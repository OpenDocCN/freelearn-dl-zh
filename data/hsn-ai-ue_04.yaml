- en: Navigation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航
- en: '*The problem behind pathfinding is as old as the Labyrinth at Knossos: how
    do I get from point A to point B using the shortest route and avoiding all obstacles
    in-between?*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*路径查找背后的问题是与克诺索斯迷宫一样古老：如何使用最短路径从点A到点B，同时避开所有中间的障碍物？*'
- en: Many algorithms have been developed to solve pathfinding problems, including
    those related to the A* algorithm, which was first introduced in computer science
    during the 1960s (section 2).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 已经开发了许多算法来解决路径查找问题，包括与A*算法相关的问题，该算法最早在20世纪60年代计算机科学中引入（第2节）。
- en: Pathfinding routines are typical components of many video games, with Non-Player
    Characters (NPCs) having the task of finding optimal paths on the game maps, which
    can constantly change. For example, passageways, gates, or doors can change their
    statuses during gameplay.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 路径查找例程是许多视频游戏的典型组件，非玩家角色（NPC）的任务是在游戏地图上找到最优路径，这些路径可以不断变化。例如，通道、门或门在游戏过程中可以改变其状态。
- en: There are quite a lot of problems when it comes to pathfinding, and unluckily
    for us, there isn't a one-solution-fits-all approach. This is because each problem
    will have its own solution, depending on the type of problem it is. Not only this,
    it will also depend on the type of game that you are developing. For example,
    is the final destination for the AI a static building (stationary), or do they
    need to jump on top of a floating raft (dynamic)? You also need to take the terrain
    into consideration – is it flat or rocky, and so on? To add an additional layer
    of complexity, we also need to consider whether there are obstacles present, as
    well as whether these objects are static (fire hydrant) or if they can be moved
    (e.g. boxes). Then, we need to think about the actual path itself. For example,
    it might be easier to travel along the road, but running across rooftops will
    get you where you need to be quicker. Following the same train of thought, the
    AI might not even have a final destination, in the sense that they don't have
    to be somewhere specific. For example, they might just wander around as someone
    who is part of a village. However, I have only highlighted a few issues and considerations
    that are related to pathfinding. As you experience different situations that use
    pathfinding, you are likely to encounter other issues. Remember to be patient
    and to consider all the variables that I have mentioned here and others that are
    specific to your situation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在路径查找方面存在许多问题，不幸的是，我们并没有一个通用的解决方案。这是因为每个问题都会有其特定的解决方案，这取决于问题的类型。不仅如此，它还取决于你正在开发的游戏类型。例如，AI的最终目的地是一个静态建筑（静止的），还是他们需要跳上漂浮的筏子（动态的）？你还需要考虑地形——它是平坦的还是多岩石的，等等？为了增加额外的复杂性，我们还需要考虑是否存在障碍物，以及这些物体是静态的（如消防栓）还是可以移动的（例如箱子）。然后，我们需要考虑实际的路径本身。例如，沿着道路旅行可能更容易，但穿越屋顶会更快地到达目的地。遵循同样的思路，AI可能甚至没有最终目的地，从某种意义上说，他们不需要去某个特定的地方。例如，他们可能只是像村庄里的人一样四处闲逛。然而，我仅仅指出了与路径查找相关的一些问题和考虑因素。随着你经历使用路径查找的不同情况，你可能会遇到其他问题。请记住要有耐心，并考虑我提到的所有变量以及其他特定于你情况的因素。
- en: Fortunately for us, Unreal has incorporated a navigation system that can be
    used for the most common of situations. As a result, we don't need to re-implement
    everything from scratch. The main goal of this chapter is to ensure that you understand
    how to use it, and ensure that you have some idea of how you can expand on it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，虚幻引擎已经集成了可以用于最常见情况的导航系统。因此，我们不需要从头开始重新实现一切。本章的主要目标是确保你了解如何使用它，并确保你对如何扩展它有一些想法。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What to expect from a ***Navigation System***
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对**导航系统**的期望
- en: The ***Unreal Navigation System***, and how it works
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚幻导航系统**及其工作原理'
- en: How to ***Generate the Navigation Mesh*** for a level, and its available settings
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何**生成导航网格**以及其可用设置
- en: 'How to ***Modify the Navigation Mesh***, by using the following:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何**修改导航网格**，以下方法：
- en: '***Navigation Areas***, to change the weight associated with a part of the
    Navigation Mesh'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航区域**，以改变与导航网格一部分相关的权重'
- en: '***Navigation Links***, to connect two parts of the Navigation Mesh that would
    otherwise be separated'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航链接**，以连接原本分开的导航网格的两部分'
- en: '***Navigation Filters***, to perform a slight change to the Navigation Mesh
    while executing a specific query on the *Navigation System*'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***导航过滤器***，在执行对*导航系统*的特定查询时对导航网格进行轻微的更改'
- en: Let's dive in!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨吧！
- en: What to expect from a Navigation System
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对导航系统有什么期望
- en: 'First of all, before we explore the ***Unreal Navigation System***, it is useful
    to define what we would expect from a generic *Navigation System*. The following
    is required from the *Navigation System*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们探索***虚幻导航系统***之前，定义一下我们对一个通用的*导航系统*的期望是有用的。以下是从*导航系统*中所需的内容：
- en: It needs to determine if a path (that can be traversed by the agent performing
    the query) exists between two generic points on the map
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要确定在地图上的两个通用点之间是否存在一条路径（可以由执行查询的代理穿越）
- en: If such a path exists, return the one that is the most convenient for the agent
    (usually the shortest)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在这样的路径，则返回对代理最方便的路径（通常是最近的路径）
- en: 'However, while searching for the best path, there are many aspects to take
    into consideration. A good navigation system should not only consider these, but
    also perform the query in a relatively short period of time. Some of these aspects
    are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在搜索最佳路径时，有许多方面需要考虑。一个好的导航系统不仅应该考虑这些方面，而且应该在相对较短的时间内执行查询。以下是一些这些方面的例子：
- en: Is the AI agent who's performing the query able to pass through a specific portion
    of the map? For instance, there might be a lake, and the AI character may or may not
    know how to swim. Similarly, can the agent crouch and move into a ventilation
    tunnel?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行查询的人工智能代理能否通过地图上的特定部分？例如，可能有一个湖，AI角色可能不知道如何游泳。同样，代理能否蹲下并进入通风隧道？
- en: 'The AI agent might want to avoid (or prefer) certain paths, which aren''t necessarily
    the shortest ones. For instance, if a building is on fire, the agent should try
    to avoid this, or risk of getting burned. As another example, let''s say there
    are two paths: one is covered from enemy fire, but it''s long, while the other
    one is short but exposed to enemy fire; which one should the AI choose? Although
    this might be part of the decision-making process, some heuristics can be implemented
    at the level of pathfinding, and a navigation system should support them.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人工智能代理可能想要避免（或偏好）某些路径，这些路径不一定是最近的。例如，如果一座建筑着火了，代理应该尽量避免这种情况，否则可能会被烧伤。作为另一个例子，假设有两条路径：一条被敌人的火力覆盖，但路程较长，而另一条路程较短但暴露在敌人的火力下；AI应该选择哪一条？虽然这可能是决策过程的一部分，但在路径查找的层面上可以实施一些启发式方法，并且导航系统应该支持它们。
- en: A map might be dynamic, which means that obstacles, objects, roads, cliffs,
    and so on, change during gameplay. Is the navigation system able to handle these
    changes in real time while they happen, and correct the generated paths?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地图可能是动态的，这意味着障碍物、物体、道路、悬崖等在游戏过程中会发生变化。导航系统能否在实时处理这些变化的同时，并纠正生成的路径？
- en: Now, it's time to see how Unreal implements all of these features.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候看看虚幻是如何实现所有这些功能的了。
- en: Unreal Navigation System
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚幻导航系统
- en: The Unreal navigation system is based on a ***Navigation Mesh*** (***Nav Mesh***
    for short). It entails dividing the navigable space into areas – in this case,
    polygons – which are subdivided into triangles for efficiency. Then, to reach
    a certain place, each triangle is considered a node of a graph, and if two triangles
    are adjacent, then their respective nodes are connected. On this graph, you can
    execute a pathfinding algorithm, such as A* with a Euclidean distance heuristic,
    or even something more complicated (e.g. variants of A* or systems that take into
    consideration different costs). This will produce a path among these triangles
    where the AI character can walk.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻导航系统基于一个***导航网格***（简称***Nav Mesh***）。它包括将可导航空间划分为区域——在这种情况下，多边形——这些区域被细分为三角形以提高效率。然后，为了到达某个地方，每个三角形被视为图中的一个节点，如果两个三角形相邻，则它们的相应节点相连。在这个图上，你可以执行路径查找算法，如带有欧几里得距离启发式的A*算法，甚至更复杂的算法（例如A*的变体或考虑不同成本的系统）。这将在这几个三角形之间产生一条路径，AI角色可以行走。
- en: In reality, this process is a little bit more complicated, because considering
    all the triangles as nodes of a giant graph will produce a good result, but it
    is inefficient, especially since we have access to the information that's stored
    in the polygons and how these are connected. Moreover, you might need extra information
    about specific triangles, which might have different costs, different abilities required
    to traverse them, etc… However, unless you need to change the underlying structure
    of the *Navigation System*, you don't need to work/operate at this level of detail.
    Being able to understand that all of the triangles form a graph in some way, in
    which pathfinding algorithms can run, is more than sufficient to master the tool
    itself.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实中，这个过程要复杂一些，因为将所有三角形视为一个巨大图的网络节点会产生一个好的结果，但这是低效的，尤其是当我们能够访问存储在多边形中的信息以及这些多边形是如何连接的时候。此外，你可能还需要关于特定三角形的一些额外信息，这些三角形可能具有不同的成本、穿越它们所需的不同能力等。然而，除非你需要改变*导航系统*的底层结构，否则你不需要在这个细节级别上进行工作/操作。能够理解所有三角形以某种方式形成一个图，路径查找算法可以在其中运行，就足以掌握这个工具本身。
- en: 'To be able to use the *Navigation System*, let''s understand the main process
    of setting up the navigation system. At this stage, we will no longer worry about
    how the system is structured underneath, but rather how we can use all of its
    features. The system will do the rest. In the same way, we need to provide information
    about the map to the navigation system (e.g. specify special areas). Usually,
    it''s the AI programmer in your team who takes care of this, but if your team
    is small, a level designer might take care of this task. Although there is not
    a specific process, but, rather an iterative procedure, let''s explore the different
    steps – or tools, if you prefer – that you can use to define the *Nav Mesh* in
    Unreal. We will examine them in detail throughout this chapter:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够使用*导航系统*，让我们了解设置导航系统的主过程。在这个阶段，我们不再担心系统是如何构建的，而是如何使用其所有功能。系统会完成剩下的工作。同样，我们需要向导航系统提供有关地图的信息（例如，指定特殊区域）。通常，这是你的团队中的AI程序员负责这项工作，但如果你的团队规模较小，关卡设计师可能会负责这项任务。尽管没有特定的流程，而是一个迭代过程，但让我们探索你可以用来在Unreal中定义*导航网格*的不同步骤——或者如果你更喜欢，工具。我们将在本章中详细检查它们。
- en: '**Generation of the Navigation Mesh**: This is the first step. Before you''ll
    be able to use the following tools, it is important to start generating a *Nav
    Mesh*. This step includes defining how to generate the polygons, the triangles,
    the precision of the *Nav Mesh*, and even which kind of agents will traverse this
    specific *Nav Mesh*.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航网格的生成**：这是第一步。在你能够使用以下工具之前，生成一个*导航网格*非常重要。这一步骤包括定义如何生成多边形、三角形、*导航网格*的精度，甚至确定哪些类型的代理将穿越这个特定的*导航网格*。'
- en: '**Navigation Mesh Modifiers**: Not all the parts of the *Nav Mesh* are created
    equal, and this is a tool to specify which parts of the *Nav Mesh* should behave
    differently. In fact, as we have seen before, there might be a zone with poisoned
    gas, and the agent would like to avoid this part, unless they really have to traverse
    it. The Nav Mesh Modifier allows you to specify that the area containing the gas
    is special. However, the type of behavior within the area (e.g. this path should
    not be traversed, or should only be traversed by agents with swimming abilities)
    is specified within a Nav Area.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航网格修改器**：*导航网格*的各个部分并不都是相同的，这是一个工具，用于指定*导航网格*的哪些部分应该有不同的行为。实际上，正如我们之前所看到的，可能有一个含有毒气体的区域，代理会希望避开这部分，除非他们真的不得不穿越它。导航网格修改器允许你指定包含气体的区域是特殊的。然而，区域内的行为类型（例如，这条路径不应该穿越，或者只有具有游泳能力的代理才能穿越）是在导航区域内指定的。'
- en: '**Navigation Areas**: This allows you to specify how a specific type of area
    should behave, whether it should be avoided, etc. These are key when performing
    *Nav Filtering* to determine which areas the agent can traverse.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航区域**：这允许你指定特定类型的区域应该如何行为，是否应该避开等。在执行*导航过滤*以确定代理可以穿越哪些区域时，这些信息是关键的。'
- en: '**Navigation Links**: These can connect two different parts of the *Nav Mesh*.
    Suppose you have a platform ledge. By default, the AI agent will find another
    way. If you have in mind the Third Person map template, the agent that needs to
    get down from platform will go around the area to use the stairs, rather than
    just falling/jumping off the platform. A ***Nav Link*** allows you to connect
    the part of the *Nav Mesh* that''s on top of the platform with the part below
    it. As a result, the agent will be able to fall off the platform. However, note
    that ***Nav Links*** can connect two generic portions of the *Nav Mesh*, thus
    allowing pathfinding to find its way through jumps, teleports, etc.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航链接**：这些可以连接*导航网格*的两个不同部分。假设你有一个平台边缘。默认情况下，AI代理会找到另一条路。如果你考虑的是第三人称地图模板，需要从平台上下来的代理会绕过该区域使用楼梯，而不是直接从平台上掉落/跳跃。一个***导航链接***允许你连接平台上的*导航网格*部分与下面的部分。结果，代理将能够从平台上掉落。然而，请注意，***导航链接***可以连接*导航网格*的两个通用部分，从而允许路径查找通过跳跃、传送等方式找到路径。'
- en: '**Nav Filtering**: We don''t necessarily want to find a path in the same way
    on every occasion. ***Nav Filtering*** allows us to define specific rules on how
    to perform the pathfind for that specific instance (for that specific time that
    the pathfind is invoked to seek a path).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航过滤**：我们并不一定希望每次都以相同的方式找到路径。***导航过滤***允许我们定义针对特定实例（在路径查找被调用以寻找路径的特定时间）如何执行路径查找的特定规则。'
- en: Let's break these points down and talk about them in more detail.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一分析这些点，并更详细地讨论它们。
- en: Generating the Navigation Mesh
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成导航网格
- en: 'Generating a simple *Navigation Mesh* is pretty straightforward in Unreal.
    Let''s look at how we can do it. From the ***Mode*** panel, in the ***Volume***
    tab, you will be able to find the **Nav Mesh Bounds Volume**, as shown in the
    following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中生成简单的*导航网格*相当直接。让我们看看我们如何能完成它。从***模式***面板，在***体积***选项卡中，你可以找到**导航网格边界体积**，如下截图所示：
- en: '![](img/c95dcf12-7fb9-4646-910e-f8caffee10e6.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c95dcf12-7fb9-4646-910e-f8caffee10e6.png)'
- en: Drag it into the world. You will notice that the volume is quite small in respect
    to the map. Everything inside that volume will be taken into consideration to
    generate a *Nav Mesh*. Of course, a *Nav Mesh* has many parameters, but for now
    let's keep thing simple.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将其拖入世界。你会注意到与地图相比，体积相当小。该体积内的所有内容都将被考虑以生成*导航网格*。当然，*导航网格*有许多参数，但为了简单起见，我们现在保持简单。
- en: 'If you press the *P* button on your keyboard, you will be able to see the *Nav
    Mesh* in the *Viewport*, as shown in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按下键盘上的*P*按钮，你将能够在*视口*中看到*导航网格*，如下截图所示：
- en: '![](img/7bda5f63-d4ba-4669-880e-571872b8f2f7.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7bda5f63-d4ba-4669-880e-571872b8f2f7.png)'
- en: 'As you can see, it is limited to the area that''s contained in the volume of
    ***Nav Mesh Bounds Volume***. Let''s scale the ***Nav Mesh Bounds Volume*** to
    fit all the level we have. This is what your level should look like:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它限制在***导航网格边界体积***所包含的区域。让我们调整***导航网格边界体积***以适应我们拥有的所有关卡。你的关卡应该看起来像这样：
- en: '![](img/9a05c6e9-be72-4247-8f7f-3a7faba6bc5b.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a05c6e9-be72-4247-8f7f-3a7faba6bc5b.png)'
- en: Did you notice how, while you were scaling your volume, the *Nav Mesh* was updating
    automatically? This is because, in Unreal, the *Nav Mesh* is generated every time
    something that impacts the *Nav Mesh* moves.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到当你调整体积时，*导航网格*会自动更新吗？这是因为，在虚幻引擎中，每次影响*导航网格*的任何东西移动时，都会生成*导航网格*。
- en: 'While updating, the part of the *Nav Mesh* that''s affected (that is, updated)
    should turn red, as shown in the following screenshot:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新过程中，受影响的*导航网格*部分（即更新的部分）应变为红色，如下截图所示：
- en: '![](img/4fb77e20-0694-4e05-be87-ef51c87721e3.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4fb77e20-0694-4e05-be87-ef51c87721e3.png)'
- en: This is how easy is to generate a *Nav Mesh*. However, to be able to master
    the tool, we need to learn more about how to refine the *Nav Mesh* and how it
    is used by the AI.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是生成*导航网格*有多简单。然而，为了能够掌握这个工具，我们需要了解更多关于如何细化*导航网格*以及它是如何被AI使用的。
- en: Setting parameters for the Nav Mesh
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为导航网格设置参数
- en: If you click on the ***Nav Mesh Bounds Volume***, you will notice that there
    are no options for the generation of the *Nav Mesh*. In fact, some parameters
    are at the project level, while others are at the map level.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击***导航网格边界体积***，你会注意到没有生成*导航网格*的选项。事实上，一些参数是在项目级别，而另一些是在地图级别。
- en: 'Let''s navigate to the ***World Outliner***, where you will find that a ***RecastNavMesh-Default***
    actor has been placed in the scene, as shown in the following screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们导航到**世界轮廓图**，在那里你会发现场景中已经放置了一个**RecastNavMesh-Default**演员，如下面的截图所示：
- en: '![](img/6a7aa75c-89fb-4011-ab5d-b79e3d098f91.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/6a7aa75c-89fb-4011-ab5d-b79e3d098f91.png)'
- en: In fact, when you drag a ***Nav Mesh Bounds Volume***, if the map doesn't have
    a ***RecastNavMesh-Default***, one will be created. If we click on it, we will
    be able to change all of its properties in the ***Details Panel***.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当你拖动**导航网格边界体积**时，如果地图中没有**RecastNavMesh-Default**，则会创建一个。如果我们点击它，我们将在**详细信息面板**中能够更改其所有属性。
- en: As you can see, there are a lot of default values. These can be changed in the
    *Project Settings* (under the *Navigation Mesh* tab). Let's break down every section,
    and try to grasp the main concepts around them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，有很多默认值。这些可以在**项目设置**（在**导航网格**选项卡下）中更改。让我们逐个分析每个部分，并尝试掌握它们的主要概念。
- en: Display settings
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示设置
- en: 'As the name suggests, these are settings that are related on how we can visualize
    the *Nav Mesh* that we have generated in detail. In particular, we will be able
    to see the generated Polygons, the triangles, and how the polygons are connected. We
    will go through these in more detail in [Chapter 12](a60155c1-2bb0-403f-bdcf-dbd6a9c67824.xhtml)*,
    Debugging Methods for AI - Navigation, EQS, and Profiling*, when we will talk
    about debugging tools:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，这些是与如何详细可视化我们生成的**导航网格**相关的设置。特别是，我们将能够看到生成的多边形、三角形以及多边形是如何连接的。我们将在[第12章](a60155c1-2bb0-403f-bdcf-dbd6a9c67824.xhtml)*，AI调试方法
    - 导航、EQS和性能分析*中更详细地介绍这些内容，届时我们将讨论调试工具：
- en: '![](img/d306b851-9c15-49ac-91b8-d7d845857233.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/d306b851-9c15-49ac-91b8-d7d845857233.png)'
- en: Generation settings
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成设置
- en: 'These settings concern the generation of the *Nav Mesh*. Usually, the default
    values are more than perfect to start with, and so you should only touch these
    values if you know what you are doing. The following screenshot shows these settings:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置涉及**导航网格**的生成。通常，默认值已经足够好，可以开始使用，因此只有在你了解自己在做什么的情况下才应该更改这些值。以下截图显示了这些设置：
- en: '![](img/7b4fde45-cb3b-465a-a1f0-6f15cbc1b1d1.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/7b4fde45-cb3b-465a-a1f0-6f15cbc1b1d1.png)'
- en: 'The best way to learn about these settings is by playing with their parameters,
    first in an example map, then in your own maps. After that, you need to check
    the results of doing this (especially with the visual debugging tools that are
    presented in [Chapter 12](a60155c1-2bb0-403f-bdcf-dbd6a9c67824.xhtml), *Debugging
    Methods for AI - Navigation, EQS, and Profiling*). To get you started, let''s
    look at the main ones:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些设置的最好方法是调整它们的参数，首先在一个示例地图中，然后在自己的地图中进行。之后，你需要检查这样做的结果（特别是[第12章](a60155c1-2bb0-403f-bdcf-dbd6a9c67824.xhtml)中介绍的视觉调试工具，*AI调试方法
    - 导航、EQS和性能分析*）。为了帮助你入门，让我们看看主要的设置：
- en: '**Tile Size UU**: This parameter defines how fine the polygons that are generated
    are. Lower values mean a more precise navigation mesh, with more polygons, but
    also a slower generation time (and potentially more memory usage). You can see
    the effect of this parameter by turning on the **Draw Triangle Edges** in the
    display settings that are shown in the preceding screenshot.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**瓦片大小UU**：此参数定义了生成的多边形的精细程度。较低的值意味着更精确的导航网格，具有更多的多边形，但生成时间会更长（并且可能使用更多的内存）。你可以通过在显示设置中打开**绘制三角形边缘**来查看此参数的效果，如前一个截图所示。'
- en: '**Cell Height**: This determines how high the generated cells are from the
    floor (which might result in connecting areas at a different height, so be careful).'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元格高度**：这决定了生成的单元格从地板的高度（这可能会导致连接不同高度的区域，所以请小心）。'
- en: '*Agent settings* (**Radius**, **Height**, **Max Height**, **Max Slope**, **Max
    Step Height**): These settings are specific to your agents and should be specified
    appropriately. In particular, these are the minimum values an agent should have
    to traverse this *Nav Mesh*. As a result, the *Nav Mesh* will not be able to navigate
    with agents with smaller values than this, because the *Nav Mesh* is generated
    only for agents with these requirements. These settings are useful to generate
    an appropriate *Nav Mesh* for your agents, without wasting resources on a *Nav
    Mesh* with areas that your agents will never be able to navigate.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代理设置*（**半径**、**高度**、**最大高度**、**最大坡度**、**最大步高**）：这些设置针对您的代理，应适当指定。特别是，这些是代理穿越此*Nav
    Mesh*所需的最小值。因此，*Nav Mesh*将无法导航具有比这些值更小值的代理，因为*Nav Mesh*只为满足这些要求的代理生成。这些设置有助于为您的代理生成适当的*Nav
    Mesh*，而不会在代理永远无法导航的区域浪费资源。'
- en: '**Min Region Area**: This gets rid of certain artifacts of the *Nav Mesh Generation* that
    are too insignificant to navigate.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小区域面积**：这消除了*Nav Mesh生成*中的一些过于微不足道的瑕疵。'
- en: Many of the remaining settings are about optimization, and they can be overwhelming,
    especially for newcomers in AI Programming. Therefore, I decided to not include
    these details in this book. However, once you are confident about using the Navigation
    System, you can check the tool-tips of these settings and experiment with them
    so that you can learn about what they do.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 许多剩余的设置都是关于优化的，它们可能会让人感到不知所措，尤其是对于AI编程的新手来说。因此，我决定不将这些细节包含在本书中。然而，一旦您对使用导航系统有信心，您就可以检查这些设置的提示，并尝试它们，以便了解它们的作用。
- en: Project Settings
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: 'It is worthwhile mentioning, even if we don''t go through them in details,
    that same *Navigation* settings can be changed from the ***Project Settings***;
    there is a specific tab for that, as shown in the following picture:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，即使我们不详细讨论，相同的*导航*设置也可以从***项目设置***中更改；有一个专门的选项卡，如下图所示：
- en: '![](img/4ad635c0-048f-4e67-bec9-00bb4eabfd58.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4ad635c0-048f-4e67-bec9-00bb4eabfd58.png)'
- en: 'Interesting to notice is the last tab about *Agents*. Here it is possible to
    create an *Array* of ***Supported Agents***, so that different agents can have
    different ways to navigate the *Nav Mesh*. For instance, a mouse might have a
    very different *Navigation Mesh* than a Giant Troll. In fact the mouse can also
    go in small holes, whereas the Troll can''t. Here you will be able to specify
    all the different kinds of agents you have:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，最后一个选项卡是关于*代理*的。在这里，您可以创建一个***支持代理数组***，以便不同的代理可以以不同的方式在*Nav Mesh*中导航。例如，鼠标可能有一个与巨魔非常不同的*导航网格*。事实上，鼠标还可以进入小洞，而巨魔则不能。在这里，您将能够指定您拥有的所有不同类型的代理：
- en: '![](img/a66abba0-becf-4f70-9023-e4b8a90d4c55.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a66abba0-becf-4f70-9023-e4b8a90d4c55.png)'
- en: You cannot assign directly which kind of *agents* your character will follow,
    but, based on the *Character Movement Component* (or *Movement Components* in
    general), a kind of agent is assigned to the *Character/AI Agent*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能直接指定角色将跟随哪种类型的*代理*，但基于*角色移动组件*（或一般意义上的*移动组件*），会将一种代理分配给*角色/AI代理*。
- en: Settings on the Character Movement Component
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色移动组件上的设置
- en: As we have seen from the previous section, the agents, which are its abilities,
    its shape, etc... influence a lot how it navigates the *Nav Mesh*. You will be
    able to find all of these settings on the *Character Movement Component*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所述，代理的能力、形状等对其在*Nav Mesh*中的导航有很大影响。您可以在*角色移动组件*中找到所有这些设置。
- en: However, this component is outside the scope of this book, and we will not see
    it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个组件超出了本书的范围，我们不会看到它。
- en: Modifying the Navigation Mesh
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改导航网格
- en: So far, we have seen how is it possible to generate a Navigation Mesh. However,
    we would like to modify this so that it suits our needs better. As we mentioned
    previously, there might be different areas that can be costly to traverse, or
    there might be a connection between two points of the *Nav Mesh* that seem to
    be separated (e.g. by a ledge).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何生成导航网格。然而，我们希望对其进行修改，使其更好地满足我们的需求。正如我们之前提到的，可能会有一些区域穿越成本较高，或者*Nav
    Mesh*中两个点之间的连接似乎被隔开（例如，由悬崖隔开）。
- en: As a result, this section explores the different tools that Unreal has to modify
    the *Nav Mesh* so that it can be adapted to the level.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本节探讨了Unreal中用于修改*Nav Mesh*的不同工具，以便它可以适应关卡。
- en: Nav Modifier Volume
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nav Modifier Volume
- en: Alright – it's time to look at how we can start modifying the *Nav Mesh*. For
    instance, there might be a part of the *Nav Mesh* that we don't want to be crossable,
    or another section that we want to have different properties. We can do this by
    using a ***Nav Modifier Volume***.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 好的——现在是时候看看我们如何开始修改 *Nav Mesh* 了。例如，可能有一些我们不希望 AI 可以穿越的 *Nav Mesh* 部分，或者我们希望另一部分具有不同的属性。我们可以通过使用
    ***Nav Modifier Volume*** 来实现这一点。
- en: 'You can find this setting by going to the *Mode* panel, under the *Volumes*
    tab, and then by going to the *Nav Mesh Bounds Volume*:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过转到 *Mode* 面板，在 *Volumes* 选项卡下，然后转到 *Nav Mesh Bounds Volume* 来找到此设置：
- en: '![](img/1db935b4-77c7-4a20-a9d5-3f5df34c14d9.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1db935b4-77c7-4a20-a9d5-3f5df34c14d9.png)'
- en: 'Once this volume has been placed in the map, the default value is to remove
    the part of the ***Nav Mesh*** within the volume, as shown in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个体积被放置到地图中，默认值是移除体积内的 ***Nav Mesh*** 部分，如下面的截图所示：
- en: '![](img/5dbdb0f1-7a72-4f6b-ad6c-ab68a8627daa.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5dbdb0f1-7a72-4f6b-ad6c-ab68a8627daa.png)'
- en: 'This is useful when you have areas that you don''t want your AI to go in, or
    fix up artifacts of your navigation mesh. Although the ***Nav Modifier Volume***
    specifies a part of the map, the behavior is specified in the ***Nav Mesh Areas***.
    This means that, if we look at the settings of the ***Nav Mesh Modifier Volume***,
    we can find only one related to the *Navigation*, named ***Area Class***:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有不想让 AI 进入的区域，或者修复导航网格的瑕疵时，这很有用。尽管 ***Nav Modifier Volume*** 指定了地图的一部分，但其行为是在
    ***Nav Mesh Areas*** 中指定的。这意味着，如果我们查看 ***Nav Mesh Modifier Volume*** 的设置，我们只能找到一个与
    *Navigation* 相关的设置，名为 ***Area Class***：
- en: '![](img/cf02f114-879b-4d7f-92ee-9cc5185b4e2a.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cf02f114-879b-4d7f-92ee-9cc5185b4e2a.png)'
- en: As a result, this volume can only specify a portion of the map in which a specific
    ***Area Class*** is applied. By default, the ***Area Class*** is ***NavArea_Null***,
    which "*removes*" the *Nav Mesh* in that portion of the map that's overlapping
    this volume. We'll explore how ***Nav Mesh Areas*** work in the next section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本卷只能指定应用了特定 ***区域类别*** 的地图的一部分。默认情况下，***区域类别*** 是 ***NavArea_Null***，它将地图中与该体积重叠的部分的
    *Nav Mesh* “移除”。我们将在下一节中探讨 ***Nav Mesh Areas*** 的工作原理。
- en: Nav Mesh Areas
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nav Mesh Areas
- en: In the previous section, we talked about how not all parts of the navigable
    area of the map are created equal. If there is a zone that it is considered dangerous,
    the AI should avoid it. Unreal's built-in navigation system is able to handle
    these different areas by using costs. This means that the AI will evaluate the
    path to take by summing all the costs along the path, and it will select the one
    with the minimal cost.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了地图的可导航区域并非所有部分都同等重要。如果有一个被认为是危险区域的区域，AI 应该避开它。虚幻引擎内置的导航系统能够通过使用成本来处理这些不同的区域。这意味着
    AI 将通过计算路径上的所有成本来评估要采取的路径，并选择成本最低的那条路径。
- en: Also, it is worth specifying that there are two types of costs. For each area,
    there is an initial cost for entering (or leaving) the area and a cost for traversing
    the area. Let's look at a couple of examples to clarify the difference between
    the two.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还值得指出的是，存在两种类型的成本。对于每个区域，都有一个进入（或离开）区域的基本成本和穿越区域的成本。让我们通过几个例子来澄清这两种成本之间的区别。
- en: Imagine that there is a forest, but at each entrance of the forest, the AI needs
    to pay a toll to the indigenous living in the forest. However, once inside, the
    AI can move freely, as if they were outside the forest. In this case, entering
    the forest has a cost, but once inside, there is no cost to pay. As a result,
    when the AI needs to evaluate whether to traverse the forest or not, it depends
    on whether there is another way to go and how long it would take them to do so.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下有一个森林，但在森林的每个入口处，AI 都需要向森林中的土著居民支付通行费。然而，一旦进入森林，AI 可以自由移动，就像他们在外面一样。在这种情况下，进入森林有成本，但一旦进入，就没有成本需要支付。因此，当
    AI 需要评估是否穿越森林时，这取决于是否有其他路线以及他们这样做需要多长时间。
- en: Now, imagine that there is an area with poison gas instead. In this second scenario,
    the cost for entering the area might be zero, but the cost for traversing it is
    high. In fact, the longer the AI stays in the area, the more health it loses.
    Whether it is worth entering or not only depends on whether there is an alternative
    way and how long that alternative way will take to traverse (like in the previous
    case), but also how long, once entered, the AI needs to traverse the area.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下有一个区域充满了毒气。在这个第二种情况下，进入该区域的成本可能是零，但穿越该区域的成本很高。事实上，AI 在该区域停留的时间越长，它的健康值损失就越多。是否值得进入不仅取决于是否有替代路线以及穿越替代路线需要多长时间（就像在先前的例子中那样），还取决于一旦进入，AI
    需要穿越该区域多长时间。
- en: 'In Unreal, costs are specified inside the class. If you click on a ***Nav Modifier
    Volume***, you will notice that you need to specify an ***Area Class***, as shown
    in the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unreal 中，成本是在类中指定的。如果你点击一个 ***Nav Modifier Volume***，你会注意到你需要指定一个 ***Area
    Class***，如下面的截图所示：
- en: '![](img/e2ce11a2-a705-48ff-a8da-fce7169816dd.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e2ce11a2-a705-48ff-a8da-fce7169816dd.png)'
- en: As you may have guessed, the default value is ***NavArea_Null***, which has
    an infinite cost for entering, resulting in the AI never going into that area.
    The Navigation system is smart enough to not even bother generating that area,
    and treats it as a non-navigable area.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，默认值是 ***NavArea_Null***，进入该区域的成本是无限的，导致 AI 从不进入该区域。导航系统足够智能，甚至不会生成该区域，将其视为不可导航区域。
- en: 'However, you can change the ***Area Class***. By default, you will be able
    to access the following *Area Classes*:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以更改 ***Area 类***。默认情况下，你将能够访问以下 *Area Classes*：
- en: '***NavArea_Default***: This is the default area that is generated. It is useful
    to have it as a modifier in case you want to have more than one of these modifiers
    in the same spot.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***NavArea_Default***：这是默认生成的区域。如果你想在同一个位置有多个这些修饰符，那么它很有用。'
- en: '**NavArea_LowHeight**: This indicates that the area is not suitable for every
    agent, since the height is reduced (for example, in the case of a ventilation
    tunnel, not all the agents can fit/crouch).'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NavArea_LowHeight**：这表明该区域不适合所有代理，因为高度降低了（例如，在通风隧道的情况下，并非所有代理都能适应/蹲下）。'
- en: '**NavArea_Null**: This makes the area non-navigable for all the agents.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NavArea_Null**：这使得该区域对所有代理都不可导航。'
- en: '**NavArea_Obstacle**: This assigns a higher cost to the area, so the agent
    will want to avoid it:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NavArea_Obstacle**：这会给区域分配更高的成本，因此代理会想要避开它：'
- en: '![](img/7e2b287f-260f-4a69-972f-f53b0a1be631.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e2b287f-260f-4a69-972f-f53b0a1be631.png)'
- en: You will notice that if you create a new Blueprint, or even when you open the
    source code in Visual Studio, there will be **NavArea_Meta** and a child of it,
    **NavArea_MetaSwitchingActor**. However, if you look at their code, they mainly
    have some deprecated code. Therefore, we won't be using them in this book.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，如果你创建一个新的蓝图，或者甚至当你在 Visual Studio 中打开源代码时，都会有一个 **NavArea_Meta** 以及它的一个子项，**NavArea_MetaSwitchingActor**。然而，如果你查看它们的代码，它们主要有一些过时的代码。因此，我们在这本书中不会使用它们。
- en: However, you can extend the list of the different areas (and potentially add
    more functionalities) by extending the ***NavArea Class***. Let's see how we can
    do this, both in Blueprint and C++. Of course, as we did in the previous chapter,
    we are going to create a new folder named *Chapter3/Navigation*, in which we will
    place all our code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以通过扩展 ***NavArea 类*** 来扩展不同区域列表（并且可能添加更多功能）。让我们看看我们如何在蓝图和 C++ 中做到这一点。当然，就像我们在上一章中做的那样，我们将创建一个名为
    *Chapter3/Navigation* 的新文件夹，我们将把所有的代码放在这个文件夹中。
- en: Creating a NavArea class in Blueprint
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在蓝图中创建 NavArea 类
- en: 'Creating a new ***NavArea*** class in blueprint is quite straightforward; you
    just need to create a new Blueprint that inherits from the ***NavArea*** class,
    as shown in the following screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图中创建一个新的 ***NavArea*** 类相当简单；你只需要创建一个新的蓝图，它继承自 ***NavArea*** 类，如下面的截图所示：
- en: '![](img/a3907d95-e2b5-4284-8d11-238ff812a44c.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a3907d95-e2b5-4284-8d11-238ff812a44c.png)'
- en: 'By convention, the name of the class should start with "*NavArea_*". We will
    rename it to ***NavArea_BPJungle*** here (I added BP to signify that we have created
    this with Blueprint, since we are repeating the same task both in Blueprint and
    in C++). This is what it should look like in the *Content Browser*:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，类的名称应该以 "*NavArea_" 开头。在这里我们将将其重命名为 ***NavArea_BPJungle***（我添加了 BP 来表示我们是用蓝图创建的，因为我们同时在蓝图和
    C++ 中重复执行相同的任务）。这是它在 *内容浏览器* 中的样子：
- en: '![](img/9b2e7914-a6c9-464b-8dc8-3e0f4921f9cc.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b2e7914-a6c9-464b-8dc8-3e0f4921f9cc.png)'
- en: 'Then, if you open the blueprint, you will be able to assign the custom costs
    to the area. You can also specify a specific color for your area so that it is
    easy to recognize when you build your *Nav Mesh*. This is what the *Details* panel
    looks like by default:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果你打开蓝图，你将能够为该区域分配自定义成本。你还可以为你的区域指定一个特定的颜色，以便在构建*导航网格*时易于识别。这是默认情况下*详细信息*面板的外观：
- en: '![](img/20aef577-b969-498d-b42d-6a5c75c5b16a.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20aef577-b969-498d-b42d-6a5c75c5b16a.png)'
- en: 'Now, we can customize as per our needs. For example, we might want to have
    a cost to enter the *Jungle*, and a slightly higher cost to traverse it. We are
    going to use a bright green for the color, as shown in the following screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以根据我们的需求进行自定义。例如，我们可能想要为进入*丛林*设置一个成本，并且穿越它时设置一个略高的成本。我们将使用明亮的绿色作为颜色，如下面的截图所示：
- en: '![](img/6e241764-a571-49aa-90d8-873e5d59d480.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e241764-a571-49aa-90d8-873e5d59d480.png)'
- en: 'Once compiled and saved, we can assign this newly created area to the ***Nav
    Modifier Volume***, as shown in the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并保存后，我们可以将这个新创建的区域分配给***Nav Modifier Volume***，如下面的截图所示：
- en: '![](img/fe05e7eb-2bbd-4282-a6c3-ee63a9ffca6a.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe05e7eb-2bbd-4282-a6c3-ee63a9ffca6a.png)'
- en: 'This is what our finished class looks like in our level (if the *Navigation
    Mesh* is visible):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们级别中完成后的类的外观（如果*导航网格*可见）：
- en: '![](img/e9eeedb0-3cd3-4091-aa80-8b852d08869a.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9eeedb0-3cd3-4091-aa80-8b852d08869a.png)'
- en: Creating a NavArea class in C++
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++中创建NavArea类
- en: 'It''s easy to create a ***NavArea*** class in C++ as well. First of all, you
    need to create a new C++ class that inherits from the ***NavArea*** class, as
    shown in the following screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中创建一个***NavArea***类同样简单。首先，你需要创建一个新的C++类，该类从***NavArea***类继承，如下面的截图所示：
- en: '![](img/08e5efd9-ba54-4a2d-b17f-ed75f2d2b4ba.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08e5efd9-ba54-4a2d-b17f-ed75f2d2b4ba.png)'
- en: 'By convention, the name should start with "*NavArea_*". Therefore, you can
    rename it ***NavArea_Desert*** (just to vary which kind of terrain the AI can
    face, since we created a *Jungle* previously) and place it in "***Chapter3/Navigation***":'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，名称应该以"*NavArea_*"开头。因此，你可以将其重命名为***NavArea_Desert***（只是为了改变AI可能遇到的哪种地形，因为我们之前创建了一个*丛林*），并将其放置在"***Chapter3/Navigation***"：
- en: '![](img/60f44b62-465c-4eb7-a887-6aff0a644ad7.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60f44b62-465c-4eb7-a887-6aff0a644ad7.png)'
- en: 'Once you have created the class, you just need to assign the parameters in
    the constructor. For your convenience, here is the class definition in which we
    declare a simple constructor:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了类，你只需要在构造函数中分配参数。为了方便起见，以下是类定义，其中我们声明了一个简单的构造函数：
- en: '[PRE0]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, in the implementation of the constructor, we can assign the different
    parameters. For instance, we can have a high cost for entering and a higher cost
    for traversing (with respect to the *Default* or the *Jungle*). Furthermore, we
    can set the color to *Yellow* so that we remember that it is a desert area:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在构造函数的实现中，我们可以分配不同的参数。例如，我们可以为进入设置一个高成本，为穿越设置一个更高的成本（相对于*默认*或*丛林*）。此外，我们可以将颜色设置为*黄色*，以便我们记住这是一个沙漠区域：
- en: '[PRE1]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can always play with these values to see which one works best for you. For
    instance, you can create an area with a very high entering cost, but a low traversal
    cost. As a result, you will have an area that, should be avoided if it's only
    going to be traversed for a little while, but if the agent traverses it for a
    long period of time, it might be more convenient than the shorter route.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随时调整这些值以查看哪个最适合你。例如，你可以创建一个进入成本非常高但穿越成本很低的区域。结果，如果只穿越一小段时间，该区域应该被避免，但如果代理穿越它的时间较长，它可能比较短路线更方便。
- en: 'Once you have created the class, you can set it as part of the ***Nav Modifier
    Volume***, as shown in the following screenshot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了类，你可以将其设置为***Nav Modifier Volume***的一部分，如下面的截图所示：
- en: '![](img/73745221-a2e8-420a-8710-ef9639376624.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73745221-a2e8-420a-8710-ef9639376624.png)'
- en: As a result, you will be able to see your custom area in the *Nav Mesh* (in
    this case, with a *Yellow Color*)*:*
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你将能够在*导航网格*（在这种情况下，带有*黄色*）中看到你的自定义区域：*
- en: '![](img/8ff546d2-ffcc-419a-8a9a-47b27a3bab00.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ff546d2-ffcc-419a-8a9a-47b27a3bab00.png)'
- en: Nav Link Proxy
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航链接代理
- en: By default, if there is a ledge, the AI will not fall through it, even if it
    would be the shortest path they could take to get to their destination. In fact,
    the *Nav Mesh* on top of the ledge is not (directly) connected with the *Nav Mesh*
    at the bottom. However, the *Unreal Navigation System* provides a way to connect
    two arbitrary triangles in the *Nav Mesh* through what is called a ***Nav Link
    Proxy***.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果有一个悬崖，AI不会从悬崖上掉下去，即使这是它们到达目的地的最短路径。实际上，悬崖上的“*导航网格*”并没有（直接）与底部的“*导航网格*”连接。然而，“**虚幻导航系统**”提供了一种通过所谓的“**导航链接代理**”连接“*导航网格*”中任意两个三角形的方法。
- en: Although the regions are connected, and the pathfinder will find the correct
    road, the AI cannot go against the rules of the game, both in terms of physics
    or game mechanics. This means that if the AI is unable to jump or traverse a magic
    wall, the character will get stuck since the pathfinder returned a path, but the
    character cannot execute it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管区域是连接的，路径查找器也会找到正确的道路，但AI不能违反游戏规则，无论是物理规则还是游戏机制。这意味着如果AI无法跳跃或穿越魔法墙，角色会卡住，因为路径查找器返回了一条路径，但角色无法执行它。
- en: Let's explore this tool in more detail.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探索这个工具。
- en: Creating a Nav Link Proxy
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建导航链接代理
- en: 'To connect two regions with a link, we need to go to the ***Mode*** panel in
    the ***All Classes*** tab and select ***Nav Link Proxy***, as shown in the following
    screenshot:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过链接连接两个区域，我们需要进入“**模式**”面板，在“**所有类**”选项卡中并选择“**导航链接代理**”，如图所示：
- en: '![](img/7efd30e8-18cf-4e84-aa25-cfb16f3c32fe.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/7efd30e8-18cf-4e84-aa25-cfb16f3c32fe.png)'
- en: 'Alternatively, you can search for it in the *Modes* panel to find it more quickly:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在“**模式**”面板中搜索它以更快地找到它：
- en: '![](img/8b88cd2f-5954-461f-989d-b6236f2a911f.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/8b88cd2f-5954-461f-989d-b6236f2a911f.png)'
- en: 'Once the link has been placed in the level, you will see an "*arrow/link*",
    and you will be able to modify the start and end points of the link. They are
    called ***Left*** and ***Right***, and the easiest way to set their location is
    by dragging (and placing) them in the *Viewport*. As a result, you will be able
    to connect two different parts of the *Nav Mesh*. As we can see in the following
    screenshot, if the *Nav Mesh* is visible (enabled with the *P* key), you will
    see an arrow connecting the ***Right*** and ***Left*** nodes. This arrow is pointing
    in both directions. This will result in the link being bidirectional:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦链接被放置在层级中，你将看到一个“*箭头/链接*”，并且你可以修改链接的起始点和终点。它们被称为“**左**”和“**右**”，设置它们位置的最简单方法是拖动（并放置）它们在“*视口*”中。结果，你将能够连接“*导航网格*”的两个不同部分。正如我们在以下截图中可以看到的，如果“*导航网格*”是可见的（通过按“*P*”键启用），你将看到一个连接“**右**”和“**左**”节点的箭头。这个箭头指向两个方向。这将导致链接是**双向的**：
- en: '![](img/c72f4dfa-8b3d-481e-b4e0-f2d54ea58e6c.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/c72f4dfa-8b3d-481e-b4e0-f2d54ea58e6c.png)'
- en: 'You might notice that there are two arrows, one with a darker shade of green.
    Also, this second *arro**w/arc/link* might not be exactly where you placed your
    *Right* end, but rather attached to the *Nav Mesh*. You can see this second arrow
    more clearly in the following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到有两个箭头，一个带有较深的绿色阴影。此外，这个第二个“*箭头/弧/链接*”可能并不完全在你放置的“*右*”端点处，而是附着在“*导航网格*”上。你可以在以下截图中更清楚地看到这个第二个箭头：
- en: '![](img/546c4c46-99a4-413c-a745-fa7b6f80b15e.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/546c4c46-99a4-413c-a745-fa7b6f80b15e.png)'
- en: This is actually how the *Nav Mesh* is connected, due to the *Projection Settings*
    of the *Link*. We will explore this setting in the next section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是“*导航网格*”是如何通过“*链接*”的“**投影设置**”连接起来的。我们将在下一节中探讨这个设置。
- en: 'If you want to make the link go only in one direction, we can change this setting
    in the *Details Panel*. However, to explore these settings, we first need to understand
    that there are two different types of *Links*: ***Simple*** and ***Smart***.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让链接只向一个方向走，我们可以在“**详情面板**”中更改这个设置。然而，要探索这些设置，我们首先需要理解存在两种不同的“**链接**”类型：“**简单**”和“**智能**”。
- en: Simple Links and Smart Links
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单链接和智能链接
- en: When we create a ***Nav Link Proxy***, it comes with an array of ***Simple Links***.
    This means that with a single ***Nav Link Proxy***, we can connect different parts
    of the *Nav Mesh* together. However, the ***Nav Link Proxy*** comes with a single
    ***Smart Link*** as well, which is disabled by default.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个“**导航链接代理**”时，它附带一系列“**简单链接**”。这意味着我们可以使用单个“**导航链接代理**”将“*导航网格*”的不同部分连接在一起。然而，“**导航链接代理**”还附带一个默认禁用的单个“**智能链接**”。
- en: Let's learn about the similarities and difference between a ***Simple Link***
    and a ***Smart Link***.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解**简单链接**和**智能链接**之间的相似之处和不同之处。
- en: Both Simple and Smart Links
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单链接和智能链接
- en: '***Both Simple and Smart Links*** behave in a similar fashion, in the sense
    that they connect two parts of the *Nav Mesh* together. Moreover, Both type of
    links can have ***Direction*** (*Left to Right*, *Right to Left*, or *Both Ways*)
    and a ***Nav Area*** (which kind of navigation area the link is in; for instance,
    you might want to have a custom cost when using this link).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单链接和智能链接**的行为方式相似，即在意义上将*导航网格*的两个部分连接起来。此外，这两种类型的链接都可以有**方向**（*从左到右*，*从右到左*，或*双向*）和**导航区域**（链接所在的导航区域类型；例如，您可能希望在通过此链接时使用自定义成本）。'
- en: Simple Links
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单链接
- en: '***Simple Links*** exists in the ***Point Links Array*** within the *Nav Proxy
    Link*, which means that multiple simple links in a single *Nav Proxy Link* are
    possible. To create another *Simple Link*, you can add an additional element to
    the array of *Simple Nodes* from the *Details* panel, as shown in the following
    screenshot:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单链接**存在于*导航代理链接*中的**点链接数组**中，这意味着在单个*导航代理链接*中可以存在多个简单链接。要创建另一个*简单链接*，您可以从*详细信息*面板中向*简单节点*数组添加一个额外的元素，如下所示：'
- en: '![](img/39a6c509-1e98-4a47-9dc3-7716d8590c37.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/39a6c509-1e98-4a47-9dc3-7716d8590c37.png)'
- en: 'Once we have more *Simple Links*, we can set the ***Start*** and ***End***
    positions, like we did for the first one (by selecting them and moving them within
    the *Viewport* as any other actor). The following screenshot shows where I placed
    two *Simple Links* on the same *Nav Proxy Link* next to each other:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了更多的**简单链接**，我们可以设置**起始**和**结束**位置，就像我们为第一个链接所做的那样（通过选择它们并在*视口*内移动它们，就像其他任何代理一样）。以下截图显示了我在同一*导航代理链接*旁边放置的两个*简单链接*的位置：
- en: '![](img/0c6c5746-93b0-4c2f-b473-42e3ce0696ee.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0c6c5746-93b0-4c2f-b473-42e3ce0696ee.png)'
- en: Every time we create a *Nav Link Proxy*, it comes with one *Simple Link* within
    the array.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们创建一个*导航链接代理*时，它都会在数组中包含一个*简单链接*。
- en: 'For every ***Simple Link*** we have in the *Point Links Array*, we can access
    its settings by expanding the item. The following screenshot shows the Settings
    for the first *Simple Link*:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们在*点链接数组*中的每个**简单链接**，我们可以通过展开项目来访问其设置。以下截图显示了第一个*简单链接*的设置：
- en: '![](img/6294e13f-1c31-4d72-90e9-e0303d1c8030.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6294e13f-1c31-4d72-90e9-e0303d1c8030.png)'
- en: 'Let''s understand these various settings:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解这些不同的设置：
- en: '***Left*** and ***Right***: The position of the ***Left*** and ***Right***
    ends of the Link, respectively.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左**和**右**：链接**左**和**右**端的位置，分别。'
- en: '***Left Project Height*** and ***Right Project Height***: If this number is
    greater than zero, then the link will be projected down to the navigation geometry
    (using a trace with the maximum length specified by this number) for the *Left*
    and *Right* end of the *Link*, respectively. You can see this projected link in
    the following screenshot:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左投影高度**和**右投影高度**：如果此数字大于零，则链接将分别投影到*链接*的**左**和**右**端导航几何形状上（使用最大长度由此数字指定的跟踪）。您可以在以下截图中看到此投影链接：'
- en: '![](img/31afd7a3-fd7e-480c-b726-e0e967eb9d8f.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/31afd7a3-fd7e-480c-b726-e0e967eb9d8f.png)'
- en: '***Direction***: This specifies in which direction the link works. Also, the
    arrow in the *Viewport* will update accordingly. The possible options for this
    are as follows:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方向**：这指定了链接工作的方向。此外，*视口*中的箭头将相应更新。此选项的可能如下：'
- en: '***Both Ways***: The link is bidirectional (remember that the AI needs to be
    equipped to traverse the Link in both directions; e.g. if we''re going over a
    ledge, the agent needs to be able to fall from it (one direction of the link)
    and jump (the other direction of the link).'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双向**：链接是双向的（请记住，AI需要能够以两个方向穿越链接；例如，如果我们正在越过悬崖，代理需要能够从它上掉落（链接的一个方向）和跳跃（链接的另一个方向）。'
- en: '***Left to Right***: The link is only crossable from the Left end to the Right
    one (the agent still needs to have the ability to go in that link direction).'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从左到右**：链接只能从左端向右端穿越（代理仍然需要具备在该链接方向行进的能力）。'
- en: '***Right to Left***: The link is only crossable from the Right end to the Left
    one (the agent still needs have the ability to go in that link direction).'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从右到左**：链接只能从右端向左端穿越（代理仍然需要具备在该链接方向行进的能力）。'
- en: '***Snap Radius*** and ***Height Radius***: You may have noticed a cylinder
    that attaches the end of each link. These two settings control the Radius and
    the Height of that cylinder. Check *Snap to Cheapest Area* for more information
    about the use of this cylinder. The following screenshot shows that the first
    link has a bigger cylinder (both a bigger radius and higher):'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***吸附半径***和***高度半径***：您可能已经注意到连接每个链接末端的圆柱体。这两个设置控制该圆柱体的半径和高度。查看*吸附到最便宜的区域*以获取有关该圆柱体使用的更多信息。以下截图显示第一个链接有一个更大的圆柱体（更大的半径和更高的高度）：'
- en: '![](img/695389b2-d0c7-4738-b69b-acf7be8d5361.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/695389b2-d0c7-4738-b69b-acf7be8d5361.png)'
- en: '***Description***: This is just a string in which you can insert a description
    for your convenience; it has no impact on the *Navigation* or on the *Link*.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***描述***：这只是一个字符串，您可以在其中插入方便的描述；它对*导航*或*链接*没有影响。'
- en: '***Snap to Cheapest Area***: If enabled, it will try to connect the link ends
    to the cheapest area among the available triangles within the cylinder that''s
    specified by the *Snap Radius* and the *Height Radius*. For instance, if the cylinder
    intersects both the *Default Nav Area* and the *BPJungle* Nav Area (that we created
    earlier), the link will be connected directly to the *Default Nav Area*, rather
    than the jungle.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***吸附到最便宜的区域***：如果启用，它将尝试将链接端连接到由*吸附半径*和*高度半径*指定的圆柱体内的最便宜的三角形区域。例如，如果圆柱体同时与*默认导航区域*和*BPJungle*导航区域（我们之前创建的）相交，链接将直接连接到*默认导航区域*，而不是丛林。'
- en: '***Area Class***: The *Link* might have a cost to traverse, or be of a specific
    *Nav Area*. This parameter allows you to define which kind of *Nav Area* the *Link* is
    when traversed.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***区域类***：链接可能具有穿越成本，或属于特定的*导航区域*。此参数允许您定义链接穿越时是哪种类型的*导航区域*。'
- en: This concludes all the possibilities for the ***Simple Links***. However, this
    is a very powerful tool that lets you shape the *Nav Mesh* and achieve amazing
    AI behavior. Now, let's dive into *Smart Links*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了所有关于***简单链接***的可能性。然而，这是一个非常强大的工具，让您能够塑造*导航网格*并实现惊人的AI行为。现在，让我们深入了解*智能链接*。
- en: Smart Links
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能链接
- en: Smart Links can be enabled and disabled at *runtime* using the "***Smart Link
    Is Relevant***" boolean variable. You can also notify surrounding actors of this
    change. By default, it is not relevant (it isn't used in the sense that the link
    is not available), and there is only a single ***Smart Link*** per *Nav Proxy
    Link*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 智能链接可以通过使用“***智能链接相关***”布尔变量在*运行时*启用和禁用。您还可以通知周围的演员这一变化。默认情况下，它是不相关的（它没有被使用，即链接不可用），并且每个*导航代理链接*只有一个***智能链接***。
- en: '**Please note, and don''t get confused**: The *Smart link* can be in two states:
    Enabled and Disabled. However, if the link is actually "present/exists" (for the
    Navigation Mesh), that is another property (*Smart Link Is Relevant*), which in
    other words means that the link is "*active*" for the Navigation System (but it
    can still be in the Enabled or Disabled state).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**请注意，不要混淆**：智能链接可以处于两种状态：启用和禁用。然而，如果链接实际上是“存在/存在”（对于导航网格），这又是另一个属性（*智能链接相关*），换句话说，这意味着链接对于导航系统来说是“*活动*”的（但它仍然可以处于启用或禁用状态）。'
- en: Unfortunately (at least for the current version of the Engine), these are not
    visible in the Editor, which means that the ***Start*** and ***End*** positions
    need to be set manually.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是（至少对于当前版本的引擎），这些在编辑器中是不可见的，这意味着需要手动设置***起始***和***结束***位置。
- en: 'However, let''s go through the settings of a *Smart Link*:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们来看看*智能链接*的设置：
- en: '![](img/958f72d7-f063-49ac-ac10-8c36b41901cc.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/958f72d7-f063-49ac-ac10-8c36b41901cc.png)'
- en: '***Enabled Area Class***: This is the *Nav Area* that the Link assumes when
    it is enabled. The default is *NavArea_Default*.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***启用区域类***：这是链接启用时假设的*导航区域*。默认为*NavArea_Default*。'
- en: '***Disabled Area Class***: This is the *Nav Area* that the Link assumes when
    it is disabled. This means that, when the Link is disabled, it can still be traversed
    if a crossable area is assigned (e.g. when the link is disabled, we might want
    to have a very high cost to cross, but we still want it to be possible to traverse
    it. Of course, the default is *NavArea_Default*, which means that it is not crossable.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***禁用区域类***：这是链接禁用时假设的*导航区域*。这意味着当链接禁用时，如果分配了可穿越的区域（例如，当链接禁用时，我们可能希望有非常高的成本来穿越，但我们仍然希望它能够穿越。当然，默认为*NavArea_Default*，这意味着它不可穿越。'
- en: '***Link Relative Start***: This represents the Start point of the link, relative
    to the position of its *Nav Link Proxy*.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***链接相对起始***：这表示链接的起始点，相对于其*导航链接代理*的位置。'
- en: '***Link Relative End***: This represents the End point of the link, relative
    to the position of its *Nav Link Proxy*.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***链接相对结束***：这表示链接的结束点，相对于其*导航链接代理*的位置。'
- en: '***Link Direction***: This specifies in which direction the link works. The
    possible options are as follows:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***链接方向***：这指定了链接工作的方向。可能的选项如下：'
- en: '***Both Ways***: The link is bidirectional (remember that the AI needs to be
    equipped to traverse the Link in both directions; e.g. over a ledge, the agent
    needs to be able to fall from it (one direction of the link) and jump (the other
    direction of the link).'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***双向***：链接是双向的（记住AI需要能够双向穿越链接；例如，在悬崖上，代理需要能够从上面掉落（链接的一个方向）和跳跃（链接的另一个方向）。'
- en: '***Left to Right***: The link is only crossable from the Left end to the Right
    one (the agent still needs to have the ability to go in that link direction).'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***从左到右***：链接只能从左端穿越到右端（代理仍然需要在该链接方向上移动的能力）。'
- en: '***Right to Left***: The link is only crossable from the Right end to the Left
    one (the agent still needs to have the ability to go in that link direction).'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***从右到左***：链接只能从右端穿越到左端（代理仍然需要在该链接方向上移动的能力）。'
- en: Although the options of this parameter label the end points of the link as *Left*
    and *Right*, they refer to the *Start* and *End* point of the link. Alternatively
    (this may be better since the link can be bidirectional), *Link Relative Start*
    and *Link Relative End* refer to *Left* and *Right*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然此参数的选项将链接的端点标记为*左*和*右*，但它们指的是链接的*起始*点和*结束*点。或者（这可能更好，因为链接可以是双向的），*链接相对起始*和*链接相对结束*指的是*左*和*右*。
- en: '***Link Enabled***: This is a boolean variable that determines whether the
    *Smart Link* is enabled. This value can be changed at runtime, and the link can
    "*notify*" surrounding agents/actors that are interested in such information (see
    later for more info). The default value is true.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***链接启用***：这是一个布尔变量，用于确定*智能链接*是否启用。此值可以在运行时更改，并且链接可以"*通知*"对这种信息感兴趣的周围代理/演员（见后文了解更多信息）。默认值是true。'
- en: '***Smart Link Is Relevant***: This is a boolean variable that determines whether
    the *Smart Link* is actually "*active*", that is, if it is relevant or whether
    we should ignore it. The default value is false.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***智能链接相关***：这是一个布尔变量，用于确定*智能链接*是否实际上是"*活动状态*"，即它是否相关，或者我们应该忽略它。默认值是false。'
- en: These are the main settings regarding a Smart Link.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是关于智能链接的主要设置。
- en: 'It''s worth mentioning that *Smart Links* can actually do more than just connect
    Nav Meshes. They have a series of functions to handle agents that are traversing
    the Link. For instance, by opening the `NavLinkProxy.h` file, we can find the
    following functions:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，*智能链接*实际上可以做的不仅仅是连接导航网格。它们有一系列处理正在穿越链接的代理的功能。例如，通过打开`NavLinkProxy.h`文件，我们可以找到以下函数：
- en: '[PRE2]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Unfortunately, these functions are outside the scope of this book, but I invite
    you to read the code to learn more about them.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这些功能超出了本书的范围，但我邀请您阅读代码以了解更多关于它们的信息。
- en: 'Previously, we mentioned that the *Smart Link* can broadcast information regarding
    its status change at runtime to nearby agent/actors. You can change how the *Smart
    Link* broadcasts this information with the ***Broadcast*** settings, which are
    just below the *Smart Link* ones:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们提到，*智能链接*可以在运行时向附近的代理/演员广播有关其状态变化的信息。您可以通过以下***广播***设置更改*智能链接*广播此信息的方式，这些设置位于*智能链接*下方：
- en: '![](img/36555d1b-3e0c-4ec7-a7f8-c4e01c536479.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36555d1b-3e0c-4ec7-a7f8-c4e01c536479.png)'
- en: 'These settings are quite intuitive, but let''s go through them quickly:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置相当直观，但让我们快速浏览一下：
- en: '***Notify when Enabled***: If true, the Link will notify agents/actors when
    it gets *Enabled*.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***启用时通知***：如果为真，链接将在启用时通知代理/演员。'
- en: '***Notify when Disabled***: If true, the Link will notify agents/actors when
    it gets *Disabled*.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***禁用时通知***：如果为真，链接将在禁用时通知代理/演员。'
- en: '***Broadcast Radius***: This specifies how far the broadcast should go. Every
    agent that is outside this radius will not get notified about the change of the
    Link.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***广播半径***：这指定了广播应该延伸多远。所有位于此半径之外的代理都不会收到关于链接变化的通知。'
- en: '***Broadcast Interval***: This specifies after how long the Link should repeat
    the broadcast. If the value is zero, the broadcast is repeated only once.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***广播间隔***：这指定了链接应该在多长时间后重复广播。如果值为零，则广播只重复一次。'
- en: '***Broadcast Channel***: This is the trace channel for broadcasting the change.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***广播频道***：这是用于广播变化的跟踪频道。'
- en: This concludes our discussion on ***Smart Links***.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对 ***智能链接*** 的讨论。
- en: Other settings of the Nav Link Proxy
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他 Nav Link Proxy 设置
- en: 'Finally, it''s just worth mentioning that the ***Nav Link Proxy*** can create
    an *Obstacle Box* when the *Nav Mesh* is generated. You can find these settings
    in the *Details Panel* of the ***Nav Link Proxy***, as shown in the following
    screenshot:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得一提的是，当生成 *Nav Mesh* 时，***Nav Link Proxy*** 可以创建一个 *障碍盒*。你可以在 ***Nav Link
    Proxy*** 的 *详细信息面板* 中找到这些设置，如下面的截图所示：
- en: '![](img/ec16dca6-906f-46f9-9647-3ef6462bfb5d.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec16dca6-906f-46f9-9647-3ef6462bfb5d.png)'
- en: These settings allow you to decide whether the *Obstacle Box* is active/used,
    its *dimension/extent* and its offset, as well as the type of *Nav Area*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置允许你决定是否激活/使用 *障碍盒*，其 *尺寸/范围* 和偏移量，以及 *导航区域* 的类型。
- en: Extending the Nav Link Proxy
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展 Nav Link Proxy
- en: If you are wondering whether it is possible to extend *Links* or include them
    within more complex actors, the answer is "*Of course, Yes! But you can only extend
    them in C++*".
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道是否可以扩展 *链接* 或在更复杂的演员中包含它们，答案是“*当然可以！但你只能用 C++ 扩展它们*”。
- en: Since this book cannot cover everything, we don't have the time to deal with
    this in detail. However, some of the reasons why you may want to extend the ***Nav
    Link Proxy*** are to have a better control over the characters that enter your
    Link. For instance, you might want to have a *Jump Pad* that pushes the character
    through the Link. This isn't very complicated to do, and if you search for this
    online, you will find plenty of tutorials on how to do this using *Navigation
    Links*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这本书不能涵盖所有内容，我们没有时间详细处理这部分。然而，你可能想要扩展 ***Nav Link Proxy*** 的原因之一是更好地控制进入你的链接的角色。例如，你可能想要有一个
    *跳跃垫* 将角色推过链接。这并不复杂，如果你在网上搜索，你会找到很多关于如何使用 *导航链接* 来实现这一点的教程。
- en: Just keep in mind that to be a good AI programmer in Unreal, you will eventually
    need to master this part of *Nav Links* as well, but for now, we are covering
    enough.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，要成为一名优秀的 Unreal AI 程序员，你最终需要掌握 *Nav Links* 的这部分内容，但就目前而言，我们已经涵盖了足够的内容。
- en: Navigation Avoidance
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航规避
- en: Navigation Avoidance is a very broad topic, and Unreal has some subsystems that
    do this for us. Therefore, we will deal with this topic in [Chapter 6](c1359fa6-3bdf-4f0d-8a0c-98c35f885167.xhtml)*,
    Crowds*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 导航规避是一个非常广泛的话题，Unreal 有一些子系统为我们处理这个问题。因此，我们将把这个话题放在 [第 6 章](c1359fa6-3bdf-4f0d-8a0c-98c35f885167.xhtml)*，人群*
    中讨论。
- en: Navigation Filtering
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航过滤
- en: We don't want to find a certain path in the same way every time. Imagine that
    our AI agent uses a power up and it is able to move through the jungle twice as
    fast. In this case, the Navigation System is not aware of this change, nor is
    it a permanent change to the shape or weights of the *Nav Mesh*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望每次都以相同的方式找到特定的路径。想象一下，我们的 AI 代理使用了一个增强效果，它能够以两倍的速度穿越丛林。在这种情况下，导航系统没有意识到这种变化，这也不是对
    *Nav Mesh* 形状或权重的永久性更改。
- en: '***Nav Filtering*** allows us to define specific rules on how to perform the
    pathfind for that specific period of time. You may have noticed that every time
    we perform a navigation task, either in Blueprint or C++, there is an optional
    parameter for inserting a ***Nav Filter***. Here are some examples of Blueprint
    nodes (the same goes for C++ functions) that have this optional filter parameter:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '***导航过滤*** 允许我们定义在特定时间段内如何执行路径查找的具体规则。你可能已经注意到，每次我们在蓝图或 C++ 中执行导航任务时，都有一个可选参数用于插入一个
    ***导航过滤器***。以下是一些具有此可选过滤器参数的蓝图节点（C++ 函数也是如此）的示例：'
- en: '![](img/76884c87-a640-4eef-8342-95d9c87ce979.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76884c87-a640-4eef-8342-95d9c87ce979.png)'
- en: 'Even the ***Move To*** nodes of ***Behavior Trees*** have the ***Navigation
    Filter*** option:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是 ***行为树*** 中的 ***移动到*** 节点也有 ***导航过滤器*** 选项：
- en: '![](img/a3c66db1-5dfc-4681-9faf-d233bf226f27.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3c66db1-5dfc-4681-9faf-d233bf226f27.png)'
- en: Of course, once you have inserted a filter, the pathfinding will behave accordingly.
    This means that using ***Nav Filters*** is pretty straightforward. However, how
    can we create ***Nav Filters***? Let's find out, both in Blueprint and C++.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一旦您插入了一个过滤器，路径查找将相应地表现。这意味着使用***导航过滤器***非常简单。然而，我们如何创建***导航过滤器***？让我们在蓝图和C++中找出答案。
- en: Creating a Navigation Filter in Blueprint
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在蓝图创建导航过滤器
- en: Previously in this chapter, we created a Jungle area in Blueprint. Thus, this
    seems like a good example that we can use to create a ***Nav Filter*** that allows
    the AI Agent to travel through the Jungle faster – even faster than it takes to
    traverse the *Default Area* of the *Nav Mesh*. Let's imagine that the AI Agent
    has some power or ability that allows it to move faster in Jungle type areas in
    the level.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之前，我们在蓝图中创建了一个丛林区域。因此，这似乎是一个很好的例子，我们可以用它来创建一个允许AI代理更快地穿越丛林——甚至比穿越*导航网格*的*默认区域*还要快——的***导航过滤器***。让我们想象AI代理有一些力量或能力，允许它在关卡中的丛林类型区域中更快地移动。
- en: 'To create a ***Nav Filter*** in Blueprint, we need to start creating a new
    Blueprint that inherits from ***NavigationQueryFilter***, as shown in the following
    screenshot:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要在蓝图创建一个***导航过滤器***，我们需要开始创建一个新的蓝图，该蓝图继承自***NavigationQueryFilter***，如下面的截图所示：
- en: '![](img/6ab2ad92-2ebe-4288-ac0a-c44987dcabc0.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6ab2ad92-2ebe-4288-ac0a-c44987dcabc0.png)'
- en: 'By convention, the name of the class should start with "*NavFilter_*". We will
    rename it to ***NavFilter_BPFastJungle*** (I added BP so that I can remember that
    I created this with Blueprint, since we are repeating the same task in Blueprint
    and in C++). This is what it should look like in the *Content Browser*:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，类的名称应该以"*NavFilter_***"开头。我们将将其重命名为***NavFilter_BPFastJungle***（我添加了BP，以便我可以记住我是用蓝图创建的，因为我们正在蓝图和C++中重复相同的任务）。这是它在*内容浏览器*中的样子：
- en: '![](img/0e66b0b6-c13f-426c-ae20-89eec9929602.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0e66b0b6-c13f-426c-ae20-89eec9929602.png)'
- en: 'Once we open the Blueprint, we will find its options in the *Details* panel:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们打开蓝图，我们将在*详细信息*面板中找到其选项：
- en: '![](img/72deec62-e9a3-4d06-8959-56d80ddcd367.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/72deec62-e9a3-4d06-8959-56d80ddcd367.png)'
- en: 'As you can see, there is an ***Array of Areas*** and two sets for *Including
    and Excluding (Nav) Flags*. Unfortunately, we didn''t cover *Nav Flags* since
    they are out of the scope of this book, and they can only be assigned in C++ at
    the time of writing. However, the ***Array of Areas*** is quite interesting. Let''s
    add a new Area and use our ***NavArea_BPJungle*** for the ***Area Class***, as
    shown in the following screenshot:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有一个***区域数组***和两个用于*包括和排除（导航）标志*的集合。不幸的是，我们没有涵盖*导航标志*，因为它们超出了本书的范围，并且在撰写时只能在C++中分配。然而，***区域数组***非常有趣。让我们添加一个新的区域，并使用我们的***NavArea_BPJungle***作为***区域类***，如下面的截图所示：
- en: '![](img/2de8dfeb-c213-4a39-80bb-41cd53eaad36.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2de8dfeb-c213-4a39-80bb-41cd53eaad36.png)'
- en: 'Now, we can override the ***Travel Cost*** and the ***Entering Cost*** for
    the Jungle Area, which will be used instead of the costs we specified in the Area
    Class if this filter is used. Remember to tick the checkbox next to the option''s
    name to enable editing. For example, we could have a ***Travel Cost*** of ***0.6***
    (since we can move through the Jungle quickly without any issues) and an ***Entering
    Cost*** of ***zero***:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以覆盖丛林区域的***旅行成本***和***进入成本***，如果使用此过滤器，则将使用这些成本代替我们在区域类中指定的成本。请记住勾选选项旁边的复选框以启用编辑。例如，我们可以将***旅行成本***设置为***0.6***（因为我们可以快速通过丛林而不会遇到任何问题），并将***进入成本***设置为***零***：
- en: '![](img/4a5f47e4-1cb1-4140-a704-550b50bf9a2e.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4a5f47e4-1cb1-4140-a704-550b50bf9a2e.png)'
- en: Now, we are all good to good. The filter is ready for if you prefer traveling
    in the Jungle!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们一切都准备好了。过滤器已准备好供您在丛林中旅行时使用！
- en: '**Changing the Travel Cost for a** **Nav Area DOESN''T make the AI agent go
    faster or slower in that area**, it just makes pathfinding prefer that path over
    another. The implementation that the agent becomes faster in that area is left
    out from the *Navigation System*, and so you will need to implement that when
    the AI character is in the jungle.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**为** **导航区域** **更改** **旅行成本** **并不会使AI代理在该区域更快或更慢，它只是使路径查找更倾向于该路径而不是另一条路径**。代理在该区域变得更快是实现，被排除在*导航系统*之外，因此您需要在AI角色在丛林中时实现这一点。'
- en: 'If you also followed the C++ part for the *Nav Areas*, then you should also
    have the Desert area in your project. As an optional step, we can add a second
    area to the filter. Imagine that by using the power-up or ability to move faster
    in the Jungle, our character has become very sensitive to the sun and very prone
    to sunburns, which decreases their health significantly. As a result, we can set
    a higher cost for the *Desert Area* if this filter is used. Just add another Area,
    and set the ***Area Class*** to ***NavArea_Desert***. Then, override the costs;
    for instance, a ***Travel Cost*** of ***2.5*** and an ***Entering Cost*** of ***10***:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你同时也跟随了*Nav Areas*的C++部分，那么你应该在你的项目中也有沙漠区域。作为一个可选步骤，我们可以向过滤器添加第二个区域。想象一下，通过使用在丛林中移动更快的加成或能力，我们的角色对阳光变得非常敏感，很容易晒伤，这会显著降低他们的健康。因此，如果使用此过滤器，我们可以为*沙漠区域*设置更高的成本。只需添加另一个区域，并将***区域类***设置为***NavArea_Desert***。然后，覆盖成本；例如，一个***旅行成本***为***2.5***和***进入成本***为***10***：
- en: '![](img/403f1ba4-5fc5-4d2c-bcef-50d932d1905f.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/403f1ba4-5fc5-4d2c-bcef-50d932d1905f.png)'
- en: Once you have finished editing the settings, save the Blueprint. From now on,
    you will be able to use this filter within the *Navigation System*. This concludes
    how to create a ***Nav Filter*** in Blueprint.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了设置编辑，保存蓝图。从现在起，你将能够在*导航系统*中使用此过滤器。这标志着如何在蓝图中创建***Nav Filter***的方法结束。
- en: Creating a Navigation Filter in C++
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++中创建导航过滤器
- en: In a similar way to Blueprint, we can create a C++ ***Nav Filter***. This time,
    we can create a filter that slightly lowers the cost for the Desert Area. You
    can use this filter on certain animals that live in the desert and will be less
    prone to its effects.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似蓝图的方式，我们可以创建一个C++的***Nav Filter***。这次，我们可以创建一个稍微降低沙漠区域成本的过滤器。你可以将此过滤器用于某些生活在沙漠中的动物，使其不太容易受到其影响。
- en: 'To start, we need to create a new C++ class that inherits from ***NavigationQueryFilter***,
    as shown in the following screenshot:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个新的C++类，它继承自***NavigationQueryFilter***，如下面的截图所示：
- en: '![](img/5fabbbab-98ea-4c47-9577-88f07d3c7fb3.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5fabbbab-98ea-4c47-9577-88f07d3c7fb3.png)'
- en: 'By convention, the name of the class should start with "*NavFilter_*". Hence,
    we will rename it to ***NavFilter_Desert Animal*** and place it in "***Chapter3/Navigation***":'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，类的名称应该以"*NavFilter_*"开头。因此，我们将将其重命名为***NavFilter_Desert Animal***并将其放置在"***Chapter3/Navigation***"：
- en: '![](img/17195ad5-bddc-4e6c-917d-39058ad8f501.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17195ad5-bddc-4e6c-917d-39058ad8f501.png)'
- en: 'To set its properties, we need to create a default constructor. Write the following
    in the header (`.h`) file:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置其属性，我们需要创建一个默认构造函数。在头文件（`.h`）中写下以下内容：
- en: '[PRE3]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For the implementation (`.cpp` file), we need to do a bit more work. First
    of all, we need to have access to the *Nav Area* that we need, which, in this
    case, is the Desert. Let''s add the following `#include` statement:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实现（`.cpp`文件），我们需要做更多的工作。首先，我们需要访问我们需要的*Nav Area*，在这种情况下，是沙漠。让我们添加以下`#include`语句：
- en: '[PRE4]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, in the constructor, we need to create a ***FNavigationFilterArea***,
    which is a class that contains all the options for filtering a specific class.
    In our example, we can store this new *Filter Area* inside a variable named `Desert`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在构造函数中，我们需要创建一个***FNavigationFilterArea***，这是一个包含过滤特定类所有选项的类。在我们的例子中，我们可以将这个新的*过滤器区域*存储在一个名为`Desert`的变量中：
- en: '[PRE5]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we need to fill the `Desert` variable with the options that we want to
    override for that class, including which ***Nav Area*** we are modifying:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将`Desert`变量填充为我们想要覆盖该类的选项，包括我们正在修改的哪个***Nav Area***：
- en: '[PRE6]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we need to add this *Filter Area* in the ***Areas*** array:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将此*过滤器区域*添加到***Areas***数组中：
- en: '[PRE7]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For your convenience, here is the full `.cpp` file:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，以下是完整的`.cpp`文件：
- en: '[PRE8]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Compile this code and you will be able to use this filter next time you need
    to use the *Navigation System*. This concludes our discussion on *Navigation Filters*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 编译此代码，你将能够在下次需要使用*导航系统*时使用此过滤器。这标志着我们对*导航过滤器*的讨论结束。
- en: Overriding the Navigation System
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖导航系统
- en: From the *Mode Panel*, you are able to drag into the level a special actor called
    ***Nav System Config Override***.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 从*模式面板*中，你可以将一个名为***Nav System Config Override***的特殊演员拖入级别。
- en: '![](img/e076b9b0-72f7-4027-803a-1d200c5c974d.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e076b9b0-72f7-4027-803a-1d200c5c974d.png)'
- en: This actor allows you to override the built-in *Navigation System* by using
    another one. Of course, you will have to develop it first, and this would need
    a lot of effort.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此演员允许你通过使用另一个来覆盖内置的*导航系统*。当然，你将不得不首先开发它，这将需要大量的努力。
- en: '![](img/14df0108-48ef-4609-8f2c-0008f216d03d.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/14df0108-48ef-4609-8f2c-0008f216d03d.png)'
- en: Reasons why you should substitute the default Navigation System (or maybe used
    along with another one) is mainly due to overcome limitations. What about air-units;
    how can they do a 3D Pathfinding? How about spiders who have a surface pathfinding?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该替换默认的导航系统（或者可能与其他系统一起使用）的原因主要是为了克服限制。那么空中单位呢？它们如何进行3D路径查找？蜘蛛如何进行表面路径查找？
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how we can set up the *Navigation System *so that
    our AI character can move around the map. In particular, we have learned how we
    can shape the *Nav Mesh* with *Modifier Volumes*, *Nav Link Proxies*, and *NavMesh
    Areas*.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何设置*导航系统*，以便我们的AI角色可以在地图上移动。特别是，我们学习了如何使用*修改体积*、*导航链接代理*和*导航网格区域*来塑造*导航网格*。
- en: As a result, our AI agents can smoothly navigate through the map, efficiently
    finding a path between two points that is optimized based on their capabilities
    (e.g. using *Navigation Filters*) by respecting the varies types of "*terrains*"
    of the map (e.g. using *Navigation Areas*). Moreover, they can fall over ledges
    or jump between platforms (e.g. by using *Nav Link Proxies* and a bit of coding
    for jumping).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的AI代理可以平滑地穿越地图，高效地找到两点之间的路径，该路径基于他们的能力进行了优化（例如，使用*导航过滤器*），同时尊重地图上各种类型的"*地形*"（例如，使用*导航区域*）。此外，它们可以翻过悬崖或跳过平台（例如，通过使用*导航链接代理*和一点跳跃的编码）。
- en: In the next chapter, we are going to learn about a more advanced AI feature
    in the Unreal Framework, that is, the *Environment Querying System*, which allows
    the agent to "*query*" the environment so that they can find locations (or actors)
    with specific requisites.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于Unreal框架中更高级的AI功能，即*环境查询系统*，它允许代理"*查询*"环境，以便他们可以找到具有特定要求的地点（或演员）。
