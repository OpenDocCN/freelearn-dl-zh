- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Genetic Algorithms in Hybrid Neural Networks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合神经网络中的遗传算法
- en: In this chapter and the following two chapters, we will explore the world inside
    us. First, in this chapter, we will use the model of our genes as an optimizing
    tool. In *Chapter 18*, *Neuromorphic Computing*, we will enter our biological
    brain activity and create neuromorphic networks. Finally, in *Chapter 19*, *Quantum
    Computing*, we will go even deeper and use the quantum material in us to build
    quantum mechanic models for quantum computing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章及接下来的两章中，我们将探索我们体内的世界。首先，在本章中，我们将使用我们的基因模型作为优化工具。在*第18章*，*类脑计算*中，我们将进入我们的生物大脑活动并创建类脑网络。最后，在*第19章*，*量子计算*中，我们将更深入地利用我们体内的量子材料来构建量子力学模型以进行量子计算。
- en: A slight change in any of these tiny entities (genes, neurons, qubits) within
    us can modify our whole existence.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们体内这些微小实体（基因、神经元、量子比特）中的任何细微变化都可能改变我们的整体存在。
- en: In this chapter, we will discover how to enter our chromosome, find our genes,
    and understand how our reproduction process works. From there, we will begin to implement
    an evolutionary algorithm in Python, a **genetic algorithm** (**GA**).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将发现如何进入我们的染色体，找到我们的基因，并了解我们的繁殖过程是如何工作的。从那里开始，我们将开始在Python中实现一个进化算法，即**遗传算法**（**GA**）。
- en: Charles Darwin offered "survival of the fittest" as a model to represent evolution.
    In some ways, the model is controversial. In 21st century societies, we tend to
    provide support to those who are not the fittest, as best as possible. However,
    in mathematics, we do not have this ethical problem.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 查尔斯·达尔文提出了“适者生存”作为进化的模型。从某些方面来说，这个模型是有争议的。在21世纪的社会中，我们倾向于尽可能地为那些不是最强者的人提供支持。然而，在数学中，我们没有这种伦理问题。
- en: In AI, we need to provide an accurate solution. If we generate several solutions,
    we can apply the "survival of the fittest" to abstract numbers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在人工智能中，我们需要提供一个准确的解决方案。如果我们生成多个解决方案，我们可以将“适者生存”应用于抽象数字。
- en: In some cases, GAs dramatically reduce the number of combinations required to
    find the optimal solution to a problem. By generating mathematical offspring,
    choosing the fittest, and producing new stronger abstract generations, the system
    often reaches a more optimal solution than propagating permutations.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，遗传算法显著减少了找到问题最优解所需的组合数。通过生成数学后代、选择最适应者并产生新的、更强的抽象世代，系统通常比通过排列组合传播达到更优的解决方案。
- en: A well-designed GA can optimize the architecture of a neural network, thereby
    producing a hybrid neural network.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计良好的遗传算法（GA）可以优化神经网络的架构，从而生成混合神经网络。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Evolutionary algorithms; genetic algorithms
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进化算法；遗传算法
- en: Extending the genes of genetic algorithms to optimizing tools
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展遗传算法的基因以优化工具
- en: Hybrid neural networks
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合神经网络
- en: Using a genetic algorithm to optimize an LSTM
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用遗传算法优化LSTM
- en: Let's begin by first working to understand what evolutionary algorithms are.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先从了解进化算法是什么开始。
- en: Understanding evolutionary algorithms
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解进化算法
- en: In this section, we will drill down from our heredity down to our genes to understand
    the process that we will then represent while building our Python program.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将从遗传到基因深入了解这个过程，然后在构建我们的Python程序时进行表示。
- en: 'Successive generations of humans activate some genes and not others, producing
    the wonderful diversity of humanity. A human lifetime is an episode in a long
    line of thousands of generations of humans. We all have two parents, four grandparents,
    and eight great-grandparents, which amounts to 2³ ascendants. Suppose that we
    extend this line of reasoning to four generations per century and then over about
    12,000 years when the last glacial period ended and the planet started warming
    up. We obtain:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 人类的连续世代激活某些基因而不激活其他基因，从而产生了人类的多样性。一个人类的生命周期是成千上万代人类中的一段经历。我们每个人都有两个父母、四个祖父母和八个曾祖父母，这一代人加起来有2³个先祖。假设我们将这种推理扩展到每个世纪四代人，然后跨越大约12,000年，即上一个冰川时期结束时，地球开始变暖。我们得到：
- en: 4 * 1 century * 10 centuries = 1,000 years and 40 generations
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 * 1 世纪 * 10 世纪 = 1,000年和40代人
- en: 40 generations * 12= 480
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 40代人 * 12 = 480
- en: Adding up to 2^(480) mathematical ascendants to anybody living today on the
    planet!
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多达2^(480)个数学先祖加到今天地球上的任何人身上！
- en: Even if we limit ourselves to 1,000 years, 2^(40), that adds up to 1,099,511,627,776
    ascendants a thousand years ago. But there is a problem. This figure is impossible!
    Today, we have reached the height of the human population, which is only 7,500,000,000\.
    So, this means that our ascendants had many children who married their cousins
    of all degrees, making humanity one large extended family, no matter what our
    skin color or hair color is!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们将时间限制为1000年，也就是2^(40)，这意味着一千年前我们的祖先有1,099,511,627,776个后代。但有一个问题，这个数字是不可能的！今天，我们已经达到了人类人口的峰值，仅为7,500,000,000。因此，这意味着我们的祖先有很多子女，他们互相结婚，甚至是各个程度的表亲，形成了一个巨大的大家族，无论我们的肤色或发色是什么！
- en: Heredity in humans
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 人类的遗传
- en: First, men fertilize women when a male cell unites with a female cell. The fertilized
    egg grows and, after quite an adventure, is born and becomes one of us writing
    or reading this book.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，男性通过精子与女性的卵子结合来完成受精。受精卵开始生长，并在经过一段冒险后诞生，最终成为现在写下或阅读这本书的我们。
- en: To grow and live from being a fertilized egg to human adults, we must gather
    much of the outside world, absorb, and transform it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从受精卵成长为人类成年人，我们必须收集外界的许多东西，吸收并转化它们。
- en: This transformation of food and materials by us until we grow into something
    that is more or less like our ancestors is called heredity.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将食物和物质转化，直到成长为类似于我们祖先的模样，这个过程叫做遗传。
- en: If life were calm and quiet, nothing noticeable would occur. However, our environment
    has exerted relentless pressure on us for millions of years, back to when we were
    just some kind of bacteria floating around in an ocean somewhere. That pressure
    brought about continuous natural selection; what worked would live on, whilst
    what didn't work would die out.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果生命是平静而安静的，什么显著的变化都不会发生。然而，我们的环境已经对我们施加了持续不断的压力，直到数百万年前，当我们只是某种在海洋中漂浮的细菌时，这种压力才开始产生。这种压力促成了持续的自然选择；有用的会存活下来，而无用的则会灭绝。
- en: That pressure continues up to present day, forcing us, humans, to adapt genetically
    or disappear. Those humans who failed to adapt to face the pressure of their environment
    died out. We who live today have survived.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种压力一直延续到今天，迫使我们人类要么在基因上适应，要么灭绝。那些未能适应环境压力的人类已经灭绝。我们今天活着的幸存下来。
- en: Evolution can be defined as a state of constant conflict. On one hand we have
    our relentless, often hostile environment. On the other, our equally relentless
    genes; many of which die out, but others morph, adapt, and continue on through
    heredity—indeed, they're doing that even now, and who knows what is going to happen
    next?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 进化可以定义为一种不断冲突的状态。一方面，我们面临着无情、常常是敌对的环境；另一方面，我们同样顽强的基因；许多基因消失了，但其他基因变异、适应，并通过遗传得以延续——事实上，它们现在仍在这样做，谁知道接下来会发生什么呢？
- en: Our cells
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的细胞
- en: In our cells, the nucleus contains personal biological data in the form of chromosomes.
    Our cells contain 46 chromosomes per cell, which, in turn, are formed by 23 pairs
    of chromosomes. One of these pairs is a sex cell to determine our sex.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的细胞中，细胞核包含个人的生物数据，形式为染色体。我们的细胞每个都有46条染色体，这些染色体由23对染色体组成。其中一对是性染色体，决定我们的性别。
- en: Inside the chromosomes, we have genes, especially the mitochondrial genome,
    which is the DNA in tiny cells that take our food and transform it into fuel for
    our cells. Each cell is a microscopic busy factory containing thousands of genes!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在染色体内，我们拥有基因，尤其是线粒体基因组，它是存在于微小细胞中的DNA，这些细胞将我们的食物转化为细胞的燃料。每个细胞都是一个微观的忙碌工厂，包含着成千上万个基因！
- en: The human genome describes an incredible set of sequences for our building blocks contained
    in the 23 chromosomes of our cells.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 人类基因组描述了一个不可思议的序列集合，这些序列构成了我们在细胞23对染色体中的构建块。
- en: How heredity works
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遗传是如何工作的
- en: Except for the sex cells, we inherit twenty-three of our mother's forty-six
    chromosomes and twenty-three of our father's chromosomes. In turn, our parents'
    cells contain the chromosomes of their parents—our grandparents—and so on in various
    proportions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除了性细胞外，我们从母亲那里继承了她46条染色体中的23条，从父亲那里继承了他那里的23条染色体。反过来，我们父母的细胞也包含他们父母——我们的祖父母——的染色体，依此类推，以不同的比例继承。
- en: Let's take an example to view the complexity of what we are facing. We will
    take one of our parents, either our mother or father. *P* represents the set of
    chromosomes of that parent.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来看看我们所面临的复杂性。我们以我们的父母之一为例，不管是母亲还是父亲。*P*代表该父母的染色体集合。
- en: Letters with primes will represent their fathers'—our grandfathers'—chromosomes,
    and letters with double primes will represent their mothers'—our grandmothers'—chromosomes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 带有单引号的字母代表其父亲—我们祖父—的染色体，带有双引号的字母代表其母亲—我们祖母—的染色体。
- en: 'We can represent this as follows for your father in his sex cell:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为你父亲的性细胞表示如下：
- en: '![](img/B15438_17_001.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15438_17_001.png)'
- en: 'For your mother, the last chromosome of the first set would be an *X* in her
    sex cell:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的母亲，第一组中的最后一个染色体将在她的性细胞中是一个*X*：
- en: '![](img/B15438_17_002.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15438_17_002.png)'
- en: Women are *X*-*X* and men *X*-*Y*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 女性是*X*-*X*，男性是*X*-*Y*。
- en: Imagine the possibilities!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下可能性！
- en: 'If we only take *A*, *B*, and *C* in only one of our parent''s cells, we already
    obtain the following set, *C*, of the eight combinations we would inherit:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只从父母的某一个细胞中取出*A*、*B*和*C*，我们已经获得了以下集合，*C*，这是我们将继承的八种组合：
- en: '![](img/B15438_17_003.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15438_17_003.png)'
- en: If we extend this to the twenty-three chromosomes, the distribution climbs up
    to 2^(23), or 8,388,608 possibilities.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此扩展到二十三对染色体，分布将达到2^(23)，即8,388,608种可能性。
- en: Our evolutionary process contains the right potential for evolutionary algorithms.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的进化过程包含了适用于进化算法的潜力。
- en: Evolutionary algorithms
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进化算法
- en: 'In this section, we will drill down further into evolutionary algorithms, getting
    closer to our Python programs. Evolutionary algorithms can be used in any field
    in which combinations are useful: scheduling, medical research on DNA, weather
    forecasting, neural network architecture optimizing and a limitless number of domains.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将进一步深入研究进化算法，并将其与我们的Python程序更加紧密地结合。进化算法可以应用于任何需要组合的领域：调度、DNA医学研究、天气预报、神经网络架构优化以及无限多的领域。
- en: '*Evolutionary computation* is a set of algorithms that apply trial-and-error
    techniques to reproduce an abstract mathematical version of biological evolution.
    This mathematical model does not contend with having solved the difficult task
    of explaining evolution, which naturally cannot be reduced to a few equations.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*进化计算*是一组应用试错技术来重现生物进化的抽象数学版本的算法。这一数学模型并不声称已经解决了进化的难题，因为进化自然无法简化为几个方程式。'
- en: However, our biological environment produces frameworks that, though the fruits
    of our imagination, enable us to create efficient abstract algorithms.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的生物环境产生了框架，这些框架虽然是我们想象的产物，却使我们能够创造出高效的抽象算法。
- en: Evolutionary algorithms enter the category of *evolutionary computation*. An
    evolutionary algorithm contains processes such as mutation, crossover, and selection.
    Many models can achieve the goals set for an evolutionary process.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 进化算法属于*进化计算*类别。一个进化算法包含诸如变异、交叉和选择等过程。许多模型能够实现为进化过程设定的目标。
- en: A GA introduces the category of an evolutionary algorithm.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法（GA）引入了进化算法的范畴。
- en: We will first define the concepts involved in a GA, which are the building blocks
    of a Python program.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义遗传算法（GA）中涉及的概念，这些是Python程序的构建块。
- en: Going from a biological model to an algorithm
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从生物模型到算法
- en: There are many ways of creating a GA model. You can reproduce the exact description
    of the human model described in the preceding section, you can simplify it, or
    you can create another view.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 创建GA模型有多种方式。你可以复制前面部分描述的人类模型，或者简化它，甚至创建另一种视角。
- en: 'Our model will contain a set of genes in a chromosome and a population to interact with:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模型将包含染色体中的一组基因，并且包含一个与之互动的种群：
- en: '![](img/B15438_17_01.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15438_17_01.png)'
- en: 'Figure 17.1: Chromosomes in genes'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.1：基因中的染色体
- en: Our model is an abstract model for algorithms, not the actual representation
    of human chromosomes that come in pairs, for example. A gene in an individual's
    chromosome will interact with the gene set of the population. This process will
    be defined in the following sections.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模型是一个抽象的算法模型，而不是人类染色体（如成对出现）的实际表现形式。例如，个体染色体中的一个基因将与种群中基因集进行交互。这个过程将在接下来的部分中定义。
- en: Basic concepts
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本概念
- en: 'Let''s first describe the concepts of the building blocks of our Python program:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先描述Python程序构建块的概念：
- en: '**Target**: Target defines the length and properties of the child we wish to
    obtain after *n* generations.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标**：目标定义了我们希望在*n*代后获得的子代的长度和属性。'
- en: In our model, the target can be specified or unspecified.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的模型中，目标可以是指定的，也可以是未指定的。
- en: 'A specified target contains a length and its value:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个指定的目标包含一个长度和它的值：
- en: '[PRE0]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this case, our environment requires an exact gene set to remain fit in that environment.
    See the following fitness function.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的环境要求精确的基因集合以保持在该环境中的适应性。请参见下面的适应度函数。
- en: 'An unspecified target contains a length, but not its actual value, which must be
    found by the GA after *n* generations:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个未指定的目标包含一个长度，但没有其实际值，这必须通过GA在*n*代后找到：
- en: '[PRE1]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this case, our environment does not require an exact gene, but rather a gene
    with the features required to remain fit in that environment. See the following
    fitness function.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的环境不需要精确的基因，而是需要具有维持适应环境特征的基因。请参见下面的适应度函数。
- en: '**Population**: Population first defines the selection of an individual at
    random we will call **parent** that will contain a certain length of its string
    of genes:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**种群**：种群首先定义了一个随机选择的个体，我们称之为**父母**，它将包含一定长度的基因字符串：'
- en: '[PRE2]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Population also defines the potential individuals the parent can interact with to
    produce a child. In our genetic simulation, the size of the population is represented
    by the gene set of the population (see the following point).
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 种群还定义了父母可以与之互动以产生孩子的潜在个体。在我们的基因模拟中，种群的大小由种群的基因集合表示（请参见下面的点）。
- en: '**Gene set of the parent**: The gene set of the parent will first be a random
    set of genes.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**父母的基因集合**：父母的基因集合将首先是一个随机基因集合。'
- en: '**Gene set of the population**: This parent will then randomly encounter another
    person in the population with random gene choices. This population is represented
    by a gene set that we will draw genes from randomly:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**种群的基因集合**：这个父母将随机遇到种群中另一个具有随机基因选择的人。这个种群由一个基因集合表示，我们将从中随机抽取基因：'
- en: '[PRE3]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since a given population can possess any or several of these genes, our population
    is very large from the start.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于一个给定的种群可以拥有这些基因中的任意一个或多个，因此我们的种群从一开始就非常庞大。
- en: '**Selection**: We will select genes randomly from our gene set to simulate
    the meeting of our parent with another parent:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择**：我们将从我们的基因集合中随机选择基因，以模拟父母与另一个父母的相遇：'
- en: '[PRE4]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Crossover**: We will then form a child from the parent and the random gene
    taken from our population represented by the gene set.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交叉**：然后，我们将从父母和从种群中随机抽取的基因形成一个孩子，种群由基因集合表示。'
- en: 'In our model, once the random selection of the gene has been made, the gene will
    be replaced by a random gene taken from the population represented by the gene
    set of the population:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的模型中，一旦完成基因的随机选择，该基因将被种群中的随机基因替换，种群由基因集合表示：
- en: '[PRE5]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that the new gene must be different from the old gene during the crossover
    in our algorithm. Our algorithm thus avoids getting stuck in some local combination
    during the reproduction phase. Child after child, we will produce new generations.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，在我们的算法中的交叉过程中，新基因必须与旧基因不同。因此，我们的算法可以避免在繁殖阶段陷入某些局部组合。一个接一个的孩子，我们将不断产生新的世代。
- en: '**Mutation**: We will not accept the same gene from a parent to form a child.
    If we detect this, we will randomly change a gene to make sure each generation
    is different.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**突变**：我们不会接受来自父母相同的基因来形成孩子。如果我们检测到这种情况，我们将随机改变一个基因，以确保每一代都是不同的。'
- en: As described in the *Crossover* paragraph, we will not accept a child with the same
    genes as a parent. As seen in the heredity section of this chapter, it is unlikely
    that a child would inherit exactly all of the genes of a given parent. *Diversity*
    is the key to producing generation after generation of children that will adapt
    to their environment.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如*交叉*段落中所述，我们不会接受与父母基因完全相同的孩子。正如本章的遗传学部分所示，孩子继承父母的基因时，不太可能完全相同。*多样性*是产生一代又一代能够适应环境的孩子的关键。
- en: 'In our model, a diversity rule forcing mutation has been introduced:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的模型中，已引入强制突变的多样性规则：
- en: '[PRE6]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We thus introduce an alternate gene, as we will see while building the Python
    program.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我们引入了一个备用基因，正如我们在构建Python程序时将看到的那样。
- en: '**Child**: Child defines a set of genes that contains the same number of genes
    as the parent but with new genes. Generations of children of child gene strings
    will be produced and then complete the selection process with a fitness function.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**孩子**：孩子定义了一组基因，包含与父母相同数量的基因，但具有新的基因。通过一代代的孩子基因字符串，将会产生新的世代，并完成与适应度函数的选择过程。'
- en: '**Fitness**: Fitness defines the value of the child as defined in a given model.
    The fittest will then be selected to be the parent for the next generation.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适应度**：适应度定义了在给定模型中，后代的价值。最适应的个体将被选为下一代的父代。'
- en: In our model, we have two fitness functions that we define in a scenario variable.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的模型中，我们有两个适应度函数，这些函数由情境变量来定义。
- en: If `scenario=1`, then a specified target scenario will be activated. The target
    will be specified to fit the surrounding environment.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果`scenario=1`，则会激活指定的目标情境。该目标将根据周围环境进行指定，以适应环境。
- en: Polar bears became white, for example, to blend in with the surrounding snow
    and ice of their environment. In other areas, bears are often brown, for example,
    to blend in with the surrounding vegetation.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，极地熊变白是为了与周围的雪和冰融为一体，而在其他地区，熊通常是棕色的，例如为了与周围的植被融为一体。
- en: 'The fitness function thus has a target to reach. For example, in one instance
    in the program:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，适应度函数有一个目标需要达到。例如，在程序中的某个实例中：
- en: '[PRE7]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This target could mean many things, as we will see. In the case of the bears,
    maybe these genes in one of their chromosomes trigger off their color: white or
    brown.'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个目标可能意味着许多事情，正如我们所看到的。对于熊来说，也许它们染色体中的某些基因会触发它们的颜色：白色或棕色。
- en: If our program simulating nature does not produce the right gene in a given generation,
    this means that the bear is not mutating correctly and will not survive. The fitness
    function of the Python program simulates nature by only keeping the strings of
    genes that make the child evolve in the right direction.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们模拟自然的程序在给定的代中没有产生正确的基因，意味着熊没有正确变异，并且将无法生存。Python程序的适应度函数通过仅保留使后代朝正确方向进化的基因字符串，模拟自然选择。
- en: The specified target, in this case, is an identified string of genes that will
    make a life-and-death difference.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，指定的目标是一个已识别的基因串，它将决定生死存亡。
- en: '[PRE8]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we will see later, `scenario==1` will make sure that the exact gene set required
    to survive is reached.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如我们稍后将看到的，`scenario==1`将确保达到生存所需的精确基因集合。
- en: 'If `scenario=0`, then an unspecified target will be activated. The length of
    the target is not specified. However, a feature set will define the value of the gene
    set of the population. This feature contains numerical values that open the door
    to any optimization you wish to solve, as we will see in the Python program example.
    This numerical set is called the KPI set because the values are key performance
    indicators of the system we will explore in this model:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果`scenario=0`，则会激活一个未指定的目标。目标的长度未指定。然而，特征集将定义种群的基因集的值。这个特征包含数值，能为你希望解决的任何优化问题打开大门，正如我们在Python程序示例中所看到的那样。这个数值集合被称为KPI集，因为这些值是我们将在模型中探索的系统的关键性能指标：
- en: '[PRE9]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `KPIset` feature set matches the size of the gene set of the population.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`KPIset`特征集与种群的基因集大小匹配。'
- en: Building a genetic algorithm in Python
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Python中构建遗传算法
- en: We will now build a GA from scratch using `GA.ipynb`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将从零开始构建一个遗传算法（GA），使用`GA.ipynb`。
- en: You can use the `.py` version. The code is the same, although the line numbers
    in this chapter refer to the Jupyter notebook cells of the `.ipynb` version.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`.py`版本。代码是相同的，尽管本章中的行号是指`.ipynb`版本的Jupyter notebook单元。
- en: At all times, you can go back to the previous section, *Basic concepts*, to
    consult the definitions used to describe the Python program in the following sections.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 随时可以返回到前一部分，*基本概念*，查阅用于描述后续部分中Python程序的定义。
- en: Importing the libraries
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入库
- en: 'This program is built from scratch with no higher-level library to get the
    feel of a GA. Three lines are enough to get everything working:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序从零开始构建，没有使用任何高级库，以便更好地理解遗传算法。三行代码足以让一切运行起来：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Calling the algorithm
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用算法
- en: In this program, we will be exploring three scenarios. Two scenarios generate
    specified targets, and one generates an unspecified target.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们将探索三种情境。两种情境生成指定目标，一种生成未指定目标。
- en: We will begin with a specified target and then move to the more advanced unspecified
    target that will prepare us for hybrid networks using a GA.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从指定的目标开始，然后转向更高级的未指定目标，这将为我们使用遗传算法（GA）构建混合网络做准备。
- en: 'We will first go to the *Calling the Algorithm* cell of the program. The first
    task is to define which scenario and type of fitness function we will use on line
    3:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先进入程序的*调用算法*单元。第一步是定义我们将在第3行使用的情境类型和适应度函数类型：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If `scenario=1`, the program generates the correct exact genes for a child from
    several generations, starting with a random seed parent.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`scenario=1`，程序将生成确切的基因以形成一个具有几代的随机种子父代的子代。
- en: If `scenario=0`, the program generates the best features of a type of genes
    of a child from several generations, starting with a random seed parent.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`scenario=0`，程序将生成一个具有一系列代的随机种子父代的基因类型的最佳特征。
- en: In line 4, `GA=2` defines which target we are dealing with.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4行，`GA=2`定义了我们正在处理的目标。
- en: 'If `GA=1`, the gene set of the population and the target are defined. The main function
    is called:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`GA=1`，则定义了种群的基因集和目标。调用主函数：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At this point, the gene set of the population is printed along with the target:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，打印出了种群的基因集以及目标：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The last line calls `ga_main()`, the main function.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行调用了`ga_main()`，即主函数。
- en: The main function
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主函数
- en: The code is in the `ga_main()` cell of the program.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的`ga_main()`单元格中的代码。
- en: 'The `ga_main()` function is divided into three parts: parent generation, child
    generation, and a summary.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`ga_main()`函数分为三个部分：父代生成、子代生成和总结。'
- en: The parent generation process
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 父代生成过程
- en: 'The parent generation runs from line 2 to line 7:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 父代生成从第2行到第7行运行：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`startTime` indicates the start time, which is printed:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startTime`指示了开始时间，该时间被打印出来：'
- en: '[PRE15]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`alphaParent` is the first parent who will be created by the `gen_parent` function,
    which will be described in the following Jupyter notebook cell.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alphaParent`是由后续的Jupyter笔记本单元格中描述的`gen_parent`函数创建的第一个父代。'
- en: '`bestFitness` is the fitness estimated by the `get_fitness` function, which
    will be described in this chapter.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bestFitness`是由`get_fitness`函数估算的适应度，在本章节中将对其进行描述。'
- en: '`display` is the function that describes the result of this process.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display`函数描述了这个过程的结果。'
- en: 'We now have a process that creates a parent: `gen_parent`, `get_fitness`, and
    `display`.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个创建父代的过程：`gen_parent`，`get_fitness`和`display`。
- en: We will now explore the parent generation function before resuming the main
    function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在继续主函数之前探索一下父代生成函数。
- en: Generating a parent
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成一个父代
- en: 'The parent generation function cell starts with zero genes and the length of
    the target:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 父代生成函数单元格以零基因和目标长度开始：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`length` = the length of the target. The target is `"Algorithm"`, so `length=9`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`length` = 目标的长度。目标是`"Algorithm"`，因此`length=9`。'
- en: At the beginning of the process, the parent has no genes since the goal of this
    function is to produce a parent at random that contains a string of genes that
    is equal to the length of the target.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程的开始阶段，由于这个函数的目标是随机产生一个包含与目标长度相等的基因字符串的父代，因此父代没有基因。
- en: 'The string of genes to produce a parent is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个父代的基因字符串如下：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, a `while` loop starts on line 3 of the cell to fill `genes[]` until it
    reaches the target''s length:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在单元格的第3行开始`while`循环以填充`genes[]`，直到达到目标的长度：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`sampleSize` is the sample of genes required from the gene set, `geneSet`,
    from which to choose a random gene for the parent.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sampleSize`是从基因集`geneSet`中需要的基因样本，用于为父代选择一个随机基因。'
- en: '`genes.extend` adds a random gene to the `genes` array from `geneSet`.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`genes.extend`从`geneSet`中添加一个随机基因到`genes`数组中。'
- en: 'Once the parent''s gene set, `genes[]`, has reached the target''s length, the
    `return` function sends the parent back to the main function, `ga_main()`, where
    it is displayed with the `display` function. The output of the parent in this
    random run was:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦父代的基因集`genes[]`达到了目标的长度，`return`函数将父代发送回主函数`ga_main()`，在那里它将通过`display`函数显示。这次随机运行中父代的输出是：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Naturally, the parent will be different at each run since this is a random process.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，每次运行时父代都会有所不同，因为这是一个随机过程。
- en: 'The string of genes is now returned to the `ga_main()` function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，基因字符串返回到`ga_main()`函数：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, let's explore the fitness function and the `display` function.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索一下适应度函数和`display`函数。
- en: Fitness
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 适应度
- en: 'At this point in the `ga_main()` function, the start time was printed out,
    and the parent created:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ga_main()`函数的这一点上，打印出了开始时间，并创建了父级：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We need to evaluate the fitness of the parent before creating generations of
    children:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建子代的多代之前，我们需要评估父代的适应度：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this paragraph, we will only describe the specified target case, which is
    part of `scenario=1`. We will create a fitness function with the target of a given
    choice. In this case, only the sum of correct genes is calculated:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一段中，我们将只描述指定的目标案例，这是`scenario=1`的一部分。我们将创建一个以给定选择为目标的适应度函数。在这种情况下，只计算正确基因的和：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`this_choice` is the parent string of genes produced by the `gen_parent` function
    described in the preceding code snippet.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this_choice`是由前面的代码片段中描述的`gen_parent`函数生成的父代基因字符串。'
- en: '`scenario` indicates whether the function calculates the sum of fit genes or
    evaluates the features of the genes. In this case, the sum of the correct genes
    is calculated.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scenario`表示该函数是计算适应基因的和，还是评估基因的特征。在本例中，计算的是正确基因的和。'
- en: Fitness is the number of correct genes found when comparing the target, the expected
    value, to actual, the `this_choice` variable.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适应度是通过将目标（预期值）与实际值（`this_choice`变量）进行比较时，找到的正确基因的数量。
- en: If `expected==actual`, the sum is incremented.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`expected==actual`，则和会增加。
- en: '`zip`, in Python, is an efficient feature that iterates over two lists at the
    same time.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zip`在Python中是一个高效的功能，它可以同时遍历两个列表。'
- en: 'Once fitness, the sum of fit genes, is calculated, the function returns the
    value to the `ga_main()` function:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计算出适应度（适应基因的和），函数将返回该值到`ga_main()`函数：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The parent generation will now be displayed by a function called in `main_ga()`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 父代将通过`main_ga()`中的一个函数进行显示。
- en: Display parent
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示父代
- en: 'At this point, `ga_main()` has printed the start time, created a parent, and
    evaluated its fitness:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`ga_main()`已打印了开始时间，创建了一个父代，并评估了其适应度：
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The program will now display the basic information concerning the first generation:
    the parent generation called the `display` function from `main_ga()`, line 7:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 程序现在将显示第一代的基本信息：父代调用了来自`main_ga()`的`display`函数，第7行：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`alphaParent` is the gene string of the parent'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alphaParent`是父代的基因字符串'
- en: '`bestFitness` is its fitness'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bestFitness`是其适应度'
- en: Since there is no child yet, `bestFitness` is sent as the default value of a
    child's fitness
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于还没有子代，`bestFitness`作为子代适应度的默认值被发送。
- en: '`startTime`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startTime`'
- en: 'In the display parent cell, line 2, the `display` function receives the data
    sent by `main_ga()`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示父代单元格中，第2行，`display`函数接收了由`main_ga()`发送的数据：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `display` function calculates the time it has taken and prints the information
    in a few lines:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`display`函数计算它所用的时间，并在几行中打印出信息：'
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`selection` is the string of genes of this generation.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selection`是这一代的基因字符串。'
- en: '`bestFitness` is the value of the best string of genes created up to now.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bestFitness`是迄今为止创建的最佳基因字符串的值。'
- en: '`childFitness` is this generation''s fitness value. The first generation is
    the value of the parent who has, for the moment, the fittest genes. The parent
    is the child of another parent, although this parent is the first generation we are
    taking into consideration.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`childFitness`是这一代的适应度值。第一代的适应度是父代的适应度，父代目前拥有最适合的基因。父代是另一个父代的子代，尽管这个父代是我们目前考虑的第一代。'
- en: '`timeDiff` is an important value when dealing with larger gene sets. It will
    help detect whether the algorithm is running well or reaching its limit.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeDiff`是处理较大基因集时的重要值。它将有助于检测算法是否运行良好或是否已达到极限。'
- en: 'The output will be displayed for the parent generation and each generation
    that gets closer to the fittest generation defined by the target:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将显示父代的基因以及每一代更接近目标所定义的最适应代：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This output will vary during each run of the program since this is a stochastic
    algorithm simulating the random events that occur in our natural and artificial
    environments.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出会在每次程序运行时有所变化，因为这是一个随机算法，模拟了我们自然和人工环境中发生的随机事件。
- en: Before exploring the loop that creates an unlimited number of generations, let's
    build the crossover function.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索创建无限代的循环之前，让我们先构建交叉函数。
- en: Crossover and mutation
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交叉和变异
- en: Our model contains a `crossover` function with a mutation rule to ensure diversity.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模型包含一个带有变异规则的`crossover`函数，以确保多样性。
- en: The `crossover` function starts with the parent.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`crossover`函数从父代开始。'
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Each child of each generation will become the parent of another child.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 每一代的每一个子代将成为另一子代的父代。
- en: 'As in nature, a random gene in a parent''s gene will be selected to be replaced:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如同自然界中一样，父代基因中的一个随机基因将被选中进行替换：
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `index` designates the exact location of the gene that will be replaced:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`index`指定将被替换的基因的确切位置：'
- en: '![](img/B15438_17_01.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15438_17_01.png)'
- en: 'Figure 17.2: Chromosomes in genes'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.2：基因中的染色体
- en: We can see that gene **D** in the chromosome will be replaced by the gene **z**
    of an individual of the population.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，染色体中的基因**D**将被种群中个体的基因**z**所替代。
- en: 'Now, we simulate the reproduction phase. The child inherits the genes of its
    parent:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们模拟繁殖阶段。子代继承父代的基因：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The parent's string of genes is converted into a list with the `list` function.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 父代的基因串通过`list`函数转换为一个列表。
- en: 'The algorithm stores the parent''s gene to replace in a variable:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 算法将父代的基因存储到一个变量中，以便替换：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`oldGene` will be compared to the new gene generated to make sure that diversity
    is respected so as to avoid getting stuck in a local loop.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`oldGene`将与新生成的基因进行比较，以确保多样性得到尊重，从而避免陷入局部循环。'
- en: 'A new gene is chosen at random in the gene set of the population to simulate
    the interaction of the child with a given person among an indefinite number of
    persons:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在种群的基因集中随机选择一个新基因，模拟子代与某个个体之间的相互作用，个体数量无限：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice that at the same time, the new gene, `newGene`, is selected at random,
    while an alternate gene, `alternate`, is chosen as well. `alternate` is chosen
    to replace `newGene` to avoid making the wrong choice.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在此过程中，新的基因`newGene`会被随机选择，同时一个备用基因`alternate`也会被选择。`alternate`被选中来替换`newGene`，以避免做出错误的选择。
- en: 'If the new gene, `newGene`, is not equal to the old gene, `oldGene`, that the
    child can inherit:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新基因`newGene`与旧基因`oldGene`不同，那么子代可以继承新基因：
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The new gene becomes part of the string of genes of the child.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 新基因成为子代基因串的一部分。
- en: However, if `newGene` is the same as `oldGene`, this could compromise the whole
    genetic process, with generations of children that do not evolve. Also, the algorithm
    might get stuck or waste quite some time making the right selections.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果`newGene`与`oldGene`相同，这可能会影响整个遗传过程，导致代代相传的子代没有进化。此外，算法可能会陷入困境或浪费大量时间做出正确选择。
- en: This is where the alternate gene comes in and becomes part of the string of
    genes of the child. This crossover rule and this alternate rule simulates the
    mutation process of this model.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这里备用基因的作用开始显现，并成为子代基因串的一部分。这个交叉规则和备用规则模拟了该模型的变异过程。
- en: '[PRE36]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Diversity has been verified!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 多样性已得到验证！
- en: 'The function now returns the new string of genes of the child so that its fitness
    value can be calculated:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数现在返回子代的基因新串，以便可以计算其适应度值：
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Producing generations of children
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成子代的多代
- en: At this point, we have generated the parent and explored the basic concepts
    and functions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经生成了父代并探讨了基本概念和函数。
- en: We are ready for the generation loop. First, we will view the code, then represent
    it in a flowchart, and then describe the lines of code.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已准备好进入代数循环。首先，我们将查看代码，然后用流程图表示，并描述代码的各行。
- en: 'Once the parent has been created, we enter the loop that simulates the evolutionary
    process for many generations:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦父代被创建，我们进入循环，模拟多代的进化过程：
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The loop is best represented in a flowchart:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 该循环最适合用流程图表示：
- en: '![](img/B15438_17_03.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15438_17_03.png)'
- en: 'Figure 17.3: Genetic algorithm flow chart'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.3：遗传算法流程图
- en: 'The process of the flowchart is based on Python''s `continue` method:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 流程图中的过程基于Python的`continue`方法：
- en: 'The code that precedes the condition:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 条件之前的代码：
- en: 'Increments the generation counter:'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加代数计数器：
- en: '[PRE39]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Calls the `crossover` function to produce a child:'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`crossover`函数生成子代：
- en: '[PRE40]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Calls the fitness function to obtain the fitness value:'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用适应度函数以获取适应度值：
- en: '[PRE41]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The condition to see if the `childFitness` is higher than the `bestFitness`
    obtained:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断`childFitness`是否高于获得的`bestFitness`的条件：
- en: '[PRE42]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If the condition is `True`, then the evolution must continue until a child is
    fitter than its parent. This sends the process back to the top of the `while`
    loop.
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果条件为`True`，则进化必须继续，直到子代比父代更适应。这样就会将过程发送回`while`循环的顶部。
- en: If the condition is `False`, this means that the child is fitter than the parent,
    and then the code will go beyond the condition.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果条件为`False`，则意味着子代比父代适应度更高，此时代码将跳出条件。
- en: 'The code beyond the condition and `continue` method:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 条件和`continue`方法之外的代码：
- en: 'The code displays the child, the `bestFitness` becomes the `childFitness`,
    and the `bestParent` is now the child:'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码显示了子代，`bestFitness`变为`childFitness`，而`bestParent`现在是子代：
- en: '[PRE43]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The goal of the two scenarios of our model is defined. The goal of `scenario==1`
    is to reach the length of the target with the right genes. The goal of `scenario==0`
    will be to reach a threshold we will define in the next section:'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们模型的两个场景目标已定义。`scenario==1`的目标是通过正确的基因达到目标长度。`scenario==0`的目标是达到我们将在下一节中定义的阈值：
- en: '[PRE44]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `break` condition of the loop:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环的`break`条件：
- en: 'The evolutionary process will stop when the fittest child has been created
    after several generations containing the genes that meet the target:'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当适应度最强的子代在多个包含满足目标基因的代之后被创建时，进化过程将停止：
- en: '[PRE45]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output of the *n* generations will appear as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*代的输出将如下所示：'
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We can see the display of all of the generations as described in the `display`
    function in the *Display parent* section of this chapter.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到在本章的*Display parent*部分中`display`函数所描述的所有代的展示。
- en: Summary code
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 汇总代码
- en: 'Once the evolutionary process is over, a summary code takes over:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进化过程结束，汇总代码将接管：
- en: '[PRE47]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The output for the example displayed for the evolutionary loop is:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 进化循环的示例输出为：
- en: '[PRE48]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Before we move on, it is important to note that using permutations for 9 out
    of 55 elements, it would take 10 ** 15.36 calculations to reach the goal instead
    of the 782 generations in this example. GAs are thus a productive way of generating
    permutations.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，需要指出的是，对于55个元素中的9个元素使用排列时，为了达到目标，需要进行10 ** 15.36次计算，而不是在本示例中的782代。因此，遗传算法是生成排列的有效方式。
- en: We have now explored the core of the evolutionary process and the Python code.
    We will now build the unspecified target and optimizing code that will lead us
    to hybrid neural networks.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经探讨了进化过程的核心和Python代码。接下来，我们将构建未指定的目标和优化代码，这将引导我们进入混合神经网络的领域。
- en: Unspecified target to optimize the architecture of a neural network with a genetic
    algorithm
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未指定的目标用于优化神经网络的架构，采用遗传算法
- en: In this section, we are laying the grounds and motivation to optimize the architecture of
    neural networks through a hybrid neural network. The architecture of a physical
    neural network will be optimized by a GA.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们为通过混合神经网络优化神经网络架构奠定了基础和动机。物理神经网络的架构将通过遗传算法进行优化。
- en: We will study a physical neural network and then see how to optimize its architecture
    with our GA.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究一个物理神经网络，并通过遗传算法优化其架构。
- en: A physical neural network
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个物理神经网络
- en: 'We will begin with a physical network named S-FNN, a **feedforward neural network**
    (**FNN**). Please look very closely at the following figure and take as much time
    as necessary to understand its architecture:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个名为S-FNN的物理网络开始，这是一个**前馈神经网络**（**FNN**）。请仔细观察以下图像，并花足够的时间理解其架构：
- en: '![](img/B15438_17_04.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15438_17_04.png)'
- en: 'Figure 17.4: Architecture of a neural network'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.4：神经网络的架构
- en: 'This physical network has some important specific features:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个物理网络具有一些重要的特定特征：
- en: This is an FNN
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个前馈神经网络（FNN）
- en: There are three layers.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共有三层。
- en: The neurons in each layer are not fully connected to the neurons of the next layer.
    The connections between the neurons of the three layers are not based on all of
    the possibilities. The connections between the layers are based upon statistics
    of the best connections in the past when running this network.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一层的神经元并非与下一层的所有神经元完全连接。三层之间的连接并非基于所有的可能性，而是基于过去运行此网络时，最优连接的统计结果。
- en: The connections are the result of many runs of this network to determine which
    ones are the best.
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 连接是通过多次运行该网络得到的，目的是确定哪些连接是最佳的。
- en: The connections represented are the most productive ones, leading to an output
    of `1` and not `0`. An output of `1` is a success, while an output of `0` is a
    failure.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里表示的连接是最具生产力的连接，导致输出为`1`而非`0`。输出为`1`表示成功，而输出为`0`表示失败。
- en: The input is a random value of the dataset that must be classified as `1` if
    it is a success and `0` if it is a failure.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入是数据集中的随机值，若为成功则必须分类为`1`，若为失败则分类为`0`。
- en: After a careful study of past runs of this network, it has been found that the productivity
    of the network fully relies, in this example, on the number and quality of the
    neurons in layer 2.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经过对该网络过去运行的仔细研究，发现该网络的生产力在本示例中完全依赖于第二层中神经元的数量和质量。
- en: Let's use what we have learned and apply it to the architecture of a soccer
    team.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用所学知识，将其应用到足球队的架构中。
- en: What is the nature of this mysterious S-FNN?
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这个神秘的S-FNN本质是什么？
- en: S-FNN is a soccer team's architecture! It is the representation of a 3-4-3 disposition
    of a soccer team before a given game.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: S-FNN是一个足球队的架构！它是给定比赛前，足球队3-4-3阵型的表示。
- en: Like abstract neural networks, the number and quality of neurons we choose per
    layer are critical. In our abstract world of **artificial neural networks** (**ANNs**),
    we have many problems to solve. How many should we keep? How many should we eliminate
    through pooling layers? How many should we abandon through dropout layers? How
    do we really know? How long will trial and error take with large datasets and
    networks?
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 像抽象神经网络一样，我们为每一层选择的神经元数量和质量至关重要。在我们这个抽象的**人工神经网络**（**ANNs**）世界中，有许多问题需要解决。我们应该保留多少个？应该通过池化层消除多少个？通过丢弃层应该放弃多少个？我们怎么知道呢？在处理大数据集和大网络时，试验和错误需要多长时间？
- en: 'Now, let''s go back to the figure, read the following explanation, and start
    finding a method to solve the architectural complexity of a neural network:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到图表，阅读以下解释，并开始寻找解决神经网络架构复杂性的方法：
- en: '**Input** represents the goal of best possible choices to input the ball in
    the game based on past game statistics.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入**代表基于过去比赛统计数据，输入比赛中的最佳选择目标。'
- en: '**Layer 1** is the defense layer of three players represented by three neurons.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第1层**是由三个神经元表示的防守层，包含三个球员。'
- en: '**Layer 2** is the middle field, the result of the transformation of layer
    1''s activity, the statistics of past games showing the fittest, the connections.
    The initial ball of the input has now been flowing through these layers game after
    game.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第2层**是中场，是第1层活动的转化结果，过去比赛的统计数据展示了最适合的连接。输入的初始球已经在这些层之间流动，经过每场比赛的演变。'
- en: '**Layer 3** is the attack layer, the one that will lead to the output classification;
    1 for a success meaning a goal has been scored, or 0 for failure. The connections
    between layer 2 and layer 3 show the fittest results found game after game.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第3层**是攻击层，它决定了输出的分类；1代表成功，表示进球，0则表示失败。第2层与第3层之间的连接展示了每场比赛中找到的最适合的结果。'
- en: '**The problem to solve**: Layer 2, in our example, has been identified as the
    critical layer in this team. For years now, it has been a weak point. Let''s see
    how our GA will help find the fittest players for this layer.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**待解决的问题**：在我们的例子中，第2层已被确定为该队的关键层。多年来，它一直是一个弱点。让我们看看我们的遗传算法如何帮助找到这一层的最适合球员。'
- en: 'We could run `scenario==1` (specified target) with target `ga==3` as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照如下方式运行`scenario==1`（指定目标），目标是`ga==3`：
- en: '[PRE49]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `geneSet` is the population of available players on the soccer market and
    `target` is the string of genes we need for layer 2 of our physical network:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`geneSet`是足球市场上所有可用球员的种群，`target`是我们物理网络第2层所需的基因串：'
- en: '[PRE50]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The target is found after 851 generations in this run.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 该目标在本次运行中经过851代后找到。
- en: However, we would like the GA to find the players by itself based on the features
    with an unspecified target. Let's explore this step by step, cell by cell.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们希望遗传算法（GA）能够根据特征自行找到球员，而不指定目标。让我们一步步地探索这一过程，每次细胞地分析。
- en: Calling the algorithm cell
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用算法单元
- en: 'From lines 7 to 12, we defined the parameters of the target architecture we
    want for layer 2 of our network:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 从第7行到第12行，我们定义了第2层网络所需的目标架构的参数：
- en: '`geneSet` is the set of all the available players for layer 2 of our network,
    whether they are in the team or on the market:'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geneSet`是我们网络第2层所有可用球员的集合，无论他们是在队内还是在市场上：'
- en: '[PRE51]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`KPIset`, or the key performance indicator set, is a performance score per
    player on the market for middle field. Each integer of the set contains a score
    between 0 and 9 based on the statistics of a player when playing as a midfielder:'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KPIset`，即关键绩效指标集，是每个球员在中场市场上的表现分数。该集的每个整数包含一个0到9之间的分数，基于球员在担任中场时的比赛统计数据：'
- en: '[PRE52]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The KPI set matches each member of the gene set.
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: KPI集与基因集中的每个成员相匹配。
- en: '`threshold` is the sum of the midfielders'' performance we need to attain in
    order to have a strong midfield in the team.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threshold`是我们需要达到的中场球员表现总和，才能在队伍中建立强大的中场。'
- en: '[PRE53]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Our goal is to find a string of genes based on their features, their KPI properties.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是根据基因的特征和KPI属性找到一串基因。
- en: The goal is to reach the threshold.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是达到阈值。
- en: 'We call our evolutionary function on line 23:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第23行调用了我们的进化函数：
- en: '[PRE54]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As you can see, `target` is set to a meaningless value that will rapidly evolve.
    The GA will have to find a fit sequence.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`target`被设置为一个没有意义的值，这个值将迅速演化。遗传算法（GA）将需要找到一个适应的序列。
- en: We can skip the intermediate fitness functions we have described in the previous
    section and focus on the scenarios within the fitness cell.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以跳过前一节中描述的中间适应度函数，集中在适应度单元中的场景上。
- en: Fitness cell
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 适应度单元
- en: We have already described the fitness function of the fitness cell in the previous
    sections. We will focus on the code of the unspecified target, `scenario==0`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在前面的章节中描述了适应度单元的适应度函数。我们将专注于未指定目标的代码，即`scenario==0`。
- en: 'The first part of the scenario calculates the sum of the performance of each
    gene (potential midfielder):'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 场景的第一部分计算每个基因（潜在中场球员）的表现之和：
- en: '[PRE55]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The collective fitness of the sequence of genes (midfielders) is contained in
    the `fitness` variable.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 基因序列（中场球员）的集体适应度存储在`fitness`变量中。
- en: 'However, we cannot accept the same gene twice, which would mean we have a clone of
    the midfielder on the field! So, we add some safety code to set `fitness` to `0`
    in that case:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不能接受相同的基因两次，否则就意味着我们在场上有了一个中场球员的克隆！因此，我们添加了一些安全代码，在这种情况下将`fitness`设置为`0`：
- en: '[PRE56]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now, we can go back to `ga_main()` and complete our process.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以回到`ga_main()`并完成我们的过程。
- en: ga_main() cell
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ga_main()`单元'
- en: We have already described the fitness cell in the previous sections. Now, we
    will focus on the code of the unspecified target, `scenario==0`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在前面的章节中描述了适应度单元。现在，我们将专注于未指定目标的代码，即`scenario==0`。
- en: 'In the `ga_main()` cell, we simply need to examine lines 22 to 24:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ga_main()`单元中，我们只需要检查第22到第24行：
- en: '[PRE57]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If the `scenario==0`, `childFitness` must be `>=goal` (sum of KPIs).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`scenario==0`，则`childFitness`必须`>=goal`（KPI总和）。
- en: We have found our midfielders!
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经找到了我们的中场球员！
- en: 'We will now display the result:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将显示结果：
- en: '[PRE58]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this case, the GA chose midfielders C, B, F, and D.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，遗传算法（GA）选择了中场球员C、B、F和D。
- en: We now have all of the ingredients, concepts, and knowledge required to understand an
    artificial hybrid neural network.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了理解人工混合神经网络所需的所有成分、概念和知识。
- en: Artificial hybrid neural networks
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工混合神经网络
- en: In the previous section, we used a GA to optimize a physical neural network.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们使用遗传算法（GA）优化了一个物理神经网络。
- en: In this section, we will extend the concept of *hybrid* we have just explored
    to ANNs. The principle is the same, so it will be relatively easy, with the concepts
    you now have in mind, to intuitively grasp the RNN we will optimize in this section.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将把刚刚探索过的*混合*概念扩展到人工神经网络（ANNs）。原则是相同的，因此，凭借你现在掌握的概念，你将能够直观地理解我们在本节中将要优化的递归神经网络（RNN）。
- en: The future of AI in society lies in the collective intelligence of humans (diversity),
    machines (AI and IoT), and nature (sustainable projects for our survival).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能在社会中的未来依赖于人类（多样性）、机器（人工智能和物联网）以及自然（可持续的生存项目）之间的集体智慧。
- en: In AI, this diversity lies in ensemble algorithms, meta-algorithms and hybrid
    systems. Deep learning has proven its point. We can create a neural network with
    TensorFlow 2.x in a few lines. However, more often than not, it takes days, weeks,
    and often months to fine-tune ANN models that rely on large amounts of data to
    provide a reliable model. And that's where hybrid neural networks are necessary.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在人工智能领域，这种多样性体现在集成算法、元算法和混合系统中。深度学习已经证明了其有效性。我们可以在几行代码中使用TensorFlow 2.x创建一个神经网络。然而，往往需要花费数天、数周，甚至数月的时间来微调依赖大量数据的人工神经网络（ANN）模型，以提供可靠的模型。这就是混合神经网络必要的原因。
- en: 'A deep learning network can use any form of another type of algorithm to become
    a more efficient system. In our case, we have chosen evolutionary algorithms that
    could be used in deep learning:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 深度学习网络可以使用任何形式的其他类型算法来成为一个更高效的系统。在我们的案例中，我们选择了进化算法，这些算法可以用于深度学习：
- en: To improve the input by extracting sequences of data that fit the patterns we are
    looking for using features of the data to find the fittest data points
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用数据特征来提取符合我们寻找的模式的数据序列，从而改善输入，找到最适应的数据点
- en: To optimize the weights of the layers of a network to boost the speed and power
    of traditional optimizers
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化网络层的权重，以提升传统优化器的速度和性能
- en: To improve the classification phase of the output of a network by selecting
    the fittest solutions processed as a sequence of genes
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过选择作为基因序列处理的最适应解决方案，来改进网络输出的分类阶段
- en: To improve the tedious task of defining the architecture of a network
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进定义网络架构的繁琐任务
- en: 'In this section, we will focus on an example of optimizing the architecture
    of a network with a GA by:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将专注于通过遗传算法优化网络架构的示例：
- en: Creating the RNN
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建RNN
- en: Introducing a GA that will optimize the architecture of the network
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入一个遗传算法，它将优化网络架构
- en: '**Note**: For information on genetic algorithm representations, please go back
    to the previous sections at all times to refresh the process of an evolutionary
    algorithm. Please also refer back to the previous chapters to consult the structure
    of a neural network, in particular, *Chapter 16*, *Improving the Emotional Intelligence
    Deficiencies of Chatbots*, which describes an RNN.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：有关遗传算法表示的信息，请随时返回前面的章节以刷新进化算法的过程。还请参考前面的章节查阅神经网络的结构，特别是*第16章*，*改进聊天机器人情感智能缺陷*，其中描述了RNN。'
- en: Building the LSTM
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建LSTM
- en: Open `Genetic_Algorithm_LSTM.ipynb` in Google Colaboratory or Jupyter on your machine
    or `genetic_algorithm_lstm.py`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在Google Colaboratory或本地机器上的Jupyter中打开`Genetic_Algorithm_LSTM.ipynb`，或打开`genetic_algorithm_lstm.py`。
- en: The model of this education example is an LSTM.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 本教育示例的模型是LSTM。
- en: The goal will be to use the window size generated by the GA and run the LSTM
    with this window size. **Root-mean-square error** (**RMSE**) will be used to measure
    the fitness of the configuration.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是使用GA生成的窗口大小并以此窗口大小运行LSTM。**均方根误差**（**RMSE**）将用于衡量配置的适应度。
- en: In short, RMSE first calculates the square of the difference between the training
    data and the testing data, like many similar formulas. Then, the root of the result
    is calculated. Just keep in mind that the RMSE will compare what we expect to
    get with what we actually get and produce a value.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，RMSE首先计算训练数据和测试数据之间差异的平方，就像许多类似的公式一样。然后，计算结果的平方根。只需记住，RMSE将比较我们期望得到的结果与实际得到的结果，并生成一个值。
- en: 'Let''s now explore the main cells of the program:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来探索程序的主要单元：
- en: '**Importing required packages cell**: `Genetic_Algorithm_LSTM.ipynb` starts by
    installing DEAP, an evolutionary computation framework:'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导入所需包单元**：`Genetic_Algorithm_LSTM.ipynb`首先安装DEAP，一个进化计算框架：'
- en: '[PRE59]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We built a GA from scratch in the previous sections. We won't need to begin from
    nothing this time, since this program uses a framework.
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在前面章节中从零开始构建了一个遗传算法。这次我们不需要从头开始，因为这个程序使用了一个框架。
- en: Then, the program installs `bitstring`, which helps to process binary data.
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，程序安装了`bitstring`，它有助于处理二进制数据。
- en: '**Loading the data cell**: The data wind power forecast data in `train.csv`
    comes from [https://www.kaggle.com/c/GEF2012-wind-forecasting/data](https://www.kaggle.com/c/GEF2012-wind-forecasting/data).'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加载数据单元**：数据中的风力预测数据来自`train.csv`，数据源为[https://www.kaggle.com/c/GEF2012-wind-forecasting/data](https://www.kaggle.com/c/GEF2012-wind-forecasting/data)。'
- en: The `wp1` to `wp7` columns provide normalized data collected from measurements
    of the wind power of seven wind farms. The goal of the LSTM will be to take the
    sequence of data and make wind power forecasts.
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`wp1`到`wp7`列提供了从七个风电场收集的风力发电测量的归一化数据。LSTM的目标是接收这一数据序列并进行风力发电预测。'
- en: '**Defining the basic functions cell**: This cell prepares the dataset and trains
    the model in a standard process. We will focus on line 14:'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义基本函数单元**：该单元准备数据集并以标准过程训练模型。我们将重点关注第14行：'
- en: '[PRE60]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**Evolutionary model cell**: The model uses the DEAP framework function, but we
    easily recognize the concepts we explored in the previous sections and that are
    initialized as follows:'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进化模型单元**：该模型使用DEAP框架函数，但我们可以轻松识别我们在前面章节中探讨过的概念，并按如下方式初始化：'
- en: '[PRE61]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The code is all set with a ready-to-use GA to optimize the window size for our
    network.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 代码已经设置好，配备了一个现成的遗传算法来优化我们网络的窗口大小。
- en: The goal of the model
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型的目标
- en: As in our previous section, the goal is to find the best window size for this
    network, just as we were looking for the best layer 2 in an earlier section.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的章节一样，目标是为这个网络找到最佳窗口大小，就像我们在早些章节中寻找最佳的第2层一样。
- en: 'The model has done the following tasks:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型已完成以下任务：
- en: Installed the packages, loaded the data, and found the window size of the LSTM
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了包，加载了数据，并找到了LSTM的窗口大小
- en: Then, it ran the GA model to test the possible window size of the LSTM
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，运行遗传算法模型来测试LSTM的可能窗口大小
- en: An RMSE measurement is provided with each generation and production of epochs
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一代和每个训练周期都会提供一个RMSE测量值
- en: 'The program takes some time to run, but the results I ran are saved in the
    notebook so that you can view them. Here is one result to view how the system
    works:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 程序需要一些时间运行，但我运行的结果保存在笔记本中，供你查看。这里有一个结果，供你查看系统是如何工作的：
- en: '[PRE62]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As in the previous section, a GA optimized a section of an ANN. You can use
    a GA for other components of an ANN. The sky is the limit! In fact, there is no
    limit. The potential of hybrid neural networks using GA or other algorithms to
    optimize their architecture or process takes your projects to another level!
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如同上一节所述，遗传算法优化了人工神经网络（ANN）的一个部分。你可以使用遗传算法优化人工神经网络的其他部分。天高地远！事实上，没有限制。使用遗传算法或其他算法优化架构或过程的混合神经网络将把你的项目带到另一个层次！
- en: Summary
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Evolutionary algorithms bring new light to AI's optimizing potential. In this
    chapter, we studied how heredity deeply affects population distribution. The impact
    of our environment can be measured through genetic mutations.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 进化算法为人工智能（AI）的优化潜力带来了新的光辉。本章中，我们研究了遗传如何深刻影响种群分布。环境的影响可以通过基因突变来衡量。
- en: Drilling down further, we focused on a class of GAs implementing a simulation
    of genetic transformations through many generations. We explored how a parent
    will transmit some genes, but how the selection of diverse genes from the generation
    population of genes will produce variations. A chromosome will inherit some genes
    but not others.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步深入，我们重点研究了一类遗传算法（GA），通过多代实现遗传变换的模拟。我们探讨了父母如何传递一些基因，以及从代际种群中选择多样基因如何产生变异。染色体会遗传一些基因，但不遗传其他基因。
- en: The pressure of nature and our environment will take over. A fitness function
    evaluates a string of genes. Only the fittest will survive. The fittest genetic
    material will produce a crossover and mutation of the child, making it fitter
    for its environment.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 自然和环境的压力将会主导。一种适应度函数评估基因串，只有最强的基因才能存活。最强的基因物质将产生交叉和突变，创造出更适应环境的后代。
- en: GAs can be used to represent strings of any type of data and also features of
    that data. The optimizing process can be applied to warehouses, transportation,
    and neural networks.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法可以用于表示任何类型的数据串，以及该数据的特征。优化过程可以应用于仓储、运输和神经网络。
- en: Hybrid networks will no doubt expand in the years to come, taking DL to the
    next level. Using a genetic algorithm to optimize the architecture of an RNN paves
    the way to optimize the architecture of any DL, ML or AutoML architecture. For
    example, a hybrid neural network can use a genetic algorithm to optimize inputs
    with feature reduction or as the weight optimizing function of the network.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 混合网络无疑将在未来几年中扩展，将深度学习（DL）带到新的高度。使用遗传算法优化递归神经网络（RNN）的架构，为优化任何深度学习（DL）、机器学习（ML）或自动机器学习（AutoML）架构奠定了基础。例如，混合神经网络可以使用遗传算法优化输入，进行特征降维，或作为网络的权重优化函数。
- en: 'Nature has provided us with invaluable tools to apply to our artificial network
    models. This chapter dealt with the invisible building blocks inside us. In the
    next chapter, *Neuromorphic Computing*, we will explore other components that
    enable us to adapt to our environment: neurons. We will explore how neural networks
    using biological models can solve complex problems.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 大自然为我们提供了无价的工具，可以应用于我们的人工神经网络模型。本章讨论了我们体内的隐形构建模块。在下一章《神经形态计算》中，我们将探索使我们能够适应环境的其他组件：神经元。我们将探讨如何利用生物模型的神经网络来解决复杂问题。
- en: Questions
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: A cell contains 42 chromosomes. (Yes | No)
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个人体细胞含有42条染色体。（是 | 否）
- en: A genetic algorithm is deterministic, not random. (Yes | No)
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遗传算法是确定性的，不是随机的。（是 | 否）
- en: An evolutionary algorithm means that the program code evolves. (Yes | No)
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进化算法意味着程序代码会进化。（是 | 否）
- en: It is best for a child to have the same genes as one of the parents even after
    many generations. (Yes | No)
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使经过多代，孩子最好也能继承父母之一的基因。（是 | 否）
- en: Diversity makes the gene sets weaker. (Yes | No)
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多样性使得基因集变得更弱。（是 | 否）
- en: Building a neural network only takes a few lines, and the architecture always
    works. (Yes | No)
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个神经网络只需要几行代码，而且架构总是能正常工作。（是 | 否）
- en: Building a neural network with a genetic algorithm can help optimize the architecture
    of the layers. (Yes | No)
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用遗传算法构建神经网络有助于优化层的架构。（是 | 否）
- en: Hybrid neural networks are useless since deep learning will constantly progress.
    (Yes | No)
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 混合神经网络是无用的，因为深度学习将不断进步。（是 | 否）
- en: Would you trust a genetic algorithm to make decisions for you? (Yes | No)
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会信任遗传算法为你做决策吗？（是 | 否）
- en: Would you trust a hybrid neural network to optimize the architecture of your
    network? (Yes | No)
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会信任一个混合神经网络来优化你的网络架构吗？（是 | 否）
- en: Further reading
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: '[https://github.com/DEAP/deap](https://github.com/DEAP/deap)'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/DEAP/deap](https://github.com/DEAP/deap)'
- en: '[https://pypi.org/project/bitstring/](https://pypi.org/project/bitstring/)'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://pypi.org/project/bitstring/](https://pypi.org/project/bitstring/)'
