- en: Navigation Behavior and Pathfinding
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航行为和路径查找
- en: In this chapter, we'll be explaining in detail how the AI character moves around
    and understands where he can go and where he cannot. For different types of games,
    there are different solutions and we'll be addressing those solutions in this
    chapter, exploring common methods that can be used to develop a character that
    can move correctly on the map. Also we want our character to calculate the best
    trajectory to arrive at a certain destination, avoiding obstacles and accomplishing
    goals while doing it. We will introduce how to create a simple navigation behavior,
    then we will move on to a point to point movement and finally explore in depth
    how to create a more complex point to point movement (RTS/RPG system).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细解释人工智能角色如何移动以及如何理解他可以去哪里以及不能去哪里。对于不同类型的游戏，有不同解决方案，我们将在本章中讨论这些解决方案，探讨可以用来开发在地图上正确移动的角色的一些常用方法。此外，我们希望我们的角色能够计算出到达特定目的地的最佳轨迹，在移动过程中避开障碍物并完成目标。我们将介绍如何创建简单的导航行为，然后我们将继续探讨点到点移动，最后深入探讨如何创建更复杂的点到点移动（RTS/RPG系统）。
- en: Navigation behavior
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航行为
- en: When we talk about navigation behavior, we are referring to the actions of a
    character that is confronted with a situation where they need to calculate where
    to go or what to do. A map can have many points where it is necessary to jump
    or climb stairs in order to arrive at the final destination. The character should
    know how to use these actions to keep moving correctly; otherwise, he will fall
    down a hole or keep walking into a wall where he should be climbing some stairs.
    To avoid that, we need to plan all of the possibilities available for the character
    while he is moving, making sure that he can jump or perform any other movement
    necessary to keep moving into the right direction.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论导航行为时，我们指的是角色面对需要计算去哪里或做什么的情况时的行动。地图上可能有多个点，在这些点上必须跳跃或爬楼梯才能到达最终目的地。角色应该知道如何使用这些动作来保持正确的移动；否则，他可能会掉进洞里或者继续走进他应该爬楼梯的墙。为了避免这种情况，我们需要在角色移动时规划所有可能的选择，确保他可以跳跃或执行任何其他必要的动作以保持正确的方向移动。
- en: Choosing a new direction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择新的方向
- en: One important aspect that the AI character should have is choosing a new direction
    when he is confronted by an object that is blocking his way and that he cannot
    pass through. The character should be aware of the objects that are in front of
    him and, if he cannot keep moving forward in that direction, he should be able
    to choose a new direction, avoid colliding against the object and keep walking
    away from it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: AI角色应该具备的一个重要方面是在面对阻挡他前进且无法穿过的物体时选择新的方向。角色应该意识到他面前有哪些物体，如果他无法继续在那个方向前进，他应该能够选择一个新的方向，避免与物体碰撞并继续远离它。
- en: Avoid walking against walls
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免撞墙
- en: If our character is facing a wall, he will need to know that he cannot pass
    through that wall and should choose another option. Unless we allow the character
    to climb the wall or destroy it, the character will need to face a new direction
    that is not blocked and walk in that new unblocked direction.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的角色面对一堵墙，他需要知道他不能穿过那堵墙，应该选择另一个选项。除非我们允许角色爬墙或摧毁它，否则角色需要面对一个新的方向，这个方向没有被阻挡，然后在这个新的未阻挡方向上行走。
- en: We will start with a simple approach that i can be often very useful, and is
    perhaps the best option, depending on the type of game that we are creating. In
    the example that we'll be demonstrating, the character in question needs to keep
    moving around the level just like the *PAC-MAN* enemies. Starting with a basic
    example, we give our character the freedom to choose which direction to move in,
    and later on we will add more information to our character's AI so he can pursue
    a specific objective on the map using this method.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简单的方法开始，这种方法通常非常有用，也许是我们创建游戏时最好的选择。在我们将要演示的例子中，所讨论的角色需要像*吃豆人*敌人一样在关卡中不断移动。从一个基本示例开始，我们赋予我们的角色选择移动方向的权利，稍后我们将向角色的AI添加更多信息，使他能够使用这种方法在地图上追求特定的目标。
- en: '![](img/1044c2cb-d14c-43bf-9beb-d54c1d9d09a7.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1044c2cb-d14c-43bf-9beb-d54c1d9d09a7.png)'
- en: 'We have created a grid and painted in black the squares where the character
    AI is not allowed to walk. Now we are going to program our character to move forward
    until he finds a black square in front of him; then, he will need to choose to
    turn right or left, making that decision randomly. This will allow our character
    to move freely on the map without any specific pattern. The code for this is as
    follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个网格，并将不允许角色AI行走的方块涂成黑色。现在我们将编写代码让角色向前移动，直到他发现前方有一个黑色方块；然后，他需要随机选择向左或向右转向，做出这个决定。这将允许我们的角色在地图上自由移动，没有任何特定的模式。相应的代码如下：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For this example, we added colliders to the black squares to let the character
    know when he is touching them. This way, he will keep moving until colliding with
    a black square, and at that point there will be three options: turn left, turn
    right, or go back. To know which directions are unblocked, we created two separate
    colliders and added them to our character. Each collider has a script that gives
    the information to the character to let it know whether that side is free or not.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们向黑色方块添加了碰撞器，让角色知道当他接触它们时。这样，他将一直移动，直到与一个黑色方块碰撞，此时将有三种选择：向左转，向右转，或返回。为了知道哪些方向是畅通的，我们创建了两个独立的碰撞器，并将它们添加到我们的角色上。每个碰撞器都有一个脚本，为角色提供信息，让他知道哪一侧是畅通的或不是。
- en: 'The `availableLeft` Boolean corresponds to the left side, and `availableRight`
    corresponds to the right side. If the left or right collider is in contact with
    the black square, the value is set to `false`. Otherwise, it is set to `true`.
    We are using `aLeft` and `aRight` simply to check in real time if the values are
    working correctly. This way, we can see whether there are any issues:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`availableLeft`布尔值对应左侧，而`availableRight`对应右侧。如果左侧或右侧的碰撞器接触到黑色方块，则值设置为`false`。否则，它设置为`true`。我们使用`aLeft`和`aRight`只是简单地实时检查这些值是否工作正确。这样，我们可以看到是否存在任何问题：'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When we start the game, we can see that the character AI starts moving around
    on the white tiles and turning left or right every time he faces a black tile:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始游戏时，我们可以看到角色AI开始在白色方块上移动，并且每次面对黑色方块时都会向左或向右转向：
- en: '![](img/f29b9264-8591-40c3-9cdc-52281032dae7.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f29b9264-8591-40c3-9cdc-52281032dae7.png)'
- en: 'But if we let the game run for a couple of minutes, we realize that the character
    keeps making the same decisions, and for that reason he will just be walking around
    a small portion of the map. This is due to the fact that he only makes a decision
    when colliding with a black tile, ignoring the other opportunities to turn:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们让游戏运行几分钟，我们会意识到角色一直在做出相同的决定，因此他只会在这个地图的小部分区域里走来走去。这是因为他在与黑色方块碰撞时才会做出决定，而忽略了其他转向的机会：
- en: '![](img/cfb84437-f25a-47b9-b07c-7c50461bf207.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cfb84437-f25a-47b9-b07c-7c50461bf207.png)'
- en: As we can see in the preceding image, the character always follows the same
    pattern, not an ideal situation if we want him to constantly choose different
    paths.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，角色总是遵循相同的模式，如果我们希望他不断选择不同的路径，这并不是一个理想的情况。
- en: Choosing an alternative path
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择替代路径
- en: 'Our character successfully chooses a new direction every time that he approaches
    a wall, and now we want him to be able to move around all over the map. To make
    that happen, we are going to add more information into the character to let him
    know that if there''s an available option to turn to the left or right, even if
    the forward path is free, the character is free to turn. We can use probabilities
    to determine whether the character is going to turn or not, and for this example
    we have chosen to give a 90% chance of choosing a new direction if one is available.
    That way, we can see the results happening very quickly:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的字符每次接近墙壁时都会成功选择一个新的方向，现在我们希望他能够在整个地图上移动。为了实现这一点，我们将向角色添加更多信息，让他知道如果有一个可用的转向左或右的机会，即使前方路径是畅通的，角色也可以自由转向。我们可以使用概率来确定角色是否会转向，在这个例子中，我们选择如果有机会，有90%的几率选择一个新的方向。这样，我们可以非常快速地看到结果：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After adding the variables we can move on to the `Start` method, everything
    that will be called on the first frame of the game.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了变量之后，我们可以继续到`Start`方法，这是游戏第一帧上将被调用的所有内容。
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Then we can move on the the `Update` method, everything that will be called
    every frame of the game.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以继续到`Update`方法，这是游戏每一帧上将被调用的所有内容。
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here we add the trigger functions, what happens when he enters/collides against
    a 2D object:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了触发函数，当他在进入/碰撞到2D对象时会发生什么：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have added four new variables to our character AI script, the `probabilityTurnLeft`
    static variable, which calculates the probability of the character turning left;
    `probabilityTurnRight`, which calculates the probability of the character turning
    right; a new probability generator, `probabilitySides`, which will decide which
    way to turn when both are available and the forward path is blocked; and finally,
    a Boolean, `forwardBlocked`, to check whether the forward path is blocked or not.
    The character needs to check whether the forward path is blocked to know if he
    can turn or not. This will prevent the character from turning more than once when
    he is facing a black tile.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为我们角色的AI脚本添加了四个新变量，即`probabilityTurnLeft`静态变量，它计算角色向左转的概率；`probabilityTurnRight`，它计算角色向右转的概率；一个新的概率生成器`probabilitySides`，当两者都可用且前方路径被阻塞时，将决定转向哪个方向；最后，一个布尔值`forwardBlocked`，用于检查前方路径是否被阻塞。角色需要检查前方路径是否被阻塞，以知道他是否可以转向。这将防止角色在面对黑色方块时多次转向。
- en: '![](img/c8e0b1d1-430f-4dd3-9c13-91a37af048fa.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c8e0b1d1-430f-4dd3-9c13-91a37af048fa.png)'
- en: 'In the script that controls the side triggers, we added a new variable called
    `probabilityTurn`, which gives the character information about the probabilities.
    Every time the trigger exits the collider, he calculates the probability and sends
    a message to the character telling it that the side is free and he can make the
    decision to turn to that side:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制侧面触发的脚本中，我们添加了一个名为`probabilityTurn`的新变量，它给角色提供关于概率的信息。每次触发器退出碰撞体时，它会计算概率并向角色发送消息，告诉它侧面是空的，他可以决定转向那个侧面：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If we play the game, we can see the new changes implemented to the character.
    Now he is unpredictable, choosing different paths every time and moving all around
    the map, contrary to what we had before. Once this is completed, we can create
    as many maps as we wish because the character will always find the right path
    and avoid colliding with the walls.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们玩这个游戏，我们可以看到对角色实施的新变化。现在他不可预测，每次选择不同的路径，在地图上四处移动，与我们之前的情况相反。一旦完成，我们可以创建尽可能多的地图，因为角色总是会找到正确的路径并避开墙壁。
- en: '![](img/a282a072-4894-4427-b877-fd1ab9918f5d.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a282a072-4894-4427-b877-fd1ab9918f5d.png)'
- en: Testing on a bigger map, the character reacts the same way, moving around the
    whole map. This means that our main objective has been completed and now we can
    easily create new maps and use the character as the main enemy of the game so
    that he will always move differently and does not follow any pattern.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在更大的地图上进行测试，角色以相同的方式反应，在整个地图上移动。这意味着我们的主要目标已经完成，现在我们可以轻松地创建新的地图，并使用角色作为游戏的主要敌人，这样他总是会以不同的方式移动，不会遵循任何模式。
- en: '![](img/dfa3060c-b95e-4edd-a81d-da54e7035429.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dfa3060c-b95e-4edd-a81d-da54e7035429.png)'
- en: We can adjust the percentage values according to the way we want the character
    to react, and also implement more variables to make it unique to our game idea.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据我们希望角色如何反应来调整百分比值，并且还可以实现更多变量，使其符合我们的游戏理念。
- en: Point to point movement
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点对点移动
- en: 'Now that we understand the basics of how to create a character that can move
    freely in a maze genre game, we will take a look at the opposite: how to create
    a movement pattern from point to point. This is also an important aspect of AI
    movement, because later on we can combine both techniques to create a character
    that goes from one point to another, avoiding walls and obstacles.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何在迷宫类游戏中创建一个可以自由移动的角色的基础，我们将看看相反的情况：如何从一点到另一点创建移动模式。这也是人工智能移动的一个重要方面，因为稍后我们可以结合这两种技术来创建一个从一个点到另一个点的角色，避开墙壁和障碍物。
- en: Tower defense genre
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 塔防游戏类型
- en: 'Once again, the principle that we will be using to make our character move
    from one point to another can be applied to both 2D and 3D games. In this example,
    we''ll explore how to create the main characteristic of a Tower Defense game:
    the enemy pattern. The objective is to have the enemies spawning at a start point
    and following a path so they can reach the final point. The enemies in a tower
    defense game usually just have this in mind, so it is a perfect example to test
    how to create point to point movement.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们将用于使我们的角色从一个点到另一个点移动的原则可以应用于2D和3D游戏。在这个例子中，我们将探讨如何创建塔防游戏的主要特征：敌人模式。目标是让敌人从起始点生成并沿着路径移动，以便它们可以到达终点。塔防游戏中的敌人通常只考虑这一点，因此它是测试如何创建点对点移动的完美例子。
- en: 'A *Tower Defense* game usually consists of two areas: the area where the enemies
    walk from their start position to the final position, and the area where the player
    is allowed to build towers that attack the enemies, trying to stop them reaching
    the final position. Because the player is not allowed to build anything inside
    the path where the enemies will pass, the AI does not need to be aware of its
    surroundings because it will always be free to pass through, and because of that
    we only need to focus on the point to point movement of the characters.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一款 *塔防* 游戏通常由两个区域组成：敌人从起始位置走到最终位置的区域，以及玩家被允许建造攻击敌人的塔的区域，试图阻止他们到达最终位置。因为玩家不允许在敌人将通过的路径内部建造任何东西，所以AI不需要意识到其周围环境，因为它将始终可以自由通过，因此我们只需要关注角色的点对点移动。
- en: '![](img/5ff945f5-0dd0-4235-a563-dd77b0ba2ae8.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5ff945f5-0dd0-4235-a563-dd77b0ba2ae8.jpg)'
- en: After importing the map and characters that we'll be using in the game, we need
    to configure the **waypoints** that will be used by the character so they know
    where they need to go. We can do this by manually adding the coordinates into
    our code, but to simplify the process we'll create objects in the scene that will
    serve as waypoints and we delete the 3D mesh because it won't be necessary.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入我们将用于游戏的地图和角色之后，我们需要配置角色将使用的**航点**，以便它们知道它们需要去哪里。我们可以通过手动将坐标添加到我们的代码中来实现这一点，但为了简化过程，我们将创建场景中的对象作为航点，并删除3D网格，因为它将不再必要。
- en: 'Now we group all the waypoints that we have created and name the group waypoints.
    Once we have the waypoints in place and grouped together, we can start creating
    the code that will tell our character how many waypoints it needs to follow. This
    code is very useful because we can create different maps, using as many waypoints
    we need, without needing to update the character''s code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将所有创建的航点分组并命名为航点组。一旦我们将航点放置并分组，我们就可以开始创建代码，告诉我们的角色它需要跟随多少个航点。这段代码非常有用，因为我们可以使用我们需要的任意数量的航点创建不同的地图，而无需更新角色的代码：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code will be assigned to the group that we have created, and will count
    the number of waypoints that he has inside of it and ordering them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将被分配到我们创建的组中，并计算它内部有多少个航点，并对它们进行排序。
- en: '![](img/b56bafd3-551f-4ce2-b4f3-539bbee33ed9.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b56bafd3-551f-4ce2-b4f3-539bbee33ed9.png)'
- en: The blue spheres that we can see in the preceding image represent the 3D meshes
    that we have used as waypoints. For this example, the character will follow eight
    points until he finishes the path. Now let's move on to the AI character code
    and see how we can make the character move from point to point using the points
    that we have created.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的图像中可以看到的蓝色球体代表我们用作航点的3D网格。在这个例子中，角色将跟随八个点，直到完成路径。现在让我们继续到AI角色代码，看看我们如何使用我们创建的点使角色从一个点到另一个点移动。
- en: 'We start by creating the basic functions of the character, the health and speed.
    Then we can create a new variable that will tell the character the next position
    that he needs to move to, and another variable that will be used show which waypoint
    it needs to follow:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建角色的基本功能，即健康和速度。然后我们可以创建一个新的变量，告诉角色他需要移动到的下一个位置，以及另一个变量，将用于显示它需要跟随哪个航点：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we have the basic variables that are needed to make an enemy character
    move from point to point until he dies or reaches the end. Let''s see how to use
    these to make it playable:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了制作敌人角色从点到点移动直到死亡或到达终点所需的基本变量。让我们看看如何使用这些变量使其可玩：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the `Start` function, the first waypoint that the characters needs to follow
    is the waypoint number zero, that is, the first on the Transform list that we
    created in the `waypoints` code. Also, we have determined the velocity of the
    character, and for this example we have chosen `10f.`
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Start`函数中，角色需要跟随的第一个航点是航点编号零，即我们在`waypoints`代码中创建的Transform列表中的第一个。此外，我们还确定了角色的速度，在这个例子中我们选择了`10f`。
- en: Then in the `Update` function the character will calculate the distance between
    the next position and the current position, using the Vector 3 `dir`. The character
    will constantly be moving, so we have created a line of code that serves as movement
    for the character, `transform.Translate` in this case. Knowing the distance and
    the speed information, the character will know how far it is from the next position,
    and once he reaches the desirable distance from that point, he can then move on
    to the next point. To make this happen, we create an `if` statement that will
    tell to the character that, if he reaches 0.4f (for this example) from the point
    that he is moving towards, it means that he has already arrived at that destination
    and can start moving on to the next point, `GetNextWaypoint()`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`Update`函数中，角色将计算下一个位置和当前位置之间的距离，使用Vector 3 `dir`。角色将不断移动，因此我们创建了一行代码作为角色的移动，即`transform.Translate`。知道距离和速度信息后，角色将知道它距离下一个位置有多远，一旦他到达从该点期望的距离，他就可以继续移动到下一个点。为了实现这一点，我们创建了一个`if`语句，告诉角色，如果他距离他正在移动到的点的距离达到0.4f（在这个例子中），这意味着他已经到达了那个目的地，可以开始移动到下一个点，调用`GetNextWaypoint()`。
- en: In the `GetNextWaypoint()` function, the character will try to confirm if he
    has arrived at the final destination. If the character has arrived at the final
    waypoint, then the object can be destroyed; if not, it can continue to the next
    waypoint. Here, `wavepointIndex++` will add one number to the index every time
    the character arrives at a waypoint, moving from 0>1>2>3>4>5, and so on.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GetNextWaypoint()`函数中，角色将尝试确认他是否已经到达了最终目的地。如果角色已经到达了最终航点，那么对象可以被销毁；如果没有，它可以继续到下一个航点。在这里，`waypointIndex++`会在角色到达一个航点时每次将一个数字加到索引上，从0>1>2>3>4>5，依此类推。
- en: 'Now we assign the code to our character and place the character on the start
    position and test the game to see if it is working properly:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将代码分配给我们的角色，并将角色放置在起始位置，测试游戏以查看它是否正常工作：
- en: '![](img/216e5d9a-70eb-4a37-b137-12e0f07f1112.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/216e5d9a-70eb-4a37-b137-12e0f07f1112.png)'
- en: 'Everything is working as expected: the character will move from one point to
    another until he arrives at the last one, and then he disappears from the game.
    However, there are still some improvements we need to make, because the character
    is facing always the same direction; he does not rotate when he changes direction.
    Let''s take the opportunity to also create the instantiating code that will keep
    spawning enemies into the map.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都按预期工作：角色将从一点移动到另一点，直到他到达最后一个点，然后他从游戏中消失。然而，我们仍然需要做一些改进，因为角色总是朝同一个方向；他在改变方向时不会旋转。让我们趁机也创建实例化代码，以便将敌人持续生成到地图中。
- en: 'In the same way we created an object to define the waypoint, we''ll do the
    same for the start position, creating an object that will simply serve as position,
    so we can spawn the enemies from that point. To make that happen, we create a
    simple code just to test the gameplay without it being necessary to manually add
    the characters to the game:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们创建对象来定义航点的方式相同，我们也将为起始位置做同样的事情，创建一个将仅作为位置的对象，这样我们就可以从那个点生成敌人。为了实现这一点，我们创建了一行简单的代码，仅用于测试游戏玩法，而不需要手动将角色添加到游戏中：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At this moment, we already have a `wave spawner` working as well, spawning a
    new wave of enemies every three seconds. This will help us visualize the gameplay
    that we are creating for our AI character. We have five variables. `enemyPrefab`
    is the character that we are creating, so the code can spawn him. `timeBetweenWaves`
    represents the time that it will wait before spawning a new wave. The `spawnPoint`
    variable determines the position where the character will appear, the start position.
    Here, `countdown` is the time that we wait before the first wave appears. `waveNumber`
    is the last variable, and serves to count the current wave (usually, this is used
    to differentiate the enemy difficulty from one wave to another).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在此刻，我们已经有了一个正在工作的`wave spawner`，每三秒生成一波新的敌人。这将帮助我们可视化我们为我们的AI角色创建的游戏玩法。我们有五个变量。`enemyPrefab`是我们正在创建的角色，因此代码可以生成它。`timeBetweenWaves`表示生成新波前等待的时间。`spawnPoint`变量决定了角色将出现的位置，即起始位置。在这里，`countdown`是我们等待第一波出现的时间。`waveNumber`是最后一个变量，用于计算当前波次（通常，这用于区分一波和另一波敌人的难度）。
- en: If we run the game now, we can see that the number of characters appearing in
    the game is much more than just one, increasing every three seconds. Doing this
    at the same time as we develop our AI character is very useful, because if our
    characters have special abilities or if they have different speeds, we can fix
    it right away while we are developing them. Because we are just creating a small
    example, it is expected to work smoothly without any bugs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行游戏，我们可以看到游戏中出现的角色数量远不止一个，每三秒增加。在我们开发AI角色时同时做这件事非常有用，因为如果我们的角色有特殊能力或速度不同，我们可以在开发它们时立即修复。因为我们只是在创建一个小的示例，所以期望它能平稳运行，没有任何错误。
- en: 'Let''s test it out now to see what happens:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在测试一下看看会发生什么：
- en: '![](img/b7e68b0e-c3d4-46fe-b3c2-5e83cbf6f08a.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b7e68b0e-c3d4-46fe-b3c2-5e83cbf6f08a.png)'
- en: It looks much more interesting now! We can see that the point to point movement
    is working as intended, and all the characters spawned into the game know where
    they need to go, following the right path.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来更有趣了！我们可以看到点对点移动按预期工作，所有被生成到游戏中的角色都知道他们需要去哪里，并沿着正确的路径前进。
- en: 'We can now update the character code so it can turn to face the next point
    position while going around corners. To create this, we add a few more lines to
    the enemy code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以更新角色代码，使其在转弯时能够转向下一个点位置。为了创建这个，我们在敌人代码中添加了几行：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we can see in the preceding code, we have added a new variable called `speedTurn`,
    which will represent the velocity of our character when turning, and in the `start`
    function we have determined the speed value as `0.2f`. Then, in the update function,
    we calculate the velocity by multiplying this number by `Time.deltaTime`, giving
    a constant value regardless of the `FPS` number that the player is experiencing.
    Then we have created a new `Vector3` variable called `newDir`, which will make
    our character turn towards the target position.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们添加了一个名为`speedTurn`的新变量，它将代表角色转向时的速度，在`start`函数中，我们确定速度值为`0.2f`。然后，在`update`函数中，我们通过乘以`Time.deltaTime`来计算速度，无论玩家体验到的`FPS`数值是多少，都给出一个恒定的值。然后我们创建了一个新的`Vector3`变量，名为`newDir`，这将使我们的角色转向目标位置。
- en: 'Now if we test the game once more, we can see that the characters turn towards
    their next point position:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们再次测试游戏，我们可以看到角色会转向他们的下一个点位置：
- en: '![](img/1642b11f-90fc-45b4-963c-77087671c1fb.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1642b11f-90fc-45b4-963c-77087671c1fb.png)'
- en: At this point, we can see that the AI characters are reacting correctly, moving
    from point to point as intended and turning towards their next position. Now we
    have the basics of a tower defense game and, we could add unique code to create
    a new and enjoyable game.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以看到AI角色正在正确地反应，从一点移动到另一点，并转向他们的下一个位置。现在我们有了塔防游戏的基础，我们可以添加独特的代码来创建一个新颖且有趣的游戏。
- en: Racing genre
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 赛车游戏类型
- en: Point to point movement is a method that can be applied to practically any game
    genre and it has been extensively used over the years. Our next example is a racing
    game, where the AI drivers use point to point movement to compete against the
    player. To create this, we would need a road and a driver and then we'll place
    the waypoints on the road and tell our AI driver to follow that path. It's very
    similar to what we have done before but with some behavior differences in our
    character because we don't want it to look rigid when he is turning and also there
    will be other drivers on the same map and they cannot overlap one on top of another.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 点对点移动是一种可以应用于几乎任何游戏类型的方法，并且在多年来被广泛使用。我们的下一个例子是一个赛车游戏，其中人工智能驾驶员使用点对点移动来与玩家竞争。为了创建这个，我们需要一条道路和一个驾驶员，然后我们将航点放置在道路上，并告诉我们的AI驾驶员跟随这条路径。这与我们之前所做的是非常相似的，但在我们的角色中会有一些行为上的差异，因为我们不希望它在转弯时看起来僵硬，而且同一张地图上还会有其他驾驶员，他们不能一个压在另一个上面。
- en: 'Without further ado let''s start, first we need to establish the map, which
    in this case is the race track:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，让我们开始吧，首先我们需要建立地图，在这个例子中是赛道：
- en: '![](img/c07ab290-7a8e-49e6-b4e4-85875acb3f11.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c07ab290-7a8e-49e6-b4e4-85875acb3f11.jpg)'
- en: After designing our race track, we need to define every point position that
    our drivers need to go to, and because we have a lot of curves, we need to create
    more point positions than we had before so that the car follows the road smoothly.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计完我们的赛道后，我们需要定义我们的驾驶员需要到达的每个点位置，因为我们有很多曲线，所以我们需要创建比之前更多的点位置，以便汽车能够平滑地跟随道路。
- en: 'We have done the same process as before, creating objects inside the game and
    using them as position references only:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与之前一样进行了同样的过程，在游戏中创建对象，并将它们用作仅作为位置参考：
- en: '![](img/b80e6720-a2e8-49bd-b363-a49d2197a342.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b80e6720-a2e8-49bd-b363-a49d2197a342.png)'
- en: This is our map with the waypoints in place, and as we can see, there are more
    points on the curves. This is very important if we want to achieve a smooth transition
    from one point to another.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的地图，已经放置了航点，正如我们所见，曲线上有更多的点。如果我们想要从一个点到另一个点实现平滑过渡，这一点非常重要。
- en: Now let's group all the waypoints again, and this time we'll create a different
    code. Instead of creating a code that manages the waypoints, we will be implementing
    that calculation inside of our AI driver code and creating a simple code to apply
    to each waypoint to specify the next position to follow.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次将所有航点分组，这次我们将创建不同的代码。我们不会创建一个管理航点的代码，而是将计算实现在我们的人工智能驾驶员代码中，并创建一个简单的代码应用于每个航点，以指定要跟随的下一个位置。
- en: There are many ways that we can develop our code, and depending on our preferences
    or the game genre that we are working on, some methods can work better than others.
    In this case, we have found that using the code we developed for our Tower Defense
    character does not fit with this game genre.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多方法可以开发我们的代码，根据我们的偏好或我们正在制作的游戏类型，有些方法可能比其他方法更有效。在这种情况下，我们发现我们为塔防角色开发的代码与这种游戏类型不匹配。
- en: 'Starting with the AI driver code, we have used ten variables, as shown in the
    following code block:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从人工智能驾驶员代码开始，我们使用了十个变量，如下面的代码块所示：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first one, `raceStarted`, is a static Boolean that will tell our driver
    whether the race has started. This takes into consideration the fact that the
    race only begins when the green light appears; if not, `raceStarted` is set to
    `false`. Next, we have `aiSpeed`, which represents the velocity of the car. This
    is a simplified version for test proposes; otherwise, we would need speed functions
    to determine how fast can the car is going according to the gear that is set.
    `aiTurnSpeed` represents the velocity of the car when he is turning, how fast
    we want the car to steer when he is facing a new direction. Next, we have the
    `waypointController`, which will be linked to the waypoints group; and the `waypoints`
    list, which will be taken from that group.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个，`raceStarted`，是一个静态布尔值，它将告诉我们的驾驶员比赛是否已经开始。这考虑到了比赛只有在绿灯亮起时才开始的事实；如果不是，`raceStarted`被设置为`false`。接下来，我们有`aiSpeed`，它代表汽车的速度。这是一个用于测试的简化版本；否则，我们需要速度函数来确定汽车根据设定的档位可以多快。`aiTurnSpeed`代表汽车在转弯时的速度，我们希望汽车在面向新方向时如何快速转向。接下来，我们有`waypointController`，它将被链接到航点组；以及`waypoints`列表，它将从该组中获取。
- en: 'Here, `currentWaypoint` will tell our driver which waypoint number he is currently
    following. The `currentSpeed` variable will show the current velocity of the car.
    Finally, `currentWaypointPosition` is the Vector 3 position of the waypoint that
    the car will be following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`currentWaypoint`将告诉我们的驾驶员他目前正在跟随哪个航点编号。`currentSpeed`变量将显示汽车当前的速度。最后，`currentWaypointPosition`是汽车将要跟随的航点的Vector
    3位置：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In our `start` function, we have only three lines of code: `GetWaypoints()`,
    which will access all of the waypoints that exist inside of the group, and `resetAISpeed`
    and `resetAITurnSpeed`, which reset the speed values because they will influence
    the rigid body placed on the car:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`start`函数中，我们只有三行代码：`GetWaypoints()`，它将访问组内存在的所有航点，以及`resetAISpeed`和`resetAITurnSpeed`，它们将重置速度值，因为它们将影响放置在车上的刚体：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the update function, we have a simple `if` statement that checks whether
    the race has started or not. If the race has started, then he can proceed to the
    next step, which is the most important for our AI driver, `MoveTowardWaypoints()`.
    For this example, we have not stated anything while the car is waiting for the
    green light, but we could have implemented the engine starting and the pre-acceleration
    of the car, for example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新函数中，我们有一个简单的`if`语句，检查比赛是否已经开始。如果比赛已经开始，那么他可以继续到下一步，这对我们的AI驾驶员来说是最重要的，即`MoveTowardWaypoints()`。在这个例子中，当汽车等待绿灯时，我们没有做任何声明，但我们可以实现引擎启动和汽车的预加速，例如：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we have `GetWaypoints()`, which was instantiated in the `Start` function.
    Here, we access the `waypointController` group and retrieve all the position information
    regarding the waypoints that are stored inside it. Because we will be ordering
    the waypoints in a different code, we don''t need to do that here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`GetWaypoints()`，它在`Start`函数中被实例化。在这里，我们访问`waypointController`组并检索其中存储的所有航点位置信息。因为我们将在不同的代码中按顺序排列航点，所以我们在这里不需要做那件事：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Finally, we have the `MoveTowardsWaypoints()` function. Because the car has
    more depth in terms of mobility than a simple Tower Defense character, we decided
    to expand and implement more content in this part of the code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`MoveTowardsWaypoints()`函数。因为汽车在移动性方面比简单的Tower Defense角色更深入，我们决定扩展并在这个代码部分实现更多内容。
- en: First, we retrieve the Vector 3 position of the current waypoint that is being
    used. We have chosen to retrieve this information and assign the axis separately,
    and for that reason we have `currentWaypointX` for the X axis, `currentWaypointY`
    for the Y axis, and `currentWaypointZ` for the Z axis.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检索当前正在使用的航点的Vector 3位置。我们选择分别检索这些信息并分配轴，因此我们有`currentWaypointX`用于X轴，`currentWaypointY`用于Y轴，`currentWaypointZ`用于Z轴。
- en: Then we create a new Vector 3 direction called `relativeWaypointPosition`, which
    will calculate the distance between the waypoint and the current position of the
    car and convert from World Space to Local, and in this case we have used `InverseTransformDirection`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建一个新的Vector 3方向`relativeWaypointPosition`，它将计算航点和汽车当前位置之间的距离，并将从世界空间转换为局部空间，在这种情况下我们使用了`InverseTransformDirection`。
- en: '![](img/eca4daa4-b5f5-4418-8cf1-342bca678f56.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eca4daa4-b5f5-4418-8cf1-342bca678f56.jpg)'
- en: As we can see represented on the preceding graphic, we want to calculate the
    distance in local space between the car and the waypoint. This will tell to our
    driver if the waypoint is at his right or left side. This is recommended because
    the wheels command the car speed and they have an independent rotation value and
    if we kept working on this game, it would be one feature that would still need
    to be developed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们想要计算汽车和航点之间的局部空间距离。这将告诉我们的驾驶员航点是在他的右侧还是左侧。这是推荐的，因为车轮控制汽车速度，并且它们有一个独立的旋转值，如果我们继续开发这个游戏，这将是一个仍然需要开发的功能。
- en: 'To smooth the rotation between one waypoint to another, we have used the following
    code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了平滑从一个航点到另一个航点的旋转，我们使用了以下代码：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is an updated version of what we used in the Tower Defense. It will make
    our car move smoothly towards the waypoint that the car is traveling toward. This
    gives the effect of the car turning; otherwise, he would turn right away towards
    the waypoint and it would look unrealistic:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Tower Defense中我们使用的一个更新版本。它将使我们的汽车平滑地移动到汽车正在行驶的航点。这给出了汽车转弯的效果；否则，他将会直接向航点右转，这看起来不真实：
- en: '![](img/b510d9d0-00a0-4fa9-8628-e0cb9c7aa616.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b510d9d0-00a0-4fa9-8628-e0cb9c7aa616.jpg)'
- en: As we can see, straight lines do not fit the genre that we are currently creating.
    It works perfectly in other genres, like Tower Defense game, but for a racing
    game it is necessary to redefine the code to adjust to the situation that we are
    creating.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，直线并不适合我们目前正在创作的游戏类型。它在其他类型，如塔防游戏中运行得非常完美，但对于赛车游戏来说，我们必须重新定义代码以适应我们正在创造的情况。
- en: The rest of the code is exactly that, adjustments for the situation that we
    are creating, which is a car moving on a race track. There are force elements
    such as `drag`, which is the friction between the car and the road, represented
    in this code. When we turn the car, it will slide according to the velocity of
    the car at that moment, and these details are taken into consideration here, creating
    a more realistic point to point movement where we can see that the car is reacting
    according to physics.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码正是如此，针对我们正在创造的情况进行的调整，即一辆在赛道上行驶的汽车。其中包含如`drag`这样的力元素，这是汽车与道路之间的摩擦力，在代码中得到了体现。当我们转向汽车时，它会根据那一刻汽车的速度滑动，这些细节在这里都被考虑到了，创造出一个更真实的点对点移动，我们可以看到汽车是按照物理规律反应的。
- en: 'This is the full code that we have used in our example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在示例中使用过的完整代码：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If we start the game and test it, we can see that he is working fine. The car
    drives by itself, turns smoothly, and completes the track as intended.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们开始游戏并测试它，我们可以看到它运行得很好。汽车可以自行驾驶，转弯顺畅，并按照预期完成赛道。
- en: Now that we have the basic point to point movement completed, we could implement
    more functions for the AI driver and start developing the game as we want. It
    is always recommended to start with the main functions of the gameplay before
    developing any details. This will help identify any ideas that we had planned
    for the game that do not work as well as we thought.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了基本的点对点移动，我们可以为AI驾驶员实现更多功能，并开始按照我们的意愿开发游戏。在开发任何细节之前，始终建议先从游戏的主功能开始。这将帮助我们识别出那些我们原本以为会很好地工作的游戏想法，但实际上并不如预期。
- en: '![](img/e69f4df7-1a8d-444c-82d0-5d93aab94edd.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e69f4df7-1a8d-444c-82d0-5d93aab94edd.png)'
- en: MOBA genre
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MOBA游戏类型
- en: Point to point movement is one of the most commonly used methods to control
    the movement of a character. It is self-explanatory why it is widely used, because
    the character moves from one point to another and usually that's we want; we want
    the character to arrive at certain destination or follow another character. One
    game genre that also requires this type of movement is the Multiplayer Online
    Battle Arena (MOBA) games that have become very popular recently. Usually, there
    are NPC characters that spawn at the start position and follow a predetermined
    path towards the enemy towers, similar to the Tower Defense enemies, but in this
    case the AI characters move in the same terrain as the players and can interfere
    with each other.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 点对点移动是控制角色移动最常用的方法之一。为什么它被广泛使用，这一点不言而喻，因为角色从一个点移动到另一个点，通常这正是我们想要的；我们希望角色到达某个目的地或跟随另一个角色。另一种也需要这种移动类型的游戏类型是最近变得非常流行的多人在线战斗竞技场（MOBA）游戏。通常，NPC角色会在起始位置生成，并沿着预定的路径向敌方塔楼移动，类似于塔防游戏中的敌人，但在这个情况下，AI角色与玩家在相同的地图上移动，并且可以相互干扰。
- en: 'The map is divided into two equal parts, where one side needs to fight the
    other, and for each part it spawns a different platoon that is composed of small
    enemies called Minions or Creeps. When they are following their path, if one platoon
    finds the other, they stop moving forward and start attacking. After the battle,
    the survivors keep moving forward:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 地图被分为两个相等的部分，其中一边需要与另一边战斗，并且每个部分都会生成一个不同的连队，由被称为小兵或 creep 的小型敌人组成。当它们沿着路径移动时，如果一个连队遇到另一个，它们就会停止前进并开始攻击。战斗结束后，幸存者继续前进：
- en: '![](img/56c70510-4439-4e49-8f62-2511f17d9324.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/56c70510-4439-4e49-8f62-2511f17d9324.jpg)'
- en: 'In this example we are going to re-create that portion of the game, where the
    platoon spawns at the start position, follows their path, stops when they find
    the enemies and keep moving towards their next direction until they win the fight.
    Then we will create the basic movement of the hero character that is controlled
    by the player or the computer: both have the freedom to move around the map and
    the characters needs to follow the direction that is directed by the player or
    computer while avoiding all obstacles.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将重新创建游戏的一部分，其中小队从起始位置出生，沿着路径前进，当它们找到敌人时停止，并继续向下一个方向移动，直到赢得战斗。然后我们将创建由玩家或计算机控制的英雄角色的基本移动：两者都有在地图上自由移动的自由，角色需要遵循玩家或计算机指示的方向，同时避开所有障碍。
- en: 'We will start by importing the map into our game. We have chosen a generic
    MOBA style map, like we can see on the following screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先将地图导入到我们的游戏中。我们选择了一个通用的MOBA风格地图，就像我们在以下截图中所看到的那样：
- en: '![](img/1bc9983d-7af5-4eb5-b1da-4106f407a258.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1bc9983d-7af5-4eb5-b1da-4106f407a258.png)'
- en: The next step is to create waypoints in the map. Here we will have six different
    waypoints groups, because each team has three different paths and each platoon
    can only follow one path. We start from the base position and then we add more
    waypoints until we reach the enemy base. The following image shows an example
    of what we have created.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在地图中创建航点。这里我们将有六个不同的航点组，因为每个队伍有三条不同的路径，每个小队只能遵循一条路径。我们从基地位置开始，然后添加更多的航点，直到我们到达敌方基地。以下图像显示了我们所创建的示例。
- en: '![](img/113a359a-2c3d-495b-85fe-944a0a3d2418.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/113a359a-2c3d-495b-85fe-944a0a3d2418.jpg)'
- en: 'We need to create three different waypoint groups for each team, because there
    will be three different spawn positions as well; they will work independently
    from one another. After setting the waypoints, we can group them and assign the
    code that will gather the position information and the order that the platoon
    should follow. For this example, we can use the same code that we used for the
    Tower Defense waypoints, because the way that the enemies follow their path is
    similar:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为每个队伍创建三个不同的航点组，因为也会有三个不同的出生点；它们将独立工作。设置航点后，我们可以将它们分组并分配用于收集位置信息和排应该遵循的顺序的代码。对于这个例子，我们可以使用我们之前用于塔防航点的相同代码，因为敌人跟随路径的方式是相似的：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Because we have six different waypoint groups, it is necessary to duplicate
    the same code six times and rename them accordingly. Our `spawnable` enemies will
    later access the right path for them, so it is recommended to rename the groups
    and codes so that we can easily understand which group represents which lane,
    for example, 1_Top/1_Middle/1_Bottom and 2_Top/2_Middle/2_Bottom. The number represents
    their team and the position name represents the position. In this case, we change
    the name `points` in our code to the correct names that represent each lane:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有六个不同的航点组，有必要将相同的代码复制六次并相应地重命名。我们的“可出生”敌人将稍后访问它们正确的路径，因此建议重命名组和代码，以便我们可以轻松理解哪个组代表哪个路线，例如，1_Top/1_Middle/1_Bottom
    和 2_Top/2_Middle/2_Bottom。数字代表他们的队伍，位置名称代表位置。在这种情况下，我们将代码中的“points”名称更改为代表每个路线的正确名称：
- en: 'Lane Team 1 Top:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lane Team 1 Top:'
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Lane Team 1 Middle:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lane Team 1 Middle:'
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Lane Team 1 Bottom:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lane Team 1 Bottom:'
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Lane Team 2 Top:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lane Team 2 Top:'
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Lane Team 2 Middle:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lane Team 2 Middle:'
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Lane Team 2 Bottom:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lane Team 2 Bottom:'
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that we have created all the groups and codes for each of them, we can
    move on to the character AI that will follow their path towards the enemy base.
    We can choose to duplicate the code for each team or integrate everything inside
    the same code, using `if` statements to decide which path the character should
    follow. For this example, we have chosen to integrate everything in the same code.
    That way, we can update the character code once and it will work for both teams
    at the same time. Once again, we can start by using the same code that we used
    in the enemies from the Tower Defense game. We can change the code so he will
    fit in the game that we are currently creating:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为每个队伍创建了所有组和代码，我们可以继续到跟随路径向敌方基地前进的角色AI。我们可以选择为每个队伍复制代码，或者将所有内容整合到同一代码中，使用`if`语句来决定角色应该遵循哪个路径。对于这个例子，我们选择将所有内容整合到同一代码中。这样，我们只需更新一次角色代码，它就会同时适用于两个队伍。再次提醒，我们可以从在塔防游戏中使用的相同代码开始。我们可以更改代码，使其适合我们目前正在创建的游戏：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With this code, we can make the character follow the path and turn smoothly
    when changing from one point to another. At this point we just need to change
    the code to make him fit the game genre that we are creating. To do that the first
    thing we need to consider is changing the name points to the names that we've
    previously created, and add `if` statements to choose which side the character
    needs to follow.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，我们可以让角色沿着路径移动，并在从一个点到另一个点时平滑地转向。在这个阶段，我们只需要更改代码，使其适合我们正在创建的游戏类型。为此，我们首先需要考虑的是将点名称更改为我们之前创建的名称，并添加`if`语句来选择角色需要跟随的侧面。
- en: 'Let''s start by adding the information that distinguish the characters of one
    team from another. To do that, we need to create two new Boolean variables:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加区分一个团队角色与另一个团队角色的信息开始。为此，我们需要创建两个新的布尔变量：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This will let us decide if the character is from Team1 or Team2, both cannot
    be true at the same time. Now we can implement more details into the character
    code, to let him know which lane he should walk on:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够决定角色是来自Team1还是Team2，两者不能同时为真。现在我们可以将更多细节添加到角色代码中，让他知道他应该走哪条路线：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We have added three more Booleans that will indicate the lane that the character
    needs to follow. After working out which team the character is spawning from,
    another `if` statement will be added to determine the lane that the character
    will follow.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了三个额外的布尔值，将指示角色需要跟随的路线。在确定角色是从哪个团队出生后，我们将添加另一个`if`语句来确定角色将遵循的路线。
- en: 'Once we have added those variables, we need to assign the waypoint groups that
    we created before according to the lane that the character will follow. We can
    implement that right in the `start` function:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们添加了这些变量，我们需要根据角色将遵循的路线分配我们之前创建的航点组。我们可以在`start`函数中实现这一点：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This allows the character to question the team that it is representing, the
    lane where it spawned, and the path that he will follow. We need to adjust the
    rest of the code so it will work for this example. The next modification will
    be in the `GetNextWaypoint()` function. We need to add the `if` statements to
    let the character know the correct next waypoint that he needs to follow, similar
    to what we did in the `Start` function:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许角色询问它所代表的团队、它出生的路线以及他将遵循的路径。我们需要调整其余的代码，以便它适用于这个示例。下一个修改将在`GetNextWaypoint()`函数中。我们需要添加`if`语句，让角色知道他需要遵循的正确下一个航点，类似于我们在`Start`函数中所做的：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'At this point, if we add a character to the game and assign it the AI code,
    it will follow the chosen path:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，如果我们向游戏中添加一个角色并分配AI代码，它将遵循所选路径：
- en: '![](img/4be59aba-e3d4-40d2-b4ed-ae187f2fe767.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4be59aba-e3d4-40d2-b4ed-ae187f2fe767.png)'
- en: 'It is working properly, and we are ready to implement more features to create
    the perfect platoon that follows a path toward the enemy tower and that stops
    to fight the other platoon or the hero. Any details or uniqueness that we want
    to add to our platoon can be applied now that we have the basic movement working.
    Here, we have attached the complete code for the platoon AI character:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 它正在正常工作，我们现在准备实现更多功能，以创建一个完美的连队，该连队沿着通往敌方塔楼的道路前进，并在必要时停下来与另一连队或英雄战斗。现在我们已经有了基本移动功能，我们可以添加任何我们想要添加到我们的连队中的细节或独特性。在这里，我们附上了连队AI角色的完整代码：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After updating the variables in the preceding code we can move on to the `Start`
    method that will be called on the first frame:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新前面代码中的变量之后，我们可以继续到`Start`方法，该方法将在第一帧被调用：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here is the `Update` method that will be called every frame of the game:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是每帧游戏都会调用的`Update`方法：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Another important aspect of a MOBA game is the hero's movement. Even if it's
    controlled by the player, the character has AI to determine the path that he needs
    to follow in order to arrive at the chosen destination. To complete this task,
    we will introduce the point to point method first; then we will continue the same
    example but using an advanced method that will make our character decide the best
    path to arrive at the final destination without implementing any waypoints.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: MOBA游戏的一个重要方面是英雄的移动。即使它由玩家控制，角色也有AI来决定他需要遵循的路径，以便到达所选目的地。为了完成这个任务，我们首先介绍点对点方法；然后我们将继续使用相同的方法，但使用一种更高级的方法，让我们的角色决定到达最终目的地的最佳路径，而不需要实现任何航点。
- en: 'This example will also serve as an example of how to create a character that
    follows the player. To do this, we need to set all the possible paths that the
    character is allowed follow. We want the AI to avoid colliding with objects or
    passing through walls, for example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子也将作为如何创建跟随玩家的角色的示例。为了做到这一点，我们需要设置所有角色允许跟随的可能路径。我们希望AI避免与物体碰撞或穿过墙壁，例如：
- en: '![](img/03647230-0824-4d25-8e17-fc604ca2b630.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/03647230-0824-4d25-8e17-fc604ca2b630.png)'
- en: Let's focus on this area of the map. As we can see, there are walls and trees
    blocking a portion of the map, and the characters should not be allowed to pass
    through them. Using the waypoints method, we will create points on the map that
    the character should follow if he wants to reach a certain destination. he won't
    have any specific order like the previous examples that we have created, because
    the character can move in any direction, and for that reason we cannot predict
    the path that it will choose.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注地图的这个区域。正如我们所见，墙壁和树木阻挡了地图的一部分，角色不应被允许穿过它们。使用航点方法，我们将在地图上创建角色应该跟随以到达特定目的地的点。它不会有像之前例子中创建的任何特定顺序，因为角色可以朝任何方向移动，因此我们无法预测它将选择哪条路径。
- en: 'We start by positioning the waypoints on the walkable positions. This will
    prevent the character from moving on the non-walkable area:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将航点定位在可通行位置。这将防止角色在不可通行区域移动：
- en: '![](img/d1894131-e2ba-4822-8573-2cc0a0ae09d0.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d1894131-e2ba-4822-8573-2cc0a0ae09d0.jpg)'
- en: The stars that we see on the map represent the waypoints that we have created,
    so we should only place them in the areas that the character is able to walk in.
    If the character wants to move from one position to another, it must follow the
    waypoints until it gets to the closest waypoint to the desired destination.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 地图上我们看到的小星星代表我们创建的航点，因此我们应该只在角色能够行走的地方放置它们。如果角色想要从一个位置移动到另一个位置，它必须遵循航点，直到到达离目标目的地最近的航点。
- en: In the gameplay mechanics, we can choose why the character needs to reach a
    certain destination, such as following the player, going to the base to recover
    health points, moving towards the enemy wall to destroy it, and many others choices.
    Independently of what the character AI needs to achieve, it needs to move correctly
    on the map, and this waypoints system will work in any circumstance.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏机制中，我们可以选择角色为什么需要到达某个特定目的地，例如跟随玩家、前往基地恢复生命值、向敌方墙壁移动以摧毁它，以及许多其他选择。无论角色AI需要实现什么，它都需要在地图上正确移动，而这个航点系统在任何情况下都会起作用。
- en: 'Here we can find the full code that will make this work. Then we''ll explain
    everything in detail to better understand how to replicate this code so it can
    work in a different game genre:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以找到使这一切工作的完整代码。然后我们将详细解释，以便更好地理解如何复制此代码，使其能在不同的游戏类型中工作：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If we assign this code into our character and hit the play button, we can test
    the game and see that what we have created works perfectly. The character should
    use the waypoint positions to move across the map to reach the desired destination.
    This method can be used for NPC characters and playable characters as well, because
    for both cases the characters need to avoid colliding with the wall and obstacles:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此代码分配给我们的角色并按下播放按钮，我们可以测试游戏并看到我们所创建的内容工作得非常完美。角色应该使用航点位置在地图上移动，以达到目标目的地。这种方法同样适用于NPC角色和可玩角色，因为在这两种情况下，角色都需要避免与墙壁和障碍物碰撞：
- en: '![](img/e9c1db85-e8e7-4e57-b927-b52fb4e025b8.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e9c1db85-e8e7-4e57-b927-b52fb4e025b8.jpg)'
- en: If we continue the example and expand the waypoints across the whole map, we
    have a basic MOBA game working properly, with a platoon of monsters spawning at
    each base and following the right path, and hero characters that can move freely
    on the map without colliding with walls.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续这个例子，并将航点扩展到整个地图上，我们就会有一个运行良好的基本MOBA游戏，每个基地都会生成一群怪物，它们会沿着正确的路径前进，同时英雄角色可以在地图上自由移动，不会撞到墙壁。
- en: Point to point movement and avoiding dynamic objects
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点对点移动和避免动态物体
- en: Now that we have characters that can follow the right path and avoid static
    objects, we are ready to move on to the next level and make those characters avoid
    dynamic objects while moving from point to point. We will revise the three different
    examples created in this chapter and see how we can add the avoiding technique
    to the AI characters in those examples.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了能够跟随正确路径并避开静态物体的角色，我们准备进入下一个级别，让这些角色在从点到点移动时避开动态物体。我们将回顾本章中创建的三个不同示例，并看看我们如何将这些避免技术添加到示例中的AI角色中。
- en: 'Those three methods should cover almost every game genre that uses point to
    point movement as their primary method of locomotion, and we will be able to create
    new ideas with these examples as a guideline:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个方法几乎涵盖了所有使用点对点移动作为其主要移动方式的游戏类型，我们将能够根据这些示例作为指南来创造新的想法：
- en: '![](img/20bf6ea9-cf58-48ad-a4a4-0ff9999b85eb.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/20bf6ea9-cf58-48ad-a4a4-0ff9999b85eb.jpg)'
- en: Let's start with the racing game, where we have a car that drives around the
    track until he finishes the race. If the car drives alone and there's nothing
    obstructing the path, it won't be necessary to avoid any obstacles, but usually
    obstacles make the game more interesting or challenging, especially when they
    are spontaneous and we don't expect them. A great example of this is the Mario
    Kart game, where they throw bananas and other objects to destabilize the opposing
    players, and the objects don't have any pre-defined position so the characters
    can't predict where they're going to be. So it is important for the drivers to
    have the necessary functions to avoid colliding with those objects and be able
    to do that in real time.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从赛车游戏开始，在这个游戏中，我们有一辆在赛道上行驶直到完成比赛的汽车。如果汽车独自驾驶且路上没有障碍物，那么它就不需要避开任何障碍，但通常障碍物会使游戏更有趣或更具挑战性，尤其是在它们是突然出现且我们没有预料到的情况下。一个很好的例子是马里奥赛车游戏，在那里他们扔香蕉和其他物体来使对手不稳定，而这些物体没有预定义的位置，所以角色无法预测它们将出现在哪里。因此，对于驾驶员来说，拥有避免与这些物体碰撞的必要功能并在实时中做到这一点是非常重要的。
- en: 'Assuming that two objects appeared unexpectedly on the road while the AI character
    was following the next waypoint, we want the character to anticipate the collision
    and turn around to avoid crashing against the object. The method that we will
    be using here is a combination of the waypoint movement with the maze movement.
    The character can only obey one order at a time, he can either respect the waypoint
    movement or the maze movement, and that''s exactly what we need to add on to our
    code so the character AI can choose the best option according the current situation
    that he is facing:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 假设当AI角色正在跟随下一个航点时，道路上意外出现了两个物体，我们希望角色能够预测碰撞并转身避开物体。我们将使用的方法是航点移动与迷宫移动的结合。角色一次只能服从一个命令，他要么遵守航点移动，要么遵守迷宫移动，这正是我们需要添加到我们的代码中的，以便角色AI可以根据他当前面临的情况选择最佳选项：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After updating the preceding variables, we can move on to the `Start` method.
    This will be called in the first frame:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新前面的变量之后，我们可以继续到`Start`方法。这将在第一帧被调用：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here is the `Update` method that will be called every frame of the game:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是每帧游戏都会调用的`Update`方法：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We have added four new static variables to our code: `isBlocked`, `isBlockedFront`,
    `isBlockedRight`, and `isBlockedLeft`. This will check if the path in front of
    the car is free from obstacles or not. The car will continue following the waypoint
    path until something appears and the car needs to turn left or right to pass the
    obstacle. To make this work, we need to add at least three sensors in front of
    the car. When they interact with some object, the sensor gives that information
    to the AI driver, and at this point it will choose the best option according to
    that information:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的代码中添加了四个新的静态变量：`isBlocked`、`isBlockedFront`、`isBlockedRight`和`isBlockedLeft`。这将检查汽车前方的路径是否没有障碍物。汽车将继续沿着航点路径行驶，直到出现某些东西，汽车需要左转或右转以通过障碍物。为了使这一点生效，我们需要在汽车前方至少添加三个传感器。当它们与某个物体交互时，传感器将信息传递给AI驾驶员，此时它将根据该信息选择最佳选项：
- en: '![](img/531474be-12b7-41b5-b7be-e0927c7c62d1.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/531474be-12b7-41b5-b7be-e0927c7c62d1.jpg)'
- en: As we can see in the preceding image, the car now has three sensors attached
    to it. In this example, the right sensor will report that it is blocked by an
    obstacle and the driver will turn left until that side is free again. Once the
    three sensors report that nothing is obstructing the driver's path, the car will
    return to following the waypoint that it was previously moving towards. If we
    notice that the driver doesn't recognize some obstacles, it is recommended to
    increase the number of sensors to cover a larger area.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的图像中所看到的，汽车现在有三个传感器附着在其上。在这个例子中，右边的传感器将报告它被障碍物阻挡，驾驶员将向左转直到那一边再次畅通。一旦三个传感器报告说没有东西阻挡驾驶员的路径，汽车将返回到之前移动的航点。如果我们注意到驾驶员没有识别某些障碍物，建议增加传感器的数量以覆盖更大的区域。
- en: Now let's move on to the platoon characters that we created for the MOBA example.
    Here, we will need to create a different method, because the characters will move
    towards the next waypoint until they find something, but this time we don't want
    them to move away. Instead, we want the character to move towards the character
    that they have found.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续到我们为MOBA示例创建的编队角色。在这里，我们需要创建一个不同的方法，因为角色将移动到下一个航点，直到他们找到某个东西，但这次我们不希望他们离开。相反，我们希望角色向他们找到的角色移动。
- en: '![](img/1b05980d-03bd-42d0-bf1c-52706cf2b4e2.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b05980d-03bd-42d0-bf1c-52706cf2b4e2.jpg)'
- en: 'To create this, we will add a circular or spherical collider to our character.
    This will serve as detection. If something triggers that zone, the character will
    stop moving towards its waypoint and use the position of the hero that triggered
    the collider as a waypoint to pursue:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这个功能，我们将为我们的角色添加一个圆形或球形的碰撞器。这将作为检测器使用。如果某个物体触发了该区域，角色将停止向其航点移动，并使用触发碰撞器的英雄的位置作为航点来追击：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After updating the preceding variables, we can move on to the `Start` method,
    which will be called on the first frame:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新前面的变量之后，我们可以继续到`Start`方法，它将在第一帧被调用：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here is the `Update` method that will be called every frame of the game:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是每帧游戏都会调用的`Update`方法：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This `GetNextWaypoint` method is used to gather the information regarding the
    next waypoint that the character needs to follow:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`GetNextWaypoint`方法用于收集角色需要跟随的下一个航点的相关信息：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the `GetHeroWaypoint` method, we set what happens when the character needs
    to follow the Hero direction, like attacking or any other function:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GetHeroWaypoint`方法中，我们设置当角色需要跟随英雄方向时发生的情况，例如攻击或其他功能：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We've added a spherical collider to the character that gives the trigger information
    to the character, to know if a hero character has entered that zone. If no hero
    triggered that zone, the character will continue following the waypoint, otherwise
    it will focus his attention to the hero and use him as a target point.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为角色添加了一个球形碰撞器，它向角色提供触发信息，以便知道是否有英雄角色进入了该区域。如果没有英雄触发该区域，角色将继续跟随航点，否则它将集中注意力在英雄身上，并使用他作为目标点。
- en: With this example we learned the core features of the artificial intelligence
    movement that can be found in a MOBA game and now we can re-create this popular
    game genre. From this chapter onwards we can create simple to complex navigation
    systems and use them to make our AI character more active in the game, constantly
    pursuing an objective even if that objective is moving.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，我们学习了MOBA游戏中可以找到的人工智能移动的核心功能，现在我们可以重新创建这种流行的游戏类型。从这一章开始，我们可以创建从简单到复杂的导航系统，并使用它们使我们的AI角色在游戏中更加活跃，不断追求目标，即使这个目标是移动。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have introduced point to point movement, a method that is
    widely used in many games today, and we can adapt the codes that we have created
    to work in practically any game. At this point ,we are able to re-create many
    popular games and add our personal touch to them. In the next chapter, we'll continue
    talking about movement, but we will be focusing on an advanced aspect called the
    Theta algorithm. This will serve as a continuation of what we have learned in
    this chapter, and we will be able to create a character AI that, without any previous
    information or positions, will be able to find for itself the best path to follow
    in order to arrive at a certain destination.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了点对点移动，这是一种在许多游戏中广泛使用的方法，并且我们可以将我们创建的代码适应到几乎任何游戏中。到目前为止，我们能够重新创建许多流行的游戏，并给它们添加我们个人的特色。在下一章中，我们将继续讨论移动，但我们将关注一个称为Theta算法的高级方面。这将作为本章所学内容的延续，我们将能够创建一个角色AI，它无需任何先前的信息或位置，就能为自己找到到达特定目的地的最佳路径。
