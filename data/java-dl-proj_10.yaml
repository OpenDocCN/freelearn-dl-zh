- en: Developing Movie Recommendation Systems Using Factorization Machines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用因式分解机开发电影推荐系统
- en: '**Factorization machines** (**FM**) are a set of algorithms that enhance the
    performance of linear models by incorporating second-order feature interactions
    that are absent in **matrix factorization** (**MF**) algorithms in a supervised
    way. Therefore, FMs are very robust compared to their classical counterpart—**collaborative
    filtering** (**CF**)—and are gaining popularity in personalization and recommendation
    systems because they can be used to discover latent features underlying the interactions
    between two different kinds of entities.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**因式分解机**（**FM**）是一组通过引入第二阶特征交互来增强线性模型性能的算法，这些交互在**矩阵分解**（**MF**）算法中是缺失的，并且这种增强方式是监督式的。因此，相比于经典的**协同过滤**（**CF**）方法，因式分解机非常稳健，并且因其能够用于发现两种不同实体之间交互的潜在特征，在个性化和推荐系统中越来越受欢迎。'
- en: 'In this chapter, we will develop a sample project for predicting both the rating
    and ranking to show their effectiveness. Nevertheless, we will see some theoretical
    background of recommendation systems using MF and CF before diving into the project''s
    implementation using RankSys library-based FMs. In summary, the following topics
    will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发一个样例项目，用于预测评分和排名，以展示其有效性。尽管如此，在使用基于RankSys库的FM实现项目之前，我们将看到一些关于使用MF和CF的推荐系统的理论背景。总的来说，本章将涵盖以下主题：
- en: Recommendation systems
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐系统
- en: Matrix factorization and the collaborative filtering approach
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵分解与协同过滤方法
- en: Developing FM-based move recommendation systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发基于FM的电影推荐系统
- en: Frequently asked questions (FAQs).
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见问题解答（FAQ）
- en: Recommendation systems
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐系统
- en: Recommender techniques are nothing but information agents that try to predict
    items that users may be interested in and recommend the best ones to the target
    user. These techniques can be classified based on the information sources they
    use. For example, user features (age, gender, income, and location), item features
    (keywords, and genres), user-item ratings (explicit ratings, and transaction data),
    and other information about the user and item that are useful for the process
    of recommendation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐技术本质上是信息代理，它们尝试预测用户可能感兴趣的物品，并向目标用户推荐最合适的物品。这些技术可以根据它们使用的信息来源进行分类。例如，用户特征（年龄、性别、收入、地点）、物品特征（关键词、类型）、用户-物品评分（显式评分、交易数据）以及其他对推荐过程有用的用户和物品信息。
- en: Thus, a recommendation system; otherwise known as a **recommendation engine**
    (**RE**) is a subclass of information filtering systems that help to predict the
    rating or preference based on the rating provided by users to an item. In recent
    years, recommendation systems have become increasingly popular.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，推荐系统，也称为**推荐引擎**（**RE**），是信息过滤系统的一个子类，帮助预测基于用户提供的评分或偏好来推荐物品。近年来，推荐系统变得越来越流行。
- en: Recommendation approaches
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐方法
- en: There are a couple of ways to develop REs to produce a list of recommendations,
    for example, collaborative and content-based filtering, knowledge-based, or the
    personality-based approach.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 开发推荐引擎（RE）以生成推荐列表有几种方法，例如，协同过滤、基于内容的过滤、基于知识的推荐或基于个性的方法。
- en: Collaborative filtering approaches
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协同过滤方法
- en: 'By using CF approaches, an RE can be built based on a user''s past behavior.
    Numerical ratings are given on consumed items. Sometimes, it can be based on the
    decisions made by other users who also have purchased the same items using some
    widely used data mining algorithms such as Apriori or FP-growth. In the following
    diagram, you can get some idea of the different recommendation systems:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用CF方法，可以基于用户的过去行为构建推荐引擎（RE）。对于已消费的物品会给出数值评分。有时，推荐也可以基于其他用户做出的决策，这些用户也购买了相同的物品，并使用一些广泛应用的数据挖掘算法，如Apriori或FP-growth。以下图示展示了不同推荐系统的一些概念：
- en: '![](img/941dcf58-8778-4aa2-bb6d-caaf171215e3.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/941dcf58-8778-4aa2-bb6d-caaf171215e3.png)'
- en: A comparative view of different recommendation systems
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 不同推荐系统的比较视图
- en: 'Even though these are successful recommendation systems, CF-based approaches
    often suffer from the following three problems:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些是成功的推荐系统，基于CF的方法往往会面临以下三大问题：
- en: '**Cold start:** Sometimes, they can become stuck when a large amount of data
    about users is required to make a more accurate recommendation system.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冷启动：** 有时，当需要大量关于用户的数据来做出更准确的推荐系统时，它们可能会卡住。'
- en: '**Scalability:** A large amount of computation power is often necessary to
    calculate recommendations using a dataset with millions of users and products.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性：** 使用一个包含数百万用户和商品的数据集进行推荐计算时，通常需要大量的计算能力。'
- en: '**Sparsity:** This often happens with crowdsourced datasets when a huge number
    of items are sold on major e-commerce sites. All recommendation datasets are crowd-sourced
    in some sense. This is a general problem for almost all recommendation systems
    that have a sufficiently large number of items to offer to a sufficiently large
    number of users and need not be confined to e-commerce sites only.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**稀疏性：** 这通常发生在众包数据集上，特别是当大量商品在主要电商网站上出售时。所有推荐数据集在某种意义上都是众包的。这是几乎所有推荐系统的普遍问题，尤其是当系统需要为大量商品提供服务，并且有足够多的用户时，并不仅限于电商网站。'
- en: In this case, active users may rate only a small subset of the whole items sold,
    so even the most popular items have very few ratings. Accordingly, the user versus
    items matrix becomes very sparse. In other words, handling a large-scale sparse
    matrix is computationally very challenging.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，活跃用户可能只对所有销售的物品中的一个小子集进行评分，因此即使是最受欢迎的物品也只有很少的评分。因此，用户与物品的矩阵变得非常稀疏。换句话说，处理一个大规模的稀疏矩阵在计算上是非常具有挑战性的。
- en: To overcome these issues, a particular type of collaborative filtering algorithm
    uses matrix factorization, which is a low-rank matrix approximation technique.
    We will see an example of this later in this chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些问题，某种类型的协同过滤算法采用矩阵分解，这是一个低秩矩阵近似技术。我们将在本章稍后看到一个示例。
- en: Content-based filtering approaches
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于内容的过滤方法
- en: With content-based filtering approaches, a series of discrete characteristics
    of an item are utilized to recommend additional items with similar properties.
    Sometimes, it is based on a description of the item and a profile of the user's
    preferences. These approaches try to recommend items that are similar to those
    that a user liked in the past, or that are currently being used.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于内容的过滤方法时，利用物品的一系列离散特征来推荐具有相似属性的其他物品。有时，这些方法基于物品的描述和用户偏好的个人资料。这些方法试图推荐与用户过去喜欢的物品相似的物品，或者是用户当前正在使用的物品。
- en: A key issue with content-based filtering is whether the system is able to learn
    user preferences from their actions regarding one content source and use them
    with other content types. When this type of RE is deployed, it can then be used
    to predict items or ratings for items that the user may have an interest in.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 基于内容的过滤方法的一个关键问题是系统是否能够根据用户对一个内容源的行为来学习其偏好，并将这些偏好应用到其他内容类型上。当这种类型的推荐引擎（RE）被部署时，就可以用来预测用户可能感兴趣的物品或物品的评分。
- en: Hybrid recommender systems
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合推荐系统
- en: As you have seen, there are several pros and cons of using collaborative filtering
    and content-based filtering approaches. Therefore, to overcome the limitations
    of these two approaches, recent trends have shown that a hybrid approach can be
    more effective and accurate. Sometimes, factorization approaches such as FM and
    **Singular Value Decomposition** (**SVD**) are used to make them robust.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用协同过滤和基于内容的过滤方法各有优缺点。因此，为了克服这两种方法的局限性，近年来的趋势表明，混合方法可以更有效且准确。有时，像**矩阵分解**（**SVD**）这样的因子化方法被用来增强其鲁棒性。
- en: Model-based collaborative filtering
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于模型的协同过滤
- en: Collaborative filtering methods are classified as memory-based, such as the
    user-based algorithm and model-based collaborative filtering (kernel mapping is
    recommended). In the model-based collaborative filtering technique, users and
    products are described by a small set of factors, also called **latent factors**
    (**LFs**). The LFs are then used to predict the missing entries. The **Alternating
    Least Squares** (**ALS**) algorithm is used to learn these latent factors.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 协同过滤方法分为基于记忆的，如基于用户的算法和基于模型的协同过滤（推荐使用核映射）。在基于模型的协同过滤技术中，用户和产品通过一组小的因子来描述，这些因子也叫做**潜在因子**（**LFs**）。然后使用这些潜在因子来预测缺失的条目。**交替最小二乘法**（**ALS**）算法用于学习这些潜在因子。
- en: Compared to a memory-based approach, a model-based approach can handle the sparsity
    of the original matrix better. This is also scalable, faster, and can avoid overfitting
    issues. However, it is not flexible and adaptable because it is difficult to add
    data to the model. Now, let's take a look at an important element in the collaborative
    filtering approach, called the utility matrix.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于记忆的方法相比，基于模型的方法可以更好地处理原始矩阵的稀疏性。它还具有可扩展性、更快的速度，并且能够避免过拟合问题。然而，它缺乏灵活性和适应性，因为很难向模型中添加数据。现在，让我们来看一下协同过滤方法中的一个重要元素——效用矩阵。
- en: The utility matrix
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 效用矩阵
- en: 'In a collaborative filtering-based recommendation system, there are dimensions
    of entities: users and items (items refers to products, such as movies, games,
    and songs). As a user, you might have preferences for certain items. Therefore,
    these preferences must be motivated out of the data about items, users, or ratings.
    This data is often represented as a utility matrix, such as a user-item pair.
    This type of value can represent what is known about the degree of preference
    that the user has for a particular item.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于协同过滤的推荐系统中，存在两类实体：用户和物品（物品指的是产品，如电影、游戏和歌曲）。作为用户，你可能对某些物品有偏好。因此，这些偏好必须从关于物品、用户或评分的数据中推导出来。这些数据通常表现为效用矩阵，例如用户-物品对。此类值可以表示用户对某个物品的偏好程度。
- en: 'The following table shows an example utility matrix that represents the rating
    users have given to movies on a 1-5 scale, with 5 being the highest rating. **HP1**,
    **HP2**, and **HP3** are acronyms for *Harry Potter I*, *II*, and *III*, **TW**
    stands for *Twilight*, and **SW1**, **SW2**, and **SW3** ;stands for *Star Wars
    episodes 1*, 2, and 3\. The letters **A**, **B**, **C**, and **D** represent the
    users:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下表展示了一个示例效用矩阵，表示用户对电影的评分，评分范围为1到5，其中5为最高评分。**HP1**、**HP2**和**HP3**分别是*哈利·波特I*、*II*和*III*的缩写，**TW**代表*暮光之城*，**SW1**、**SW2**和**SW3**分别代表*星球大战I*、*II*和*III*。字母**A**、**B**、**C**和**D**代表用户：
- en: '![](img/a0963aa4-7115-4b60-834f-de08bdee83dc.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0963aa4-7115-4b60-834f-de08bdee83dc.png)'
- en: Utility matrix (user versus movies matrix)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 效用矩阵（用户与电影的矩阵）
- en: There are many blank entries for the user-movie pairs. This means that users
    have not rated those movies, which increases sparsity. Using this matrix, the
    goal is to predict the blanks in the utility matrix. Suppose we are curious to
    know whether user **A** would like **SW2**. This is difficult to predict since
    there is not much data in the matrix.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户-电影对中有许多空白项。这意味着用户尚未对这些电影进行评分，这增加了稀疏性。使用此矩阵的目标是预测效用矩阵中的空白项。假设我们好奇是否用户**A**会喜欢**SW2**。由于矩阵中没有太多数据，这个预测是困难的。
- en: Therefore, other properties regarding movies, such as the producer, director,
    leading actors, or even the similarity of their names, can be used to compute
    the similarity of the movies **SW1** and **SW2**. This similarity would drive
    us to conclude that since **A** did not like **SW1**, they are unlikely to enjoy
    **SW2** either.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，关于电影的其他属性，如制片人、导演、主演，甚至是它们名字的相似性，都可以用来计算电影**SW1**和**SW2**的相似度。这种相似性会引导我们得出结论，由于**A**不喜欢**SW1**，他们也不太可能喜欢**SW2**。
- en: However, this might not work for a larger dataset. Therefore, with much more
    data, we might observe that the people who rated both **SW1** and **SW2** were
    inclined to give them similar ratings. Finally, we can conclude that A would also
    give **SW2** a low rating, similar to **A**'s rating of **SW1**. This approach,
    however, has a serious drawback called the ;**cold-start problem**.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于更大的数据集，这种方法可能不起作用。因此，当数据量更大时，我们可能会观察到评分**SW1**和**SW2**的用户倾向于给它们相似的评分。最终，我们可以得出结论，**A**也会给**SW2**一个低评分，类似于**A**对**SW1**的评分。然而，这种方法有一个严重的缺点，称为**冷启动问题**。
- en: The cold-start problem in collaborative-filtering approaches
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协同过滤方法中的冷启动问题
- en: The term cold-start problem sounds funny, but, as the name implies, it derives
    from cars. In recommendation engines, however, the term cold-start simply means
    a circumstance that is not yet optimal for the engine to provide the best possible
    results.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 冷启动问题这个词听起来有些滑稽，但正如其名字所示，它源自汽车。在推荐引擎中，冷启动问题只是意味着一种尚未达到最佳状态的情况，导致引擎无法提供最理想的结果。
- en: In collaborative filtering approaches, the recommender system would identify
    users who share preferences with the active user and propose items that like-minded
    users have favored. Due to the cold-start problem, this approach would fail to
    consider items that no-one in the community has rated.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在协同过滤方法中，推荐系统会识别与当前用户有相似偏好的用户，并推荐那些志同道合的用户喜欢的物品。由于冷启动问题，这种方法无法考虑没有人在社区中评分的物品。
- en: 'Recommendation engines using CF-based approaches recommend each item based
    on user actions. The more user actions an item has, the easier it is to tell which
    user would be interested in it and what other items are similar to it. As time
    progresses, the system will be able to give more and more accurate recommendations.
    At a certain stage, when new items or users are added to the user-item matrix,
    the following problem occurs:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于协同过滤（CF）方法的推荐引擎根据用户的行为推荐每个物品。物品的用户行为越多，越容易判断哪些用户可能对该物品感兴趣，以及哪些其他物品与之相似。随着时间的推移，系统将能够提供越来越准确的推荐。当新的物品或用户被添加到用户-物品矩阵时，以下问题就会发生：
- en: '![](img/09ebe6c2-f70c-4fbc-b0a0-1392572ad78f.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09ebe6c2-f70c-4fbc-b0a0-1392572ad78f.png)'
- en: Users versus items matrices sometimes lead to the cold-start problem
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 用户与物品矩阵有时会导致冷启动问题
- en: In this case, the RE does not have enough knowledge about this new user or this
    new item yet. The content-based filtering approach, similar to FM, is a method
    that can be incorporated to alleviate the cold-start problem.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，推荐引擎对这个新用户或新物品的了解还不够。基于内容的过滤方法，类似于因子分解机（FM），是一种可以结合使用以缓解冷启动问题的方法。
- en: Factorization machines in recommender systems
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐系统中的因子分解机
- en: In real life, most recommendation problems assume that we have a rating dataset
    formed by a collection of (user, item, and rating) tuples. However, in many applications,
    we have plenty of item metadata (tags, categories, and genres) that can be used
    to make better predictions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际生活中，大多数推荐问题假设我们拥有一个由（用户、物品和评分）元组构成的评分数据集。然而，在许多应用中，我们有大量的物品元数据（标签、类别和类型），这些可以用来做出更好的预测。
- en: This is one of the benefits of using FMs with feature-rich datasets, because
    there is a natural way in which extra features can be included in the model, and
    higher-order interactions can be modeled using the dimensionality parameter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用因子分解机（FMs）与特征丰富数据集的好处之一，因为模型中可以自然地加入额外的特征，且可以使用维度参数建模高阶交互。
- en: 'A few recent types of research show which feature-rich datasets give better
    predictions:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最近的研究类型展示了哪些特征丰富的数据集能够提供更好的预测：
- en: Xiangnan He and Tat-Seng Chua, *Neural Factorization Machines for Sparse Predictive
    Analytics*. During proceedings of SIGIR '17, Shinjuku, Tokyo, Japan, August 07-11,
    2017
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xiangnan He和Tat-Seng Chua，*Neural Factorization Machines for Sparse Predictive
    Analytics*。发表于SIGIR '17会议，东京新宿，日本，2017年8月07-11日
- en: 'Jun Xiao, Hao Ye, Xiangnan He, Hanwang Zhang, Fei Wu and Tat-Seng Chua (2017).
    *Attentional Factorization Machines: Learning the Weight of Feature Interactions
    via Attention Networks* IJCAI, Melbourne, Australia, August 19-25, 2017'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Jun Xiao, Hao Ye, Xiangnan He, Hanwang Zhang, Fei Wu和Tat-Seng Chua（2017）。*Attentional
    Factorization Machines: Learning the Weight of Feature Interactions via Attention
    Networks* IJCAI，澳大利亚墨尔本，2017年8月19-25日'
- en: These papers explain how to make existing data into a feature-rich dataset and
    how FMs were implemented on the dataset. Therefore, researchers are trying to
    use FMs to develop more accurate and robust REs. In the next section, we will
    start developing our project for movie recommendations using FMs. For that, we
    will be using Apache Spark and RankSys libraries.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些论文解释了如何将现有数据转化为特征丰富的数据集，并且如何在该数据集上实现因子分解机（FMs）。因此，研究人员正试图使用因子分解机（FMs）来开发更准确和更强大的推荐引擎（REs）。在接下来的章节中，我们将开始开发基于因子分解机（FMs）的电影推荐项目。为此，我们将使用Apache
    Spark和RankSys库。
- en: Existing recommendation algorithms require a consumption (product) or rating
    (movie) dataset in *(user, item, rating)* tuples. These types of dataset are mostly
    used by variations of CF algorithms. CF algorithms have been widely adopted and
    have proven to yield good results.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的推荐算法需要一个由*(用户、物品、评分)*元组构成的消费（产品）或评分（电影）数据集。这些类型的数据集主要被协同过滤（CF）算法的变种使用。协同过滤（CF）算法已被广泛采用，并且证明能够产生良好的结果。
- en: However, in many instances, we have plenty of item metadata (tags, categories,
    and genres) that can be used to make better predictions as well. Unfortunately,
    CF algorithms do not use these types of metadata.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在许多情况下，我们也有大量的物品元数据（标签、类别和类型），这些可以用来做出更好的预测。不幸的是，协同过滤（CF）算法并未使用这些类型的元数据。
- en: 'FMs can make use of these feature-rich (meta) datasets. An FM can consume these
    extra features to model higher-order interactions specifying the dimensionality
    parameter *d*. Most importantly, FMs are also optimized for handling large-scale
    sparse datasets. Therefore, a second order FM model would suffice because there
    is not enough information to estimate interactions that are more complex:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: FM可以利用这些特征丰富（元）数据集。FM可以消耗这些额外的特征来建模更高阶的交互，并指定维度参数*d*。最重要的是，FM也经过优化，可以处理大规模的稀疏数据集。因此，二阶FM模型就足够了，因为没有足够的信息来估计更复杂的交互：
- en: '![](img/0bbeea54-1a2c-47f3-b5ef-9fb02d82ad45.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0bbeea54-1a2c-47f3-b5ef-9fb02d82ad45.png)'
- en: An example training dataset representing a personalization problem with the
    feature vectors x and the target y. Here, rows refer to movies, while columns
    include director, actor and genre info, and so on
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例训练数据集，表示一个个性化问题，特征向量x和目标y。在这里，行代表电影，而列包括导演、演员和类型等信息
- en: Let's assume that the dataset of a prediction problem is described by a design
    matrix *X* ∈ℝ*^n*^(x*p*),. In the preceding diagram, the *i^(th)* row, x*[i]*∈ℝ*^(p
    ;)*of *X*, describes one case with *p* real-valued variables and where *y[i]*
    is the prediction target of the *i*^(th) case. Alternatively, we can describe
    this set as a set *S* of tuples *(x,y)*, where (again) *x* ∈ ℝ*^p* is a feature
    vector and *y* is its corresponding target or label.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 假设预测问题的数据集由设计矩阵*X* ∈ ℝ*^n*^(x*p*)描述。在前面的图中，*i^(th)*行，x*[i]* ∈ ℝ*^(p;)*是*X*中的一个案例，描述了一个包含*p*个实值变量的情况，且*y[i]*是第*i*个案例的预测目标。或者，我们可以将这个集合描述为一组元组*(x,y)*的集合，其中（再次）*x*
    ∈ ℝ*^p*是特征向量，*y*是其对应的目标或标签。
- en: In other words, in figure 7, every row represents a feature vector *x[i]* with
    its corresponding target *y[i]*. For easier interpretation, the features are grouped
    into indicators for the active user (blue), the active item (red), other movies
    rated by the same user (orange), the time in months (green), and the last movie
    rated (brown).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在图7中，每一行表示一个特征向量*x[i]*及其对应的目标*y[i]*。为了更容易理解，特征被分组为：活动用户（蓝色）、活动商品（红色）、相同用户评分的其他电影（橙色）、时间（月）（绿色）以及最后评分的电影（棕色）。
- en: 'Then, the FM algorithm models all the nested interactions (up to order d*)*
    between *p* input variables in *x* using the following factorized interaction
    parameters:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，FM算法使用以下因子化的交互参数，建模*p*个输入变量在*x*中的所有嵌套交互（最多到d*阶）：
- en: '![](img/c81dc120-f418-47ad-bc34-ac5df6ece7bc.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c81dc120-f418-47ad-bc34-ac5df6ece7bc.png)'
- en: In this equation, the *vs* represent *k*-dimensional latent vectors associated
    with each variable (the users and the items), and the bracket operator represents
    the inner product. This kind of representation with data matrices and feature
    vectors is common in many machine learning approaches, for example, in linear
    regression or support vector machines (SVM).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方程中，*vs*代表与每个变量（用户和商品）相关的*k*维潜在向量，而括号操作符表示内积。许多机器学习方法中都使用这种数据矩阵和特征向量的表示方式，例如线性回归或支持向量机（SVM）。
- en: 'However, if you are familiar with the MF models, the preceding equation should
    look familiar: it contains a global bias as well as user/item-specific biases
    and includes user-item interactions. Now, if we assume that each *x(j)* vector
    is only non-zero at positions *u* and *i*, we get the classic MF model:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你熟悉矩阵分解（MF）模型，那么前面的公式应该看起来很熟悉：它包含一个全局偏差，以及用户/商品特定的偏差，并且包括用户与商品的交互。现在，如果我们假设每个*x(j)*向量仅在位置*u*和*i*处非零，我们得到经典的MF模型：
- en: '![](img/1cc28cd9-dfb1-47b0-ae12-0c30b2d6f31d.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1cc28cd9-dfb1-47b0-ae12-0c30b2d6f31d.png)'
- en: 'Nevertheless, FMs can also be used for classification or regression and are
    much more computationally efficient on large, sparse datasets than traditional
    algorithms like linear regression. This property is why FM is widely used for
    recommendation: user count and item count are typically very large although the
    actual number of recommendations is very small (users do not rate all available
    items!).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，FM也可以用于分类或回归，并且在处理大规模稀疏数据集时，比传统算法（如线性回归）计算效率更高。正是因为这个特点，FM被广泛用于推荐系统：用户数和商品数通常非常大，尽管实际的推荐数量非常少（用户并不会对所有可用商品进行评分！）。
- en: Developing a movie recommender system using FMs
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用因子分解机（FM）开发电影推荐系统
- en: 'In this project, we will show you how to do ranking prediction from the MovieLens
    1m dataset. First, we will prepare the dataset. Then, we will train the FM algorithm,
    which eventually predicts the rankings and ratings for movies. The project code
    has the following structure:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，我们将展示如何从 MovieLens 1M 数据集中进行排名预测。首先，我们将准备数据集。然后，我们将训练 FM 算法，最终预测电影的排名和评分。项目代码的结构如下：
- en: '![](img/a6c66d50-7932-41f9-bfbf-5ed054c9579f.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6c66d50-7932-41f9-bfbf-5ed054c9579f.png)'
- en: Movie rating and ranking prediction project structure
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 电影评分和排名预测项目结构
- en: 'In summary, the project has the following structure:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，该项目的结构如下：
- en: '**EDA:** This package is used to do an exploratory analysis of the MovieLens
    1M dataset.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EDA：** 该包用于对 MovieLens 1M 数据集进行探索性分析。'
- en: '**Tools, FMCore, and DataUtils:** These are the core FM libraries. For the
    purpose of this probject, I used (but extended) the `RankSys` library (see the
    `GitHub` repository at [https://github.com/RankSys/RankSys](https://github.com/RankSys/RankSys)).'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具、FMCore 和 DataUtils：** 这些是核心的 FM 库。为了这个项目，我使用了（但进行了扩展）`RankSys` 库（可以查看
    `GitHub` 仓库：[https://github.com/RankSys/RankSys](https://github.com/RankSys/RankSys)）。'
- en: '**Preprocessing:** This package is used to convert the `MovieLens` 1M dataset
    into LibFM format.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预处理：** 这个包用于将 `MovieLens` 1M 数据集转换为 LibFM 格式。'
- en: '**Prediction:** This package is used for the movie rating and ranking prediction.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预测：** 这个包用于电影评分和排名预测。'
- en: '**GraphUtil:** This package visualizes some performance metrics over iteration.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GraphUtil：** 该包用于在迭代过程中可视化一些性能指标。'
- en: We will go through all of these packages step by step. Nevertheless, knowing
    the dataset is a mandate.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一步步讲解所有这些包。不过，了解数据集是必须的。
- en: Dataset description and exploratory analysis
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据集描述和探索性分析
- en: 'The MovieLens 1M small dataset was downloaded (and used with necessary permission)
    from the MovieLens website at [https://grouplens.org/datasets/movielens/](https://grouplens.org/datasets/movielens/).
    I sincerely acknowledge and thank F. Maxwell Harper and Joseph A. Konstan for
    making the datasets available for use. The dataset was published in *MovieLens
    Dataset: History and Context*. ACM Transactions on Interactive Intelligent Systems
    (TiiS) 5, 4, Article 19 (December 2015), 19 pages.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: MovieLens 1M 小型数据集是从 MovieLens 网站下载（并已获得必要的许可）并使用的，网址为：[https://grouplens.org/datasets/movielens/](https://grouplens.org/datasets/movielens/)。我由衷感谢
    F. Maxwell Harper 和 Joseph A. Konstan 提供的这个数据集。该数据集已发表于 *MovieLens 数据集：历史与背景*，ACM
    交互智能系统事务（TiiS）5（4），文章 19（2015 年 12 月），共 19 页。
- en: 'There are three files in the dataset: `movies.dat`, `ratings.dat`, and `users.dat`,
    which are related to movies, ratings, and users, respectively. These files contain
    1,000,209 anonymous ratings of approximately 3,900 movies made by 6,040 MovieLens
    users who joined MovieLens in 2000\. All of the ratings are contained in the `ratings.dat`
    file and are in the following format:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集包含三个文件：`movies.dat`、`ratings.dat` 和 `users.dat`，分别与电影、评分和用户相关。文件中包含 1,000,209
    个匿名评分，涵盖约 3,900 部电影，评分由 6,040 名于 2000 年加入 MovieLens 的用户提供。所有评分都存储在 `ratings.dat`
    文件中，格式如下：
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The description is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 描述如下：
- en: '`UserID`: This ranges between 1 and 6,040'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`用户ID`：范围在 1 到 6,040 之间'
- en: '`MovieID`: This ranges between 1 and 3,952'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`电影ID`：范围在 1 到 3,952 之间'
- en: '`Rating`: These are made on a 5-star scale'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`评分`：这些评分采用 5 星制'
- en: '`Timestamp`: This is represented in seconds'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`时间戳`：这是以秒为单位表示的'
- en: 'Note that each user has rated at least 20 movies. Movie information, on the
    other hand, is in the `movies.dat` file and is in the following format:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个用户至少评价了 20 部电影。电影信息则保存在 `movies.dat` 文件中，格式如下：
- en: '[PRE1]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The description is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 描述如下：
- en: '`Title`: These are identical to titles provided by IMDb (with the release year)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标题`：这些与 IMDb 提供的标题相同（包括上映年份）'
- en: '`Genres`: These are comma-separated (,), and each movie is categorized as action,
    adventure, animation, children''s, comedy, crime, drama, war, documentary, fantasy,
    film-noir, horror, musical, mystery, romance, sci-fi, thriller, and western'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`类别`：这些是用逗号（,）分隔的，每部电影被分类为动作、冒险、动画、儿童、喜剧、犯罪、剧情、战争、纪录片、奇幻、黑色电影、恐怖、音乐、悬疑、浪漫、科幻、惊悚和西部'
- en: 'Finally, user information is in the `users.dat` file and is in the following
    format:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，用户信息保存在 `users.dat` 文件中，格式如下：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'All demographic information is provided voluntarily by the users and is not
    checked for accuracy. Only users who have provided some demographic information
    are included in this dataset. An M for male and F for female denote gender. Age
    is chosen from the following ranges:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的个人信息是用户自愿提供的，且没有经过准确性检查。只有那些提供了部分个人信息的用户才会被包含在此数据集中。M代表男性，F代表女性，性别由此标识。年龄选择以下范围：
- en: '1: Under 18'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1: 未满18岁'
- en: '18: 18-24'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '18: 18-24'
- en: '25: 25-34'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '25: 25-34'
- en: '35: 35-44'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '35: 35-44'
- en: '45: 45-49'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '45: 45-49'
- en: '50: 50-55'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '50: 50-55'
- en: '56: 56+'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '56: 56岁以上'
- en: 'Occupation is chosen from the following choices:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 职业从以下选项中选择：
- en: '0: Other, or not specified'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0: 其他，或未指定'
- en: '1: Academic/educator'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1: 学术/教育工作者'
- en: '2: Artist'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '2: 艺术家'
- en: '3: Clerical/admin'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '3: 文员/行政'
- en: '4: College/grad student'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '4: 大学/研究生学生'
- en: '5: Customer service'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '5: 客服'
- en: '6: Doctor/healthcare'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '6: 医生/医疗保健'
- en: '7: Executive/managerial'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '7: 高管/经理'
- en: '8: Farmer'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '8: 农民'
- en: '9: Homemaker'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '9: 家庭主妇'
- en: '10: K-12 student'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '10: K-12学生'
- en: '11: Lawyer'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '11: 律师'
- en: '12: Programmer'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '12: 程序员'
- en: '13: Retired'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '13: 退休'
- en: '14: Sales/marketing'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '14: 销售/市场营销'
- en: '15: Scientist'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '15: 科学家'
- en: '16: Self-employed'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '16: 自雇'
- en: '17: Technician/engineer'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '17: 技术员/工程师'
- en: '18: Tradesman/craftsman'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '18: 工匠/技工'
- en: '19: Unemployed'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '19: 失业'
- en: '20: Writer'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '20: 作家'
- en: 'Now that we know the dataset, we can play with the datasets toward exploratory
    analysis. First, we will create a Spark session as the gateway to the Spark program:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了数据集，接下来可以开始进行探索性分析。首先，我们将创建一个Spark会话，作为Spark程序的入口：
- en: '[PRE3]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we will load and parse the `rating.dat` file to do some exploratory analysis.
    The following lines of code should return the DataFrame rating:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将加载并解析`rating.dat`文件，进行一些探索性分析。以下代码行应该返回数据框rating：
- en: '[PRE4]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![](img/9aea1ec0-6fe1-45bf-8814-da645acbe6da.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9aea1ec0-6fe1-45bf-8814-da645acbe6da.png)'
- en: 'Next, we will load the `movies.dat` and prepare the movies DataFrame:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将加载`movies.dat`并准备电影数据框：
- en: '[PRE5]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![](img/8f533e03-9994-428f-b125-bc49b54234ef.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f533e03-9994-428f-b125-bc49b54234ef.png)'
- en: 'Then, we will register both DataFrames as temporary tables to make querying
    easier. To register both Datasets, the following lines of code need to be used:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将注册两个数据框作为临时表，以便更容易进行查询。要注册这两个数据集，以下代码行需要被使用：
- en: '[PRE6]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that this will help to make in-memory querying faster by creating a temporary
    view as a table in-memory. Then, we will opt to explore some rating and movie-related
    statistics:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这将通过在内存中创建一个临时视图作为表，帮助加快内存查询的速度。然后，我们将选择探索一些与评分和电影相关的统计信息：
- en: '[PRE7]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, let's get the maximum and minimum ratings along with the count of users
    who have rated a movie. However, you need to perform a SQL query on the rating
    table we just created in-memory in the previous step. Making a query here is simple,
    and it is similar to making a query from a MySQL database or RDBMS.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们获取最大和最小评分以及评分过电影的用户数量。不过，你需要对我们刚刚在内存中创建的评分表执行一个SQL查询。在这里执行查询非常简单，类似于从MySQL数据库或关系型数据库管理系统（RDBMS）中进行查询。
- en: However, if you are not familiar with SQL-based queries, you are suggested to
    look at the SQL query specification to find out how to perform a selection using
    `SELECT` from a particular table, how to perform the ordering using `ORDER`, and
    how to perform a joining operation using the `JOIN` keyword.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你不熟悉基于SQL的查询，建议你查看SQL查询规范，了解如何使用`SELECT`从特定表中进行选择，如何使用`ORDER`进行排序，如何使用`JOIN`关键字执行连接操作。
- en: 'Well, if you know the SQL query, you should get a new dataset by using a complex
    SQL query as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，如果你知道SQL查询，你应该使用如下复杂的SQL查询获取一个新的数据集：
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![](img/4bc62580-9bc3-4f30-846b-b540e7625346.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4bc62580-9bc3-4f30-846b-b540e7625346.png)'
- en: 'Now, to get an insight, we need to know more about the users and their ratings.
    Let''s find the top 10 most active users and how many times they have rated a
    movie:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了深入了解，我们需要更多地了解用户及其评分。让我们找出前10个最活跃的用户，以及他们评分的电影次数：
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![](img/5cbda7d6-4e4c-41d8-9dae-4d925e40931c.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5cbda7d6-4e4c-41d8-9dae-4d925e40931c.png)'
- en: 'Finally, let''s have a look at a particular user and find the movies that,
    say, user 668, rated higher than 4:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看一下某个特定用户，找出例如用户668评分高于4的电影：
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![](img/cbdb75b4-cb1c-493d-ac42-d3425b5250ae.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbdb75b4-cb1c-493d-ac42-d3425b5250ae.png)'
- en: Movie rating prediction
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电影评分预测
- en: 'First, we perform the rating prediction using FM algorithms that learn using
    `PointWiseGradientDescent`. We start with preprocessing and converting data into
    the LibFM format. To run this rating prediction using the following order of execution:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用FM算法进行评分预测，该算法通过`PointWiseGradientDescent`学习。我们从数据预处理和转换为LibFM格式开始。要运行此评分预测，请按以下执行顺序：
- en: First, execute `MovieLensFormaterWithMetaData.java` ;to generate the `MovieLens`
    data in the `LibFM` format.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，执行`MovieLensFormaterWithMetaData.java`；生成`LibFM`格式的`MovieLens`数据。
- en: Then, execute `SplitDataWithMetaData.java` to prepare the training, test, and
    validation sets.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，执行`SplitDataWithMetaData.java`来准备训练集、测试集和验证集。
- en: Finally, execute ;`MovieRatingPrediction.java`, which is the main class.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，执行`MovieRatingPrediction.java`，这是主类。
- en: Converting the dataset into LibFM format
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据集转换为LibFM格式
- en: The FM-based model that we are going to reuse can consume the training data
    only in LibFM format, which is more or less the same as LibSVM. Therefore, first,
    we must format the MovieLens 1M dataset sp that the training dataset contains
    both users, movies, and existing rating information.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要重用的基于FM的模型只能消耗LibFM格式的训练数据，这与LibSVM格式差不多。因此，首先我们必须将MovieLens 1M数据集格式化，以便训练数据集包含用户、电影和现有评分信息。
- en: The LibFM format is similar to the LibSVM format but has some basic differences.
    For more information, interested readers can take a look at [http://www.libfm.org/libfm-1.42.manual.pdf](http://www.libfm.org/libfm-1.42.manual.pdf).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: LibFM格式类似于LibSVM格式，但有一些基本的区别。更多信息，感兴趣的读者可以查看[http://www.libfm.org/libfm-1.42.manual.pdf](http://www.libfm.org/libfm-1.42.manual.pdf)。
- en: 'At the same time, new features will be generated by the user information and
    movie information. First, we will define the input (this will be updated according
    to users, movies, and ratings) and output file path as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，新特性将由用户信息和电影信息生成。首先，我们将定义输入（这将根据用户、电影和评分更新）和输出文件路径，如下所示：
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we define the data path and the output folder, where the generated data
    in LibFM format will be saved:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义数据路径和输出文件夹，用于保存生成的LibFM格式数据：
- en: '[PRE13]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we define the target column, which is to be predicted by the FM model.
    Additionally, we also delete the timestamp column:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们定义目标列，这是FM模型要预测的内容。此外，我们还删除了时间戳列：
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we set the separator as `::` and offset:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置分隔符为`::`并进行偏移：
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we read and parse the user''s data (that is, `users.dat`) and create
    three `Map<Integer, String>` for the user''s genre, the user''s age, and the user''s
    occupation:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们读取并解析用户数据（即`users.dat`），并为用户的类型、年龄和职业信息创建三个`Map<Integer, String>`：
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we parse the movie dataset to create a `Map<Integer, String>` for movies:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们解析电影数据集，创建一个`Map<Integer, String>`来存储电影信息：
- en: '[PRE17]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we parse the rating dataset to create a `Map<Integer, String>` for existing
    ratings. Additionally, we define the output filename where the rating data in
    the LibFM format will be saved:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们解析评分数据集，创建一个`Map<Integer, String>`来存储现有的评分。此外，我们定义了LibFM格式下将保存评分数据的输出文件名：
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we start adding attributes such as gender information, age, occupation,
    and movie class information:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们开始添加一些属性，如性别信息、年龄、职业和电影类别信息：
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the previous code block, `:1` ;stands for which movie the user has provided
    a rating for. Finally, we add the metadata information, `userid` and `movieid`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，`:1`代表用户为哪个电影提供了评分。最后，我们添加元数据，`userid`和`movieid`：
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, the resulting rating dataset (once `MovieLensFormaterWithMetaData.java`
    is executed) in LibFM format will be saved in the `formatted_data` directory as
    `ratings.libfm` ;having the following structure:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，生成的评分数据集（执行`MovieLensFormaterWithMetaData.java`后）将以LibFM格式保存在`formatted_data`目录下，文件名为`ratings.libfm`，其结构如下：
- en: '![](img/260b022e-5277-4ad9-ba90-c0104a8266db.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/260b022e-5277-4ad9-ba90-c0104a8266db.png)'
- en: Training and test set preparation
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练集和测试集的准备
- en: 'Now that we have seen how to convert rating, movie, and metadata, we can now
    start creating training, test, and validation sets from the data in LibFM format.
    First, we set the path of the LibFM files to be used as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何转换评分、电影和元数据，接下来我们可以开始从LibFM格式的数据中创建训练集、测试集和验证集。首先，我们设置将要使用的LibFM文件的路径，如下所示：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we show the output directory to write the split training, validation,
    and test sets:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们展示输出目录，用于写入分割后的训练集、验证集和测试集：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we instantiate the `BufferedWriter` that is going to be used for writing
    the split files:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们实例化一个`BufferedWriter`，用于写入分割后的文件：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we close the file pointers to release the resources:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们关闭文件指针以释放资源：
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, the resulting rating datasets (once `SplitDataWithMetaData.java` is executed)
    in LibFM format will be saved in the `formatted_data` directory having the following
    LibFM (similar to LibSVM) format:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，结果评分数据集（执行`SplitDataWithMetaData.java`后）将以LibFM格式保存在`formatted_data`目录中，格式与LibSVM类似：
- en: '![](img/36100945-4ad5-4e4b-b091-e80013f3884c.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36100945-4ad5-4e4b-b091-e80013f3884c.png)'
- en: 'Finally, the directory (that is, `formatted_data`) will have the following
    files in it:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，目录（即`formatted_data`）将包含以下文件：
- en: '![](img/11798569-110f-47d7-80ab-8e97f2a8aa58.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11798569-110f-47d7-80ab-8e97f2a8aa58.png)'
- en: Fantastic! Now that our dataset is ready, we can now start making the movie
    rating prediction using the FM algorithm.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们的数据集已经准备好，我们可以使用FM算法开始进行电影评分预测了。
- en: Movie rating prediction
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电影评分预测
- en: 'Now that all of the datasets required for training, validating, and evaluating
    are ready, we can start training the FM model. We first start by showing the filename
    for the training data:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有训练、验证和评估所需的数据集都已准备就绪，我们可以开始训练FM模型。我们首先展示训练数据的文件名：
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we set the testing data file path:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置测试数据文件路径：
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we set the testing metadata file path:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置测试元数据文件路径：
- en: '[PRE27]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, the filename for the final prediction output file:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，设置最终预测输出文件的文件名：
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we set up the path for writing the logs, metrics, time, and so on for
    each iteration to a file (but don''t worry, we will see them in graph form, too):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置日志、指标、时间等每次迭代的文件写入路径（但不用担心，我们也会看到图形形式的结果）：
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we set up the dimension of k0, k1, and k2 so that k0 is use bias, k1
    is the use of one-way interactions, and k2 is the dim of two-way interactions:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置k0、k1和k2的维度，使得k0用于偏置，k1用于单向交互，k2用于双向交互的维度：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We will iterate the training for 100 times the number of iterations:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将迭代训练100次迭代次数：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We then set the learning rate for SGD—the rate at which the optimizer tries
    to minimize the error:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们为SGD设置学习率——优化器试图最小化误差的速率：
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now that the optimizer knows the learning rate, the next important parameter
    is setting up the regularization parameters to regularize the training against
    overfitting.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在优化器已经知道了学习率，接下来的重要参数是设置正则化参数，以防止训练时过拟合。
- en: 'The Java-based FM library needs three-way regularization: bias, one-way, and
    two-way regularization. Therefore, the format accepted by the FM library is r0,
    r1, r2\. Here, r0 is bias regularization, r1 is one-way regularization, and r2
    is two-way regularization:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Java的FM库需要三种正则化：偏置、单向和双向正则化。因此，FM库接受的格式是r0、r1、r2。这里，r0是偏置正则化，r1是单向正则化，r2是双向正则化：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we initialize the standard deviations for the initialization of two-way
    factors:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们初始化用于初始化双向因子的标准差：
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we use the ;`LibSVMDataProvider()` class for loading both training and
    test sets:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`LibSVMDataProvider()`类加载训练集和测试集：
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'One the training and test sets are loaded, we start creating the user-item
    table (that is, the main table):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦训练集和测试集加载完成，我们开始创建用户-物品表（即主表）：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, we instantiate the factorization machine before we start the training:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实例化因式分解机，在开始训练之前：
- en: '[PRE37]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, the `init()` method is used for initializing the parameters needed for
    instantiating and training the following FM model''s parameters:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`init()`方法初始化实例化和训练以下FM模型所需的参数：
- en: '[PRE38]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The signature of the `init()` method goes as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`init()`方法的签名如下：'
- en: '[PRE39]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, we set the number of attributes and standard deviations from the main
    class:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置主类的属性数和标准差：
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, we set the number of dimensions in the factorization. In our case, we
    have 3-way interaction—user, movie, and rating:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置因式分解的维度数量。在我们的例子中，我们有三种交互——用户、电影和评分：
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The preceding values are actually parsed using the `getIntegerValues()` method,
    which accepts the dimension as a string and split using `,`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的值实际上是通过`getIntegerValues()`方法解析的，该方法接受维度作为字符串并使用`,`进行拆分。
- en: 'Finally, it returns only integer values for the dimension to be used by the
    model for making interactions. The following signature is used for this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它只返回用于模型进行交互的维度的整数值。使用以下签名来实现：
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, we set up the learning method as **Stochastic Gradient Descent** (**SGD**):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将学习方法设置为**随机梯度下降**（**SGD**）：
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, we define the task to be performed. In our case, it is regression. However,
    we are going to use ;`TASK_CLASSIFICATION` for classification:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们定义要执行的任务类型。在我们的例子中，它是回归。然而，我们将使用 `TASK_CLASSIFICATION` 进行分类：
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, we set the regularization:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置正则化：
- en: '[PRE45]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, when it comes to the learning rate, we have to set the learning rates
    (individual, per layer) unlike the DL4J library:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，关于学习率，我们必须设置每层的学习率（单独设置），这与 DL4J 库不同：
- en: '[PRE46]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The preceding values are actually parsed using the `getDoubleValues()` method,
    which accepts the learning rate as a string and split using `,`. Finally, it returns
    only a single value for the learning rate to be used by the model. The following
    signature is used for this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的值实际上是通过 `getDoubleValues()` 方法解析的，该方法接受一个字符串形式的学习率，并使用 `,` 进行分割。最后，它返回一个单一的学习率值供模型使用。此方法的签名如下：
- en: '[PRE47]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now that all the hyperparameters are set, we are ready to start the training.
    For this, unlike DL4J FM, it comes with a ;`learn()` method for learning the model:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的超参数都已经设置好，我们准备开始训练了。与 DL4J FM 不同的是，它提供了一个 `learn()` 方法来学习模型：
- en: '[PRE48]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `learn()` method is an abstract method that takes both train and test sets:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`learn()` 方法是一个抽象方法，接收训练集和测试集：'
- en: '[PRE49]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The concrete implementation of the ;`learn()` method takes both the training
    and test sets. Then, it shuffles the training set to avoid the bias in training.
    Then, it performs the prediction operation using the ;`predict()` method for the
    task type we defined at the beginning (that is, regression in our case).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`learn()` 方法的具体实现需要同时传入训练集和测试集。然后，它会打乱训练集，以避免训练中的偏差。接着，使用 `predict()` 方法进行预测操作，基于我们一开始定义的任务类型（在我们这个例子中是回归）。'
- en: 'Finally, it evaluates the model on the test set and computes the MSE for both
    the training and test set. The actual implementation of this method goes as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它会在测试集上评估模型，并计算训练集和测试集的均方误差（MSE）。该方法的实际实现如下：
- en: '[PRE50]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the preceding code block, the FM model performs the prediction operation,
    similar to any other regression algorithm, by considering three-way interaction
    and so on and computing the prediction as a probability:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，FM 模型通过考虑三元交互等方式进行预测操作，类似于其他回归算法，并将预测结果计算为概率：
- en: '[PRE51]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Nevertheless, at the end, the training and test MSE per iteration is visualized
    using the `plot()` method from the `PlotUtil_Rating` class. We'll discuss this
    class later on.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最后，使用 `PlotUtil_Rating` 类中的 `plot()` 方法对每次迭代的训练和测试 MSE 进行可视化。我们稍后会讨论这个类。
- en: 'Additionally, we also initialize the logging so that the result and progress
    of the computations are printed on the console:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还初始化了日志记录，以便在控制台上打印计算的结果和进度：
- en: '[PRE52]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, we evaluate the model on the test set. Since our task is a regression
    task, we compute the regression metric, such as RMSE, for each iteration:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在测试集上评估模型。由于我们的任务是回归任务，我们计算每次迭代的回归指标，例如 RMSE：
- en: '[PRE53]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, we save the prediction and all associated metrics in a file:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将预测结果及所有相关的指标保存在一个文件中：
- en: '[PRE55]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The preceding code block will generate two files called ;`predict_output.txt`
    and `metrics_logs.txt` for writing predicted results and logs, respectively. For
    example, a sample from the `predicted_output.txt` file shows that the second column
    is the movie ID and the third column is the predicted rating out of 5.0, as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块将生成两个文件，分别是 `predict_output.txt` 和 `metrics_logs.txt`，用于分别写入预测结果和日志。例如，`predicted_output.txt`
    文件中的一个样本显示第二列是电影 ID，第三列是预测评分（满分 5.0），如下所示：
- en: '[PRE56]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'On the other hand, `metrics_logs.txt` shows metrics such as RMSE, MAE, logs,
    as shown in the following diagram:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`metrics_logs.txt` 显示了包括 RMSE、MAE 和日志等指标，如下图所示：
- en: '![](img/1133cb50-c9fd-41d2-9223-a7f4e5cd5a08.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1133cb50-c9fd-41d2-9223-a7f4e5cd5a08.png)'
- en: 'Nevertheless, since making some sense of the training status and prediction,
    it is difficult just seeing these values, therefore, I decided to plot them. The
    following graph shows the MSE for both the training and testing phase for each
    iteration:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于仅凭这些数值难以理解训练状态和预测效果，我决定将它们绘制成图。以下图展示了每次迭代的训练和测试阶段的 MSE：
- en: '![](img/7f56c119-7126-4ba2-8020-792ced3044aa.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f56c119-7126-4ba2-8020-792ced3044aa.png)'
- en: Training and test MSE per iteration (for 100 iterations)
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 每次迭代的训练和测试 MSE（100 次迭代）
- en: 'The preceding graph shows that both training and test errors are consistent,
    which means the FM model was not overfitted. This graph also shows that the error
    count is still very high. Then, I iterated the training 1,000 times and found
    that errors had been reduced slightly, which is reported in the following graph:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 前述图表显示，训练误差和测试误差一致，这意味着FM模型没有过拟合。该图表还显示，错误数量仍然很高。然后，我将训练迭代了1,000次，发现错误有所减少，具体内容如下图所示：
- en: '![](img/c151fd9e-375d-4f6d-8405-c803b312bbb5.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c151fd9e-375d-4f6d-8405-c803b312bbb5.png)'
- en: Training and test MSE per iteration for up to 1,000 iterations
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 每次迭代的训练和测试均方误差（MSE），最多迭代1,000次
- en: 'Now, to plot the preceding graph, I wrote a ;`plot()` method in the `PlotUtil_Rating.java`
    class that uses the ;`JFreeChart` library for plotting the training and test error/iteration:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了绘制前述图表，我在`PlotUtil_Rating.java`类中编写了一个`plot()`方法，使用`JFreeChart`库绘制训练和测试误差/迭代：
- en: '[PRE57]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Whereas the `addSeries()` method from the `XYSeries` class adds the series
    for the plot:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 而`XYSeries`类中的`addSeries()`方法用于为图表添加系列：
- en: '[PRE58]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Which one makes more sense ;– ranking or rating?
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哪个更有意义；– 排名还是评分？
- en: Is a rating or ranking prediction more logical while developing a movie recommendation
    system? If the amount of ratings per user is high enough, factorizing the user-product
    matrix is the best thing, in my opinion. However, if the dataset is too sparse,
    the prediction can be extremely inaccurate.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发电影推荐系统时，评分预测还是排名预测更具逻辑性？如果每个用户的评分量足够高，分解用户-产品矩阵是最好的方法。在我看来，然而，如果数据集过于稀疏，预测可能会非常不准确。
- en: Knowing this fact, I was exploring the RankSys library and found that one of
    the contributors is arguing that ranking is more logical. He did not provide any
    explanation, though. Later on, I talked to some recommender system developers
    and researchers and got to know that he probably meant ranking is less sensitive
    to the prediction error due to the gap between a number of ratings and items.
    The reason is that ranking preserves the hierarchy, independent of the absolute
    rating.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 知道这一点后，我开始探索RankSys库，并发现其中一位贡献者认为排名更具逻辑性，尽管他没有提供任何解释。后来，我与一些推荐系统的开发者和研究人员交流，了解到他可能指的是，排名由于评分和项目数量之间的差距，对预测误差不那么敏感。原因是排名保留了层次结构，而不依赖于绝对评分。
- en: 'Based on this understanding, later on, I decided to go one step further toward
    ranking prediction. For this, I wrote a spate class called `RankingPrediction.java`
    for predicting movie ranking by each user in the test set, which has the following
    structure:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此理解，后来我决定向排名预测迈出一步。为此，我编写了一个单独的类`RankingPrediction.java`，用于预测测试集中的每个用户的电影排名，其结构如下：
- en: '![](img/31a53fdf-8eae-44d1-845a-c9ffd79f05f8.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31a53fdf-8eae-44d1-845a-c9ffd79f05f8.png)'
- en: Movie ranking prediction subproject structure
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 电影排名预测子项目结构
- en: 'This has three methods, which are as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 该类有三个方法，具体如下：
- en: '`createIndexFromFile()`: This method is used for the creation of indexes from
    files that are passing as an argument in the method parameters itself.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createIndexFromFile()`：此方法用于根据传入方法参数的文件创建索引。'
- en: '`generateTrainAndTestDataSet()`: This is used for separating data into training
    and testing sets, which is an important part of evaluating data mining models.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generateTrainAndTestDataSet()`：此方法用于将数据分为训练集和测试集，这是评估数据挖掘模型的重要部分。'
- en: '`main()`: This is used for the creation of indexes, both for items and users,
    and is used for the following operations:'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main()`：此方法用于创建项目和用户的索引，并用于以下操作：'
- en: Index for a set of users
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组用户的索引
- en: Index for a set of items
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组项目的索引
- en: Stores the preferences/rating for users and items provided by `FastUserIndex`
    and `FastItemIndex`
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储由`FastUserIndex`和`FastItemIndex`提供的用户和项目的偏好/评分
- en: Creates a recommender interface that will be used by `FMRecommender`
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个推荐接口，将由`FMRecommender`使用
- en: Uses a factorization machine that uses `RMSE-like loss` with a balanced sampling
    of negative instances
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个因式分解机，该机器使用`RMSE-like损失`，并均衡地采样负实例
- en: 'First, we set the path of the input data files:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设置输入数据文件的路径：
- en: '[PRE59]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Then, we set the path for the user and movie indexes stated previously:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置之前提到的用户和电影索引路径：
- en: '[PRE60]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then, we set the path for the resultant file, where the training and test set
    will be generated:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置结果文件的路径，训练集和测试集将在该路径生成：
- en: '[PRE61]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, we create the user index for all the users in the `users.dat` file. Here,
    the users are internally represented with numerical indices from 0 (inclusive)
    to the number of indexed users (exclusive):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为`users.dat`文件中的所有用户创建用户索引。在这里，用户在内部由从0（包括）到索引用户数量（不包括）的数字索引表示：
- en: '[PRE62]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the preceding line of code, we used the `SimpleFastUserIndex` class from
    the RankSys library that helped in creating a simple implementation of `FastUserIndex`
    backed by a bi-map called ;`IdxIndex`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行中，我们使用了RankSys库中的`SimpleFastUserIndex`类，它帮助我们创建了一个由名为`IdxIndex`的双向映射支持的`FastUserIndex`的简单实现。
- en: 'Then, we create the item index for all of the items in the `movies.dat` file.
    This creates the index for a set of items. Here, the items are internally represented
    with numerical indices from 0 (inclusive) to the number of indexed items (exclusive):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为`movies.dat`文件中的所有项目创建项目索引。这为一组项目创建了索引。在这里，项目在内部由从0（包括）到索引项目数量（不包括）的数字索引表示：
- en: '[PRE63]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In the preceding line of code, we used the `SimpleFastItemIndex` class from
    the RankSys library, which helps us create a simple implementation of `FastItemIndex`
    backed by a bi-map called ;`IdxIndex`. Then, we store the preferences/rating for
    users and items provided by `FastUserIndex` and `FastItemIndex`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行中，我们使用了RankSys库中的`SimpleFastItemIndex`类，它帮助我们创建了一个由名为`IdxIndex`的双向映射支持的`FastItemIndex`的简单实现。然后，我们存储了由`FastUserIndex`和`FastItemIndex`提供的用户和项目的偏好/评分：
- en: '[PRE64]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then, we invoke these two methods for creating user and item indexes:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用这两个方法来创建用户和项目索引：
- en: '[PRE65]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In the preceding if statements, we generated indexes from file using the `createIndexFromFile()`
    method that goes as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的if语句中，我们使用`createIndexFromFile()`方法从文件中生成了索引，该方法如下所示：
- en: '[PRE66]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Once the index files are generated, we then start generating the training and
    test sets as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦索引文件生成，我们就开始生成训练集和测试集，如下所示：
- en: '[PRE67]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In this code block, we used the ;`generateTrainAndTestDataSet()` method for
    generating both training and test sets:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码块中，我们使用了`generateTrainAndTestDataSet()`方法来生成训练集和测试集：
- en: '[PRE68]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The preceding method divides up 2/3 as the training set and 1/3 as the test
    set. Finally, the file pointers are closed to release the resources. If the preceding
    three if statements executed successfully, you should see that two index files
    and two other files for the training and test sets have been generated:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 前述方法将2/3作为训练集，1/3作为测试集。最后，文件指针被关闭，以释放资源。如果前三个if语句成功执行，您应该会看到生成了两个索引文件和两个其他文件（分别用于训练集和测试集）：
- en: '![](img/f570978c-1cf1-4616-a08b-e0e0228224a3.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f570978c-1cf1-4616-a08b-e0e0228224a3.png)'
- en: 'Then, we create a recommender interface, which will be used by the `FMRecommender`
    class, which generates recommendations without any restriction on the items being
    recommended:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个推荐接口，它将由`FMRecommender`类使用，该类生成没有任何推荐项限制的推荐：
- en: '[PRE69]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Finally, wrap up the preference factorization machine to work with RankSys
    user-preference pairs. Then, we train the model by setting the learning rate,
    regularization, and standard deviation, and iterate the training up to 100 times
    using `PointWiseGradientDescent`. FM then uses RMSE-like loss with a balanced
    sampling of negative instances:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，包装偏好因子分解机以与RankSys用户-偏好对配合使用。然后，我们通过设置学习率、正则化和标准差来训练模型，并使用`PointWiseGradientDescent`迭代训练最多100次。FM然后使用类似RMSE的损失，并通过负实例的平衡抽样：
- en: '[PRE70]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In the preceding code block, the FM model is trained using the `learn()` method,
    which is pretty similar to the `learn()` method used for predicting rating in
    the previous section. Then, to evaluate the model, first, we set the target user
    and `SimpleRecommendationFormat`, which is in tab-separated, user-item score triplets
    (that is, present in the original dataset):'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，FM模型使用`learn()`方法进行训练，该方法与上一节中用于预测评分的`learn()`方法非常相似。然后，为了评估模型，首先，我们设置目标用户和`SimpleRecommendationFormat`，该格式为制表符分隔的用户-项目评分三元组（即原始数据集中的内容）：
- en: '[PRE71]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Then, we invoke the `RecommenderRunner` interface to generate recommendations
    and print it based on the format:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用`RecommenderRunner`接口来生成推荐并根据格式打印出来：
- en: '[PRE72]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The preceding code block will perform the evaluation on the test set and write
    the recommendation in the text file we specified previously:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块将在测试集上执行评估，并将推荐写入我们之前指定的文本文件：
- en: '[PRE73]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The prediction has been saved at outFolder/Ranking_RMSE.txt
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 预测结果已保存在outFolder/Ranking_RMSE.txt
- en: 'Now, let''s take a look at the output file:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看输出文件：
- en: '[PRE74]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This snapshot from the output file shows the predicted ranking by user 944 for
    different movies. Now that we can see that our FM model has predicted the user's
    ranking for movies, inspecting model performance in terms of accuracy and execution
    time would make sense.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这张来自输出文件的快照显示了用户944对不同电影的预测排名。现在我们可以看到我们的FM模型已经预测了用户的电影排名，接下来检查模型在准确性和执行时间方面的表现是有意义的。
- en: 'For this, I wrote a class called `PlotUtil_Rank.java`. This class takes the
    metrics type and a number of iterations and generates the plot using the `plot()`
    method:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我编写了一个名为`PlotUtil_Rank.java`的类。该类接受度量类型和迭代次数，并使用`plot()`方法生成图表：
- en: '[PRE75]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This method is further called from the `PointWiseGradientDescent.java` class.
    First, we create two `ArrayList` of `Double` to hold the execution time and MSE:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法进一步从`PointWiseGradientDescent.java`类中调用。首先，我们创建两个`ArrayList`类型的`Double`来存储执行时间和MSE：
- en: '[PRE76]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Then, for each iteration, the ;`learn()` method generates both the MSE error
    and time for each iteration and puts them in the list:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于每次迭代，`;` `learn()` 方法会生成每次迭代的MSE误差和时间，并将它们放入列表中：
- en: '[PRE77]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Finally, the `plot()` method is called as follows to plot the graph:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用`plot()`方法绘制图表，如下所示：
- en: '[PRE78]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'By the way, `convertobjectArraytoDouble()`, which is shown in the following
    code, is used to convert the object array into doubles to act as data points for
    the plots:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，`convertobjectArraytoDouble()`，在下面的代码中显示，用于将对象数组转换为双精度数值，以作为绘图的数据点：
- en: '[PRE79]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The preceding invocation should generate two graphs. First, we see the MSE
    per iteration, and the following graph reports the same for 100 iterations:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 上述调用应该生成两个图表。首先，我们看到每次迭代的MSE，接下来的图表报告了100次迭代的相同数据：
- en: '![](img/07ab7d7b-9aca-4220-9d58-84f427c6cee1.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07ab7d7b-9aca-4220-9d58-84f427c6cee1.png)'
- en: MSE per iteration (up to 100^(th))
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 每次迭代的MSE（最多到第100次迭代）
- en: 'Then, we see the time per iteration, and the following graph reports the same
    for the 100th iteration:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看到每次迭代的时间，接下来的图表报告了第100次迭代的相同数据：
- en: '![](img/dfe6c1de-3150-473f-9461-dce817101237.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dfe6c1de-3150-473f-9461-dce817101237.png)'
- en: Time per iteration (up to 100^(th))
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 每次迭代的时间（最多到第100次迭代）
- en: Finally, from the second graph, we cannot make important insights except that
    the execution time per iteration fluctuated a lot. However, on the 90^(th) iteration,
    the time needed for each iteration was saturated.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，从第二个图表中，我们无法得出重要的结论，除了每次迭代的执行时间波动很大。然而，在第90次迭代时，每次迭代所需的时间已经达到饱和。
- en: On the other hand, the MSE drastically decreased after the 20th iteration from
    0.16 to 0.13, but was saturated after the 25^(th) iteration. This means increasing
    only a number of iterations, will not help us further reduce the MSE. Therefore,
    I would suggest that you try this after changing not only the number of iterations
    but also other hyperparameters.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，MSE在第20次迭代后大幅下降，从0.16降到0.13，但在第25次迭代后趋于饱和。这意味着仅增加迭代次数并不能进一步减少MSE。因此，我建议你在改变迭代次数的同时，也要尝试调整其他超参数。
- en: Frequently asked questions (FAQs)
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题解答（FAQs）
- en: Now that we have seen how to develop a movie recommendation that predicts both
    the rating and ranking of movies by users, there are some issues that require
    our attention, too. Also, we couldn't cover/discuss the library in this chapter,
    so I suggest that you read the documentation more carefully.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到如何开发一个电影推荐系统，预测用户对电影的评分和排名，还有一些问题也需要我们关注。同时，本章没有涵盖/讨论该库，因此我建议你仔细阅读文档。
- en: However, we will still see some frequently asked questions that might already
    be on your mind in this section. Answers to these questions can be found in the
    Appendix.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然会在本节中看到一些你可能已经想过的常见问题。你可以在附录中找到这些问题的答案。
- en: How can I save a trained FM model?
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何保存一个训练好的FM模型？
- en: How can I restore a saved FM model from disk?
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何从磁盘恢复一个已保存的FM模型？
- en: Can I use the FM algorithm for solving a classification task?
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我可以使用FM算法来解决分类任务吗？
- en: Give me a few example use cases where FM algorithms have been used.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给我几个FM算法应用的示例用例。
- en: Can I use the FM algorithm for making top-N recommendations?
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我可以使用FM算法进行Top-N推荐吗？
- en: Summary
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw how to develop a movie recommendation system using FMs,
    which are a set of algorithms that enhance the performance of linear models by
    incorporating second-order feature interactions that are absent in matrix factorization
    algorithms in a supervised way.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用FM开发一个电影推荐系统，FM是一组算法，通过以监督的方式引入缺失在矩阵分解算法中的二阶特征交互，从而增强线性模型的性能。
- en: Nevertheless, we have seen some theoretical background of recommendation systems
    using matrix factorization and collaborative filtering before diving into the
    project's implementation using RankSys library-based FMs. Due to page limitation,
    I didn't discuss the library more extensively. However, readers are suggested
    to take a look athe API documentation on GitHub at [https://github.com/RankSys/RankSys](https://github.com/RankSys/RankSys).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在深入讨论使用基于RankSys库的FM实现项目之前，我们已经看过了使用矩阵分解和协同过滤的推荐系统的理论背景。由于页面限制，我没有详细讨论该库。建议读者查阅GitHub上的API文档：[https://github.com/RankSys/RankSys](https://github.com/RankSys/RankSys)。
- en: This project not only covers movie rating prediction by individual users but
    also discusses ranking prediction, too. Consequently, we also used FMs for predicting
    the ranking of movies.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目不仅涵盖了由个人用户进行的电影评分预测，还讨论了排名预测。因此，我们还使用了FM（因子分解机）来预测电影的排名。
- en: This is more or less the end of our journey toward developing an end-to-end
    project with Java. However, we are not done yet! In the next chapter, we will
    discuss some recent trends of deep learning. Then, we will see some emerging use
    cases that can be implemented using DL4J library or least we'll see some pointers.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这或多或少是我们开发一个端到端Java项目的旅程的结束。然而，我们还没有结束！在下一章中，我们将讨论一些深度学习的最新趋势。然后，我们将看到一些可以使用DL4J库实现的新兴用例，或者至少我们会看到一些指引。
- en: Answers to questions
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题的答案
- en: '**Answer** **to question 1**: For this, you can invoke the `saveModel()` method
    by providing the input model filename:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题1的答案**：为此，您可以通过提供输入模型文件名来调用`saveModel()`方法：'
- en: '[PRE80]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `saveModel()` method goes as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveModel()`方法如下：'
- en: '[PRE81]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Then, the method will save all the metadata (including dimension, rank, weight,
    and attribute information) of the trained model onto disk.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，该方法将把训练模型的所有元数据（包括维度、排名、权重和属性信息）保存到磁盘。
- en: '**Answer** **to question 2**: For this, you can invoke the ;`therestoreModel()`
    method by providing the input model filename:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题2的答案**：为此，您可以通过提供输入模型文件名来调用`restoreModel()`方法：'
- en: '[PRE82]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The invocation of this method will restore the saved model, including all the
    metadata (for example, dimension, rank, weight, and attribute information) of
    the trained model from the disk.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的调用将恢复保存的模型，包括从磁盘加载的训练模型的所有元数据（例如，维度、排名、权重和属性信息）。
- en: '**Answer** **to question 3**: Yes, of course. This algorithm is very effective
    for very sparse datasets, too. All you need is to have the predicted labels in
    the integer and the task type classification, that is, `task == TaskType.TASK_CLASSIFICATION`.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题3的答案**：是的，当然可以。这种算法对于非常稀疏的数据集也非常有效。您只需要确保预测标签为整数，并且任务类型是分类，即`task == TaskType.TASK_CLASSIFICATION`。'
- en: '**Answer to question 4**: There are several use cases where FM-based approaches
    have been applied. For example:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题4的答案**：有几个使用FM方法的应用场景。例如：'
- en: Predicting whether the user is going to buy an item in a session from a given
    sequence of click events performed by users. Also, if he/she is buying, what would
    be the items he/she is going to buy? This problem is called the RecSys Challenge
    2015 (see more at [http://2015.recsyschallenge.com/challenge.html](http://2015.recsyschallenge.com/challenge.html)).
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测用户是否会在一个会话中购买某个物品，基于用户在该会话中点击的事件序列。如果他/她会购买，那么他/她将购买哪些物品？这个问题被称为RecSys Challenge
    2015（更多内容见[http://2015.recsyschallenge.com/challenge.html](http://2015.recsyschallenge.com/challenge.html)）。
- en: To see a sample solution, interested readers can take a look at the following
    book titled *Deep Learning with TensorFlow - Second Edition* by Karim et al Packt
    Publishing, March 2018 (see more at [https://www.packtpub.com/big-data-and-business-intelligence/deep-learning-tensorflow-second-edition](https://www.packtpub.com/big-data-and-business-intelligence/deep-learning-tensorflow-second-edition)).
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 想要查看示例解决方案的读者可以参考以下书籍：《Deep Learning with TensorFlow - Second Edition》，Karim等人著，Packt出版社，2018年3月（更多内容见[https://www.packtpub.com/big-data-and-business-intelligence/deep-learning-tensorflow-second-edition](https://www.packtpub.com/big-data-and-business-intelligence/deep-learning-tensorflow-second-edition)）。
- en: '*Using Factorization Machines for Hybrid Recommendation Systems Based on Behavioral,
    Product, and Customer Data* (see more at [https://dl.acm.org/citation.cfm?id=2796542](https://dl.acm.org/citation.cfm?id=2796542)).'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于行为、产品和客户数据的混合推荐系统中使用因式分解机*（更多内容请见[https://dl.acm.org/citation.cfm?id=2796542](https://dl.acm.org/citation.cfm?id=2796542)）。'
- en: '**Answer to question 5**: Yes, you can extract it from implicit feedback (from
    reviews, events, transactions, and so on), since converting the rating prediction
    results to top-N lists is a trivial job. However, I don''t think there''s any
    open source implementations available, but you can of course try by modifying
    LibFM significantly to use pairwise ranking.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题5的回答**：是的，你可以从隐式反馈中提取（如评论、事件、交易等），因为将评分预测结果转换为Top-N列表是一个简单的工作。然而，我认为目前没有开源实现可用，但你当然可以通过大幅修改LibFM来尝试使用成对排序。'
