- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Performing Complex Actions by Chaining Functions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过链式连接函数执行复杂操作
- en: In the previous chapter, we learned how to create native plugins, which we used
    to check the format of Excel and Word documents, and semantic plugins, which we
    used to verify whether the content of the documents fulfilled our requirements.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何创建本地插件，我们使用它们来检查 Excel 和 Word 文档的格式，以及语义插件，我们使用它们来验证文档内容是否符合我们的要求。
- en: In this chapter, we will start by creating a simple pipeline that generates
    images. The pipeline will receive a text with clues about an animal and will then
    generate a text that guesses the animal from the clues, as well as generating
    a picture of the animal.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先创建一个简单的管道，该管道生成图像。该管道将接收包含关于动物线索的文本，然后生成一个根据线索猜测动物的文本，以及生成该动物的图片。
- en: 'Later in the chapter, we will continue the application of the previous chapter:
    verifying whether grant requests fulfill some requirements. For that application,
    a grant request will come with two files inside a folder: a Word document and
    an Excel spreadsheet.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将继续应用上一章的内容：验证资助请求是否符合某些要求。为此应用，资助请求将包含文件夹内的两个文件：一个 Word 文档和一个 Excel
    电子表格。
- en: Our application checks that the Word document contains a proposal for a vaccination
    campaign, including the team who will perform it and their experience, and an
    Excel file that contains its budget.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序检查 Word 文档是否包含疫苗接种活动的提案，包括将执行该活动的团队及其经验，以及包含其预算的 Excel 文件。
- en: 'This type of scenario is common in enterprises: governments and corporations
    must prioritize requests for projects, editors must approve or reject book proposals,
    and lawyers must verify that the documents they are filing in court fulfill legal
    requirements. It’s not uncommon to have to verify thousands or tens of thousands
    of documents. This is a kind of job that, until recently, was done manually. We’re
    going to write a pipeline that automates it.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这种场景在企业中很常见：政府和企业必须优先处理项目请求，编辑必须批准或拒绝书籍提案，律师必须核实他们提交给法庭的文件是否符合法律要求。需要核实数千或数万份文件的情况并不少见。这类工作直到最近都是手工完成的。我们将编写一个自动化此过程的管道。
- en: 'In this chapter, we’ll be covering the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating a native plugin that generates images
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建生成图像的本地插件
- en: Chaining a semantic plugin that outputs text with the native plugin that generates
    images
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将输出文本的语义插件与生成图像的本地插件链式连接
- en: Running a complex, multistep pipeline
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行复杂的多步骤管道
- en: By the end of the chapter, you will have the tools required to build a kernel
    that can perform many coordinated functions, and that can be used as a copilot
    or be integrated into other tools, such as a planner.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将拥有构建能够执行许多协调功能的核心所需工具，它可以作为副驾驶或集成到其他工具中，例如规划器。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you will need to have a recent, supported version
    of your preferred Python or C# development environment:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章，您需要拥有您首选的 Python 或 C# 开发环境的最新、受支持的版本：
- en: For Python, the minimum supported version is Python 3.10, and the recommended
    version is Python 3.11
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Python，最低支持的版本是 Python 3.10，推荐版本是 Python 3.11
- en: For C#, the minimum supported version is .NET 8
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 C#，最低支持的版本是 .NET 8
- en: In this chapter, we will call OpenAI services. Given the amount that companies
    spend on training these LLMs, it’s no surprise that using these services is not
    free. You will need an **OpenAI API** key, either directly through **OpenAI**
    or **Microsoft**, via the **Azure** **OpenAI** service.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将调用 OpenAI 服务。鉴于公司在训练这些大型语言模型（LLM）上花费的金额，使用这些服务不是免费的。您需要一个 **OpenAI API**
    密钥，无论是直接通过 **OpenAI** 还是 **Microsoft**，通过 **Azure** **OpenAI** 服务。
- en: If you are using .NET, the code for this chapter is at [https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/dotnet/ch4](https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/dotnet/ch4).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 .NET，本章的代码位于 [https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/dotnet/ch4](https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/dotnet/ch4)。
- en: If you are using Python, the code for this chapter is at [https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/python/ch4](https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/python/ch4).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Python，本章的代码位于 [https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/python/ch4](https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/python/ch4)。
- en: 'You can install the required packages by going to the GitHub repository and
    using the following: `pip install -``r requirements.txt`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问 GitHub 仓库并使用以下命令安装所需的包：`pip install -r requirements.txt`。
- en: Creating a native plugin that generates images
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个生成图像的原生插件
- en: To learn about the power of chaining functions, we are going to create functions
    that perform very different actions. We will start by creating functions that
    generate images and putting them in a plugin. Then, we’re going to learn how to
    incorporate these functions into a more complex chain.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解函数链的强大功能，我们将创建执行非常不同动作的函数。我们将从创建生成图像的函数并将它们放入插件开始。然后，我们将学习如何将这些函数整合到一个更复杂的链中。
- en: In some applications, you may want to generate an image with AI. For example,
    social media posts with images tend to get more engagement, but creating images
    without AI or finding images can be time-consuming and expensive.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些应用中，你可能希望使用 AI 生成图像。例如，带有图像的社交媒体帖子往往能获得更多的互动，但如果没有 AI 或找到图像，创建图像可能会很耗时且成本高昂。
- en: Compared to market prices of non-AI images, generating images with AI is very
    cheap. On the other hand, generating images is still one of the most compute-intensive
    activities that can be done with AI. Recent research from Hugging Face [1] has
    shown that generating an image is 2,000 times more expensive in terms of carbon
    emissions than generating a text answer. These costs will be passed down to you.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与非 AI 图像的市场价格相比，使用 AI 生成图像非常便宜。另一方面，使用 AI 生成图像仍然是计算密集型活动之一。来自 Hugging Face 的最新研究
    [1] 表明，生成一张图像在碳排放方面的成本是生成一个文本答案的 2,000 倍。这些成本将转嫁给你们。
- en: Costs of OpenAI image generation
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAI 图像生成的成本
- en: If you want to reproduce the content in this section, be aware that image generation
    is far more costly than text generation. You will need an API key, and each image
    generation costs $0.04 per image for the following examples, and up to $0.12 per
    image if you want to create higher-quality images with higher resolutions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想复制本节的内容，请注意图像生成比文本生成成本高得多。你需要一个 API 密钥，以下示例中，每生成一张图像的成本为 0.04 美元，如果你想要创建更高分辨率、更高质量的图像，每张图像的成本可能高达
    0.12 美元。
- en: Prices change frequently, and you can check the latest prices at [https://openai.com/pricing](https://openai.com/pricing).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 价格经常变动，你可以在 [https://openai.com/pricing](https://openai.com/pricing) 查看最新的价格。
- en: In *Figure 4**.1*, we show two examples of images generated with AI that I have
    created to enhance a couple of my social media posts. The first, me as a cowboy,
    was for a post about billionaires using cowboy hats. The second, with me as a
    character on the cover of a romantic novel, was for a post about writing fiction.
    Each image took less than a minute to generate with AI. I ran a test in Threads,
    Instagram’s new microblogging app where I have over 10,000 followers, and the
    image posts had multiple times more engagement than posts with the same text but
    no image.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 4**.1 中，我们展示了两个使用 AI 生成的图像示例，我创建这些图像是为了增强我的几篇社交媒体帖子。第一个，我作为一个牛仔，是为了关于亿万富翁戴牛仔帽的帖子。第二个，我作为一个浪漫小说封面的角色，是为了关于写小说的帖子。每个图像使用
    AI 生成的时间不到一分钟。我在 Threads 上进行了一次测试，Threads 是 Instagram 的新微型博客应用，我有超过 10,000 名关注者，带有图像的帖子比只有文字但没有图像的帖子获得了多倍的互动。
- en: '![Figure 4.1 – Images generated with AI for social media posts](img/B21826_04_1.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 用于社交媒体帖子的 AI 生成的图像](img/B21826_04_1.jpg)'
- en: Figure 4.1 – Images generated with AI for social media posts
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 用于社交媒体帖子的 AI 生成的图像
- en: Image generation support in Microsoft Semantic Kernel is not consistent. The
    C# API has an object called `TextToImage` that can generate images using DALL-E
    2, a model released in November 2022, but that API is not available for Python.
    That image-generating model is now obsolete, having been superseded by DALL-E
    3 in October of 2023; however, at the time of writing, Semantic Kernel does not
    offer an out-of-the-box way to access DALL-E 3.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Semantic Kernel 中的图像生成支持并不一致。C# API 有一个名为 `TextToImage` 的对象，可以使用 2022
    年 11 月发布的 DALL-E 2 模型生成图像，但该 API 不可用于 Python。这个图像生成模型现在已经过时，因为 2023 年 10 月被 DALL-E
    3 取代；然而，在撰写本文时，Semantic Kernel 并没有提供一种现成的访问 DALL-E 3 的方法。
- en: We will create two native plugins, one for C# and one for Python, that allow
    us to access DALL-E 3 from Semantic Kernel.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个本地插件，一个用于 C#，一个用于 Python，这样我们就可以从 Semantic Kernel 访问 DALL-E 3。
- en: Adding new models to the kernel
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 向内核添加新模型
- en: Although we are using DALL-E 3, as an interesting and novel model, as the example
    that we are adding to the kernel, this approach of creating a native plugin wrapper
    works for any model that has an API, including Claude from Anthropic, Gemini from
    Google, and hundreds of models from Hugging Face. Any AI service that is made
    available through a REST API can be added in this way.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们使用的是 DALL-E 3，作为一个有趣且新颖的模型，作为我们添加到内核的示例，但创建本地插件包装器的方法适用于任何具有 API 的模型，包括
    Anthropic 的 Claude、Google 的 Gemini 以及来自 Hugging Face 的数百个模型。任何通过 REST API 提供的
    AI 服务都可以以这种方式添加。
- en: Writing a DALL-E 3 wrapper in Python
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Python 中编写 DALL-E 3 包装器
- en: 'It is easier to write a DALL-E 3 wrapper in Python than in C# because OpenAI
    offers and supports a Python package called openai that allows developers to access
    any new OpenAI function as soon as it’s made available. All we must do is create
    a native function that uses the OpenAI package and send a request to DALL-E 3:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中编写 DALL-E 3 包装器比在 C# 中更容易，因为 OpenAI 提供并支持一个名为 openai 的 Python 包，允许开发者在新功能发布时立即访问任何新功能。我们只需创建一个使用
    OpenAI 包的本地函数并向 DALL-E 3 发送请求：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As we saw in [*Chapter 3*](B21826_03.xhtml#_idTextAnchor071), we declare a native
    function using the `kernel_function` decorator. We then simply instantiate an
    OpenAI client object with our API key.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [*第 3 章*](B21826_03.xhtml#_idTextAnchor071) 中所看到的，我们使用 `kernel_function`
    装饰器声明一个本地函数。然后我们只需使用我们的 API 密钥实例化一个 OpenAI 客户端对象。
- en: 'Now let’s submit the request:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们提交请求：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Python OpenAI client contains the `images.generate` method, which will call
    DALL-E 3 and return the generated URL. We simply call it and return the URL.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Python OpenAI 客户端包含 `images.generate` 方法，该方法将调用 DALL-E 3 并返回生成的 URL。我们只需调用它并返回
    URL。
- en: 'Now, we are going to create a simple script that instantiates the plugin and
    calls it:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个简单的脚本，实例化插件并调用它：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code instantiates the `Dalle3` native plugin and calls its `ImageFromPrompt`
    function with the `"A painting of a cat sitting on a sofa in the impressionist
    style"` input parameter. An example output is in *Figure 4**.2*:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码实例化了 `Dalle3` 本地插件，并使用 `"A painting of a cat sitting on a sofa in the impressionist
    style"` 输入参数调用其 `ImageFromPrompt` 函数。一个示例输出在 *图 4**.2* 中：
- en: '![Figure 4-2 – A cat in the impressionist style generated by DALL-E 3 by Python](img/B21826_04_2.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 4-2 – 由 Python 生成的 DALL-E 3 的印象派风格猫](img/B21826_04_2.jpg)'
- en: Figure 4.2 – A cat in the impressionist style generated by DALL-E 3 by Python
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 由 Python 生成的 DALL-E 3 的印象派风格猫
- en: Now that we have seen how to do this in Python, let’s see how to do it in C#.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何在 Python 中实现这一点，接下来让我们看看如何在 C# 中实现。
- en: Writing a DALL-E 3 wrapper in C#
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 C# 中编写 DALL-E 3 包装器
- en: OpenAI does not provide a supported package for C# that allows users of that
    language to interact with its service. The best way of interacting with the OpenAI
    service for C# users is to use Microsoft Semantic Kernel, which has a `TextToImage`
    functionality, but at the time of writing, it only provides connectivity to DALL-E
    2.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAI 没有为 C# 提供受支持的包，该包允许该语言的用户与服务进行交互。对于 C# 用户来说，与 OpenAI 服务交互的最佳方式是使用 Microsoft
    Semantic Kernel，它具有 `TextToImage` 功能，但在撰写本文时，它仅提供对 DALL-E 2 的连接。
- en: 'Most AI services will expose a REST API. Therefore, to connect Microsoft Semantic
    Kernel to them, one solution is to write a native plugin that wraps the REST API.
    We show how to do this for DALL-E 3 here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 AI 服务都会公开 REST API。因此，要将 Microsoft Semantic Kernel 连接到它们，一个解决方案是编写一个本地插件，该插件包装
    REST API。我们在这里展示了如何为 DALL-E 3 实现这一点：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Making a REST `POST` request requires several packages, such as `System.Text.Json`
    and `System.Net`. Like what we did in [*Chapter 3*](B21826_03.xhtml#_idTextAnchor071),
    we use a decorator, `KernelFunction`, to signal that the function is accessible
    to Semantic Kernel, and a `Description` attribute to describe what our function
    does.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 制作 REST `POST` 请求需要几个包，例如 `System.Text.Json` 和 `System.Net`。就像我们在[*第三章*](B21826_03.xhtml#_idTextAnchor071)中所做的那样，我们使用一个装饰器，`KernelFunction`，来指示该函数对语义内核是可访问的，并使用`Description`属性来描述我们的函数功能。
- en: 'We then create an `HttpClient` object. This object will make a REST API call.
    We need to set it up with our API key as a `Bearer` token and set its header as
    accepting “`application/json`” because that’s how the OpenAI API will respond:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个`HttpClient`对象。此对象将执行 REST API 调用。我们需要使用我们的 API 密钥作为`Bearer`令牌来设置它，并将其头设置为接受“`application/json`”，因为
    OpenAI API 将以这种方式响应：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next step is to submit the `POST` request to the API:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是向 API 提交`POST`请求：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We created a JSON object, `obj`, using the fields that are required by the
    OpenAI API. The `model` field states what model we’re using, and here we make
    sure to specify `"dall-e-3"` to use DALL-E 3\. The documentation of all the possible
    parameters can be found here: [https://platform.openai.com/docs/api-reference/images/create](https://platform.openai.com/docs/api-reference/images/create).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 OpenAI API 所需的字段创建了一个 JSON 对象，`obj`。`model`字段说明了我们正在使用什么模型，在这里我们确保指定`"dall-e-3"`以使用
    DALL-E 3。所有可能参数的文档可以在这里找到：[https://platform.openai.com/docs/api-reference/images/create](https://platform.openai.com/docs/api-reference/images/create)。
- en: 'The final step is to recover the `url` field from the JSON returned by OpenAI.
    That `url` field points to the image:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是从 OpenAI 返回的 JSON 中恢复`url`字段。该`url`字段指向图像：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, let’s see how to call the plugin:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何调用该插件：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To call the plugin, we added a reference to the source file, `Plugins`, instantiated
    the `Dalle3` plugin with `AddFromType`, and called its `ImageFromPrompt` method,
    passing `prompt` as a parameter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用插件，我们在源文件中添加了对`Plugins`的引用，使用`AddFromType`实例化了`Dalle3`插件，并调用了它的`ImageFromPrompt`方法，将`prompt`作为参数传递。
- en: 'The resulting picture is the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图片如下：
- en: '![Figure 4.3 – A cat in the impressionist style generated by the C# native
    plugin](img/B21826_04_3.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 由 C# 本地插件生成的印象派风格的猫](img/B21826_04_3.jpg)'
- en: Figure 4.3 – A cat in the impressionist style generated by the C# native plugin
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 由 C# 本地插件生成的印象派风格的猫
- en: Now that we have created a function that accesses a new service, let’s incorporate
    it into a solution that uses it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个可以访问新服务的函数，让我们将其整合到使用它的解决方案中。
- en: Using multiple steps to solve a problem
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多个步骤解决问题
- en: Although programming solutions step by step can be very helpful, one of the
    best abilities that Semantic Kernel gives users is allowing them to make requests
    using natural language. This will require using **planners**, which we will use
    in [*Chapter 5*](B21826_05.xhtml#_idTextAnchor106), to break down a user request
    into multiple steps and then automatically call each step in the appropriate order.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然逐步编程解决方案可能非常有帮助，但语义内核提供给用户的最优秀的能力之一是允许他们使用自然语言进行请求。这需要使用**规划器**，我们将在[*第五章*](B21826_05.xhtml#_idTextAnchor106)中使用它，将用户请求分解成多个步骤，然后自动按适当顺序调用每个步骤。
- en: In this section, we will solve problems by telling Semantic Kernel which functions
    to call. This is helpful for making sure that the solutions we make available
    to the planner work, and it is also helpful when we want to explicitly control
    how things are executed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过告诉语义内核调用哪些函数来解决问题。这有助于确保我们提供给规划器的解决方案是有效的，并且当我们要显式控制执行方式时也很有帮助。
- en: To illustrate the manual approach, we will see how to give Semantic Kernel clues
    about an animal, guess it with a semantic function, and then generate an image
    of the animal using the native function we created in the previous section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明手动方法，我们将展示如何向语义内核提供关于动物的线索，使用语义函数猜测它，然后使用我们在上一节中创建的本地函数生成动物的图像。
- en: Generating an image from a clue
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从线索生成图像
- en: In the following code, we have two steps. In the first step, we will use GPT-3.5
    to guess an animal from clues. To do that, we will create a semantic plugin called
    `AnimalGuesser`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们有两个步骤。在第一步中，我们将使用 GPT-3.5 从线索中猜测一个动物。为此，我们将创建一个名为`AnimalGuesser`的语义插件。
- en: 'Important: Using OpenAI services is not free'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：使用 OpenAI 服务并非免费
- en: 'The semantic functions will call the OpenAI API. These calls require a paid
    subscription, and each call will incur a cost. The costs are usually small per
    request. GPT 3.5 costs $0.0002 per thousand tokens, but they may add up if you
    make a large number of calls. Prices change frequently, so make sure to check
    the latest prices on the following websites:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 语义函数将调用 OpenAI API。这些调用需要付费订阅，并且每次调用都会产生费用。通常，每个请求的费用很小。GPT 3.5 每千个标记的费用为 $0.0002，但如果进行大量调用，费用可能会累积。价格经常变动，因此请确保在以下网站上检查最新的价格：
- en: 'OpenAI pricing: [https://openai.com/pricing](https://openai.com/pricing)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAI 定价：[https://openai.com/pricing](https://openai.com/pricing)
- en: 'Azure OpenAI pricing: [https://azure.microsoft.com/en-us/pricing/details/cognitive-services/openai-service/](https://azure.microsoft.com/en-us/pricing/details/cognitive-services/openai-service/)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Azure OpenAI 定价：[https://azure.microsoft.com/en-us/pricing/details/cognitive-services/openai-service/](https://azure.microsoft.com/en-us/pricing/details/cognitive-services/openai-service/)
- en: 'The semantic plugin, as always, consists of two files, `config.json` and `skprompt.txt`,
    listed as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 语义插件，一如既往，由两个文件组成，`config.json` 和 `skprompt.txt`，如下所示：
- en: config.json
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: config.json
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: skprompt.txt
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: skprompt.txt
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we always do, we must make sure that the `description` fields in the `config.json`
    files are set correctly. This will not have any effect now, but when we start
    using the planner or letting Semantic Kernel automatically call functions, the
    kernel will use the `description` fields to figure out what each function does
    and decide which ones to call.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们通常所做的那样，我们必须确保 `config.json` 文件中的 `description` 字段设置正确。现在这不会有任何影响，但当我们开始使用规划器或让语义内核自动调用函数时，内核将使用
    `description` 字段来确定每个函数的功能并决定调用哪些函数。
- en: For now, let’s see how to tell the kernel to call functions in sequence.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何告诉内核按顺序调用函数。
- en: Chaining semantic and native functions with C#
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 C# 链接语义和本地函数
- en: In C#, you need to use the `KernelFunctionCombinators` class to create a function
    pipeline. The code for the class is provided in the GitHub repository.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，你需要使用 `KernelFunctionCombinators` 类来创建函数管道。该类的代码在 GitHub 仓库中提供。
- en: 'The code for implementing a function pipeline follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 实现函数管道的代码如下：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding snippet, we create our kernel, add an OpenAI service to it,
    and add the `AnimalGuesser` and `Dalle3` plugins to it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了我们的内核，向其中添加了一个 OpenAI 服务，并添加了 `AnimalGuesser` 和 `Dalle3` 插件。
- en: 'Next, we assign the functions we want to call, `AnimalGuesser.GuessAnimal`
    and `Dalle3.ImageFromPrompt`, to `KernelFunction` variables:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将要调用的函数 `AnimalGuesser.GuessAnimal` 和 `Dalle3.ImageFromPrompt` 分配给 `KernelFunction`
    变量：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Lastly, we create a `KernelArguments` object called `context` and pass it as
    a parameter to `InvokeAsync`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个名为 `context` 的 `KernelArguments` 对象，并将其作为参数传递给 `InvokeAsync`：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The attributes of the `context` object must match what the first function is
    expecting. In our case, the `AnimalGuesser.GuessAnimal` function expects a parameter
    named `input`. From then on, the pipeline will call each function, get the output
    as a text string, and pass that text string as the first parameter to the next
    function. In our case, even though the first parameter of the `Dalle3.ImageFromPrompt`
    function is called `prompt` instead of `input`, the call is still going to work.
    You only need to provide the correct name for the parameter used in the first
    step of the pipeline.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`context` 对象的属性必须与第一个函数期望的属性相匹配。在我们的例子中，`AnimalGuesser.GuessAnimal` 函数期望一个名为
    `input` 的参数。从那时起，管道将调用每个函数，将输出作为文本字符串，并将该文本字符串作为下一个函数的第一个参数传递。在我们的例子中，尽管 `Dalle3.ImageFromPrompt`
    函数的第一个参数名为 `prompt` 而不是 `input`，但调用仍然会正常进行。你只需要提供在管道第一步中使用的参数的正确名称。'
- en: 'If you run the preceding program, you will get a picture of a cat:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的程序，你将得到一张猫的图片：
- en: '![Figure 4.4 – Picture of a cat generated from AI guessing the animal from
    clues](img/B21826_04_4.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 通过 AI 从线索中猜测动物生成的猫的图片](img/B21826_04_4.jpg)'
- en: Figure 4.4 – Picture of a cat generated from AI guessing the animal from clues
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 通过 AI 从线索中猜测动物生成的猫的图片
- en: Chaining semantic and native functions with Python
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Python 链接语义和本地函数
- en: As we did in C#, let’s use Python to create a script that starts from a list
    of clues, guesses the animal that the clues refer to, and then generates a picture
    of the animal.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C# 中的做法一样，让我们使用 Python 创建一个脚本，该脚本从一个线索列表开始，猜测线索所指的动物，然后生成该动物的图片。
- en: We will build on the plugins we already have. We will reuse the native plugin
    that we created to generate images using DALL-E 3.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于我们已有的插件进行构建。我们将重用我们创建的用于使用DALL-E 3生成图像的原生插件。
- en: One new thing is that we are going to create a function called `pipeline` that
    receives a list of functions and an input parameter and then calls each function
    in the list, passing the output of the call as the input parameter of the next
    function in the list.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 新的一件事是我们将创建一个名为`pipeline`的函数，它接收一个函数列表和一个输入参数，然后调用列表中的每个函数，将调用的输出作为下一个函数的输入参数传递。
- en: 'The definition of the function is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的定义如下：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We start as we always do, creating a kernel and adding an AI service to it.
    Here, we are assigning the plugins to variables, which will enable us to reference
    functions in the next step:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像往常一样开始，创建一个内核并向其中添加一个AI服务。在这里，我们将插件分配给变量，这将使我们能够在下一步中引用函数：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With that, we can now give our model the clues and ask it to guess:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们现在可以给我们的模型提供线索并要求它猜测：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As seen in the preceding snippet, to run the pipeline, we create the list of
    functions we want to call in order, adding it to the `function_list` variable,
    and then call the `pipeline` function. The `pipeline` function will run the first
    function with the input parameter you passed, then it will use the output of the
    first function as the parameter of the second function, and so on.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个代码片段所示，要运行管道，我们创建一个我们想要按顺序调用的函数列表，将其添加到`function_list`变量中，然后调用`pipeline`函数。`pipeline`函数将使用您传入的输入参数运行第一个函数，然后它将使用第一个函数的输出作为第二个函数的参数，依此类推。
- en: Like what happened in the C# example, the output will be a URL pointing to a
    freshly generated picture of a cat (not displayed).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在C#示例中发生的那样，输出将是一个指向新生成的猫的图片的URL（未显示）。
- en: 'Now that we’re done with a simple example of a pipeline, let’s go back to the
    problem we were solving in [*Chapter 3*](B21826_03.xhtml#_idTextAnchor071) and
    described in the introduction of this chapter: verifying whether a proposal for
    a vaccination campaign fulfills the basic requirements.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了一个简单的管道示例，让我们回到我们在[*第3章*](B21826_03.xhtml#_idTextAnchor071)中解决的问题，并在本章引言中进行了描述：验证疫苗接种活动提案是否满足基本要求。
- en: Dealing with larger, more complex chains
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理更大、更复杂的链
- en: 'In the previous chapter, we created three plugins:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了三个插件：
- en: '`CheckSpreadsheet`: A native plugin that checks that the Excel spreadsheet
    contains the required fields and that they fulfill some rules'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CheckSpreadsheet`：一个原生插件，用于检查Excel电子表格是否包含所需的字段，并且它们满足某些规则'
- en: '`ParseWordDocument`: A native plugin that extracts text from a Word document'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParseWordDocument`：一个原生插件，用于从Word文档中提取文本'
- en: '`ProposalChecker`: A semantic plugin that checks whether text blocks fulfill
    some requirements, such as “*does this text block describe a team that has a Ph.D.
    and a* *medical doctor*?”'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProposalChecker`：一个语义插件，用于检查文本块是否满足某些要求，例如“*这个文本块是否描述了一个拥有博士学位和* *医学博士* *的团队？”'
- en: With these three plugins, you can already solve the business problem of checking
    proposals by calling each plugin separately and writing the logic to handle whether
    there was an error. This is likely sufficient for problems that have a small number
    of steps.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这三个插件，您已经可以通过分别调用每个插件并编写处理是否有错误的逻辑来解决检查提案的业务问题。这可能对于只有少量步骤的问题来说是足够的。
- en: While we are still going to use a small number of steps and a small number of
    documents for didactic purposes, the approach to analyzing and making decisions
    on a large number of documents presented in this chapter excels when there are
    many steps and many documents to process.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们仍然会为了教学目的使用少量步骤和少量文档，但本章中介绍的针对大量文档进行分析和做出决策的方法，在有许多步骤和许多文档需要处理时表现得尤为出色。
- en: Let’s see how to implement it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现它。
- en: Preparing our directory structure
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备我们的目录结构
- en: Before we start, we need to make sure that we have the data for the proposals
    loaded in the `data/proposals` folder. We will also reuse the native plugins by
    putting them in the same directory as our main program. The semantic plugins will
    be in the `plugins` directory.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们需要确保我们已经将提案数据加载到`data/proposals`文件夹中。我们还将通过将它们放在与我们的主程序相同的目录中来重用原生插件。语义插件将放在`plugins`目录中。
- en: We will modify our native and semantic functions slightly from what we did in
    the previous chapter. The main change is that we will introduce error handling
    directly into the semantic functions, which will enable us to process many documents
    with a single call.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对我们在上一章中做的本地和语义函数进行轻微的修改。主要的变化是我们将直接在语义函数中引入错误处理，这将使我们能够通过单个调用处理许多文档。
- en: 'Below is the directory structure of our solution. Each proposal is represented
    by a directory in the `proposals` directory, and each directory should contain
    exactly two files, one Excel file with the extension `.xlsx` and one Word file
    with the extension `.docx`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们解决方案的目录结构。每个提案在 `proposals` 目录下都有一个目录表示，每个目录应恰好包含两个文件，一个是扩展名为 `.xlsx` 的
    Excel 文件，另一个是扩展名为 `.docx` 的 Word 文件：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This follows the same structure we used earlier: a main file containing the
    code (`ch4.py` or `Program.cs`), additional files in the same directory, each
    containing a native plugin (`ParseWordDocument` and `CheckSpreadsheet`), and all
    the semantic plugins in a dedicated directory, `plugins`. We separate folders
    by language because that makes it simpler to manage the virtual environments that
    hold installed packages by folder. Semantic plugins are language-independent and
    can have their own directory.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这遵循了我们之前使用的相同结构：一个包含代码的主要文件（`ch4.py` 或 `Program.cs`），同一目录下的附加文件，每个文件包含一个本地插件（`ParseWordDocument`
    和 `CheckSpreadsheet`），以及所有语义插件在一个专门的目录 `plugins` 中。我们根据语言分隔文件夹，因为这使得管理按文件夹安装的包的虚拟环境变得更加简单。语义插件是语言无关的，并且可以有自己的目录。
- en: Now that we have described the expected directory structure, let’s look at the
    high-level flow of our process.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经描述了预期的目录结构，让我们来看看我们流程的高级流程。
- en: Understanding the flow of our process
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解我们流程的流程
- en: We will start by writing a native plugin called `Helpers` that contains a native
    function called `ProcessProposalFolder`, which when given a path that represents
    a folder, checks whether it contains exactly one Excel file and a Word document.
    If it does, it returns the path of the folder, if not, it returns a string with
    an error.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写一个名为 `Helpers` 的本地插件，其中包含一个名为 `ProcessProposalFolder` 的本地函数，当给定一个表示文件夹的路径时，检查它是否恰好包含一个
    Excel 文件和一个 Word 文档。如果是，它返回文件夹的路径，如果不是，它返回一个包含错误的字符串。
- en: Once we create the `Helpers` plugin, we will be almost ready to call the functions
    we developed in [*Chapter 3*](B21826_03.xhtml#_idTextAnchor071). We will make
    two modifications to the existing files `ParseWordDocument` and `CheckSpreadsheet`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了 `Helpers` 插件，我们几乎就可以调用我们在 [*第 3 章*](B21826_03.xhtml#_idTextAnchor071)
    中开发的函数了。我们将对现有的 `ParseWordDocument` 和 `CheckSpreadsheet` 文件进行两项修改。
- en: One modification we will make to both files will be to check if the input is
    an error state. If it is, we simply pass the error state forward. If we are not
    in an error state, we keep passing the folder path forward. We will need to make
    these simple modifications to all the native functions and semantic functions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对两个文件进行的修改之一是检查输入是否处于错误状态。如果是，我们简单地传递错误状态。如果我们不在错误状态中，我们继续传递文件夹路径。我们需要对所有本地函数和语义函数进行这些简单的修改。
- en: The second and last modification will be to the `ParseWordDocument` native plugin.
    We will add three separate helper functions, each one parsing one of the three
    different required sections of the document (`Team`, `Experience`, and `Implementation`
    details). The new functions will simply call the existing function with a parameter
    representing one section per function.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次也是最后一次修改将是 `ParseWordDocument` 本地插件。我们将添加三个单独的辅助函数，每个函数解析文档的三个不同必需部分（`团队`、`经验`和`实施`细节）。新函数将简单地调用现有的函数，每个函数用一个参数表示一个部分。
- en: The reason for doing all of this is to only have functions with a single parameter
    in the pipeline. This enables the return of each function to be passed as a parameter
    to the next function, which will make things much simpler.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 做所有这些的原因是为了在管道中只保留具有单个参数的函数。这使得每个函数的返回值可以作为参数传递给下一个函数，这将使事情变得更加简单。
- en: The full pipeline, with 10 steps, is represented in the next diagram.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的管道，包含 10 个步骤，在下图中表示。
- en: '![Figure 4.5 – Visual representation of the pipeline](img/B21826_04_5.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 管道的视觉表示](img/B21826_04_5.jpg)'
- en: Figure 4.5 – Visual representation of the pipeline
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 管道的视觉表示
- en: In *Figure 4**.5*, orange boxes represent native functions that deal with the
    filesystem, green boxes represent native functions that deal with Excel, blue
    boxes represent native functions that deal with Word, and purple boxes represent
    semantic functions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图4**.5*中，橙色框表示处理文件系统的本地函数，绿色框表示处理Excel的本地函数，蓝色框表示处理Word的本地函数，紫色框表示语义函数。
- en: Now that we understand all the steps for the pipeline, let’s create the new
    plugin and function and make the required modifications.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了管道的所有步骤，让我们创建新的插件和函数，并进行必要的修改。
- en: Creating the native function to process a folder
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建处理文件夹的本地函数
- en: To get the pipeline started, we need a plugin that ensures that the folder that
    we want to process contains the correct files. Since this is an activity that
    requires interacting with the operating system, we need to create a native function,
    which we will host inside a plugin we will call `Helpers`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动管道，我们需要一个插件来确保我们想要处理的文件夹包含正确的文件。由于这是一个需要与操作系统交互的活动，我们需要创建一个本地函数，我们将将其托管在我们将称为`Helpers`的插件中。
- en: 'The code for the plugin is as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 插件的代码如下：
- en: C#
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: C#
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As usual, since we want this function to be available to Semantic Kernel, we
    use the `KernelFunction` decorator and the descriuption of what the function does
    under the `Description` variable.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，由于我们希望这个函数对Semantic Kernel可用，我们使用`KernelFunction`装饰器和`Description`变量下的函数功能描述。
- en: 'Now, we are simply going to count the number of files available in the folder.
    Remember that we want exactly one file with the `.docx` extension and one file
    with the `.``xlsx` extension:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只是简单地计算文件夹中可用的文件数量。请记住，我们希望恰好有一个以`.docx`扩展名和一个以`.xlsx`扩展名的文件：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The logical part of the function is very simple. It counts the number of files
    with the `.docx` and `.xlsx` extensions in the directory. If the directory has
    one of each, the call succeeded. We signal success by passing the folder as the
    return result. In any other situation, we generate a string with an error message.
    We will use the convention that error messages in this pipeline start with `Error`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的逻辑部分非常简单。它计算目录中`.docx`和`.xlsx`扩展名的文件数量。如果目录中每种文件恰好有一个，调用成功。我们通过传递文件夹作为返回结果来指示成功。在任何其他情况下，我们生成一个包含错误信息的字符串。我们将使用约定，该管道中的错误信息以`Error`开头。
- en: 'Let’s now check out the code for the plugin in Python:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看Python中插件代码：
- en: Python
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In Python, we use the `kernel_function` decorator to indicate that this function
    can be used by Semantic Kernel. We also add an `Annotated` description to the
    parameter.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们使用`kernel_function`装饰器来指示这个函数可以被Semantic Kernel使用。我们还为参数添加了一个`Annotated`描述。
- en: 'Then, the function code is very simple. Similar to the C# function above, we
    count how many files with the `.docx` and `.xlsx` extensions are in the directory.
    If there’s exactly one of each, we indicate success by returning the folder name.
    Anything else will result in a failure, which will be indicated by a string starting
    with `Error`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，函数代码非常简单。类似于上面的C#函数，我们计算目录中`.docx`和`.xlsx`扩展名的文件数量。如果每种文件恰好有一个，我们通过返回文件夹名称来指示成功。任何其他情况都将导致失败，将通过以`Error`开头的字符串来指示：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that we have the function to kick off the pipeline, let’s see what needs
    to be done with the plugins we wrote in [*Chapter 3*](B21826_03.xhtml#_idTextAnchor071)
    to make them usable for this pipeline.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了启动管道的函数，让我们看看为了使我们在[*第3章*](B21826_03.xhtml#_idTextAnchor071)中编写的插件可用于此管道，我们需要对它们进行哪些操作。
- en: Modifying the Excel native plugin
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改Excel本地插件
- en: 'We need to make a few changes to the Excel plugin we created for [*Chapter
    3*](B21826_03.xhtml#_idTextAnchor071):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对为[*第3章*](B21826_03.xhtml#_idTextAnchor071)创建的Excel插件进行一些修改：
- en: Standardize the error message to always start with `Error`
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将错误信息标准化，使其始终以`Error`开头
- en: Standardize the success message to always return the folder
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将成功信息标准化，使其始终返回文件夹
- en: At the beginning of every function, if the input starts with `Error`, do nothing
    and simply pass the received input forward
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个函数的开始处，如果输入以`Error`开头，则不执行任何操作，只需简单地将接收到的输入传递下去
- en: To save space, the following code shows the changes to only one of the functions,
    `CheckTabs`. The full modified code is available in the GitHub repository.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，以下代码仅展示了函数`CheckTabs`的更改。完整的修改后的代码可在GitHub仓库中找到。
- en: C#
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: C#
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding code checks if the input received contains an error. Since this
    is going to be used in a pipeline, any errors in previous steps will be received
    here.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码检查接收到的输入是否包含错误。由于这将在管道中使用，因此之前步骤中的任何错误都将在这里接收。
- en: 'If we get an error, we’re simply going to pass the error forward in the following
    code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遇到错误，我们将在以下代码中简单地将错误传递下去：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that we are ensuring that any error message starts with `Error`, to make
    sure they’re easy to detect when they are received by other pipeline functions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们确保任何错误信息都以 `Error` 开头，以确保它们在由其他管道函数接收时易于检测。
- en: 'We now check how many sheets are in the file:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在检查文件中有多少个工作表：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the case of success, we simply pass the folder forward.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功的情况下，我们只需将文件夹传递下去。
- en: 'Otherwise, the following code passes the error forward:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，以下代码将错误传递下去：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Let’s see the changes in Python. To save space, we’re only showing the changes
    to the `CheckTabs` function. The full code for all functions is in the GitHub
    repository.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Python 中的变化。为了节省空间，我们只展示了 `CheckTabs` 函数的变化。所有函数的完整代码可以在 GitHub 仓库中找到。
- en: Python
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If the previous function sent us an error, we simply pass it forward.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上一个函数发送给我们一个错误，我们只需将其传递下去。
- en: 'Otherwise, we continue:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们继续：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To indicate success, we simply return the folder we received as input:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示成功，我们只需返回我们接收到的输入文件夹：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now that we have standardized the input and output of the functions, it makes
    it easier to extend the pipeline, since all the functions expect the same input,
    a folder, and when the function succeeds, it simply passes the folder to the next
    function.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经标准化了函数的输入和输出，这使得扩展管道变得更加容易，因为所有函数都期望相同的输入，一个文件夹，当函数成功时，它只需将文件夹传递给下一个函数。
- en: In the case of an error, the string passed as an input will start with `Error`,
    and all functions will simply pass it forward. These changes make it easier to
    change the order of steps and to add or remove steps.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现错误的情况下，作为输入传递的字符串将以 `Error` 开头，所有函数将简单地将其传递下去。这些更改使得更改步骤顺序以及添加或删除步骤变得更加容易。
- en: Now that we’re done with the changes in the Excel plugin, let’s make changes
    to the `ParseWordDocument` plugin that extracts text from Word documents.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了 Excel 插件中的更改，让我们对提取 Word 文档文本的 `ParseWordDocument` 插件进行修改。
- en: Modifying the Word native plugin
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改 Word 原生插件
- en: 'The modifications to the Word native plugin are very simple. In [*Chapter 3*](B21826_03.xhtml#_idTextAnchor071),
    when we were calling the native plugin directly, we created a function called
    `ExtractTextUnderHeading` that received two parameters: a path to a file and the
    heading that we wanted to extract, and we called that function three times so
    that we could extract the text under the three headings we wanted.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Word 原生插件进行的修改非常简单。在 [*第 3 章*](B21826_03.xhtml#_idTextAnchor071) 中，当我们直接调用原生插件时，我们创建了一个名为
    `ExtractTextUnderHeading` 的函数，该函数接收两个参数：一个文件的路径和我们想要提取的标题，我们调用了该函数三次，以便提取我们想要的三个标题下的文本。
- en: In pipelines, since we can only have one parameter, we will create three functions
    named `ExtractTeam`, `ExtractExperience`, and `ExtractImplementation` that receive
    the folder as a parameter and call the `ExtractTextUnderHeading` function that
    we created in [*Chapter 3*](B21826_03.xhtml#_idTextAnchor071) with the appropriate
    heading parameter, respectively `"Team"`, `"Experience"`, and `"Implementation"`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在管道中，由于我们只能有一个参数，我们将创建三个名为 `ExtractTeam`、`ExtractExperience` 和 `ExtractImplementation`
    的函数，这些函数接收文件夹作为参数，并分别使用适当的标题参数调用我们在 [*第 3 章*](B21826_03.xhtml#_idTextAnchor071)
    中创建的 `ExtractTextUnderHeading` 函数，分别是 `"Team"`、`"Experience"` 和 `"Implementation"`。
- en: 'Like we did with the Excel plugin, we will also make the following changes:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对 Excel 插件所做的那样，我们也将进行以下更改：
- en: Standardize the error message to always start with `Error`
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将错误信息标准化，使其始终以 `Error` 开头
- en: Standardize the success message to always return the folder
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将成功信息标准化，使其始终返回文件夹
- en: At the beginning of every function, if the input starts with `Error`, do nothing
    and simply pass the received input forward
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个函数的开始处，如果输入以 `Error` 开头，则不执行任何操作，只需简单地将接收到的输入传递下去
- en: 'To save space, we only show one of the functions here. The full code, including
    the modifications in the `ExtractTextUnderHeading` function, is in the GitHub
    repository:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，我们在这里只展示一个函数。包括 `ExtractTextUnderHeading` 函数中的修改在内的完整代码可以在 GitHub 仓库中找到：
- en: C#
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: C#
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Python
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In both cases, in addition to creating three function wrappers for `ExtractTextUnderHeading`
    to extract the text, we also perform two more tasks. The first is to check whether
    the previous step of the pipeline sent an error message. If it did, we simply
    pass it on. The second is to prepend the folder path to the text in a line called
    `FolderPath`. This will be used in the semantic functions. When the semantic function
    decides that the text it read fulfills the requirements, it will return the folder
    path, as is expected by functions in the pipeline.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，除了为`ExtractTextUnderHeading`创建三个函数包装器以提取文本外，我们还执行了两个额外的任务。第一个任务是检查管道的上一阶段是否发送了错误消息。如果是，我们直接传递它。第二个任务是将文件夹路径添加到名为`FolderPath`的行中。这将在语义函数中使用。当语义函数决定读取的文本满足要求时，它将返回文件夹路径，正如管道中的函数所期望的那样。
- en: Let’s work on the semantic functions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们着手处理语义函数。
- en: Modifying the semantic functions
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改语义函数
- en: The main modification that we need to make to the semantic functions is to ensure
    they understand the inputs and provide the appropriate outputs – either the folder
    in the case of success or an error message in the case of failure.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对语义函数进行的主要修改是确保它们理解输入并提供适当的输出——在成功的情况下返回文件夹，在失败的情况下返回错误消息。
- en: One way to do this is to encode the input into tags and then tell the AI service
    to perform operations on the contents of the tag. There was no need to modify
    the `config.json` files, only the `skprompt.txt` files.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的一种方法是将输入编码成标签，然后告诉AI服务对标签内容执行操作。没有必要修改`config.json`文件，只需修改`skprompt.txt`文件。
- en: 'CheckTeamV2: skprompt.txt'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 'CheckTeamV2: skprompt.txt'
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this semantic function, we tell the AI to check the contents of the text
    between `=====` for an error and simply pass it on if it finds one. If the contents
    between the ===== tags are not an error, they will contain the folder we’re processing
    in a line starting with `FolderPath` and the text from the `Team` heading in the
    Word document. We tell the AI to return the folder if the team fulfills the requirements
    we list or to return an error message if they don’t:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个语义函数中，我们告诉AI检查`=====`之间的文本内容是否存在错误，如果找到错误，则直接传递。如果`=====`标签之间的内容不是错误，它们将包含我们正在处理的文件夹，在Word文档的`FolderPath`行中开始，以及来自`Team`标题的文本。我们告诉AI，如果团队满足我们列出的要求，则返回文件夹，如果不满足，则返回错误消息：
- en: 'CheckDatesV2: skprompt.txt'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 'CheckDatesV2: skprompt.txt'
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We now ask the AI to check the contents between the `=====` tags for an error.
    The same as before, we simply pass it on if we find it. We then check whether
    the dates proposed for the vaccination campaign are within our expectations. If
    they are, we return the folder contained in the `FolderPath` line inside the tag.
    Otherwise, we return an error message:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要求AI检查`=====`标签之间的内容是否存在错误。与之前一样，如果我们找到错误，我们直接传递它。然后，我们检查为疫苗接种活动提出的日期是否在我们的预期范围内。如果是，我们返回标签内`FolderPath`行中包含的文件夹。如果不是，我们返回一个错误消息：
- en: 'CheckPreviousProjectV2: skprompt.txt'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'CheckPreviousProjectV2: skprompt.txt'
- en: '[PRE32]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The final semantic function is very similar to the previous two. We ask the
    AI to check the contents between the `=====` tags and return an error message
    if the team requesting for funding does not have enough experience as demonstrated
    by a previous project.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个语义函数与前两个非常相似。我们要求AI检查`=====`标签之间的内容，如果请求资金的团队没有足够的经验（如前一个项目所示），则返回错误消息。
- en: Now that we’re done with all the steps of our process, let’s assemble them into
    a pipeline and run it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了我们流程的所有步骤，让我们将它们组装成一个管道并运行它。
- en: Creating and calling the pipeline
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和调用管道
- en: Calling the pipeline requires creating a kernel, loading it with the functions
    we want, and then calling them in sequence. Since we’re going to use semantic
    functions, we also need to add an AI service to the kernel. Evaluating text against
    requirements can be a complex task, and therefore we will use GPT-4 to execute
    it. GPT 3.5 can work if the documents are simple, but some of our documents have
    more than one page, and that can be too much for GPT 3.5 to handle well.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 调用管道需要创建一个内核，用我们想要的函数加载它，然后按顺序调用它们。由于我们将使用语义函数，我们还需要将AI服务添加到内核中。对文本进行需求评估可能是一项复杂的任务，因此我们将使用GPT-4来执行它。如果文档简单，GPT
    3.5可以工作，但我们的某些文档有多页，这可能对GPT 3.5来说处理起来过于复杂。
- en: C#
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: C#
- en: 'In the following code block, we load all the native and semantic plugins into
    our kernel:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块中，我们将所有原生和语义插件加载到我们的内核中：
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we create variables for each of the functions:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为每个函数创建变量：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Creating variables for each of the functions is not strictly necessary – you
    could simply put the code on the right-hand side of each of the preceding assignments
    directly into the pipeline call.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个函数创建变量并不是严格必要的——你只需将代码直接放入每个先前赋值右侧的管道调用中即可。
- en: For example, instead of
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，而不是
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You could write:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以写：
- en: '[PRE36]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Assigning it to variables makes the contents of the pipeline call much shorter,
    and that can make it easier to maintain.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 将其分配给变量可以使管道调用中的内容更短，这可以使其更容易维护。
- en: 'Next, we create a pipeline with the `Pipe` method of `KernelFunctionCombinators`,
    simply listing the steps in the order we want them to be called:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `KernelFunctionCombinators` 的 `Pipe` 方法创建一个管道，简单地列出我们希望它们按顺序调用的步骤：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The next step will be to call the pipeline:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是调用管道：
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We get the path of the `data/proposals` folder that contains our proposals.
    Each proposal is a subfolder of that folder. We iterate over each of the subfolders
    of the `data/proposal` folder and call our pipeline. If we don’t find any errors,
    we print `Success`. Otherwise, we list the errors we found.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取包含我们提案的 `data/proposals` 文件夹的路径。每个提案都是该文件夹的子文件夹。我们遍历 `data/proposal` 文件夹的每个子文件夹并调用我们的管道。如果我们没有发现任何错误，我们打印
    `Success`。否则，我们列出我们找到的错误。
- en: Python
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: 'We start by creating our kernel, adding the GPT-4 service to it, and adding
    all the native and semantic plugins to it:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建我们的内核，向其中添加GPT-4服务，并添加所有本地和语义插件：
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that we added the pipeline function that we created in the previous section.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们添加了上一节中创建的管道函数。
- en: 'The final step is to create a function list and call the pipeline for each
    document:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是创建一个函数列表并调用每个文档的管道：
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The full pipeline obtains the expected results, with the proposals that fulfill
    all the requirements returning success and the proposals with problems returning
    an error message describing the problem.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的管道获得了预期的结果，满足所有要求的提案返回成功，有问题的提案返回描述问题的错误消息。
- en: 'The results are displayed here:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 结果在此显示：
- en: '[PRE41]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Before having the help of AI, reading and interpreting a document required using
    the time of a person, or writing a specialized machine learning model. Semantic
    Kernel allows you to write code to analyze large and complex documents.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在得到AI的帮助之前，阅读和解释文档需要使用人的时间，或者编写专门的机器学习模型。语义内核允许你编写代码来分析大型和复杂的文档。
- en: In our pipeline, the `CheckSpreadsheet` native plugin does not strictly require
    Semantic Kernel and could be done in a separate step, since it only runs code
    that is never read by AI. We added it to the pipeline to make our end-to-end solution
    more streamlined.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的管道中，`CheckSpreadsheet` 本地插件并不严格需要语义内核，可以在单独的步骤中完成，因为它只运行AI永远不会读取的代码。我们将其添加到管道中，以使我们的端到端解决方案更加流畅。
- en: 'The `ParseWordDocument` native plugin, on the other hand, helps Semantic Kernel
    receive the information in parts. Breaking the document into parts makes the semantic
    functions simpler: each function can evaluate just a portion of the document.
    For example, the function that evaluates the *Teams* section of the document just
    needs to check the team qualifications. That makes the function a lot simpler
    to write than a function that reads the whole document and decides about all sections
    of the document in a single step.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相反，`ParseWordDocument` 本地插件帮助语义内核以部分形式接收信息。将文档拆分为部分使得语义功能更简单：每个功能只需评估文档的一部分。例如，评估文档
    *Teams* 部分的函数只需检查团队资格。这使得函数的编写比一次性读取整个文档并决定所有部分的单步函数要简单得多。
- en: The real value that AI adds to this process, therefore, is in the semantic plugin.
    The tasks of evaluating sections of the document that are implemented by the semantic
    functions in the `ProposalCheckerV2` plugin are the ones that would formerly require
    either a lot of human effort or a specialized machine learning model. This chapter
    showed how to execute these tasks just by describing what the requirements were
    in three short `skprompt.txt` files.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，AI为这个过程增加的实际价值在于语义插件。由 `ProposalCheckerV2` 插件中的语义函数实现的评估文档部分的任务，以前可能需要大量的人工努力或专门的机器学习模型。本章展示了如何仅通过在三个简短的
    `skprompt.txt` 文件中描述要求来执行这些任务。
- en: In this chapter, we created our pipeline manually, explicitly naming the functions
    that we wanted to call and in which order. In the next chapter, we will learn
    how to use a planner. The planner will receive the user request and decide which
    functions to call and in which order.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们手动创建了我们的流程，明确命名了我们想要调用的函数以及它们的调用顺序。在下一章中，我们将学习如何使用规划器。规划器将接收用户请求并决定调用哪些函数以及它们的调用顺序。
- en: References
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[1] A. S. Luccioni, Y. Jernite, and E. Strubell, “Power Hungry Processing:
    Watts Driving the Cost of AI Deployment?” arXiv, Nov. 28, 2023\. doi: 10.48550/arXiv.2311.16863.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] A. S. Luccioni, Y. Jernite, 和 E. Strubell, “Power Hungry Processing: Watts
    Driving the Cost of AI Deployment?” arXiv, Nov. 28, 2023\. doi: 10.48550/arXiv.2311.16863.'
