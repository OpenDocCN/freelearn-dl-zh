- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Unlocking OpenAI and Setting Up Your API Playground Environment
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解锁 OpenAI 并设置你的 API Playground 环境
- en: ChatGPT, an advanced **artificial intelligence** (**AI**) language model developed
    by OpenAI, is the fastest-growing original consumer application in history, reaching
    100 million users in only 2 months. By comparison, TikTok is in second place,
    reaching the same number of users in over 9 months ([https://www.forbes.com/sites/cindygordon/2023/02/02/chatgpt-is-the-fastest-growing-ap-in-the-history-of-web-applications/?sh=3551e45d678c](https://www.forbes.com/sites/cindygordon/2023/02/02/chatgpt-is-the-fastest-growing-ap-in-the-history-of-web-applications/?sh=3551e45d678c)).
    The reason for its popularity can be attributed to its ability to democratize
    **Natural Language Processing** (**NLP**) models for the everyday user. NLP represents
    a domain in AI that focuses on the interaction between computers and humans through
    natural language. The ultimate goal of NLP is to enable computers to interpret,
    understand, and respond to human language in a way that is both meaningful and
    useful. Traditionally, tasks in this field – from sentiment analysis to language
    translation – required robust datasets and specialized knowledge in machine learning
    and data science to be effectively executed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT 是由 OpenAI 开发的先进 **人工智能** (**AI**) 语言模型，是历史上增长最快的原生消费应用，仅用 2 个月就达到了 1
    亿用户。相比之下，TikTok 排名第二，达到同样的用户数用了超过 9 个月（[https://www.forbes.com/sites/cindygordon/2023/02/02/chatgpt-is-the-fastest-growing-ap-in-the-history-of-web-applications/?sh=3551e45d678c](https://www.forbes.com/sites/cindygordon/2023/02/02/chatgpt-is-the-fastest-growing-ap-in-the-history-of-web-applications/?sh=3551e45d678c)）。它之所以如此受欢迎，可以归因于其使
    **自然语言处理** (**NLP**) 模型对普通用户普及的能力。NLP 是 AI 中一个关注计算机与人类通过自然语言互动的领域。NLP 的终极目标是使计算机能够以既有意义又有用的方式解释、理解并响应人类语言。传统上，这个领域的任务——从情感分析到语言翻译——都需要强大的数据集和机器学习与数据科学的专业知识才能有效执行。
- en: However, the rise of ChatGPT and its associated **Application Programming Interface**
    (**API**) has revolutionized the NLP landscape. Thanks to its ability to democratize
    NLP models, anyone, including regular users, can now generate human-like text
    from prompts without having any in-depth knowledge of data science or machine
    learning. For instance, whereas previously one might have needed to design a complex
    model to classify text into categories, with ChatGPT, a simple prompt can often
    achieve the same goal.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，ChatGPT 的崛起及其相关的 **应用程序接口** (**API**) 已彻底改变了 NLP 领域。得益于它使 NLP 模型普及的能力，任何人，包括普通用户，现在都可以通过简单的提示生成类人文本，而不需要具备深入的数据科学或机器学习知识。例如，以前可能需要设计一个复杂的模型来将文本分类，现在通过
    ChatGPT，一个简单的提示就能实现相同的目标。
- en: In essence, the advent of ChatGPT has made previously intricate NLP tasks more
    accessible and user-friendly, bridging the gap between advanced technology and
    the general public.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，ChatGPT 的出现使得以前复杂的 NLP 任务变得更易接触和用户友好，弥合了先进技术与大众之间的鸿沟。
- en: Programmers and developers are taking note, integrating GPT’s power into their
    own applications to make them intelligent. In fact, many well-funded start-ups
    (*Typeface*, *Jasper AI*, *Copy.ai*) have ChatGPT and other **Large Language Models**
    (**LLMs**) as the basis of their product, whether it’s summarizing text, finding
    information, or creating a chatbot. This requires a fundamental understanding
    of the OpenAI API and how to use it to build intelligent applications, which is
    where we’ll begin.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员和开发者们正在关注并将 GPT 的强大功能融入他们自己的应用程序中，使其变得智能。事实上，许多资金充足的初创公司（*Typeface*、*Jasper
    AI*、*Copy.ai*）将 ChatGPT 和其他 **大型语言模型** (**LLMs**) 作为其产品的基础，无论是用于总结文本、寻找信息还是创建聊天机器人。这需要对
    OpenAI API 及其如何用于构建智能应用程序有一个基本的了解，而这就是我们将要开始的地方。
- en: This starts with the basics, which involves creating an OpenAI account, accessing
    the API Playground, and making API requests.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这从基础开始，包括创建 OpenAI 账户、访问 API Playground 并发出 API 请求。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将介绍以下内容：
- en: Setting up your OpenAI Playground environment
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置你的 OpenAI Playground 环境
- en: Running a completion request in the OpenAI Playground
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 OpenAI Playground 中运行完成请求
- en: Using the System Message in the OpenAI Playground
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 OpenAI Playground 中使用系统消息
- en: Using the Chat Log to modify the model’s behavior
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用聊天记录修改模型行为
- en: Making OpenAI API requests with Postman
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Postman 发出 OpenAI API 请求
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires you to have access to the OpenAI API. You can create an
    account and register for access at [https://platform.openai.com/overview](https://platform.openai.com/overview).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章需要您能够访问OpenAI API。您可以在[https://platform.openai.com/overview](https://platform.openai.com/overview)创建账户并注册以获取访问权限。
- en: Setting up your OpenAI Playground environment
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置您的OpenAI Playground环境
- en: The **OpenAI Playground** is an interactive web-based interface designed to
    allow users to experiment with OpenAI’s language models, including ChatGPT. It’s
    a place where you can learn about the capabilities of these models by entering
    prompts and seeing the responses generated in real time. This platform acts as
    a sandbox where developers, researchers, and curious individuals alike can experiment,
    learn, and even prototype their ideas.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenAI Playground**是一个交互式的基于Web的界面，旨在允许用户尝试OpenAI的语言模型，包括ChatGPT。这是一个您可以通过输入提示并实时查看生成响应来了解这些模型能力的地方。该平台充当一个沙盒，开发者、研究人员和好奇的个人都可以在此进行实验、学习，甚至原型设计他们的想法。'
- en: In the Playground, you have the freedom to engage in a wide range of activities.
    You can test out different versions of the AI models, experimenting with various
    prompts to see how the model responds, and you can play around with different
    parameters to influence the responses generated. It provides a real-time glimpse
    into how these powerful AI models think, react, and create based on your input.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Playground中，您可以自由参与各种活动。您可以测试AI模型的不同版本，尝试使用各种提示来查看模型的响应，并且您可以通过调整不同的参数来影响生成的响应。这提供了一个实时的窥视，展示了这些强大的AI模型如何思考、反应和创造基于您的输入。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before you start, you need to create an *OpenAI* *Platform* account.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，您需要创建一个*OpenAI* *Platform*账户。
- en: Navigate to [https://platform.openai.com/](https://platform.openai.com/) and
    sign in to your OpenAI account. If you do not have an account, you can sign up
    for free with an email address. Alternatively, you can log in to OpenAI with a
    valid Google, Microsoft, or Apple account. Follow the instructions to complete
    the creation of your account. You may need to verify your identity with a valid
    phone number.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 转到[https://platform.openai.com/](https://platform.openai.com/)并登录您的OpenAI账户。如果您没有账户，您可以使用电子邮件地址免费注册。或者，您可以使用有效的Google、Microsoft或Apple账户登录OpenAI。按照说明完成账户创建。您可能需要使用有效的电话号码进行身份验证。
- en: How to do it…
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: After you have successfully logged in, navigate to **Profile** in the top right-hand
    menu, select **Personal**, and then select **Usage** from the left-hand side menu.
    Alternatively, you can navigate to [https://platform.openai.com/account/usage](https://platform.openai.com/account/usage)
    after logging in. This page shows the usage of your API, but more importantly,
    it shows you how many credits you have available.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功登录后，在右上角菜单中选择**Profile**，然后选择左侧菜单中的**Personal**，接着选择**Usage**。或者，您可以在登录后转到[https://platform.openai.com/account/usage](https://platform.openai.com/account/usage)。此页面显示您API的使用情况，更重要的是，它展示了您可用的学分数量。
- en: Normally, OpenAI provides you a $5 credit with a new account, which you should
    be able to see under the **Free Trial Usage** section of the page. If you do have
    credits, proceed to *step 4*. If, however, you do not have any credits, you will
    need to upgrade and set up a paid account.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，OpenAI为新账户提供$5的学分，您应该能在页面的**Free Trial Usage**部分看到这一点。如果您有学分，请继续*第四步*。然而，如果您没有任何学分，您需要升级并设置一个付费账户。
- en: 'You need not set up a paid account if you have received free credits. If you
    run out of free credits, however, here is how you can set up a paid account: select
    **Billing** from the left-hand side menu and then select **Overview**. Then, select
    the **Set up paid account** button. You will be prompted to enter your payment
    details and set a dollar threshold, which can be set to any level of spend that
    you are comfortable with. Note that the amount of credits required to collectively
    execute every single recipe contained in this book is not likely to exceed *$5*.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您已经获得了免费学分，则无需设置付费账户。然而，如果您用完了免费学分，这里是如何设置付费账户的方法：从左侧菜单选择**Billing**，然后选择**Overview**。接着，选择**Set
    up paid account**按钮。您将被提示输入支付详细信息并设置一个美元阈值，可以设置为您感到舒适的任何消费水平。请注意，执行本书中包含的每一个配方可能需要的学分总额不太可能超过*$5*。
- en: After you have created an OpenAI Platform account, you should be able to access
    the Playground by selecting **Playground** from the top menu bar, or by navigating
    to [https://platform.openai.com/playground](https://platform.openai.com/playground).
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 OpenAI 平台账户后，你应该能通过选择顶部菜单栏中的**Playground**，或者访问 [https://platform.openai.com/playground](https://platform.openai.com/playground)
    来进入 Playground。
- en: How it works…
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: The OpenAI Playground interface is, in my experience, clean, intuitive, and
    designed to provide users easy access to OpenAI’s powerful language models. The
    Playground is an excellent place to learn how the models perform under different
    settings, allowing you to experiment with parameters such as temperature and max
    tokens, which influence the randomness and length of the outputs respectively.
    The changes you make are instantly reflected in the model’s responses, offering
    immediate feedback.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，OpenAI Playground 界面简洁、直观，旨在为用户提供便捷访问 OpenAI 强大语言模型的途径。Playground 是一个极好的地方，可以学习在不同设置下模型的表现，允许你尝试诸如温度和最大令牌数等参数，它们分别影响输出的随机性和长度。你所做的更改会立即反映在模型的响应中，提供即时反馈。
- en: 'As shown in *Figure 1**.1*, the Playground consists of three sections: the
    *System Message*, the *Chat Log*, and the *Parameters*. You will learn more about
    these three features in the *Running a completion request in the OpenAI* *Playground*
    recipe.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图 1.1*所示，Playground 包含三个部分：*系统消息*、*聊天日志*和*参数*。你将在*在 OpenAI Playground 中运行完成请求*的教程中了解这三个功能的更多信息。
- en: '![Figure 1.1 – The OpenAI Playground](img/B21007_01_1.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – OpenAI Playground](img/B21007_01_1.jpg)'
- en: Figure 1.1 – The OpenAI Playground
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – OpenAI Playground
- en: Now, your Playground is set up and ready to be used. You can use it to run completion
    requests and see how varying your prompts and parameters affect the response from
    OpenAI.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的 Playground 已经设置好并准备使用了。你可以用它来运行完成请求，查看修改提示和参数如何影响 OpenAI 的响应。
- en: Running a completion request in the OpenAI Playground
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 OpenAI Playground 中运行完成请求
- en: In this recipe, we will actually put the Playground in action and execute a
    completion request from OpenAI. Here, you will see the power of the OpenAI API
    and how it can be used to provide completions for virtually any prompt.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将实际操作 Playground，并执行来自 OpenAI 的完成请求。在这里，你将看到 OpenAI API 的强大功能，以及它如何用于为几乎任何提示提供完成。
- en: Getting ready
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Ensure you have an OpenAI Platform account with available usage credits. If
    you don’t, please follow the *Setting up your OpenAI Playground environment* recipe.
    All the recipes in this chapter will have this same requirement.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你有一个拥有可用使用额度的 OpenAI 平台账户。如果没有，请按照*设置你的 OpenAI Playground 环境*的教程进行操作。本章中的所有教程都会有这个相同的要求。
- en: How to do it…
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let’s go ahead and start testing the model with the Playground. Let’s create
    an assistant that writes marketing slogans:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始用 Playground 测试模型吧。我们来创建一个编写营销标语的助手：
- en: Navigate to the **OpenAI Playground**.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**OpenAI Playground**。
- en: 'In the System Message, type in the following: **You are an assistant that creates
    marketing slogans based on descriptions of companies**. Here, we are clearly instructing
    the model of its role and context.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在系统消息中，输入以下内容：**你是一个根据公司描述创建营销标语的助手**。在这里，我们明确指示模型的角色和上下文。
- en: 'In the Chat Log, populate the **USER** message with the following: **A company
    that writes engaging** **mystery novels**.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在聊天日志中，填写**用户**消息如下：**一个编写吸引人的** **悬疑小说**的公司。
- en: Select the **Submit** button on the bottom of the page.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择页面底部的**提交**按钮。
- en: 'You should now see a completion response from OpenAI. In my case (*Figure 1**.2*),
    the response is as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你应该能看到 OpenAI 返回的完成响应。在我的例子中（*图 1.2*），响应如下：
- en: '[PRE0]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Figure 1.2 – The OpenAI Playground with prompt and completion](img/B21007_01_2.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – OpenAI Playground 与提示和完成](img/B21007_01_2.jpg)'
- en: Figure 1.2 – The OpenAI Playground with prompt and completion
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – OpenAI Playground 与提示和完成
- en: Note
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since OpenAI’s LLMs are probabilistic, you will likely not see the same outputs
    as me. In fact, if you run this recipe multiple times, you will likely see different
    answers, and that is expected because it is built into the randomness of the model.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 OpenAI 的大语言模型（LLMs）是基于概率的，你可能不会看到和我一样的输出。实际上，如果你多次运行这个教程，你可能会看到不同的答案，这也是预期的，因为这是模型随机性的内在特征。
- en: How it works…
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: 'OpenAI’s text generation models utilize a specific neural network architecture
    termed a transformer. Before delving deeper into this, let’s unpack some of these
    terms:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAI 的文本生成模型使用一种特定的神经网络架构，称为 transformer。在深入探讨之前，我们先来解释一些这些术语：
- en: '**Neural network architecture**: At a high level, this refers to a system inspired
    by the human brain’s interconnected neuron structure. It’s designed to recognize
    patterns and can be thought of as the foundational building block for many modern
    AI systems.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**神经网络架构**：从高层次来看，这指的是一个受到人脑互联神经结构启发的系统。它设计用来识别模式，可以被认为是许多现代 AI 系统的基础构建块。'
- en: '**Transformer**: This is a type of neural network design that has proven particularly
    effective for understanding sequences, making it ideal for tasks involving human
    language. It focuses on the relationships between words and their context within
    a sentence or larger text segment.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Transformer**：这是一种神经网络设计，已被证明在理解序列方面特别有效，使其非常适合处理与人类语言相关的任务。它专注于词语之间的关系及其在句子或更大文本段落中的上下文。'
- en: In machine learning, **unsupervised learning** typically refers to training
    a model without any labeled data, letting the model figure out patterns on its
    own. However, OpenAI’s methodology is more nuanced. The models are initially trained
    on a vast corpus of text data, supervised with various tasks. This helps them
    predict the next word in a sentence, for instance. Subsequent refinements are
    made using **Reinforcement Learning through Human Feedback** (**RLHF**), where
    the model is further improved based on feedback from human evaluators.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中，**无监督学习**通常指的是在没有任何标签数据的情况下训练模型，让模型自行发现模式。然而，OpenAI 的方法论更为细致。模型最初是在一个庞大的文本数据语料库上进行训练，配合各种任务进行监督。这帮助它们预测句子中的下一个词。例如，后续的改进是通过**人类反馈强化学习**（**RLHF**）进行的，其中模型会根据人类评估者的反馈进一步优化。
- en: Through this combination of techniques and an extensive amount of data, the
    model starts to capture the intricacies of human language, encompassing context,
    tone, humor, and even sarcasm.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些技术的结合以及大量数据，模型开始捕捉到人类语言的细微差别，涵盖了上下文、语气、幽默，甚至讽刺。
- en: 'In this case, the completion response is provided based on both the System
    Message and the Chat Log. The System Message serves a critical role in shaping
    and guiding the responses you receive from Open AI, as it dictates the model’s
    *persona*, *role*, *tone*, and *context*, among other attributes. In our case,
    the System Message contains the persona we want the model to take: *You are an
    assistant that creates marketing slogans based on descriptions* *of companies*.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，完成的响应是基于系统消息和聊天记录提供的。系统消息在塑造和引导你从 Open AI 获得的响应中起着至关重要的作用，因为它决定了模型的*个性*、*角色*、*语气*和*上下文*等属性。在我们的案例中，系统消息包含了我们希望模型采取的个性：*你是一个根据公司描述创作营销口号的助手*。
- en: The Chat Log contains the history of messages that the model has access to before
    providing its response, which contains our prompt, `A company that writes engaging`
    `mystery novels`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天记录包含了模型在生成响应之前可以访问的消息历史，其中包含我们的提示信息，`一个编写引人入胜的` `悬疑小说`的公司。
- en: Finally, the parameters contain more granular settings that you can change for
    the model, such as temperature. These significantly change the completion response
    from OpenAI. We will discuss temperature and other parameters in greater detail
    in [*Chapter 3*](B21007_03.xhtml#_idTextAnchor060).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，参数包含了一些更细粒度的设置，你可以为模型调整这些设置，比如温度。这些设置会显著改变 OpenAI 的完成响应。我们将在 [*第 3 章*](B21007_03.xhtml#_idTextAnchor060)
    中详细讨论温度和其他参数。
- en: There’s more…
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: It is worth noting that ChatGPT does not read and understand the meaning behind
    text – instead, the responses are based on statistical probabilities based on
    patterns it observed during training.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，ChatGPT 并不读取和理解文本背后的意义——相反，响应是基于它在训练过程中观察到的模式的统计概率。
- en: The model does not understand the text in the same way that humans do; instead,
    the completions are generated based on statistical associations and patterns that
    have been *trained* in the model’s neural network from a large body of similar
    text. Now, you know how to run completion requests with the OpenAI Playground.
    You can try this feature out for your own prompts and see what completions you
    get. Try creative prompts such as `write me a song about lightbulbs` or more professional
    prompts such as `explain Newton's` `first law`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 模型并不像人类一样理解文本；相反，完成内容是基于模型神经网络中从大量相似文本中训练出来的统计关联和模式生成的。现在，你知道如何在 OpenAI Playground
    中运行完成请求了。你可以为自己的提示尝试这个功能，并查看得到的完成内容。试试富有创意的提示，比如`为我写一首关于灯泡的歌`，或者更专业的提示，比如`解释牛顿的`
    `第一定律`。
- en: Using the System Message in the OpenAI Playground
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 OpenAI Playground 中使用系统消息
- en: In this recipe, we will observe how modifying the System Message affects the
    completion response that we receive from the model. This is important because
    as you begin to use the OpenAI API, you will likely adjust and refine the System
    Message to your specific needs, and the Playground is a great way to try that.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将观察修改系统消息如何影响从模型收到的完成响应。这很重要，因为当你开始使用 OpenAI API 时，你可能会根据具体需求调整和优化系统消息，而
    Playground 是一个很好的实验平台。
- en: How to do it…
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Navigate to the OpenAI Playground.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入 OpenAI Playground。
- en: 'In the **SYSTEM** field, type in the following: **You are an assistant that
    creates engaging and professional company names based on descriptions** **of companies**.'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**SYSTEM**字段中，输入以下内容：**你是一个根据公司描述生成有趣且专业公司名称的助手**。
- en: 'In the Chat Log, populate the **USER** message with the following: **A company
    that helps you with** **your taxes**.'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在聊天记录中，填写**USER**消息为：**一个帮助你处理** **税务问题**的公司。
- en: Select the **Submit** button on the bottom of the page.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面底部的**Submit**按钮。
- en: 'You should now see a completion response from OpenAI. In my case in *Figure
    1**.3*, the response is as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你应该能看到来自 OpenAI 的完成响应。以我在*图 1.3*中的例子，响应如下：
- en: '[PRE1]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Figure 1.3 – The OpenAI Playground with prompt and completion](img/B21007_01_3.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 带有提示和完成的 OpenAI Playground](img/B21007_01_3.jpg)'
- en: Figure 1.3 – The OpenAI Playground with prompt and completion
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 带有提示和完成的 OpenAI Playground
- en: Hover over the **ASSISTANT** response and select the minus icon on the right-hand
    side to delete the model’s response from the Chat Log. This needs to be done because
    we want OpenAI to not only generate a response but generate one as the **ASSISTANT**.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在**ASSISTANT**响应上，然后点击右侧的减号图标，删除聊天记录中的模型响应。这一步是必要的，因为我们希望 OpenAI 不仅仅生成一个响应，而是以**ASSISTANT**的身份生成响应。
- en: Modify the System Message to **You are an assistant that creates potential customer
    segments and marketing strategies based on descriptions** **of companies**.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改系统消息为**你是一个根据公司描述生成潜在客户群体和营销策略的助手**。
- en: Select the **Submit** button on the bottom of the page.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面底部的**Submit**按钮。
- en: 'You should now see a much longer completion response from OpenAI. In my case,
    as shown in *Figure 1**.4*, the response details potential customer segments:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你应该能看到来自 OpenAI 的更长的完成响应。以我在*图 1.4*中的例子，响应详细列出了潜在的客户群体：
- en: '![Figure 1.4 – The OpenAI Playground response after modifying the System Message](img/B21007_01_4.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – 修改系统消息后的 OpenAI Playground 响应](img/B21007_01_4.jpg)'
- en: Figure 1.4 – The OpenAI Playground response after modifying the System Message
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 修改系统消息后的 OpenAI Playground 响应
- en: How it works…
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The model generates a completely different type of response after modifying
    the System Message, even though the prompt in the Chat Log is exactly the same.
    The response changed from a one-word answer to a multi-paragraph response because
    of the instructions from the System Message. We also had to remove the default
    Assistant response because we want OpenAI to generate its own response instead
    of *feeding* it a response.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 即使聊天记录中的提示完全相同，修改系统消息后，模型生成的响应类型会完全不同。响应从一个单词的回答变成了多段的回复，这是因为系统消息中的指示。我们还需要删除默认的助手响应，因为我们希望
    OpenAI 生成自己的响应，而不是*提供*一个现成的回答。
- en: The System Message, being the first message in the conversation, heavily influences
    the *thinking* of the model by providing a frame of reference or context. This
    context is crucial because, without it, the model would lack necessary guidance
    to respond appropriately to subsequent user inputs. It is the cornerstone of defining
    your interaction with the model, allowing you to provide important context and
    high-level directives that steer the conversation or task at hand.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 系统消息作为对话中的第一条消息，通过提供参考框架或上下文，深刻影响模型的*思维*。这个上下文至关重要，因为没有它，模型将缺乏必要的指导，无法适当地响应后续的用户输入。它是定义与模型互动的基石，允许你提供重要的背景信息和高层次的指令，引导对话或任务的进行。
- en: As a result, when we begin to use the OpenAI API to create business applications,
    careful considerations must be made to the instructions that we put into the System
    Message.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们开始使用OpenAI API来创建商业应用时，必须谨慎考虑我们在系统消息中输入的指令。
- en: There’s more…
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'The beauty of the System Message is that that you can be as simple or as intricate
    with your instructions as you want. For example, here are common system messages
    that can be used for various purposes:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 系统消息的优点在于，你可以根据需要将指令做得简单或复杂。例如，以下是可以用于不同目的的常见系统消息：
- en: '**You are an assistant that helps young students learn important concepts in
    science by explaining concepts in** **easy-to-understand language**'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你是一个帮助年轻学生通过简明易懂的语言解释科学概念的助手**'
- en: '**You are an assistant that creates marketing slogans based on descriptions
    of companies that are provided** **to you**'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你是一个根据公司描述创建营销标语的助手** **提供给你**'
- en: '**I am planning a birthday party 2 weeks from now for my 5 year old niece and
    you are my party planner that tells me what I should** **be doing**'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我计划在两周后为我的五岁侄女举办生日派对，你是我的派对策划师，告诉我应该做什么**'
- en: Using the Chat Log to modify the model’s behavior
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用聊天记录来修改模型的行为
- en: In this recipe, we will learn how to modify the Chat Log and how it impacts
    the completion response that we receive from the model. This is important because
    developers often find this to be the best way to *fine tune* a model, without
    actually needing to create a new model. This also follows a *prompt engineering*
    must-have of providing the model with suitable examples.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们将学习如何修改聊天记录以及它如何影响我们从模型获得的响应。这很重要，因为开发者通常认为这是*微调*模型的最佳方法，而无需实际创建一个新模型。这也符合*提示工程*中必须提供适当示例的要求。
- en: How to do it…
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We can add examples of prompts and responses to the Chat Log to modify the
    model’s behavior. Let’s observe this with the following steps:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在聊天记录中添加提示和回应的示例，以修改模型的行为。让我们通过以下步骤观察这一点：
- en: Navigate to the **OpenAI Playground**. If you already have messages populated,
    refresh the page to start afresh.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**OpenAI Playground**。如果你已经填充了消息，请刷新页面以重新开始。
- en: 'In the System Message, type in the following: **You are an assistant that creates
    marketing slogans based on descriptions of companies**. Here, we are clearly instructing
    the model of its role and context.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在系统消息中输入以下内容：**你是一个根据公司描述创建营销标语的助手**。在这里，我们明确指示模型其角色和上下文。
- en: In the Chat Log, populate the `Sham - the ice cream that` `never melts!`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在聊天记录中，输入`Sham - the ice cream that` `never melts!`。
- en: 'Select the **Add message** button and ensure that the label of the message
    says **USER** instead now. Type the following into the **USER** message: **A company
    that produces** **comedy movies.**'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**添加消息**按钮，并确保消息标签现在显示为**USER**。在**USER**消息中输入以下内容：**一家公司制作** **喜剧电影**。
- en: 'Select the **Add message** button, and ensure that the label of the message
    says **ASSISTANT**. Type the following into the **ASSISTANT** message: **Sham
    - the best way to tickle your** **funny bone!**.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**添加消息**按钮，并确保消息标签显示**ASSISTANT**。在**ASSISTANT**消息中输入以下内容：**Sham - the best
    way to tickle your** **funny bone!**。
- en: 'Repeat *steps 4-5* once more, with the following **USER** and **ASSISTANT**
    messages, respectively: **A company that provides legal assistance to businesses,
    and Sham - we know business law!**. At this point, you should see the following:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次重复*步骤4-5*，依次输入以下**USER**和**ASSISTANT**消息：**为企业提供法律援助的公司，Sham - 我们懂商业法律！**。此时，你应该看到如下内容：
- en: '![Figure 1.5 – The OpenAI Playground with Chat Logs populated](img/B21007_01_5.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5 – 填充了聊天记录的OpenAI Playground](img/B21007_01_5.jpg)'
- en: Figure 1.5 – The OpenAI Playground with Chat Logs populated
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – 填充了聊天日志的OpenAI Playground
- en: 'Finally, select the **Add message** button, and create a **USER** message with
    the following: **A company that writes engaging** **mystery novels.**'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，选择**添加消息**按钮，并创建一条**USER**消息，内容为：**一家编写引人入胜的** **悬疑小说的公司。**
- en: Select the **Submit** button on the bottom of the page.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择页面底部的**提交**按钮。
- en: 'You should now see a completion response from OpenAI. In my case (*Figure 1**.6*),
    the response is as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你应该能看到来自OpenAI的回复。在我的情况下（*图1.6*），回复内容如下：
- en: '[PRE2]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Yours may be different, but the response you see will definitely start with
    the word “*Sham –*” and end with an exclamation point. In this way, we have *trained*
    the model to only give us completion responses in that format.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的情况可能不同，但你看到的回复肯定会以“*Sham –*”一词开头，并以感叹号结尾。通过这种方式，我们已经*训练*模型，只以这种格式给我们提供回复。
- en: '![Figure 1.6 – The OpenAI Playground with completion, after changing the Chat
    Log](img/B21007_01_5.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6 – 修改聊天日志后的OpenAI Playground与完成内容](img/B21007_01_5.jpg)'
- en: Figure 1.6 – The OpenAI Playground with completion, after changing the Chat
    Log
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – 修改聊天日志后的OpenAI Playground与完成内容
- en: How it works…
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: As we learned in the *Running a completion request in the OpenAI Playground*
    recipe, ChatGPT and its GPT models are built on a transformer architecture, which
    processes input and generates responses based on the immediate chat history it
    has been given. It doesn’t have an ongoing memory of past interactions or a stored
    understanding of context outside the immediate conversation. The Chat Log has
    a significant impact on the model’s completions. When the model receives a prompt,
    it takes into account the most recent prompt, the System Message, and all the
    preceding messages in the Chat Log.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*在OpenAI Playground中运行完成请求*的示例中所学，ChatGPT及其GPT模型是基于变换器架构构建的，该架构处理输入并根据给定的即时聊天历史生成回复。它没有对过去互动的持续记忆，也没有存储超出当前对话的上下文理解。聊天日志对模型的回复有显著影响。当模型接收到一个提示时，它会考虑最近的提示、系统消息以及聊天日志中所有先前的消息。
- en: We can observe this in the **Playground** by providing our own sets of User
    and Assistant messages, and then see how the model changes its completion, as
    we did in the preceding steps.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在**Playground**中提供我们自己的用户和助手消息集来观察这一点，然后看看模型如何改变它的回复，就像我们在前面的步骤中所做的那样。
- en: 'In particular, the model has detected two patterns in the Chat Log and then
    generated the completion to follow that behavior:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，模型在聊天日志中检测到了两种模式，并生成了与这些行为相符的回复：
- en: The model detected that all manual Assistant completions begin with the word
    *Sham*, and so it added that prefix to its completion
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型检测到所有手动助手的回复都以*Sham*一词开头，因此它将该前缀添加到自己的回复中。
- en: The model identified that all slogans end with an exclamation point, and so
    when it generated the completion, it also added in an exclamation point
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型识别到所有标语都以感叹号结尾，因此在生成回复时，它也加上了一个感叹号。
- en: Overall, the Chat Log can be used to *train* the model to generate certain types
    of completions that the user wants to create. In addition, the Chat Log helps
    the model understand and maintain the context of the bigger conversation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，聊天日志可以用来*训练*模型生成用户希望创建的特定类型的回复。此外，聊天日志帮助模型理解并维持更大对话的上下文。
- en: For example, if you added a User message with `What is an airplane?` and followed
    it up with another User message of `How do they fly?`, the model would understand
    that `they` refers to the `airplane` because of the Chat Log.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你添加了一条用户消息`什么是飞机？`，并紧接着又发送了另一条用户消息`它们是如何飞行的？`，模型会理解`它们`指的是`飞机`，因为聊天日志的上下文。
- en: Prompt engineering
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示工程
- en: The Chat Log plays a pivotal role in influencing the model’s completions, and
    this observation is a glimpse into the broader realm of **prompt engineering**.
    Prompt engineering is a technique where the input or **prompt** given to a model
    is carefully crafted to guide the model towards producing a desired output.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天日志在影响模型回复方面起着至关重要的作用，这一观察揭示了**提示工程**的更广阔领域。提示工程是一种技巧，通过精心设计给模型的输入或**提示**，引导模型生成所需的输出。
- en: 'Within the sphere of prompt engineering, there are a few notable concepts,
    as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示工程的领域中，有一些显著的概念，如下所示：
- en: '**Zero-shot prompting**: Here, the model is given a task that it hasn’t been
    explicitly trained on. It relies entirely on its pre-existing knowledge and training
    to generate a relevant response. In essence, it’s like asking the model to perform
    a task *cold*, without any prior examples.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**零-shot 提示**：在这种情况下，模型接收到的任务是它没有被明确训练过的。它完全依赖其现有的知识和训练来生成相关的响应。本质上，这就像是在没有任何先前示例的情况下，*冷启动*地要求模型执行任务。'
- en: '**Few-shot prompting**: This involves providing the model with a small number
    of examples related to the desired task. The aim is to nudge the model into recognizing
    the pattern or context and then generating a relevant completion based on the
    few examples given.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**少-shot 提示**：这意味着向模型提供与目标任务相关的少量示例。目的是通过这些示例引导模型识别模式或上下文，从而生成与这些少量示例相关的响应。'
- en: Understanding these nuances in how prompts can be engineered allows users to
    leverage ChatGPT’s capabilities more effectively, tailoring interactions to their
    specific needs.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 理解如何构造提示的这些细微差别，使用户能够更有效地利用 ChatGPT 的功能，根据特定需求定制互动。
- en: Overall, the Chat Log (and the System Message, as we learned in the earlier
    recipe) is a great low-touch method of aligning the completion responses from
    OpenAI to a desired target, without needing to fine-tune the model itself. Now
    that we’ve used the Playground to test prompts and completions, it’s time to use
    the actual OpenAI API.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，聊天记录（以及我们在前面章节中学习到的系统消息）是将 OpenAI 的响应与预期目标对齐的一种非常低成本的方法，无需对模型本身进行微调。现在我们已经使用
    Playground 测试了提示和完成，是时候使用实际的 OpenAI API 了。
- en: Making OpenAI API requests with Postman
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Postman 发起 OpenAI API 请求
- en: The OpenAI Playground is a great way to test model completions and provides
    the exact same responses that you would receive with the OpenAI API, but it serves
    a different purpose. While the Playground is treated as a sandbox for experimentation
    that is easy to use, interactive, and great for learning, the OpenAI API enables
    users to integrate the models directly into their applications.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAI Playground 是测试模型完成情况的一个极好的方式，提供与 OpenAI API 相同的响应，但它有不同的目的。Playground
    被视为一个实验沙盒，使用简单、互动性强，非常适合学习，而 OpenAI API 则使用户能够将模型直接集成到他们的应用程序中。
- en: Getting ready
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to make HTTP requests, we need a client such as Postman to post requests
    to the API. We also need to generate an **API key**, a unique identifier that
    authorizes us to make requests to OpenAI’s API.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发起 HTTP 请求，我们需要一个客户端，比如 Postman，来向 API 发送请求。我们还需要生成一个 **API 密钥**，这是一个唯一标识符，授权我们向
    OpenAI 的 API 发起请求。
- en: In this recipe and book, we will select Postman as our API client, but note
    that many alternatives exist, including *WireMock*, *Smartbear*, and *Paw*. We
    have chosen Postman because it is the most widely used tool, it’s cross-platform
    (meaning that it works on Windows, Mac, and Linux), and finally, for our use case
    it’s completely free.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将选择 Postman 作为我们的 API 客户端，但请注意，市面上有许多替代工具，包括 *WireMock*、*Smartbear* 和
    *Paw*。我们选择 Postman 是因为它是最广泛使用的工具，支持跨平台（即可以在 Windows、Mac 和 Linux 上运行），而且对于我们的使用场景来说，它是完全免费的。
- en: Installing Postman
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Postman
- en: Postman is the widely recognized stand-alone tool for testing APIs, used by
    over 17 million users ([https://blog.postman.com/postman-public-api-network-is-now-the-worlds-largest-public-api-hub/](https://blog.postman.com/postman-public-api-network-is-now-the-worlds-largest-public-api-hub/)).
    It contains many features, but its core use case is enabling developers to send
    HTTP requests and viewing responses in an easy-to-use user interface. In fact,
    Postman also contains a web-based version (no downloads necessary), which is what
    we will be using in this section.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Postman 是一个广泛认可的独立 API 测试工具，已有超过 1700 万用户使用 ([https://blog.postman.com/postman-public-api-network-is-now-the-worlds-largest-public-api-hub/](https://blog.postman.com/postman-public-api-network-is-now-the-worlds-largest-public-api-hub/))。它包含许多功能，但其核心用途是让开发者能够发送
    HTTP 请求并在易于使用的用户界面中查看响应。实际上，Postman 还提供了一个基于 Web 的版本（无需下载），这就是我们在本节中将使用的版本。
- en: To use Postman, navigate to [https://www.postman.com/](https://www.postman.com/)
    and create a free account using the **Sign Up for Free** button. Follow the on-screen
    instructions until you get to platform, where you should see a menu bar at the
    top with options for **Home**, **Workspaces**, **API Network**, and more. Alternatively,
    you can choose to download and install the Postman application on your computer
    (follow the steps on the website), removing the need to create a Postman account.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Postman，请访问 [https://www.postman.com/](https://www.postman.com/) 并通过点击**Sign
    Up for Free**按钮创建一个免费账户。按照屏幕上的指示操作，直到进入平台，在那里您应该能看到顶部菜单栏，包含**Home**、**Workspaces**、**API
    Network**等选项。或者，您也可以选择下载并安装 Postman 应用程序（按照网站上的步骤），这样就不需要创建 Postman 账户。
- en: 'Now that we are on the Postman platform, let’s configure our workspace:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经进入 Postman 平台，接下来配置我们的工作区：
- en: Select **Workspaces** from the top and click **Create Workspace**.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择顶部的**Workspaces**，然后点击**Create Workspace**。
- en: Select **Blank Workspace** and click **Next**.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Blank Workspace**，然后点击**Next**。
- en: Give the workspace a name (such as **OpenAI API**), select **Personal**, and
    then select **Create**.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给工作区命名（例如**OpenAI API**），选择**Personal**，然后选择**Create**。
- en: '![Figure 1.7 – Configuring the Postman workspace](img/B21007_01_7.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.7 – 配置 Postman 工作区](img/B21007_01_7.jpg)'
- en: Figure 1.7 – Configuring the Postman workspace
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – 配置 Postman 工作区
- en: Getting your API key
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取您的 API 密钥
- en: 'API keys are used to authenticate HTTP requests to OpenAI’s servers. Each API
    key is unique to an OpenAI Platform account. In order to get your OpenAI API key:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: API 密钥用于对 OpenAI 服务器的 HTTP 请求进行身份验证。每个 API 密钥都是唯一的，且与一个 OpenAI Platform 账户关联。要获取您的
    OpenAI API 密钥：
- en: Navigate to [https://platform.openai.com/](https://platform.openai.com/) and
    log in to your OpenAI API account.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 [https://platform.openai.com/](https://platform.openai.com/) 并登录您的 OpenAI
    API 账户。
- en: Select **Personal** from the top right and click **View** **API keys**.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右上角选择**Personal**，点击**View** **API keys**。
- en: Select the **Create new secret key** button, type in any name, and then select
    **Create** **secret key**.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Create new secret key**按钮，输入任意名称，然后选择**Create** **secret key**。
- en: Your API key should now be visible to you – note it down somewhere safe, such
    as in a password-protected **.****txt** file.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的 API 密钥现在应该对您可见——请将其记下来并存放在安全的地方，例如一个受密码保护的**.txt**文件中。
- en: Note
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Your API key is your means of authenticating with OpenAI – it should not be
    shared with anyone and should be stored as securely as any password.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 API 密钥是您与 OpenAI 进行身份验证的凭证——它不应与任何人共享，并应像任何密码一样安全存储。
- en: How to do it…
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: After setting up our Postman workspace and generating our OpenAI API key, we
    have everything we need to make HTTP requests to the API. We will first create
    and send the request, and then analyze the various components of the request.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好 Postman 工作区并生成 OpenAI API 密钥后，我们就可以开始进行 HTTP 请求。我们首先创建并发送请求，然后分析请求的各个组成部分。
- en: 'In order to make an API request using Postman, follow these steps:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Postman 发起 API 请求，请按照以下步骤进行操作：
- en: In your Postman workspace, select the **New** button on the top-left menu bar,
    and then select **HTTP** from the list of options that appears. This will create
    a new **Untitled Request**.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 Postman 工作区中，选择左上角菜单栏中的**New**按钮，然后从出现的选项列表中选择**HTTP**。这将创建一个新的**Untitled
    Request**。
- en: Change the HTTP request type from **GET** to **POST** in the **Method** drop-down
    menu (by default, it will be set to **GET**).
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Method**下拉菜单中将 HTTP 请求类型从**GET**更改为**POST**（默认为**GET**）。
- en: 'Enter the following URL as the endpoint for Chat Completions: [https://api.openai.com/v1/chat/completions](https://api.openai.com/v1/chat/completions)'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下 URL 作为 Chat Completions 的终端：[https://api.openai.com/v1/chat/completions](https://api.openai.com/v1/chat/completions)
- en: 'Select **Headers** in the sub-menu, and add the following key-value pairs into
    the table below it:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在子菜单中选择**Headers**，并将以下键值对添加到其下方的表格中：
- en: '| *Key* | *Value* |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| *Key* | *Value* |'
- en: '| --- | --- |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Content-Type` | `application/json` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `Content-Type` | `application/json` |'
- en: '| `Authorization` | `Bearer <your API` `key here>` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `Authorization` | `Bearer <your API` `key here>` |'
- en: 'Select **Body** in the sub-menu and then select **raw** for the request type.
    Enter the following request body, which details to OpenAI the prompt, system message,
    chat log, and a set of other parameters that it needs to use to generate a completion
    response:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在子菜单中选择**Body**，然后选择**raw**作为请求类型。输入以下请求正文，向 OpenAI 提供需要生成响应的提示、系统消息、聊天记录及其他参数：
- en: '[PRE3]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The **Headers** and **Body** sections of the Postman request should look like
    this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Postman 请求的**Headers**和**Body**部分应如下所示：
- en: '![Figure 1.8 – Postman Headers](img/B21007_01_8.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.8 – Postman 头部](img/B21007_01_8.jpg)'
- en: Figure 1.8 – Postman Headers
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – Postman 头部
- en: '![Figure 1.9 – Postman Body](img/B21007_01_9.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.9 – Postman 主体](img/B21007_01_9.jpg)'
- en: Figure 1.9 – Postman Body
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 – Postman 主体
- en: 5. Click the **Send** button on the top right to make your HTTP request.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 点击右上角的 **发送** 按钮以发起 HTTP 请求。
- en: After sending the HTTP request, you should see the response from OpenAI API.
    The response is in the form of a **JavaScript Object Notation** (**JSON**) object.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 发送 HTTP 请求后，您应该会看到来自 OpenAI API 的响应。响应的形式是 **JavaScript 对象表示法**（**JSON**）对象。
- en: '![Figure 1.10 – Postman request body and response](img/B21007_01_10.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.10 – Postman 请求主体和响应](img/B21007_01_10.jpg)'
- en: Figure 1.10 – Postman request body and response
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 – Postman 请求主体和响应
- en: How it works…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'In order to build intelligent applications, we need to start using the OpenAI
    API instead of the Playground. There are other benefits to using the OpenAI API
    as well, including the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建智能应用，我们需要开始使用 OpenAI API 而不是 Playground。使用 OpenAI API 还有其他好处，包括以下几点：
- en: More flexibility, control, and customization of the model, its parameters, and
    its completions
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多的灵活性、控制和定制模型、其参数及其补全
- en: Enables you to integrate the power of OpenAI’s models directly into your application
    without your end users interacting with OpenAI at all
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使您能够直接将 OpenAI 模型的强大功能集成到您的应用中，而无需您的最终用户与 OpenAI 进行任何交互
- en: Provides you the power to scale the amount of model requests you’re making to
    fit the load of your application
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了根据您的应用负载来扩展模型请求数量的能力
- en: We are now going to shift our focus exclusively to the API, but seasoned developers
    will always revert to the Playground to perform testing on their system messages,
    chat logs, and parameters.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将专注于 API，但有经验的开发者总是会返回到 Playground 来测试他们的系统消息、聊天记录和参数。
- en: 'To make API requests, we need two things:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要发起 API 请求，我们需要两样东西：
- en: '*A way to make our requests* – For this, we used Postman as it’s an easy-to-use
    tool. When developing applications, however, the app itself will make requests.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*发起我们请求的一种方式* – 为此，我们使用了 Postman，因为它是一个易于使用的工具。然而，在开发应用时，应用本身会发起请求。'
- en: '*A way to authenticate our requests* – For this, we generated an API key from
    our OpenAI account. This tells OpenAI who is making this request.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*验证我们请求的一种方式* – 为此，我们从 OpenAI 账户中生成了一个 API 密钥。这告诉 OpenAI 谁在发起这个请求。'
- en: 'The actual API request consists of four elements: the *endpoint*, the *Header*,
    the *body*, and finally, the *response*. Note that this concept is not exclusive
    to OpenAI but applies to most APIs.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的 API 请求由四个元素组成：*端点*、*头部*、*主体*，最后是 *响应*。请注意，这一概念不仅仅适用于 OpenAI，也适用于大多数 API。
- en: The endpoint
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 端点
- en: The **endpoint** serves as the location of your HTTP request, which manifests
    itself in the form of a specific URL. A web server exists at the endpoint URL
    to listen to requests and provide the corresponding data. With OpenAI, each function
    corresponds to a different endpoint.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**端点** 是您的 HTTP 请求的目标位置，以特定的 URL 形式表现出来。端点 URL 上存在一个 Web 服务器，用来监听请求并提供相应的数据。在
    OpenAI 中，每个功能对应一个不同的端点。'
- en: 'For example, two additional examples of different endpoints within OpenAI are
    the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，OpenAI 中的两个额外示例端点如下：
- en: '[PRE4]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Additionally, the OpenAI API endpoint only accepts **POST** method requests.
    Think of the HTTP methods (POST, GET, etc.) as different ways to travel to a location:
    by train, air, or sea. In this case, OpenAI only accepts **POST** requests.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，OpenAI API 端点只接受 **POST** 方法的请求。可以将 HTTP 方法（POST、GET 等）视为不同的方式去一个目的地：火车、飞机或海运。在这种情况下，OpenAI
    只接受 **POST** 请求。
- en: The Header
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 头部（Header）
- en: 'The **Header** of an API request contains metadata about the request itself.
    Information represented in Header tags contains relevant and important elements
    about the body, and helps the server interpret the request. Specifically, in our
    case, we set two Headers:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: API 请求的 **头部** 包含有关请求本身的元数据。头部标签中表示的信息包含关于主体的相关和重要元素，帮助服务器解释请求。具体来说，在我们的案例中，我们设置了两个头部：
- en: '**Content-Type**: We set the content-type of our request to **application/json**,
    meaning that we are telling the server that our request body will be in JSON format.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Content-Type**：我们将请求的内容类型设置为 **application/json**，这意味着我们告诉服务器我们的请求主体将采用 JSON
    格式。'
- en: '**Authorization**: We set the authorization value to the API key, which allows
    the server to verify the client (Postman and our OpenAI Platform account in our
    case) that is making the specific request. The server can use the API key to check
    whether the client has permissions to make the request and whether the client
    has enough credit available to make the request. It’s worth noting that often,
    API keys are sent as a **Bearer token** within the authorization Header. A Bearer
    token signifies that the bearer of this token (i.e., the client making the request)
    is authorized to access specific resources. It serves as a compact and self-contained
    method for transmitting identity and authorization information between the client
    and the server.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：我们将授权值设置为 API 密钥，该密钥允许服务器验证发出特定请求的客户端（在我们的例子中是 Postman 和 OpenAI 平台账户）。服务器可以使用
    API 密钥检查客户端是否有权限发起请求，并且是否有足够的信用来执行请求。值得注意的是，通常，API 密钥作为 **Bearer token** 发送在授权头中。Bearer
    token 表示持有此令牌的用户（即发出请求的客户端）被授权访问特定资源。它作为一种紧凑且自包含的方法，用于在客户端和服务器之间传输身份和授权信息。'
- en: The Body
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正文
- en: 'Finally, the `Content-Type` defined in the Header of the request). The required
    parameters for the endpoint that we are using (Chat Completions) are `model` and
    `messages`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请求头中定义的 `Content-Type`。我们使用的端点（聊天完成）的必需参数是 `model` 和 `messages`：
- en: '**model**: This represents the specific model that is used to produce the completion.
    In our case, we used **gpt-3.5-turbo**, which represents the latest model that
    was available at the time. This is equivalent to using the **Model** dropdown
    in the **Parameters** section of the OpenAI Playground, which we saw in the *Setting
    up your OpenAI Playground* *environment* recipe.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**model**：这表示用于生成完成内容的特定模型。在我们的案例中，我们使用了 **gpt-3.5-turbo**，这是当时可用的最新模型。这相当于在
    OpenAI Playground 的 **模型** 下拉菜单中选择模型，就像我们在 *设置你的 OpenAI Playground* *环境* 示例中看到的那样。'
- en: '**messages**: This represents the System Message and Chat Log that the model
    has access to when generating its completion. In a conversation, it represents
    the list of messages comprising the conversation so far. In JSON, the list is
    denoted by **[]** to indicate that the message parameter contains a list of JSON
    objects (messages). Each JSON object (or message) within **messages** must contain
    a **role** string and a **content** string:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**messages**：这表示模型在生成完成内容时可以访问的系统消息和聊天记录。在对话中，它代表迄今为止组成对话的消息列表。在 JSON 中，列表通过
    **[]** 来表示，指示消息参数包含一个 JSON 对象列表（消息）。每个 **messages** 中的 JSON 对象（或消息）必须包含 **role**
    字符串和 **content** 字符串：'
- en: '**role**: In each message, this represents the role of the message author.
    To create a System Message, the role should be equal to **system**. To create
    a User message, the role should be equal to **user**. To create an Assistant message,
    the role should equal to **assistant**.'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**role**：在每条消息中，这表示消息作者的角色。要创建系统消息，角色应等于 **system**。要创建用户消息，角色应等于 **user**。要创建助手消息，角色应等于
    **assistant**。'
- en: '**content**: This represents the content of the message itself.'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**content**：这表示消息本身的内容。'
- en: In our case, we had set the System Message to `You are an assistant that creates
    marketing slogans based on descriptions of companies`, and the User message or
    prompt to `A company that writes engaging mystery novels`. This, in JSON form,
    is equivalent to our first Playground example.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将系统消息设置为 `你是一个根据公司描述创建营销标语的助手`，用户消息或提示设置为 `一个写引人入胜的悬疑小说的公司`。在 JSON
    形式中，这与我们的第一个 Playground 示例相当。
- en: The response
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 响应
- en: When we made the preceding request using Postman, we received a **response**
    from OpenAI in JSON notation. JSON is a lightweight data format that is easy for
    humans to read and write, and easy for machines to parse and generate. The data
    format consists of parameters, which are key-value pairs. Each parameter value
    can be in the form of a string, another JSON object, a list of strings, or a list
    of JSON objects.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Postman 发出前述请求时，我们收到了来自 OpenAI 的 **响应**，以 JSON 格式表示。JSON 是一种轻量级的数据格式，易于人类读取和编写，也容易被机器解析和生成。该数据格式由参数组成，这些参数是键值对。每个参数值可以是字符串、另一个
    JSON 对象、字符串列表或 JSON 对象列表的形式。
- en: '![Figure 1.11 – Postman OpenAI API response](img/B21007_01_10.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.11 – Postman OpenAI API 响应](img/B21007_01_10.jpg)'
- en: Figure 1.11 – Postman OpenAI API response
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11 – Postman OpenAI API 响应
- en: 'As you can see in *Figure 1**.11*, the response contains both metadata and
    actual content. The parameters and their meaning are described as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在*图1.11*中所见，响应包含了元数据和实际内容。参数及其含义描述如下：
- en: '**id**: A unique identifier for the transaction – every response has a different
    ID. This is typically used for record-keeping and tracking purposes.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**id**：事务的唯一标识符——每个响应都有不同的ID。通常用于记录和跟踪目的。'
- en: '**object**: The designation of the request and object type returned by the
    API, which in this scenario is **chat.completion** (as we used the Chat Completions
    endpoint), signifying the conclusion of a chat request.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**object**：请求的名称和由API返回的对象类型，在本例中是**chat.completion**（因为我们使用了聊天完成端点），表示聊天请求的结束。'
- en: '**created**: A timestamp denoting the exact moment of chat completion creation
    (based on Unix time)..'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**created**：一个时间戳，表示聊天完成创建的确切时间（基于Unix时间）。'
- en: '**model**: The precise model that was used to generate the response, which
    in this case is **gpt-3.5-turbo-0613**. Note that this differs from the model
    parameter in the request body. The model parameter in the **Body** section specifies
    the model type (**gpt-3.5-turbo**) that was used, whereas the model parameter
    in the **Response** section specifies not only the model type, but also the model
    version (which, in this case, is **0613**).'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：生成响应时使用的精确模型，在本例中是**gpt-3.5-turbo-0613**。请注意，这与请求正文中的模型参数不同。**Body**部分中的模型参数指定了使用的模型类型（**gpt-3.5-turbo**），而**Response**部分中的模型参数不仅指定了模型类型，还指定了模型版本（在本例中为**0613**）。'
- en: '**Choices**: An array that comprises the responses generated by the model.
    Each element of this array contains the following:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Choices**：一个数组，包含模型生成的响应。该数组的每个元素包含以下内容：'
- en: '**index**: A number that represents the order of the choices, with the first
    choice having an index of **0**'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**索引**：一个表示选择顺序的数字，第一个选择的索引是**0**。'
- en: '**message**: An object containing the message produced by the assistant, comprising
    the following:'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息**：一个包含助手生成的消息的对象，包含以下内容：'
- en: '**role**: The role of the entity generating the message. This is very similar
    to the roles in the Chat Log within the Playground screen.'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**role**：生成消息的实体的角色。这与Playground屏幕中的聊天日志中的角色非常相似。'
- en: '**content**: The literal text or output generated by the OpenAI model.'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**content**：由OpenAI模型生成的文字或输出。'
- en: '**finish_reason**: A string that indicates why the OpenAI model decided to
    stop generating further output. In this case, **stop** means the model concluded
    the message in a natural way.'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**finish_reason**：一个字符串，表示OpenAI模型决定停止生成进一步输出的原因。在本例中，**stop**意味着模型以自然的方式结束了消息。'
- en: '**usage**: A list of parameters that represent the usage, or costs, of the
    particular API request:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用情况**：表示特定API请求使用情况或费用的参数列表：'
- en: '**prompt_tokens**: The quantity of tokens utilized in the initial prompt or
    the input message'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**prompt_tokens**：在初始提示或输入消息中使用的令牌数量。'
- en: '**completion_tokens**: The number of tokens produced by the model as a response
    to the prompt'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**completion_tokens**：模型根据提示生成的令牌数量。'
- en: '**total_tokens**: An aggregate of the prompt and completion tokens, signifying
    the total tokens expended for the specific API invocation'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**total_tokens**：提示令牌和完成令牌的总和，表示特定API调用所消耗的令牌总数。'
- en: The response in JSON format may be difficult for us to read. In fact, what we
    particularly care about is not `id`, `index`, or `created`, but the `content`
    parameter, which contains the response
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: JSON格式的响应可能不容易阅读。事实上，我们特别关心的不是`id`、`index`或`created`，而是包含响应内容的`content`参数。
- en: '[PRE5]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: However, the JSON response format is essential when integrating the API into
    your own applications.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，JSON响应格式在将API集成到你自己的应用程序中时是至关重要的。
- en: This recipe summarizes the essential elements of the OpenAI API and demonstrates
    how to use an API client such as Postman to send requests and receive responses.
    This is important because this is the primary method that we will use to learn
    more about the API and its various other aspects (such as parameters, different
    endpoints, interpreting the response, etc.).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱总结了OpenAI API的基本要素，并展示了如何使用像Postman这样的API客户端发送请求并接收响应。这一点很重要，因为这是我们用来了解API及其其他方面（如参数、不同端点、解析响应等）的主要方法。
