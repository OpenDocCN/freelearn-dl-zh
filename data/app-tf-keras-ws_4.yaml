- en: 4\. Productization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. 产品化
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概览
- en: In this chapter, you will handle new data and create a model that is able to
    learn continuously from the patterns it is shown and help make better predictions.
    We will use a web application as an example to show how to deploy deep learning
    models not only because of the simplicity and prevalence of web apps, but also
    the different possibilities they provide, such as getting predictions on mobile
    using a web browser and making REST APIs for users.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将处理新数据，并创建一个能够从展示的模式中持续学习并帮助做出更好预测的模型。我们将以网页应用程序为例，展示如何部署深度学习模型，不仅因为网页应用程序的简单性和普及性，还因为它们提供了不同的可能性，比如通过网页浏览器在移动设备上获取预测结果，并为用户制作
    REST API。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: This chapter focuses on how to *productize* a deep learning model. We use the
    word productize to define the creation of a software product from a deep learning
    model that can be used by other people and applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是如何将深度学习模型*产品化*。我们使用“产品化”这个词来定义从深度学习模型创建软件产品的过程，使其可以被其他人和应用程序使用。
- en: 'We are interested in models that use new data as and when it becomes available,
    continuously learn patterns from new data, and consequently, make better predictions.
    In this chapter, we will study two strategies to deal with new data: one that
    retrains an existing model, and another that creates a completely new model. Then,
    we implement the latter strategy in our Bitcoin price prediction model so that
    it can continuously predict new Bitcoin prices.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关注的是那些使用新数据并在数据可用时进行学习的模型，这些模型能够从新数据中持续学习模式，并因此做出更好的预测。在本章中，我们将研究两种处理新数据的策略：一种是重新训练现有模型，另一种是创建一个完全新的模型。然后，我们将在比特币价格预测模型中实现后一种策略，以使其能够持续预测新的比特币价格。
- en: By the end of this chapter, we will be able to deploy a working web application
    (with a functioning HTTP API) and modify it to our heart's content.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将能够部署一个可工作的网页应用程序（具有有效的 HTTP API），并根据需要进行修改。
- en: Handling New Data
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理新数据
- en: Models can be trained once using a set of data and can then be used to make
    predictions. Such static models can be very useful, but it is often the case that
    we want our model to continuously learn from new data—and to continuously get
    better as it does so.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 模型可以使用一组数据进行一次性训练，然后用来进行预测。这类静态模型非常有用，但通常情况下，我们希望模型能够从新数据中持续学习——并在此过程中不断改进。
- en: In this section, we will discuss two strategies of handling new data and see
    how to implement them in Python.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论处理新数据的两种策略，并展示如何在 Python 中实现它们。
- en: Separating Data and Model
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据和模型的分离
- en: When building a deep learning application, the two most important areas are
    data and model. From an architectural point of view, it is recommended that these
    two areas be kept separate. We believe that is a good suggestion because each
    of these areas includes functions inherently separate from each other. Data is
    often required to be collected, cleaned, organized, and normalized, whereas models
    need to be trained, evaluated, and able to make predictions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建深度学习应用程序时，最重要的两个领域是数据和模型。从架构角度来看，建议将这两个领域分开。我们认为这是一个好建议，因为这两个领域本质上包含了彼此独立的功能。数据通常需要收集、清洗、整理和标准化，而模型需要训练、评估，并能够进行预测。
- en: 'Following that suggestion, we will be using two different code bases to help
    us build our web application: the Yahoo Finance API and `Model()`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个建议，我们将使用两个不同的代码库来帮助构建我们的网页应用程序：Yahoo Finance API 和 `Model()`：
- en: 'The Yahoo Finance API: The API can be installed by using `pip` with the following command:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yahoo Finance API：可以使用以下命令通过 `pip` 安装该 API：
- en: '[PRE0]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After installation, we will be able to access all the historical data related
    to the finance domain.
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安装完成后，我们将能够访问所有与金融领域相关的历史数据。
- en: '`Model()`: This class implements all the code we have written so far into a
    single class. It provides facilities for interacting with our previously trained
    models and allows us to make predictions using de-normalized data, which is much
    easier to understand. The `Model()` class is our model component.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Model()`：这个类将我们目前所写的所有代码整合成一个单独的类。它提供了与我们先前训练的模型交互的功能，并允许我们使用去标准化的数据进行预测，这样更容易理解。`Model()`
    类是我们的模型组件。'
- en: These two code bases are used extensively throughout our example application
    and define the data and model components.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个代码库在我们的示例应用程序中被广泛使用，定义了数据和模型组件。
- en: The Data Component
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据组件
- en: 'The Yahoo Finance API helps to retrieve and parse the historical data of stocks.
    It contains one relevant method, `history()`, which is detailed in the following
    code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Yahoo Finance API 帮助检索并解析股票的历史数据。它包含一个相关方法 `history()`，其详细代码如下：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This `history()` method collects data from the Yahoo Finance website, parses
    it, and returns a pandas DataFrame that is ready to be used by the `Model()` class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `history()` 方法从 Yahoo Finance 网站收集数据，解析数据并返回一个已准备好供 `Model()` 类使用的 pandas
    DataFrame。
- en: The Yahoo Finance API uses the parameter ticker to determine what cryptocurrency
    to collect. The Yahoo Finance API has many other cryptocurrencies available, including
    popular ones such as Ethereum and Bitcoin Cash. Using the `ticker` parameter,
    you can change the cryptocurrency and train a different model apart from the Bitcoin
    model created in this book.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Yahoo Finance API 使用参数 `ticker` 来确定要收集的加密货币。Yahoo Finance API 还提供了许多其他加密货币，包括以太坊（Ethereum）和比特币现金（Bitcoin
    Cash）等流行的加密货币。通过使用 `ticker` 参数，你可以更改加密货币，并训练一个与本书中创建的比特币模型不同的模型。
- en: The Model Component
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型组件
- en: 'The `Model()` class is where we implement the application''s model component.
    The `Model()` class contains five methods that implement all the different modeling
    topics from this book. They are the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Model()` 类是我们实现应用程序模型组件的地方。`Model()` 类包含五个方法，这些方法实现了本书中的所有不同建模主题。它们分别是：'
- en: '`build()`: This method builds an LSTM model using TensorFlow. This method works
    as a simple wrapper for a manually created model.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build()`：这个方法使用 TensorFlow 构建一个 LSTM 模型。该方法作为一个简单的包装器，用于手动创建的模型。'
- en: '`train()`: This method trains the model using data that the class was instantiated
    with.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`train()`：这个方法使用类实例化时提供的数据来训练模型。'
- en: '`evaluate()`: This method evaluates the model using a set of loss functions.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`evaluate()`：这个方法使用一组损失函数来评估模型。'
- en: '`save()`: This method saves the model locally as a file.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`save()`：这个方法将模型保存为本地文件。'
- en: '`predict()`: This method makes and returns predictions based on an input sequence
    of observations ordered by week.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`predict()`：这个方法基于按周排序的观察输入序列进行预测并返回结果。'
- en: 'We will use these methods throughout this chapter to work, train, evaluate,
    and issue predictions with our model. The `Model()` class is an example of how
    to wrap essential TensorFlow functions into a web application. The preceding methods
    can be implemented almost exactly as in previous chapters, but with enhanced interfaces.
    For example, the `train()` method implemented in the following code trains a model
    available in `self.model` using data from `self.X` and `self.Y`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中使用这些方法来工作、训练、评估和发出预测。`Model()` 类是如何将 TensorFlow 的核心功能包装成 Web 应用程序的一个示例。前面提到的方法几乎可以像以前的章节一样实现，但有增强的接口。例如，以下代码中实现的
    `train()` 方法使用来自 `self.X` 和 `self.Y` 的数据训练 `self.model` 中的模型：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The general idea is that each of the processes from the Keras workflow (build
    or design, train, evaluate, and predict) can easily be turned into distinct parts
    of a program. In our case, we have made them into methods that can be invoked
    from the `Model()` class. This organizes our program and provides a series of
    constraints (such as on the model architecture or certain API parameters), which
    help us deploy our model in a stable environment.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，Keras 工作流程中的每个过程（构建或设计、训练、评估和预测）都可以轻松地转化为程序中的独立部分。在我们的案例中，我们将它们转化为可以从 `Model()`
    类调用的方法。这组织了我们的程序，并提供了一系列约束（例如关于模型架构或某些 API 参数的约束），帮助我们在稳定的环境中部署模型。
- en: In the following sections, we will explore common strategies for dealing with
    new data.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨处理新数据的常见策略。
- en: Dealing with New Data
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理新数据
- en: 'The core idea of machine learning models—neural networks included—is that they
    can learn patterns from data. Imagine that a model was trained with a certain
    dataset and it is now issuing predictions. Now, imagine that new data is available.
    There are different strategies you can employ so that a model can take advantage
    of the newly available data to learn new patterns and improve its predictions.
    In this section, we will discuss two strategies:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习模型的核心理念（包括神经网络）是它们可以从数据中学习模式。假设一个模型已经使用某个数据集进行训练，现在它开始进行预测。现在，假设有新的数据可用。你可以采用不同的策略，让模型利用这些新数据学习新模式并改进其预测。在本节中，我们将讨论两种策略：
- en: Retraining an old model
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新训练旧模型
- en: Training a new model
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练新模型
- en: Retraining an Old Model
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新训练旧模型
- en: In this strategy, we retrain an existing model with new data. Using this strategy,
    you can continuously adjust the model parameters to adapt to new phenomena. However,
    data used in later training periods might be significantly different from earlier
    data. Such differences might cause significant changes to the model parameters,
    such as making it learn new patterns and forget old patterns. This phenomenon
    is generally referred to as **catastrophic forgetting**.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个策略中，我们通过使用新数据来重新训练现有模型。通过这种策略，你可以持续调整模型参数，以适应新的现象。然而，后期训练期间使用的数据可能与早期数据有显著差异。这些差异可能导致模型参数发生重大变化，比如让模型学习新的模式并遗忘旧的模式。这种现象通常被称为**灾难性遗忘**。
- en: Note
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Catastrophic forgetting is a common phenomenon affecting neural networks. Deep
    learning researchers have been trying to tackle this problem for many years. DeepMind,
    a Google-owned deep learning research group from the United Kingdom, has made
    notable advancements in finding a solution. The article, *Overcoming* *Catastrophic
    Forgetting in Neural Networks*, *James Kirkpatrick*, *et. al*. is a good reference
    for such work, and is available at [https://arxiv.org/pdf/1612.00796.pdf](https://arxiv.org/pdf/1612.00796.pdf).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 灾难性遗忘是一个常见的现象，影响着神经网络。深度学习研究人员多年来一直在努力解决这个问题。DeepMind（一个来自英国、隶属于谷歌的深度学习研究团队）在寻找解决方案方面取得了显著进展。文章《克服神经网络中的灾难性遗忘》，*James
    Kirkpatrick* 等人，提供了很好的参考，相关资料可以在[https://arxiv.org/pdf/1612.00796.pdf](https://arxiv.org/pdf/1612.00796.pdf)找到。
- en: 'The interface used for training (`model.fit()`) for the first time can be used
    for training with new data as well. The following snippet loads the data and helps
    to train a model specifying the epochs and batch size:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 用于第一次训练的接口（`model.fit()`）也可以用于用新数据进行训练。以下代码段加载数据并帮助训练一个模型，指定了训练的轮数（epochs）和批量大小（batch
    size）：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In TensorFlow, when models are trained, the model's state is saved as weights
    on the disk. When you use the `model.save()` method, that state is also saved.
    And when you invoke the `model.fit()` method, the model is retrained with the
    new dataset, using the previous state as a starting point.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TensorFlow 中，当模型训练时，模型的状态会作为权重保存在磁盘上。当你使用 `model.save()` 方法时，该状态也会被保存。而当你调用
    `model.fit()` 方法时，模型会使用新的数据集进行重新训练，且以之前的状态作为起点。
- en: 'In typical Keras models, this technique can be used without further issues.
    However, when working with LSTM models, this technique has one key limitation:
    the shape of both train and validation data must be the same. For example, in
    *Chapter 3*, *Real-World Deep Learning with TensorFlow and Keras: Evaluating the
    Bitcoin Model*, our LSTM model (`bitcoin_lstm_v0`) uses 186 weeks to predict one
    week into the future. If we attempt to retrain the model with 187 weeks to predict
    the coming week, the model raises an exception with information regarding the
    incorrect shape of data.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的 Keras 模型中，这种技术可以正常使用而不会遇到问题。然而，在处理 LSTM 模型时，这种技术有一个关键限制：训练数据和验证数据的形状必须相同。例如，在*第3章*，*使用
    TensorFlow 和 Keras 进行真实世界深度学习：评估比特币模型*中，我们的 LSTM 模型（`bitcoin_lstm_v0`）使用了186周的数据来预测未来的一周。如果我们尝试用187周的数据来重新训练模型以预测下一周，模型会抛出异常，并提供有关数据形状不正确的信息。
- en: 'One way of dealing with this is to arrange data in the format expected by the
    model. For example, to make predictions based on a year''s data (52 weeks), we
    would need to configure a model to predict a future week using 40 weeks. In this
    case, we first train the model with the first 40 weeks of 2019, then continue
    to retrain it over the following weeks until we reach week 51\. We use the `Model()`
    class to implement a retraining technique in the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是将数据安排成模型所期望的格式。例如，为了基于一年的数据（52周）进行预测，我们需要配置一个模型，用40周的数据预测未来一周。在这种情况下，我们首先使用2019年初的40周数据训练模型，然后继续在接下来的周数中进行重新训练，直到达到第51周。我们使用
    `Model()` 类在以下代码中实现了这一重新训练技术：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This technique tends to be fast to train and tends to work well with series
    that are large. The next technique is easier to implement and works well in smaller
    series.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术通常训练速度较快，并且适用于较大的序列数据。接下来的技术更容易实现，并且在较小的序列中表现良好。
- en: Training a New Model
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 训练新模型
- en: Another strategy is to create and train a new model every time new data is available.
    This approach tends to reduce catastrophic forgetting, but training time increases
    as data increases. Its implementation is quite simple.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种策略是每当有新数据时，创建并训练一个新模型。这种方法通常能减少灾难性遗忘，但随着数据量的增加，训练时间也会增加。其实现相当简单。
- en: 'Using the Bitcoin model as an example, let''s now assume that we have old data
    for 49 weeks of 2019, and that after a week, new data is available. We represent
    this with the `old_data` and `new_data` variables in the following snippet, in
    which we implement a strategy for training a new model when new data is available:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以比特币模型为例，假设我们有2019年49周的旧数据，并且在一周后，新的数据可用。我们通过以下代码片段中的`old_data`和`new_data`变量来表示这一点，并在新数据可用时实现训练新模型的策略：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This approach is very simple to implement and tends to work well for small datasets.
    This will be the preferred solution for our Bitcoin price-predictions application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法非常简单，通常适用于小型数据集。这将是我们比特币价格预测应用的首选解决方案。
- en: 'Exercise 4.01: Retraining a Model Dynamically'
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '练习 4.01: 动态重新训练模型'
- en: 'In this exercise, you have to retrain a model to make it dynamic. Whenever
    new data is loaded, it should be able to make predictions accordingly. Here are
    the steps to follow:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你需要重新训练一个模型，使其具备动态功能。每当加载新数据时，模型应能根据数据做出预测。以下是需要遵循的步骤：
- en: 'Start by importing `cryptonic`. Cryptonic is a simple software application
    developed for this book that implements all the steps up to this section using
    Python classes and modules. Consider Cryptonic as a template to be used to create
    applications. Cryptonic, provided as a Python module for this exercise, can be
    found at the following GitHub link: [https://packt.live/325WdZQ](https://packt.live/325WdZQ).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入 `cryptonic`。Cryptonic 是一本书中为实现这一节的步骤而开发的简单软件应用，使用 Python 类和模块实现了所有步骤。可以将
    Cryptonic 视为创建应用程序的模板。作为本练习的 Python 模块，Cryptonic 可以在以下 GitHub 链接找到：[https://packt.live/325WdZQ](https://packt.live/325WdZQ)。
- en: First, we will start a Jupyter Notebook instance, and then we will load the
    `cryptonic` package.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将启动一个 Jupyter Notebook 实例，然后加载 `cryptonic` 包。
- en: 'Using your Terminal, navigate to the `Chapter04/Exercise4.01` directory and
    execute the following code to start a Jupyter Notebook instance:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用终端，导航到 `Chapter04/Exercise4.01` 目录，并执行以下代码来启动 Jupyter Notebook 实例：
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The server will automatically open in your browser, then open the Jupyter Notebook
    named `Exercise4.01_Re_training_a_model_dynamically.ipynb`.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 服务器会自动在浏览器中打开，然后打开名为 `Exercise4.01_Re_training_a_model_dynamically.ipynb` 的
    Jupyter Notebook。
- en: 'Now, we will import classes from the `cryptonic` package: `Model()` and the
    Yahoo Finance API. These classes facilitate the process of manipulating our model.'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将从`cryptonic`包中导入类：`Model()`和Yahoo Finance API。这些类简化了操作我们模型的过程。
- en: 'In the Jupyter Notebook instance, navigate to the header `Fetching Real-Time
    Data`. We will now be fetching updated historical data from Yahoo Finance by calling
    the `history()` method:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Jupyter Notebook 实例中，导航到标题为 `Fetching Real-Time Data` 的部分。我们将通过调用 `history()`
    方法，从 Yahoo Finance 获取更新的历史数据：
- en: '[PRE7]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `historic_data` variable is now populated with a pandas DataFrame that contains
    historic data of Bitcoin rates up to the time of running this code. This is great
    and makes it easier to retrain our model when more data is available.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`historic_data` 变量现在包含一个 pandas DataFrame，其中包含比特币汇率的历史数据，直到运行此代码的时刻为止。这非常好，并且使得在获取更多数据时重新训练我们的模型变得更容易。'
- en: 'You can view the first three rows of data stored in `historic_data` using the
    following command:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用以下命令查看存储在`historic_data`中的前三行数据：
- en: '[PRE8]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can then view this data stored in `historic_data`:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，你可以查看存储在`historic_data`中的数据：
- en: '![Figure 4.1: Output displaying the head of the data'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.1: 显示数据头部的输出'
- en: '](img/B15911_04_01.jpg)'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15911_04_01.jpg)'
- en: 'Figure 4.1: Output displaying the head of the data'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '图 4.1: 显示数据头部的输出'
- en: The data contains practically the same variables from the Bitcoin dataset we
    used. However, much of the data comes from an earlier period, 2017 to 2019.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据包含与我们使用的比特币数据集几乎相同的变量。然而，大部分数据来自较早的时间段，即2017年到2019年。
- en: 'Using the pandas API, filter the data for only the dates available in 2019,
    and store them in `model_data`. You should be able to do this by using the date
    variable as the filtering index. Make sure the data is filtered before you continue:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 pandas API，筛选出2019年可用的数据，并将其存储在`model_data`中。你应该能够通过使用日期变量作为筛选索引来实现这一点。确保在继续之前已经过滤好数据：
- en: '[PRE9]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run `model_data` in next cell and the output model can be seen as follows:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下一个单元格中运行`model_data`，输出模型如下所示：
- en: '![Figure 4.2: The model_data variable showing historical data'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.2: model_data 变量显示历史数据'
- en: '](img/B15911_04_02.jpg)'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15911_04_02.jpg)'
- en: 'Figure 4.2: The model_data variable showing historical data'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '图 4.2: model_data 变量显示历史数据'
- en: The `Model()` class compiles all the code we have written so far in all of our
    activities. We will use that class to build, train, and evaluate our model in
    this activity.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Model()` 类将我们在所有活动中编写的所有代码进行了汇编。我们将在本活动中使用该类来构建、训练和评估我们的模型。'
- en: 'We will now use the filtered data to train the model:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用筛选后的数据来训练模型：
- en: '[PRE10]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the following command to see the trained model:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令查看训练后的模型：
- en: '[PRE11]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The trained model is shown in the following screenshot:'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 训练后的模型显示在以下截图中：
- en: '![Figure 4.3: The output showing our trained model'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.3：显示我们训练好的模型的输出'
- en: '](img/B15911_04_03.jpg)'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15911_04_03.jpg)'
- en: 'Figure 4.3: The output showing our trained model'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.3：显示我们训练好的模型的输出
- en: The preceding steps showcase the complete workflow when using the `Model()`
    class to train a model.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述步骤展示了使用 `Model()` 类训练模型时的完整工作流。
- en: Note
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: For the complete code, use the `Chapter04/Exercise4.01` folder.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整代码请参阅 `Chapter04/Exercise4.01` 文件夹。
- en: Next, we'll focus on retraining our model every time more data is available.
    This readjusts the weights of the network to new data.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将重点关注每次新数据可用时重新训练我们的模型。这样可以根据新数据调整网络权重。
- en: In order to do this, we have configured our model to predict a week using 40
    weeks. We now want to use the remaining 11 full weeks to create overlapping periods
    of 40 weeks. These include one of those 11 weeks at a time, and retrain the model
    for every one of those periods.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为此，我们已将模型配置为使用40周来预测一周。现在我们想利用剩余的11周完整数据来创建40周的重叠周期。每个周期包括这11周中的一个，并为每个周期重新训练模型。
- en: 'Navigate to the `Re-Train Old Model` header in the Jupyter Notebook. Now, complete
    the `range` function and the `model_data` filtering parameters using an index
    to split the data into overlapping groups of seven days. Then, retrain our model
    and collect the results:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Jupyter Notebook中导航到`Re-Train Old Model`标题。现在，使用索引完成`range`函数和`model_data`筛选参数，按七天为一组进行数据拆分，形成重叠组。然后，重新训练我们的模型并收集结果：
- en: '[PRE12]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `A`, `B`, `C`, and `D` variables are placeholders. Use integers to create
    overlapping groups of seven days in which the overlap is of one day.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`A`、`B`、`C` 和 `D` 变量是占位符。使用整数来创建重叠的七天组，其中重叠部分为一天。'
- en: 'Replacing these placeholders with weeks, we run the loop as follows:'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将这些占位符替换为周数后，我们按照以下方式运行循环：
- en: '[PRE13]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here''s the output showing the results of this loop:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是显示该循环结果的输出：
- en: '[PRE14]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After you have retrained your model, go ahead and invoke the `M.predict(denormalized=True)`
    function and examine the results:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新训练模型后，继续调用`M.predict(denormalized=True)`函数并检查结果：
- en: '[PRE15]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next, we'll focus on creating and training a new model every time new data is
    available. In order to do this, we now assume that we have old data for 49 weeks
    of 2019, and after a week, we now have new data. We represent this with the `old_data`
    and `new_data` variables.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将专注于每次有新数据时创建和训练一个新模型。为此，我们假设我们有2019年49周的旧数据，并且过了一周后我们有了新数据。我们用`old_data`和`new_data`变量表示这一点。
- en: 'Navigate to the `New Data New Model` header and split the data between the
    `old_data` and `new_data` variables:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `New Data New Model` 标题，并将数据分为 `old_data` 和 `new_data` 两个变量：
- en: '[PRE16]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, train the model with `old_data` first:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，首先使用`old_data`训练模型：
- en: '[PRE17]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We now have all the pieces that we need in order to train our model dynamically.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了训练动态模型所需的所有组成部分。
- en: Note
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2AQb3bE](https://packt.live/2AQb3bE).
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问该特定部分的源代码，请参考 [https://packt.live/2AQb3bE](https://packt.live/2AQb3bE)。
- en: You can also run this example online at [https://packt.live/322KuLl](https://packt.live/322KuLl).
    You must execute the entire Notebook in order to get the desired result.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以在线运行这个示例，访问 [https://packt.live/322KuLl](https://packt.live/322KuLl)。你必须执行整个Notebook才能获得期望的结果。
- en: In the next section, we will deploy our model as a web application, making its
    predictions available in the browser via an HTTP API.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分中，我们将把模型部署为Web应用程序，使其预测结果通过HTTP API在浏览器中可用。
- en: Deploying a Model as a Web Application
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将模型部署为Web应用程序
- en: In this section, we will deploy our model as a web application. We will use
    the Cryptonic web application to deploy our model, exploring its architecture
    so that we can make modifications in the future. The intention is to have you
    use this application as a starter for more complex applications—a starter that
    is fully working and can be expanded as you see fit.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将把模型部署为 Web 应用程序。我们将使用 Cryptonic Web 应用程序来部署模型，探索其架构，以便我们将来能够进行修改。我们的目的是让您使用此应用程序作为更复杂应用程序的起点——一个完全可用并可以根据需要扩展的起点。
- en: Aside from familiarity with Python, this topic assumes familiarity with creating
    web applications. Specifically, we assume that you have some knowledge of web
    servers, routing, the HTTP protocol, and caching. You will be able to locally
    deploy the demonstrated Cryptonic application without extensive knowledge of these
    web servers, the HTTP protocol, and caching, but learning these topics will make
    any future development much easier.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了熟悉 Python，本主题还假设您了解创建 Web 应用程序的相关知识。具体来说，我们假设您对 Web 服务器、路由、HTTP 协议和缓存有一定的了解。您可以在没有深入了解
    Web 服务器、HTTP 协议和缓存的情况下，本地部署所演示的 Cryptonic 应用程序，但学习这些知识将使未来的开发更加轻松。
- en: Finally, Docker is used to deploy our web applications, so basic knowledge of
    that technology is also useful.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Docker 用于部署我们的 Web 应用程序，因此对该技术的基本了解也是有帮助的。
- en: 'Before we continue, make sure that you have the following applications installed
    and available on your computer:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保您的计算机上已安装并可以使用以下应用程序：
- en: Docker (Community Edition) 17.12.0-ce or later
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker（社区版）17.12.0-ce 或更高版本
- en: Docker Compose (`docker-compose`) 1.18.0 or later
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose (`docker-compose`) 1.18.0 或更高版本
- en: Both these components can be downloaded and installed on all major systems from
    [http://docker.com/](http://docker.com/). These are essential for completing this
    activity. Make sure these are available in your system before moving forward.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个组件可以从 [http://docker.com/](http://docker.com/) 下载并安装在所有主要系统上。这些组件对于完成本次活动至关重要。确保在继续之前，它们已经安装并可在系统中使用。
- en: Application Architecture and Technologies
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序架构与技术
- en: 'In order to deploy our web applications, we will use the tools and technologies
    described in *Figure 4.4*. Flask is key because it helps us create an HTTP interface
    for our model, allowing us to access an HTTP endpoint (such as `/predict`) and
    receive data back in a universal format. The other components are used because
    they are popular choices when developing web applications:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了部署我们的 Web 应用程序，我们将使用 *图 4.4* 中描述的工具和技术。Flask 是关键，因为它帮助我们为模型创建一个 HTTP 接口，使我们能够访问
    HTTP 端点（例如 `/predict`）并以通用格式接收数据。其他组件之所以被使用，是因为它们在开发 Web 应用程序时非常流行：
- en: '![Figure 4.4: Tools and technologies used for deploying a deep learning web
    application'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.4：用于部署深度学习 Web 应用程序的工具和技术](img/B15911_04_04.jpg)'
- en: '](img/B15911_04_04.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15911_04_04.jpg)'
- en: 'Figure 4.4: Tools and technologies used for deploying a deep learning web application'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：用于部署深度学习 Web 应用程序的工具和技术
- en: 'These components fit together as shown in the following diagram:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件按如下图所示组合在一起：
- en: '![Figure 4.5: System architecture for the web application built in this project'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5：本项目中构建的 Web 应用程序的系统架构](img/B15911_04_04.jpg)'
- en: '](img/B15911_04_05.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15911_04_05.jpg)'
- en: 'Figure 4.5: System architecture for the web application built in this project'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5：本项目中构建的 Web 应用程序的系统架构
- en: A user visits the web application using their browser. That traffic is then
    routed by Nginx to the Docker container containing the Flask application (by default,
    running on port `5000`). The Flask application has instantiated our Bitcoin model
    at startup. If a model has been given, it uses that model without training; if
    not, it creates a new model and trains it from scratch using data from Yahoo Finance.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通过浏览器访问 Web 应用程序。然后，流量由 Nginx 路由到包含 Flask 应用程序的 Docker 容器中（默认情况下，运行在 `5000`
    端口）。Flask 应用程序在启动时已实例化我们的比特币模型。如果指定了一个模型，它将使用该模型而不进行训练；如果没有，它会创建一个新模型，并使用来自 Yahoo
    Finance 的数据从头开始训练。
- en: After having a model ready, the application verifies if the request has been
    cached on Redis; if yes, it returns the cached data. If no cache exists, then
    it will go ahead and issue predictions, which are rendered in the UI.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型准备好之后，应用程序会验证请求是否已缓存到 Redis 中；如果缓存存在，它会返回缓存的数据。如果没有缓存，它将继续进行预测，并在用户界面中渲染结果。
- en: 'Exercise 4.02: Deploying and Using Cryptonic'
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.02：部署和使用 Cryptonic
- en: Cryptonic is developed as a dockerized application. In Docker terms, this means
    that the application can be built as a Docker image and then deployed as a Docker
    container in either a development or a production environment.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Cryptonic 被开发为一个容器化应用程序。在 Docker 术语中，这意味着该应用程序可以作为 Docker 镜像构建，然后在开发或生产环境中作为
    Docker 容器部署。
- en: In this exercise, we will see how to use Docker and Cryptonic to deploy the
    application. Before you begin, download Docker for Desktop from [https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)
    Make sure that this application is running in the background before beginning
    the exercise.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将学习如何使用 Docker 和 Cryptonic 部署应用程序。在开始之前，请从 [https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)
    下载 Docker Desktop，确保在开始练习之前该应用程序已在后台运行。
- en: Note
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The complete code for this exercise can be found at [https://packt.live/2AM5mLP](https://packt.live/2AM5mLP).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 该练习的完整代码可以在 [https://packt.live/2AM5mLP](https://packt.live/2AM5mLP) 找到。
- en: 'Docker uses files called `Dockerfiles` to describe the rules for how to build
    an image and what happens when that image is deployed as a container. Cryptonic''s
    Dockerfile is available in the following code:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 使用名为 `Dockerfile` 的文件来描述如何构建镜像的规则以及当镜像作为容器部署时会发生什么。Cryptonic 的 Dockerfile
    可在以下代码中找到：
- en: '[PRE18]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A Dockerfile can be used to build a Docker image with the following command:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用以下命令构建 Docker 镜像：
- en: '[PRE19]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This command will make the `cryptonic:latest` image available to be deployed
    as a container. The building process can be repeated on a production server, or
    the image can be directly deployed and then run as a container.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将使 `cryptonic:latest` 镜像可用于作为容器部署。构建过程可以在生产服务器上重复执行，或者直接部署该镜像并作为容器运行。
- en: 'After an image has been built and is available, you can run the Cryptonic application
    by using the `docker run` command, as shown in the following code:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在镜像构建完成并可用后，您可以使用 `docker run` 命令运行 Cryptonic 应用程序，如下所示的代码所示：
- en: '[PRE20]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `--publish` flag binds port `5000` on localhost to port `5000` on the Docker
    container, and `--detach` runs the container as a daemon in the background.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`--publish` 标志将本地 `5000` 端口绑定到 Docker 容器的 `5000` 端口，`--detach` 使容器在后台以守护进程模式运行。'
- en: In case you have trained a different model and would like to use that instead
    of training a new model, you can alter the `MODEL_NAME` environment variable on
    the `docker-compose.yml`. That variable should contain the filename of the model
    you have trained and want served (for example, `bitcoin_lstm_v1_trained.h5`);
    it should also be a Keras model. If you do that, make sure to also mount a local
    directory into the `/models` folder. The directory that you decide to mount must
    contain your model file.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您已经训练了一个不同的模型，并且希望使用该模型而不是训练新模型，您可以在 `docker-compose.yml` 文件中修改 `MODEL_NAME`
    环境变量。该变量应包含您训练并希望提供的模型的文件名（例如，`bitcoin_lstm_v1_trained.h5`）；它也应该是一个 Keras 模型。如果您这样做，请确保将本地目录挂载到
    `/models` 文件夹中。您决定挂载的目录必须包含您的模型文件。
- en: 'The Cryptonic application also includes several environment variables that
    you may find useful when deploying your own model:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Cryptonic 应用程序还包括一些在部署您自己的模型时可能会用到的环境变量：
- en: '`MODEL_NAME`: Allows us to provide a trained model to be used by the application.'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`MODEL_NAME`：允许我们提供一个经过训练的模型供应用程序使用。'
- en: '`BITCOIN_START_DATE`: Determines which day to use as the starting day for the
    Bitcoin series. Bitcoin prices have a lot more variance in recent years than earlier
    ones. This parameter filters the data to only years of interest. The default is
    `January 1, 2017`.'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`BITCOIN_START_DATE`：确定用于比特币系列的起始日期。近年来，比特币价格的波动比早期更大。此参数过滤数据，仅保留感兴趣年份的数据。默认值为
    `2017年1月1日`。'
- en: '`PERIOD_SIZE`: Sets the period size in terms of days. The default is `7`.'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`PERIOD_SIZE`：设置以天为单位的周期大小。默认值为 `7`。'
- en: '`EPOCHS`: Configures the number of epochs that the model trains on every run.
    The default is `300`.'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`EPOCHS`：配置模型在每次运行时训练的轮数。默认值为 `300`。'
- en: 'These variables can be configured in the `docker-compose.yml` file. A part
    of this file is shown in the following code snippet:'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些变量可以在 `docker-compose.yml` 文件中进行配置。该文件的一部分在以下代码片段中显示：
- en: '[PRE21]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The easiest way to deploy Cryptonic is to use the `docker-compose.yml` file
    in the repository ([https://packt.live/2AM5mLP](https://packt.live/2AM5mLP)).
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署 Cryptonic 最简单的方法是使用仓库中的 `docker-compose.yml` 文件 ([https://packt.live/2AM5mLP](https://packt.live/2AM5mLP))。
- en: 'This file contains all the specifications necessary for the application to
    run, including instructions on how to connect with the Redis cache and what environment
    variables to use. After navigating to the location of the `docker-compose.yml`
    file, Cryptonic can then be started with the `docker-compose up` command, as shown
    in the following code:'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个文件包含了应用程序运行所需的所有规范，包括如何连接Redis缓存以及使用哪些环境变量的说明。导航到`docker-compose.yml`文件所在的位置后，可以通过`docker-compose
    up`命令启动Cryptonic，示例如下代码：
- en: '[PRE22]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `-d` flag executes the application in the background.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`-d`标志会将应用程序在后台执行。'
- en: 'After deployment, Cryptonic can be accessed on port `5000` via a web browser.
    The application has an HTTP API that makes predictions when invoked. The API has
    the endpoint `/predict`, which returns a JSON object containing the de-normalized
    Bitcoin price prediction for a week into the future. Here''s a snippet showing
    an example JSON output from the `/predict` endpoint:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署后，Cryptonic可以通过Web浏览器在端口`5000`访问。该应用程序具有一个HTTP API，在调用时会进行预测。API有一个端点`/predict`，该端点返回一个包含未来一周比特币价格预测的去归一化JSON对象。以下是显示`/predict`端点的示例JSON输出片段：
- en: '[PRE23]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2ZZlZMm](https://packt.live/2ZZlZMm).
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问此特定章节的源代码，请参考[https://packt.live/2ZZlZMm](https://packt.live/2ZZlZMm)。
- en: This section does not currently have an online interactive example, and will
    need to be run locally.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本节目前没有在线互动示例，需要在本地运行。
- en: The application can now be deployed on a remote server and you can then use
    it to continuously predict Bitcoin prices. You'll be deploying an application
    in the activity that follows.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以将应用程序部署到远程服务器上，然后你可以使用它持续预测比特币价格。在接下来的活动中，你将部署一个应用程序。
- en: 'Activity 4.01: Deploying a Deep Learning Application'
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动4.01：部署深度学习应用程序
- en: 'In this section, based on the concepts explained up to now, try deploying the
    model as a local web application. You will need to follow these steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，基于到目前为止解释的概念，尝试将模型作为本地Web应用程序进行部署。你需要按照以下步骤进行：
- en: Navigate to the `cryptonic` directory.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`cryptonic`目录。
- en: Build the Docker images for the required components.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为所需组件构建Docker镜像。
- en: Change the necessary parameters in `docker-compose.yml`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`docker-compose.yml`中的必要参数。
- en: Deploy the application using Docker on the localhost.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地使用Docker部署应用程序。
- en: 'The expected output would be as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 4.6: Expected output'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.6：预期输出'
- en: '](img/B15911_04_06.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15911_04_06.jpg)'
- en: 'Figure 4.6: Expected output'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：预期输出
- en: Note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 150\.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第150页找到。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This lesson concludes our journey into creating a deep learning model and deploying
    it as a web application. Our very last steps included deploying a model that predicts
    Bitcoin prices built using Keras and the TensorFlow engine. We finished our work
    by packaging the application as a Docker container and deploying it so that others
    can consume the predictions of our model, as well as other applications, via its
    API.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 本课程结束了我们创建深度学习模型并将其作为Web应用程序部署的旅程。我们的最后一步包括部署一个使用Keras和TensorFlow引擎构建的比特币价格预测模型。我们通过将应用程序打包为Docker容器并进行部署，使得其他人可以通过其API使用我们模型的预测结果，以及其他应用程序。
- en: 'Aside from that work, you have also learned that there is much that can be
    improved. Our Bitcoin model is only an example of what a model can do (particularly
    LSTMs). The challenge now is twofold: how can you make that model perform better
    as time passes? And what features can you add to your web application to make
    your model more accessible? With the concepts you''ve learned in this book, you
    will be able to develop models and keep enhancing them to make accurate predictions.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，你还学到了很多可以改进的地方。我们的比特币模型只是一个模型可以做的示例（特别是LSTM）。现在的挑战有两个：如何让模型随着时间推移表现得更好？你还可以为Web应用程序添加哪些功能，使得你的模型更易于访问？通过你在本书中学到的概念，你将能够开发模型并不断改进它们，以实现更精确的预测。
