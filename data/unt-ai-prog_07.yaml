- en: '*Chapter 5*: Flocking'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：鸟群'
- en: 'During early summer evenings, you have probably seen flocks of birds flying
    in the sky. You have probably noted how they seem to move as a single living object:
    they all move in a particular direction, turn around, and grow and shrink. A flocking
    system aims to replicate this behavior in games: we want to implement an algorithm
    to move many objects as an organic group.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在初夏的傍晚，你可能见过成群的鸟在天空中飞翔。你可能注意到它们似乎作为一个单一的生物体移动：它们都朝着一个特定的方向移动，转弯，并且大小变化。鸟群系统旨在在游戏中复制这种行为：我们希望实现一个算法，使许多物体作为一个有机群体移动。
- en: 'In games, we call each element of a flock a **boid**. To implement a flocking
    behavior, we do not need to equip each boid with a high-level complex decision-making
    system; instead, all we need to do is implement simple *reactive* rules for each
    boid that depend only on the state of the flock itself. Thus, flocking is an excellent
    example of emergent behavior: each boid reacts exclusively to its neighbor''s
    behaviors; nevertheless, the flock seems to move as if someone were coordinating
    it.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，我们称鸟群中的每个元素为**boid**。要实现鸟群行为，我们不需要为每个boid配备高级复杂的决策系统；相反，我们只需要为每个boid实现简单的**反应性**规则，这些规则只依赖于鸟群本身的状态。因此，鸟群是一个很好的涌现行为的例子：每个boid只对其邻居的行为做出反应；然而，鸟群似乎像有人协调一样移动。
- en: In this chapter, we will learn what these rules are and how to implement them
    in Unity3D. We will implement two variations of flocking in this chapter. The
    first one is based on an old flocking behavior demo that has been circulating
    in the Unity community since since the game engine was created.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习这些规则是什么，以及如何在Unity3D中实现它们。本章我们将实现两种鸟群变体。第一个是基于自游戏引擎创建以来在Unity社区中流传的一个旧的鸟群行为演示。
- en: The second variation is based on Craig Reynold's original flocking algorithm
    from 1986.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个变体是基于1986年克雷格·雷诺的原始鸟群算法。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: An overview of basic flocking behavior and how to implement it
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本鸟群行为的概述及其实现方法
- en: An alternative implementation of flocking behavior
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鸟群行为的另一种实现
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you just need Unity3D 2022\. You can find the example project
    described in this chapter in the `Chapter 5` folder in the book''s repository:
    [https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter05).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你只需要Unity3D 2022。你可以在本书仓库的`第五章`文件夹中找到本章描述的示例项目：[https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter05)。
- en: Basic flocking behavior
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本鸟群行为
- en: 'As we said in the introduction to this chapter, we can describe a flocking
    behavior by using just three intuitive properties:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章引言中所说的，我们可以仅使用三个直观的属性来描述鸟群行为：
- en: '**Separation**: This property, also called *short-range repulsion*, represents
    the minimum distance between neighboring boids to avoid collisions. You can imagine
    this rule as a force that pushes a boid away from the others.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分离**：这个属性，也称为**近距离排斥**，表示相邻boid之间的最小距离，以避免碰撞。你可以想象这个规则就像一股将boid推离其他物体的力量。'
- en: '**Alignment**: This property represents the likelihood for each boid to move
    in the same direction as the flock (we measure this as the average direction of
    all the individual boids).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对齐**：这个属性表示每个boid移动与鸟群相同方向的可能性（我们将其测量为所有单个boid的平均方向）。'
- en: '**Cohesion**: This property, also called *long-range attraction*, represents
    the likelihood for each boid to move toward the center of mass of the flock (we
    measure this by averaging the position of each boid in the flock). Thus, you can
    imagine this rule as a force that pushes a boid toward the center of the flock.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**凝聚力**：这个属性，也称为**远距离吸引**，表示每个boid移动向鸟群质心的可能性（我们通过平均鸟群中每个boid的位置来测量）。因此，你可以想象这个规则就像一股将boid推向鸟群中心的力。'
- en: In this demo, we will create a scene with flocks of objects and implement the
    flocking behavior in C#. For this first version, we compute all the rules by ourselves.
    Also, we will create a boid commander that leads the crowd to control and track
    the general position of the flock easily.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中，我们将创建一个由物体群组成的场景，并在 C# 中实现群聚行为。对于这个第一个版本，我们将自行计算所有规则。此外，我们还将创建一个鸟群指挥官，以便轻松地控制和跟踪鸟群的总体位置。
- en: 'You can see the **Hierarchy** scene in the following screenshot. As you can
    see, we have several boid entities named **UnityFlock**, under a controller named
    **UnityFlockController**. **UnityFlock** entities are individual boid objects
    that refer to their parent **UnityFlockController** entity, using it as a leader.
    The controller updates the next destination point randomly once it reaches the
    current destination point:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在下面的屏幕截图中看到 **Hierarchy** 场景。如您所见，我们有几个名为 **UnityFlock** 的鸟群实体，位于名为 **UnityFlockController**
    的控制器下。**UnityFlock** 实体是单个鸟群对象，它引用其父 **UnityFlockController** 实体，将其用作领导者。控制器在达到当前目的地点后随机更新下一个目的地点：
- en: '![Figure 5.1 – The scene hierarchy'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – 场景层次结构'
- en: '](img/B17984_05_1.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17984_05_1.jpg]'
- en: Figure 5.1 – The scene hierarchy
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 场景层次结构
- en: '`UnityFlock` script. We can use any other mesh representation for this prefab
    to represent something more interesting, such as birds. You can add as many **UnityFlock**
    prefabs as you like. The algorithm will automatically check the number of children
    in the **UnityFlockController** object.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnityFlock` 脚本。我们可以为这个预制件使用任何其他网格表示来表示更有趣的东西，比如鸟。您可以添加任意数量的 **UnityFlock**
    预制件。算法将自动检查 **UnityFlockController** 对象中的子项数量。'
- en: Individual behavior
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个体行为
- en: '*Boid* is a term coined by Craig Reynold that refers to bird-like objects.
    We use this term to describe each object in our flock. The boid behaviour consists
    of a group of objects, each having their individual position, velocity, and orientation.
    Now, let''s implement the boid behavior. You can find the behavior that controls
    each boid in the flock in the `UnityFlock.cs` script, which we''ll examine now:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*鸟群* 是克雷格·雷诺德创造的术语，指的是类似鸟类的物体。我们使用这个术语来描述我们鸟群中的每个物体。鸟群行为由一组物体组成，每个物体都有其自身的位置、速度和方向。现在，让我们实现鸟群行为。您可以在
    `UnityFlock.cs` 脚本中找到控制鸟群中每个鸟群行为的代码，我们现在将检查它：'
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As public fields, we declare the input values for our algorithm. These can
    be set up and customized from within the Inspector. In this script, we perform
    the following operations:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 作为公共字段，我们声明了算法的输入值。这些可以在检查器中设置和自定义。在这个脚本中，我们执行以下操作：
- en: We define the minimum movement speed (`minSpeed`) and rotation speed (`turnSpeed`)
    for our boid.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为我们的鸟群定义了最小移动速度（`minSpeed`）和旋转速度（`turnSpeed`）。
- en: We use `randomFreq` to determine how many times we want to update the `randomPush`
    value, based on the `randomForce` value. Then, we use this force to vary the single
    boid's velocity and make the flock's movement look more realistic.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `randomFreq` 来确定我们希望根据 `randomForce` 值更新 `randomPush` 值的次数。然后，我们使用这种力量来改变单个鸟群的速度，使鸟群的移动看起来更真实。
- en: '`toOriginRange` specifies how much we want the flock to spread out. In other
    words, it represents the maximum distance from the flock''s origin in which we
    want to maintain the boids (following the previously mentioned cohesion rule).
    We use the `avoidanceRadius` and `avoidanceForce` properties to maintain a minimum
    distance between individual boids (following the separation rule). Similarly,
    we use `followRadius` and `followVelocity` to keep a minimum distance between
    the leader or origin of the flock. The `origin` variable stores the parent object
    that controls the entire flock; in other words, it is the flock leader. The boids
    need to know about the other boids in the flock. Therefore, we use the `objects`
    and `otherFlocks` attributes to store the neighboring boid''s information.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`toOriginRange` 指定了我们希望鸟群扩散的程度。换句话说，它代表了我们要保持鸟群（遵循之前提到的凝聚力规则）的最大距离。我们使用 `avoidanceRadius`
    和 `avoidanceForce` 属性来保持个体鸟群之间的最小距离（遵循分离规则）。同样，我们使用 `followRadius` 和 `followVelocity`
    来保持领导者或鸟群起源之间的最小距离。`origin` 变量存储控制整个鸟群的父对象；换句话说，它是鸟群领导者。鸟群需要了解群中的其他鸟群。因此，我们使用
    `objects` 和 `otherFlocks` 属性来存储邻近鸟群的信息。'
- en: 'This is the initialization method for our boid:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的鸟群的初始化方法：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We set the parent of the object of our boid as origin, meaning that this is
    the controller object for the other boids to follow. Then, we grab all the other
    boids in the group and store them in the `otherFlocks` attribute for later reference.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将boid的对象的父级设置为`origin`，这意味着这是其他boid跟随的控制器对象。然后，我们抓取组中的所有其他boid并将它们存储在`otherFlocks`属性中以供以后参考。
- en: Coroutines
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 协程
- en: 'Put simply, coroutines are *functions that can be paused*. With coroutines,
    you can run a method, pause the execution for a desired amount of time (for example,
    a single frame or several seconds), and then continue from the following line
    as if nothing happened. They have two primary use cases: to run a function after
    a specific interval (without keeping track of every frame of `elapsedTimes`, as
    we did in other examples) or to split the computation of some heavy algorithm
    over multiple frames (and, therefore, not incur in frame drops). Coroutines, it
    turns out, are a pretty helpful tool to master. You can read more at [https://docs.unity3d.com/Manual/Coroutines.html](https://docs.unity3d.com/Manual/Coroutines.html).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，协程是可以暂停的函数。使用协程，你可以运行一个方法，暂停执行一段时间（例如，一帧或几秒钟），然后从下一行继续，就像什么都没发生一样。它们有两个主要用途：在特定间隔后运行一个函数（无需像其他示例中那样跟踪每一帧的`elapsedTimes`）或分割一些重算法的计算到多个帧上（因此不会引起帧率下降）。事实证明，协程是一个非常有用的工具。你可以在[https://docs.unity3d.com/Manual/Coroutines.html](https://docs.unity3d.com/Manual/Coroutines.html)上了解更多信息。
- en: 'Now, we can implement the `UpdateRandom` coroutine. As a coroutine, the function
    never actually terminates, but we run the body of the `while` loop for each random
    time interval:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现`UpdateRandom`协程。作为一个协程，函数实际上永远不会终止，但我们为每个随机时间间隔运行`while`循环的主体：
- en: 'We define the `UpdateRandom` method as a coroutine by specifying the `IEnumerator`
    return type:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过指定`IEnumerator`返回类型将`UpdateRandom`方法定义为协程：
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `UpdateRandom()` method updates the `randomPush` value throughout the game
    with an interval based on `randomFreq`. `Random.insideUnitSphere` returns a `Vector3`
    object with random *x*, *y*, and *z* values within a sphere, with a radius of
    the `randomForce` value.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UpdateRandom()`方法通过基于`randomFreq`的间隔在整个游戏过程中更新`randomPush`值。`Random.insideUnitSphere`返回一个具有随机*x*、*y*和*z*值的`Vector3`对象，这些值在以`randomForce`值为半径的球体内。'
- en: We wait for a certain random amount of time before resuming `while(true)`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在恢复`while(true)`之前，我们等待一定随机的时长。
- en: Loop to update the `randomPush` value again.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环再次更新`randomPush`值。
- en: 'Now, here is our boid behavior''s `Update()` method, which helps the boid entity
    comply with the three rules of the flocking algorithm:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，这是我们的boid行为`Update()`方法，它帮助boid实体遵守群聚算法的三个规则：
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code implements the separation rule. First, we check the distance
    between the current boid and the other boids, and then we update the velocity
    accordingly, as explained in the comments in the preceding code block.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码实现了分离规则。首先，我们检查当前boid与其他boid之间的距离，然后根据注释中解释的方式相应地更新速度。
- en: 'We now calculate the average velocity vector of the flock by dividing the current
    velocity vector by the number of boids in the flock:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在通过将当前速度向量除以群中的boid数量来计算群的平均速度向量：
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We add up all the factors, such as `randomPush`, `originPush`, and `avgVelocity`,
    to calculate the final target velocity vector, `wantedVel`. We also update the
    current velocity to `wantedVel` with a linear interpolation by using the `Vector3.RotateTowards`
    method.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将所有因素，如`randomPush`、`originPush`和`avgVelocity`相加，以计算最终的目标速度向量`wantedVel`。我们还使用`Vector3.RotateTowards`方法通过线性插值将当前速度更新为`wantedVel`。
- en: We move our boid based on the new velocity using the `Translate` method.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`Translate`方法根据新的速度移动我们的boid。
- en: 'As a final touch, we create a cube mesh, to which we add the `UnityFlock` script,
    and then save it as a prefab, as shown in the following screenshot:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后的润色，我们创建了一个立方网格，向其中添加了`UnityFlock`脚本，然后将其保存为预制件，如下面的截图所示：
- en: '![Figure 5.2 – The UnityFlock prefab'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2 – UnityFlock预制件'
- en: '](img/B17984_05_2.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17984_05_2.jpg](img/B17984_05_2.jpg)'
- en: Figure 5.2 – The UnityFlock prefab
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – UnityFlock预制件
- en: Controller
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器
- en: Now, it is time to create the controller class. This class updates its position
    so that the other individual boid objects know where to go. The `origin` variable
    in the preceding `UnityFlock` script contains a reference to this object.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候创建控制器类了。这个类更新其位置，以便其他个体boid对象知道去哪里。前面`UnityFlock`脚本中的`origin`变量包含对这个对象的引用。
- en: 'The following is the code in the `UnityFlockController.cs` file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`UnityFlockController.cs`文件中的代码：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `Update()` method, we check whether our controller object is near the
    target destination point. If it is, we update the `nextMovementPoint` variable
    again with the `CalculateNextMovementPoint()` method that we just discussed:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Update()`方法中，我们检查我们的控制器对象是否接近目标目的地点。如果是，我们再次使用我们刚才讨论的`CalculateNextMovementPoint()`方法更新`nextMovementPoint`变量：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `CalculateNextMovementPoint()` method finds the next random destination
    position in a range between the current position and the boundary vectors.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`CalculateNextMovementPoint()`方法在当前位置和边界向量之间找到一个随机目的地位置。'
- en: 'Finally, we put all of this together, as shown in *Figure 5.1*, which should
    give you flocks of squares flying around realistically in the sunset:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将所有这些放在一起，如图*图5.1*所示，这应该会给出在日落时分真实飞行的方阵群：
- en: '![Figure 5.3 – A demonstration of the ﬂocking behavior using the Unity seagull
    sample'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 – 使用Unity海鸥示例演示群聚行为'
- en: '](img/B17984_05_3.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_05_3.jpg)'
- en: Figure 5.3 – A demonstration of the ﬂocking behavior using the Unity seagull
    sample
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 使用Unity海鸥示例演示群聚行为
- en: The previous example gave you the basics of flocking behaviors. In the next
    section, we will explore a different implementation that makes use of Unity's
    `Rigidbody` component.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子向您介绍了群聚行为的基础知识。在下一节中，我们将探讨一种不同的实现方法，该方法利用了Unity的`Rigidbody`组件。
- en: Alternative implementation
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替代实现
- en: In this section, we use the Unity physics engine to simplify the code a bit.
    In fact, in this example, we attach a `Rigidbody` component to the boids to use
    the `Rigidbody` properties to translate and steer them. In addition, the `Rigidbody`
    component is also helpful in preventing the other boids from overlapping with
    each other.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用Unity物理引擎来简化代码。实际上，在这个例子中，我们将`Rigidbody`组件附加到鸟群上，以使用`Rigidbody`属性来转换和引导它们。此外，`Rigidbody`组件还有助于防止其他鸟群相互重叠。
- en: 'In this implementation, we have two components: the individual boid behavior
    and the controller behavior (the element referred to as the *flock controller*
    in the previous section). As before, the controller is the object that the rest
    of the boids follow.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，我们有两个组件：个体鸟群行为和控制器行为（在上一节中提到的称为*群控制器*的元素）。和之前一样，控制器是其他鸟群跟随的对象。
- en: 'The code in the `Flock.cs` file is as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flock.cs`文件中的代码如下：'
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will create `FlockController` in a moment. In the meantime, in the `Update()`
    method in the previous code block, we calculate the boid's velocity using the
    `Steer()` method and apply the result to the boid's rigid-body velocity.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后创建`FlockController`。在此期间，在前一个代码块中的`Update()`方法中，我们使用`Steer()`方法计算鸟群的速度，并将结果应用于鸟群的刚体速度。
- en: 'Next, we check whether the current speed of the `Rigidbody` component falls
    inside our controller''s maximum and minimum velocity ranges. If not, we cap the
    velocity at the preset range:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查当前`Rigidbody`组件的速度是否在我们的控制器最大和最小速度范围内。如果不是，我们将速度限制在预设的范围内：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `steer()` method implements the *separation*, *cohesion*, *alignment*,
    and *follows the leader* rules of the flocking algorithm. Then, we add up all
    the factors with a random weight value. We use this *Flock* script together with
    the `Rigidbody` and `SphereCollider` components to create a Flock prefab, as shown
    in the following screenshot (make sure to disable the gravity by unchecking **Use
    Gravity**):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`steer()`方法实现了群聚算法的*分离*、*凝聚力*、*对齐*和*跟随领导者*规则。然后，我们将所有因素与一个随机权重值相加。我们使用这个*Flock*脚本与`Rigidbody`和`SphereCollider`组件一起创建一个Flock预制件，如图所示（确保通过取消选中**使用重力**来禁用重力）：'
- en: '![Figure 5.4 – Flock'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.4 – 群'
- en: '](img/B17984_05_4.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_05_4.jpg)'
- en: Figure 5.4 – Flock
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 群
- en: 'It is now time to implement the final piece of the puzzle: the `FlockController`
    component.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现拼图的最后一块：`FlockController`组件。
- en: FlockController
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FlockController
- en: 'This `FlockController` component is similar to the one in the previous example.
    In addition to controlling the flock''s speed and position, this script also instantiates
    the boids at runtime:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`FlockController`组件与上一个例子中的类似。除了控制鸟群的速度和位置外，这个脚本还在运行时实例化鸟群：
- en: 'The code in the `FlockController.cs` file is as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FlockController.cs`文件中的代码如下：'
- en: '[PRE9]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We declare all the public properties to implement the flocking algorithm and
    then start generating the boid objects based on the flock size input.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明所有公共属性以实现群聚算法，然后根据群聚大小输入开始生成鸟群对象。
- en: We set up the controller class and the parent `Transform` object, as we did
    last time.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置了控制器类和父`Transform`对象，就像上次做的那样。
- en: 'We add every boid object we create to the `flockList` array. The target variable
    accepts an entity to be used as a moving leader. In this example, we create a
    sphere entity as a moving target leader for our flock:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建的每个鸟群对象添加到`flockList`数组中。目标变量接受一个用作移动领导者的实体。在这个例子中，我们创建一个球体实体作为鸟群的移动目标领导者：
- en: '[PRE10]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `Update` method, we keep updating the average center and velocity of
    the flock. These are the values referenced from the boid object and are used to
    adjust the cohesion and alignment properties with the controller:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Update`方法中，我们持续更新群聚的平均中心和速度。这些是从鸟群对象引用的值，用于调整与控制器的凝聚力和对齐属性：
- en: '![Figure 5.5 – Flock Controller'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.5 – 群聚控制器'
- en: '](img/B17984_05_5.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_05_5.jpg)'
- en: Figure 5.5 – Flock Controller
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 群聚控制器
- en: 'We need to implement our **Target** entity with the **Target Movement (Script)**.
    The movement script is the same as what we saw in our previous Unity3D sample
    controller''s movement script:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用**目标移动（脚本）**来实现我们的**目标**实体。移动脚本与我们之前在Unity3D示例控制器中的移动脚本相同：
- en: '![Figure 5.6 – The Target entity with the TargetMovement script'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.6 – 带有TargetMovement脚本的Target实体'
- en: '](img/B17984_05_6.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_05_6.jpg)'
- en: Figure 5.6 – The Target entity with the TargetMovement script
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 – 带有TargetMovement脚本的Target实体
- en: 'Here is how our `TargetMovement` script works: we pick a random point nearby
    for the target to move to, and when we get close to that point, we pick a new
    one. The code in the `TargetMovement.cs` file is as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`TargetMovement`脚本的工作原理如下：我们随机选择一个附近的点作为目标移动到，当我们接近那个点时，我们再选择一个新的点。`TargetMovement.cs`文件中的代码如下：
- en: '[PRE11]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After we put everything together, we should see a nice flock of cubic boids
    flying around in the scene, all chasing the spheric target:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们将一切组合起来之后，我们应该在场景中看到一群立方体鸟群在飞行，它们都在追逐球形目标：
- en: '![Figure 5.7 – Flocking with Craig Reynold''s algorithm'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.7 – 使用雷诺德算法的群聚'
- en: '](img/B17984_05_7.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_05_7.jpg)'
- en: Figure 5.7 – Flocking with Craig Reynold's algorithm
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – 使用雷诺德算法的群聚
- en: 'Now that we have implemented flocking behavior in two different ways, we can
    experiment with different parameters and tweak the boids'' behavior until we find
    a movement we like. I want to conclude this chapter with an important takeaway:
    note that we do not need complex algorithms to have a natural-looking behavior.
    For that, we just need simple reactive rules and a way to combine them.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经以两种不同的方式实现了群聚行为，我们可以尝试不同的参数，调整鸟群的行为，直到找到我们喜欢的移动方式。我想以一个重要的启示来结束本章：请注意，我们不需要复杂的算法来获得自然的外观行为。为此，我们只需要简单的反应性规则和一种将它们组合起来的方法。
- en: Summary
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to implement flocking behaviors in two ways.
    First, we examined and learned how to implement a basic flocking algorithm using
    nothing other than our scripts. Next, we implemented the same algorithm using
    Unity's `Rigidbody` component to control the boid's movement and Sphere Collider
    to avoid collision with other boids.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了两种实现群聚行为的方法。首先，我们检查并学习了如何仅使用我们的脚本实现基本的群聚算法。接下来，我们使用Unity的`Rigidbody`组件来控制鸟群的移动，以及球体碰撞器来避免与其他鸟群相撞。
- en: 'In our example, we always referred to boids as bird-like entities. However,
    we can use flocking for many other applications: fishes swimming in the sea, sheep
    grazing on a plane, a swarm of insects, and even groups of people walking on the
    street can show flocking behavior. To adapt the algorithm to different scenarios,
    we just need to change the flocking rules'' values and eventually lock the movement
    to a plane.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们总是将鸟群称为类似鸟类的实体。然而，我们可以将群聚应用于许多其他应用：海中的鱼群，草原上吃草的羊群，一群昆虫，甚至街道上行走的人群都可以表现出群聚行为。为了将算法适应不同的场景，我们只需更改群聚规则的值，最终将移动锁定到平面上。
- en: In the next chapter, we will go beyond random movement and look at how to follow
    a specific path. This is the first step toward learning how to avoid obstacles
    that are in your way.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将超越随机移动，看看如何跟随特定的路径。这是学习如何避开挡路的障碍物的第一步。
