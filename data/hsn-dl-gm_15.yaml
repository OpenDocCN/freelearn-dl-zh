- en: Debugging/Testing a Game with DRL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用DRL调试/测试游戏
- en: While the ML-Agents framework provides powerful capabilities for building AI
    agents for your games, it also provides automation for debugging and testing.
    The development of any complex software needs to be tied to extensive product
    testing and review by talented quality assurance teams. Testing every aspect,
    every possible combination, and every level can be extremely time-consuming and
    expensive. Therefore, in this chapter, we will look at using ML-Agents as an automated
    way to test a simple game. As we change or modify the game, our automated testing
    system can inform us of any issues or possible changes that may have broken the
    test. We can also take this further with ML-Agents, for instance, to evaluate
    training performance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然ML-Agents框架为构建游戏中的AI代理提供了强大的功能，但它也为调试和测试提供了自动化工具。任何复杂软件的开发都需要与广泛的产品测试和优秀的质量保证团队的审查相结合。测试每个方面、每种可能的组合和每个级别可能非常耗时且昂贵。因此，在本章中，我们将探讨使用ML-Agents作为自动化方式来测试一个简单的游戏。当我们修改或更改游戏时，我们的自动化测试系统可以通知我们是否存在问题或可能已经破坏了测试的变更。我们还可以进一步利用ML-Agents，例如，评估训练性能。
- en: 'The following is a brief summary of what we will cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章将涵盖内容的简要总结：
- en: Introducing the game
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍游戏
- en: Setting up ML-Agents
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置ML-Agents
- en: Overriding the Unity input system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写Unity输入系统
- en: Testing through imitation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过模仿进行测试
- en: Analyzing the testing process
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析测试过程
- en: In this chapter, we will assume that you have sound knowledge of the ML-Agents
    toolkit and are somewhat familiar with the Unity game engine. You should also
    have a good grasp of reward functions and the use of imitation learning with ML-Agents.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设你对ML-Agents工具包有一定的了解，并且对Unity游戏引擎有一定的熟悉程度。你还应该对奖励函数以及如何使用ML-Agents进行模仿学习有较好的掌握。
- en: In the next section, we will start by downloading and importing the game; we
    will teach ML-Agents to play in the following section. This should be considered
    an advanced chapter, even for experienced users of Unity. Therefore, if you are
    relatively new to Unity and/or C#, just take your time and slowly work through
    the exercises. By the end of this chapter, if you have completed all the exercises,
    you should be on your way to being a Unity pro.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将从下载并导入游戏开始；我们将在接下来的部分中教你如何让ML-Agents玩游戏。即使是对于有经验的Unity用户来说，这一章也应视为进阶内容。因此，如果你对Unity和/或C#相对较新，只需慢慢来，逐步完成练习。本章结束时，如果你完成了所有练习，你应该已经朝着成为Unity高手的方向迈进。
- en: Introducing the game
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍游戏
- en: The game that we are going to look at is a demo sample asset that is free and
    is an excellent example of a typical game. The game that we'll test will use discrete
    control mechanics and a first-person perspective, like the games that we have
    looked at in the past. The technique that we will show you here is how to map/hack
    into a game's controller so that it can be powered by ML-Agents. Using this technique
    should allow you to attach ML-Agents to any existing game, although different
    controllers, such as third-person or top-down, may require a slightly altered
    approach.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的游戏是一个免费的示范样本资产，它是典型游戏的优秀示例。我们测试的游戏将采用离散控制机制和第一人称视角，类似于我们过去看过的游戏。我们将在这里展示的技术是如何将游戏的控制器映射/破解到ML-Agents中，以便它可以由ML-Agents驱动。使用这种技术应该能让你将ML-Agents附加到任何现有的游戏中，尽管不同的控制器，比如第三人称或俯视视角，可能需要稍微调整方法。
- en: If you consider yourself an experienced Unity user and have your own project
    that uses an FPS system, then you should go ahead and try to adapt this sample
    to your own game or example.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为自己是有经验的Unity用户，并且有自己的项目使用FPS系统，那么你可以尝试将这个示例适应到自己的游戏或示例中。
- en: You will generally find a lack of good sample game projects for Unity, due to
    a somewhat questionable technique called **asset flipping**. Essentially, some
    developers will take a sample project and quickly skin it as their own game, and
    then resell it. This practice has primarily been frowned upon in the Unity community,
    since it generally casts this excellent game engine in a negative light. The quick
    games, meant only as samples, are often of very poor quality and are unsupported,
    not to mention that these developers only use the free license, which means that
    these poorly designed games are also shipped with *Made with Unity*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于某些被称为**资源翻转**的可疑技术，你通常很难找到好的Unity示范游戏项目。实际上，一些开发者会拿到一个示范项目，并快速为其换皮，作为他们自己的游戏进行转售。由于这一行为通常会给Unity这个优秀的游戏引擎带来负面影响，Unity社区普遍对这种做法表示反对。这些快速制作的游戏通常质量很差，且没有任何支持，更不用说这些开发者通常仅使用免费许可证，这意味着这些设计不佳的游戏会标注上*Made
    with Unity*字样。
- en: 'We want to illustrate how ML-Agents can be incorporated into a working game
    for testing, debugging, and/or as an AI enhancement. Let''s start by importing
    the base project and setting up the game to run in the editor. Along the way,
    we may have to tweak a few things in order to get things working, but that is
    our intent. Open up the Unity editor and follow the exercises in the next section
    to set up the base game project:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望展示如何将ML-Agents集成到一个正在运行的游戏中，用于测试、调试和/或作为AI增强功能。让我们从导入基础项目并设置游戏在编辑器中运行开始。在此过程中，我们可能需要对一些内容进行调整，以确保一切正常运行，但这是我们的目标。打开Unity编辑器并按照下一部分中的练习设置基础游戏项目：
- en: Create a new project called `HoDLG` (or another name of your preference). Wait
    for the empty project to load. Again, if you feel qualified, use your own project.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`HoDLG`的新项目（或使用你自己喜欢的名字）。等待空项目加载完成。如果你觉得自己有足够资格，可以使用你自己的项目。
- en: From the menu, select **Window** | **Asset Store**.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择**Window** | **Asset Store**。
- en: In the search pane, type `ms vehicle system` and hit *Enter* or click on the
    **Search** button. We are going to look at a free asset called MS Vehicle System,
    which has a fun little environment that we can play with. It is often difficult
    to find free environments such as this (for the reasons mentioned earlier), but,
    generally, well-made commercial (not free) asset packages will provide good demo
    environments such as this one. Unity has a number of tutorial environments as
    well, but they tend to become dated quickly, and they may not always upgrade that
    easily.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索面板中，输入`ms vehicle system`并按*Enter*或点击**Search**按钮。我们将查看一个免费的资源包，名为MS Vehicle
    System，它有一个有趣的小环境可以玩耍。通常，像这样的免费环境比较难找到（如前所述），但一般来说，制作精良的商业（非免费）资源包会提供良好的演示环境，比如这个。Unity也有一些教程环境，但它们通常会迅速过时，而且更新也不一定容易。
- en: 'Click on the **MS Vehicle System** card and wait for the asset page to load,
    as shown in the following screenshot:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**MS Vehicle System**卡片，等待资源页面加载，如下图所示：
- en: '![](img/aa902239-3d00-4e57-939c-641ab0ebc9d0.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa902239-3d00-4e57-939c-641ab0ebc9d0.png)'
- en: Selecting the asset package to download
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 选择要下载的资源包
- en: Click on the **Download** button to download the asset, and then click on **Import** to
    import the asset into the project. Follow the import dialogues to import all of
    the assets into the project.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下载**按钮下载资源，然后点击**导入**将资源导入项目中。按照导入对话框的提示将所有资源导入项目中。
- en: Locate the **MainScene** scene in the **Assets** | **MSVehicleSystem (FreeVersion)**
    folder, and open it.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Assets** | **MSVehicleSystem (FreeVersion)** 文件夹中找到**MainScene**场景并打开它。
- en: Press **Play** to run the scene in the editor, and use the controls to drive
    the vehicles around. Notice how you can switch vehicles and camera controls. When
    you are done testing (playing), stop the scene by pressing Play.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下**Play**按钮在编辑器中运行场景，使用控制来驾驶车辆。注意如何切换车辆和相机控制。当测试（游戏）完成后，通过按下Play停止场景。
- en: 'Type `canvas` in the **Hierarchy** filter field and just select all of the
    **Canvas** objects in the scene, as shown in the following screenshot:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**筛选框中输入`canvas`，然后选择场景中的所有**Canvas**对象，如下图所示：
- en: '![](img/6e52faec-5f44-4a39-bb26-713ad7259648.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e52faec-5f44-4a39-bb26-713ad7259648.png)'
- en: Disabling the Canvas UI in the scene
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用场景中的Canvas UI
- en: That will disable the UI in the scene; we won't need it for testing, and in
    this case, it isn't important. If this were a real game, there might have been
    more colorful visuals to denote scores, and you could always add those, of course.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将禁用场景中的 UI，我们在测试时不需要它，而且在这种情况下它并不重要。如果这是一个真正的游戏，可能会有更多颜色鲜艳的视觉效果来表示分数，当然，你也可以随时添加这些。
- en: Click on the **X** beside the filter input to clear it and return the scene
    to normal.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击过滤器输入框旁的**X**，清除它并将场景恢复正常。
- en: 'Play the scene again, and explore several areas. Look for an area that you
    think may make a suitable goal; remember, don''t make it too difficult initially.
    The following is an example of a spot that might make an interesting goal; see
    whether you can find the location:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次播放场景并探索多个区域。寻找一个你认为可能适合作为目标的地方；记住，最初不要设置太难的目标。以下是一个可能成为有趣目标的位置示例；看看你能否找到这个位置：
- en: '![](img/f8abf3a5-19a8-47f9-8264-d3f789676eb1.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8abf3a5-19a8-47f9-8264-d3f789676eb1.png)'
- en: Finding a good place for our goal
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找适合放置目标的位置
- en: Even if you can't find the specific spot, locate an area that is difficult to
    get to. That way, the agent will have to explore the level extensively in order
    to find the goal (or goals). In our case, we will drop random goal squares on
    to the level and encourage the agent to look for those. That way, we can also
    map out areas that get explored by how often it happens, and then determine how
    to cover other areas for testing. Before we get to that, we will add ML-Agents,
    in the next section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你找不到具体的地方，也要找到一个不容易到达的区域。这样，代理必须广泛地探索该关卡才能找到目标（或目标点）。在我们的例子中，我们将随机放置目标方块在关卡中，并鼓励代理去寻找这些目标。这样，我们也可以通过探索的频率来绘制出探索的区域，然后决定如何覆盖其他区域进行测试。在进入下一部分之前，我们将添加
    ML-Agents。
- en: Setting up ML-Agents
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 ML-Agents
- en: At the time of writing this book, ML-Agents is developed and shipped as a GitHub
    project. It is likely that as the product matures, it will be shipped as its own
    asset package, but currently, it is not.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在写这本书时，ML-Agents 是作为一个 GitHub 项目进行开发和发布的。随着产品的成熟，可能会将其作为独立的资源包发布，但目前并不是这样。
- en: 'Therefore, we first need to export ML-Agents as an asset package. Open up a
    new Unity Editor session to an ML-Agents or Unity SDK project, and follow these
    steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先需要将 ML-Agents 导出为资源包。打开一个新的 Unity 编辑器会话，进入 ML-Agents 或 Unity SDK 项目，并按照以下步骤操作：
- en: Locate the **ML-Agents** folder in the **Project** window, and select it.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到**项目**窗口中的**ML-Agents**文件夹，并选择它。
- en: From the menu, select **Assets** | **Export Package**.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择**资源** | **导出包**。
- en: 'Be sure that all of the folder contents are highlighted, as shown in the following **Exporting
    package** dialog excerpt:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保所有文件夹内容都已高亮显示，如下所示的**导出包**对话框摘录：
- en: '![](img/b0e71209-a84b-4603-a5b9-cd22fc46c741.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0e71209-a84b-4603-a5b9-cd22fc46c741.png)'
- en: Exporting ML-Agents as an asset package
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将 ML-Agents 导出为资源包
- en: Be sure to uncheck the **Include dependencies** checkbox, as shown in the preceding
    excerpt. As long as you have the proper root folder selected, all of the dependencies
    that we need should get packaged.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保取消选中**包括依赖项**复选框，如上文摘录所示。只要选择了正确的根文件夹，所有我们需要的依赖项应该都会被打包。
- en: Click on the **Export...** button in the dialog, and then choose and save the
    asset file to a location that you will easily be able to find later.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对话框中点击**导出...**按钮，然后选择并保存资产文件到一个你稍后容易找到的位置。
- en: Open the Unity Editor to the project that we started in the last exercise.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Unity 编辑器，进入我们在上一个练习中开始的项目。
- en: From the menu, select **Assets** | **Import Package** | **Custom Package**.
    Locate the package that we just exported and import it into the new test project.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择**资源** | **导入包** | **自定义包**。定位我们刚刚导出的包，并将其导入到新的测试项目中。
- en: 'Locate the project window and create a new folder called `HoDLG` in the **Asset**s
    root, and, then, inside that new folder, create new folders called `Brains`, `Prefabs`**,**
    and `Scripts`, as shown in the following screenshot:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到项目窗口，在**资源**根目录下创建一个名为`HoDLG`的新文件夹，然后在该新文件夹内创建名为`Brains`、`Prefabs`**、**和`Scripts`的新文件夹，如下图所示：
- en: '![](img/7a2bb1e2-4fdc-41c6-9c95-d2172533ab80.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a2bb1e2-4fdc-41c6-9c95-d2172533ab80.png)'
- en: Creating new project folders
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的项目文件夹
- en: Creating these folders is the standard way of laying the foundation for a new
    asset, example, or project. You can now close the old ML-Agents Unity SDK project,
    as we no longer need it.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建这些文件夹是为新的资源、示例或项目打基础的标准方式。现在你可以关闭旧的 ML-Agents Unity SDK 项目，因为我们不再需要它。
- en: Now that we have ML-Agents imported and the foundations laid for our test game,
    we can move on to adding the learning parts of ML-Agents for testing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了ML-Agents并为测试游戏奠定了基础，接下来我们可以开始添加ML-Agents的学习部分进行测试。
- en: Introducing rewards to the game
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向游戏中引入奖励
- en: The scene currently has no well-defined goal. There are plenty of open worlds
    and exploration-style games where the goal is very loosely defined. For our purposes,
    however, we only really want the agent to test-play the whole game level, and
    hopefully identify any game flaws or perhaps strategies that we never foresaw.
    Of course, that doesn't mean that if the car-driving agents became good, we could
    also use them as game opponents. The bottom line is that our agent needs to learn,
    and it does that through rewards; therefore, we need to make some reward functions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 目前场景没有明确的目标。许多开放世界和探索类型的游戏目标定义较为松散。然而，对于我们的目的，我们只希望代理能够测试整个游戏关卡，并尽可能识别出任何游戏缺陷，或许还能发现一些我们从未预见的策略。当然，这并不意味着如果汽车驾驶代理变得足够强大，我们也能把它们作为游戏对手使用。底线是，我们的代理需要学习，而它通过奖励来实现这一点；因此，我们需要制定一些奖励函数。
- en: 'Let''s first define a reward function for our goal, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先为目标定义一个奖励函数，如下所示：
- en: '![](img/c2eb3510-7177-41b7-aa6d-4c6b6b0a0871.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c2eb3510-7177-41b7-aa6d-4c6b6b0a0871.png)'
- en: 'It''s pretty simple; whenever the agent encounters a goal, they will score
    a reward of 1 . Now, to avoid the agent taking too long, we will also introduce
    a standard step reward, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程非常简单；每当代理遇到目标时，它们将获得一个奖励值1。为了避免代理花费过长时间，我们还会引入一个标准的步骤奖励，具体如下：
- en: '![](img/e34c7aa3-2241-40ba-bb05-ec2f0e823134.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e34c7aa3-2241-40ba-bb05-ec2f0e823134.png)'
- en: This means that we apply a step reward of -1 divided by the maximum number of
    steps, per agent action. This is quite standard (our Hallway agent used it, for
    instance), so there is nothing new here. So, our reward functions will be quite
    simple, which is good.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们为每个代理的行动应用一个奖励，奖励值为-1除以最大步骤数。这是相当标准的做法（例如我们的Hallway代理就使用了它），所以这里没有什么新东西。因此，我们的奖励函数将非常简单，这很好。
- en: In many cases, your game may have well-defined goals that you can use to give
    rewards with. A driving game, for example, would have a clear goal that we could
    map for our agent. In this case, in our open-world game, it makes sense to add
    goals for the agent to locate. How you implement your reward structure does matter,
    of course, but use what makes sense for your situation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，您的游戏可能有明确的目标，您可以基于这些目标给予奖励。例如，一款驾驶游戏会有一个明确的目标，我们可以为代理设定目标。在这种情况下，在我们的开放世界游戏中，为代理设定目标是有意义的。当然，如何实现奖励结构非常重要，但请根据您的实际情况选择合适的方式。
- en: With the reward functions defined, it is time to introduce the concept of a
    goal into our game. We want to keep this system somewhat generic, so we will build
    a goal deployment system into a new object called `TestingAcademy`. That way,
    you can take this academy and drop it into any similar FPS or third-person controlled
    worlds, and it will work the same.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了奖励函数后，接下来是将目标的概念引入游戏中。我们希望保持这个系统的通用性，因此我们将在一个名为`TestingAcademy`的新对象中构建一个目标部署系统。这样，您可以将这个学院对象拖放到任何类似的FPS或第三人称控制的世界中，它就能正常工作。
- en: '**First-person shooter** (**FPS**) refers to a type of game, but also a type
    of control/camera system. We are interested in the latter, since it is the method
    by which we control our car.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一人称射击游戏**（**FPS**）指的是一种游戏类型，也是一种控制/摄像头系统。我们感兴趣的是后者，因为它是我们控制汽车的方式。'
- en: 'Open the editor to the new combined project, and follow the next exercise to
    build the `TestingAcademy` object:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 打开新的合并项目的编辑器，接着按照下一个练习来构建`TestingAcademy`对象：
- en: Click in the **Hierarchy** window, and from the menu, select **GameObject**
    | **Create Empty**. Name the new object `TestingAcademy`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层级**窗口中点击，然后从菜单中选择**游戏对象** | **创建空物体**。将新对象命名为`TestingAcademy`。
- en: Locate and click inside the HoDLG | **Scripts** folder, and then open the **Create**
    sub-menu in the **Project** window.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到并点击**HoDLG | Scripts**文件夹，然后在**项目**窗口中打开**创建**子菜单。
- en: From the **Create** menu, select **C# Script**. Rename the script `TestingAcademy`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**创建**菜单中，选择**C# 脚本**。将脚本重命名为`TestingAcademy`。
- en: 'Open the new **TestingAcademy** script and enter the following code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新的**TestingAcademy**脚本并输入以下代码：
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All of the code for this chapter's exercise is included in the `Chapter_12_Code.assetpackage` included
    with the book's source code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 本章练习的所有代码都包含在`Chapter_12_Code.assetpackage`中，该包随书籍的源代码一同提供。
- en: This code defines our class and imports by using the required namespaces. Then,
    we define our own namespace, `Packt.HoDLG`,and the class is extended from `Academy`,
    an ML-Agents base class. Next comes the declaration of several variables for defining
    the goal deployment cube. Think of this as a virtual cube in space that will spawn
    the goals. The idea is to let physics do the rest and let the goal just drop to
    the ground.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码通过使用所需的命名空间来定义我们的类和导入内容。然后，我们定义了自己的命名空间`Packt.HoDLG`，并且类继承自ML-Agents的基类`Academy`。接下来声明了几个变量来定义目标部署的立方体。可以把它想象成一个虚拟的空间立方体，用来生成目标。其基本思路是让物理引擎处理剩余部分，让目标直接掉到地面上。
- en: '**Namespaces** are optional in Unity, but it is highly recommended to put your
    code within a namespace in order to avoid most naming issues, which can be a common
    problem if you are using many assets or if you find yourself modifying existing
    assets, as we are doing here.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名空间**在Unity中是可选的，但强烈建议将代码放入命名空间中，以避免大多数命名问题。如果你使用了很多资源或修改了现有资源，就像我们在这里所做的那样，这些问题会很常见。'
- en: 'Next, we will define the standard `Academy` class setup method, `InitializeAcademy`.
    This method is called automatically, and is shown as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义标准的`Academy`类设置方法`InitializeAcademy`。该方法会自动调用，具体如下所示：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This method is called as a part of the ML-Agents setup, and it essentially
    starts the whole SDK. By adding the `Academy` (`TestingAcademy`), we will effectively
    be enabling ML-Agents. Next, we will add the final method, called when the academy
    is reset at the end of all of the agent episodes, as follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个方法是作为ML-Agents设置的一部分被调用的，它实际上启动了整个SDK。通过添加`Academy`（`TestingAcademy`），我们实际上启用了ML-Agents。接下来，我们将添加最后一个方法，该方法会在所有代理回合结束时重置学院，如下所示：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code just spawns the goals randomly within the virtual cube bounds. Before
    it does this, however, it first clears the old goals by using the `Destroy` method. `Destroy` removes
    an object from the game. Then, the code loops again and creates new goals at random
    locations within the virtual cube. The line that actually creates the goal in
    the game is highlighted and uses the `Instantiate` method. `Instantiate` creates
    an object in the game at the specified location and rotation.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码会随机生成目标，并将其放置在虚拟立方体的范围内。然而，在此之前，它首先使用`Destroy`方法清除旧的目标。`Destroy`会将对象从游戏中移除。然后，代码再次循环并在虚拟立方体内的随机位置创建新的目标。实际创建目标的代码行被高亮显示，并使用了`Instantiate`方法。`Instantiate`会在指定的位置和旋转角度创建游戏中的对象。
- en: Save the file and return to the editor. Don't worry about any compiler errors
    at this time. If you are writing the code from scratch, you will be missing some
    types, which we will define later.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并返回编辑器。此时不必担心任何编译错误。如果你是从头开始编写代码，可能会缺少一些类型，稍后我们会定义这些类型。
- en: With the new `TestingAcademy` script created, we can move on to adding the component
    to the game object and setting up the academy in the next section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 创建好新的`TestingAcademy`脚本后，我们可以继续在下一节中将该组件添加到游戏对象并设置学院。
- en: Setting up TestingAcademy
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置TestingAcademy
- en: 'With the `TestingAcademy` script created, it is time to add it to the game
    object via the following steps:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建好`TestingAcademy`脚本后，接下来通过以下步骤将其添加到游戏对象中：
- en: Drag the new **TestingAcademy** script file from the **Scripts** folder and
    drop it on to the **TestingAcademy** object in the **Hierarchy** window. This
    will add the component to the object. We want to create a few other components
    before we complete the academy.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**脚本**文件夹中拖动新的**TestingAcademy**脚本文件，并将其放到**层次结构**窗口中的**TestingAcademy**对象上。这会将该组件添加到对象中。在完成学院设置之前，我们还需要创建其他一些组件。
- en: Click in the **Hierarchy** window, and in the menu, select **Game Object | 3D
    Object | Cube**. Rename the new object `goal`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中点击，菜单中选择**Game Object | 3D Object | Cube**。将新对象重命名为`goal`。
- en: 'Select the object and change the **Tag** to `goal`. Then, swap its material
    by clicking on the **Target** icon and selecting the **v46**, or another flashy
    material of your choice, as shown in the following screenshot:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择该对象并将**Tag**更改为`goal`。然后，通过点击**Target**图标并选择**v46**或其他闪亮材质，来更换其材质，如下图所示：
- en: '![](img/2564018c-e40d-4aa1-b3de-98711659f027.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2564018c-e40d-4aa1-b3de-98711659f027.png)'
- en: Swapping the goal object's materials
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 更换目标对象的材质
- en: With the **goal** object selected from the menu, select **Component | Physics
    | Rigidbody**. This will add a physics system component called a Rigidbody. By
    adding the **Rigidbody** to the object, we allow it to be controlled by the physics
    system.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在菜单中选择**goal**对象，接着选择**Component | Physics | Rigidbody**。这将添加一个名为Rigidbody的物理系统组件。通过将**Rigidbody**添加到对象上，我们允许它受物理系统的控制。
- en: Drag and drop the **goal** object into the **HoDLG | Prefabs** folder in the
    **Project** window. This will turn the goal object into a **Prefab**. Prefabs are
    self-contained objects that contain their own hierarchies. A prefab can contain
    an entire scene, or just one object, as we have here.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**goal**对象拖放到**Project**窗口中的**HoDLG | Prefabs**文件夹中。这将使目标对象成为一个**Prefab**。预制件是自包含的对象，包含自己的层级结构。预制件可以包含一个完整的场景，或者只是一个对象，就像我们这里所做的一样。
- en: Select and delete the **goal** object from the **Hierarchy** window. In the
    future, we will programmatically instantiate the **goal** from the Academy by
    using its Prefab.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**窗口中选择并删除**goal**对象。未来，我们将通过使用它的Prefab从Academy中以编程方式实例化**goal**。
- en: Click inside the **HoDLG | Brains** folder, and click to open the **Create**
    menu. From the menu, select **ML-Agents | LearningBrain**. Name the new brain
    **`TestingLearningBrain`**, and then create a new player brain called `TestingPlayerBrain`.
    Don't worry about configuring the brains just yet.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**HoDLG | Brains**文件夹，点击打开**Create**菜单。在菜单中选择**ML-Agents | LearningBrain**。将新建的大脑命名为**`TestingLearningBrain`**，然后创建一个名为`TestingPlayerBrain`的新玩家大脑。暂时无需配置这些大脑。
- en: 'Select the **TestingAcademy** object in the **Hierarchy** window, and then
    update the values of the **Testing Academ**y component, as shown in the following
    screenshot:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**窗口中选择**TestingAcademy**对象，然后更新**Testing Academy**组件的值，如下图所示：
- en: '![](img/dbe7dab4-44b7-4ff5-8719-59c79fa884d0.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dbe7dab4-44b7-4ff5-8719-59c79fa884d0.png)'
- en: Setting up TestingAcademy
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 设置TestingAcademy
- en: 'Notice that we are setting up the following properties in the **TestingAcademy**
    script:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，我们正在**TestingAcademy**脚本中设置以下属性：
- en: '**Brains**: TestingLearningBrain'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Brains**: TestingLearningBrain'
- en: '**Max Steps**: 3000'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Max Steps**: 3000'
- en: '**Goal**: Goal set by dragging the prefab from the folder'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Goal**: 通过从文件夹中拖动预制件来设置目标'
- en: '**Num Goals**: 3 (number of goals dropped from the box)'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Num Goals**: 3（从盒子中丢出的目标数）'
- en: '**Goal Size**: (50, 50, 50) (determines maximum bounds of the goal box)'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Goal Size**: (50, 50, 50)（确定目标框的最大边界）'
- en: '**Goal Center**:  (85, 110, -37) (the center point of the goal box)'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Goal Center**: (85, 110, -37)（目标框的中心点）'
- en: You may be tempted to run the project at this point; you can if you have just
    downloaded the code, but hold off until we define the `TestingAgent` in the next
    section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此时你可能会想要运行项目；如果你刚刚下载了代码，倒是可以先运行，但等我们在下一节中定义`TestingAgent`时再开始吧。
- en: Scripting the TestingAgent
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写TestingAgent脚本
- en: 'Of course, our testing (or however far we want to take this simulation) won''t
    do much without an agent to interact with the environment and learn. In the next
    exercise, we will define the script that describes the `TestingAgent` component:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果没有代理来与环境交互并进行学习，我们的测试（或者说我们想要推进的模拟程度）是没有意义的。在接下来的练习中，我们将定义描述`TestingAgent`组件的脚本：
- en: Click inside the **HoDLG | Scripts** folder, and click on the **Create** button
    to open the menu.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**HoDLG | Scripts**文件夹，点击**Create**按钮以打开菜单。
- en: From the menu, select **C# Script** and name the script `TestingAgent`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在菜单中选择**C# Script**并将脚本命名为`TestingAgent`。
- en: 'Open the script in your editor and start to script it with the following code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开脚本，并开始用以下代码进行编写：
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This starts our class; this time, it's extended from `Agent`, another base class.
    Then, we define some base fields for setting variables and recording the agent's
    start position and rotation.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这开始了我们的类；这次它是从`Agent`这个基类扩展而来。接着，我们定义了一些基本字段，用于设置变量和记录代理的起始位置和旋转。
- en: 'Next, we move on to define the `InitializeAgent` method. This method is called
    once, to set up the agent and make sure that the action lengths are the same;
    we will get to that shortly. We remember the position/rotation from which the
    agent started, so that we can restore it later. The code is as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义`InitializeAgent`方法。该方法会被调用一次，用于设置代理并确保动作长度一致；我们很快就会讲到。我们记住代理开始时的位置/旋转，以便稍后恢复。代码如下：
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we define an empty method called `CollectObservations`. This is typically
    where the agent observes the environment; since we plan to use visual observations,
    we can leave this empty. The code is as follows:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个空的方法，名为`CollectObservations`。通常，这是代理观察环境的地方；由于我们计划使用视觉观察，因此可以将其留空。代码如下：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we define another required method: `AgentAction`. This is the method
    where we add the negative step reward and move the agent, as shown in the following
    code snippet:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义另一个必需的方法：`AgentAction`。这是我们添加负面步骤奖励并移动代理的地方，如下方代码片段所示：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code here is what deciphers the actions from the brain and injects them
    back into a new class (which we will build shortly), called `TestingInput`. `TestingInput`
    is a helper class that we will use to override the input system of the game.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里的代码解读来自大脑的动作，并将它们注入到一个新的类中（我们稍后将构建它），叫做`TestingInput`。`TestingInput`是一个辅助类，我们将用它来覆盖游戏的输入系统。
- en: Save the script, and, again, ignore any compiler errors. Again, we have a new
    dependency, `TestingInput`, that we will define shortly.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本，并且再次忽略任何编译器错误。我们有一个新的依赖项，`TestingInput`，我们将在稍后定义它。
- en: With the new script in hand, we can begin to set up the `TestingAgent` component
    in the next section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有了新的脚本，我们可以在下一部分开始设置`TestingAgent`组件。
- en: Setting up the TestingAgent
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 TestingAgent
- en: 'Now, the system that we are building here is fairly generic, and it''s intended
    to be used in multiple environments. Keep that in mind as we set things up, especially
    if some concepts seem a bit abstract. Open up the editor, and let''s add the `TestingAgent`
    script to an object:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们正在构建的系统是相当通用的，旨在用于多个环境。在设置过程中请记住这一点，特别是当某些概念看起来有点抽象时。打开编辑器，让我们将`TestingAgent`脚本添加到一个对象中：
- en: Select **Vehicle1**, **Vehicle3**, **Vehicle4,** and **Vehicle5** in the scene,
    and disable them. We currently only want to give our agent the ability to drive,
    and not to switch vehicles; therefore, we only need the default **Vehicle2**.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择场景中的**Vehicle1**、**Vehicle3**、**Vehicle4**和**Vehicle5**，并禁用它们。我们当前只希望给代理提供驾驶能力，而不是切换车辆；因此，我们只需要默认的**Vehicle2**。
- en: Select the **TestingAgent** script from the **HoDLG | Scripts** folder and drag
    it on to the **Vehicle2** object. This will add the **TestingAgent** component
    to our **Vehicle2**, and will make it an agent (well, almost).
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**HoDLG | Scripts**文件夹中选择**TestingAgent**脚本并将其拖动到**Vehicle2**对象上。这将把**TestingAgent**组件添加到我们的**Vehicle2**，使其成为一个代理（嗯，差不多）。
- en: 'Open **Vehicle2 | Cameras** in the **Hierarchy** window and choose the view
    that you want the agent to use. We will select **Camera2** for this exercise,
    but the options for each of the five cameras are shown in the following screenshot:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**Vehicle2 | Cameras**在**Hierarchy**窗口中，并选择你希望代理使用的视图。我们将选择**Camera2**进行此练习，但每个五个摄像头的选项如以下截图所示：
- en: '![](img/57b066fb-c719-4455-bab5-3f7d8ee20693.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57b066fb-c719-4455-bab5-3f7d8ee20693.png)'
- en: Selecting the visual observation camera to use as an input to the agent
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 选择作为输入的视觉观察摄像头
- en: The best options are either **Camera1** or **Camera5**, as shown in the preceding
    screenshot. Note that the cameras are ordered in reverse, with 1 starting at the
    far right, not the left. Of course, that leaves plenty of opportunity to play
    with other visual input in the future.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最佳选择是**Camera1**或**Camera5**，如上面截图所示。请注意，摄像头的顺序是反向的，从右到左，编号从1开始。当然，这也留给我们很多机会在未来尝试其他视觉输入。
- en: 'Select **Vehicle2** and drag the selected **TestingPlayerBrain** and **Camera1**
    into the required slots, as shown in the following screenshot:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Vehicle2**并将选中的**TestingPlayerBrain**和**Camera1**拖到需要的插槽中，如下方截图所示：
- en: '![](img/9cba63e4-8356-405a-abc5-bca34bf77309.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9cba63e4-8356-405a-abc5-bca34bf77309.png)'
- en: Setting up the TestingAgent component
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 TestingAgent 组件
- en: 'You will also need to define additional properties, which are summarized as
    follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要定义其他属性，具体如下：
- en: '**Brain**: TestingPlayerBrain.'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大脑**：TestingPlayerBrain。'
- en: '**Camera 1**: Click on **Add Camera** to add a new camera, and then select
    **Camera1** from the **Vehicle2** cameras.'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摄像头 1**：点击**添加摄像头**以添加一个新摄像头，然后从**Vehicle2**的摄像头中选择**Camera1**。'
- en: '**Decision Frequency**: `10` (this determines how often the agent makes decisions;
    `10` is a good starting point for this game. It will vary, and you will likely
    have to tune it to your needs)'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**决策频率**：`10`（这决定了代理做决策的频率；`10`是这个游戏的一个不错的起始值。它会有所变化，可能需要根据需要进行调整）'
- en: '**Axis Action:** 2:'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轴向动作**：2：'
- en: '**Element 0**: Vertical (denotes the axis we will be overriding to allow the
    agent to control the game. We will get more into axis descriptions shortly)'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元素 0**：垂直（表示我们将要覆盖的轴，允许代理控制游戏。稍后我们会更详细地介绍轴的描述）'
- en: '**Element 1**: Horizontal (same as the preceding)'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元素 1**：水平（与之前相同）'
- en: Save the project and the scene, and, again, ignore any compiler errors.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存项目和场景，并再次忽略任何编译错误。
- en: That completes the set up of the `TestingAgent`; as you can see, there isn't
    a whole lot of configuration or code required to get this running. In the future,
    you will likely see more advanced ways of testing/debugging or building agents
    this way. For now, however, we need to complete our example by injecting into
    the Unity input system, which we will do in the next section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了 `TestingAgent` 的设置；正如你所看到的，启动这个功能所需的配置或代码并不多。未来，你可能会看到更多高级的测试/调试或构建代理的方式。不过，目前我们需要通过注入
    Unity 输入系统来完成我们的示例，下一部分我们将会这样做。
- en: Overriding the Unity input system
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖 Unity 输入系统
- en: One of Unity's most compelling features is its ability to be cross-platform
    across any system, and with that comes several helpful layers of abstraction that
    we can use to inject our code into. However, the game in question needs to be
    following the Unity best practices in order to make this injection easy. That
    isn't to say that we couldn't do it by overriding the game's input system; it
    just wouldn't be as easy.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 最具吸引力的特点之一是其跨平台能力，能够在任何系统上运行，而这也带来了多个有助于我们将代码注入其中的抽象层。然而，所讨论的游戏需要遵循 Unity
    的最佳实践，以便轻松实现这种注入。并不是说我们不能通过覆盖游戏的输入系统来实现，只是那样做起来不那么简单。
- en: Before we get into describing how the injection works, let's take a step back
    and look at the best practices for using the Unity input system. Over the years,
    the Unity input system has evolved from a simple query that the device uses for
    inputs to the more cross-platform system that it uses now. However, many developers,
    including Unity itself, still use input methods that query a particular key code,
    for instance. The best practice is to define a set of axes (input channels) that
    define the input for the game.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始描述注入如何工作之前，先回顾一下使用 Unity 输入系统的最佳实践。多年来，Unity 输入系统已经从最初的简单查询设备输入的方式，演变成现在更具跨平台特性的系统。然而，包括
    Unity 本身在内的许多开发者，仍然使用查询特定按键代码的输入方法。最佳实践是定义一组轴（输入通道），来定义游戏的输入。
- en: 'We can easily see how it is currently defined in the game by following this
    exercise:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下练习轻松查看它在游戏中的当前定义：
- en: From the editor menu, select **Edit | Project Settings**.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从编辑器菜单中选择 **编辑 | 项目设置**。
- en: 'Select the Input tab and then expand **Axes | Horizontal** and **Axes | Vertica**l,
    as shown in the following screenshot:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“输入”标签，然后展开 **轴 | 水平** 和 **轴 | 垂直**，如下面的截图所示：
- en: '![](img/17cdd21e-d1c3-4ddf-b67e-d9e1c386136a.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17cdd21e-d1c3-4ddf-b67e-d9e1c386136a.png)'
- en: Inspecting the Input Axes settings
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 检查输入轴设置
- en: The **Vertical** and **Horizontal** axes define the input that will be used
    to control the game. By defining them in this tab, we can control the input across
    platforms by querying the axes. Notice that the axis input allows us to define
    both the button and joystick (touch) input. The output of a query to the input
    system with `getAxis` returns a value from `-1` to `+1`, or continuous output.
    This means that we can take any discrete form of input, such as a keystroke, and
    immediately convert it to a continuous value automatically. For example, if a
    user presses the *W* key, the input system coverts that to a positive 1 value
    on the **Vertical Axis**, and conversely, a press on the *S* key generates a negative
    1 value, again on the **Vertical Axis. **Likewise, the *A* and *D* keys control
    the Horizontal Axis.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**垂直** 和 **水平** 轴定义了将用于控制游戏的输入。通过在这个标签中定义它们，我们可以通过查询轴来跨平台控制输入。请注意，轴输入允许我们定义按钮和摇杆（触摸）输入。对输入系统的查询（使用
    `getAxis`）返回一个从 `-1` 到 `+1` 的值，或者是连续的输出。这意味着我们可以将任何离散形式的输入（比如按键）立即转换为连续值。例如，当用户按下
    *W* 键时，输入系统将其转换为 **垂直轴** 上的正 1 值，相反，按下 *S* 键则会生成负 1 值，同样是在 **垂直轴** 上。类似地，*A* 和
    *D* 键控制 **水平轴**。'
- en: As you have seen in a few chapters in this book, using the .6 version of ML-Agents,
    the current discrete action solution is not nearly as good as the continuous action.
    Therefore, it will be our preference going forward.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本书的几章中所看到的，使用.6版本的ML-Agents时，当前的离散动作解决方案远不如连续动作。因此，未来我们更倾向于使用连续动作。
- en: At this point, you may be wondering why we used discrete actions at all; that
    is a good question. It remains to be seen how Unity will handle this dichotomy
    in the future. In the next section, we will look at how to inject into the input
    system.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个阶段，你可能会想，为什么我们使用了离散动作？这是一个很好的问题。如何在未来处理这个二分法，Unity还未明确。在下一节中，我们将探讨如何将其注入到输入系统中。
- en: Building the TestingInput
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建TestingInput
- en: 'We are going to use a pattern called a **Singleton** in order to implement
    a class that we can access from anywhere in our code, much like the input class
    from Unity that is currently used. Unity has the benefit of making the input completely
    static, but for our purposes, we will use the well-defined scripting version.
    Open the editor and follow the next exercise to build the `TestingInput` script
    and object:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一种名为**单例模式**的设计模式，以实现一个可以在代码的任何地方访问的类，类似于当前使用的Unity输入类。Unity的优点是能够让输入完全静态，但对于我们的目的，我们将使用定义良好的脚本版本。打开编辑器并按照接下来的练习构建`TestingInput`脚本和对象：
- en: Select the **HoDLG | Scripts** folder and open the **Create** menu.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**HoDLG | Scripts**文件夹并打开**创建**菜单。
- en: 'From the **Create** menu, select **C# Script**. Name the new script `Singleton`.
    This script is the standard pattern script from [http://wiki.unity3d.com/index.php/Singleton](http://wiki.unity3d.com/index.php/Singleton);
    the script is shown as follows:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**创建**菜单中，选择**C#脚本**。将新脚本命名为`Singleton`。这个脚本是来自[http://wiki.unity3d.com/index.php/Singleton](http://wiki.unity3d.com/index.php/Singleton)的标准模式脚本；脚本如下所示：
- en: '[PRE7]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Enter the preceding code, or just use the code downloaded from the book's source.
    A singleton allows us to define one thread-safe instance of a specific class that
    all of the objects can refer to. A typical static class will not be thread-safe,
    and may cause corruption or memory issues.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入上述代码，或者直接使用从书籍源代码下载的代码。单例模式允许我们定义一个线程安全的特定类实例，所有对象都可以引用。典型的静态类不是线程安全的，可能会导致数据损坏或内存问题。
- en: Create a new script called `TestingInput` in the **HoDLG | Scripts** folder
    and open it for editing.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**HoDLG | Scripts**文件夹中创建一个名为`TestingInput`的新脚本，并打开它进行编辑。
- en: 'We will start the class with the following code:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从以下代码开始该类：
- en: '[PRE8]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Notice the highlighted line, and how we declare the class to extend from the
    type `Singleton` that wraps the type `TestingInput`. This form of recursive typing,
    which uses generics, is perfect for the singleton. Don''t worry if this is a little
    unclear; the only thing that you need to remember is that we can now access the
    instance of this class from anywhere in our code. Notice that we mentioned an
    instance and not a class, meaning that we can also persist the state within our
    `TestingInput` class. The variables that we declare here, `axes` and `isPlayer`,
    are either set in the editor or defined in the `Start` method, as follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意高亮显示的那一行，以及我们如何声明该类继承自`Singleton`类型，该类型包装了`TestingInput`类型。这个使用泛型的递归类型非常适合单例模式。如果这一点有点不清楚，别担心；你需要记住的唯一一点是，我们现在可以在代码的任何地方访问该类的实例。请注意我们提到的是实例而不是类，这意味着我们还可以在`TestingInput`类中保持状态。我们在这里声明的变量，`axes`和`isPlayer`，要么在编辑器中设置，要么在`Start`方法中定义，如下所示：
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Inside the `Start` method, we define a `Dictionary` to hold the axis and values
    that we want this component to override. This allows us to control which input
    we want to override. Then, we build the collection of name/value pairs.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start`方法中，我们定义了一个`Dictionary`来保存我们希望该组件覆盖的轴和值。这使我们能够控制希望覆盖哪些输入。然后，我们构建名称/值对集合。
- en: Next, we will define a couple methods that will allow us to both mimic and set
    the axis values of our input system. Unity has no direct way to set the value
    of an axis. Currently, the `Input` system queries the hardware directly in order
    to read the input state, and provides no way to override this for testing. While
    this is a feature that has long been requested by the community, it remains to
    be seen whether it will ever be implemented.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义几个方法，使我们能够模拟并设置输入系统的轴值。Unity没有直接设置轴值的方式。目前，`Input`系统直接查询硬件以读取输入状态，并且没有提供覆盖此状态进行测试的方式。虽然这是社区长期以来的一个需求，但是否最终会实现仍然有待观察。
- en: 'We then enter a `setAxis` and `getAxis` method, as follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们输入`setAxis`和`getAxis`方法，如下所示：
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That completes the script; if you have been adding the code as you go, save
    the file and return to Unity. At this point, you should see no compiler errors,
    as all of the required types should be present and accounted for.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这完成了脚本的编写；如果你在过程中已经添加了代码，保存文件并返回Unity。此时，你应该看不到编译错误，因为所有必需的类型应该已经存在并且是完整的。
- en: That sets up the `TestingInput` script; now, we need to move on to the next
    section to add it to the scene.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置`TestingInput`脚本；现在，我们需要继续下一部分，将它添加到场景中。
- en: Adding TestingInput to the scene
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将TestingInput添加到场景
- en: 'Singletons can be called from anywhere and everywhere, and they actually don''t
    need a game object in the scene. However, by adding the object to the scene, we
    become more self-aware of the required dependency, as it allows us to set required
    parameters for a particular scene. Open the Unity editor and follow the next exercise
    to add the `TestingInput` component to the scene:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 单例可以在任何地方被调用，实际上，它们并不需要场景中的游戏对象。然而，通过将对象添加到场景中，我们更清晰地意识到所需的依赖关系，因为它使我们能够为特定的场景设置所需的参数。打开Unity编辑器，按照接下来的练习将`TestingInput`组件添加到场景中：
- en: Click in the **Hierarchy** window, and from the menu, select **Game Object |
    Create Empty**.  Rename the object `TestingInput`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**层级**窗口，然后从菜单中选择**游戏对象 | 创建空对象**。重命名该对象为`TestingInput`。
- en: Drag the **TestingInput** script from the **HoDLG | Scripts** folder in the
    **Project** window to the new **TestingInput** object in the **Hierarchy** window.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**TestingInput**脚本从**HoDLG | 脚本**文件夹拖到**层级**窗口中的新**TestingInput**对象上。
- en: 'Select the **TestingInput** object, and then set the required **Axes**, as
    shown in the following screenshot:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**TestingInput**对象，然后设置所需的**轴**，如下图所示：
- en: '![](img/f0dd7e42-d971-4217-b1b1-031c898e42d1.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0dd7e42-d971-4217-b1b1-031c898e42d1.png)'
- en: Setting the axes to override
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 设置要重写的轴
- en: We need to define two Axes that we want to override. In this case, we are only
    overriding the **Vertical** (*S* and *W*) and **Horizontal** (*A* and *D*) keys.
    You could, of course, override any axis that you wanted, but in this case, we
    are only overriding two.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要定义两个要重写的轴。在这个例子中，我们只重写**垂直**（*S*和*W*）和**水平**（*A*和*D*）键。当然，你也可以重写任何你想要的轴，但在这个例子中，我们只重写了两个。
- en: Save the project and the scene.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存项目和场景。
- en: At this point, you can't really run the project, since the actual input system
    isn't overriding anything just yet. We complete that final injection in the next
    section.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你无法运行项目，因为实际的输入系统还没有重写任何内容。我们将在下一部分完成最终的注入。
- en: Overriding the game input
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重写游戏输入
- en: 'At this point, we have a complete testing system in place; we just need to
    complete the last parts of the injection. This bit of surgery can require a keen
    eye and a little digging through code. Fortunately, there are some good, clear
    indicators that you can use to spot places for injection. Open the editor and
    follow the next steps to complete the injection:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经建立了一个完整的测试系统；接下来只需要完成注入的最后部分。这部分的操作可能需要敏锐的眼光和一些代码的挖掘。幸运的是，有一些清晰的指示器，可以帮助你找到注入的位置。打开编辑器，按照以下步骤完成注入：
- en: Select the **Control** object in the **Hierarchy** window.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层级**窗口中选择**Control**对象。
- en: Locate the **MS Scene Controller Free** component in the **Inspector** window
    and use the **Context** menu to open the script in your code editor.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中找到**MS Scene Controller Free**组件，然后使用**上下文**菜单打开代码编辑器中的脚本。
- en: 'Locate the following block of code, around line **286** (about halfway in),
    as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到以下代码块，大约在**286**行（大约中间位置），如下所示：
- en: '[PRE11]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is where the game is querying the `GetAxis` method, in order to return
    the values of the respective input axis. As we have discussed, we are only interested
    in the vertical and horizontal axes for this example. You can, of course, override
    other axes, as you see fit.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是游戏查询`GetAxis`方法的位置，用来返回相应输入轴的值。正如我们所讨论的，我们这里只关心垂直和水平轴。你当然可以根据需要重写其他轴。
- en: 'Modify the lines where the `verticalInput` and `horizontalInput` are being
    set, as follows:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改设置`verticalInput`和`horizontalInput`的代码行，如下所示：
- en: '[PRE12]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that we call `TestingInput.Instance`, in order to access the singleton
    instance of our class. This allows us to query that class for the current input
    values. The `TestingInput` object can now be the source of truth (as far as this
    class is concerned), with respect to the input.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，我们调用 `TestingInput.Instance`，以便访问我们类的单例实例。这使我们能够查询该类当前的输入值。现在，`TestingInput`
    对象可以作为该类在输入方面的真实来源。
- en: 'Previously, we quickly went over the agent code that sets the input, but here
    it is again for reference:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前，我们快速浏览了设置输入的代理代码，但这里再次提供供参考：
- en: '[PRE13]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice the highlighted line in the `TestingAgent` `MoveAgent` method. This is
    where we override the input by the agent and inject the values back into the game.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意 `TestingAgent` `MoveAgent` 方法中的高亮行。这里是我们通过代理重写输入并将值注入到游戏中的地方。
- en: Save the code and return to the editor. Make sure to fix any compiler issues
    now.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存代码并返回编辑器。确保现在修复任何编译问题。
- en: Unfortunately, we are still unable to run the scene, as we have one last configuration
    step to tend to. In the next section, we will complete the configuration by setting
    up the brains.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们仍然无法运行场景，因为我们还有最后一个配置步骤需要处理。在下一部分，我们将通过设置脑模型来完成配置。
- en: Configuring the required brains
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置所需的脑模型
- en: 'The last piece of the puzzle is to configure the brains that we quickly built
    earlier. ML-Agents requires that the brains be configured with the required input
    and observation space, in order to work correctly. We will set up the `TestingPlayerBrain`
    and `TestingLearningBrain` in the next exercise:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一块拼图是配置我们之前快速构建的脑模型。ML-Agents要求脑模型配置所需的输入和观察空间，以便正常工作。我们将在下一个练习中设置 `TestingPlayerBrain`
    和 `TestingLearningBrain`：
- en: Open the Unity editor and select **TestingLearningBrain** from the **HoDLG |
    Brains** folder to open it in the **Inspector**.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Unity 编辑器并从 **HoDLG | Brains** 文件夹中选择 **TestingLearningBrain**，以在 **Inspector**
    中打开它。
- en: 'Set the **Brain** parameters, as shown in the following screenshot:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 **Brain** 参数，如下图所示：
- en: '![](img/9bbd5fff-4871-4cf5-8f8c-e4d6a90c86c5.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9bbd5fff-4871-4cf5-8f8c-e4d6a90c86c5.png)'
- en: Setting the parameters for the TestingPlayerBrain
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 TestingPlayerBrain 的参数
- en: 'There are several parameters to set; they are summarized as follows:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要设置几个参数，它们总结如下：
- en: '**Visual Observations**: `84` x `84` and no grayscale'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视觉观察**：`84` x `84`，无灰度'
- en: '**Vector Action**:'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向量动作**：'
- en: '**Space Type**: Continuous'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空间类型**：连续'
- en: '**Space Size**: `2`'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空间大小**：`2`'
- en: '**Action Descriptions:**'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动作描述：**'
- en: '**Size**: `2`'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大小**：`2`'
- en: '**Element 0**: Vertical'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元素 0**：垂直'
- en: '**Elem****ent 1**: Horizontal'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元素 1**：水平'
- en: '**Axis Continuous Player Actions**:'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轴向连续玩家动作**：'
- en: '**Size**: `2`'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大小**：`2`'
- en: '**Vertical:**'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垂直：**'
- en: '**Axis**: Vertical'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轴向**：垂直'
- en: '**Index**: `0`'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**索引**：`0`'
- en: '**Scale**: `1`'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩放**：`1`'
- en: '**Horizontal:**'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平：**'
- en: '**Axis**: Horizontal'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轴向**：水平'
- en: '**Index**: `1`'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**索引**：`1`'
- en: '**Scale**: `1`'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩放**：`1`'
- en: 'Select **TestingLearningBrain** and configure it the same, but for learning,
    as shown in the following screenshot:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **TestingLearningBrain** 并以相同方式进行配置，但这是用于学习，如下图所示：
- en: '![](img/79c20b13-8e7e-4d7d-a10f-092cd9df7118.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79c20b13-8e7e-4d7d-a10f-092cd9df7118.png)'
- en: Configuring the TestingLearningBrain
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 TestingLearningBrain
- en: The configuration for the learning brain is much simpler, but it is also still
    required, even when running the sample in player mode (which, if you recall, it
    is set up to do).
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 学习脑的配置要简单得多，但即使在以玩家模式运行示例时（如你记得的，它已被设置为这样做），这也是必须的。
- en: Save the scene and project. Finally, we have completed our required configuration.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景和项目。最终，我们已经完成了所需的配置。
- en: Press Play to run the scene and play the game in player mode. We are controlling
    the game through the ML-Agents system. After a few seconds, you should see some
    goals drop nearby.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下播放按钮运行场景并以玩家模式玩游戏。我们通过ML-Agents系统控制游戏。几秒钟后，你应该能看到附近掉落一些目标。
- en: 'Control the vehicle and drive into a goal, as shown in the following screenshot:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制车辆并驶入目标，如下图所示：
- en: '![](img/d7deecda-a6e9-4fa3-b19c-ae6c617db3b3.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7deecda-a6e9-4fa3-b19c-ae6c617db3b3.png)'
- en: Driving into the goals
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 驾驶进入目标
- en: When you are done playing, stop the game.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你完成游戏后，停止游戏。
- en: Now that we are able to play the game through ML-Agents by using a configured
    player brain, we will switch to a learning brain and let an agent take control
    in the next section.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够通过配置好的玩家脑模型通过ML-Agents玩游戏，我们将在下一部分切换到学习脑，让代理控制游戏。
- en: Time for training
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练时间
- en: 'However we decide to use this platform, whether for training or testing, we
    now need to do the last brain configuration step, in order to set any custom hyperparameters
    that we may decide to use for training. Open a Python/Anaconda console and prepare
    it for training, and then follow these steps:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们决定如何使用这个平台，无论是用于训练还是测试，我们现在需要做最后的脑配置步骤，以便设置任何我们可能决定用于训练的自定义超参数。打开Python/Anaconda控制台并准备进行训练，然后按照以下步骤进行：
- en: Open the `trainer_config.yaml` file located in the `ML-Agents/ml-agents/config`
    folder.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于`ML-Agents/ml-agents/config`文件夹中的`trainer_config.yaml`文件。
- en: 'We will add a new configuration section to the config file, modeled after one
    of the other visual environments. Add the new configuration, as follows:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将向配置文件中添加一个新的配置部分，模仿其他视觉环境中的配置。按照以下方式添加新的配置：
- en: '[PRE14]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that we added the word `brain`, in order to differentiate it from the
    other brains. This brain is modeled after the `VisualHallwayBrain` that we spent
    some time exploring previously. Keep in mind, however, that we are running a continuous
    action problem now, and this can affect some parameters.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，我们添加了`brain`这个词，以便与其他脑区分开来。这个脑是基于我们之前花时间探索的`VisualHallwayBrain`模型制作的。然而，请记住，我们现在运行的是一个连续动作问题，这可能会影响某些参数。
- en: Save the file and return to the Unity editor.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并返回到Unity编辑器。
- en: Locate the `TestingAcademy` object, swap its `Brains` for a `TestingLearningBrain`,
    and set it to `Control`, as you have done so many times before.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到`TestingAcademy`对象，将其`Brains`替换为`TestingLearningBrain`，并将其设置为`Control`，就像你之前做过的那样。
- en: Save the scene and project and return to the Python/Anaconda console.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景和项目，并返回到Python/Anaconda控制台。
- en: 'Start a training/learning/testing session by running the following command:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令开始训练/学习/测试会话：
- en: '[PRE15]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Watch the training session and the agent play the game. The agent will run,
    and depending on how long you train, it may become good at finding the goals.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观看训练过程和代理玩游戏的表现。代理将开始运行，取决于你训练的时间长度，它可能会变得擅长于寻找目标。
- en: At this point, you can let the agent go and just run through your level on its
    own, exploring. However, what we want to do is control or nudge the testing agent
    to the right path by using imitation learning, which we will discuss in the next
    section.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你可以让代理自行运行并探索你的关卡。然而，我们要做的是通过使用模仿学习来控制或引导测试代理走向正确的路径，我们将在下一节中讨论这一方法。
- en: Testing through imitation
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过模仿进行测试
- en: At this point in your learning, you have learned several strategies that we
    can apply to help our testing agent learn and find the goals. We can use curiosity
    or curriculum learning fairly easily, and we will leave that as an exercise for
    the reader. What we want is a way to control some of the testing process, and
    we don't really want our agent to randomly test everything (at least not at this
    stage). Sure, there are places where completely random testing works well. (By
    the way, this random form of testing is called **monkey testing**, because it
    resembles a monkey just mashing keys or input.) However, in a space such as our
    game, exploring every possible combination could take a very long time. Therefore,
    the best alternative is to capture player recordings and use them for our testing
    agent as a source for imitation learning.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习的这一阶段，你已经掌握了几种策略，我们可以应用它们来帮助测试代理学习并找到目标。我们可以轻松地使用好奇心或课程学习，我们将把这作为读者的练习。我们想要的是一种控制某些测试过程的方法，而且我们不希望代理随机地测试所有内容（至少在这个阶段不希望）。当然，有些地方完全随机测试效果很好。（顺便提一下，这种随机测试被称为**猴子测试**，因为它类似于猴子乱按键盘或输入。）然而，在像我们的游戏这样的空间中，探索每一个可能的组合可能需要很长时间。因此，最好的替代方法是捕捉玩家的录制并将其用作我们测试代理的模仿学习来源。
- en: 'With everything set up and with our ability to now route the input events through
    ML-Agents, we can capture player input in the form that an agent needs to learn
    from. Let''s open a backup Unity and set up the scene to capture player recordings,
    as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一切设置好后，并且我们现在能够通过ML-Agents将输入事件传递过去，我们可以以代理需要学习的形式捕捉玩家输入。接下来，让我们打开一个备份的Unity并设置场景来捕捉玩家的录制，步骤如下：
- en: Select the **Vehicle2** object in the **Hierarchy** window. Recall that this
    is where the **TestingAgent** script is attached.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**窗口中选择**Vehicle2**对象。回忆一下，这里是**TestingAgent**脚本附加的地方。
- en: Use the **Add Component** button at the bottom of the **Inspector** window to
    add a **Demonstration Recorder** component to the agent.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**Inspector**窗口底部的**Add Component**按钮将**Demonstration Recorder**组件添加到代理上。
- en: 'Set the **Demonstration Recorde**r to **Record** and the **Demonstration Nam**e
    to **Testing**, and change the brain to **TestingPlayerBrain**, as shown in the
    following screenshot:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Demonstration Recorder**设置为**Record**，并将**Demonstration Name**设置为**Testing**，然后将大脑切换到**TestingPlayerBrain**，如下面的截图所示：
- en: '![](img/b373980c-c6b3-4d82-b764-440aafaa5907.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b373980c-c6b3-4d82-b764-440aafaa5907.png)'
- en: Adding a Demonstration Recorder to the agent
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 向智能体添加演示记录器
- en: Select the **TestingAcademy** object, and make sure to disable the **Control**
    option on the **Brain**. We want the player to control the agent when recording.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**TestingAcademy**对象，确保禁用**Brain**上的**Control**选项。我们希望玩家在录制时控制智能体。
- en: Press Play and run the game. Use the *WASD* controls keys on your keyboard to
    drive the vehicle over the goals. Play for a little while, in order to generate
    a decent recording.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 Play 键并运行游戏。使用键盘上的*WASD*控制键驾驶车辆穿越目标。玩一会儿，以生成一个不错的录制。
- en: When you are done, check the `Assets` folder for a new folder called `Demonstrations`
    that contains your `Testing.demo` recording file.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，检查`Assets`文件夹中是否有一个名为`Demonstrations`的新文件夹，其中包含你的`Testing.demo`录制文件。
- en: Now, with the player recording in play, we can set up and run the agent, using
    imitation learning to test the level.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着玩家录制功能启用，我们可以设置并运行智能体，使用模仿学习来测试关卡。
- en: Configuring the agent to use IL
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置智能体使用 IL
- en: 'We have already run through the process of setting up and running an offline
    **imitation learning (IL)** session, but let''s review the process in the next
    exercise:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了设置和运行离线**模仿学习 (IL)** 会话的过程，但让我们在接下来的练习中回顾一下这个过程：
- en: Open the Unity editor to the same project and locate the **Vehicle2** object
    containing the agent.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Unity 编辑器，进入相同项目，找到包含智能体的**Vehicle2**对象。
- en: Switch the agent's brain from **TestingPlayerBrain** to **TestingLearningBrain**.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将智能体的大脑从**TestingPlayerBrain**切换到**TestingLearningBrain**。
- en: Select the **TestingAcademy** and enable the **Control** property on the **Testing
    Academy | Brains** component property.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**TestingAcademy**并启用**Testing Academy | Brains**组件上的**Control**属性。
- en: Save the scene and project.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景和项目。
- en: Open the `config/offline_bc_config.yaml` file in a text or code editor.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`config/offline_bc_config.yaml`文件，在文本或代码编辑器中编辑。
- en: 'Add the following section (a modified copy of `HallwayLearning`):'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下部分（`HallwayLearning`的修改版）：
- en: '[PRE16]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Save the file when you are done editing it.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑完成后保存文件。
- en: 'Open a Python/Anaconda console that is ready for training, and enter the following
    command:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个准备好进行训练的 Python/Anaconda 控制台，并输入以下命令：
- en: '[PRE17]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note a couple of modifications, highlighted in bold. After the training starts,
    watch the agent drive the car in the same manner that you trained it (or at least,
    it will try to).
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意几个修改，已用粗体标出。训练开始后，观察智能体以你训练它的方式驾驶汽车（或者至少，它会尽力去做）。
- en: Let the agent play the game, and watch how well it performs and/or gets into
    trouble.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让智能体玩游戏，观察它的表现以及是否遇到问题。
- en: This demo/game is quite stable and is not prone to any obvious issues, which
    makes testing it for obvious issues difficult. However, hopefully, you can appreciate
    that if this type of system is implemented very early in a game, even just for
    testing, it provides the ability to quickly find bugs and other issues. Of course,
    currently, our only method to identify any issues is to watch the agent play,
    which doesn't save us any time. What we need is a way to track agent activity
    and determine whether (and when) the agent finds itself in trouble. Fortunately,
    we can easily add this form of tracking by adding analytics, which we will cover
    in the next section.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示/游戏相当稳定，不容易出现明显问题，这使得测试明显问题变得困难。然而，希望你能理解，如果在游戏早期实现这种类型的系统，即使只是为了测试，它也能提供快速发现
    bug 和其他问题的能力。当然，目前我们唯一的识别问题的方法是观察智能体的游戏表现，这并没有节省时间。我们需要的是一种追踪智能体活动的方法，并确定智能体是否（以及何时）遇到问题。幸运的是，我们可以通过添加分析功能轻松地增加这种追踪方式，接下来我们将介绍这一部分。
- en: Analyzing the testing process
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析测试过程
- en: 'One of the key features that ML-Agents is currently missing is extra training
    analytics (beyond what is provided by the console and TensorBoard). A key feature
    that could be crucial (and which is not difficult to add) is training analytics.
    This could be implemented with the Unity Analytics service that is free to try
    with all games. Since this isn''t a current feature in ML-Agents, it is one that
    we will add in the next exercise, by adding our own training analytics system:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ML-Agents当前缺少的一个关键功能是额外的训练分析（超出控制台和TensorBoard提供的内容）。一个可能至关重要的功能（而且不难添加）是训练分析。可以通过Unity
    Analytics服务来实现这个功能，所有游戏都可以免费试用。由于这不是ML-Agents的现有功能，因此我们将在下一个练习中通过添加我们自己的训练分析系统来实现：
- en: Open the Unity editor, and from the menu, select **Window | General | Services**.
    This will open a new window called **Services**, usually over the top of the **Inspector**
    window.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Unity编辑器，从菜单中选择**Window | General | Services**。这将打开一个名为**Services**的新窗口，通常会出现在**Inspector**窗口上方。
- en: 'Click on the **Analytics** service in the newly opened **Services** window.
    You will need to progress through a couple of screens, asking for your preferences
    and acknowledgment, as shown in the following screenshot:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击新打开的**服务**窗口中的**Analytics**服务。你需要通过几屏设置，询问你的偏好和确认，如下图所示：
- en: '![](img/0795c6b9-6ccc-4b03-be81-671aea78d558.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0795c6b9-6ccc-4b03-be81-671aea78d558.png)'
- en: Setting up analytics for your project
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的项目设置分析
- en: Click on the button to enable **Google Analytics**. Then, select the **Discover**
    player insights switch, and you will be prompted to press **Play** in your editor.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击按钮启用**Google Analytics**。然后，选择**Discover**玩家洞察开关，你将被提示按下编辑器中的**Play**。
- en: Press **Play** in the editor, and let the game run for only a few seconds.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中按下**Play**，让游戏运行几秒钟。
- en: 'Return to the Services window and the Analytics page, and at the top, you should
    see a button called **Go to Dashboard**. Click on the button, as shown in the
    following screenshot:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到服务窗口和Analytics页面，在顶部，你应该看到一个叫做**Go to Dashboard**的按钮。点击该按钮，如下图所示：
- en: '![](img/bb50c421-7aaf-490f-b646-481a2653da5c.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb50c421-7aaf-490f-b646-481a2653da5c.png)'
- en: Exploring your data using the dashboard
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 使用仪表板探索你的数据
- en: This will open your default web browser to your project analytics page, and
    you should see some events, such as **appStart** and **appStop**.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开你的默认网页浏览器，带你到你的项目分析页面，你应该能看到一些事件，如**appStart**和**appStop**。
- en: That completes the setup of the analytics service, and, as you have seen, it
    is quite easy. However, as with everything, we need to customize some of the reporting
    data that we will send to the analytics service. You will learn how to send your
    own custom analytics in the next section.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了分析服务的设置，正如你所看到的，它其实非常简单。然而，像所有事情一样，我们需要自定义一些我们将要发送到分析服务的数据。你将在下一节学习如何发送你自己的自定义分析。
- en: Sending custom analytics
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送自定义分析
- en: If you have used the analytics service previously, you may have your own best
    practices for how to track your game usage; if so, feel free to use that. The
    method that we will present here is intended as a start for how you can go about
    setting up and sending custom analytics for training, or even for tracking player
    usage.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前使用过分析服务，你可能已经有了自己追踪游戏使用情况的最佳实践；如果是这样，随时可以使用这些方法。我们在这里展示的方法是作为起点，帮助你设置并发送自定义分析数据用于训练，或者用于跟踪玩家使用情况。
- en: 'Let''s begin by opening the Unity editor and following the next exercise:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始，打开Unity编辑器并进行下一个练习：
- en: Create a new C# script called `TestingAnalytics` in the `HoDLG` `Scripts` folder.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HoDLG`的`Scripts`文件夹中创建一个名为`TestingAnalytics`的新C#脚本。
- en: 'Open and edit the `TestingAnalytics` script in your editor, and enter the following
    code:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开并编辑`TestingAnalytics`脚本，在编辑器中输入以下代码：
- en: '[PRE18]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: All this code does is collect the current position of the goals and how close
    they are to the agents. That is what we care about currently. Also, notice that
    we made this a **public property,** so that it can be called like a method, and
    not just a field. This will be important later on.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码所做的就是收集目标的当前位置以及它们与代理的接近程度。那是我们目前关心的内容。此外，注意我们将其设为**public property**，以便像方法一样调用，而不仅仅是一个字段。这在后面会很重要。
- en: Save the file and return to the editor. Confirm that there are no compiler errors.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并返回编辑器。确认没有编译错误。
- en: Create a new empty game object in the scene, and call it `TestingAnalytics`.
    Drag the new `TestingAnalytics` script on to the object to set it as a scene component.
    While the class is a singleton, we still want to add it as a dependency in the
    scene (essentially, as a reminder). However, there is another trick that we can
    also use to program prefabs.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中创建一个新的空游戏对象，并命名为 `TestingAnalytics`。将新的 `TestingAnalytics` 脚本拖到该对象上，将其设置为场景组件。虽然这个类是单例，但我们仍然希望将其作为场景的依赖项添加（本质上是作为一个提醒）。然而，我们还可以使用另一个技巧来编程预制体。
- en: Drag the **TestingAnalytics** object into the **HoDLG | Prefabs** folder. This
    will make the object a prefab, which is now accessible by all of the other prefabs.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **TestingAnalytics** 对象拖入 **HoDLG | Prefabs** 文件夹。这将使该对象成为预制体，其他所有预制体现在都可以访问它。
- en: Double-click on the **goal** prefab located in the **HoDLG | Prefabs** folder
    to open the object in its own mini editor.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 **HoDLG | Prefabs** 文件夹中的 **goal** 预制体，以在其自己的迷你编辑器中打开该对象。
- en: 'Use the **Add Component** button to add an **Analytics Event Tracker** component
    to the object and configure it, as shown in the following screenshot:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **添加组件** 按钮为对象添加 **Analytics Event Tracker** 组件并进行配置，如下图所示：
- en: '![](img/bd606824-cf59-4713-8e4a-ff3a3779be99.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd606824-cf59-4713-8e4a-ff3a3779be99.png)'
- en: Setting up the Analytics Event Tracker
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 设置分析事件跟踪器
- en: 'Configure the component as follows:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置组件如下：
- en: '**When**: Lifecycle'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**何时**：生命周期'
- en: '**Lifecycle Event**: On Destroy'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生命周期事件**：销毁时'
- en: '**Send Event:**'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发送事件：**'
- en: '**Name**: Goal Destroyed Event'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：目标摧毁事件'
- en: '**Parameters: 1/10:**'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数：1/10：**'
- en: '**Name**: Status'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：状态'
- en: '**Value**: Dynamic'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值**：动态'
- en: 'Object: TestingAnalytics (Prefab)'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象：TestingAnalytics（预制体）
- en: '**Method**: CurrentGameState'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**：CurrentGameState'
- en: Switch the scene back to the player mode by altering the Academy and Agent configuration.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过更改学院和代理配置，将场景切换回玩家模式。
- en: Save the scene and the project.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景和项目。
- en: Run the scene by pressing **Play**, and drive over a goal. As you hit the goal,
    check the **Analytics** dashboard and note how the event is tracked.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按 **播放** 运行场景，驾车经过一个目标。当你碰到目标时，查看 **Analytics** 仪表板并注意事件是如何被追踪的。
- en: At this stage, the analytics only report when a goal is destroyed, and they
    report how close each agent is to a goal. So, for one agent and three goals, they
    would report three distances when a goal was destroyed by driving over it or when
    the object was reset. By following these stats, you can generally view how each
    agent testing session is going overall, for better or for worse. Of course, you
    can add any manner of analytics that you want; it is easy to get carried away.
    Who knows; in the future, Unity may offer a self-testing platform driven by ML-Agents
    that provides testing analytics.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，分析数据只有在目标被摧毁时才会报告，并报告每个代理与目标的距离。因此，对于一个代理和三个目标，当目标被撞毁或物体重置时，它们会报告三个距离。通过这些统计数据，你可以大致了解每个代理测试会话的整体情况，不管是好是坏。当然，你可以添加任何你想要的分析数据；这很容易让人过度投入。谁知道呢；未来，Unity
    可能会提供一个由 ML-Agents 驱动的自测平台，提供测试分析数据。
- en: We are coming to the end of another chapter, and, of course, we are approaching
    your favorite section, Exercises.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 本章即将结束，当然，我们也接近你最喜欢的部分——练习。
- en: Exercises
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'The exercises in this chapter are a mix of working with ML-Agents and building
    your own testing analysis platform. As such, choose one or two exercises that
    make sense for you to complete on your own from the following list:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的练习是结合了使用 ML-Agents 和构建你自己的测试分析平台。因此，从下面的列表中选择一到两个你可以自己完成的练习：
- en: Configure the **TestingAgent** to use a different camera for its visual observation
    input.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 **TestingAgent** 使用不同的相机进行视觉观察输入。
- en: Enable **Curiosity Learning** on the agent's brain.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用代理大脑上的 **好奇心学习**。
- en: Set up the **TestingAgent** to control a different vehicle.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 **TestingAgent** 控制另一辆车。
- en: Set up the **TestingAgent** to run on another vehicle and let ML-Agents control
    both of the agents simultaneously.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 **TestingAgent** 在另一辆车上运行，让 ML-Agents 同时控制两个代理。
- en: Add additional tracking analytics custom events for the agents. Perhaps track
    the distance that the agent travels versus its lifetime. This will provide a speed
    factor that can also denote the agent's efficiency. An agent that hits a goal
    quicker will have a better speed factor.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为代理添加额外的追踪分析自定义事件。也许可以跟踪代理的移动距离与其生命周期的关系。这将提供一个速度因子，也能表示代理的效率。一个更快撞到目标的代理会有更好的速度因子。
- en: Enable online imitation learning by adding a second vehicle with a learning
    agent. If you need to, go back and review the setup of the tennis scene.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加带有学习代理的第二辆车，启用在线模仿学习。如果需要，回顾一下网球场景的设置。
- en: Set up the Academy to use curriculum learning. Perhaps allow the virtual goal
    deployment box to grow in size over training iterations (by 10%, or some other
    factor). This will allow the goals to disperse farther and make it more difficult
    for the agent to find.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置学院使用课程学习。也许允许虚拟目标部署框在训练迭代中增长（按10%或其他因素）。这将使目标分散更远，使得代理更难找到。
- en: Modify the visual observation input that the brains are using to `184` x `184`,
    the new standard, and see what effect this has on agent training.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改大脑使用的视觉观察输入为`184` x `184`，这是新的标准，看看这对代理训练有何影响。
- en: Modify the visual observation convolutional encoding network, as we did in [Chapter
    7](9b7b6ff8-8daa-42bd-a80f-a7379c37c011.xhtml), *Agents and the Environment*,
    to use more layers and/or different filtering.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改视觉观察卷积编码网络，就像我们在[第7章](9b7b6ff8-8daa-42bd-a80f-a7379c37c011.xhtml)中所做的那样，*Agents
    and the Environment*，使用更多层和/或不同的过滤器。
- en: Apply this testing framework to your own game. Be sure to also add the analytics,
    so that you can track training and player usage.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个测试框架应用到你自己的游戏中。确保也添加分析功能，以便跟踪培训和玩家使用情况。
- en: These exercises are more involved than those in the previous chapters, since
    this is a big and important chapter. In the next section, we will review what
    you learned and covered in this chapter.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习比前几章更复杂，因为这是一个重要的大章节。在下一节中，我们将回顾你在本章学到和涵盖的内容。
- en: Summary
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Of all the chapters in this book, this may be the most useful if you are in
    the process of developing your own game. Game testing is one of those things that
    requires so much time and attention, it has to be up for some form of automation.
    While it makes sense for DRL to work well in this area for almost any game, it
    remains to be seen whether that is one of the niches for this new learning phenomena.
    One thing that's for sure, however, is that ML-Agents is more than capable of
    working as a testing harness, and we are sure that it will only get better over
    time.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的所有章节中，如果你正在开发自己的游戏，这可能是最有用的章节之一。游戏测试是需要大量时间和注意力的事情，必须部分自动化。虽然深度强化学习在几乎任何游戏中都表现良好是有意义的，但尚不清楚这是否是这种新学习现象的一个利基。然而，有一点可以肯定的是，ML-Agents完全可以作为一个测试工具，并且我们确信随着时间的推移它会变得更加出色。
- en: In this chapter, we looked at building a generic testing platform, powered by
    ML-Agents, that we can use to test any game automatically. We first looked at
    each of the components that we needed to adapt, the academy and the agent, and
    how they could be generalized for testing. Then, we looked at how we could inject
    into the Unity input system and use our `TestingAgent` to override the game's
    input and learn how to control it on its own. After that, we looked at how to
    better set up our testing by using offline IL and recording a demo file that we
    could use to train the agent later. Finally, in order to see how well our testing
    was doing, we added analytics and customized them to our needs.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了建立一个通用测试平台，由ML-Agents提供支持，可以自动测试任何游戏。我们首先看了我们需要调整的每个组件，学院和代理，以及它们如何被泛化用于测试。然后，我们看了如何注入到Unity输入系统中，并使用我们的`TestingAgent`来覆盖游戏的输入并学习如何独立控制它。之后，我们看了如何通过使用离线IL来更好地设置我们的测试，并记录一个演示文件，以便稍后用来训练代理。最后，为了查看我们的测试效果如何，我们添加了分析功能，并根据我们的需求进行了定制。
- en: The next chapter will be our final chapter and our last discussion of deep learning
    for games; appropriately enough, we will look at what the future holds for ML-Agents
    and DRL.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将是我们的最后一章，也是我们对游戏深度学习的最后讨论；适当地，我们将展望ML-Agents和DRL的未来。
