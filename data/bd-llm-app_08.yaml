- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Using LLMs with Structured Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LLMs与结构化数据
- en: 'In this chapter, we are going to cover yet another great capability of **large
    language models** (**LLMs**): the ability to handle structured, tabular data.
    We will see how, thanks to plugins and an agentic approach, we can use LLMs as
    a natural language interface between us and our structured data, reducing the
    gap between the business user and the structured information.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍大型语言模型（**LLMs**）的另一个出色功能：处理结构化、表格数据的能力。我们将看到，得益于插件和代理方法，我们如何可以使用LLMs作为我们与结构化数据之间的自然语言界面，缩小业务用户与结构化信息之间的差距。
- en: 'During this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to the main structured data systems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要结构化数据系统的介绍
- en: Using tools and plugins to connect LLMs to tabular data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工具和插件将LLMs连接到表格数据
- en: Building a database copilot with LangChain
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LangChain构建数据库助手
- en: By the end of this chapter, you will be able to build your own natural language
    interface for your data estate and be able to combine unstructured with structured
    sources.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够为你的数据资产构建自己的自然语言界面，并且能够将非结构化数据与结构化数据源相结合。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete the tasks in this chapter, you will need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的任务，你需要以下内容：
- en: A Hugging Face account and user access token.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Hugging Face账户和用户访问令牌。
- en: An OpenAI account and user access token.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个OpenAI账户和用户访问令牌。
- en: Python 3.7.1 or later version.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.7.1或更高版本。
- en: 'Python packages: Make sure to have the following Python packages installed:
    `langchain`, `python-dotenv`, `huggingface_hub`, `streamlit`, and `sqlite3`. Those
    can be easily installed via `pip install` in your terminal.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python包：请确保已安装以下Python包：`langchain`、`python-dotenv`、`huggingface_hub`、`streamlit`和`sqlite3`。这些包可以通过在终端中运行`pip
    install`轻松安装。
- en: You can find all the code and examples in the book’s GitHub repository at [https://github.com/PacktPublishing/Building-LLM-Powered-Applications](Chapter_08.xhtml).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的GitHub存储库中找到所有代码和示例：[https://github.com/PacktPublishing/Building-LLM-Powered-Applications](Chapter_08.xhtml)。
- en: What is structured data?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是结构化数据？
- en: In previous chapters, we focused on how LLMs can handle textual data. In fact,
    those models are, as the name suggests, “language” models, meaning that they have
    been trained and are able to handle unstructured text data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们关注了LLMs如何处理文本数据。实际上，这些模型正如其名所示，是“语言”模型，这意味着它们已经被训练并且能够处理非结构化文本数据。
- en: 'Nevertheless, unstructured data only refers to a portion of the overall data
    realm that applications can handle. Generally, data can be categorized into three
    types, which are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，非结构化数据仅指应用程序可以处理的整体数据领域的一部分。通常，数据可以分为三种类型，如下所示：
- en: '**Unstructured data**: This refers to data that doesn’t have a specific or
    predefined format. It lacks a consistent structure, making it challenging to organize
    and analyze using traditional databases. Examples of unstructured data include:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非结构化数据**：这指的是没有特定或预定义格式的数据。它缺乏一致的结构，使得使用传统数据库进行组织和分析变得具有挑战性。非结构化数据的例子包括：'
- en: 'Text documents: Emails, social media posts, articles, and reports.'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本文档：电子邮件、社交媒体帖子、文章和报告。
- en: 'Multimedia: Images, videos, audio recordings.'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多媒体：图像、视频、音频记录。
- en: 'Natural language text: Chat logs, transcriptions of spoken conversations.'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自然语言文本：聊天记录、口头对话的转录。
- en: 'Binary data: Files without a specific data format, such as proprietary file
    formats.'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制数据：没有特定数据格式的文件，例如专有文件格式。
- en: '**Note**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: When it comes to storing unstructured data, NoSQL databases play a crucial role,
    due to their flexible schema-less design, which allows them to handle various
    data types like text, images, and videos efficiently. The term “NoSQL” originally
    stood for “non-SQL” or “not only SQL” to emphasize that these databases don’t
    rely solely on the traditional **Structured Query Language** (**SQL**) to manage
    and query data. NoSQL databases emerged as a response to the limitations of relational
    databases, particularly their rigid schema requirements and difficulties in scaling
    horizontally.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到存储非结构化数据时，由于它们的灵活的无模式设计，NoSQL数据库在处理各种数据类型（如文本、图像和视频）方面发挥着至关重要的作用。术语“NoSQL”最初代表“非SQL”或“不仅SQL”，以强调这些数据库不依赖于传统的**结构化查询语言（SQL**）来管理和查询数据。NoSQL数据库的出现是对关系型数据库局限性的回应，特别是它们严格的模式要求以及横向扩展的困难。
- en: An example of a NoSQL database is MongoDB, a document-oriented NoSQL database,
    which stores data in JSON-like documents, making it highly effective for managing
    diverse unstructured content; similarly, Cassandra, with its wide-column store
    model, excels at handling large volumes of data across many commodity servers,
    providing high availability without compromising performance. This flexibility
    enables NoSQL databases to adapt to the volume, variety, and velocity of unstructured
    data, accommodating rapid changes and scaling easily. Traditional relational databases,
    with their rigid schema requirements, struggle to manage such diversity and volume
    efficiently.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个NoSQL数据库的例子是MongoDB，这是一个面向文档的NoSQL数据库，以类似JSON的文档形式存储数据，这使得它非常有效地管理多样化的非结构化内容；同样，Cassandra以其宽列存储模型而闻名，擅长处理大量数据，在许多通用服务器上提供高可用性而不影响性能。这种灵活性使得NoSQL数据库能够适应非结构化数据的量、种类和速度，适应快速变化并易于扩展。传统的基于关系的数据库，由于其严格的模式要求，难以有效地管理这种多样性和大量数据。
- en: '**Structured data**: This type of data is organized and formatted with a clear
    structure, typically into rows and columns. It follows a fixed schema, making
    it easy to store, retrieve, and analyze using relational databases. Examples of
    structured data include:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构化数据**：这种类型的数据是有组织和格式化的，通常以行和列的形式。它遵循固定的模式，使得使用关系数据库存储、检索和分析变得容易。结构化数据的例子包括：'
- en: 'Relational databases: Data stored in tables with predefined columns and data
    types.'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系数据库：存储在具有预定义列和数据类型的表中的数据。
- en: 'Spreadsheets: Data organized in rows and columns in software like Microsoft
    Excel.'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子表格：在Microsoft Excel等软件中以行和列组织的数据。
- en: 'Sensor data: Recorded measurements like temperature, pressure, and time in
    a structured format.'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传感器数据：以结构化格式记录的测量值，如温度、压力和时间。
- en: 'Financial data: Transaction records, balance sheets, and income statements.'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 财务数据：交易记录、资产负债表和损益表。
- en: '**Semi-structured data**: This falls between the two categories. While it doesn’t
    adhere to a rigid structure like structured data, it has some level of organization
    and may contain tags or other markers that provide context. Examples of semi-structured
    data include:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半结构化数据**：它介于这两者之间。虽然它不像结构化数据那样遵循严格的格式，但它具有一定的组织性，可能包含提供上下文的标签或其他标记。半结构化数据的例子包括：'
- en: '**eXtensible Markup Language** (**XML**) files: They use tags to structure
    data, but the specific tags and their arrangement can vary.'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展标记语言**（**XML**）文件：它们使用标签来结构化数据，但具体的标签及其排列可能不同。'
- en: '**JavaScript Object Notation** (**JSON**): This is used for data interchange
    and allows for nested structures and key-value pairs.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaScript对象表示法**（**JSON**）：用于数据交换，允许嵌套结构和键值对。'
- en: 'NoSQL databases: Storing data in a format that doesn’t require a fixed schema,
    allowing for flexibility.'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: NoSQL数据库：以不要求固定模式的方式存储数据，允许灵活性。
- en: In summary, unstructured data lacks a defined format, structured data follows
    a strict format, and semi-structured data has some level of structure but is more
    flexible than structured data. The distinction between these types of data is
    important as it impacts how they are stored, processed, and analyzed in various
    applications.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，非结构化数据缺乏定义明确的格式，结构化数据遵循严格的格式，而半结构化数据具有一定的结构，但比结构化数据更灵活。这些数据类型之间的区别很重要，因为它影响它们在各种应用中的存储、处理和分析方式。
- en: However, regardless of its nature, querying structured data involves using a
    query language or methods specific to that database technology. For example, for
    SQL databases, SQL is used to interact with relational databases. Henceforth,
    to extract data from tables, you need to know this specific language.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，无论其性质如何，查询结构化数据都需要使用特定的查询语言或数据库技术的方法。例如，对于SQL数据库，使用SQL与关系数据库交互。因此，要从表中提取数据，你需要了解这种特定语言。
- en: 'But what if we want to ask questions in natural language to our structured
    data? What if our application could provide us not only with a sterile numeric
    answer but rather with a conversational answer, which also gives us context about
    the number? This is exactly what we will try to achieve in the next sections with
    our LLM-powered applications. More specifically, we are going build something
    that we’ve already defined in *Chapter 2*: a **copilot**. Since we are going to
    mount our copilot to a relational database, we will name our application **DBCopilot**.
    First, let’s look at what relational databases are.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们想用自然语言向我们的结构化数据提问呢？如果我们的应用程序不仅能提供枯燥的数字答案，还能提供对话式的答案，并给出关于数字的背景信息呢？这正是我们将在下一节中尝试实现的内容，使用我们基于LLM的应用程序。更具体地说，我们将构建在*第二章*中已经定义的东西：一个**副驾驶**。由于我们将我们的副驾驶安装到关系型数据库中，我们将我们的应用程序命名为**DBCopilot**。首先，让我们看看什么是关系型数据库。
- en: Getting started with relational databases
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始学习关系型数据库
- en: The concept of relational databases was first proposed by E.F. Codd, an IBM
    researcher, in 1970\. He defined the rules and principles of the relational model,
    which aimed to provide a simple and consistent way of accessing and manipulating
    data. He also introduced SQL, which became the standard language for querying
    and manipulating relational databases. Relational databases have become widely
    used in various domains and applications, such as e-commerce, inventory management,
    payroll, **customer relationship management** (**CRM**), and **business intelligence**
    (**BI**).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库的概念最早由IBM研究员E.F. Codd在1970年提出。他定义了关系模型的规则和原则，旨在提供一种简单一致的方式来访问和操作数据。他还引入了SQL，它成为查询和操作关系型数据库的标准语言。关系型数据库在各种领域和应用中得到了广泛的使用，如电子商务、库存管理、工资单、**客户关系管理**（CRM）和**商业智能**（BI）。
- en: In this section, we are going to cover the main aspects of a relational database.
    Then, we will start working with the sample database we will use in our DBCopilot,
    the Chinook database. We will inspect this database and explore how to connect
    to remote tables using Python.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍关系型数据库的主要方面。然后，我们将开始使用我们将在DBCopilot中使用的示例数据库——Chinook数据库。我们将检查这个数据库，并探索如何使用Python连接到远程表。
- en: Introduction to relational databases
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系型数据库简介
- en: A relational database is a type of database that stores and organizes data in
    structured tables with rows and columns. Each row represents a record, and each
    column represents a field or attribute. The relationships between tables are established
    through keys, primarily the primary key and foreign key. This allows for efficient
    querying and manipulation of data using SQL. These databases are commonly used
    for various applications like websites and business management systems, due to
    their ability to manage structured data effectively.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库是一种将数据存储和组织在结构化表格中的数据库，表格由行和列组成。每一行代表一条记录，每一列代表一个字段或属性。表之间的关系通过键来建立，主要是主键和外键。这允许使用SQL进行高效的数据查询和操作。这些数据库因其能够有效管理结构化数据的能力，常用于各种应用，如网站和业务管理系统。
- en: 'To have a better understanding of relational databases, let’s consider an example
    of a database of a library. We’ll have two tables: one for books and another for
    authors. The relationship between them will be established using primary and foreign
    keys.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解关系型数据库，让我们考虑一个图书馆数据库的例子。我们将有两个表：一个用于书籍，另一个用于作者。它们之间的关系将通过主键和外键来建立。
- en: '**Definition**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义**'
- en: A primary key is like the unique fingerprint of each record in a table. It’s
    a special column that holds a value that’s distinct for each row in that table.
    Think of it as the “identity” of a record. Having a primary key is important because
    it guarantees that no two records in the same table will share the same key. This
    uniqueness makes it easy to locate, modify, and manage individual records in the
    table.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 主键就像表中每条记录的独特指纹。它是一个特殊的列，包含一个对表中每一行都是唯一的值。将其视为记录的“身份”。拥有主键很重要，因为它保证了同一表中不会有两条记录共享相同的键。这种唯一性使得在表中定位、修改和管理单个记录变得容易。
- en: A foreign key is a bridge between two tables. It’s a column in one table that
    references the primary key column in another table. This reference creates a link
    between the data in the two tables, establishing a relationship. The purpose of
    the foreign key is to maintain data consistency and integrity across related tables.
    It ensures that if a change is made in the primary key table, the related data
    in the other table remains accurate. By using foreign keys, you can retrieve information
    from multiple tables that are connected, enabling you to understand how different
    pieces of data are related to each other.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 外键是两张表之间的桥梁。它是一个表中的列，引用另一个表中的主键列。这种引用在两个表的数据之间创建了一个链接，建立了关系。外键的目的是在相关表之间维护数据的一致性和完整性。它确保如果主键表中的数据发生变化，其他表中的相关数据仍然准确。通过使用外键，您可以检索多个连接的表中的信息，从而了解不同的数据片段是如何相互关联的。
- en: 'Let’s take a closer look at our example, as shown in the following image:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看以下图像中的示例：
- en: '![A screenshot of a computer  Description automatically generated](img/B21714_08_01.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成](img/B21714_08_01.png)'
- en: 'Figure 8.1: An example of the relationship between two tables in a database'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：数据库中两张表之间关系的一个示例
- en: In this example, the Authors table contains information about authors, including
    their ID, name, and birth year. The Books table includes details about books,
    including the book’s ID, title, and a foreign key called AuthorID, which references
    the corresponding author in the Authors table (with AuthorID as the primary key).
    This way, you can use SQL queries to retrieve information like finding all books
    written by a specific author or the birth year of an author based on the book
    they wrote. The relational structure allows for efficient management and retrieval
    of data in a structured manner.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，Authors表包含有关作者的信息，包括他们的ID、姓名和出生年份。Books表包含有关书籍的详细信息，包括书籍的ID、标题以及一个名为AuthorID的外键，它引用Authors表中的相应作者（其中AuthorID作为主键）。这样，您可以使用SQL查询检索信息，例如查找特定作者所写的所有书籍或根据作者所写的书籍确定作者的出生年份。这种关系型结构允许以结构化的方式高效地管理和检索数据。
- en: 'Some of the main database systems in the market include:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上的一些主要数据库系统包括：
- en: '**SQL databases**: These are **relational database management systems** (**RDBMS**)
    that use SQL for data manipulation and querying. Examples include MySQL, PostgreSQL,
    and Microsoft SQL Server.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQL数据库**：这些是使用SQL进行数据操作和查询的**关系型数据库管理系统（RDBMS**）。例如MySQL、PostgreSQL和Microsoft
    SQL Server。'
- en: '**Oracle Database**: A widely-used RDBMS that offers advanced features and
    scalability for large-scale applications.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Oracle数据库**：一种广泛使用的RDBMS，为大型应用提供高级功能和可扩展性。'
- en: '**SQLite:** A self-contained, serverless, and zero-configuration SQL database
    engine commonly used in embedded systems and mobile applications.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQLite**：一个自包含、无服务器、零配置的SQL数据库引擎，通常用于嵌入式系统和移动应用程序。'
- en: '**IBM Db2**: A family of data management products, including relational database
    servers, developed by IBM.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IBM Db2**：由IBM开发的一系列数据管理产品，包括关系型数据库服务器。'
- en: '**Amazon Web Services (AWS) RDS**: A managed relational database service offered
    by Amazon, providing options for various databases like MySQL, PostgreSQL, SQL
    Server, and more.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**亚马逊云服务 (AWS) RDS**：由亚马逊提供的一种托管关系型数据库服务，提供MySQL、PostgreSQL、SQL Server等多种数据库选项。'
- en: '**Google Cloud SQL**: A managed database service by Google Cloud Platform,
    supporting MySQL, PostgreSQL, and SQL Server.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**谷歌云平台云SQL**：由谷歌云平台提供的一种托管数据库服务，支持MySQL、PostgreSQL和SQL Server。'
- en: '**Redis**: An open-source, in-memory data structure store that can be used
    as a database, cache, and message broker.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Redis**：一个开源的内存数据结构存储，可以用作数据库、缓存和消息代理。'
- en: In this chapter, we are going to use SQLite database, which also offers a seamless
    integration with Python. But before we do that, let’s understand the database
    we’ll be using.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用SQLite数据库，它还提供了与Python的无缝集成。但在我们这样做之前，让我们了解我们将要使用的数据库。
- en: Overview of the Chinook database
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Chinook数据库概述
- en: The Chinook database is a sample database that can be used for learning and
    practicing SQL. It is based on a fictional digital media store and contains data
    about artists, albums, tracks, customers, invoices, and more. The Chinook database
    is available for various database management systems, such as SQL Server, Oracle,
    MySQL, PostgreSQL, SQLite, and DB2.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Chinook数据库是一个用于学习和练习SQL的示例数据库。它基于一个虚构的数字媒体商店，包含艺术家、专辑、曲目、客户、发票等数据。Chinook数据库适用于各种数据库管理系统，如SQL
    Server、Oracle、MySQL、PostgreSQL、SQLite和DB2。
- en: 'Here are some features of this database:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个数据库的一些特性：
- en: It uses real data from an iTunes library, which makes it more realistic and
    interesting.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用iTunes库中的真实数据，这使得它更加真实和有趣。
- en: It has a clear and simple data model, which makes it easy to understand and
    query.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个清晰简单的数据模型，这使得理解和查询变得容易。
- en: It covers more features of SQL, such as subqueries, joins, views, and triggers.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它涵盖了SQL的更多特性，如子查询、连接、视图和触发器。
- en: It is compatible with multiple database servers, which makes it more versatile
    and portable.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与多个数据库服务器兼容，这使得它更加灵活和便携。
- en: You can find the configuration instructions at [https://database.guide/2-sample-databases-sqlite/](https://database.guide/2-sample-databases-sqlite/).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://database.guide/2-sample-databases-sqlite/](https://database.guide/2-sample-databases-sqlite/)找到配置说明。
- en: 'You can see an illustration of the relationship among the database’s tables
    here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里看到数据库表之间关系的示意图：
- en: '![A screenshot of a computer  Description automatically generated](img/B21714_08_02.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成](img/B21714_08_02.png)'
- en: 'Figure 8.2: Diagram of Chinook Database (source: [https://github.com/arjunchndr/Analyzing-Chinook-Database-using-SQL-and-Python](https://github.com/arjunchndr/Analyzing-Chinook-Database-using-SQL-and-Python))'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：Chinook数据库图（来源：[https://github.com/arjunchndr/Analyzing-Chinook-Database-using-SQL-and-Python](https://github.com/arjunchndr/Analyzing-Chinook-Database-using-SQL-and-Python)）
- en: As you can see, there are 11 tables, all related to each other with primary
    and foreign keys. In the upcoming paragraph, we will see how LLMs will be able
    to navigate among those tables, capturing their relationships and gathering relevant
    information. But before jumping to LLMs, let’s first inspect the Chinook database
    a bit more by setting up the connection with Python.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有11个表，它们通过主键和外键相互关联。在接下来的段落中，我们将看到LLMs将如何在这些表之间导航，捕捉它们的关系并收集相关信息。但在跳到LLMs之前，让我们首先通过Python设置连接来更详细地检查Chinook数据库。
- en: How to work with relational databases in Python
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在Python中处理关系型数据库
- en: 'To work with relational databases in Python, you need to use a library that
    can connect to the database and execute SQL queries. Some of these libraries are
    as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Python中处理关系型数据库，您需要使用一个可以连接到数据库并执行SQL查询的库。以下是一些这些库的例子：
- en: '`SQLAlchemy`: This is an open-source SQL toolkit and **object-relational mapper**
    (**ORM**) for Python. It allows you to create, read, update, and delete data from
    relational databases using Python objects and methods. It supports many database
    engines, such as SQLite, MySQL, PostgreSQL, and Oracle.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SQLAlchemy`: 这是一个开源的SQL工具包和Python的**对象关系映射器**（**ORM**）。它允许您使用Python对象和方法从关系型数据库中创建、读取、更新和删除数据。它支持许多数据库引擎，例如SQLite、MySQL、PostgreSQL和Oracle。'
- en: '`Psycopg`: This is a popular database connector for PostgreSQL. It enables
    you to execute SQL queries and access PostgreSQL features from Python. It is fast,
    reliable, and thread-safe.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Psycopg`: 这是一个流行的PostgreSQL数据库连接器。它允许您从Python执行SQL查询并访问PostgreSQL功能。它是快速、可靠且线程安全的。'
- en: '`MySQLdb`: This is a database connector for MySQL. It allows you to interact
    with MySQL databases from Python using the DB-API 2.0 specification. It is one
    of the oldest and most widely used Python libraries for MySQL, but its development
    is mostly frozen.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MySQLdb`: 这是一个MySQL的数据库连接器。它允许您使用DB-API 2.0规范从Python与MySQL数据库交互。它是Python中最古老且最广泛使用的MySQL库之一，但其开发主要已冻结。'
- en: '`cx_Oracle`: This is a database connector for Oracle Database. It enables you
    to connect to Oracle databases and use SQL and PL/SQL features from Python. It
    supports advanced features such as object types, **Large Objects** (**LOBs**),
    and arrays.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cx_Oracle`: 这是一个Oracle数据库的数据库连接器。它使您能够从Python连接到Oracle数据库并使用SQL和PL/SQL功能。它支持高级功能，如对象类型、**大型对象**（**LOBs**）和数组。'
- en: '`sqlite3`: This is a database connector for SQLite3, a widely used, lightweight,
    serverless, self-contained, and open-source relational database management system.
    You can use sqlite3 to create, query, update, and delete data from `SQLite` databases
    in your Python programs'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite3`：这是一个SQLite3数据库连接器，SQLite3是一个广泛使用、轻量级、无服务器、自包含和开源的关系型数据库管理系统。您可以使用sqlite3在Python程序中创建、查询、更新和删除`SQLite`数据库中的数据'
- en: 'Since we are going to work with SQLite, we will use the `sqlite3` module, which
    you will need to install via `pip install sqlite3`. Some of the features of sqlite3
    are as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用SQLite，我们将使用`sqlite3`模块，您需要通过`pip install sqlite3`来安装它。sqlite3的一些功能如下：
- en: It follows the DB-API 2.0 specification, which defines a standard interface
    for Python database access modules.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它遵循DB-API 2.0规范，该规范定义了Python数据库访问模块的标准接口。
- en: It supports transactions, which allow you to execute multiple SQL statements
    as a single unit of work and roll back in case of errors.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持事务，这允许您将多个SQL语句作为一个工作单元执行，并在出错时回滚。
- en: It allows you to use Python objects as parameters and results for SQL queries,
    using various adapters and converters.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许您使用Python对象作为SQL查询的参数和结果，使用各种适配器和转换器。
- en: It supports user-defined functions, aggregates, collations, and authorizers,
    which enable you to extend the functionality of SQLite with Python code.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持用户定义的函数、聚合、排序规则和授权者，这使您能够使用Python代码扩展SQLite的功能。
- en: It has a built-in row factory, which returns query results as named tuples or
    dictionaries instead of plain tuples.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个内置的行工厂，它将查询结果作为命名元组或字典返回，而不是普通的元组。
- en: 'Let’s see an example of this connection using our Chinook database:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用我们的Chinook数据库的此连接的一个例子：
- en: 'The database can be downloaded locally from [https://www.sqlitetutorial.net/wp-content/uploads/2018/03/chinook.zip](https://www.sqlitetutorial.net/wp-content/uploads/2018/03/chinook.zip).
    You will only need to unzip the `chinook.db` file and it will be ready to be consumed.
    In the following code, we are initializing a connection (`conn`) to our `chinook.db`,
    which will be used to interact with the database. Then, we will save our tables
    in a pandas object with the `read_sql` module, which allows you to run SQL queries
    against your database:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库可以从[https://www.sqlitetutorial.net/wp-content/uploads/2018/03/chinook.zip](https://www.sqlitetutorial.net/wp-content/uploads/2018/03/chinook.zip)本地下载。您只需解压`chinook.db`文件，它就准备好被使用了。在下面的代码中，我们正在初始化一个连接（`conn`）到我们的`chinook.db`，这将用于与数据库交互。然后，我们将使用`read_sql`模块将我们的表保存到一个pandas对象中，该模块允许您对数据库运行SQL查询：
- en: '[PRE0]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the output that we can see:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们可以看到的输出：
- en: '![A screenshot of a black screen  Description automatically generated](img/B21714_08_03.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![黑屏的截图 自动生成的描述](img/B21714_08_03.png)'
- en: 'Figure 8.3: A list of tables within the Chinook database'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：Chinook数据库中的表列表
- en: '**Note**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'Column names might be slightly different as the online database is updated
    over time. To get up-to-date columns’ naming conventions, you can run the following
    command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列名可能会略有不同，因为在线数据库会随着时间的推移而更新。要获取最新的列命名约定，您可以运行以下命令：
- en: '[PRE1]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can also inspect the single table to gather some relevant data. For example,
    let’s say we want to see the top five countries per album sales:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以检查单个表以收集一些相关数据。例如，假设我们想查看按专辑销量排名前五的国家：
- en: '[PRE2]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is the corresponding output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相应的输出：
- en: '![A screenshot of a cellphone  Description automatically generated](img/B21714_08_04.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![手机的截图 自动生成的描述](img/B21714_08_04.png)'
- en: 'Figure 8.4: Top 5 countries with highest sales'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：销量最高的前5个国家
- en: 'Finally, we can also use the `matplotlib` Python library to create useful diagrams
    about the database’s statistics. In the following Python snippet, we are going
    to run an SQL query to extract the number of tracks grouped by genre, and then
    plot the result using `matplotlib` as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们还可以使用`matplotlib` Python库创建有关数据库统计的有用图表。在下面的Python代码片段中，我们将运行一个SQL查询以提取按流派分组的曲目数量，然后使用`matplotlib`进行如下绘图：
- en: '[PRE3]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We’ll see the following output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到以下输出：
- en: '![A graph of tracks with blue bars  Description automatically generated](img/B21714_08_05.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![带有蓝色条的曲目图表 自动生成的描述](img/B21714_08_05.png)'
- en: 'Figure 8.5: Number of tracks by genre'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：按流派划分的曲目数量
- en: As you can see, in order to gather relevant information from our database, we
    used the syntax of SQL. Our goal is to gather information by simply asking in
    natural language, and we are going to do so starting in the next section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，为了从我们的数据库中收集相关信息，我们使用了 SQL 的语法。我们的目标是简单地通过自然语言提问来收集信息，我们将在下一节开始这样做。
- en: Implementing the DBCopilot with LangChain
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 LangChain 实现 DBCopilot
- en: In this section, we are going to cover the architecture and implementation steps
    behind a DBCopilot application, a natural language interface to chat with database-structured
    data. In the upcoming sections, we will explore how to achieve that by leveraging
    a powerful LangChain component called SQL Agent.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍 DBCopilot 应用程序背后的架构和实现步骤，这是一个与数据库结构化数据进行聊天的自然语言界面。在接下来的章节中，我们将探讨如何利用一个名为
    SQL Agent 的强大 LangChain 组件来实现这一点。
- en: LangChain agents and SQL Agent
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LangChain 代理和 SQL 代理
- en: In *Chapter 4*, we introduced the concept of LangChain agents, defining them
    as entities that drive decision making within LLM-powered applications.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 4 章* 中，我们介绍了 LangChain 代理的概念，将其定义为在 LLM 驱动的应用程序中驱动决策的实体。
- en: Agents have access to a suite of tools and can decide which tool to call based
    on the user input and the context. Agents are dynamic and adaptive, meaning that
    they can change or adjust their actions based on the situation or the goal.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 代理可以访问一系列工具，并根据用户输入和上下文决定调用哪个工具。代理是动态和自适应的，这意味着它们可以根据情况或目标改变或调整其行为。
- en: 'In this chapter, we will see agents in action, using the following LangChain
    components:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到代理的实际应用，使用以下 LangChain 组件：
- en: '`create_sql_agent`: An agent designed to interact with relational databases'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_sql_agent`: 一个设计用来与关系型数据库交互的代理'
- en: '`SQLDatabaseToolkit`: A toolkit to provide the agent with the required non-parametric
    knowledge'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SQLDatabaseToolkit`: 一个工具包，为代理提供所需的非参数化知识'
- en: '`OpenAI`: An LLM to act as the reasoning engine behind the agent, as well as
    the generative engine to produce conversational results'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OpenAI`: 一个 LLM，作为代理背后的推理引擎，以及生成对话结果的生成引擎'
- en: 'Let’s start with our implementation by following these steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下步骤开始我们的实现：
- en: 'We’ll first initialize all the components and establish the connection to the
    Chinook database, using the `SQLDatabase` LangChain component (which uses `SQLAlchemy`
    under the hood and is used to connect to our database):'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先初始化所有组件，并使用 `SQLDatabase` LangChain 组件（底层使用 `SQLAlchemy` 并用于连接我们的数据库）建立与
    Chinook 数据库的连接：
- en: '[PRE4]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Before running the agent, let’s first inspect its available tools:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行代理之前，让我们首先检查其可用的工具：
- en: '[PRE5]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is the output:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Those tools have the following capabilities:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具具有以下功能：
- en: '`sql_db_query`: This takes as input a detailed and correct SQL query, and it
    outputs a result from the database. If the query is not correct, an error message
    will be returned.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sql_db_query`: 这个函数接受一个详细且正确的 SQL 查询作为输入，并从数据库中输出结果。如果查询不正确，将返回错误信息。'
- en: '`sql_db_schema`: This takes as input a comma-separated list of tables, and
    it outputs the schema and sample rows for those tables.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sql_db_schema`: 这个函数接受一个以逗号分隔的表列表作为输入，并输出这些表的架构和样本行。'
- en: '`sql_db_list_tables`: This takes as input an empty string, and it outputs a
    comma-separated list of tables in the database.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sql_db_list_tables`: 这个函数接受一个空字符串作为输入，并输出数据库中表的逗号分隔列表。'
- en: '`sql_db_query_checker`: This tool double-checks whether the query is correct
    before executing it.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sql_db_query_checker`: 这个工具在执行查询之前会再次检查查询是否正确。'
- en: 'Let’s now execute our agent with a simple query to describe the `playlisttrack`
    table:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们用一个简单的查询来描述 `playlisttrack` 表来执行我们的代理：
- en: '[PRE7]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following output is then obtained (the output is truncated – you can find
    the full output in the book’s GitHub repository):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的输出结果如下（输出已截断 - 您可以在书籍的 GitHub 仓库中找到完整输出）：
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, with a simple question in natural language, our agent was able
    to understand its semantics, translate it into an SQL query, extract the relevant
    information, and use it as context to generate the response.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过一个简单的自然语言问题，我们的代理能够理解其语义，将其翻译成 SQL 查询，提取相关信息，并将其用作上下文来生成响应。
- en: 'But how was it able to do all of that? Under the hood, the SQL agent comes
    with a default prompt template, which makes it tailored to this type of activity.
    Let’s see the default template of the LangChain component:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 但它是如何做到这一切的？在底层，SQL 代理自带一个默认的提示模板，这使得它适合这种活动。让我们看看 LangChain 组件的默认模板：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is the output obtained:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是获得的输出：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Thanks to this prompt template, the agent is able to use the proper tools and
    generate a SQL query, without modifying the underlying database (you can see the
    explicit rule not to run any **data manipulation language** (**DML**) statements).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这个提示模板，代理能够使用适当的工具并生成SQL查询，而不会修改底层数据库（你可以看到明确的规则，即不要运行任何**数据操作语言**（**DML**）语句）。
- en: '**Definition**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义**'
- en: 'DML is a class of SQL statements that are used to query, edit, add, and delete
    row-level data from database tables or views. The main DML statements are as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: DML是一类SQL语句，用于查询、编辑、添加和从数据库表或视图中删除行级数据。主要的DML语句如下：
- en: '`SELECT`: This is used to retrieve data from one or more tables or views based
    on specified criteria.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT`：此操作用于根据指定的标准从一个或多个表或视图中检索数据。'
- en: '`INSERT`: This is used to insert new data records or rows into a table.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INSERT`：此操作用于向表中插入新的数据记录或行。'
- en: '`UPDATE`: This is used to modify the values of existing data records or rows
    in a table.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPDATE`：此操作用于修改表中现有数据记录或行的值。'
- en: '`DELETE`: This is used to remove one or more data records or rows from a table.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：此操作用于从表中删除一个或多个数据记录或行。'
- en: '`MERGE`: This is used to combine the data from two tables into one based on
    a common column.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MERGE`：此操作用于根据公共列将两个表中的数据合并到一个表中。'
- en: DML statements are used to store, modify, retrieve, delete, and update data
    in a database.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DML语句用于在数据库中存储、修改、检索、删除和更新数据。
- en: 'We can also see how the agent is able to correlate more than one table within
    the database:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到代理如何在数据库中关联多个表：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'From the first lines of the chain, you can see that `Action Input` invokes
    two tables – track and genre:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从链的第一行中，你可以看到`Action Input`调用了两个表——track和genre：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following is the output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为输出结果：
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, the question is as follows: are we sure that we are getting the proper
    result? A nice way to double-check this would be to print the SQL query that the
    agent ran against the database. To do so, we can modify the default prompt to
    ask the agent to explicitly show us the reasoning behind its result.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题是这样的：我们是否确定得到了正确的结果？一个很好的双重检查方法是打印出代理对数据库运行的SQL查询。为此，我们可以修改默认提示，要求代理明确显示其结果的推理过程。
- en: Prompt engineering
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提示工程
- en: As we saw in the previous chapter, pre-built LangChain agents and chains come
    with default prompts, which make it easier to tailor them toward their goals.
    Nevertheless, we can customize that prompt and pass it as a parameter to our component.
    For example, let’s say that we want our SQL agent to print the SQL query it used
    to return the result.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，预构建的LangChain代理和链带有默认提示，这使得它们更容易针对其目标进行定制。尽管如此，我们仍然可以自定义该提示并将其作为参数传递给我们的组件。例如，假设我们希望我们的SQL代理打印出它用来返回结果的SQL查询。
- en: First of all, we have to understand which kind of prompt chunks the SQL Agent
    is able to take as parameters. To do so, we can simply inspect the objects running
    `create_sql_agent`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须理解SQL代理能够接受哪些类型的提示块作为参数。为此，我们可以简单地检查运行`create_sql_agent`的对象。
- en: '![](img/B21714_08_06.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21714_08_06.png)'
- en: 'Figure 8.6: A screenshot of the description of the SQL agent'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：SQL代理描述的截图
- en: 'The Agent takes a prompt prefix and a format instruction, which are merged
    and constitute the default prompt we inspected in the previous section. To make
    our agent more self-explanatory, we will create two variables, `prefix` and `format_instructions`,
    which will be passed as parameters and that slightly modify the default prompt
    as follows (you can find the whole prompts in the GitHub repository at [https://github.com/PacktPublishing/Building-LLM-Powered-Applications](Chapter_08.xhtml):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 代理接受一个提示前缀和一个格式指令，这两个指令合并构成了我们在上一节中检查的默认提示。为了使我们的代理更具自解释性，我们将创建两个变量，`prefix`和`format_instructions`，这两个变量将作为参数传递，并略微修改默认提示如下（你可以在GitHub仓库中找到整个提示，网址为[https://github.com/PacktPublishing/Building-LLM-Powered-Applications](Chapter_08.xhtml)）：
- en: 'We have the `prompt_prefix`, which is already configured as follows:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有`prompt_prefix`，它已经配置如下：
- en: '[PRE14]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To this, we will add the following line of instruction:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将添加以下指令行：
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In `prompt_format_instructions`, we will add the following example of explanation
    using few-shot learning, which we covered in *Chapter 1*:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`prompt_format_instructions`中，我们将添加一个使用少量学习（我们在*第1章*中讨论过）的说明示例：
- en: '[PRE16]sql'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE16]sql'
- en: SELECT c.country AS Country, SUM(i.total) AS Sales
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SELECT c.country AS Country, SUM(i.total) AS Sales
- en: FROM customer c
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: FROM customer c
- en: JOIN invoice i ON c.customer_id = i.customer_id
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: JOIN 客户 c ON c.customer_id = i.customer_id
- en: GROUP BY Country
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: GROUP BY 国家
- en: ORDER BY Sales DESC
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ORDER BY 销售额 DESC
- en: LIMIT 5;
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: LIMIT 5;
- en: '[PRE17]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let’s pass those prompt chunks as parameters to our agent and print the
    result (I will omit the whole chain here, but you can see it in the GitHub repository):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这些提示块作为参数传递给我们的代理并打印结果（这里省略整个链，但您可以在GitHub仓库中看到它）：
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is the obtained output:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是获取到的输出：
- en: '[PRE19]sql'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE19]sql'
- en: SELECT al.title AS Album, ar.name AS Artist, SUM(i.total) AS Sales
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT al.title AS 专辑, ar.name AS 艺术家, SUM(i.total) AS 销售额
- en: FROM album al
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: FROM 专辑 al
- en: JOIN invoice i ON al.album_id = i.invoice_id
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: JOIN 发票 i ON al.album_id = i.invoice_id
- en: JOIN artist ar ON al.artist_id = ar.artist_id
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: JOIN 艺术家 ar ON al.artist_id = ar.artist_id
- en: GROUP BY ar.name
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: GROUP BY ar.name
- en: ORDER BY Sales
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ORDER BY 销售额
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: from  langchain_experimental.tools.python.tool import PythonREPLTool
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: from  langchain_experimental.tools.python.tool import PythonREPLTool
- en: from  langchain_experimental.python import PythonREPL
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: from  langchain_experimental.python import PythonREPL
- en: from langchain.agents.agent_toolkits import FileManagementToolkit
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: from langchain.agents.agent_toolkits import FileManagementToolkit
- en: working_directory  = os.getcwd()
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: working_directory  = os.getcwd()
- en: tools = FileManagementToolkit(
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: tools = FileManagementToolkit(
- en: root_dir=str(working_directory),
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: root_dir=str(working_directory),
- en: selected_tools=["read_file", "write_file", "list_directory"],).get_tools()
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: selected_tools=["read_file", "write_file", "list_directory"],).get_tools()
- en: tools.append(
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: tools.append(
- en: PythonREPLTool())
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: PythonREPLTool())
- en: tools.extend(SQLDatabaseToolkit(db=db, llm=llm).get_tools())
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: tools.extend(SQLDatabaseToolkit(db=db, llm=llm).get_tools())
- en: '[PRE21]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: from langchain.chat_models import ChatOpenAI
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: from langchain.chat_models import ChatOpenAI
- en: from langchain.agents import initialize_agent, Tool
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: from langchain.agents import initialize_agent, Tool
- en: from langchain.agents import AgentType
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: from langchain.agents import AgentType
- en: model = ChatOpenAI()
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: model = ChatOpenAI()
- en: agent = initialize_agent(
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: agent = initialize_agent(
- en: tools, model, agent= AgentType.STRUCTURED_CHAT_ZERO_SHOT_REACT_DESCRIPTION,
    verbose=True
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: tools, model, agent= AgentType.STRUCTURED_CHAT_ZERO_SHOT_REACT_DESCRIPTION,
    verbose=True
- en: )
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: agent.run("generate a matplotlib bar chart of the top 5 countries for sales
    from the chinook database. Save the output in the current working directory as
    figure.png")
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: agent.run("从 chinook 数据库中生成销售额前5的国家matplotlib条形图。将输出保存到当前工作目录下的 figure.png 文件中")
- en: '[PRE22]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Entering new AgentExecutor chain...
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正在进入新的 AgentExecutor 链...
- en: 'Action:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'Action:'
- en: '[PRE23]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[…]'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[…]'
- en: 'Observation: [(''USA'', 10405.889999999912), (''Canada'', 5489.549999999994),
    (''Brazil'', 4058.999999999997), (''France'', 3972.869999999995), (''Germany'',
    3441.2399999999925)]'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 观察：[('USA', 10405.889999999912), ('Canada', 5489.549999999994), ('Brazil', 4058.999999999997),
    ('France', 3972.869999999995), ('Germany', 3441.2399999999925)]
- en: '[…]'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[…]'
- en: We have successfully retrieved the top 5 countries for sales. We can now use
    matplotlib to create a bar chart.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功检索到销售额前5的国家。现在我们可以使用matplotlib创建条形图。
- en: 'Action:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'Action:'
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[…]'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[…]'
- en: Finished chain.
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 完成链。
- en: '''Here is the bar chart of the top 5 countries for sales from the Chinook database.
    It has been saved as figure.png in the current working directory. '''
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '''这里是 Chinook 数据库中销售额前5的国家的条形图。它已保存为当前工作目录下的 figure.png 文件。'''
- en: '[PRE25]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: prompt_prefix = """ Your prefix here
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: prompt_prefix = """ Your prefix here
- en: '"""'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: prompt_format_instructions= """
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: prompt_format_instructions= """
- en: Your instructions here.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您的指示。
- en: '"""'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: agent = initialize_agent(tools, model, agent=AgentType.STRUCTURED_CHAT_ZERO_SHOT_REACT_DESCRIPTION,
    verbose = True,
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: agent = initialize_agent(tools, model, agent=AgentType.STRUCTURED_CHAT_ZERO_SHOT_REACT_DESCRIPTION,
    verbose = True,
- en: agent_kwargs={
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: agent_kwargs={
- en: '''prefix'':prompt_prefix,'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''prefix'':prompt_prefix,'
- en: '''format_instructions'': prompt_format_instructions })'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''format_instructions'': prompt_format_instructions })'
- en: '[PRE26]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: import streamlit as st
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: import streamlit as st
- en: st.set_page_config(page_title="DBCopilot", page_icon="![](img/Icon.png)")
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: st.set_page_config(page_title="DBCopilot", page_icon="![](img/Icon.png)")
- en: st.header('![](img/Icon.png) Welcome to DBCopilot, your copilot for structured
    databases.')
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: st.header('![](img/Icon.png) 欢迎来到 DBCopilot，您的结构化数据库助手。')
- en: '[PRE27]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: load_dotenv()
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: load_dotenv()
- en: '#os.environ["HUGGINGFACEHUB_API_TOKEN"]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#os.environ["HUGGINGFACEHUB_API_TOKEN"]'
- en: openai_api_key = os.environ['OPENAI_API_KEY']
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: openai_api_key = os.environ['OPENAI_API_KEY']
- en: db = SQLDatabase.from_uri('sqlite:///chinook.db')
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: db = SQLDatabase.from_uri('sqlite:///chinook.db')
- en: '[PRE28]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: llm = OpenAI()
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: llm = OpenAI()
- en: toolkit = SQLDatabaseToolkit(db=db, llm=llm)
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: toolkit = SQLDatabaseToolkit(db=db, llm=llm)
- en: '[PRE29]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: agent_executor = create_sql_agent(
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: agent_executor = create_sql_agent(
- en: prefix=prompt_prefix,
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: prefix=prompt_prefix,
- en: format_instructions = prompt_format_instructions,
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: format_instructions = prompt_format_instructions,
- en: llm=llm,
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: llm=llm,
- en: toolkit=toolkit,
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: toolkit=toolkit,
- en: verbose=True,
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: verbose=True,
- en: top_k=10
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: top_k=10
- en: )
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: '[PRE30]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'if "messages" not in st.session_state or st.sidebar.button("Clear message history"):'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if "messages" not in st.session_state or st.sidebar.button("Clear message history"):'
- en: 'st.session_state["messages"] = [{"role": "assistant", "content": "How can I
    help you?"}]'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'st.session_state["messages"] = [{"role": "assistant", "content": "我能帮您什么忙？"}]'
- en: 'for msg in st.session_state.messages:'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'for msg in st.session_state.messages:'
- en: st.chat_message(msg["role"]).write(msg["content"])
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: st.chat_message(msg["role"]).write(msg["content"])
- en: '[PRE31]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'if user_query:'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if user_query:'
- en: 'st.session_state.messages.append({"role": "user", "content": user_query})'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'st.session_state.messages.append({"role": "user", "content": user_query})'
- en: st.chat_message("user").write(user_query)
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: st.chat_message("user").write(user_query)
- en: 'with st.chat_message("assistant"):'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'with st.chat_message("assistant"):'
- en: st_cb = StreamlitCallbackHandler(st.container())
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: st_cb = StreamlitCallbackHandler(st.container())
- en: response = agent_executor.run(user_query, callbacks = [st_cb], handle_parsing_errors=True)
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: response = agent_executor.run(user_query, callbacks = [st_cb], handle_parsing_errors=True)
- en: 'st.session_state.messages.append({"role": "assistant", "content": response})'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'st.session_state.messages.append({"role": "assistant", "content": response})'
- en: st.write(response)
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: st.write(response)
- en: '```'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '```'
- en: 'You can run your application in the terminal with the `streamlit run copilot.py`
    command. The final web page looks as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`streamlit run copilot.py`命令在终端运行您的应用程序。最终的网页如下所示：
- en: '![A screenshot of a computer  Description automatically generated](img/B21714_08_08.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图 自动生成描述](img/B21714_08_08.png)'
- en: 'Figure 8.8: Screenshot of the front-end of DBCopilot'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：DBCopilot前端截图
- en: 'Thanks to the `StreamlitCallbackHandler` module, we can also expand each action
    the agent took, for example:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了`StreamlitCallbackHandler`模块，我们还可以扩展代理采取的每个动作，例如：
- en: '![A screenshot of a computer  Description automatically generated](img/B21714_08_09.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图 自动生成描述](img/B21714_08_09.png)'
- en: 'Figure 8.9: Illustration of the agent’s actions during the chain'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：代理在链中的动作示意图
- en: With just a few lines of code, we were able to set up a simple front-end for
    our DBCopilot with a conversational user interface.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 仅用几行代码，我们就能够为我们的DBCopilot设置一个简单的具有对话用户界面的前端。
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we saw how LLMs are not only capable of interacting with textual
    and unstructured data, but also with structured and numeric data. This is made
    possible because of two main elements: the natural capabilities of LLMs and, more
    generally, LFMs for understanding a problem’s statement, planning a resolution,
    and acting as reasoning engines, as well as a set of tools that extend LLMs’ capabilities
    with domain-specific skills.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了LLM不仅能够与文本和非结构化数据交互，还能够与结构化和数值数据交互。这是由于两个主要元素：LLM的自然能力和更普遍的LFMs，用于理解问题的陈述、规划解决方案以及作为推理引擎，以及一套工具，这些工具通过特定领域的技能扩展了LLM的能力。
- en: In this case, we mainly relied upon LangChain’s SQL Database toolkit, which
    connects the Agent to an SQL database with a curated prompt. Furthermore, we extended
    the Agent’s capabilities even further, making it able to generate matplotlib graphs,
    with the Python REPL tool, and save the output to our local file system with the
    File Management tool.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们主要依赖于LangChain的SQL数据库工具包，它通过精心设计的提示将代理连接到SQL数据库。此外，我们还进一步扩展了代理的功能，使其能够使用Python
    REPL工具生成matplotlib图表，并使用文件管理工具将输出保存到我们的本地文件系统。
- en: In the next chapter, we are going to delve even deeper into the analytical capabilities
    of LLMs. More specifically, we are going to cover their capabilities of working
    with code.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨LLM的分析能力。更具体地说，我们将介绍它们处理代码的能力。
- en: References
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Chinook Database: [https://github.com/lerocha/chinook-database/tree/master/ChinookDatabase/DataSources](https://github.com/lerocha/chinook-database/tree/master/ChinookDatabase/DataSources)'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chinook数据库：[https://github.com/lerocha/chinook-database/tree/master/ChinookDatabase/DataSources](https://github.com/lerocha/chinook-database/tree/master/ChinookDatabase/DataSources)
- en: 'LangChain File system tool: [https://python.langchain.com/docs/integrations/tools/filesystem](https://python.langchain.com/docs/integrations/tools/filesystem)'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LangChain文件系统工具：[https://python.langchain.com/docs/integrations/tools/filesystem](https://python.langchain.com/docs/integrations/tools/filesystem)
- en: 'LangChain Python REPL tool: [https://python.langchain.com/docs/integrations/toolkits/python](https://python.langchain.com/docs/integrations/toolkits/python)'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LangChain Python REPL工具：[https://python.langchain.com/docs/integrations/toolkits/python](https://python.langchain.com/docs/integrations/toolkits/python)
- en: Join our community on Discord
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/llm](https://packt.link/llm )'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/llm](https://packt.link/llm )'
- en: '![](img/QR_Code214329708533108046.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code214329708533108046.png)'
