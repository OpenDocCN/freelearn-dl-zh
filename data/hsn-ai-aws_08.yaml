- en: Building a Voice Chatbot with Amazon Lex
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Amazon Lex 构建语音聊天机器人
- en: In this chapter, we will build a chatbot that allows the user to search for
    information and perform actions using voice or text conversations. This chatbot
    offers a more intuitive interface for humans to interact with computers. We will
    use Amazon Lex to build a custom AI capability to understand requests in natural
    language, to ask for missing inputs, and to fulfill tasks. We will provide guidance
    on the Amazon Lex development paradigm, including its conventions and norms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个聊天机器人，允许用户通过语音或文本对话搜索信息并执行操作。这个聊天机器人为人类与计算机的交互提供了更直观的界面。我们将使用 Amazon
    Lex 构建一个自定义的 AI 能力，理解自然语言中的请求，询问缺失的输入，并完成任务。我们将提供有关 Amazon Lex 开发范式的指导，包括其惯例和规范。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Building conversational interfaces with Amazon Lex
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Amazon Lex 构建对话式界面
- en: Implementing task fulfillment logics with AWS Lambda
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AWS Lambda 实现任务完成逻辑
- en: Adding a RESTful API in front of Amazon Lex custom AI capability
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Amazon Lex 自定义 AI 能力前添加 RESTful API
- en: Discussing design concerns for conversational interfaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论对话式界面的设计问题
- en: Understanding the friendly human-computer interface
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解友好的人与计算机界面
- en: The intelligent personal assistant, sometimes called the **chatbot**, is rapidly
    appearing in more and more products with which we interact. The most prominent
    of these products are smart speakers, such as Amazon Echo and Google Home. Interacting
    with machines using your voice used to be the stuff of science fiction. Nowadays,
    fun facts and jokes are just an *Alexa* or *Hey Google* away. The tasks we can
    ask these intelligent assistants to perform include media control, information
    search, home automation, and administrative tasks, such as emails, to-dos, and
    reminders.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 智能个人助手，有时被称为**聊天机器人**，正在迅速出现在我们互动的越来越多的产品中。其中最显著的产品是智能音响，如 Amazon Echo 和 Google
    Home。用声音与机器互动曾经是科幻小说中的情节，如今，只需要对着 *Alexa* 或 *Hey Google* 说几句话，就能获得趣味事实和笑话。我们可以让这些智能助手执行的任务包括媒体控制、信息搜索、家庭自动化以及行政任务，如电子邮件、待办事项和提醒。
- en: 'The capability of the intelligent personal assistant can be integrated into
    many more types of devices and platforms than just smart speakers. These include
    mobile operating systems such as Android and iOS, instant messaging apps such
    as Facebook Messenger, and company websites such as restaurants (to take orders)
    and banks (to check account balances). There are two main methods of interaction:
    through text or voice. This intelligent assistant capability is a combination
    of several AI technologies. For both interaction methods, **Natural Language Processing**
    (**NLP**) is needed to interpret and match the text to supported questions or
    commands. For voice interaction, speech-to-text and text-to-speech are needed
    to enable voice communication, which is something we have had hands-on experience
    with in Amazon Transcribe and Amazon Polly, respectively.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 智能个人助手的能力可以集成到比智能音响更多种类的设备和平台中。这些平台包括移动操作系统，如 Android 和 iOS；即时通讯应用，如 Facebook
    Messenger；以及公司网站，如餐厅（接收订单）和银行（查询账户余额）。有两种主要的互动方式：通过文本或语音。这种智能助手能力是多种 AI 技术的结合。对于两种互动方式，都需要**自然语言处理**（**NLP**）来解释并匹配文本与支持的问题或命令。对于语音交互，则需要语音转文本和文本转语音技术，分别由
    Amazon Transcribe 和 Amazon Polly 提供，这也是我们已经亲自体验过的技术。
- en: It may appear that these intelligent assistants are performing tasks such as
    getting answers to questions, placing orders, and automating our homes. But behind
    the scenes, these tasks are almost always fulfilled by traditional APIs and services.
    What we actually get with the intelligent assistant capability is a more flexible
    human-computer interface. Leveraging this new capability is not simply slapping
    a fancy voice interface on top of an existing application. When designing intelligent
    assistants, it's important to understand the use cases and operating environments
    where the intelligent assistant can provide a better user experience. Not all
    applications should have such interfaces; for example, use cases requiring precise
    inputs or dense outputs, noisy operating environments, and workflows that are
    long and complex.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些智能助手可能看起来像是在执行诸如回答问题、下订单和自动化家庭的任务。但在幕后，这些任务几乎总是由传统的API和服务完成的。我们通过智能助手能力获得的，实际上是一个更灵活的人机接口。利用这一新能力并不仅仅是将一个华丽的语音界面加在现有应用程序上。在设计智能助手时，理解智能助手可以提供更好用户体验的使用场景和操作环境非常重要。并非所有应用程序都应该具备这样的界面；例如，要求精确输入或密集输出、噪音环境和长时间复杂的工作流程等使用场景。
- en: In this chapter, we will be implementing an intelligent assistant, called Contact
    Assistant, for searching contact information. The contact assistant will work
    with the same contact data store we created for the contact organizer project
    in [Chapter 5](cffd245d-bee7-40bc-a64f-e108c039a8ec.xhtml), *Extracting Information
    from Text with Amazon Comprehend*. We will also add a RESTful API in front of
    the contact assistant, giving us multiple applications to leverage its capabilities.
    The way this intelligent assistant is designed makes it most useful out in the
    field, for example, when a traveling salesman is driving to a client and needs
    to get the client's contact information verbally. Instead of performing the searches
    through a web application running in a browser, this use case is better suited
    to be a mobile application with a driver-friendly user interface. This mobile
    application and its user interface are beyond the scope of this book, but may
    turn out to be interesting hands-on projects for some of you.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现一个智能助手，称为“联系助手”，用于搜索联系信息。该联系助手将与我们在[第5章](cffd245d-bee7-40bc-a64f-e108c039a8ec.xhtml)中为联系组织者项目创建的相同联系数据存储一起工作，*通过Amazon
    Comprehend提取文本中的信息*。我们还将在联系助手前端添加一个RESTful API，使我们能够通过多个应用程序利用其功能。这个智能助手的设计方式使其在实际场景中非常有用，例如，当一位外地销售人员正在开车前往客户，并需要口头获取客户的联系信息时。与通过浏览器运行的Web应用程序进行搜索不同，这种使用场景更适合开发一个具有驾驶员友好用户界面的移动应用程序。虽然本书的范围不涉及该移动应用程序及其用户界面，但它可能会成为一些人有趣的动手项目。
- en: Contact assistant architecture
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联系助手架构
- en: 'The architecture for the contact assistant project includes the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 联系助手项目的架构包括以下内容：
- en: An orchestration layer
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编排层
- en: A service implementation layer
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务实现层
- en: 'The following architecture does not include the user interface layer, since
    we will not be implementing the mobile or web application that connects to the
    contact assistant. Instead, we will be focusing our efforts on developing a custom
    AI capability, an intelligent assistant bot, using the Amazon Lex platform. Let''s
    have a look at a screenshot of the following architecture:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下架构不包括用户界面层，因为我们不会实现连接到联系助手的移动或Web应用程序。相反，我们将重点开发一个自定义AI能力，一个智能助手机器人，使用Amazon
    Lex平台。让我们来看一下以下架构的截图：
- en: '![](img/591fce9b-cdb7-4636-b130-7bd852ac3ff9.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/591fce9b-cdb7-4636-b130-7bd852ac3ff9.png)'
- en: 'The contact assistant architecture includes the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 联系助手架构包括以下内容：
- en: In the orchestration layer, we will build a **Contact Assistant Endpoint** that
    provides a RESTful interface to access our contact assistant's capabilities.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编排层中，我们将构建一个**联系助手端点**，为访问我们联系助手的功能提供RESTful接口。
- en: In the service implementation layer, we will build a service, called the **intelligent
    assistant service**, that shields implementation details of our custom AI capability,
    including its Amazon Lex implementation details. This way, when we want to reimplement
    the contact assistant bot with a different chatbot technology, only the intelligent
    assistant service needs to be modified.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务实现层，我们将构建一个名为**智能助手服务**的服务，来屏蔽我们自定义 AI 能力的实现细节，包括其 Amazon Lex 实现细节。这样，当我们想用不同的聊天机器人技术重新实现联系人助手机器人时，只需要修改智能助手服务。
- en: In previous chapters, we built our own services, such as Recognition Service
    and Speech Service, that connect to AWS AI capabilities such as Rekognition and
    Polly, respectively. Just like these services are shielding implementation details
    of the AWS AI services, the intelligent assistant service is shielding implementation
    details of our custom AI capability built on top of Amazon Lex.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们构建了自己的服务，例如识别服务和语音服务，分别连接到 AWS AI 能力，如 Rekognition 和 Polly。就像这些服务屏蔽了
    AWS AI 服务的实现细节一样，智能助手服务也屏蔽了我们基于 Amazon Lex 构建的自定义 AI 能力的实现细节。
- en: The contact assistant bot will be able to perform two tasks, `LookupPhoneNumberByName`
    and `MakePhoneCallByName`. This bot leverages Amazon Lex's underlying AI capabilities
    to interpret the user's verbal commands, and then performs the tasks using AWS
    Lambda functions. These Lambda functions implement the fulfillment of the tasks,
    looking up phone numbers and making phone calls.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联系人助手机器人将能够执行两个任务，`LookupPhoneNumberByName` 和 `MakePhoneCallByName`。这个机器人利用
    Amazon Lex 的底层 AI 能力来解释用户的口头命令，然后使用 AWS Lambda 函数执行任务，查找电话号码并拨打电话。
- en: Contact Assistant will be looking up contact information stored in the same
    DynamoDB table that we used in [Chapter 5](https://cdp.packtpub.com/hands_on_artificial_intelligence_on_amazon_web_services/wp-admin/post.php?post=527&action=edit#post_301),
    *Extracting Information from Text with Amazon Comprehend*, in the contact organizer
    application. In the spirit of reuse, we will be reusing the contact store implementation
    that connects to the DynamoDB table. More specifically, the Lambda functions will
    delegate the contact searches to the contact store. The fact that the contact
    information is stored in a DynamoDB table is transparent to the contact assistant.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联系人助手将查找存储在与[第 5 章](https://cdp.packtpub.com/hands_on_artificial_intelligence_on_amazon_web_services/wp-admin/post.php?post=527&action=edit#post_301)《*使用
    Amazon Comprehend 提取文本信息*》中相同的 DynamoDB 表中的联系人信息。在复用的精神下，我们将重新使用连接到 DynamoDB 表的联系人存储实现。更具体地说，Lambda
    函数将把联系人搜索委托给联系人存储。联系人信息存储在 DynamoDB 表中的事实对联系人助手是透明的。
- en: Understanding the Amazon Lex development paradigm
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Amazon Lex 开发范式
- en: Amazon Lex is a development platform for building intelligent assistants or
    chatbots. With Amazon Lex, we are building our own custom intelligent assistant
    capabilities. Lex itself provides many AI capabilities, including **Automatic
    Speech Recognition** (**ASR**) and **Natural Language Understanding** (**NLU**),
    that are useful for building conversational interfaces. However, developers must
    follow Lex's development constructs, conventions, and norms to leverage these
    underlying AI capabilities.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon Lex 是一个用于构建智能助手或聊天机器人的开发平台。通过 Amazon Lex，我们正在构建自己的自定义智能助手能力。Lex 本身提供了许多
    AI 能力，包括**自动语音识别**（**ASR**）和**自然语言理解**（**NLU**），这些能力对于构建对话界面非常有用。然而，开发人员必须遵循 Lex
    的开发构造、约定和规范，才能利用这些底层的 AI 能力。
- en: 'These Amazon Lex conversational interfaces are built from Lex''s specific building
    blocks:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 Amazon Lex 对话界面是由 Lex 特定的构建模块构建的：
- en: '**Bot**: A Lex bot can perform a set of related tasks through the custom conversational
    interfaces. A bot organizes the related tasks into a unit for development, deployment,
    and execution.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机器人**：Lex 机器人可以通过自定义的对话界面执行一组相关任务。一个机器人将相关任务组织成一个单元，以便于开发、部署和执行。'
- en: For example, to make the tasks available to the applications, they are deployed
    or published as a bot and the application must specify the bot name in order to
    access the available tasks.
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，为了让任务对应用程序可用，任务会被部署或发布为一个机器人，应用程序必须指定机器人名称才能访问可用的任务。
- en: '**Intent**: An intent represents an automated task the users want to perform.
    An intent belongs to a specific AWS account rather than a specific bot and can
    be used by different bots in the same AWS account. This design decision makes
    them more reusable.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**意图**：意图表示用户希望执行的自动化任务。意图属于特定的 AWS 账户，而不是特定的机器人，可以被同一 AWS 账户中的不同机器人使用。这个设计决策使得意图更具可重用性。'
- en: '**Sample utterance**: An utterance is a typed or spoken phrase in natural language
    that the user might say to invoke an automated task. Amazon Lex encourages developers
    to provide multiple utterances to make the conversational interface more flexible
    for the users.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例话语**：话语是用户可能用来触发自动化任务的自然语言输入，无论是键入还是说出。Amazon Lex 鼓励开发者提供多个话语，以使对话界面对用户更加灵活。'
- en: For example, a user might either say *What's the weather like today?*, or *Tell
    me about the weather today?* to check the weather report. Amazon Lex uses advanced
    NLU to understand the intent of the user.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，用户可能会说*今天的天气怎么样？*，或者*告诉我今天的天气？*来查询天气报告。Amazon Lex 使用先进的自然语言理解（NLU）来理解用户的意图。
- en: Given the previous two sample utterances, Amazon Lex also uses the NLU capability
    to handle variations of the utterances. Lex can understand *Tell me what the weather's
    like today?* even if the exact phrase is not provided.
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据前面两个示例话语，Amazon Lex 还利用 NLU 功能处理话语的变化。即使没有提供完全相同的表达方式，Lex 也能理解*告诉我今天的天气怎么样？*。
- en: '**Slot**: An automated task may require zero or more slots (parameters) to
    complete. For example, the date and the location are parameters used to fetch
    the weather report the user is interested in. In the conversational interface,
    Lex asks the user to provide all of the required slots.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**槽位**：自动化任务可能需要零个或多个槽位（参数）来完成。例如，日期和地点是获取用户感兴趣的天气报告时使用的参数。在对话界面中，Lex 会要求用户提供所有必需的槽位。'
- en: For example, the location can be defaulted to the user's home address if not
    specified.
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，如果未指定位置，可以默认使用用户的家庭地址。
- en: '**Slot type**: Each slot has a type. Similar to a parameter type in programming
    languages, a slot type restricts input space and simplifies verification to make
    the conversational interface more user friendly. In verbal communication in particular,
    knowing the types of slots can help the AI technologies more accurately determine
    the typed or spoken texts.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**槽位类型**：每个槽位都有一个类型。类似于编程语言中的参数类型，槽位类型限制了输入空间并简化了验证，从而使对话界面更加用户友好。特别是在口语交流中，了解槽位类型可以帮助
    AI 技术更准确地判断输入的文本或语音。'
- en: There are numerous built-in slot types, such as Number, City, Airport, Language,
    and Musician, to name but a few. Developers can also create custom slot types
    specific to their applications.
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多内置的槽位类型，例如数字、城市、机场、语言和音乐家，仅举几例。开发者还可以创建特定于其应用程序的自定义槽位类型。
- en: '**Prompt and response**: A prompt is a question in which Lex asks the users
    to either provide input to a slot, or to confirm the input provided. A response
    is a message to inform the user about the result of the task, such as the weather
    report.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提示和响应**：提示是 Lex 向用户提问，要求用户提供某个槽位的输入或确认已提供的输入。响应是向用户告知任务结果的消息，例如天气报告。'
- en: The design of prompts and responses for conversational interfaces should take
    into account the use case, communication modality (text or speech), and the operating
    environment. The design should get user confirmation while not overburdening users
    with unnecessary communication.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对话界面的提示和响应设计应考虑使用场景、通信方式（文本或语音）和操作环境。设计应在不让用户感到负担的情况下获取用户确认。
- en: '**Session attributes**: Amazon Lex provides mechanisms to keep contextual data
    that can be shared across intents in the same session.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话属性**：Amazon Lex 提供机制来保持上下文数据，这些数据可以在同一会话中的不同意图之间共享。'
- en: For example, if a user just asked for the weather report for a city and then
    follows up with a question, *How's the traffic there?*, the session context should
    be able to infer that *there* means the city reference in the previous intent.
    This type of contextual information can be stored in Lex's session attributes
    for developers to build smarter bots.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，如果用户只请求了某个城市的天气报告，然后又提出问题*那里的交通怎么样？*，会话上下文应该能够推断出*那里*是指先前意图中提到的城市。此类上下文信息可以存储在
    Lex 的会话属性中，供开发者构建更智能的机器人。
- en: 'The Amazon Lex platform focuses on building conversational interfaces; fulfillment
    of the automated tasks is delegated to AWS Lambda. There are two built-in hook
    types for developers to integrate lambda functions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon Lex 平台专注于构建对话接口；自动任务的执行则委托给 AWS Lambda。开发者可以使用两种内置的钩子类型来集成 Lambda 函数：
- en: '**Lambda initialization and validation**: This hook allows developers to write
    AWS Lambda functions to validate the user inputs. For example, the lambda function
    can verify a user''s inputs from a data source and with more complex business
    logic.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lambda 初始化和验证**：此钩子允许开发者编写 AWS Lambda 函数来验证用户输入。例如，Lambda 函数可以验证用户的输入，检查数据源并执行更复杂的业务逻辑。'
- en: '**The fulfillment lambda function**: This hook allows developers to write AWS
    Lambda code that performs the task. With this lambda hook, developers can tap
    into AWS services, API endpoints, and much more to write the business logic for
    tasks such as checking the weather, ordering a pizza, and sending messages.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**履行 Lambda 函数**：此钩子允许开发者编写 AWS Lambda 代码来执行任务。通过这个 Lambda 钩子，开发者可以利用 AWS 服务、API
    端点等，编写用于检查天气、订购披萨、发送消息等任务的业务逻辑。'
- en: Setting up the contact assistant bot
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置联系助手机器人
- en: 'Now that we understand the Amazon Lex''s development paradigm and terminology,
    let''s put them to use by building a bot with both the conversational interface
    and the fulfillment business logic. We will be building the contact assistant
    using the AWS Console. Observe the following steps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了 Amazon Lex 的开发范式和术语，接下来我们将通过构建一个具有对话界面和业务逻辑实现的机器人来应用它们。我们将使用 AWS 控制台构建联系助手。请按照以下步骤操作：
- en: Navigate to the Amazon Lex page and click on the Create button.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航至 Amazon Lex 页面并点击“创建”按钮。
- en: On the Create your bot page, select Custom bot to create our own bot instead
    of building from a sample bot.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“创建你的机器人”页面，选择“自定义机器人”以创建我们自己的机器人，而不是从示例机器人开始。
- en: For the Bot name field, enter `ContactAssistant`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在机器人名称字段中，输入 `ContactAssistant`。
- en: For the Output voice, select Joanna. Currently, Lex only supports US English.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输出语音（Output voice）中，选择 Joanna。目前，Lex 仅支持美式英语。
- en: For the Session timeout, enter 5 min. This is the maximum idle time before the
    contact assistant closes a session.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在会话超时（Session timeout）字段中，输入 5 分钟。这是联系助手在关闭会话之前的最大空闲时间。
- en: For the IAM role, leave it as the default AWSServiceRoleForLexBots.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 IAM 角色，保持默认设置为 AWSServiceRoleForLexBots。
- en: Select No for COPPA; the contact assistant is designed for a traveling salesman,
    not children.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 COPPA 选择“否”；这个联系助手是为一位旅行推销员设计的，而不是为儿童设计的。
- en: Click on the Create button.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“创建”按钮。
- en: 'The Create your bot page should have the following settings after the preceding
    steps have been carried out:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成上述步骤后，“创建你的机器人”页面应具有以下设置：
- en: '![](img/21e9c9e0-a17f-45da-997a-94c55c901931.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21e9c9e0-a17f-45da-997a-94c55c901931.png)'
- en: 'Once the contact assistant has been created, you will be taken to the development
    console for Lex, similar to the one shown in the following screenshot:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦联系助手被创建，你将进入 Lex 的开发控制台，界面类似于下图所示：
- en: '![](img/acd2c4db-1656-478e-8eed-b95f5befab22.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/acd2c4db-1656-478e-8eed-b95f5befab22.png)'
- en: 'Let''s familiarize ourselves with the Lex development console:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先熟悉一下 Lex 开发控制台：
- en: The bot's name can be found in the top-left corner, Contact_Assistant.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 机器人的名称可以在左上角找到，命名为 Contact_Assistant。
- en: There are a pair of disabled buttons for Build and Publish in the top-right
    corner.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右上角有一对禁用的“构建”和“发布”按钮。
- en: Below the bot name and buttons are the tabs for Editor, Settings, Channels,
    and Monitoring screens. We will perform most of our bot development in the Editor
    tab.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在机器人名称和按钮下方是编辑器（Editor）、设置（Settings）、渠道（Channels）和监控（Monitoring）屏幕的标签。我们将在编辑器标签中进行大部分的机器人开发工作。
- en: With the Editor tab selected, we see that no Intents or Slot types have been
    added to the contact assistant.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选中编辑器标签后，我们看到联系助手中尚未添加任何意图（Intent）或槽类型（Slot types）。
- en: In the top-right corner of the screen, there is a Test bot sidebar that can
    be expanded (shown in the diagram) to reveal a chat interface. This chat interface
    is used to issue verbal commands to the bot under development. The chat interface
    is currently disabled. The bot needs to be built, with at least one intent created.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕的右上角，有一个可展开的“测试机器人”侧边栏（如图所示），展开后会显示一个聊天界面。该聊天界面用于向正在开发的机器人发出语音命令。目前，该聊天界面是禁用的，机器人需要先构建，并且至少创建一个意图（Intent）。
- en: Finally, Click on the Create Intent button to build our first intent.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击“创建意图”按钮来构建我们的第一个意图。
- en: The LookupPhoneNumberByName intent
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LookupPhoneNumberByName 意图
- en: Our first intent allows the user to look up a contact's phone number by stating
    the contact's first and last names. This intent is essentially a search feature
    built on top of the contact store, but with a conversational interface.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个意图允许用户通过说出联系人的名字和姓氏来查找该联系人的电话号码。这个意图本质上是一个构建在联系人存储之上的搜索功能，但它采用了对话式界面。
- en: We recommend designing each intent to focus on a narrow use case, and building
    up multiple intents to expand the bot's use cases.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议将每个意图设计为专注于一个狭窄的使用场景，并通过构建多个意图来扩展机器人的使用场景。
- en: The `LookupPhoneNumberByName` intent has very focused inputs and outputs, but
    we can build many related intents, such as `LookupAddressByName` and `LookupContactNamesByState`.
    Even though we can consider the `LookupPhoneNumberByName` intent as a search feature
    to a data source, it requires a different design thinking.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`LookupPhoneNumberByName` 意图有非常专注的输入和输出，但我们可以构建许多相关的意图，例如 `LookupAddressByName`
    和 `LookupContactNamesByState`。即使我们可以将 `LookupPhoneNumberByName` 意图视为对数据源的搜索功能，它仍然需要不同的设计思维。'
- en: 'Let''s highlight a few design differences when comparing this intent to a more
    conventional search feature on a web application:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在比较这个意图和更传统的网页应用搜索功能时，突出一些设计上的差异：
- en: In a web interface, we would provide the user with several search parameters,
    such as name, organization, and location. In a conversational interface, we would
    want to limit the number of search parameters, or inputs, for each intent. In
    a voice chatbot in particular, prompting and confirming all of the inputs might
    be cumbersome.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网页界面中，我们会提供多个搜索参数，例如姓名、组织和地点。在对话式界面中，我们希望每个意图的搜索参数或输入尽量少。尤其是在语音聊天机器人中，提示和确认所有输入可能会显得繁琐。
- en: In a web interface, we would return many pieces of information about the contact
    and display them on the screen. In a conversational interface, we need to consider
    the modality. If this is a text chatbot, we might be able to get away with displaying
    multiple pieces of information. But, if this is a voice chatbot, then reading
    a long list of information to the user might create a cognitive burden.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网页界面中，我们会返回关于联系人的许多信息并显示在屏幕上。在对话式界面中，我们需要考虑交互方式。如果这是一个文本聊天机器人，我们或许可以展示多条信息。但如果这是一个语音聊天机器人，那么向用户朗读大量信息可能会造成认知负担。
- en: Sample utterances and slots for LookupPhoneNumberByName
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`LookupPhoneNumberByName` 的示例话语和槽位'
- en: When designing a new intent, all stakeholders, not just developers, must carefully
    think through the conversational flow between the user and the bot. Let's start
    with the sample utterances.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计新的意图时，所有相关方——不仅仅是开发人员——必须仔细思考用户与机器人之间的对话流程。我们先从示例话语开始。
- en: The intelligent assistant is a likely replacement for existing communication
    channels to users, such as phone calls to customer representatives, inquiry emails
    for product issues, and text chats with technical agents. It's common practice
    to use recordings of user conversations from these existing channels to design
    the conversational flow of the intelligent assistant. These recordings provide
    the most accurate reflection of your users' interactions with the products; they
    are a good starting point for designing the utterances and the prompts.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 智能助手很可能会替代现有的用户沟通渠道，例如打电话给客户代表、发送产品问题咨询邮件以及与技术支持人员进行文本聊天。通常做法是使用来自这些现有渠道的用户对话录音来设计智能助手的对话流程。这些录音能最准确地反映用户与产品的互动，它们是设计话语和提示的良好起点。
- en: 'Sample utterances are phrases that invoke the intent to perform an automated
    task. Here are a few sample utterances for our `LookupPhoneNumberByName` intent:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 示例话语是调用意图以执行自动任务的短语。以下是我们 `LookupPhoneNumberByName` 意图的一些示例话语：
- en: '![](img/083c2cef-cd8d-4b05-b86c-e29d1b7ff0de.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/083c2cef-cd8d-4b05-b86c-e29d1b7ff0de.png)'
- en: As we can see in the preceding screenshot, two of the sample utterances naturally
    included slots or input parameters, {FirstName} and {LastName}, in the conversation
    flow. This way users can provide some or all of the inputs needed to fulfill the
    task when it is invoked.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在前面的截图中所见，两个示例话语自然地在对话流程中包含了槽位或输入参数 {FirstName} 和 {LastName}。这样，用户可以在触发任务时提供完成任务所需的部分或全部输入。
- en: 'For `LookupPhoneNumberByName`, we need both the {FirstName} and {LastName}
    to look up a phone number as they are both required. Let''s have a look at the
    following screenshot of slots:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`LookupPhoneNumberByName`，我们需要同时提供{FirstName}和{LastName}来查找电话号码，因为这两个都是必填项。我们来看一下以下的插槽截图：
- en: '![](img/76967ad7-b5f4-4041-b538-14cd4945d233.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76967ad7-b5f4-4041-b538-14cd4945d233.png)'
- en: As shown in the preceding screenshot, for the slot types, there are built-in
    AMAZON.US_FIRST_NAME and AMAZON.US_LAST_NAME types. As we noted previously, specifying
    the most relevant and specific types for the inputs makes natural language understanding
    and value validation much easier for the underlying AI technologies.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，对于插槽类型，有内置的AMAZON.US_FIRST_NAME和AMAZON.US_LAST_NAME类型。如前所述，为输入指定最相关和最具体的类型，可以大大简化自然语言理解和底层AI技术的值验证。
- en: What if the user did not provide the inputs to the slots? For example, what
    if the user spoke the first sample utterance, *I would like to look up a phone
    number*. Each slot must have one or more prompts to ask the user for the input
    value if it was not provided in the invoking utterance. For `{FirstName}` and
    `{LastName}`, we used `What's the contact's first name?` and `What's the {FirstName}'s
    last name?`, respectively. Notice that the prompt for `{LastName}` included the
    slot value for `{FirstName}`. This can make the conversation flow more natural
    and human-like.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户没有提供插槽的输入怎么办？例如，如果用户说了第一个样本话语，*我想查找一个电话号码*。每个插槽如果没有在调用话语中提供输入值，都必须有一个或多个提示来请求用户输入。对于`{FirstName}`和`{LastName}`，我们分别使用了`What's
    the contact's first name?`和`What's the {FirstName}'s last name?`。注意，`{LastName}`的提示中包含了`{FirstName}`的值。这可以让对话流程更加自然和人性化。
- en: 'To add more than one prompt for a slot, click on the gear icon to edit the
    slot''s settings. Here, you can add additional prompts, set the Maximum number
    of retries to elicit this input, and corresponding utterances, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 若要为插槽添加多个提示，请点击齿轮图标编辑插槽的设置。在这里，您可以添加其他提示，设置最大重试次数以获取此输入，并设置相应的表达式，如下所示：
- en: '![](img/a022eb63-88f9-415f-8a07-9f18b0f1c149.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a022eb63-88f9-415f-8a07-9f18b0f1c149.png)'
- en: The bot will select from this list of prompts to ask the user for the slot.
    The bot will attempt the prompts up to two times before giving up.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人将从这些提示中选择一个来请求用户输入插槽值。机器人会尝试这些提示最多两次，然后放弃。
- en: Confirmation prompt and response for LookupPhoneNumberByName
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LookupPhoneNumberByName的确认提示和响应
- en: To complete the conversational flow design, let's move on to the confirmation
    prompt and response. Both of these are optional, but they can greatly improve
    the behavior and user experience of the intelligent assistant.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成对话流程设计，让我们继续设计确认提示和响应。虽然这两者是可选的，但它们能极大地改善智能助手的行为和用户体验。
- en: 'The following is a screenshot of a confirmation prompt. A confirmation prompt
    is an opportunity to inform the user about the action about to be taken. At this
    point, values for all of the required slots and potentially optional slots have
    been elicited:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个确认提示的截图。确认提示是一个通知用户即将执行的操作的机会。此时，所有必填插槽和可能的可选插槽的值都已获取：
- en: '![](img/490f4b0f-bc09-4245-ae2c-316db9a0005a.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/490f4b0f-bc09-4245-ae2c-316db9a0005a.png)'
- en: 'We are able to use `{FirstName}` and `{LastName}` in the confirmation message.
    It''s a good design to read or display back the values for the `{FirstName}` and
    `{LastName}` slots; this confirms with the user that the bot understood the inputs
    correctly. Natural language conversations can be ambiguous at times. Let''s take
    a look at this example conversation:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在确认消息中使用`{FirstName}`和`{LastName}`。在确认消息中回显`{FirstName}`和`{LastName}`的值是一个很好的设计，它能够确认机器人正确理解了用户输入。自然语言对话有时会产生歧义。让我们来看一个示例对话：
- en: '![](img/34de4f55-b6d6-4fbc-9193-a053f19ec030.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34de4f55-b6d6-4fbc-9193-a053f19ec030.png)'
- en: Do you spot the issue? One of our sample utterances is What's {FirstName} {LastName}
    phone number. However, the user invoked the intent without providing a `{LastName}`.
    Our bot interpreted *what's* as the `{FirstName}`, and `John` as the `{LastName}`.
    By reading back the input values with the confirmation prompt, the user can notice
    and correct the input error before the action is taken.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你发现问题了吗？我们其中一个示例话语是What's {FirstName} {LastName} phone number。然而，用户在调用意图时没有提供`{LastName}`。我们的机器人将*what's*解释为`{FirstName}`，将`John`解释为`{LastName}`。通过在确认提示中回显输入值，用户可以注意到并纠正输入错误，然后再执行操作。
- en: 'We will skip fulfillment of the task for now and move on to the response. In
    the following screenshot, the response for the `LookupPhoneNumberByName` intent
    closes out the task by displaying or reading the phone number for the contact:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在跳过任务的 Fulfillment 部分，直接进入响应部分。在以下截图中，`LookupPhoneNumberByName` 意图通过显示或朗读联系人的电话号码来完成任务：
- en: '![](img/4109580b-2e25-4014-abb8-7b17302d4131.png)`[Phone]` is a session attribute
    that is holding the phone number for the contact. It will be set in the fulfillment
    lambda function. We will cover how that''s implemented later in the chapter.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/4109580b-2e25-4014-abb8-7b17302d4131.png)`[Phone]` 是一个会话属性，用于保存联系人的电话号码。它将在
    Fulfillment lambda 函数中设置。我们将在本章后续部分介绍其实现方式。'
- en: This intent is used to query for information. Providing the information in the
    response will feel natural to users. There are also intents that will perform
    a task without the need to provide information back to the users. In such cases,
    it is still a good idea to respond to the users of the outcome of the task.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该意图用于查询信息。提供响应中的信息将使用户感到自然。也有一些意图会执行任务，而无需向用户提供信息。在这种情况下，仍然建议向用户反馈任务的结果。
- en: Now, we have completed the conversational interface for our first intent. Next,
    we will implement the AWS Lambda function that will perform the task asked of
    our intelligent assistant.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了第一个意图的对话接口。接下来，我们将实现 AWS Lambda 函数，来执行智能助手所要求的任务。
- en: Fulfillment for LookupPhoneNumberByName using AWS Lambda
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AWS Lambda 执行 LookupPhoneNumberByName 的 Fulfillment
- en: To perform any fulfillment action with the intelligent assistant, developers
    need to invoke AWS Lambda functions. The *Fulfillment* section provides a hook
    to an existing lambda function. Let's implement a lambda function called **LookupPhoneNumberByName**
    to search for the phone number of a contact by his or her first and last names.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行与智能助手相关的任何完成操作，开发者需要调用 AWS Lambda 函数。*Fulfillment* 部分提供了一个钩子，用于现有的 lambda
    函数。让我们实现一个名为 **LookupPhoneNumberByName** 的 lambda 函数，通过联系人的名字和姓氏来查找其电话号码。
- en: 'In contrast to previous projects, where we used AWS Chalice to develop and
    deploy the lambda code and AWS permissions, we will be using the AWS Lambda console
    page to create the `LookupPhoneNumberByName` function. Here are the steps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前使用 AWS Chalice 开发和部署 lambda 代码以及 AWS 权限的项目不同，我们将使用 AWS Lambda 控制台页面来创建 `LookupPhoneNumberByName`
    函数。以下是步骤：
- en: Navigate to the AWS Lambda service from AWS Console, and then click on the Create
    function button.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 AWS 控制台导航到 AWS Lambda 服务，然后点击“创建函数”按钮。
- en: Select Author from scratch. We will implement the lambda function without any
    blueprints or sample applications.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“从头开始创建”。我们将不使用任何蓝图或示例应用来实现 lambda 函数。
- en: Name the function `LookupPhoneNumberByName`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将函数命名为 `LookupPhoneNumberByName`。
- en: Select the Python 3.7 runtime to match the language version for our other hands-on
    projects.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 Python 3.7 运行时，以匹配我们其他动手项目的语言版本。
- en: Choose Create a new role with basic Lambda permissions to create a role. We
    will need to add additional policies later to connect to additional AWS services.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“创建具有基本 Lambda 权限的新角色”来创建一个角色。稍后我们需要添加更多策略来连接其他 AWS 服务。
- en: Click the Create function button.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“创建函数”按钮。
- en: 'The settings on the Create function page should look similar to the following
    screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 创建函数页面上的设置应该类似于以下截图：
- en: '![](img/ef9490a5-90a4-40a7-ba82-b3e1870a3135.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef9490a5-90a4-40a7-ba82-b3e1870a3135.png)'
- en: 'After the lambda function and its execution role have been created, you will
    see a development console similar to this one:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 lambda 函数及其执行角色后，您将看到一个类似以下的开发控制台：
- en: '![](img/1e628f19-1f6a-4d78-bb33-78311efbafed.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e628f19-1f6a-4d78-bb33-78311efbafed.png)'
- en: 'The preceding screenshot demonstrates the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图演示了以下内容：
- en: In the Designer section, we can add triggers to invoke this lambda function.
    For Lex bots, we do not need to select a trigger.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设计器部分，我们可以添加触发器来调用这个 lambda 函数。对于 Lex 机器人，我们无需选择触发器。
- en: We also see that the `LookupPhoneNumberByName` function has access to CloudWatch
    logs. Any outputs or error messages from the execution of this function will be
    written to CloudWatch, and we can view those logs from the CloudWatch console
    page. This will be useful while developing and debugging the function.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还看到，`LookupPhoneNumberByName` 函数有权限访问 CloudWatch 日志。该函数执行过程中产生的任何输出或错误消息将写入
    CloudWatch，我们可以通过 CloudWatch 控制台页面查看这些日志。在开发和调试该函数时，这将非常有用。
- en: In the Function code section, we can choose Edit code inline, modify the function
    runtime, and change the Handler function name. The handler function specifies
    the Python file and function name that constitute the entry point to our lambda
    function.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数代码部分，我们可以选择“编辑代码内联”，修改函数运行时并更改 Handler 函数名称。Handler 函数指定了构成 Lambda 函数入口点的
    Python 文件和函数名。
- en: Beneath the three lambda configuration fields, we have the inline code editor.
    Here, we can create additional source files and edit the code for each source
    file.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在三个 Lambda 配置字段下方，我们有内联代码编辑器。在这里，我们可以创建额外的源文件并编辑每个源文件的代码。
- en: 'Our lambda function will need to interact with the same DynamoDB that stores
    the contact information from the contact organizer application. We can leverage
    the existing contact store and then add a new function to query for contact information
    with the help of the following steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Lambda 函数需要与存储来自联系人管理应用的联系人信息的相同 DynamoDB 进行交互。我们可以利用现有的联系人存储，然后添加一个新函数来查询联系人信息，步骤如下：
- en: Right-click within the left panel of the inline editor and then select New File.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内联编辑器的左侧面板中右键点击，然后选择“新建文件”。
- en: Name the file `contact_store.py`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件命名为 `contact_store.py`。
- en: Replace the content of `contact_store.py` with the contact store implementation
    from [Chapter 5](https://cdp.packtpub.com/hands_on_artificial_intelligence_on_amazon_web_services/wp-admin/post.php?post=527&action=edit#post_301),
    *Extracting Information from Text with Amazon Comprehend*.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `contact_store.py` 的内容替换为 [第 5 章](https://cdp.packtpub.com/hands_on_artificial_intelligence_on_amazon_web_services/wp-admin/post.php?post=527&action=edit#post_301)
    中的联系人存储实现，*使用 Amazon Comprehend 从文本中提取信息*。
- en: 'Add `get_contact_by_name()` after the existing function implementation:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有函数实现后添加 `get_contact_by_name()`：
- en: '[PRE0]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code includes the following elements:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码包含以下元素：
- en: The `get_contact_by_name()` method retrieves a single contact by its unique
    identifier, which is the name. In this method, we are calling DynamoDB's `get_item()`
    function. The response from `get_item()` contains a dictionary. If the item key
    exists, then we get a return value containing the contact information.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_contact_by_name()` 方法通过唯一标识符（即姓名）检索单个联系人。在该方法中，我们调用 DynamoDB 的 `get_item()`
    函数。`get_item()` 的响应包含一个字典。如果项键存在，则我们会得到一个包含联系人信息的返回值。'
- en: Here, we are getting an item from the DynamoDB table by key. The key is the
    name of the contact, first name, and last name, separated by a space. This code
    will be executed in the Python 3.7 lambda runtime environment. In this environment,
    the `boto3` package is already installed.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，我们通过键从 DynamoDB 表中获取一项。键是联系人姓名、名和姓，用空格分隔。此代码将在 Python 3.7 的 Lambda 运行时环境中执行。在该环境中，`boto3`
    包已经安装。
- en: DynamoDB IAM role for LookupPhoneNumberByName
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于 LookupPhoneNumberByName 的 DynamoDB IAM 角色
- en: 'Since this code will need to connect to DynamoDB, we need to add a policy to
    our lambda function''s execution role:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这段代码需要连接到 DynamoDB，我们需要为我们的 Lambda 函数的执行角色添加一个策略：
- en: Navigate to the IAM page from AWS Console.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 AWS 控制台导航到 IAM 页面。
- en: Click on Roles on the left-hand panel.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧面板中的“角色”。
- en: From the list of roles, find and click on the LookupPhoneNumberByName-role-<unique
    id> role for our lambda function.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在角色列表中，找到并点击用于我们 Lambda 函数的 LookupPhoneNumberByName-role-<unique id> 角色。
- en: Click on the Attach policies button.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“附加策略”按钮。
- en: Find and select the AmazonDynamoDBFullAccess policy, and then click on the Attach
    policy button.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到并选择 AmazonDynamoDBFullAccess 策略，然后点击“附加策略”按钮。
- en: 'Now, let''s have a look at the following screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下以下截图：
- en: '![](img/17d6d4d5-449a-4a18-a3b6-eaebb7749df6.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17d6d4d5-449a-4a18-a3b6-eaebb7749df6.png)'
- en: Now, our `LookupPhoneNumberByName` lambda function can access DynamoDB. The
    `AmazonDynamoDBFullAccess` policy is fine for our hands-on projects, but, for
    real production application, you should fine-tune the policy to limit the number
    of permissions granted.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 `LookupPhoneNumberByName` Lambda 函数可以访问 DynamoDB。`AmazonDynamoDBFullAccess`
    策略适用于我们的实操项目，但对于真实的生产应用，您应当调整该策略，以限制授予的权限数量。
- en: Fulfillment lambda function for LookupPhoneNumberByName
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于 LookupPhoneNumberByName 的履行 Lambda 函数
- en: 'In the lambda editor window, open the existing `lambda_function.py` file and
    replace its content with the following implementation:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lambda 编辑器窗口中，打开现有的 `lambda_function.py` 文件，并将其内容替换为以下实现：
- en: '[PRE1]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding code, the following takes place:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，发生了以下情况：
- en: We first initialize the contact store with the DynamoDB table contacts.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先用 DynamoDB 表 contacts 初始化联系人存储。
- en: In the `lambda_handler()` function, we are extracting the intent name, the slots,
    and the attributes from the event object passed in. The event object is passed
    in to our Amazon Lex bot when the fulfillment hook is triggered. All of the slot
    input values, as well as the session attributes, will be included in this event
    object.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `lambda_handler()` 函数中，我们从传入的事件对象中提取意图名称、槽位和属性。当履行钩子被触发时，事件对象会传入我们的亚马逊 Lex
    机器人。所有槽位输入值以及会话属性都会包含在此事件对象中。
- en: '`lambda_handler()` then calls the `lookup_phone()` function that uses the contact
    store to retrieve the contact information.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lambda_handler()` 然后调用 `lookup_phone()` 函数，该函数使用联系人存储来检索联系信息。'
- en: In the `lookup_phone()` function, we are constructing the item key from the
    `FirstName` and `LastName` slot values. The item key must be `FirstName` and `LastName`
    separated by a space, with the correct capitalization.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `lookup_phone()` 函数中，我们根据 `FirstName` 和 `LastName` 槽位值构建项目键。项目键必须是由空格分隔的 `FirstName`
    和 `LastName`，并且需要正确的大写。
- en: For example, the first name `john` and the last name `smith` will result in
    the item key `John Smith`; the first letter of each part of the name is capitalized.
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，名字 `john` 和姓氏 `smith` 会生成项目键 `John Smith`；名字的每个部分的首字母都大写。
- en: We are using the `title()` function to ensure correct capitalization, irrespective
    of how the user inputs the names.
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `title()` 函数确保正确的大写形式，无论用户如何输入名字。
- en: If we are able to retrieve a contact with those names, we will save the contact's
    phone number, first name, and last name in the session attributes. This is how
    the phone number is passed back to be displayed or spoken in this intent's response.
    We will cover why the first name and last name are saved in the session attributes
    in a later section of this chapter.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够通过这些名字查找到联系人，我们将把联系人的电话号码、名字和姓氏保存在会话属性中。这就是电话号码如何传回并在该意图的响应中显示或朗读的方式。稍后我们将解释为什么名字和姓氏会保存在会话属性中。
- en: If we are successful at fulfilling the lookup, we respond with `intent_success()`,
    otherwise, we respond with `intent_failure()` with an explanation message. These
    are helper functions that encapsulate some of Amazon Lex's specific response formats.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们成功完成查找，我们会响应 `intent_success()`，否则我们会响应 `intent_failure()` 并附带解释信息。这些是封装了亚马逊
    Lex 特定响应格式的助手函数。
- en: Amazon Lex helper functions
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 亚马逊 Lex 助手函数
- en: 'The Amazon Lex helper functions format the responses to what Lex is expecting.
    We have four helper functions here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊 Lex 助手函数将响应格式化为 Lex 所期望的格式。这里有四个助手函数：
- en: '`intent_success()` indicates that the intent has been successfully fulfilled,
    and any session attributes are passed back to Lex as `sessionAttributes`.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intent_success()` 表示意图已经成功实现，并且任何会话属性都会作为 `sessionAttributes` 返回给 Lex。'
- en: '`intent_failure()` indicates that the intent was not fulfilled successfully.
    This response also includes an explanation message.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intent_failure()` 表示意图未能成功实现。此响应还包括一条解释信息。'
- en: '`intent_elicitation()` asks the Lex bot to elicit a value for the specified
    parameter name. This elicitation might be due to missing slot values or invalid
    slot values. This helper function is useful when we create custom `Lambda initialization
    and validation` logic.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intent_elicitation()` 请求 Lex 机器人引导获取指定参数名称的值。此引导可能是由于缺少槽位值或槽位值无效。这一助手函数在我们创建自定义
    `Lambda 初始化和验证` 逻辑时非常有用。'
- en: '`intent_delegation()` indicates that the lambda function has completed its
    obligation and directs Lex to choose the next course of action based on the bot''s
    configuration.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intent_delegation()` 表示 Lambda 函数已经完成了它的任务，并指示 Lex 根据机器人配置选择下一步行动。'
- en: 'We only used the first two helper functions for this `LookupPhoneNumberByName`
    intent. Here is the code implementation:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只使用了前两个助手函数来实现 `LookupPhoneNumberByName` 意图。以下是代码实现：
- en: '[PRE2]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Even though the `lambda_function.py` file is relatively short, we still applied
    a few clean code practices. We organized all of the AWS Lambda- and Amazon Lex-specific
    implementation details into the `lambda_handler()` function and the Amazon Lex
    helper functions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 `lambda_function.py` 文件相对较短，我们仍然应用了一些清晰代码的实践。我们将所有与 AWS Lambda 和亚马逊 Lex 相关的实现细节都组织到了
    `lambda_handler()` 函数和亚马逊 Lex 助手函数中。
- en: For example, how are the slots from the Lambda event object and the response
    format to Amazon Lex to be retrieved? This way, the `lookup_phone()` function
    is free from those platform specific details and, hence, is more likely to be
    reusable on other platforms. The `lookup_phone()` function only requires `intent_name`
    to be a string, and the parameters and attributes to be dictionaries.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如何从 Lambda 事件对象中获取槽位和响应格式以供 Amazon Lex 使用？这样，`lookup_phone()` 函数就不受这些平台特定细节的影响，因此更可能在其他平台上重用。`lookup_phone()`
    函数只需要 `intent_name` 为字符串类型，参数和属性为字典类型。
- en: Save the lambda function implementation by clicking on the Save button in the
    top-right corner of the lambda development console.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击 Lambda 开发控制台右上角的 Save 按钮保存 Lambda 函数实现。
- en: The intent fulfillment for LookupPhoneNumberByName
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LookupPhoneNumberByName 的意图 Fulfillment
- en: 'Now, let''s add this lambda function to the fulfillment hook:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将此 Lambda 函数添加到 Fulfillment hook 中：
- en: 'Go to the Amazon Lex development console and, under Fulfillment, select LookupPhoneNumberByName
    from the Lambda function list, as shown in the following screenshot:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 Amazon Lex 开发控制台，在 Fulfillment 部分，从 Lambda 函数列表中选择 LookupPhoneNumberByName，如下图所示：
- en: '![](img/4001a0dc-1c8a-42e0-80cd-056493ab3b12.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4001a0dc-1c8a-42e0-80cd-056493ab3b12.png)'
- en: 'As shown in the following screenshot, Amazon Lex will ask for permission to
    invoke this lambda function. Click OK to grant permission:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下图所示，Amazon Lex 会请求调用此 Lambda 函数的权限。点击 OK 以授予权限：
- en: '![](img/79ab4701-6483-4a7d-9e22-b18056a1db37.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79ab4701-6483-4a7d-9e22-b18056a1db37.png)'
- en: In the Lex development console, click on the Save Intent button at the bottom
    of the page, and then click on the Build button in the top-right corner of the
    page. It will take a few seconds for our first Lex bot to build.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Lex 开发控制台中，点击页面底部的 Save Intent 按钮，然后点击页面右上角的 Build 按钮。构建我们的第一个 Lex 机器人需要几秒钟时间。
- en: Test conversations for LookupPhoneNumberByName
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 LookupPhoneNumberByName 的对话
- en: 'Now, we are ready to build and test our first intent. In the Test bot panel
    on the right of the page, issue a few variations of the sample utterances and
    follow the conversation with the contact assistant. Here is a sample conversation:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好构建并测试我们的第一个意图。在页面右侧的 Test bot 面板中，发出一些示例话语的变化，并与联系人助手进行对话。以下是一个示例对话：
- en: '![](img/8512b6bf-4b0b-4d9a-98a8-8a061da526e4.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8512b6bf-4b0b-4d9a-98a8-8a061da526e4.png)'
- en: 'In the preceding conversation, the following happened:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的对话中，发生了以下情况：
- en: The utterance did not include the slots, and our contact assistant prompted
    for the first and last names
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 话语中没有包含槽位，我们的联系人助手提示输入名字和姓氏
- en: The assistant confirmed the lookup for John Smith before proceeding with fulfillment
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 助手在继续执行 Fulfillment 之前确认了对 John Smith 的查询
- en: The response included the contact's first name and the phone number
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应中包含了联系人的名字和电话号码
- en: Now, think through how this conversation plays out, both as a text chat and
    as a voice conversation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想想这个对话是如何进行的，无论是文本聊天还是语音对话。
- en: 'Here is another sample conversation:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个示例对话：
- en: '![](img/aecd439d-51e2-4a4f-a1a1-61271779447c.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aecd439d-51e2-4a4f-a1a1-61271779447c.png)'
- en: 'In the preceding conversation, the following happened:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的对话中，发生了以下情况：
- en: The utterance included both of the required slots
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 话语中包含了两个必需的槽位
- en: This time, our contact assistant only had to confirm the lookup before proceeding
    with the fulfillment and response
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这次，我们的联系人助手只需要在继续执行 Fulfillment 和响应之前确认查询
- en: The user can also respond **no** to the confirmation prompt to cancel the fulfillment
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户也可以通过回答**no**来取消 Fulfillment
- en: Congratulations! You just completed your first intelligent assistant with a
    conversation interface and AWS Lambda fulfillment implementation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚完成了第一个具有对话界面和 AWS Lambda Fulfillment 实现的智能助手。
- en: The test bot panel's chat interface also supports voice inputs. You can use
    the microphone icon to issue the utterances and responses via voice.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 测试机器人面板的聊天界面也支持语音输入。你可以使用麦克风图标通过语音发出话语和响应。
- en: '![](img/7da95da6-551a-4e10-a08d-30da7c48b114.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7da95da6-551a-4e10-a08d-30da7c48b114.png)'
- en: In the test bot chat interface, the response from Lex will always be in text.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试机器人聊天界面中，Lex 的响应将始终以文本形式显示。
- en: The MakePhoneCallByName intent
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MakePhoneCallByName 意图
- en: Next, we will create a second intent for our contact assistant, called **MakePhoneCallByName**.
    The task performed by this intent should be obvious from its name; it can phone
    the contacts. However, we will not be implementing the phone call functionality
    in this project.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为我们的联系人助手创建第二个意图，命名为**MakePhoneCallByName**。从名字就可以看出，这个意图执行的任务是拨打电话给联系人。然而，在这个项目中我们不会实现电话拨打功能。
- en: The goal as regards implementing this second intent is to demonstrate how multiple
    intents of an intelligent assistant can interact and collaborate. We want to design
    the conversational interface of `MakePhoneCallByName` to be able to function independently,
    but also to be able to function in conjunction with the `LookupPhoneNumberByName`
    intent.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 实现第二个意图的目标是演示智能助手的多个意图如何互相交互和协作。我们希望设计`MakePhoneCallByName`的对话界面，使其能够独立运行，同时也能够与`LookupPhoneNumberByName`意图协同工作。
- en: To make this intent collaboration concrete, imagine that the user just looked
    up the phone number of a contact and then decided to make a call to this contact.
    Should the second intent start over with the first name and last name slot elicitations?
    Or would it be more fluid and natural to know that the user wants to call the
    same contact that the assistant just looked up? Of course, the latter. After `LookupPhoneNumberByName`
    was fulfilled successfully, and then the user utters `Call him` or `Call her`,
    `MakePhoneCallByName` should just know who `him` or `her` is referring to based
    on the context of prior conversations. This is where session attributes can help
    to maintain the context.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这种意图协作更具实用性，可以设想用户刚刚查找了某个联系人的电话号码，然后决定拨打该联系人的电话。第二个意图是否应该从头开始，要求提供姓氏和名字的插槽？还是说，考虑到之前的对话，知道用户想打电话给刚刚查找过的联系人，会更流畅自然呢？当然是后者。在`LookupPhoneNumberByName`成功执行后，用户如果说“Call
    him”或“Call her”，`MakePhoneCallByName`应该能够根据先前的对话上下文，知道“him”或“her”指的是谁。这时，会话属性就可以帮助保持上下文。
- en: Sample utterances and lambda initialization/validation for MakePhoneCallByName
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为`MakePhoneCallByName`创建的示例发声和 Lambda 初始化/验证
- en: 'We''ll start by adding a new intent from the Lex development console by clicking
    on the blue plus button next to Intents on the left-hand panel, as shown in the
    following screenshot:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过点击左侧面板“Intents”旁边的蓝色加号按钮，从 Lex 开发控制台添加一个新的意图，具体步骤如以下截图所示：
- en: Select Create intent, name it `MakePhoneCallByName`, and then click on Add.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择创建意图，命名为`MakePhoneCallByName`，然后点击添加。
- en: 'Let''s create a few sample utterances for this intent. The first utterance
    **Call** {FirstName} {LastName} provides the values for the two required slots.
    For the other utterances, the intent should try its best to get the slot values
    from the conversation context if possible:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为此意图创建一些示例发声。第一个发声**Call** {FirstName} {LastName}为两个必需插槽提供了值。对于其他发声，意图应该尽量从对话上下文中获取插槽值：
- en: '![](img/53a0464f-1811-4fb1-9092-0ed84692cb74.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53a0464f-1811-4fb1-9092-0ed84692cb74.png)'
- en: 'To do this, we will use the second type of AWS Lambda hook from Amazon Lex,
    lambda initialization and validation. The following steps will create the hook:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用来自 Amazon Lex 的第二种类型的 AWS Lambda 钩子——Lambda 初始化和验证。以下步骤将创建该钩子：
- en: In the Lambda initialization and validation section, check the box for Initialization
    and validation code hook.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Lambda 初始化和验证部分，勾选初始化和验证代码钩子的复选框。
- en: Go to the AWS Lambda page from AWS Console and create a lambda function named
    `InitContact` from scratch for Python 3.7.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 AWS 控制台进入 AWS Lambda 页面，创建一个名为`InitContact`的 Lambda 函数，选择 Python 3.7 环境。
- en: Create a new default lambda execution role. We do not need the AmazonDynamoDBFullAccess
    policy for this lambda function.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的默认 Lambda 执行角色。我们不需要为此 Lambda 函数添加 AmazonDynamoDBFullAccess 策略。
- en: 'In the inline function code editor, replace the `lambda_function.py` file contact
    with the following implementation:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内联函数代码编辑器中，用以下实现替换`lambda_function.py`文件的内容：
- en: '[PRE3]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, the following takes place:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，发生了以下操作：
- en: In the `init_contact()` function, we check whether `FirstName` and `LastName`
    are missing from the slots coming from the utterance. If so, we then check whether
    `FistName` and `LastName` exist in the session attributes.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`init_contact()`函数中，我们检查来自发声的插槽是否缺少`FirstName`和`LastName`。如果缺少，我们接着检查`FirstName`和`LastName`是否存在于会话属性中。
- en: Do you recall that we saved `FirstName` and `LastName` to the session attributes
    in the fulfillment implementation for the `LookupPhoneNumberByName` intent? We
    are retrieving those saved values here.
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还记得我们在`LookupPhoneNumberByName`意图的Fulfillment实现中将`FirstName`和`LastName`保存到会话属性吗？我们在这里提取了那些保存的值。
- en: If both `FirstName` and `LastName` are set, then we respond back to Lex with
    a delegation response.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`FirstName`和`LastName`都已设置，那么我们将返回一个委托响应给Lex。
- en: The delegation response tells Lex that initialization and validation are complete,
    and that the bot should continue with its execution based on its configuration,
    including fulfillment.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托响应告诉Lex，初始化和验证已完成，机器人应根据其配置继续执行，包括Fulfillment。
- en: If either `FirstName` or `LastName` is still missing its value, then we respond
    back with an elicitation response.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`FirstName`或`LastName`的值仍然缺失，那么我们将以诱导响应的方式进行回应。
- en: The elicitation response will trigger the prompt for the missing slot that was
    configured for the bot.
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诱导响应将触发配置给机器人用于缺失插槽的提示。
- en: 'Save the lambda function, and then go back to the Amazon Lex development console:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 保存lambda函数，然后返回到Amazon Lex开发控制台：
- en: '![](img/add41d5e-43f0-4d83-8926-fb1400099d1b.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/add41d5e-43f0-4d83-8926-fb1400099d1b.png)'
- en: Select InitContact for the Lambda initialization and validation function.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 选择InitContact作为Lambda初始化和验证函数。
- en: Slots and confirmation prompt for MakePhoneCallByName
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MakePhoneCallByName的插槽和确认提示
- en: 'The slots configuration for the `MakePhoneCallByName` intent can be exactly
    the same as the configuration for `LookupPhoneNumberByName`. See the details in
    the following screenshot:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`MakePhoneCallByName`意图的插槽配置可以与`LookupPhoneNumberByName`的配置完全相同。请参见以下截图中的详细信息：'
- en: '![](img/1c949a72-d569-4606-97c4-41def12adabd.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c949a72-d569-4606-97c4-41def12adabd.png)'
- en: Both slots are required, and are set to the built-in `AMAZON.US_FIRST_NAME`
    and `AMAZON.US_LAST_NAME` types.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 两个插槽都是必需的，并且被设置为内置的`AMAZON.US_FIRST_NAME`和`AMAZON.US_LAST_NAME`类型。
- en: 'The Confirmation prompt can be tailored for making phone calls, as shown in
    the following screenshot:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 确认提示可以根据拨打电话的需求进行定制，如下图所示：
- en: '![](img/bcb3bbfd-52df-4527-aa68-ae348b7d5e3c.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bcb3bbfd-52df-4527-aa68-ae348b7d5e3c.png)'
- en: Both the Confirm and Cancel messages are tailored to the `MakePhoneCallByName`
    intent.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 确认和取消消息都定制为`MakePhoneCallByName`意图。
- en: Fulfillment and response for MakePhoneCallByName
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MakePhoneCallByName的Fulfillment和响应
- en: We could implement a new lambda function to fulfill the contact lookup and phone
    call functionalities. But, since we are not actually making phone calls in this
    project, the business logic of the fulfillment lambda function will be the same
    as the contact lookup function we already implemented.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现一个新的lambda函数来完成联系人查找和拨打电话的功能。但由于在这个项目中我们并不会真正拨打电话，所以Fulfillment lambda函数的业务逻辑与我们已经实现的联系人查找功能相同。
- en: 'In fact, for this project, Fulfillment can be handled by the LookupPhoneNumberByName
    lambda function, as shown in the following screenshot:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，对于这个项目，Fulfillment可以通过LookupPhoneNumberByName lambda函数来处理，如下图所示：
- en: '![](img/924d3c1f-1518-4ffb-bd79-da9ed740fe6b.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/924d3c1f-1518-4ffb-bd79-da9ed740fe6b.png)'
- en: 'Finally, the Response configuration can also be tailored to make phone calls,
    as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，响应配置也可以定制为进行电话拨打，如下所示：
- en: '![](img/8ab7aef8-01b9-4d5a-8eab-fe0c94983ecb.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ab7aef8-01b9-4d5a-8eab-fe0c94983ecb.png)'
- en: Now, click on the Save Intent button on the bottom of the Lex development console,
    and then click on the Build button in the top-right corner of the development
    console.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击Lex开发控制台底部的保存意图按钮，然后点击开发控制台右上角的构建按钮。
- en: Test conversations for MakePhoneCallByName
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MakePhoneCallByName的测试对话
- en: 'In the Test bot panel on the right-hand side of the page, issue a few variations
    of the sample utterances and follow the conversation with the contact assistant.
    Here is a sample conversation:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面右侧的测试机器人面板中，发布几个示例话语的不同版本，并与联系人助手进行对话。以下是一个示例对话：
- en: '![](img/1a69bccd-6e5f-4bb3-ac49-4ccdaf7e5d92.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a69bccd-6e5f-4bb3-ac49-4ccdaf7e5d92.png)'
- en: The preceding conversation demonstrates that the `MakePhoneCallByName` intent
    can function independently without running the `LookupPhoneNumberByName` intent
    first.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 上述对话展示了`MakePhoneCallByName`意图可以独立运行，而无需先执行`LookupPhoneNumberByName`意图。
- en: 'Here is another sample conversation:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个示例对话：
- en: '![](img/8516bcf7-f1e5-4af9-88be-eed12ee104ad.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8516bcf7-f1e5-4af9-88be-eed12ee104ad.png)'
- en: 'The preceding conversation shows the power of context:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 上述对话展示了上下文的强大作用：
- en: The user first asked for John Smith's phone number with the `LookupPhoneNumberByName`
    intent.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户首先通过`LookupPhoneNumberByName`意图请求了 John Smith 的电话号码。
- en: Then, the user requested to `call him`.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，用户请求`call him`。
- en: At this point, our `InitContact` lambda function grabbed the `FirstName` and
    `LastName` from the session attributes and confirmed whether John Smith is the
    contact to call.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此时，我们的`InitContact` lambda 函数从会话属性中获取了`FirstName`和`LastName`，并确认 John Smith
    是否是要联系的人。
- en: The confirmation prompt is important here, since the contact assistant is inferring
    the contact. We do not want to automatically make awkward calls to the wrong contact;
    it is better to confirm with the user first before taking action.
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认提示在这里非常重要，因为联系人助手正在推断联系人。我们不希望自动给错误的联系人打电话，最好先与用户确认再采取行动。
- en: 'Click on Clear chat history before issuing the next utterance. This will clear
    the session and its stored attributes. Continue the sample conversation with the
    following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在发出下一个话语之前，点击“清除聊天历史记录”。这将清除会话及其存储的属性。继续以下示例对话：
- en: '![](img/33f380a8-2482-48fe-941e-f7c2e588521e.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33f380a8-2482-48fe-941e-f7c2e588521e.png)'
- en: 'In this conversation, the following took place:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次对话中，发生了以下情况：
- en: The user started with an utterance without any slots. On this occasion, however,
    there was no previous conversational context saved in the session attributes.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户开始时没有提供任何槽位。然而，这次会话中并没有保存任何之前的对话上下文。
- en: The `InitContact` lambda function was not able to retrieve a first and last
    name; therefore, it responds with intent elicitations.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InitContact` lambda 函数无法获取名字和姓氏，因此它通过意图激发请求进行响应。'
- en: It's important to test our intelligent assistant to handle all possible orders
    and combinations of intents and utterances. This quality assurance becomes more
    difficult as more intents share the session attributes.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试我们的智能助手以处理所有可能的意图和话语组合非常重要。随着更多意图共享会话属性，这种质量保证变得更加困难。
- en: Congratulations! Our contact assistant just became more intelligent with context
    awareness.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们的联系人助手现在通过上下文感知变得更智能了。
- en: Deploying the contact assistant bot
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署联系人助手机器人
- en: We can now publish the contact assistant as a custom intelligent assistant capability.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将联系人助手发布为自定义智能助手能力。
- en: 'Click on the Publish button on the top right of the Lex development console
    and set Alias to Production:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 Lex 开发控制台右上角的“发布”按钮，并将别名设置为“生产”：
- en: '![](img/5ef89a4d-2cbb-4659-9f03-9468b4fff2c4.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ef89a4d-2cbb-4659-9f03-9468b4fff2c4.png)'
- en: The preceding screenshot shows that the contact assistant is now published.
    Once the contact assistant is published, the applications can start to leverage
    it through various integration methods, including the boto3 SDK.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示了联系人助手已经发布。一旦联系人助手发布，应用程序可以通过各种集成方式开始使用它，包括 boto3 SDK。
- en: Integrating the contact assistant into applications
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将联系人助手集成到应用程序中
- en: Next, we will create the layers to integrate the contact assistant capability
    into applications. As mentioned at the beginning of this chapter, we will not
    implement any application; we will only implement the service and RESTful endpoint
    layers.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建层来将联系人助手能力集成到应用程序中。如本章开始时所述，我们不会实现任何应用程序，我们只会实现服务和 RESTful 端点层。
- en: As with previous hands-on projects, we will be using Python, Pipenv, Chalice,
    and boto3 as part of the technology stack. Let's create a project structure first.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前的动手项目一样，我们将使用 Python、Pipenv、Chalice 和 boto3 作为技术栈的一部分。让我们先创建项目结构。
- en: 'In the terminal, we will create the `root` project directory and enter it with
    the following commands:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，我们将创建`root`项目目录并进入，使用以下命令：
- en: '[PRE4]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will create a Python 3 virtual environment with `Pipenv` in the project''s
    `root` directory. Our Python portion of the project requires two packages, `boto3`
    and `chalice`. We can install them with the following commands:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在项目的`root`目录下使用`Pipenv`创建一个 Python 3 虚拟环境。我们的 Python 项目部分需要两个包，`boto3` 和
    `chalice`。我们可以通过以下命令安装它们：
- en: '[PRE5]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Remember that the Python packages installed via `pipenv` are only available
    if we activate the virtual environment. One way to do this is by means of the
    following command:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，通过`pipenv`安装的 Python 包只有在我们激活虚拟环境后才可用。一种方法是使用以下命令：
- en: '[PRE6]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, while still in the virtual environment, we will create the orchestration
    layer as an AWS Chalice project named `Capabilities` with the following commands:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在虚拟环境中，我们将创建一个名为 `Capabilities` 的 AWS Chalice 项目的编排层，使用以下命令：
- en: '[PRE7]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To create the `chalicelib` Python package, issue the following commands:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建 `chalicelib` Python 包，发出以下命令：
- en: '[PRE8]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The initial project structure should look like the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 初始项目结构应如下所示：
- en: '[PRE9]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The project structure is slightly different to those structures created in previous
    chapters. This project structure contains the orchestration and service implementations
    layers, but does not include a web user interface.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 项目结构与前几章中创建的结构略有不同。该项目结构包含编排层和服务实现层，但不包括 Web 用户界面。
- en: Intelligent assistant service implementation
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能助手服务实现
- en: The contact assistant is backed by a Lex bot in the current implementation,
    but good architecture design should have the flexibility to change implementations
    easily. The service implementation serves to shield the Lex implementation details
    from the client applications.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前实现中，联系人助手由 Lex 机器人支持，但良好的架构设计应该具有灵活性，能够轻松更换实现。该服务实现旨在将 Lex 实现的细节与客户端应用程序隔离开来。
- en: 'Create a Python file in `chalicelib` with the name `intelligent_assistant_service.py`,
    as shown in the following screenshot:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `chalicelib` 中创建一个名为 `intelligent_assistant_service.py` 的 Python 文件，如下所示：
- en: '[PRE10]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code, the following takes place:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，发生了以下操作：
- en: '`IntelligentAssistantService` is a generic implementation that can be configured
    to work with different intelligent assistants, and not just the contact assistant.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntelligentAssistantService` 是一个通用实现，可以配置为与不同的智能助手一起使用，而不仅仅是联系人助手。'
- en: The `__init__()` constructor takes in the assistant name to configure itself
    for a particular intelligent assistant at creation time. The constructor creates
    a `boto3` client for `lex-runtime`, which can communicate with published Lex bots.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__()` 构造函数接收助手名称，以便在创建时为特定的智能助手配置自身。构造函数为 `lex-runtime` 创建一个 `boto3`
    客户端，用于与已发布的 Lex 机器人进行通信。'
- en: '`IntelligentAssistantService` implements the `send_user_text()` method to send
    text chat messages to the assistants. This method takes in a `user_id` and the
    `input_text` from the application, and uses the `post_text()` function from `lex-runtime`
    to send the input text.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntelligentAssistantService` 实现了 `send_user_text()` 方法，用于向助手发送文本聊天消息。此方法接收来自应用程序的
    `user_id` 和 `input_text`，并使用 `lex-runtime` 的 `post_text()` 函数发送输入文本。'
- en: '`user_id` is an ID created by the client application. A Lex bot can have multiple
    conversations with different users at once. This `user_id` identifies a user;
    in other words, it identifies a chat session.'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user_id` 是由客户端应用程序创建的 ID。一个 Lex 机器人可以与多个不同的用户同时进行多个对话。该 `user_id` 标识一个用户；换句话说，它标识一个聊天会话。'
- en: There is also a `post_content()` function from `lex-runtime` for sending both
    text and speech inputs. In addition to `botName`, `botAlias`, and `userId`, the
    `post_content()` function also requires the `contentType` and `inputStream` parameters
    to be set. `contentType` can be either audio or text, with a few supported audio
    formats. `inputStream` contains the byte stream for the audio or text contents.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个来自 `lex-runtime` 的 `post_content()` 函数，用于发送文本和语音输入。除了 `botName`、`botAlias`
    和 `userId` 外，`post_content()` 函数还需要设置 `contentType` 和 `inputStream` 参数。`contentType`
    可以是音频或文本，支持几种音频格式。`inputStream` 包含音频或文本内容的字节流。
- en: If the application would like to receive an audio response from the Lex bot,
    the `accept` parameter should be set to one of the audio output formats supported.
    The supported audio input and output formats are implementation details of Lex.
    Any format conversions for the audio inputs and outputs should be performed in
    this service implementation to hide those details from the client applications.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序希望从 Lex 机器人接收音频响应，则应将 `accept` 参数设置为支持的音频输出格式之一。音频输入和输出格式是 Lex 的实现细节。任何音频输入和输出的格式转换应在此服务实现中执行，以隐藏这些细节给客户端应用程序。
- en: Contact assistant RESTful endpoint
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联系人助手 RESTful 端点
- en: 'Let''s have a look at the following steps:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看接下来的步骤：
- en: 'Now, let''s build a quick RESTful endpoint to the contact assistant in `app.py`.
    This way, we can test our `IntelligentAssistantService` with `curl` commands:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在 `app.py` 中快速构建一个 RESTful 端点来连接联系人助手。通过这种方式，我们可以使用 `curl` 命令测试我们的 `IntelligentAssistantService`：
- en: '[PRE11]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The RESTful endpoint implementation is short and simple:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful 端点的实现简短且简单：
- en: The initialization code binds our generic `IntelligentAssistantService` implementation
    to the contact assistant
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化代码将我们的通用`IntelligentAssistantService`实现绑定到联系人助手
- en: The RESTful endpoint itself takes in the `user_id` through the URL and the input
    text as JSON in the request body
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful端点本身通过URL接收`user_id`，并通过请求体中的JSON格式接收输入文本
- en: 'Start the `chalice local` environment with the following command in the terminal:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中使用以下命令启动`chalice local`环境：
- en: '[PRE12]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we can have a conversation with our contact assistant using the `curl`
    commands:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`curl`命令与联系人助手进行对话：
- en: '[PRE13]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding conversation, the following takes place:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述对话中，发生了以下情况：
- en: The first `curl` command issues the intent `Call John Smith`, which includes
    both slots required for the first and last names of the contact.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个`curl`命令发出了意图`Call John Smith`，其中包括联系人名字和姓氏所需的两个槽位。
- en: The response is a confirmation from the contact assistant, *Would you like me
    to call John Smith?*
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应是来自联系人助手的确认，*您希望我拨打John Smith的电话吗？*
- en: The second `curl` command continues the conversation by replying, *Yes*.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个`curl`命令通过回复*是*来继续对话。
- en: The contact assistant then responds with, *Calling John Smith at (202) 123-4567*.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，联系人助手回应，*正在拨打John Smith的电话，电话号码是(202) 123-4567*。
- en: The applications that will leverage the capabilities of the contact assistant
    will provide the appropriate user interface to best facilitate the conversation,
    for example, a mobile app for a traveling salesman. The application will pass
    the verbal communication between the users and the contact assistant using the
    RESTful endpoint.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 将利用联系人助手功能的应用程序将提供适当的用户界面，以最好地促进对话，例如，为旅行推销员设计的移动应用。该应用程序将通过RESTful端点传递用户与联系人助手之间的口头交流。
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we built the contact assistant, a chatbot that allows the user
    to search for contact information using a voice or text conversational interface.
    We built the contact assistant's conversational interface using Amazon Lex. We
    learned the development paradigm of Amazon Lex to build a custom AI capability,
    including concepts such as intents, utterances, prompts, and confirmations. The
    contact assistant supports two intents, `LookupPhoneNumberByName` and `MakePhoneCallByName`.
    The task fulfillment of these intents is implemented using AWS Lambda. We also
    designed these two intents to be context aware by using Amazon Lex's session attributes;
    being context aware reduces the cognitive burden of the user and makes the chatbot
    smarter.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们构建了联系人助手，一个允许用户通过语音或文本对话界面搜索联系人信息的聊天机器人。我们使用Amazon Lex构建了联系人助手的对话界面。我们学习了Amazon
    Lex的开发范式，以构建定制的AI能力，涉及的概念包括意图、语句、提示和确认。联系人助手支持两个意图，`LookupPhoneNumberByName`和`MakePhoneCallByName`。这些意图的任务履行通过AWS
    Lambda实现。我们还通过使用Amazon Lex的会话属性设计了这两个意图，使其具有上下文感知能力；上下文感知减少了用户的认知负担，使得聊天机器人更加智能。
- en: Amazon Lex is the last of the AWS AI services that we will cover in this book.
    In the next part of the book, we will cover AWS ML services to train customer
    AI capabilities using machine learning.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon Lex是我们在本书中介绍的最后一个AWS AI服务。在本书的下一部分，我们将介绍AWS ML服务，使用机器学习训练客户AI能力。
- en: Further reading
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information on building a voice chatbot with Amazon Lex, you can refer
    to the following links:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用Amazon Lex构建语音聊天机器人的更多信息，可以参考以下链接：
- en: '[https://restechtoday.com/smart-speaker-industry/](https://restechtoday.com/smart-speaker-industry/)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://restechtoday.com/smart-speaker-industry/](https://restechtoday.com/smart-speaker-industry/)'
- en: '[https://www.lifewire.com/amazon-alexa-voice-assistant-4152107](https://www.lifewire.com/amazon-alexa-voice-assistant-4152107)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.lifewire.com/amazon-alexa-voice-assistant-4152107](https://www.lifewire.com/amazon-alexa-voice-assistant-4152107)'
- en: '[https://www.nngroup.com/articles/intelligent-assistants-poor-usability-high-adoption/](https://www.nngroup.com/articles/intelligent-assistants-poor-usability-high-adoption/)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.nngroup.com/articles/intelligent-assistants-poor-usability-high-adoption/](https://www.nngroup.com/articles/intelligent-assistants-poor-usability-high-adoption/)'
