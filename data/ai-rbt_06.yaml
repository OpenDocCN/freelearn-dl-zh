- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Teaching a Robot to Listen
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 教会机器人倾听
- en: Teaching a robot to listen to spoken instructions is a whole discipline in itself.
    It is not sufficient for the robot to just recognize individual words or some
    canned phrase. We want the robot to respond to normal spoken commands with a normal
    variety of phrasing. We might say, “Pick up the toys,” or “Please pick up all
    the toys,” or “Clean this mess up,” any of which would be a valid command to instruct
    the robot to begin searching the room for toys to pick up and put away. We will
    be using a variety of techniques and processes for this chapter. We are going
    to be building on an open source verbal assistant called **Mycroft**, an AI-based
    speech recognition and **natural language processing** (**NLP**) engine that can
    be programmed and extended by us. We will be adding some additional capability
    to Mycroft – we will use a technique I call the “fill in the blank” method of
    command processing to extract the intent of the user’s voice instructions, so
    that the robot does what you want it to do, even if that is not exactly what you
    said. We will complete this chapter by teaching the robot to both tell and respond
    to a specific form of human communication – knock-knock jokes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 教会机器人倾听口头指令本身就是一个完整的学科。机器人仅仅识别个别单词或一些预先设定的短语是不够的。我们希望机器人能够以正常多样的措辞对口头命令做出反应。我们可能会说，“拿起玩具”，或者“请把所有玩具都拿起来”，或者“清理这个混乱”，这些都可以是有效的指令，指示机器人开始搜索房间中的玩具并取走。我们将在本章中使用各种技术和流程。我们将基于一个开源的语音助手
    **Mycroft** 进行构建，这是一个基于人工智能的语音识别和 **自然语言处理**（**NLP**）引擎，我们可以对其进行编程和扩展。我们将为 Mycroft
    添加一些额外的功能——我们将使用我称之为“填空”方法的命令处理技术来提取用户语音指令的意图，这样机器人就能做你想让它做的事情，即使那不是你说的原话。我们将通过教会机器人讲述和回应特定形式的人类交流——敲门笑话来完成这一章。
- en: 'The following topics will be covered in the chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Exploring robot speech recognition with NLP – both **speech to text** (**STT**)
    and **text to** **speech** (**TTS**)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 NLP 探索机器人语音识别——包括 **语音转文本**（**STT**）和 **文本转语音**（**TTS**）
- en: Programming our robot
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程我们的机器人
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter uses the following tools:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用以下工具：
- en: Mycroft Open Source Voice Assistant ([http://mycroft.ai](http://mycroft.ai))
    – I had to build it from source from the GitHub repository ([https://github.com/MycroftAI](https://github.com/MycroftAI)),
    so expect to do the same to keep it compatible with the **Robot Operating System**
    (**ROS**) we run the robot with.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mycroft 开源语音助手 ([http://mycroft.ai](http://mycroft.ai)) - 我必须从 GitHub 仓库 ([https://github.com/MycroftAI](https://github.com/MycroftAI))
    中从头开始构建，因此请预期您也需要这样做以保持与我们在机器人上运行的 **机器人操作系统**（**ROS**）兼容。
- en: Python 3.2.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.2。
- en: You will need a GitHub account at [https://github.com/](https://github.com/).
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要一个 GitHub 账户，请访问 [https://github.com/](https://github.com/).
- en: I used a miniature USB speaker and microphone for this project, which worked
    very well with the Jetson. They can be found at [https://www.amazon.com/gp/product/B08R95XJW8](https://www.amazon.com/gp/product/B08R95XJW8)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我在这个项目中使用了微型 USB 扬声器和麦克风，它们与 Jetson 配合得非常好。您可以在 [https://www.amazon.com/gp/product/B08R95XJW8](https://www.amazon.com/gp/product/B08R95XJW8)
    找到它们。
- en: The code used in this chapter can be found in the GitHub repository for this
    book at [https://github.com/PacktPublishing/Artificial-Intelligence-for-Robotics-2e](https://github.com/PacktPublishing/Artificial-Intelligence-for-Robotics-2e).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的代码可以在本书的 GitHub 仓库中找到，请访问 [https://github.com/PacktPublishing/Artificial-Intelligence-for-Robotics-2e](https://github.com/PacktPublishing/Artificial-Intelligence-for-Robotics-2e)。
- en: Exploring robot speech recognition with NLP
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 NLP 探索机器人语音识别
- en: This is going to be a rather involved chapter, but all of the concepts are fairly
    easy to understand. We will end up with a very strong framework to build voice
    recognition and commands upon. Not only will you get a voice-based command system
    for a robot, but also a full-featured digital assistant that tells jokes. Let’s
    first quickly introduce NLP.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个相当复杂的章节，但所有概念都相对容易理解。我们将最终构建一个强大的框架，用于构建语音识别和命令。你不仅会得到一个基于语音的机器人命令系统，还会得到一个功能齐全的数字助手，可以讲笑话。让我们首先快速介绍
    NLP。
- en: Briefly introducing the NLP concept
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简要介绍 NLP 概念
- en: NLP is not just converting sound waves to written words (speech to text, or
    STT), but also understanding what those words mean. We don’t want to just have
    some rigid, pre-programmed spoken commands, but some ability for the robot to
    respond to human speech.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 自然语言处理（NLP）不仅仅是将声音波转换为书面文字（语音到文本，或STT），还包括理解这些文字的含义。我们不想只有一些僵化的、预先编程的语音命令，而希望机器人能够对人类语音做出响应。
- en: 'We will be using two different forms of STT processing:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两种不同的STT处理形式：
- en: '**Spectrum analysis**: This type helps to detect when you say the robot’s name.
    This technique recognizes words or phrases by sampling which frequencies and amplitudes
    make up the word. This process has the advantage of not taking a lot of computer
    resources and it is good at recognizing just one word or phrase – our “wake word”
    that will cause the computer to switch to the second type of voice recognition.
    This is the reason other voice-operated assistants require you to use a specific
    word (e.g., Siri, or Alexa) to enable them to start listening.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**频谱分析**：这种类型有助于检测你何时说出机器人的名字。这种技术通过采样构成单词的频率和振幅来识别单词或短语。这个过程的优势在于不需要太多的计算机资源，并且擅长识别单个单词或短语——我们的“唤醒词”，这将使计算机切换到第二种类型的语音识别。这就是为什么其他语音操作助手需要你使用特定的词（例如，Siri或Alexa）来启用它们开始监听的原因。'
- en: '**Phoneme recognition**: This technique converts STT by recognizing the parts
    of sounds – phonemes – that make up words. This technique, which seeks to interpret
    all sounds as words, is much more difficult, so we use the wake word to trigger
    the change. We’ll cover this in more detail later in this chapter.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音素识别**：这种技术通过识别构成单词的发音部分——音素——来转换语音识别技术（STT）。这种试图将所有声音解释为单词的技术要困难得多，所以我们使用唤醒词来触发这种转换。我们将在本章后面更详细地介绍这一点。'
- en: Next, let’s explore our primary goals for implementing speech recognition.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探讨实现语音识别的主要目标。
- en: Setting our goals
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设定我们的目标
- en: 'We set several goals for our robot in [*Chapter 2*](B19846_02.xhtml#_idTextAnchor032),
    which included being able to give voice commands to the robot since we may be
    using the robot without a base station. I also wanted the robot to be able to
    interact with my grandchildren, and specifically to be able to tell and respond
    to knock-knock jokes, a favorite activity of my grandson, William. For our robot,
    we do not want to use canned or memorized speech commands but rather have it be
    able to do some NLP to create a form of robot understanding of the spoken word.
    For example, if we want to have a command for picking up a toy, we humans could
    phrase that several ways: *grab a toy*, *grasp a toy*, *pick up that toy car*,
    or even *get that*. We want the robot to understand or at least respond to all
    of those utterances with the same action, to drive to the nearest toy and pick
    it up with the robot arm. STT systems are fairly commonplace today, but we would
    like to have some natural variations in the robot’s speech patterns to help create
    the illusion that the robot is smarter than it really is. We can break this process
    down into several steps, which we will be handling independently:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第二章*](B19846_02.xhtml#_idTextAnchor032)中为我们的机器人设定了几个目标，包括能够对机器人发出语音命令，因为我们可能在没有基站的情况下使用机器人。我还希望机器人能够与我的孙子孙女互动，特别是能够讲并回应敲门笑话，这是我的孙子威廉最喜欢的活动。对于我们的机器人，我们不想使用预先录制或记忆中的语音命令，而是希望它能够进行一些自然语言处理，以创建一种机器人对
    spoken word 的理解形式。例如，如果我们想要一个捡起玩具的命令，我们人类可以用几种方式表达：*抓起一个玩具*，*握住一个玩具*，*拿起那个玩具车*，甚至*拿那个*。我们希望机器人能够理解或至少对所有的这些表述做出相同的反应，驱动机器人手臂前往最近的玩具并将其捡起。STT系统今天相当普遍，但我们希望机器人的语音模式有一些自然的变体，以帮助创造机器人比实际更聪明的错觉。我们可以将这个过程分解为几个步骤，我们将独立处理这些步骤：
- en: Receive audio (sound) inputs. We need the robot to be able to hear or have the
    ability to convert sound into a digital form.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收音频（声音）输入。我们需要机器人能够听到或具有将声音转换为数字形式的能力。
- en: Those sounds need to be converted into text that the robot can process.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些声音需要被转换成机器人可以处理的文本。
- en: Use processing on those text words to understand the intent of the speaker.
    We need to not just recognize individual words but combine those words into sentences
    and from those sentences, infer the intent of the speaker to understand what the
    robot is to do.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对这些文本单词进行加工处理，以理解说话者的意图。我们需要识别单个单词，并将这些单词组合成句子，从这些句子中推断说话者的意图，以理解机器人应该做什么。
- en: Use that intent as a command to perform some task.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用那个意图作为命令来执行某些任务。
- en: Provide verbal responses in the form of spoken words (text to speech, or TTS)
    back to the operator to confirm the robot heard and understood the command.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以语音的形式（文本到语音，或TTS）向操作员提供口头回应，以确认机器人已听到并理解了指令。
- en: Create a custom verbal interface that both tells and responds to knock-knock
    jokes.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个定制的语音界面，既能讲述也能回应“敲门”笑话。
- en: We will start in the next section by introducing the process of STT, which is
    how the robot will receive voice input from you.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节介绍STT的过程，这是机器人如何接收您的语音输入。
- en: Understanding the STT process
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解STT过程
- en: In the rest of this chapter, we will be implementing an AI-based voice recognition
    and response system in the robot and creating our own custom voice interface.
    We will be using Mycroft, an open source voice-activated digital assistant that
    is adept at understanding speech and is easily extended for new functions and
    custom interfaces.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将实现机器人的基于AI的语音识别和响应系统，并创建我们自己的定制语音界面。我们将使用Mycroft，这是一个开源的语音激活数字助手，擅长理解语音，并且易于扩展以实现新的功能和定制界面。
- en: 'We will discuss each of the steps involved in voice interaction in detail.
    There are two forms of STT involved in this process that greatly simplify matters
    for the robot: **wake word recognition** and **STT recognition**. Let’s explore
    wake word recognition first.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细讨论语音交互中涉及的每个步骤。在这个过程中涉及两种STT形式，这大大简化了机器人的任务：**唤醒词识别**和**STT识别**。让我们首先探索唤醒词识别。
- en: Listening for the wake word
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监听唤醒词
- en: In the first approach, the robot is listening continuously for only one sound
    – the wake word. This is a specific sound that just means one thing – get ready
    to process the next sound into a command. Why is this necessary? Since the robot
    has only a very small processor – the Jetson Nano – it really does not have the
    sort of onboard compute power to run a robust STT engine. But it can run a simple
    sound recognizer that can listen for the wake word. You are familiar with this
    from other voice command systems, such as Alexa or Siri, that also either use
    a special wake word or a button to have the interface pay attention (see [https://www.howtogeek.com/427686/how-alexa-listens-for-wake-words/](https://www.howtogeek.com/427686/how-alexa-listens-for-wake-words/)).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种方法中，机器人持续监听唯一的语音——唤醒词。这是一个特定的声音，仅意味着一件事——准备处理下一个声音成为指令。为什么这是必要的呢？由于机器人只有一个非常小的处理器——Jetson
    Nano，它实际上并没有足够的板载计算能力来运行一个健壮的语音识别引擎。但它可以运行一个简单的声音识别器，可以监听唤醒词。您可能从其他语音命令系统中熟悉这一概念，例如Alexa或Siri，它们也使用特殊的唤醒词或按钮来让界面注意（参见[https://www.howtogeek.com/427686/how-alexa-listens-for-wake-words/](https://www.howtogeek.com/427686/how-alexa-listens-for-wake-words/))。
- en: Once the wake word is received, the Jetson Nano switches into record mode and
    records the next thing we say. It then transfers that information to an online
    system, the Google Cloud Speech to Text system (the same thing that runs the Google
    Assistant).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦接收到唤醒词，Jetson Nano将切换到录音模式，并记录我们接下来所说的话。然后，它将信息传输到在线系统，即Google Cloud Speech
    to Text系统（与运行Google Assistant的系统相同）。
- en: 'How does the robot recognize the wake word? The speech system we will be using,
    the open source system Mycroft, uses one of two methods:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人是如何识别唤醒词的？我们将使用的语音系统，开源系统Mycroft，使用两种方法之一：
- en: The first is a **phoneme recognition system** called Sphynx. What is a phoneme?
    You can understand that words are made up of individual sounds, which we roughly
    assign to letters of the alphabet. An example would be the *p* sound in the word
    *pet* or *pick* – this is an example of a phoneme. The word “Albert” has several
    phonemes – the *A* sound, (ah), the *L* sound, the *B*, the *ER* together, and
    finally, the *T*. The letters we associate with the sounds – for example, the
    *ch* in *cherry*, and the *er* in *Albert*, are called **graphemes**, as they
    graphically represent these sounds. We could say that the STT problem is one of
    mapping these phonemes to graphemes, but we know that this is too easy – English
    has all sorts of borrowed words and phrases where the pronunciation and the spelling
    are far apart.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是一个名为Sphynx的**音素识别系统**。什么是音素？你可以理解，单词是由单个声音组成的，我们大致将这些声音分配给字母表中的字母。例如，单词*pet*或*pick*中的*p*声音就是一个音素的例子。单词“Albert”有几个音素——*A*声音（啊），*L*声音，*B*，*ER*组合在一起，最后是*T*。我们与声音关联的字母——例如，*cherry*中的*ch*和*Albert*中的*er*——被称为**图形符号**，因为它们图形地表示了这些声音。我们可以这样说，语音到文本（STT）问题是将这些音素映射到图形符号的问题，但我们知道这太简单了——英语中有各种各样的借词和短语，它们的发音和拼写相差甚远。
- en: The frontend of the Mycroft speech recognition process uses phonemes to recognize
    the wake word. You will find that it is quite sensitive. I had no problem getting
    the speech processor to receive the wake word from eight feet away. When we get
    to the setup, we will change the default Mycroft wake word from “Hey, Mycroft,”
    to “Hey, Albert.”
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Mycroft语音识别过程的前端使用音素来识别唤醒词。你会发现它非常敏感。我没有任何问题让语音处理器从八英尺远的地方接收唤醒词。当我们设置时，我们将默认的Mycroft唤醒词从“嘿，Mycroft”更改为“嘿，阿尔伯特”。
- en: 'Mycroft can also use a trained **neural network** that has been taught to recognize
    entire words all at once by their **spectral power graph**. What is a spectral
    graph? The sound of your voice is not one frequency of sound energy – it is a
    complex congregation of different frequencies produced by our mouths and vocal
    cords. If we spoke in pure frequencies, we would sound like a flute – pure tones
    at mostly one frequency. We can use a process called a **fast Fourier transform**
    to convert a selection of speech into a graph that shows the amount of energy
    (volume) at each frequency. This is called a spectral plot or spectral graph.
    The low frequencies are on the left, and higher frequencies are on the right.
    Most human speech’s energy is concentrated in the frequencies between 300 Hz and
    4,000 Hz. Each word has a unique distribution of sound energy amounts in these
    frequencies, and can be recognized by a neural network in this manner:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mycroft还可以使用一个经过训练的**神经网络**，该网络被训练成通过它们的**频谱功率图**一次性识别整个单词。什么是频谱图？你的声音不是单一频率的声音能量——它是由我们的嘴巴和声带产生的不同频率的复杂集合。如果我们用纯频率说话，我们会像笛子一样——主要是单一频率的纯音。我们可以使用一个称为**快速傅里叶变换**的过程将一段语音转换成一个图表，该图表显示了每个频率的能量（音量）。这被称为频谱图或频谱功率图。低频在左侧，高频在右侧。大多数人类语音的能量集中在300
    Hz到4,000 Hz之间的频率上。每个单词在这些频率上的声音能量分布都是独特的，可以通过这种方式被神经网络识别：
- en: "![Figure 6.1 – Analog audio waveform (top) and the spectral graph for the phrase\
    \ “Hey, Albert” (bottom)\uFEFF](img/B19846_06_1.jpg)"
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – （顶部）模拟音频波形和短语“嘿，阿尔伯特”的频谱图（底部）](img/B19846_06_1.jpg)'
- en: Figure 6.1 – Analog audio waveform (top) and the spectral graph for the phrase
    “Hey, Albert” (bottom)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – （顶部）模拟音频波形和短语“嘿，阿尔伯特”的频谱图（底部）
- en: This preceding diagram shows both the audio waveform (top graph) in the time
    domain and the spectral plot in the frequency domain for the phrase “Hey, Albert.”
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表展示了短语“嘿，阿尔伯特”在时域中的音频波形（顶部图表）和频域中的频谱图。
- en: Both the phoneme method and the neural network method use spectral plots to
    recognize sounds as words, but the phoneme process divides words into individual
    sounds, and the neural network listens and recognizes the entire word all at once.
    Why does this make a big difference? The phoneme system can be developed to recognize
    any word in English without reprogramming or retraining, while the neural network
    has to be trained on each word individually, and hopefully by a lot of different
    speakers with a lot of different accents. We’ll be using the neural network method
    for Albert.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 语音识别方法和神经网络方法都使用频谱图来识别声音作为单词，但语音识别过程将单词分解成单个声音，而神经网络则一次性监听并识别整个单词。这为什么会造成很大的差异呢？语音识别系统可以开发出来识别英语中的任何单词，而无需重新编程或重新训练，而神经网络必须对每个单词单独进行训练，并且希望由很多不同口音的不同说话者进行训练。我们将为阿尔伯特使用神经网络方法。
- en: Note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can remember from [*Chapter 4*](B19846_04.xhtml#_idTextAnchor126) that
    we needed labeled data to train a neural network. You recall we had pictures in
    categories and trained on each category. Training **artificial neural networks**
    (**ANNs**) for sound is the same: we need sounds and the associated words. Can
    you think of a place to get samples of lots of different voices where you also
    have the exact written script to match? Have you ever listened to a book on tape?'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[*第4章*](B19846_04.xhtml#_idTextAnchor126)中回忆起，我们需要标记的数据来训练一个神经网络。你记得我们有一些分类的图片，并在每个分类上进行训练。为声音训练**人工神经网络**（**ANNs**）也是一样的：我们需要声音和相关的单词。你能想到一个地方，那里有很多不同声音的样本，同时也有精确的书面脚本相匹配吗？你有没有听过录音带上的书？
- en: Converting STT
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换语音识别
- en: Our next step after receiving the wake word is to record the next sounds that
    the robot hears. The Mycroft system then transfers that audio data over the internet
    to the Google online STT engine ([https://cloud.google.com/speech-to-text/](https://cloud.google.com/speech-to-text/)).
    This is a quick way to resolve the problem of our little Jetson Nano not having
    enough processing power or storage to have a robust speech recognition capability.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收到唤醒词之后，我们的下一步是记录机器人听到的下一个声音。然后，Mycroft系统将音频数据通过互联网传输到谷歌在线语音识别引擎（[https://cloud.google.com/speech-to-text/](https://cloud.google.com/speech-to-text/)）。这是一种快速解决问题的方法，我们的Jetson
    Nano处理能力或存储空间不足，无法拥有强大的语音识别能力。
- en: What goes on in Google Cloud? The STT engine breaks the speech down into phonemes
    (sounds) and uses a neural network to assign the most probable graphemes (letters)
    to those sounds. The output would be spelled out more phonetically than we want
    to receive. For example, as per the *Carnegie Mellon University Pronouncing Dictionary*,
    the sentence “Pick up the toys, please?” comes out as `P IH K . AH P . DH AH .
    T OY Z . P L IY Z`. Why is this the case? What happened? These are the phonemes
    that make up that sentence. The periods indicate spaces between words. Now the
    system has to convert this into the words we are expecting. The STT system uses
    word rules and dictionaries to come up with the most likely conversion into regular
    words. This includes both expert systems (word rules) and trained neural networks
    that predict output words based on phonemes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌云中发生了什么？语音识别引擎将语音分解成音素（声音），并使用神经网络为这些声音分配最可能的图形（字母）。输出会比我们想要的更音素化。例如，根据*Carnegie
    Mellon大学发音词典*，句子“请捡起玩具？”发音为`P IH K . AH P . DH AH . T OY Z . P L IY Z`。为什么会这样？发生了什么？这些都是构成那个句子的音素。句号表示单词之间的空格。现在系统必须将其转换为我们期望的单词。语音识别系统使用单词规则和词典来得出最可能的常规单词转换。这包括专家系统（单词规则）和基于音素的预测输出单词的训练神经网络。
- en: We can call this step the **language model**. Our STT outputs the sentence “How
    many ounces in a gallon?” and sends it back to the robot, all in less than two
    seconds.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以称这个步骤为**语言模型**。我们的语音识别输出句子“一加仑有多少盎司？”并将其在不到两秒内发送回机器人。
- en: Now that we have the command in text, an English sentence, how does the robot
    recognize what your intent is?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了文本中的命令，一个英语句子，机器人如何识别你的意图呢？
- en: Clarifying the intent
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 明确意图
- en: 'The NLP we are doing has one aim, or goal. We are giving commands to our robot
    using a voice interface. Commands in English normally follow a sentence pattern,
    something like “You – do this.” Often the “you” subject of the sentence is implied
    or understood and left out. We are left with statements such as “Clean this room,”
    or “Pick up those toys.” The intent of these commands is to have the robot initiate
    a program that results in the robot picking up toys and putting them away. The
    robot and its processor have to divine or derive the intent of the user from the
    words that are spoken. What we want is for any reasonable sentence to have as
    its meaning: “You, robot, start your pick-up-toys process.”'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在做的NLP有一个目标或目标。我们通过语音界面向我们的机器人下达命令。英语中的命令通常遵循句子模式，类似于“你 - 做这个。”句子中的“你”主语通常是隐含或理解的，并被省略。我们剩下的是像“清理这个房间”或“捡起那些玩具”这样的陈述。这些命令的意图是让机器人启动一个程序，使机器人捡起玩具并将它们放好。机器人和它的处理器必须从所说的词语中推断或推导出用户的意图。我们希望任何合理的句子都有这样的意义：“你，机器人，开始你的捡起玩具过程。”
- en: 'Think of how many ways we can say that command to the robot. Here are some
    examples:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 想想我们可以有多少种方式对机器人说那个命令。以下是一些例子：
- en: Let’s clean up this room
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们清理这个房间
- en: Put away the toys
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 把玩具放好
- en: Pick up the toys
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拾起玩具
- en: Pick up all the toys
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拾起所有玩具
- en: Clean up this room
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理这个房间
- en: Put those away
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 把那些放好
- en: Put this away
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 把这个放好
- en: Time to clean up
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是时候清理了
- en: What do these phrases have in common? They all imply the subject who is doing
    the action is the robot. There are no words such as “You,” “robot,” or “Albert”
    to indicate to whom the command is intended for. The word “toys” appears a lot,
    as does “pick,” “clean,” and “put away.” It is possible that we can just pay attention
    to those keywords to understand this command. If we get rid of all of the common
    conjunction and pronoun words, what does the list look like?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些短语有什么共同之处？它们都暗示执行动作的主体是机器人。没有像“你”、“机器人”或“阿尔伯特”这样的词来指示命令的目标对象。“玩具”这个词出现很多，同样“捡起”、“清理”和“放好”也经常出现。我们可能只需要关注这些关键词来理解这个命令。如果我们去掉所有常见的连词和代词，这个列表看起来会是什么样子？
- en: Clean room
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理房间
- en: Put toys
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放置玩具
- en: Pick toys
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拾起玩具
- en: Pick toys
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拾起玩具
- en: Clean room
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理房间
- en: Put away
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放好
- en: Put away
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放好
- en: Time clean
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间清洁
- en: An important concept for this chapter is to understand that we are not trying
    to understand all speech, but only that subset of speech that are commands that
    the robot can execute. A general solution to this voice recognition problem would
    be to have some ability to predict from the command given to the robot, the likelihood
    that the intent of the user points to one command more than any of the others.
    You can see that in the case of the word “clean,” none of our other commands (“drive
    around,” “move arm,” or “stop”) relate to “clean” at all. Thus, a sentence with
    “clean” in it is likely associated with the *pick up toys* command. This process
    of deciding intent will be used later in this chapter to send commands to the
    robot using Mycroft.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一个重要概念是理解我们不是试图理解所有语音，而是只理解机器人可以执行的命令子集。解决这个语音识别问题的通用解决方案可能是有能力从机器人收到的命令中预测，用户的意图指向一个命令的可能性比指向其他任何命令的可能性更大。你可以看到，在“清理”这个词的情况下，我们的其他命令（“开车绕圈”、“移动手臂”或“停止”）与“清理”根本不相关。因此，包含“清理”的句子很可能与“捡起玩具”命令相关。这个决定意图的过程将在本章后面用于通过Mycroft向机器人发送命令。
- en: Now we are going to jump right into programming the Albert robot to listen and
    understand commands using Mycroft.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将直接进入编程Albert机器人，使其通过Mycroft监听和理解命令。
- en: Programming our robot
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程我们的机器人
- en: As discussed earlier in this chapter, Mycroft is a version of a digital assistant
    similar to Siri from Apple or Alexa from Amazon in that it can listen to voice
    commands in a mostly normal fashion and interface those commands to a computer.
    We are using it because it has an interface that runs on a Jetson Nano 3\. In
    this section, we will be setting up our hardware and our software (i.e., Mycroft).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所讨论的，Mycroft是一种数字助理版本，类似于苹果的Siri或亚马逊的Alexa，因为它可以以基本上正常的方式监听语音命令并将这些命令与计算机接口。我们使用它是因为它有一个在Jetson
    Nano 3上运行的界面。在本节中，我们将设置我们的硬件和我们的软件（即Mycroft）。
- en: Setting up the hardware
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置硬件
- en: We will be installing Mycroft on Nvidia Jetson Nano (or whatever microprocessor
    you’re using). One of the few things that the Jetson Nano did not come with is
    **audio capability**. It has no speakers or microphones. I found that a quick
    and effective way to add that capability was to use an existing hardware kit that
    provided both a very high-quality speaker and an excellent set of stereo microphones
    in a robot-friendly form factor. Note that this works with pretty much any Linux
    **single-board** **computer** (**SBC**).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Nvidia Jetson Nano（或您使用的任何微处理器）上安装 Mycroft。Jetson Nano 没有附带的一件少数几件事情是**音频功能**。它没有扬声器或麦克风。我发现，添加这种功能的一个快速有效的方法是使用现有的硬件套件，该套件提供了一个非常高质量的扬声器和一个优秀的立体声麦克风套件，且适合机器人使用。请注意，这几乎适用于任何
    Linux **单板** **计算机**（**SBC**）。
- en: The kit is a miniature USB audio board that plugs into the Jetson Nano. It has
    both speakers and a microphone.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 该套件是一个微型 USB 音频板，可插入 Jetson Nano。它既有扬声器也有麦克风。
- en: Note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I used a USB audio board (the brand is not important as any of them will do)
    for the Jetson Nano, which has been working very well for me and fits in the very
    small space we have on the robot. Installation could not be simpler. Plug in the
    audio board. You will need to go to **Settings** in the upper-right corner of
    your screen to select the USB audio version. There will be several other options
    listed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我为 Jetson Nano 使用了一个 USB 音频板（品牌不重要，因为任何一种都行），它对我来说工作得非常好，并且适合我们机器人上非常小的空间。安装过程非常简单。插入音频板。您需要前往屏幕右上角的**设置**来选择
    USB 音频版本。将列出几个其他选项。
- en: Turn on your Jetson Nano 3 with the new speaker and microphone. I ran a quick
    test with YouTube to make sure the audio worked, and you can test it directly
    in the **Settings** user interface. Now we can dive into the software.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的扬声器和麦克风开启您的 Jetson Nano 3。我使用 YouTube 进行了快速测试，以确保音频工作正常，您可以直接在**设置**用户界面中进行测试。现在我们可以深入软件部分。
- en: Setting up the Mycroft software
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Mycroft 软件
- en: 'There are several ways to install Mycroft, as we have to put Mycroft on top
    of the other software we have already:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Mycroft 有几种方法，因为我们必须将 Mycroft 安装在我们已经安装的其他软件之上：
- en: 'Since Mycroft must get along with the ROS, and all of the AI libraries we installed,
    such as TensorFlow, Theano, and Keras, it is best that we use the `git clone`
    method to download the source code and build Mycroft on the Jetson Nano:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 Mycroft 必须与 ROS 以及我们安装的所有 AI 库（如 TensorFlow、Theano 和 Keras）兼容，因此我们最好使用 `git
    clone` 方法下载源代码，并在 Jetson Nano 上构建 Mycroft：
- en: '[PRE0]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Mycroft will create a virtual environment it needs to run. It also isolates
    the Mycroft package from the rest of the packages on the Jetson Nano.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Mycroft 将创建它运行所需的虚拟环境。它还将 Mycroft 软件包与其他 Jetson Nano 上的软件包隔离开。
- en: Note
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please do not install Mycroft as the root user (or superuser). This will cause
    permissions problems with the configuration files.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要以 root 用户（或超级用户）的身份安装 Mycroft。这会导致配置文件出现权限问题。
- en: 'In order to get the Mycroft system to work in this manner, I also had to do
    one more step. The Mycroft system kept failing when I first tried to get it to
    run. It would quit or get stuck when I tried to start the debugger. In order to
    correct this problem, I had to recompile the entire system using the following
    steps:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让 Mycroft 系统能够以这种方式运行，我还必须再进行一个步骤。当我第一次尝试让 Mycroft 运行时，系统总是失败。当我尝试启动调试器时，它会退出或卡住。为了解决这个问题，我必须按照以下步骤重新编译整个系统：
- en: '[PRE1]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can start in debug mode:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以从调试模式开始：
- en: '[PRE2]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, you can ask Mycroft a more advanced skill, such as looking up information
    on the internet. Ask, “Hey, Mycroft, how many ounces in a gallon?” Mycroft will
    use the internet to look up the answer and reply.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你可以向 Mycroft 询问更高级的技能，例如在互联网上查找信息。问：“嘿，Mycroft，一加仑有多少盎司？”Mycroft 将使用互联网查找答案并回复。
- en: Next, you can change the wake word on the Mycroft website to something more
    appropriate – we did not name this robot Mycroft. We have been calling this robot
    Albert, but you can choose to call the robot anything you want. You may find that
    a very short name such as Bob is too quick to be a good wake word, so pick a name
    with at least two syllables. To do this, navigate to the Mycroft web page ([http://home.mycroft.ai](http://home.mycroft.ai))
    and log in to your account, which we created back in *Step 4*. Click on your name
    in the upper right corner and select **Settings** from the menu. You can select
    several settings on this page, such as the type of voice you want, the units of
    measurement, and time and date formats. Select **Advanced Settings**, which will
    take you to the page where we can change the wake word.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你可以在 Mycroft 网站上更改唤醒词，使其更合适——我们并没有给这个机器人起名为 Mycroft。我们一直称这个机器人为阿尔伯特，但你也可以选择给机器人起任何你想要的名字。你可能发现一个非常短的名字，比如鲍勃，可能太短，不适合作为唤醒词，所以选择一个至少有两个音节的词。为此，导航到
    Mycroft 网页（[http://home.mycroft.ai](http://home.mycroft.ai)）并登录你的账户，这是我们之前在**步骤
    4**中创建的。点击右上角的你的名字，从菜单中选择**设置**。你可以在这一页上选择几个设置，例如你想要的语音类型、度量单位以及时间和日期格式。选择**高级设置**，这将带你去一个可以更改唤醒词的页面。
- en: We change the first field, the **Wake word** field, to **Custom**. We change
    the next line to put in our custom wake word – “Hey, Albert.”
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将第一个字段，即**唤醒词**字段，更改为**自定义**。我们将下一行更改为输入我们的自定义唤醒词——“嘿，阿尔伯特。”
- en: We also need to look up the phonemes for this wake word. Go to *The CMU Pronouncing
    Dictionary* from Carnegie Mellon University ([http://www.speech.cs.cmu.edu/cgi-bin/cmudict](http://www.speech.cs.cmu.edu/cgi-bin/cmudict)).
    Put in our phrase and you will get out the phoneme phrase. Copy and paste this
    phrase and go back to the Mycroft page to paste the phoneme phrase into the **Phonemes**
    field. You are done – don’t change any of the other settings.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要查找这个唤醒词的音素。从卡内基梅隆大学的**CMU 发音词典**（[http://www.speech.cs.cmu.edu/cgi-bin/cmudict](http://www.speech.cs.cmu.edu/cgi-bin/cmudict)）查找。输入我们的短语，你将得到音素短语。复制并粘贴这个短语，然后回到
    Mycroft 页面，将音素短语粘贴到**音素**字段中。你已经完成了——不要更改其他任何设置。
- en: Hit **Save** at the top of the page before you navigate away.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你离开页面之前，请点击页面顶部的**保存**按钮。
- en: 'You can test your new wake word back on the Jetson Nano. Start Mycroft up again
    in debug mode and wait for it to come up. Say your new wake phrase and enjoy the
    response. I have a standard test set of phrases to show Mycroft’s skill at being
    the voice of our robot. Try the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Jetson Nano 上测试你的新唤醒词。再次以调试模式启动 Mycroft 并等待其启动。说出你的新唤醒短语并享受其响应。我有一组标准的测试短语来展示
    Mycroft 作为我们机器人声音的能力。尝试以下短语：
- en: Hey, Albert. What time is it?
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嘿，阿尔伯特。现在几点了？
- en: Hey, Albert. What is the weather for tomorrow? Hey, Albert. How many ounces
    in a gallon?
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嘿，阿尔伯特。明天的天气怎么样？嘿，阿尔伯特。一加仑有多少盎司？
- en: Hey, Albert. Who is the king of England?
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嘿，阿尔伯特。英国国王是谁？
- en: You should get the appropriate answers to these questions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到对这些问题的适当答案。
- en: Mycroft has many other skills that we can take advantage of, such as setting
    a timer, setting an alarm, listening to music on Pandora, or playing the news.
    What we will be doing next is adding to these skills by creating our own that
    are specific to our room-cleaning robot.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Mycroft 有许多其他我们可以利用的技能，例如设置定时器、设置闹钟、在 Pandora 上听音乐或播放新闻。我们接下来要做的是通过创建我们自己的、针对我们房间清洁机器人的特定技能来扩展这些技能。
- en: Adding skills
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加技能
- en: The first skill we will create is a command to pick up toys. We are going to
    connect this command to the ROS to control the robot. Later on, we will add a
    skill to tell knock-knock jokes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的第一个技能是捡起玩具的命令。我们将把这个命令连接到 ROS 以控制机器人。稍后，我们将添加一个讲敲门笑话的技能。
- en: Designing our dialogs
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计我们的对话
- en: 'Our first step is to design our dialog on how we will talk to the robot. Start
    by making a list of what ways you might tell the robot to pick up the toys in
    the playroom. Here is my list, which I generated using ChatGPT (version 3.5):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是设计我们的对话，确定我们将如何与机器人交谈。首先，列出你可能告诉机器人去捡起游戏室玩具的各种方式。以下是我的列表，这是我使用 ChatGPT（版本
    3.5）生成的：
- en: Hey robot, could you please start picking up all the toys?
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嘿，机器人，你能帮我开始捡起所有的玩具吗？
- en: It’s time to tidy up. Can you gather all the toys for me?
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是时候整理一下了。你能帮我收集所有的玩具吗？
- en: Need your help, robot. Could you please pick up all the toys and put them in
    the toy bin?
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要你的帮助，机器人。你能帮我捡起所有的玩具并放进玩具箱吗？
- en: Let’s clean up together. Begin by collecting all the toys, please.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们一起来打扫。首先，请收集所有的玩具。
- en: I need a clean room. Can you please start by picking up the toys scattered around?
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我需要一间干净的房间。您能先捡起散落在各处的玩具吗？
- en: Dear robot, would you be so kind as to tidy up the room by gathering all the
    toys?
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亲爱的机器人，您能否麻烦一下，把所有的玩具收拾起来，整理一下房间？
- en: Let’s make this room spotless. Begin with collecting all the toys, please.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们把这个房间打扫得干干净净。请先收集所有玩具。
- en: It’s clean-up time.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是时候打扫了。
- en: Can you pick up all the toys?
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能捡起所有的玩具吗？
- en: Pick up all the toys.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拾起所有玩具。
- en: You could collect all the toys and place them in the toy box.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将所有玩具收集起来，放在玩具箱里。
- en: It’s time to showcase your cleaning skills. Start by picking up all the toys,
    please.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是时候展示您的清洁技能了。请先从捡起所有玩具开始。
- en: Could you please make the room tidy by picking up all the toys?
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请您通过捡起所有玩具来整理房间。
- en: You will note that there are several keywords that are specific to the command
    to clean up the room. We have the word “clean,” of course. We have the phrase
    “pick up,” and “away.” We also have the words “toys” or “toy”, and finally, “mess.”
    These keywords will cue the natural language processor and allow some variation
    in the exact words used.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到有几个关键词是针对清洁房间命令的特定关键词。当然，我们有“清洁”这个词。我们有短语“捡起”和“拿开”。我们还有“玩具”或“玩具”，最后还有“杂乱”。这些关键词将引导自然语言处理器，并允许在确切使用的词语上有所变化。
- en: 'Next, we write down what we want the robot to say back. We don’t want the same
    canned response each time; it would be good to have some natural variation in
    the robot’s responses. Here is my list of responses, created again by ChatGPT3,
    with a variety of robot attitudes represented:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们写下我们希望机器人回应的内容。我们不希望每次都是相同的预设回复；机器人回应的自然变化会更好。以下是我由ChatGPT3创建的回应列表，其中展示了各种机器人的态度：
- en: Command received – picking up toys.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令已接收——捡起玩具。
- en: Of course, I will start cleaning the room right away.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，我会立即开始打扫房间。
- en: Understood, I will tidy up the room and ensure everything is in its proper place.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明白了，我会整理房间，并确保一切物品都归位。
- en: Cleaning mode activated! I will make sure to leave your room spotless and organized.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清洁模式已激活！我会确保您的房间干净整洁、井井有条。
- en: As you wish, I will take care of cleaning the room for you.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如您所愿，我将为您打扫房间。
- en: No problem, I will use my cleaning capabilities to efficiently tidy up the room
    and remove any clutter.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没问题，我会使用我的清洁能力高效地整理房间并清除任何杂乱。
- en: Consider it done! I will sweep, dust, and mop the room to make it pristine for
    you.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已完成！我将打扫、除尘和拖地，让您有一个一尘不染的房间。
- en: Cleaning in progress! I will diligently clean up the room and ensure it’s tidy
    and presentable.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清洁中！我会勤奋地打扫房间，并确保它整洁、可展示。
- en: I’m on it! I will use my cleaning tools and techniques to make your room look
    spick and span.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我明白了！我会使用我的清洁工具和技术，让您的房间看起来一尘不染。
- en: Acknowledged, I will clean up the room and ensure it’s organized and ready for
    your use.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已确认，我将整理房间并确保它整洁有序，以便您使用。
- en: Cleaning task accepted! I will work diligently to make your room clean and inviting,
    just the way you like it.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清洁任务已接受！我会勤奋工作，让您的房间变得干净、舒适，就像您喜欢的那样。
- en: You can use as many of these as you want. The Mycroft system will grab a random
    phrase from this list. This gives us some room for creativity and gives the illusion
    that the robot is more intelligent than it really is. This type of response system
    enables us to quickly develop our dialogs.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用您想要的任何数量的这些短语。Mycroft系统会从这个列表中随机抽取一个短语。这为我们提供了创意空间，并给人一种机器人比实际更智能的错觉。这种响应系统使我们能够快速开发我们的对话。
- en: In the next section, we’ll look at how we can connect voice commands to the
    ROS interface.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何将语音命令连接到ROS接口。
- en: Creating skills
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建技能
- en: In this section, we’ll build the framework in Mycroft that allows it to associate
    our spoken phrases with the commands to be sent to the robot. This will involve
    adding each skill that we want the robot to possess.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建Mycroft框架，使其能够将我们的口语短语与发送给机器人的命令关联起来。这需要添加我们希望机器人拥有的每个技能。
- en: Cleaning up the toys
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 正在整理玩具
- en: 'First, let’s add the most basic skill for Albert – cleaning the room by picking
    up toys. To do this, follow these steps:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为Albert添加最基本的功能——通过捡起玩具来打扫房间。为此，请按照以下步骤操作：
- en: 'Use the `mycroft-msk create` command, which helps us put together our skills
    in the proper format:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`mycroft-msk create`命令，这有助于我们将技能以正确的格式组合在一起：
- en: '[PRE3]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Then it will ask for a class name and a repository name, for both of which I
    used `Cleanroomrobot`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它将询问类名和存储库名，这两个我都使用了 `Cleanroomrobot`。
- en: 'Enter a one-line description for your skill: `Pick up all of the toys in` `the
    room`.'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的技能输入一行描述：`捡起房间里的所有玩具`。
- en: Enter a long description, such as `Command the robot to detect toys, move to
    grab a toy, pick it up, and put it into` `the toybox`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个长描述，例如 `命令机器人检测玩具，移动去抓取一个玩具，拿起它，并将其放入` `玩具箱`。
- en: 'Enter some example phrases to trigger your skill:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一些示例短语以触发你的技能：
- en: '`Hey robot, could you please start picking up all` `the toys?`'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`嘿机器人，你能开始捡起所有` `玩具吗？`'
- en: '`It''s time to tidy up. Can you gather all the toys` `for me?`'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`是时候整理了。你能帮我收集所有玩具吗？`'
- en: '`Can you pick up all` `the toys?`'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`你能捡起所有` `玩具吗？`'
- en: 'Enter the following parameters:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下参数：
- en: '`<your` `name here>`'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<你的` `名字在这里>`'
- en: '`Productivity`'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Productivity`'
- en: '`IoT`'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IoT`'
- en: 'Entering tags makes it easier to search for your skill (although this is optional):
    `robot`, `cleanup`, `pick up`, and `toys`.'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入标签可以更容易地搜索你的技能（尽管这是可选的）：`robot`，`cleanup`，`pick up` 和 `toys`。
- en: 'We will end up with a directory structure in `/opt/Mycroft/skills/cleanroomrobot-skill`
    like the following:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最终会在 `/opt/Mycroft/skills/cleanroomrobot-skill` 目录结构中拥有以下结构：
- en: '[PRE4]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We are going to import the libraries we need from Mycroft (`IntentBuilder`,
    `MycroftSkill`, `getLogger`, and `intent_handler`). We also import `rclpy`, the
    ROS Python interface, and the ROS standard message `String`, which we use to send
    commands to the robot by publishing on the `syscommand` topic:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将导入 Mycroft 所需的库（`IntentBuilder`，`MycroftSkill`，`getLogger` 和 `intent_handler`）。我们还导入
    `rclpy`，ROS 的 Python 接口，以及 ROS 标准消息 `String`，我们通过在 `syscommand` 主题上发布来使用它向机器人发送命令：
- en: '[PRE5]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`MycroftSkill` is a function that is called when one of its phrases is recognized
    by the Mycroft Intent Engine. As such, it has no body or main function, just a
    function definition for the `create_skill` function that instantiates a `MycroftSkill`
    object. The `init` function does most of the work of setting up the various dialogs,
    intent handlers, and vocabulary for the skill. This arrangement works very well
    in our limited environment of giving the robot commands or telling jokes.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`MycroftSkill` 是一个在它的短语被 Mycroft 意图引擎识别时被调用的函数。因此，它没有主体或主函数，只有一个 `create_skill`
    函数的定义，该函数实例化一个 `MycroftSkill` 对象。`init` 函数执行设置技能的各种对话框、意图处理程序和词汇的大部分工作。这种安排在我们的有限环境中工作得非常好，即给出机器人命令或讲笑话。'
- en: 'The next line is the logger for Mycroft so that we can save our responses.
    Anything we put out to stdout, such as print statements, will end up in the log,
    or on the screen if you are in debug mode:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个行是 Mycroft 的日志记录器，这样我们就可以保存我们的响应。我们将输出到 stdout 的任何内容，例如打印语句，最终都会记录在日志中，或者在调试模式下显示在屏幕上：
- en: '[PRE6]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'class Cleanroomrobot(MycroftSkill):'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'class Cleanroomrobot(MycroftSkill):'
- en: 'def __init__(self):'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def __init__(self):'
- en: MycroftSkill.__init__(self)
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MycroftSkill.__init__(self)
- en: 'def setRobotInterface(self,interfce):'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def setRobotInterface(self,interfce):'
- en: self.interface = interfce
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: self.interface = interfce
- en: 'def initialize(self):'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def initialize(self):'
- en: pass  # just return for now
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: pass  # 目前只返回
- en: '[PRE7]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We set up the publisher for our `syscommand` topic in the ROS. This is how
    we send commands to the robot control program via the ROS publish/subscribe system.
    We will be publishing commands only, and the only message format we need is `String`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 ROS 中设置了 `syscommand` 主题的发布者。这是我们通过 ROS 发布/订阅系统向机器人控制程序发送命令的方式。我们只发布命令，我们需要的唯一消息格式是
    `String`：
- en: '[PRE8]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our Mycroft skill is created as a child object of the `MycroftSkill` object.
    We rename our skill object class to `CleanRoomSkill`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 Mycroft 技能被创建为 `MycroftSkill` 对象的子对象。我们将我们的技能对象类重命名为 `CleanRoomSkill`：
- en: '[PRE9]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: According to the template, Mycroft requires both an `init` method and an `initialize`
    method. These commands set up the intent in the Intent Builder part of Mycroft
    and register our handler when any of our phrases are spoken.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据模板，Mycroft 需要一个 `init` 方法和 `initialize` 方法。这些命令在 Mycroft 的意图构建器部分设置意图，并在我们任何短语被说出时注册我们的处理器。
- en: 'Next, we refer to the dialogs we built back in the *Creating skills* section
    with `require("CleanRoomKeyword")`, so be careful that all the spelling is correct:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `require("CleanRoomKeyword")` 引用我们在 *创建技能* 部分构建的对话框，所以请确保所有的拼写都是正确的：
- en: '[PRE10]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This next section creates our handler for when the system has recognized one
    of our phrases, and we want to perform the action for this command. This is where
    we kick off the publish command to the robot’s control program via the ROS using
    the `pubMessage` function we defined earlier:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一节创建了一个处理程序，当系统识别到我们的一种短语时，并希望执行此命令的操作。这就是我们通过之前定义的`pubMessage`函数使用ROS启动向机器人的控制程序发布命令的地方：
- en: '[PRE11]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We also need a `stop` function, where we can command the robot to stop cleaning,
    if necessary, to prevent any sort of *Mickey Mouse – Sorcerer’s* *Apprentice*
    accident:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个`stop`函数，其中我们可以命令机器人停止清洁，如果需要，以防止任何形式的*米老鼠-魔术师-学徒*事故：
- en: '[PRE12]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the movie *Fantasia*, Mickey Mouse acts out the part of the Sorcerer’s Apprentice
    from a fairy tale. In the story, the Apprentice learns to animate a broom, which
    he teaches to fetch water from a well. The problem is the Apprentice never learned
    how to stop the enchantment, and soon the room is flooded.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在电影《幻想曲》中，米老鼠扮演了童话中魔术师的学徒的角色。在故事中，学徒学会了使扫帚活动，他教扫帚从井里取水。问题是学徒从未学会如何停止魔法，很快房间里就充满了水。
- en: 'We now need a block of code to create the skill in the program where we can
    associate the ROS interface to the robot into the skill. We will add a `create_skill`
    function to allow Mycroft to create the skill and to have a function pointer to
    enable the skill:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要一个代码块来在程序中创建技能，以便我们将ROS接口与机器人关联到技能中。我们将添加一个`create_skill`函数，以便Mycroft创建技能并有一个函数指针来启用技能：
- en: '[PRE13]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we have the ROS interface. All we need to do is send a command to the
    robot to publish mode commands on our `RobotCmd` topic:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有ROS接口。我们只需要向机器人发送一个命令，在`RobotCmd`主题上发布模式命令：
- en: '[PRE14]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We define our ROS interface and create a control node called `mycroftROS` to
    serve as our interface. Then we create a subscriber and publisher to the `RobotCmd`
    topic so we can send and receive commands from the ROS 2 interface.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们定义我们的ROS接口并创建一个名为`mycroftROS`的控制节点，作为我们的接口。然后我们创建一个订阅者和发布者到`RobotCmd`主题，这样我们就可以从ROS
    2接口发送和接收命令。
- en: 'The rest of the program is just housekeeping. We need to start up our ROS node,
    start the Mycroft logger, and instantiate the ROS interface object and the `cleanSkill`
    objects for ROS and Mycroft, respectively. Then we point the `cleanSkill` object
    to the ROS interface so they can communicate. Finally, we start the ROS 2 interface
    with the `.spin` function. When the program is stopped, we fall out of `.spin`
    and shut down our program:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序的其余部分只是日常维护。我们需要启动我们的ROS节点，启动Mycroft记录器，并实例化ROS接口对象和ROS和Mycroft的`cleanSkill`对象。然后我们将`cleanSkill`对象指向ROS接口，以便它们可以通信。最后，我们使用`.spin`函数启动ROS
    2接口。当程序停止时，我们退出`.spin`并关闭我们的程序：
- en: '[PRE15]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In order for our skill to work, we need to copy our directory to `/opt/mycroft/skills`.
    From there, we can test it in debug mode. Remember that you have to source the
    ROS 2 directory (`source /opt/ros/foxy/local_setup.sh` and `source ~/ros2_ws/install/local_setup.sh`)
    or the program won’t be able to find all of the inclusion files or ROS nodes.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使我们的技能正常工作，我们需要将我们的目录复制到`/opt/mycroft/skills`。从那里，我们可以在调试模式下测试它。记住，你必须源ROS
    2目录（`source /opt/ros/foxy/local_setup.sh`和`source ~/ros2_ws/install/local_setup.sh`），否则程序将无法找到所有包含文件或ROS节点。
- en: Our next skill comes at the request of my grandson, William, who just adores
    knock-knock jokes. William is seven, so he is just the right age for this. Let’s
    look at how we can implement this.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个技能是根据我的孙子威廉的要求来的，他非常喜欢敲敲门笑话。威廉七岁，所以他正是适合这个年龄。让我们看看我们如何实现它。
- en: Telling jokes
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 讲笑话
- en: 'In this section, we will handle the case where the robot is telling the knock-knock
    joke. As you probably know, knock-knock jokes are pun-based jokes that always
    take the same form:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将处理机器人讲敲敲门笑话的情况。如您所知，敲敲门笑话是基于双关语的笑话，通常采用相同的形式：
- en: 'Person 1: Knock, knock'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个人：敲，敲
- en: 'Person 2: Who’s there?'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个人：谁在那里？
- en: 'Person 1: Wooden'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个人：木
- en: 'Person 2: Wooden Who?'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个人：木谁？
- en: 'Person 1: Wooden you like to know!'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个人：你愿意知道吗！
- en: 'As you can see, the dialog is very simple. Several parts of it are standard,
    such as the first two lines – “Knock, knock” and “Who’s there?” We can create
    a generic knock-knock joke in the following form:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，对话非常简单。其中一些部分是标准的，例如前两行——“敲，敲”和“谁在那里？”我们可以在以下形式中创建一个通用的敲敲门笑话：
- en: Knock, knock.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 敲，敲。
- en: Who’s there?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 谁在那里？
- en: '`<``word 1>`'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<``word 1>`'
- en: '`<word` `1>` who?'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<word` `1>`谁？'
- en: '`<``punchline phrase>`'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<``punchline phrase>`'
- en: In defining our joke, you can see we just have two variable elements – the word
    in *Step 3*, and the punchline phrase in *Step 5*. Our word is repeated in *Step
    4*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义我们的笑话时，您可以看到我们只有两个变量元素——*步骤3*中的单词和*步骤5*中的笑点短语。我们的单词在*步骤4*中被重复。
- en: 'We begin by creating a joke database of one-line jokes, which we will put in
    a text file. Since we just have two elements, we can separate them with a slash
    (`/)`. Here is an example:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个包含单行笑话的笑话数据库，我们将将其放入一个文本文件中。由于我们只有两个元素，我们可以用斜杠(`/`)来分隔它们。以下是一个示例：
- en: '[PRE16]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: I’m providing you with a database of about 10 jokes in the files section of
    the repository for this chapter. Please feel free to add all of your favorites,
    or send them to me and I’ll add them.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我在当前章节的仓库文件部分提供了一个大约10个笑话的数据库。请随意添加您喜欢的所有笑话，或者发送给我，我会添加它们。
- en: 'Now, let’s look at the steps involved in telling the joke:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看讲笑话所涉及的步骤：
- en: We will start, as with any skill, with the wake word, “Hey, Albert.”
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将像任何技能一样，从唤醒词“嘿，阿尔伯特”开始。
- en: Then we need a phrase to indicate we want to hear a joke, so we will use variations
    of “Tell me a knock-knock joke,” such as “I want to hear a knock-knock joke.”
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要一个短语来表示我们想要听一个笑话，所以我们将使用“告诉我一个敲门笑话”的变体，例如“我想听一个敲门笑话”。
- en: This will trigger our skill program to look up a joke. We will create several
    intents, or response capabilities, to respond to the user (or child) talking to
    the robot. We will start with the “Who’s there?” dialog intent. That will let
    the robot know to proceed to the next part of the joke, which is to say our word.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将触发我们的技能程序查找一个笑话。我们将创建几个意图或响应能力来响应用户（或孩子）与机器人交谈。我们将从“谁在那里？”对话意图开始。这将让机器人知道继续到笑话的下一部分，即说出我们的单词。
- en: Then we disable the “Who’s there?” dialog and enable a dialog for listening
    for `<word>` and the phrase “who.”
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们禁用了“谁在那里？”对话，并启用了一个用于监听`<word>`和短语“who”的对话。
- en: Then we can deliver the final part of the joke by reciting the punchline phrase,
    and we are done.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以通过背诵笑点短语来传达笑话的最后一部分，这样我们就完成了。
- en: 'How can we implement this? You can follow these steps:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何实现这个功能？您可以按照以下步骤进行：
- en: 'We start by creating our vocabulary files, of which we will need three. These
    are the things that the user will be saying to the robot. We have our first “tell
    me a knock, knock joke” phrase – so let’s create a file called `knockknock.voc`
    (you can use any text editor to create the file) and put the following in it:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建我们的词汇文件，我们需要三个。这些是用户将对机器人说的话。我们有第一个“告诉我一个敲门笑话”短语——所以让我们创建一个名为`knockknock.voc`的文件（您可以使用任何文本编辑器来创建文件）并将以下内容放入其中：
- en: '[PRE17]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Please note that the Mycroft STT system interprets the phrase “knock, knock”
    as `knock-knock` with a hyphen, so it is important to put that into our script.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，Mycroft STT系统将短语“敲门”解释为带有连字符的`knock-knock`，所以将这一点放入我们的脚本中非常重要。
- en: Now our second vocabulary is just “Who’s there,” so we can create this as a
    second `.voc` file, `whosthere.voc`, which contains the line `Whos there`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们第二个词汇是“谁在那里”，因此我们可以创建这个作为第二个`.voc`文件，`whosthere.voc`，它包含一行`Whos there`。
- en: Our final line is a bit trickier. We really only care about the keyword “who”
    to trigger the punchline, so we can look only for that. Make a file called `who.voc`
    and put the one word `who` in it. Remember these all go in the `dialog/en-us`
    folder in our `skill` directory.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的最后一行有点棘手。我们真正关心的是触发笑点的关键词“谁”，所以我们只需查找那个词。创建一个名为`who.voc`的文件，并将一个单词`who`放入其中。记住，这些文件都应该放在我们的`skill`目录下的`dialog/en-us`文件夹中。
- en: 'Now for our responses. We have one canned response, which is to reply to “tell
    me a knock-knock joke” with the phrase “knock, knock.” We don’t need any sophisticated
    dialog system, we just have the robot say the “knock, knock” phrase. To do this,
    we first import the libraries we need to call in this program, which are the `MycroftSkill`
    class and the `intent_file_handler` function:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来处理我们的回应。我们有一个预设的回应，即用短语“敲门”来回应“告诉我一个敲门笑话”。我们不需要任何复杂的对话系统，我们只需要让机器人说出“敲门”短语。为此，我们首先导入在这个程序中需要调用的库，即`MycroftSkill`类和`intent_file_handler`函数：
- en: '[PRE18]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We define our skill as a child object of the `MycroftSkill` object – this is
    a standard object-oriented design. We are inheriting all of the functions and
    data of the `MycroftSkill` parent object and adding our own functionality to it.
    We create an initialize function and then call the `init` parent function to execute
    the code of the parent class as well. We are augmenting the functionality of the
    `init` parent function. Without this call, we would be replacing the `init` function
    with our own, and might have to duplicate a considerable amount of work:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将我们的技能定义为 `MycroftSkill` 对象的子对象——这是一个标准的面向对象设计。我们正在继承 `MycroftSkill` 父对象的所有功能和数据，并添加我们自己的功能。我们创建了一个初始化函数，然后调用
    `init` 父函数来执行父类的代码。我们正在增强 `init` 父函数的功能。如果没有这个调用，我们将用我们自己的替换 `init` 函数，可能需要复制大量工作：
- en: '[PRE19]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The next step is to create our `knockknock.intent` file and place that file
    in the `voc` directory (which was `dialog/voc-en`):'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建我们的 `knockknock.intent` 文件，并将该文件放置在 `voc` 目录中（之前是 `dialog/voc-en`）：
- en: '[PRE20]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we get two parts from the joke database:'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们从笑话数据库中获取两个部分：
- en: The name to say after “who’s there”
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“谁在那里”之后要说的名字
- en: The punchline that ends the joke
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结束笑话的点睛之笔
- en: 'We use the `get_response` function from `MycroftSkill` to have the robot make
    a statement and then wait for a reply, which will get turned into a text string
    and stored in the `response` variable:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `MycroftSkill` 中的 `get_response` 函数让机器人发表声明并等待回复，该回复将被转换成文本字符串并存储在 `response`
    变量中：
- en: '[PRE21]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we are at the part where the robot says the name in response. For example,
    the user asks “who’s there?” and the robot replies “Harold.” What we are expecting
    next is for the user to say “Harold (or whatever name) who?” We will check our
    response, and see whether the word “who” is included. If it is not, we can prompt
    the user to follow along with the joke. We will only do this one time to keep
    from getting stuck in a loop. If they are not playing along, the robot will just
    continue:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们到了机器人回应名字的部分。例如，用户问“谁在那里？”机器人回答“哈罗德。”我们期待用户接下来会说“哈罗德（或任何名字）谁？”我们将检查我们的回应，看看是否包含单词“谁”。如果没有，我们可以提示用户跟随笑话。我们只会这样做一次，以避免陷入循环。如果他们不参与，机器人将继续：
- en: '[PRE22]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We have moved through the joke, so now we get to say the punchline, such as
    “Harold you like a hug?” (How would you like a hug?). The task is complete and
    we exit the routine; both the comedy routine and the program routine:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经讲完了笑话，现在轮到说出点睛之笔，比如“哈罗德，你想拥抱吗？”（你想要拥抱吗？）。任务完成，我们退出程序；既包括喜剧程序也包括程序程序：
- en: '[PRE23]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We need a function to read the joke database we defined earlier. As described
    earlier, the database has one knock-knock joke per line, with a forward slash
    (`/`) between the name and the punchline. We read all of the jokes, put them in
    a list, and then choose one at random using the (wait for it) `random.choice`
    function. We return the name and the punchline separately. We should only call
    this routine once per instance of the joke:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个函数来读取我们之前定义的笑话数据库。如前所述，数据库中每行有一个敲门笑话，名字和点睛之笔之间用正斜杠（`/`）分隔。我们读取所有笑话，将它们放入一个列表中，然后使用（等着瞧）`random.choice`
    函数随机选择一个。我们分别返回名字和点睛之笔。我们应该只为每个笑话实例调用这个程序一次：
- en: '[PRE24]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We finish the program by defining our instance of the `Knockknock` class and
    returning that object to the calling program, Mycroft:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过定义 `Knockknock` 类的实例并返回该对象给调用程序 Mycroft 来结束程序：
- en: '[PRE25]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Next, we’ll discuss the other end of the knock-knock joke concept, which is
    to receive a joke – where the child wants to tell the robot a joke. If you know
    any seven-year-olds, then you know that this is a requirement also – the child
    will want to tell the robot a joke as well.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论敲敲门笑话概念的另一端，即接收笑话——孩子想要告诉机器人一个笑话。如果你认识任何七岁的孩子，那么你知道这也是一个要求——孩子也会想要告诉机器人一个笑话。
- en: Receiving jokes
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 接收笑话
- en: The receiving dialog is pretty simple as well. The user will say “knock, knock”,
    which is the cue to the robot to go into the *receive knock-knock joke* mode.
    The robot then has only one response – “who’s there.” We could also add “who is
    there?” if we want to keep to the common sci-fi concept that robots do not use
    contractions.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接收对话也很简单。用户会说“敲门，敲门”，这是机器人进入接收“敲门笑话”模式的提示。然后机器人只有一个回应——“谁在那里。”如果我们想保持科幻中常见的概念，即机器人不使用缩写，我们也可以添加“谁在那里？”
- en: Note
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Data, the android from *Star Trek: The Next Generation*, stated many times
    he was not able to use contractions, although the writers slipped up from time
    to time.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 来自《星际迷航：下一代》的机器人Data多次声明他无法使用缩写，尽管编剧偶尔会犯错误。
- en: 'In order to create our schema for our new Mycroft skill, we will be using the
    `pip3 install msk`. MSK provides a dialog-driven approach to building skills that
    will make a framework, including all of the subdirectories for dialog files and
    vocabulary. This saves a lot of time, so let’s try it out:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们新的Mycroft技能的架构，我们将使用`pip3 install msk`。MSK提供了一个基于对话的方法来构建技能，这将创建一个框架，包括所有对话文件和词汇的子目录。这节省了很多时间，所以让我们试试：
- en: 'The following is the command for creating the *receive knock-knock* *joke*
    code:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是为创建“接收敲门”笑话代码的命令：
- en: '[PRE26]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We start with our imports, which are `MycroftSkill` and `intent_file_handler`.
    We will also need the `time` library to do some pauses:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从导入开始，这些是`MycroftSkill`和`intent_file_handler`。我们还需要`time`库来进行一些暂停：
- en: '[PRE27]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here is our class definition for our `ReceiveKnock` class, which is a child
    class of the `MycroftSkill` object we imported. We start the `init` function by
    passing an `init` command back up to the parent class (`MycroftSkill`) and have
    it do its initialization. Then we add our custom functionality on top of that:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是我们为`ReceiveKnock`类定义的类，它是我们导入的`MycroftSkill`对象的子类。我们在`init`函数中通过传递一个`init`命令回传给父类（`MycroftSkill`）并让它执行初始化。然后我们在其基础上添加我们的自定义功能：
- en: '[PRE28]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The next section is our intent handler for receiving a knock-knock joke. We
    use the `@decorator` to extend the intent handler, in this case, reading the parameters
    of the intent from a file called `knock.receive.intent`. The intent handler just
    has our two key words, the immortal phrase: `knock, knock`. We are fortunate that
    all jokes start exactly the same way, so we only have these two words.'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一节是我们的意图处理器，用于接收“敲门”笑话。我们使用`@decorator`来扩展意图处理器，在这种情况下，从名为`knock.receive.intent`的文件中读取意图的参数。意图处理器只有我们两个关键词，不朽的短语：“敲门，敲门”。我们很幸运，所有的笑话都以完全相同的方式开始，所以我们只需要这两个词。
- en: 'After the `handle_knock_receive` function has been activated by the Intent
    Engine seeing the phrase “knock, knock,” we then get control passed to our handler.
    What is our next step? We reply with the single answer “Who is there?” You will
    remember we said robots do not use contractions. We use a different function to
    do this. We don’t want to use another intent handler, but fortunately, Mycroft
    provides a free-form interface called `get_response`. You need to look up the
    documentation for this versatile function, but it makes our joke routine a lot
    simpler. The `get_response` function both lets us speak our reply and then receive
    whatever the user says next and store it as a string in the `response` variable:'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在意图引擎看到短语“敲门，敲门”并激活`handle_knock_receive`函数后，控制权传递到我们的处理器。我们的下一步是什么？我们用一个简单的回答“谁在那里？”来回应。你会记得我们说过机器人不使用缩写。我们使用不同的函数来做这件事。我们不希望使用另一个意图处理器，但幸运的是，Mycroft提供了一个自由形式的接口，称为`get_response`。你需要查找这个多功能函数的文档，但它使我们的笑话程序变得更加简单。`get_response`函数既让我们说出我们的回答，然后接收用户接下来说的任何话，并将其存储为字符串在`response`变量中：
- en: '[PRE29]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now that we have our response, we can just repeat it back with the robot’s voice,
    with the additional word “who?” So, if the child says, “Howard,” the robot responds
    “Howard who?”
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们有了我们的回应，我们可以用机器人的声音重复它，并额外加上一个词“谁？”。所以，如果孩子说，“霍华德”，机器人回应“霍华德谁？”
- en: 'We use `get_response` again to have the robot speak and then record whatever
    the child or adult says next. We don’t need it, but we want to have the robot’s
    speech system listen to whatever is said next. We toss away the response, but
    insert our own comment to the joke from our dialog `veryfunny.dialog`, which is
    a file in the `dialog` directory. I created this file to hold responses to our
    jokes from the robot. I tried to make some responses that the grandchildren would
    find funny – I guess I can add “robot joke writer” to my resume, as I seem to
    have done this a lot in my career. After this, I added a sleep timer to allow
    everything to settle down before returning control. We include the standard `stop`
    function required of all `MycroftSkills`, and make our `create_skill` function
    make a `ReceiveCall` object and return it:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们再次使用`get_response`让机器人说话，并记录孩子或成人接下来所说的话。我们不需要它，但我们想让机器人的语音系统听到接下来所说的话。我们丢弃了回应，但将我们自己的评论插入到我们的对话`veryfunny.dialog`中，这是一个位于`dialog`目录的文件。我创建了这个文件来保存机器人对我们笑话的回应。我尝试了一些孙子辈可能会觉得好笑的回应——我想我可以把“机器人笑话作家”加到我的简历上，因为我似乎在我的职业生涯中做了很多这样的事情。之后，我添加了一个睡眠计时器，以便在返回控制之前让一切平静下来。我们包括所有`MycroftSkills`所需的`stop`函数，并让我们的`create_skill`函数创建一个`ReceiveCall`对象并返回它：
- en: '[PRE30]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can get as creative as you want with the responses, but here are my suggestions:'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以想多创意就有多创意，但这里是我的建议：
- en: That was very funny!
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那真是太有趣了！
- en: Ha ha ha.
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈哈哈哈。
- en: Very good joke.
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真是好笑。
- en: I like that one. Thank you!
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我喜欢这个。谢谢！
- en: Ho HO! Ho.
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈哈！哈哈。
- en: That was cute!
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那真可爱！
- en: I do not have a sound for a groan thththththpppppp!
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我没有咕噜咕噜的声音！
- en: 'Here is our directory structure and files for our receive knock-knock jokes
    skill:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的接收敲门笑话技能的目录结构和文件：
- en: '[PRE31]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Remember the local version of the skill goes in the `/opt/mycroft/skills/receive-knock-skill`
    directory. Now test to your heart’s content – how many knock-knock jokes can you
    tell the robot?
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 将技能的本地版本放入`/opt/mycroft/skills/receive-knock-skill`目录。现在尽情测试吧——你能对机器人讲多少个敲门笑话？
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter introduced NLP for robotics and concentrated on developing a natural
    language interface for the robot that accomplished three tasks: starting the *pick
    up toys* process, telling knock-knock jokes, and listening to knock-knock jokes.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了用于机器人的自然语言处理技术，并专注于开发一个能够完成三项任务的机器人自然语言界面：启动*捡玩具*过程，讲讲敲门笑话，以及听敲门笑话。
- en: The concepts introduced included recognizing words by phonemes, turning phonemes
    into graphemes and graphemes into words, parsing intent from sentences, and executing
    computer programs with a voice interface. We introduced the open source AI engine,
    Mycroft, which is an AI-based voice assistant program that runs on the Jetson
    Nano. We also wrote a joke database to entertain small children with some very
    simple dialog.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍的概念包括通过音素识别单词，将音素转换为音素和音素转换为单词，从句子中解析意图，以及通过语音界面执行计算机程序。我们介绍了开源AI引擎Mycroft，这是一个基于AI的语音助手程序，在Jetson
    Nano上运行。我们还编写了一个笑话数据库，用一些非常简单的对话来娱乐小孩子。
- en: In the next chapter, we’ll be learning about **robot navigation** using landmarks,
    neural networks, obstacle avoidance, and machine learning.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习使用地标、神经网络、避障和机器学习进行**机器人导航**。
- en: Questions
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Do some internet research on why the AI engine was named Mycroft. How many different
    stories did you find, and which one did you like?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 做一些互联网研究，了解为什么AI引擎被命名为Mycroft。你找到了多少不同的故事，哪一个是你喜欢的？
- en: In the discussion of intent, how would you design a neural network to predict
    command intent from natural language sentences?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在讨论意图时，你会如何设计一个神经网络来从自然语言句子中预测命令意图？
- en: Rewrite “Receive knock-knock jokes” to remember the jokes told to the robot
    by adding them to the joke database used by the “tell knock knock jokes” program.
    Is this machine learning?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“接收敲门笑话”重写为记住机器人所讲的笑话，将它们添加到“讲敲门笑话”程序使用的笑话数据库中。这是机器学习吗？
- en: Modify the “tell jokes” program to play sounds from a wave file, such as a music
    clip, as well as doing TTS.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“讲笑话”程序修改为播放波形文件中的声音，例如音乐剪辑，以及进行语音合成。
- en: The sentence structures used in this chapter are all based on English grammar.
    Other languages, such as French and Japanese, have different structures. How does
    that change the parsing of sentences? Would the program we wrote be able to understand
    Yoda?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本章使用的句子结构都是基于英语语法的。其他语言，如法语和日语，有不同的结构。这会如何改变句子的解析？我们编写的程序能否理解Yoda？
- en: Do you think that Mycroft’s Intent Engine is actually understanding intent,
    or just pulling out keywords?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你认为 Mycroft 的意图引擎实际上是在理解意图，还是只是在提取关键词？
- en: Describe the voice commands necessary to instruct the robot to drive to an object
    and pick it up without the robot being able to recognize the object. How many
    commands do you need?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述必要的语音命令，以指导机器人驶向一个物体并拿起它，而机器人无法识别该物体。你需要多少个命令？
- en: From *Question 7*, work to minimize the number of commands. How many can you
    eliminate or combine?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自 *问题7*，努力减少命令的数量。你可以消除或合并多少个？
- en: Also from *Question 7*, how many unique keywords are involved? How many non-unique
    keywords?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也来自 *问题7*，涉及多少个独特的关键词？多少个非独特关键词？
- en: Further reading
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Python Natural Language Processing* by Jalaj Thanaki, Packt Publishing'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Python 自然语言处理》* by Jalaj Thanaki，Packt Publishing'
- en: '*Artificial Intelligence with Python* by Prateek Joshi, Packt Publishing'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Python 人工智能》* by Prateek Joshi，Packt Publishing'
- en: Mycroft tutorial for developing skills is located at [https://mycroft.gitbook.io/mycroft-docs/developing_a_skill/introduction-developing-skills](https://mycroft.gitbook.io/mycroft-docs/developing_a_skill/introduction-developing-skills)
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mycroft 开发技能教程位于 [https://mycroft.gitbook.io/mycroft-docs/developing_a_skill/introduction-developing-skills](https://mycroft.gitbook.io/mycroft-docs/developing_a_skill/introduction-developing-skills)
- en: Additional documentation for using Mycroft is located at [https://media.readthedocs.org/pdf/mycroft-core/stable/mycroft-core.pdf](https://media.readthedocs.org/pdf/mycroft-core/stable/mycroft-core.pdf)
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Mycroft 的附加文档位于 [https://media.readthedocs.org/pdf/mycroft-core/stable/mycroft-core.pdf](https://media.readthedocs.org/pdf/mycroft-core/stable/mycroft-core.pdf)
- en: 'Part 3: Advanced Concepts – Navigation, Manipulation, Emotions, and More'
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：高级概念 – 导航、操作、情感等
- en: In the last part of the book, we tackle more advanced topics including AI-based
    navigation and obstacle avoidance. We learn about decision trees and classification
    algorithms for unsupervised learning and then start an exciting chapter on creating
    a simulation of a robot personality. While we can’t give a robot real emotions,
    we can create a simulation of emotion using state machines and Monte Carlo techniques.
    Finally, we end the book with a discussion of AI philosophy and a look at the
    future from the author’s perspective, and provide advice for people wanting to
    pursue robotics and autonomy as a career.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后部分，我们探讨更高级的主题，包括基于 AI 的导航和避障。我们了解无监督学习的决策树和分类算法，然后开始一个关于创建机器人性格模拟的激动人心的章节。虽然我们无法给机器人赋予真实的情感，但我们可以使用状态机和蒙特卡洛技术来创建情感模拟。最后，我们以作者的角度讨论
    AI 哲学，并展望未来，为那些想将机器人学和自主性作为职业的人提供建议。
- en: 'This part has the following chapters:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 7*](B19846_07.xhtml#_idTextAnchor221), *Teaching the Robot to Navigate
    and Avoid Stairs*'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B19846_07.xhtml#_idTextAnchor221), *教机器人导航和避免楼梯*'
- en: '[*Chapter 8*](B19846_08.xhtml#_idTextAnchor235), *Putting Things Away*'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B19846_08.xhtml#_idTextAnchor235), *整理物品*'
- en: '[*Chapter 9*](B19846_09.xhtml#_idTextAnchor294), *Giving the Robot an Artificial
    Personality*'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B19846_09.xhtml#_idTextAnchor294), *赋予机器人一个人工性格*'
- en: '[*Chapter 10*](B19846_10.xhtml#_idTextAnchor366), *Conclusions and Reflections*'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B19846_10.xhtml#_idTextAnchor366), *结论和反思*'
