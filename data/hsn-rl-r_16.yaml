- en: Deep Q-Learning Using Keras
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Keras进行深度Q学习
- en: Keras is a library of high-level neural networks, written in Python and able
    to work using different support libraries. It was developed to allow rapid experimentation.
    Keras allows easy and fast prototyping using total modularity, minimalism, and
    extensibility. It supports both convolutional networks and recurrent networks
    and combinations of both. Furthermore, it supports arbitrary connectivity schemes
    and runs smoothly on CPU and GPU. In this chapter, we will learn how to approach
    reinforcement learning using Keras. We will learn to use Keras to develop a model
    that can recognize handwritten digits. Later, we will use deep Q-learning to balance
    a cart pole.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Keras是一个高级神经网络库，使用Python编写，并能够与不同的支持库配合使用。它的开发旨在允许快速实验。Keras通过完全模块化、极简主义和可扩展性，提供了简单且快速的原型设计功能。它支持卷积网络和递归网络，以及两者的组合。此外，它支持任意连接方案，并能在CPU和GPU上平稳运行。在本章中，我们将学习如何使用Keras处理强化学习。我们将学习如何使用Keras开发一个能够识别手写数字的模型。随后，我们将使用深度Q学习来平衡小车摆杆系统。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to Keras
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Keras介绍
- en: Multilayer perceptron for image processing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像处理中的多层感知机
- en: Approaching deep-Q learning
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度Q学习方法
- en: By the end of this chapter, we will have explored the Keras model using TensorFlow
    as the backend engine and how to use Keras to set up a **Multilayer Perceptron**
    (**MLP**) model. Then, we will learn how to use deep reinforcement learning to
    balance a cart pole system.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将探索使用TensorFlow作为后端引擎的Keras模型，并学习如何使用Keras设置**多层感知机**（**MLP**）模型。接着，我们将学习如何使用深度强化学习来平衡小车摆杆系统。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，观看代码运行实例：
- en: '[http://bit.ly/2qMtw3I](http://bit.ly/2qMtw3I)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2qMtw3I](http://bit.ly/2qMtw3I)'
- en: Introduction to Keras
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Keras介绍
- en: Keras is a Python library that provides a simple and clean way to create a range
    of deep learning models. Keras code was released under the MIT license. Keras
    has been structured based on austerity and simplicity, and it provides a no frills
    programming model that maximizes readability. It allows neural networks to be
    expressed in a very modular way, considering a model as a sequence or a single
    graph. This is a good approximation because the components of a deep learning
    model are discrete elements that can be arbitrarily combined. New components are
    easily aggregated and modifiable within the framework designed for engineers,
    to quickly test and explore new ideas. Finally, using the Python programming language
    provides constructs that allow clear programming on both a small and large scale.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Keras是一个Python库，提供了一种简单、清晰的方式来创建各种深度学习模型。Keras的代码在MIT许可下发布。Keras的结构基于简洁和简约原则，提供了一种没有多余功能的编程模型，最大限度地提高了可读性。它允许神经网络以非常模块化的方式表达，将模型视为一系列组件或单一图形。这是一个很好的近似，因为深度学习模型的组件是可以任意组合的离散元素。新的组件可以在为工程师设计的框架内轻松集成和修改，以快速测试和探索新想法。最后，使用Python编程语言提供的构造允许在小规模和大规模上进行清晰编程。
- en: 'In the following screenshot, we can see the Keras official home page ([https://keras.io/](https://keras.io/)):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在下方截图中，我们可以看到Keras的官方网站首页（[https://keras.io/](https://keras.io/)）：
- en: '![](img/9c4131d3-f184-4443-a1d1-d6baaa8b0d6a.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c4131d3-f184-4443-a1d1-d6baaa8b0d6a.png)'
- en: Its ease of use is the strong point of Keras. During the design phase, the user
    has been the focus of the attention of the developers, producing a product that
    reduces the user's work using simple and consistent APIs. In this way, the number
    of actions necessary to solve common use cases is reduced. Also, the results are
    returned clearly, making the identification of possible errors very simple.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Keras的易用性是其强大优势之一。在设计阶段，开发者一直将用户需求作为重点，创造出了通过简单一致的API来减少用户工作量的产品。这样，解决常见用例所需的操作数量被大大减少。此外，结果返回清晰，便于迅速识别潜在错误。
- en: In Keras, a model is represented by a sequence of autonomous and completely
    configurable modules that can relate to the lowest possible number of restrictions.
    Everything in Keras is a module—neural layers, cost functions, optimizers, initialization
    schemes, activation functions, and regularization schemes. These independent modules
    can be combined to create new, more complex models.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Keras 中，一个模型由一系列自主且完全可配置的模块组成，这些模块可以与最低限度的约束条件相关联。Keras 中的一切都是模块——神经网络层、代价函数、优化器、初始化方案、激活函数和正则化方案。这些独立的模块可以组合在一起，创建新的、更复杂的模型。
- en: All modules available in Keras are simple to add, and so are new classes and
    functions in a programming language. Also, the modules are already available and
    are accompanied by numerous examples that explain their practical use. But Keras
    is not limited to the availability of the built-in modules. The user will be able
    to easily create new modules, making Keras an easily extensible environment.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Keras 中可用的所有模块都很容易添加，就像在编程语言中添加新的类和函数一样。此外，这些模块已经可用，并且附带了大量解释其实际应用的示例。但 Keras
    并不限于内置模块的可用性。用户可以轻松创建新的模块，使得 Keras 成为一个易于扩展的环境。
- en: 'The `keras` library bases its technology on the levels that are used to manage
    input and output. An application in Keras can be implemented through the following
    four simple steps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`keras` 库基于用于管理输入和输出的层技术。在 Keras 中，应用可以通过以下四个简单步骤实现：'
- en: Prepare input and output data.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备输入和输出数据。
- en: Create the first level to manage the input data.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第一个层以管理输入数据。
- en: Set up intermediate levels to perform the analysis.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置中间层以进行分析。
- en: Create the output level to manage the targets.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建输出层以管理目标。
- en: Keras works as a specific high-level API for neural networks. It can act as
    a user interface and can extend the functionality of other deep learning framework
    backends on which it runs. Thanks to this feature, Keras has become a wrapper
    for migration between frameworks. Not only can algorithms and models of neural
    networks for deep learning be exchanged but also networks and preliminary weights.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Keras 作为一个特定的高层 API 用于神经网络。它可以充当用户界面，并且可以扩展它所运行的其他深度学习框架后端的功能。正因为这个特点，Keras
    成为了框架之间迁移的封装器。不仅可以交换深度学习神经网络的算法和模型，还可以交换网络和预训练权重。
- en: Wrapper libraries consist of a thin layer of code that translates a library's
    existing interface into a compatible interface.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 封装库由一层薄代码组成，负责将库的现有接口转换为兼容的接口。
- en: On the other hand, since Keras is autonomous, it can be used without having
    to interact with the backend framework on which it is running. Keras has its own
    chart data structures for defining computational charts; it is not based on the
    data structures of the underlying backend framework. This way, you will not have
    to learn how to program the backend framework.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，由于 Keras 是自主的，它可以在不与其运行的后端框架交互的情况下使用。Keras 有自己的图数据结构用于定义计算图；它并不依赖于底层后端框架的数据结构。这样，你就不必学习如何编程后端框架。
- en: Keras is easy to learn and use. Using Keras is like working with LEGO® blocks;
    you just have to put in sequence a series of compatible modules. It was created
    so that people can quickly perform the experimental phase of models using a highly
    modular and extensible framework. Keras focuses on defining levels for neural
    networks. You do not have to deal with tensors, but it's easy to write with less
    code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Keras 易于学习和使用。使用 Keras 就像玩 LEGO® 积木一样；你只需要将一系列兼容的模块按顺序排列即可。它的设计目的是让人们能够通过一个高度模块化和可扩展的框架，快速进行模型的实验阶段。Keras
    主要集中在定义神经网络的层。你不需要处理张量，但可以用更少的代码轻松编写。
- en: The backend takes care of complex mathematics and, in the next section, we will
    see how the TensorFlow backend works.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 后端负责复杂的数学运算，在下一节中，我们将看到 TensorFlow 后端的工作原理。
- en: The Keras backend in TensorFlow
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TensorFlow 中的 Keras 后端
- en: Keras is a model-level library that provides high-level blocks for the development
    of deep learning models. Keras developers have focused their efforts on creating
    high-level models by neglecting low-level operations such as tensor products and
    convolutions. These operations have been entrusted to specialized and well-optimized
    tensor manipulation libraries that already exist, hence acting as a backend engine
    for Keras. Several backend engines can be connected perfectly to Keras. Actually,
    Keras has three backend implementations available—TensorFlow, Theano, and Microsoft
    **Cognitive Toolkit** (**CNTK**).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Keras 是一个模型级库，提供用于深度学习模型开发的高级模块。Keras 开发者专注于创建高级模型，而忽略了低级操作，如张量乘积和卷积。这些操作已被交给专门的、经过优化的张量操作库来处理，因此它们充当了
    Keras 的后端引擎。多个后端引擎可以完美地连接到 Keras。实际上，Keras 提供了三个可用的后端实现——TensorFlow、Theano 和微软
    **认知工具包**（**CNTK**）。
- en: TensorFlow is an open source software library for numerical calculation based
    on graph modeling (data flow graphs). A graph is defined as an abstract pipeline
    of mathematical operations operating on tensors and is known as a multidimensional
    array. Each graph consists of nodes and arcs, wherein the nodes are operations
    on the data, and the arcs represent the tensors that pass through the various
    operations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow 是一个基于图模型（数据流图）的开源软件库，用于数值计算。图被定义为在张量上操作的数学运算的抽象管道，并被称为多维数组。每个图由节点和弧线组成，其中节点是数据上的操作，弧线表示通过各种操作传递的张量。
- en: 'You can find the updated version of the library and all of the documentation
    supplied at the following link: [http://www.tensorflow.org](http://www.tensorflow.org).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接找到该库的最新版本和所有提供的文档：[http://www.tensorflow.org](http://www.tensorflow.org)。
- en: TensorFlow is the most commonly used library in the field of machine learning
    and neural networks. It has numerous APIs, including the lowest level, that is,
    TensorFlow Core, and allows complete control over programming. These APIs are
    those typically used in the field of machine learning since they make it possible
    to check in detail all of the elements of the model being implemented. The highest-level
    APIs are available and built from TensorFlow Core. In some cases, they can make
    some operations such as repetitive and predefined tasks faster and simpler, but
    generally preclude the possibility of going into detail, and in the implementation
    of a neural network, it is often necessary to have more precise control over operations.
    However, they can still be useful for the development of standard machine learning
    models.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow 是机器学习和神经网络领域最常用的库。它有许多 API，包括最低级别的 TensorFlow Core，允许完全控制编程。这些 API
    通常用于机器学习领域，因为它们使得可以详细检查实现中的所有模型元素。最高级别的 API 是基于 TensorFlow Core 构建的。在某些情况下，它们可以使某些操作，如重复性和预定义任务，更加快速和简单，但通常无法深入细节，且在神经网络的实现中，往往需要更精确地控制操作。然而，它们在标准机器学习模型的开发中仍然非常有用。
- en: So, let's see how we can exploit the potential offered by the `keras` library
    in the R environment.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们来看一下如何利用 `keras` 库在 R 环境中提供的潜力。
- en: Using Keras in R
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 R 中使用 Keras
- en: As we anticipated in the *Introduction to Keras* section, Keras is written in
    Python and is, therefore, the natural development environment in which to operate.
    Despite this, as with many libraries, an interface has been built that allows
    us to operate in the R environment using the potential of Keras. This is due to
    the great simplicity of use of the `keras` library technology, which makes the
    implementation of algorithms based on machine learning really simple and immediate.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *Keras 简介* 部分中预见到的那样，Keras 是用 Python 编写的，因此它是操作的自然开发环境。尽管如此，和许多库一样，已经构建了一个接口，使我们能够利用
    Keras 在 R 环境中进行操作。这是因为 `keras` 库技术的极大简易性，它使得基于机器学习的算法实现变得简单而直观。
- en: 'To use Keras in R, we can use the interface available at the following URL:
    [https://keras.rstudio.com/index.html](https://keras.rstudio.com/index.html).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 R 中使用 Keras，我们可以使用以下网址提供的接口：[https://keras.rstudio.com/index.html](https://keras.rstudio.com/index.html)。
- en: 'In the following screenshot, we can see the official home page of the R interface
    to Keras:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，我们可以看到 R 接口到 Keras 的官方网站首页：
- en: '![](img/22a55595-eab5-4356-8977-8acc6b03873a.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22a55595-eab5-4356-8977-8acc6b03873a.png)'
- en: It will be possible to retrieve all of the information needed to install the
    interface and to start using it. The simplicity with which it is possible to operate
    with the `keras` library will be confirmed in the next section, where we will
    see how to recognize handwritten digits using Keras.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将能够检索安装界面所需的所有信息，并开始使用它。在接下来的部分中，我们将看到如何使用Keras识别手写数字，确认使用`keras`库的简易操作性。
- en: Multilayer perceptron for image processing
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于图像处理的多层感知器
- en: As we saw in [Chapter 11](91935d6b-70d6-4d61-b1b8-86d84470caf4.xhtml), *Exploring
    Deep Reinforcement Learning Methods*, the MLP is a feedforward artificial neural
    network. The simplest variant is the single-layer variant, which consists of a
    single layer of output nodes while the inputs are supplied directly to the units
    through a series of weights. The MLP is a type of network that provides for the
    presence of at least three levels connected to each other in feedforward—an input
    layer, a hidden layer, and output layers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第11章](91935d6b-70d6-4d61-b1b8-86d84470caf4.xhtml)中看到的*探索深度强化学习方法*，MLP是一个前馈人工神经网络。最简单的变体是单层变体，它由一个输出节点层组成，而输入则通过一系列权重直接提供给单元。MLP是一种网络类型，其前馈连接至少包括三个相互连接的层——输入层、隐藏层和输出层。
- en: For each node, except those of the input layer, a non-linear activation function
    is used. In fact, if an MLP network has a linear activation function that maps
    the weighted inputs of each neuron into output, then even with multiple levels,
    it is considered a two-level input/output model. In the training phase, the weights
    of the connections are modified by processing the data contained in the model.
    The update is based on the amount of error present in the output compared to the
    expected result.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于除输入层外的每个节点，都使用非线性激活函数。事实上，如果MLP网络具有线性激活函数，将每个神经元的加权输入映射到输出，即使有多个层，也被认为是一个两级输入/输出模型。在训练阶段，通过处理模型中包含的数据来修改连接的权重。更新基于输出中存在的错误量与预期结果的比较。
- en: The error function is one that belongs to the space of the weights that measure
    how reliable the network is at solving the problem in question. The task of the
    learning algorithm is to minimize this function, therefore, to find the point
    in the space of the weights at which the function has the global minimum point,
    or in some cases, a local minimum point may suffice.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 误差函数是属于权重空间的函数，用于衡量网络在解决问题时的可靠性。学习算法的任务是最小化此函数，因此要找到权重空间中使函数达到全局最小点的点，或者在某些情况下，局部最小点可能就足够了。
- en: To verify the potential of Keras in image processing, we will deal with a practical
    case of handwritten digit recognition. To do this, we will use a dataset widely
    used by the developer community—the MNIST dataset.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证Keras在图像处理中的潜力，我们将处理手写数字识别的实际案例。为此，我们将使用开发者社区广泛使用的数据集——MNIST数据集。
- en: The MNIST dataset
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MNIST数据集
- en: The **Modified National Institute of Standards and Technology** (**MNIST**)
    dataset is a large database of handwritten digits. It has a set of 70,000 examples
    of data. It is a subset of NIST's larger dataset. The digits are of 28x28 pixel
    resolution and are stored in a matrix of 70,000 rows and 785 columns; 784 columns
    form each pixel value from the 28x28 matrix, and one value is the actual digit.
    The digits have been size-normalized and centered in a fixed-size image.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**美国国家标准与技术研究院改进版**（**MNIST**）数据集是一个大型手写数字数据库。它包含70,000个数据示例。它是NIST更大数据集的子集。这些数字的分辨率为28x28像素，并存储在一个70,000行和785列的矩阵中；784列形成每个28x28矩阵的像素值，其中一个值是实际数字。这些数字已经进行了尺寸标准化和中心化处理，存储在固定大小图像中。'
- en: The digit images in the MNIST set were originally selected and experimented
    with by Chris Burges and Corinna Cortes using bounding box normalization and centering.
    Yann LeCun's version uses centering by the center of mass within a larger window.
    The data is available on Yann LeCun's website at [http://yann.lecun.com/exdb/mnist/](http://yann.lecun.com/exdb/mnist/).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: MNIST数据集中的数字图像最初由Chris Burges和Corinna Cortes选择并进行了边界框归一化和居中处理的实验。Yann LeCun的版本使用了较大窗口中心质量的中心化方法。数据可在Yann
    LeCun的网站上获取：[http://yann.lecun.com/exdb/mnist/](http://yann.lecun.com/exdb/mnist/)。
- en: 'The following diagram shows a sample of images of 0-8 from the MNIST dataset:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了MNIST数据集中0-8的图像样本：
- en: '![](img/c1de2216-a245-435b-89a3-4fcae011755d.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1de2216-a245-435b-89a3-4fcae011755d.png)'
- en: This dataset is already available in the `keras` library and contains 60,000
    28x28 grayscale images of the 10 digits for the training, along with a test set
    of 10,000 images.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该数据集已经包含在 `keras` 库中，包含 60,000 张 28x28 的灰度图像（用于训练）以及 10,000 张图像的测试集，数字范围为 10。
- en: To start, we preprocess the data by preparing it adequately for the next use
    in the Keras model.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过适当地准备数据来进行预处理，以便在接下来的 Keras 模型中使用。
- en: Data preprocessing
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据预处理
- en: 'In this section, we will analyze the features of the MNIST dataset and we will
    learn how to prepare the data in a format compatible with Keras:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将分析 MNIST 数据集的特征，并学习如何将数据准备为 Keras 可兼容的格式：
- en: 'Let''s start importing the `keras` library:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始导入 `keras` 库：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To import the `mnist` dataset, we can use the following command:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要导入 `mnist` 数据集，我们可以使用以下命令：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s take a look at what is contained in the dataset:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看数据集里包含了什么：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following results are returned:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是返回的结果：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now we can see the dataset contains 60,000 observations for training and 10,000
    for the test phase. Each observation represents a 28x28 pixel (*x*) image. The
    corresponding label (*y*) is provided for each observation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到，数据集包含了 60,000 个训练样本和 10,000 个测试样本。每个观察值代表一个 28x28 像素的 (*x*) 图像，并为每个观察值提供了相应的标签
    (*y*)。
- en: 'Now, we will extract the four lists, and place them in four variables that
    represent our input and output data for the model we intend to process:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将提取四个列表，并将它们放入四个变量中，这些变量代表我们要处理的模型的输入和输出数据：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In *The MNIST dataset* section, we four said that the dataset contains 10 digits.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在*MNIST 数据集*部分，我们之前提到过该数据集包含 10 个数字。
- en: 'Let''s verify it; we''ll also analyze the distribution of these figures in
    the dataset:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们验证一下；我们还将分析数据集中这些数字的分布情况：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following results are returned:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是返回的结果：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Actually, we have 10 occurrences – the digits from 0 to 9\. Furthermore, we
    can verify that the frequencies of each digit are comparable. To confirm this,
    we can trace a histogram:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际上，我们有 10 个数字——从 0 到 9。此外，我们可以验证每个数字的频率是相似的。为此，我们可以绘制一个直方图：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following diagram shows the histograms of the two distributions next to
    each other (**YTrain** on the left and **YTest** on the right):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了两个分布的直方图并排展示（**YTrain** 在左侧，**YTest** 在右侧）：
- en: '![](img/c39f2f5f-1669-4382-9a7f-ea3386cfb9ce.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c39f2f5f-1669-4382-9a7f-ea3386cfb9ce.png)'
- en: By analyzing the previous diagram, we can see that the frequencies of the presence
    of 10 digits are equally distributed in the two datasets. As we said, each sample
    image consists of a 28x28 matrix.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分析之前的图，我们可以看到这两个数据集中 10 个数字的出现频率是均匀分布的。正如我们所说，每个样本图像由一个 28x28 的矩阵组成。
- en: 'To confirm this, we will extract the dimensions of the two input vectors:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确认这一点，我们将提取这两个输入向量的维度：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following shapes are returned:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是返回的形状：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Hence, each observation contains the data relating to the 28x28 pixels in grayscale.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个观察值包含与 28x28 像素的灰度值相关的数据。
- en: 'To reduce the dimensionality, we will flatten the 28x28 images into vectors
    of a size of `784`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了降低维度，我们将 28x28 的图像展平为大小为 `784` 的向量：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `array_reshape()` function reshapes a multi-dimensional array, using row-major
    (C-style) reshaping semantics by default. This function gives a new shape to an
    array without changing its data. The new shape should be compatible with the original
    shape. The first dimension of the new shape is the number of observations. The
    second dimension represents the product of the last two dimensions of the starting
    data (*28 x 28 = 784*).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_reshape()` 函数重新塑形一个多维数组，默认情况下使用行主序（C 风格）重新塑形语义。此函数为数组赋予新形状，而不改变其数据。新形状应与原始形状兼容。新形状的第一维是观察值的数量，第二维表示起始数据的最后两个维度的乘积（*28
    x 28 = 784*）。'
- en: 'To understand this transformation better, we print the shape of the transformed
    dataset:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更好地理解这一转化，我们打印出转化后数据集的形状：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following results are printed:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是打印的结果：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, we have to normalize all values between 0 and 1\. The MNIST images are
    stored in pixel format, where each pixel (in total, 28x28) is stored as an 8-bit
    integer, giving a range of possible values from 0 to 255\. Typically, 0 is taken
    to be black, and 255 is taken to be white.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须将所有值归一化到 0 和 1 之间。MNIST 图像以像素格式存储，其中每个像素（共 28x28）作为一个 8 位整数存储，数值范围从 0
    到 255。通常，0 被认为是黑色，255 被认为是白色。
- en: 'The values in between make up the different shades of gray. Now, to normalize
    all values between 0 and 1, simply divide each value by 255\. So, the pixel containing
    the value 255 will become 1, and the one containing 0 will remain as such; in
    between, lie all of the other values:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其中的值构成了不同的灰度。现在，为了将所有值标准化到 0 和 1 之间，只需将每个值除以 255。因此，包含值 255 的像素将变为 1，而包含值 0
    的像素保持不变；介于两者之间的是所有其他值：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After preparing the input data, it is necessary to rearrange the output data.
    We have said that it represents the labels of the images. We have already seen
    that each image has been labeled with a number ranging from 0 to 9\. To use these
    values in a Keras model, it is necessary to modify them.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备好输入数据之后，需要重新排列输出数据。我们之前说过，输出数据表示图像的标签。我们已经看到每个图像都标注了一个从 0 到 9 的数字。为了在 Keras
    模型中使用这些值，必须对它们进行修改。
- en: 'A method to quantify each category of a qualitative predictor involves the
    creation of a binary variable, 0-1 (called a dummy variable), which indicates
    the presence or absence of the attribute in each statistical unit. Let''s see
    how:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定量化每个类别的定性预测变量的方法涉及创建一个二进制变量，0-1（称为虚拟变量），该变量表示每个统计单元中属性的存在与否。我们来看看如何操作：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `to_categorical()` function takes a vector or 1 column matrix of class
    labels and converts it into a matrix with *p* columns, one for each category.
    This is the format most commonly used in the fitting and predicting of neural
    networks. The dummy variable can take two values:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`to_categorical()` 函数接受一个类标签的向量或 1 列矩阵，并将其转换为一个有 *p* 列的矩阵，每一列代表一个类别。这是神经网络拟合和预测中最常用的格式。虚拟变量可以取两个值：'
- en: '0: If the attribute is absent'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0：如果属性不存在
- en: '1: If the attribute is present'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1：如果属性存在
- en: Now, each observation will be a line of 10 values in which there are all zeros
    except in the column that identifies the digit that will contain 1.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个观测将是一个包含 10 个值的行，除了标识包含 1 的数字的列外，其余列均为零。
- en: After preparing the data, it is time to use them to train a Keras model.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备好数据之后，是时候使用这些数据训练 Keras 模型了。
- en: Keras MLP model
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Keras MLP 模型
- en: 'After adequately preprocessing the data, we can define the architecture of
    the Keras model. Keras is structured according to the object-oriented programming
    methodology. Therefore, the creation of a model is very simple: select the basic
    architecture and then add the layers necessary to create the desired model. As
    just mentioned, the sequential model lets you create a layer-by-layer model as
    a linear stack of layers. However, it is not possible to create models that share
    levels or that have multiple inputs or outputs. A sequential model is created
    by passing a list of layer instances to the constructor:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在适当预处理数据之后，我们可以定义 Keras 模型的架构。Keras 是基于面向对象的编程方法构建的。因此，创建模型非常简单：选择基本架构，然后添加必要的层以构建所需的模型。如前所述，顺序模型允许你逐层创建模型，作为层的线性堆叠。然而，顺序模型不能创建共享层或具有多个输入或输出的模型。顺序模型是通过将一系列层实例传递给构造函数来创建的：
- en: 'First, we instantiate an object from the `keras_model_sequential` class:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们从 `keras_model_sequential` 类实例化一个对象：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All information about your network, such as weights, layers, and operations,
    will be stored in this object.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所有关于网络的信息，如权重、层和操作，都将存储在这个对象中。
- en: 'After instantiating our object, we will move on to adding layers:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实例化对象之后，我们将继续添加层：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `layer_dense()` function adds a densely-connected NN layer to an output.
    In a densely connected layer, every input is connected to every output by a weight,
    which is generally followed by a non-linear activation function. The first argument
    contains the dimensionality of the output space (units = 256). The second argument
    contains the activation function (`activation = 'relu'`). **Rectified Linear Unit**
    (**ReLU**) is the most used activation function since 2015\. It's a simple condition
    and has advantages over the other functions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`layer_dense()` 函数将一个密集连接的神经网络层添加到输出中。在一个密集连接的层中，每个输入都通过一个权重与每个输出相连，通常后面跟着一个非线性激活函数。第一个参数包含输出空间的维度（units
    = 256）。第二个参数包含激活函数（`activation = ''relu''`）。**修正线性单元**（**ReLU**）是自 2015 年以来最常用的激活函数。它是一个简单的条件，并且相对于其他函数具有优势。'
- en: 'Finally, the third argument contains the input shape (`input_shape = c(784)`).
    Recall that the first layer passed to a sequential model should have a defined
    input shape. Let''s add the second layer:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，第三个参数包含输入形状（`input_shape = c(784)`）。请记住，传递给顺序模型的第一层应该有一个已定义的输入形状。接下来我们添加第二层：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The dropout layer applies dropout to the input. Dropout consists of randomly
    setting a fraction rate of input units to 0 at each update during training time,
    which helps to prevent overfitting. Only one argument is passed. This is the rate,
    a float between 0 and 1\. This indicates the fraction of the units to drop.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: dropout层对输入进行dropout。dropout在训练期间通过随机将一定比例的输入单元设为0来帮助防止过拟合。只传入一个参数，即比例，它是一个介于0和1之间的浮动数值，表示丢弃单元的比例。
- en: 'Then, a second dense layer is added:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加第二个全连接层：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this case, the input is not present, the number of output nodes is progressively
    resized, and the activation function is always `relu`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输入不存在，输出节点的数量逐渐调整，并且激活函数始终为`relu`。
- en: 'Let''s add another layer of dropout:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再加一个dropout层：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s finish with a last dense layer:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们结束时加上最后一个全连接层：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code block, the output units are 10 because there are 10 figures
    that the system must classify. The softmax function is a more generalized logistic
    activation function that's used for multiclass classification.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，输出单元为10，因为系统必须分类10个数字。softmax函数是一种更通用的逻辑激活函数，通常用于多类别分类。
- en: 'Now, we''ll analyze the overall architecture of the Keras model we have defined.
    In Keras, to summarize a model, it is possible to use the `summary()` function.
    The summary is returned in text format and includes the following information:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将分析我们所定义的Keras模型的整体架构。在Keras中，若要总结模型，可以使用`summary()`函数。该总结以文本格式返回，并包括以下信息：
- en: The layers and their order in the model
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型中的层及其顺序
- en: The output shape of each layer
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一层的输出形状
- en: The number of parameters (weights) in each layer
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一层的参数数量（权重）
- en: The total number of parameters (weights) in the model
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型中的总参数数量（权重）
- en: 'To print a summary of the model, we simply type the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印模型的总结，我们只需键入以下命令：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following screenshot shows the architecture of the Keras model defined:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了定义的Keras模型架构：
- en: '![](img/95ad0254-26bd-45c4-9917-1754c45a09ec.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95ad0254-26bd-45c4-9917-1754c45a09ec.png)'
- en: In the previous screenshot, we can clearly see the output shape and number of
    weights in each layer.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一张截图中，我们可以清晰地看到每一层的输出形状和权重数量。
- en: 'Before training a model, you need to configure the learning process, which
    is done via the `compile()` method, as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在训练模型之前，您需要配置学习过程，这可以通过`compile()`方法来完成，如下所示：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `compile()` method configures a Keras model for training. Three arguments
    are passed, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`compile()`方法配置Keras模型以进行训练。传入三个参数，如下所示：'
- en: '`loss`: The `categorical_crossentropy` loss function is passed. When using
    `categorical_crossentropy`, your targets should be in categorical format. We have
    10 classes; the target for each sample must be a 10-dimensional vector that is
    all zeros except for a one at the index corresponding to the class of the sample.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loss`：传入`categorical_crossentropy`损失函数。使用`categorical_crossentropy`时，您的目标应该是分类格式。我们有10个类别；每个样本的目标必须是一个10维的向量，除非对应类别的索引位置为1，其余位置都为0。'
- en: '`optimizer`: `optimizer_rmsprop` is passed. This optimizer divides the learning
    rate by an exponentially decaying average of squared gradients.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`optimizer`：传入`optimizer_rmsprop`。该优化器通过平方梯度的指数衰减平均值来调整学习率。'
- en: '`metrics`: The accuracy metric is passed. A metric is a function that is used
    to evaluate the performance of your model during training and testing.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metrics`：传入准确率度量。度量是用来评估模型在训练和测试过程中的表现的函数。'
- en: 'Now, we can move on to the training phase. First, you need to set some parameters:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以进入训练阶段。首先，您需要设置一些参数：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`BatchSize` is the number of samples per gradient update. `NumEpochs` is the
    number of epochs to train the model. An epoch is an iteration over the entire
    input and output data provided.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`BatchSize`是每次梯度更新的样本数量。`NumEpochs`是训练模型的轮次。一个轮次是对提供的整个输入和输出数据的一次迭代。'
- en: 'To train the model, the `fit()` method is used, as follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要训练模型，可以使用`fit()`方法，如下所示：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following arguments are passed:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 传入以下参数：
- en: '`Xtrain`: This is an array of input training data.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Xtrain`：这是输入训练数据的数组。'
- en: '`Ytrain`: This is an array of target (label) data.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ytrain`：这是目标（标签）数据的数组。'
- en: '`epochs`: This is the number of epochs to train the model. An epoch is an iteration
    over the entire *x* and *y* data provided.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`epochs`：这是训练模型的轮次。一个轮次是对提供的整个*x*和*y*数据的一次迭代。'
- en: '`batch_size`: This is the number of samples per gradient update.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`batch_size`：这是每次梯度更新的样本数量。'
- en: '`verbose`: This is an integer, either 0, 1, or 2\. Verbosity mode would be:
    0 = silent, 1 = progress bar, and 2 = one line per epoch.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`verbose`：这是一个整数值，值可以是0、1或2。详细程度模式为：0 = 静默，1 = 进度条，2 = 每个周期一行。'
- en: '`validation_split`: This is a float between 0 and 1, a fraction of the training
    data to be used as validation data.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validation_split`：这是一个介于0和1之间的浮动值，表示将用于验证的数据占训练数据的比例。'
- en: 'When the `fit()` function is used, the loss and the accuracy at the end of
    each training epoch are displayed, as shown in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`fit()`函数时，训练周期结束时会显示损失和准确度，如下截图所示：
- en: '![](img/11594ff3-e351-44b9-9acd-37a6e8184684.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11594ff3-e351-44b9-9acd-37a6e8184684.png)'
- en: 'To get an idea of how the loss function and the accuracy vary during the epochs,
    it can be useful to create a plot of loss and accuracy on the training and validation
    phases, as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了了解损失函数和准确度在训练周期中的变化情况，可以通过如下方式绘制损失和准确度图表，展示训练和验证阶段的表现：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following diagram is plotted:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制出以下图表：
- en: '![](img/ea3218d3-57b5-4f45-b407-9ec1a34d1711.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea3218d3-57b5-4f45-b407-9ec1a34d1711.png)'
- en: We can see the evolution of the model for both subsets, as loss and accuracy
    vary.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到模型在两个子集上的演化，随着损失和准确度的变化。
- en: 'To evaluate the performance of the model we''ve just adapted, we use the `evaluate()`
    function, as follows:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了评估我们刚刚调整的模型的表现，我们使用`evaluate()`函数，如下所示：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This function returns the loss value and metrics values for the model in test
    mode. Computation is done in batches. Let''s print loss and accuracy:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数返回模型在测试模式下的损失值和度量值。计算是分批进行的。让我们打印出损失和准确度：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following results are printed:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 打印出以下结果：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The accuracy obtained confirms that a deep neural network can classify the handwritten
    digits.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 获得的准确度证明了深度神经网络能够对手写数字进行分类。
- en: In the next section, we will see how to use deep Q-learning to balance a cart
    pole.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将看到如何使用深度Q学习来平衡一个推车。
- en: Approaching deep Q-learning
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接近深度Q学习
- en: In [Chapter 11](91935d6b-70d6-4d61-b1b8-86d84470caf4.xhtml), *Exploring Deep
    Reinforcement Learning Methods*, we saw that deep Q-learning adopts a neural network
    as an approximation of a value function. These methods represent an evolution
    of the basic Q-learning method since the action-state table is replaced by a neural
    network, to approximate the optimal value function. Deep Q-learning only requires
    the state of the environment as an input and provides all of the status-action
    values as there are actions that can be performed in the environment. In this
    algorithm, therefore, the learning does not consist of updating the table but
    of adjusting the weights of the neurons that make up the network. This update
    takes place using the backpropagation technique.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](91935d6b-70d6-4d61-b1b8-86d84470caf4.xhtml)，*探索深度强化学习方法*中，我们看到深度Q学习采用神经网络作为值函数的近似。这些方法是基本Q学习方法的演变，因为动作-状态表被神经网络所替代，以逼近最优值函数。深度Q学习只需要环境的状态作为输入，并提供所有状态-动作值，因为在环境中可以执行的动作是已知的。因此，在这个算法中，学习的过程并不是更新表格，而是调整构成网络的神经元的权重。这一更新过程通过反向传播技术完成。
- en: To begin with, let's see how to install the library we will use as a first approach
    to deep Q-learning.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何安装我们将用作深度Q学习初步方法的库。
- en: Deep Q-learning in R
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: R中的深度Q学习
- en: 'To approach the DQN in R, we will use the `rlR` library. To use this library,
    Keras must be installed with TensorFlow as a backend on our machine. Furthermore,
    to run the example that we will propose, the OpenAI Gym library must be installed:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在R中实现DQN，我们将使用`rlR`库。要使用此库，必须在我们的计算机上安装Keras，并将TensorFlow作为后端。此外，为了运行我们将要提出的示例，还需要安装OpenAI
    Gym库：
- en: 'To begin, we provide to install the `rlXR` library. The library is available
    on GitHub at the following URL: [https://github.com/smilesun/rlR](https://github.com/smilesun/rlR).'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们提供安装`rlXR`库的方法。该库可以在GitHub上找到，网址为：[https://github.com/smilesun/rlR](https://github.com/smilesun/rlR)。
- en: To install an R package available on GitHub, we can use the `install_github()`
    function available in the `devtools` package.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装一个在GitHub上提供的R包，我们可以使用`install_github()`函数，该函数来自`devtools`包。
- en: 'Then, we must first install the `devtools` package:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们首先需要安装`devtools`包：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `devtools` package contains several functions for developing R packages.
    Using this library, many common tasks are greatly simplified.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`devtools`包包含了多个用于开发R包的函数。通过使用这个库，许多常见任务变得更加简单。'
- en: 'At this point, we can use the `install_github()` function contained in `devtools`,
    as follows:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此时，我们可以使用`devtools`中包含的`install_github()`函数，方法如下：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This command will first download the package from the GitHub website and then
    install it. The function argument contains a text string that calls both the author
    and the package name.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将首先从GitHub网站下载包并安装。函数参数包含一个文本字符串，调用了作者和包名。
- en: 'Now, we can load the library:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以加载库：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As an example of the application of the method, we will use an OpenAI library
    environment, already introduced in [Chapter 8](47b30864-c93f-4e61-aa44-fa46b70508dd.xhtml),
    *Reinforcement Learning in Game Applications*. I refer to the `CartPole-v0` environment,
    which is a classic problem of reinforcement learning.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 作为该方法应用的示例，我们将使用一个已经在[第8章](47b30864-c93f-4e61-aa44-fa46b70508dd.xhtml)中介绍的OpenAI库环境，*游戏应用中的强化学习*。我指的是`CartPole-v0`环境，这是一个经典的强化学习问题。
- en: 'The system consists of a pole (which acts like an inverted pendulum) attached
    to a cart via a joint, as shown in the following diagram:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 系统由一个杆子（像倒立摆一样）和通过关节连接的小车组成，如下图所示：
- en: '![](img/4e2a9057-b551-4190-878e-5440690171ae.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e2a9057-b551-4190-878e-5440690171ae.png)'
- en: 'The system is controlled by applying a force of +1 or -1 to the cart. The force
    applied to the cart can be controlled, and the objective is to swing the pole
    upward and stabilize it. This must be done without the cart falling to the ground.
    The balancing procedure involves the following actions: the agent moves the pole
    to the right or the left. A reward of 1 is returned for each time the pole is
    balanced. If the pole deviates by more than 15 degrees from the vertical position,
    the procedure ends. To balance the pole and therefore solve the problem, it is
    necessary to set the push in the opposite direction to the inclination of the
    pole:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 系统通过向小车施加+1或-1的力来控制。小车上施加的力量可以控制，目标是将杆子向上摆动并保持稳定。必须在小车不掉到地面的情况下完成这一过程。平衡过程包括以下动作：智能体将杆子向右或向左移动。每当杆子保持平衡时，返回一个奖励值1。如果杆子偏离垂直位置超过15度，过程结束。为了平衡杆子并解决问题，需要施加与杆子倾斜方向相反的推力：
- en: 'To load the `CartPole` environment using the OpenAI Gym library, simply type
    the following code:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用OpenAI Gym库加载`CartPole`环境，只需输入以下代码：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We check what makes are available:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查有哪些牌号是可用的：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following information is returned:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 返回以下信息：
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'There are two actions (`action cnt: 2`); this agrees with what was said before.
    The system is controlled by applying a force of +1 or -1 to the cart. These are
    the two actions available. The second piece of information, `state original dim:
    4`, tells us that the state of the system is characterized by four pieces of information,
    as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '有两个动作（`action cnt: 2`）；这与前述内容一致。系统通过向小车施加+1或-1的力来控制。这是两个可用的动作。第二个信息，`state
    original dim: 4`，告诉我们系统的状态由四个信息组成，具体如下：'
- en: Cart position
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小车位置
- en: Cart velocity
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小车速度
- en: Pole angle
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 杆子角度
- en: Pole velocity at the tip
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 杆尖的速度
- en: Finally, the third piece of information, `discrete action`, tells us that the
    space of action is defined by discrete choices. This makes the DQN the best solution
    to deal with this type of problem.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第三个信息，`discrete action`，告诉我们动作空间是由离散选择定义的。这使得DQN成为处理此类问题的最佳解决方案。
- en: 'The environment we initialized contains several methods. For example, we can
    use the `step()` method, which performs an action and returns the state of the
    environment:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化的环境包含多个方法。例如，我们可以使用`step()`方法，它执行一个动作并返回环境的状态：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following results are returned:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 返回以下结果：
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The returned values have the following meaning:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的值具有以下含义：
- en: '`$state`: This is an environment-specific object representing your observation
    of the environment.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$state`：这是一个环境特定的对象，表示你对环境的观察。'
- en: '`$reward`: This is the amount of reward achieved by the previous action. The
    scale varies between environments, but the goal is always to increase your total
    reward.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$reward`：这是前一个动作所获得的奖励值。奖励的规模因环境而异，但目标始终是增加你的总奖励。'
- en: '`$done`: This shows whether it''s time to reset the environment again. Most
    (but not all) tasks are divided into well-defined episodes, and done being `True`
    indicates that the episode has terminated.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$done`：这表示是否需要重置环境。大多数（但不是所有）任务被划分为明确的阶段，当`done`为`True`时，表示该阶段已经结束。'
- en: '`$info`: This is diagnostic information useful for debugging. It can sometimes
    be useful for learning.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$info`：这是用于调试的诊断信息，有时也对学习很有帮助。'
- en: 'At this point, we can elaborate on the model based on deep Q-learning:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们可以基于深度Q学习进一步构建模型：
- en: 'Let''s initialize the agent:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们初始化智能体：
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s analyze what the object we have instantiated contains:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们分析一下我们实例化的对象包含了什么：
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We are given back so much information, we have highlighted only part of it:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获得了大量的信息，这里我们仅突出显示了其中的一部分：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Analyzing this information in detail, we can obtain the functions available
    for this agent. After instantiating our agent, it is time to train it:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过详细分析这些信息，我们可以得到此智能体可用的功能。在实例化智能体后，是时候开始训练它了：
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The next step is to train the agent for 500 episodes. At the end of each episode,
    the following information is printed:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是训练智能体进行500轮。每轮结束时，以下信息将被打印出来：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, we can print a graph showing how the reward varies in the episodes:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以打印出一张图表，展示奖励在各轮之间的变化：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following diagram is printed:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表将被打印出来：
- en: '![](img/bfc3ff40-8cf0-4522-a128-7145d4c72e83.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bfc3ff40-8cf0-4522-a128-7145d4c72e83.png)'
- en: We can see that as the agent learns, the rewards obtained from the system increase,
    meaning that the agent is implementing the best policy to achieve the desired
    result.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，随着智能体的学习，从系统中获得的奖励逐渐增加，这意味着智能体正在执行最佳策略，以实现期望的结果。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to tackle a deep reinforcement learning problem
    using Keras. To begin with, we explored the `keras` library and analyzed the TensorFlow
    backend. Next, we identified handwritten digits using a multilayered neural network
    using Keras. In this way, we could understand how a Keras model is structured
    with a practical example. In the final part of this chapter, we used the `rlR`
    library to apply deep reinforcement learning using the cart pole environment of
    the OpenAI Gym library.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了如何使用Keras解决深度强化学习问题。首先，我们探讨了`keras`库并分析了TensorFlow后端。接着，我们使用Keras通过多层神经网络识别手写数字。通过这种方式，我们理解了Keras模型的结构，并通过一个实际的例子来学习。最后，我们使用`rlR`库，在OpenAI
    Gym库的CartPole环境中应用深度强化学习。
- en: In the next chapter, we will summarize what has been covered so far in this
    book, and what the next steps are from this point on. We will explore the next
    real-life challenges in the construction and implementation of machine learning
    models, and additional resources and technologies to learn how to improve our
    machine learning capabilities.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将总结本书到目前为止的内容，并讨论从此时起的下一步。我们将探讨在构建和实现机器学习模型过程中面临的实际挑战，以及其他资源和技术，帮助我们学习如何提升机器学习能力。
