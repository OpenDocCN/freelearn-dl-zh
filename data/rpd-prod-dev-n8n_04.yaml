- en: '*Chapter 3*: Diving into Core Nodes and Data in n8n'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 3 章*：深入 n8n 的核心节点和数据'
- en: If you have ever been to a construction site just as they are starting to build
    a home, it can sometimes be challenging to envision what the final home will be
    like, and the future owners are probably very excited to get into the home and
    make it their own. If they had their way, they would probably skip this part of
    the home build and focus on all the details such as paint color, room layout,
    and furniture placement.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经去过正在开始建造房屋的建筑工地，有时很难想象最终房屋会是什么样子，未来的业主可能非常兴奋地想要搬进房子，将其变成自己的家。如果他们能按照自己的意愿行事，他们可能会跳过房屋建造的这一部分，专注于所有细节，如油漆颜色、房间布局和家具摆放。
- en: But if all home builders were to do this, none of their homes would last very
    long. They would not have a proper foundation upon which to sit, and the frame
    of the home would quickly fail.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果所有住宅建造者都这样做，他们的房子都不会持久。他们没有合适的地基来支撑，房子的框架会很快失效。
- en: The same thing can be said for learning to design computer programs. If a new
    developer does not learn the foundational parts and concepts of a programming
    system, then the application build goes very slowly and tends to be of poor quality.
    But unlike with a traditional computer programmer, it is not necessary to understand
    complex syntax or coding structure to become proficient at developing with a no-code
    solution.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于学习设计计算机程序来说，同样的话也可以说。如果一个新开发者没有学习编程系统的基本部分和概念，那么应用程序的开发就会非常缓慢，并且往往质量较差。但与传统计算机程序员不同，不需要理解复杂的语法或编码结构，就可以熟练地使用无代码解决方案进行开发。
- en: It is crucial to properly understand the core nodes and how data is structured
    in n8n. Without these foundational concepts, you will not get very far with n8n.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 正确理解核心节点以及数据在 n8n 中的结构至关重要。没有这些基础概念，你将无法在 n8n 中取得很大进展。
- en: 'This chapter covers the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Introduction to the data structure in n8n
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: n8n中的数据结构简介
- en: Function node—Custom JavaScript in workflows
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数节点——在工作流中使用自定义 JavaScript
- en: The items array
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目数组
- en: HTTP Request node—Talk to any **application programming interface** (**API**)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 请求节点——与任何 **应用程序编程接口**（**API**）进行通信
- en: Webhook node — Handling real-time events
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webhook 节点——处理实时事件
- en: Working with arrays and **JavaScript Object Notation** (**JSON**) objects
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与数组和 **JavaScript 对象表示法**（**JSON**）对象一起工作
- en: 'By the end of the chapter, you will have learned how to do the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会以下内容：
- en: Use n8n's data structure to manipulate and transform data inside workflows
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 n8n 的数据结构来操纵和转换工作流中的数据
- en: Use JavaScript inside your low-code workflows to unlock custom functionalities
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的低代码工作流中使用 JavaScript 来解锁自定义功能
- en: Call `HTTP Request` node
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `HTTP 请求` 节点
- en: Handle real-time events using the `Webhook` node and trigger workflows based
    on this data
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Webhook` 节点处理实时事件，并根据这些数据触发工作流
- en: Work with arrays and JSON objects inside n8n, understand when to use what kind
    of data format, and transform data inside the workflows
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 n8n 内部处理数组和 JSON 对象，了解何时使用哪种数据格式，并在工作流中转换数据
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You should have installed n8n
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该已经安装了 n8n
- en: n8n should be running, and the Editor **user interface** (**UI**) is open
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: n8n 应该正在运行，并且编辑器 **用户界面**（**UI**）已打开
- en: 'You have access to the GitHub repository, which can be found here: [https://github.com/PacktPublishing/Rapid-Product-Development-with-n8n](https://github.com/PacktPublishing/Rapid-Product-Development-with-n8n)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以访问 GitHub 仓库，网址如下：[https://github.com/PacktPublishing/Rapid-Product-Development-with-n8n](https://github.com/PacktPublishing/Rapid-Product-Development-with-n8n)
- en: Introduction to the data structure in n8n
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: n8n中的数据结构简介
- en: I love traveling to different countries and experiencing life from a different
    perspective. Different cultures and customs fascinate me.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我热爱旅行到不同的国家，并从不同的视角体验生活。不同的文化和习俗让我着迷。
- en: But unfortunately, I often find myself running into trouble because I am only
    fluent in a single language. Without having a language in common, it is easy to
    misunderstand what someone else is trying to communicate to me.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但不幸的是，我经常发现自己遇到麻烦，因为我只精通一种语言。如果没有共同的语言，很容易误解别人试图传达给我的信息。
- en: n8n also has its version of a language that it uses to communicate between nodes.
    This "language" is known as JSON and is a simple text format that is easy for
    both computers and humans to read. Using JSON, n8n can transfer both text and
    non-text (known as **binary**) information.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: n8n 也有它自己的语言版本，用于节点之间的通信。这种“语言”被称为 JSON，它是一种简单的文本格式，易于计算机和人类阅读。使用 JSON，n8n 可以传输文本和非文本（称为**二进制**）信息。
- en: The developers at n8n designed each node in the workflow to receive and output
    data in this specific JSON format. This standard data structure allows n8n to
    chain these nodes together in infinite workflow combinations to produce a wide
    variety of different solutions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: n8n 的开发者设计了工作流程中的每个节点，以便以这种特定的 JSON 格式接收和输出数据。这种标准数据结构允许 n8n 以无限的工作流程组合将这些节点链接在一起，以产生各种不同的解决方案。
- en: It is essential to have a strong understanding of JSON in general and, specifically,
    how n8n uses JSON. This section talks about how JSON represents information and
    two different ways of grouping it—objects and arrays. We also delve into how n8n
    uses JSON to communicate inside a workflow and store the two main types of data
    inside a workflow—JSON and binary data.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 JSON 的总体情况以及 n8n 如何使用 JSON 是非常重要的。本节讨论了 JSON 如何表示信息以及两种不同的分组方式——对象和数组。我们还深入探讨了
    n8n 如何在工作流程中使用 JSON 进行通信以及存储工作流程中的两种主要数据类型——JSON 和二进制数据。
- en: 'In the following code snippet, you will find a sample of JSON-formatted information.
    This example describes a 2021 red car with automatic transmission:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，您将找到 JSON 格式信息的样本。此示例描述了一辆 2021 年红色的自动挡汽车：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: JSON syntax
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON 语法
- en: 'There are a few syntax items to cover, making it easier to understand these
    JSON files. These items can be broken down into the following categories:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个语法项需要介绍，以便更容易理解这些 JSON 文件。这些项可以分为以下几类：
- en: '**Values**—Data or information'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值**—数据或信息'
- en: '**Key-value pairs**—Name of the information and the information itself'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**键值对**—信息的名称及其本身'
- en: '**Objects**—Groups of key-value pairs'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象**—键值对组'
- en: '**Arrays**—Groups of values'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数组**—值组'
- en: We will be learning more about these in the following sections.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中了解更多关于这些内容。
- en: Values
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 值
- en: 'A value is a piece of data represented in JSON. A value can be:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 值是 JSON 中表示的数据片段。一个值可以是：
- en: A string (a series of alphanumeric symbols)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字符串（一系列字母数字符号）
- en: A number (standard numeric value)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数字（标准数值）
- en: A JSON object (see the *Objects* section)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 对象（见*对象*部分）
- en: An array (see the *Arrays* section)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数组（见*数组*部分）
- en: A Boolean (`true` or `false` value)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔值（`true` 或 `false`）
- en: Key-value pairs
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 键值对
- en: The first piece of JSON information to understand is key-value pairs. These
    are made of a field name in double quotes and a value separated by a colon.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 需要首先理解的是 JSON 中的键值对。这些由双引号内的字段名和冒号分隔的值组成。
- en: 'For example, `"fruit": "apple"` is a key-value pair, with `"fruit"` being the
    key and `"apple"` being the value.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，`"fruit": "apple"` 是一个键值对，其中 `"fruit"` 是键，`"apple"` 是值。'
- en: You can reference a key in n8n to retrieve the value that is paired with it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 n8n 中引用一个键来检索与其配对的值。
- en: Objects
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象
- en: 'An object is a group of key-pair values enclosed within curly brackets and
    separated by a comma. For example, `{"name": "Jill", "age": 27, "certified": true}`
    is an object with three keys (`name`, `age`, and `certified`), and each key has
    a value (`Jill`, `27`, and `true`).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '对象是一组键值对，用花括号括起来并用逗号分隔。例如，`{"name": "Jill", "age": 27, "certified": true}`
    是一个包含三个键（`name`、`age` 和 `certified`）的对象，每个键都有一个值（`Jill`、`27` 和 `true`）。'
- en: Their key can reference values in the object.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的密钥可以引用对象中的值。
- en: 'To take this a step further, let''s imagine we have the following JSON object:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更进一步，让我们想象我们有一个以下的 JSON 对象：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, `user1.name` would be `Jill` and `user2.name` would be `James`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`user1.name` 将是 `Jill`，而 `user2.name` 将是 `James`。
- en: Arrays
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组
- en: An array is a group of values enclosed within square brackets and separated
    by a comma. For example, `[ "zero", "one", "two" ]` is an array with three values.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一组用方括号括起来并用逗号分隔的值。例如，`[ "zero", "one", "two" ]` 是一个包含三个值的数组。
- en: Arrays are similar to objects, except they do not have keys, so their index
    references the values.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 数组与对象类似，但它们没有键，因此它们的索引引用值。
- en: 'An index is the position of a value in the array. The index value starts with
    zero (0) and increases by one for each portion in the array. In our example, these
    are the indexes of the array and their values:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 索引是数组中值的位臵。索引值从零（0）开始，对于数组中的每个部分增加一。在我们的例子中，这些是数组的索引及其值：
- en: '`0`—`"zero"`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`—`"零"`'
- en: 1—"one"
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1——“一”
- en: 2—"two"
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2——“二”
- en: n8n JSON structure
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: n8n JSON结构
- en: The JSON that is passed between nodes in n8n is a particular structure. It is
    made up of an array of at least one object.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在n8n中节点之间传递的JSON是一种特定的结构。它由至少一个对象的数组组成。
- en: That object has either one or two sub-objects inside it. The two object keys
    are `json` and `binary`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 该对象内部包含一个或两个子对象。这两个对象键是`json`和`binary`。
- en: The json object
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: json对象
- en: The `json` object is a required object. Inside it is all of the JSON data that
    you will see as the result of a node execution.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`json`对象是一个必需的对象。在其内部包含了作为节点执行结果看到的全部JSON数据。'
- en: The contents of the `json` object are flexible and can be a mixture of other
    objects, arrays, and key-value pairs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`json`对象的内容是灵活的，可以是其他对象、数组和键值对的混合。'
- en: 'For example, if you have a set note that sets the key `colour` to a `red` value,
    the node output will appear like this in JSON:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有一个设置笔记，将键`colour`设置为`red`值，节点输出将以以下JSON格式显示：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'But when this information is stored in the n8n JSON format, it is passed between
    nodes, looking like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 但当此信息以n8n JSON格式存储时，在节点之间传递，看起来像这样：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This way, the nodes understand that the information is meant to be for them
    and identify the information as test information. There is also an optional binary
    section to go along with the json section, and that will be covered a bit later.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，节点就能理解信息是针对它们的，并将信息识别为测试信息。还有一个可选的二进制部分与json部分一起，稍后将会介绍。
- en: 'The following diagram illustrates the format in which data is passed between
    nodes. It represents the framework for the data:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了数据在节点之间传递的格式。它代表了数据框架：
- en: '![Figure 3.1 – n8n data structure'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 – n8n数据结构'
- en: '](img/Figure_3.01_B17493.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.01_B17493.jpg)'
- en: Figure 3.1 – n8n data structure
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – n8n数据结构
- en: The entire set of data that is passed between nodes is built into a JSON array.
    Inside that array, there are two JSON objects—one called `JSON` and another called
    `Binary`. The `JSON` object contains key-value pairs representing text data. Meanwhile,
    the `Binary` object contains binary information (think of this as a file). Along
    with the actual data of the `Binary` object, there is some metadata such as `mimeType`
    (this is the type of file the data contains), `fileExtension`, and `fileName`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在节点之间传递的整个数据集被构建成一个JSON数组。在该数组内部，有两个JSON对象——一个称为`JSON`，另一个称为`Binary`。`JSON`对象包含表示文本数据的键值对。同时，`Binary`对象包含二进制信息（可以将其视为文件）。除了`Binary`对象的实际数据外，还有一些元数据，如`mimeType`（这是数据包含的文件类型）、`fileExtension`和`fileName`。
- en: The binary object
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二进制对象
- en: The second object in the n8n JSON data structure is the `binary` object. The
    `binary` object is an optional component since not every JSON dataset contains
    a binary element. But when it is provided, this object contains information that
    generally represents a file in a filesystem.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: n8n JSON数据结构中的第二个对象是`binary`对象。`binary`对象是一个可选组件，因为并非每个JSON数据集都包含二进制元素。但是当它提供时，该对象包含的信息通常代表文件系统中的一个文件。
- en: 'But if you are to include this object in your n8n JSON data, it has a particular
    structure. Inside the `binary` object is a key named whatever you wish (for our
    example, we will call it `binaryKeyName`). The value associated with this key
    is another object. This object is made up of up to four key-value pairs:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你要在n8n JSON数据中包含此对象，它具有特定的结构。在`binary`对象内部有一个键，其名称可以是任意的（在我们的例子中，我们将它称为`binaryKeyName`）。与此键关联的值是另一个对象。该对象由最多四个键值对组成：
- en: '`data` (required)—Base64-encoded binary data or unique data ID reference'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`（必需）—Base64编码的二进制数据或唯一数据ID引用'
- en: '`mimeType` (optional)—The type of data stored in the `data` value based on
    standard mime types'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mimeType`（可选）—根据标准MIME类型存储在`data`值中的数据类型'
- en: '`fileExtension` (optional)—The extension that the file representing the information
    in the `data` value has'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileExtension`（可选）—表示`data`值中信息所具有的文件扩展名'
- en: '`fileName` (optional)—The name of the file describing the data in the `data`
    value'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileName`（可选）—描述`data`值中数据的文件名称'
- en: '`path` (optional) - The location of the file on the system'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`（可选） - 文件在系统中的位置'
- en: 'When the `binary` object is set in the n8n JSON data, you will see an extra
    `binary` object, as illustrated in the following screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当在n8n JSON数据中设置`binary`对象时，你将看到额外的`binary`对象，如下面的截图所示：
- en: '![Figure 3.2 – Binary data in n8n Editor UI'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.2 – n8n编辑器UI中的二进制数据](img/Figure_3.02_B17493.jpg)'
- en: '](img/Figure_3.02_B17493.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.02 – 函数节点](img/Figure_3.02_B17493.jpg)'
- en: Figure 3.2 – Binary data in n8n Editor UI
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – n8n编辑器UI中的二进制数据
- en: In the next section, we are going to take a look at the `Function` node. It
    allows you to create custom code in JavaScript in case there is no node to perform
    the exact action you need. This is where understanding the n8n data structure
    becomes extremely important for manipulating information using JavaScript code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看`函数`节点。它允许你在没有节点执行你需要的精确动作时，在JavaScript中创建自定义代码。对于使用JavaScript代码操作信息，理解n8n数据结构变得极为重要。
- en: Function node – Custom JavaScript in workflows
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数节点 – 工作流程中的自定义JavaScript
- en: 'Sometimes, the perfect n8n node for the action you want to complete simply
    doesn''t exist. This makes sense because there are an infinite number of different
    actions that could take place. This is why n8n created the `Function` node: so
    that we would have a way of creating our own custom actions, and we are going
    to learn how to do that next.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，对于你想要完成的操作，完美的n8n节点可能根本不存在。这是有道理的，因为可能发生无限多种不同的操作。这就是为什么n8n创建了`函数`节点：这样我们就有了一种创建我们自己的自定义动作的方法，我们将在下一节中学习如何做到这一点。
- en: 'The `Function` node is the most versatile node in the n8n toolbox. It can execute
    JavaScript to manipulate data output from other nodes and then output it in the
    standard n8n data structure. You can see a screenshot representation of it here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`函数`节点是n8n工具箱中最通用的节点。它可以执行JavaScript来操作其他节点输出的数据，并将其以标准n8n数据结构的形式输出。你可以在以下截图中看到它的表示：'
- en: '![Figure 3.3 – Function node'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.3 – 函数节点](img/Figure_3.03_B17493.jpg)'
- en: '](img/Figure_3.03_B17493.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.03_B17493.jpg)'
- en: Figure 3.3 – Function node
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 函数节点
- en: But the flexibility of the `Function` node does require you to be able to use
    some JavaScript. Unlike many other nodes with several options and parameters to
    pick and choose from, the `Function` node only has a single parameter—the JavaScript
    code field. It is in this field that you will do all of your work.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 但`函数`节点的灵活性确实要求你能够使用一些JavaScript。与许多其他具有多个选项和参数可供选择的节点不同，`函数`节点只有一个参数——JavaScript代码字段。你将在该字段中完成所有工作。
- en: The JavaScript code field contains, surprisingly, JavaScript. You will use this
    programming language to do all data manipulations within the `Function` node.
    While you don't need to be a JavaScript expert, there is some value in getting
    to know this language better. For what we will be talking about in this book,
    a basic understanding of JavaScript will suffice.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码字段中意外地包含JavaScript。你将使用这种编程语言在`函数`节点内进行所有数据操作。虽然你不需要成为JavaScript专家，但更好地了解这种语言是有价值的。对于我们在本书中将要讨论的内容，对JavaScript的基本理解就足够了。
- en: 'The first time you open up the JavaScript code field in a new `Function` node,
    you will notice that there are already several lines of code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次在新`函数`节点中打开JavaScript代码字段时，你会注意到已经有几行代码：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This gives you an excellent example of how the `Function` node works. This script
    assigns the value of `1` to the `myNewField` key in every item in the JSON object
    of the n8n data structure. It then writes to the web browser console that the
    action is done. Finally, it outputs the results.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这为你提供了一个很好的例子，说明了`函数`节点是如何工作的。此脚本将值`1`赋给n8n数据结构中JSON对象的每个`myNewField`键。然后它将操作已完成的动作写入网页浏览器控制台。最后，它输出结果。
- en: 'If you execute this `Function` node, you will get the following output as a
    result:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行这个`函数`节点，你将得到以下输出结果：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, just how did this work? It worked because of the `items` array, which we
    are going to be covering in the next section.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，它是如何工作的呢？它之所以能工作，是因为`items`数组，我们将在下一节中介绍。
- en: The items array
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目数组
- en: The key to this code is the `items` array. This stores all of the information
    in the n8n data structure passed to the `Function` node from the previous node.
    The value in the square brackets represents the index of the JSON object in the
    `items` array with which you wish to work.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的关键是`items`数组。它存储了传递给`函数`节点的上一个节点中n8n数据结构中的所有信息。方括号中的值代表你希望与之工作的`items`数组中JSON对象的索引。
- en: The most basic `items` array only has a single object represented by the zero
    (0) index number, but it is possible to have several more objects in the `items`
    array, and you can access each of these objects using the array index number associated
    with that object.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的`items`数组只有一个由零（0）索引号表示的对象，但`items`数组中可能有更多的对象，你可以使用与该对象关联的数组索引号访问每个这些对象。
- en: In the next sections, we are going to talk a bit about referencing different
    parts of the `items` array using dot notation, along with how to output the information
    once we have transformed it. Plus, we will also cover how to access data in different
    nodes other than the one that immediately preceded the node you are in.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将简要讨论使用点符号引用`items`数组的不同部分，以及如何在我们转换信息后输出信息。此外，我们还将介绍如何访问除你所在的节点直接前一个节点之外的其他节点中的数据。
- en: Dot notation
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点符号
- en: Once you have chosen the proper object within the `items` array by indicating
    its index number, you need to determine if you will work with the JSON or the
    binary object. You can do this by using what is referred to as `.`). In *line
    1* of our code, the dot between `items[0]` and `json` tells n8n to reference the
    `json` object in the `items` array with the `0` index.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你通过指定其索引号在`items`数组中选择了适当的对象，你需要确定你将处理JSON还是二进制对象。你可以通过使用所谓的`.`来完成此操作）。在我们的代码的第*1*行中，`items[0]`和`json`之间的点告诉n8n引用`items`数组中索引为`0`的`json`对象。
- en: Most of the time, you will be working in the `json` object, but there are situations
    where you would use the `binary` object.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你将在`json`对象中工作，但有些情况下你会使用`binary`对象。
- en: 'To better understand the dot notation used to reference different parts of
    the `items` array, refer to the following table with the dot notation name on
    the left and the piece of the JSON it is referencing on the right:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解用于引用`items`数组不同部分的点符号，请参考以下表格，其中左侧是点符号名称，右侧是它引用的JSON部分：
- en: '![](img/Table_3.05_B17493.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 表格](img/Table_3.05_B17493.jpg)'
- en: Outputting data
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出数据
- en: As with functions in other programming languages, the `Function` node needs
    to indicate which information gets passed to the rest of the program. This is
    accomplished by the second line of code, which returns the newly updated `items`
    array to the next node.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编程语言中的函数一样，`Function`节点需要指示哪些信息被传递到程序的其余部分。这是通过代码的第二行完成的，它将更新后的`items`数组返回到下一个节点。
- en: While it is a best practice to modify the value of the `items` array and pass
    it on to the next node, this is technically not required, and you can return any
    array that follows the proper n8n data structure.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然修改`items`数组的值并将其传递给下一个节点是一种最佳实践，但从技术上讲，这不是必需的，你可以返回任何遵循正确的n8n数据结构的数组。
- en: Data from other nodes (the $items method)
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来自其他节点的数据（$items方法）
- en: Sometimes, it is necessary to reference the output of a node that is not directly
    connected to the `Function` node that you are working with but has been executed
    before your node. In this instance, referencing the `items` array will not give
    you the correct information.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，有必要引用一个未直接连接到你正在工作的`Function`节点但之前已经执行过的节点的输出。在这种情况下，引用`items`数组将不会给你正确的信息。
- en: To resolve this issue, you can use the `$items` method. This method allows you
    to access all of the data in a node as long as that node is before the present
    node you are working in and has already been executed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，你可以使用`$items`方法。此方法允许你访问节点中的所有数据，只要该节点在你正在工作的当前节点之前并且已经执行过。
- en: 'Let''s take a look at this in action. Let''s build the following workflow:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个动作。让我们构建以下工作流程：
- en: '![Figure 3.4 – Basic workflow with three Function nodes'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 – 使用三个Function节点的基本工作流程'
- en: '](img/Figure_3.04_B17493.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 – 使用三个Function节点的基本工作流程](img/Figure_3.04_B17493.jpg)'
- en: Figure 3.4 – Basic workflow with three Function nodes
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 使用三个Function节点的基本工作流程
- en: 'Since this is a default `Function` node, the output of the `myFunction` node
    is this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个默认的`Function`节点，`myFunction`节点的输出如下：
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `Reset` node then deletes everything that it receives and sets the output
    to empty, as indicated here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reset`节点随后删除它接收到的所有内容，并将输出设置为空，如这里所示：'
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We set the JavaScript in the `Function` node to output the information from
    the previous node, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Function`节点中设置JavaScript以输出前一个节点的信息，如下所示：
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you will see, we end up with the same results as we have from the `Reset`
    node.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们最终得到与`Reset`节点相同的结果。
- en: 'Now, let''s use the `$items` method to pull the data from the `myFunction`
    node, essentially skipping the `Reset` node. Change the JavaScript in the `Function`
    node to this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`$items`方法从`myFunction`节点中提取数据，实际上跳过了`Reset`节点。将`Function`节点中的JavaScript更改如下：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When you run the workflow now, you will see that the output of the `Function`
    node matches the output of the `myFunction` node.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在运行工作流时，你会看到`Function`节点的输出与`myFunction`节点的输出相匹配。
- en: 'As with the `items` array, you can specify which item in the `$items` method
    to reference by setting the index in square brackets. Along with using the array
    index, you can also use dot notation to reference deeper into the array and objects.
    For example, this is a perfectly acceptable way of accessing specific information
    from a node:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 就像对`items`数组一样，你可以通过设置方括号中的索引来指定要引用的`$items`方法中的哪个项目。除了使用数组索引外，你还可以使用点符号来深入到数组和对象中引用。例如，以下方式访问特定信息是完全可接受的：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Manipulating data
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据操作
- en: Because the `Function` node uses JavaScript, you have all of the power of JavaScript
    at your disposal for manipulating data. A deep dive into JavaScript and its capabilities
    is outside of the scope of this book, but there are some useful commands that
    we have put together to give you a head start.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Function`节点使用JavaScript，你可以使用JavaScript的所有功能来操作数据。对JavaScript及其功能的深入研究超出了本书的范围，但有一些有用的命令我们已经整理出来，以帮助你入门。
- en: Strings
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串
- en: 'For these examples, we will assume that we have a variable called `fullName`,
    and the value assigned to it is `Jim Nasium`. Have a look at the following table:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些示例，我们将假设我们有一个名为`fullName`的变量，并且分配给它的值是`Jim Nasium`。请看以下表格：
- en: '![](img/Table_3.01_B17493.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_3.01_B17493.jpg)'
- en: Mathematics
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数学
- en: 'JavaScript also has potent mathematical abilities. Here are some practical
    examples:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript也具有强大的数学能力。以下是一些实际例子：
- en: '![](img/Table_3.02_B17493.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_3.02_B17493.jpg)'
- en: As you should now realize, the `Function` node is extremely powerful. We have
    learned how to reference data both inside the node and from other nodes, manipulate
    both strings and numbers, and output the data so that it can be used by other
    nodes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你现在应该意识到的，`Function`节点非常强大。我们已经学会了如何在节点内部和从其他节点引用数据，操作字符串和数字，以及输出数据以便其他节点可以使用。
- en: Now that we have a better understanding of the power of the `Function` node
    and some ideas of what can be done with the data, let's look at getting some data
    from remote systems via their API using the `HTTP Request` node.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经更好地理解了`Function`节点的能力以及我们可以用数据做什么，让我们看看如何通过`HTTP Request`节点从远程系统获取数据。
- en: HTTP Request node – Talk to any API
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP请求节点 - 与任何API通信
- en: Computer systems are fantastic for storing and processing massive amounts of
    data, but computer users and developers very quickly discovered that there was
    no actual standard for allowing these computers to share information.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机系统非常适合存储和处理大量数据，但计算机用户和开发者很快发现，并没有实际的标准允许这些计算机共享信息。
- en: Someone had the bright idea to use the new web standard to create a way for
    these systems to communicate. They would use standard request methods to retrieve,
    add, delete, or update information on remote computers. Along with these functions,
    they would even provide the ability to secure these connections using various
    methods to ensure only authorized individuals could get to the data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人有了一个聪明的想法，即使用新的Web标准来创建一种让这些系统进行通信的方式。他们会使用标准的请求方法来检索、添加、删除或更新远程计算机上的信息。除了这些功能外，他们甚至提供了使用各种方法来确保只有授权的个人才能访问数据的能力。
- en: This system setup is collectively referred to as a web API, which is one of
    the most popular ways of working with remote data today. There are thousands of
    different APIs available, providing access to an extensive range of data and information.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这种系统设置统称为Web API，这是今天处理远程数据最受欢迎的方式之一。有数千种不同的API可用，提供对广泛的数据和信息访问。
- en: Since one of the primary functions of n8n is to connect different systems to
    share data, it only makes sense to talk to these web APIs.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于n8n的主要功能之一是将不同的系统连接起来以共享数据，因此与这些Web API进行通信是合情合理的。
- en: In this section, we are going to learn how APIs work, how they are formatted,
    ways that data can be passed through APIs, and primary methods supported by APIs,
    along with the response codes that they return. Finally, we will perform some
    basic API calls, as well as look at how to secure these calls.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习API是如何工作的，它们的格式是怎样的，数据如何通过API传递，以及API支持的主要方法和它们返回的响应代码。最后，我们将进行一些基本的API调用，并了解如何确保这些调用的安全性。
- en: Web API 101
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web API 101
- en: Before we look at the `HTTP Request` node, let's first do a quick overview of
    how APIs work to better understand how they allow systems to interact with them.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看`HTTP请求`节点之前，让我们先快速概述一下API是如何工作的，以便更好地理解它们如何允许系统与之交互。
- en: Web APIs run on the same technology as most of the websites on the internet,
    but instead of dishing up your favorite web pages or cat videos, web servers configured
    to run APIs allow remote systems to make a request and then reply to the request
    with data based on the input received earlier. The data that is sent between the
    systems is often formatted in JSON.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Web API运行在互联网上大多数网站所使用的技术上，但与提供您最喜欢的网页或猫视频不同，配置为运行API的Web服务器允许远程系统发出请求，并根据之前接收到的输入以数据的形式回复请求。系统之间发送的数据通常格式化为JSON。
- en: 'To see the most basic API in action, let''s take a look at the Random User
    API. Open up your web browser, and in the address bar, enter [https://randomuser.me/api/](https://randomuser.me/api/).
    When you press the *Enter* key, you will see a bunch of text similar to this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看最基础的API操作，让我们看看Random User API。打开您的网络浏览器，在地址栏中输入[https://randomuser.me/api/](https://randomuser.me/api/)。当您按下*Enter*键时，您将看到一些类似这样的文本：
- en: '[PRE11]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: While this may look like a lot of gibberish, you will see a few characters that
    look familiar from our `Function` node chapter if you look closely. What we've
    come across is compressed or unformatted JSON!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来像是一堆乱码，但如果您仔细观察，您将看到一些从我们的`函数`节点章节中熟悉的字符。我们遇到的是压缩或未格式化的JSON！
- en: Anatomy of an API URL
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API URL的解剖结构
- en: To access an API, one of the essential items you will need is a **Uniform Resource
    Locator** (**URL**). It is vital to understand the different parts of a URL because
    you or your system will often be required to build the URL yourself so that you
    can work with your desired information.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问API，您将需要的必备物品之一是**统一资源定位符**（**URL**）。理解URL的不同部分至关重要，因为您或您的系统将经常需要自己构建URL，以便您可以处理所需的信息。
- en: 'Let''s look at a fictional API URL, dissect the different parts of the URL,
    and determine their purpose. For this exercise, we are going to use the following
    URL: [https://api.example.com/v3/computers?type=laptop&ram=32&hdd=1024](https://api.example.com/v3/computers?type=laptop&ram=32&hdd=1024)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个虚构的API URL，分析URL的不同部分，并确定它们的目的。为此练习，我们将使用以下URL：[https://api.example.com/v3/computers?type=laptop&ram=32&hdd=1024](https://api.example.com/v3/computers?type=laptop&ram=32&hdd=1024)
- en: The parts of the API URL are explained in the following sections.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: API URL的各个部分将在以下章节中解释。
- en: Protocol
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协议
- en: In our example, this is the https:// portion of the URL. This will generally
    be either http:// or https://. This is important because if the protocol is http://,
    the data is not encrypted between the API server and the client. Anyone can see
    what information is passing between these two computers, including passwords.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，这是URL中的https://部分。这通常将是http://或https://。这很重要，因为如果协议是http://，那么API服务器和客户端之间的数据不会被加密。任何人都可以看到这两台计算机之间传递的信息，包括密码。
- en: Always make sure that the protocol is https://.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 总是要确保协议是https://。
- en: Base URL
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础URL
- en: The base URL in our example is [api.example.com](http://api.example.com). It
    is sometimes referred to as the **hostname**, **domain name**, or **Domain Name
    System (DNS) name**. These all refer to the same thing. The base URL is generally
    the server that is hosting the API.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，基础URL是[api.example.com](http://api.example.com)。它有时被称为**主机名**、**域名**或**域名系统（DNS）名称**。这些都指的是同一件事。基础URL通常是托管API的服务器。
- en: Endpoint
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 端点
- en: For our example, the endpoint is /v3/computers. It is sometimes referred to
    as the API path. The endpoint is either static (that is, it stays the same) or
    dynamic (that is, it changes based on the information that is being requested).
    While there is no absolute standard for how endpoints are used, there are some
    common practices.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的例子，端点是/v3/computers。它有时被称为API路径。端点是静态的（即保持不变）或动态的（即根据请求的信息而变化）。虽然端点的使用没有绝对标准，但有一些常见的做法。
- en: From our example, the /v3 portion tells us that this is version 3 of the API,
    and the /computers portion tells us that we can expect one or more records to
    be returned by this endpoint.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的示例中，/v3 部分告诉我们这是 API 的第 3 版，而 /computers 部分告诉我们可以期待此端点返回一个或多个记录。
- en: Query parameters
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询参数
- en: The example has three query parameters—`type=laptop`, `ram=32`, and `hdd=1024`.
    Two delimiters identify the query parameters. The `?` delimiter separates the
    query parameters from the rest of the URL, and the `&` delimiter separates each
    query parameter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中有三个查询参数——`type=laptop`、`ram=32` 和 `hdd=1024`。两个分隔符标识查询参数。`?` 分隔符将查询参数与 URL
    的其余部分分开，而 `&` 分隔符将每个查询参数分开。
- en: Much as with JSON key-value pairs, the key is the portion before the equals
    sign (`=`), and the value is the portion after the equals sign (`=`).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JSON 键值对类似，键是等于号（`=`）之前的部分，值是等于号（`=`）之后的部分。
- en: Other parameters
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他参数
- en: While using specific endpoints and query parameters are the most common ways
    of controlling the type of information that is passed between the API client and
    server, other parameters can further modify the information flow.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用特定端点和查询参数是控制 API 客户端和服务器之间传递的信息类型最常见的方式的同时，其他参数可以进一步修改信息流。
- en: Headers
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标头
- en: Headers are typically used to provide metadata about the API request. They often
    give information on the type of data being transmitted, security tokens, or server
    information.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 标头通常用于提供有关 API 请求的元数据。它们通常会提供有关正在传输的数据类型、安全令牌或服务器信息的信息。
- en: These are generally transmitted in a key-value pair.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息通常以键值对的形式传输。
- en: Body parameters
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主体参数
- en: The body of a request typically carries information or data required to complete
    the request or is supplied by the server based on the request made by the client.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的主体通常携带完成请求所需的信息或数据，或者由服务器根据客户端提出的请求提供。
- en: This information is generally sent in a key-value pair.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此信息通常以键值对的形式发送。
- en: HTTP methods
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 方法
- en: There are different ways of interacting with APIs, each producing a different
    result on the server hosting the API and the client requesting the action. These
    are referred to as **methods** and can be thought of as action verbs that allow
    the system to know how to deal with the request. The next sections provide a brief
    overview of each method and its general use.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 与 API 交互有不同的方式，每种方式都会在托管 API 的服务器和请求操作的客户端上产生不同的结果。这些被称为 **方法**，可以被视为允许系统知道如何处理请求的动作动词。下一节将简要概述每种方法及其一般用途。
- en: GET
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GET
- en: '`GET` is the most common method. It is used every time you use a web browser
    to retrieve information from a web server.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET` 是最常见的方法。每次您使用网络浏览器从网络服务器检索信息时都会使用它。'
- en: '`GET` is typically used for retrieving data from an API.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET` 通常用于从 API 中检索数据。'
- en: POST
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: POST
- en: The `POST` method is the other most commonly used method. Web browsers will
    often use this method to submit information from a web form.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST` 方法是另一种最常用的方法。网络浏览器通常会使用此方法从网页表单提交信息。'
- en: '`POST` is generally used for submitting information to an API that is then
    stored by the API as a new record.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST` 通常用于向 API 提交信息，然后由 API 作为新记录存储。'
- en: DELETE
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DELETE
- en: The `DELETE` method is usually used to delete a resource or record on the API's
    remote server.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELETE` 方法通常用于在 API 的远程服务器上删除资源或记录。'
- en: HEAD
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HEAD
- en: The `HEAD` method works very much like the `GET` method, except that the API
    only returns header information and no other data.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`HEAD` 方法与 `GET` 方法非常相似，除了 API 只返回头部信息而不返回其他数据。'
- en: PATCH
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PATCH
- en: Patching a resource allows you to change only part of the information in the
    record, leaving everything else the same as it was before.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 修补资源允许您只更改记录中的部分信息，而将其他所有内容保持与之前相同。
- en: PUT
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PUT
- en: '`PUT` is similar to the `POST` method in that it creates a new record on the
    API server if no record exists. But if the information being put to the API has
    a matching record, this record will be overwritten and replaced by the new information.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT` 方法与 `POST` 方法类似，如果不存在记录，则会在 API 服务器上创建一个新记录。但如果要放入 API 的信息有一个匹配的记录，则该记录将被覆盖并由新信息替换。'
- en: Response codes
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应代码
- en: When a request is made to an API server and the data and metadata is returned
    to the client, there is also a response code. While diving deep into what each
    response code means and how you can use them for detailed troubleshooting is beyond
    the scope of this book, it is essential to know each classification of response
    code and what they represent.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当向 API 服务器发出请求并且数据及元数据返回给客户端时，还有一个响应代码。虽然深入探讨每个响应代码的含义以及如何使用它们进行详细的故障排除超出了本书的范围，但了解每个响应代码的分类以及它们代表的内容是至关重要的。
- en: 1xx (informational)
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1xx (信息性)
- en: The request was received by the server and is still being processed. Please
    wait for it to finish.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 请求已被服务器接收并正在处理中。请等待它完成。
- en: 2xx (success)
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2xx (成功)
- en: Everything worked as expected, more or less.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的操作都按预期进行，或多或少。
- en: 3xx (redirection)
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3xx (重定向)
- en: The API is no longer at the location you requested. Check the error message
    to get a better idea of the new API location.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: API 已经不在你请求的位置了。检查错误信息以获取关于新 API 位置的更多信息。
- en: 4xx (client error)
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4xx (客户端错误)
- en: Something is wrong with how you formed the API request. Check the error message
    and then update the request.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你构建的 API 请求有误。检查错误信息，然后更新请求。
- en: 5xx (server error)
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5xx (服务器错误)
- en: There's a problem with the server, and generally, there is little that you can
    do to resolve the issue. If you have the contact information for the person/team
    managing the API server, you could report the error to them and see if they can
    assist.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器有问题，通常你无法做太多来解决这个问题。如果你有管理 API 服务器的个人/团队的联系方式，你可以向他们报告错误并看看他们是否能提供帮助。
- en: Now that we understand what APIs are about, let's start using n8n's `HTTP Request`
    node to connect to a few APIs.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了 API 的概念，让我们开始使用 n8n 的 `HTTP Request` 节点连接到一些 API。
- en: Basic API call
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本API调用
- en: Let's start with a simple API call. Let's get information from GitHub about
    the n8n project.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的 API 调用开始。让我们从 GitHub 获取有关 n8n 项目的信息。
- en: Add a new `HTTP Request` node to the canvas in the n8n Editor UI and open the
    node. Please leave all of the parameters at their defaults, except for the `URL`
    value. Set the `URL` value to https://api.github.com/users/n8n-io/.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在 n8n 编辑器 UI 的画布中添加一个新的 `HTTP Request` 节点并打开它。请将所有参数保留在默认值，除了 `URL` 值。将 `URL`
    值设置为 https://api.github.com/users/n8n-io/。
- en: 'And that''s it! We are now ready to retrieve the data from the server via the
    API! Click on **Execute Node** to perform the API request. You should get a response
    that looks something like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们现在已经准备好通过 API 从服务器检索数据了！点击 **执行节点** 执行 API 请求。你应该得到一个类似以下响应：
- en: '[PRE12]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can now connect other nodes to the output of the `HTTP Request` node and
    process the information however you wish, or send it to another system.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以将其他节点连接到 `HTTP Request` 节点的输出，并按你的意愿处理信息，或者将其发送到另一个系统。
- en: Using basic authentication
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用基本认证
- en: 'Now, let''s try something a bit more complicated. We''re going to look up `HTTP
    Request` node to query the API:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试一个稍微复杂一点的操作。我们将查找 `HTTP Request` 节点以查询 API：
- en: Browse to [https://upcdatabase.org/signup](https://upcdatabase.org/signup) and
    create an account.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到 [https://upcdatabase.org/signup](https://upcdatabase.org/signup) 并创建一个账户。
- en: Once you have your account created, go to [https://upcdatabase.org/apikeys](https://upcdatabase.org/apikeys)
    and copy the token on that page. If there is no token on the page, create a new
    token and then copy it.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你创建了账户，转到 [https://upcdatabase.org/apikeys](https://upcdatabase.org/apikeys)
    并复制该页面的令牌。如果页面上没有令牌，创建一个新的令牌然后复制它。
- en: In the n8n Editor UI, add a new `HTTP Request` node to the canvas.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 n8n 编辑器 UI 中，将一个新的 `HTTP Request` 节点添加到画布中。
- en: For the **Authentication** parameter, select **Basic Auth**.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 **认证** 参数，选择 **基本认证**。
- en: Next, click **Create New** to open up a new credential window for the **Basic
    Auth** parameter.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击 **创建新** 打开 **基本认证** 参数的新凭证窗口。
- en: Enter in a value for `UPC`), enter your email address in the **User** field,
    and paste your token into the **Password** field.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `UPC` 输入值中输入，在 **用户** 字段中输入你的电子邮件地址，并将你的令牌粘贴到 **密码** 字段中。
- en: Click on the `HTTP Request` node. Notice that the **Basic Auth** parameter now
    has the name of the credentials that you just created.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `HTTP Request` 节点。注意，**基本认证**参数现在显示的是你刚刚创建的凭证名称。
- en: In the URL parameter field, enter [https://api.upcdatabase.org/product/765756931182](https://api.upcdatabase.org/product/765756931182).
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 URL 参数字段中输入 [https://api.upcdatabase.org/product/765756931182](https://api.upcdatabase.org/product/765756931182)。
- en: 'Your `HTTP Request` node should be ready to go. Hit **Execute Node** and check
    out your results. They should look something like this:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的 `HTTP 请求` 节点应该已经准备好。点击 **执行节点** 并查看您的结果。它们应该看起来像这样：
- en: '[PRE13]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Try changing the number at the end of the URL and replace it with other UPCs
    you have around your home, and see what information you can find out about the
    products.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更改 URL 末尾的数字，并用你家里的其他 UPC 替换它，看看你能找到关于产品的哪些信息。
- en: In this section, we covered the basics of APIs including the parts that make
    up an API, how information is transmitted using APIs, the different **HyperText
    Transfer Protocol** (**HTTP**) methods, and their corresponding response codes.
    We then made both basic and secured API calls.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了 API 的基础知识，包括构成 API 的部分，信息如何通过 API 传输，不同的 **超文本传输协议**（**HTTP**）方法以及它们对应的响应代码。然后我们进行了基本的和安全性的
    API 调用。
- en: Now that we better understand APIs, let's move away from retrieving information
    that we request from other servers and take a look at receiving information that
    is pushed to n8n.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 API 有更好的理解，让我们从获取我们从其他服务器请求的信息转向接收推送到 n8n 的信息。
- en: Webhook node – Handling real-time events
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Webhook 节点 – 处理实时事件
- en: You can think of Webhooks as the cousin of APIs. In fact, you can create an
    API server using the `Webhook` node!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把 Webhooks 视为 API 的堂兄弟。实际上，你可以使用 `Webhook` 节点创建一个 API 服务器！
- en: A Webhook listens for `GET`, `HEAD`, or `POST` requests and then starts a workflow
    when it detects one. The `Webhook` node can do this because it is a trigger node.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Webhook 监听 `GET`、`HEAD` 或 `POST` 请求，并在检测到请求时启动工作流程。`Webhook` 节点可以这样做，因为它是一个触发节点。
- en: In this section, we are going to learn how to create a Webhook using n8n. As
    part of this build, we will learn how to send information to the Webhook and how
    to respond back with the requested information.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用 n8n 创建 Webhook。作为构建的一部分，我们将学习如何向 Webhook 发送信息以及如何响应请求的信息。
- en: Creating a basic test Webhook
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基本的测试 Webhook
- en: 'To build a basic Webhook, follow these instructions:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建基本的 Webhook，请按照以下说明操作：
- en: Add a `Webhook` node to the n8n Editor UI canvas and open the node.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个 `Webhook` 节点添加到 n8n 编辑器 UI 画布中，并打开该节点。
- en: Leave all of the parameter values at their defaults.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有参数值保留在默认值。
- en: Expand the **Webhook URLs** section by clicking on the **Webhook URLs** text.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击 **Webhook URLs** 文本来展开 **Webhook URLs** 部分。
- en: Click on the **Test URL** toggle under the **Display URL for** section.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **显示 URL 为** 部分下点击 **测试 URL** 开关。
- en: Click on the URL to copy it to your clipboard (for example, [https://tephlon.app.n8n.cloud/webhook-test/373227bb-5fda-49e9-b491-54ef33db3eed](https://tephlon.app.n8n.cloud/webhook-test/373227bb-5fda-49e9-b491-54ef33db3eed)).
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 URL 以将其复制到您的剪贴板（例如，[https://tephlon.app.n8n.cloud/webhook-test/373227bb-5fda-49e9-b491-54ef33db3eed](https://tephlon.app.n8n.cloud/webhook-test/373227bb-5fda-49e9-b491-54ef33db3eed))。
- en: Close the `Webhook` node.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 `Webhook` 节点。
- en: Save the workflow. This is important because the Webhook URL can't register
    until the workflow is saved.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存工作流程。这很重要，因为 Webhook URL 在工作流程保存之前无法注册。
- en: That's it! You've just created your first basic Webhook!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你已经创建了你第一个基本的 Webhook！
- en: 'Now, let''s test it to see if it is working! Follow these steps:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试一下它是否正常工作！按照以下步骤操作：
- en: In the n8n Editor UI, open up the `Webhook` node.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 n8n 编辑器 UI 中，打开 `Webhook` 节点。
- en: Click on the **Execute Node** button to start the Webhook listening.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **执行节点** 按钮以启动 Webhook 监听。
- en: Open up a new web browser, paste the Webhook URL you copied earlier into the
    address bar, and press *Enter*.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的网页浏览器，将你之前复制的 Webhook URL 粘贴到地址栏中，然后按 *Enter*。
- en: 'If everything is working correctly, you should see two things happen, as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，你应该看到以下两个结果：
- en: 'In the web browser window, you should get the following message:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网页浏览器窗口中，你应该会看到以下信息：
- en: '[PRE14]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the n8n Editor UI, you should receive a bunch of information in the `Webhook`
    node output window, similar to this:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 n8n 编辑器 UI 中，你应该在 `Webhook` 节点输出窗口中接收到一些信息，类似于以下内容：
- en: '[PRE15]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is all of the information that has been sent to n8n from the web browser.
    While there is some interesting data here, there isn't anything helpful at this
    time.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从网页浏览器发送到 n8n 的所有信息。虽然这里有一些有趣的数据，但目前没有有用的信息。
- en: Sending information to n8n
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向 n8n 发送信息
- en: 'Since we have a basic Webhook running, let''s see what happens when we send
    some information to it as a query in the URL. Follow these steps:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有一个基本的 Webhook 在运行，让我们看看当我们向它发送一些信息作为 URL 中的查询时会发生什么。按照以下步骤操作：
- en: In the n8n Editor UI, open up the `Webhook` node and press the **Execute Node**
    button.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在n8n编辑器UI中，打开`Webhook`节点并按下**执行节点**按钮。
- en: In the web browser window that you used previously, paste the Webhook URL into
    the address bar, but before you press *Enter*, add `?fname=Jim&lname=Nasium` to
    the end of the URL. Then, press *Enter*.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你之前使用的网页浏览器窗口中，将Webhook URL粘贴到地址栏中，但在按*Enter*之前，将`?fname=Jim&lname=Nasium`添加到URL的末尾。然后，按*Enter*。
- en: 'Everything looks the same in the web browser, but let''s look closely at the
    `query` section in the `Webhook` node output window, which you can see here:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页浏览器中看起来一切正常，但让我们仔细看看Webhook节点输出窗口中的`query`部分，如下所示：
- en: '[PRE16]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These values match the values entered at the end of the URL that was entered
    into the web browser. You can now use this information received from the client
    in the rest of your workflow.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值与在网页浏览器中输入的URL末尾输入的值匹配。你现在可以使用从客户端接收到的这些信息在你的工作流程的其余部分中使用。
- en: Responding to the client
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应客户端
- en: 'Now that we know we can receive information from the client, let''s send a
    confirmation message to the sender! Follow these steps:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道我们可以从客户端接收信息，那么让我们向发送者发送一条确认消息！按照以下步骤操作：
- en: In the `Webhook` node, change `Response Mode` to `Last Node`.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Webhook`节点中，将`Response Mode`更改为`Last Node`。
- en: Under the `Webhook` node, add a `html`.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Webhook`节点下，添加一个`html`。
- en: Next, add a `Webhook` node and enable the option.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个`Webhook`节点并启用该选项。
- en: Close the `Webhook` node.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`Webhook`节点。
- en: Add a `Set` node to the n8n Editor UI and connect it to the output of the `Webhook`
    node.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在n8n编辑器UI中添加一个`Set`节点，并将其连接到`Webhook`节点的输出。
- en: Open the `Set` node and add a `string` value.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Set`节点并添加一个`string`值。
- en: Name the value `html`.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值命名为`html`。
- en: Click on the gears next to **Value** and click on the **Add Expression** option.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Value**旁边的齿轮，然后点击**添加表达式**选项。
- en: In the `<H1>Thanks for visiting, {{$json["query"]["fname"]}} {{$json["query"]["lname"]}}!</H1>`
    in the **Expression** field.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**表达式**字段中的`<H1>感谢光临，{{$json["query"]["fname"]}} {{$json["query"]["lname"]}}!</H1>`。
- en: Close the `Set` node.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`Set`节点。
- en: Let's see what this does for us. In the n8n Editor UI, click on the `?fname=Jim&lname=Nasium`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这能为我们做什么。在n8n编辑器UI中，点击`?fname=Jim&lname=Nasium`。
- en: If everything has been set up correctly, you should get a message in large letters
    stating "`Thanks for visiting, Jim Nasium!`".
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切设置正确，你应该会收到一条大字显示的消息，内容为"`感谢光临，Jim Nasium！`"。
- en: How does that work?
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这是如何工作的？
- en: When the web browser sends the information to the Webhook, the Webhook grabs
    the `fname=Jim&lname=Nasium` portion of the URL and sends it on to the `Set` node.
    The `Set` node then uses the values for `fname` and `lname` to dynamically generate
    **HyperText Markup Language** (**HTML**), which the Webhook uses to send back
    to the web browser. The web browser then displays the HTML accordingly.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当网页浏览器将信息发送到Webhook时，Webhook会抓取URL中的`fname=Jim&lname=Nasium`部分，并将其发送到`Set`节点。然后`Set`节点使用`fname`和`lname`的值动态生成**超文本标记语言**（**HTML**），Webhook使用它将HTML发送回网页浏览器。然后，网页浏览器相应地显示HTML。
- en: We've essentially turned n8n into a web server that can generate real-time dynamic
    web pages!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上已经把n8n转换成了一个可以生成实时动态网页的Web服务器！
- en: We have one last section that we want to cover before we close out this chapter.
    Let's talk about manipulating data stored in arrays and JSON objects.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，我们还有一个部分要介绍。让我们谈谈如何操作存储在数组和JSON对象中的数据。
- en: Working with arrays and JSON objects
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数组和JSON对象
- en: n8n uses a lot of arrays and JSON objects, and it is important that you are
    comfortable working with them. In this section, we will learn how to manipulate
    arrays and objects by splitting, combining, and writing to these items.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: n8n使用了大量的数组和JSON对象，因此你需要熟悉它们。在本节中，我们将学习如何通过拆分、合并和写入这些项来操作数组和对象。
- en: There is a lot of data flying around an n8n workflow, and it can be constructive
    to learn a few tips and tricks about manipulating this data stored in arrays and
    JSON objects.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在n8n工作流程中有很多数据在传输，学习一些关于操作这些存储在数组和JSON对象中的数据的技巧和窍门是有益的。
- en: 'For these examples, we are going to use an array with three JSON objects with
    the same keys, as illustrated in the following code snippet:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们将使用一个包含三个具有相同键的JSON对象的数组作为示例：
- en: '[PRE17]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you look at this information using the **Table** tab at the top of the n8n
    node generating this information, it will look something like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用n8n节点顶部**表格**选项卡查看这些信息，它看起来可能像这样：
- en: '![](img/Table_3.03_B17493.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![img/Table_3.03_B17493.jpg]'
- en: 'You can generate this table in a `Function` node by adding a `Function` node
    to the n8n Editor UI and then pasting the following into the JavaScript code field:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Function`节点中通过将`Function`节点添加到n8n编辑器UI中，并将以下内容粘贴到JavaScript代码字段中生成此表格：
- en: '[PRE18]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, the output of the `Function` node should match the preceding table.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Function`节点的输出应该与前面的表格匹配。
- en: Next, let's learn how to split data from the `Function` node using the `IF`
    node.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们学习如何使用`IF`节点从`Function`节点中分割数据。
- en: Separating the cats from the dogs
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将猫和狗分开
- en: The first thing we are going to do is split this array into two arrays using
    the `IF` node. We are going to send all of the dogs to the `true` output and all
    of the cats to the `false` output.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的第一件事是将这个数组分成两个数组，使用`IF`节点。我们将所有狗发送到`true`输出，所有猫发送到`false`输出。
- en: 'To do this, follow these steps:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，请按照以下步骤操作：
- en: Attach an `IF` node to the output of the node generating the array.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个`IF`节点连接到生成数组的节点的输出。
- en: Open the `IF` node and add a `string` condition to the node.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`IF`节点并向节点添加一个`string`条件。
- en: In the `Value 1` field, click on the gears icon and select **Add Expression**.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`值 1`字段中，点击齿轮图标并选择**添加表达式**。
- en: In the `{{$json["species"]}}` into the **Expression** field and close the Expression
    editor.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**表达式**字段中将`{{$json["species"]}}`输入，并关闭表达式编辑器。
- en: In the `Value 2` field, type `dog` for the value.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`值 2`字段中，将值输入为`dog`。
- en: Close the `IF` node and execute the workflow.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`IF`节点并执行工作流程。
- en: Open the `IF` node and take a look at the results for the `true` and `false`
    outputs. You should see that there are two entries in the `false` output and one
    in the `true` output.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`IF`节点并查看`true`和`false`输出的结果。你应该会看到`false`输出中有两个条目，而`true`输出中有一个条目。
- en: Combining two arrays
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并两个数组
- en: 'Now that we have split the array apart, let''s see if we can bring them back
    together again. We''re going to do this using the `Merge` node. Follow these steps:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将数组分开，让我们看看我们是否可以将它们再次合并在一起。我们将使用`Merge`节点来完成这项工作。请按照以下步骤操作：
- en: Add a `Merge` node to the n8n Editor UI.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个`Merge`节点添加到n8n编辑器UI中。
- en: Connect the `true` output from the `IF` node to `Input 1` of the `Merge` node.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`IF`节点的`true`输出连接到`Merge`节点的`输入 1`。
- en: Connect the `false` output from the `IF` node to `Input 2` of the `Merge` node
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`IF`节点的`false`输出连接到`Merge`节点的`输入 2`。
- en: Open the `Merge` node.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Merge`节点。
- en: For the `Mode` parameter, select **Append**.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`模式`参数，选择**追加**。
- en: Close the `Merge` node.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`Merge`节点。
- en: 'Your final workflow should look something like this:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你的最终工作流程应该看起来像这样：
- en: '![Figure 3.5 – Splitting and merging an array workflow'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.5 – Splitting and merging an array workflow]'
- en: '](img/Figure_3.05_B17493.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.05_B17493.jpg]'
- en: Figure 3.5 – Splitting and merging an array workflow
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 分割和合并数组工作流程
- en: It's now time to test it out! Execute the workflow. When it finishes running,
    open up the `Merge` node. The output windows should show that the array is once
    again back together.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候测试它了！执行工作流程。当它运行完成后，打开`Merge`节点。输出窗口应该显示数组再次合并在一起。
- en: Adding the same value to all JSON objects
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将相同的值添加到所有JSON对象中
- en: Now, let's imagine we want to add another key to all records in the array coming
    out from the `Merge` node. Let's also assume that each copy of the key will be
    the same.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们想要向从`Merge`节点输出的所有记录中添加另一个键。让我们还假设每个键的副本都是相同的。
- en: 'We can accomplish this by using the `Set` node. Here are the steps you need
    to follow:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`Set`节点来完成这项工作。以下是你需要遵循的步骤：
- en: Add a `Set` node to the n8n Editor UI and attach it to the output of the `Merge`
    node.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个`Set`节点添加到n8n编辑器UI中，并将其连接到`Merge`节点的输出。
- en: Open the `Set` node.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Set`节点。
- en: Add a new Boolean value and name it `adopted`.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的布尔值并命名为`adopted`。
- en: Set the value of `adopted` to `true`.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`adopted`的值设置为`true`。
- en: Close the `Set` node.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`Set`节点。
- en: 'To check if it worked, execute the workflow and open up the `IF` node. The
    table in the output window should now look like this:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查它是否工作，执行工作流程并打开`IF`节点。输出窗口中的表格现在应该看起来像这样：
- en: '![](img/Table_3.04_B17493.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![img/Table_3.04_B17493.jpg]'
- en: Using the `IF`, `Merge`, and `Set` nodes allows us to perform some instrumental
    data manipulation tasks quickly and easily without resorting to custom coding
    using the `Function` node.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`IF`、`Merge`和`Set`节点，我们可以快速轻松地执行一些重要的数据处理任务，而无需使用`Function`节点进行自定义编码。
- en: Summary
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered some critical concepts, and in it, we learned how to build
    some powerful tools within n8n.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一些关键概念，我们学习了如何在n8n中构建一些强大的工具。
- en: We first covered how n8n structures data with JSON using the primary components
    of key-value pairs, objects, and arrays. We followed this by showing how n8n stores
    JSON and binary data internally. Then we talked about using the `Function` node
    and understanding the `items` array, dot notation, and the `$items` method. Once
    functions were figured out, we learned about APIs and how to send and receive
    data using basic and authenticated calls. Next, we reviewed Webhooks and used
    them in n8n to send information and generate HTML files. Finally, we went over
    how n8n works with JSON objects and arrays, including manipulating data that is
    stored in these items.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍了 n8n 如何使用键值对、对象和数组等主要组件来结构化 JSON 数据。随后，我们展示了 n8n 如何在内部存储 JSON 和二进制数据。然后，我们讨论了如何使用
    `Function` 节点，以及如何理解 `items` 数组、点表示法和 `$items` 方法。一旦函数的概念被掌握，我们就学习了 API 以及如何使用基本和认证调用来发送和接收数据。接下来，我们回顾了
    Webhooks，并在 n8n 中使用它们来发送信息和生成 HTML 文件。最后，我们探讨了 n8n 如何与 JSON 对象和数组协同工作，包括如何操作存储在这些项目中的数据。
- en: With this new information under your belt, you are well on your way to building
    practical tools using n8n.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些新信息，你将顺利地开始使用 n8n 构建实用的工具。
- en: In the next chapter, you will put this new knowledge to use and build three
    applications in n8n!
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将运用这些新知识，并在 n8n 中构建三个应用程序！
