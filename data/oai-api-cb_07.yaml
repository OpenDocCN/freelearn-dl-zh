- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Building Assistants with the OpenAI API
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenAI API构建助手
- en: The primary reason that ChatGPT changed the Generative AI landscape is that
    it marketed itself as an easy-to-use all-in-one digital assistant. This approach
    has made it highly accessible to a broad range of users, from developers and businesses
    to educators and creative professionals.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT改变生成性AI格局的主要原因是它将自己推广为一个易于使用的全能数字助手。这种方式使它对广泛的用户群体（从开发者和企业到教育工作者和创意专业人士）都非常可及。
- en: The versatility of the OpenAI API lies in its ability to understand and generate
    human-like text, enabling the creation of sophisticated digital assistants tailored
    to various needs. Whether it’s automating customer service, providing educational
    support, assisting in content creation, or enabling interactive storytelling,
    the API’s robust features allow for endless possibilities.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAI API的多功能性在于它能够理解并生成类人文本，从而能够创建适应各种需求的复杂数字助手。无论是自动化客户服务、提供教育支持、协助内容创作，还是进行互动故事讲述，API强大的功能都允许无尽的可能性。
- en: As a result, we can use the API, along with the other elements that we learned
    about in previous chapters, to create powerful knowledge assistants. How will
    the assistant that we create differ from the ChatGPT product itself? The answer
    lies in the knowledge or information to which the assistant has access.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以利用API以及我们在前几章学习的其他元素，创建强大的知识助手。那么我们创建的助手与ChatGPT产品本身有何不同呢？答案在于助手可以访问的知识或信息。
- en: 'OpenAI has trained ChatGPT on a variety of different sources on the internet,
    but the model itself is data-limited. This has two implications:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAI已经在互联网上的各种不同来源上训练了ChatGPT，但该模型本身是数据有限的。这有两个含义：
- en: '*Information is out of date*: The model (without any extensions or plugins)
    cannot provide current or up-to-date information. For example, you cannot ask
    it **what was the score in yesterday''s** **basketball game**.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信息过时*: 该模型（没有任何扩展或插件）无法提供当前或最新的信息。例如，你不能问它**昨天的** **篮球比赛** **比分是多少**。'
- en: '*Knowledge retrieval is messy*: You cannot restrict the model to only look
    at specific sources when answering questions. Because of this and since the data
    has been trained on various sources from the internet (and certainly not everything
    online is correct), this means that the answers you get may not always be correct.
    This can also occur due to hallucinations.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*知识检索混乱*: 你不能限制模型只查看特定的来源来回答问题。由于这一点，并且因为数据是从互联网上的各种来源进行训练的（而且显然并非所有网上的信息都是正确的），这意味着你得到的答案可能并不总是正确的。这也可能是由于幻觉现象所导致的。'
- en: How do we fix this? We can build our own assistants that use both the OpenAI
    API and a trusted knowledge source that we specify. This can be in the form of
    a PDF file that the user can upload or a web link that we know has the most up-to-date
    information.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决这个问题？我们可以构建自己的助手，使用OpenAI API和我们指定的可信知识源。这可以是用户可以上传的PDF文件，或者是我们知道具有最新信息的网页链接。
- en: In this chapter, we will build knowledge-based assistants. We will use ChatGPT’s
    ability to understand human-like text and respond accordingly, as well as a trusted
    up-to-date knowledge source. Similar to the previous chapter, the application
    architecture will contain the frontend and backend that access the OpenAI API.
    However, we will add an intermediary step to account for the knowledge source.
    If you don’t recall the architecture, *Figure 7**.1* demonstrates the layers within
    any application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建基于知识的助手。我们将利用ChatGPT理解类人文本并做出相应回应的能力，以及一个可信的最新知识源。与上一章类似，应用架构将包含访问OpenAI
    API的前端和后端。然而，我们将添加一个中介步骤来考虑知识源。如果你不记得架构了，*图 7.1*展示了任何应用程序中的层次结构。
- en: '![Figure 7.1 – Demonstration of a typical application architecture using the
    OpenAI API with the Knowledge Source](img/B21007_07_1.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 使用 OpenAI API 和知识源的典型应用架构示例](img/B21007_07_1.jpg)'
- en: Figure 7.1 – Demonstration of a typical application architecture using the OpenAI
    API with the Knowledge Source
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 使用 OpenAI API 和知识源的典型应用架构示例
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Creating a knowledge-retrieval assistant application
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个知识检索助手应用程序
- en: Creating a knowledge-retrieval assistant through the Assistants API
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Assistants API创建知识检索助手
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the recipes in this chapter require you to have access to the OpenAI API
    (via a generated API key) and have an API client installed. You can refer to the
    [*Chapter 1*](B21007_01.xhtml#_idTextAnchor021) recipe *Making OpenAI API requests
    with Postman* for more information on how to obtain your API key. This will also
    require knowledge of Python and the Python OpenAI library, which we covered in
    the first recipe within [*Chapter 4*](B21007_04.xhtml#_idTextAnchor074).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有食谱都要求你可以访问OpenAI API（通过生成的API密钥）并安装了API客户端。你可以参考[*第1章*](B21007_01.xhtml#_idTextAnchor021)中的食谱*使用Postman发起OpenAI
    API请求*，了解如何获取API密钥。这还需要了解Python和Python OpenAI库，我们在[*第4章*](B21007_04.xhtml#_idTextAnchor074)的第一个食谱中已涉及这些内容。
- en: We will also use the **Google Cloud Platform** (**GCP**) to host our public
    endpoint. GCP is a suite of cloud computing services offered by Google. It provides
    a range of hosting and computing services for databases, data storage, data analytics,
    machine learning, and more, all hosted on Google’s infrastructure. You can refer
    to the [*Chapter 5*](B21007_05.xhtml#_idTextAnchor090) recipe *Creating a public
    endpoint server that calls the OpenAI API* for more information.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用**Google Cloud Platform**（**GCP**）来托管我们的公共端点。GCP是由Google提供的一套云计算服务，提供包括数据库、数据存储、数据分析、机器学习等一系列托管和计算服务，全部托管在Google的基础设施上。你可以参考[*第5章*](B21007_05.xhtml#_idTextAnchor090)中的食谱*创建调用OpenAI
    API的公共端点服务器*，了解更多信息。
- en: Finally, you need to be familiar with *Bubble*, which is a visual programming
    platform that allows users to create web applications without needing to write
    code. You can refer to the [*Chapter 5*](B21007_05.xhtml#_idTextAnchor090) recipe
    *Calling the user-created* *endpoint* *from no-code applications* for more information
    on how to set up Bubble.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要熟悉*Bubble*，这是一种可视化编程平台，允许用户无需编写代码即可创建Web应用程序。你可以参考[*第5章*](B21007_05.xhtml#_idTextAnchor090)中的食谱*从无代码应用程序调用用户创建的端点*，了解如何设置Bubble。
- en: It is also recommended that you complete the recipes in [*Chapter 6*](B21007_06.xhtml#_idTextAnchor106),
    as this chapter’s recipes will cover concepts that we learned in that chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 同时建议你完成[*第六章*](B21007_06.xhtml#_idTextAnchor106)中的食谱，因为这一章的食谱将涵盖我们在该章学到的概念。
- en: Creating a knowledge-retrieval assistant application
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建知识检索助手应用程序
- en: In this first recipe, we will build an intelligent application that analyzes
    an uploaded PDF document and answers questions about it that the user poses. This
    can have several use cases, such as aiding in academic research by quickly summarizing
    key points, assisting legal professionals in extracting specific information from
    lengthy documents, or aiding businesses in understanding technical reports.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个食谱中，我们将构建一个智能应用程序，分析上传的PDF文档，并回答用户提出的问题。这可以有多种使用场景，例如通过快速总结要点帮助学术研究，协助法律专业人员从长篇文档中提取特定信息，或帮助企业理解技术报告。
- en: The application will leverage the OpenAI API’s NLP capabilities to interpret
    the content of the PDF and provide accurate, context-aware responses. This not
    only streamlines the process of information retrieval but also enhances user engagement
    by offering interactive, AI-driven insights.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序将利用OpenAI API的自然语言处理（NLP）能力来解析PDF的内容并提供准确、上下文感知的响应。这不仅简化了信息检索的过程，还通过提供互动式、AI驱动的洞察力增强了用户参与度。
- en: 'The example that we will follow is one where we upload the following instructional
    manual about a drone, and we want to ask questions such as `what is the maximum
    height I can fly this drone?` and `How do I recharge the drone battery?`. The
    PDF of the drone instructional manual can be found here: [https://bookpackt67.blob.core.windows.net/test/XDroneManual.pdf?sp=r&st=2024-01-12T00:52:16Z&se=2024-12-31T08:52:16Z&spr=https&sv=2022-11-02&sr=b&sig=IEXLlGXVXCilEg0ffqW8ItXc4LX2YkbRWuZIpSxfP8Y%3D](https://bookpackt67.blob.core.windows.net/test/XDroneManual.pdf?sp=r&st=2024-01-12T00:52:16Z&se=2024-12-31T08:52:16Z&spr=https&sv=2022-11-02&sr=b&sig=IEXLlGXVXCilEg0ffqW8ItXc4LX2YkbRWuZIpSxfP8Y%3D).
    We should download the file to our computer before starting the recipe. A screenshot
    of the file can be seen in *Figure 7**.2*.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将跟随的示例是上传以下关于无人机的操作手册，并希望提问如 `我可以将这架无人机飞到的最大高度是多少？` 和 `如何给无人机电池充电？`。无人机操作手册的
    PDF 文件可以在此处找到：[https://bookpackt67.blob.core.windows.net/test/XDroneManual.pdf?sp=r&st=2024-01-12T00:52:16Z&se=2024-12-31T08:52:16Z&spr=https&sv=2022-11-02&sr=b&sig=IEXLlGXVXCilEg0ffqW8ItXc4LX2YkbRWuZIpSxfP8Y%3D](https://bookpackt67.blob.core.windows.net/test/XDroneManual.pdf?sp=r&st=2024-01-12T00:52:16Z&se=2024-12-31T08:52:16Z&spr=https&sv=2022-11-02&sr=b&sig=IEXLlGXVXCilEg0ffqW8ItXc4LX2YkbRWuZIpSxfP8Y%3D)。在开始本指南之前，我们应该先将文件下载到电脑。文件的截图见
    *图 7.2*。
- en: '![Figure 7.2 – PDF of the drone manual](img/B21007_07_2.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 无人机手册的 PDF 文件](img/B21007_07_2.jpg)'
- en: Figure 7.2 – PDF of the drone manual
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 无人机手册的 PDF 文件
- en: Getting ready
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure you have an OpenAI Platform account with available usage credits. If
    you don’t, please follow the *Setting up your OpenAI Playground environment* recipe
    in [*Chapter 1*](B21007_01.xhtml#_idTextAnchor021).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您拥有一个可用的 OpenAI 平台账户并且有足够的使用积分。如果没有，请按照 [*第 1 章*](B21007_01.xhtml#_idTextAnchor021)
    中的 *设置 OpenAI Playground 环境* 食谱操作。
- en: Furthermore, ensure you have created a GCP account. You may need to provide
    a billing profile as well to create any GCP resources. Note that GCP does have
    a free tier, and in this recipe, we will not go above the free tier (so, essentially,
    you should not be billed for anything).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请确保您已创建了 GCP 账户。您可能还需要提供账单资料以创建任何 GCP 资源。请注意，GCP 确实有免费套餐，并且在本指南中，我们将不会超出免费套餐（也就是说，您不应为任何服务付费）。
- en: Finally, ensure that you have created a Bubble account, which you can do for
    free at [http://bubble.io](http://bubble.io).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，确保您已创建一个 Bubble 账户，您可以在 [http://bubble.io](http://bubble.io) 上免费创建。
- en: Both the recipes in this chapter will have this same requirement.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的两个食谱都将有相同的要求。
- en: How to do it…
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Google Cloud Functions
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Google Cloud Functions
- en: In a new browser tab, navigate to [https://cloud.google.com](https://cloud.google.com)
    and log in with your Google credentials.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的浏览器标签页中，访问 [https://cloud.google.com](https://cloud.google.com)，并使用您的 Google
    凭证登录。
- en: Select **Console** in the top right.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择右上角的 **控制台**。
- en: Create a new Google cloud function. In the search bar, type in **function**,
    select **Cloud Functions**, and then select **Create Function**.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Google 云函数。在搜索栏中输入 **function**，选择 **Cloud Functions**，然后选择 **创建函数**。
- en: Name the function a descriptive name. Since this function will return answers
    based on a file, we are going to aptly name it **get_answer_from_file**.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给函数起一个具有描述性的名称。由于该函数将根据文件返回答案，我们将其命名为 **get_answer_from_file**。
- en: In the **Authentication** menu, ensure that you select **Allow unauthenticated
    invocations** as the authentication method. This will enable the frontend application
    to make calls to the backend layer.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **身份验证** 菜单中，确保选择 **允许未经身份验证的调用** 作为身份验证方式。这样可以使前端应用能够调用后端层。
- en: Select the **Runtime, build, connections and security settings** drop-down menu
    to expand the options. Change **Timeout** from 60 seconds to 300 seconds. This
    will make sure that the timeout for the Google cloud function is not 1 minute
    but 5 minutes instead. This is important in multi-modal applications, as several
    API requests will be made.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **运行时、构建、连接和安全设置** 下拉菜单以展开选项。将 **超时** 从 60 秒改为 300 秒。这将确保 Google 云函数的超时不是
    1 分钟，而是 5 分钟。这在多模态应用中非常重要，因为会发出多个 API 请求。
- en: "![Figure 7.3 – Google \uFEFFcloud \uFEFFfunction configuration settings](img/B21007_07_3.jpg)"
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – Google 云函数配置设置](img/B21007_07_3.jpg)'
- en: Figure 7.3 – Google cloud function configuration settings
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – Google 云函数配置设置
- en: Select **Next** to move on to function development. In the **Runtime** drop-down
    menu, select **Python 3.12**. For **entry point**, select or type in **get_answer_from_pdf**.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **下一步** 以进入函数开发阶段。在 **运行时** 下拉菜单中选择 **Python 3.12**。对于 **入口点**，选择或输入 **get_answer_from_pdf**。
- en: 'Go to **Requirements.txt** in the left-hand menu and type the following Python
    packages in as these libraries will be used in the backend function:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧菜单中转到**Requirements.txt**，并输入以下 Python 库，因为这些库将在后台函数中使用：
- en: '[PRE0]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For the actual *code block*, type in the following. This function takes in
    two inputs (**pdf_url** and **question**) and returns the relevant **answer**
    based on information found in the PDF:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于实际的*代码块*，输入以下内容。此函数接受两个输入（**pdf_url** 和 **question**），并根据在 PDF 中找到的信息返回相应的**答案**：
- en: '[PRE1]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Select **Deploy**. You might need to wait five minutes for the deployment to
    fully complete. When you see the green checkmark on the cloud function screen,
    your function has been successfully deployed.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**部署**。你可能需要等待五分钟，直到部署完全完成。当你在云函数页面看到绿色勾选标记时，说明你的函数已成功部署。
- en: Similar to the previous chapter, we will now use Postman to test the cloud function
    that we have just deployed. Open Postman. Select **New** in the top left and select
    **HTTP**.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与上一章类似，我们现在将使用 Postman 测试刚刚部署的云函数。打开 Postman。点击左上角的**新建**，然后选择**HTTP**。
- en: On the Postman request, select **Headers** and type in a new header, with **Key**
    equal to **Content-Type** and **Value** equal to **application/json**.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Postman 请求中，选择**Headers**，并输入一个新的头部，**Key**为**Content-Type**，**Value**为**application/json**。
- en: Change the request from **Get** to **Post** in the left-hand drop-down menu.
    Copy the endpoint URL from the **Cloud Function** page and paste it into Postman.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧下拉菜单中，将请求从**GET**改为**POST**。复制**云函数**页面中的端点 URL，并将其粘贴到 Postman 中。
- en: 'Select **Body**, then select **Raw**, and copy and paste the following JSON
    request:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Body**，然后选择**Raw**，并复制粘贴以下 JSON 请求：
- en: '[PRE2]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Select **Send** to make the call to your cloud function. If all goes well, you
    should see a similar response to the one shown in *Figure 7**.4*, which contains
    several objects embedded in the JSON response.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**发送**，以调用你的云函数。如果一切顺利，你应该看到类似于*图 7.4*所示的响应，其中包含嵌入在 JSON 响应中的多个对象。
- en: '![Figure 7.4 – Postman output](img/B21007_07_4.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – Postman 输出](img/B21007_07_4.jpg)'
- en: Figure 7.4 – Postman output
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – Postman 输出
- en: Bubble
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bubble
- en: Next, navigate to [http://bubble.io](http://bubble.io) and log in. Select **Create
    an app** and give your app a relevant name. Select **Get started** and then select
    **Start with basic features**. You can also select the **Skip the application
    assistant** prompt if you encounter it.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，访问 [http://bubble.io](http://bubble.io) 并登录。选择**创建一个应用**并为你的应用命名。选择**开始使用**，然后选择**从基本功能开始**。如果出现**跳过应用助手**的提示，你也可以选择跳过。
- en: On the Canvas page, we are going to add a few elements that are required for
    our application. Select **Input** from the left-hand menu and then draw a rectangle
    at the top of the page. Double-click the element and, in the property menu, replace
    the **Placeholder** with **Question**.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在画布页面，我们将添加一些应用程序所需的元素。从左侧菜单中选择**输入**，然后在页面顶部绘制一个矩形。双击该元素，在属性菜单中，将**占位符**替换为**问题**。
- en: '![](img/B21007_07_5.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21007_07_5.jpg)'
- en: Figure 7.5 – Bubble input configuration
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – Bubble 输入配置
- en: Add a **File Uploader** element by selecting it from the left-hand menu and
    then drawing a rectangle directly below the previous element.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧菜单中选择**文件上传器**元素，并将其绘制在前一个元素的下方。
- en: Next, create a text element by selecting it from the left-hand menu and drawing
    a rectangle (make it multiple lines) directly below the previous elements. Double-click
    the text element to get the property menu. Then, click **Insert dynamic data**
    on the actual text field, then select **Text A** and **create a new custom state**.
    You will be prompted for a name and type. For the name, type in **answer**. For
    the type, ensure **text** is selected. This will create a unique custom state
    for the text box, which is required to show the values in the application.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从左侧菜单中选择文本元素并绘制一个矩形（可以设为多行），将其放置在前一个元素下方。双击文本元素以进入属性菜单。然后，点击实际文本框中的**插入动态数据**，选择**文本
    A**并**创建一个新的自定义状态**。系统会提示你输入名称和类型。在名称处输入**answer**，在类型处确保选择**文本**。这将为文本框创建一个唯一的自定义状态，用于在应用程序中显示值。
- en: '![Figure 7.6 – Inserting dynamic data](img/B21007_07_6.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 插入动态数据](img/B21007_07_6.jpg)'
- en: Figure 7.6 – Inserting dynamic data
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 插入动态数据
- en: '![Figure 7.7 – Creating a custom state](img/B21007_07_7.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 创建自定义状态](img/B21007_07_7.jpg)'
- en: Figure 7.7 – Creating a custom state
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 创建自定义状态
- en: The next thing we need to do is load the cloud function that we created into
    Bubble. Select **Plugins** from the left-hand menu and then select **Add Plugins**.
    Select the **API Connector**, then select **Install**, and then **Done**.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将我们创建的云函数加载到Bubble中。选择左侧菜单中的**插件**，然后选择**添加插件**。选择**API连接器**，然后选择**安装**，接着点击**完成**。
- en: '![Figure 7.8 – Bubble.io UI configuration](img/B21007_07_8.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – Bubble.io UI 配置](img/B21007_07_8.jpg)'
- en: Figure 7.8 – Bubble.io UI configuration
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – Bubble.io UI 配置
- en: 'Select **API Connector** from the list of plugins. Select **Add Another API**.
    For the **API name**, type in **answer_from_file**. Scroll down to **Create a
    New API** and click **Expand**. Leave the name of this API as **API call**. For
    the API, configure the following settings:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从插件列表中选择**API连接器**。选择**添加另一个API**。对于**API名称**，输入**answer_from_file**。向下滚动到**创建新API**并点击**展开**。将此API的名称保留为**API调用**。对于API，配置以下设置：
- en: From the **Use as** dropdown menu, select **Action**.
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**用作**下拉菜单中，选择**动作**。
- en: Change the request from **GET** to **POST**.
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将请求方式从**GET**更改为**POST**。
- en: Create a new header by clicking on **New Header**. Select **Add Header**. For
    **key**, type in **Content-Type**, and for **value**, type in **application/json**.
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击**新建标题**以创建新标题。选择**添加标题**。对于**key**，输入**Content-Type**，对于**value**，输入**application/json**。
- en: Add a parameter by clicking **Parameter**. For **key**, type in **pdf_url**.
    For **value**, type in **https://bookpackt67.blob.core.windows.net/test/XDroneManual.pdf?sp=r&st=2024-01-12T00:52:16Z&se=2024-12-31T08:52:16Z&spr=https&sv=2022-11-02&sr=b&sig=IEXLlGXVXCilEg0ffqW8ItXc4LX2YkbRWuZIpSxfP8Y%3D**.
    Do not include any quotes. Ensure that the **private** box is *unchecked*.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过点击**参数**添加一个参数。对于**key**，输入**pdf_url**。对于**value**，输入**https://bookpackt67.blob.core.windows.net/test/XDroneManual.pdf?sp=r&st=2024-01-12T00:52:16Z&se=2024-12-31T08:52:16Z&spr=https&sv=2022-11-02&sr=b&sig=IEXLlGXVXCilEg0ffqW8ItXc4LX2YkbRWuZIpSxfP8Y%3D**。不要包含引号。确保**私密**框未被选中。
- en: Click on **Parameter** again. For **key**, type in **question**. For **value**,
    type in **for safety, what's the highest you should fly the drone?**. Do not include
    any quotes. Ensure that the **private** box is *unchecked*.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次点击**参数**。对于**key**，输入**question**。对于**value**，输入**为了安全，飞行无人机的最高高度应该是多少？**。不要包含引号。确保**私密**框未被选中。
- en: Select **Initialize Call** to test the API call. If you see the screen shown
    in *Figure 7**.9*, then the call has been successful. Ensure that for each choice,
    the **text** type has been selected, and click **Save**.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**初始化调用**来测试API调用。如果您看到显示在*图 7.9*中的屏幕，那么调用已成功。确保为每个选项选择了**文本**类型，并点击**保存**。
- en: "![Figure 7.9 – A successful UI \uFEFFconfiguration](img/B21007_07_9.jpg)"
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9 – 成功的 UI 配置](img/B21007_07_9.jpg)'
- en: Figure 7.9 – A successful UI configuration
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 – 成功的 UI 配置
- en: Select **Design** from the left-hand menu. Create a Button element by selecting
    **Button** and then drawing a box below the **File** **Uploader** element.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧菜单中选择**设计**。通过选择**按钮**并在**文件上传**元素下方绘制一个框来创建按钮元素。
- en: Double-click the Button element that you have created. In the property menu
    that appears, select **Add Workflow**.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击您创建的按钮元素。在弹出的属性菜单中选择**添加工作流**。
- en: '![Figure 7.10 – Visual layout of page and adding a workflow](img/B21007_07_10.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.10 – 页面视觉布局和添加工作流](img/B21007_07_10.jpg)'
- en: Figure 7.10 – Visual layout of page and adding a workflow
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 – 页面视觉布局和添加工作流
- en: 'Select **Click here to add an action**. Go to **Plugins**, find the API you
    have just created (**answer_from_file - API call**), and select it. Do the following
    in the property menu that appears:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**点击此处添加动作**。进入**插件**，找到您刚刚创建的API（**answer_from_file - API调用**），并选择它。然后在弹出的属性菜单中执行以下操作：
- en: Delete the content of **(param) pdf_url**. Type in **http:** and then select
    **Insert dynamic data**. Scroll down and select **File Uploader A**, and then
    select **value**.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除**(param) pdf_url**的内容。输入**http:**，然后选择**插入动态数据**。向下滚动并选择**文件上传器A**，然后选择**value**。
- en: Delete the content of **(param) question**. Select **Insert dynamic data**.
    Scroll down and select **Input Question**, and then select **value**.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除**(param) question**的内容。选择**插入动态数据**。向下滚动并选择**输入问题**，然后选择**value**。
- en: Next, select **Click here to add an action** again, scroll down to **Element
    Actions**, and then select **Set State**. For the **Element** drop-down menu,
    select **Text A**. For the **Custom state** drop-down menu, select **answer**.
    For **Value**, select **Results of step 1** and then select **answer**. This will
    make the value of **Text A** equal to the answer from the API call to the cloud
    function that you have created.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，再次选择**点击此处添加操作**，向下滚动至**元素操作**，然后选择**设置状态**。在**元素**下拉菜单中，选择**Text A**。在**自定义状态**下拉菜单中，选择**answer**。在**值**字段中，选择**步骤1的结果**，然后选择**answer**。这将使**Text
    A**的值等于你创建的云函数API调用返回的答案。
- en: '![Figure 7.11 – Setting the state in an element](img/B21007_07_11.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图7.11 – 在元素中设置状态](img/B21007_07_11.jpg)'
- en: Figure 7.11 – Setting the state in an element
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 – 在元素中设置状态
- en: '![Figure 7.12 – Setting the value to a custom state](img/B21007_07_12.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图7.12 – 设置值为自定义状态](img/B21007_07_12.jpg)'
- en: Figure 7.12 – Setting the value to a custom state
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 – 设置值为自定义状态
- en: We have completed everything we need for our Bubble application. Let’s test
    if the application works. Select **Preview** on the right and a new page will
    appear, with your application. In the **Question** text box, type in **for safety,
    what's the highest you should fly the drone?**. Select the **File Uploader** input
    and upload the PDF file of the drone manual that you downloaded earlier.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经完成了Bubble应用所需的一切。让我们来测试一下应用是否正常工作。在右侧选择**预览**，然后会出现一个新页面，显示你的应用。在**问题**文本框中，输入**为了安全，应该将无人机飞到什么高度？**。选择**文件上传**输入框，上传你之前下载的无人机手册PDF文件。
- en: Click the **Submit** button. If all goes well, you should get a screen like
    the one shown in *Figure 7**.13*, which contains the answer to the user’s question
    directly from content in the PDF file.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**提交**按钮。如果一切顺利，你应该会看到一个像*图7.13*中的屏幕，其中包含了直接从PDF文件内容中提取的用户问题的答案。
- en: '![Figure 7.13 – Output from the Bubble application](img/B21007_07_13.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图7.13 – Bubble应用的输出](img/B21007_07_13.jpg)'
- en: Figure 7.13 – Output from the Bubble application
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 – Bubble应用的输出
- en: After you’ve done this, try typing other questions that are relevant to the
    PDF file, such as `How do I charge the battery?` or `How do I do a` `360 flip?`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，尝试输入其他与PDF文件相关的问题，比如`如何给电池充电？`或者`如何做一个` `360翻转？`。
- en: How it works…
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we created a knowledge-based assistant that can read any PDF
    file and provide answers to questions based on that file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们创建了一个基于知识的助手，它可以读取任何PDF文件并根据该文件提供问题的答案。
- en: 'This is very similar to the recipes in the previous chapter but with one key
    difference: the knowledge that is used to answer questions does not come from
    ChatGPT but instead from a PDF file that was provided.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这与上一章中的配方非常相似，但有一个关键区别：用来回答问题的知识不来自ChatGPT，而是来自提供的PDF文件。
- en: Code walkthrough
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码讲解
- en: The code that we used in the Google cloud function contains instructions to
    read the PDF URL, extract the content, and pass it to the OpenAI API, which is
    what makes this different than previous recipes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Google云函数中使用的代码包含了读取PDF URL、提取内容并将其传递给OpenAI API的指令，这也是它与之前配方的不同之处。
- en: 'To do this, we had to import two additional Python packages:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要导入两个额外的Python包：
- en: '**Requests**: This package enables us to send HTTP requests easily. This is
    essential for fetching the PDF file from the provided URL. By using the **requests.get()**
    function, we can retrieve the content of any online document, in this case, a
    PDF file.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Requests**：这个包使我们能够轻松发送HTTP请求。这对于从提供的URL获取PDF文件至关重要。通过使用**requests.get()**函数，我们可以检索任何在线文档的内容，在本例中是一个PDF文件。'
- en: '**PyPDF2**: This package enables us to interact with and manipulate PDF files
    directly within Python. Once the PDF is fetched, **PyPDF2** provides the tools
    to read the PDF file, extract text, and even handle different aspects of PDF manipulation,
    if necessary. In our application, it primarily serves to convert the PDF content
    into a text format that can be processed by the OpenAI API.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PyPDF2**：这个包使我们能够在Python中直接与PDF文件交互并进行操作。一旦PDF被获取，**PyPDF2**提供了读取PDF文件、提取文本，甚至在必要时处理PDF操作的工具。在我们的应用中，它主要用于将PDF内容转换为可以由OpenAI
    API处理的文本格式。'
- en: 'We first make a request to the URL of the PDF that is provided to us by the
    user from the `pdf_url` object. We then convert that into bytes:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先向用户提供的PDF URL（来自`pdf_url`对象）发起请求。然后我们将其转换为字节：
- en: '[PRE3]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We then use the `PdfReader` class of `PyPDF2` to read the bytes and read the
    contents of the PDF file page by page. We save the entire string content of the
    PDF file to the `text` variable:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着使用 `PyPDF2` 的 `PdfReader` 类来读取字节，并逐页读取 PDF 文件的内容。我们将 PDF 文件的整个字符串内容保存到 `text`
    变量中：
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, when we call the OpenAI Chat API, our instructions are for the LLM
    to read through the text and the user’s question, and then to answer the user’s
    question based on the text provided. We then provided the text of the entire PDF
    file and the user’s question:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们调用 OpenAI Chat API 时，我们的指令是让 LLM 阅读文本和用户的问题，然后基于提供的文本回答用户的问题。我们然后提供了整个
    PDF 文件的文本和用户的问题：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is the same as if you were to go to ChatGPT, copy and paste the content
    of the entire PDF file, and then ask the user’s question. However, in this way,
    you’ve built an application around it that makes it far easier for the user –
    all they need to do is upload the PDF and put their question in a text box.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像你去 ChatGPT，复制并粘贴整个 PDF 文件的内容，然后问用户的问题。然而，通过这种方式，你已经围绕它构建了一个应用程序，使得用户操作更加简便——他们只需上传
    PDF 并在文本框中输入问题。
- en: Limitations of this approach
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这种方法的局限性
- en: 'We have already discussed the benefits: namely that since ChatGPT’s internal
    knowledge may be out of date and it’s impossible to track the source of any information
    provided by ChatGPT, having an architecture that forces the Open API to use only
    the knowledge provided by the user alleviates this issue.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过这种方法的好处：即因为 ChatGPT 的内部知识可能过时，且无法追踪 ChatGPT 提供的任何信息的来源，建立一个强制 Open AI
    仅使用用户提供的知识的架构可以缓解这个问题。
- en: 'There are, however, also a few limitations to this approach. It’s key to have
    an understanding of them so you can make the most out of the approach. They are
    as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法也有一些局限性。了解这些局限性是关键，这样您才能充分利用这种方法。具体如下：
- en: '*Dependency on PDF quality*: The accuracy of the assistant is heavily dependent
    on the quality and clarity of the PDF content. Poorly structured documents or
    complex formats can lead to incomplete or incorrect responses. Additionally, this
    method will not work for information embedded within images, as the Open AI API
    cannot read images.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*依赖于 PDF 的质量*：助手的准确性在很大程度上依赖于 PDF 内容的质量和清晰度。结构不佳的文档或复杂的格式可能导致不完整或错误的回答。此外，这种方法无法处理嵌入在图像中的信息，因为
    Open AI API 无法读取图像。'
- en: '*Resource intensity for large documents*: The assistant needs to process and
    understand the entire document for each query, which can be resource-intensive
    and result in slow response times, especially for large documents.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*大型文档的资源消耗*：助手需要处理并理解整个文档以回答每个查询，这可能会消耗大量资源，尤其是在处理大型文档时，可能导致响应时间缓慢。'
- en: '*Limited knowledge scope*: The assistant’s knowledge is limited to the specific
    subject matter of the PDF, lacking the comprehensive coverage found in ChatGPT’s
    built-in database.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*知识范围有限*：助手的知识仅限于 PDF 的特定主题，缺乏 ChatGPT 内置数据库中所涵盖的全面内容。'
- en: '*Maintenance of the knowledge base*: Keeping the information current requires
    constant updates to the PDF files, which can be time-consuming, especially with
    frequently changing information.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*知识库的维护*：保持信息的时效性需要不断更新 PDF 文件，这可能非常耗时，特别是对于信息频繁变化的情况。'
- en: '*Context window limitation*: The content in the PDF must be within the context
    window of the ChatGPT model. This approach is not feasible for very long PDFs
    as the model cannot process content that exceeds its context window (which is
    the maximum number of words that can be processed by the API), limiting the amount
    of information that can be used for responses.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*上下文窗口的限制*：PDF 中的内容必须在 ChatGPT 模型的上下文窗口内。对于非常长的 PDF 文件，这种方法不可行，因为模型无法处理超出其上下文窗口的内容（即
    API 可处理的最大单词数），从而限制了可用于回答的问题的信息量。'
- en: As a result, users can adopt another approach that is contained within a special
    subset of the OpenAI API, called the Assistants API, which we will discuss in
    the subsequent recipe.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，用户可以采用另一种方法，即 OpenAI API 的特殊子集——Assistants API，我们将在后续的教程中讨论。
- en: Creating a knowledge-retrieval assistant through the Assistants API
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 Assistants API 创建一个知识检索助手
- en: OpenAI has recently released the Assistants API, wherein you can create knowledge-based
    assistants with minimal coding and complexity. A big advantage is that you can
    incorporate tools into your assistants that OpenAI has built, such as *Code Interpreter*
    and *Knowledge Retrieval*. These augmentations essentially give your assistant
    application superpowers. For this recipe, we will focus on the Knowledge Retrieval
    tool.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAI最近发布了助手API，通过该API，你可以创建基于知识的助手，几乎不需要编码和复杂的设置。一个很大的优势是，你可以将OpenAI已经构建的工具集成到你的助手中，例如*代码解释器*和*知识检索*。这些增强功能实质上赋予了你的助手应用超能力。在这个食谱中，我们将重点介绍知识检索工具。
- en: '**Knowledge** **R****etrieval** enhances your assistants by incorporating external
    knowledge (such as the drone manual PDF file from the previous recipe). OpenAI
    automatically and efficiently segments any uploaded documents while creating indices
    of embeddings. These embeddings are stored in OpenAI’s database.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**知识** **检索**通过整合外部知识（例如前面食谱中的无人机手册PDF文件）来增强你的助手。OpenAI会自动高效地对上传的文档进行分段，同时创建嵌入索引。这些嵌入存储在OpenAI的数据库中。'
- en: Recall in [*Chapter 4*](B21007_04.xhtml#_idTextAnchor074) we discussed how embeddings
    can be used to compare text similarity and to search for segments of texts. With
    Knowledge Retrieval, OpenAI does this automatically for you. When a user asks
    the Assistants API a question that is augmented by Knowledge Retrieval, it employs
    a vector search to extract pertinent information from the uploaded documents,
    responding effectively to user inquiries.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下在[*第4章*](B21007_04.xhtml#_idTextAnchor074)中，我们讨论了如何使用嵌入来比较文本相似性并搜索文本片段。通过知识检索，OpenAI会自动为你执行这些操作。当用户向助手API提问时，如果问题被知识检索增强，API会使用向量搜索从上传的文档中提取相关信息，从而有效地回答用户的查询。
- en: In this way, the knowledge source can be infinite in length, as the knowledge
    source itself is not passed to the Chat API, but instead is vectorized and only
    small relevant segments of text are passed to the Chat API based on a user’s question.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，知识来源的长度可以是无限的，因为知识源本身不会传递到Chat API，而是经过向量化，仅根据用户的提问将相关的文本片段传递给Chat API。
- en: In other words, using the Assistants API with Knowledge Retrieval means that
    you can upload large PDFs and as many PDFs as you want, and there is effectively
    no context window limitation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，使用带有知识检索的助手API意味着你可以上传大量PDF文件，数量没有限制，而且实际上没有上下文窗口的限制。
- en: This is useful for creating highly specialized assistants that need to draw
    on vast amounts of specific information. For instance, if you’re building an assistant
    for legal professionals, you can upload numerous legal texts, case studies, and
    statutes. The Assistants API, powered by Knowledge Retrieval, can then provide
    precise legal references and interpretations in response to complex queries. Similarly,
    for medical professionals, uploading extensive medical literature and research
    papers enables the Assistants API to offer detailed medical insights. This makes
    the Assistants API not just a conversational tool, but a robust, information-rich
    resource.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于创建高度专业化的助手非常有用，这些助手需要调用大量特定信息。例如，如果你在为法律专业人员构建助手，你可以上传大量的法律文本、案例研究和法规。由知识检索驱动的助手API随后可以在复杂的查询中提供准确的法律引用和解释。同样，针对医学专业人员，上传大量的医学文献和研究论文可以使助手API提供详细的医学见解。这使得助手API不仅仅是一个对话工具，而是一个强大的、信息丰富的资源。
- en: In this recipe, we will use the Assistants API to create a *Legal Constitution
    Helper* assistant that gets its knowledge directly from the US Constitution document.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用助手API创建一个*法律宪法助手*，该助手直接从美国宪法文档中获取知识。
- en: How to do it…
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: Playground
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Playground
- en: Navigate to [https://openai.com](https://openai.com). Select **Playground**
    from the left-hand menu. In the top menu, ensure that **Assistants** is selected
    from the drop-down menu. Select the dropdown near the top and select **Create
    assistant** to create a new assistant.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[https://openai.com](https://openai.com)，在左侧菜单中选择**Playground**。在顶部菜单中，确保从下拉菜单中选择了**Assistants**。在顶部附近选择下拉菜单，然后选择**创建助手**以创建一个新的助手。
- en: 'Enter the following configuration details for **Assistant**:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下配置信息以设置**助手**：
- en: '**Name**: **US** **Constitution Expert.**'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：**美国** **宪法专家**。'
- en: '**Instructions**: **You are a helpful assistant that helps answer legal constitution
    related questions from reading the US constitution. Reference specific parts of
    the document where you found the information required to answer** **the question.**'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**说明**：**您是一个帮助回答与美国宪法相关的法律问题的助手。请引用文档中找到的特定部分，以回答问题。**'
- en: '**Model**: **gpt-4-1106-preview**.'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：**gpt-4-1106-preview**。'
- en: Toggle the **Retrieval** tool *on.*
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 **Retrieval** 工具切换到 *开启* 状态。
- en: Under **Files**, select **Add**, and upload the following file ([https://bookpackt67.blob.core.windows.net/test/us_constitution.pdf?sp=r&st=2024-01-15T07:51:23Z&se=2024-12-31T15:51:23Z&spr=https&sv=2022-11-02&sr=b&sig=C9hFIvrI3FHogBumPTRaL1hrwS8C1B0t3hnlzS9t6Ew%3D](https://bookpackt67.blob.core.windows.net/test/us_constitution.pdf?sp=r&st=2024-01-15T07:51:23Z&se=2024-12-31T15:51:23Z&spr=https&sv=2022-11-02&sr=b&sig=C9hFIvrI3FHogBumPTRaL1hrwS8C1B0t3hnlzS9t6Ew%3D)).
    This file is the US Constitution.
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **文件** 部分，选择 **添加**，并上传以下文件 ([https://bookpackt67.blob.core.windows.net/test/us_constitution.pdf?sp=r&st=2024-01-15T07:51:23Z&se=2024-12-31T15:51:23Z&spr=https&sv=2022-11-02&sr=b&sig=C9hFIvrI3FHogBumPTRaL1hrwS8C1B0t3hnlzS9t6Ew%3D](https://bookpackt67.blob.core.windows.net/test/us_constitution.pdf?sp=r&st=2024-01-15T07:51:23Z&se=2024-12-31T15:51:23Z&spr=https&sv=2022-11-02&sr=b&sig=C9hFIvrI3FHogBumPTRaL1hrwS8C1B0t3hnlzS9t6Ew%3D))。该文件是美国宪法。
- en: Note
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You will need to download the file locally to then upload it to OpenAI.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将文件下载到本地，然后再上传到 OpenAI。
- en: '![Figure 7.14 – Assistant Playground configuration](img/B21007_07_14.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.14 – 助手 Playground 配置](img/B21007_07_14.jpg)'
- en: Figure 7.14 – Assistant Playground configuration
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 – 助手 Playground 配置
- en: 'Select the **Save** button at the bottom. After you do this, an assistant ID
    will appear directly below the **Name** field. It will be in the following format:
    *asst_XXXXXXXXXXXXXXXXXXXXX*. Note this down, as this is the unique ID for your
    assistant, and we will need to reference this in the backend function that we
    create.'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击底部的 **保存** 按钮。完成此操作后，助手 ID 将出现在 **名称** 字段正下方，格式为 *asst_XXXXXXXXXXXXXXXXXXXXX*。请记下此
    ID，因为这是您的助手唯一的标识符，我们在创建后端函数时需要引用它。
- en: Google Cloud Functions
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Google 云函数
- en: In a new tab, navigate to [https://cloud.google.com](https://cloud.google.com)
    and log in with your Google credentials.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新标签页中，访问 [https://cloud.google.com](https://cloud.google.com)，并使用您的 Google
    账户凭据登录。
- en: Select **Console** in the top right.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右上角选择 **控制台**。
- en: Create a new Google cloud function. In the search bar, type in **function**,
    select **Cloud Functions**, and then select **Create Function**.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Google 云函数。在搜索栏中输入 **function**，选择 **Cloud Functions**，然后选择 **创建函数**。
- en: Name the function a descriptive name. We are going to aptly name it **get_answer**.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给函数起个具有描述性的名字。我们将其命名为 **get_answer**。
- en: In the **Authentication** menu, ensure that you select **Allow unauthenticated
    invocations** as the authentication method. This will enable the frontend application
    to make calls to the backend layer.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **身份验证** 菜单中，确保选择 **允许未经身份验证的调用** 作为身份验证方法。这将使前端应用能够调用后端层。
- en: Select the **Runtime, build, connections and security settings** drop-down menu
    to expand the options. Change **timeout** from 60 seconds to 300 seconds. This
    will make sure that the timeout for the Google cloud function is not 1 minute
    but five minutes instead.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **运行时、构建、连接和安全设置** 下拉菜单，展开选项。将 **超时** 从 60 秒改为 300 秒。这将确保 Google 云函数的超时从
    1 分钟增加到 5 分钟。
- en: "![Figure 7.15 – Google \uFEFFcloud \uFEFFfunction configuration settings](img/B21007_07_15.jpg)"
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.15 – Google 云函数配置设置](img/B21007_07_15.jpg)'
- en: Figure 7.15 – Google cloud function configuration settings
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15 – Google 云函数配置设置
- en: Select **Next** to move on to function development. In the **Runtime** dropdown
    menu, select **Python 3.12**. For **entry point**, select or type in **get_answer**.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **下一步** 进入函数开发阶段。在 **运行时** 下拉菜单中，选择 **Python 3.12**。对于 **入口点**，选择或输入 **get_answer**。
- en: 'Go to **Requirements.txt** in the left-hand menu and type the following Python
    package in as this library will be used in the backend function:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧菜单中，找到 **Requirements.txt**，并输入以下 Python 包，因为该库将在后端函数中使用：
- en: '[PRE6]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For the actual code block, type in the following. This function takes in one
    input (**question**) and returns the relevant **answer** through the Assistants
    API. The code walkthrough will be discussed in the *Using the assistant* sub-section.
    Replace the **<assistant-id-here>** with the assistant ID you noted down in *step
    3* of the *Playground* section:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于实际的代码块，输入以下内容。此函数接受一个输入（**question**），并通过Assistants API返回相关的**answer**。代码演示将在*使用助手*子章节中讨论。将**<assistant-id-here>**替换为您在*Playground*部分*步骤
    3*中记下的助手ID：
- en: '[PRE7]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Select **Deploy**. You might need to wait five minutes for the deployment to
    fully complete. When you see the green checkmark on the cloud function screen,
    your function has been successfully deployed.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**部署**。您可能需要等待五分钟，直到部署完全完成。当您在云函数页面上看到绿色勾选标记时，说明您的函数已成功部署。
- en: Similar to the previous recipe, we will now use Postman to test the cloud function
    that we have just deployed. Open **Postman**. Select **New** on the top left,
    select **HTTP**.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前的步骤类似，我们现在将使用Postman来测试我们刚刚部署的云函数。打开**Postman**。在左上角选择**新建**，然后选择**HTTP**。
- en: In the Postman request, select **Headers** and type in a new header, with the
    **Key** equal to **Content-Type** and the **value** equal to **application/json**.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Postman请求中，选择**头部**并添加一个新头部，**Key**为**Content-Type**，**Value**为**application/json**。
- en: Change the request from **Get** to **Post** from the left-hand drop-down menu.
    Copy the endpoint URL from the **Cloud Function** page and paste it into Postman.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将请求从左侧下拉菜单中的**Get**更改为**Post**。复制**云函数**页面中的端点URL并将其粘贴到Postman中。
- en: 'Select **Body**, then select **Raw**, and copy and paste the following JSON
    request:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Body**，然后选择**Raw**，并复制粘贴以下JSON请求：
- en: '[PRE8]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Select **Send** to make the call to your cloud function. If all goes well,
    you should see an answer such as this:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**发送**以调用您的云函数。如果一切顺利，您应该会看到类似以下的答案：
- en: '[PRE9]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Bubble
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bubble
- en: Navigate to w and log in. Select **Create an app** and give your app a relevant
    name. Select **Get started** and then select **Start with basic features**. You
    can also click the **Skip the Application Assistant** prompt if you encounter
    it.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录并导航到w。选择**创建应用**，为您的应用命名。选择**开始使用**，然后选择**从基础功能开始**。如果遇到**跳过应用助手**的提示，您也可以点击该选项。
- en: On the Canvas page, we are going to add a few elements that are required for
    our application. Select **Input** from the left-hand menu and then draw a rectangle
    at the top of the page. Double-click the element and on the property menu, replace
    **Placeholder** with **question**.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在画布页面上，我们将添加一些应用程序所需的元素。从左侧菜单选择**输入**，然后在页面顶部绘制一个矩形。双击该元素，在属性菜单中将**占位符**替换为**question**。
- en: '![Figure 7.16 – Bubble input configuration](img/B21007_07_16.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.16 – Bubble 输入配置](img/B21007_07_16.jpg)'
- en: Figure 7.16 – Bubble input configuration
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16 – Bubble 输入配置
- en: Next, create a text element by selecting it from the left-hand menu and drawing
    a rectangle (make it multiple lines) directly below the previous elements. Double-click
    the text element to show the property. Then, click **insert dynamic data** on
    the actual text field, select **Text A**, and select **create a new custom state**.
    You will be prompted for a name and type. For the name, type in **answer**. For
    the type, ensure **text** is selected. This will create a unique custom state
    for the text box, which is required to show the values in the application.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过从左侧菜单选择文本元素并在前一个元素下方绘制一个矩形（可以设置为多行）来创建一个文本元素。双击文本元素以显示属性。然后，在实际的文本字段上点击**插入动态数据**，选择**Text
    A**，并选择**创建一个新的自定义状态**。系统将提示您输入名称和类型。对于名称，输入**answer**；对于类型，确保选择**文本**。这将为文本框创建一个独特的自定义状态，应用程序需要它来显示值。
- en: '![Figure 7.17 – Adding a text element to Bubble](img/B21007_07_17.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.17 – 向Bubble添加文本元素](img/B21007_07_17.jpg)'
- en: Figure 7.17 – Adding a text element to Bubble
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17 – 向Bubble添加文本元素
- en: The next thing we need to do is to load the cloud function that we created into
    Bubble. Select **Plugins** from the left-hand menu, and then select **Add Plugins**.
    Select the **API Connector**, and then select **Install**, and then **Done**.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要做的是将我们创建的云函数加载到Bubble中。从左侧菜单选择**插件**，然后选择**添加插件**。选择**API连接器**，然后选择**安装**，最后点击**完成**。
- en: '![Figure 7.18 – Bubble.io UI configuration](img/B21007_07_18.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.18 – Bubble.io UI 配置](img/B21007_07_18.jpg)'
- en: Figure 7.18 – Bubble.io UI configuration
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.18 – Bubble.io UI 配置
- en: 'Select **API Connector** from the list of plugins. Select **Add Another API**.
    For the **API name**, type in **get_answer**. Scroll down to **Create a New API**,
    and click **Expand**. Leave the name of this API to **API call**. For the API,
    configure the settings to the following:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从插件列表中选择**API连接器**。选择**添加另一个API**。在**API名称**中输入**get_answer**。向下滚动到**创建新API**，然后点击**展开**。将此API的名称保持为**API调用**。对于API，配置如下设置：
- en: From the **Use as** drop-down menu, select **Action**.
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从**用作**下拉菜单中，选择**动作**。
- en: Change request from **GET** to **POST**.
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将请求方法从**GET**更改为**POST**。
- en: Create a new header using **New Header**. Select **Add Header.** For **key**
    type in **Content-Type** for **value** type in **application/json**.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**新建头部**创建一个新的头部。选择**添加头部**。在**key**中输入**Content-Type**，在**value**中输入**application/json**。
- en: Click on **Parameter** to add a parameter. For **key**, type in **question**.
    For **value**, type in **How many senators are there?**. Do not include any quotes.
    Ensure that the **private** box is *unchecked*.
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击**参数**以添加一个参数。在**key**中输入**question**，在**value**中输入**How many senators are
    there?**。不要包含引号。确保**private**框未被选中。
- en: Select **Initialize Call** to test the API call. Ensure that for each **choice**,
    the **text** type has been selected, and click **Save**.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**初始化调用**以测试API调用。确保每个**选项**都已选择**文本**类型，然后点击**保存**。
- en: Select **Design** from left-hand menu. Create a Button element by selecting
    **Button** and then drawing a box to the right of the Input element.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧菜单中选择**设计**。通过选择**按钮**并在输入元素右侧绘制一个框来创建一个按钮元素。
- en: Double-click the **Button** element that you had created. In the property menu
    that appears, select **Add Workflow**.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击你创建的**按钮**元素。在弹出的属性菜单中，选择**添加工作流**。
- en: '![Figure 7.19 – Visual layout of page and adding a button and a workflow](img/B21007_07_19.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.19 – 页面视觉布局，添加按钮和工作流](img/B21007_07_19.jpg)'
- en: Figure 7.19 – Visual layout of page and adding a button and a workflow
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.19 – 页面视觉布局，添加按钮和工作流
- en: Select **Click here to add an action**. Go to **Plugins** and find the API you
    had just created (**get_answer - API call**) and select it. In the property menu
    that appears, delete the content of **(param) question**. Select **Insert dynamic
    data**. Scroll down, select **Input Question**, and then select **value**.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**点击此处添加动作**。进入**插件**，找到你刚刚创建的API（**get_answer - API调用**），并选择它。在弹出的属性菜单中，删除**(param)
    question**的内容。选择**插入动态数据**。向下滚动，选择**输入问题**，然后选择**值**。
- en: Next, select **Click here to add an action** again, scroll down to **Element
    Actions**, and then select **Set State**. For the **Element** drop-down menu,
    select **Text A**. For the **Custom state** drop-down menu, select **answer**.
    For **Value**, select **Results of step 1** and then select **answer**. This will
    make the value of **Text A** equal to the answer from the API call to the cloud
    function that you created.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，再次选择**点击此处添加动作**，向下滚动到**元素动作**，然后选择**设置状态**。在**元素**下拉菜单中，选择**Text A**。在**自定义状态**下拉菜单中，选择**answer**。在**值**中，选择**第1步的结果**，然后选择**answer**。这将使**Text
    A**的值等于你创建的云函数API调用的回答。
- en: We have completed everything we need for our Bubble application. Let’s test
    whether the application works. Select **Preview** on the right and a new page
    will appear, with your application. In the **Question** text box, type in **How
    many senators** **are there?**.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经完成了Bubble应用所需的所有内容。现在让我们测试应用程序是否正常工作。选择右侧的**预览**，一个新页面将会显示出你的应用程序。在**问题**文本框中，输入**How
    many senators are there?**。
- en: Select the **Submit** button. If all goes well, you should get an answer similar
    to the one you saw before in Postman, which answers the question with text from
    the *US Constitution document* that we uploaded earlier.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**提交**按钮。如果一切顺利，你应该会得到一个类似于你之前在Postman中看到的回答，回答中包含我们之前上传的*美国宪法文档*中的文本。
- en: '![Figure 7.20 – Bubble application example question](img/B21007_07_20.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.20 – Bubble 应用示例问题](img/B21007_07_20.jpg)'
- en: Figure 7.20 – Bubble application example question
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.20 – Bubble 应用示例问题
- en: The best part about this is that you can ask *any* related question and it will
    answer based on the US Constitution document that you uploaded, even if it was
    several hundred pages. The answers are also document-specific. For example, you
    can ask `How old must a person be to become a Senator?` and it’ll generate a response,
    as shown in *Figure 7**.21*.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最棒的是，你可以提问*任何*相关问题，它会基于你上传的美国宪法文档进行回答，即使文档有几百页。答案也是文档特定的。例如，你可以问`一个人要多大年纪才能成为参议员？`，它会生成一个回答，如*图7.21*所示。
- en: '![Figure 7.21 – Bubble application example question](img/B21007_07_21.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图7.21 – 气泡应用示例问题](img/B21007_07_21.jpg)'
- en: Figure 7.21 – Bubble application example question
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.21 – 气泡应用示例问题
- en: You can see in *Figure 7**.22* that the PDF uses different language, but the
    assistant has reworked it to match the format of the question that we asked.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*图7.22*中看到，PDF使用了不同的语言，但助手已经重新调整，使其与我们提出的问题格式匹配。
- en: '![Figure 7.22 – Document excerpt from where the answer is retrieved](img/B21007_07_22.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图7.22 – 从中检索答案的文档摘录](img/B21007_07_22.jpg)'
- en: Figure 7.22 – Document excerpt from where the answer is retrieved
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.22 – 从中检索答案的文档摘录
- en: How it works…
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we created an assistant that answers questions from a PDF that
    we loaded in.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建了一个能够回答我们加载的PDF中的问题的助手。
- en: The handbook is 85 pages long and contains over 35,000 words, and yet the API
    has no issues with finding the right information from the handbook. It is worth
    noting that this could have been done with a knowledge source that is a million
    words, or several large PDF files. That is the beauty of the Retrieval tool within
    the Assistants API – it can scale very easily.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 该手册长达85页，包含超过35,000个词汇，然而API在从手册中找到正确的信息时毫无问题。值得注意的是，即使是百万字的知识源或几个大型PDF文件，这也是可以完成的。这就是Assistants
    API中的检索工具的魅力——它可以轻松扩展。
- en: Creating the assistant
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建助手
- en: 'We created the assistant using the **OpenAI Playground** instead of through
    the OpenAI API. The OpenAI Playground provides a nice UI for creating our initial
    assistant instead of having to build using code. We defined the following parameters
    when building our assistant:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用**OpenAI Playground**创建了这个助手，而不是通过OpenAI API。OpenAI Playground提供了一个很好的UI，用于创建我们的初始助手，而无需通过编写代码来构建。我们在构建助手时定义了以下参数：
- en: '**Name**: The name of the assistant.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：助手的名称。'
- en: '**Instructions**: The system instructions that the assistant uses. This is
    very similar to the System Message that was used in the Chat API.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指令**：助手使用的系统指令。这与Chat API中使用的系统消息非常相似。'
- en: '**Model**: The Chat model to use when constructing answers. For assistants,
    GPT-4 is always recommended due to its ability to understand and answer nuanced
    information, a critical element in any knowledge-retrieval application.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：用于构建答案的聊天模型。对于助手来说，推荐使用GPT-4，因为它能够理解并回答细致的信息，这是任何知识检索应用中的关键元素。'
- en: '**Tools**: Superpowers that can be added to your assistant. We added the Retrieval
    tool, which again enables OpenAI to read through and search knowledge bases that
    the user uploads.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具**：可以为您的助手添加的超级功能。我们添加了检索工具，这使得OpenAI能够读取和搜索用户上传的知识库。'
- en: '**Files**: A set of files to upload that will be used as the knowledge source.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件**：一组文件，用作知识源并上传。'
- en: Using the assistant
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用助手
- en: 'In the **Google** cloud function, we first create a message thread with the
    user’s question:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Google**云函数中，我们首先创建一个包含用户问题的消息线程：
- en: '[PRE10]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We then run the assistant, providing the unique *assistant ID* that is generated
    when we create the assistant in the OpenAI playground, and the *thread ID* of
    the message thread that contains that user question.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们运行助手，提供在OpenAI Playground创建助手时生成的独特*助手ID*，以及包含用户问题的消息线程的*线程ID*。
- en: 'Note that after running the assistant, we force our function to sleep for 30
    seconds. We do this because we need to give the assistant time to fully process
    the message thread. Another way to do this would be to poll the assistant in a
    loop and progress only once the poll shows a successful completion. If you’d like
    to know more about this method, you can go to [https://pypi.org/project/polling2/](https://pypi.org/project/polling2/):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在运行助手后，我们强制让我们的函数睡眠30秒。我们这样做是因为需要给助手时间充分处理消息线程。另一种方法是使用轮询来检查助手，并在轮询显示成功完成后才继续。如果你想了解更多关于这个方法的信息，可以访问[https://pypi.org/project/polling2/](https://pypi.org/project/polling2/)：
- en: '[PRE11]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We then extract the assistant’s reply and return the message as the `answer`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们提取助理的回复并将消息返回为`answer`：
- en: '[PRE12]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Other use cases
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他应用场景
- en: 'The combination of the Assistants API and the Retrieval tool offers a wide
    array of potential applications across various industries and domains. Here are
    some examples:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 助理 API 和检索工具的结合为各行各业和领域提供了广泛的潜在应用。以下是一些例子：
- en: '*Customer support chatbots*: Develop chatbots that can provide detailed and
    specific answers to customer queries by accessing a company’s extensive knowledge
    base or product manuals'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*客户支持聊天机器人*：开发聊天机器人，通过访问公司的广泛知识库或产品手册，为客户查询提供详细和具体的答案。'
- en: '*Healthcare information systems*: Build systems that can retrieve and provide
    specific medical information, guidelines, or research papers to healthcare professionals,
    aiding in diagnosis or treatment decisions'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*医疗信息系统*：构建可以检索并提供特定医学信息、指南或研究论文的系统，为医疗专业人员提供诊断或治疗决策支持。'
- en: '*Legal research assistants*: Create tools that can sift through large volumes
    of legal documents, cases, and precedents to assist lawyers in preparing for cases
    or conducting legal research'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*法律研究助理*：创建能够从大量法律文档、案例和先例中筛选信息的工具，帮助律师为案件做准备或进行法律研究。'
- en: '*Educational platforms*: Develop educational aids that can pull information
    from textbooks, research papers, or educational materials to assist students in
    learning or researching various topics'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*教育平台*：开发教育辅助工具，可以从教科书、研究论文或教育材料中提取信息，帮助学生学习或研究各种主题。'
- en: '*Financial advisory tools*: Build applications that can access and analyze
    financial reports, market trends, and economic research to provide investment
    advice or market insights'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*财务顾问工具*：构建可以访问和分析财务报告、市场趋势和经济研究的应用程序，为投资建议或市场洞察提供支持。'
- en: '*Technical support and troubleshooting*: Implement systems that can access
    technical manuals and user guides to provide step-by-step troubleshooting assistance
    or technical guidance'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*技术支持与故障排除*：实施能够访问技术手册和用户指南的系统，为故障排除或技术指导提供逐步帮助。'
- en: '*Content curation and recommendation systems*: Create platforms that can analyze
    and retrieve articles, news, or multimedia content based on user preferences or
    queries'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内容策划和推荐系统*：创建可以根据用户偏好或查询分析和检索文章、新闻或多媒体内容的平台。'
- en: '*Corporate data retrieval systems*: Develop internal tools for businesses that
    can search through corporate documents, reports, and databases to provide employees
    with quick access to the information they need'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*企业数据检索系统*：开发企业内部工具，可以搜索公司文档、报告和数据库，快速为员工提供他们需要的信息。'
- en: '*Travel and hospitality assistants*: Build travel assistants that can access
    and provide information on travel destinations, accommodations, local customs,
    or points of interest'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*旅游和酒店助理*：构建可以访问并提供有关旅游目的地、住宿、当地习俗或景点的旅行助手。'
- en: '*E-commerce personal shopping assistants*: Create tools that can recommend
    products based on user queries by searching through product catalogs and reviews'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*电子商务个人购物助手*：创建可以根据用户查询从产品目录和评论中搜索并推荐产品的工具。'
- en: Each of these applications uses the capabilities of the Assistants API to understand
    and process natural language queries and the Retrieval tool’s ability to access
    and extract relevant information from a vast array of documents and data sources.
    This combination enables the creation of powerful, context-aware, and highly informative
    applications.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应用程序都利用了助理 API 的能力来理解和处理自然语言查询，以及检索工具从大量文档和数据源中访问并提取相关信息的能力。这种结合使得创建功能强大、具有上下文意识和高度信息化的应用成为可能。
- en: As we wrap up our journey through the expansive world of the OpenAI API, I hope
    you feel empowered to harness its capabilities to fuel your innovative projects.
    From taking those initial steps in setting up your API environment to exploring
    the intricate details of endpoints and key parameters, we’ve traversed a path
    that has prepared you to not just understand but to also apply the OpenAI API
    in creating applications that can transform the way we interact with technology.
    The exploration of additional features and the process of staging and hosting
    for application development have laid down the foundation for you to build intelligent
    solutions that can make a difference.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束穿越开放AI API广阔世界的旅程时，我希望你能感受到赋予你力量的感觉，以利用其能力推动你创新的项目。从搭建API环境的初步步骤到探索终端和关键参数的复杂细节，我们走过了一条道路，这条道路不仅让你理解OpenAI
    API，还让你能够应用它来创建能够改变我们与技术互动方式的应用程序。探索额外功能和为应用开发进行分阶段和托管的过程，为你奠定了构建智能解决方案的基础，这些解决方案能够产生影响。
- en: Whether it’s designing versatile intelligent applications or crafting knowledge-based
    assistants, the skills you’ve garnered are a testament to the potential that lies
    in your hands. Remember, the journey doesn’t end here. Each application you build
    is a step towards innovation, a bridge to solving complex problems, and a contribution
    to a future where technology and human creativity converge in harmony. Embrace
    the challenges and opportunities that come your way, for you are now equipped
    to make a significant impact in the world of technology.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是设计多功能智能应用程序还是打造基于知识的助手，你所获得的技能证明了你手中潜力的存在。请记住，旅程并不在此结束。你构建的每一个应用程序都是向创新迈出的一步，是解决复杂问题的桥梁，也是对未来技术与人类创造力和谐融合的贡献。接受那些到来的挑战和机遇，因为你现在已经具备了在技术世界中产生重大影响的能力。
