- en: Getting Started with CNTK
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用CNTK
- en: Deep learning is a machine learning technique that is getting a lot of attention
    from the public and researchers. In this chapter, we will explore what deep learning
    is and how large companies are using it to solve complex problems. We'll look
    at what makes this technique so exciting and what concepts drive deep learning.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 深度学习是一种机器学习技术，正受到公众和研究人员的广泛关注。在本章中，我们将探讨深度学习是什么，以及大公司如何使用它来解决复杂问题。我们将看看是什么使得这种技术如此激动人心，以及推动深度学习的概念是什么。
- en: We will then talk about **Microsoft Cognitive Toolkit** (**CNTK**), what it
    is, and how it fits into the bigger picture of deep learning. We'll also discuss
    what makes CNTK unique compared to other frameworks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将讨论**微软认知工具包**（**CNTK**），它是什么，以及它在深度学习的更大框架中的作用。我们还将讨论CNTK与其他框架相比有什么独特之处。
- en: In this chapter, we'll also show you how to get CNTK installed on your computer.
    We will explore installation on both Windows and Linux. If you have a compatible
    graphics card, you'll also want to check out the instructions on how to configure
    your graphics card for use with CNTK, as it will significantly speed up the calculations
    that are needed to train deep learning models.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将向你展示如何在你的计算机上安装CNTK。我们将探讨如何在Windows和Linux上进行安装。如果你有兼容的显卡，你还需要查看如何配置显卡以便与CNTK一起使用，因为这将显著加速训练深度学习模型所需的计算。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下主题：
- en: The relationship between AI, machine learning, and deep learning
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人工智能、机器学习和深度学习之间的关系
- en: How does deep learning work?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度学习是如何工作的？
- en: What is CNTK?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是CNTK？
- en: Installing CNTK
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装CNTK
- en: The relationship between AI, machine learning, and deep learning
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工智能、机器学习和深度学习之间的关系
- en: 'In order to understand what deep learning is, we have to explore what **Artificial
    Intelligence** (**AI**) is and how it relates to machine learning and deep learning.
    Conceptually, deep learning is a form of machine learning, whilst machine learning
    is a form of AI:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解深度学习是什么，我们必须探索**人工智能**（**AI**）是什么以及它与机器学习和深度学习的关系。从概念上讲，深度学习是机器学习的一种形式，而机器学习是人工智能的一种形式：
- en: '![](img/20a2db1c-d324-42e0-bd82-9409bf9ab6cf.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20a2db1c-d324-42e0-bd82-9409bf9ab6cf.png)'
- en: In computer science, Artificial intelligence, is a form of intelligence demonstrated
    by machines. AI is a term that was invented in the 1950s by scientists doing research
    in computer science. AI encompasses a large set of algorithms that shows behavior
    that is more intelligent than the standard software we build for our computers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，人工智能是一种由机器表现出的智能形式。AI是20世纪50年代计算机科学研究人员发明的术语。人工智能包括一大类算法，它们表现出的行为比我们为计算机构建的标准软件更智能。
- en: Some algorithms demonstrate intelligent behavior but aren't capable of improving
    themselves. One group of algorithms, called machine learning algorithms, can learn
    from sample data that you show them and generate models that you then use on similar
    data to make predictions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一些算法表现出智能行为，但不能自我改进。一类算法，叫做机器学习算法，可以从你展示的样本数据中学习，并生成模型，然后你可以在类似数据上使用这些模型进行预测。
- en: Within the group of machine learning algorithms there's the sub-category of
    deep learning algorithms. This group of algorithms uses models that are inspired
    by the structure and function of a biological brain found in humans or animals.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习算法的群体中，有一个子类别叫做深度学习算法。这个算法组使用的模型受到人类或动物大脑的结构和功能的启发。
- en: 'Both machine learning and deep learning learn from sample data that you provide.
    When we build regular programs, we write business rules by using different language
    constructs, such as if-statements, loops, and functions. The rules are fixed.
    In machine learning, we feed samples and an expected answer into an algorithm
    that then learns the rules that connect the samples to the expected answers:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习和深度学习都可以从你提供的样本数据中学习。当我们构建常规程序时，我们通过使用不同的语言构造（如if语句、循环和函数）编写业务规则。这些规则是固定的。在机器学习中，我们将样本和期望的答案输入到算法中，算法随后学习将样本与期望答案连接的规则：
- en: '![](img/e3148b6f-ac3d-4650-9bf1-9946349dea66.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3148b6f-ac3d-4650-9bf1-9946349dea66.png)'
- en: 'There are two major components in machine learning: machine learning models
    and machine learning algorithms.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习中有两个主要组成部分：机器学习模型和机器学习算法。
- en: 'When you use machine learning to build a program, you first choose a machine
    learning model. A machine learning model is a mathematical equation containing
    trainable parameters that transforms input into a predicted answer. This model
    shapes the rules that the computer will learn. For example: predicting the miles
    per gallon for a car requires that you model reality in a certain way. Classifying
    whether a credit card transaction is fraudulent requires a different model.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用机器学习构建程序时，首先选择一个机器学习模型。机器学习模型是一个包含可训练参数的数学方程，能够将输入转化为预测的答案。这个模型塑造了计算机将要学习的规则。例如：预测汽车的每加仑英里数需要以某种方式建模现实。判断信用卡交易是否欺诈需要一个不同的模型。
- en: The representation of the input could be the properties of a car turned into
    a vector. The output of the model could be the miles per gallon for a car. In
    the case of credit card fraud, the input could be the properties of the user account
    and the transaction that was done. The output representation could be a score
    between 0 and 1 where a value close to 1 means that the transaction should be
    rejected.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 输入的表示可以是汽车的属性转化为向量。模型的输出可以是汽车的每加仑英里数。对于信用卡欺诈的情况，输入可以是用户账户的属性和交易信息。输出表示可以是一个介于0和1之间的分数，其中接近1的值表示该交易应该被拒绝。
- en: The mathematical transformation in the machine learning model is controlled
    by a set of parameters that need to be trained for the transformation to produce
    the correct output representation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习模型中的数学变换由一组需要训练的参数控制，只有当这些参数经过训练，变换才能产生正确的输出表示。
- en: 'This is where the second part, the machine learning algorithm comes into play.
    To find the best values for the parameters in the machine learning model we need
    to perform a multi-step process:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，第二部分——机器学习算法就派上用场了。为了找到机器学习模型中参数的最佳值，我们需要执行一个多步骤的过程：
- en: Initially, the computer will choose a random value for each of the unknown parameters
    in your model
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始时，计算机会为模型中的每个未知参数选择一个随机值。
- en: It will then use sample data to make an initial prediction
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，模型会使用样本数据进行初步预测。
- en: This prediction is fed into a `loss` function together with the expected output
    to get feedback regarding how well the model is performing
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个预测会被输入到`loss`函数中，与预期的输出一起，以获取关于模型表现的反馈。
- en: This feedback is then used by the machine learning algorithm to find better
    values for the parameters in the model
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个反馈然后被机器学习算法用来为模型中的参数找到更好的值。
- en: These steps are repeated many times to find the best possible values for the
    parameters in the model. If all goes well, you end up with a model that is capable
    of making accurate predictions for many complicated situations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤会重复多次，以找到模型中参数的最佳值。如果一切顺利，你最终会得到一个能够对许多复杂情况做出准确预测的模型。
- en: 'The fact that we can learn rules from examples is a useful concept. There are
    many situations where we can''t use simple rules to solve a particular problem.
    For example: credit card fraud cases come in many shapes and sizes. Sometimes
    a hacker slowly breaks the system injecting smaller hacks over time and then stealing
    the money. Other times hackers simply try to steal a lot of money in one attempt.
    A rule-based program would become too hard to maintain because it would need to
    contain a lot of code to handle all different fraud cases. Machine learning is
    an elegant way to solve this problem. It understands how to handle different kinds
    of credit card fraud without a lot of code. And it is also capable of making a
    judgment on cases that it hasn''t seen before, within reasonable boundaries.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够从示例中学习规则这一事实是一个有用的概念。许多情况下，我们无法使用简单的规则来解决特定问题。例如：信用卡欺诈案件的形式各异。有时，黑客会慢慢地渗透系统，逐步注入小型的攻击，然后盗取资金。其他时候，黑客则会在一次攻击中试图盗取大量资金。基于规则的程序会变得非常难以维护，因为它需要包含大量的代码来处理所有不同的欺诈案件。机器学习是一种优雅的解决方案。它可以在不需要大量代码的情况下理解如何处理不同类型的信用卡欺诈案件。它还能够在合理的范围内对之前未见过的案件做出判断。
- en: Limitations of machine learning
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器学习的局限性
- en: Machine learning models are very powerful. You can use them in many cases where
    rule-based programs fall short. Machine learning is a good first alternative whenever
    you find a problem that can't be solved with a regular rule-based program. Machine
    learning models do, however, come with their limitations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习模型非常强大。在许多规则性程序无法解决的场景中，你可以使用它们。机器学习是当你遇到无法用常规规则程序解决的问题时，一个很好的替代方案。然而，机器学习模型也有其局限性。
- en: 'The mathematical transformation in machine learning models is very basic. For
    example: when you want to classify whether a credit transaction should be marked
    as fraud, you can use a linear model. A logistic regression model is a great model
    for this kind of use case; it creates a decision boundary function that separates
    fraud cases from non-fraud cases. Most of the fraud cases will be above the line
    and correctly marked as such. But no machine learning model is perfect and some
    of the cases will not be correctly marked as fraud by the model as you can see
    in the following image.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习模型中的数学变换非常基础。例如：当你想要判断一次信用交易是否应该被标记为欺诈时，你可以使用线性模型。逻辑回归模型是这种用例的一个很好的选择；它创建了一个决策边界函数，将欺诈案例和非欺诈案例分开。大多数欺诈案例将位于边界线的上方，并被正确标记为欺诈。但是没有任何机器学习模型是完美的，正如你在下图中看到的那样，某些案例将无法被模型正确标记为欺诈。
- en: '![](img/431607a0-4125-48ba-bde5-c1fd18bc32c0.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/431607a0-4125-48ba-bde5-c1fd18bc32c0.png)'
- en: 'If your data happens to be perfectly linearly-separable all cases would be
    correctly classified by the model. But when have to deal with more complex types
    of data, the basic machine learning models fall short. And there are more reasons
    why machine learning is limited in what it can do:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的数据恰好是完全线性可分的，模型会正确分类所有的案例。但当你需要处理更复杂的数据时，基础的机器学习模型就会显得力不从心。而且，机器学习的局限性还有更多原因：
- en: Many algorithms assume that there's no interaction between features in the input
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多算法假设输入特征之间没有交互作用。
- en: Machine learning are, in many cases, based on linear algorithms, that don't
    handle non-linearity very well
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习在许多情况下是基于线性算法的，这些算法对非线性处理得并不好。
- en: Often, you are dealing with a lot of features, classic machine learning algorithms
    have a harder time to deal with high dimensionality in the input data
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常情况下，你需要处理大量的特征，经典的机器学习算法在处理高维输入数据时会面临更大的困难。
- en: How does deep learning work?
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度学习是如何工作的？
- en: The limitations discovered in machine learning caused scientists to look for
    other ways to build more complex models that allowed them to handle non-linear
    relationships and cases where there's a lot of interaction between the input of
    a model. This led to the invention of the artificial neural network.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习中的局限性促使科学家们寻找其他方法来构建更复杂的模型，使其能够处理非线性关系以及输入之间有大量交互的情况。这导致了人工神经网络的发明。
- en: An artificial neural network is a graph composed of several layers of artificial
    neurons. It's inspired by how the structure and function of the biological brain
    found in humans and animals.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 人工神经网络是由多层人工神经元组成的图结构。它的灵感来源于人类和动物的大脑结构和功能。
- en: To understand the power of deep learning and how to use CNTK to build neural
    networks, we need to look at how a neural network works and how it is trained
    to detect patterns in samples you feed it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解深度学习的强大之处以及如何使用CNTK构建神经网络，我们需要了解神经网络是如何工作的，以及它是如何被训练来识别你输入的样本中的模式。
- en: The neural network architecture
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 神经网络架构
- en: A neural network is made out of different layers. Each layer contains multiple
    neurons.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 神经网络由不同的层组成。每一层包含多个神经元。
- en: A typical neural network is made of several layers of artificial neurons. The
    first layer in a neural network is called the **input layer**. This is where we
    feed input into the neural network. The last layer of a neural network is called
    the **output layer**. This is where the transformed data is coming out of the
    neural network. The output of a neural network represents the prediction made
    by the network.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的神经网络由多个人工神经元的层组成。神经网络的第一层被称为**输入层**，这是我们将输入数据输入神经网络的地方。神经网络的最后一层被称为**输出层**，这是神经网络输出变换后数据的地方。神经网络的输出代表了网络做出的预测。
- en: In between the input and output layer of the neural network, you can find one
    or more hidden layers. The layers in between the input and output are hidden because
    we don't typically observe the data going through these layers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在神经网络的输入层和输出层之间，您可以找到一个或多个隐藏层。在输入和输出之间的层被称为隐藏层，因为我们通常不观察数据通过这些层。
- en: Neural networks are mathematical constructs. The data passed through a neural
    network is encoded as floating-point numbers. This means that everything you want
    to process with a neural network has to be encoded as vectors of floating-point
    numbers.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 神经网络是数学构造。通过神经网络传递的数据被编码为浮点数。这意味着您想要处理的所有内容都必须被编码为浮点数向量。
- en: Artificial neurons
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工神经元
- en: 'The core of a neural network is the artificial neuron. The artificial neuron
    is the smallest unit in a neural network that we can train to recognize patterns
    in data. Each artificial neuron inside the neural network has one or more input.
    Each of the vector input gets a weight:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 神经网络的核心是人工神经元。人工神经元是神经网络中最小的单元，我们可以训练它来识别数据中的模式。神经网络内的每个人工神经元都有一个或多个输入。每个向量输入都有一个权重：
- en: '![](img/ed8dfd9e-b993-4aa2-b3e6-d05158356a62.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed8dfd9e-b993-4aa2-b3e6-d05158356a62.png)'
- en: 'The image is adapted from: https://commons.wikimedia.org/wiki/File:Artificial_neural_network.png'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图像来源：https://commons.wikimedia.org/wiki/File:Artificial_neural_network.png
- en: The artificial neuron inside a neural network works in much the same way, but
    doesn't use chemical signals. Each artificial neuron inside the neural network
    has one or more inputs. Each of the vector inputs gets a weight.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 神经网络内部的人工神经元工作方式与此类似，但不使用化学信号。神经网络内的每个人工神经元都有一个或多个输入。每个向量输入都有一个权重。
- en: The numbers provided for each input of the neuron gets multiplied by this weight.
    The output of this multiplication is then added up to produce a total activation
    value for the neuron.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为神经元的每个输入提供的数字被这个权重相乘。然后将此乘积的输出相加以产生神经元的总激活值。
- en: 'This activation signal is then passed through an `activation` function. The
    `activation` function performs a non-linear transformation on this signal. For
    example: it uses a `rectified linear` function to process the input signal:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个激活信号被传递给一个`激活`函数。`激活`函数对这个信号进行非线性变换。例如：它使用`修正线性`函数处理输入信号：
- en: '![](img/bc32d394-207d-4e02-9050-0e22f6367239.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc32d394-207d-4e02-9050-0e22f6367239.png)'
- en: The `rectified linear` function will convert negative activation signals to
    zero but performs an identity (pass-through) transformation on the signal when
    it is a positive number.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`修正线性`函数将负激活信号转换为零，但在正数时执行一个恒等（通过）变换。'
- en: One other popular activation function is the `sigmoid` function. It behaves
    slightly different than the `rectified linear` function in that it transforms
    negative values to 0 and positive values to 1\. There is, however, a slope in
    the activation between -0.5 and +0.5, where the signal is transformed in a linear
    fashion.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的激活函数是`sigmoid`函数。它与`修正线性`函数略有不同，它将负值转换为0，正值转换为1。然而，在-0.5到+0.5之间，信号以线性方式转换。
- en: '![](img/23a438f1-08e4-491e-9de6-c368d07bb277.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23a438f1-08e4-491e-9de6-c368d07bb277.png)'
- en: Activation functions in artificial neurons play an important role in the neural
    network. It's because of these non-linear transformation functions that the neural
    network is capable of working with non-linear relationships in the data.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 人工神经元中的激活函数在神经网络中起着重要作用。正是因为这些非线性变换函数，神经网络才能处理数据中的非线性关系。
- en: Predicting output with a neural network
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用神经网络预测输出
- en: 'By combining layers of neurons together we create a stacked function that has
    non-linear transformations and trainable weights so it can learn to recognize
    complex relationships. To visualize this, let''s transform the neural network
    from previous sections into a mathematical formula. First, let''s take a look
    at the formula for a single layer:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将神经元层组合在一起，我们创建一个堆叠函数，具有非线性变换和可训练权重，因此它可以学习识别复杂的关系。为了可视化这一点，让我们将前面章节中的神经网络转换为数学公式。首先，让我们看一下单层的公式：
- en: '![](img/f00d068d-f5ae-47f1-8414-265f00ccec57.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f00d068d-f5ae-47f1-8414-265f00ccec57.png)'
- en: The *X* variable is a vector that represents the input for the layer in the
    neural network. The *w* parameter represents a vector of weights for each of the
    elements in the input vector, *X*. In many neural network implementations, an
    additional term, *b*, is added, this is called the **bias** and basically increases
    or decreases the overall level of input required to activate the neuron. Finally,
    there's a function, *f*, which is the `activation` function for the layer.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*X*变量是一个向量，表示神经网络中某一层的输入。*w*参数表示输入向量*X*中每个元素的权重向量。在许多神经网络实现中，会添加一个额外的项*b*，这被称为**偏置**，它基本上用来增加或减少激活神经元所需的输入量。最后，还有一个函数*f*，它是该层的`激活`函数。'
- en: 'Now that you''ve seen the formula for a single layer, let''s put together additional
    layers to create the formula for the neural network:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了单层的公式，让我们组合更多层，构造出神经网络的公式：
- en: '![](img/625d16d1-0a53-45e5-b927-65de2891a392.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/625d16d1-0a53-45e5-b927-65de2891a392.png)'
- en: Notice how the formula has changed. We now have the formula for the first layer
    wrapped in another `layer` function. This wrapping or stacking of functions continues
    when we add more layers to the neural network. Each layer introduces more parameters
    that need to be optimized to train the neural network. It also allows the neural
    network to learn more complex relationships from the data we feed into it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意观察公式是如何变化的。现在我们有了第一个层的公式，这个公式被包装在另一个`layer`函数中。当我们向神经网络添加更多层时，这种函数的包装或堆叠会继续进行。每一层都会引入更多需要优化的参数，以训练神经网络。它还使得神经网络能够从我们输入的数据中学习到更复杂的关系。
- en: To make a prediction with a neural network, we need to fill all of the parameters
    in the neural network. Let's assume we know those because we trained it before.
    What's left is the input value for the neural network.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用神经网络进行预测，我们需要填充神经网络中的所有参数。假设我们知道这些参数，因为之前已经训练过它了。剩下的就是神经网络的输入值。
- en: The input is a vector of floating-point numbers that is a representation of
    the input of our neural network. The output is a vector that forms a representation
    of the predicted output of the neural network.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 输入是一个浮动数值向量，它表示神经网络的输入。输出是一个向量，形成神经网络预测输出的表示。
- en: Optimizing a neural network
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化神经网络
- en: 'We''ve talked about making predictions with neural networks. We haven''t yet
    talked about how to optimize the parameters in a neural network. Let''s go over
    each of the components in a neural network and explore how they work together
    when we train it:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何使用神经网络进行预测，但还没有讨论如何优化神经网络中的参数。接下来让我们逐一介绍神经网络中的各个组成部分，并探讨它们在训练过程中如何协同工作：
- en: '![](img/56e4170c-cec1-4959-b0a1-e86ace2f0299.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56e4170c-cec1-4959-b0a1-e86ace2f0299.png)'
- en: A neural network has several layers that are connected together. Each layer
    will have a set of trainable parameters that we want to optimize. Optimizing a
    neural network is done using a technique called backpropagation. We aim to minimize
    the output of a loss function by gradually optimizing the values for the *w1*,
    *w2*, and *w3* parameters in the preceding diagram.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 神经网络由多个相互连接的层组成。每一层都有一组我们希望优化的可训练参数。优化神经网络使用一种叫做反向传播（backpropagation）的方法。我们的目标是通过逐步优化前述图中*w1*、*w2*和*w3*参数的值，来最小化损失函数的输出。
- en: 'The `loss` function for a neural network can take many shapes. Typically, we
    choose a function that expresses the difference between the expected output, *Y*,
    and the real output produced by the neural network. For example: we could use
    the following `loss` function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 神经网络的`loss`函数可以有多种形式。通常，我们选择一个表达期望输出*Y*与神经网络实际输出之间差异的函数。例如：我们可以使用以下`loss`函数：
- en: '![](img/9dcf5046-0e88-4908-b763-9209ccf136be.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9dcf5046-0e88-4908-b763-9209ccf136be.png)'
- en: Firstly, the neural network is initialized with . We can do this with random
    values for all of the parameters in the model.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，神经网络会被初始化。我们可以使用模型中所有参数的随机值来实现这一点。
- en: After we initialize the neural network, we feed data into the neural network
    to make a prediction. We then feed the prediction together with the expected output
    into a `loss` function to measure how close the model is to what we expect it
    to be.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化神经网络后，我们将数据输入神经网络进行预测。接着，我们将预测结果与期望输出一起输入`loss`函数，以衡量模型与我们期望的结果有多接近。
- en: The feedback from the `loss` function is used to feed an optimizer. The optimizer
    uses a technique called gradient descent to find out how to optimize each of the
    parameters.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`loss`函数的反馈被用来馈送给优化器。优化器使用一种叫做梯度下降的技术来找出如何优化每个参数。'
- en: 'Gradient descent is a key ingredient of neural network optimization and works
    because of an interesting property of the `loss` function. When you visualize
    the output of the `loss` function for one set of input with different values for
    the parameters in the neural network, you end up with a plot that looks similar
    to this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度下降是神经网络优化的一个关键成分，它之所以有效，是因为`loss`函数的一个有趣特性。当你可视化神经网络中一组输入对应的`loss`函数输出，并使用不同的参数值时，你最终得到的图像类似于这个：
- en: '![](img/352df2a1-9654-4efe-a08a-f6a809d6c2d0.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/352df2a1-9654-4efe-a08a-f6a809d6c2d0.png)'
- en: At the beginning of the backpropagation process, we start somewhere on one of
    the slopes in this mountain landscape. Our aim is to walk down the mountain toward
    a point where the values for the parameters are at their best. This is the point
    where the output of the `loss` function is minimized as much as possible.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在反向传播过程的开始，我们从这座山地的某个坡道上的位置出发。我们的目标是沿着山坡走向一个点，在那里参数的值达到了最佳状态。这就是`loss`函数的输出被尽可能最小化的点。
- en: For us to find the way down the mountain slope, we need to find a function that
    expresses the slope at the current spot on the mountain slope. We do this by creating
    a derived function from the `loss` function. This derived function gives us the
    gradients for the parameters in the model.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到下坡的路径，我们需要找到一个函数，它表示当前山坡上的坡度。我们通过从`loss`函数派生出一个导数函数来实现这一点。这个导数函数为模型中的参数提供了梯度。
- en: When we perform one pass of the backpropagation process, we take one step down
    the mountain using the gradients for the parameters. We can add the gradients
    to the parameters to do this. But this is a dangerous way of following the slope
    down the mountain. Because if we move too fast, we might miss the optimum spot.
    Therefore, all neural network optimizers have a setting called the learning rate.
    The learning rate controls the rate of descent.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行一次反向传播过程时，我们会使用参数的梯度沿着山坡向下走一步。我们可以通过将梯度加到参数上来实现这一点。但这种沿着坡道下山的方法是危险的。因为如果我们走得太快，可能会错过最优点。因此，所有神经网络优化器都有一个叫做学习率的设置。学习率控制了下降的速率。
- en: Because we can only take small steps in the gradient-descent algorithm, we need
    to repeat this process many times to reach the optimum values for the neural network
    parameters.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只能在梯度下降算法中采取小步伐，我们需要多次重复这个过程，才能达到神经网络参数的最优值。
- en: What is CNTK?
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是CNTK？
- en: Building a neural network from scratch is a big undertaking—something I would
    not advise anyone to start with unless you're looking for a programming challenge.
    There are some great libraries that can help you build neural networks without
    the need to fully understand the mathematical formulas.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始构建神经网络是一个巨大的工程——除非你在寻求编程挑战，否则我不建议任何人从这个开始。有一些很棒的库可以帮助你构建神经网络，而无需完全理解数学公式。
- en: '**Microsoft Cognitive Toolkit** (**CNTK**) is an open source library that contains
    all the basic building blocks to build a neural network.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**Microsoft Cognitive Toolkit**（**CNTK**）是一个开源库，包含构建神经网络所需的所有基本构件。'
- en: CNTK is implemented using C++ and Python, but it is also available in C# and
    Java. Training can only be done in C++ or Python, but you can easily load your
    models in C# or Java for making predictions after you've trained your neural network.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: CNTK是用C++和Python实现的，但它也可以在C#和Java中使用。训练只能在C++或Python中进行，但你可以在训练神经网络之后，轻松地在C#或Java中加载模型并进行预测。
- en: There is also a variant of CNTK that uses a proprietary language called BrainScript.
    But for the purpose of this book, we'll only look at Python for the basic features
    of the framework. Later on, in [Chapter 7](8db9f932-5716-4a33-82a7-0c5ce5fe2ed4.xhtml),
    *Deploying Models to Production*, we'll discuss how to use C# or Java to load
    and use a trained model.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个CNTK的变体，使用一种叫做BrainScript的专有语言。但在本书中，我们将仅关注Python来介绍该框架的基本功能。稍后，在[第7章](8db9f932-5716-4a33-82a7-0c5ce5fe2ed4.xhtml)《*将模型部署到生产环境*》中，我们将讨论如何使用C#或Java加载和使用训练好的模型。
- en: Features of CNTK
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CNTK的特点
- en: CNTK is a library that has both a low-level and high-level API for building
    neural networks. The low-level API is meant for scientists looking to build the
    next generation of neural network components, while the high-level API is meant
    for building production-quality neural networks.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: CNTK是一个同时具有低级和高级API的库，用于构建神经网络。低级API旨在为科学家提供构建下一代神经网络组件的工具，而高级API则是用于构建生产级神经网络。
- en: On top of these basic building blocks, CNTK features a set of components that
    will make it easier to feed data into your neural network. It also contains various
    components to monitor and debug neural networks.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些基本构建块之上，CNTK提供了一组组件，使得将数据输入到神经网络中变得更加容易。它还包含了各种组件来监控和调试神经网络。
- en: Finally, CNTK features a C# and Java API. You can use both of these languages
    to load trained models and make predictions from within your web application,
    microservices, or even Windows Store apps. In addition, you can use C# to train
    models should you want to do this.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，CNTK还提供C#和Java API。你可以使用这两种语言加载已训练的模型，并在你的Web应用程序、微服务，甚至是Windows Store应用中进行预测。此外，如果你愿意，也可以使用C#来训练模型。
- en: 'Although it is possible to work with CNTK from Java and C#, it is important
    to know that at this point not all features in the Python version of CNTK are
    available to the C# and Java APIs. For example: models trained for object detection
    in Python do not work in C# with version 2.6 of CNTK.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以从Java和C#使用CNTK，但重要的是要知道，目前CNTK的C#和Java API并未完全支持Python版本中的所有功能。例如：在Python中为目标检测训练的模型，在CNTK
    2.6版本的C#中无法使用。
- en: A high-speed low-level API
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高速低级API
- en: At the core of CNTK, you'll find a low-level API that contains a set of mathematical
    operators to build neural network components. The low-level API also includes
    the automatic differentiation needed to optimize the parameters in your neural
    network.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在CNTK的核心，你会找到一个低级API，它包含一组数学运算符，用于构建神经网络组件。低级API还包括自动求导功能，帮助优化神经网络中的参数。
- en: 'Microsoft built the components with high performance in mind. For example:
    it included specific code to train neural networks on graphics cards. Graphics
    cards contain specialized processors, called GPUs, that are capable of processing
    large volumes of vector and matrix math at very high speeds. You can typically
    speed up the training process of a neural network by at least a factor 10.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 微软在构建组件时考虑了高性能。例如：它包括了专门的代码来在图形处理单元（GPU）上训练神经网络。图形处理单元是专用处理器，能够以非常高的速度处理大量的向量和矩阵运算。你通常可以通过至少提高10倍的速度加速神经网络的训练过程。
- en: Basic building blocks for quickly creating neural networks
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于快速创建神经网络的基本构建块
- en: When you want to build a neural network for production use, you typically use
    the high-level API. The high-level API contains all kinds of different building
    blocks of a neural network.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要构建用于生产的神经网络时，通常使用高级API。高级API包含构建神经网络所需的各种不同模块。
- en: 'For example: there''s a basic dense layer to build the most basic kind of neural
    network. But you will also find more advanced layer types in the high-level API,
    such as the layer types needed to process images or time series data.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：有一个基本的密集层，可以用来构建最基本的神经网络。但你也会在高级API中找到更高级的层类型，例如处理图像或时间序列数据所需的层类型。
- en: The high-level API also contains different optimizers to train neural networks,
    so you don't have to manually build a gradient-descent optimizer. In CNTK, the
    optimization process is implemented using learners and trainers, where the learner
    defines which kind of gradient-descent algorithm to use while the trainer defines
    how to implement the basics of backpropagation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 高级API还包含不同的优化器来训练神经网络，因此你不需要手动构建梯度下降优化器。在CNTK中，优化过程通过学习器和训练器实现，学习器定义使用哪种梯度下降算法，而训练器定义如何实现反向传播的基本过程。
- en: In [Chapter 2](4c9da7a9-6873-4de9-99a9-43de693d65f8.xhtml), *Building Neural
    Networks with CNTK*, we'll explore how to use the high-level API to build and
    train a neural network. In [Chapter 5](9d91a0e4-3870-4a2f-b483-82fdb8849bc2.xhtml),
    *Working with Images*, and [Chapter 6](a5da9ef2-399a-4c30-b751-318d64939369.xhtml),
    *Working with Time Series Data,* you'll learn how to use some of the more advanced
    layer types to process images and time series data with CNTK.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](4c9da7a9-6873-4de9-99a9-43de693d65f8.xhtml)，*使用CNTK构建神经网络*，我们将探索如何使用高级API来构建和训练神经网络。在[第5章](9d91a0e4-3870-4a2f-b483-82fdb8849bc2.xhtml)，*处理图像*，以及[第6章](a5da9ef2-399a-4c30-b751-318d64939369.xhtml)，*处理时间序列数据*，你将学习如何使用一些更高级的层类型来处理图像和时间序列数据。
- en: Measuring model performance
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量模型性能
- en: Once you've built a neural network, you want to make sure that it works correctly.
    CNTK offers a number of components to measure the performance of neural networks.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你构建了神经网络，你需要确保它能够正常工作。CNTK提供了多个组件来衡量神经网络的性能。
- en: You will often find yourself looking for ways to monitor how well the training
    process for your model is doing. CNTK includes components that will generate log
    data from your model and the associated optimizer, which you can use to monitor
    the training process.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你常常会寻找一些方法来监控模型训练过程的效果。CNTK包括一些组件，这些组件可以从你的模型和相关的优化器中生成日志数据，供你监控训练过程。
- en: Loading and processing large datasets
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和处理大规模数据集
- en: When you use deep learning, you often need a large dataset to train neural networks.
    It is not uncommon to use gigabytes of data to train your model. Included with
    CNTK is a set of components that allow you to feed data into the neural network
    for training.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用深度学习时，你通常需要一个大型数据集来训练神经网络。使用数GB的数据来训练模型是很常见的。CNTK包含了一套组件，允许你将数据馈送到神经网络中进行训练。
- en: Microsoft did its best to build specialized readers that will load data into
    memory in batches so you don't need a terabyte of RAM to train your network. We'll
    talk about these readers in greater depth in [Chapter 3](f7cd9148-99e8-427c-acf4-d74c3e52df58.xhtml),
    *Getting Data into Your Neural Network*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 微软尽力构建了专用的读取器，这些读取器会将数据批量加载到内存中，这样你就不需要一TB的RAM来训练你的网络。我们将在[第3章](f7cd9148-99e8-427c-acf4-d74c3e52df58.xhtml)，*将数据加载到你的神经网络中*中更详细地讨论这些读取器。
- en: Using models from C# and Java
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从C#和Java使用模型
- en: The main CNTK library is built in Python on top of a C++ core. You can use both
    C++ and Python to train models. When you want to use your models in production,
    you have a lot more choice. You can use your trained model from C++ or Python,
    but most developers will want to use Java or C#. Python is much slower than these
    languages when it comes to runtime performance. Also, C# and Java are more widely
    used in corporate environments.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的CNTK库是基于Python构建的，核心部分使用C++实现。你可以使用C++和Python来训练模型。当你想在生产环境中使用模型时，你有更多选择。你可以从C++或Python使用训练好的模型，但大多数开发者会选择使用Java或C#。在运行时性能上，Python比这些语言要慢得多。此外，C#和Java在企业环境中使用更广泛。
- en: You can download the C# and Java version of CNTK as a separate library from
    NuGet or Maven central. In [Chapter 7](8db9f932-5716-4a33-82a7-0c5ce5fe2ed4.xhtml),
    *Deploying Models to Production*, we'll discuss how to use CNTK from these languages
    to host a trained model inside a microservice environment.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从NuGet或Maven中央库下载C#和Java版本的CNTK作为独立库。在[第7章](8db9f932-5716-4a33-82a7-0c5ce5fe2ed4.xhtml)，*将模型部署到生产环境*，我们将讨论如何从这些语言使用CNTK来在微服务环境中托管一个训练好的模型。
- en: Installing CNTK
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装CNTK
- en: Now that we've seen how neural networks work and what CNTK is, let's take a
    look at how to install it on your computer. CNTK is supported on both Windows
    and Linux, so we'll walk through each of them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了神经网络是如何工作的，以及CNTK是什么，让我们来看一下如何在你的计算机上安装它。CNTK支持Windows和Linux操作系统，因此我们将分别介绍这两种系统的安装方法。
- en: Installing on Windows
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上安装
- en: We will be using the Anaconda version of Python on Windows to run CNTK. Anaconda
    is a redistribution of Python that includes additional packages, such as `SciPy`
    and `scikit-learn`, which are used by CNTK to perform various calculations.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Windows上使用Anaconda版的Python来运行CNTK。Anaconda是Python的再发行版，其中包括一些额外的包，比如`SciPy`和`scikit-learn`，这些包被CNTK用来执行各种计算。
- en: Installing Anaconda
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Anaconda
- en: 'You can download Anaconda from the public website: [https://www.anaconda.com/download/](https://www.anaconda.com/download/).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从Anaconda的官方网站下载Anaconda：[https://www.anaconda.com/download/](https://www.anaconda.com/download/)。
- en: After you've downloaded the setup files, start the installation and follow the
    instructions to install Anaconda on your computer. You can find the installation
    instructions at [https://docs.anaconda.com/anaconda/install/](https://docs.anaconda.com/anaconda/install/).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下载设置文件后，启动安装并按照指示安装Anaconda。你可以在[https://docs.anaconda.com/anaconda/install/](https://docs.anaconda.com/anaconda/install/)找到安装说明。
- en: Anaconda will install a number of utilities on your computer. It will install
    a new command prompt that will automatically include all the Anaconda executables
    in your PATH variable. You can quickly manage your Python environment from this
    command prompt, install packages and, of course, run Python scripts.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Anaconda将在你的计算机上安装多个工具。它将安装一个新的命令行提示符，该提示符会自动将所有Anaconda可执行文件添加到你的PATH变量中。你可以通过这个命令行快速管理Python环境、安装软件包，当然，还可以运行Python脚本。
- en: Optionally, you can install Visual Studio Code with your Anaconda installation.
    Visual Studio Code is a code editor similar to Sublime and Atom and contains a
    large number of plugins that make it easier to write program code in different
    programming languages, such as Python.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，你可以在安装Anaconda时一起安装Visual Studio Code。Visual Studio Code是一款类似于Sublime和Atom的代码编辑器，包含大量插件，可以帮助你在不同编程语言中编写程序代码，例如Python。
- en: 'CNTK 2.6 supports Python 3.6 only, which means that not all distributions of
    Anaconda will work correctly. You can get an older version of Anaconda through
    the Anaconda archives at [https://repo.continuum.io/archive/](https://repo.continuum.io/archive/).
    Alternatively, you can downgrade the Python version in your Anaconda installation
    if you haven''t got a version with Python 3.6 included. To install Python 3.6
    in your Anaconda environment, open a new Anaconda prompt and execute the following
    command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: CNTK 2.6只支持Python 3.6，这意味着并非所有版本的Anaconda都能正常工作。你可以通过Anaconda的存档网站 [https://repo.continuum.io/archive/](https://repo.continuum.io/archive/)
    获取旧版本的Anaconda。或者，如果你没有包含Python 3.6版本的Anaconda，可以降级Anaconda中的Python版本。要在Anaconda环境中安装Python
    3.6，请打开新的Anaconda命令行并执行以下命令：
- en: '[PRE0]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Upgrading pip
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级pip
- en: Anaconda comes with a slightly outdated version of the python package manager,
    `pip`. This can cause problems when we try to install the `CNTK` package. So,
    before we install the `CNTK` package, let's upgrade the `pip` executable.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Anaconda附带的Python包管理器`pip`版本略显过时。这可能会导致我们在尝试安装`CNTK`包时出现问题。所以，在安装`CNTK`包之前，我们需要先升级`pip`可执行文件。
- en: 'To upgrade the `pip` executable, open the Anaconda prompt and execute the following
    command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要升级`pip`可执行文件，打开Anaconda命令行并执行以下命令：
- en: '[PRE1]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will remove the old `pip` executable and install a new version in its place.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将移除旧版的`pip`可执行文件，并安装一个新的版本来替代它。
- en: Installing CNTK
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装CNTK
- en: 'There''s a number of ways to get the `CNTK` package on your computer. The most
    common way is to install the package through the `pip` executable:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式可以将`CNTK`包安装到你的计算机上。最常见的方式是通过`pip`可执行文件安装该包：
- en: '[PRE2]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will download the `CNTK` package from the package manager website and install
    it on your machine. `pip` will automatically check for missing dependencies and
    install those as well.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从包管理器网站下载`CNTK`包并将其安装到你的机器上。`pip`会自动检查缺失的依赖项并一并安装。
- en: 'There are several alternative methods to install CNTK on your machine. The
    website has a neat set of documentation that explains the other installation methods
    in great detail: [https://docs.microsoft.com/en-us/cognitive-toolkit/Setup-CNTK-on-your-machine](https://docs.microsoft.com/en-us/cognitive-toolkit/Setup-CNTK-on-your-machine).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种替代方法可以在你的计算机上安装CNTK。官网上有一套详尽的文档，详细解释了其他安装方法：[https://docs.microsoft.com/en-us/cognitive-toolkit/Setup-CNTK-on-your-machine](https://docs.microsoft.com/en-us/cognitive-toolkit/Setup-CNTK-on-your-machine)。
- en: Installing on Linux
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Linux上安装
- en: Installing CNTK on Linux is slightly different than installing it on Windows.
    Just as on Windows, we will use Anaconda to run the `CNTK` package. But instead
    of a graphical installer for Anaconda, there's a terminal-based installer on Linux.
    The installer will work on most Linux distributions. We limited the description
    to Ubuntu, a widely-used Linux distribution.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上安装CNTK与在Windows上有所不同。与Windows一样，我们将使用Anaconda来运行`CNTK`包。但在Linux上没有图形界面的Anaconda安装程序，而是一个基于终端的安装程序。该安装程序适用于大多数Linux发行版。我们将描述限制在Ubuntu这一广泛使用的Linux发行版上。
- en: Installing Anaconda
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Anaconda
- en: 'Before we can install Anaconda, we need to make sure that the system is fully
    up to date. To check this, execute the following two commands inside a terminal:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够安装 Anaconda 之前，需要确保系统已完全更新。要检查这一点，请在终端中执行以下两个命令：
- en: '[PRE3]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Automatically Programmed Tool** (**APT**) is used to install all sorts of
    packages inside Ubuntu. In the code sample, we first ask `apt` to update the references
    to the various package repositories. We then ask it to install the latest updates.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动化工具**（**APT**）用于在 Ubuntu 中安装各种软件包。在代码示例中，我们首先让`apt`更新对各个软件包仓库的引用。然后我们让它安装最新的更新。'
- en: After the computer is updated, we can start the installation of Anaconda. First,
    navigate to [https://www.anaconda.com/download/](https://www.anaconda.com/download/)
    to get the URL for the latest Anaconda installation files. You can right-click
    on the download link and copy the URL to your clipboard.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机更新完成后，我们可以开始安装 Anaconda。首先，访问[https://www.anaconda.com/download/](https://www.anaconda.com/download/)以获取最新
    Anaconda 安装文件的 URL。你可以右键点击下载链接并将 URL 复制到剪贴板。
- en: 'Now open up a terminal window and execute the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开一个终端窗口并执行以下命令：
- en: '[PRE4]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Make sure to replace the `url` placeholder with the URL you copied from the
    Anaconda website. Press *Enter* to execute the command.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将`url`占位符替换为你从 Anaconda 网站复制的 URL。按 *Enter* 执行命令。
- en: 'Once the installation file is download, you can install Anaconda by running
    the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装文件下载完成，你可以通过运行以下命令来安装 Anaconda：
- en: '[PRE5]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will start the installer. Follow the instructions on the screen to install
    Anaconda on your computer. By default, Anaconda gets installed in a folder called
    `anaconda3` inside your home directory.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动安装程序。按照屏幕上的说明将 Anaconda 安装到你的计算机上。默认情况下，Anaconda 会被安装在你主目录下名为`anaconda3`的文件夹中。
- en: 'As is the case with the Windows version of CNTK 2.6, it only supports Python
    3.6\. You can either get an older distribution of Anaconda through their archives
    at [https://repo.continuum.io/archive/](https://repo.continuum.io/archive/), or
    downgrade your Python version by executing the following command in your terminal:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 CNTK 2.6 的 Windows 版本一样，它只支持 Python 3.6。你可以通过访问[https://repo.continuum.io/archive/](https://repo.continuum.io/archive/)获取
    Anaconda 的旧版本，或者通过在终端中执行以下命令来降级你的 Python 版本：
- en: '[PRE6]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Upgrading pip to the latest version
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级 pip 到最新版本
- en: 'Once we have Anaconda installed, we need to upgrade `pip` to the latest version.
    `pip` is used to install packages inside Python. It is the tool we''re going to
    use to install CNTK:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了 Anaconda，就需要将`pip`升级到最新版本。`pip`用于在 Python 中安装软件包。它是我们将用来安装 CNTK 的工具：
- en: '[PRE7]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Installing the CNTK package
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 CNTK 包
- en: 'The final step in the installation process is to install CNTK. This is done
    through `pip` using the following command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程的最后一步是安装 CNTK。这是通过`pip`使用以下命令完成的：
- en: '[PRE8]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Should you want to, you can also install CNTK by downloading a wheel file directly
    or using an installer with Anaconda included. You can find more information on
    alternative installation methods for CNTK at [https://docs.microsoft.com/en-us/cognitive-toolkit/Setup-CNTK-on-your-machine](https://docs.microsoft.com/en-us/cognitive-toolkit/Setup-CNTK-on-your-machine).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，也可以通过直接下载一个 wheel 文件或使用包含 Anaconda 的安装程序来安装 CNTK。你可以在[https://docs.microsoft.com/en-us/cognitive-toolkit/Setup-CNTK-on-your-machine](https://docs.microsoft.com/en-us/cognitive-toolkit/Setup-CNTK-on-your-machine)找到更多关于
    CNTK 替代安装方法的信息。
- en: Using your GPU with CNTK
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用你的 GPU 与 CNTK
- en: We looked at how to install the basic version of CNTK for use with your CPU.
    While the `CNTK` package is fast, it will run quicker on a GPU. But not all machines
    support this setup, and that's why I put the description of how to use your GPU
    into a separate section.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何安装适用于 CPU 的基本版本 CNTK。虽然 `CNTK` 包运行得很快，但在 GPU 上运行时会更快。不过，并非所有机器都支持这种配置，这就是为什么我把如何使用
    GPU 的描述放在了单独的一节中。
- en: 'Before you attempt to install CNTK for use with a GPU, make sure you have a
    supported graphics card. Currently, CNTK supports the NVIDIA graphics card with
    at least CUDA 3.0 support. CUDA is the programming API from NVIDIA that allows
    developers to run non-graphical programs on their graphics cards. You can check
    whether your graphics card supports CUDA on this website: [https://developer.nvidia.com/cuda-gpus](https://developer.nvidia.com/cuda-gpus).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试安装 CNTK 以使用 GPU 之前，确保你拥有支持的显卡。目前，CNTK 支持至少支持 CUDA 3.0 的 NVIDIA 显卡。CUDA 是
    NVIDIA 提供的编程 API，允许开发者在显卡上运行非图形程序。你可以在这个网站上检查你的显卡是否支持 CUDA：[https://developer.nvidia.com/cuda-gpus](https://developer.nvidia.com/cuda-gpus)。
- en: Enabling GPU usage on Windows
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Windows 上启用 GPU 使用
- en: To use your graphics card with CNTK on Windows, you need to have the latest
    GeForce or Quadro drivers for your graphics card (depending on which one you have).
    Aside from the latest drivers, you need to install the CUDA toolkit Version 9.0
    for Windows.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Windows 上使用显卡与 CNTK，你需要为你的显卡安装最新的 GeForce 或 Quadro 驱动程序（具体取决于你的显卡）。除了最新的驱动程序外，你还需要安装适用于
    Windows 的 CUDA 工具包 9.0 版本。
- en: 'You can download the CUDA toolkit from the NVIDIA website: [https://developer.nvidia.com/cuda-90-download-archive?target_os=Windows&target_arch=x86_64](https://developer.nvidia.com/cuda-90-download-archive?target_os=Windows&target_arch=x86_64).
    Once downloaded, run the installer and follow the instructions on the screen.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 NVIDIA 网站下载 CUDA 工具包：[https://developer.nvidia.com/cuda-90-download-archive?target_os=Windows&target_arch=x86_64](https://developer.nvidia.com/cuda-90-download-archive?target_os=Windows&target_arch=x86_64)。下载后，运行安装程序并按照屏幕上的说明操作。
- en: CNTK uses a layer on top of CUDA, called cuDNN, for neural-network-specific
    primitives. You can download the cuDNN binaries from the NVIDIA website at [https://developer.nvidia.com/rdp/form/cudnn-download-survey](https://developer.nvidia.com/rdp/form/cudnn-download-survey).
    In contrast to the CUDA toolkit, you need to register an account to the website
    before you can download the cuDNN binaries.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: CNTK 使用位于 CUDA 上方的一层，称为 cuDNN，用于神经网络特定的原语。你可以从 NVIDIA 网站下载 cuDNN 二进制文件，网址为 [https://developer.nvidia.com/rdp/form/cudnn-download-survey](https://developer.nvidia.com/rdp/form/cudnn-download-survey)。与
    CUDA 工具包不同，下载 cuDNN 二进制文件之前，你需要在网站上注册一个账户。
- en: Not all cuDNN binaries work with every version of CUDA. The website mentions
    which version of cuDNN is compatible with which version of the CUDA toolkit. For
    CUDA 9.0, you need to download cuDNN 7.4.1\.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的 cuDNN 二进制文件都与每个版本的 CUDA 兼容。网站上会注明每个版本的 cuDNN 与哪个版本的 CUDA 工具包兼容。对于 CUDA
    9.0，你需要下载 cuDNN 7.4.1\。
- en: Once you have downloaded the cuDNN binaries, extract the zip file into the root
    folder of your CUDA toolkit installation. Typically, the CUDA toolkit is located
    at `C:\program files\NVIDIA GPU Computing Toolkit\CUDA\v9.0`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 下载 cuDNN 二进制文件后，将 zip 文件解压到你的 CUDA 工具包安装的根文件夹中。通常，CUDA 工具包位于 `C:\program files\NVIDIA
    GPU Computing Toolkit\CUDA\v9.0`。
- en: 'The final step to enable GPU usage inside CNTK is to install the `CNTK-GPU`
    package. Open the Anaconda prompt in Windows and execute the following command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 CNTK 内 GPU 使用的最后一步是安装 `CNTK-GPU` 包。在 Windows 上打开 Anaconda 提示符并执行以下命令：
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Enabling GPU usage on Linux
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Linux 上启用 GPU 使用
- en: Using your graphics card with CNTK on Linux requires that you run the proprietary
    drivers for NVIDIA. When you install the CUDA toolkit on your Linux machine, you
    get asked to install the latest drivers for your graphics card automatically.
    While you are not required to install the drivers through the CUDA toolkit installer,
    we strongly recommend you do, as the drivers will match the binaries of the CUDA
    toolkit. This reduces the risk of a failing installation or other errors later
    on.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上使用显卡与 CNTK 需要运行 NVIDIA 的专有驱动程序。当你在 Linux 机器上安装 CUDA 工具包时，它会自动要求你安装适用于显卡的最新驱动程序。虽然你可以选择不通过
    CUDA 工具包安装程序安装驱动程序，但我们强烈推荐你这样做，因为驱动程序将与 CUDA 工具包的二进制文件匹配，这可以减少安装失败或其他错误的风险。
- en: 'You can download the CUDA toolkit from the NVIDIA website: [https://developer.nvidia.com/cuda-90-download-archive?target_os=Linux&target_arch=x86_64&target_distro=Ubuntu&target_version=1604&target_type=runfilelocal](https://developer.nvidia.com/cuda-90-download-archive?target_os=Linux&target_arch=x86_64&target_distro=Ubuntu&target_version=1604&target_type=runfilelocal).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 NVIDIA 网站下载 CUDA 工具包：[https://developer.nvidia.com/cuda-90-download-archive?target_os=Linux&target_arch=x86_64&target_distro=Ubuntu&target_version=1604&target_type=runfilelocal](https://developer.nvidia.com/cuda-90-download-archive?target_os=Linux&target_arch=x86_64&target_distro=Ubuntu&target_version=1604&target_type=runfilelocal)。
- en: Please make sure you select the appropriate Linux distribution and version.
    The link automatically selects Ubuntu 16.04 and uses a local runfile.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保选择合适的Linux发行版和版本。链接会自动选择Ubuntu 16.04，并使用本地运行文件。
- en: 'Once you''ve downloaded the binaries to disk, you can run the installer by
    opening a terminal and executing the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 下载二进制文件到磁盘后，你可以通过打开终端并执行以下命令来运行安装程序：
- en: '[PRE10]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Follow the onscreen instructions to install the CUDA toolkit on your machine.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 按照屏幕上的指示在你的机器上安装CUDA工具包。
- en: 'Once you have the CUDA toolkit installed, you need to modify your Bash profile
    script. Open the `$HOME/.bashrc` file in your favorite text editor and include
    the following lines at the end of the script:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了CUDA工具包后，你需要修改你的Bash配置文件。使用你喜欢的文本编辑器打开`$HOME/.bashrc`文件，并在脚本的末尾添加以下几行：
- en: '[PRE11]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first line includes the CUDA binaries in the PATH variable so CNTK can access
    them. The second line in the script includes the CNTK libraries in your library
    PATH so CNTK can load them when needed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将CUDA二进制文件包含到PATH变量中，以便CNTK能够访问它们。脚本中的第二行将CNTK库包含到你的库路径中，以便CNTK在需要时能够加载它们。
- en: Save the changes to the file and close the editor. Please make sure you restart
    your terminal window to ensure that the new settings are loaded.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件的更改并关闭编辑器。请确保重新启动终端窗口，以确保新设置已生效。
- en: 'The final step is to download and install the cuDNN binaries. CNTK uses a layer
    on top of CUDA, called cuDNN, for neural-network-specific primitives. You can
    download the cuDNN binaries from the NVIDIA website here: [https://developer.nvidia.com/rdp/form/cudnn-download-survey](https://developer.nvidia.com/rdp/form/cudnn-download-survey).
    In contrast to the CUDA toolkit, you need to register an account on the website
    before you can download the cuDNN binaries.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是下载并安装cuDNN二进制文件。CNTK使用一个位于CUDA之上的层，叫做cuDNN，来处理神经网络特定的原语。你可以从NVIDIA网站下载cuDNN二进制文件，网址是：[https://developer.nvidia.com/rdp/form/cudnn-download-survey](https://developer.nvidia.com/rdp/form/cudnn-download-survey)。与CUDA工具包不同，你需要在该网站上注册一个账户，才能下载cuDNN二进制文件。
- en: 'Not all cuDNN binaries work with every version of CUDA. The website mentions
    which version of cuDNN is compatible with which version of the CUDA toolkit. For
    CUDA 9.0, you need to download cuDNN 7.4.1\. Download the version for Linux and
    extract it to the `/usr/local/cuda-9.0` folder using the following command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的cuDNN二进制文件都与每个版本的CUDA兼容。网站上会提到哪些版本的cuDNN与哪些版本的CUDA工具包兼容。对于CUDA 9.0，你需要下载cuDNN
    7.4.1\. 下载适用于Linux的版本，并使用以下命令将其提取到`/usr/local/cuda-9.0`文件夹中：
- en: '[PRE12]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The filename may differ slightly; change the path to the filename as needed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名可能会有所不同；根据需要更改路径到相应的文件名。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about deep learning and its relationship to machine
    learning and AI. We looked at the basic concepts behind deep learning and how
    to train a neural network using gradient descent. We then talked about CNTK, what
    it is, and what features the library offers to build deep learning models. We
    finally spent some time discussing how to install CNTK on Windows and Linux and
    how to use your GPU should you want to.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了深度学习及其与机器学习和人工智能的关系。我们了解了深度学习背后的基本概念，以及如何使用梯度下降法训练神经网络。接着我们讨论了CNTK，它是什么，以及该库提供了哪些功能来构建深度学习模型。最后，我们花了一些时间讨论了如何在Windows和Linux上安装CNTK，并如何在需要时使用GPU。
- en: In the next chapter, we will learn how to build basic neural networks with CNTK
    so we get a better understanding of how the concepts in this chapter work in code.
    We will also discuss the different ways we can use various components in our deep
    learning model for different scenarios.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习如何使用CNTK构建基本的神经网络，以便更好地理解本章中的概念如何在代码中实现。我们还将讨论如何在不同场景下使用深度学习模型中的各种组件。
