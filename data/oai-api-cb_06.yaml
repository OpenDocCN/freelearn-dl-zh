- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Building Intelligent Applications with the OpenAI API
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenAI API构建智能应用程序
- en: This chapter will bring together all the key concepts that we have learned about
    in the previous chapters. It’s all about creating real intelligent applications
    using the OpenAI API. It’s important to note that an application is not simply
    just the OpenAI API, but several layers around it, such as the frontend and backend
    layers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将汇总我们在之前各章中学到的所有关键概念。重点是使用OpenAI API创建真正的智能应用程序。需要特别注意的是，应用程序不仅仅是OpenAI API本身，还包括其周围的多个层次，如前端和后端层。
- en: 'In this chapter, we will make use of the application architecture that we learned
    in the previous chapter. In particular, we will use *Google Cloud Functions* as
    the backend layer and *Bubble* as the frontend layer. In case you don’t recall
    the architecture, *Figure 6**.1* demonstrates the layers within any application:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用上一章中学到的应用架构。具体来说，我们将使用*Google Cloud Functions*作为后端层，*Bubble*作为前端层。如果你不记得架构了，*图6.1*演示了任何应用程序中的各个层次：
- en: '![Figure 6.1 - Demonstration of a typical application architecture using the
    OpenAI API](img/B21007_06_1.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 - 使用OpenAI API的典型应用架构演示](img/B21007_06_1.jpg)'
- en: Figure 6.1 - Demonstration of a typical application architecture using the OpenAI
    API
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 - 使用OpenAI API的典型应用架构演示
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Creating a wrapper application that generates replies to your emails
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个生成回复电子邮件的包装应用程序
- en: Creating a multi-modal application that generates travel itineraries
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个生成旅行行程的多模态应用程序
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the recipes in this chapter require you to have access to the OpenAI API
    (via a generated API key) and have an API client installed. Please refer to the
    *Making OpenAI API requests with Postman* recipe in [*Chapter 1*](B21007_01.xhtml#_idTextAnchor021)
    for more information on how to obtain your API key. You will also require knowledge
    of Python and the Python OpenAI library, which we covered in the first recipe
    within [*Chapter 4*](B21007_04.xhtml#_idTextAnchor074).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有食谱都要求你拥有OpenAI API访问权限（通过生成的API密钥）并安装了API客户端。有关如何获取API密钥的更多信息，请参见[*第1章*](B21007_01.xhtml#_idTextAnchor021)中的*使用Postman发起OpenAI
    API请求*食谱。你还需要掌握Python和Python OpenAI库的知识，这些内容在[*第4章*](B21007_04.xhtml#_idTextAnchor074)的第一个食谱中已覆盖。
- en: We will also use GCP to host our public endpoint. GCP is a suite of cloud computing
    services offered by Google. It offers a range of hosting and computing services
    for databases, data storage, data analytics, machine learning, and more, all hosted
    on Google’s infrastructure. You can refer to the *Creating a public endpoint server
    that calls the OpenAI API* recipe in [*Chapter 5*](B21007_05.xhtml#_idTextAnchor090)
    for more information.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用GCP来托管我们的公共端点。GCP是Google提供的一套云计算服务，涵盖了数据库、数据存储、数据分析、机器学习等多种托管和计算服务，所有服务都托管在Google的基础设施上。有关更多信息，请参见[*第5章*](B21007_05.xhtml#_idTextAnchor090)中的*创建调用OpenAI
    API的公共端点服务器*食谱。
- en: Finally, you need to be familiar with Bubble, which is a visual programming
    platform that allows users to create web applications without needing to write
    code. You can refer to the *Calling the user-created endpoint from no-code applications*
    recipe in [*Chapter 5*](B21007_05.xhtml#_idTextAnchor090) for more information
    on how to set up Bubble.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要熟悉Bubble，这是一个可视化编程平台，允许用户无需编写代码即可创建Web应用程序。有关如何设置Bubble的更多信息，请参见[*第5章*](B21007_05.xhtml#_idTextAnchor090)中的*从无代码应用程序调用用户创建的端点*食谱。
- en: Creating a wrapper application that generates replies to your emails
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个生成回复电子邮件的包装应用程序
- en: In this recipe, we will build an intelligent application that helps you reply
    to emails from your manager, who has asked you to perform a specific task. I always
    have a hard time politely saying no to my manager when I’m overburdened with tasks,
    so this could be a great application for me (and I use a variant of this every
    day).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将构建一个智能应用程序，帮助你回复经理的电子邮件，经理要求你执行一个特定的任务。当我被任务压得喘不过气时，总是很难礼貌地拒绝经理，所以这个应用程序对我来说可能是个很好的选择（而且我每天都在使用这个变种）。
- en: Technically, everything that you do with this application you could do with
    the ChatGPT service directly. So, why take the time and build it with the API,
    backend, frontend approach? When learning any new skill, it is useful to learn
    concepts in manageable steps. Here, the first step when building an intelligent
    application is to start with a simple wrapper application. This will enable you
    to master the underlying workflow of building an intelligent application. Afterward,
    we will add new concepts to this workflow that will enable you to build an application,
    which cannot be done with the ChatGPT service.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，使用这个应用程序做的所有事情，你都可以直接通过 ChatGPT 服务完成。那么，为什么要花时间通过 API、后端和前端的方式来构建它呢？学习任何新技能时，逐步学习概念是非常有用的。这里，构建智能应用程序的第一步是从一个简单的
    wrapper 应用程序开始。这将帮助你掌握构建智能应用程序的基本工作流程。之后，我们将向这个工作流程添加新的概念，帮助你构建一个 ChatGPT 服务无法做到的应用程序。
- en: A **wrapper application** for the OpenAI API is essentially a software layer
    that facilitates easier and more efficient interaction with the OpenAI API. The
    term **wrapper** in programming generally refers to a type of software that acts
    as an intermediary or interface to another software component or API, making it
    more accessible or simpler to use. Wrappers are very useful as they simplify API
    interactions, and they are also easier to make compared to more complex multi-modal
    applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**Wrapper 应用程序**是一个为 OpenAI API 提供支持的软层，便于与 OpenAI API 更高效地交互。在编程中，**wrapper**
    通常指代一种作为中介或接口的软件，它使得与另一个软件组件或 API 的交互变得更加容易或简洁。Wrapper 非常有用，因为它们简化了 API 的交互，而且比更复杂的多模态应用程序更容易制作。'
- en: 'In this recipe, we will build the application in three phases: *OpenAI Playground*,
    *Google Cloud Function*, and *Bubble*.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将分三步构建应用程序：*OpenAI Playground*、*Google Cloud Function* 和 *Bubble*。
- en: Getting ready
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure you have an OpenAI platform account with available usage credits. If
    you don’t, please follow the *Setting up your OpenAI Playground environment* recipe
    in [*Chapter 1*](B21007_01.xhtml#_idTextAnchor021).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你有一个可用额度的 OpenAI 平台账户。如果没有，请参阅[*第 1 章*](B21007_01.xhtml#_idTextAnchor021)中的
    *设置你的 OpenAI Playground 环境* 配方。
- en: Furthermore, ensure you have created a GCP account. You may need to provide
    a billing profile as well to create any GCP resources. Note that GCP does have
    a free tier, and in this recipe, we will *not* go above the free tier so, essentially,
    you should not be billed for anything.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，确保你已经创建了 GCP 账户。你可能还需要提供账单资料才能创建 GCP 资源。请注意，GCP 提供免费层，在这个配方中，我们将 *不会* 超过免费层，因此你基本上不应该产生任何费用。
- en: Finally, ensure that you have created a Bubble account, which you can do for
    free at [http://bubble.io](http://bubble.io).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，确保你已经创建了一个 Bubble 账户，你可以通过 [http://bubble.io](http://bubble.io) 免费创建。
- en: All the recipes in this chapter will have this same requirement.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有配方都将有相同的要求。
- en: How to do it…
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: OpenAI Playground
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenAI Playground
- en: Navigate to [https://openai.com](https://openai.com). Select **Playground**
    from the left-hand side menu. From the top menu, switch Playground mode from **Assistant**
    to **Chat**.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 [https://openai.com](https://openai.com)。在左侧菜单中选择 **Playground**。从顶部菜单，将
    Playground 模式从 **Assistant** 切换为 **Chat**。
- en: In the **System** message, type **You are a helpful assistant that creates replies
    to emails that politely say no to the task you have been asked to perform. Only
    return the reply to the email,** **nothing else.**
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **System** 消息中，输入 **You are a helpful assistant that creates replies to emails
    that politely say no to the task you have been asked to perform. Only return the
    reply to the email,** **nothing else.**
- en: On the `Hi Henry,`
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Hi Henry,`
- en: '`Since Dave is out, could you please pick up the Henderson proposal and have
    it on my desk by` `tomorrow morning?`'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`由于 Dave 不在，能否请你接手 Henderson 提案，并在` `明天早上`之前放到我的办公桌上？`'
- en: '`Best,`'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Best,`'
- en: '`Rick`'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Rick`'
- en: 'Over on the right-hand side, make the following changes to the Playground properties:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧，进行以下更改以调整 Playground 的属性：
- en: Switch **Model** from **gpt-3.5** to **gpt-4**
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 **Model** 从 **gpt-3.5** 切换为 **gpt-4**
- en: Increase **Temperature** to **1.4**
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 **Temperature** 增加到 **1.4**
- en: 'Set **Maximum length** to around **1000**:'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 **Maximum length** 设置为大约 **1000**：
- en: '![Figure 6.2 – ChatGPT Playground configuration](img/B21007_06_2.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – ChatGPT Playground 配置](img/B21007_06_2.jpg)'
- en: Figure 6.2 – ChatGPT Playground configuration
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – ChatGPT Playground 配置
- en: Next, select **Submit**. OpenAI will create a response for you. In this case,
    it will create a reply to the sample email you sent, with the condition that it
    *politely* says no to the task you have been asked to perform.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择**提交**。OpenAI 会为你生成一个回复。在此情况下，它会针对你发送的示例邮件做出回复，并且条件是它*礼貌地*拒绝你被要求执行的任务。
- en: Google Cloud Function
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Google Cloud Function
- en: In a new tab, navigate to [https://cloud.google.com](https://cloud.google.com)
    and log in with your Google account.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新标签页中，导航到[https://cloud.google.com](https://cloud.google.com)，并使用你的 Google
    帐户登录。
- en: Select **Console** at the top right.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右上角选择**控制台**。
- en: Create a new Google cloud function. To do so, in the search bar, type **function**,
    select **Cloud Functions**, and then select **Create Function**.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Google 云函数。为此，在搜索栏中输入**function**，选择**Cloud Functions**，然后选择**创建函数**。
- en: Give the function a descriptive name. Since this function will return a polite
    email for us, we are going to aptly name it **generatepoliteemail**.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给函数起个描述性的名字。由于此函数将为我们返回一封礼貌的电子邮件，我们将其命名为**generatepoliteemail**。
- en: In the **Authentication** menu, ensure that you select **Allow unauthenticated
    invocations** as the authentication method. This will enable the frontend application
    to make calls to the backend layer.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**身份验证**菜单中，确保选择**允许未经身份验证的调用**作为身份验证方式。这将使前端应用能够调用后端层。
- en: Select **Next** to move on to function development. In the **Runtime** drop-down
    menu, select **Python 3.12**. For the **entry point** value, select or type **get_message**.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**下一步**进入函数开发。在**运行时**下拉菜单中，选择**Python 3.12**。对于**入口点**值，选择或输入**get_message**。
- en: 'For the actual *code block*, type the following:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于实际的*代码块*，输入以下内容：
- en: '[PRE0]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Go to **Requirements.txt** in the left-hand side menu, type in a new line, and
    type **openai**. This is to ensure that the OpenAI library will be downloaded
    as part of this function.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到左侧菜单中的**Requirements.txt**，输入新的一行，并输入**openai**。这样可以确保 OpenAI 库作为此函数的一部分被下载。
- en: Go back to **Open AI Playground**. Remove the **Assistant** message that was
    produced as part of *step 4*. Ensure that the only messages that are populated
    are **System** and **User**.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到**Open AI Playground**。删除作为*步骤 4*一部分生成的**Assistant**消息。确保填充的唯一消息是**System**和**User**。
- en: 'Select **View code**, copy the response (*Figure 6**.3*), and then paste it
    into the Google Cloud console code block under where it says **### Playground
    Code Here ###** (*Figure 6**.4*):'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '选择**查看代码**，复制响应（*图 6.3*），然后将其粘贴到 Google Cloud 控制台中的代码块下方，那里写着**### Playground
    Code Here ###**（*图 6.4*）：'
- en: '![Figure 6.3 – Code from Playground to be ingested into Google Cloud Functions](img/B21007_06_3.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 从 Playground 获取的代码要导入到 Google Cloud Functions 中](img/B21007_06_3.jpg)'
- en: Figure 6.3 – Code from Playground to be ingested into Google Cloud Functions
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 从 Playground 获取的代码要导入到 Google Cloud Functions 中
- en: "![Figure 6.4 – Pasting the code into the Google Cloud \uFEFFconsole](img/B21007_06_4.jpg)"
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 将代码粘贴到 Google Cloud 控制台中](img/B21007_06_4.jpg)'
- en: Figure 6.4 – Pasting the code into the Google Cloud console
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 将代码粘贴到 Google Cloud 控制台中
- en: The key part to change about the code is that the `Hi Henry, since Dave is out…`).
    We want to replace this with the `email` variable that is part of the function.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改代码的关键部分是`Hi Henry, since Dave is out…`。我们希望用函数中的`email`变量来替换它。
- en: Additionally, since we want three email replies (and therefore three answers
    from the OpenAI API), we need to put in another argument in the OpenAI request
    that says *n=3*. This will ensure that we get *n* or *three* emails from the actual
    API.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们想要三封电子邮件回复（因此需要从 OpenAI API 获取三条回答），我们需要在 OpenAI 请求中添加一个额外的参数，表示*n=3*。这将确保我们从实际的
    API 获得*n*或*三封*电子邮件。
- en: 'After making these changes, the code block in **Google Cloud Functions** should
    look like this:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行这些更改后，**Google Cloud Functions**中的代码块应如下所示：
- en: '[PRE1]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Select **Deploy**. You might need to wait 5 minutes for the deployment to fully
    complete. When you see the *green checkmark* on the **Cloud Functions** screen,
    your function has been successfully deployed:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**部署**。你可能需要等待 5 分钟，直到部署完全完成。当你在**Cloud Functions**屏幕上看到*绿色勾选标记*时，表示你的函数已成功部署：
- en: '![Figure 6.5 – Cloudless function deployment snapshot](img/B21007_06_5.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 无云函数部署快照](img/B21007_06_5.jpg)'
- en: Figure 6.5 – Cloudless function deployment snapshot
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 无云函数部署快照
- en: We will now use Postman to test the cloud function that we have just deployed.
    To do so, open Postman, select **New** at the top left, and then select **HTTP**.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用 Postman 来测试刚刚部署的云函数。为此，打开 Postman，在左上角选择**新建**，然后选择**HTTP**。
- en: 'On the Postman request, select **Headers** and type in a new header, with **Key**
    equal to **Content-Type** and **Value** equal to **application/json**:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Postman请求中，选择**头部**，并输入一个新的头部，其中**键**为**Content-Type**，**值**为**application/json**：
- en: '![Figure 6.6 – Cloud Functions test configuration](img/B21007_06_6.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 云函数测试配置](img/B21007_06_6.jpg)'
- en: Figure 6.6 – Cloud Functions test configuration
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 云函数测试配置
- en: Change the request from **Get** to **Post** from the left-hand side drop-down
    menu. Copy the endpoint URL from the **Cloud Functions** page and paste it into
    Postman.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将请求从左侧下拉菜单中的**GET**更改为**POST**。复制**云函数**页面中的端点URL，并将其粘贴到Postman中。
- en: 'Select **Body**, then select **Raw**, and copy and paste the following JSON
    request:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**正文**，然后选择**原始**，复制并粘贴以下JSON请求：
- en: '[PRE2]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Select **Send** to make the call to your cloud function. If all goes well,
    you should see a response similar to what’s shown in *Figure 6**.7*:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**发送**以调用你的云函数。如果一切顺利，你应该能看到类似于*图 6.7*所示的响应：
- en: "![Figure 6.7 – \uFEFFA successful cloud function test](img/B21007_06_7.jpg)"
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7 – 成功的云函数测试](img/B21007_06_7.jpg)'
- en: Figure 6.7 – A successful cloud function test
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – 成功的云函数测试
- en: Bubble
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bubble
- en: Navigate to [http://bubble.io](http://bubble.io) and log in. Select **Create
    an app** and give your app a relevant name. Select **Get started** and then select
    **Start with basic features**. You can also click on the **Skip application assistant**
    prompt if you encounter it.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[http://bubble.io](http://bubble.io)并登录。选择**创建应用**并为你的应用命名。选择**开始使用**，然后选择**从基础功能开始**。如果遇到**跳过应用助手**的提示，也可以点击跳过。
- en: 'On the **Canvas** page, we are going to add a few elements that are required
    for our application. Select **Multiline Input** from the left-hand side menu and
    then draw a rectangle at the top of the page. Double-click the element from the
    property menu and replace **Placeholder** with **Type** **email here**:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**画布**页面，我们将添加一些应用程序所需的元素。从左侧菜单中选择**多行输入框**，然后在页面顶部绘制一个矩形。双击属性菜单中的元素，并将**占位符**替换为**在此输入电子邮件**：
- en: '![Figure 6.8 – Bubble.io UI configuration](img/B21007_06_8.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8 – Bubble.io 用户界面配置](img/B21007_06_8.jpg)'
- en: Figure 6.8 – Bubble.io UI configuration
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 – Bubble.io 用户界面配置
- en: Create a **Button** element by selecting **Button** and then drawing a box to
    the right of the first element you created.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**按钮**元素，方法是选择**按钮**，然后在你创建的第一个元素右侧绘制一个框。
- en: 'The final set of elements to create is three **Text** elements. Select **Text**
    from the left-hand side menu and draw a box to the bottom of **Multiline Input**,
    about 1/3 the width of the page. Repeat this for the other two text boxes and
    put them adjacent to the other **Text** elements. Name these elements **Text A**,
    **Text B**, and **Text C** by double-clicking each element and replacing the **Placeholder**
    element with **Text A**, **Text B**, and **Text** **C**, respectively:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一组需要创建的元素是三个**文本**元素。从左侧菜单中选择**文本**，然后在**多行输入框**的下方绘制一个框，宽度约为页面的1/3。对其他两个文本框重复此操作，并将它们与其他**文本**元素相邻。通过双击每个元素并将**占位符**元素分别替换为**文本
    A**、**文本 B** 和**文本 C**来命名这些元素。
- en: '![Figure 6.9 – Bubble.io UI configuration](img/B21007_06_9.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9 – Bubble.io 用户界面配置](img/B21007_06_9.jpg)'
- en: Figure 6.9 – Bubble.io UI configuration
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 – Bubble.io 用户界面配置
- en: For each text box, double-click the **Text** element to show the property. Then,
    click **Insert dynamic data** on the actual text field, select **Text A**, and
    then **Create a new custom state**. You will be prompted for a name and type.
    For the name, type **email_ reply**. For **Type**, ensure **Text** is selected.
    This will create a unique custom state for the text box, which is required to
    show the values in the application.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个文本框，双击**文本**元素以显示其属性。然后，在实际文本字段上点击**插入动态数据**，选择**文本 A**，然后**创建一个新的自定义状态**。系统会提示你输入名称和类型。名称填写**email_reply**，对于**类型**，确保选择**文本**。这将为文本框创建一个独特的自定义状态，这是在应用程序中显示值所必需的。
- en: 'The next thing we need to do is load the cloud function that we created into
    Bubble. Select **Plugins** from the left-hand side menu, and then select **Add
    Plugins**. Select **API Connector**, then select **Install**, and then **Done**:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们需要做的是将我们创建的云函数加载到Bubble中。从左侧菜单中选择**插件**，然后选择**添加插件**。选择**API连接器**，然后选择**安装**，再选择**完成**：
- en: '![Figure 6.10 – Bubble.io UI configuration](img/B21007_06_10.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10 – Bubble.io 用户界面配置](img/B21007_06_10.jpg)'
- en: Figure 6.10 – Bubble.io UI configuration
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – Bubble.io 用户界面配置
- en: 'Select **API Connector** from the list of plugins. Then, select **Add Another
    API**. For **API name**, type **get_replies**. Scroll down until you get to the
    **Name** field and click **Expand**. Change the name of this API to **get_replies**.
    For the API, configure its settings like so:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从插件列表中选择**API连接器**。然后选择**添加另一个API**。对于**API名称**，输入**get_replies**。向下滚动直到找到**名称**字段，点击**展开**。将此API的名称更改为**get_replies**。对于该API，按如下方式配置其设置：
- en: From the **Use as** drop-down menu, select **Action**.
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从**作为使用**下拉菜单中，选择**动作**。
- en: Change the request from **GET** to **POST**.
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将请求从**GET**更改为**POST**。
- en: Directly adjacent to the **POST** request is a place to enter your **Endpoint
    URL**. Enter the URL you copied from the Google cloud function.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧挨着**POST**请求的是一个输入**Endpoint URL**的地方。输入你从Google云函数复制的URL。
- en: Create a new header by clicking **New Header**. Select **Add Header.** For **key**
    type in **Content-Type**, for **value** type in **application/json**.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击**新建头部**来创建新的头部。选择**添加头部**。对于**key**，输入**Content-Type**，对于**value**，输入**application/json**。
- en: 'Click **Parameter** to add a new parameter. For **key**, type in **email**.
    For **value**, copy the same JSON text that was used in the Postman call in *step
    17*, which is also written as follows. Do *not* include the quotes. Ensure that
    the **private** box is *unchecked*. This is important because we need to make
    sure that we have this argument available within Bubble:'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击**参数**以添加新参数。对于**key**，输入**email**。对于**value**，复制在*步骤17*中使用的相同JSON文本，如下所示。请**不要**包含引号。确保**私人**框未被选中。这一点非常重要，因为我们需要确保该参数在Bubble中可用：
- en: '[PRE3]'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Select **Initialize Call** to test the API call. If you see the screen shown
    in *Figure 6**.11*, then the call has been successful. Ensure that for each **choice**
    field, the **text** type has been selected, and click **Save**.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**初始化调用**来测试API调用。如果你看到如*图6.11*所示的屏幕，那么调用已经成功。确保每个**选择**字段都已选择**文本**类型，并点击**保存**。
- en: "![Figure 6.11 \uFEFF– A successful UI \uFEFFconfiguration](img/B21007_06_11.jpg)"
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图6.11 – 成功的UI配置](img/B21007_06_11.jpg)'
- en: Figure 6.11 – A successful UI configuration
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 – 成功的UI配置
- en: Select **Design** from the left-hand side menu. Double-click the **Button**
    element that you had created. In the property menu that appears, select **Add
    Workflow**.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧菜单中选择**设计**。双击你创建的**按钮**元素。在弹出的属性菜单中，选择**添加工作流**。
- en: Select **Click here to add an action**. Go to **Plugins** and find the API you
    had just created (**get_replies – get_replies**) and select it. On the property
    menu that appears, delete the content of **(param.) email** and then select **Insert
    dynamic data**. Scroll down and select **Multiline Input Type email here**, and
    then select **value**.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**点击此处添加动作**。进入**插件**，找到你刚刚创建的API（**get_replies – get_replies**）并选择它。在弹出的属性菜单中，删除**(param.)
    email**的内容，然后选择**插入动态数据**。向下滚动并选择**多行输入类型email这里**，然后选择**值**。
- en: "![Figure 6.12 \uFEFF– Bubble workflow](img/B21007_06_12.jpg)"
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图6.12 – Bubble工作流](img/B21007_06_12.jpg)'
- en: Figure 6.12 – Bubble workflow
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12 – Bubble工作流
- en: Next, select **Click here to add an action** again, scroll down to **Element
    Actions**, and then select **Set State**. For the **Element** drop-down menu,
    select **Text A**. For the **Custom state** drop-down menu, select **email_reply**.
    For **Value**, select **Results of step 1** and then select **Choice 1**. This
    will make the value of **Text A** equal to the first choice is the result of the
    API call to the cloud function that you had created.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，再次选择**点击此处添加动作**，向下滚动到**元素动作**，然后选择**设置状态**。对于**元素**下拉菜单，选择**Text A**。对于**自定义状态**下拉菜单，选择**email_reply**。对于**值**，选择**步骤1的结果**，然后选择**选择1**。这将使得**Text
    A**的值等于第一个选择，即你创建的云函数API调用的结果。
- en: Repeat *step 33* two more times for the **Text B** and **Text C** elements,
    choosing **Choice 2** and **Choice** **3**, respectively.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对**Text B**和**Text C**元素重复*步骤33*两次，分别选择**选择2**和**选择3**。
- en: We have completed everything we need for our Bubble intelligent application.
    To test whether the application works, select `Hi Henry,`
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经完成了Bubble智能应用程序所需的一切。为了测试应用程序是否正常工作，选择`Hi Henry,`
- en: '`Since Dave is out, could you please pick up the Henderson proposal and have
    it on my desk by` `tomorrow morning?`'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Since Dave is out, could you please pick up the Henderson proposal and have
    it on my desk by` `tomorrow morning?`'
- en: '`Best,`'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Best,`'
- en: '`Rick`'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Rick`'
- en: 'Select **Generate Replies**. If all goes well, you should get a screen like
    the one shown in *Figure 6**.13*, which shows the user three possible ways to
    reply to their manager and politely say no to an upcoming task:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**生成回复**。如果一切顺利，您应该看到一个如*图6.13*所示的屏幕，展示给用户三种可能的方式来回复经理，并礼貌地拒绝即将到来的任务：
- en: '![Figure 6.13 – A successful application configuration](img/B21007_06_13.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图6.13 – 一个成功的应用配置](img/B21007_06_13.jpg)'
- en: Figure 6.13 – A successful application configuration
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13 – 一个成功的应用配置
- en: How it works…
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we created a simple wrapper web application that produces sample
    responses to emails. By using the OpenAI API, our web application leveraged the
    power of LLMs to solve a particular problem. In this case, it was finding ways
    to politely say no to common tasks on email.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个流程中，我们创建了一个简单的Web应用程序，用来生成邮件的示例回复。通过使用OpenAI API，我们的Web应用程序利用了大型语言模型（LLM）的强大能力来解决一个特定的问题。在这种情况下，它是找到一种礼貌地拒绝邮件中常见任务的方法。
- en: 'The steps that we followed in this recipe are like what we have covered previously:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在此流程中遵循的步骤就像我们之前讲解的那样：
- en: First, we tested our prompts in the *Playground*, an environment where users
    can test different configurations and observe the impact on generated responses.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在*Playground*中测试了我们的提示，这是一个用户可以测试不同配置并观察其对生成回复的影响的环境。
- en: Then, we created the Google cloud function, which is the backend layer. In this
    layer, we added the code from the Playground that calls the OpenAI Chat API.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着，我们创建了Google云函数，它作为后端层。在这一层中，我们添加了Playground中的代码，调用OpenAI的聊天API。
- en: Then, we tested our backend layer using Postman to ensure that the calls were
    working properly, and then we received a suitable response from our backend API.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用Postman测试了后端层，确保调用正常工作，并且从后端API得到了适当的响应。
- en: Next, we created a simple frontend using Bubble.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用Bubble创建了一个简单的前端。
- en: Finally, we connected the frontend and backend layers using Bubble workflows
    and the API connector plugin.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过使用Bubble工作流和API连接插件，将前端和后端层连接起来。
- en: By performing these steps, we can create any intelligent application in less
    than an hour. It is worth zooming in on *step 1* as it is a critical step in creating
    any new application.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行这些步骤，我们可以在不到一小时的时间内创建任何智能应用。值得特别关注*步骤1*，因为它是创建任何新应用的关键步骤。
- en: We started this recipe with the OpenAI Playground, where we tested the **System**
    prompt in an environment where we could quickly iterate to ensure that we received
    the right response. The Playground provided a user-friendly interface, allowing
    us to experiment with different prompts and parameters. This experimentation was
    crucial for understanding how the AI model responds to various inputs, which,
    in turn, helped us fine-tune the prompts for our application.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从OpenAI Playground开始了这个流程，在一个可以快速迭代的环境中测试了**系统**提示，以确保我们得到正确的回复。Playground提供了一个用户友好的界面，允许我们实验不同的提示和参数。这一实验对于理解AI模型如何响应不同输入至关重要，进而帮助我们微调应用程序的提示。
- en: 'In the Playground and in the Python script where we made the OpenAI API request,
    we purposely set the following settings:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Playground和我们发出OpenAI API请求的Python脚本中，我们故意设置了以下配置：
- en: '**Model** to **gpt-4**: For an email response application, GPT-4’s advanced
    understanding of context and nuance is crucial. Emails can cover a wide range
    of topics and styles, from formal business communications to casual conversations.
    GPT-4’s robust language model can adapt to these varying styles and provide responses
    that are more accurate and contextually relevant.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**设置为**gpt-4**：对于一款邮件回复应用，GPT-4对上下文和细微差别的高级理解至关重要。邮件可以涵盖广泛的主题和风格，从正式的商业通信到随意的对话。GPT-4强大的语言模型能够适应这些不同的风格，并提供更准确、上下文相关的回复。'
- en: '**Temperature** to **1.4**: Since the purpose of this app is to create several
    varied responses, the temperature has been set higher than the standard value
    (1.0) to ensure there’s some randomness in the responses. A higher temperature
    helps in generating responses that are not too generic and can adapt to the unique
    content and tone of each email.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**温度**设置为**1.4**：由于这个应用的目的是生成多样化的回复，因此温度值设置高于标准值（1.0），以确保回复中有一定的随机性。较高的温度有助于生成不那么通用的回复，并能够适应每封邮件的独特内容和语气。'
- en: '**Maximum length** to **1000**: The maximum token length setting determines
    how long the generated responses can be. Setting this to 1,000 allows for sufficiently
    lengthy responses.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大长度**设置为**1000**：最大令牌长度设置决定了生成的响应的最大长度。将其设置为1000可以生成足够长的响应。'
- en: '**N** to **3**: The **N** parameter dictates the number of different responses
    the model will generate for each prompt. Setting **N** to **3** means the app
    will generate three different responses for each email, which is what we want
    for the web application.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**N**设置为**3**：**N**参数决定了模型为每个提示生成的不同响应的数量。将**N**设置为**3**意味着应用程序会为每封电子邮件生成三种不同的回复，这是我们为Web应用程序所希望的。'
- en: The other benefit of the Playground is that it produces Python-ready code for
    you; this is what we did in *step 15* of this recipe. After configuring all the
    settings and after we were happy with the responses from the Playground, all we
    needed to do was click **View Code** to then produce the exact code that we needed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Playground的另一个好处是它可以为你生成Python代码；这就是我们在*步骤15*中所做的。在配置好所有设置，并且对Playground的响应感到满意后，我们所需要做的就是点击**查看代码**，从而生成我们所需的确切代码。
- en: 'In this recipe, we created a simple application. However, because it was a
    wrapper application, it technically could have been done within ChatGPT itself,
    without the need to set up a complex backend layer or frontend layer. For example,
    I can go to ChatGPT ([https://chat.openai.com/](https://chat.openai.com/)) and
    type in the following prompt, at which point it will give me similar answers:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们创建了一个简单的应用程序。然而，由于它是一个封装应用程序，技术上它本来可以直接在ChatGPT中完成，而无需设置复杂的后端或前端层。例如，我可以访问ChatGPT（[https://chat.openai.com/](https://chat.openai.com/)），输入以下提示，它会给我类似的回答：
- en: '![Figure 6.14 – Using ChatGPT to create email responses](img/B21007_06_14.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图6.14 – 使用ChatGPT创建电子邮件回复](img/B21007_06_14.jpg)'
- en: Figure 6.14 – Using ChatGPT to create email responses
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14 – 使用ChatGPT创建电子邮件回复
- en: So, you may be wondering, what’s the point of creating the application through
    the OpenAI API? Well, there are some examples of applications that are not wrappers
    and can only be created through the API. This is what we will cover in the next
    recipe.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你可能会想，为什么要通过OpenAI API来创建这个应用程序呢？好吧，有一些应用程序的例子，它们不是封装器，必须通过API来创建。这就是我们将在下一个配方中讨论的内容。
- en: Creating a multi-modal application that generates travel itineraries
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个生成旅游行程的多模态应用程序
- en: In the previous recipe, we successfully created an intelligent application that
    produced replies to emails. We also discussed how this is technically a wrapper
    application, something that could be easily done through ChatGPT or the Playground
    itself.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，我们成功创建了一个智能应用程序，能够自动回复电子邮件。我们还讨论了这在技术上是一个封装应用程序，这种操作本身可以通过ChatGPT或Playground轻松实现。
- en: In this recipe, we will take the next step and create a multi-modal application.
    A **multi-modal application** is an advanced type of software that integrates
    various forms of media and interaction methods into a single *cohesive* experience.
    This integration allows for a richer and more engaging user interface, one that
    can cater to a wider range of user preferences and needs.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将迈出下一步，创建一个多模态应用程序。**多模态应用程序**是一种高级类型的软件，它将各种形式的媒体和互动方式集成到一个*统一*的体验中。这种集成能够提供更丰富、更具吸引力的用户界面，能够满足更广泛的用户偏好和需求。
- en: The core idea behind a multi-modal application is to combine text, voice, images,
    and possibly even video, to create a more dynamic and interactive environment.
    For instance, consider an application that not only responds to text queries but
    also understands voice commands, can analyze images, and perhaps even respond
    with video content. Such an application would be tremendously useful in fields
    such as education, where different learning styles could be accommodated, or in
    customer service, where it could provide a more personalized and efficient experience.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 多模态应用程序的核心思想是将文本、语音、图像，甚至可能的视频结合起来，创建一个更加动态和互动的环境。例如，考虑一个不仅能响应文本查询，还能理解语音命令、分析图像，甚至可能通过视频内容进行回应的应用程序。这样的应用程序在教育等领域将非常有用，因为它可以适应不同的学习风格；在客户服务中，它也能提供更加个性化和高效的体验。
- en: In our case, we will combine the **Chat API** and **Images API** to create travel
    itineraries. A user can go to the application, type in the city to which they
    will be traveling, and receive a full-day itinerary with images of the items mentioned
    specifically in the created itinerary.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将结合**Chat API**和**Images API**来创建旅行行程。用户可以访问应用程序，输入他们将要前往的城市，并获得包含具体行程内容和相关图像的全天旅行计划。
- en: This is an example of an application that could *not* easily be created through
    ChatGPT or the Playground, and as such provides real value.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个无法通过 ChatGPT 或 Playground 轻松创建的应用示例，因此它具有实际价值。
- en: How to do it…
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: In a new tab, navigate to [https://cloud.google.com](https://cloud.google.com)
    and log in with your Google account.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新标签页中，访问 [https://cloud.google.com](https://cloud.google.com)，并使用 Google 账户登录。
- en: Select **Console** at the top right.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择右上角的**控制台**。
- en: Create a new Google cloud function. In the search bar, type **function**, select
    **Cloud Functions**, and then select **Create Function**.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Google 云函数。在搜索框中输入**function**，选择**Cloud Functions**，然后选择**创建函数**。
- en: Give the function a descriptive name. Since this function will return an itinerary
    and images for us, we are going to aptly name it **get_itinerary_and_images**.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给函数起个描述性的名字。由于此函数将返回行程和图像，我们将其命名为**get_itinerary_and_images**。
- en: In the **Authentication** menu, ensure that you select **Allow unauthenticated
    invocations** as the authentication method. This will enable the frontend application
    to make calls to the backend layer.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**身份验证**菜单中，确保选择**允许无身份验证调用**作为身份验证方式。这将使前端应用程序能够调用后端层。
- en: 'Select the **Runtime, build, connections and security settings** drop-down
    menu to expand the options. Change **Timeout** from **60 seconds** to **300 seconds**.
    This will ensure that the timeout for the Google cloud function is not 1 minute
    but 5 minutes instead. This is important in multi-modal applications as several
    API requests will be made:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**运行时、构建、连接和安全设置**下拉菜单以展开选项。将**超时**从**60秒**更改为**300秒**。这将确保 Google 云函数的超时为
    5 分钟，而不是 1 分钟。在多模态应用中非常重要，因为将进行多个 API 请求：
- en: '![Figure 6.15 – Google Cloud Functions configuration settings](img/B21007_06_15.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.15 – Google 云函数配置设置](img/B21007_06_15.jpg)'
- en: Figure 6.15 – Google Cloud Functions configuration settings
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.15 – Google 云函数配置设置
- en: Select **Next** to move on to function development. In the **Runtime** drop-down
    menu, select **Python 3.12**. For **Entry point**, select or type in **get_travel_details**.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**下一步**进入函数开发。在**运行时**下拉菜单中选择**Python 3.12**。对于**入口点**，选择或输入**get_travel_details**。
- en: Go to **Requirements.txt** in the left-hand side menu, type in a new line, and
    type in **openai**. This is to ensure that the OpenAI library will be downloaded
    as part of this function.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧菜单中，转到**Requirements.txt**，输入一行新代码，输入**openai**。这样可以确保 OpenAI 库作为函数的一部分进行下载。
- en: 'For the actual *code block*, type in the following. This function takes in
    a city as an input and returns the itinerary in a morning-afternoon-evening format
    and three relevant images, one each for morning, afternoon, and evening, respectively:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于实际的*代码块*，请输入以下内容。此函数接受一个城市作为输入，并返回按早晨、下午、晚上的格式安排的行程，以及每个时段对应的三张相关图像：
- en: '[PRE4]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Select **Deploy**. You might need to wait 5 minutes for the deployment to fully
    complete. When you see the green checkmark on the **Cloud Functions** screen,
    your function has been successfully deployed.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**部署**。可能需要等待 5 分钟才能完成部署。当你在**Cloud Functions**页面看到绿色对勾时，表示函数已成功部署。
- en: Similar to the previous recipe, we will now use Postman to test the cloud function
    that we have just deployed. To do so, open Postman, select **New** at the top
    left, and then select **HTTP**.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似于之前的教程，我们现在将使用 Postman 测试刚刚部署的云函数。为此，打开 Postman，选择左上角的**新建**，然后选择**HTTP**。
- en: On the Postman request, select **Headers** and type in a new header, with **Key**
    equal to **Content-Type** and **Value** equal to **application/json**.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Postman 请求中，选择**Headers**并输入一个新标头，**Key**为**Content-Type**，**Value**为**application/json**。
- en: Change the request from **Get** to **Post** from the left-hand side drop-down
    menu. Copy the endpoint URL from the **Cloud Functions** page and paste it into
    Postman.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将请求从左侧下拉菜单中的**Get**更改为**Post**。复制**Cloud Functions**页面中的端点 URL，并将其粘贴到 Postman
    中。
- en: 'Select **Body**, then **Raw**, and copy and paste the following JSON request:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Body**，然后选择**Raw**，并复制粘贴以下 JSON 请求：
- en: '[PRE5]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![Figure 6.16 – Postman body](img/B21007_06_16.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.16 – Postman 请求体](img/B21007_06_16.jpg)'
- en: Figure 6.16 – Postman body
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.16 – Postman 请求体
- en: Note that because this is a long cloud function that makes several calls to
    OpenAI (for both text and images), this may take several minutes to complete.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于这是一个长时间运行的云函数，涉及多次调用 OpenAI（用于文本和图像），可能需要几分钟才能完成。
- en: 'Select **Send** to make the call to your cloud function. If all goes well,
    you should see a similar response to the one shown in *Figure 6**.17*, which contains
    several objects embedded in the JSON response:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**发送**，调用你的云函数。如果一切顺利，你应该会看到类似于*图 6.17*中展示的响应，其中包含嵌入在 JSON 响应中的多个对象：
- en: '![Figure 6.17 – Postman output](img/B21007_06_17.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.17 – Postman 输出](img/B21007_06_17.jpg)'
- en: Figure 6.17 – Postman output
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.17 – Postman 输出
- en: Navigate to [http://bubble.io](http://bubble.io) and log in. Select **Create
    an App** and give your app a relevant name. Select **Get Started** and then select
    **Start with Basic Features**. You can also click **Skip the application assistant**
    if you encounter the prompt.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[http://bubble.io](http://bubble.io)并登录。选择**创建应用**，为你的应用命名。选择**开始使用**，然后选择**从基本功能开始**。如果遇到提示，你也可以点击**跳过应用助手**。
- en: 'On the **Canvas** page, we are going to add a few elements that are required
    for our application. Add in an input by selecting **Input** from the left-hand
    side menu and then drawing a rectangle at the top left of the page. Then, add
    a button adjacent to it by selecting **Button** from the left-hand side menu and
    drawing it next to **Input**:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Canvas**页面中，我们将添加一些应用程序所需的元素。从左侧菜单中选择**Input**并在页面的左上角绘制一个矩形框来添加输入框。接着，选择左侧菜单中的**Button**并将其绘制在**Input**旁边，添加一个按钮：
- en: '![Figure 6.18 – Adding a button in Bubble](img/B21007_06_18.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.18 – 在 Bubble 中添加按钮](img/B21007_06_18.jpg)'
- en: Figure 6.18 – Adding a button in Bubble
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.18 – 在 Bubble 中添加按钮
- en: Double-click the **Input** element and in the property menu, replace **Placeholder**
    with **City**.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**Input**元素，在属性菜单中，将**Placeholder**替换为**城市**。
- en: Double-click the **Button** element and in the property menu, replace **Text**
    with **Plan Itinerary**.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**Button**元素，在属性菜单中，将**Text**替换为**计划行程**。
- en: Create a **Text** element and place it on the left-hand side of the page.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**Text**元素，并将其放置在页面的左侧。
- en: 'Next, we need to create three images. Select **Image** and put it on the right-hand
    side. Do this *three* times, creating *Image A*, *Image B*, and *Image C*. Verify
    that they are around the same size. You may need to drag and move the images around
    to verify this:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建三张图像。选择**Image**并将其放在页面右侧。重复这一过程 *三* 次，分别创建 *图像 A*、*图像 B* 和 *图像 C*。确保它们大小相同。你可能需要拖动并移动这些图像以确认这一点：
- en: '![Figure 6.19 – Adding images in Bubble](img/B21007_06_19.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.19 – 在 Bubble 中添加图像](img/B21007_06_19.jpg)'
- en: Figure 6.19 – Adding images in Bubble
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.19 – 在 Bubble 中添加图像
- en: Next, create **Custom states** for the **Text** and **Image** elements.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为**Text**和**Image**元素创建**自定义状态**。
- en: For each **Text** element, double-click the element to show the property menu.
    Then, click **Insert dynamic data** on the actual text field, select **Text**,
    and then **Create a new custom state**. You will be prompted for a name and type.
    For the name, type **itinerary_details**. For **Type**, ensure **Text** is selected.
    This will create a unique custom state for the text box, which is required to
    show the values in the application. The box will contain the itinerary details
    from the application.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个**Text**元素，双击该元素以显示属性菜单。然后，点击实际文本字段中的**插入动态数据**，选择**Text**，然后**创建新的自定义状态**。系统会提示你输入名称和类型。名称填写**itinerary_details**，类型选择**Text**。这将为文本框创建一个唯一的自定义状态，用于显示应用程序中的值。该框将包含应用程序中的行程详情。
- en: For each of the **Image** elements, double-click the element to show the property
    menu. Then, click **Insert dynamic data** where it says **Dynamic image**. Select
    **Image X**, then **Create a new custom state**. You will be prompted for a name
    and type. For the name, type in **img_url**. For **Type**, ensure **Text** is
    selected.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个**Image**元素，双击该元素以显示属性菜单。然后，点击**插入动态数据**，在**动态图像**的地方选择**Image X**，然后**创建新的自定义状态**。系统会提示你输入名称和类型。名称填写**img_url**，类型选择**Text**。
- en: 'The next thing we need to do is load the cloud function that we created into
    Bubble. Select **Plugins** from the left-hand side menu, and then select **Add
    Plugins**. Select **API Connector**, then **Install**, and then **Done**:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们需要做的是将我们创建的云函数加载到Bubble中。从左侧菜单中选择**插件**，然后选择**添加插件**。选择**API Connector**，然后点击**安装**，最后点击**完成**：
- en: '![Figure 6.20 - Bubble.io UI configuration](img/B21007_06_20.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图6.20 - Bubble.io UI 配置](img/B21007_06_20.jpg)'
- en: Figure 6.20 - Bubble.io UI configuration
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.20 - Bubble.io UI 配置
- en: 'Select **API Connector** from the list of plugins. Select **Add Another API**.
    For **API name**, type in **travel**. Scroll down until you get to the **Name**
    field and click **Expand**. Change the name of this API to **travel**. For the
    API, configure its settings like so:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从插件列表中选择**API Connector**。选择**添加另一个API**。对于**API名称**，输入**travel**。向下滚动直到找到**名称**字段并点击**展开**。将此API的名称更改为**travel**。对于该API，按如下方式配置其设置：
- en: From the **Use as** drop-down menu, select **Action**.
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从**用作**下拉菜单中选择**操作**。
- en: Change the request from **GET** to **POST**.
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将请求从**GET**更改为**POST**。
- en: Directly adjacent to the **POST** request is a place to enter your **Endpoint
    URL**. Enter the URL you copied from the Google cloud function.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧邻**POST**请求的是一个输入**Endpoint URL**的位置。输入你从Google云函数复制的URL。
- en: Create a **New Header** value. Select **Add Header**. Then, for **Key**, type
    **Content-Type**, and for **Value**, type **application/json**.
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**新头部**值。选择**添加头部**。然后，在**键**中输入**Content-Type**，在**值**中输入**application/json**。
- en: 'Add a parameter by clicking **Parameter**. For **Key**, type **city**. For
    **Value**, copy the same JSON text that was used in the Postman call, which was
    **Toronto, Canada**. Ensure that the **Private** box is *unchecked*:'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过点击**参数**添加一个参数。对于**键**，输入**city**。对于**值**，复制在Postman调用中使用的相同JSON文本，即**Toronto,
    Canada**。确保**私密**框已*未选中*：
- en: '![Figure 6.21 – Bubble API configurations](img/B21007_06_21.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图6.21 - Bubble API 配置](img/B21007_06_21.jpg)'
- en: Figure 6.21 – Bubble API configurations
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.21 - Bubble API 配置
- en: 'Select **Initialize Call** to test the API call. If you see the screen depicted
    in *Figure 6**.22*, then the call has been successful. Ensure that for each return
    object, the **Text** type has been selected. Then, click **Save**:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**初始化调用**以测试API调用。如果你看到屏幕中显示的*图6.22*，则说明调用已成功。确保每个返回对象都已选择**文本**类型。然后，点击**保存**：
- en: '![Figure 6.22 –  A successful UI configuration](img/B21007_06_22.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图6.22 - 成功的UI配置](img/B21007_06_22.jpg)'
- en: Figure 6.22 – A successful UI configuration
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.22 - 成功的UI配置
- en: Select **Design** from the left-hand side menu. Double-click the **Button**
    element that you created. In the property menu that appears, select **Add Workflow**.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧菜单中选择**设计**。双击你创建的**按钮**元素。在出现的属性菜单中，选择**添加工作流**。
- en: 'Select **Click here to add an action**. Then, go to **Plugins**, find the API
    you just created (**travel-travel**), and select it. From the property menu that
    appears, delete the content of **(param.) city** and then select **Insert dynamic
    data**. Scroll down, select **Input City here**, and then select **Value**:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**点击这里添加一个操作**。然后，前往**插件**，找到你刚刚创建的API（**travel-travel**），并选择它。在出现的属性菜单中，删除**（参数）city**的内容，然后选择**插入动态数据**。向下滚动，选择**在此输入城市**，然后选择**值**：
- en: '![Figure 6.23 – Adding dynamic data to an API call (1)](img/B21007_06_23.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图6.23 - 向API调用添加动态数据（1）](img/B21007_06_23.jpg)'
- en: Figure 6.23 – Adding dynamic data to an API call (1)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.23 - 向API调用添加动态数据（1）
- en: '![Figure 6.24 – Adding dynamic data to an API call (2)](img/B21007_06_24.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图6.24 - 向API调用添加动态数据（2）](img/B21007_06_24.jpg)'
- en: Figure 6.24 – Adding dynamic data to an API call (2)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.24 - 向API调用添加动态数据（2）
- en: Next, select **Click here to add an action** again, scroll down to **Element
    Actions**, and then select **Set State**. From the **Element** drop-down menu,
    select **Text A**. From the **Custom state** drop-down menu, select **itinerary_details**.
    For **Value**, select **Results of step 1** and then select **itinerary**. This
    will make the value of **Text A** equal to the itinerary value in the JSON object
    result of the API call to the cloud function that you created.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，再次选择**点击这里添加一个操作**，向下滚动到**元素操作**，然后选择**设置状态**。从**元素**下拉菜单中选择**Text A**。从**自定义状态**下拉菜单中选择**itinerary_details**。对于**值**，选择**步骤1的结果**，然后选择**itinerary**。这将使**Text
    A**的值等于从你创建的云函数API调用返回的JSON对象中的行程值。
- en: 'Next, select **Click here to add an action** again. Then scroll down to **Element
    Actions**, and then select **Set State**. From the **Element** drop-down menu,
    select **Image A**. From the **Custom state** drop-down menu, select **img_url**.
    For **Value**, select **Results of step 1** and then select **morning_image**.
    This will make **Image A** equal to the picture of **Morning Image**, which was
    returned in the cloud function, which was, in turn, returned from the OpenAI Images
    API:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，再次选择**点击此处添加操作**。然后向下滚动到**元素操作**，选择**设置状态**。在**元素**下拉菜单中，选择**Image A**。在**自定义状态**下拉菜单中，选择**img_url**。对于**值**，选择**步骤1的结果**，然后选择**morning_image**。这将使**Image
    A**等于云函数返回的**Morning Image**，该函数又是从OpenAI图像API返回的：
- en: '![Figure 6.25 – Assigning a custom state in Bubble](img/B21007_06_25.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图6.25 – 在Bubble中分配自定义状态](img/B21007_06_25.jpg)'
- en: Figure 6.25 – Assigning a custom state in Bubble
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.25 – 在Bubble中分配自定义状态
- en: Repeat *step 31* two more times for the **Image B** and **Image C** elements,
    choosing **afternoon_image** and **evening_image**, respectively.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*第31步*再重复两次，分别为**Image B**和**Image C**元素，选择**afternoon_image**和**evening_image**。
- en: We have completed everything we need for our Bubble intelligent application.
    To test if the application works, select **Preview** on the right; a new page
    will appear that contains your application.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经完成了构建Bubble智能应用程序所需的一切。为了测试应用程序是否正常工作，请点击右侧的**预览**；一个新页面将显示您的应用程序。
- en: In the **City** text box, type in any city you want (I have typed in Toronto,
    Canada). Then, select the **Plan Itinerary** button; this will start the Bubble
    workflow and call the cloud function.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**城市**文本框中，输入任何您想要的城市（我输入的是加拿大多伦多）。然后，点击**规划行程**按钮；这将启动Bubble工作流并调用云函数。
- en: 'If all goes well, you should get a screen like what’s shown in *Figure 6**.26*,
    which shows the travel itinerary, along with three images that correspond directly
    to what is stated in the itinerary:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该看到类似*图6.26*中所显示的屏幕，展示了旅行行程，并附带三张与行程内容直接对应的图片：
- en: '![Figure 6.26 – Output of the completed Bubble application](img/B21007_06_26.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图6.26 – 完成的Bubble应用程序输出](img/B21007_06_26.jpg)'
- en: Figure 6.26 – Output of the completed Bubble application
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.26 – 完成的Bubble应用程序输出
- en: How it works…
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: In this recipe, we created a travel itinerary app where a user can type in any
    location and the application will create a 1-day itinerary specific to that location,
    along with AI-generated photos that correspond to that itinerary. As mentioned
    previously, this is a *multi-modal* application as both the OpenAI Chat API and
    Images API were used to construct this application.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们创建了一个旅行行程应用程序，用户可以输入任何地点，应用程序将根据该地点生成一个1天的行程，并附带与该行程相对应的AI生成照片。如前所述，这是一个*多模态*应用程序，因为我们使用了OpenAI的聊天API和图像API来构建该应用程序。
- en: Configuring settings for a multi-modal application
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置多模态应用程序的设置
- en: Since this was a multi-modal application, there was one key difference when
    creating the backend Google cloud function. In particular, we set **Function Timeout**
    to 300 seconds (which is the max possible – by default, at the time of writing,
    it is 60 seconds). This timeout is crucial for ensuring the application can process
    and handle more complex or time-consuming tasks without prematurely terminating.
    Given the intricate nature of the multi-modal data being processed – combining
    text, images, and possibly even video content – the extended timeout allows for
    sufficient data parsing, analysis, and response generation. This adjustment also
    means that the backend can comfortably accommodate the occasional spikes in data
    volume or complexity, which is typical in a multi-modal setup, without compromising
    on performance or reliability.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个多模态应用程序，在创建后端Google云函数时有一个关键的不同之处。特别是，我们将**函数超时**设置为300秒（这是最大值——默认情况下，本文撰写时为60秒）。这个超时设置对于确保应用程序能够处理和处理更复杂或耗时的任务，而不会过早终止至关重要。考虑到处理的多模态数据的复杂性——包括文本、图像，甚至可能还有视频内容——延长的超时允许足够的数据解析、分析和响应生成。这一调整还意味着，后端可以舒适地应对数据量或复杂度偶尔的峰值，这在多模态设置中很常见，而不影响性能或可靠性。
- en: Code walk-through for the three OpenAI API calls
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三个OpenAI API调用的代码讲解
- en: The backend layer contains three interweaving OpenAI API calls, and it is worth
    going through each so that we can discuss exactly what is occurring in each step.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 后端层包含三个交织的OpenAI API调用，值得逐一讲解每个步骤，以便我们能够讨论每一步的具体内容。
- en: Call 1
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调用1
- en: '[PRE6]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is the standard GPT-4 chat call that we have made in previous recipes,
    but note that we have included a long *Chat Log* as part of the call. In particular,
    we gave OpenAI two examples of the input and output to effectively *fine-tune*
    the model:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在之前的配方中使用的标准GPT-4聊天调用，但请注意，我们在调用中包含了一个较长的*聊天记录*。特别是，我们给OpenAI提供了两个输入和输出示例，以有效地*微调*模型：
- en: '| **Input** | **Output** |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| **输入** | **输出** |'
- en: '| --- | --- |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Rome, Italy` |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `意大利罗马` |'
- en: '[PRE7]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Lisbon, Portugal` |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `葡萄牙里斯本` |'
- en: '[PRE11]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: In [*Chapter 1*](B21007_01.xhtml#_idTextAnchor021), [*Chapter 2*](B21007_02.xhtml#_idTextAnchor044),
    and [*Chapter 4*](B21007_04.xhtml#_idTextAnchor074), we learned how `itinerary`
    variable.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B21007_01.xhtml#_idTextAnchor021)、[*第2章*](B21007_02.xhtml#_idTextAnchor044)和[*第4章*](B21007_04.xhtml#_idTextAnchor074)中，我们学习了如何使用`行程`变量。
- en: Call 2
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调用2
- en: 'In the second call, we request the OpenAI API to create image-generating (DALL-E)
    prompts based on the itinerary that was produced by the previous call. Specifically,
    three DALL-E prompts are produced (one for morning, one for afternoon, and one
    for evening) that are separated by a pipe (`|`):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次调用中，我们请求OpenAI API根据前一个调用生成的行程创建图像生成（DALL-E）提示。具体来说，生成了三个DALL-E提示（一个用于早晨，一个用于下午，一个用于晚上），它们由竖线（`|`）分隔：
- en: '[PRE15]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that, in this case, we have changed the model from `gpt-4` to `gpt-3.5-turbo-1106`.
    We discussed when to use what model in [*Chapter 3*](B21007_03.xhtml#_idTextAnchor060),
    and in this case, GPT-3.5 is perfect as the instruction itself is simple and not-nuanced
    and it’s far cheaper. Additionally, even if it does hallucinate, the user never
    sees the output of this call – they just see the resulting image generation for
    DALL-E.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这种情况下，我们已将模型从`gpt-4`更改为`gpt-3.5-turbo-1106`。我们在[*第3章*](B21007_03.xhtml#_idTextAnchor060)中讨论了何时使用哪种模型，在这种情况下，GPT-3.5是完美的，因为指令本身简单且不复杂，而且它的成本要低得多。此外，即使它出现幻觉，用户也不会看到此调用的输出——他们只会看到DALL-E生成的图像。
- en: Call 3
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调用3
- en: '[PRE16]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the last call, we cycle through each of the three DALL-E prompts that were
    generated in the previous call and pass them to the OpenAI Images API. We do this
    through a **for loop**. In Python, a for loop is a programming structure that
    allows us to execute a block of code multiple times, usually with some variation
    in each iteration. In this context, we systematically process each DALL-E prompt.
    With each iteration, the loop takes a prompt from the list, sends it to the OpenAI
    Images API, and then moves to the next prompt until all prompts have been processed.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一次调用中，我们遍历了前一次调用中生成的三个DALL-E提示，并将它们传递给OpenAI图像API。我们通过**for循环**来完成这一操作。在Python中，for循环是一种编程结构，允许我们多次执行一个代码块，通常每次迭代时会有所变化。在这个上下文中，我们系统地处理每个DALL-E提示。每次迭代时，循环从列表中取出一个提示，发送到OpenAI图像API，然后继续处理下一个提示，直到所有提示都被处理完毕。
- en: 'Note that instead of using the `client.chat` library, we are using the `client.images`
    library as we need to use DALL-E to generate images. We store each output in a
    list variable called `image_urls`. This is then returned by our Google cloud function,
    with the following JSON structure:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不是使用`client.chat`库，而是使用`client.images`库，因为我们需要使用DALL-E来生成图像。我们将每个输出存储在一个名为`image_urls`的列表变量中。然后，这些输出通过我们的Google云函数返回，返回的JSON结构如下：
- en: '[PRE17]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this recipe, we created an intelligent application that combines multiple
    models, multiple API calls, and fine-tuning concepts. Overall, in this chapter,
    we built two impactful applications in less than a few hours.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们创建了一个智能应用程序，结合了多个模型、多个API调用和微调概念。总体而言，在本章中，我们在不到几小时的时间里构建了两个具有影响力的应用程序。
