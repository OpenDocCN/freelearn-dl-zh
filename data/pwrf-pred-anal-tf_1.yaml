- en: Chapter 1. From Data to Decisions – Getting Started with TensorFlow
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章 从数据到决策——开始使用 TensorFlow
- en: Despite the huge availability of data and significant investments, many business
    organizations still go on gut feel because they neither make the proper use of
    the data nor do they take appropriate and effective business decisions. TensorFlow,
    on the other hand, can be used to help take the business decision from this huge
    collection of data. TensorFlow is mathematical software and an open source software
    library for Machine Intelligence, developed in 2011 by the Google Brain Team and
    it can be used to help us analyze data to predict the effective business outcome.
    Although the initial target of TensorFlow was to conduct research in machine learning
    and in deep neural networks, however, the system is general enough to be applicable
    in a wide variety of other domains as well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数据的巨大可用性和大量投资，许多商业组织仍然依赖直觉，因为他们既没有充分利用数据，也没有做出适当且有效的商业决策。另一方面，TensorFlow 可以帮助从这庞大的数据集合中做出商业决策。TensorFlow
    是一款数学软件，是由 Google Brain 团队在 2011 年开发的开源机器智能软件库，它可以帮助我们分析数据并预测有效的商业结果。虽然 TensorFlow
    的初衷是进行机器学习和深度神经网络的研究，但该系统足够通用，能够应用于各种其他领域。
- en: Keeping in mind your needs and based on all the latest and exciting features
    of TensorFlow 1.x, in this lesson, we will give a description of the main TensorFlow
    capabilities that are mostly motivated by a real-life example using the data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记您的需求，并基于 TensorFlow 1.x 的所有最新且令人兴奋的特性，在本课程中，我们将描述 TensorFlow 的主要功能，这些功能大多通过使用数据的实际例子来激励。
- en: 'The following topics will be covered in this lesson:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本课程将涵盖以下主题：
- en: 'From data to decision: Titanic example'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据到决策：泰坦尼克号例子
- en: General overview of TensorFlow
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TensorFlow 概述
- en: Installing and configuring TensorFlow
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装与配置 TensorFlow
- en: TensorFlow computational graph
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TensorFlow 计算图
- en: TensorFlow programming model
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TensorFlow 编程模型
- en: TensorFlow data model
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TensorFlow 数据模型
- en: Visualizing through TensorBoard
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 TensorBoard 可视化
- en: 'Getting started with TensorFlow: linear regression and beyond'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 TensorFlow：线性回归及其应用
- en: Taking Decisions Based on Data – Titanic Example
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于数据做决策——泰坦尼克号例子
- en: The growing demand for data is a key challenge. Decision support teams such
    as institutional research and business intelligence often cannot take the right
    decisions on how to expand their business and research outcomes from a huge collection
    of data. Although data plays an important role in driving the decision, however,
    in reality, taking the right decision at right time is the goal.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对数据需求的日益增加是一个关键挑战。决策支持团队，如机构研究和商业智能，通常无法在大量数据中做出关于如何扩展业务和研究成果的正确决策。尽管数据在推动决策方面起着重要作用，但实际上，正确的决策是在正确的时间做出的目标。
- en: In other words, the goal is the decision support, not the data support. This
    can be achieved through an advanced use of data management and analytics.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，目标是决策支持，而非数据支持。通过高级的数据管理和分析方法可以实现这一目标。
- en: Data Value Chain for Making Decisions
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据价值链与决策制定
- en: 'The following diagram in figure 1 (source: *H. Gilbert Miller and Peter Mork,
    From Data to Decisions: A Value Chain for Big Data, Proc. Of IT Professional,
    Volume: 15, Issue: 1, Jan.-Feb. 2013, DOI: 10.1109/MITP.2013.11*) shows the data
    chain towards taking actual decisions–that is, the goal. The value chains start
    through the data discovery stage consisting of several steps such as data collection
    and annotating data preparation, and then organizing them in a logical order having
    the desired flow. Then comes the data integration for establishing a common data
    representation of the data. Since the target is to take the right decision, for
    future reference having the appropriate provenance of the data–that is, where
    it comes from, is important:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '图 1 中的下图（来源：*H. Gilbert Miller 和 Peter Mork，From Data to Decisions: A Value
    Chain for Big Data，IT Professional，2013 年 1 月 - 2 月，卷：15，期：1，DOI：10.1109/MITP.2013.11*）展示了从数据到实际决策的链条——即目标。价值链从数据发现阶段开始，包含多个步骤，如数据收集和注释数据准备，然后按逻辑顺序组织它们，确保所需的数据流。接着是数据集成，用于建立数据的共同表示。由于目标是做出正确的决策，因此，未来参考时，拥有适当的数据来源（即数据的来源）非常重要：'
- en: '![Data Value Chain for Making Decisions](img/01_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![数据价值链与决策制定](img/01_01.jpg)'
- en: 'Figure 1: From data to decisions: a value chain for big data'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1：从数据到决策：大数据的价值链
- en: Well, now your data is somehow integrated into a presentable format, it's time
    for the data exploration stage, which consists of several steps such as analyzing
    the integrated data and visualization before taking the actions to take on the
    basis of the interpreted results.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的数据已经以某种方式集成到一个可呈现的格式中，是时候进入数据探索阶段了，该阶段包括多个步骤，如分析集成数据和可视化，之后根据解读结果采取相应的行动。
- en: However, is this enough before taking the right decision? Probably not! The
    reason is that it lacks enough analytics, which eventually helps to take the decision
    with an actionable insight. Predictive analytics comes in here to fill the gap
    between. Now let's see an example of how in the following section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在做出正确决策之前，这就足够了吗？可能不够！原因在于，它缺乏足够的分析，这最终有助于通过可操作的洞察力做出决策。此时，预测分析介入，填补了其中的空白。现在让我们在接下来的部分中看看一个例子。
- en: From Disaster to Decision – Titanic Survival Example
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从灾难到决策 – Titanic生存案例
- en: 'Here is the challenge, Titanic–Machine Learning from Disaster from Kaggle ([https://www.kaggle.com/c/titanic](https://www.kaggle.com/c/titanic)):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是挑战，来自Kaggle的Titanic–机器学习从灾难中（[https://www.kaggle.com/c/titanic](https://www.kaggle.com/c/titanic)）：
- en: '*"The sinking of the RMS Titanic is one of the most infamous shipwrecks in
    history. On April 15, 1912, during her maiden voyage, the Titanic sank after colliding
    with an iceberg, killing 1502 out of 2224 passengers and crew. This sensational
    tragedy shocked the international community and led to better safety regulations
    for ships. One of the reasons that the shipwreck led to such loss of life was
    that there were not enough lifeboats for the passengers and crew. Although there
    was some element of luck involved in surviving the sinking, some groups of people
    were more likely to survive than others, such as women, children, and the upper-class.
    In this challenge, we ask you to complete the analysis of what sorts of people
    were likely to survive. In particular, we ask you to apply the tools of machine
    learning to predict which passengers survived the tragedy."*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*"RMS Titanic的沉没是历史上最臭名昭著的船难之一。1912年4月15日，在她的处女航行中，Titanic与冰山相撞后沉没，造成2224名乘客和船员中1502人死亡。这个震惊国际社会的悲剧促使了更严格的船只安全规定。船难导致如此多人死亡的原因之一是船上没有足够的救生艇供乘客和船员使用。虽然幸存者中有些人是因为运气因素，但某些群体比其他人更可能生还，例如妇女、儿童和上层阶级。在这个挑战中，我们要求你完成对哪些人更可能幸存的分析。特别地，我们要求你应用机器学习工具来预测哪些乘客在这场悲剧中幸存。"*'
- en: But going into this deeper, we need to know about the data of passengers travelling
    in the Titanic during the disaster so that we can develop a predictive model that
    can be used for survival analysis.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但深入研究这一点，我们需要了解在灾难中乘坐Titanic的乘客数据，以便我们可以开发一个可用于生存分析的预测模型。
- en: 'The dataset can be downloaded from the preceding URL. Table 1 here shows the
    metadata about the Titanic survival dataset:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集可以从前述网址下载。表1显示了Titanic生存数据集的元数据：
- en: '![From Disaster to Decision – Titanic Survival Example](img/01_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![从灾难到决策 – Titanic生存案例](img/01_02.jpg)'
- en: 'A snapshot of the dataset can be seen as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集的快照如下所示：
- en: '![From Disaster to Decision – Titanic Survival Example](img/01_03.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![从灾难到决策 – Titanic生存案例](img/01_03.jpg)'
- en: 'Figure 2: A snapshot of the Titanic survival dataset'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：Titanic生存数据集快照
- en: 'The ultimate target of using this dataset is to predict what kind of people
    survived the Titanic disaster. However, a bit of exploratory analysis of the dataset
    is a mandate. At first, we need to import necessary packages and libraries:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该数据集的最终目标是预测哪些人幸存于Titanic灾难。然而，稍微进行一些数据集的探索性分析是必要的。首先，我们需要导入必要的软件包和库：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now read the dataset and create a panda''s DataFrame:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在读取数据集并创建一个Pandas的DataFrame：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Before drawing the distribution of the dataset, let''s specify the parameters
    for the graph:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制数据集的分布之前，让我们先指定图表的参数：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Draw a bar diagram for showing who survived versus who did not:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制一个柱状图，显示谁幸存了与谁没有幸存：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Plot a graph showing survival by `Age`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制一个显示`年龄`与生存情况的图表：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Plot a graph showing distribution of the `passengers` classes:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制一个显示`乘客`类别分布的图表：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Plot a kernel density estimate of the subset of the 1st class passengers''
    age:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制1等舱乘客年龄子集的核密度估计图：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Plot a graph showing `passengers per boarding location`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制一个显示`每个登船地点的乘客`的图表：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The figure shows the survival distribution, survival by age, age distribution,
    and the passengers per boarding location:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图表显示了生存分布、年龄生存率、年龄分布以及每个登船地点的乘客数量：
- en: '![From Disaster to Decision – Titanic Survival Example](img/01_04.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![从灾难到决策 – 泰坦尼克号生存案例](img/01_04.jpg)'
- en: 'Figure 3: Titanic survival data distribution across age, class, and age within
    classes and boarding location'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '图3: 泰坦尼克号生存数据在年龄、舱位和各舱位内年龄分布以及登船地点上的分布'
- en: 'However, to execute the preceding code, you need to install several packages
    such as matplotlib, pandas, and scipy. They are listed as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要执行上述代码，您需要安装几个包，例如matplotlib、pandas和scipy。它们列在下面：
- en: '**Installing pandas**: Pandas is a Python package for data manipulation. It
    can be installed as follows:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安装pandas**: Pandas是用于数据操作的Python包。可以按以下步骤安装：'
- en: '[PRE8]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Installing matplotlib**: In the preceding code, matplotlib is a plotting
    library for mathematical objects. It can be installed as follows:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安装matplotlib**: 在上述代码中，matplotlib是用于数学对象绘图的库。可以按以下步骤安装：'
- en: '[PRE9]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Installing scipy**: Scipy is a Python package for scientific computing. Installing
    `blas` and `lapack`and `gfortran` are a prerequisite for this one. Now just execute
    the following command on your terminal:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安装scipy**: Scipy是用于科学计算的Python包。安装`blas`、`lapack`和`gfortran`是其先决条件。现在只需在您的终端上执行以下命令：'
- en: '[PRE10]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For Mac, use the following command to install the above modules:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Mac，请使用以下命令安装上述模块：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For windows, I am assuming that Python 2.7 is already installed at C:\Python27\.
    Then open the command prompt and type the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows，我假设Python 2.7已经安装在C:\Python27\。然后打开命令提示符并键入以下命令：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For Python3, issue the following commands:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python3，请发出以下命令：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Well, we have seen the data. Now it's your turn to do some analytics on top
    of the data. Say predicting what kinds of people survived from that disaster.
    Don't you agree that we have enough information about the passengers, but how
    could we do the predictive modeling so that we can draw some fairly straightforward
    conclusions from this data?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们已经看过数据了。现在轮到你对数据进行一些分析了。比如预测哪些人从那场灾难中幸存下来了。你不觉得我们已经有足够的乘客信息了吗？但是如何进行预测建模，以便我们可以从这些数据中得出一些相当直接的结论呢？
- en: For example, say being a woman, being in 1st class, and being a child were all
    factors that could boost passenger chances of survival during this disaster.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，女性、一等舱乘客和儿童在这次灾难中生存的可能性更高。
- en: In a brute-force approach–for example, using if/else statements with some sort
    of weighted scoring system, you could write a program to predict whether a given
    passenger would survive the disaster. However, does writing such a program in
    Python make much sense? Naturally, it would be very tedious to write, difficult
    to generalize, and would require extensive fine tuning for each variable and samples
    (that is, passenger).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在一种蛮力方法中，例如使用if/else语句和某种加权评分系统，您可以编写一个程序，以预测给定乘客是否会在灾难中生存。然而，在Python中编写这样的程序是否有多大意义呢？自然地，这将非常繁琐，难以泛化，并且需要对每个变量和样本（即乘客）进行广泛的微调。
- en: This is where predictive analytics with machine learning algorithms and emerging
    tools comes in so that you could build a program that learns from the sample data
    to predict whether a given passenger would survive. In such cases, we will see
    throughout this book that TensorFlow could be a perfect solution to achieve outstanding
    accuracies across your predictive models. We will start describing the general
    overview of the TensorFlow framework. Then we will show how to install and configure
    TensorFlow on Linux, Mac OS and Windows.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是预测分析与机器学习算法及新兴工具的应用，使您可以构建一个程序，从样本数据中学习，预测给定乘客是否会生存。在本书中，我们将看到TensorFlow能够成为实现预测模型卓越准确性的完美解决方案。我们将开始描述TensorFlow框架的概要，然后展示如何在Linux、Mac
    OS和Windows上安装和配置TensorFlow。
- en: General Overview of TensorFlow
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TensorFlow框架的概述
- en: TensorFlow is an open source framework from Google for scientific and numerical
    computation based on dataflow graphs that stand for the TensorFlow's execution
    model. The dataflow graphs used in TensorFlow help the machine learning experts
    to perform more advanced and intensive training on the data for developing deep
    learning and predictive analytics models. In 2015, Google open sourced the TensorFlow
    and all of its reference implementation and made all the source code available
    on GitHub under the Apache 2.0 license. Since then, TensorFlow has achieved wide
    adoption from academia and research to the industry, and following that recently
    the most stable version 1.x has been released with a unified API.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow是谷歌推出的一个开源框架，用于基于数据流图进行科学计算和数值计算，数据流图代表了TensorFlow的执行模型。TensorFlow中使用的数据流图帮助机器学习专家在数据上进行更高级、更密集的训练，以开发深度学习和预测分析模型。2015年，谷歌将TensorFlow及其所有参考实现开源，并将所有源代码以Apache
    2.0许可证发布到GitHub上。从那时起，TensorFlow得到了学术界、研究界和工业界的广泛采用，最近发布了稳定的1.x版本，并且具有统一的API。
- en: As the name TensorFlow implies, operations are performed by neural networks
    on multidimensional data arrays (aka flow of tensors). This way, TensorFlow provides
    some widely used and robust implementation linear models and deep learning algorithms.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称TensorFlow所暗示的那样，操作是由神经网络在多维数据数组上执行的（也就是张量流）。通过这种方式，TensorFlow提供了一些广泛使用且稳健的线性模型和深度学习算法实现。
- en: Deploying a predictive or general purpose model using TensorFlow is pretty straightforward.
    The thing is that once you have constructed your neural networks model after necessary
    feature engineering, you can simply perform the training interactively using plotting
    or TensorBoard (we will see more on it in upcoming sections). Finally, you deploy
    it eventually after evaluating it by feeding it some test data.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TensorFlow部署预测模型或通用模型是相当简单的。关键是，一旦你构建了神经网络模型并完成必要的特征工程，就可以通过交互式训练（使用绘图或TensorBoard进行）来进行训练（我们将在接下来的部分看到更多内容）。最后，在通过一些测试数据进行评估后，你可以将模型部署到实际环境中。
- en: Since we are talking about the dataflow graphs, nodes in a flow graph correspond
    to the mathematical operations, such as addition, multiplication, matrix factorization,
    and so on, whereas, edges correspond to tensors that ensure communication between
    edges and nodes, that is dataflow and controlflow.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们在谈论数据流图，流图中的节点对应于数学运算，如加法、乘法、矩阵分解等，而边则对应于张量，确保边与节点之间的通信，即数据流和控制流。
- en: You can perform the numerical computation on a CPU. Nevertheless, using TensorFlow,
    it is also possible to distribute the training across multiple devices on the
    same system and train on them, especially if you have more than one GPU on your
    system so that these can share the computational load. But the precondition is
    if TensorFlow can access these devices, it will automatically distribute the computations
    to the multiple devices via a greedy process. But TensorFlow also allows the program,
    to specify which operations will be on which devices via name scope placement.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在CPU上执行数值计算。然而，使用TensorFlow，你也可以将训练分布到同一系统上的多个设备，并在这些设备上进行训练，特别是如果你的系统有多个GPU，可以共享计算负载。但前提是TensorFlow能访问这些设备，它会通过贪婪的方式自动将计算分配到多个设备上。TensorFlow也允许程序指定哪些操作会在哪些设备上执行，这通过命名作用域进行分配。
- en: The APIs in TensorFlow 1.x have changed in ways that are not all backward compatible.
    That is, TensorFlow programs that worked on TensorFlow 0.x won't necessarily work
    on TensorFlow 1.x.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow 1.x中的API发生了变化，这些变化并非完全向后兼容。也就是说，之前在TensorFlow 0.x上运行的TensorFlow程序不一定能在TensorFlow
    1.x上运行。
- en: 'The main features offered by the latest release of TensorFlow are:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow最新版本提供的主要功能包括：
- en: '**Faster computing**: The latest release of TensorFlow is incredibly faster.
    For example, it is 7.3 times faster on 8 GPUs for Inception v3 and 58 times speedup
    for distributed inception (v3 training on 64 GPUs).'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快的计算**：TensorFlow的最新版本极其快速。例如，Inception v3在8个GPU上速度提高了7.3倍，分布式Inception（在64个GPU上进行v3训练）的速度提升达58倍。'
- en: '**Flexibility**: TensorFlow is not just a deep learning library, but it comes
    with almost everything you need for powerful mathematical operations through functions
    for solving the most difficult problems. TensorFlow 1.x introduces some high-level
    APIs for high-dimensional arrays or tensors, with `tf.layers`, `tf.metrics`, `tf.losses`,
    and `tf.keras` modules. These have made TensorFlow very suitable for high-level
    neural networks computing.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：TensorFlow不仅仅是一个深度学习库，它还提供了几乎所有你需要的功能，通过函数解决最困难的问题，进行强大的数学运算。TensorFlow
    1.x引入了一些高层次的API，用于处理高维数组或张量，包含`tf.layers`、`tf.metrics`、`tf.losses`和`tf.keras`模块。这些功能使得TensorFlow非常适合高层次的神经网络计算。'
- en: '**Portability**: TensorFlow runs on Windows, Linux, and Mac machines and on
    mobile computing platforms (that is, Android).'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植性**：TensorFlow可以在Windows、Linux和Mac机器以及移动计算平台（即Android）上运行。'
- en: '**Easy** **debugging**: TensorFlow provides the TensorBoard tool for the analysis
    of the developed models.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于调试**：TensorFlow提供了TensorBoard工具，用于分析已开发的模型。'
- en: '**Unified** **API**: TensorFlow offers you a very flexible architecture that
    enables you to deploy computation to one or more CPUs or GPUs in a desktop, server,
    or mobile device with a single API.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一** **API**：TensorFlow提供了非常灵活的架构，使得您可以通过一个API将计算部署到桌面、服务器或移动设备上的一个或多个CPU或GPU上。'
- en: '**Transparent** **use** **of** **GPU** **computing**: Automating management
    and optimization of the same memory and the data used. You can now use your machine
    for large-scale and data-intensive GPU computing with NVIDIA cuDNN and CUDA toolkits.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**透明** **使用** **GPU** **计算**：自动管理和优化相同的内存和数据。现在，您可以使用NVIDIA cuDNN和CUDA工具包，在机器上进行大规模和数据密集型的GPU计算。'
- en: '**Easy** **use**: TensorFlow is for everyone, it''s for students, researchers,
    deep learning practitioners, and also for readers of this book.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于使用**：TensorFlow适合每个人，适合学生、研究人员、深度学习从业者，也适合本书的读者。'
- en: '**Production** **ready** **at** **scale**: Recently it has evolved as the neural
    network for machine translation, at production scale. TensorFlow 1.x promises
    Python API stability, making it easier to choose new features without worrying
    too much about breaking your existing code.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产就绪** **并且** **可扩展**：它最近已经发展为一种用于机器翻译的神经网络，并且可以在生产规模下运行。TensorFlow 1.x保证了Python
    API的稳定性，使得选择新功能变得更加容易，无需过多担心现有代码的破坏。'
- en: '**Extensibility**: TensorFlow is relatively newer technology and it''s still
    under active development. However, it is extensible because it was released with
    source code available on GitHub ([https://github.com/tensorflow/tensorflow](https://github.com/tensorflow/tensorflow)).'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：TensorFlow是一项相对较新的技术，仍在积极开发中。然而，它具有可扩展性，因为它以开源代码的形式发布在GitHub上（[https://github.com/tensorflow/tensorflow](https://github.com/tensorflow/tensorflow)）。'
- en: '**Supported**: There is a large community of developers and users working together
    to make TensorFlow a better product, both by providing feedback and by actively
    contributing to the source code.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持**：有一个庞大的开发者和用户社区在共同努力，使TensorFlow成为一个更好的产品，既通过提供反馈，也通过积极贡献源代码。'
- en: '**Wide** **adoption**: Numerous tech giants are using TensorFlow for increasing
    their business intelligence. For example, ARM, Google, Intel, eBay, Qualcomm,
    SAM, Drobox, DeepMind, Airbnb, Twitter, and so on.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广泛应用**：众多科技巨头正在使用TensorFlow来提升他们的商业智能。例如，ARM、Google、Intel、eBay、Qualcomm、SAM、Dropbox、DeepMind、Airbnb、Twitter等。'
- en: Throughout the next lesson, we will see how to achieve these features for predictive
    analytics.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的课程中，我们将看到如何实现这些预测分析功能。
- en: Installing and Configuring TensorFlow
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置TensorFlow
- en: You can install and use TensorFlow on a number of platforms such as Linux, Mac
    OS, and Windows. Moreover, you can also build and install TensorFlow from the
    latest GitHub source of TensorFlow. Furthermore, if you have a Windows machine,
    you can install TensorFlow via native pip or Anacondas. It is to be noted that
    TensorFlow supports Python 3.5.x and 3.6.x on Windows.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在多个平台上安装和使用TensorFlow，例如Linux、Mac OS和Windows。此外，您还可以从TensorFlow的最新GitHub源代码构建并安装TensorFlow。此外，如果您使用的是Windows机器，可以通过原生pip或Anaconda安装TensorFlow。需要注意的是，TensorFlow在Windows上支持Python
    3.5.x和3.6.x。
- en: Also, Python 3 comes with the pip3 package manager, which is the program you'll
    use to install TensorFlow. So you don't need to install pip if you're using this
    Python version. For simplicity, in this section, I will show you how to install
    TensorFlow using native pip. Now to install TensorFlow, start a terminal. Then
    issue the appropriate `pip3 install`command in that terminal.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，Python 3附带了pip3包管理器，这是你将用来安装TensorFlow的程序。所以，如果你使用的是此版本的Python，就无需单独安装pip。为了简便起见，在本节中，我将展示如何使用原生pip安装TensorFlow。现在，为了安装TensorFlow，启动终端，然后在终端中输入相应的`pip3
    install`命令。  '
- en: 'To install the CPU-only version of TensorFlow, enter the following command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 若要安装仅支持CPU版本的TensorFlow，请输入以下命令：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To install the GPU version of TensorFlow, enter the following command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 若要安装TensorFlow的GPU版本，请输入以下命令：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When it comes to Linux, the TensorFlow Python API supports Python 2.7 and Python
    3.3+, so you need to install Python to start the TensorFlow installation. You
    must install Cuda Toolkit 7.5 and cuDNN v5.1+ to get the GPU support. In this
    section, we will show you how to install and get started with TensorFlow. More
    details on installing TensorFlow on Linux will be shown.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到Linux时，TensorFlow的Python API支持Python 2.7和Python 3.3以上版本，因此你需要安装Python来开始安装TensorFlow。为了获得GPU支持，你必须安装Cuda
    Toolkit 7.5和cuDNN v5.1以上版本。在本节中，我们将向你展示如何安装并开始使用TensorFlow。更多关于在Linux上安装TensorFlow的详细信息将在后续展示。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Installing on Mac OS is more or less similar to Linux. Please refer to the [https://www.tensorflow.org/install/install_mac](https://www.tensorflow.org/install/install_mac)
    for more details. On the other hand, Windows users should refer to [https://www.tensorflow.org/install/install_windows](https://www.tensorflow.org/install/install_windows).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac OS上的安装与Linux类似。有关更多详情，请参阅[https://www.tensorflow.org/install/install_mac](https://www.tensorflow.org/install/install_mac)。另一方面，Windows用户应参阅[https://www.tensorflow.org/install/install_windows](https://www.tensorflow.org/install/install_windows)。
- en: Note that for this and the rest of the lesson, we will provide most of the source
    codes with Python 3.x compatible.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在本课程的这一部分及后续部分，我们将提供大多数源代码，这些代码兼容Python 3.x。
- en: Installing TensorFlow on Linux
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Linux上安装TensorFlow
- en: In this section, we will show you how to install TensorFlow on Ubuntu 14.04
    or higher. The instructions presented here also might be applicable for other
    Linux distributions with minimal adjustments.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向你展示如何在Ubuntu 14.04或更高版本上安装TensorFlow。这里提供的说明也可能适用于其他Linux发行版，只需进行一些小的调整。
- en: 'However, before proceeding with formal steps, we need to determine which TensorFlow
    to install on your platform. TensorFlow has been developed such that you can run
    data intensive tensor applications on a GPU as well as a CPU. Thus, you should
    choose one of the following types of TensorFlow to install on your platform:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在正式开始之前，我们需要确定在你的平台上安装哪个版本的TensorFlow。TensorFlow的开发使得你可以在GPU和CPU上运行数据密集型的张量应用。因此，你应选择以下类型之一的TensorFlow进行安装：
- en: '**TensorFlow** **with** **CPU** **support** **only**: If there is no GPU such
    as NVIDIA® installed on your machine, you must install and start computing using
    this version. This is very easy and you can do it in just 5 to 10 minutes.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅支持CPU的TensorFlow**：如果你的机器上没有安装类似NVIDIA®的GPU，你必须安装并使用此版本进行计算。这非常简单，你只需5到10分钟即可完成。'
- en: '**TensorFlow** **with** **GPU** **support**: As you might know, a deep learning
    application requires typically very high intensive computing resources. Thus TensorFlow
    is no exception, but can typically speed up the data computation and analytics
    significantly faster on a GPU rather than on a CPU. Therefore, if there''s NVIDIA®
    GPU hardware on your machine, you should ultimately install and use this version.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持GPU的TensorFlow**：正如你所知，深度学习应用通常需要非常高强度的计算资源。因此，TensorFlow也不例外，但通常在GPU上进行数据计算和分析比在CPU上快得多。因此，如果你的机器上有NVIDIA®
    GPU硬件，你最终应该安装并使用此版本。'
- en: From our experience, even if you have NVIDIA GPU hardware integrated on your
    machine, it would be worth installing and trying the CPU-only version first and
    if you don't experience good performance you should switch for GPU support then.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的经验，即使你的机器上集成了NVIDIA GPU硬件，首先安装并尝试仅支持CPU的版本也是值得的。如果你没有获得良好的性能，再切换到GPU支持版本。
- en: The GPU-enabled version of TensorFlow has several requirements such as 64-bit
    Linux, Python 2.7 (or 3.3+ for Python 3), NVIDIA CUDA® 7.5 or higher (CUDA 8.0
    required for Pascal GPUs), and NVIDIA cuDNN v4.0 (minimum) or v5.1 (recommended).
    More specifically, the current development of TensorFlow supports only GPU computing
    using NVIDIA toolkits and software. Therefore, the following software must have
    to be installed on your Linux machine to get the GPU support on your predictive
    analytics applications:.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow 的GPU支持版本有几个要求，如64位Linux、Python 2.7（或Python 3的3.3及更高版本）、NVIDIA CUDA®
    7.5或更高版本（Pascal GPU需要CUDA 8.0）、NVIDIA cuDNN v4.0（最低要求）或v5.1（推荐）。更具体地说，TensorFlow的当前开发版本仅支持使用NVIDIA工具包和软件进行GPU计算。因此，必须在Linux机器上安装以下软件，以便为预测分析应用程序提供GPU支持：
- en: Python
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python
- en: NVIDIA Driver
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NVIDIA 驱动程序
- en: CUDA with **compute capability >= 3.0**
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算能力 >= 3.0** 的CUDA'
- en: CudNN
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cuDNN
- en: TensorFlow
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TensorFlow
- en: Installing Python and nVidia Driver
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Python和nVidia驱动程序
- en: We have already seen how to install Python on a different platform, so we can
    skip this one. Also, I'm assuming that your machine already has a NVIDIA GPU installed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解如何在不同平台上安装Python，因此可以跳过这一步。同时，我假设您的机器上已经安装了NVIDIA GPU。
- en: 'To find out if your GPU is really installed properly and working, issue the
    following command on the terminal:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查GPU是否安装正确并正常工作，可以在终端中输入以下命令：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since predictive analytics largely depend on machine learning and deep learning
    algorithms, make sure you check that some essential packages are installed on
    your machine such as GCC and some of the scientific Python packages.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于预测分析在很大程度上依赖于机器学习和深度学习算法，因此请确保在机器上安装了一些基本的软件包，如GCC和一些科学Python包。
- en: 'Simply issue the following command for doing so on the terminal:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在终端中输入以下命令即可：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now download the NVIDIA driver (don''t forget to choose the right version for
    your machine) via `wget` and run the script in silent mode:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过`wget`下载NVIDIA驱动程序（别忘了选择适合您机器的版本），并以静默模式运行脚本：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some GPU cards such as NVidia GTX 1080 comes with the built in–driver. Thus,
    if your machine has a different GPU other than the GTX 1080, you have to download
    the driver for that GPU.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一些GPU卡，如NVIDIA GTX 1080，配有内置驱动程序。因此，如果您的机器使用的是不同于GTX 1080的GPU，您需要下载该GPU的驱动程序。
- en: 'To make sure if the driver was installed correctly, issue the following command
    on the terminal:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要确认驱动程序是否正确安装，请在终端中输入以下命令：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The outcome of the command should be as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出结果应如下所示：
- en: '![Installing Python and nVidia Driver](img/01_05.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![安装 Python 和 NVIDIA 驱动](img/01_05.jpg)'
- en: 'Figure 4: Outcome of the nvidia-smi command'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：nvidia-smi命令的输出结果
- en: Installing NVIDIA CUDA
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装NVIDIA CUDA
- en: 'To use TensorFlow with NVIDIA GPUs, CUDA® Toolkit 8.0, and associated NVIDIA
    drivers with CUDA toolkit 8+ are required to be installed. The CUDA toolkit includes:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用TensorFlow与NVIDIA GPU，必须安装CUDA®工具包8.0和与CUDA工具包8+相关联的NVIDIA驱动程序。CUDA工具包包括：
- en: GPU-accelerated libraries such as cuFFT for **Fast** **Fourier** **Transforms**
    (**FFT**)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPU加速库，如cuFFT，用于**快速** **傅里叶** **变换**（**FFT**）
- en: cuBLAS for **Basic** **Linear** **Algebra** **Subroutines** (**BLAS**)
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cuBLAS 用于**基本** **线性** **代数** **子程序**（**BLAS**）
- en: cuSPARSE for sparse matrix routines
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cuSPARSE 用于稀疏矩阵运算
- en: cuSOLVER for dense and sparse direct solvers
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cuSOLVER 用于稠密和稀疏直接求解器
- en: cuRAND for random number generation, NPP for image, and video processing primitives
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cuRAND 用于随机数生成，NPP 用于图像和视频处理原语
- en: '**nvGRAPH** for **NVIDIA** **Graph** **Analytics** **Library**'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nvGRAPH** 用于 **NVIDIA** **图形** **分析** **库**'
- en: Thrust for template parallel algorithms and data structures and a dedicated
    CUDA math library
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Thrust 用于模板并行算法和数据结构以及专用的CUDA数学库
- en: 'For Linux, download and install required packages:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux，下载并安装所需的软件包：
- en: '[https://developer.nvidia.com/cuda-downloads](https://developer.nvidia.com/cuda-downloads)
    using the `wget` command on Ubuntu as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`wget`命令在Ubuntu上下载 [https://developer.nvidia.com/cuda-downloads](https://developer.nvidia.com/cuda-downloads)：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Also, ensure that you have added the CUDA installation path to the `LD_LIBRARY_PATH`
    environment variable as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，确保已将CUDA安装路径添加到`LD_LIBRARY_PATH`环境变量中，如下所示：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Installing NVIDIA cuDNN v5.1+
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装NVIDIA cuDNN v5.1+
- en: 'Once the CUDA Toolkit is installed, you should download the cuDNN v5.1 library
    from for Linux and once downloaded, uncompress the files and copy them into the
    CUDA Toolkit directory (assumed here to be in /usr/local/cuda/):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦CUDA工具包安装完成，您应该从Linux下载cuDNN v5.1库，并在下载后解压文件并将其复制到CUDA工具包目录（假定位于/usr/local/cuda/）：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that to install the cuDNN v5.1 library, you must need to register for the
    Accelerated Computing Developer Program at [https://developer.nvidia.com/accelerated-computing-developer](https://developer.nvidia.com/accelerated-computing-developer).
    Now when you have installed the cuDNN v5.1 library, ensure that you create the
    `CUDA_HOME` environment variable.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，要安装 cuDNN v5.1 库，您必须注册 [加速计算开发者计划](https://developer.nvidia.com/accelerated-computing-developer)。现在，当您安装了
    cuDNN v5.1 库后，请确保创建 `CUDA_HOME` 环境变量。
- en: Installing the libcupti-dev Library
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 libcupti-dev 库
- en: 'Lastly, you need to have the libcupti-dev library installed on your machine.
    This is the NVIDIA CUDA that provides advanced profiling support. To install this
    library, issue the following command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要在机器上安装 libcupti-dev 库。这是 NVIDIA CUDA 提供的高级性能分析支持。要安装此库，请执行以下命令：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Installing TensorFlow
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 TensorFlow
- en: Refer to the following section for more step-by-step guidelines on how to install
    the latest version of TensorFlow for the CPU only and GPU supports with NVIDIA
    cuDNN and CUDA computing capability. You can install TensorFlow on your machine
    in a number of ways, such as using virtualenv, pip, Docker, and Anaconda. However,
    using Docker and Anaconda is a bit advanced and this is why we have decided to
    use pip and virtualenv instead.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下部分，获取关于如何安装仅支持 CPU 和支持 NVIDIA cuDNN 和 CUDA 计算能力的最新版本 TensorFlow 的逐步指南。您可以通过多种方式在您的机器上安装
    TensorFlow，例如使用 virtualenv、pip、Docker 和 Anaconda。然而，使用 Docker 和 Anaconda 有点复杂，因此我们决定使用
    pip 和 virtualenv。
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Interested readers can try using Docker and Anaconda from [https://www.tensorflow.org/install/](https://www.tensorflow.org/install/).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有兴趣的读者可以尝试从 [https://www.tensorflow.org/install/](https://www.tensorflow.org/install/)
    使用 Docker 和 Anaconda。
- en: Installing TensorFlow with native pip
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用本地 pip 安装 TensorFlow
- en: 'If steps 1 to 6 are completed, install TensorFlow by invoking one of the following
    commands. For Python 2.7 and, of course, with only CPU support:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果步骤 1 到 6 已完成，请通过以下命令之一安装 TensorFlow。对于 Python 2.7，并且仅支持 CPU：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If step 3 failed somehow, install the latest version of TensorFlow by issuing
    a command manually:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果步骤 3 失败，请手动执行命令安装最新版本的 TensorFlow：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For both cases, `TF_PYTHON_URL` signifies the URL of the TensorFlow Python package
    presented at [https://www.tensorflow.org/install/install_linux#the_url_of_the_tensorflow_python_package](https://www.tensorflow.org/install/install_linux#the_url_of_the_tensorflow_python_package).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两种情况，`TF_PYTHON_URL` 表示位于 [https://www.tensorflow.org/install/install_linux#the_url_of_the_tensorflow_python_package](https://www.tensorflow.org/install/install_linux#the_url_of_the_tensorflow_python_package)
    的 TensorFlow Python 包的 URL。
- en: 'For example, to install the latest version with CPU-only support (at the time
    of writing v1.1.0), use the following command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要安装仅支持 CPU 的最新版本（在撰写时为 v1.1.0），请使用以下命令：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Installing with virtualenv
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 virtualenv 安装
- en: 'We assume that you already have Python 2+ (or 3+) and pip (or pip3) installed
    on your system. If so, follow these steps to install TensorFlow:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设您已经在系统上安装了 Python 2+（或 3+）和 pip（或 pip3）。如果是这样，请按照以下步骤安装 TensorFlow：
- en: 'Create a virtualenv environment as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下创建 virtualenv 环境：
- en: '[PRE27]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `targetDirectory` signifies the root of the `virtualenv` tree. By default,
    it is `~/tensorflow` (however, you may choose any directory).
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`targetDirectory` 表示 `virtualenv` 树的根目录。默认情况下，它是 `~/tensorflow`（但您可以选择任何目录）。'
- en: 'Activate virtualenv environment as follows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下激活 virtualenv 环境：
- en: '[PRE28]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the command succeeds in step 2, then you should see the following on your
    terminal:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果步骤 2 中的命令成功，则应在终端中看到以下内容：
- en: '[PRE29]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Installing TensorFlow.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 TensorFlow。
- en: 'Follow one of the following commands to install TensorFlow in the active virtualenv
    environment. For Python 2.7 with CPU-only support, use the following command:'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按照以下命令之一，在激活的 virtualenv 环境中安装 TensorFlow。对于 Python 2.7，仅支持 CPU，请使用以下命令：
- en: '[PRE30]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If the preceding command succeeds, skip step 5\. If the preceding command fails,
    perform step 5\. Moreover, if step 3 failed somehow, try to install TensorFlow
    in the active virtualenv environment by issuing a command of the following format:'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果前面的命令成功，跳过步骤 5。如果前面的命令失败，请执行步骤 5。此外，如果步骤 3 失败，请尝试通过执行以下格式的命令，在激活的 virtualenv
    环境中安装 TensorFlow：
- en: '[PRE31]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Validate the installation.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证安装。
- en: 'To validate the installation in step 3, you must activate the virtual environment.
    If the virtualenv environment is not currently active, issue one of the following
    commands:'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要验证步骤 3 中的安装，必须激活虚拟环境。如果虚拟环境当前没有激活，请执行以下命令之一：
- en: '[PRE32]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Uninstalling TensorFlow
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 卸载TensorFlow
- en: 'To uninstall TensorFlow, simply remove the tree you created. For example:'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要卸载TensorFlow，只需删除您创建的目录树。例如：
- en: '[PRE33]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, if you want to control which devices are visible to TensorFlow manually,
    you should set the `CUDA_VISIBLE_DEVICES`. For example, the following command
    can be used to force the use of only GPU 0:'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，如果您想手动控制哪些设备对TensorFlow可见，您应该设置`CUDA_VISIBLE_DEVICES`。例如，以下命令可强制仅使用GPU 0：
- en: '[PRE34]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Installing TensorFlow from Source
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从源代码安装TensorFlow
- en: The pip installation can cause problems using TensorBoard (this will be discussed
    later in this lesson). For this reason, I suggest you build TensorFlow directly
    from the source. The steps are described as follows.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pip安装可能会在使用TensorBoard时出现问题（稍后在本课程中讨论）。因此，我建议您直接从源代码构建TensorFlow。步骤如下所述。
- en: Note
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Follow the instructions and guidelines on how to install Bazel on your platform
    at [http://bazel.io/docs/install.html](http://bazel.io/docs/install.html).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照以下网址上的指示和准则，在您的平台上安装Bazel：[http://bazel.io/docs/install.html](http://bazel.io/docs/install.html)。
- en: 'At first, clone the entire TensorFlow repository as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按以下方式克隆整个TensorFlow存储库：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then it''s time to install Bazel, which is a tool that automates software builds
    and tests. Also, for building TensorFlow from source, Bazel build system must
    be installed on your machine. For this, issue the following command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是安装Bazel的时候了，这是一个自动化软件构建和测试的工具。此外，为了从源代码构建TensorFlow，必须在您的机器上安装Bazel构建系统。为此，请执行以下命令：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then run the Bazel installer by issuing the following command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行Bazel安装程序，执行以下命令：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Moreover, you might need some Python dependencies such as `python-numpy`, `swig`,
    and `python-dev`. Now, issue the following command for doing so:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可能需要一些Python依赖项，例如`python-numpy`、`swig`和`python-dev`。现在，执行以下命令来安装它们：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now it''s time to configure the installation (GPU or CPU). Let''s do it by
    executing the following command:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候配置安装（GPU或CPU）了。通过执行以下命令来完成：
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then create your TensorFlow package using `bazel`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`bazel`创建您的TensorFlow包：
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'However, to build with the GPU support, issue the following command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要构建支持GPU的版本，请执行以下命令：
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, install TensorFlow. Here I have listed, as per the Python version:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，安装TensorFlow。这里我列出了Python版本的安装步骤：
- en: 'For Python 2.7:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Python 2.7：
- en: '[PRE42]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For Python 3.4:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Python 3.4：
- en: '[PRE43]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Testing Your TensorFlow Installation
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试您的TensorFlow安装
- en: 'We start with the popular TensorFlow alias `tf`. Open a Python terminal (just
    type `python` or `python3` on terminal) and issue the following lines of code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从流行的TensorFlow别名`tf`开始。打开一个Python终端（只需在终端上键入`python`或`python3`）并执行以下代码：
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If your favourite Python interpreter doesn't complain, then you're ready to
    start using TensorFlow!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢的Python解释器没有投诉，那么您已经准备好开始使用TensorFlow了！
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now to verify your installation just type the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在验证您的安装，只需输入以下命令：
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If the installation is OK, you''ll see the following output:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装成功，您将看到以下输出：
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: TensorFlow Computational Graph
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TensorFlow计算图
- en: 'When thinking of execution of a TensorFlow program we should be familiar with
    a graph creation and a session execution. Basically the first one is for building
    the model and the second one is for feeding the data in and getting the results.
    An interesting thing is that TensorFlow does each and everything on the C++ engine,
    which means even a little multiplication or addition is not executed on Python
    but Python is just a wrapper. Fundamentally, TensorFlow C++ engine consists of
    following two things:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑执行TensorFlow程序时，我们应该熟悉图的创建和会话的执行。基本上，第一个是用于构建模型，第二个是用于提供数据并获取结果。有趣的是，TensorFlow的每一点乘或加法都是在C++引擎上执行的，这意味着甚至在Python上执行的操作也只是一个包装器。基本上，TensorFlow的C++引擎由以下两部分组成：
- en: Efficient implementations for operations like convolution, max pool, sigmoid,
    and so on.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于操作如卷积、最大池、sigmoid等的高效实现。
- en: Derivatives of forwarding mode operation.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前向模式操作的导数。
- en: 'When we/you''re performing a little complex operation with TensorFlow, for
    example training a linear regression, TensorFlow internally represents its computation
    using a dataflow graph. The graph is called a computational graph, which is a
    directed graph consisting of the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们/您使用TensorFlow执行一些稍复杂的操作时，例如训练线性回归，TensorFlow内部使用数据流图来表示其计算。这个图称为计算图，它是由以下内容组成的有向图：
- en: A set of nodes, each one representing an operation
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组节点，每个节点表示一个操作
- en: A set of directed arcs, each one representing the data on which the operations
    are performed.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组有向弧线，每一条代表操作执行时的数据。
- en: 'TensorFlow has two types of edges:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow 有两种类型的边：
- en: '**Normal**: They carry the data structures between the nodes. The output of
    one operation from one node, becomes input for another operation. The edge connecting
    two nodes carries the values.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**普通**：它们在节点之间传递数据结构。一个节点的某个操作的输出，成为另一个操作的输入。连接两个节点的边承载着这些值。'
- en: '**Special**: This edge doesn''t carry values, but only represents a control
    dependency between two nodes, say X and Y. It means that the node Y will be executed
    only if the operation in X is executed already, but before the relationship between
    operations on the data.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特殊**：该边不传递值，仅表示两个节点之间的控制依赖关系，例如 X 和 Y。这意味着，只有当 X 中的操作已执行时，节点 Y 才会被执行，但在数据操作之间的关系之前。'
- en: The TensorFlow implementation defines control dependencies to enforce orderings
    between otherwise independent operations as a way of controlling the peak memory
    usage.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow 的实现定义了控制依赖关系，以强制执行原本独立的操作之间的顺序，从而控制峰值内存使用。
- en: 'A computational graph is basically like a dataflow graph. Figure 5 shows a
    computational graph for a simple computation like *z=d×c=(a+b) ×c*:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 计算图基本上就像是一个数据流图。图 5 展示了一个简单计算的计算图，例如 *z=d×c=(a+b) ×c*：
- en: '![TensorFlow Computational Graph](img/01_06.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![TensorFlow 计算图](img/01_06.jpg)'
- en: 'Figure 5: A very simple execution graph that computes a simple equation'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5：一个非常简单的执行图，计算一个简单的方程。
- en: 'In the preceding figure, the circles in the graph indicate the operations,
    while rectangles indicate a data computational graph. As stated earlier, a TensorFlow
    graph contains the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，图中的圆圈表示操作，而矩形表示数据计算图。正如前面所述，TensorFlow 图包含以下内容：
- en: '**A set of tf.Operation objects**: This is used to represent units of computation
    to be performed'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一组 tf.Operation 对象**：用于表示要执行的计算单元。'
- en: '**A tf.Tensor object**: This is used to represent units of data that control
    the dataflow between operations'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个 tf.Tensor 对象**：用于表示控制操作之间数据流的单元数据。'
- en: Using TensorFlow, it is also possible to perform a deferred execution. To give
    an idea, once you have composed a highly compositional expression during the building
    phase of the computational graph, you can still evaluate them in the running session
    phase. Technically saying TensorFlow schedules the job and executes on time in
    an efficient manner. For example, parallel execution of independent parts of the
    code using the GPU is shown in figure 6.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TensorFlow，也可以执行延迟计算。简单来说，一旦你在计算图的构建阶段组成了一个高度可组合的表达式，你仍然可以在运行会话阶段评估它们。从技术上讲，TensorFlow
    会调度任务并高效地按时执行。例如，图 6 展示了如何使用 GPU 并行执行独立的代码部分。
- en: '![TensorFlow Computational Graph](img/01_07.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![TensorFlow 计算图](img/01_07.jpg)'
- en: 'Figure 6: Edges and nodes in TensorFlow graph to be executed under a session
    on devices such as CPUs or GPUs'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6：TensorFlow 图中的边和节点将在设备（如 CPU 或 GPU）上通过会话执行。
- en: 'After a computational graph is created, TensorFlow needs to have an active
    session to be executed by multiple CPUs (and GPUs if available) in a distributed
    way. In general, you really don''t need to specify whether to use a CPU or a GPU
    explicitly, since TensorFlow can choose and use which one is to be used. By default,
    a GPU will be picked for as many operations as possible; otherwise, a CPU will
    be used. So in a broad view, here are the main components of TensorFlow:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 创建计算图后，TensorFlow 需要一个活跃的会话，在多个 CPU（以及可用的 GPU）上以分布式方式执行。通常，你不需要明确指定使用 CPU 还是
    GPU，因为 TensorFlow 会选择并使用其中之一。默认情况下，TensorFlow 会选择尽可能多的操作使用 GPU；如果没有 GPU，则使用 CPU。因此，从整体上看，TensorFlow
    的主要组件如下：
- en: '**Variables**: Used to contain values for the weights and bias between TensorFlow
    sessions.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量**：用于存储在 TensorFlow 会话之间的权重和偏置值。'
- en: '**Tensors**: A set of values that pass in between nodes.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**张量**：一组在节点之间传递的值。'
- en: '**Placeholders**: Is used to send data between the program and the TensorFlow
    graph.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**占位符**：用于在程序和 TensorFlow 图之间传递数据。'
- en: '**Session**: When a session is started, TensorFlow automatically calculates
    gradients for all the operations in the graph and use them in a chain rule. In
    fact, a session is invoked when the graph is to be executed.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话**：当会话启动时，TensorFlow 会自动计算图中所有操作的梯度，并使用链式法则。实际上，当图要执行时，会调用一个会话。'
- en: 'Don''t worry much, each of the preceding components will be discussed in later
    sections. Technically saying, the program you will be writing can be considered
    as a client. The client is then used to create the execution graph in C/C++ or
    Python symbolically, and then your code can ask TensorFlow to execute this graph.
    See details in the following figure:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 不用太担心，前面提到的每个组件将在后续章节中详细讨论。从技术上讲，你所编写的程序可以被视为客户端。然后，客户端用于在 C/C++ 或 Python 中符号化地创建执行图，然后你的代码可以要求
    TensorFlow 执行这个图。详细信息请见下图：
- en: '![TensorFlow Computational Graph](img/01_08.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![TensorFlow 计算图](img/01_08.jpg)'
- en: 'Figure 7: Using a client–master architecture for executing TensorFlow graph'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7：使用客户端–主节点架构执行 TensorFlow 图
- en: A computational graph helps to distribute the work load across multiple computing
    nodes having a CPU or a GPU. This way, a neural network can further be equaled
    to a composite function where each layer (input, hidden or output layer) can be
    represented as a function. Now to understand the operations performed on the tensors,
    knowing a good workaround about TensorFlow programming model is a mandate. The
    next section explains the role of the computational graph to implement a neural
    network.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 计算图有助于将工作负载分配到具有 CPU 或 GPU 的多个计算节点。这样，神经网络可以进一步等同于一个复合函数，其中每一层（输入层、隐藏层或输出层）都可以表示为一个函数。现在，为了理解在张量上执行的操作，了解有关
    TensorFlow 编程模型的良好解决方案是必须的。下一节将解释计算图在实现神经网络中的作用。
- en: TensorFlow Programming Model
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TensorFlow 编程模型
- en: 'The TensorFlow programming model signifies how to structure your predictive
    models. A TensorFlow program is generally divided into four phases once you have
    imported TensorFlow library for associated resources:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow 编程模型表示如何构建你的预测模型。一旦导入了 TensorFlow 库的相关资源，TensorFlow 程序通常会分为四个阶段：
- en: Construction of the computational graph that involves some operations on tensors
    (we will see what is a tensor soon)
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建计算图，涉及对张量的一些操作（我们将很快了解什么是张量）
- en: Create a session
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个会话
- en: Running a session, that is performed for the operations defined in the graph
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行一个会话，这将在图中定义的操作上执行
- en: Computation for data collection and analysis
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据收集和分析的计算
- en: 'These main steps define the programming model in TensorFlow. Consider the following
    example, in which we want to multiply two numbers:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这些主要步骤定义了 TensorFlow 中的编程模型。考虑以下示例，我们要乘两个数字：
- en: '[PRE48]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The preceding code segment can be represented by the following figure:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码段可以通过以下图示表示：
- en: '![TensorFlow Programming Model](img/01_09.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![TensorFlow 编程模型](img/01_09.jpg)'
- en: 'Figure 8: A simple multiplication executed and returned the product on client-master
    architecture'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8：在客户端-主节点架构中执行并返回乘积的简单乘法
- en: 'To make the preceding program more efficient, TensorFlow also allows you to
    exchange data in your graph variables through placeholders (to be discussed later).
    Now imagine the following code segment that does the same but in a more efficient
    way:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高前面程序的效率，TensorFlow 还允许你通过占位符（稍后讨论）在图变量中交换数据。现在，假设以下代码段以更高效的方式执行相同的操作：
- en: '[PRE49]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: TensorFlow is not necessary to multiply two numbers; also the number of lines
    of the code for this simple operation is so many. However, the example wants to
    clarify how to structure any code, from the simplest as in this instance, to the
    most complex. Furthermore, the example also contains some basic instructions that
    we will find in all the other examples given in the course of this book.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow 不是为了乘两个数而必需的；此外，这个简单操作的代码行数也很多。然而，这个例子旨在阐明如何构建任何代码，从最简单的例子到最复杂的例子。此外，该例子还包含了一些基本的指令，这些指令会出现在本书其他例子中。
- en: Note
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will demonstrate most of the examples in this book with Python 3.x compatible.
    However, a few examples will be given using Python 2.7.x too.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的大多数例子将以 Python 3.x 兼容的方式演示。然而，也有少数例子将使用 Python 2.7.x 来展示。
- en: 'This single import in the first line helps to import the TensorFlow for your
    command that can be instantiated with `tf as stated earlier. Then the` TensorFlow
    operator will then be expressed by `tf` and the dot ''`.`'' and by the name of
    the operator to use. In the next line, we construct the object `session`, by means
    of the instruction `tf.Session()`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行中的这个单一导入帮助你导入 TensorFlow，之后可以使用 `tf` 来实例化它。然后，`TensorFlow` 运算符将通过 `tf` 和点符号
    '.' 来表达，并通过运算符的名称来使用。接下来的行中，我们通过 `tf.Session()` 指令来构造对象 `session`：
- en: '[PRE50]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The session object (that is, sess) encapsulates the environment for the TensorFlow
    so that all the operation objects are executed, and Tensor objects are evaluated.
    We will see them in upcoming sections.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 会话对象（即sess）封装了TensorFlow的环境，以便执行所有操作对象并评估Tensor对象。我们将在接下来的章节中看到它们。
- en: This object contains the computation graph, which as we said earlier, are the
    calculations to be carried out.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 该对象包含计算图，正如我们之前所说，它是需要执行的计算。
- en: 'The following two lines define variables x and y, using the notion of placeholder.
    Through a placeholder you may define both an input (such as the variable x of
    our example) and an output variable (such as the variable y):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两行定义了变量x和y，使用了占位符的概念。通过占位符，你可以定义输入（例如我们示例中的变量x）和输出变量（例如变量y）：
- en: '[PRE51]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Placeholder provides an interface between the elements of the graph and the
    computational data of the problem, it allows us to create our operations and build
    our computation graph, without needing the data, but only a reference to it.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符提供了图形元素与问题计算数据之间的接口，它允许我们创建操作并构建计算图，而不需要数据，只需要对其的引用。
- en: 'To define a data or tensor (soon I will introduce you to the concept of tensor)
    via the placeholder function, three arguments are required:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过占位符函数定义数据或张量（稍后我将介绍张量的概念），需要三个参数：
- en: '**Data** **type**: Is the type of element in the tensor to be fed.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据** **类型**：是输入张量中元素的类型。'
- en: '**Shape**: Of the placeholder–that is, shape of the tensor to be fed (optional).
    If the shape is not specified, you can feed a tensor of any shape.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**形状**：占位符的形状——即要输入的张量的形状（可选）。如果未指定形状，可以输入任何形状的张量。'
- en: '**Name**: Very useful for debugging and code analysis purposes, but it is optional.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：对调试和代码分析非常有用，但它是可选的。'
- en: Note
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more, refer to [https://www.tensorflow.org/api_docs/python/tf/Tensor](https://www.tensorflow.org/api_docs/python/tf/Tensor).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅[https://www.tensorflow.org/api_docs/python/tf/Tensor](https://www.tensorflow.org/api_docs/python/tf/Tensor)。
- en: So, we may introduce the model that we want to compute with two arguments, the
    placeholder and the constant that are previously defined. Next, we define the
    computational model.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以介绍我们希望使用两个参数计算的模型，即先前定义的占位符和常量。接下来，我们定义计算模型。
- en: 'The following statement, inside the session, builds the data structures of
    the `x` product with `y`, and the subsequent assignment of the result of the operation
    to the placeholder `z`. Then it goes as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语句在会话内部构建了`x`与`y`的乘积数据结构，并将操作结果赋值给占位符`z`。接下来是这样的：
- en: '[PRE52]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now since the result is already held by the placeholder `z`, we execute the
    graph, through the `sess.run`statement. Here we feed two values to patch a tensor
    into a graph node. It temporarily replaces the output of an operation with a tensor
    value (more in upcoming sections):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于结果已经由占位符`z`持有，我们通过` sess.run`语句执行计算图。这里我们提供两个值，将张量传入计算图节点。它暂时用张量值替换操作的输出（更多内容将在接下来的章节中介绍）：
- en: '[PRE53]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then we close the TensorFlow session when we''re done:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后当我们完成时，关闭TensorFlow会话：
- en: '[PRE54]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the final instruction, we print out the result:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后的指令中，我们打印出结果：
- en: '[PRE55]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This essentially prints output 72.0.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这本质上是打印输出72.0。
- en: Data Model in TensorFlow
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TensorFlow中的数据模型
- en: The data model in TensorFlow is represented by **tensors**. Without using complex
    mathematical definitions, we can say that a tensor (in TensorFlow) identifies
    a multidimensional numerical array. But we will see more details on tensor in
    the next sub-section.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow中的数据模型由**张量**表示。无需使用复杂的数学定义，我们可以说，张量（在TensorFlow中）标识了一个多维的数字数组。但我们将在下一小节中看到关于张量的更多细节。
- en: Tensors
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 张量
- en: 'Let''s see a formal definition of tensors from Wikipedia ([https://en.wikipedia.org/wiki/Tensor](https://en.wikipedia.org/wiki/Tensor))
    as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Wikipedia上对张量的正式定义（[https://en.wikipedia.org/wiki/Tensor](https://en.wikipedia.org/wiki/Tensor)）如下：
- en: '*"Tensors are geometric objects that describe linear relations between geometric
    vectors, scalars, and other tensors. Elementary examples of such relations include
    the dot product, the cross product, and linear maps. Geometric vectors, often
    used in physics and engineering applications, and scalars themselves are also
    tensors."*'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*“张量是几何对象，用于描述几何向量、标量和其他张量之间的线性关系。此类关系的基本示例包括点积、叉积和线性映射。几何向量通常用于物理学和工程应用中，标量本身也是张量。”*'
- en: 'This data structure is characterized by three parameters: Rank, Shape, and
    Type, as shown in the following figure:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据结构由三个参数来描述：秩、形状和类型，如下图所示：
- en: '![Tensors](img/01_10.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![张量](img/01_10.jpg)'
- en: 'Figure 9: Tensors are nothing but geometrics objects having shape, rank, and
    type used to hold multidimensional arrays'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9：张量不过是几何对象，具有形状、秩和类型，用于存储多维数组
- en: A tensor thus can be thought of as a generalization of a matrix that specifies
    an element by an arbitrary number of indices. While practically used, the syntax
    for tensors is even more or less like nested vectors.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，张量可以被看作是矩阵的推广，它通过任意数量的索引来指定一个元素。在实际使用时，张量的语法几乎与嵌套向量相似。
- en: Note
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Tensors just define the type of this value and the means by which this value
    should be calculated during the session. Therefore, essentially, they do not represent
    or hold any value produced by an operation.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 张量仅定义这个值的类型，以及在会话期间如何计算这个值。因此，实质上，它们并不代表或保存任何由操作生成的值。
- en: A few people love to compare NumPy versus TensorFlow comparison; however, in
    reality, TensorFlow and NumPy are quite similar in a sense that both are N-d array
    libraries!
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 一些人喜欢比较 NumPy 与 TensorFlow；然而，实际上，TensorFlow 和 NumPy 在某种程度上非常相似，因为它们都是 N 维数组库！
- en: 'Well, it''s true that NumPy has the n–dimensional array support, but it doesn''t
    offer methods to create tensor functions and automatically compute derivatives
    (+ no GPU support). The following table can be seen as a short and one-to-one
    comparison that could make some sense of such comparisons:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，NumPy 支持 n 维数组，但它并没有提供创建张量函数和自动计算导数的方法（+ 不支持 GPU）。下表可以看作是一个简短且一对一的比较，可以帮助我们理解这种比较：
- en: '![Tensors](img/01_11.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![张量](img/01_11.jpg)'
- en: 'Figure 10: NumPy versus TensorFlow'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10：NumPy 与 TensorFlow
- en: 'Now let''s see an alternative way of creating tensors before they could be
    fed (we will see other feeding mechanisms later on) by the TensorFlow graph:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看另一种创建张量的方式，在它们可以被 TensorFlow 图形接收之前（我们稍后会看到其他接收机制）：
- en: '[PRE56]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here `X` is a list, `Y` is an n-dimensional array from the NumPy library, and
    `Z` is itself the TensorFlow''s Tensor object. Now let''s see their types:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`X` 是一个列表，`Y` 是来自 NumPy 库的 n 维数组，而 `Z` 本身是 TensorFlow 的张量对象。现在让我们来看它们的类型：
- en: '[PRE57]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Well, their types are printed correctly. However, a more convenient function
    that we''re formally dealing with tensors, as opposed to the other types is `tf.convert_to_tensor()`
    function as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，它们的类型已经正确打印。然而，当我们正式处理张量时，相比其他类型，更方便的函数是 `tf.convert_to_tensor()`，如下所示：
- en: '[PRE58]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now let''s see their type using the following lines:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过以下几行代码来看它们的类型：
- en: '[PRE59]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Fantastic! I think up to now it's enough discussion already carried out on tensors,
    so now we can think about the structure that is characterized by the term **rank**.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我认为到现在为止关于张量的讨论已经足够了，现在我们可以考虑由 **秩** 这一术语所描述的结构。
- en: Rank
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 秩
- en: 'Each tensor is described by a unit of dimensionality called rank. It identifies
    the number of dimensions of the tensor, for this reason, a rank is known as order
    or n–dimensions of a tensor. A rank zero tensor is a scalar, a rank one tensor
    id a vector, while a rank two tensor is a matrix. The following code defines a
    TensorFlow scalar, a `vector`, a `matrix`, and a `cube_matrix`, in the next example
    we will show how the rank works:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 每个张量由一个叫做秩的维度单位来描述。它标识了张量的维度数，因此，秩也称为张量的阶数或 n 维度。秩为零的张量是标量，秩为一的张量是向量，而秩为二的张量是矩阵。以下代码定义了一个
    TensorFlow 标量，一个 `向量`，一个 `矩阵`，以及一个 `立方矩阵`，在下一个例子中，我们将展示秩是如何工作的：
- en: '[PRE60]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The results are printed here:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 结果打印如下：
- en: '[PRE61]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Shape
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 形状
- en: 'The shape of a tensor is the number of rows and columns it has. Now we will
    see how to relate the shape to a rank of a tensor:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 张量的形状是它拥有的行数和列数。现在我们将看到如何将形状与张量的秩关联起来：
- en: '[PRE62]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Data Type
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'In addition to rank and shape, tensors have a data type. The following is the
    list of the data types:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 除了秩和形状，张量还有数据类型。以下是数据类型的列表：
- en: '![Data Type](img/01_12.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![数据类型](img/01_12.jpg)'
- en: 'We believe the preceding table is self-explanatory hence we did not provide
    detailed discussion on the preceding data types. Now the TensorFlow APIs are implemented
    to manage data **to** and **from** NumPy arrays. Thus, to build a tensor with
    a constant value, pass a NumPy array to the `tf.constant()` operator, and the
    result will be a TensorFlow tensor with that value:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为前面的表格不言自明，因此没有详细讨论前述数据类型。现在，TensorFlow APIs 已经实现了管理数据 **到** 和 **从** NumPy
    数组的功能。因此，要构建具有常量值的张量，只需将 NumPy 数组传递给 `tf.constant()` 运算符，结果将是一个包含该值的 TensorFlow
    张量：
- en: '[PRE63]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Running the example, we obtain:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例后，我们得到：
- en: '[PRE64]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'To build a tensor, with variable values, use a `NumPy` array and pass it to
    the `tf.Variable` constructor, the result will be a TensorFlow variable tensor
    with that initial value:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建具有变量值的张量，使用一个 `NumPy` 数组并将其传递给 `tf.Variable` 构造函数，结果将是一个具有该初始值的 TensorFlow
    变量张量：
- en: '[PRE65]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The result is:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE66]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'For ease of use in interactive Python environments, we can use the `InteractiveSession`
    class, and then use that session for all `Tensor.eval()` and `Operation.run()`
    calls:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便在交互式 Python 环境中使用，我们可以使用 `InteractiveSession` 类，然后用该会话执行所有 `Tensor.eval()`
    和 `Operation.run()` 调用：
- en: '[PRE67]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`tf.InteractiveSession()` is just a convenient syntactic sugar for keeping
    a default session open in IPython.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`tf.InteractiveSession()` 只是为了在 IPython 中保持默认会话而提供的一种便捷的语法糖。'
- en: 'The result is:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE68]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This can be easier in an interactive setting, such as the shell or an IPython
    notebook, when it's tedious to pass around a session object everywhere.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式环境中（如 shell 或 IPython notebook）使用时，这种方式会更加方便，因为在这种环境下将会话对象传递到处可能会显得繁琐。
- en: Note
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The IPython Notebook is now known as the Jupyter Notebook. It is an interactive
    computational environment, in which you can combine code execution, rich text,
    mathematics, plots and rich media. For more information, interested readers should
    refer to the web page at [https://ipython.org/notebook.html](https://ipython.org/notebook.html).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: IPython Notebook 现在被称为 Jupyter Notebook。它是一个交互式计算环境，允许你结合代码执行、富文本、数学公式、绘图和富媒体。欲了解更多信息，感兴趣的读者可以参考
    [https://ipython.org/notebook.html](https://ipython.org/notebook.html) 页面。
- en: 'Another way to define a tensor is using the TensorFlow statement `tf.convert_to_tensor`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 定义张量的另一种方法是使用 TensorFlow 语句 `tf.convert_to_tensor`：
- en: '[PRE69]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Variables
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: 'Variables are TensorFlow objects to hold and update parameters. A variable
    must be initialized; also you can save and restore it to analyze your code. Variables
    are created by using the `tf.Variable()` statement. In the following example,
    we want to count the numbers from 1 to 10, but let''s import TensorFlow first:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是 TensorFlow 对象，用于保存和更新参数。变量必须初始化；你还可以保存并恢复它以便分析代码。变量是通过使用 `tf.Variable()`
    语句创建的。在以下示例中，我们想要计算从 1 到 10 的数字，但我们先导入 TensorFlow：
- en: '[PRE70]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We created a variable that will be initialized to the scalar value `0`:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个变量，并将其初始化为标量值 `0`：
- en: '[PRE71]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `assign()` and `add()`operators are just nodes of the computation graph,
    so they do not execute the assignment until the run of the session:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`assign()` 和 `add()` 运算符只是计算图的节点，因此它们不会在会话运行之前执行赋值操作：'
- en: '[PRE72]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We can instantiate the computation graph:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实例化计算图：
- en: '[PRE73]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Let''s recall that a tensor object is a symbolic handle to the result of an
    operation, but it does not actually hold the values of the operation''s output:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下，张量对象是对操作结果的符号句柄，但它并不实际保存操作输出的值：
- en: '[PRE74]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Fetches
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取
- en: 'To fetch the outputs of operations, execute the graph by calling `run()` on
    the session object and pass in the tensors to retrieve. Except fetching the single
    tensor node, you can also fetch multiple tensors. In the following example, the
    sum and multiply tensors are fetched together, using the `run()` call:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取操作的输出，通过在会话对象上调用 `run()` 并传入要检索的张量来执行图。除了获取单个张量节点外，你还可以获取多个张量。在以下示例中，我们一起获取了求和和乘法张量，使用
    `run()` 调用：
- en: '[PRE75]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The output is as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE76]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: All the ops needed to produce the values of the requested tensors are run once
    (not once per requested tensor).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 所有生成所请求张量值的操作仅执行一次（而不是每个请求的张量一次）。
- en: Feeds and Placeholders
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入和占位符
- en: 'There are four methods of getting data into a TensorFlow program (see details
    at [https://www.tensorflow.org/api_guides/python/reading_data](https://www.tensorflow.org/api_guides/python/reading_data)):'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种方法可以将数据导入 TensorFlow 程序（详情见 [https://www.tensorflow.org/api_guides/python/reading_data](https://www.tensorflow.org/api_guides/python/reading_data)）：
- en: '**The Dataset API**: This enables you to build complex input pipelines from
    simple and reusable pieces from distributed file systems and perform complex operations.
    Using the Dataset API is recommended while dealing with large amounts of data
    in different data formats. The Dataset API introduces two new abstractions to
    TensorFlow for creating feedable dataset using either `tf.contrib.data.Dataset`
    (by creating a source or applying a transformation operations) or using a `tf.contrib.data.Iterator`.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据集 API**：它使你能够从分布式文件系统中构建复杂的输入管道，并执行复杂的操作。处理大量数据和不同数据格式时，建议使用数据集 API。数据集
    API 引入了两个新的抽象概念来为 TensorFlow 创建可馈送的数据集，分别是通过 `tf.contrib.data.Dataset`（通过创建源或应用转换操作）或使用
    `tf.contrib.data.Iterator`。'
- en: '**Feeding**: Allows us to inject data into any Tensor in a computation graph.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**馈送**：允许我们将数据注入到计算图中的任何张量中。'
- en: '**Reading from files**: We can develop an input pipeline using Python''s built-in
    mechanism for reading data from data files at the beginning of a TensorFlow graph.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从文件中读取**：我们可以在 TensorFlow 图的开头使用 Python 内建的机制来开发输入管道，从数据文件中读取数据。'
- en: '**Preloaded data**: For small datasets, we can use either constants or variables
    in the TensorFlow graph for holding all the data.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预加载数据**：对于小型数据集，我们可以在 TensorFlow 图中使用常量或变量来保存所有数据。'
- en: In this section, we will see an example of the feeding mechanism only. For the
    other methods, we will see them in upcoming lesson. TensorFlow provides the feed
    mechanism that allows us inject data into any tensor in a computation graph. You
    can provide the feed data through the `feed_dict` argument to a `run()` or `eval()`invoke
    that initiates the computation.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们只会看到馈送机制的示例。其他方法将在接下来的课程中看到。TensorFlow 提供了馈送机制，允许我们将数据注入到计算图中的任何张量中。你可以通过
    `feed_dict` 参数将馈送数据提供给 `run()` 或 `eval()` 调用来启动计算。
- en: Note
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Feeding using the `feed_dict` argument is the least efficient way to feed data
    into a TensorFlow execution graph and should only be used for small experiments
    needing small datasets. It can also be used for debugging.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `feed_dict` 参数进行馈送是将数据馈送到 TensorFlow 执行图中的最低效方式，应该仅用于需要小型数据集的小型实验。它也可以用于调试。
- en: We can also replace any tensor with feed data (that is variables and constants),
    the best practice is to use a TensorFlow placeholder node using `tf.placeholder()`
    invocation. A placeholder exists exclusively to serve as the target of feeds.
    An empty placeholder is not initialized so it does not contain any data. Therefore,
    it will always generate an error if it is executed without a feed, so you won't
    forget to feed it.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以用馈送数据（即变量和常量）替换任何张量，最佳实践是使用 `tf.placeholder()` 调用来创建 TensorFlow 占位符节点。占位符仅用于作为馈送的目标。空占位符未初始化，因此不包含任何数据。因此，如果没有馈送它，它总是会生成错误，这样你就不会忘记给它馈送数据。
- en: 'The following example shows how to feed data to build a random 2×3 matrix:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何馈送数据以构建一个随机的 2×3 矩阵：
- en: '[PRE77]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The output is:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE78]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: TensorBoard
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TensorBoard
- en: TensorFlow includes functions to debug and optimize programs in a visualization
    tool called **TensorBoard**. Using TensorBoard, you can observe different types
    of statistics concerning the parameters and details of any part of the graph computing
    graphically.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow 包括用于调试和优化程序的函数，这些函数位于一个名为 **TensorBoard** 的可视化工具中。使用 TensorBoard，你可以观察与图中任何部分的参数和细节相关的不同统计信息。
- en: Moreover, while doing predictive modeling using the complex deep neural network,
    the graph can be complex and confusing. Thus to make it easier to understand,
    debug, and optimize TensorFlow programs, you can use TensorBoard to visualize
    your TensorFlow graph, plot quantitative metrics about the execution of your graph,
    and show additional data such as images that pass through it.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在使用复杂的深度神经网络进行预测建模时，图可能会变得复杂和混乱。为了更容易理解、调试和优化 TensorFlow 程序，你可以使用 TensorBoard
    来可视化你的 TensorFlow 图，绘制有关图执行的定量指标，并展示经过图形处理的额外数据，如图像等。
- en: 'Therefore, the TensorBoard can be thought of as a framework designed for analysis
    and debugging of predictive models. TensorBoard uses the so-called summaries to
    view the parameters of the model: once a TensorFlow code is executed, we can call
    TensorBoard to view summaries in a GUI.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，TensorBoard 可以看作是一个为分析和调试预测模型而设计的框架。TensorBoard 使用所谓的汇总（summaries）来查看模型的参数：一旦执行了
    TensorFlow 代码，我们可以调用 TensorBoard 在图形界面中查看汇总。
- en: How Does TensorBoard Work?
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TensorBoard 是如何工作的？
- en: As explained previously, TensorFlow uses the computation graph to execute an
    application, where each node represents an operation and the arcs are the data
    between operations.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，TensorFlow使用计算图来执行应用程序，其中每个节点表示一个操作，弧线表示操作之间的数据。
- en: 'The main idea in TensorBoard is to associate the so-called summary with nodes
    (operations) of the graph. Upon running the code, the summary operations will
    serialize the data of the node that is associated with it and output the data
    into a file that can be read by TensorBoard. Then TensorBoard can be run and visualize
    the summarized operations. The workflow when using TensorBoard is:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: TensorBoard的主要思想是将所谓的摘要与计算图的节点（操作）关联起来。运行代码时，摘要操作会将与节点相关联的数据序列化，并将数据输出到一个文件中，TensorBoard可以读取该文件。然后，TensorBoard可以运行并可视化这些摘要操作。使用TensorBoard的工作流程是：
- en: Build your computational graph/code
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建你的计算图/代码
- en: Attach summary ops to the nodes you are interested in examining
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将摘要操作附加到你感兴趣的节点
- en: Start running your graph as you normally would
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像平常一样开始运行你的计算图
- en: Additionally, run the summary ops
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，运行摘要操作
- en: When the code is done running, run TensorBoard to visualize the summary outputs
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当代码运行完成后，运行TensorBoard以可视化摘要输出
- en: 'If you type `$ which tensorboard` in your terminal, it should exist if you
    installed with `pip`:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在终端中输入`$ which tensorboard`，如果你是通过`pip`安装的，它应该会显示：
- en: '[PRE79]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'You need to give it a log directory, so you are in the directory where you
    ran your graph; you can launch it from your terminal with something like:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要提供一个日志目录，所以确保你在运行计算图的目录下；你可以在终端使用类似以下命令来启动它：
- en: '[PRE80]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Then open your favorite web browser and type in `localhost:6006` to connect.
    When TensorBoard is fully configured, this can be accessed by issuing the following
    command:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 然后打开你喜欢的网页浏览器，输入`localhost:6006`进行连接。当TensorBoard完全配置好后，你可以通过执行以下命令来访问它：
- en: '[PRE81]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now you simply need to access the local port `6006` from the browser `http://localhost:6006/`.
    Then it should look like this:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你只需从浏览器访问本地端口`6006`，地址为`http://localhost:6006/`。然后界面应该是这样的：
- en: '![How Does TensorBoard Work?](img/01_13.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![TensorBoard如何工作？](img/01_13.jpg)'
- en: 'Figure 11: Using TensorBoard on browser'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 图11：在浏览器中使用TensorBoard
- en: Is this already too much? Don't worry, in the last section, we'll combine all
    the ideas previously explained to build a single input neuron model and to analyze
    it with TensorBoard.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不是有点太复杂了？别担心，在最后一部分，我们将结合之前解释的所有概念，构建一个单输入神经元模型，并用TensorBoard分析它。
- en: Getting Started with TensorFlow – Linear Regression and Beyond
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用TensorFlow – 线性回归及其应用
- en: In this example, we will take a closer look at TensorFlow's and TensorBoard's
    main concepts and try to do some basic operations to get you started. The model
    we want to implement simulates the linear regression.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将更详细地了解TensorFlow和TensorBoard的主要概念，并尝试进行一些基本操作，帮助你入门。我们要实现的模型是模拟线性回归。
- en: 'In the statistics and machine learning realm, linear regression is a technique
    frequently used to measure the relationship between variables. This is also a
    quite simple but effective algorithm that can be used in predictive modeling too.
    Linear regression models the relationship between a dependent variable **yi**,
    an interdependent variable **xi**, and a random term **b**. This can be seen as
    follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在线性回归的统计学和机器学习领域，线性回归是一种常用的技术，用于衡量变量之间的关系。这也是一个非常简单但有效的算法，可以用于预测建模。线性回归模拟了一个因变量**yi**、一个自变量**xi**和一个随机项**b**之间的关系。可以表示为：
- en: '![Getting Started with TensorFlow – Linear Regression and Beyond](img/01_14.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用TensorFlow – 线性回归及其应用](img/01_14.jpg)'
- en: 'Now to conceptualize the preceding equation, I am going to write a simple Python
    program for creating data into a 2D space. Then I will use TensorFlow to look
    for the line that best fits in the data points:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了更好地理解前面的方程，我将编写一个简单的Python程序来创建二维空间中的数据。然后，我将使用TensorFlow寻找最适合这些数据点的直线：
- en: '[PRE82]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'If your compiler does not make any complaints, you should observe the following
    graph:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译器没有报错，你应该能看到以下图形：
- en: '![Getting Started with TensorFlow – Linear Regression and Beyond](img/01_15.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用TensorFlow – 线性回归及其应用](img/01_15.jpg)'
- en: 'Figure 12: Randomly generated (but original) data'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图12：随机生成（但原始的）数据
- en: Well, so far we have just created a few data points without any associated model
    that could be executed through TensorFlow. So the next step is to create a linear
    regression model to be able to obtain the output values `y` that is estimated
    from the input data points–that is, `x_data`. In this context, we have only two
    associated parameters–that is, `W` and `b`. Now the objective is to create a graph
    that allows finding the values for these two parameters based on the input data
    `x_data` by adjusting them to `y_data`–that is, optimization problem.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是创建了一些数据点，但没有任何可以通过TensorFlow执行的关联模型。那么，下一步是创建一个线性回归模型，以便能够从输入数据点（即`x_data`）中估计输出值`y`。在这个上下文中，我们只有两个相关参数，即`W`和`b`。现在的目标是创建一个图形，允许通过调整`W`和`b`的值，使其根据输入数据`x_data`来拟合`y_data`，即优化问题。
- en: 'So the target function in our case would be as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在我们的例子中，目标函数将如下所示：
- en: '![Getting Started with TensorFlow – Linear Regression and Beyond](img/01_16.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用TensorFlow——线性回归及更多](img/01_16.jpg)'
- en: If you recall, we defined **W = 0.1** and **b = 0.4** while creating the data
    points in the 2D space. Now TensorFlow has to optimize these two values so that
    `W` tends to 0.1 and `b` to 0.4, but without knowing any optimization function,
    TensorFlow does not even know anything.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们在创建二维空间中的数据点时定义了**W = 0.1**和**b = 0.4**。现在TensorFlow需要优化这两个值，使得`W`趋近于0.1，`b`趋近于0.4，但如果没有任何优化函数，TensorFlow甚至无法知道这些。
- en: A standard way to solve such optimization problems is to iterate through each
    value of the data points and adjust the value of `W` and `b` in order to get a
    more precise answer on each iteration. Now to realize if the values are really
    improving, we need to define a cost function that measures how good a certain
    line is.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这种优化问题的标准方法是通过每个数据点的值进行迭代，并调整`W`和`b`的值，以便在每次迭代中获得更精确的答案。现在，为了检查这些值是否真正改进，我们需要定义一个代价函数来衡量某条直线的好坏。
- en: 'In our case, the cost function is the mean squared error that helps find the
    average of the errors based on the distance function between the real data points
    and the estimated ones on each iteration. We start by importing the TensorFlow
    library:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，代价函数是均方误差，它有助于基于每次迭代中真实数据点和估计数据点之间的距离函数，找到误差的平均值。我们首先导入TensorFlow库：
- en: '[PRE83]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'In the preceding code segment, we are generating a random point using a different
    strategy and storing in variable W. Now let''s define a loss function **loss=mean
    [(y−y_data) 2]** and this returns a scalar value with the mean of all distances
    between our data and the model prediction. In terms of TensorFlow convention,
    the loss function can be expressed as follows:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码段中，我们使用不同的策略生成一个随机点，并将其存储在变量W中。现在我们来定义一个损失函数**loss=mean [(y−y_data) 2]**，它返回一个标量值，表示我们数据与模型预测之间所有距离的均值。按照TensorFlow的约定，损失函数可以表示如下：
- en: '[PRE84]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Without going into further detail, we can use some widely used optimization
    algorithms such as gradient descent. At a minimal level, the gradient descent
    is an algorithm that works on a set of given parameters that we already have.
    It starts with an initial set of parameter values and iteratively moves toward
    a set of values that minimize the function by taking another parameter called
    learning rate. This iterative minimization is achieved by taking steps in the
    negative direction of the function called gradient.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入讨论，我们可以使用一些广泛使用的优化算法，例如梯度下降。在最基本的层面，梯度下降是一种算法，它在一组已有的参数上工作。它从一组初始参数值开始，通过迭代逐步朝着一组最小化函数的值前进，并采用另一个参数称为学习率。这个迭代最小化是通过沿着函数的负方向（称为梯度）进行步进来实现的。
- en: '[PRE85]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Before running this optimization function, we need to initialize all the variables
    that we have so far. Let''s do it using TensorFlow convention as follows:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行这个优化函数之前，我们需要初始化到目前为止所有的变量。让我们按照TensorFlow的约定进行初始化，如下所示：
- en: '[PRE86]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Since we have created a TensorFlow session, we are ready for the iterative
    process that helps us find the optimal values of `W` and `b`:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经创建了一个TensorFlow会话，我们已经准备好进行迭代过程，帮助我们找到`W`和`b`的最优值：
- en: '[PRE87]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'You should observe the following output:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE88]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Thus you can see the algorithm starts with the initial values of **W = 0.18418592
    and b = 0.47198644** where the loss is pretty high. Then the algorithm iteratively
    adjusted the values by minimizing the cost function. In the eighth iteration,
    all the values tend to our desired values.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以看到算法从**W = 0.18418592和b = 0.47198644**的初始值开始，此时损失较高。然后，算法通过最小化成本函数来迭代调整这些值。在第八次迭代时，所有值趋近于我们期望的值。
- en: 'Now what if we could plot them? Let''s do it by adding the plotting line under
    the `for` loop as follows:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们能够绘制它们呢？让我们通过在`for`循环下方添加绘图代码来实现，如下所示：
- en: '![Getting Started with TensorFlow – Linear Regression and Beyond](img/01_17.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用TensorFlow – 线性回归及其扩展](img/01_17.jpg)'
- en: 'Figure 13: Linear regression after eight iteration that optimizes the loss
    function'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 图13：第八次迭代后的线性回归，优化了损失函数
- en: 'Now let''s iterate the same up to the 16th iteration:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将迭代次数增加到第16次：
- en: '[PRE89]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Much better and we're closer to the optimized values, right? Now, what if we
    further improve our visual analytics through TensorFlow that help visualize what
    is happening in these graphs. TensorBoard provides a web page for debugging your
    graph as well as inspecting the used variables, node, edges, and their corresponding
    connections.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 好得多，我们离优化后的值更近了，对吧？那么，接下来我们如何进一步通过TensorFlow提高可视化分析，帮助我们更好地理解这些图表中发生的事情。TensorBoard提供了一个网页，供你调试图形并检查所用的变量、节点、边以及它们的连接关系。
- en: However, to get the facility of the preceding regression analysis, you need
    to annotate the preceding graphs with the variables such as loss function, `W`,
    `b`, `y_data`, `x_data`, and so on. Then you need to generate all the summaries
    by invoking the function `tf.summary.merge_all()`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了获取前面回归分析的功能，你需要为前面的图形注释一些变量，如损失函数、`W`、`b`、`y_data`、`x_data`等。然后，你需要通过调用函数`tf.summary.merge_all()`来生成所有的汇总信息。
- en: 'Now, we need to make the following changes to the preceding code. However,
    it is a good practice to group related nodes on the graph using the `tf.name_scope()`
    function. Thus, we can use `tf.name_scope()` to organize things on the TensorBoard
    graph view, but let''s give it a better name:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要对前面的代码进行以下更改。不过，使用`tf.name_scope()`函数将相关节点分组是一种好习惯。因此，我们可以使用`tf.name_scope()`来组织TensorBoard图形视图中的内容，但我们为它起个更合适的名字：
- en: '[PRE90]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Then let''s annotate the loss function in a similar way, but by giving a suitable
    name such as `LossFunction`:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们以类似的方式注释损失函数，但要给它起个合适的名字，如`LossFunction`：
- en: '[PRE91]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Let''s annotate the loss, weights, and bias that are needed for the TensorBoard:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们注释TensorBoard所需的损失、权重和偏差：
- en: '[PRE92]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Well, once you annotate the graph, it''s time to configure the summary by merging
    them:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，一旦你注释了图形，接下来就该通过合并它们来配置汇总：
- en: '[PRE93]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now before running the training (after the initialization), write the summary
    using the `tf.summary.FileWriter()` API as follows:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在运行训练之前（初始化后），使用`tf.summary.FileWriter()` API来编写汇总信息，如下所示：
- en: '[PRE94]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Then start the TensorBoard as follows:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按如下方式启动TensorBoard：
- en: '[PRE95]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'In our case, it could be something like the following:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，它可能是如下所示：
- en: '[PRE96]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now let''s move to `http://localhost:6006` and on clicking on the **GRAPHS**
    tab, you should see the following graph:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到`http://localhost:6006`，点击**GRAPHS**标签后，你应该会看到如下图：
- en: '![Getting Started with TensorFlow – Linear Regression and Beyond](img/01_18.jpg)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用TensorFlow – 线性回归及其扩展](img/01_18.jpg)'
- en: 'Figure 14: Main graph and auxiliary nodes on TensorBoard'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 图14：TensorBoard中的主图和辅助节点
- en: Source Code for the Linear Regression
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性回归的源代码
- en: 'We reported for the entire source code for the example previously described:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们报告了之前描述的示例的完整源代码：
- en: '[PRE97]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Ubuntu may ask you to install the python-tk package. You can do it by executing
    the following command on Ubuntu:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu可能会提示你安装python-tk包。你可以通过在Ubuntu上执行以下命令来安装：
- en: '[PRE98]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Summary
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'TensorFlow is designed to make the predictive analytics through the machine
    and deep learning easy for everyone, but using it does require understanding some
    general principles and algorithms. Furthermore, the latest release of TensorFlow
    comes with lots of exciting features. Thus I also tried to cover them so that
    you can use them with ease. I have shown how to install TensorFlow on different
    platforms including Linux, Windows, and Mac OS. In summary, here is a brief recap
    of the key concepts of TensorFlow explained in this lesson:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow的设计目的是使机器学习和深度学习中的预测分析变得简单易懂，但使用它确实需要理解一些基本原理和算法。此外，TensorFlow的最新版本带来了许多令人兴奋的功能。因此，我也尝试覆盖这些功能，帮助你更轻松地使用它们。我展示了如何在不同平台上安装TensorFlow，包括Linux、Windows和Mac
    OS。总之，以下是本课中解释的TensorFlow的关键概念的简要回顾：
- en: '**Graph**: each TensorFlow computation can be represented as a set of dataflow
    graphs where each graph is built as a set of operation objects. There are three
    core graph data structures:'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图**：每个TensorFlow计算可以表示为一组数据流图，其中每个图都作为一组操作对象构建。图的核心数据结构有三种：'
- en: '`tf.Graph`'
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tf.Graph`'
- en: '`tf.Operation`'
  id: totrans-448
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tf.Operation`'
- en: '`tf.Tensor`'
  id: totrans-449
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tf.Tensor`'
- en: '**Operation**: A graph node takes tensors as input and also produces a tensor
    as output. A node can be represented by an operation object for performing units
    of computations such as addition, multiplication, division, subtraction or more
    complex operation.'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作**：图中的一个节点将张量作为输入，并且也产生一个张量作为输出。一个节点可以通过操作对象来表示，执行加法、乘法、除法、减法或更复杂操作等计算单位。'
- en: '**Tensor**: Tensors are like high-dimensional array objects. In other words,
    they can be represented as edges of a dataflow graph but still they don''t hold
    any value produced out of an operations.'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**张量**：张量类似于高维数组对象。换句话说，它们可以表示为数据流图的边缘，但它们并不持有由操作产生的任何值。'
- en: '**Session**: A session object is an entity that encapsulates the environment
    in which operation objects are executed for running calculations on the dataflow
    graph. As a result, the tensors objects are evaluated inside the `run()` or `eval()`
    invocation.'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话**：会话对象是一个封装了操作对象执行环境的实体，用于在数据流图上运行计算。因此，张量对象在`run()`或`eval()`调用中被评估。'
- en: In a later section of the lesson, we introduced TensorBoard, which is a powerful
    tool for analyzing and debugging neural network models, the lesson ended with
    an example that shows how to implement a simple neuron model and how to analyze
    its learning phase with TensorBoard.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在课程的后续部分，我们介绍了TensorBoard，它是一个强大的工具，用于分析和调试神经网络模型，本课最后通过一个示例展示了如何实现一个简单的神经元模型，以及如何通过TensorBoard分析其学习过程。
- en: Predictive models often perform calculations during live transactions, for example,
    to evaluate the risk or opportunity of a given customer or transaction, in order
    to guide a decision. With advancements in computing speed, individual agent modeling
    systems have become capable of simulating human behavior or reactions to given
    stimuli or scenarios.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 预测模型通常在实时交易中进行计算，例如评估给定客户或交易的风险或机会，以指导决策。随着计算速度的提升，单个代理建模系统已经能够模拟人类的行为或对给定刺激或场景的反应。
- en: In the next lesson, we will cover linear models for regression, classification,
    and clustering and dimensionality reduction and will also give some insights about
    some performance measures.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一课中，我们将介绍用于回归、分类和聚类的线性模型，以及降维方法，并对一些性能度量进行一些洞察。
- en: Assessments
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Each tensor is described by a unit of dimensionality called ____.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个张量由一个维度单位描述，称为____。
- en: Data type
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据类型
- en: Rank
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 排序
- en: Variables
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量
- en: Fetches
  id: totrans-461
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取
- en: 'State whether the following statement is True or False: TensorFlow uses the
    computation graph to execute an application, where each node represents an operation
    and the arcs are the data between operations.'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断下列陈述是否正确：TensorFlow使用计算图来执行应用程序，其中每个节点表示一个操作，弧线是操作之间的数据。
- en: 'State whether the following statement is True or False: NumPy has the n–dimensional
    array support, but it doesn''t offer methods to create tensor functions and automatically
    compute derivatives (+ no GPU support).'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断下列陈述是否正确：NumPy支持n维数组，但不提供创建张量函数和自动计算导数的方法（+ 不支持GPU）。
- en: Which objects does a TensorFlow graph contains?
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个TensorFlow图包含哪些对象？
- en: When you're performing a little complex operation with TensorFlow, for example
    training a linear regression, TensorFlow internally represents its computation
    using a dataﬂow graph. The graph is called as?
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你使用 TensorFlow 执行稍微复杂的操作时，例如训练线性回归，TensorFlow 会在内部使用数据流图表示其计算。这个图被称为？
- en: Dataflow graph
  id: totrans-466
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据流图
- en: Linear graph
  id: totrans-467
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线性图
- en: Computational graph
  id: totrans-468
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算图
- en: Regression graph
  id: totrans-469
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回归图
