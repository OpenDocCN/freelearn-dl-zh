- en: '*Chapter 15*: Voice Communication with a Robot Using Mycroft'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 15 章*：使用 Mycroft 与机器人进行语音通信'
- en: Using our voice to ask a robot to do something and receiving a voice response
    has been seen as a sign of intelligence for a long time. Devices around us, such
    as those using Alexa and Google Assistant, have these tools. Being able to program
    our system to integrate with these tools gives us access to a powerful voice assistant
    system. Mycroft is a Python-based open source voice system. We will get this running
    on the Raspberry Pi by connecting it to a speaker and microphone, and then we
    will run instructions on our robot based on the words we speak.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的语音请求机器人做某事并接收语音响应长期以来被视为智能的标志。我们周围的设备，如使用 Alexa 和 Google Assistant 的设备，都有这些工具。能够编程我们的系统以集成这些工具，使我们能够访问强大的语音助手系统。Mycroft
    是一个基于 Python 的开源语音系统。我们将通过将其连接到扬声器和麦克风来在树莓派上运行它，然后我们将根据我们说的词语在机器人上运行指令。
- en: In this chapter, we will have an overview of Mycroft and then learn how to add
    a speaker/microphone board to a Raspberry Pi. We will then install and configure
    a Raspberry Pi to run Mycroft.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将概述 Mycroft，然后学习如何将扬声器/麦克风板添加到树莓派上。然后我们将安装和配置树莓派以运行 Mycroft。
- en: We'll also extend our use of Flask programming, building a Flask API with more
    control points.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将扩展我们对 Flask 编程的使用，构建具有更多控制点的 Flask API。
- en: Toward the end of the chapter, we will create our own skills code to connect
    a voice assistant to our robot. You will be able to take this knowledge and use
    it to create further voice agent skills.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的末尾，我们将创建我们自己的技能代码以将语音助手连接到我们的机器人。你将能够利用这些知识来创建更多的语音代理技能。
- en: 'The following topics are covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Introducing Mycroft – understanding voice agent terminology
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Mycroft – 理解语音代理术语
- en: Limitations of listening for speech on a robot
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在机器人上监听语音的限制
- en: How to add a speaker/microphone board to a Raspberry Pi
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将扬声器/麦克风板添加到树莓派上
- en: How to install and configure a Raspberry Pi to run Mycroft
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装和配置树莓派以运行 Mycroft
- en: Programming a Flask control API
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程 Flask 控制API
- en: How to create our own skills code to connect a voice assistant to our robot
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建我们自己的技能代码以将语音助手连接到我们的机器人
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will require the following hardware for this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本章，你需要以下硬件：
- en: An additional Raspberry Pi 4 (model B).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个 Raspberry Pi 4（型号 B）。
- en: An SD card (at least 8 GB).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一张 SD 卡（至少 8 GB）。
- en: A PC that can write the card (with the balenaEtcher software).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台可以写入卡的 PC（带有 balenaEtcher 软件）。
- en: The ReSpeaker 2-Mics Pi HAT.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ReSpeaker 2-Mics Pi HAT。
- en: Mini Audio Magnet Raspberry Pi Speaker—a tiny speaker with a JST connector or
    a speaker with a 3.5 mm jack.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mini Audio Magnet Raspberry Pi Speaker——一个带有 JST 连接器的微型扬声器或带有 3.5 毫米插孔的扬声器。
- en: It may be helpful to have a Micro-HDMI to HDMI cable for troubleshooting.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一条 Micro-HDMI 到 HDMI 的电缆可能有助于故障排除。
- en: Micro USB power supply.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Micro USB 电源。
- en: The robot from the previous chapters (after all, we intend to get this moving).
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一章中的机器人（毕竟，我们打算让它动起来）。
- en: The code for this chapter is available on GitHub at [https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter15](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter15).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在 GitHub 上找到：[https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter15](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter15)。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2N5bXqr](https://bit.ly/2N5bXqr)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用：[https://bit.ly/2N5bXqr](https://bit.ly/2N5bXqr)
- en: Introducing Mycroft – understanding voice agent terminology
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Mycroft – 理解语音代理术语
- en: '**Mycroft** is a software suite known as a **voice assistant**. Mycroft listens
    for voice commands and takes actions based on those commands. Mycroft code is
    written in Python and is open source and free. It performs most of its voice processing
    in the cloud. After the commands are processed, Mycroft will use a voice to respond
    to the human.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mycroft** 是一个名为 **语音助手** 的软件套件。Mycroft 监听语音命令并根据这些命令采取行动。Mycroft 代码是用 Python
    编写的，是开源和免费的。它的大部分语音处理都在云端进行。在命令处理完毕后，Mycroft 将使用语音对人类进行回应。'
- en: Mycroft is documented online and has a community of users. There are alternatives
    that you could consider after you've experimented with Mycroft – for example,
    Jasper, Melissa-AI, and Google Assistant.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Mycroft 在线有文档和用户社区。在尝试了 Mycroft 之后，你可以考虑其他替代方案——例如 Jasper、Melissa-AI 和 Google
    Assistant。
- en: So, what are the concepts of a voice assistant? Let's look at them in the following
    subsections.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，语音助手的概念是什么呢？让我们在以下小节中看看它们。
- en: Speech to text
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语音转文本
- en: '**Speech to text** (**STT**) describes systems that take audio containing human
    speech and turn it into a series of words that a computer can then process.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**语音转文本**（**STT**）描述的是将包含人类语音的音频转换为计算机可以处理的单词序列的系统。'
- en: These can run locally, or they can run in the cloud on far more powerful machines.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以在本地运行，也可以在更强大的机器上云上运行。
- en: Wake words
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 唤醒词
- en: Voice assistants usually have a **wake word** – a phrase or word that is spoken
    before the rest of a command to get the attention of the voice assistant. Examples
    are the *Hey Siri*, *Hi Google*, and *Alexa* utterances. Mycroft uses the word
    *Mycroft* or the phrase *Hey Mycroft,* but that can be changed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 语音助手通常有一个**唤醒词**——一个在命令其余部分之前说出的短语或单词，以引起语音助手的注意。例如，有“嘿，Siri”，“嗨，Google”和“Alexa”的表达。Mycroft使用单词“Mycroft”或短语“嘿，Mycroft”，但这可以更改。
- en: A voice assistant is usually only listening for wake words and ignores all other
    audio input until woken. The wake word is recognized locally on the device. The
    sounds it samples after the wake word are sent to a speech-to-text system for
    recognition.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 语音助手通常只监听唤醒词，直到被唤醒才会忽略所有其他音频输入。唤醒词在设备上本地识别。唤醒词之后的样本声音被发送到语音转文本系统进行识别。
- en: Utterances
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达
- en: An **utterance** is a term for something a user says. Voice assistants use vocabulary
    you define to match an utterance to a skill. The specific vocabulary will cause
    Mycroft to invoke the intent handler.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达**是用户说的东西的术语。语音助手使用你定义的词汇来匹配表达与技能。特定的词汇将导致Mycroft调用意图处理器。'
- en: The vocabulary in Mycroft comprises lists of interchangeable phrases in a file.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Mycroft中的词汇包括一个文件中可互换短语的列表。
- en: 'A good example of an utterance is asking Mycroft about the weather: *Hey Mycroft,
    what is the weather?*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的例子是询问Mycroft关于天气：“嘿，Mycroft，天气怎么样？”
- en: Intent
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 意图
- en: An **intent** is a task that the voice assistant can do, such as finding out
    what today's weather is. We will build intents to interact with our robot. An
    intent is part of a skill, defining the handler code for what it does and choosing
    a dialog to respond.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**意图**是语音助手可以执行的任务，例如找出今天的天气。我们将构建意图与我们的机器人交互。意图是技能的一部分，定义了执行它的处理代码并选择一个对话框来响应。'
- en: Using the weather skill as an example, the utterance *What is the weather?*
    triggers an intent to fetch the current weather for the configured location and
    then speak the details of this back to the user. An example for our robot is *ask
    the robot to test LEDs*, with an intent that starts the LED rainbow behavior (from
    [*Chapter 9*](B15660_09_Final_ASB_ePub.xhtml#_idTextAnchor171), *Programming RGB
    Strips in Python*) on the robot.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以天气技能为例，表达“天气怎么样？”会触发获取配置位置当前天气的意图，然后向用户说出这些细节。对于我们机器人来说，一个例子是“让机器人测试LED”，这个意图会在机器人上启动LED彩虹行为（来自[*第9章*](B15660_09_Final_ASB_ePub.xhtml#_idTextAnchor171)，*在Python中编程RGB条带*)。
- en: Dialog
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对话
- en: In Mycroft terminology, **dialogs** are phrases that Mycroft speaks to the user.
    An example would be *OK, the robot has been started*, or *Today, the weather is
    clear*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mycroft术语中，**对话**是Mycroft对用户说的短语。例如，“好的，机器人已经启动了”，或者“今天，天气晴朗”。
- en: A skill has a collection of dialogs. These have sets of synonymous words to
    say and can use different languages.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 技能包含一系列对话。这些对话有可以说的同义词组，并且可以使用不同的语言。
- en: Vocabulary
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 词汇
- en: Utterances you speak, once converted into text, are matched to **vocabulary**.
    Vocabulary files, like dialogs, are parts of an intent, matching utterances to
    action. The vocabulary files contain synonymous phrases and can be organized into
    language sets to make your skill multi-lingual.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你说的表达，一旦转换为文本，就会与**词汇**相匹配。词汇文件，就像对话一样，是意图的一部分，将表达与动作相匹配。词汇文件包含同义词组，并且可以组织成语言集，使你的技能多语言。
- en: This would make phrases like *what is the weather?*, *is it sunny?*, *do I need
    an umbrella?* or *will it rain?* synonymous. You may have things split – for example,
    *ask the robot to* as one vocabulary item and *drive forward* as another.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使像“天气怎么样？”，“天气晴朗吗？”，“我需要伞吗？”或“会下雨吗？”这样的短语具有同义性。你可以将某些内容分开——例如，“让机器人做”作为一个词汇项，而“向前行驶”作为另一个。
- en: Skills
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技能
- en: '**Skills** are containers for a whole set of vocabulary for utterances, dialogs
    to speak, and *intents*. A skill for alarms might contain intents such as setting
    an alarm, listing the alarms, deleting an alarm, or changing an alarm. It would
    contain a dialog to say the alarm setting is complete or to confirm each alarm.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**技能**是用于话语、对话和*意图*的整个词汇表的容器。一个用于闹钟的技能可能包含设置闹钟、列出闹钟、删除闹钟或更改闹钟的意图。它将包含一个用于说闹钟设置完成或确认每个闹钟的对话。'
- en: Later in this chapter, we will build a `MyRobot` skill with intents to make
    it move and stop.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将构建一个带有使机器人移动和停止意图的`MyRobot`技能。
- en: Now you've learned a bit about the terminology and parts of a voice agent. We
    next need to consider what we will build. Where would we put a speaker and microphone?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了一些关于语音代理术语和部件的知识。接下来，我们需要考虑我们将要构建什么。扬声器和麦克风将放在哪里？
- en: Limitations of listening for speech on a robot
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在机器人上监听语音的限制
- en: Before we start to build this, we should consider what we are going to make.
    Should the speaker and microphone be on the robot or somewhere else? Will the
    processing be local or in the cloud?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建这个之前，我们应该考虑我们将要制作什么。扬声器和麦克风应该放在机器人上还是其他地方？处理是本地还是云端？
- en: 'Here are some considerations to keep in mind:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要考虑的事项：
- en: '**Noise**: A robot with motors is a noisy environment. Having a microphone
    anywhere near the motors will make it close to useless.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**噪音**：带有电机的机器人是一个嘈杂的环境。如果麦克风靠近电机，它几乎就毫无用处。'
- en: '**Power**: The voice assistant is continuously listening. The robot has many
    demands for power already with the other sensors that are running on it. This
    power demand applies both in terms of battery power and the CPU power needed.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电源**：语音助手一直在监听。机器人已经有很多传感器在运行，对电源的需求已经很大。这种电源需求既包括电池功率，也包括CPU功率。'
- en: '**Size and physical location**: The speaker and voice HAT would add height
    and wiring complications to an already busy robot.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尺寸和物理位置**：扬声器和语音HAT将增加机器人高度和布线复杂性，而这个机器人本身已经非常繁忙。'
- en: A microphone and speaker combination could be on a stalk for a large robot –
    a tall standoff with a second Raspberry Pi there. But this is unsuitable for this
    small and simple robot. We will create a separate voice assistant board that will
    communicate with our robot, but we won't be putting it directly on the robot.
    The voice assistant will be a second Raspberry Pi.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个麦克风和扬声器的组合可以放在大型机器人的茎上——一个高支架上，那里还有一个第二个树莓派。但这对这个小而简单的机器人来说不合适。我们将创建一个独立的语音助手板，它将与我们的机器人通信，但我们不会直接将其放在机器人上。语音助手将是一个第二个树莓派。
- en: We will also be using a system that goes to the cloud to process the speech.
    While a fully local system would have better privacy and could respond quicker,
    at the time of writing, there is not a complete packaged voice assistant that
    works this way for a Raspberry Pi. The Mycroft software gives us flexibility in
    using our own skills and has a pluggable backend for voice processing, so that
    one day it may run locally.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用一个发送到云端进行语音处理系统。虽然一个完全本地的系统会有更好的隐私性并且可以更快地响应，但在撰写本文时，还没有一个完整的打包语音助手适用于树莓派。Mycroft软件让我们在使用自己的技能时具有灵活性，并且有一个可插拔的后端用于语音处理，因此有一天它可能可以在本地运行。
- en: Now we've chosen how we will make our voice agent with Mycroft and a second
    Raspberry Pi, it's time to start building it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经选择了如何使用Mycroft和第二个树莓派来制作我们的语音代理，现在是时候开始构建它了。
- en: Adding sound input and output to the Raspberry Pi
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为树莓派添加声音输入和输出
- en: Before we can use a voice processing/voice assistant, we need to give the Raspberry
    Pi some speakers and a microphone. A few Raspberry Pi add-ons provide this. My
    recommendation, with a microphone array (for better recognition) and a connection
    to speakers, is the ReSpeaker 2-Mics Pi HAT, which is widely available.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用语音处理/语音助手之前，我们需要给树莓派一些扬声器和麦克风。一些树莓派附加组件可以提供这些设备。我的推荐是带有麦克风阵列（以提高识别率）和扬声器连接的ReSpeaker
    2-Mics Pi HAT，它非常容易获得。
- en: 'The next photograph shows the ReSpeaker 2-Mics Pi HAT:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张照片显示了ReSpeaker 2-Mics Pi HAT：
- en: '![](img/B15660_15_01.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_15_01.jpg)'
- en: Figure 15.1 – The ReSpeaker 2-Mics Pi HAT
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 – ReSpeaker 2-Mics Pi HAT
- en: '*Figure 15.1* shows a photo of a ReSpeaker 2-Mics Pi HAT mounted on a Raspberry
    Pi. On the left, I''ve labeled the left microphone. The hat has two microphones,
    which are two tiny rectangular metal parts on each side. The next label is for
    3 RGB LEDs and a button connected to a GPIO pin. After this are the two ways of
    connecting speakers – a 3.5mm jack or a JST connector. I recommend you connect
    a speaker to hear output from this HAT. Then, the last label highlights the right
    microphone.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15.1* 展示了 ReSpeaker 2-Mics Pi HAT 安装在 Raspberry Pi 上的照片。在左侧，我标记了左侧麦克风。该帽子有两个麦克风，每个侧面都有两个微小的矩形金属部件。下一个标签是
    3 个 RGB LED 和一个连接到 GPIO 引脚的按钮。接下来是连接扬声器的两种方式 – 3.5mm 插孔或 JST 连接器。我建议您连接一个扬声器来听从这个
    HAT 的输出。然后，最后一个标签突出了右侧麦克风。'
- en: I've chosen the ReSpeaker 2-Mic Pi HAT because it is an inexpensive device to
    get started on voice recognition. Very cheap USB microphones will not work well
    for this. There are expensive devices better supported in Mycroft, but they do
    not sit on the Pi as a hat. This ReSpeaker 2-Mics Pi HAT is a trade-off – great
    for hardware simplicity and cost but with some more software setup. Let's now
    look at how we physically install this HAT.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择 ReSpeaker 2-Mic Pi HAT，因为它是一个便宜的设备，可以开始语音识别。非常便宜的 USB 麦克风对此不起作用。在 Mycroft
    中有更好的支持的昂贵设备，但它们不会像帽子一样放在 Pi 上。这个 ReSpeaker 2-Mics Pi HAT 是一种权衡 – 对于硬件简单性和成本来说很好，但需要更多的软件设置。现在让我们看看如何物理安装这个
    HAT。
- en: Physical installation
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬件安装
- en: The ReSpeaker 2-Mics HAT will sit directly on the Raspberry Pi 4 headers with
    the board overhanging the Pi.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ReSpeaker 2-Mics HAT 将直接安装在 Raspberry Pi 4 头部，板子悬在 Pi 上方。
- en: 'The speakers will have either a tiny two-pin connector (JST) type that fits
    the single two-pin socket on the board or a 3.5 mm jack. The next photograph shows
    the speaker plugged into it:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 扬声器将有一个微小的两针连接器（JST）类型，适合板上的单个两针插座，或者一个 3.5 mm 插孔。下一张照片显示了扬声器插入到其中：
- en: '![](img/B15660_15_02.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_15_02.png)'
- en: Figure 15.2 – The Mycroft Voice Assistant ReSpeaker setup
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.2 – Mycroft 语音助手 ReSpeaker 设置
- en: '*Figure 15.2* shows my Mycroft setup with the ReSpeaker 2-Mics Pi HAT set up
    on my desk. It is powered up, and the Raspberry Pi is lit. I''ve connected a speaker
    to it as well.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15.2* 展示了我的 Mycroft 设置，ReSpeaker 2-Mics Pi HAT 已设置在我的桌子上。它已通电，Raspberry
    Pi 已点亮。我还连接了一个扬声器。 '
- en: You could use a Raspberry Pi case or project box but ensure that the microphones
    are not covered up.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Raspberry Pi 外壳或项目箱，但确保麦克风没有被遮挡。
- en: You also need an SD card and a power supply.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要一个 SD 卡和一个电源供应器。
- en: Important note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: For the next few sections, I recommend using a mains power supply. Do not plug
    it in and power it up yet.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我建议使用市电电源。不要插上电源并启动它。
- en: Now we have the hardware prepared, and it has speakers and a microphone. In
    the next section, we will set up Raspbian and the voice agent software.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了硬件，它配备了扬声器和麦克风。在下一节中，我们将设置 Raspbian 和语音代理软件。
- en: Installing a voice agent on a Raspberry Pi
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Raspberry Pi 上安装语音代理
- en: 'Mycroft has a Raspbian distribution prepared for this. Let''s put that on an
    SD card:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Mycroft 为此准备了 Raspbian 发行版。让我们将其放入 SD 卡中：
- en: 'Go to the Mycroft website to download the *Picroft* image: [https://mycroft-ai.gitbook.io/docs/using-mycroft-ai/get-mycroft/picroft](https://mycroft-ai.gitbook.io/docs/using-mycroft-ai/get-mycroft/picroft)
    – this is based on Raspbian Buster. Select **stable disk image**.'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 Mycroft 网站，下载 *Picroft* 镜像：[https://mycroft-ai.gitbook.io/docs/using-mycroft-ai/get-mycroft/picroft](https://mycroft-ai.gitbook.io/docs/using-mycroft-ai/get-mycroft/picroft)
    – 该镜像基于 Raspbian Buster。选择 **稳定磁盘镜像**。
- en: Insert the SD card into your computer. Use the procedures from [*Chapter 3*](B15660_03_Final_ASB_ePub.xhtml#_idTextAnchor050),
    *Exploring the Raspberry Pi*, in the *Flashing the card in balenaEtcher* section.
    Be sure to select the Picroft image instead of Raspbian.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 SD 卡插入您的计算机。使用 [*第 3 章*](B15660_03_Final_ASB_ePub.xhtml#_idTextAnchor050)
    中的程序，*探索 Raspberry Pi* 的 *在 balenaEtcher 中闪存卡* 部分。务必选择 Picroft 镜像而不是 Raspbian。
- en: Make sure this image works headlessly, enabling SSH and Wi-Fi as we did in [*Chapter
    4*](B15660_04_Final_ASB_ePub.xhtml#_idTextAnchor063), *Preparing a Headless Raspberry
    Pi for a Robot*, in the *Setting up wireless on the Raspberry Pi and enabling
    SSH* section.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保此镜像可以无头运行，启用 SSH 和 Wi-Fi，就像我们在 [*第 4 章*](B15660_04_Final_ASB_ePub.xhtml#_idTextAnchor063)
    中所做的那样，在 *为机器人准备无头 Raspberry Pi* 的 *在 Raspberry Pi 上设置无线并启用 SSH* 部分中。
- en: With this SD card ready, it's time to try it out. Insert it into the voice assistant
    Raspberry Pi and power it up using the USB micro socket on the ReSpeaker 2-Mics
    Pi HAT (not the Pi).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好这张 SD 卡后，是时候尝试使用了。将其插入语音助手 Raspberry Pi，并使用 ReSpeaker 2-Mics Pi HAT 上的 USB
    微型插座（而不是 Pi）供电。
- en: Important note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Ensure you supply power via the ReSpeaker 2-Mics Pi HAT and not the Pi. This
    board requires power to drive its speaker. The documentation for the board suggests
    that if you power it through the Pi you don't get output from the speaker. See
    [https://wiki.seeedstudio.com/ReSpeaker_2_Mics_Pi_HAT/#hardware-overview](https://wiki.seeedstudio.com/ReSpeaker_2_Mics_Pi_HAT/#hardware-overview)
    for details.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您通过 ReSpeaker 2-Mics Pi HAT 提供电源，而不是 Pi。该板需要电源来驱动其扬声器。该板的文档建议，如果您通过 Pi 为其供电，则扬声器不会输出声音。有关详细信息，请参阅
    [https://wiki.seeedstudio.com/ReSpeaker_2_Mics_Pi_HAT/#hardware-overview](https://wiki.seeedstudio.com/ReSpeaker_2_Mics_Pi_HAT/#hardware-overview)。
- en: Its hostname starts as `picroft.local`. You use the username `pi` and password
    `mycroft`. Ensure it is connected to Wi-Fi, and you can reach it via SSH (PuTTY).
    With the Raspberry Pi started, you can start to set up Mycroft.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 其主机名最初为 `picroft.local`。您使用用户名 `pi` 和密码 `mycroft`。确保它已连接到 Wi-Fi，并且您可以通过 SSH（PuTTY）访问它。启动
    Raspberry Pi 后，您就可以开始设置 Mycroft。
- en: Installing the ReSpeaker software
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 ReSpeaker 软件
- en: 'When you log on, Mycroft will show you an installation guide. This will ask
    you some questions as listed:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当您登录时，Mycroft 将显示安装指南。这将向您列出的问题进行提问：
- en: When asked if you want a guided setup, press *Y* for yes. The Mycroft installation
    will download a load of updates. Leave it for 30 minutes to an hour to do so.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当询问是否要进行引导设置时，按 *Y* 表示是。Mycroft 安装将下载大量更新。留出 30 分钟到 1 小时的时间来完成。
- en: 'Mycroft will now ask for your audio output device:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Mycroft 现在将询问您的音频输出设备：
- en: '[PRE0]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Press *Ctrl* + *C* to leave the guided setup and return to the `$` prompt.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Ctrl* + *C* 退出引导设置并返回到 `$` 提示符。
- en: For the installation to work, we'll need the software on the SD card to be updated.
    At the prompt, type `sudo apt update -y && sudo apt upgrade -y`. The update will
    take some time.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使安装生效，我们需要更新 SD 卡上的软件。在提示符下，输入 `sudo apt update -y && sudo apt upgrade -y`。更新可能需要一些时间。
- en: Reboot the Pi (with `sudo reboot`) for the updates to take effect. After you
    reboot the Pi, `ssh` in. You will be at the guided setup again. Press *Ctrl* +
    *C* again.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `sudo reboot` 重启 Pi 以使更新生效。重启 Pi 后，使用 `ssh` 登录。您将再次处于引导设置中。再次按 *Ctrl* + *C*。
- en: 'Use the following commands to install the audio drivers for the ReSpeaker 2-Mics
    Pi HAT:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装 ReSpeaker 2-Mics Pi HAT 的音频驱动程序：
- en: '[PRE1]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Git clone may take a minute or two. This board uses the WM8960 sound chip.
    The install script will take 20-30 minutes to finish.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Git 克隆可能需要一分钟左右。该板使用 WM8960 音频芯片。安装脚本将花费 20-30 分钟完成。
- en: Reboot again. Press *Ctrl* + *C* after to leave the guided mode.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次重启。在退出引导模式后按 *Ctrl* + *C*。
- en: Before we move on, it's a good idea to test that we are getting audio here.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们继续之前，测试我们是否真的得到了音频是一个好主意。
- en: 'Type `aplay -l` to list playback devices. In the output, you should see the
    following:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `aplay -l` 以列出播放设备。在输出中，您应该看到以下内容：
- en: '[PRE2]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This shows that it has found our card.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这表明它已经找到了我们的卡。
- en: 'We can now test this card will play audio by getting it to play an audio file.
    Use this command: `aplay -Dplayback /usr/share/sounds/alsa/Front_Left.wav`.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以通过让这张卡播放一个音频文件来测试它是否能够播放音频。使用以下命令：`aplay -Dplayback /usr/share/sounds/alsa/Front_Left.wav`。
- en: This command specifies the device named `playback` with the device `-D` flag,
    and then the file to play. The `playback` device is a default ALSA handler that
    ensures mixing is done and avoids issues with bitrate and channel number mismatches.
    There are other test audio files in `/usr/share/sounds/alsa`.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令指定了带有设备 `-D` 标志的名为 `playback` 的设备，然后是要播放的文件。`playback` 设备是一个默认的 ALSA 处理器，它确保了混音的完成，并避免了比特率和通道数不匹配的问题。在
    `/usr/share/sounds/alsa` 中还有其他测试音频文件。
- en: 'We can then check for recording devices with `arecord -l`. In the following
    output, we can see that `arecord` has found the card:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `arecord -l` 命令检查录音设备。在以下输出中，我们可以看到 `arecord` 已经找到了这张卡：
- en: '[PRE3]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The card is now ready for use. Next, we need to show the Mycroft system how
    to choose this card for use.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 该卡现在已准备好使用。接下来，我们需要向 Mycroft 系统展示如何选择这张卡进行使用。
- en: Troubleshooting
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'If you haven''t got audio output, there are some things you can check:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有音频输出，有一些事情您可以检查：
- en: First, type `sudo poweroff` to turn off the Raspberry Pi. When it is off, check
    the connections. Ensure that the board is connected fully to the GPIO header on
    the Pi. Make sure you've connected the speaker to the correct port on the ReSpeaker
    2-Mics Pi HAT.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，输入`sudo poweroff`来关闭Raspberry Pi。当它关闭时，检查连接。确保电路板已完全连接到Pi的GPIO引脚。确保你已经将扬声器连接到ReSpeaker
    2-Mics Pi HAT的正确端口。
- en: When you power it again, ensure that you are using the power connector on the
    ReSpeaker 2-Mics Pi HAT, and not the Raspberry Pi.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你再次开机时，确保你使用的是ReSpeaker 2-Mics Pi HAT上的电源连接器，而不是Raspberry Pi。
- en: If you are using the headphone slot instead of the speaker slot, you may need
    to increase the volume. Type `alsamixer`, select the WM8960 sound card, and turn
    the headphone volume up. Then try the playback tests again.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用的是耳机插槽而不是扬声器插槽，你可能需要增加音量。输入`alsamixer`，选择WM8960声卡，并将耳机音量调高。然后再次尝试播放测试。
- en: Make sure you have performed the `apt update` and the `apt upgrade` steps. The
    installation of the drivers will not work without it. You will need to reboot
    after this and then try reinstalling the driver.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你已经执行了`apt update`和`apt upgrade`步骤。没有这些步骤，驱动程序的安装将无法进行。你需要在此之后重新启动，然后尝试重新安装驱动程序。
- en: When installing the driver, if the Git step fails, double-check the address
    you have fetched.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装驱动程序时，如果Git步骤失败，请仔细检查你获取的地址。
- en: When attempting playback, the `-D` flag is case-sensitive. A lowercase `d` will
    not work here.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在尝试播放时，`-D`标志是区分大小写的。小写的`d`在这里不起作用。
- en: If these steps still do not help, please go to the [https://github.com/waveshare/WM8960-Audio-HAT](https://github.com/waveshare/WM8960-Audio-HAT)
    website, read their documentation, or raise an issue.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些步骤仍然没有帮助，请访问[https://github.com/waveshare/WM8960-Audio-HAT](https://github.com/waveshare/WM8960-Audio-HAT)网站，阅读他们的文档，或者提出一个问题。
- en: Now we've checked this, let's try to link the sound card with Mycroft.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经检查了这一点，让我们尝试将声卡与Mycroft链接。
- en: Getting Mycroft to talk to the sound card
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让Mycroft与声卡通信
- en: 'Now you need to connect Mycroft and the sound card. Do this by editing the
    Mycroft configuration file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要将Mycroft和声卡连接起来。通过编辑Mycroft配置文件来完成此操作：
- en: Open the Mycroft config file as root using `sudo nano /etc/mycroft/mycroft.conf`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sudo nano /etc/mycroft/mycroft.conf`以root权限打开Mycroft配置文件。
- en: 'The file has lines describing various aspects of Mycroft. However, we are interested
    in two lines only:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件中有描述Mycroft各个方面的行。然而，我们只对其中两行感兴趣：
- en: '[PRE4]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Edit both occurrences of `hw:0,0` to be the term `playback`. The two lines
    should look like this:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个`hw:0,0`的出现更改为术语`playback`。这两行应该看起来像这样：
- en: '[PRE5]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Press *Ctrl* + *X* to write out and exit. Type *Y* for yes when asked to write
    out the file.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Ctrl* + *X*来保存并退出。当被询问是否保存文件时，输入*Y*表示是。
- en: Reboot one more time; when you return, do not exit the guided mode.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次重启；当你回来时，不要退出指导模式。
- en: Mycroft will ask to test the device. Press *T* to test the speaker. It may take
    a few seconds, but you will hear Mycroft speak to you. If it is a little quiet,
    try typing the number `9`, and test it again. An exciting moment! Press *D* to
    say you have done the test.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Mycroft会要求测试设备。按*T*来测试扬声器。可能需要几秒钟，但你将听到Mycroft对你说话。如果声音有点小，尝试输入数字`9`，然后再次测试。这是一个激动人心的时刻！按*D*表示你已经完成了测试。
- en: The guided installer will next ask about the microphone. Select **4** for **Other
    USB Microphone** and try the sound test. The installer will ask you to speak to
    the microphone, and it should play your voice back to you. Press *1* if this sounds
    good.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指导安装程序接下来会询问麦克风。选择**4**代表**其他USB麦克风**并尝试声音测试。安装程序会要求你对着麦克风说话，并且应该会回放你的声音。如果听起来不错，请按*1*。
- en: The guided installation will ask you about using the recommendations; select
    *1* to confirm you want that. There will be a series of questions about your password
    settings. I recommend not adding a sudo password but changing the default password
    for the Pi to something unique.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指导安装程序会询问你是否使用推荐设置；选择*1*以确认你想要使用它。将有一系列关于密码设置的问题。我建议不要添加sudo密码，而是将Pi的默认密码改为一个独特的密码。
- en: Mycroft will launch with a large section of purple installation text.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Mycroft将以大量紫色安装文本启动。
- en: You have Mycroft configured and starting up. It can record your voice and play
    that back to you, and you have heard it speak a test word too. Now, it's time
    to start using Mycroft and see what it can do.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经配置并启动了Mycroft。它可以记录你的声音并回放给你听，你也已经听到了它的测试词。现在，是时候开始使用Mycroft并看看它能做什么了。
- en: Starting to use Mycroft
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用Mycroft
- en: Let's get to know Mycroft a little, and then try talking with it. We will start
    with the debug interface, the Mycroft client, which shows you what is going on
    with the system, and then we'll get into talking to it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微了解一下Mycroft，然后尝试与它交谈。我们将从调试界面、Mycroft客户端开始，它显示了系统正在发生的事情，然后我们将开始与它交谈。
- en: The Mycroft client
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mycroft客户端
- en: 'When you connect to Mycroft, you will see a display like the following figure:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当你连接到Mycroft时，你会看到如下所示的显示界面：
- en: '![](img/B15660_15_03.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_15_03.jpg)'
- en: Figure 15.3 – The Mycroft client interface
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3 – Mycroft客户端界面
- en: The screenshot in *Figure 15.3* is the Mycroft client. It allows you to see
    what Mycroft is doing, but you don't need to connect to this for Mycroft to listen
    to you. The top right shows how many messages there are and how many you can see.
    In the screenshot, you can see messages **0-10**, out of a total of **10** messages.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15.3*中的截图是Mycroft客户端。它允许你看到Mycroft正在做什么，但你不需要连接到这个客户端，Mycroft才能听到你的声音。右上角显示了有多少消息以及你能看到多少。在截图上，你可以看到**0-10**条消息，总共**10**条消息。'
- en: The main middle section shows the messages. *Red* and *purple* messages come
    from the Mycroft system and plugins. If many *purple* messages are flashing by,
    Mycroft is installing plugins and updates, so you may need to leave it until it
    finishes. *Green* messages show Mycroft interacting with a user. It shows when
    it detects a wake word, when it starts to record, when it ends the recording,
    and the utterance it thinks you said. The messages are useful as if it isn't quite
    responding, you can check whether it's picking up the wake word and that the utterance
    matches what you are trying to say.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的中间部分显示消息。*红色*和*紫色*消息来自Mycroft系统和插件。如果许多*紫色*消息快速闪过，说明Mycroft正在安装插件和更新，你可能需要等到它完成后再操作。*绿色*消息显示Mycroft与用户的交互。它显示当它检测到唤醒词、开始录音、结束录音以及它认为你所说的表述。如果它没有完全响应，你可以检查它是否正在拾取唤醒词以及表述是否与你试图说的相符。
- en: Below this, on the left, is the history. In the history, what Mycroft has processed
    from your utterance is in *blue*. The dialog Mycroft speaks is in *yellow*. You
    should hear *yellow* text repeated on the speaker; however, it can take a while
    if it is very busy. On the right, it shows a legend that matches colors to a log
    file. Further right is a microphone speaker level meter, and unless Mycroft is
    busy, or you are very quiet, you should see this moving up and down as it picks
    up noise in the room. Note – too much noise, and you may have trouble talking
    to it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之下，左侧是历史记录。在历史记录中，Mycroft从你的表述中处理的内容以*蓝色*显示。Mycroft所说的对话以*黄色*显示。你应该在扬声器上听到*黄色*文本的重复；然而，如果它非常忙碌，这可能需要一段时间。在右侧，它显示一个与日志文件颜色匹配的图例。更右边是一个麦克风扬声器电平计，除非Mycroft正在忙碌，或者你非常安静，否则你应该看到它在上下移动，因为它正在拾取房间内的噪音。注意
    – 噪音太多，你可能会有困难与它交谈。
- en: At the bottom of the screen is an input area, where you can type commands for
    Mycroft.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕底部是一个输入区域，你可以在这里为Mycroft输入命令。
- en: Give the system about 30-40 minutes to finish all the installations. If it is
    not responsive, it is not hung but is usually installing and compiling additional
    components.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 给系统大约30-40分钟的时间来完成所有安装。如果它没有响应，并不是卡住了，通常是在安装和编译额外的组件。
- en: Mycroft will then tell you it needs to be paired at [mycroft.ai](http://mycroft.ai).
    You will need to register the device using the code it gives you; which you can
    do while Mycroft is installing. You will need to create an account there to do
    so (or log in if this is a second device/attempt). Please complete this before
    proceeding.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Mycroft会告诉你需要在[mycroft.ai](http://mycroft.ai)进行配对。你需要使用它给出的代码来注册设备；这可以在Mycroft安装时完成。你需要在那里创建一个账户（或者如果这是一个第二设备/尝试，则登录）。请在继续之前完成此操作。
- en: When you've paired Mycroft, and it finishes installing things, you can start
    to interact.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当你配对好Mycroft，并且它完成安装后，你就可以开始交互了。
- en: Talking to Mycroft
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与Mycroft交谈
- en: 'Now you should be able to speak to your voice assistant:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够与你的语音助手交谈了：
- en: First, to get its attention, you must use the wake word *Hey Mycroft*. If it's
    ready (and not still busy), it will issue a speaker tone to show *Mycroft* is
    listening. You need to stand within about a meter of the microphones on the Raspberry
    Pi. It may respond with *Please wait a moment while I finish booting up*. Give
    it a minute and try again.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为了引起它的注意，你必须使用唤醒词*Hey Mycroft*。如果它准备好了（并且没有还在忙碌），它将发出一个扬声器音调来显示*Mycroft*正在倾听。你需要站在大约一米的Raspberry
    Pi麦克风附近。它可能会回应说*请稍等，我正在完成启动*。给它一分钟，然后再次尝试。
- en: 'If you hear the tone, you can now ask it to do something. A good starting point
    is to tell it: *Say hello*. Mycroft should respond with *Hello* from the speaker
    after about 10 seconds. You will need to speak as clearly as possible. I''ve found
    that it needs you to pronounce each syllable; those *t* and *n* sounds are essential.'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你听到声音，你现在可以要求它做某事。一个好的起点是告诉它：*说你好*。大约10秒后，Mycroft 应该会通过扬声器回应*你好*。你需要尽可能清晰地说话。我发现它需要你逐个发音；那些*t*和*n*的音是必不可少的。
- en: 'Now that this works, you can have some fun with it! You can shorten *Hey Mycroft*
    to just *Mycroft*. Other things you can say include the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然它已经工作，你可以用它来玩一些有趣的事情！你可以将*嘿 Mycroft*缩短为*Mycroft*。你还可以说的其他事情包括以下内容：
- en: '*Hey Mycroft, what is the weather?*: This will use the weather skill and tell
    you the weather. It may be for the wrong location; use the [mycroft.ai](http://mycroft.ai)
    website to configure your device to your location.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*嘿 Mycroft，天气怎么样？*：这将使用天气技能并告诉你天气情况。可能不是你所在位置的天气；请使用 [mycroft.ai](http://mycroft.ai)
    网站配置你的设备以适应你的位置。'
- en: '*Mycroft, what is 23 times 76*: This will use the Wolfram skill, which can
    handle mathematical questions.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Mycroft，23 乘以 76 是多少*：这将使用 Wolfram 技能，它可以处理数学问题。'
- en: '*Mycroft, wiki banana*: This will use a Wikipedia skill, and Mycroft will tell
    you what it has found out about the banana.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Mycroft，wiki banana*：这将使用维基百科技能，Mycroft 将告诉你它关于香蕉的发现。'
- en: Try these out to get used to talking to Mycroft so it responds. It may say *I
    don't understand*, and the log will tell you what it heard, which can help you
    try to tune how you pronounce things for it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些来习惯与 Mycroft 交谈，以便它做出响应。它可能会说*我不明白*，日志会告诉你它听到了什么，这可以帮助你尝试调整发音以便于它理解。
- en: We can now create a skill to connect Mycroft to our robot. But first, let's
    check for problems.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个技能，将 Mycroft 连接到我们的机器人。但首先，让我们检查是否有问题。
- en: Troubleshooting
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'If you are not able to get Mycroft to speak or recognize talking, try the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法让 Mycroft 说话或识别说话，请尝试以下方法：
- en: Make sure you are close enough to the microphone/loud enough. This can be checked
    by observing whether the mic (microphone) level goes above the dashed line in
    the Mycroft console.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你离麦克风足够近或声音足够大。这可以通过观察麦克风（麦克风）水平是否超过 Mycroft 控制台中的虚线来检查。
- en: Ensure you have a good network connection from your Raspberry Pi. Mycroft is
    only going to work where you can reach the internet. See the Mycroft documentation
    for handling proxies. Mycroft can fail to boot correctly if the internet connection
    isn't great. Fixing the connection and rebooting it can help.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你的 Raspberry Pi 有良好的网络连接。Mycroft 只能在你可以访问互联网的地方工作。请参阅 Mycroft 文档了解如何处理代理。如果互联网连接不佳，Mycroft
    可能无法正确启动。修复连接并重新启动可能会有所帮助。
- en: Attaching a monitor while the Pi is booting may reveal error messages.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Pi 启动时连接监视器可能会显示错误消息。
- en: 'Mycroft has a troubleshooting system starting with: *Troubleshooting and Known
    errors* ([https://mycroft.ai/documentation/troubleshooting/](https://mycroft.ai/documentation/troubleshooting/)).'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mycroft 有一个以 *故障排除和已知错误* 开始的故障排除系统（[https://mycroft.ai/documentation/troubleshooting/](https://mycroft.ai/documentation/troubleshooting/)）。
- en: Mycroft is under active development. Taking the latest Picroft image and applying
    the ReSpeaker driver may help. In short, getting this installed and running is
    subject to change.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mycroft 正在积极开发中。使用最新的 Picroft 图像并应用 ReSpeaker 驱动程序可能会有所帮助。简而言之，安装和运行此软件可能会发生变化。
- en: With Mycroft talking and responding, we need to prepare the robot for Mycroft
    to talk to it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mycroft 说话并做出响应的情况下，我们需要为 Mycroft 准备机器人以便与之交谈。
- en: Programming a Flask API
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程 Flask API
- en: This chapter aims to control our robot with Mycroft. To do so, we need to give
    our robot some way to receive commands from other systems. An **Application Programming
    Interface** (**API**) on a server lets us decouple systems like this to send commands
    across the network to another and receive a response. The Flask system is ideally
    suited to building this.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在使用 Mycroft 控制我们的机器人。为此，我们需要为我们的机器人提供一种接收来自其他系统命令的方式。服务器上的 **应用程序编程接口**（**API**）允许我们将此类系统解耦，以便通过网络向另一个系统发送命令并接收响应。Flask
    系统非常适合构建此类系统。
- en: Web-based APIs have endpoints that other systems make their requests to and
    roughly map to functions or methods in a Python module. As you'll see, we map
    our API endpoints directly to functions in the Python `robot_modes` module.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 基于网络的API有端点，其他系统会向其发送请求，并大致映射到Python模块中的函数或方法。正如你将看到的，我们将我们的API端点直接映射到Python
    `robot_modes` 模块中的函数。
- en: Before we get into building much, let's look at the design of this thing – it
    will also reveal how Mycroft works.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建之前，让我们看看这个系统的设计——它还将揭示 Mycroft 的工作方式。
- en: Overview of Mycroft controlling the robot
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mycroft 控制机器人的概述
- en: 'The following diagram shows how a user controls a robot via Mycroft:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示展示了用户如何通过 Mycroft 控制机器人：
- en: '![](img/B15660_15_04.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_15_04.jpg)'
- en: Figure 15.4 – Overview of the robot skill
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4 – 机器人技能概述
- en: 'The diagram in *Figure 15.4* shows how data flows in this system:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15.4* 中的图示展示了数据在这个系统中的流动：'
- en: On the left, it starts with the user speaking an instruction to Mycroft.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧，它从用户对 Mycroft 发出指令开始。
- en: On recognizing the wake word, Mycroft sends the sound to the Google STT engine.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在识别唤醒词后，Mycroft 将声音发送到 Google STT 引擎。
- en: Google STT returns text, an utterance, which Mycroft matches against vocabulary
    in skills/intents. We'll dig more into these later.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Google STT 返回文本，一个语音输入，Mycroft 会将其与技能/意图中的词汇进行匹配。我们稍后会更深入地探讨这些内容。
- en: This triggers intents in the robot skill, which we will build. The robot skill
    will send a request to the Raspberry Pi in the robot, on the right, as a request
    to a Flask control API (web) server.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在机器人技能中触发意图，我们将构建这个技能。机器人技能将向机器人右侧的 Raspberry Pi 发送请求，作为对 Flask 控制API（网络）服务器的请求。
- en: That control API server will start the robot processes and respond to say it's
    done so.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那个控制 API 服务器将启动机器人进程，并响应表示已完成。
- en: The robot skill will choose dialog to say it has completed and sends this to
    Mycroft.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 机器人技能将选择对话来说明它已完成，并将此信息发送给 Mycroft。
- en: Mycroft will then speak this response to the user.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Mycroft 将然后向用户说出这个响应。
- en: At this point, we are going to build the Flask server on the robot. You have
    seen Flask before in the visual processing chapters and have already installed
    this library.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将在机器人上构建 Flask 服务器。你之前在视觉处理章节中已经见过 Flask，并且已经安装了这个库。
- en: Starting a behavior remotely
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程启动行为
- en: We will use HTTP and a web server for this, as it's simple to send requests
    to, so we can build other ways to control the robot remotely. HTTP sends requests
    in a URL—first, the `http://` protocol identifier; a server hostname, `myrobot.local`;
    a path, `/mode/foo`; and it may have additional parameters after that. We use
    the path of the URL to determine what our robot does.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 HTTP 和一个网络服务器来完成这项工作，因为向其发送请求很简单，因此我们可以构建其他远程控制机器人的方法。HTTP 在 URL 中发送请求——首先，`http://`
    协议标识符；服务器主机名，`myrobot.local`；路径，`/mode/foo`；之后可能还有额外的参数。我们使用 URL 的路径来确定机器人做什么。
- en: 'As we have done with other systems, we create a few logical sections and blocks
    to handle different aspects of this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们处理其他系统一样，我们创建了一些逻辑部分和块来处理这个系统的不同方面：
- en: Code to manage the robot's modes and to start and stop known scripts. It can
    also give us a list of those known scripts.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理机器人模式和启动/停止已知脚本的代码。它还可以给我们一个已知脚本的列表。
- en: A web server to handle requests over the network.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个网络服务器来处理网络请求。
- en: We'll need to build the mode manager first.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要构建模式管理器。
- en: Managing robot modes
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理机器人模式
- en: 'We can manage modes by starting and stopping our behavior scripts as subprocesses.
    Let''s make a configuration to tell the mode manager about the modes. This configuration
    maps a mode name to a file—a Python file. Note that we are specifying a list of
    files and not inferring it. Although we could take our mode/path section and add
    `.py` to get a file, this would be bad for two reasons:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过启动和停止我们的行为脚本作为子进程来管理模式。让我们创建一个配置来告诉模式管理器关于模式的信息。这个配置将模式名称映射到一个文件——一个 Python
    文件。请注意，我们指定了一个文件列表，而不是推断它。尽管我们可以将模式/路径部分添加 `.py` 来获取一个文件，但这有两个原因是不好的：
- en: It would couple us directly to script names; it would be nice if we could change
    underlying scripts for the same mode name.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将直接与脚本名称耦合；如果我们可以更改相同模式名称的底层脚本，那将很棒。
- en: Although the robot is not a secure environment, allowing arbitrary subprocesses
    to run is very bad; restricting it keeps the robot a little more secure.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管机器人不是一个安全的环境，允许任意子进程运行是非常糟糕的；限制它可以使机器人更加安全。
- en: 'Let''s start building it:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建它：
- en: Create a file called `robot_modes.py`. This file contains a class called `RobotModes`
    that handles robot processes.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `robot_modes.py` 的文件。这个文件包含一个名为 `RobotModes` 的类，用于处理机器人进程。
- en: 'The file starts with some imports and the top of the class definition:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件以一些导入和一些类定义的顶部开始：
- en: '[PRE6]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we create a few mode mappings, mapping a mode name to a filename:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一些模式映射，将模式名称映射到文件名：
- en: '[PRE7]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The mode name is a short name, also known as a *slug*, a compromise between
    human-readable and machine-readable – they are usually restricted to lowercase
    and underscore characters and are shorter than a full English description. Our
    filenames are relatively close to slug names already.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模式名称是一个简短名称，也称为 *slug*，是可读性和机器可读性之间的折衷方案 – 它们通常仅限于小写和下划线字符，并且比完整的英文描述要短。我们的文件名已经相对接近
    slug 名称。
- en: 'With the fixed configuration aside, this class is also managing running behaviors
    as processes. It should only run one at a time. Therefore, we need a member variable
    to keep track of the current process and check whether it is running:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在固定配置之外，这个类还在管理作为进程的运行行为。它一次只能运行一个。因此，我们需要一个成员变量来跟踪当前进程并检查它是否正在运行：
- en: '[PRE8]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We should be able to check whether something is already running or it has completed:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该能够检查是否有东西已经在运行或已完成：
- en: '[PRE9]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The next function is running a process. The function parameters include a mode
    name. The function checks whether a process is running, and if not, starts a process:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个函数是运行一个进程。函数参数包括一个模式名称。该函数检查进程是否正在运行，如果不是，则启动一个进程：
- en: '[PRE10]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The class needs a way to ask it to stop a process. Note that this doesn''t
    try to stop a process when it is not running. When we stop the scripts, we can
    use Unix signals, which let us ask them to stop in a way that allows their `atexit`
    code to run. It sends the `SIGINT` signal, which is the equivalent of the *Ctrl*
    + *C* keyboard combination:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该类需要一种方法来请求它停止一个进程。请注意，当进程未运行时，它不会尝试停止进程。当我们停止脚本时，我们可以使用 Unix 信号，这允许我们以允许它们运行
    `atexit` 代码的方式请求它们停止。它发送 `SIGINT` 信号，这是 *Ctrl* + *C* 键盘组合的等效信号：
- en: '[PRE11]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After we have signaled the process, we set the current process to `None` – throwing
    away the handle.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们发出信号后，我们将当前进程设置为 `None` – 丢弃句柄。
- en: We now have code to start and stop processes, which also maps names to scripts.
    We need to wrap it in a web service that the voice agent can use.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了启动和停止进程的代码，它还将名称映射到脚本。我们需要将其封装在一个语音代理可以使用的网络服务中。
- en: Programming the Flask control API server
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程 Flask 控制API服务器
- en: We've used Flask previously to make the web server for our visual processing
    behaviors. We are going to use it for something a bit simpler this time, though.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用 Flask 创建了我们的视觉处理行为的网络服务器。这次我们将用它来做一些更简单的事情。
- en: As we saw with the start and stop buttons in the image servers, Flask lets us
    set up handlers for links to perform tasks. Let's make a script that acts as our
    control web service, which uses `Flask` and our `RobotModes` object.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在图像服务器中的启动和停止按钮所看到的，Flask 允许我们为链接设置处理程序以执行任务。让我们编写一个脚本，作为我们的控制网络服务，它使用 `Flask`
    和我们的 `RobotModes` 对象。
- en: 'Let''s build this by following these steps:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤构建它：
- en: 'Create a script called `control_server.py`. We can start by importing Flask
    and our robot modes:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `control_server.py` 的脚本。我们可以从导入 Flask 和我们的机器人模式开始：
- en: '[PRE12]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we create a Flask app to contain the routes and an instance of our `RobotModes`
    class from before:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个 Flask 应用程序来包含路由和之前创建的 `RobotModes` 类的实例：
- en: '[PRE13]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we need a route, or API endpoint, to run the app. It takes the mode name
    as part of the route:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个路由，或 API 端点，来运行应用程序。它将模式名称作为路由的一部分：
- en: '[PRE14]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We return a running confirmation.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们返回一个运行确认。
- en: 'We also need another API endpoint to stop the running process:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要另一个 API 端点来停止正在运行的过程：
- en: '[PRE15]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we need to start the server up:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要启动服务器：
- en: '[PRE16]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Power up the robot and copy both the `control_server.py` and `robot_modes.py`
    files to it.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动机器人并复制 `control_server.py` 和 `robot_modes.py` 文件到其中。
- en: 'SSH into the robot and start the control server with `python3 control_server.py`.
    You should see the following:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 SSH 连接到机器人，并使用 `python3 control_server.py` 启动控制服务器。你应该看到以下内容：
- en: '[PRE17]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now create another `ssh` window into the Mycroft Raspberry Pi – we can test
    that one talks to the other. Press *Ctrl* + *C* once into `pi@picroft.local` to
    get to the Linux command line (the `$` prompt).
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建另一个 `ssh` 窗口进入 Mycroft Raspberry Pi – 我们可以测试它是否与另一个窗口通信。在 `pi@picroft.local`
    中按一次 *Ctrl* + *C* 以进入 Linux 命令行（`$` 提示符）。
- en: The `curl` command is frequently used on Linux systems like the Raspberry Pi
    to test servers like this. It makes requests to web servers, sending/receiving
    data, and displaying the result. It's perfect for testing HTTP control APIs like
    this.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`curl` 命令在像 Raspberry Pi 这样的 Linux 系统上经常被用来测试此类服务器。它向网络服务器发送请求，发送/接收数据，并显示结果。它非常适合测试此类
    HTTP 控制API。'
- en: 'We intend to make a `post` request. Type this command:'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们打算发送一个 `post` 请求。输入以下命令：
- en: '[PRE18]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This should start the rainbows turning on and off, using the code from [*Chapter
    9*](B15660_09_Final_ASB_ePub.xhtml#_idTextAnchor171), *Programming RGB Strips
    in Python*. The `curl` command specifies that we are using the `POST` method to
    make a request, then a URL with the port, the robot hostname, then the instruction
    `run`, and then the mode name.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会启动彩虹灯的开关，使用来自[*第9章*](B15660_09_Final_ASB_ePub.xhtml#_idTextAnchor171)，*在Python中编程RGB灯带*的代码。`curl`命令指定我们使用`POST`方法发送请求，然后是一个包含端口号、机器人主机名、指令`run`和模式名称的URL。
- en: You can stop the LEDs with `curl -X POST http://myrobot.local:5000/stop`. This
    URL has the instruction `stop`. The robot LED rainbow should stop.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以用`curl -X POST http://myrobot.local:5000/stop`停止LED灯。这个URL有`stop`指令。机器人的LED彩虹灯应该会停止。
- en: Notice how both these URLs have `http://myrobot.local:5000/` at their start.
    The address may be different for your robot, depending on your hostname. This
    is a base URL for this control server.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意这两个URL都是以`http://myrobot.local:5000/`开头的。这个地址可能因你的主机名而异。这是这个控制服务器的基准URL。
- en: You can press *Ctrl* + *C* to stop this.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以按*Ctrl* + *C*来停止它。
- en: We can use this to build our Mycroft behaviors, but let's check for any problems
    before carrying on.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用这个来构建我们的 Mycroft 行为，但在继续之前，让我们检查一下是否有任何问题。
- en: Troubleshooting
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'If this isn''t working for you, we can check a few things to see what happened:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这对你不起作用，我们可以检查一些事情来看看发生了什么：
- en: If you receive any syntax errors, check your code and try again.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你收到任何语法错误，请检查你的代码并再次尝试。
- en: Please verify that your robot and the device you are testing from have internet
    availability.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请验证你的机器人和你正在测试的设备都有互联网连接。
- en: Note that when we are starting the subprocess, we are starting Python 3\. Without
    the `3`, other unexpected things will happen.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，当我们启动子进程时，我们正在启动Python 3。如果没有`3`，可能会发生一些意外的事情。
- en: First, remember the control server is running on the Raspberry Pi 3A+ on the
    robot. You will need to substitute it for your robot's address in the `curl` commands.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，记住控制服务器正在机器人的Raspberry Pi 3A+上运行。你需要在`curl`命令中用你的机器人地址替换它。
- en: Ensure you have installed Flask, as shown in [*Chapter 13*](B15660_13_Final_ASB_ePub.xhtml#_idTextAnchor283),
    *Robot Vision – Using a Pi Camera and OpenCV*.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你已经安装了Flask，如[*第13章*](B15660_13_Final_ASB_ePub.xhtml#_idTextAnchor283)，*机器人视觉
    – 使用Pi摄像头和OpenCV*中所示。
- en: Make sure you have copied both the control server and the robot mode scripts
    to the robot. You will also need the code from [*Chapter 9*](B15660_09_Final_ASB_ePub.xhtml#_idTextAnchor171),
    *Programming RGB Strips in Python* installed on the robot to run this test.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你已经将控制服务器和机器人模式脚本复制到了机器人上。你还需要在机器人上安装来自[*第9章*](B15660_09_Final_ASB_ePub.xhtml#_idTextAnchor171)，*在Python中编程RGB灯带*的代码来运行这个测试。
- en: Now we've tested the control server, you can power down the Pi. There's some
    more code to write! Let's tie this into Mycroft.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经测试了控制服务器，你可以关闭Pi的电源。还有一些代码要写！让我们将其与Mycroft连接起来。
- en: Programming a voice agent with Mycroft on the Raspberry Pi
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Raspberry Pi上使用Mycroft编程语音代理
- en: The robot backend provided by the Flask control system is good enough to create
    our Mycroft skill with.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Flask控制系统提供的机器人后端足够我们创建Mycroft技能。
- en: In *Figure 15.4*, you saw that after you say something with the wake word, upon
    waking, Mycroft will transmit the sound you made to the Google STT system. Google
    STT will then return the text.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图15.4*中，你看到在你说出唤醒词后，Mycroft会将你发出的声音传输到Google STT系统。Google STT随后会返回文本。
- en: Mycroft will then match this against vocabulary files for the region you are
    in and match that with intents set up in the skills. Once matched, Mycroft will
    invoke an intent in a skill. Our robot skill has intents that will make network
    (HTTP) requests to the Flask control server we created for our robot. When the
    Flask server responds to say that it has processed the request (perhaps the behavior
    is started), the robot skill will choose a dialog to speak back to the user to
    confirm that it has successfully carried out the request or found a problem.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Mycroft会将这些与你在该地区使用的词汇文件进行匹配，并将其与技能中设置的意图相匹配。一旦匹配，Mycroft将在技能中调用一个意图。我们的机器人技能有意图，会向为我们机器人创建的Flask控制服务器发送网络（HTTP）请求。当Flask服务器响应表示它已处理请求（可能是行为已启动）时，机器人技能将选择一个对话框对用户说话，以确认它已成功执行请求或发现问题。
- en: We'll start with a simple skill, with a basic intent, and then you can expand
    this to perform more. I've picked the rainbow LEDs test (`test_leds` from [*Chapter
    9*](B15660_09_Final_ASB_ePub.xhtml#_idTextAnchor171), *Programming RGB Strips
    in Python*) because it is simple.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简单的技能开始，有一个基本的意图，然后你可以扩展它以执行更多操作。我选择了彩虹 LED 测试（来自 [*第 9 章*](B15660_09_Final_ASB_ePub.xhtml#_idTextAnchor171)，*在
    Python 中编程 RGB 条带*），因为它很简单。
- en: It's worth noting that the time taken to get the speech processed by Google
    means that this is not suitable for stopping a robot in a hurry; the voice recognition
    can take some time. You could consider using `GPIOZero` in the intent and a `when_pressed`
    handler to trigger the control server's stop handler.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Google 处理语音所需的时间意味着这不适合紧急停止机器人；语音识别可能需要一些时间。你可以在意图中使用 `GPIOZero` 和 `when_pressed`
    处理器来触发控制服务器的停止处理器。
- en: Building the intent
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建意图
- en: 'We can start with the intent, then look at some vocabulary. To build it, we
    will use a library built into Mycroft named `adapt`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从意图开始，然后看看一些词汇。为了构建它，我们将使用 Mycroft 内置的名为 `adapt` 的库：
- en: Create a folder called `my-robot-skill`, which we will work in to build the
    Mycroft skill.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `my-robot-skill` 的文件夹，我们将在此文件夹中构建 Mycroft 技能。
- en: 'The main intent file will be an `__init__.py` file in this folder. This filename
    means that Python will treat the whole folder like a Python library, called a
    `my-robot-skill/__init__.py`:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主要意图文件将是此文件夹中的 `__init__.py` 文件。此文件名意味着 Python 将将整个文件夹视为一个 Python 库，称为 `my-robot-skill/__init__.py`：
- en: '[PRE19]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we will define our skill from the `MycroftSkill` base. It needs to set
    up its parent and prepare settings:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将从 `MycroftSkill` 基类定义我们的技能。它需要设置其父类并准备设置：
- en: '[PRE20]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next thing we need is to define an intent. We do so with a `handle_test_rainbow`
    method – but you need to decorate it using `@intent_handler`. In Python, decorating
    wraps a method in further handling – in this case, making it suitable for Mycroft:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步我们需要定义一个意图。我们通过一个 `handle_test_rainbow` 方法来实现，但你需要使用 `@intent_handler` 装饰器。在
    Python 中，装饰器会将方法包装在进一步的处理中——在这种情况下，使其适合 Mycroft：
- en: '[PRE21]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, this skill should make the request to the robot – using `requests.post`:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步，这个技能应该使用 `requests.post` 向机器人发送请求：
- en: '[PRE22]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We need Mycroft to say something, to say that it has told the robot to do something
    here:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要 Mycroft 说出一些话，表明它已经告诉机器人在这里做些什么：
- en: '[PRE23]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This request could fail for a few reasons, hence the `try` in the code snippet
    before last. We need an `except` to handle this and speak a dialog for the user.
    We also `LOG` an exception to the Mycroft console:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此请求可能因几个原因而失败，因此在代码片段的最后之前有 `try`。我们需要一个 `except` 来处理这种情况，并为用户说话一个对话框。我们还将 `LOG`
    一个异常到 Mycroft 控制台：
- en: '[PRE24]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This file then needs to provide a `create_skill` function outside of the class,
    which Mycroft expects to find in skill files:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此文件需要提供一个 `create_skill` 函数，该函数位于类外部，Mycroft 预期在技能文件中找到：
- en: '[PRE25]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The code is one part of this system, but we need to configure this before using
    it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是这个系统的一部分，但在使用它之前我们需要配置它。
- en: The settings file
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置文件
- en: Our intent started by loading a setting. We will put this in `my-robot-skill/settingsmeta.json`,
    and it defines the base URL for our control server.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的意图首先加载一个设置。我们将将其放在 `my-robot-skill/settingsmeta.json` 中，并定义我们的控制服务器的基准 URL。
- en: 'Please use the hostname/address of your robot Raspberry Pi if it is different.
    This file is a little long for this one setting, but will mean that you can configure
    the URL later if need be:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的机器人树莓派的域名/地址不同，请使用该域名/地址。此文件对于这个设置来说有点长，但意味着你可以稍后配置 URL：
- en: '[PRE26]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We have now set which base URL to use, but we need to configure Mycroft to load
    our skill.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了要使用的基准 URL，但我们需要配置 Mycroft 以加载我们的技能。
- en: The requirements file
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 要求文件
- en: 'Our skill uses the `requests` library. When Mycroft encounters our skill, we
    should tell it to expect this. In Python, requirements files are the standard
    way to do this. Put the following in `my-robot-skill/requirements.txt`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的技能使用 `requests` 库。当 Mycroft 遇到我们的技能时，我们应该告诉它期待这个。在 Python 中，要求文件是这样做的一种标准方式。将以下内容放入
    `my-robot-skill/requirements.txt`：
- en: '[PRE27]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This file is not unique to Mycroft and is used with many Python systems to install
    libraries needed by an application.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件并非仅限于 Mycroft，它还与许多 Python 系统一起使用，以安装应用程序所需的库。
- en: Now we need to tell Mycroft what to listen for, with vocabulary.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要告诉 Mycroft 它需要监听什么，即词汇。
- en: Creating the vocabulary files
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建词汇文件
- en: To define vocabularies, we need to define vocabulary files. You need to put
    them in a folder following the format `my-robot-skill/vocab/<IETF language and
    locale>`. A language/locale means we should be able to define a vocabulary for
    variants such as `en-us` for American English and `zn-cn` for simplified Chinese;
    however, at the time of writing, `en-us` is the most supported Mycroft language.
    Parts of the community are working on support for other languages.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义词汇，我们需要定义词汇文件。你需要将它们放入一个遵循格式`my-robot-skill/vocab/<IETF语言和区域设置>`的文件夹中。语言/区域设置意味着我们应该能够为变体定义词汇，例如`en-us`代表美式英语和`zn-cn`代表简体中文；然而，在撰写本文时，`en-us`是最受支持的Mycroft语言。社区的一部分正在努力支持其他语言。
- en: You define each intent with one or more vocabulary parts matching vocabulary
    files. Vocabulary files have lines representing ways to phrase the intended utterance.
    These allow a human to naturally vary the way they say things, something people
    notice when a machine fails to respond to a slightly different way of asking for
    something. There is a bit of a trick in thinking up similar phrases for the vocabulary
    files.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用一个或多个与词汇文件匹配的词汇部分来定义每个意图。词汇文件有代表预期话语方式的行。这允许人类自然地变化他们说话的方式，当机器无法以稍微不同的方式请求某事时，人们会注意到这一点。在为词汇文件想出类似短语时，有一些技巧。
- en: 'We need two vocabulary files for our intent—one for `robot` synonyms and one
    for `TestRainbow` synonyms:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为我们的意图定义两个词汇文件——一个用于`robot`同义词，另一个用于`TestRainbow`同义词：
- en: Create the folder `vocab` under `my-robot-skill`, and then the `en-us` folder
    under that.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`my-robot-skill`下创建`vocab`文件夹，然后在其中创建`en-us`文件夹。
- en: Make a file there with the path and name `my-robot-skill/vocab/en-us/robot.voc`.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那里创建一个路径和名称为`my-robot-skill/vocab/en-us/robot.voc`的文件。
- en: 'Add some phrases for *asking the robot to do something*:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些用于*请求机器人做某事*的短语：
- en: '[PRE28]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s create the vocabulary for testing the rainbow. Put it into `my-robot-skill/vocab/en-us/TestRainbow.voc`:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建用于测试彩虹的词汇。将其放入`my-robot-skill/vocab/en-us/TestRainbow.voc`：
- en: '[PRE29]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Important note
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that the vocabulary filename's capitalization must match the intent builder;
    I've then used the convention of capitalizing the non-shared vocab parts.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，词汇文件名的首字母大小写必须与意图构建器匹配；我随后使用了将非共享词汇部分首字母大写的惯例。
- en: Inevitably, when you test this, you will eventually try to say a sensible sounding
    phrase that isn't there. Mycroft will tell you *Sorry, I don't understand*, and
    you will add another expression to the vocabularies above.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试这个时，你不可避免地会尝试说出一个听起来合理的短语，但这个短语并不在那里。Mycroft会告诉你“抱歉，我不明白”，然后你会在上面的词汇表中添加另一个表达。
- en: Dialog files
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对话文件
- en: 'We also want to define the phrases Mycroft will say back to you. We have three
    phrases that our intent requires so far. These go into the `my-robot-skill/dialog/en-us`
    folder with a similar structure to vocabulary files. Let''s build them:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想要定义Mycroft会对你说的短语。到目前为止，我们有三个短语是我们意图所需的。这些短语将放入与词汇文件类似结构的`my-robot-skill/dialog/en-us`文件夹中。让我们来构建它们：
- en: Under `my-robot-skill`, create the folder `dialog`, and then under this, the
    folder `en-us`.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`my-robot-skill`下创建`dialog`文件夹，然后在其中创建`en-us`文件夹。
- en: 'In the folder, create the file with the path `my-robot-skill/dialog/en-us/Robot.dialog`.
    We can add some phrases for that here:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该文件夹中创建路径为`my-robot-skill/dialog/en-us/Robot.dialog`的文件。我们可以在其中添加一些短语：
- en: '[PRE30]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The next dialog we need is `TestRainbow.dialog` in the same folder:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个对话我们需要的是同一文件夹中的`TestRainbow.dialog`：
- en: '[PRE31]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Since we have an error handler, we should also create `UnableToReach.dialog`:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们有一个错误处理器，我们也应该创建`UnableToReach.dialog`：
- en: '[PRE32]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By defining multiple possible dialogs, Mycroft will randomly pick one to make
    itself less repetitive. We've now seen how to make vocabulary phrases and dialog
    phrases. Let's just recap what we should have.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义多个可能的对话，Mycroft会随机选择一个，使其不那么重复。我们已经看到了如何制作词汇短语和对话短语。让我们简要回顾一下我们应该有什么。
- en: Current skill folder
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当前技能文件夹
- en: 'Our skill folder should look like the following screenshot:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的技术文件夹应该看起来像以下截图：
- en: '![](img/B15660_15_05.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15660_15_05.jpg)'
- en: Figure 15.5 – Screenshot of the robot skill folder
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5 – 机器人技能文件夹截图
- en: In *Figure 15.5,* we see a screenshot showing the skill in a folder called `my-robot-skill`.
    This skill folder has the `dialog` folder, with the `en-us` subfolder and the
    three dialog files here. Below that is the `vocab` folder, with the `en-us` folder
    and two vocab files. Below the `vocab` folder, we have `__init__.py` defining
    the intents, requirements for Mycroft to install it, and a settings file. Whew
    – we've created a lot here, but it will be worth it!
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 15.5* 中，我们看到一个截图显示了名为 `my-robot-skill` 的文件夹中的技能。这个技能文件夹包含 `dialog` 文件夹，其中包含
    `en-us` 子文件夹和这里的三个对话文件。下面是 `vocab` 文件夹，包含 `en-us` 文件夹和两个词汇文件。在 `vocab` 文件夹下面，我们有
    `__init__.py` 文件，它定义了意图、Mycroft 安装它的要求和一个设置文件。哇 - 我们在这里创建了很多东西，但这一切都将是值得的！
- en: 'We are going to now need to upload this whole folder structure to our robot:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要将整个文件夹结构上传到我们的机器人：
- en: Using SFTP (FileZilla), upload this folder to your Mycroft Pi, in the `/opt/mycroft/skills`
    folder.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 SFTP（FileZilla），将此文件夹上传到你的 Mycroft Pi，在 `/opt/mycroft/skills` 文件夹中。
- en: Mycroft will automatically load this skill; you will see purple text for this
    flash past as it does the install.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Mycroft 将自动加载此技能；你将看到紫色文本在安装过程中闪烁。
- en: If you need to update the code, uploading the files to this location again will
    cause Mycroft to reload it.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你需要更新代码，再次上传文件到这个位置将导致 Mycroft 重新加载它。
- en: Any problems loading or using the skill will be shown on the Mycroft output.
    You can also find the result in `/var/log/mycroft/skills.log`—the `less` Linux
    tool is useful for looking at log output like this, using *Shift* + *G* to jump
    to the end of the file or typing `/myrobot` to jump to its output.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 加载或使用技能时遇到的问题将在 Mycroft 输出中显示。你还可以在 `/var/log/mycroft/skills.log` 中找到结果——`less`
    Linux 工具对于查看此类日志输出很有用，使用 *Shift* + *G* 跳到文件末尾或输入 `/myrobot` 跳到其输出。
- en: You can also use `tail -f /var/log/mycroft/skills.log` to see problems as they
    happen. Use *Ctrl* + *C* to stop.
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以使用 `tail -f /var/log/mycroft/skills.log` 来查看问题发生时的状态。使用 *Ctrl* + *C* 来停止。
- en: Now, power up the robot, `ssh` in, and start the control server with `python3
    control_server.py`.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开机器人的电源，使用 `ssh` 登录，并使用 `python3 control_server.py` 启动控制服务器。
- en: 'You can then try out your skill with Mycroft: *Tell the robot to turn on the
    lights*.'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以尝试使用 Mycroft 测试你的技能：*告诉机器人打开灯光*。
- en: Mycroft should beep to show the user it's awake and, once it has got the words
    from speech to text, it will send `/run/test_rainbow` to the control server on
    the robot. You should hear Mycroft say one of the dialog phrases, such as *The
    robot is testing rainbows* and see the LEDs light up.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Mycroft 应该发出哔哔声以向用户显示它已唤醒，一旦它从语音到文本转换中获取了单词，它将向机器人上的控制服务器发送 `/run/test_rainbow`。你应该听到
    Mycroft 说出其中一个对话短语，例如 *机器人正在测试彩虹*，并看到 LED 灯亮起。
- en: Troubleshooting
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'If you encounter problems making the intent respond, please try the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到意图响应的问题，请尝试以下操作：
- en: First, check the syntax and indenting of the previous Python code.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，检查之前 Python 代码的语法和缩进。
- en: Ensure that your robot and the voice assistant Raspberry Pi are on the same
    network; I've found this problematic with some Wi-Fi extenders, and IP addresses
    are needed instead of `myrobot.local`. Use the `settingsmeta.json` file to configure
    this.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你的机器人和语音助手 Raspberry Pi 在同一网络中；我发现一些 Wi-Fi 扩展器存在这个问题，需要使用 IP 地址而不是 `myrobot.local`。使用
    `settingsmeta.json` 文件来配置此设置。
- en: Ensure you have copied over the whole structure – with the `vocab`, `dialog`,
    `settingsmeta.json`, and `__init__.py` – to the `/opt/mycroft/skills` folder on
    the voice assistant Raspberry Pi.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你已经将整个结构 - 包括 `vocab`、`dialog`、`settingsmeta.json` 和 `__init__.py` - 复制到语音助手
    Raspberry Pi 的 `/opt/mycroft/skills` 文件夹中。
- en: If your settings were incorrect, you will need to change them on the [https://account.mycroft.ai/skills](https://account.mycroft.ai/skills)
    page. Look for the `My Robot` skill and change it here. You will need to save
    the change and may need to restart Mycroft or wait a few minutes for this to take
    effect.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的设置不正确，你需要在 [https://account.mycroft.ai/skills](https://account.mycroft.ai/skills)
    页面上更改它们。查找 `My Robot` 技能并在此处更改。你需要保存更改，可能需要重新启动 Mycroft 或等待几分钟以使更改生效。
- en: Ensure the way you have spoken to Mycroft matches your vocabulary files – it
    will not recognize your words otherwise.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你与 Mycroft 对话的方式与你的词汇文件相匹配 - 否则它将无法识别你的单词。
- en: You can also type phrases into the Mycroft console if you are having trouble
    with it recognizing your voice.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你遇到它识别你的声音的问题，你也可以在 Mycroft 控制台中输入短语。
- en: We've got our first intent to work! You've been able to speak to a voice assistant,
    and it has instructed the robot what to do. However, we've now started the LEDs
    flashing, and the only way to stop them is with that inconvenient `curl` command.
    We should probably fix that by adding another intent.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一种意图已经生效！你能够对语音助手说话，并且它已经指导机器人执行操作。然而，我们现在开始闪烁 LED，唯一停止它们的方法是使用那个不方便的 `curl`
    命令。我们可能需要通过添加另一个意图来修复这个问题。
- en: Adding another intent
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加另一个意图
- en: Now we have our skill, adding a second intent for it to stop becomes relatively
    easy, using another of the endpoints in our robot's control server.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了自己的技能，为它添加一个停止的第二个意图变得相对容易，使用机器人控制服务器中的另一个端点。
- en: Vocabulary and dialog
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 词汇和对话
- en: 'We need to add the vocabulary and dialog so our new intent can understand what
    we are saying and has a few things to say back:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加词汇和对话，以便我们的新意图能够理解我们所说的话，并且有一些话可以回应：
- en: 'We will need to create the `stop` vocabulary; we can put this in `my-robot-skill/vocab/en-us/stop.voc`:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建 `stop` 词汇；我们可以将其放在 `my-robot-skill/vocab/en-us/stop.voc` 中：
- en: '[PRE33]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We need a dialog file for Mycroft to tell us the robot is stopping in `my-robot-skill/dialog/en-us/stopping.dialog`:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为 Mycroft 创建一个对话文件，以便在 `my-robot-skill/dialog/en-us/stopping.dialog` 中告诉机器人它正在停止：
- en: '[PRE34]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: These will do, but you can add more synonyms if you think of them.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就足够了，但如果你想到了更多的同义词，也可以添加。
- en: Adding the code
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加代码
- en: 'Now we need to add the intent code to our skill:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将意图代码添加到我们的技能中：
- en: 'We will put this into the `MyRobot` class in `my-robot-skill/__init__.py`:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将此放入 `my-robot-skill/__init__.py` 中的 `MyRobot` 类：
- en: '[PRE35]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the same file, add the following:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，添加以下内容：
- en: '[PRE36]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The two intents now become far simpler. Change them to the following:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两个意图现在变得更为简单。将它们更改为以下内容：
- en: '[PRE37]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Adding new intents is now easier as we can reuse `handle_control`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新的意图现在更容易，因为我们能够重用 `handle_control`。
- en: Running with the new intent
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用新意图运行
- en: You can now upload the folder structure again—since the `vocab`, `dialog`, and
    `__init__` files have changed. When you do so, note that Mycroft will automatically
    reload the changed skill (or show any problems trying to do so), so it is immediately
    ready to use.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以再次上传文件夹结构——因为 `vocab`、`dialog` 和 `__init__` 文件已经更改。当你这样做时，请注意 Mycroft 将自动重新加载更改后的技能（或显示尝试这样做时出现的任何问题），因此它立即可以投入使用。
- en: Try this out by saying *Mycroft, tell the robot to stop*.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 通过说出 *Mycroft，告诉机器人停止* 来尝试一下。
- en: You've now added a second intent to the system, defining further vocabulary
    and dialogs. You've also refactored this code, having seen some repetition. You've
    now got the beginnings of voice control for your robot.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已向系统中添加了第二个意图，定义了更多的词汇和对话。你也已经重构了这段代码，因为看到了一些重复。现在，你的机器人已经开始具备语音控制功能。
- en: Summary
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about voice assistant terminology, speech to text,
    wake words, intents, skills, utterances, vocabulary, and dialog. You considered
    where you would install microphones and speakers and whether they should be on
    board a robot.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了语音助手术语、语音转文本、唤醒词、意图、技能、话语、词汇和对话。你考虑了麦克风和扬声器的安装位置，以及它们是否应该安装在机器人上。
- en: You then saw how to physically install a speaker/microphone combination onto
    a Raspberry Pi, then prepare software to get the Pi to use it. You installed Picroft
    – a Mycroft Raspbian environment, getting the voice agent software.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 你随后看到了如何将扬声器/麦克风组合物理安装在 Raspberry Pi 上，然后准备软件以便 Pi 使用它。你安装了 Picroft – 一个 Mycroft
    Raspbian 环境，获取了语音代理软件。
- en: You were then able to play with Mycroft and get it to respond to different voice
    commands and register it with its base.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 你随后能够与 Mycroft 互动，让它响应不同的语音命令，并将其与基础注册。
- en: You then saw how to make a robot ready for an external agent, such as a voice
    agent to control it with a Flask API. You were able to create multiple skills
    that communicate with a robot, with a good starting point for creating more.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 你还看到了如何使机器人准备好接受外部代理，例如使用 Flask API 的语音代理来控制它。你能够创建多个与机器人通信的技能，为创建更多技能提供了良好的起点。
- en: In the next chapter, we will bring back out the IMU we introduced in [*Chapter
    12*](B15660_12_Final_ASB_ePub.xhtml#_idTextAnchor251), *IMU Programming with Python*,
    and get it to do more interesting things – we will smooth and calibrate the sensors
    and then combine them to get a heading for the robot, programming the robot to
    always turn north.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾在第 12 章[*第 12 章*](B15660_12_Final_ASB_ePub.xhtml#_idTextAnchor251)中引入的
    IMU，*使用 Python 进行 IMU 编程*，并让它做更多有趣的事情——我们将平滑和校准传感器，然后将它们组合起来为机器人获取航向，编程机器人始终朝北转。
- en: Exercises
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Try these exercises to get more out of this chapter and expand your experience:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些练习以充分利用本章内容并扩展你的经验：
- en: 'Try installing some other Mycroft skills from the Mycroft site and playing
    with them. Hint: say *Hey Mycroft, install pokemon*.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试从Mycroft网站安装一些其他Mycroft技能并与之互动。提示：说“Hey Mycroft，install pokemon”。
- en: The robot mode system has a flaw; it assumes that a process you've asked to
    stop does stop. Should it wait and check the return code to see if it has stopped?
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人模式系统有一个缺陷；它假设你要求停止的过程确实停止了。它应该等待并检查返回代码以查看是否已停止吗？
- en: An alternative way to implement the robot modes might be to update all the behaviors
    to exit cleanly so you could import them instead of running in subprocesses. How
    tricky would this be?
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现机器人模式的另一种方法可能是更新所有行为以干净地退出，这样你就可以导入它们而不是在子进程中运行。这会多么棘手？
- en: While testing the interactions, did you find the vocabulary wanting? Perhaps
    extend it with phrases you might find more natural to start the different behaviors.
    Similarly, you could make dialogs more interesting too.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试交互时，你是否觉得词汇量不足？也许你可以用更自然的短语来开始不同的行为。同样，你也可以使对话更有趣。
- en: Add more intents to the skill, for example, wall avoiding. You could add a stop
    intent, although the response time may make this less than ideal.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向技能添加更多意图，例如，避障。你可以添加一个停止意图，尽管响应时间可能会使这不太理想。
- en: Could the RGB LEDs on the ReSpeaker 2-Mics Pi HAT be used? The project [https://github.com/respeaker/mic_hat](https://github.com/respeaker/mic_hat)
    has an LED demonstration.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ReSpeaker 2-Mics Pi HAT上的RGB LED可以使用吗？项目[https://github.com/respeaker/mic_hat](https://github.com/respeaker/mic_hat)有一个LED演示。
- en: With these ideas, there is plenty of room to explore this concept more. Further
    reading will help too.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 有这些想法，有足够的空间来进一步探索这个概念。进一步的阅读也会有所帮助。
- en: Further reading
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Please refer to the following for more information:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下信息以获取更多信息：
- en: '*Raspberry Pi Robotic Projects*, *Dr. Richard Grimmett*, *Packt Publishing*,
    has a chapter on providing speech input and output.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《树莓派机器人项目》*，*理查德·格里姆特博士*，*Packt Publishing*，有一章介绍语音输入和输出。'
- en: '*Voice User Interface Projects*, *Henry Lee*, *Packt Publishing*, focuses entirely
    on voice interfaces to systems. It shows you how to build chatbots and applications
    with the Alexa and Google Home voice agents.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《语音用户界面项目》*，*亨利·李*，*Packt Publishing*，专注于系统的语音界面。它展示了如何使用Alexa和Google Home语音代理构建聊天机器人和应用程序。'
- en: '*Mycroft AI – Introduction Voice Stack* – a whitepaper from Mycroft AI gives
    more detail on how the Mycroft stack works and its components.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Mycroft AI – 语音栈介绍》* – Mycroft AI的一份白皮书提供了更多关于Mycroft栈如何工作及其组件的详细信息。'
- en: Mycroft has a large community that supports and discusses the technology at
    [https://community.mycroft.ai/](https://community.mycroft.ai/). I recommend consulting
    the troubleshooting information of this community. Mycroft is under active development
    and has both many quirks and many new features. It's also an excellent place to
    share skills you build for it.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mycroft有一个庞大的社区支持并讨论这项技术，请参阅[https://community.mycroft.ai/](https://community.mycroft.ai/)。我建议咨询这个社区的故障排除信息。Mycroft正在积极开发中，既有许多怪癖，也有许多新功能。它也是一个分享你为它构建的技能的绝佳地方。
- en: Seeed Studio, the ReSpeaker 2-Mics Pi HAT creators, host documentation and code
    for this device, along with bigger four and six-microphone versions at [https://github.com/respeaker/seeed-voicecard](https://github.com/respeaker/seeed-voicecard).
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看[https://github.com/respeaker/seeed-voicecard](https://github.com/respeaker/seeed-voicecard)以获取Seeed
    Studio，ReSpeaker 2-Mics Pi HAT的创造者，提供的关于此设备的文档和代码，以及更大型的四麦克风和六麦克风版本。
