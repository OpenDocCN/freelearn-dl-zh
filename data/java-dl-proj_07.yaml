- en: Stock Price Prediction Using LSTM Network
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LSTM网络进行股票价格预测
- en: Stock market price prediction is one of the most challenging tasks. One of the
    major reasons is noise and the volatile features of this type of dataset. Therefore,
    how to predict stock price movement accurately is still an open question for the
    modern trading world. However classical machine learning algorithms, such as Support
    vector machines, decision trees, and tree ensembles (for example, random forest
    and gradient-boosted trees), have been used in the last decade.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 股票市场价格预测是最具挑战性的任务之一。一个主要原因是噪声和这种类型数据集的波动特性。因此，如何准确预测股价走势仍然是现代交易世界中的一个未解问题。然而，经典的机器学习算法，如支持向量机、决策树和树集成算法（例如，随机森林和梯度提升树），在过去十年中已被广泛应用。
- en: However, stock market prices have severe volatility and a historical perspective,
    which make them suited for time series analysis. This also challenges those classical
    algorithms, since long-term dependencies cannot be availed using those algorithms.
    Considering these challenges and the limitations of existing algorithms, in this
    chapter, we will see how to develop a real-life plain stock open or close price
    prediction using, LSTM on top of DL4J library.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，股市价格存在严重的波动性和历史视角，这使得它们适合进行时间序列分析。这也对经典算法提出了挑战，因为这些算法无法利用长期依赖关系。考虑到这些挑战和现有算法的局限性，在本章中，我们将学习如何利用LSTM并基于DL4J库开发一个真实的股票开盘或收盘价预测模型。
- en: 'A time series dataset generated from a real-life stock dataset will be used
    to train the LSTM model, which will be used to predict only one day ahead at a
    time. Briefly, we will learn the following topics throughout this end-to-end project:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用从真实股市数据集生成的时间序列数据集来训练LSTM模型，该模型将用于预测一次仅一天的股票价格。简而言之，我们将在整个端到端的项目中学习以下内容：
- en: Stock price prediction and online trading
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 股票价格预测与在线交易
- en: Data collection and description
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据收集与描述
- en: Stock price prediction with LSTM
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LSTM进行股票价格预测
- en: FAQs.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见问题解答（FAQ）
- en: State-of-the-art automated stock trading
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 先进的自动化股票交易
- en: Usually, in a security exchange, exchanges maintain order book lists of all
    buy and sell orders with their quantity and prices, and they execute them when
    a match is found between somebody buying and selling. In addition, exchanges keep
    and provide statistics about state trading, often captured as **OHCL** (short
    for, **open-high-close-low**) and volume for both currencies of a trader pair.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在证券交易所，交易所会维护所有买卖订单的订单簿，包括它们的数量和价格，并在买方和卖方匹配时执行这些订单。此外，交易所还会保持并提供关于状态交易的统计数据，这些数据通常以**OHCL**（即**开盘-最高-最低-收盘**）和交易对货币的成交量形式呈现。
- en: 'By the way, bar charts are used, showing open, high, low, and closing prices.
    Unlike line charts, OHLC charts enable technical analysts to evaluate intra-day
    volatility and see where prices opened and closed. Take a look at this diagram:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，柱状图用于展示开盘价、最高价、最低价和收盘价。与线形图不同，OHLC图表使得技术分析师能够评估日内波动性，并查看价格的开盘和收盘情况。看看这个图表：
- en: '![](img/82d2422a-194a-432b-ba95-c5cb07a2f637.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82d2422a-194a-432b-ba95-c5cb07a2f637.png)'
- en: 'OHLC pricing model showing the open, high, low, and close prices of a certain
    time period (source: http://en.tradimo.com/tradipedia/ohlc-chart/)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: OHLC定价模型展示了某一时间段的开盘价、最高价、最低价和收盘价（来源：[http://en.tradimo.com/tradipedia/ohlc-chart/](http://en.tradimo.com/tradipedia/ohlc-chart/)）
- en: This data is being presented as aggregated in some periods, from seconds to
    days, and even months. There are dedicated servers working on collecting this
    data for professional traders and institutions. Although you cannot expect to
    have all the order data available for free, some of it is accessible to the public
    and can be used. The first set is historical stock trading data (OHLC), and the
    second contains the technical indicators of stock trading.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据以某些时间段的聚合形式展示，从秒到天，甚至是几个月。专门的服务器在为专业交易员和机构收集这些数据。虽然你不能指望所有订单数据都可以免费获取，但其中一部分是对公众开放的，并且可以使用。第一组数据是历史股市交易数据（OHLC），第二组数据包含股市交易的技术指标。
- en: 'For example, Bitcoin, which is one of the first cryptocurrencies, has attracted
    the interest of investors and traders. This is because of the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，比特币作为最早的加密货币之一，吸引了投资者和交易员的关注。这是因为以下原因：
- en: With Bitcoin, is possible to start trading
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用比特币，可以开始进行交易
- en: Bitcoin allows you to stay pseudo-anonymous
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比特币让你保持伪匿名状态
- en: There has been, dramatic growth during Bitcoin's history (see the following
    graph for some statistics), which lures long-term investors
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在比特币的历史中，曾经历过剧烈的增长（见下图的一些统计数据），这吸引了长期投资者
- en: There is high volatility, which attracts daytraders
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在高度的波动性，这吸引了日内交易者
- en: 'It is hard to predict the value of Bitcoin in the long term, as the value behind
    Bitcoin is less tangible, and its price mostly reflects market perception and
    is highly dependent on news, regulations, collaboration of governments and banks,
    technical issues of platform, such as transactions fees and size of block, interest
    of institutional investors in including Bitcoin into their portfolio and so on.
    Take a look at this screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 难以预测比特币的长期价值，因为比特币背后的价值较为抽象，其价格主要反映市场认知，并且高度依赖于新闻、法规、政府与银行的合作、平台的技术问题，如交易费用和区块大小、机构投资者是否将比特币纳入其投资组合等。看看这个截图：
- en: '![](img/5ff3ea00-951a-4fdb-81e1-cff8e2922efb.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ff3ea00-951a-4fdb-81e1-cff8e2922efb.jpg)'
- en: 'Bitcoin and its dramatic price increases until September 2017 (source: http://www.bitcoin2040.com/bitcoin-price-history/)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币及其在2017年9月之前的剧烈价格上涨（来源：http://www.bitcoin2040.com/bitcoin-price-history/）
- en: 'Now the question would be how to analyze this dataset in an automated way to
    help an investor or an online currency trader. Well, in the world of traditional
    securities, such as company''s stocks, it used to be humans who would do the analytics,
    predict stock prices, and make the trades. Currently, the volume of Bitcoin trading
    is relatively low compared to traditional exchanges. Two of the reasons for this
    are high volatility in the stock market and regulations of cryptocurrencies. Take
    a look at this diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是如何以自动化的方式分析这个数据集，帮助投资者或在线货币交易者。好吧，在传统证券世界中，比如公司的股票，过去是由人来做分析，预测股价并进行交易。目前，比特币的交易量相较于传统交易所来说还是较低的。造成这种情况的两个原因是股市的高波动性和加密货币的监管问题。看看这个图表：
- en: '![](img/71929ab3-01a2-46fa-8a9d-fee88f1af575.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71929ab3-01a2-46fa-8a9d-fee88f1af575.png)'
- en: 'Bitcoin buy and sell orders for the BTC/USD pair (until June 18th, 2018, source:
    https://cex.io/trade#)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币的买卖订单数据（BTC/USD对，截止2018年6月18日，来源：https://cex.io/trade#）
- en: So, today, people mostly buy and sell Bitcoins with all the consequences of
    irrational behavior connected to that, but some attempts to automate Bitcoin trading
    have been made. The most famous one was a paper by MIT and another one by Stanford
    researchers, published in 2014.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在人们主要通过购买和出售比特币进行交易，而这一切都伴随着与此相关的非理性行为，但也有一些尝试将比特币交易自动化的努力。最著名的尝试之一是麻省理工学院和斯坦福大学研究人员于2014年发布的一篇论文。
- en: Many things have changed, and taking into account the massive Bitcoin price
    increase during the last three years, anyone who would just buy and hold would
    be satisfied enough with the results. Definitely, some traders use **machine learning**
    (**ML**) for trading, and such applications look promising. Up to now, a few best
    possible approaches.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 许多事情已经发生了变化，考虑到过去三年比特币价格的大幅上涨，任何只买入并持有的人都会对结果感到满意。显然，一些交易者使用**机器学习**（**ML**）进行交易，这类应用看起来很有前景。直到现在，仍然有几种最佳的可能方法。
- en: 'For the training, use order-book data instead of derived *OHLC + volume data*.
    Therefore, for training and prediction, use data in the following way:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于训练，使用订单簿数据，而不是衍生的*OHLC + 成交量数据*。因此，训练和预测时，使用以下方式的数据：
- en: Split the data into a time series of a certain size (where size is a parameter
    to adjust).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据拆分为某一大小的时间序列（其中大小是一个可以调整的参数）。
- en: Cluster the time series data into *K* clusters, where *K* is the only parameter
    to tune. It is assumed that clusters with some natural trends will appear (sharp
    drop/rise in price and so on).
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将时间序列数据聚类为*K*个集群，其中*K*是唯一需要调节的参数。假设某些具有自然趋势的集群会出现（如价格的急剧下跌/上涨等）。
- en: For each cluster, train the regression/classifier to predict the price and the
    price change, respectively.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对每个集群，训练回归/分类器，分别预测价格和价格变化。
- en: 'For the inferencing and evaluation, this approach considers the most recent
    time series with the size of a specific window and trains the model. Then it classifies
    the data as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于推理和评估，这种方法考虑了最新的时间序列，并使用特定窗口的大小来训练模型。然后，它会按如下方式对数据进行分类：
- en: It takes the most-recent time series with window size used for training and
    classifies it—which of the clusters does it belong to?
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会采用用于训练的窗口大小的最新时间序列，并对其进行分类——它属于哪个集群？
- en: It uses the ML model to predict the clusters for the price and the price change
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用机器学习模型来预测价格和价格变动的聚类
- en: This solution comes from 2014, but, still, it gives a certain level of robustness.
    By having many parameters to identify, and not having order-book historical data
    available, in this project, we use a simpler approach and dataset.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案来源于2014年，但仍然具有一定的鲁棒性。由于需要识别多个参数，并且没有可用的订单簿历史数据，在本项目中我们使用了一种更简单的方法和数据集。
- en: Developing a stock price predictive model
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发股票价格预测模型
- en: As stated earlier, the stock market price has severe volatility and historical
    perspective, which make it suited for time analysis. This also challenges those
    classical algorithms, since long-term dependencies cannot be availed using those
    algorithms.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，股市价格具有较大的波动性和历史视角，这使得它非常适合时间序列分析。这也对经典算法构成了挑战，因为这些算法无法处理长期依赖关系。
- en: 'As outlined in following diagram, first we collect historical financial data.
    The data is then converted into a time series after the necessary preprocessing
    and feature engineering. The resultant time series data is then fed into the LSTM
    to carry out the training. The following diagram illustrates this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，首先我们收集历史财务数据。数据经过必要的预处理和特征工程后，转换成时间序列。最终生成的时间序列数据被输入到LSTM中进行训练。下图展示了这一过程：
- en: '![](img/f14e1f05-03e4-49e8-b51d-2cb98fb5e010.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f14e1f05-03e4-49e8-b51d-2cb98fb5e010.png)'
- en: High-level data pipeline of the prototype used for this project
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目原型的高层数据管道
- en: 'Therefore, we will be using LSTM not only because it outperforms classical
    algorithms but also because we can solve long-term dependencies with it. Consequently,
    our project will have the following steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将使用LSTM模型，不仅因为它优于经典算法，还因为它能够解决长期依赖问题。因此，我们的项目将包括以下步骤：
- en: Load and preprocess the data, and split it into train-and-test sets
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载并预处理数据，并将其划分为训练集和测试集
- en: Train the `LSTM` model with the data
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数据训练`LSTM`模型
- en: Evaluate the model on test data
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试数据上评估模型
- en: Visualize the model's performance
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可视化模型的表现
- en: We will go into the details of each step. However, before that, knowing about
    the dataset is mandatory.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细讲解每一步。但在此之前，了解数据集是必须的。
- en: Data collection and exploratory analysis
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据收集与探索性分析
- en: 'As stated earlier, we will utilize historical stock data for training our LSTM
    network. The dataset has one minute OHLC data from 506 different securities for
    the period of January 2016 to December 2016\. Let''s take a look at the data we''ll
    be using:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用历史股票数据来训练我们的LSTM网络。数据集包含来自506只不同证券的每分钟OHLC数据，时间跨度为2016年1月至2016年12月。让我们来看一下我们将使用的数据：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following snapshot shows the output from this code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下快照展示了该代码的输出：
- en: '![](img/208ceae0-fcfb-426c-8b6a-9155f4a640b9.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/208ceae0-fcfb-426c-8b6a-9155f4a640b9.png)'
- en: A snapshot of the historical dataset used in this project
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目使用的历史数据集快照
- en: 'As shown in the preceding screenshot, our dataset has seven features. They''re
    described as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，我们的数据集包含七个特征，具体如下：
- en: '`date`: Time elapsed between January 2016 and December 2016'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date`：2016年1月到2016年12月之间的时间'
- en: '`symbol`: Ticker symbols for 506 different securities'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`symbol`：506只不同证券的股票代码'
- en: '`open`: The price at the opening of the time interval'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open`：时间区间开始时的开盘价'
- en: '`close`: The price at the closing of the time interval'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`close`：时间区间结束时的收盘价'
- en: '`high`: The highest price from all orders executed during the interval'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`high`：该时间区间内所有订单执行时的最高价格'
- en: '`low`: Same, but the lowest price'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`low`：同样的，但为最低价格'
- en: '`volume`: The sum of all stocks that were transferred during the time interval'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volume`：该时间段内所有转手的股票数量'
- en: 'Now let''s take a look at some ticker symbols (see more in the `securities.csv`
    file):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看一些股票代码（更多内容请见`securities.csv`文件）：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The is snapshot shows the output from the previous code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是上一段代码的输出快照：
- en: '![](img/f37203cb-a74a-45d1-a265-b15798aa6f39.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f37203cb-a74a-45d1-a265-b15798aa6f39.png)'
- en: Some symbols whose stock price data is used in this project
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目使用的部分股票符号及其价格数据
- en: 'If we need to learn about securities, the following table gives us some insight
    into this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要了解证券，以下表格可以为我们提供一些信息：
- en: '![](img/3a316da5-b3f4-456e-8f19-ae25733137ce.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a316da5-b3f4-456e-8f19-ae25733137ce.png)'
- en: Some securities and their details, whose stock price data is used in this project
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目使用的部分证券及其详细信息
- en: 'Then we decide to see the average price of four categories—open, close, low,
    and high—for all individual securities. Take a look at this code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们决定查看所有个别证券的四个类别的平均价格——开盘价、收盘价、最低价和最高价。看看这个代码：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This snapshot shows the output from the previous code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个快照展示了之前代码的输出：
- en: '![](img/0d3ef10e-1382-4c28-925b-47e88fdf52dd.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d3ef10e-1382-4c28-925b-47e88fdf52dd.png)'
- en: Average prices for the open, close, low, and high categories
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 开盘价、收盘价、最低价和最高价的平均价格。
- en: 'The preceding table, however, did not provide much insight, except when it
    came to the average prices. Therefore, knowing the minimum and maximum prices
    gives us an idea whether the stock market really has very high volatility. Take
    a look at this code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前面的表格并没有提供太多的见解，除了平均价格这一点。因此，知道最小值和最大值价格可以让我们了解股票市场是否真的有很高的波动性。看看这个代码：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This snapshot shows the code''s output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个快照展示了代码的输出：
- en: '![](img/04cd7d7a-8537-4109-82b3-ad82144cae72.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04cd7d7a-8537-4109-82b3-ad82144cae72.png)'
- en: Average max and min prices for the open, close, low, and high categories
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 开盘价、收盘价、最低价和最高价的平均最大和最小价格。
- en: This table shows, for example, that the minimum opening and closing prices are
    not significantly different. However, the maximum opening price or even the closing
    price is very different. This is the nature of time series data, and it motivated
    me to choose `LSTM` by converting the data into a time series.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表格展示了例如最小开盘价和收盘价并没有显著的差异。然而，最大开盘价甚至收盘价差异很大。这是时间序列数据的特点，它促使我选择通过将数据转换为时间序列来使用
    `LSTM`。
- en: Preparing the training and test sets
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备训练集和测试集。
- en: One of the most important parts of the data science pipeline, after data collection
    (which was in a sense outsourced—we use data collected by others) is data preprocessing,
    that is, clearing the dataset and transforming it to suit our needs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学流程中最重要的部分之一，在数据收集（从某种意义上讲是外包的——我们使用了别人收集的数据）之后，就是数据预处理，即清理数据集并将其转换为适应我们需求的格式。
- en: 'So, our goal is to predict the direction of price change from the actual price
    in dollars over time. To do that, we define variables such as `file`, `symbol`,
    `batchSize`, `splitRatio`, and `epochs`. You can see the explanation of each variable
    in the inline comments within this code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们的目标是预测价格变化的方向，基于实际的美元价格随时间的变化。为了做到这一点，我们定义了像 `file`、`symbol`、`batchSize`、`splitRatio`
    和 `epochs` 这样的变量。你可以在代码中的内联注释中看到每个变量的解释：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We use the `StockDataSetIterator` constructor variable to prepare the dataset
    for the model. Here, we prepare the input dataset for the model as a sequence
    format for `category = PriceCategory.ALL`, which means we will predict all five
    price categories (open, close, low, high, and volume). Take a look at this code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `StockDataSetIterator` 构造函数变量来为模型准备数据集。在这里，我们为模型准备了一个按序列格式的输入数据集，`category
    = PriceCategory.ALL`，这意味着我们将预测所有五个价格类别（开盘价、收盘价、最低价、最高价和成交量）。看看这个代码：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code block, the `PriceCategory` constructor that we used has
    the following signature:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们使用的 `PriceCategory` 构造函数具有以下签名：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the same line, the following options are valid too:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一行中，以下选项也是有效的：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Whereas, inside, the constructor function of the `StockDataSetIterator` class
    has the following functionalities:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 而在内部，`StockDataSetIterator` 类的构造函数具有以下功能：
- en: We read the stock data from the file, and for each symbol we create a list
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从文件中读取股票数据，对于每个符号，我们创建一个列表。
- en: We set the `miniBatchSize`, `exampleLength`, and `category` variables to class
    properties
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 `miniBatchSize`、`exampleLength` 和 `category` 变量设置为类的属性。
- en: Then the `split` variable is computed based on the `splitRation` variable
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，`split` 变量是根据 `splitRation` 变量计算得出的。
- en: 'We separate the `stockDataList` into two parts: train and test'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 `stockDataList` 分成两部分：训练集和测试集。
- en: Then the stock data is split into training and test sets
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，股票数据被分割成训练集和测试集。
- en: We call the function `initializeOffsets()` to initial value for the array `exampleStartOffsets`
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用函数 `initializeOffsets()` 来初始化 `exampleStartOffsets` 数组的值。
- en: 'Following this, the `StockDataSetIterator()` constructor has the following
    signature, which generates the test dataset as a `List<Pair<INDArray, INDArray>>`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`StockDataSetIterator()` 构造函数具有以下签名，它将生成一个 `List<Pair<INDArray, INDArray>>`
    类型的测试数据集：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the following code, `StockData` is a case class that provides the structure
    of the dataset to be extracted or prepared from the input `CSV` file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，`StockData` 是一个 case 类，提供了从输入的 `CSV` 文件中提取或准备数据集的结构：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then we have the following getter and setter methods for the aforementioned
    variable, which are as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有以下的getter和setter方法，用于上述变量，如下所示：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now that we have seen the signature for the `StockData.java` class, it''s time
    to create the test dataset as `StockDataSetIterator`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过`StockData.java`类的签名，是时候创建测试数据集作为`StockDataSetIterator`了：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding method, the `initializeOffsets()` method is invoked to initialize
    the mini-batch offsets:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，调用了`initializeOffsets()`方法来初始化小批量的偏移量：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The actual reading is done using the `readStockDataFromFile()` method. Inside
    the constructor, first, we call the function `readStockDataFromFile()` to read
    data from the file and load it to the `stockDataList`. Then we initialize the
    `StockDataList` list to contain data read from the `csv` file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 实际读取是通过`readStockDataFromFile()`方法完成的。在构造函数内部，首先，我们调用函数`readStockDataFromFile()`从文件中读取数据并加载到`stockDataList`中。然后，我们初始化`StockDataList`列表，以包含从`csv`文件中读取的数据。
- en: 'Next, we initialize max in min arrays with `Double.MIN_VALUE` and `Double.MAX_VALUE`.
    Then the `CSV` file is read line by line for five values. The values are inserted
    subsequently into the constructor of the `StockData` object, and we add this object
    to `StockDataList`. Additionally, we throw if we have any exception. Finally,
    the method returns `StockDataList`. The signature of the method is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们用`Double.MIN_VALUE`和`Double.MAX_VALUE`初始化最大值和最小值数组。然后，逐行读取`CSV`文件中的五个值。接着将这些值依次插入到`StockData`对象的构造函数中，并将该对象添加到`StockDataList`中。此外，如果出现任何异常，我们会抛出异常。最后，方法返回`StockDataList`。方法的签名如下：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then the `generateTestDataSet()` method actually generates the features only
    consumable by the `LSTM` model as `List<Pair<INDArray, INDArray>>`, where the
    ordering is set as `f` for faster construct:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`generateTestDataSet()`方法实际上生成仅能由`LSTM`模型消费的特征，格式为`List<Pair<INDArray, INDArray>>`，其中排序设置为`f`以便更快构建：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the previous code block, we save the `miniBatchSize`, `exampleLength`, and
    `category` variables as class properties. Then we compute the `split` variable
    based on the `splitRation` variable. We then separate the `stockDataList` into
    two parts:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们将`miniBatchSize`、`exampleLength`和`category`变量保存为类属性。然后，根据`splitRation`变量计算`split`变量。接着，我们将`stockDataList`分为两部分：
- en: Indices starting from the beginning to `split` belong to train set
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从开始到`split`的索引属于训练集。
- en: Indices starting from split+1 to the end of the list belong to test set.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`split+1`到列表末尾的索引属于测试集。
- en: 'The test data generated is quite different from the train dataset. Call the
    function `generatedTestDataSet()` to set up the test dataset. First, we set a
    window variable by the example length and the prediction length. Then we loop
    through from 0 to test the data length minus the window. Consider the following::'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的测试数据与训练数据集差异很大。调用函数`generatedTestDataSet()`来设置测试数据集。首先，我们通过示例长度和预测长度设置一个窗口变量。然后，我们从0开始循环，直到测试数据的长度减去窗口大小。请考虑以下内容：
- en: 'Read five input variables: open price, close price, low price, high price,
    and volume.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取五个输入变量：开盘价、收盘价、最低价、最高价和交易量。
- en: Base on the value of `category`, read the label value. If `category` is equal
    to `ALL`, then read five variables such as input variables. Otherwise, read only
    one variable via the value of `category`.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于`category`的值，读取标签值。如果`category`等于`ALL`，则读取五个变量，如输入变量。否则，仅通过`category`的值读取一个变量。
- en: 'In the preceding code block, the labels are being fed using the `feedLabel()`
    method, which goes as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，标签是通过`feedLabel()`方法传递的，具体如下：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding code block, we initialize variable `value`. We then check
    the value of variable `category`, and the computed value of variable `value` can
    be seen using math notation as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们初始化变量`value`。然后检查变量`category`的值，计算出的变量`value`的值可以用数学符号表示如下：
- en: '`value = (data.getOpen() - minArray[0]) / (maxArray[0] - minArray[0])`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`value = (data.getOpen() - minArray[0]) / (maxArray[0] - minArray[0])`'
- en: 'Then both the features and labels are used to prepare the dataset. Take a look
    at this code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，特征和标签都被用来准备数据集。看看这段代码：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding code block, we loop through the `epochs` time, and for each
    time we loop until we have the data, fitting the network with a data get in function
    `iterator.next()`. Consider the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们循环`epochs`次数，对于每次循环，直到获取到数据，我们通过`iterator.next()`函数将数据拟合到网络中。请考虑以下内容：
- en: 'We initialize two variables: `input` using `actualMinibatchSize` and `label`
    with `category`.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们初始化两个变量：`input`使用`actualMinibatchSize`，`label`使用`category`。
- en: 'We then loop from 0 to `actualMiniBatchSize`. Each time, we create two additional
    variables: `curData` , which is a `StockData` point of current time. Then we put
    their value into the `input` list. Similarly the`nextData` variable is also a
    `StockData` point of the day, which is after the day of `curData` . Finally, we
    put the value of `nextData` to `label` list.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们从0循环到`actualMiniBatchSize`。每次循环时，我们创建两个额外的变量：`curData`，它是当前时间点的`StockData`数据。然后我们将它们的值放入`input`列表中。类似地，`nextData`变量也是一天的`StockData`数据，它是`curData`数据的后一天。最后，我们将`nextData`的值放入`label`列表中。
- en: LSTM network construction
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LSTM网络构建
- en: As stated earlier, I wrote a class called `RecurrentNets.java` to build an LSTM
    network. We create a `MultilayerNetwork` LSTM network that consists of an input
    layer, four LSTM layers, three dense layers, and an output layer. The input consists
    of sequences of genetic variants.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我编写了一个名为`RecurrentNets.java`的类来构建LSTM网络。我们创建了一个`MultilayerNetwork` LSTM网络，包含一个输入层、四个LSTM层、三个密集层和一个输出层。输入由基因变异的序列组成。
- en: 'We use the `BuildBuildLstmNetworks()` method with two parameters—number of
    input for input layers and number of output for output layers, as shown here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`BuildBuildLstmNetworks()`方法，传入两个参数——输入层的输入数量和输出层的输出数量，如下所示：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, before we start creating and building the network, let''s see what our
    model would look like:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们开始创建和构建网络之前，先来看看我们的模型将是什么样子：
- en: '![](img/f4bfded0-ee1e-4a5e-9966-35f85db1c7b5.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4bfded0-ee1e-4a5e-9966-35f85db1c7b5.png)'
- en: The stock price LSTM network
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 股票价格LSTM网络
- en: 'Then, the `createAndBuildLstmNetworks()` method is used to create and build
    the network with the preceding parameter setting:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`createAndBuildLstmNetworks()`方法根据前面的参数设置创建并构建网络：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Since we created and used an `LSTM` net several times in this chapter, I decided
    not to discuss its details. However, one important thing here is the use of the
    `IDENTITY` activation with `Root Means Square Errors (RMSE)`, which is used for
    regression problems.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在本章中多次创建并使用了`LSTM`网络，我决定不讨论它的详细内容。不过，这里有一个重要的点是使用了`IDENTITY`激活函数，并结合`均方根误差（RMSE）`，它通常用于回归问题。
- en: 'In short, to perform regression with a neural network in DL4J, you would set
    up a multilayer neural network and add an output layer at the end with the following
    properties, as shown previously:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，要在DL4J中执行回归分析，你需要设置一个多层神经网络，并在末尾添加一个输出层，具有如下属性，如前所示：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For more information on regression analysis using DL4j, interested readers can
    visit [https://deeplearning4j.org/evaluation#Regression](https://deeplearning4j.org/evaluation#Regression).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用DL4J进行回归分析的更多信息，感兴趣的读者可以访问[https://deeplearning4j.org/evaluation#Regression](https://deeplearning4j.org/evaluation#Regression)。
- en: Network training, and saving the trained model
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络训练，以及保存训练好的模型
- en: 'Now that our network as well as the training and test sets are ready, we can
    start training the network. For this, again we use the DL4J-provided `fit()` method.
    We loop through `epochs` times, for each time looping until we have the data.
    We fit the network with a `miniBatchSize` amount of data at each time step, as
    shown here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然我们的网络以及训练和测试集已经准备好，我们就可以开始训练网络了。为此，我们再次使用DL4J提供的`fit()`方法。我们循环`epochs`次数，每次循环直到获得数据。我们在每个时间步中使用`miniBatchSize`数量的数据来拟合网络，如下所示：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once the training is completed, we save the trained model to disk (in directory
    `data`). Here I specified a sample name `StockPriceLSTM_+ category name + .zip`
    as shown here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 训练完成后，我们将训练好的模型保存到磁盘（在`data`目录中）。这里我指定了一个示例名称`StockPriceLSTM_+ category name
    + .zip`，如下所示：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now let''s take a look at the number of parameters at each layer:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下每层的参数数量：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Nevertheless, we enable the DL4J UI to view the training progress and params,
    as shown here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们启用了DL4J UI以查看训练进度和参数，如下所示：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following screenshot shows the output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了输出：
- en: '![](img/8621da6a-21ff-4d2a-b57c-51a991d9a3fa.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8621da6a-21ff-4d2a-b57c-51a991d9a3fa.png)'
- en: Network parameters on the UI
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面上的网络参数
- en: The graphs look as though they are not regularized, probably because we do not
    have enough training data.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图表看起来似乎没有进行正则化，可能是因为我们没有足够的训练数据。
- en: Restoring the saved model for inferencing
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恢复已保存的模型进行推断
- en: 'Now that we have finished the training, and the trained model is at hand, we
    can either directly use that trained one on the fly as well as restore the saved
    model from disk, or start the inferencing. Take a look at this code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了训练，并且训练好的模型已在手，我们可以直接使用该训练模型进行推断，或者从磁盘恢复已保存的模型，或者开始推理。看看这段代码：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Evaluating the model
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估模型
- en: 'The number of parameters is the same as the one we saved on disk. This means
    our trained model is not contaminated, so we are safe. Next up, we start evaluating
    the model on the test set. But, as stated earlier, we will perform a two-way evaluation
    of the model. First, we predict one feature of a stock, one day ahead, as shown
    here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的数量与我们在磁盘上保存的一样。这意味着我们的训练模型没有受到污染，因此我们是安全的。接下来，我们开始在测试集上评估模型。但是，正如前面所说，我们将对模型进行双向评估。首先，我们预测某只股票的一个特征，提前一天，如下所示：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding code block, we perform the training for a single category,
    for example, by setting any one of the following options:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们对单一类别进行训练，例如，设置以下任意选项：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can do the evaluation simultaneously for all the categories by setting `PriceCategory
    category = PriceCategory.***ALL***; // **ALL**: predict close price`.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以同时对所有类别进行评估，方法是设置`PriceCategory category = PriceCategory.***ALL***; //
    **ALL**: 预测收盘价`。'
- en: 'Thus, we predict all the features (open, close, low, high prices, and volume)
    of a stock, one day ahead. The process of evaluation on a category is the same
    within case all categories. There is only one thing different: We need to loop
    through a number of categories using `PlotUtil` for the draw `XY` line chart,
    as shown here:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们预测了所有股票特征（开盘价、收盘价、最低价、最高价和交易量）的一天后值。对一个类别的评估过程在所有类别中都是相同的。唯一不同的是：我们需要使用`PlotUtil`循环遍历多个类别，绘制`XY`折线图，如下所示：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding code block, we go to the function `predictAllCategories()`
    to see how evaluation goes on in all categories. Next, we create two arrays, `predicts`
    and `actuals`, to store the predicted result and the actual result. Then we loop
    over the test data. Then we do the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们进入函数`predictAllCategories()`，查看在所有类别中的评估过程。接下来，我们创建两个数组，`predicts`和`actuals`，分别用于存储预测结果和实际结果。然后我们遍历测试数据。接着我们执行以下操作：
- en: Call the function `net.rnnTimeStep()` with parameter as the key of row i-th
    and append the result to the `predicts` list
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用函数`net.rnnTimeStep()`，参数为第i行的键，并将结果附加到`predicts`列表中
- en: Actual value gets from the value of test data row *i*^(th)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际值来自测试数据行*i*^(th)的值
- en: Print the predicted value and actual values
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印预测值和实际值
- en: 'Finally, we loop through five categories; we''re using the `PlotUtil.java`
    to draw an *XY* line chart between predicted and actual values. Consider the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们遍历五个类别；我们使用`PlotUtil.java`来绘制预测值与实际值之间的*XY*折线图。请考虑以下内容：
- en: The initial two double arrays are named `pred` and `actu` with size equal to
    the size of the predicted length.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最初的两个双精度数组分别命名为`pred`和`actu`，其大小与预测的长度相等。
- en: Loop through the `predicts` and `actuals` arrays and, get the double value of
    each element in each list.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历`predicts`和`actuals`数组，获取每个列表中每个元素的双精度值。
- en: With each value of *n* has four values from 0 to 4\. Set the variable `name`
    to the ledge of the *Y* column.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个*n*的值有四个从0到4的值。将变量`name`设置为*Y*列的边缘。
- en: Call the function `PlotUtil` to draw the *XY* line.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`PlotUtil`函数来绘制*XY*折线图。
- en: 'By the way, the `PlotUtil.java` class is used to draw an *XY* line for predicted
    versus actual values, which goes as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，`PlotUtil.java`类用于绘制预测值与实际值的*XY*折线图，代码如下：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding code block,the `addSeries()` method is used to add the *XY*
    series, which is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，`addSeries()`方法用于添加*XY*系列，代码如下：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Apart from these, finding the min, max values of `predicted` and `actual` values
    that we used in the preceding code happen as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，找出我们在前面代码中使用的`predicted`和`actual`值的最小值和最大值，过程如下：
- en: '**Finding min:** First, we set variable `min` as `MAX_VALUE.` Then we loop
    through the `predicted` and `actual` arrays, such that if `min` is greater than
    any element, then we reset `min` as the current element. Then we take the integer
    closest lower bound of value of min:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**寻找最小值：**首先，我们将变量`min`设置为`MAX_VALUE`。然后我们遍历`predicted`和`actual`数组，如果`min`大于任何元素，则将`min`重置为当前元素。接着我们取`min`值的最接近下界的整数：'
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Finding max:** First, we set the variable `max` as `MIN_VALUE.` Then we loop
    through the `predicts` and `actual` arrays such that if `max` < any element, we
    reset `max` as this element. Then we take the integer closest to the upper bound
    of the value of max as shown here:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查找最大值：**首先，我们将变量 `max` 设置为 `MIN_VALUE`。然后，我们循环遍历 `predicts` 和 `actual` 数组，如果
    `max` 小于某个元素，则将 `max` 重置为该元素。接着，我们取 `max` 值上限最接近的整数，如下所示：'
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Finally, we use the `addSeries()` method to add a series to dataSet while plotting
    the graph. Nevertheless, since the task is a regression, we perform the evaluation
    showing regression metrics too, such as `MSE`, `MAE`, `R2`, and so on.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `addSeries()` 方法在绘制图表时将一个系列添加到数据集。然而，由于这是一个回归任务，我们也会展示回归指标，例如 `MSE`、`MAE`、`R2`
    等。
- en: 'Now, based on the preceding plans and based on the value of variable `category`,
    we have two methods to evaluate the model. If the category is `ALL`, then the
    network will predict all categories; otherwise, the network will work only on
    one category. First, for only a single category, say `OPEN`. Take a look at this
    code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，基于前述计划和变量 `category` 的值，我们有两种方法来评估模型。如果类别是 `ALL`，那么网络将预测所有类别；否则，网络只会处理一个类别。首先，对于单一类别，比如
    `OPEN`，请查看以下代码：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then the regression metrics will be printed as follows (you may experience
    slightly different result, though):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后回归指标将会如下所示（尽管你的结果可能略有不同）：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, we observe the following screenshot showing predicted versus actual
    `OPEN` prices:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们观察到以下截图，展示了预测价格与实际 `OPEN` 类别价格的对比：
- en: '![](img/9d1020c0-ee25-4e63-85d1-c322756232db.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d1020c0-ee25-4e63-85d1-c322756232db.png)'
- en: Predicted versus actual prices for `OPEN` category
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`OPEN` 类别的预测与实际价格对比'
- en: 'Then, for only the `**ALL**` category, we run a similar code, except that `PriceCategory.ALL`
    is used as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于仅 `**ALL**` 类别，我们运行类似的代码，唯一不同的是使用了 `PriceCategory.ALL`，如下所示：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then the regression metrics will be printed as follows (you may experience
    slightly different result, though):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后回归指标将会如下所示（尽管你的结果可能略有不同）：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now take a look at the following graph, showing predicted versus actual `ALL`
    prices:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看以下图表，展示了预测价格与实际 `ALL` 类别价格的对比：
- en: '![](img/8b74636f-a246-4971-b678-f266defb34f5.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b74636f-a246-4971-b678-f266defb34f5.png)'
- en: Predicted versus actual prices for `ALL` categories
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`ALL` 类别的预测与实际价格对比'
- en: From the graph, we can see that the price for `OPEN` and `HIGH` shows a good
    fit, whereas `LOW` shows a somewhat good fit. Unfortunately, `CLOSE` and `VOLUME`
    show a very disappointing fit (see the preceding regression result table). One
    possible reason could be lack of data. And also, the hyperparameters used are
    not hypertuned at all. Nevertheless, most of the hyperparameters were chosen naively.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 从图表中我们可以看到，`OPEN` 和 `HIGH` 的价格表现得较为匹配，而 `LOW` 的表现则稍微较好。遗憾的是，`CLOSE` 和 `VOLUME`
    的匹配程度非常令人失望（请参见前面的回归结果表）。一个可能的原因是数据不足。另外，使用的超参数完全没有进行超参数调优。不过，大部分超参数是天真地选择的。
- en: Frequently asked questions (FAQs)
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题解答 (FAQs)
- en: 'In this section, we will see some frequently asked questions that may be already
    on your mind. Answers to these questions can be found in Appendix A:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看到一些可能已经浮现在你脑海中的常见问题。答案可以在附录A中找到：
- en: Can I extend this project for Bitcoin price prediction purposes? If so, how
    and where can I get such datasets?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我可以将这个项目扩展用于比特币价格预测吗？如果可以，如何做以及在哪里可以获得这样的数据集？
- en: What happens if you take predicted values as input for the next prediction?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将预测值作为输入进行下一次预测，会发生什么？
- en: I understand that this is a regression problem, but how can I predict whether
    a price will go up or down?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我理解这是一个回归问题，但我如何预测价格是会上涨还是下跌？
- en: I would like to extend this app and deploy a web application. How can I do that?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我想扩展这个应用并部署一个Web应用程序。我该怎么做？
- en: I want to extend this application not only for price prediction, but also for
    anomaly detection in prices. How can I do that?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我想将这个应用扩展，不仅用于价格预测，还用于价格的异常检测。我该怎么做？
- en: Can I use similar technique for stock price recommendation?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我可以使用类似的技术进行股票价格推荐吗？
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter,we saw how to develop a demo project for predicting stock prices
    for five categories: `OPEN`, `CLOSE`, `LOW`, `HIGH`, and `VOLUME`. However, our
    approach cannot generate an actual signal. Still, it gives some idea of how to
    use LSTM. I know there are some serious drawbacks of this approach. Nevertheless,
    we did not use enough data, which potentially limits the performance of such a
    model.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了如何开发一个示范项目，用于预测五个类别的股票价格：`OPEN`（开盘价）、`CLOSE`（收盘价）、`LOW`（最低价）、`HIGH`（最高价）和`VOLUME`（成交量）。然而，我们的方法不能生成实际的信号。尽管如此，它仍然提供了使用
    LSTM 的一些思路。我知道这种方法存在一些严重的缺点。然而，我们并没有使用足够的数据，这可能限制了该模型的性能。
- en: In the next chapter, we will see how to apply deep learning approaches to a
    video dataset. We will describe how to process and extract features from a large
    collection of video clips. Then we will make the overall pipeline scalable and
    faster by distributing the training on multiple devices (CPUs and GPUs), and run
    them in parallel.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何将深度学习方法应用于视频数据集。我们将描述如何处理和提取来自大量视频片段的特征。然后，我们将通过在多个设备（CPU 和 GPU）上分布式训练，并进行并行运行，使整个流程更加可扩展和高效。
- en: We will see a complete example of how to develop a deep learning application
    that accurately classifies a large collection of a video dataset, such as `UCF101`,
    using a combined CNN-LSTM network with DL4J. It overcomes the limitations of standalone
    CNN or `LSTM` networks. The training will be carried out on an Amazon EC2 GPU
    compute cluster. Eventually, this end-to-end project can be treated as a primer
    for human activity recognition from video or so.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何开发一个深度学习应用的完整示例，该应用能够准确地分类大规模视频数据集，如`UCF101`，使用结合 CNN-LSTM 网络与 DL4J。这克服了独立
    CNN 或 `LSTM` 网络的局限性。训练将在 Amazon EC2 GPU 计算集群上进行。最终，这个端到端的项目可以作为视频中人类活动识别的入门指南。
- en: Answers to questions
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题的答案
- en: '**Answer** **to question** **1:** Some historical Bitcoin data can be downloaded
    from Kaggle, for example, [https://www.kaggle.com/mczielinski/bitcoin-historical-data/data](https://www.kaggle.com/mczielinski/bitcoin-historical-data/data).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 1 的答案：** 一些历史比特币数据可以从 Kaggle 下载，例如，[https://www.kaggle.com/mczielinski/bitcoin-historical-data/data](https://www.kaggle.com/mczielinski/bitcoin-historical-data/data)。'
- en: Once you've downloaded the dataset, try to extract the most important features
    and convert the dataset into a time series so that it can be fed into an LSTM
    model. Then the model can be trained with the time series for each time step.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 下载数据集后，尝试提取最重要的特征，并将数据集转换为时间序列，这样就可以输入到 LSTM 模型中。然后，模型可以通过每个时间步的时间序列进行训练。
- en: '**Answer** **to question 2:** Our sample project only calculates the stock
    price of those stocks whose actual stock price is given, and not the next day''s
    stock price. It shows `actual` and `predicted`, but the next day''s stock price
    should only contain `predicted`. This is what is happening if we take predicted
    values as input for the next prediction:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 2 的答案：** 我们的示例项目只计算那些实际股价已给出的股票的股价，而不是第二天的股价。它显示的是`实际`和`预测`，但是第二天的股价应仅包含`预测`。如果我们将预测值作为输入进行下一次预测，就会出现这种情况：'
- en: '![](img/f9c0c769-0e8a-467d-9771-8c9d377e2565.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f9c0c769-0e8a-467d-9771-8c9d377e2565.png)'
- en: Predicted versus actual prices for `ALL` categories, where predicted values
    are input for the next prediction
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 预测与实际价格对比，针对`所有`类别，预测值作为下一次预测的输入
- en: '**Answer** **to question** **3:** Well, then the task would be a binary classification
    problem. To make this happen, you need to make two changes:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 3 的答案：** 好的，那么这个任务将是一个二分类问题。为了实现这一点，您需要进行两个更改：'
- en: Convert the dataset such that there will be two labels
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换数据集，使其包含两个标签
- en: Replace the `IDENTITY` activation function and `RMSE` loss with cross-entropy
    loss
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `IDENTITY` 激活函数和 `RMSE` 损失函数替换为交叉熵损失函数
- en: '**Answer to question 4:** That is a great idea. You can try improving the modeling
    by following questions 1 and 2\. Then you can save the model on disk for later
    stage inferencing. Finally, you can serve this model as a web application, as
    suggested in previous chapters.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 4 的答案：** 这是个很好的主意。你可以尝试通过问题 1 和 2 来改进建模。然后，你可以将模型保存到磁盘，以便后续推理。最后，你可以像前面章节建议的那样，将这个模型作为
    web 应用提供服务。'
- en: '**Answer** **to question** **5**: Applying anomaly detection in such a dataset
    is very challenging, and I am not sure whether it is feasible, since the market
    has very high volatility. Therefore, the time series will have very many vicissitudes
    sometimes, which is the nature of the stock market. This helps the trained model
    to identify that abnormal volatility.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**回答第5题：** 在这样的数据集中应用异常检测非常具有挑战性，我不确定是否可行，因为市场波动性非常大。因此，时间序列有时会经历非常多的波动，这是股市的本质。这有助于训练好的模型识别出这种异常波动。'
- en: Answer **to question 6:** Yes, you can. You can try using **Machine Learning
    based ZZAlpha Ltd. Stock Recommendations 2012-2014 Data Set.** This dataset can
    be downloaded from `UCI ML repository` at [https://archive.ics.uci.edu/ml/datasets/Machine+Learning+based+ZZAlpha+Ltd.+Stock+Recommendations+2012-2014](https://archive.ics.uci.edu/ml/datasets/Machine+Learning+based+ZZAlpha+Ltd.+Stock+Recommendations+2012-2014).
    The repository also describes the problem as well as the dataset.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**回答第6题：** 是的，你可以。你可以尝试使用**基于机器学习的ZZAlpha有限公司股票推荐2012-2014数据集**。该数据集可以从`UCI
    ML 仓库`下载，网址是[https://archive.ics.uci.edu/ml/datasets/Machine+Learning+based+ZZAlpha+Ltd.+Stock+Recommendations+2012-2014](https://archive.ics.uci.edu/ml/datasets/Machine+Learning+based+ZZAlpha+Ltd.+Stock+Recommendations+2012-2014)。仓库中还描述了问题和数据集的详细信息。'
