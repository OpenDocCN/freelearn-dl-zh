- en: Setting Up R for Deep Learning
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为深度学习配置R环境
- en: 'In this book, we will primarily use the following libraries for deep learning:
    **H2O**, **MXNet**, and **Keras**. We will also use the **Restricted Boltzmann
    Machine** (**RBM**) package specifically for RBMs and **deep belief networks**
    (**DBNs**). In addition, we will conclude the book by using the `ReinforcementLearning`
    package.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将主要使用以下库进行深度学习：**H2O**、**MXNet**和**Keras**。我们还将专门使用**限制玻尔兹曼机**（**RBM**）包来处理RBM和**深度信念网络**（**DBN**）。此外，我们将在本书结尾时使用`ReinforcementLearning`包。
- en: In this chapter, we will install all of the previously listed packages. Each
    package can be used to train deep learning models in R. However, each has its
    particular strengths and weaknesses. We will explore the underlying architecture
    for each of these packages, which will help us to understand how they execute
    code. The packages have been created to allow R programmers to perform deep learning, with
    the exception of `RBM` and `ReinforcementLearning`, which are not written natively
    in R. This does have important implications for us to consider, starting with
    ensuring that we have all the necessary dependencies in order to install the packages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将安装所有之前列出的包。每个包都可以用于在R中训练深度学习模型。然而，每个包都有其特定的优点和缺点。我们将探讨每个包的底层架构，这将帮助我们理解它们是如何执行代码的。除了`RBM`和`ReinforcementLearning`这两个包未使用R本地编写外，其它包都为R程序员提供了深度学习功能。这对于我们来说有重要的影响，从确保我们具备安装包所需的所有依赖开始。
- en: 'This chapter will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: Installing the packages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装软件包
- en: Preparing a sample dataset
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备示例数据集
- en: Exploring Keras
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Keras
- en: Exploring H2O
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索H2O
- en: Reinforcement learning and RBM
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强化学习和RBM
- en: Deep learning library comparison
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度学习库对比
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files used in this chapter at [https://github.com/PacktPublishing/Hands-on-Deep-Learning-with-R](https://github.com/PacktPublishing/Hands-on-Deep-Learning-with-R).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/PacktPublishing/Hands-on-Deep-Learning-with-R](https://github.com/PacktPublishing/Hands-on-Deep-Learning-with-R)找到本章中使用的代码文件。
- en: Installing the packages
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装软件包
- en: Some packages can be directly installed from CRAN or GitHub, while `H2O` and
    `MXNet` are a bit more complex. We will start with the packages that are the most
    straightforward to install and then move on to those that are more complex.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一些软件包可以直接从CRAN或GitHub安装，而`H2O`和`MXNet`则稍微复杂一些。我们将从最简单安装的包开始，然后转向那些更复杂的包。
- en: Installing ReinforcementLearning
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装ReinforcementLearning
- en: 'You can install `ReinforcementLearning` by using `install.packages`, since
    there is a CRAN release for this package, with the following line of code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`install.packages`来安装`ReinforcementLearning`，因为这个包有CRAN版本，使用以下代码行即可：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Installing RBM
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装RBM
- en: 'The `RBM` package is only available on GitHub and is not available on CRAN,
    so the installation here is slightly different. First, you will need to install
    the `devtools` package if you do not already have it installed on your system.
    Next, use the `install_github()` function from the `devtools` package in place
    of `install.packages` in order to install the `RBM` package, as in the following
    code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`RBM`包仅在GitHub上提供，不在CRAN上发布，因此其安装方式稍有不同。首先，如果你还没有安装`devtools`包，需要先安装它。接着，使用`devtools`包中的`install_github()`函数代替`install.packages`来安装`RBM`包，代码如下：'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Installing Keras
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Keras
- en: Installing Keras is similar to the way that we installed `RBM`, with one subtle,
    but important, difference. After running `install_github()` function to download
    and install the package, you run `install_keras()` to complete the installation. From
    the Keras documentation, calling `install_keras()` function is not required if
    you would prefer to install Keras yourself.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Keras的方式与我们安装`RBM`的方式类似，唯一的区别是稍微微妙但非常重要的。下载并安装包后，你需要运行`install_keras()`来完成安装。根据Keras的文档，如果你希望手动安装Keras，则不需要调用`install_keras()`函数。
- en: 'If you choose this route, the R package will find the version that you have
    installed. For this book, we will use `install_keras()` to complete installation,
    as in the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择这种方式，R包将自动找到你已安装的版本。在本书中，我们将使用`install_keras()`来完成安装，代码如下：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you would prefer to install the GPU version, then just make one change when
    calling the function, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更倾向于安装GPU版本，只需在调用函数时做出如下更改：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Running `install_keras()` will install Keras and TensorFlow in a virtual environment
    by default, except on a Windows machine where—at the time of writing—this is not
    supported, in which case a `conda` environment will be used and Anaconda will
    need to be installed on the Windows machine beforehand. By default, the CPU version
    of TensorFlow and the latest release of Keras will be installed; an optional argument
    can be added in order to install the GPU version, as in the preceding code. For
    this book, we will accept the default values and run `install_keras`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`install_keras()`将默认在虚拟环境中安装 Keras 和 TensorFlow，除了在 Windows 机器上——在写这本书时——此功能尚不支持，在这种情况下将使用`conda`环境，并且需要预先在
    Windows 机器上安装 Anaconda。默认情况下，将安装 TensorFlow 的 CPU 版本以及最新版本的 Keras；可以添加一个可选参数来安装
    GPU 版本，如前面的代码所示。对于本书，我们将接受默认值并运行`install_keras`。
- en: If you have a machine with multiple versions of Python, you may discover some
    issues. If the Python instance that you wish to use is not declared, then R will
    attempt to find Python by first looking in common locations such as `usr/bin`
    and `usr/local/bin`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的机器上有多个版本的 Python，可能会遇到一些问题。如果你想使用的 Python 实例没有声明，R 将尝试通过先在常见位置查找，如`usr/bin`和`usr/local/bin`，来找到
    Python。
- en: 'When using Keras, you will likely want to point to the Python instance in your
    TensorFlow virtual environment. By default, the virtual environment will be called
    `r-tensorflow`. You can tell R the version of Python you would like to use by
    using the `use_python()` function from the `reticulate` package. Within the function,
    simply note the path to the instance of Python in the virtual environment. On
    my machine, this looks as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Keras 时，你可能希望指向 TensorFlow 虚拟环境中的 Python 实例。默认情况下，虚拟环境将命名为`r-tensorflow`。你可以使用
    `reticulate` 包中的`use_python()`函数告诉 R 你想使用的 Python 版本。在函数内部，只需注明虚拟环境中 Python 实例的路径。在我的机器上，它如下所示：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This should look similar on your machine.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的机器上应该类似于这个样子。
- en: Once R has the path to the right instance of Python, the code that we will introduce
    later in this chapter should work. However, if you are not referencing the correct
    version of Python, you will encounter errors and the code will not run.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 R 找到正确的 Python 实例路径，接下来我们将在本章中介绍的代码应该可以正常运行。然而，如果没有引用正确的 Python 版本，你将遇到错误，代码将无法运行。
- en: Installing H2O
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 H2O
- en: 'For H2O, we will use the installation instructions from the H2O website. Using
    this approach, we will first search for any previous installations of H2O and
    remove those. Next, `RCurl` and `jsonlite` are installed and, after this, H2O
    is installed from the AWS S3 bucket containing the latest release. This is accomplished
    by simply making a change to the location of the repository when obtaining the
    package files, which, by default, is a CRAN server. We install H2O by running
    the following code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 H2O，我们将使用 H2O 网站上的安装说明。通过这种方法，我们将首先搜索并移除任何先前安装的 H2O。接下来，安装 `RCurl` 和 `jsonlite`，然后从包含最新发布版本的
    AWS S3 存储桶中安装 H2O。这个过程通过在获取软件包文件时简单地修改存储库位置来完成，默认情况下它是 CRAN 服务器。我们通过运行以下代码安装 H2O：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Installing MXNet
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 MXNet
- en: 'There are multiple ways to install MXNet. The following code is the easiest
    installation instruction for setting up the CPU version of MXNet:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 MXNet 有多种方法。以下代码是设置 MXNet CPU 版本的最简单安装说明：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For the GPU support, use the following installation code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 GPU 支持，使用以下安装代码：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: OpenCV and OpenBLAS are required to use MXNet. If you need to install these,
    you can do so through one of the following options.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MXNet 需要 OpenCV 和 OpenBLAS。如果你需要安装这些，可以通过以下选项之一进行安装。
- en: 'For macOS X, Homebrew can be used to install these libraries:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 macOS X，可以使用 Homebrew 来安装这些库：
- en: If Homebrew is not already installed, installation instructions can be found
    at [https://brew.sh/](https://brew.sh/).
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未安装 Homebrew，安装说明可以在[https://brew.sh/](https://brew.sh/)找到。
- en: 'With Homebrew available, open a Terminal window and install the libraries using
    the following commands:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经安装了 Homebrew，打开终端窗口并使用以下命令安装库：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, as shown here, create a symbolic link to ensure that the latest version
    of OpenBLAS is being used:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如此处所示，创建一个符号链接以确保使用的是最新版本的 OpenBLAS：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For Windows, the process is slightly more involved and so the details will
    not be noted in this book:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows，过程稍微复杂一些，因此本书中不会详细说明：
- en: To install OpenCV, follow the instructions found at [https://docs.opencv.org/3.4.3/d3/d52/tutorial_windows_install.html](https://docs.opencv.org/3.4.3/d3/d52/tutorial_windows_install.html).
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要安装 OpenCV，请按照[https://docs.opencv.org/3.4.3/d3/d52/tutorial_windows_install.html](https://docs.opencv.org/3.4.3/d3/d52/tutorial_windows_install.html)中提供的说明进行操作。
- en: To install OpenBLAS, follow the instructions found at [https://github.com/xianyi/OpenBLAS/wiki/How-to-use-OpenBLAS-in-Microsoft-Visual-Studio](https://github.com/xianyi/OpenBLAS/wiki/How-to-use-OpenBLAS-in-Microsoft-Visual-Studio).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要安装 OpenBLAS，请按照[https://github.com/xianyi/OpenBLAS/wiki/How-to-use-OpenBLAS-in-Microsoft-Visual-Studio](https://github.com/xianyi/OpenBLAS/wiki/How-to-use-OpenBLAS-in-Microsoft-Visual-Studio)中提供的说明进行操作。
- en: 'With OpenCV and OpenBLAS installed, the preceding lines should work to download
    and install the MXNet package. However, if you run into errors while trying to
    load the library, then it may be necessary to build the MXNet package and then
    create the R package. The instructions to complete this are very clear and detailed,
    but they are too long to include in this book:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了 OpenCV 和 OpenBLAS 后，前面的几行代码应该可以正常工作，以下载和安装 MXNet 包。不过，如果在尝试加载库时遇到错误，可能需要构建
    MXNet 包并创建 R 包。完成这些操作的说明非常清晰且详细，但它们太长，无法包含在本书中：
- en: '**For macOS X**: [https://mxnet.incubator.apache.org/versions/master/install/osx_setup.html](https://mxnet.incubator.apache.org/versions/master/install/osx_setup.html)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于 macOS X**：[https://mxnet.incubator.apache.org/versions/master/install/osx_setup.html](https://mxnet.incubator.apache.org/versions/master/install/osx_setup.html)'
- en: '**For Windows**: [https://mxnet.incubator.apache.org/versions/master/install/windows_setup.html](https://mxnet.incubator.apache.org/versions/master/install/windows_setup.html)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于 Windows**：[https://mxnet.incubator.apache.org/versions/master/install/windows_setup.html](https://mxnet.incubator.apache.org/versions/master/install/windows_setup.html)'
- en: If there are still issues when downloading and installing the package after
    following the steps needed to build the MXNet library and the R bindings, this
    could be due to a number of possible reasons, many of which have been documented.
    Unfortunately, trying to work through all the possible installation scenarios
    and issues is outside the scope of this book. However, to use MXNet for learning
    purposes, it is possible to use a kernel from the Kaggle website, where MXNet
    is available.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按照构建 MXNet 库和 R 绑定所需的步骤操作后，下载和安装包时仍然出现问题，这可能是由于多种可能的原因，很多问题已经有文档说明。不幸的是，尝试解决所有可能的安装场景和问题超出了本书的范围。不过，为了学习目的，你可以通过
    Kaggle 网站上的内核使用 MXNet，那里可以使用 MXNet。
- en: Preparing a sample dataset
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备示例数据集
- en: 'For Keras, H2O, and MXNet, we will use the adult census dataset, which uses
    U.S. Census data to predict whether someone makes more or less than USD50,000
    a year. We will perform the data preparation for the Keras and MXNet examples
    here, so we are not repeating the same code in both examples:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Keras、H2O 和 MXNet，我们将使用成人普查数据集，该数据集使用美国普查数据来预测某人的年收入是否超过 50,000 美元。我们将在这里进行
    Keras 和 MXNet 示例的数据准备，这样就不需要在两个示例中重复相同的代码：
- en: 'In the following code, we will load the data and label the two datasets to
    prepare for combining them:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将加载数据并标注这两个数据集，以便将它们合并：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As a result of running the preceding code, we will now have our libraries loaded
    and ready to use. We also have the `train` and `test` data loaded, which can now
    be seen in the `Environment` pane.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码后，我们的库已经加载并准备好使用。我们还加载了`train`和`test`数据集，现在可以在`Environment`面板中看到它们。
- en: 'Next, we will combine the datasets so we can make some changes to all the data
    at the same time. We will use the `complete.cases` function to remove rows with
    `NA` for the sake of simplicity for these examples. We will also remove white
    space around the character terms so that terms such as `Male` and `Male ` are
    both treated as the same term. Let''s have a look at the following code:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将合并这些数据集，以便可以同时对所有数据进行一些更改。为了简化这些示例，我们将使用`complete.cases`函数来删除包含`NA`的行。我们还将删除字符项周围的空格，以便像`Male`和`Male
    `这样的项都被视为相同的项。让我们来看一下以下代码：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will now perform some extra pre-processing steps on the `train` dataset.
    First, we use the `filter()` function to extract the `train` data from the combined
    data frame labeled `all`. After that, we will extract the `target` column as a
    vector and then remove the `target` and `label` columns. We isolate the `train`
    data and `train` target variables using the following code:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在 `train` 数据集上执行一些额外的预处理步骤。首先，我们使用 `filter()` 函数从名为 `all` 的合并数据框中提取 `train`
    数据。然后，我们将提取 `target` 列作为向量，并移除 `target` 和 `label` 列。我们通过以下代码来隔离 `train` 数据和 `train`
    目标变量：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will now separate the columns with numeric values and those with character
    values so that we can encode the character value column to prepare for a completely
    numeric matrix. We separate the numeric and character columns using the following
    code:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将分离数值列和字符列，以便对字符列进行编码，准备一个完全数值化的矩阵。我们通过以下代码分离数值列和字符列：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we will use the `dummyVars()` function from `caret` to pivot the character
    values within a column into separate columns and we will indicate whether a character
    string is present in the row by assigning `1` to the row. If the character string
    is not present, then the column will contain `0` for that row. We perform this
    one-hot encoding step by running the following code:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `caret` 中的 `dummyVars()` 函数，将列中的字符值转换为单独的列，并通过将 `1` 分配给行来指示某个字符字符串是否存在。如果字符字符串不存在，那么该列在这一行中将包含
    `0`。我们通过运行以下代码执行这一步骤：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After transforming the data, we will now bind the two datasets back together
    with the following line of code:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据转换后，我们将使用以下代码将两个数据集重新合并：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will then repeat the same steps for the `test` dataset by running the following
    code:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将通过运行以下代码对 `test` 数据集执行相同的步骤：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we created our target vector, it converted the factor values to `1` and
    `2`. However, we would like this to be `1` and `0`, so we will subtract `1` from
    the vector, as in the following code:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们创建目标向量时，它将因子值转换为 `1` 和 `2`。但是，我们希望将其转换为 `1` 和 `0`，因此我们将从向量中减去 `1`，如以下代码所示：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The last step is to clean up one column from the `train` dataset because it
    is not present in the `test` dataset. We remove this particular column by running
    the following line of code:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是清理 `train` 数据集中的一列，因为它在 `test` 数据集中不存在。我们通过运行以下代码来移除这一列：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that we have loaded and prepared this dataset, we can use it in the next
    step to demonstrate some preliminary examples using all the packages that we have
    installed. At this point, our goal is to take a look at the syntax and ensure
    that the code can run and that the libraries are installed correctly. In later
    chapters, we will go into more depth about each package.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载并准备好了这个数据集，可以在下一步中使用它来展示一些初步示例，演示我们已安装的所有包。此时，我们的目标是查看语法，确保代码能够运行且库已正确安装。在后续章节中，我们将深入探讨每个包的详细内容。
- en: Exploring Keras
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Keras
- en: Keras was created and is maintained by Francois Chollet. Keras lays claim to
    being designed for humans, so common use cases are simple to execute and the syntax
    is clear and comprehensible. Keras is made to work with a number of lower-level
    deep learning languages and, in this book, Keras will be the interface that we
    use to utilize a number of popular deep learning backends, including TensorFlow.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Keras 由 Francois Chollet 创建并维护。Keras 声称自己是为人类设计的，因此常见的用例非常简单，语法清晰易懂。Keras 可与多种低级深度学习语言配合使用，在本书中，Keras
    将作为接口，帮助我们利用多个流行的深度学习后端，包括 TensorFlow。
- en: Available functions
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用函数
- en: 'Keras offers support for a broad array of deep learning methods, including the
    following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Keras 提供了对多种深度学习方法的支持，包括以下内容：
- en: '**Recurrent neural networks** (**RNNs**)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环神经网络** (**RNNs**)'
- en: '**Long short-term memory** (**LSTM**) networks'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长短期记忆** (**LSTM**) 网络'
- en: '**Convolutional neural networks** (**CNNs**)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卷积神经网络** (**CNNs**)'
- en: '**Multilayer perceptrons** (**MLPs**)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多层感知机** (**MLPs**)'
- en: '**Variable autoencoders**'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量自编码器**'
- en: This is not an exhaustive list and further support is available for additional
    methods. However, these are what will be covered in the later chapters of this
    book.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是一个详尽无遗的列表，针对其他方法的支持也可以提供。然而，这些是本书后续章节中将涉及的内容。
- en: A Keras example
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个 Keras 示例
- en: 'In this example, we will train a multilayer perceptron on the adult census
    dataset that we just prepared. This example is included to introduce the syntax
    of the package and to show that a basic exercise can be completed without an excessive
    amount of code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将训练一个多层感知器，使用我们刚刚准备的成人普查数据集。此示例包含在内，以介绍该包的语法，并展示无需过多代码即可完成的基础练习：
- en: If you have multiple versions of Python installed on your system, then this
    can become an issue. Use the `reticulate` package and the `use_python()` function
    to define the path to the Python instance that you would like to use; for example,
    `use_python(usr/local/bin/python3)`. You can also use `RETICULATE_PYTHON` within
    your `.Rprofile` file to set the path to the Python instance that R should use.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统中安装了多个版本的Python，可能会出现问题。使用`reticulate`包和`use_python()`函数来定义您希望使用的Python实例的路径；例如，`use_python(usr/local/bin/python3)`。您也可以在`.Rprofile`文件中使用`RETICULATE_PYTHON`来设置R应该使用的Python实例路径。
- en: 'To begin, we will load the `tensorflow` and `keras` libraries, as shown:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将加载`tensorflow`和`keras`库，如下所示：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we will convert our datasets into matrices, as shown:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将把数据集转换为矩阵，如下所示：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we can create a sequential model, which will move through each layer in
    succession. We will have one layer and then we will compile the results. We define
    our model by running the following code:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个顺序模型，该模型将按顺序通过每一层。我们将有一层，然后我们将编译结果。我们通过运行以下代码来定义我们的模型：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the previous step, we defined our model and now, in the following code,
    we will fit this model to our training dataset:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前一步中，我们定义了我们的模型，现在，在以下代码中，我们将把此模型拟合到我们的训练数据集：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, we can evaluate our model by comparing our model results to the `test`
    target values. We evaluate model performance by running the following code:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以通过将模型结果与`test`目标值进行比较来评估我们的模型。我们通过运行以下代码来评估模型性能：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is the general syntax for `keras`. As we have shown, it is compatible with
    piping and has a syntax that will be familiar to R programmers. Next, we will
    look at an example using the MXNet package.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`keras`的一般语法。如我们所示，它与管道操作兼容，并且具有对R程序员来说熟悉的语法。接下来，我们将查看一个使用MXNet包的例子。
- en: Exploring MXNet
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索MXNet
- en: MXNet is a deep learning library designed by the Apache Software Foundation.
    It supports both imperative and symbolic programming. It is designed for speed
    by serializing functions with dependencies while running functions with no dependencies
    in parallel. It provides compatibility with CPU and GPU processors.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: MXNet是由Apache软件基金会设计的深度学习库。它支持命令式编程和符号编程。通过将带有依赖关系的函数序列化，同时并行运行没有依赖关系的函数，它被设计成具有较高的速度。它支持CPU和GPU处理器。
- en: Available functions
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用函数
- en: 'MXNet provides the means to run a very extensive list of deep learning methods,
    including the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: MXNet提供了运行多种深度学习方法的手段，包括以下内容：
- en: CNN
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷积神经网络（CNN）
- en: RNN
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环神经网络（RNN）
- en: GAN
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成对抗网络（GAN）
- en: LSTM
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长短时记忆网络（LSTM）
- en: Autoencoders
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动编码器
- en: RBM/DBN
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受限玻尔兹曼机/深度玻尔兹曼网络（RBM/DBN）
- en: Reinforcement learning
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强化学习
- en: Getting started with MXNet
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用MXNet
- en: 'For MXNet, we will use the same prepared adult census dataset. We will also
    use a multilayer perceptron as our model. Fitting a model using MXNet will be
    quite familiar to you if you are familiar with fitting a model using a number
    of other common machine learning packages:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MXNet，我们将使用相同的准备好的成人普查数据集。我们还将使用多层感知器作为我们的模型。如果您熟悉使用其他常见机器学习包来拟合模型，使用MXNet拟合模型将非常熟悉：
- en: 'First, we will load the MXNet package with the following line of code:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用以下代码行加载MXNet包：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we will define our multilayer perceptron. A `seed` value is set for reproducibility
    purposes. Afterward, the training data is converted to a data matrix and passed
    as an argument to the model, along with the training target values, as shown:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将定义我们的多层感知器。为了可重复性，我们设置了一个`seed`值。之后，训练数据将转换为数据矩阵，并作为参数传递给模型，同时传递训练目标值，如下所示：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we will make our predictions by applying the model to a data matrix version
    of the `test` data, as in the following code:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将通过将模型应用于`test`数据的矩阵版本来进行预测，如以下代码所示：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can then use a confusion matrix to evaluate performance, with the adjusted
    target class on the *y*-axis and the predicted results on the *x*-axis, as shown:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用混淆矩阵来评估性能，将调整后的目标类别放在*y*-轴上，预测结果放在*x*-轴上，如下所示：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The syntax for MXNet should look familiar to those with experience with doing
    machine learning coding in R. The function to train the model takes in descriptive
    and target data, as well as captures values for a number of options, just like
    using RandomForest or XGBoost.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有 R 语言机器学习编程经验的人来说，MXNet 的语法应该看起来很熟悉。训练模型的函数接受描述性数据和目标数据，并且捕捉多个选项的值，就像使用 RandomForest
    或 XGBoost 一样。
- en: The options are slightly different and we will cover how to best assign values
    to these arguments in a later chapter. However, the syntax is quite similar to
    the syntax used for other machine learning libraries in R. Next, we will write
    the code to train a minimal model using H2O.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项略有不同，我们将在后面的章节中介绍如何为这些参数赋值。然而，语法与其他 R 语言机器学习库的语法非常相似。接下来，我们将编写代码，使用 H2O
    训练一个最小化的模型。
- en: Exploring H2O
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 H2O
- en: 'H2O has been around longer than Keras and MXNet and is still used widely. It
    makes use of Java and MapReduce in-memory compression to handle big datasets.
    H2O is used for many machine learning tasks and also supports deep learning. In
    particular, H2O provides native support for feedforward artificial neural networks
    (multilayer perceptrons). H2O performs automatic data preparation and missing
    value handling. Loading data requires the use of a special data type: `H2OFrame`.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: H2O 的出现时间比 Keras 和 MXNet 更久，并且仍然被广泛使用。它利用 Java 和 MapReduce 内存压缩来处理大数据集。H2O 被用于许多机器学习任务，并且也支持深度学习。特别地，H2O
    原生支持前馈人工神经网络（多层感知机）。H2O 还执行自动数据准备和缺失值处理。加载数据时需要使用一种特殊的数据类型：`H2OFrame`。
- en: Available functions
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用的函数
- en: H2O only natively supports feedforward neural networks. Compared with the other
    main packages for deep learning, this creates an obvious limitation for this library.
    However, this is a very common deep learning implementation. In addition, H2O
    allows for large objects to be stored outside memory in the H2O cluster. For these
    reasons, H2O is still a valuable library to know about when studying deep learning.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: H2O 原生只支持前馈神经网络。与其他主要的深度学习包相比，这为该库带来了明显的限制。然而，这仍然是一个非常常见的深度学习实现方法。此外，H2O 允许将大对象存储在
    H2O 集群的内存之外。由于这些原因，H2O 仍然是学习深度学习时值得了解的一个有价值的库。
- en: An H2O example
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个 H2O 示例
- en: 'For this example, we will again use the adult census dataset to predict income.
    As with our Keras example, this will be kept extremely minimal and we will cover
    just enough to illustrate the syntax for working with H2O, as well as the design
    nuances that differ from other packages:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将再次使用成人人口普查数据集来预测收入。与我们的 Keras 示例一样，这个示例将保持极简，并且我们只会涵盖足够的内容来展示与 H2O
    交互的语法，以及与其他包不同的设计细节：
- en: 'The first major difference when working with H2O is that we must explicitly
    initialize our H2O session, which will generate a Java Virtual Machine instance
    and connect it with R. This is accomplished with the following lines of code:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 H2O 时的第一个主要区别是，我们必须显式地初始化我们的 H2O 会话，这将生成一个 Java 虚拟机实例，并将其与 R 连接。这可以通过以下代码行来实现：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Loading data to use with H2O requires converting the data to `H2OFrame`. `H2OFrame`
    is very similar to data frames, with the major distinction having to do with where
    the object is stored. While data frames are held in memory, `H2OFrame` is stored
    on the H2O cluster. This feature can be an advantage with very large datasets.
    In the following example, we will convert the data into the proper format using
    a two-step process. First, we load the data by reading `csv` in the usual way.
    Second, we will convert the data frames to `H2OFrame`. We convert our data into
    the proper format using the following code:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载数据以供 H2O 使用时，需要将数据转换为 `H2OFrame`。`H2OFrame` 与数据框非常相似，主要区别在于对象的存储位置。数据框存储在内存中，而
    `H2OFrame` 存储在 H2O 集群中。对于非常大的数据集来说，这个特性可能是一个优势。在下面的示例中，我们将通过两步过程将数据转换为适当的格式。首先，我们按常规方式读取
    `csv` 文件加载数据。然后，我们将数据框转换为 `H2OFrame`。我们使用以下代码将数据转换为适当的格式：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For this example, we will perform some imputation as the sole pre-processing
    step. In this step, we will replace all missing values and we will use `mean`
    for numeric data and `mode` for factor data. In H2O, setting `column = 0` will
    apply the function to the entire frame. Of note is that the function is called
    on the data; however, it is not necessary to assign the results to a new object
    as the imputations will be directly reflected in the data passed through as an
    argument to the function. It is also worth highlighting that in H2O, we can pass
    a vector to the method argument and it will be used for every variable in this
    case by first checking whether the first method can be used and, if not, moving
    on to the second method. Pre-processing this data is accomplished by running the
    following lines of code:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将执行一些插补作为唯一的预处理步骤。在此步骤中，我们将替换所有缺失值，对于数值数据我们使用`mean`，对于因子数据我们使用`mode`。在H2O中，设置`column
    = 0`将函数应用于整个数据框。值得注意的是，该函数是作用于数据的；然而，不需要将结果分配给新对象，因为插补结果会直接反映在作为函数参数传递的数据中。还值得强调的是，在H2O中，我们可以将一个向量传递给方法参数，它将在此情况下用于每个变量，首先检查是否可以使用第一种方法，如果不行，则切换到第二种方法。通过运行以下代码行可以完成数据的预处理：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In addition, in this step, we will define the `dependent` and `independent`
    variables. The `dependent` variable is held in the `target` column, while all
    the remaining columns contain the `independent` variables, which will be used
    for predicting the `target` variable during this task:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在此步骤中，我们将定义`dependent`和`independent`变量。`dependent`变量存储在`target`列中，而所有其余列包含`independent`变量，这些变量将在该任务中用于预测`target`变量：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With all of the preparation steps complete, we can now create a minimal model.
    The H2O `deeplearning` function will create a feedforward artificial neural network.
    In this example, just the minimum required to run the model will be included.
    However, this function can accept 80 to 90 arguments and we will cover many of
    these in the later chapters. In the following code, we provide a name for our
    model, identify the training data, set a seed for reproducibility through replicating
    pseudo-random numbers involved in the model, define the `dependent` and `independent`
    variables, and note the number of times the model should be run and how the data
    should be cut for each round:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有准备步骤完成后，我们现在可以创建一个最小模型。H2O的`deeplearning`函数将创建一个前馈人工神经网络。在这个例子中，只包含运行模型所需的最小内容。然而，该函数可以接受80到90个参数，我们将在后面的章节中介绍这些参数。以下代码中，我们为模型提供一个名称，识别训练数据，通过复制模型中涉及的伪随机数设置种子以确保可重复性，定义`dependent`和`independent`变量，并指定模型应运行的次数以及每轮数据的切分方式：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After running the model, the performance can be evaluated on the out-of-fold
    samples using the following line of code:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行模型后，可以使用以下代码行在外部折叠样本上评估性能：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, when our model is complete, the cluster must be explicitly shut down
    just as it was initialized. The following function will close the current `h2o` instance:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当我们的模型完成时，集群必须像初始化时那样显式关闭。以下函数将关闭当前的`h2o`实例：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can observe the following in this example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这个例子中观察到以下几点：
- en: The syntax for H2O varies quite a bit from other machine learning libraries.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: H2O的语法与其他机器学习库有很大不同。
- en: First, we need to initiate the Java Virtual Machine and we need to store our
    data in special data containers with this package.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们需要初始化Java虚拟机，并且我们需要将数据存储在该包的特殊数据容器中。
- en: In addition, we can see that imputation happens by running the function on a
    data object without assigning the changes back to an object.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，我们可以看到，通过在数据对象上运行函数而不将更改分配回对象，插补会发生。
- en: We can see that we also need to include all the independent variable column
    names, which is slightly different from other models.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以看到，我们还需要包括所有自变量的列名，这与其他模型略有不同。
- en: All of this is to say that H2O may feel a little unfamiliar as you use it. It
    is also limited in terms of the algorithms available. However, the ability to
    work with larger datasets is a definite advantage to this package.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有这些都是在说明，使用H2O时它可能会显得有些不熟悉。它在算法的可用性方面也有限。但它能够处理更大的数据集，这一点是该包的明显优势。
- en: Now that we have looked at the comprehensive deep learning packages, we will
    focus on packages written with R that perform a specific modeling task or a limited
    set of tasks.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了全面的深度学习包，我们将重点关注使用 R 编写的，执行特定建模任务或一组有限任务的包。
- en: Exploring ReinforcementLearning and RBM
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索ReinforcementLearning和RBM
- en: 'The `ReinforcementLearning` and `RBM` packages differ from the libraries already
    covered in two important ways: first, they are specialized packages that have
    functions for only one specific deep learning task instead of attempting to support
    myriad deep learning options, and second, they are completely written in R and
    have no additional language dependencies. This can be an advantage as the complexity
    of the previous libraries means that the packages can break when changes happen
    outside the package. The support pages for these libraries are full of examples
    of installation FAQs and troubleshooting instructions, as well as some cases where
    a given package may suddenly stop working or become deprecated. In these cases,
    we encourage you to continue searching CRAN and other sites as the R community
    is well known for its dynamic, evolving, and robust support and development.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReinforcementLearning`和`RBM`包与之前介绍的库有两个重要的不同之处：首先，它们是专门化的包，仅包含单一深度学习任务的函数，而不是试图支持各种深度学习选项；其次，它们完全用R语言编写，没有额外的语言依赖。这是一个优点，因为之前的库的复杂性意味着，当包外部发生变化时，包可能会崩溃。对于这些库的支持页面，充满了安装常见问题和故障排除的示例，以及一些包突然停止工作或被弃用的案例。在这些情况下，我们鼓励你继续在CRAN和其他网站上寻找解决方案，因为R社区以其动态发展和强大的支持闻名。'
- en: Reinforcement learning example
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强化学习示例
- en: 'In this example, we will create a sample environment for reinforcement learning.
    The concept of reinforcement learning will be explored in more detail in a later
    chapter. For this example, we will generate a series of states and actions, along
    with the reward for taking those actions, that is, whether taking the action led
    to the desired result or a negative consequence. Afterward, we will define how
    our agent should respond or learn from actions. Once all of this has been defined,
    we will run the program and the agent will navigate through the environment to
    learn to solve the task. We will define and run a minimal reinforcement learning
    example by running the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个强化学习的样本环境。强化学习的概念将在后续章节中更详细地探讨。在这个示例中，我们将生成一系列状态和动作，以及采取这些动作的奖励，即，采取行动是否导致了期望的结果或负面后果。然后，我们将定义我们的代理如何响应或从这些动作中学习。一旦所有这些内容都被定义，我们将运行程序，代理将通过环境进行学习并解决任务。我们将通过运行以下代码定义并执行一个最小的强化学习示例：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can see the following in this example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们可以看到以下内容：
- en: The syntax is very familiar and similar to many other R packages that we might
    use. In addition, we can see that we can complete a simple reinforcement learning
    task using a minimal amount of code.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法非常熟悉，类似于我们可能使用的许多其他R包。此外，我们还可以看到，我们可以使用极少的代码完成一个简单的强化学习任务。
- en: In the GitHub repository for the package, all of the functions are written in
    R, which provides the convenience to explore the possible reasons for issues if
    they arrive. This also alleviates any concerns over dependencies on additional
    languages present in the more complex packages noted previously.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在该包的GitHub代码库中，所有函数都是用R语言编写的，这为探索问题发生的可能原因提供了便利。如果出现问题，也能够减少对更复杂包中其他语言的依赖，这一点较为重要。
- en: An RBM example
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个RBM示例
- en: Here is a simple example using the `RBM` package. RBMs can be created using
    the `MXNet` library. However, we include this package in this book to note when
    it makes the most sense to train an `RBM` model using `MXNet` and when a standalone
    implementation of the algorithm may be a better fit.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用`RBM`包的简单示例。RBM模型可以通过`MXNet`库创建。然而，我们在本书中包含这个包，是为了说明何时使用`MXNet`训练`RBM`模型最为合适，以及何时独立实现算法可能会更合适。
- en: 'In the following example, we assign the `train` Fashion MNIST dataset to an
    object, create an RBM model on this data, and then make a prediction using the
    modeled results. A detailed exploration of how the RBM algorithm achieves this
    outcome and suggested applications are included in a future chapter. We will see
    how simply we can train this model and use it for prediction with a familiar syntax
    by running the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将`train` Fashion MNIST数据集分配给一个对象，在此数据上创建一个RBM模型，并使用模型的结果进行预测。关于RBM算法如何实现这一结果以及建议的应用将在后续章节中详细探讨。我们将通过运行以下代码，看到我们如何使用熟悉的语法简单地训练此模型并用于预测：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As with the `ReinforcementLearning` package, the following applies:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ReinforcementLearning`包类似，以下内容适用：
- en: RBM is written entirely in R, so exploring the code in the repository is an
    excellent way to better understand how this particular technique works.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RBM 完全用 R 编写，因此浏览代码库是更好地理解这种特定技术如何工作的一个绝佳方法。
- en: Also, as noted before, if you only need to train a model using RBM, then using
    a standalone package can be a great way to avoid having to load too many unnecessary
    functions, as is the case when using a library such as MXNet.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，正如之前提到的，如果你只需要使用 RBM 训练模型，那么使用一个独立的包是避免加载过多不必要的函数的好方法，这种情况在使用像 MXNet 这样的库时会出现。
- en: Both comprehensive packages and standalone packages have their place in a deep
    learning workflow, so this book will highlight the advantages and disadvantages
    of each of them.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 综合包和独立包在深度学习工作流中各有其位置，因此本书将重点介绍它们各自的优缺点。
- en: Comparing the deep learning libraries
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较深度学习库
- en: 'When comparing the three comprehensive machine learning libraries highlighted
    in this chapter (Keras, H2O, and MXNet), there are three primary differences:
    external language dependencies, functions, and syntax (ease of use and cognitive
    load). We will now cover each of these main differences in turn.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较本章中强调的三种综合机器学习库（Keras、H2O 和 MXNet）时，有三个主要的区别：外部语言依赖性、函数和语法（易用性和认知负担）。我们将逐一介绍这些主要区别。
- en: 'The first major difference between the three packages is the external language
    dependencies for each. As mentioned earlier, none of these packages are written
    in R. What this means is that you will need additional languages installed on
    your machine in order for these packages to work. It also means that you cannot
    easily look at the source documentation to see how a particular function works
    or why you are receiving a certain error (unless you know one of the languages,
    of course). The packages are written using the following languages: Keras in Python,
    H2O in Java, and MXNet in C#.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 三个软件包之间的第一个主要区别是它们的外部语言依赖性。如前所述，这些软件包都不是用 R 编写的。这意味着你需要在机器上安装额外的语言才能使这些软件包正常工作。这也意味着你不能轻松查看源文档来了解某个函数是如何工作的，或者为什么会收到特定的错误（当然，前提是你知道某种语言）。这些软件包是使用以下语言编写的：Keras
    用 Python，H2O 用 Java，MXNet 用 C#。
- en: The next major difference has to do with the types of models that can be implemented
    from each package. You can use all three packages to train a feedforward model,
    such as a multilayer perceptron, where all hidden layers are fully connected layers.
    Keras and MXNet allow you to train deep learning models that include different
    types of hidden layers, as well as feedback loops between layers. These include
    RNNs, LSTMs, and CNNs. MXNet offers support for additional algorithms, including
    GANs, RBMs/DBNs, and reinforcement learning.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个主要区别涉及每个软件包中可以实现的模型类型。你可以使用这三个软件包训练前馈模型，例如多层感知器，其中所有隐藏层都是全连接层。Keras 和 MXNet
    允许你训练包括不同类型隐藏层的深度学习模型，并且支持层间反馈循环。这些模型包括 RNN、LSTM 和 CNN。MXNet 还支持其他算法，包括 GAN、RBM/DBN
    和强化学习。
- en: The last major difference has to do with the syntax for the model. Some use
    a very familiar syntax, which, in turn, makes them easier to learn and use. There
    is less for you to remember when the code resembles other R code that you use
    for other purposes. To this end, Keras has a very familiar syntax. It is modular,
    which means every function performs a discrete step within the overall model and
    all the functions can be piped together.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个主要区别涉及模型的语法。有些语法非常熟悉，这使得它们更容易学习和使用。当代码类似于你用于其他用途的 R 代码时，你需要记住的内容会更少。为此，Keras
    采用了一种非常熟悉的语法。它是模块化的，这意味着每个函数在整体模型中执行一个离散的步骤，所有函数都可以链式连接起来。
- en: This closely resembles the way that `tidyverse` functions are chained together
    for data preparation. MXNet follows a syntax similar to other machine learning
    packages, where a dataset and target variable vector are passed to the function
    to train the model, along with numerous additional arguments that control how
    the model is created. The syntax for H2O deviates the furthest from common R programming
    conventions. It requires a cluster to be initialized ahead of any modeling. Data
    must also be stored in specific data objects and some functions operate on a data
    object just by calling a function on that object without assigning the results
    to a new object, as in typical R programming.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `tidyverse` 函数如何连接在一起进行数据准备非常相似。MXNet 的语法类似于其他机器学习库，其中数据集和目标变量向量被传递给函数以训练模型，同时还有许多额外的参数来控制模型的创建。H2O
    的语法则与常见的 R 编程习惯最为不同。它要求在任何建模之前初始化一个集群。数据也必须存储在特定的数据对象中，一些函数通过对该对象调用函数来操作数据对象，而不需要将结果分配给一个新对象，这与典型的
    R 编程不同。
- en: Aside from these differences, Keras also provides a means for using TensorFlow,
    while H2O allows larger objects to be stored out of memory. As noted, MXNet has
    the most robust offering of deep learning algorithms. As we can see, each package
    has its advantages and, throughout this book, we will explore them in depth and
    note the most suitable use cases and applications along the way.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些差异，Keras 还提供了使用 TensorFlow 的方法，而 H2O 允许将较大的对象存储在内存之外。如前所述，MXNet 提供了最强大的深度学习算法库。正如我们所看到的，每个包都有其优点，在本书中我们将深入探讨它们，并在此过程中指出最合适的使用案例和应用。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Having completed this chapter, you should now have all of the libraries that
    will be used in this book installed. In addition, you should be familiar with
    the syntax for each of them, and you should have seen a preliminary example of
    how to train a model using each one. We also explored some of the differences
    between the deep learning libraries, noting their strengths as well as their limitations.
    The three main packages (Keras, MXNet, and H2O) are widely used for deep learning
    in industry and academia, and an understanding of these will enable you to tackle
    a number of deep learning problems. We are now ready to explore them all in more
    depth. However, before we do, we will review neural networks—the building block
    for all deep learning.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你应该已经安装了本书中将使用的所有库。此外，你还应该熟悉每个库的语法，并且已经看到过如何使用它们中的每个来训练模型的初步示例。我们还探讨了深度学习库之间的一些差异，指出了它们的优点以及局限性。这三大主要库（Keras、MXNet
    和 H2O）在工业和学术界广泛应用于深度学习，理解这些库将使你能够解决多个深度学习问题。现在，我们准备深入探索这些库。不过，在此之前，我们将回顾一下神经网络——所有深度学习的基础构建块。
- en: In the following chapter, you will learn about artificial neural networks, which
    comprise the base building block for all deep learning. We will not use these
    deep learning libraries yet in the next chapter; however, the basics of how neural
    networks are coded will be critical as we move forward. Everything we cover in
    the next chapter will carry forward and be useful as we code examples of deep
    learning models. All deep learning cases are variations of the basic neural network,
    which we will learn how to create in the next chapter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将学习人工神经网络，它构成了所有深度学习的基本构建模块。在下一章中我们还不会使用这些深度学习库；然而，神经网络如何编码的基础知识将对我们后续的学习至关重要。在下一章中，我们所涵盖的内容将继续推进，并在我们编写深度学习模型示例时非常有用。所有深度学习的案例都是基本神经网络的变体，我们将在下一章中学习如何创建这些神经网络。
