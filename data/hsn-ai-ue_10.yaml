- en: Designing Behavior Trees - Part I
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计行为树 - 第一部分
- en: This chapter (and the two that follow) will take you through a more practical
    approach of what we have learned so far. In particular, we will be focusing on
    how to implement a *Behavior Tree* so that we can chase our character in the game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章（以及接下来的两章）将带您了解我们迄今为止所学到的更实际的方法。特别是，我们将关注如何实现一个 *行为树*，以便我们可以在游戏中追逐我们的角色。
- en: In fact, we will use all the content from [Chapter 2](00781951-41e3-4e33-8512-052e7aecfd15.xhtml),
    *Behavior Trees and Blackboards*, along with a *blackboard*, to execute these
    actions, a *NavMesh* to move around the environment, and the *Perception System*
    to sense the Player.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们将使用 [第 2 章](00781951-41e3-4e33-8512-052e7aecfd15.xhtml)，*行为树和黑板* 的所有内容，以及一个
    *黑板* 来执行这些动作，一个 *NavMesh* 来在环境中移动，以及一个 **感知系统** 来感知玩家。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How to design a **Behavior Tree**, starting from the **Expected Behavior**
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 **预期行为**开始设计 **行为树**
- en: Analyzing the nodes that we might need on a **Behavior Tree**
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析我们可能在 **行为树** 中需要的节点
- en: Implementing a **Custom Decorator** (both in Blueprint and C++) to check boolean
    variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 **自定义装饰器**（在蓝图和 C++ 中）以检查布尔变量
- en: Implementing a **Custom Task** (both in Blueprint and C++) to find a random
    location around the character
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 **自定义任务**（在蓝图和 C++ 中）以找到角色周围的随机位置
- en: Using the **Navigation System** to query the **NavMesh** to find the random
    location
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **导航系统**查询 **NavMesh** 以找到随机位置
- en: Implementing a **Custom AI Controller** (both in Blueprint and C++) to use the
    **Perception System**
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 **自定义 AI 控制器**（在蓝图和 C++ 中）以使用 **感知系统**
- en: Using the **Perception System** to sense the Player
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **感知系统**来感知玩家
- en: We will cover more in the two chapters that follow.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两章中，我们将涵盖更多内容。
- en: We will be implementing everything in both Blueprint and C++ to give you a broader
    idea of what you can use. Alternatively, if you already know what you want to
    use, you can just follow one of the two implementations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在蓝图和 C++ 中实现所有内容，以便您对可以使用的内容有一个更广泛的概念。或者，如果您已经知道您想使用什么，您可以直接遵循两种实现中的任何一种。
- en: 'If you want to follow along, I''m creating this example by starting a clean
    project (in my case, I''m doing this in C++, but if you want to follow just the
    Blueprint part of this chapter, you can use the Blueprint Template), as shown
    in the following screenshot:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想跟上来，我会创建这个示例，从启动一个干净的项目开始（在我的情况下，我在 C++ 中这样做，但如果您只想跟随本章的蓝图部分，您可以使用蓝图模板），如下面的截图所示：
- en: '![](img/9913e998-403a-4d77-b1d4-e4193bd36503.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/9913e998-403a-4d77-b1d4-e4193bd36503.png)'
- en: Unreal Project Browser
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal 项目浏览器
- en: The project is called `BehaviorTreeDesign` and I am using the `Third Person`
    template.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目被称为 `BehaviorTreeDesign`，我正在使用 `Third Person` 模板。
- en: With all this said and done, let's dive in!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，让我们深入探讨吧！
- en: The Expected Behavior
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预期行为
- en: The first step in **Designing a Behavior Tree** is to pin down the **Expected
    Behavior** we would like to see in our character. This seems like a simple phase,
    but trying to take all the cases into consideration isn't trivial. However, it
    will avoid many headaches later on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计行为树**的第一步是确定我们希望在角色中看到的 **预期行为**。这似乎是一个简单的阶段，但尝试考虑所有情况并不简单。然而，这将避免以后出现许多头痛问题。'
- en: While writing down the **Expected Behavior**, try to be as specific as possible.
    If something is unclear, try to rephrase it. The sentences that you use should
    be short and always add information. Don't be scared if you have sentences starting
    with "In this case…" or "If…", because it will just mean that you are taking all
    the different possibilities into consideration. Once you have written it, read
    it out loud, maybe to a friend, and ask him/her if he/she clearly understands
    its meaning.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在写下 **预期行为** 时，尽量具体。如果有什么不清楚的地方，尝试重新措辞。您使用的句子应该简短，并且总是添加信息。如果您有以 "在这种情况下…" 或
    "如果…" 开头的句子，不要害怕，因为这仅仅意味着您正在考虑所有不同的可能性。一旦您写完，大声读出来，也许给朋友听，并问他/她是否清楚地理解其含义。
- en: 'This is my attempt of describing the behavior we are going to implement in
    this chapter: "*The agent checks whether it has the player in sight. If it is
    true, then it chases the player until he/she is no longer in sight. If the player
    is not in sight, then the agent goes to the last location where it saw the player
    (if the location is known). Otherwise, the agent chooses a random location around
    it and goes to that location*"'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我尝试描述本章将要实现的行为：“**智能体检查它是否能看到玩家。如果是真的，那么它将追逐玩家**，直到他/她不再在视野中。如果玩家不在视野中，那么智能体将前往它最后一次看到玩家的位置（如果位置已知）。否则，智能体将在其周围选择一个随机位置并前往该位置。”
- en: Building the Nodes
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建节点
- en: After you've written the **Expected Behavior**, the next step is to analyze
    it so that you understand which kind of Behavior Tree nodes we will need. Of course,
    we can always add them at a later stage, but it is better to try and anticipate
    as much as possible so that you can proceed smoothly during the creation of the
    **Behavior Tree**. Let's break down the expected behavior so that we can try and
    understand which node we need to implement.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在你编写了**预期行为**之后，下一步是分析它，以便你理解我们需要哪种类型的行为树节点。当然，我们总是可以在稍后阶段添加它们，但最好尽可能多地预测，以便你在创建**行为树**的过程中能够顺利地进行。让我们分解预期行为，以便我们尝试理解需要实现哪些节点。
- en: Nodes that already exist
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 已存在的节点
- en: We need to check which part of our behavior already exists in our project, and
    whether it is either a built-in functionality or whether we have already created the
    node for that functionality (maybe for another *AI Behavior Tree*).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要检查我们的行为中哪些部分已经存在于我们的项目中，以及它是否是内置功能，或者我们是否已经为该功能创建了节点（可能是为另一个 *AI 行为树*）。
- en: '"The agent checks whether it has the player in sight. If it is true, **then
    it chases the player** until he/she is no longer in sight. If the player is not
    in sight, **then the agent goes** to the last location where it saw the player
    (if the location is known). Otherwise, the agent chooses a random location around
    it **and goes to that location**."'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: “智能体检查它是否能看到玩家。如果是真的，**那么它将追逐玩家**，直到他/她不再在视野中。如果玩家不在视野中，**那么智能体将前往**它最后一次看到玩家的位置（如果位置已知）。否则，智能体将在其周围选择一个随机位置**并前往该位置**。”
- en: In particular, it's worth noting that we already have a *Behavior Tree Task* already
    built in that allows the agent to chase after an object or reach a location. Therefore,
    all the highlighted parts of the **Expected Behavior** are covered.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 特别值得一提的是，我们已经有了一个内置的 *行为树任务*，允许智能体追逐一个对象或到达一个位置。因此，**预期行为**中所有加粗的部分都已涵盖。
- en: Decorator – check variable
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器 - 检查变量
- en: '"***The agent checks whether it has the player in sight.** If it is true, then
    it chases the player until he/she is no longer in sight. If the player is not
    in sight, then the agent goes to the last location where it saw the player (if
    the location is known). Otherwise, the agent chooses a random location around
    it and goes to that location.*"'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: “**智能体检查它是否能看到玩家。** 如果是真的，那么它将追逐玩家，直到他/她不再在视野中。如果玩家不在视野中，那么智能体将前往它最后一次看到玩家的位置（如果位置已知）。否则，智能体将在其周围选择一个随机位置并前往该位置。”
- en: To perform this check, we need to decide how the agent is going to "*perceive*" the
    player. In chapter 5, we saw how the built-in perception system works, and for
    such a trivial task, the system is more than perfect. Therefore, it is worth using
    it. However, we need to transfer this information into the *Behavior Tree*. Therefore,
    we need to start making assumptions on how we will implement the whole AI Behavior.
    For now, let's assume that this information regarding whether the player is in
    sight or not is stored within a boolean *Blackboard* variable. As a result, we
    need to implement a decorator that it is able to check this boolean variable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此检查，我们需要决定智能体将如何“感知”玩家。在第5章中，我们看到了内置感知系统的工作原理，对于这样一个简单的任务，系统已经非常完美。因此，值得使用它。然而，我们需要将此信息转移到**行为树**中。因此，我们需要开始假设我们将如何实现整个AI行为。目前，让我们假设有关玩家是否在视野中的信息存储在一个布尔**黑板**变量中。因此，我们需要实现一个装饰器，使其能够检查这个布尔变量。
- en: You could also use the ***Blackboard*** decorator (which is displayed for "*Blackboard
    Based Conditions*") to check whether a variable is assigned or not and use that
    to determine whether the player is on-sight or not. However, since the main goal
    of this chapter is to learn how to build a *Behavior Tree* from scratch from a
    practical point of view, it is more useful for you to create an extra Decorator
    node so that you are more familiar with the process of creating Decorators as
    well.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用***黑板***装饰器（用于显示“基于黑板的条件”）来检查变量是否已分配，并使用它来确定玩家是否在视野中。然而，由于本章的主要目标是学习从实际角度从头开始构建*行为树*，因此创建一个额外的装饰器节点对你来说更有用，这样你就可以更熟悉创建装饰器的过程。
- en: Also, while designing nodes, we need to try and be as general as possible, so
    that if we have a similar need in another *Behavior Tree*, we can reuse the node
    we have created. Therefore, we can create a check, by using a *Decorator* node,
    for boolean variables in general, and we will use this to check if a variable
    in our Blackboard tells us whether the player is in sight.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在设计节点时，我们需要尽可能保持通用性，这样如果我们在另一个*行为树*中有类似的需求，我们可以重用我们创建的节点。因此，我们可以通过使用*装饰器*节点来检查布尔变量，我们将使用它来检查黑板中的变量是否告诉我们玩家是否在视野中。
- en: Once we have established this, we need to think about how we are going to implement
    the node. In this specific case, it is quite straightforward, but to keep things
    as general as possible, let's think of other possible use of this node.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们建立了这个，我们需要考虑我们将如何实现这个节点。在这个特定的情况下，它相当直接，但为了尽可能保持通用性，让我们考虑这个节点可能的其他用途。
- en: 'For instance, what if we want to check if the variable is false instead? Actually,
    we will need this functionality (you will understand why later in this chapter).
    Thankfully, Unreal has us covered. In fact, there is a handy checkbox in the details
    panel of a decorator named Inverse Condition, which (as the name suggests) inverts
    the result of the condition, allowing us somehow check for the opposite:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想检查变量是否为假呢？实际上，我们将需要这个功能（你将在本章后面理解为什么需要它）。幸运的是，虚幻引擎已经为我们提供了这个功能。事实上，在装饰器的详细面板中有一个方便的复选框，名为“逆条件”，正如其名所示，它反转条件的输出，使我们能够检查相反的情况：
- en: '![](img/31dbc4e1-05da-4da0-b4b2-d6d922fc889f.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/31dbc4e1-05da-4da0-b4b2-d6d922fc889f.png)'
- en: 'As an exercise, ignore this checkbox and try to implement your own version
    of inverting the condition. Even though it has no practical application, and *it
    is actually bad practice* doing something like that, it is still a useful exercise
    so that you can understand how inputs are given to a Decorator. In this exercise,
    there are two inputs for this node: the Blackboard key value (which is assumed
    to be a boolean type) to check, and another boolean variable to establish if the
    check is on the "true" or "false" value of the variable.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，忽略这个复选框，尝试实现你自己的条件反转版本。尽管它没有实际应用，并且*这样做实际上是不好的做法*，但它仍然是一个有用的练习，这样你可以理解如何向装饰器提供输入。在这个练习中，这个节点有两个输入：要检查的黑板键值（假设为布尔类型）和另一个布尔变量，用于确定检查的是变量的“真”值还是“假”值。
- en: Without further ado, let's move on to the actual implementation of this node.
    As usual, I will do this both in Blueprint and C++.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 不再赘述，让我们继续进行这个节点的实际实现。像往常一样，我将在蓝图和C++中同时进行。
- en: Check Variable Blueprint implementation
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查变量蓝图实现
- en: First of all, let's create a new *Decorator* (recall that you can either create
    it from the Behavior Tree editor or from the content browser; the first one is
    easier, but you need to have a Behavior Tree open). Either way, name it `BTDecorator_CheckBooleanVariableBP` (the
    ending "BP" is only used to distinguish it from the C++ version of it, since you
    might be doing both. In a real project, you usually have only one version).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个新的*装饰器*（回想一下，你可以从行为树编辑器或内容浏览器中创建它；前者更容易，但你需要有一个行为树打开。无论如何，将其命名为`BTDecorator_CheckBooleanVariableBP`（结尾的“BP”仅用于区分它与C++版本的差异，因为你可能两者都会做。在实际项目中，你通常只有一个版本）。
- en: 'In case you close the Editor without adding anything to your Decorator (for
    instance, to rename it), when you open it, you might see a screen like the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在没有向装饰器添加任何内容的情况下关闭编辑器（例如，为了重命名它），当你打开它时，你可能会看到如下屏幕：
- en: '![](img/316baf07-e302-48ce-a75e-1e41272142f5.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/316baf07-e302-48ce-a75e-1e41272142f5.png)'
- en: In this case, just click on Open Full Blueprint Editor to go to the Blueprint
    Editor.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，只需点击“打开完整蓝图编辑器”进入蓝图编辑器。
- en: 'As we stated previously, we just need a single variable of type *Blackboard
    Key Selector* as input, which we will name `BoolVariableToCheckKey`. This holds
    a reference to the blackboard boolean variable we would like to check. Moreover,
    it needs to be public (open the eye next to the variable name) so that it can
    be seen within the Behavior Tree Editor. This is what it should look like:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所述，我们只需要一个类型为 *Blackboard Key Selector* 的单个变量作为输入，我们将它命名为 `BoolVariableToCheckKey`。它持有我们想要检查的黑板布尔变量的引用。此外，它需要是公共的（打开变量名称旁边的眼睛），这样它就可以在行为树编辑器中看到。它应该看起来是这样的：
- en: '![](img/7f519881-0e2a-4c95-bcbf-970d46852696.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7f519881-0e2a-4c95-bcbf-970d46852696.png)'
- en: 'Next, we need to implement/override the Perform Condition Check AI function,
    which can be found in the override dropdown menu, as shown in the following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现/重写 Perform Condition Check AI 函数，该函数可以在重写下拉菜单中找到，如下面的截图所示：
- en: '![](img/fdda5624-65be-4d03-82cb-6a4535584d5a.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fdda5624-65be-4d03-82cb-6a4535584d5a.png)'
- en: 'Once the function has been created, this is what it looks like by default:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了这个函数，默认情况下它看起来是这样的：
- en: '![](img/3219c375-c950-417b-8bdd-2bb9aabbd08d.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3219c375-c950-417b-8bdd-2bb9aabbd08d.png)'
- en: 'First, we need to retrieve the boolean value of our Blackboard Key, which can
    be done by using the Get Blackboard Value as Bool node. Then, we can plug the
    Return Value pin of this node into the Return Value pin of the Return Node. This
    is what the final graph should look like:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要检索我们的黑板键的布尔值，这可以通过使用“获取黑板值作为布尔值”节点来完成。然后，我们可以将此节点的“返回值”引脚连接到“返回节点”的“返回值”引脚。最终图形应该看起来是这样的：
- en: '![](img/f992d09e-7b7d-4380-a276-9921f6ae99b0.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f992d09e-7b7d-4380-a276-9921f6ae99b0.png)'
- en: 'Save the Blueprint, and the Decorator will be ready. If you wish, you can place
    it somewhere in a Behavior Tree to see if the inputs show up properly. In particular,
    this is what it looks like when placed in a Behavior Tree:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 保存蓝图，装饰器将准备就绪。如果您愿意，可以将它放置在行为树中的某个位置，以查看输入是否显示正确。特别是，当放置在行为树中时，它看起来是这样的：
- en: '![](img/da35b790-3f7a-4120-9b33-6aec5b2b2a82.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/da35b790-3f7a-4120-9b33-6aec5b2b2a82.png)'
- en: 'Finally, the *Details Panel* of the *Decorator* (within the Behavior Tree Editor)
    should look as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*装饰器*（在行为树编辑器中）的 *详细信息面板* 应该看起来如下：
- en: '![](img/44f5ba63-ae9c-4620-932b-5436d5043dcd.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/44f5ba63-ae9c-4620-932b-5436d5043dcd.png)'
- en: Check Variable C++ implementation
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查变量 C++ 实现
- en: For details on how to extend a Decorator, you can have a look at Chapter 6,
    *Extending Behavior Trees*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何扩展装饰器的详细信息，您可以查看第 6 章，*扩展行为树*。
- en: 'First of all, let''s create a new C++ class that inherits from **UBTDecorator**.
    You need to search for all the classes and select BTDecorator, as shown in the
    following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个新的 C++ 类，该类继承自 **UBTDecorator**。您需要搜索所有类并选择 BTDecorator，如下面的截图所示：
- en: '![](img/388abf62-0800-45bd-bc08-c3a388b07634.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/388abf62-0800-45bd-bc08-c3a388b07634.png)'
- en: 'Then, you can rename your class `BTDecorator_CheckBoolVariable`. Also, if you
    wish, you can place the file in a sub-folder, such as `AI`. As example of this
    is shown in the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以重命名您的类 `BTDecorator_CheckBoolVariable`。如果您愿意，您还可以将文件放置在子文件夹中，例如 `AI`。以下是一个示例截图：
- en: '![](img/10f67242-1c45-49b8-b87d-c862005b9df6.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/10f67242-1c45-49b8-b87d-c862005b9df6.png)'
- en: Press Create Class, and your *Decorator* class will be created.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 点击创建类，您的 *Decorator* 类将被创建。
- en: 'After you have created the Class, Unreal will try to compile your code. If
    you haven''t set up your Public Dependencies in your project properly (as we learned
    back in Chapter 1 and Chapter 2; and especially in [Chapter 6](e8c4d8a9-579e-4e38-b02a-a9002f1c48ce.xhtml),
    *Extending Behavior Trees*), you should have a message similar to the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在您创建类之后，Unreal 将尝试编译您的代码。如果您没有正确设置项目中的公共依赖项（正如我们在第 1 章和第 2 章中学到的；特别是在[第 6 章](e8c4d8a9-579e-4e38-b02a-a9002f1c48ce.xhtml)，*扩展行为树*），您应该收到如下类似的消息：
- en: '![](img/46a5e21d-866f-460a-98c0-a5ab82df2271.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/46a5e21d-866f-460a-98c0-a5ab82df2271.png)'
- en: 'However, when you try to compile from Visual Studio, this is what the error
    will look like:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当您尝试从 Visual Studio 编译时，错误将如下所示：
- en: '![](img/79958f18-57ed-4757-869c-14b6efa97c40.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/79958f18-57ed-4757-869c-14b6efa97c40.png)'
- en: 'Therefore, you need to change your `.cs` file (in our case, ***BehaviorTreeDesign.cs***),
    and add "**GameplayTasks**" and "**AIModule**" as public dependencies, as shown
    in the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您需要更改您的 `.cs` 文件（在我们的案例中，***BehaviorTreeDesign.cs***），并将“**GameplayTasks**”和“**AIModule**”作为公共依赖项添加，如下面的代码所示：
- en: '`PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject",
    "Engine", "InputCore", "HeadMountedDisplay", **"GameplayTasks", "AIModule"** });`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject",
    "Engine", "InputCore", "HeadMountedDisplay", **"GameplayTasks", "AIModule"** });`'
- en: Now, you should be able compile without any issues.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够无任何问题地编译。
- en: 'In the header file, we need to add an input variable, the *Blackboard Key Selector*
    that references a Boolean, named `BoolVariableToCheck`. We also need to expose
    this variable to the Behavior Tree editor by using the `UPROPERTY()` macro, as
    shown in the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在头文件中，我们需要添加一个输入变量，一个引用布尔值的*黑板键选择器*，命名为`BoolVariableToCheck`。我们还需要通过使用`UPROPERTY()`宏将这个变量暴露给行为树编辑器，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we need to override the `CalculateRawConditionValue()` method, which
    is public, and so its override needs to be public as well. Insert (always in the
    header file) the following lines of code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要重写`CalculateRawConditionValue()`方法，这个方法是公开的，因此它的重写也需要是公开的。在头文件中插入以下代码行：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, we need to implement this function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现这个函数。
- en: 'First, we need to retrieve `BlackboardComponent`, which allows us to resolve
    and get the values from the Blackboard Key Selectors. Thankfully, we can retrieve
    it from `BeheviorTreeComponent` (on which this decorator is running), which is
    passed to the node as a variable named `OwnerComp`. However, to use `BlackboardComponent`,
    we need to include its definition in our `.cpp` file, with the following statement:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要检索`BlackboardComponent`，这允许我们从黑板键选择器中解析和获取值。幸运的是，我们可以从`BeheviorTreeComponent`（装饰器正在其上运行）中检索它，它作为名为`OwnerComp`的变量传递给节点。然而，要使用`BlackboardComponent`，我们需要在我们的`.cpp`文件中包含其定义，如下所示：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If, for some reason, this `BlackboardComponen**t**` is invalid (this might
    happen if you create a Behavior Tree in your Project but you have no Blackboards;
    otherwise this is difficult to do, since the Behavior Tree editor automatically
    picks a Blackboard), we can just `return false`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，这个`BlackboardComponen**t**`无效（这可能会发生在你在项目中创建行为树但你没有黑板的情况下；否则这很难做到，因为行为树编辑器会自动选择一个黑板），我们只需`return
    false`：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we need to retrieve and return the value, as a Boolean, from our *Blackboard
    Key Selector* variable. This is how we can do this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要检索并返回从我们的*黑板键选择器*变量中作为布尔值的值。这是我们可以这样做的方式：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is what the whole function should look like:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 整个函数应该看起来像这样：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Save your code and the *Decorator* will be ready. If you wish, you can place
    it somewhere in a Behavior Tree to see if the inputs show up properly. This is
    how it appears on the tree:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的代码，*装饰器*就会准备好了。如果你愿意，你可以将它放在行为树中的某个地方，看看输入是否显示正确。这是它在树上的样子：
- en: '![](img/422eb950-b1dd-4b45-9463-869ff7ef2fc9.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/422eb950-b1dd-4b45-9463-869ff7ef2fc9.png)'
- en: 'The *Details Panel* of the *Decorator* (within the *Behavior Tree Editor*)
    should look as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在*装饰器*的*详细信息面板*（在*行为树编辑器*内）应该看起来如下：
- en: '![](img/8de3bb38-097b-4ba6-acfe-048188582fa5.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8de3bb38-097b-4ba6-acfe-048188582fa5.png)'
- en: As you may have noticed, the description of our Decorator doesn't change based
    on which variable we put into it, nor does it have an icon. If you are working
    on a large project, paying attention to these details might help you and your
    team greatly. In this small example, I will leave this as an exercise. You can
    consult [Chapter 5](94d71bd8-35a2-481e-adac-1fc3494350ba.xhtml), *Agent Awareness*,
    for more information on how to do it. You can also consult the source code, in
    particular, `BTDecorator_TimeLimit`, which implements functions such as `GetStaticDescription()`,
    `DescribeRuntimeValues()`, and `GetNodeIconName()`. In this section, we are going
    to implement the `**GetStaticDescription()**` function so that you can get used
    to implementing these kinds of functions as well.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，我们的装饰器的描述不会根据我们放入其中的变量而改变，也没有图标。如果你在一个大型项目中工作，注意这些细节可能会对你和你的团队有很大帮助。在这个小例子中，我将把它作为一个练习。你可以查阅[第5章](94d71bd8-35a2-481e-adac-1fc3494350ba.xhtml)，*代理意识*，以获取更多关于如何做的信息。你也可以查阅源代码，特别是`BTDecorator_TimeLimit`，它实现了`GetStaticDescription()`、`DescribeRuntimeValues()`和`GetNodeIconName()`等函数。在本节中，我们将实现`**GetStaticDescription()**`函数，这样你就可以习惯于实现这类函数了。
- en: If you haven't read the preceding tip box, do so. Now, we are going to implement
    the `GetStaticDescription()` function for our Decorator so that we can see which
    Blackboard key has been selected for the `BoolVariableToCheck` variable.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有阅读前面的提示框，请先阅读。现在，我们将实现我们的装饰器的`GetStaticDescription()`函数，以便我们可以看到为`BoolVariableToCheck`变量选择了哪个黑板键。
- en: 'To start, we need to add the following override to the header file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在头文件中添加以下覆盖代码：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we can implement it by returning an `FString` that has been formatted
    with the `Printf()` function. By using a `***?***` statement, we can determine
    whether the Key has been set or not and show the right string value:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过返回一个使用`Printf()`函数格式化的`FString`来实现它。通过使用`***?***`语句，我们可以确定键是否已设置，并显示正确的字符串值：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you compile and add the decorator to the *Behavior Tree*, this is what it
    should look like now:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编译并将装饰器添加到*行为树*中，它现在应该看起来像这样：
- en: '![](img/7fa4cbce-e87b-414b-8b45-283ee4a83644.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fa4cbce-e87b-414b-8b45-283ee4a83644.png)'
- en: Much better! Now, it's time to implement a *Behavior Tree Task*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在好多了！现在是时候实现一个*行为树任务*了。
- en: Task – Find Random Location
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务 - 寻找随机位置
- en: '"*The agent checks whether it has the player in sight. If it is true, then
    it chases the player until he/she is no longer in sight. If the player is not
    in sight, then the agent goes to the last location where it saw the player (if
    the location is known). Otherwise, **the agent chooses a random location around
    it** and goes to that location.*"'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '"*代理检查它是否可以看到玩家。如果是，那么它会追逐玩家，直到他/她不再在视线中。如果玩家不在视线中，那么代理将前往它最后一次看到玩家的位置（如果位置已知）。否则，**代理将在其周围选择一个随机位置**并前往该位置。"*'
- en: During our Behavior, the agent selects a random location around it. This means
    that we need to create a Task that, starting from the current location of the
    agent, picks a random location that it will go to. Moreover, we should add that
    this location needs to be reachable by the agent. Thankfully, we have some pre-made
    functions to query the *Navigation Mesh* and select a *Random Location* for us.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的行为过程中，代理选择它周围的一个随机位置。这意味着我们需要创建一个任务，从代理的当前位置开始，选择一个它将前往的随机位置。此外，我们应该添加这个位置需要是代理可到达的。幸运的是，我们有一些预先制作的功能来查询*导航网格*并为我们选择一个*随机位置*。
- en: This also means that we need to assume that we have a *Navigation Mesh* available
    for our agent. Since this is the case, we can use this node. However, we still
    need to create a Task that can be executed in the Behavior Tree, and that stores
    this value properly somewhere in the *Blackboard*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着我们需要假设我们有一个*导航网格*可供我们的代理使用。既然是这样，我们可以使用这个节点。然而，我们仍然需要创建一个可以在行为树中执行的任务，并且能够将这个值适当地存储在*黑板*中。
- en: Thinking like a general node, we would like to add some additional options so
    that we can customize the behavior. For instance, how far away would we like this
    Random Location could be?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个通用节点的方式思考，我们希望添加一些额外的选项，以便我们可以自定义行为。例如，我们希望这个随机位置有多远？
- en: We have two input variables. The first is a Blackboard Key Selector that holds
    the Random Location we want to go to (since we need to save it in the Blackboard).
    The second will be just a float indicating the maximum Radius of where this Random
    Location can be taken.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个输入变量。第一个是一个黑板键选择器，它保存我们想要前往的随机位置（因为我们需要将其保存在黑板中）。第二个将是一个表示这个随机位置可以取到的最大半径的float。
- en: Once again, we will do this process both in Blueprint and C++ (so you can choose
    the implementation you are the most comfortable with).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次在蓝图和C++中执行此过程（这样你可以选择你最舒服的实现方式）。
- en: Find Random Location Blueprint implementation
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找随机位置蓝图实现
- en: Create a *Blueprint Behavior Tree Task* (read the previous chapter to learn
    how to do this) and name it `BTT_FindRandomLocation`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个*蓝图行为树任务*（阅读前面的章节了解如何做这个），并将其命名为`BTT_FindRandomLocation`。
- en: 'Create the two variables we need, one of the Blackboard Key Selector type named
    "**RandomDestination**" and the other one of the *float* type named "**Radius**".
    For the float, set a *default value different from zero*, for example, **3,000**.
    Finally, make them both *public*:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 创建我们需要的两个变量，一个是名为“**RandomDestination**”的黑板键选择器类型，另一个是名为“**Radius**”的*float*类型。对于float，设置一个*不同于零的默认值*，例如，**3,000**。最后，使它们两个都*公开*：
- en: '![](img/a468655a-fa71-456f-889c-251fbc347ab0.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a468655a-fa71-456f-889c-251fbc347ab0.png)'
- en: 'Let''s implement/override the Receive Execute AI event, as shown in the following
    screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现/覆盖以下截图所示的Receive Execute AI事件：
- en: '![](img/213ae0da-f314-4ce1-8ec8-a6798e9bf7ad.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/213ae0da-f314-4ce1-8ec8-a6798e9bf7ad.png)'
- en: 'From the event, we can retrieve the ***Controller Pawn*** actor (the agent)
    from which we can get its location, as shown in the following screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从事件中，我们可以检索到***控制器傀儡***（代理）的位置，如图下截图所示：
- en: '![](img/c186e44a-50d1-4ead-9fba-8f9c044a075f.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c186e44a-50d1-4ead-9fba-8f9c044a075f.png)'
- en: 'Then, we can use the GetRandomReachablePointInRadius node to generate a random
    reachable location within the *NavMesh*. We need to use as *Location* as the *Origin*
    from the Controlled Pawn (the agent), and ***Radius*** as our ***Radius** variable*:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用GetRandomReachablePointInRadius节点在*导航网格*内生成一个随机的可到达位置。我们需要使用*位置*作为受控傀儡（代理）的*原点*，并将***半径***作为我们的***半径**变量：
- en: '![](img/ed4b6c2d-d15c-4e60-b65c-2c183b5d1c06.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ed4b6c2d-d15c-4e60-b65c-2c183b5d1c06.png)'
- en: Find Random Location Blueprint
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 查找随机位置蓝图
- en: 'From the return value of the GetRandomReachablePointInRadius node, we create
    a Branch node. However, the call to generate the random location can fail. If
    it does, we need to terminate the task with an *insuccess (not Success)*. From
    the **Branch True** pin, we can set the **Random Location** in our **Destination
    Key** variable, as shown in the following screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从GetRandomReachablePointInRadius节点的返回值中，我们创建一个分支节点。然而，生成随机位置的调用可能会失败。如果失败了，我们需要以*失败（不是成功）*结束任务。从**分支真**引脚，我们可以将**随机位置**设置到我们的**目标键**变量中，如图下截图所示：
- en: '![](img/36d272b2-4c18-4306-a5ec-eb1a34081192.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/36d272b2-4c18-4306-a5ec-eb1a34081192.png)'
- en: Find Random Location Blueprint
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 查找随机位置蓝图
- en: 'Then, regardless of the **Branch** (from both the end of the **Set Blackboard
    Value as Vector** node and from the **False** pin of the **Branch**), we need
    to **Finish Execute** the task. To do this, we can plug the return value of the
    ***GetRandomReachablePointInRadius*** node into the **Success** pin of the **Finish
    Execute**:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，无论从**分支**（从**设置黑板值为向量**节点的末尾和**分支**的**False**引脚），我们都需要**完成执行**任务。为此，我们可以将***GetRandomReachablePointInRadius***节点的返回值插入到**完成执行**的**成功**引脚中：
- en: '![](img/c9895ca1-6178-4528-b5a6-dfc26b666c29.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c9895ca1-6178-4528-b5a6-dfc26b666c29.png)'
- en: This concludes our task, which we can now save.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的任务，我们现在可以保存它。
- en: 'If we place this node in a *Behavior Tree*, this is what it will look like:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此节点放置在*行为树*中，它将看起来像这样：
- en: '![](img/f18433ed-d3ef-404c-b4a6-b47f94fa3ce1.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f18433ed-d3ef-404c-b4a6-b47f94fa3ce1.png)'
- en: 'The *Details Panel* will look as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*详细信息面板*将如下所示：'
- en: '![](img/e7e5ce98-e3df-4d62-bac7-c5f57941f576.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e7e5ce98-e3df-4d62-bac7-c5f57941f576.png)'
- en: If you want, you can read the next section to learn how to implement this task
    in C++, otherwise, you are free to skip the next section.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想，你可以阅读下一节来学习如何在C++中实现这个任务，否则，你可以自由地跳过下一节。
- en: Find Random Location C++ implementation
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找随机位置C++实现
- en: Creating the Find Random Location task in C++ will be a bit more complicated
    than creating the Decorator, since we need to retrieve many components and check
    if they are valid.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中创建“查找随机位置”任务会比创建装饰器复杂一些，因为我们需要检索许多组件并检查它们是否有效。
- en: 'First of all, create a C++ **Behavior Tree Task** that inherits from **UBTTaskNode** by
    selecting BTTaskNode as the class you want to extend, as shown in the following
    screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个C++ **行为树任务**，通过选择BTTaskNode作为你想要扩展的类来继承自**UBTTaskNode**，如图下截图所示：
- en: '![](img/839a566c-bd87-4113-8832-6fc2e2886660.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/839a566c-bd87-4113-8832-6fc2e2886660.png)'
- en: 'Then, we can name it `BTTaskNode_FindRandomLocation` and place it (as we did
    for the Decorator) inside a folder, such as `AI`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将其命名为`BTTaskNode_FindRandomLocation`并将其（就像我们对装饰器所做的那样）放置在一个文件夹中，例如`AI`：
- en: '![](img/02f6f9e1-cdc7-4e23-bb65-49e540d8c474.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/02f6f9e1-cdc7-4e23-bb65-49e540d8c474.png)'
- en: 'First of all, in the header file, we need to add our two variables. The first
    one is the *Blackboard Key Selector* named `DestinationVector`, which will hold
    the reference to the newly calculated Destination. The second is a *float* containing
    a parametrization of the ***Radius*** (in which we will select a Random Reachable
    Point). Moreover, both of them need to be accessible to the *Behavior Tree Editor*;
    hence we need to expose them by using the `UPROPERTY()` macro. We need to use
    the following lines of code for these two variables:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在头文件中，我们需要添加我们的两个变量。第一个是名为`DestinationVector`的*黑板键选择器*，它将持有新计算出的目标引用。第二个是一个包含***半径***参数化（在其中我们将选择一个随机可到达点）的*float*。此外，它们都需要对*行为树编辑器*可访问；因此，我们需要使用`UPROPERTY()`宏来公开它们。我们需要使用以下代码行来设置这两个变量：
- en: '[PRE8]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As always, in the header file, we need to override the `ExecuteTask()` method,
    which will be called when this task needs to be executed:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，在头文件中，我们需要重写 `ExecuteTask()` 方法，当这个任务需要执行时将会被调用：
- en: '[PRE9]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is what the whole header file should look like:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 整个头文件应该看起来像这样：
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, that we are getting to our `.cpp` file, we need to do some preparation,
    especially in the `include` statements. In fact, we are going to use the **Blackboard
    Component** (like we did for the Decorator), the **Navigation System**, and the
    **AI Controller **classes. Thus, we need to include all of them, which we can
    do by using the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们进入 `.cpp` 文件时，我们需要做一些准备工作，特别是在 `include` 语句中。实际上，我们将使用 **黑板组件**（就像我们在装饰器中做的那样）、**导航系统**
    和 **AI 控制器** 类。因此，我们需要包含所有这些，我们可以通过以下代码来完成：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So, let''s define the `ExecuteTask()` function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们定义 `ExecuteTask()` 函数：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we need to start filling up the `ExecuteTask()` function. The first thing
    we need to do is get the **Blackboard Component**. In case this component is not
    available (as explained in the *D**ecorator* section, this seldom happens, but
    it still might), we need to return that the Task has failed, as shown in the following
    code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要开始填充 `ExecuteTask()` 函数。我们首先需要做的是获取 **黑板组件**。如果这个组件不可用（如 *装饰器* 部分所述，这种情况很少发生，但仍然可能），我们需要返回任务失败，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'From the Blackboard Component, we can retrieve the ***Controlled Pawn*** of
    the AI Controller that is running this instance of the *Behavior Tree*. This can
    be done by using a couple of GET functions. However, once again, the *Pawn* needs
    to be checked for its validity, and in case it isn''t valid, then the tasks need
    to return a failure:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从黑板组件中，我们可以检索运行此实例的 *行为树* 的 AI 控制器的 ***受控角色***。这可以通过使用几个 GET 函数来完成。然而，一旦再次，需要检查
    *角色* 的有效性，如果它无效，那么任务需要返回失败：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, we need to get our Navigation System. As per Unreal 4.21, we will use
    the `UNavigationSystemV1` class to do so.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要获取我们的导航系统。根据 Unreal 4.21，我们将使用 `UNavigationSystemV1` 类来完成这一任务。
- en: Starting from Unreal 4.20, the Navigation System has been refactored. Therefore,
    many functions and classes became deprecated. If the version of your Engine is
    below 4.20, this code will not work. In this case, you will need to use the `UNavigationSystem`
    class. This isn't covered in this book since it may only be of interest to a few
    readers with specific needs of using an old version of the engine.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Unreal 4.20 开始，导航系统已经被重构。因此，许多函数和类已经过时。如果你的引擎版本低于 4.20，这段代码将无法工作。在这种情况下，你需要使用
    `UNavigationSystem` 类。由于这可能只对少数有特定需求的读者感兴趣，所以这本书没有涵盖这一点。
- en: 'To get the **Current Navigation System**, we need to specify the **World**
    from which we want to retrieve this data by using a specific function named `GetCurrent()`
    (referring to the Navigation System). Once we have obtained the Navigation System,
    we want to check its validity, and in case it isn''t valid, then we make the Task
    fail:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 **当前导航系统**，我们需要通过使用名为 `GetCurrent()` 的特定函数（指导航系统）来指定我们想要从中检索这些数据的 **世界**。一旦我们获得了导航系统，我们想要检查其有效性，如果它无效，那么我们让任务失败：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There''s one more step to go before we can perform the query on the Navigation
    System. We need to create a variable of the `FNavLocation` type named `Result`,
    which is a structure that our **Navigation System** will fill with the result
    of our query. In our case, we are only interested in the Location. As a result,
    the **Navigation System** is able to perform the query:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够在导航系统上执行查询之前，还有一步要走。我们需要创建一个名为 `Result` 的 `FNavLocation` 类型的变量，这是一个结构体，我们的
    **导航系统** 将在其中填充查询的结果。在我们的案例中，我们只对位置感兴趣。因此，**导航系统** 能够执行查询：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The request to the Query can be done by using the `GetRandomReachablePointInRadius()`
    function. It has three mandatory parameters, which are the ***Origin*** from where
    this query needs to be performed, the **Radius**, and the Structure to return
    the result. In fact, its pure return value is a *boolean* that indicates if the
    query has succeeded or not, which we can use to check whether the task has failed
    or not:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用 `GetRandomReachablePointInRadius()` 函数来执行对查询的请求。它有三个强制参数，分别是查询需要执行的 ***起点***、**半径**
    和返回结果的 **结构**。实际上，它的纯返回值是一个 *布尔值*，表示查询是否成功，我们可以用它来检查任务是否失败：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In case we were able to get a random point, we need to assign it within the
    blackboard and return that the task has succeeded:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够得到一个随机点，我们需要在黑板上分配它，并返回任务已成功完成：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you try to compile this right now, you will get an error. The reason for
    this is that we have been using the **Navigation System**, but it was not included
    in the public dependencies of our module. Also, if you didn't include `AIModule`
    and `GameplayTasks`, this is the right moment to add them so that you can compile
    the code without any errors.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在尝试编译，你会得到一个错误。原因是我们在使用 **Navigation System**，但它没有被包含在我们的模块的公共依赖中。此外，如果你没有包含
    `AIModule` 和 `GameplayTasks`，现在是添加它们的好时机，这样你就可以在没有错误的情况下编译代码。
- en: 'Open the `BehaviourTreeDesign.Build.cs` file and add the `NavigationSystem`
    module to the public dependencies, as shown in the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `BehaviourTreeDesign.Build.cs` 文件，并将 `NavigationSystem` 模块添加到公共依赖中，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, we can compile without any problems.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以无任何问题地编译。
- en: 'If we add this *Task* node to our *Behavior Tree*, this is what it will look
    like:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此 *Task* 节点添加到我们的 *Behavior Tree* 中，它将看起来是这样的：
- en: '![](img/f133e894-985e-4ac6-a049-b7d18ac6e2cc.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f133e894-985e-4ac6-a049-b7d18ac6e2cc.png)'
- en: 'The *Details Panel* looks as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*Details Panel* 看起来如下：'
- en: '![](img/e75a182b-6372-4420-98a0-e7fa37f5398c.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e75a182b-6372-4420-98a0-e7fa37f5398c.png)'
- en: As we discussed earlier for the Decorator, it is always good practice to implement
    the functions that describe the node so that we can use it easier. I understand
    that we might not have an icon ready, but at least we can change the description
    to show which variables we have assigned.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论 Decorator 时所说的，实现描述节点的函数始终是一个好习惯，这样我们就可以更容易地使用它。我明白我们可能还没有准备好图标，但至少我们可以更改描述以显示我们分配了哪些变量。
- en: 'To do this, we need to implement/override the `GetStaticDescription()` function.
    Declare it in the header file by adding the following line:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要实现/覆盖 `GetStaticDescription()` 函数。在头文件中声明它，添加以下行：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, in the `.cpp` file, we need to return a `FString` that has been formatted
    to show the variables of the Task. In particular, we want to show the `DestinationKey`
    and how big the ***Radius*** is. We can easily format the string with the `Printf()`
    function, as shown in the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `.cpp` 文件中，我们需要返回一个格式化后的 `FString`，以显示任务的变量。特别是，我们想显示 `DestinationKey`
    和 ***Radius*** 的大小。我们可以使用 `Printf()` 函数轻松地格式化字符串，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we compile and add this *Task* again to a *Behavior Tree*, this is how it
    should appear now:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编译并再次将此 *Task* 添加到 *Behavior Tree* 中，它现在的样子应该是这样的：
- en: '![](img/ed04c8ee-fde0-494c-83e3-195571c7af7c.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed04c8ee-fde0-494c-83e3-195571c7af7c.png)'
- en: This concludes the implementation of our Task in C++.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们在 C++ 中的 Task 实现。
- en: AI Controller
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AI 控制器
- en: From the *Expected Behavior*, we have concluded that we need a *Perception System*
    to check whether the agent is able to see the *Player*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *Expected Behavior* 中，我们得出结论，我们需要一个 *Perception System* 来检查代理是否能够看到 *Player*。
- en: Once again, we can create our AI Controller both in Blueprint or C++.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们可以在蓝图或 C++ 中创建我们的 AI 控制器。
- en: Implementing the AI Controller in Blueprint
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在蓝图实现 AI 控制器
- en: 'First of all, create a new AI Controller and name it `BP_ChasingAIController` by
    selecting the `AIController` *Class*:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的 AI 控制器，并将其命名为 `BP_ChasingAIController`，通过选择 `AIController` *Class*：
- en: '![](img/ab550be6-e01b-42e0-980d-12cdc944bffb.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab550be6-e01b-42e0-980d-12cdc944bffb.png)'
- en: 'In the editor, we need to add two variables (so that the Service we build in
    the next chapter will be able to retrieve the values within them). The first variable
    is `LastKnownPlayerPosition` of type *Vector*, and the second is `CanSeePlayer`
    of type *boolean*, as shown in the following screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器中，我们需要添加两个变量（这样我们下一章构建的服务就能检索到它们内部的值）。第一个变量是 `LastKnownPlayerPosition`，类型为
    *Vector*，第二个变量是 `CanSeePlayer`，类型为 *boolean*，如下面的截图所示：
- en: '![](img/c66c5402-6d59-46b8-9a7f-faad17982be6.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c66c5402-6d59-46b8-9a7f-faad17982be6.png)'
- en: 'Now, we need to add the perception component. So, from the Components tab,
    add the AIPerception system, as shown in the following screenshot:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加感知组件。因此，从组件选项卡中，添加 AIPerception 系统，如下面的截图所示：
- en: '![](img/c4432dd0-12ca-44cc-ae92-89fd853c7858.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c4432dd0-12ca-44cc-ae92-89fd853c7858.png)'
- en: 'Then, in the Details panel, we need to select the options for it. In particular,
    we need to set the ***Sense of Sight***:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 Details 面板中，我们需要选择它的选项。特别是，我们需要设置 ***Sense of Sight***：
- en: '![](img/a347cbce-dbf7-443a-88f3-71123ec866ed.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a347cbce-dbf7-443a-88f3-71123ec866ed.png)'
- en: 'Next, in the **Sense Of Sight Config** settings, check all the detection flags
    (as we explained in [Chapter 5](94d71bd8-35a2-481e-adac-1fc3494350ba.xhtml), *Agent
    Awareness*, we need to detect the player, which by default is neutral). In the
    end, this is what the settings should look like:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在**视觉配置**设置中，检查所有的检测标志（正如我们在[第五章](94d71bd8-35a2-481e-adac-1fc3494350ba.xhtml)中解释的，*代理意识*，我们需要检测玩家，默认情况下是中立的）。最后，设置应该看起来像这样：
- en: '![](img/30a5a1fd-dfe5-4759-9a1e-e0a1d210da94.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/30a5a1fd-dfe5-4759-9a1e-e0a1d210da94.png)'
- en: 'From the Details panel, we need to generate the On Target Perception Updated
    event by clicking on the + symbol next to it:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在详情面板中，我们需要通过点击旁边的+符号来生成`On Target Perception Updated`事件：
- en: '![](img/1e405f13-77bc-4be9-afe6-fbd220440243.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1e405f13-77bc-4be9-afe6-fbd220440243.png)'
- en: 'Now, we cast the **Actor** pin from the event into our player (for example, `FirstPersonCharacter`
    or `ThirdPersonCharacter`, depending which template you choose, or your *Player
    class* if you are using this in your project), to check if the object of the perception
    is actually the player:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将事件中的**Actor**引脚从我们的玩家（例如，`FirstPersonCharacter`或`ThirdPersonCharacter`，取决于你选择的模板，或者如果你在项目中使用它，是你的*Player类*），以检查感知的对象实际上是否是玩家：
- en: '![](img/fb1ce399-58af-4be4-9762-64fc8b6b3a5e.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb1ce399-58af-4be4-9762-64fc8b6b3a5e.png)'
- en: 'Then, we break the **Stimulus** pin to get the **Stimulus Location**, which
    we store inside the **LastKnownPlayerPosition** variable, and **Successfully Sensed**,
    which we store inside the ***CanSeePlayer*** variable. Of course, these Set functions
    need to be placed after the cast. This is the final code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们断开**刺激**引脚以获取**刺激位置**，我们将其存储在**LastKnownPlayerPosition**变量中，以及**Successfully
    Sensed**，我们将其存储在**CanSeePlayer**变量中。当然，这些Set函数需要在转换之后放置。这是最终的代码：
- en: '![](img/b1764676-a86c-4155-9f82-3be7b25e148d.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b1764676-a86c-4155-9f82-3be7b25e148d.png)'
- en: The ***AI Controller*** is now ready to be used.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，***AI控制器***已经准备好使用。
- en: Implementing the AI Controller in C++
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++中实现AI控制器
- en: 'First of all, create a new class that inherits from `AIController`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的类，它继承自`AIController`：
- en: '![](img/b4597ce4-e182-428c-83b9-3b6d54550a0c.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b4597ce4-e182-428c-83b9-3b6d54550a0c.png)'
- en: 'Then, name it `ChasingAIController` and place it in our `AI` folder, as shown
    in the following screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将其命名为`ChasingAIController`并将其放置在我们的`AI`文件夹中，如下面的截图所示：
- en: '![](img/a9513b1a-fed0-46f3-a42e-90ad4c67cfdb.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a9513b1a-fed0-46f3-a42e-90ad4c67cfdb.png)'
- en: 'As we explained in the Chapter about the *Perception*, we first need to include
    the classes that concern the perception to be able to use them. Add the following
    `#include` statements in the header file:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在关于*感知*的章节中解释的，我们首先需要包含与感知相关的类，以便能够使用它们。在头文件中添加以下`#include`语句：
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we need to add the declaration of our ***Class Constructor***, since
    we will be using one to set up our controller. Just below the `GENERATE_BODY()`
    macro, add the following code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加我们的***类构造函数***的声明，因为我们将会使用一个来设置我们的控制器。在`GENERATE_BODY()`宏下面，添加以下代码：
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We need to keep track of the `PerceptionComponent` that we will add to the
    controller. However, the AI Controller base class, has already a reference to
    a Perception Component, so we don''t need to declare it. You will find this very
    signature in the base class:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要跟踪我们将要添加到控制器中的`PerceptionComponent`。然而，AI控制器基类已经有一个感知组件的引用，所以我们不需要声明它。你将在基类中找到这个非常相似的签名：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'However, we need to have a reference to the *Sight Configuration* that we will
    create, so we need this variable:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要有一个对我们将要创建的*视觉配置*的引用，因此我们需要这个变量：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Since in the next chapter we will create a service that will gather some variables
    from this controller, we need to make two public variables. The first variable
    is the `LastKnownPlayerPosition` of type Vector, and the second is `CanSeePlayer`
    of type boolean. You can add them in the header with the following snippet of
    code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在下一章中我们将创建一个服务来收集从这个控制器中的一些变量，我们需要创建两个公共变量。第一个变量是`LastKnownPlayerPosition`，类型为Vector，第二个是`CanSeePlayer`，类型为布尔型。你可以在头文件中添加以下代码片段：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, in our header file, we need to **add a delegate** for our Perception
    System that will update our variables. We can call this delegate `OnTargetPerceptionUpdated()`
    and make it protected. It has `AActor*` and `FAIStimuli` as inputs, as shown in
    the following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的头文件中，我们需要为我们的感知系统添加一个代表，该代表将更新我们的变量。我们可以将此代表命名为`OnTargetPerceptionUpdated()`并使其受保护。它以`AActor*`和`FAIStimuli`作为输入，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we need to create the **Perception Component** in the **Constructor**
    of the class. Add the following code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在类的**构造函数**中创建**感知组件**。添加以下代码：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we need to create the *Sight Sense*, and configure it to set all the
    `DetectionByAffiliation` to true, as shown in the following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要创建**视觉感知**，并将其配置为将所有`DetectionByAffiliation`设置为true，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now that we have `PerceptionComponent` and `SightConfig`, we need to assign
    the latter to the first:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`PerceptionComponent`和`SightConfig`，我们需要将后者分配给前者：
- en: '[PRE30]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The last step is to ***bind our delegate*** function to the **Perception System**,
    as shown in the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将我们的委托函数**绑定**到**感知系统**，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we need to implement our `OnTargetPerceptionUpdate()` Delegate. First
    of all, we need to include the header file of our Player class. In this example
    case, we have a C++ class named `BehaviorTreeDesignCharacter` (the Blueprint `ThirdPersonCharacter`
    inherits from this class). In my case, I added the following #`include` statement
    (you can include the one of your Player class):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要实现我们的`OnTargetPerceptionUpdate()`委托。首先，我们需要包含我们的玩家类的头文件。在这个示例中，我们有一个名为`BehaviorTreeDesignCharacter`的C++类（蓝图`ThirdPersonCharacter`从这个类继承）。在我的情况下，我添加了以下`#include`语句（你可以包含你的玩家类中的一个）：
- en: '[PRE32]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In particular, we need to check if the Actor (passed as input) is really the
    *Player* class, which we can do with a cast (to the Player class we have included):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们需要检查传递给我们的Actor（作为输入）是否真的是**玩家**类，我们可以通过强制类型转换（到我们包含的玩家类）来完成：
- en: '[PRE33]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If this is the case, we can use the ***Stimulus*** input to retrieve the `StimulusLocation` if
    it `WasSuccessfullySensed` and assign it to our `LastKnownPlayerPosition` and
    `CanSeePlayer` variables, as shown in the following code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，我们可以使用**刺激**输入来检索`StimulusLocation`，如果它`WasSuccessfullySensed`，并将其分配给我们的`LastKnownPlayerPosition`和`CanSeePlayer`变量，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The AI Controller is now ready to be used!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: AI控制器现在已准备好使用！
- en: Using the AI Controller
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AI控制器
- en: Regardless of whether you used a Blueprint or C++ implementation, you need to
    assign the controller to your Chasing Agent. Whether you do so directly in the
    blueprint, or directly in the instanced version of the game, under the Pawn settings,
    you need to change the AI Controller so that it's the one we just created. We
    also need to ensure that the AI is able to auto-posses this pawn.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用的是蓝图还是C++实现，你都需要将控制器分配给你的追逐代理。无论你是直接在蓝图中进行，还是在游戏的实例版本中，在Pawn设置下，你都需要更改AI控制器，使其为我们刚刚创建的那个。我们还需要确保AI能够自动控制这个Pawn。
- en: 'As a result, you should have something like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你应该会有类似以下的内容：
- en: '![](img/517ef3f9-0354-4e9b-b043-728261e5817c.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/517ef3f9-0354-4e9b-b043-728261e5817c.png)'
- en: Now, we have (almost) all the pieces to build our Chasing agent.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们几乎已经拥有了构建追逐代理所需的所有组件。
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started to look at our in-depth example of how to create
    a ***Behavior Tree***, and have used all of the systems we have encountered so
    far.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们开始深入了解如何创建**行为树**的示例，并使用了迄今为止遇到的所有系统。
- en: In particular, we have seen how we can write down the ***Expected Behavior***
    and work from there to gather all the different pieces that we need to build our
    AI. We have seen how we can do this in both C++ and Blueprint. The pieces we have
    created were a ***Custom Decorator***, to check *boolean* variables in our **Behavior
    Tree**,a**Custom Task**, to find a random location by using the **Navigation System**,
    and a **Custom AI Controller** so that we can use the **Perception System** to
    sense the **Player**.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是我们可以看到如何写下**预期行为**，并从这里开始收集构建我们的AI所需的所有不同组件。我们看到了如何在C++和蓝图中都这样做。我们创建的组件包括一个**自定义装饰器**，用于检查**行为树**中的**布尔**变量，一个**自定义任务**，通过使用**导航系统**来找到一个随机位置，以及一个**自定义AI控制器**，这样我们就可以使用**感知系统**来感知**玩家**。
- en: In the next chapter, we will continue with this example and build the last piece
    we need so that we can update the variables for the Chasing Behavior. At the end
    of the next chapter, you will be ready to build the Behavior Tree. So, let's move
    on!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续这个示例，并构建我们需要的最后一个组件，以便我们可以更新追逐行为的变量。在下一章的结尾，你将准备好构建行为树。所以，让我们继续前进！
