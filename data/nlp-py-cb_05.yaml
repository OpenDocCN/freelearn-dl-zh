- en: POS Tagging and Grammars
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 词性标注和语法
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Exploring the in-built tagger
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索内置标注器
- en: Writing your own tagger
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自己的标注器
- en: Training your own tagger
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练自己的标注器
- en: Learning to write your own grammar
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习编写自己的语法
- en: Writing a probabilistic context-free grammar--CFG
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写概率上下文无关语法（CFG）
- en: Writing a recursive CFG
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写递归CFG
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'This chapter primarily focuses on learning the following subjects using Python
    NLTK:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要聚焦于使用Python NLTK学习以下内容：
- en: Taggers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标注器
- en: CFG
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CFG
- en: 'Tagging is the process of classifying the words in a given sentence using **parts
    of speech** (**POS**). Software that helps achieve this is called **tagger**.
    NLTK has support for a variety of taggers. We will go through the following taggers
    as part of this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 标注是使用**词性**（**POS**）对给定句子中的单词进行分类的过程。帮助实现这一过程的软件称为**标注器**。NLTK支持多种标注器。我们将在本章中介绍以下标注器：
- en: In-built tagger
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置标注器
- en: Default tagger
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认标注器
- en: Regular expression tagger
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式标注器
- en: Lookup tagger
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找标注器
- en: CFG describes a set of rules that can be applied to text in a formal language
    specification to generate newer sets of text.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: CFG描述了一组规则，可以在正式语言规范中应用于文本，以生成新的文本集。
- en: 'CFG in a language comprises the following things:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 语言中的CFG包含以下内容：
- en: Starting token
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动标记
- en: A set of tokens that are terminals (ending symbols)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组终结符（结束符号）的标记
- en: A set of tokens that are non-terminals (non-ending symbols)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组非终结符（非结束符号）的标记
- en: Rules or productions that define rewrite rules that help transform non-terminals
    to either terminals or non-terminals
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义重写规则的规则或产生式，帮助将非终结符转换为终结符或非终结符
- en: Exploring the in-built tagger
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索内置标注器
- en: In the following recipe, we use the Python NLTK library to understand more about
    the POS tagging features in a given text.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下实例中，我们使用Python NLTK库来了解给定文本中的词性标注功能。
- en: 'We will make use of the following technologies from the Python NLTK library:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Python NLTK库中的以下技术：
- en: Punkt English tokenizer
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Punkt英语分词器
- en: Averaged perception tagger
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均感知标注器
- en: The datasets for these taggers can be downloaded from your NLTK distribution
    by invoking `nltk.download()` from the Python prompt.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标注器的数据集可以通过在Python提示符下调用`nltk.download()`从你的NLTK分发包中下载。
- en: Getting ready
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have a working Python (Python 3.6 is preferred) installed in your
    system along with the NLTK library and all its collections for optimal experience.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在系统中安装工作中的Python（推荐Python 3.6），并配备NLTK库及其所有集合，以获得最佳体验。
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open atom editor (or favorite programming editor).
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开atom编辑器（或喜欢的编程编辑器）。
- en: Create a new file called `Exploring.py`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Exploring.py`的新文件。
- en: 'Type the following source code:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下源代码：
- en: '![](img/60ff55a2-66f9-42da-8a22-035a143c1dc6.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60ff55a2-66f9-42da-8a22-035a143c1dc6.png)'
- en: Save the file.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Run the program using the Python interpreter.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Python解释器运行程序。
- en: 'You will see the following output:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '![](img/06bf1f75-3720-4b26-925b-fb807cebef24.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06bf1f75-3720-4b26-925b-fb807cebef24.png)'
- en: How it works...
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Now, let''s go through the program that we have just written and dig into the
    details:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下我们刚刚编写的程序，并深入了解细节：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is the first instruction in our program, which instructs the Python interpreter
    to load the module from disk to memory and make the NLTK library available for
    use in the program:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们程序中的第一条指令，它指示Python解释器从磁盘加载模块到内存，并使得NLTK库在程序中可用：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this instruction, we are creating a variable called `simpleSentence` and
    assigning a hard coded string to it:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本指令中，我们创建了一个名为`simpleSentence`的变量，并为其分配了一个硬编码的字符串：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this instruction, we are invoking the NLTK built-in tokenizer function `word_tokenize()`;
    it breaks a given sentence into words and returns a Python `list` datatype. Once
    the result is computed by the function, we assign it to a variable called `wordsInSentence` using
    the `=` (equal to) operator:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本指令中，我们调用了NLTK的内置分词函数`word_tokenize()`；它将给定句子分解为单词，并返回一个Python `list`数据类型。一旦函数计算完结果，我们使用`=`（等号）操作符将结果赋值给一个名为`wordsInSentence`的变量：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this instruction, we are calling the Python built-in `print()` function,
    which displays the given data structure on the screen. In our case, we are displaying
    the list of all words that are tokenized. See the output carefully; we are displaying
    a Python `list` data structure on screen, which consists of all the strings separated
    by commas, and all the list elements are enclosed in square brackets:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这条指令中，我们调用了 Python 内置的`print()`函数，它会将给定的数据结构显示在屏幕上。在我们的例子中，我们显示了所有分词后的单词列表。仔细观察输出；我们正在屏幕上显示一个
    Python `list` 数据结构，它由用逗号分隔的所有字符串组成，所有列表元素都被方括号括起来：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this instruction we are invoking the NLTK built-in tagger `pos_tag()`, which
    takes a list of words in the `wordsInSentence` variable and identifies the POS.
    Once the identification is complete, a list of tuples. Each tuple has the tokenized
    word and the POS identifier:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这条指令中，我们调用了 NLTK 内置的标注器`pos_tag()`，它接受`wordsInSentence`变量中的单词列表并识别词性。一旦识别完成，将返回一个元组列表，每个元组包含分词后的单词和词性标识符：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this instruction, we are invoking the Python built-in `print()` function,
    which prints the given parameter to the screen. In our case, we can see a list
    of tuples, where each tuple consists of the original word and POS identifier.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这条指令中，我们调用了 Python 内置的`print()`函数，它将给定的参数打印到屏幕上。在我们的例子中，我们可以看到一个元组列表，每个元组包含原始单词和词性标识符。
- en: Writing your own tagger
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写你自己的标注器
- en: 'In the following recipe, we will explore the NLTK library by writing our own
    taggers. The following types of taggers will be written:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们将通过编写自己的标注器来探索 NLTK 库。我们将编写以下类型的标注器：
- en: Default tagger
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认标注器
- en: Regular expression tagger
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式标注器
- en: Lookup tagger
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找标注器
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正在准备
- en: You should have a working Python (Python 3.6 is preferred) installed in your
    system along with the NLTK library and all its collections for optimal experience.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在系统中安装一个工作中的 Python（推荐 Python 3.6），以及 NLTK 库及其所有集合，以获得最佳体验。
- en: You should also have `python-crfsuite` installed to run this recipe.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该安装`python-crfsuite`以运行这个示例。
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open your atom editor (or favorite programming editor).
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的 Atom 编辑器（或你喜欢的编程编辑器）。
- en: Create a new file called `OwnTagger.py`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`OwnTagger.py`的新文件。
- en: 'Type the following source code:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下源代码：
- en: '![](img/7ead53b2-d77f-44e1-b0d6-50863789a0ba.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ead53b2-d77f-44e1-b0d6-50863789a0ba.png)'
- en: Save the File.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Run the program using the Python interpreter.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Python 解释器运行程序。
- en: You will see the following output.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到以下输出。
- en: '![](img/eb492d87-304b-4d3e-ad8b-4587cb0af1ed.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb492d87-304b-4d3e-ad8b-4587cb0af1ed.png)'
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Now, let''s go through the program that we have just written to understand
    more:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下我们刚刚写的程序，深入理解：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is the first instruction in our program; it instructs the Python interpreter
    to load the module from disk to memory and make the NLTK library available for
    use in the program:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们程序中的第一条指令；它指示 Python 解释器将模块从磁盘加载到内存中，并使 NLTK 库在程序中可用：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'All of these instructions are defining a new Python function that takes a string
    as input and prints the words in this sentence along with the default tag on screen.
    Let''s further understand this function to see what it''s trying to do:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些指令都在定义一个新的 Python 函数，它接受一个字符串作为输入并在屏幕上打印该句子中的单词以及默认标注。我们进一步理解这个函数，看看它在做什么：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this instruction, we are defining a new Python function called `learnDefaultTagger`;
    it takes a parameter named `simpleSentence`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这条指令中，我们定义了一个新的 Python 函数，名为`learnDefaultTagger`；它接受一个名为`simpleSentence`的参数：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this instruction, we are calling the `word_tokenize` function from the NLTK
    library. We are passing `simpleSentence` as the first parameter to this function.
    Once the data is computed by this function, the return value is stored in the
    `wordsInSentence` variable. Which are list of words:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这条指令中，我们从 NLTK 库中调用了`word_tokenize`函数。我们将`simpleSentence`作为第一个参数传递给这个函数。当数据被该函数处理后，返回值将存储在`wordsInSentence`变量中。它是一个包含单词的列表：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this instruction, we are creating an object of the `DefaultTagger()` class
    from the Python `nltk` library with `NN` as the argument passed to it. This will
    initialize the tagger and assign the instance to the `tagger` variable:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这条指令中，我们创建了一个`DefaultTagger()`类的对象，该类来自 Python `nltk` 库，并将`NN`作为参数传递给它。这将初始化标注器并将实例分配给`tagger`变量：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this instruction, we are calling the `tag()` function of the `tagger` object,
    which takes the tokenized words from the `wordsInSentence` variable and returns
    the list of tagged words. This is saved in `posEnabledTags`. Remember that all
    the words in the sentence will be tagged as `NN` as that''s what the tagger is
    supposed to do. This is like a very basic level of tagging without knowing anything
    about POS:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本说明中，我们正在调用`tag()`函数，它属于`tagger`对象，该函数接受来自`wordsInSentence`变量的分词，并返回标记化单词的列表。该列表保存在`posEnabledTags`中。请记住，句子中的所有单词都将被标记为`NN`，因为这是标记器应该做的。这就像一个非常基础的标注，甚至没有涉及词性（POS）：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we are calling Python's built-in `print()` function to inspect the contents
    of the `posEnabledTags` variable. We can see that all the words in the sentence
    will be tagged with `NN:`
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用了Python内置的`print()`函数来检查`posEnabledTags`变量的内容。我们可以看到，句子中的所有单词都会被标记为`NN:`。
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These are the instructions to create a new function called `learnRETagger()`,
    which takes a string as input and prints the list of all tokens in the string
    with properly identified tags using the regular expression tagger as output.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是创建一个新函数`learnRETagger()`的指令，该函数接受一个字符串作为输入，并使用正则表达式标注器输出正确标记的所有令牌列表。
- en: 'Let''s try to understand one instruction at a time:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着一次理解一条指令：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are defining a new Python function named `*learnRETagger*` to take a parameter
    called *`simpleSentence`.*
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在定义一个名为`*learnRETagger*`的Python函数，该函数接受一个名为*`simpleSentence`*的参数。
- en: 'In order to understand the next instruction, we should learn more about Python
    lists, tuples, and regular expressions:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解下一条指令，我们需要学习更多关于Python列表、元组和正则表达式的知识：
- en: A Python list is a data structure that is an ordered set of elements
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python列表是一种数据结构，是一组有序的元素
- en: A Python tuple is a immutable (read-only) data structure that is an ordered
    set of elements
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python元组是一种不可变（只读）数据结构，是一组有序的元素
- en: 'Python regular expressions are strings that begin with the letter `r` and follow
    the standard PCRE notation:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python正则表达式是以字母`r`开头的字符串，并遵循标准的PCRE符号：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Even though this looks big, this is a single instruction that does many things:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这看起来很大，这其实是一个单一的指令，它做了很多事情：
- en: Creating a variable called `customPatterns`
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`customPatterns`的变量
- en: Defining a new Python list datatype with `[`
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`[`定义一个新的Python列表数据类型
- en: Adding eight elements to this list
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向此列表添加八个元素
- en: Each element in this list is a tuple that has two items in it
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该列表中的每个元素是一个元组，元组中有两个元素
- en: The first item in the tuple is a regular expression
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组中的第一项是一个正则表达式
- en: The second item in the tuple is a string
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组中的第二项是一个字符串
- en: Now, translating the preceding instruction into a human-readable form, we have
    added eight regular expressions to tag the words in a sentence to be any of `ADJECTIVE`,
    `ADVERB`, `NOUN`, `VERB`, `INDEFINITE-ARTICLE`, `PREPOSITION`, `NUMBER`, or `None`
    type.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将前面的指令翻译成易于理解的形式，我们添加了八个正则表达式来标记句子中的单词，标记类型包括`ADJECTIVE`、`ADVERB`、`NOUN`、`VERB`、`INDEFINITE-ARTICLE`、`PREPOSITION`、`NUMBER`或`None`类型。
- en: We do this by identifying certain patterns in English words identifiable as
    a given POS.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过识别英语单词中的某些模式，来识别它们属于某个特定的词性（POS）。
- en: 'In the preceding example, these are the clues we are using to tag the POS of
    English words:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，这些是我们用来标记英语单词词性的线索：
- en: Words that end with `ing` can be called `ADJECTIVE`, for example, `running`
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`ing`结尾的单词可以标记为`ADJECTIVE`，例如`running`
- en: Words that end with `ly` can be called `ADVERB`, for example, `willingly`
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`ly`结尾的单词可以标记为`ADVERB`，例如`willingly`
- en: Words that end with `ion` can be called `NOUN`, for example, `intimation`
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`ion`结尾的单词可以标记为`NOUN`，例如`intimation`
- en: Words that end with `ate` or `en` can be called `VERB`, for example, `terminate`,
    `darken`, or `lighten`
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`ate`或`en`结尾的单词可以标记为`VERB`，例如`terminate`、`darken`或`lighten`
- en: Words that end with `an` can be called `INDEFINITE-ARTICLE`
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`an`结尾的单词可以标记为`INDEFINITE-ARTICLE`
- en: Words such as `with`, `on`, or `at` are `PREPOSITION`
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像`with`、`on`、`at`这样的单词是`PREPOSITION`
- en: Words that are like, `-123.0`, `984` can be called `NUMBER`
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像`-123.0`、`984`这样的单词可以标记为`NUMBER`
- en: We are tagging everything else as `None`, which is a built-in Python datatype
    used to represent nothing
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将其他所有单词标记为`None`，`None`是Python内置的数据类型，用于表示“无”。
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this instruction, we are creating an instance of the NLTK built-in regular
    expression tagger `RegexpTagger`. We are passing the list of tuples in the `customPatterns`
    variable as the first parameter to the class to initialize the object. This object
    can be referenced in future with the variable named `tagger`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这条指令中，我们创建了一个NLTK内置正则表达式标注器`RegexpTagger`的实例。我们将`customPatterns`变量中的元组列表作为第一个参数传递给类，以初始化对象。这个对象可以在未来通过名为`tagger`的变量引用：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Following the general process, we first try to tokenize the string in `simpleSentence`
    using the NLTK built-in `word_tokenize()` function and store the list of tokens
    in the `wordsInSentence` variable:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 按照常规流程，我们首先尝试使用NLTK内置的`word_tokenize()`函数对`simpleSentence`中的字符串进行分词，并将标记列表存储在`wordsInSentence`变量中：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we are invoking the regular expression tagger''s `tag()` function to tag
    all the words that are in the `wordsInSentence` variable. The result of this tagging
    process is stored in the `posEnabledTags` variable:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们调用常规表达式标注器的`tag()`函数，对`wordsInSentence`变量中的所有单词进行标注。这个标注过程的结果存储在`posEnabledTags`变量中：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We are calling the Python built-in `print()` function to display the contents
    of the `posEnabledTags` data structure on screen:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用了Python内置的`print()`函数，在屏幕上显示`posEnabledTags`数据结构的内容：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s take a closer look:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看一下：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We are defining a new function, `learnLookupTagger`, which takes a string as
    parameter into the `simpleSentence` variable:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个新函数`learnLookupTagger`，它接受一个字符串作为参数并存入`simpleSentence`变量：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this instruction, we are calling `UnigramTagger` from the `nltk` library.
    This is a lookup tagger that takes the Python dictionary we have created and assigned
    to the `mapping` variable. Once the object is created, it''s available in the
    `tagger` variable for future use:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这条指令中，我们从`nltk`库中调用了`UnigramTagger`。这是一种查找标注器，它接受我们创建并赋值给`mapping`变量的Python字典。一旦对象创建完成，它将存储在`tagger`变量中，供以后使用：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we are tokenizing the sentence using the NLTK built-in `word_tokenize()`
    function and capturing the result in the `wordsInSentence` variable:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用NLTK内置的`word_tokenize()`函数对句子进行分词，并将结果保存在`wordsInSentence`变量中：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once the sentence is tokenized, we call the `tag()` function of the tagger
    by passing the list of tokens in the `wordsInSentence` variable. The result of
    this computation is assigned to the `posEnabledTags` variable:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦句子被分词，我们通过传入`wordsInSentence`变量中的标记列表来调用标注器的`tag()`函数。这个计算的结果被赋值给`posEnabledTags`变量：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this instruction, we are printing the data structure in `posEnabledTags` on
    the screen for further inspection:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这条指令中，我们将在屏幕上打印`posEnabledTags`中的数据结构，便于进一步检查：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We are creating a variable called `testSentence` and assigning a simple English
    sentence to it:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`testSentence`的变量，并将一个简单的英文句子赋给它：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We call the `learnDefaultTagger` function created in this recipe by passing
    the `testSentence` as the first argument to it. Once this function execution completes,
    we will see the sentence POS tagged:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用了在本教程中创建的`learnDefaultTagger`函数，传入`testSentence`作为第一个参数。该函数执行完成后，我们将看到句子的词性标注结果：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this expression, we are invoking the `learnRETagger()` function with the
    same test sentence in the `testSentence` variable. The output from this function
    is a list of tags that are tagged as per the regular expressions that we have
    defined ourselves:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表达式中，我们调用了`learnRETagger()`函数，传入了相同的测试句子`testSentence`变量。这个函数的输出是根据我们自己定义的正则表达式标记的标签列表：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The output from this function `learnLookupTagger` is list of all tags from the
    sentence `testSentence` that are tagged using the lookup dictionary that we have
    created.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数`learnLookupTagger`的输出是从句子`testSentence`中提取的所有标签，这些标签是通过我们创建的查找字典进行标记的。
- en: Training your own tagger
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练你自己的标注器
- en: In this recipe, we will learn how to train our own tagger and save the trained
    model to disk so that we can use it later for further computations.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习如何训练我们自己的标注器并将训练好的模型保存到磁盘，以便以后用于进一步的计算。
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have a working Python (Python 3.6 is preferred) installed in your
    system, along with the NLTK library and all its collections for optimal experience.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在系统中安装了一个可用的Python（推荐Python 3.6）版本，并且安装了NLTK库及其所有集合，以便获得最佳体验。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Open your atom editor (or favorite programming editor).
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的Atom编辑器（或你喜欢的编程编辑器）。
- en: Create a new file called `Train3.py`.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件，命名为`Train3.py`。
- en: 'Type the following source code:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下源代码：
- en: '![](img/7fdeb930-8718-49f3-af6e-f3b66f77beee.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fdeb930-8718-49f3-af6e-f3b66f77beee.png)'
- en: Save the file.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Run the program using the Python interpreter.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Python 解释器运行程序。
- en: 'You will see the following output:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '![](img/e2cf88f7-b8f8-4e8e-b538-ca05208ac5f3.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2cf88f7-b8f8-4e8e-b538-ca05208ac5f3.png)'
- en: How it works...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s understand how the program works:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解程序是如何工作的：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In these two instructions, we are loading the `nltk` and `pickle` modules into
    the program. The `pickle` module implements powerful serialization and de-serialization
    algorithms to handle very complex Python objects:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两条指令中，我们将`nltk`和`pickle`模块加载到程序中。`pickle`模块实现了强大的序列化和反序列化算法，用于处理非常复杂的 Python
    对象：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In these instructions, we are defining a function called `sampleData()` that
    returns a Python list. Basically, we are returning four sample strings:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些指令中，我们定义了一个名为`sampleData()`的函数，它返回一个 Python 列表。基本上，我们返回了四个样本字符串：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We now define a function called `buildDictionary()`; it reads one string at
    a time from the list generated by the `sampleData()` function. Each string is
    tokenized using the `nltk.word_tokenize()` function. The resultant tokens are
    added to a Python dictionary, where the dictionary key is the word in the sentence
    and the value is POS. Once a dictionary is computed, it''s returned to the caller:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们定义了一个名为`buildDictionary()`的函数；它一次从`sampleData()`函数生成的列表中读取一个字符串。每个字符串都使用`nltk.word_tokenize()`函数进行分词。结果的标记被添加到一个
    Python 字典中，其中字典的键是句子中的单词，值是词性。计算完字典后，它会返回给调用者：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In these instructions, we are defining a function called `saveMyTagger()` that
    takes two parameters:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些说明中，我们定义了一个名为`saveMyTagger()`的函数，该函数接受两个参数：
- en: '`tagger`: An object to the POS tagger'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tagger`：一个指向词性标注器的对象'
- en: '`fileName`: This contains the name of the file to store the `tagger` object
    in'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileName`：这是包含要存储`tagger`对象的文件名'
- en: 'We first open the file in **write binary** (**wb**) mode. Then, using `pickle`
    module''s `dump()` method, we store the entire tagger in the file and call the
    `close()` function on `fileHandle`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先以**写入二进制**（**wb**）模式打开文件。然后，使用`pickle`模块的`dump()`方法，将整个tagger存储到文件中，并调用`fileHandle`的`close()`函数：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In these instructions, we are defining a new function called `saveMyTraining`;
    it takes a single argument called `fileName`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些指令中，我们定义了一个名为`saveMyTraining`的新函数；它接受一个名为`fileName`的参数。
- en: 'We are building an `nltk.UnigramTagger()` object with the model as output from
    the `buildDictionary()` function (which itself is built from the sample set of
    strings that we have defined). Once the `tagger` object is created, we call the
    `saveMyTagger()` function to save it to disk:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建一个`nltk.UnigramTagger()`对象，其模型输出来自`buildDictionary()`函数（该函数本身是通过我们定义的字符串样本集构建的）。一旦创建了`tagger`对象，我们调用`saveMyTagger()`函数将其保存到磁盘：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, we are defining a new function, `loadMyTagger()`, which takes `fileName`
    as a single argument. This function reads the file from disk and passes it to
    the `pickle.load()` function which unserializes the tagger from disk and returns
    a reference to it:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个新的函数`loadMyTagger()`，它以`fileName`作为唯一参数。该函数从磁盘读取文件，并将其传递给`pickle.load()`函数，该函数将从磁盘反序列化tagger并返回对它的引用：
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In these two instructions, we are defining two variables, `sentence` and `fileName`,
    which contain a sample string that we want to analyze and the file path at which
    we want to store the POS tagger respectively:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两条指令中，我们定义了两个变量，`sentence`和`fileName`，分别包含我们想要分析的样本字符串和我们希望存储词性标注器的文件路径：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This is the instruction that actually calls the function `saveMyTraining()`
    with `myTagger.pickle` as argument. So, we are basically storing the trained tagger
    in this file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令实际上调用了`saveMyTraining()`函数，并以`myTagger.pickle`作为参数。因此，我们基本上是在这个文件中存储训练好的tagger：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this instruction, we take the `myTagger.pickle` as argument of the `loadMyTagger()`
    function, which loads the tagger from disk, deserializes it, and creates an object,
    which further gets assigned to the `myTagger` variable:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这条指令中，我们将`myTagger.pickle`作为参数传递给`loadMyTagger()`函数，它从磁盘加载tagger，进行反序列化，并创建一个对象，然后将该对象分配给`myTagger`变量：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this instruction, we are calling the `tag()` function of the tagger that
    we have just loaded from disk. We use it to tokenize the sample string that we
    have created.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这条指令中，我们调用了刚刚从磁盘加载的tagger的`tag()`函数。我们用它来分词我们创建的样本字符串。
- en: Once the processing is done, the output is displayed on the screen.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完成后，输出会显示在屏幕上。
- en: Learning to write your own grammar
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习编写你自己的语法
- en: 'In automata theory, CFG consists of the following things:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动机理论中，CFG 由以下几个部分组成：
- en: A starting symbol/ token
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个起始符号/符号
- en: A set of symbols/ tokens that are terminals
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组符号/符号集，表示终结符
- en: A set of symbols/ tokens that are non-terminals
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组符号/符号集，表示非终结符
- en: A rule (or production) that defines the start symbol/token and the possible
    end symbols/tokens
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义起始符号/符号以及可能的结束符号/符号的规则（或产生式）
- en: The symbol/token can be anything that is specific to the language that we consider.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 符号/符号可以是任何特定于我们考虑的语言的元素。
- en: 'For example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: In the case of the English language, *a, b, c, d, e, f, g, h, i, j, k, l, m,
    n, o, p, q, r, s, t, u, v, w, x, y, z* are symbols/tokens/alphabets.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在英语语言中，*a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w,
    x, y, z* 是符号/符号/字母。
- en: In the case of the decimal numbering system *0, 1, 2, 3, 4, 5, 6, 7, 8, 9 *are
    symbols/tokens/alphabets.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在十进制计数系统中，*0, 1, 2, 3, 4, 5, 6, 7, 8, 9* 是符号/符号/字母。
- en: Generally, rules (or productions) are written in **Backus-Naur form** (**BNF**)
    notation.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，规则（或产生式）采用 **巴科斯-诺尔范式**（**BNF**）表示法编写。
- en: Getting ready
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You should have a working Python (Python 3.6 is preferred) installed on your
    system, along with the NLTK library.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在系统上安装一个可工作的 Python（推荐 Python 3.6），并且安装 NLTK 库。
- en: How to do it...
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open your atom editor (or your favorite programming editor).
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的 atom 编辑器（或你喜欢的编程编辑器）。
- en: Create a new file called `Grammar.py`.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件，命名为 `Grammar.py`。
- en: 'Type the following source code:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下源代码：
- en: '![](img/46df3271-f331-4d11-b97e-60d2883bbf79.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46df3271-f331-4d11-b97e-60d2883bbf79.png)'
- en: Save the file.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Run the program using the Python interpreter.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Python 解释器运行该程序。
- en: 'You will see the following output:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '![](img/a1901496-60f9-4ce1-99b9-19fa547116b2.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1901496-60f9-4ce1-99b9-19fa547116b2.png)'
- en: How it works...
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Now, let''s go through the program that we have just written and dig into the
    details:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下我们刚刚编写的程序，并深入了解细节：
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We are importing the `nltk` library into the current program:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `nltk` 库导入到当前程序中：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This instruction imports the `string` module into the current program:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令将 `string` 模块导入到当前程序中：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This instruction imports the `generate` function from the `nltk.parse.generate`
    module, which helps in generating strings from the CFG that we are going to create:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令从 `nltk.parse.generate` 模块导入 `generate` 函数，帮助从我们将要创建的 CFG 中生成字符串：
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We are defining a new grammar here. The grammar can contain the following production
    rules:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里定义了一个新的语法。该语法可以包含以下产生规则：
- en: The starting symbol is `ROOT`
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 起始符号是 `ROOT`
- en: The `ROOT` symbol can produce `WORD` symbol
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROOT` 符号可以生成 `WORD` 符号'
- en: The `WORD` symbol can produce `' '` (empty space); this is a dead end production
    rule
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORD` 符号可以生成 `'' ''`（空格）；这是一个死循环产生规则'
- en: The `WORD` symbol can produce `NUMBER` symbol followed by `LETTER` symbol
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORD` 符号可以生成 `NUMBER` 符号后跟 `LETTER` 符号'
- en: The `WORD` symbol can produce `LETTER` symbol followed by `NUMBER` symbol
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORD` 符号可以生成 `LETTER` 符号后跟 `NUMBER` 符号'
- en: These instructions further extend the production rules.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令进一步扩展了产生规则。
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`NUMBER` can produce terminal alphabets `0`, `1`, `2`, or `3`:'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NUMBER` 可以生成终结符字母 `0`、`1`、`2` 或 `3`：'
- en: These instructions further extend the production rules.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令进一步扩展了产生规则。
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`LETTER` can produce lowercase alphabets `a`, `b`, `c`, or `d`.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LETTER` 可以生成小写字母 `a`、`b`、`c` 或 `d`。'
- en: Let's try to understand what this grammar is for. This grammar represents the
    language wherein there are words such as `0a`, `1a`, `2a`, `a1`, `a3`, and so
    on.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试理解这条语法的用途。该语法表示包含诸如 `0a`、`1a`、`2a`、`a1`、`a3` 等单词的语言。
- en: 'All the production rules that we have stored so far in the list variable called `productions` are
    converted to a string:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在名为 `productions` 的列表变量中存储的所有产生规则都已转换为字符串：
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We are creating a new grammar object using the `nltk.CFG.fromstring()` method,
    which takes the `grammarString` variable that we have just created:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用 `nltk.CFG.fromstring()` 方法创建一个新的语法对象，该方法采用我们刚刚创建的 `grammarString` 变量：
- en: '[PRE47]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'These instructions print the first five auto generated words that are present
    in this language, which is defined with the grammar:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令打印出该语言中自动生成的前五个单词，这些单词是根据定义的语法生成的：
- en: '[PRE48]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Writing a probabilistic CFG
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个概率上下文无关文法
- en: Probabilistic CFG is a special type of CFG in which the sum of all the probabilities
    for the non-terminal tokens (left-hand side) should be equal to one.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 概率上下文无关文法（Probabilistic CFG）是一种特殊类型的上下文无关文法，其中所有非终结符号（左侧）的概率之和应该等于 1。
- en: Let's write a simple example to understand more.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个简单的示例以便更好地理解。
- en: Getting ready
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have a working Python (Python 3.6 is preferred) installed on your
    system, along with the NLTK library.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在系统上安装一个有效的 Python 环境（推荐 Python 3.6），并且需要安装 NLTK 库。
- en: How to do it...
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open your atom editor (or your favorite programming editor).
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的 Atom 编辑器（或你喜欢的编程编辑器）。
- en: Create a new file called `PCFG.py`.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `PCFG.py` 的新文件。
- en: 'Type the following source code:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下源代码：
- en: '![](img/4e881933-b935-4459-8f08-a303c6d7e4a0.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e881933-b935-4459-8f08-a303c6d7e4a0.png)'
- en: Save the file.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Run the program using the Python interpreter.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Python 解释器运行程序。
- en: 'You will see the following output:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '![](img/1720a2bb-4c3f-4c2b-9eb7-73164094b88d.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1720a2bb-4c3f-4c2b-9eb7-73164094b88d.png)'
- en: How it works...
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Now, let''s go through the program that we have just written and dig into the
    details:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细看看我们刚刚编写的程序：
- en: '[PRE49]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This instruction imports the `nltk` module into our program:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令将 `nltk` 模块导入到我们的程序中：
- en: '[PRE50]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This instruction imports the `generate` function from the `nltk.parse.genearate`
    module:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令从 `nltk.parse.generate` 模块导入 `generate` 函数：
- en: '[PRE51]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here, we are defining the grammar for our language, which goes like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在定义我们语言的语法，格式如下：
- en: '| **Description** | **Content** |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | **内容** |'
- en: '| Starting symbol | `ROOT` |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| 起始符号 | `ROOT` |'
- en: '| Non-terminals | `WORD`, `P1`, `P2`, `P3`, `P4` |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 非终结符 | `WORD`, `P1`, `P2`, `P3`, `P4` |'
- en: '| Terminals | `''A''`, `''B''`, `''C''`, `''D''`, `''E''`, `''F''`, `''G''`,
    `''H''` |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| 终结符 | `''A''`, `''B''`, `''C''`, `''D''`, `''E''`, `''F''`, `''G''`, `''H''`
    |'
- en: 'Once we have identified the tokens in the grammar, let''s see what the production
    rules look like:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们识别出语法中的符号，就来看一下产生规则是什么样子的：
- en: There is a `ROOT` symbol, which is the starting symbol for this grammar
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个 `ROOT` 符号，它是此语法的起始符号
- en: There is a `WORD` symbol that has a probability of `1.0`
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个 `WORD` 符号，其概率为 `1.0`
- en: There is a `WORD` symbol that can produce `P1` with a probability of `0.25`
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个 `WORD` 符号，它可以以 `0.25` 的概率生成 `P1`
- en: There is a `WORD` symbol that can produce `P1 P2` with a probability of `0.25`
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个 `WORD` 符号，它可以以 `0.25` 的概率生成 `P1 P2`
- en: There is a `WORD` symbol that can produce `P1 P2 P3` with a probability of `0.25`
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个 `WORD` 符号，它可以以 `0.25` 的概率生成 `P1 P2 P3`
- en: There is a `WORD` symbol that can produce `P1 P2 P3 P4` with a probability of
    `0.25`
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个 `WORD` 符号，它可以以 `0.25` 的概率生成 `P1 P2 P3 P4`
- en: The `P1` symbol can produce symbol `'A'` with a `1.0` probability
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`P1` 符号可以以 `1.0` 的概率生成符号 `''A''`'
- en: The `P2` symbol can produce symbol `'B'` with a `0.5` probability
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`P2` 符号可以以 `0.5` 的概率生成符号 `''B''`'
- en: The `P2` symbol can produce symbol `'C'` with a `0.5` probability
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`P2` 符号可以以 `0.5` 的概率生成符号 `''C''`'
- en: The `P3` symbol can produce symbol `'D'` with a `0.3` probability
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`P3` 符号可以以 `0.3` 的概率生成符号 `''D''`'
- en: The `P3` symbol can produce symbol `'E'` with a `0.3` probability
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`P3` 符号可以以 `0.3` 的概率生成符号 `''E''`'
- en: The `P3` symbol can produce symbol `'F'` with a `0.4` probability
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`P3` 符号可以以 `0.4` 的概率生成符号 `''F''`'
- en: The `P4` symbol can produce symbol `'G'` with a `0.9` probability
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`P4` 符号可以以 `0.9` 的概率生成符号 `''G''`'
- en: The `P4` symbol can produce symbol `'H'` with a `0.1` probability
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`P4` 符号可以以 `0.1` 的概率生成符号 `''H''`'
- en: If you observe carefully, the sum of all the probabilities of the non-terminal
    symbols is equal to `1.0`. This is a mandatory requirement for the PCFG.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，所有非终结符符号的概率之和等于 `1.0`。这是 PCFG 的强制要求。
- en: 'We are joining the list of all the production rules into a string called the `grammarString` variable:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有生成规则的列表合并成一个字符串，称为 `grammarString` 变量：
- en: '[PRE52]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This instruction creates a `grammar` object using the `nltk.PCFG.fromstring` method
    and taking the `grammarString` as input:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令使用 `nltk.PCFG.fromstring` 方法创建一个 `grammar` 对象，并以 `grammarString` 作为输入：
- en: '[PRE53]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This instruction uses the Python built-in `print()` function to display the
    contents of the `grammar` object on screen. This will summarize the total number
    of tokens and production rules we have in the grammar that we have just created:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令使用 Python 内建的 `print()` 函数在屏幕上显示 `grammar` 对象的内容。这将总结我们刚刚创建的语法中所有符号和生成规则的总数：
- en: '[PRE54]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We are printing 10 strings from this grammar using the NLTK built-in function
    `generate` and then displaying them on screen:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 NLTK 内建的 `generate` 函数从这个语法中打印 10 个字符串，并将它们显示在屏幕上：
- en: '[PRE55]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Writing a recursive CFG
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写递归 CFG
- en: Recursive CFGs are a special types of CFG where the Tokens on the left-hand
    side are present on the right-hand side of a production rule.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 递归 CFG 是 CFG 的一种特殊类型，其中生产规则左侧的符号出现在右侧。
- en: Palindromes are the best examples of recursive CFG. We can always write a recursive
    CFG for palindromes in a given language.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 回文是递归 CFG 的最佳示例。我们总是可以为给定语言中的回文编写递归 CFG。
- en: 'To understand more, let''s consider a language system with alphabets 0 and
    1; so palindromes can be expressed as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，我们考虑一个只有字母 0 和 1 的语言系统；因此回文可以如下表示：
- en: '11'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '11'
- en: '1001'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1001'
- en: '010010'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '010010'
- en: No matter in whatever direction we read these alphabets (left to right or right
    to left), we always get the same value. This is the special feature of palindromes.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们从哪个方向读取这些字母（从左到右或从右到左），我们总是得到相同的值。这就是回文的特性。
- en: In this recipe, we will write grammar to represent these palindromes and generate
    a few palindromes using the NLTK built-in string generation libraries.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编写语法来表示这些回文，并使用 NLTK 内建的字符串生成库生成一些回文。
- en: Let's write a simple example to understand more.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个简单的例子来更好地理解。
- en: Getting ready
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备开始
- en: You should have a working Python (Python 3.6 is preferred) installed on your
    system, along with the NLTK library.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在系统上安装一个正常工作的 Python 环境（推荐使用 Python 3.6），并安装 NLTK 库。
- en: How to do it...
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open your atom editor (or your favorite programming editor).
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的 atom 编辑器（或你喜欢的编程编辑器）。
- en: Create a new file called `RecursiveCFG.py`.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `RecursiveCFG.py` 的新文件。
- en: 'Type the following source code:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下源代码：
- en: '![](img/7adccfc0-5c94-41b2-9caf-5a8695e28f15.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7adccfc0-5c94-41b2-9caf-5a8695e28f15.png)'
- en: Save the file.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Run the program using the Python interpreter.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Python 解释器运行程序。
- en: 'You will see the following output:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到如下输出：
- en: '![](img/3237ca32-26ba-44bc-81ff-305fa771527a.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3237ca32-26ba-44bc-81ff-305fa771527a.png)'
- en: How it works...
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Now, let''s go through the program that we have just written and dig into the
    details. We are importing the `nltk` library into our program for future use:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下刚才编写的程序并深入了解细节。我们正在将 `nltk` 库导入到我们的程序中，以便将来使用：
- en: '[PRE56]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We are also importing the `string` library into our program for future use:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将 `string` 库导入到我们的程序中，以便将来使用：
- en: '[PRE57]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We are importing the `generate` function from the `nltk.parse.generate` module:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在从 `nltk.parse.generate` 模块导入 `generate` 函数：
- en: '[PRE58]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We have created a new list data structure called `productions`, where there
    are two elements. Both the elements are strings that represent the two productions
    in our CFG:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `productions` 的新列表数据结构，其中有两个元素。两个元素都是表示我们 CFG 中两个生产规则的字符串：
- en: '[PRE59]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We are retrieving the list of decimal digits as a list in the `alphabets` variable:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将十进制数字列表作为 `alphabets` 变量中的列表进行检索：
- en: '[PRE60]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Using the digits 0 to 9, we add more productions to our list. These are the
    production rules that define palindromes:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数字 0 到 9，我们向列表中添加更多的生产规则。这些是定义回文的生产规则：
- en: '[PRE61]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Once all the rules are generated, we concatenate them as strings to a variable, `grammarString`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有规则都生成完毕，我们将它们作为字符串连接到一个变量 `grammarString` 中：
- en: '[PRE62]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In this instruction, we are creating a new `grammar` object by passing the
    newly constructed `grammarString` to the NLTK built-in `nltk.CFG.fromstring` function:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在此指令中，我们通过将新构建的 `grammarString` 传递给 NLTK 内建的 `nltk.CFG.fromstring` 函数来创建一个新的
    `grammar` 对象：
- en: '[PRE63]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In this instruction, we print the grammar that we have just created by calling
    the Python built-in `print()` function:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在此指令中，我们通过调用 Python 内建的 `print()` 函数打印出我们刚刚创建的语法：
- en: '[PRE64]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We are generating five palindromes using the `generate` function of the NLTK library
    and printing the same on the screen:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 NLTK 库的 `generate` 函数生成五个回文，并将其打印到屏幕上：
- en: '[PRE65]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
