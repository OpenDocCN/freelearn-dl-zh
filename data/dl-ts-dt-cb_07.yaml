- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Probabilistic Time Series Forecasting
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概率时间序列预测
- en: In the preceding chapters, we delved into time series problems from a point
    forecasting perspective. Point forecasting models predict a single value. However,
    forecasts are inherently uncertain, so it makes sense to quantify the uncertainty
    around a prediction. This is the goal of probabilistic forecasting, which can
    be a valuable approach for better-informed decision-making.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们从点预测的角度探讨了时间序列问题。点预测模型预测的是一个单一值。然而，预测本质上是充满不确定性的，因此量化预测的不确定性是有意义的。这就是概率预测的目标，它可以作为一种有价值的方法，帮助做出更明智的决策。
- en: In this chapter, we’ll focus on three types of probabilistic forecasting settings.
    We’ll delve into exceedance probability forecasting, which helps us estimate the
    likelihood of a time series surpassing a predefined threshold. We will also deal
    with prediction intervals, which provide a range of possible values within which
    a future observation is likely to fall. Finally, we will explore predicted probability
    forecasting, which offers a probabilistic assessment of individual outcomes, providing
    a fine-grained perspective of future possibilities.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点介绍三种类型的概率预测设置。我们将深入探讨超限概率预测，它帮助我们估计时间序列超过预定阈值的可能性。我们还将讨论预测区间，它提供一个可能值的范围，未来的观测值可能会落在该范围内。最后，我们将探讨预测概率预测，它提供了对单个结果的概率评估，从而为未来的可能性提供更细致的视角。
- en: 'This chapter covers the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下食谱：
- en: Introduction to exceedance probability forecasting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超限概率预测简介
- en: Exceedance probability forecasting with an LSTM
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 LSTM 进行超限概率预测
- en: Creating prediction intervals using conformal prediction
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用符合预测法创建预测区间
- en: Probabilistic forecasting with an LSTM
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 LSTM 进行概率预测
- en: Probabilistic forecasting with DeepAR
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 DeepAR 进行概率预测
- en: Introduction to Gaussian Processes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高斯过程简介
- en: Using Prophet for probabilistic forecasting
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Prophet 进行概率预测
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We’ll focus on the PyTorch ecosystem in this chapter. Here’s the full list
    of libraries that will be used in this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍 PyTorch 生态系统。以下是本章将使用的库的完整列表：
- en: NumPy (1.26.2)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy (1.26.2)
- en: pandas (2.1.3)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pandas (2.1.3)
- en: scikit-learn (1.3.2)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: scikit-learn (1.3.2)
- en: PyTorch Forecasting (1.0.0)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyTorch Forecasting (1.0.0)
- en: PyTorch Lightning (2.1.2)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyTorch Lightning (2.1.2)
- en: torch (2.1.1)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: torch (2.1.1)
- en: statsforecast (1.6.0)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: statsforecast (1.6.0)
- en: GluonTS (0.14.2)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GluonTS (0.14.2)
- en: gpytorch (1.11)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gpytorch (1.11)
- en: prophet (1.1.5)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: prophet (1.1.5)
- en: 'You can install these libraries using `pip`, Python’s package manager. For
    example, to install `scikit-learn`, you can run the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `pip`，Python 的包管理器，来安装这些库。例如，要安装 `scikit-learn`，你可以运行以下命令：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The code for this chapter can be found in this book’s GitHub repository: [https://github.com/PacktPublishing/Deep-Learning-for-Time-Series-Data-Cookbook](https://github.com/PacktPublishing/Deep-Learning-for-Time-Series-Data-Cookbook).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书的 GitHub 仓库中找到：[https://github.com/PacktPublishing/Deep-Learning-for-Time-Series-Data-Cookbook](https://github.com/PacktPublishing/Deep-Learning-for-Time-Series-Data-Cookbook)。
- en: Introduction to exceedance probability forecasting
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超限概率预测简介
- en: This recipe introduces exceedance probability forecasting problems. Exceedance
    events occur when a time series exceeds a predefined threshold in a predefined
    future period. This problem is relevant when the tails of the time series distribution
    can have a significant impact on the domain. For example, consider the case of
    the inflation rate in the economy. Central banks leverage this type of forecast
    to assess the possibility that the inflation rate will exceed some critical threshold,
    above which they might consider increasing interest rates.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱介绍了超限概率预测问题。超限事件发生在时间序列在预定的未来时期超过预定义的阈值。这类问题在时间序列分布的尾部可能对领域产生重大影响时尤为相关。例如，考虑到经济中的通货膨胀率。中央银行利用这种预测评估通货膨胀率可能超过某个临界阈值的可能性，如果超过该阈值，它们可能考虑提高利率。
- en: From a data science perspective, exceedance events are binary problems. Thus,
    it is common to tackle them using binary probabilistic classification models.
    One of the challenges is that the class representing the exceedance events is
    rare, which makes the learning task more difficult.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据科学的角度来看，超限事件是二分类问题。因此，通常使用二元概率分类模型来处理这些问题。一个挑战是，代表超限事件的类别是稀有的，这使得学习任务更加困难。
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We’ll use a multivariate time series as an example to describe what an exceedance
    probability task is and why they are relevant. Specifically, we’ll use the solar
    radiation dataset that was used in previous chapters (check, for example, the
    *Preparing a multivariate time series for supervised learning* recipe from [*Chapter
    4*](B21145_04.xhtml#_idTextAnchor259)).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个多变量时间序列作为示例，描述什么是超越概率任务，以及它们为什么重要。具体来说，我们将使用前几章中使用的太阳辐射数据集（例如，参见*为监督学习准备多变量时间序列*食谱，来自[*第
    4 章*](B21145_04.xhtml#_idTextAnchor259)）。
- en: 'Let’s start by loading the dataset using `pandas`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使用`pandas`加载数据集：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, let’s see how to define an exceedance problem using this time series.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用这个时间序列定义一个超越问题。
- en: How to do it…
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Exceedance probability forecasting is the process of predicting the probability
    that a time series will exceed a critical threshold in a future period. We’ll
    use a data module from PyTorch Lightning, which can be used to handle all the
    necessary steps for defining the task.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 超越概率预测是预测一个时间序列在未来某一时期超过某个临界阈值的概率的过程。我们将使用来自PyTorch Lightning的数据模块，它可以处理定义任务所需的所有步骤。
- en: 'The main component of this module is the `setup()` method. Most of the steps
    were already explained in the *Feedforward neural networks for multivariate time
    series forecasting* recipe. To create an exceedance task, we must start by defining
    the new binary target variable, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块的主要组件是`setup()`方法。大部分步骤已经在*多变量时间序列预测中的前馈神经网络*食谱中解释过了。为了创建超越任务，我们必须首先定义新的二元目标变量，具体如下：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, we use the `diff``()` method to compute how the solar
    radiation values change between consecutive observations. Then, we check whether
    the total daily solar radiation (in watts/m2) decreases by `2000` from one day
    to the next. This value was set arbitrarily. The intuition is that this should
    be a major event that we are interested in predicting. In this case study, such
    significant decreases in solar radiation mean that power systems will not be able
    to produce as much solar energy from photovoltaic devices. Therefore, predicting
    these events promptly allows power systems to generate energy from alternative
    sources efficiently.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用`diff()`方法计算连续观测中太阳辐射值的变化。然后，我们检查总日太阳辐射（单位：瓦特/平方米）是否在一天到第二天之间下降了`2000`。这个值是随意设定的。直觉上，这应该是我们感兴趣的重大事件。对于这个案例研究，太阳辐射的这种显著下降意味着电力系统将无法从光伏设备中产生大量太阳能。因此，及时预测这些事件可以使电力系统更加高效地从替代能源源中产生能源。
- en: 'Here’s a plot of the differenced series and the selected threshold:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是差分序列和所选阈值的图表：
- en: '![Figure 7.1: Difference in total daily solar radiation in consecutive observations](img/B21145_07_001.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1：连续观测中总日太阳辐射的差异](img/B21145_07_001.jpg)'
- en: 'Figure 7.1: Difference in total daily solar radiation in consecutive observations'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：连续观测中总日太阳辐射的差异
- en: 'Afterward, we pass this variable as the target variable in the `TimeSeriesDataSet`
    instance within the data module. Let’s start by loading the required libraries
    and building the constructor of the data modules:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将此变量作为目标变量传递给数据模块中的`TimeSeriesDataSet`实例。让我们首先加载所需的库并构建数据模块的构造函数：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the constructor, we store all the elements that are used during the data
    preprocessing stage. The `setup()` method of the class is implemented in the following
    code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们存储了数据预处理阶段中使用的所有元素。该类的`setup()`方法在以下代码中实现：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function works similarly to a standard auto-regressive pipeline. The crucial
    difference is that we’re setting the target variable to a binary variable that
    denotes whether there’s an exceedance event. We also set up the training, validation,
    and testing sets to build and evaluate the model. We set the number of lags to
    `14` (`max_encoder_length`) and the forecasting horizon to `7` (`max_prediction_length`).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的工作方式类似于标准的自回归管道。关键的不同之处在于，我们将目标变量设置为一个二元变量，表示是否发生了超越事件。我们还设置了训练、验证和测试集，用于构建和评估模型。我们将滞后数设置为`14`（`max_encoder_length`），预测时长设置为`7`（`max_prediction_length`）。
- en: 'The remaining methods of the `LightningDataModule` instance are similar to
    what we built in the previous chapter (for example, see the *Feedforward neural
    networks for multivariate time series* *forecasting* recipe):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`LightningDataModule`实例的其余方法与我们在上一章中构建的类似（例如，参见*多变量时间序列预测中的前馈神经网络*食谱）：'
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here’s how to get a single observation using this data module:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用该数据模块获取单个观测值：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we create an instance of `ExceedanceDataModule`, after
    which we use the `iter``()` and `next``()` methods to get observations from it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个`ExceedanceDataModule`的实例，随后使用`iter()`和`next()`方法从中获取观测值。
- en: How it works…
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Exceedance problems can also be tackled with an auto-regressive approach. So,
    we can predict the probability of an exceedance event based on the value of recent
    observations of the time series.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 超越问题也可以通过自回归方法来解决。因此，我们可以基于时间序列最近观测值的值来预测超越事件的概率。
- en: An exceedance probability forecasting problem is a particular type of binary
    classification task that can be defined using a time series where the events are
    defined by exceedance. Yet, other types of events can be defined that are not
    necessarily based on exceedance events, and a probabilistic model can be built
    accordingly. The required logic is all set in the `setup()` method, which encapsulates
    all the preprocessing steps.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 超越概率预测问题是一种特定类型的二分类任务，可以使用时间序列来定义，其中事件是由超越定义的。然而，也可以定义其他类型的事件，这些事件不一定基于超越事件，可以据此构建概率模型。所需的逻辑都设置在`setup()`方法中，该方法封装了所有的预处理步骤。
- en: There’s more…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: In this recipe, we used a single multivariate time series to describe exceedance
    tasks. Yet, we remark that our approach can be defined trivially for datasets
    involving multiple time series using the data module framework.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们使用单一的多变量时间序列来描述超越任务。然而，我们强调，我们的方法可以通过数据模块框架轻松地为涉及多个时间序列的数据集定义。
- en: There is a related problem to exceedance probability forecasting tasks called
    **time series classification**, in which a given time series has an associated
    label. We’ll learn about this problem in the next chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与超越概率预测任务相关的一个问题是**时间序列分类**，其中给定的时间序列有一个关联标签。我们将在下一章中学习这个问题。
- en: Exceedance probability forecasting with an LSTM
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LSTM进行超越概率预测
- en: This recipe describes creating a probabilistic deep learning model to tackle
    exceedance tasks with a multivariate time series.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例描述了如何创建一个概率深度学习模型，通过多变量时间序列解决超越任务。
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We’ll continue our example with the solar radiation dataset. Here’s the data
    module that we defined in the previous recipe:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用太阳辐射数据集作为示例。以下是我们在之前的示例中定义的数据模块：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, let’s see how to create a classifier using an LSTM neural network and PyTorch’s
    `LightningModule`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用LSTM神经网络和PyTorch的`LightningModule`创建一个分类器。
- en: How to do it…
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We will set up a binary classification using PyTorch Lightning’s `LightningModule`.
    Here’s the constructor and the `forward()` method:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用PyTorch Lightning的`LightningModule`来设置一个二分类任务。以下是构造函数和`forward()`方法：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The LSTM architecture is similar to what we learned about in [*Chapter 4*](B21145_04.xhtml#_idTextAnchor259)
    – we create an LSTM layer based on PyTorch and set up its configuration regarding
    the number of layers, number of units, and input dimension (number of time series
    variables). During the forward pass, the output of the LSTM layer is passed onto
    a linear layer. In the previous recipes involving predicting the numeric value
    of future observations, this would be the final layer of the network. Yet, for
    classification, we add a sigmoid layer (`torch.sigmoid`), which transforms the
    model’s output into a value between `0` and `1`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: LSTM架构与我们在[*第4章*](B21145_04.xhtml#_idTextAnchor259)中学习的类似——我们基于PyTorch创建一个LSTM层，并设置关于层数、单元数和输入维度（时间序列变量的数量）的配置。在前向传播过程中，LSTM层的输出会传递给一个线性层。在之前涉及预测未来观测值数值的示例中，这将是网络的最后一层。然而，对于分类任务，我们添加了一个sigmoid层（`torch.sigmoid`），它将模型的输出转换为介于`0`和`1`之间的值。
- en: 'The training and validation steps of the module are coded as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的训练和验证步骤的代码如下：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, the training and validation methods follow similar steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，训练和验证方法遵循相似的步骤：
- en: First, we check if any of the observations in the forecasting horizon is positive
    (in the `y[0] > 0).any(axis=1).long()` snippet). In effect, we’re building a neural
    network that models whether there’s an exceedance event in any of the next `7`
    observations.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们检查预测时间范围内的任何观测值是否为正（在`y[0] > 0).any(axis=1).long()`代码片段中）。实际上，我们正在构建一个神经网络，用于建模未来`7`个观测值中是否存在超越事件。
- en: We convert the output of this test into a `torch.FloatTensor` data structure,
    which is required for the `loss``()` function to work.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将此测试的输出转换为`torch.FloatTensor`数据结构，这是`loss()`函数工作的必需结构。
- en: Then, we compare the prediction with the actual value using binary cross entropy
    (`F.binary_cross_entropy`), which is used to train the model.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用二元交叉熵（`F.binary_cross_entropy`）比较预测值和实际值，这是用于训练模型的方式。
- en: 'Besides these methods, we also set up the optimizer as Adam with a 0.001 learning
    rate. Finally, we set up the testing method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些方法，我们还将优化器设置为Adam，并使用0.001的学习率。最后，我们设置了测试方法：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code, we add the area under the `ROC` curve as an evaluation
    metric, which is commonly used to test binary classification models.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们增加了`ROC`曲线下面积作为评估指标，这是常用于测试二分类模型的一个指标。
- en: 'Finally, we must train and test the model:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须训练和测试模型：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, the workflow follows the PyTorch Lightning style, where a `Trainer`
    instance uses the neural network model and the data module for training and testing.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，工作流遵循PyTorch Lightning风格，其中`Trainer`实例使用神经网络模型和数据模块进行训练和测试。
- en: How it works…
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The deep learning models we built in the previous chapters can be extended for
    classification predictive tasks. In this case, we added a sigmoid layer, which
    maps the output of the previous layer into a `0–1` value range. This value can
    be interpreted as the likelihood of the observations belonging to the positive
    class, which in our case is the exceedance event.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章中构建的深度学习模型可以扩展用于分类预测任务。在这种情况下，我们增加了一个sigmoid层，该层将前一层的输出映射到`0–1`的值范围内。这个值可以解释为观察值属于正类的概率，在我们这里即为超越事件。
- en: 'Classification models are no longer optimized with metrics such as mean squared
    error. For binary problems, we use binary cross entropy. In the testing phase,
    we added the area under the `ROC` curve as a secondary evaluation metric, which
    is helpful in understanding how the model distinguishes the two classes. The following
    figure shows the results of the ROC curve:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 分类模型不再通过均方误差等指标进行优化。对于二分类问题，我们使用二元交叉熵。在测试阶段，我们增加了`ROC`曲线下面积作为辅助评估指标，这有助于理解模型如何区分两个类别。下图展示了ROC曲线的结果：
- en: '![Figure 7.2: Results of the exceedance probability model in a ROC curve](img/B21145_07_002.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2：超越概率模型在ROC曲线中的结果](img/B21145_07_002.jpg)'
- en: 'Figure 7.2: Results of the exceedance probability model in a ROC curve'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：超越概率模型在ROC曲线中的结果
- en: The ROC curve provides a way of visualizing the performance of the probabilistic
    classifier for different decision thresholds. Results on the diagonal line denote
    a performance identical to a random guess. As the curve goes toward the top-left
    corner, it indicates better performance by the model.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ROC曲线提供了一种可视化方法，用于展示不同决策阈值下概率分类器的性能。位于对角线上的结果表示与随机猜测相同的性能。当曲线朝左上角移动时，表示模型的表现越好。
- en: Besides these tweaks to the pipeline, the design pattern provided by PyTorch
    Lightning makes the overall code similar to what we used in previous chapters
    for building models for point forecasting.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些管道调整，PyTorch Lightning提供的设计模式使得整体代码类似于我们在前几章中构建点预测模型时所用的代码。
- en: There’s more…
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: We remark that while we are focusing on an LSTM here, other architectures can
    be used, such as feedforward neural networks or convolutional neural networks.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到，尽管这里重点讨论的是LSTM，但其他架构也可以使用，例如前馈神经网络或卷积神经网络。
- en: Creating prediction intervals using conformal prediction
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用符合预测创建预测区间
- en: In this recipe, we’ll explore how to create prediction intervals. Prediction
    intervals describe the range of values within which future observations will likely
    fall with some confidence level. The greater the confidence required, the larger
    the intervals will be.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将探索如何创建预测区间。预测区间描述了一个范围，在这个范围内，未来的观察值很可能会落入某个置信水平。所需的置信度越高，区间就越大。
- en: In practice, the model predicts not just a single point but a distribution for
    future observations. Various techniques exist to construct these intervals, including
    parametric methods that assume a specific distribution of errors and non-parametric
    methods that use empirical data to estimate intervals.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，模型不仅预测一个单一的点，而是为未来的观察值预测一个分布。构建这些区间的方法有很多种，包括假设误差服从特定分布的参数方法，以及使用经验数据估计区间的非参数方法。
- en: We’ll resort to a conformal prediction approach, which is increasingly popular
    among data science practitioners.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用符合预测方法，这种方法在数据科学从业者中越来越流行。
- en: Getting ready
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We’ll build prediction intervals for an ARIMA model, which is a popular forecasting
    approach. Yet, conformal prediction is agnostic to the underlying method and can
    be applied to other forecasting methods.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为ARIMA模型构建预测区间，这是一个流行的预测方法。然而，符合预测方法与底层模型无关，可以应用于其他预测方法。
- en: 'Let’s start by loading a time series. In this example, we’ll work with a univariate
    time series:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从加载一个时间序列开始。在这个例子中，我们将处理一个单变量时间序列：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let’s see how to create prediction intervals using this dataset.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这个数据集创建预测区间。
- en: How to do it…
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'The data is split into training and testing sets to fit the ARIMA model. We’ll
    focus on the `statsforecast` Python library, so we need to transform the time
    series into a `pandas` DataFrame with three columns:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 数据被分为训练集和测试集，用于拟合ARIMA模型。我们将重点使用`statsforecast` Python库，因此我们需要将时间序列转换为包含三列的`pandas`
    DataFrame：
- en: '`ds`: The timestep for the corresponding observation'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ds`：对应观测值的时间步长'
- en: '`unique_id`: The identifier of the time series, which is constant since we’re
    working with a single time series'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unique_id`：时间序列的标识符，由于我们处理的是单一时间序列，因此它是常数。'
- en: '`y`: The value of the observation'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y`：观测值'
- en: 'This process is done as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程如下所示：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we must split the data into training and testing sets:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须将数据分为训练集和测试集：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The test set is composed of the last `7` observations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 测试集由最后`7`个观测值组成。
- en: 'Now, we must set up the conformal method using the `ConformalIntervals` class
    from `statsforecast`. We must also create an ARIMA model and pass the conformal
    instance to it:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须使用`statsforecast`中的`ConformalIntervals`类设置符合方法。我们还需要创建一个ARIMA模型，并将符合实例传递给它：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, we set the seasonal length to `365` since our data is
    daily, and we expect that solar radiation will exhibit a repeating yearly variation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将季节长度设置为`365`，因为我们的数据是按日记录的，我们预期太阳辐射会呈现出重复的年度变化。
- en: 'Finally, we must use the `StatsForecast` class instance to get the forecasts
    from the model:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须使用`StatsForecast`类的实例来获取模型的预测值：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we set the level of the prediction intervals to `95`. This means that
    we expect that the actual value will be within the respective interval with 95%
    confidence.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将预测区间的水平设置为`95`。这意味着我们期望实际值以95%的置信度位于相应的区间内。
- en: 'Here’s a plot of the prediction interval we obtained:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们获得的预测区间的图示：
- en: '![ Figure 7.3: ARIMA model forecasts and their respective intervals](img/B21145_07_003.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![ 图 7.3：ARIMA模型预测及其相应的区间](img/B21145_07_003.jpg)'
- en: 'Figure 7.3: ARIMA model forecasts and their respective intervals'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：ARIMA模型预测及其相应的区间
- en: How it works…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Conformal prediction involves using a subset of historical data to fit the ARIMA
    model. Then, another subset is used to calibrate the conformal prediction, typically
    through calculating nonconformity scores that measure the deviation between the
    actual observed values and the model’s predictions. The calibration step allows
    a threshold to be determined that corresponds to the desired confidence level
    (for example, 95%). This threshold is used for future forecasts to construct intervals
    around the predicted values, providing a range within which the actual values
    are expected to fall with the specified confidence level.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 符合预测方法通过使用历史数据的一个子集来拟合ARIMA模型。然后，使用另一个子集来校准符合预测，通常是通过计算不符合性分数来衡量实际观测值与模型预测之间的偏差。校准步骤允许确定一个阈值，该阈值对应于所需的置信水平（例如，95%）。这个阈值将用于未来的预测，以便在预测值周围构建区间，提供一个范围，在该范围内，实际值预计将以指定的置信水平落入其中。
- en: Conformal prediction helps quantify the uncertainty behind point forecasts by
    building intervals around these. In this recipe, we trained an ARIMA model and
    built intervals around its predictions using conformal prediction. We set the
    confidence level to `95`, but we can explore several values at the same time.
    You can do this by changing the level argument to `level=[80, 95]`, for example.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 符合预测有助于量化点预测背后的不确定性，通过在这些预测周围构建区间。在这个例子中，我们训练了一个ARIMA模型，并使用符合预测构建了它的预测区间。我们将置信水平设置为`95`，但我们也可以同时探索多个值。例如，你可以通过将`level`参数改为`level=[80,
    95]`来实现。
- en: Overall, this recipe follows a simple train plus testing cycle that uses the
    `statsforecast` Python library framework.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，这个食谱遵循一个简单的训练加测试周期，使用 `statsforecast` Python 库框架。
- en: Probabilistic forecasting with an LSTM
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 LSTM 进行概率预测
- en: This recipe will walk you through building an LSTM neural network for probabilistic
    forecasting using PyTorch Lightning.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将引导你构建一个用于概率预测的 LSTM 神经网络，使用 PyTorch Lightning。
- en: Getting ready
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we’ll introduce probabilistic forecasting with LSTM networks.
    This approach combines the strengths of LSTM models in capturing long-term dependencies
    within sequential data with the nuanced perspective of probabilistic forecasting.
    This method goes beyond traditional point estimates by predicting a range of possible
    future outcomes, each accompanied by a probability. This means that we are incorporating
    uncertainty into forecasts.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将介绍使用 LSTM 网络进行概率预测。这种方法结合了 LSTM 模型在捕捉序列数据中长期依赖关系方面的优势和概率预测的细致视角。这种方法超越了传统的点估计，通过预测一系列可能的未来结果，每个结果都附带一个概率。这意味着我们在预测中加入了不确定性。
- en: This recipe uses the same dataset that we used in [*Chapter 4*](B21145_04.xhtml#_idTextAnchor259),
    in the *Feedforward neural networks for multivariate time series forecasting*
    recipe. We’ll also use the same data module we created in that recipe, which is
    called `MultivariateSeriesDataModule`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱使用了与我们在[*第 4 章*](B21145_04.xhtml#_idTextAnchor259)的 *多变量时间序列预测的前馈神经网络* 食谱中相同的数据集。我们还将使用在该食谱中创建的相同数据模块，名为
    `MultivariateSeriesDataModule`。
- en: Let’s explore how to use this data module to build an LSTM model for probabilistic
    forecasting.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何使用这个数据模块来构建一个用于概率预测的 LSTM 模型。
- en: How to do it…
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In this subsection, we’ll define a probabilistic LSTM model that outputs the
    predictive mean and standard deviation for each forecasted point of the time series.
    This technique involves designing the LSTM model to predict parameters that define
    a probability distribution for future outcomes rather than outputting a single
    value. The model is usually configured to output parameters of a specific distribution,
    such as the mean and variance for a Gaussian distribution. These describe the
    expected value and the spread of future values, respectively:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将定义一个概率 LSTM 模型，该模型输出时间序列每个预测点的预测均值和标准差。此技术涉及设计 LSTM 模型以预测定义未来结果概率分布的参数，而不是输出单一值。该模型通常配置为输出特定分布的参数，如高斯分布的均值和方差。这些分别描述了未来值的期望值和分布：
- en: 'Let’s start by defining a callback:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先定义一个回调函数：
- en: '[PRE17]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `LossTrackingCallback` class is used to monitor the training and validation
    losses throughout the epochs. This is important for diagnosing the learning process
    of the model, identifying overfitting, and deciding when to stop training.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`LossTrackingCallback` 类用于监控整个训练过程中的训练和验证损失。这对于诊断模型的学习过程、识别过拟合以及决定何时停止训练至关重要。'
- en: 'Then, we must build the LSTM model based on PyTorch Lightning’s `LightningModule`
    class:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须基于 PyTorch Lightning 的 `LightningModule` 类构建 LSTM 模型：
- en: '[PRE18]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `ProbabilisticLSTM` class defines the LSTM architecture for our probabilistic
    forecasts. The class includes layers to compute the predictive mean (`fc_mu`)
    and standard deviation (`fc_sigma`) of the forecast distribution. The standard
    deviation is passed through a `Softplus``()` activation function to ensure it
    is always positive, reflecting the nature of standard deviation.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ProbabilisticLSTM` 类定义了我们用于概率预测的 LSTM 架构。该类包括计算预测均值（`fc_mu`）和预测分布标准差（`fc_sigma`）的层。标准差通过
    `Softplus` `()` 激活函数传递，以确保其始终为正，反映了标准差的特性。'
- en: 'The following code implements the training and validation steps, along with
    the network configuration parameters:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码实现了训练和验证步骤，以及网络配置参数：
- en: '[PRE19]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After defining the model architecture, we initialize the data module and set
    up training callbacks. As we saw previously, the `EarlyStopping` callback is a
    valuable tool for preventing overfitting by halting the training process once
    the model ceases to improve on the validation set. The `ModelCheckpoint` callback
    ensures that we capture and save the best version of the model based on its validation
    performance. Together, these callbacks optimize the training process, aiding in
    developing a robust and well-tuned model:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义模型架构后，我们初始化数据模块并设置训练回调函数。正如我们之前看到的，`EarlyStopping`回调函数是一个有效的工具，通过在模型在验证集上停止改进时终止训练过程，防止过拟合。`ModelCheckpoint`回调函数确保我们根据模型在验证集上的表现捕获并保存最佳模型。结合这些回调函数，它们优化了训练过程，有助于开发出一个强大且调优良好的模型：
- en: '[PRE20]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using the `Trainer` class from PyTorch Lightning simplifies the training process,
    handling the complex training loops internally and allowing us to focus on defining
    the model and its behavior. It increases the code’s readability and maintainability,
    making experimenting with different model configurations easier.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用PyTorch Lightning中的`Trainer`类简化了训练过程，内部处理复杂的训练循环，让我们能够专注于定义模型及其行为。它提高了代码的可读性和可维护性，使得尝试不同模型配置变得更加容易。
- en: 'After training, assessing the model’s performance and visualizing its probabilistic
    forecasts is very important. The graphical representation of the forecasted means,
    alongside their uncertainty intervals against the actual values, offers a clear
    depiction of the model’s predictive power and the inherent uncertainty in its
    predictions. We built a visualization framework to plot the forecasts. You can
    check the functions at the following link: [https://github.com/PacktPublishing/Deep-Learning-for-Time-Series-Data-Cookbook](https://github.com/PacktPublishing/Deep-Learning-for-Time-Series-Data-Cookbook).'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 训练完成后，评估模型的性能并可视化其概率性预测非常重要。预测均值的图形表示，与其不确定性区间相结合，并与实际值对比，清晰地展示了模型的预测能力以及预测中固有的不确定性。我们构建了一个可视化框架来绘制预测图。你可以在以下链接查看相关函数：[https://github.com/PacktPublishing/Deep-Learning-for-Time-Series-Data-Cookbook](https://github.com/PacktPublishing/Deep-Learning-for-Time-Series-Data-Cookbook)。
- en: 'The following figure illustrates the true values of our time series in blue,
    with the forecasted means depicted by the dashed red line:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了我们时间序列的真实值（蓝色），预测均值由虚线红色线条表示：
- en: '![Figure 7.4: Probabilistic forecasts with uncertainty intervals and true values](img/B21145_07_004.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4：带有不确定性区间和真实值的概率性预测](img/B21145_07_004.jpg)'
- en: 'Figure 7.4: Probabilistic forecasts with uncertainty intervals and true values'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：带有不确定性区间和真实值的概率性预测
- en: The shaded area represents the uncertainty interval, calculated as a standard
    deviation from the forecasted mean. This probabilistic approach to forecasting
    provides a more comprehensive picture than point estimates as it accounts for
    the variability and uncertainty inherent in the time series data. The overlap
    between the uncertainty intervals and the actual values indicates areas where
    the model has higher confidence in its predictions. Conversely, wider intervals
    may suggest periods of more significant uncertainty, potentially due to inherent
    noise in the data or complex underlying dynamics that the model finds more challenging
    to capture.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影区域表示不确定性区间，其计算方法是以预测均值为基础的标准差。相比于点估计，这种概率性预测方法提供了更为全面的图景，因为它考虑了时间序列数据中固有的变异性和不确定性。不确定性区间与实际值的重叠区域表明模型在这些区域内对预测的信心较高。相反，较宽的区间可能表示更大的不确定性，可能是由于数据中的固有噪声或模型更难捕捉的复杂潜在动态。
- en: 'Moreover, the following figure provides insights into the training dynamics
    of our probabilistic LSTM model:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，下图提供了我们概率性LSTM模型训练动态的深入分析：
- en: '![Figure 7.5: Training and validation loss over epochs, demonstrating the learning
    progress of the probabilistic LSTM model](img/B21145_07_005.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5：训练和验证损失随训练轮次的变化，展示了概率性LSTM模型的学习进展](img/B21145_07_005.jpg)'
- en: 'Figure 7.5: Training and validation loss over epochs, demonstrating the learning
    progress of the probabilistic LSTM model'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5：训练和验证损失随训练轮次的变化，展示了概率性LSTM模型的学习进展
- en: The relatively stable and low validation loss suggests that our model generalizes
    well without overfitting the training data.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 相对稳定且较低的验证损失表明我们的模型能够很好地泛化，而不会对训练数据过拟合。
- en: How it works…
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The probabilistic LSTM model extends beyond traditional point prediction models.
    Unlike point forecasts, which output a single expected value, this model predicts
    a full distribution characterized by mean and standard deviation parameters.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 概率LSTM模型超越了传统的点预测模型。与输出单一期望值的点预测不同，该模型预测一个由均值和标准差参数特征化的完整分布。
- en: This probabilistic approach provides a richer representation by capturing the
    uncertainty inherent in the data. The mean of the distribution gives the expected
    value of the forecast, while the standard deviation quantifies the confidence
    in the prediction, expressing the expected variability around the mean.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这种概率方法通过捕捉数据中固有的不确定性，提供了更丰富的表示。分布的均值给出了预测的期望值，而标准差则量化了对预测的信心，表达了围绕均值的预期波动性。
- en: To train this model, we use a loss function that differs from those used in
    point prediction models. Instead of using MSE or MAE, which minimizes the difference
    between predicted and actual values, the probabilistic LSTM employs a negative
    log-likelihood loss function. This loss function, often called the probabilistic
    loss, maximizes the likelihood of the observed data under the predicted distribution.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了训练这个模型，我们使用与点预测模型不同的损失函数。与最小化预测值和实际值之间差异的MSE或MAE不同，概率LSTM使用负对数似然损失函数。这个损失函数，通常称为概率损失，最大化预测分布下观察到数据的似然。
- en: This probabilistic loss function is particularly suited for uncertainty estimation
    as it directly penalizes the divergence between the predicted probability distribution
    and the observed values. When the predicted distribution assigns a high probability
    to the actual observed values, the negative log-likelihood is low, and thus the
    loss is low.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这种概率损失函数特别适用于不确定性估计，因为它直接惩罚预测概率分布与观察值之间的偏差。当预测分布给实际观察值分配较高的概率时，负对数似然值较低，因此损失较低。
- en: Probabilistic forecasting with DeepAR
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`DeepAR`进行概率预测
- en: This time, we’ll turn our attention to `DeepAR`, a state-of-the-art method for
    probabilistic forecasting. We’ll also leverage the `neuralforecast` framework
    to exemplify how to apply `DeepAR` for this task.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将重点关注`DeepAR`，一种用于概率预测的最先进方法。我们还将利用`neuralforecast`框架，示范如何应用`DeepAR`来完成这个任务。
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We’ll continue with the same dataset that we used in the previous recipe.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用之前食谱中的相同数据集。
- en: 'Since we are using a different Python package, we need to change our preprocessing
    steps to get the data into a suitable format. Now, each row corresponds to a single
    observation at a given time for a specific time series. This is similar to what
    we did in the *Prediction intervals using conformal* *prediction* recipe:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了不同的Python包，我们需要更改预处理步骤，将数据转换为合适的格式。现在，每一行对应于给定时间点某个特定时间序列的单个观察值。这与我们在*使用符合预测*
    *的预测区间*食谱中所做的类似：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this case, we select the targeted series within the dataset and resample
    it to a weekly frequency, aggregating the data points using the mean.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们选择数据集中的目标序列，并将其重新采样为每周频率，使用均值聚合数据点。
- en: Next, we show how to enhance the dataset by adding time-related features. We
    introduce Fourier series components for the week and month of the year. By incorporating
    sine and cosine transformations, we capture the cyclical nature of time in our
    data. Additionally, we scale the target using a `MinMaxScaler`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们展示如何通过添加与时间相关的特征来增强数据集。我们引入了与年份的周和月相关的傅里叶级数成分。通过结合正弦和余弦变换，我们捕捉了数据中的时间周期性。此外，我们使用`MinMaxScaler`对目标进行缩放。
- en: 'Finally, we split our dataset into training and testing sets:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将数据集分为训练集和测试集：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, let’s see how to build a `DeepAR` model using `neuralforecast`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用`neuralforecast`构建一个`DeepAR`模型。
- en: How to do it…
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'With the data prepared, we can define and train the `DeepAR` model. The `NeuralForecast`
    class receives a list of models as input. In this case, we only define the `DeepAR`
    class. The library provides a straightforward way to specify the architecture
    and training behavior of the model. After training, we generate forecasts using
    the `predict()` method:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 数据准备好后，我们可以定义并训练`DeepAR`模型。`NeuralForecast`类接受一个模型列表作为输入。在这个例子中，我们只定义了`DeepAR`类。该库提供了一种简便的方式来指定模型的架构和训练行为。训练后，我们使用`predict()`方法生成预测：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following figure illustrates a probabilistic forecast generated by `DeepAR`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了由`DeepAR`生成的概率预测：
- en: '![Figure 7.6: DeepAR probabilistic forecast showing the mean prediction and
    associated uncertainty](img/B21145_07_006.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6：DeepAR 概率预测，显示均值预测和相关的不确定性](img/B21145_07_006.jpg)'
- en: 'Figure 7.6: DeepAR probabilistic forecast showing the mean prediction and associated
    uncertainty'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6：DeepAR 概率预测，显示均值预测和相关的不确定性
- en: The solid line represents the mean prediction, while the shaded region shows
    the uncertainty bounds for the 80% and 95% confidence intervals. This plot shows
    the range of likely future values and is more informative than a single predicted
    value, especially for decision-making under uncertainty.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 实线代表均值预测，而阴影区域显示了 80% 和 95% 置信区间的不确定性范围。该图展示了可能的未来值范围，相比单一预测值，它为不确定性下的决策提供了更多信息。
- en: How it works…
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: '`DeepAR` is a probabilistic forecasting method that generates a probability
    distribution, such as a normal distribution or a negative binomial distribution,
    for each future time point. Once again, we are interested in capturing the uncertainty
    in our predictions rather than just producing point forecasts.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeepAR` 是一种概率预测方法，它为每个未来时间点生成一个概率分布，如正态分布或负二项分布。再次强调，我们关注的是捕捉预测中的不确定性，而不仅仅是生成点预测。'
- en: The `DeepAR` model uses an autoregressive recurrent network structure and conditions
    it on past observations, covariates, and an embedding of the time series. The
    output is a set of parameters, typically the mean and variance, which define the
    distribution of future values. During training, the model maximizes the likelihood
    of the observed data given these parameters.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeepAR` 模型使用自回归递归网络结构，并基于过去的观察值、协变量以及时间序列的嵌入进行条件化。输出是一组参数，通常是均值和方差，定义了未来值的分布。在训练过程中，模型最大化在给定这些参数下观测数据的似然。'
- en: '`DeepAR` is designed to work well with multiple related time series, enabling
    it to learn complex patterns across similar sequences and improve prediction accuracy
    by leveraging cross-series information.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeepAR` 旨在处理多个相关的时间序列，使其能够学习跨相似序列的复杂模式，并通过利用跨序列信息提高预测准确性。'
- en: Introduction to Gaussian Processes
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高斯过程简介
- en: In this recipe, we’ll introduce **Gaussian Processes** (**GP**), a powerful
    algorithm for probabilistic machine learning.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍**高斯过程**（**GP**），一种强大的概率性机器学习算法。
- en: Getting ready
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: GP offers a flexible, probabilistic approach to modeling in machine learning.
    This section introduces the concept of GP and prepares the necessary environment
    for forecasting using a GP model.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯过程（GP）提供了一种灵活的、概率性的机器学习建模方法。本节介绍了高斯过程的概念，并为使用 GP 模型进行预测做好了必要的环境准备。
- en: 'We need to import a new library to be able to fit GP, namely `gpytorch`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要导入一个新库来拟合 GP，即 `gpytorch`：
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Then, we must read the multivariate time series data and process it, scaling
    both the features and target variable, as scaled data typically improves GP modeling
    performance significantly.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须读取多元时间序列数据并进行处理，缩放特征和目标变量，因为缩放后的数据通常能显著提高 GP 建模的性能。
- en: How to do it…
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'We’ll use the `gpytorch` library to implement a GP model:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `gpytorch` 库来实现 GP 模型：
- en: 'The key components in a GP model are the mean and covariance functions, which
    are defined in the `GPModel` class:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GP 模型中的关键组件是均值和协方差函数，它们在 `GPModel` 类中定义：
- en: '[PRE25]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The model is then trained using the standard PyTorch training loop, optimizing
    the marginal log-likelihood:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后使用标准的 PyTorch 训练循环对模型进行训练，优化边际对数似然：
- en: '[PRE26]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After training, the GP model can make predictions for new data points. The
    key advantage of GP is its ability to quantify uncertainty in these predictions.
    The following code snippet demonstrates how predictions are made using a trained
    GP model:'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 训练后，GP 模型可以对新的数据点进行预测。GP 的主要优势在于它能够量化这些预测中的不确定性。以下代码片段演示了如何使用训练好的 GP 模型进行预测：
- en: '[PRE27]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here’s a visualization of the fitted values of the model:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是模型拟合值的可视化：
- en: '![Figure 7.7: A visualization of the GP model’s predictions](img/B21145_07_007.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7：GP 模型预测的可视化](img/B21145_07_007.jpg)'
- en: 'Figure 7.7: A visualization of the GP model’s predictions'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7：GP 模型预测的可视化
- en: This preceding figure illustrates the GP model’s ability to fit the historical
    data and forecast future values with quantified uncertainty. The shaded areas
    around the predictions visually represent the model’s forecast confidence, with
    wider intervals indicating more significant uncertainty.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的图示展示了 GP 模型如何拟合历史数据，并以量化的不确定性预测未来值。预测值周围的阴影区域直观地表示了模型的预测置信度，间隔越宽，表示不确定性越大。
- en: How it works…
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: GP offers a sophisticated way to analyze and understand complicated datasets.
    It differs from typical models because it doesn’t rely on a fixed number of parameters
    to describe data. Instead, GP uses a limitless range of possible functions, which
    gives it great adaptability to fit any type of data generation process.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: GP 提供了一种复杂的方式来分析和理解复杂的数据集。它与典型的模型不同，因为它不依赖固定数量的参数来描述数据。相反，GP 使用无限可能的函数范围，这使得它能非常灵活地适应任何类型的数据生成过程。
- en: GP is a collection of random variables. The key characteristic of these variables
    in GP is that one variable affects or is related to the values of others. The
    dependency pattern is governed by the Gaussian distribution. A GP can model a
    wide variety of functions (for example, nonlinear, noisy, and others). This method
    is particularly useful in our current setting because it adopts a probabilistic
    approach to modeling. GP can not only predict the most likely outcome but also
    quantify the uncertainty of these predictions.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: GP 是一组随机变量。这些变量的关键特性在于一个变量会影响或与其他变量的值相关联。它们之间的依赖关系由高斯分布决定。GP 可以建模多种不同类型的函数（例如，非线性、噪声等）。这种方法在我们当前的应用场景中尤其有用，因为它采用了概率方法进行建模。GP
    不仅可以预测最可能的结果，还能量化这些预测的“不确定性”。
- en: 'GP is defined by the mean and kernel functions:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: GP 由均值和核函数定义：
- en: '**Mean function**: The baseline expectation for the function’s values. It provides
    a starting point for predictions and is often set to zero.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**均值函数**：函数值的基准期望值。它为预测提供了起始点，通常设置为零。'
- en: '**Kernel function**: The core of a GP, this determines the relationship between
    data points by encoding the function’s properties (for example, smoothness, periodicity,
    and so on). It influences how predictions are made by assessing the similarity
    among points.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核函数**：GP 的核心，它通过编码函数的属性（例如，平滑性、周期性等）来确定数据点之间的关系。它影响着如何通过评估数据点之间的相似性来进行预测。'
- en: The kernel function is the essential component of a GP model’s predictive accuracy,
    adapting the model to the data’s underlying structure. In practice, you can mix
    different kernels to capture various aspects of the data. For instance, combining
    a kernel that’s good for smooth data with one good for periodic data can help
    model data with both characteristics.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 核函数是 GP 模型预测准确性的关键组成部分，它将模型适应于数据的潜在结构。在实际应用中，可以混合不同的核函数来捕捉数据的各种特征。例如，将适用于平滑数据的核与适用于周期性数据的核结合，可以帮助建模同时具有这两种特征的数据。
- en: Training a GP involves fine-tuning specific parameters in the kernel to fit
    your data best. This is often done using optimization techniques such as gradient
    descent. Once the GP has been trained, it can predict new data points.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 训练一个 GP 涉及微调核函数中的特定参数，以使其最好地拟合你的数据。通常使用优化技术，如梯度下降，来完成这一过程。一旦 GP 训练完成，它就可以预测新的数据点。
- en: Using Prophet for probabilistic forecasting
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Prophet 进行概率预测
- en: In this recipe, we’ll show how to use Prophet for probabilistic forecasting.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将展示如何使用 Prophet 进行概率预测。
- en: Getting ready
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Prophet is a tool developed by Facebook for forecasting time series data. It’s
    particularly adept at handling data with strong seasonal patterns and irregular
    events such as holidays. To get started with Prophet, we need to prepare our data
    and environment.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet 是 Facebook 开发的一个工具，用于时间序列数据的预测。它特别擅长处理具有强季节性模式和不规则事件（如节假日）的数据。要开始使用
    Prophet，我们需要准备好数据和环境。
- en: 'The process begins with loading and preprocessing the time series data so that
    it fits the format Prophet requires. Each time series in Prophet must have two
    columns – `ds` (the timestamp) and `y` (the value we wish to predict):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 过程从加载和预处理时间序列数据开始，使其符合 Prophet 所要求的格式。Prophet 中的每个时间序列必须有两列——`ds`（时间戳）和 `y`（我们希望预测的值）：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, let’s see how to build a Prophet model.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下如何构建 Prophet 模型。
- en: How to do it…
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'Follow these steps to build a Prophet model:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建 Prophet 模型：
- en: 'After preprocessing, we must divide the dataset into training and testing sets.
    Prophet is then used to fit the model on the training data:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经过预处理后，我们必须将数据集分为训练集和测试集。然后，使用 Prophet 对训练数据进行拟合：
- en: '[PRE29]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we must create a Prophet instance and train it, as follows:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须创建一个 Prophet 实例并进行训练，如下所示：
- en: '[PRE30]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can use the model to make future predictions once the model has been trained.
    This involves creating a future `dataframe` for the desired forecast period and
    then using the model to predict the values:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦模型训练完成，我们可以使用该模型进行未来预测。这涉及到创建一个用于预测期的未来 `dataframe`，然后使用模型进行值的预测：
- en: '[PRE31]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here’s how to visualize the forecasts:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是如何可视化预测的：
- en: '[PRE32]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'These forecasts are shown in the following figure:'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些预测结果展示在下图中：
- en: '![Figure 7.8: Prophet forecast with uncertainty intervals and observed data](img/B21145_07_008.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8：带有不确定性区间和观测数据的 Prophet 预测](img/B21145_07_008.jpg)'
- en: 'Figure 7.8: Prophet forecast with uncertainty intervals and observed data'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8：带有不确定性区间和观测数据的 Prophet 预测
- en: 'In addition to the basic forecasting model, Prophet also provides functionality
    to dissect and understand various components of the time series. This can be particularly
    useful for gaining insights into the underlying patterns of the data. Here’s how
    to visualize the forecasts by each component:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本的预测模型外，Prophet 还提供了功能来分解和理解时间序列的各个组件。这对于深入了解数据的潜在模式特别有用。以下是如何按各个组件可视化预测结果：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here’s the plot:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该图：
- en: '![Figure 7.9: Prophet model components showing trend, as well as weekly and
    yearly seasonality](img/B21145_07_009.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9：展示趋势以及每周和每年季节性的 Prophet 模型组件](img/B21145_07_009.jpg)'
- en: 'Figure 7.9: Prophet model components showing trend, as well as weekly and yearly
    seasonality'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9：展示趋势以及每周和每年季节性的 Prophet 模型组件
- en: The top plot illustrates the overall trend in the data over time. Here, we can
    see a general upward trend, suggesting that the value we predict increases over
    the years. The middle plot shows the weekly seasonality. This plot indicates how
    each day of the week affects our forecasting value. For instance, there might
    be peaks on specific days associated with weekly events or habits. The bottom
    plot represents yearly seasonality, showing how the time of the year influences
    the forecast. This could capture increased activity during certain months or seasonal
    effects.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部图展示了数据随时间的总体趋势。在这里，我们可以看到一个大致的上升趋势，表明我们预测的值在逐年增加。中间的图展示了每周季节性。这张图表明了一周中的每一天如何影响我们的预测值。例如，某些特定的日子可能会因每周事件或习惯而出现峰值。底部图表示了每年季节性，展示了一年中的不同时间如何影响预测。这可能会捕捉到某些月份或季节性效应的活动增加。
- en: How it works…
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'Prophet is an additive model that decomposes the time series into several components:
    trend, seasonality, and holidays. In this recipe, we used the default parameters
    of the model. However, you can tweak Prophet with several parameters. Check out
    the documentation at [https://facebook.github.io/prophet/docs/quick_start.html](https://facebook.github.io/prophet/docs/quick_start.html)
    for more information.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet 是一个加性模型，将时间序列分解为多个组件：趋势、季节性和假期。在本食谱中，我们使用了模型的默认参数。然而，你可以通过多个参数来调整 Prophet。更多信息，请查看文档
    [https://facebook.github.io/prophet/docs/quick_start.html](https://facebook.github.io/prophet/docs/quick_start.html)。
- en: 'The `prophet` library requires the data to be framed in a specific format:
    a `pandas` DataFrame with two columns: `ds` (timestamps) and `y` (the values).
    Then, the training and inference steps are carried out using a `fit()` method
    and a `predict()` method, respectively. You can also visualize the predictions
    by each component, which gives the model a more interpretable characteristic.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`prophet` 库要求数据采用特定格式：一个包含两列的 `pandas` DataFrame：`ds`（时间戳）和 `y`（值）。然后，通过使用
    `fit()` 方法和 `predict()` 方法分别进行训练和推断。你还可以按组件可视化预测结果，这使得模型更具可解释性。'
- en: There’s more…
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: There’s a newer extension of the Prophet model called `NeuralProphet`. It incorporates
    neural network models for improved forecasting, especially in complex patterns
    and multiple seasonality scenarios.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet 模型有一个更新版叫做 `NeuralProphet`。它结合了神经网络模型，以改善预测，特别是在复杂模式和多季节性场景下。
