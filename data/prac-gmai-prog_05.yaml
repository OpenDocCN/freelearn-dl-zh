- en: Animation Behaviors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画行为
- en: When we think about AI, usually we imagine smart robots, mechanical objects
    that perfectly perform a vast array of actions, and the same thought happens with
    video game AI. We tend to think about opponents or allies that act, react, think,
    or do a lot of things with smart decisions, and that's correct, but one more important
    aspect is usually left behind, the animations. In order to create believable and
    realistic AI characters, the animation is one of the most important aspects. Animations
    define the visual interaction, that is, what it looks like when the character
    is doing something. It's very important to have the animations working as well
    as the functional mechanics in order for the character to be believable. In this
    chapter, we'll be looking at some useful techniques and solutions to use, re-use,
    and create animations that smoothly fit the characters' behaviors. The way we
    create and use animations are the same for the player as for the AI characters,
    but we'll be focusing on how to integrate animations with the techniques that
    we have already learned about to create AI.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想到人工智能时，通常我们会想象智能机器人，能够完美执行大量动作的机械物体，对于视频游戏人工智能也是如此。我们倾向于认为对手或盟友会行动、反应、思考或做出许多智能决策，这是正确的，但通常还有一个更重要的方面被忽略了，那就是动画。为了创建可信和逼真的AI角色，动画是最重要的方面之一。动画定义了视觉交互，即角色做某事时的样子。为了让角色看起来可信，动画和功能机制一样重要。在本章中，我们将探讨一些有用的技术和解决方案，用于使用、重用和创建与角色行为无缝匹配的动画。我们创建和使用动画的方式对玩家和AI角色都是一样的，但我们将重点关注如何将动画与我们已经学习过的技术相结合来创建AI。
- en: 2D animation versus 3D animation
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2D动画与3D动画
- en: Video game animation can be put into two genres, 2D and 3D animation. Both have
    distinct features, and we need to take that into consideration and use them to
    our advantage when developing a game. Let's take a look at some of the main differences
    between the two.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 视频游戏动画可以分为两种类型，2D动画和3D动画。两者都有独特的特点，我们在开发游戏时需要考虑这一点，并利用它们的优势。让我们来看看这两种类型之间的一些主要区别。
- en: 2D animation - sprites
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2D动画 - 图像精灵
- en: As soon as consoles and computers allowed developers to integrate animation
    into the video games that they were making, games became much richer, relying
    on good-looking visuals to express the movement and actions of the characters.
    It also opened many doors to create new game genres or update older genres, making
    them more appealing, and since then, almost every game has started to implement
    animations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦控制台和计算机允许开发者将动画集成到他们制作的视频游戏中，游戏变得更加丰富，依赖于美观的视觉效果来表现角色的动作。这也为创造新的游戏类型或更新旧的游戏类型打开了大门，使它们更具吸引力，从那时起，几乎每款游戏都开始实施动画。
- en: The process of 2D animation used on video games is similar to what Disney use
    to use create their movies. They would draw and paint every frame of the movie,
    and every second would have around 12 frames. Games couldn't use real-life drawings
    at the time, but they could use coordinates to paint every bit of the game to
    make it look like a person or an animal if they wanted. The rest of the process
    is about the same. They needed to use that in order to create every frame of the
    animation, but because it was a hard and long process, they had a lot less detail
    and complexity. Now that they have all the frames needed to animate a character,
    it is necessary to program the machine to read the frames in a specific order,
    only using the ones that belong to the action that the character is doing.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在视频游戏中使用的2D动画过程与迪士尼过去用来制作电影的过程相似。他们会绘制和上色电影的每一帧，每秒大约有12帧。当时游戏不能使用现实生活中的绘画，但它们可以使用坐标来绘制游戏的每一部分，使其看起来像人或动物。其余的过程大致相同。他们需要这样做，以便创建动画的每一帧，但由于这是一个艰难且漫长的过程，他们有更少的细节和复杂性。现在他们有了所有必要的帧来动画化一个角色，这就需要编程机器以特定的顺序读取这些帧，只使用属于角色正在执行的动作的帧。
- en: '![](img/dc4281f2-250e-460f-82d4-a5089e7580c7.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dc4281f2-250e-460f-82d4-a5089e7580c7.png)'
- en: In the preceding figure, we can see an example of the 8-bit era that shows every
    animation of the *Super Mario Bros* character called Mario. As we can see, there
    is the run animation, jump, swim, die, stop, and crouch, some of which are just
    a single frame. Smooth transitions didn't appear right away, and the animations
    were combined into the gameplay. So, if we wanted to include more animations in
    the game, it would be necessary to create more frames. The same goes for the complexity
    of the animation; if we wanted the animation to include more detail, it would
    be necessary to create more frames and transitional frames. This makes the process
    of creating animations very long, but with the evolution of hardware capabilities,
    this process has started to take less time to implement, and the results are famous.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个图中，我们可以看到一个8位时代的例子，展示了名为马里奥的*超级马里奥兄弟*角色的每一个动画。正如我们所见，有跑步动画、跳跃、游泳、死亡、停止和蹲下，其中一些只是单个帧。平滑过渡并没有立即出现，动画被结合到游戏玩法中。因此，如果我们想在游戏中包含更多动画，就需要创建更多帧。动画的复杂性也是如此；如果我们想让动画包含更多细节，就需要创建更多帧和过渡帧。这使得创建动画的过程非常漫长，但随着硬件能力的进化，这个过程开始变得实施起来所需的时间更少，而且结果也变得闻名。
- en: 'One example of the 2D animation capabilities on video games is *Prince of Persia*,
    released in 1989 (the following sprite sheet shows the character''s animations
    in *Prince of Persia*). By using real-world references of a person doing the movements
    of the game, the quality, detail, and smooth transitions were stupendous, raising
    the bar even higher for the next generation of games. So at this time, game developers
    started to worry about transitions, smooth animations, and how to create a lot
    of actions without it being necessary to add more frames to the sprite sheet:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 2D动画在视频游戏中的能力的一个例子是1989年发布的*波斯王子*（以下精灵表显示了*波斯王子*中角色的动画）。通过使用现实世界中人物进行游戏动作的参考，质量、细节和平滑过渡都令人惊叹，甚至为下一代游戏提高了标准。因此，在这个时候，游戏开发者开始担心过渡、平滑动画以及如何在不增加精灵表中的帧的情况下创建大量动作：
- en: '![](img/f6095ca7-4462-49e7-8103-41047405e0fd.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f6095ca7-4462-49e7-8103-41047405e0fd.png)'
- en: Today, we still use the same process on 2D games, we have a sprite sheet with
    all the animations that we want, then we code to animate them at the same time
    the character is performing an action. Working with sprite sheets is not as flexible
    as working with 3D animations that use bone structures, but there are some useful
    tips that we can use to create smooth transitions and separate the code animation
    from the gameplay code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们仍然在2D游戏中使用相同的过程，我们有一个包含所有我们想要的动画的精灵表，然后我们编码在角色执行动作的同时使它们动画化。与使用骨骼结构的3D动画相比，使用精灵表的工作并不那么灵活，但有一些有用的技巧我们可以使用来创建平滑过渡，并将代码动画与游戏玩法代码分开。
- en: 3D animation - bone structure
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D动画 - 骨骼结构
- en: 'Using 3D models and 3D animations to create games is a very popular choice
    at the moment, and one of the main reasons is related to the time that it takes
    to create them. We only need to create the 3D model once, and then we can implement
    a bone structure to animate it as we want. We can also use the same bone structure
    and skin it to another 3D model and it will get the same animations as the previous
    one. Using 3D animations is obviously convenient for larger projects, saving hours
    of hard work and allowing us to update the character without the need to create
    it all over again. This is due to the bone structure of the character, which helps
    us improve the quality of the animations, saving time and resources. Because of
    this, we can decide to animate just one specific area and leave the rest of the
    body completely still or doing some other animation. It is very useful to smoothly
    change from one animation to another, or to have two animations playing at the
    same time:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用3D模型和3D动画来创建游戏是目前一个非常流行的选择，其中一个主要原因是与创建它们所需的时间有关。我们只需要创建一次3D模型，然后我们可以实现一个骨骼结构来按我们的意愿动画化它。我们还可以使用相同的骨骼结构，将其皮肤应用到另一个3D模型上，它将获得与之前相同的动画。使用3D动画对于大型项目来说显然很方便，可以节省数小时的工作，并允许我们更新角色而无需重新创建它。这是由于角色的骨骼结构，它帮助我们提高动画质量，节省时间和资源。正因为如此，我们可以决定只动画化一个特定的区域，而让身体的其余部分完全静止或执行其他动画。从一种动画平滑过渡到另一种动画，或者同时播放两个动画非常有用：
- en: '![](img/7a321cc7-92a4-41ae-9b8a-e7d9eaaa4320.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a321cc7-92a4-41ae-9b8a-e7d9eaaa4320.jpg)'
- en: The main differences
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要区别
- en: Sprite sheets versus bones structure are the two main differences between the
    two types of animation that will change the way we integrate the animations with
    the gameplay. Using sprites, we stick to how many images we have available and
    we cannot change the way they look in the code, whereas with the bone structure,
    we can define which portion of the character we want to animate and we can use
    physics to shape the animation according to the situation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图精灵与骨骼结构是两种动画类型之间的两个主要区别，这将改变我们将动画与游戏玩法集成的整合方式。使用图精灵，我们坚持使用我们拥有的图像数量，并且在代码中无法改变它们的外观，而使用骨骼结构，我们可以定义我们想要动画化的角色的哪一部分，并且我们可以使用物理来根据情况塑造动画。
- en: Recently, there are some new options that allow us to implement a similar technique
    as bone structure in the 2D models, but it's still a very limited option compared
    to what we can do in 3D.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，有一些新选项允许我们在2D模型中实现类似于骨骼结构的类似技术，但与我们在3D中能做的相比，这仍然是一个非常有限的选项。
- en: Animation state machines
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画状态机
- en: We have already talked about behavior states, where we define the possible actions
    of a character and how to link them. Animation state machines is a very similar
    process, but instead of defining the actions, we define the animations of a character.
    While developing the character and creating the behavior states, we could assign
    the animations in the action code, defining at which point the character starts
    to run, and once that happens, the walk animation stops and the run animation
    starts playing. This way of integrating the animations with the gameplay code
    looks like an easier approach to do it, but it's not the best way and it gets
    complicated if we want to update the code later on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了行为状态，其中我们定义了角色的可能动作以及如何将它们链接起来。动画状态机是一个非常类似的过程，但我们不是定义动作，而是定义角色的动画。在开发角色和创建行为状态时，我们可以在动作代码中分配动画，定义角色何时开始奔跑，一旦发生，行走动画停止，奔跑动画开始播放。这种将动画与游戏玩法代码集成的做法看起来是一个更容易的方法来做这件事，但这并不是最好的方法，如果我们想要更新代码，它会变得复杂。
- en: 'The solution to this problem is to create a separate state machine just for
    the animations. This will allow us to have better control of the animations without
    worrying about changing our character''s code. It is a good method to use between
    programmer and animator as well, because the animator can add more animations
    to the animation state machine without interfering with the code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是创建一个专门用于动画的独立状态机。这将使我们能够更好地控制动画，而不用担心更改我们的角色代码。这对于程序员和动画师之间的交互也是一个好方法，因为动画师可以在动画状态机中添加更多动画，而不会干扰代码：
- en: '![](img/a9638f99-2309-4e98-bad8-a1c9ff4ce29f.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a9638f99-2309-4e98-bad8-a1c9ff4ce29f.jpg)'
- en: 'In the preceding diagram, we can see a simple example of a behavior state machine,
    where the character can stay still, move, jump, and use a ladder. Once we have
    this part completed, we can start designing and implementing an animation state
    machine to work according to the behavior state machine principles:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到一个行为状态机的简单示例，其中角色可以静止、移动、跳跃和使用梯子。一旦这部分完成，我们就可以开始设计和实现一个动画状态机，使其根据行为状态机的原则工作：
- en: '![](img/a12f1f19-bb2c-43f8-943f-649a360ac069.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a12f1f19-bb2c-43f8-943f-649a360ac069.jpg)'
- en: As we can see, there are more animation states than behavior states, which is
    why the best method to integrate the animations into our characters is to separate
    the gameplay from the animation. When developing our game, we use statements and
    values, so the only difference between walk and run is the number that defines
    how fast our character is moving. That is why we need to use the animation states
    to convert this information into visual output, where the character is animated
    according to the gameplay states. Using this method does not necessarily mean
    that we cannot use the animations to interfere with the gameplay, because we can
    also do it by simply reporting that information back to our gameplay code and
    changing the gameplay if we want to.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，动画状态比行为状态要多，这就是为什么将动画集成到我们的角色中最好的方法是分离游戏玩法和动画。在开发我们的游戏时，我们使用语句和值，所以行走和奔跑之间的唯一区别是定义角色移动速度的数字。这就是为什么我们需要使用动画状态将此信息转换为视觉输出，其中角色根据游戏玩法状态进行动画。使用这种方法并不意味着我们不能使用动画来干扰游戏玩法，因为我们也可以通过简单地向我们的游戏玩法代码报告信息并更改游戏玩法来实现这一点。
- en: 'This can be used both for 2D and 3D animations. The process is exactly the
    same, and can be used with the most popular game engines, such as CryENGINE, Unity,
    and Unreal Development Kit. To make it work, we need to import all of the animations
    into our game and then we assign the animations into the animation state section:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用于2D和3D动画。过程完全相同，并且可以与最流行的游戏引擎一起使用，例如CryENGINE、Unity和Unreal Development Kit。为了使其工作，我们需要将所有动画导入到我们的游戏中，然后我们将动画分配到动画状态部分：
- en: '![](img/a4708052-d88d-4e33-8342-3d70f5cadff6.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a4708052-d88d-4e33-8342-3d70f5cadff6.jpg)'
- en: 'Now that, we have imported the animations into the animation state section,
    we need to configure when the animations will be played according to the values
    that we used in our code. The values or statements that we can use are integers,
    floats, Booleans, and triggers. With these, we can define when each animation
    will be played. When linking the animations, we''ll be using the values to determine
    when to change from one animation state to another:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将动画导入到动画状态部分，我们需要根据我们在代码中使用的值来配置动画播放的时间。我们可以使用的值或语句是整数、浮点数、布尔值和触发器。有了这些，我们可以定义每个动画何时播放。在链接动画时，我们将使用这些值来确定何时从一个动画状态切换到另一个状态：
- en: '![](img/6e067c49-a586-4e77-9c1a-438724a447e9.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6e067c49-a586-4e77-9c1a-438724a447e9.png)'
- en: This is where we define the difference between walking and running. If the movement
    speed of our character reaches a certain value, it will start playing the run
    animation, and once that value decreases it will play the walk animation again.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们定义行走和奔跑之间差异的地方。如果我们的角色移动速度达到某个值，它将开始播放奔跑动画，一旦该值降低，它将再次播放行走动画。
- en: We can have as many animations states as we want, regardless of the gameplay
    states. Let's take a look at the locomotion example. We can define that if the
    character is moving really slowly, it would animate like he is sneaking; a little
    bit faster and it starts walking; even faster and the characters starts running;
    and ultimately, if the movement speed is really high, he can grow a pair of wings
    to give the impression that he is flying. As we can see, it is more convenient
    to separate the animations from the gameplay, because that way we can change the
    animations, remove them, or add new ones, without modifying our code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以拥有我们想要的任意数量的动画状态，无论游戏状态如何。让我们看看运动学示例。我们可以定义，如果角色移动非常缓慢，它会像潜行一样进行动画；稍微快一点，它就开始行走；更快的话，角色开始奔跑；最终，如果移动速度非常高，他可以长出一对翅膀，给人一种他在飞行的印象。正如我们所见，将动画与游戏玩法分开会更方便，因为这样我们可以更改动画，删除它们，或添加新的动画，而无需修改我们的代码。
- en: 'Now let''s move on to the example. Using all the topics that we have explored
    in the previous chapters, we''ll configure our character to animate according
    to the gameplay behavior and the environment. We start by importing the model
    and all the animations into our game. Then we create a new animation state machine;
    in this case it''s called **animator**. After that, we just need to assign that
    animation state machine to our character:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续到示例部分。使用我们在前几章中探索的所有主题，我们将配置我们的角色根据游戏玩法行为和环境进行动画处理。我们首先将模型和所有动画导入到我们的游戏中。然后我们创建一个新的动画状态机；在这种情况下，它被称为**animator**。之后，我们只需将那个动画状态机分配给我们的角色：
- en: '![](img/26ed83f9-a35d-4aad-8b06-18ce0af9f883.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/26ed83f9-a35d-4aad-8b06-18ce0af9f883.png)'
- en: The model that we import into the game ideally should be in a neutral pose,
    such as the T-pose (demonstrated on the preceding screenshot). Then we import
    the animations and add them into the Animator Controller.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入到游戏中的模型理想状态下应该是中性的姿势，例如T姿势（如前一张截图所示）。然后我们导入动画并将它们添加到Animator Controller中。
- en: '![](img/81f8c5dd-647c-4b2c-bf5a-9f521dd988cf.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/81f8c5dd-647c-4b2c-bf5a-9f521dd988cf.jpg)'
- en: 'Now, if we click on the character and open the animation state machine that
    we created, it will be empty. That is normal, because we need to manually add
    the animations that we want to use:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们点击角色并打开我们创建的动画状态机，它将是空的。这是正常的，因为我们需要手动添加我们想要使用的动画：
- en: '![](img/709a2da2-427f-470a-9436-e99365bd914f.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/709a2da2-427f-470a-9436-e99365bd914f.png)'
- en: 'Once we have done this, we''ll need to organize everything to make it easy
    to link the animations:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成这项工作，我们就需要组织好一切，以便轻松地链接动画：
- en: '![](img/a6942f34-594c-4492-89e3-2a88042a3bc4.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a6942f34-594c-4492-89e3-2a88042a3bc4.png)'
- en: So, we have separated the different animations taking in consideration gameplay
    states such as **IDLE**, **ATTACK**, **JUMP**, **LOCOMOTION**, and **DAMAGE**,
    as shown in preceding diagram. We have two distinct animations for the **IDLE**
    state and another two for **ATTACK**. We want them to play in a random order,
    and separate from the gameplay code, so we can add as many animations we want
    there to add more diversity. Inside of the locomotion state, we have two separate
    groups, walking **STRAIGHT** and **CROUCH**. We have chosen to include both groups
    in the locomotion state because they will animate according to the position of
    the movement joystick.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们根据游戏状态（如**IDLE**、**ATTACK**、**JUMP**、**LOCOMOTION**和**DAMAGE**）将不同的动画分开，如图所示。对于**IDLE**状态，我们有两个不同的动画，对于**ATTACK**状态也有另外两个。我们希望它们以随机顺序播放，并且与游戏代码分开，这样我们就可以添加尽可能多的动画来增加多样性。在移动状态内部，我们有两组独立的动画，分别是**STRAIGHT**行走和**CROUCH**蹲下。我们选择将这两组动画都包含在移动状态中，因为它们将根据移动摇杆的位置进行动画处理。
- en: 'Now, we can start linking the animations, and at this point we can forget about
    how the animations will be activated and focus only on the play order:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始链接动画，在这个阶段，我们可以忘记动画是如何被激活的，而只关注播放顺序：
- en: '![](img/3a7c0757-d99f-4811-9e41-0f3e7f230ee3.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3a7c0757-d99f-4811-9e41-0f3e7f230ee3.png)'
- en: 'Once we have all the animations linked in the desired order, we can start defining
    how they will be played. At this point, we need to take a look at the character
    code and use the variables to change the animations. In our code, we have variables
    that accesses the animation state machine. In this case, they are the `Animator`,
    `Health` and `Stamina` integer values, `movementSpeed`, `rotationSpeed`, `maxSpeed`,
    `jumpHeight`, `jumpSpeed` and `currentSpeed` as float values, and finally a Boolean
    variable to check whether the player is alive:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将所有动画以所需的顺序链接起来，我们就可以开始定义它们将如何播放。在这个阶段，我们需要查看角色代码并使用变量来更改动画。在我们的代码中，我们有访问动画状态机的变量。在这种情况下，它们是`Animator`、`Health`和`Stamina`整数值，`movementSpeed`、`rotationSpeed`、`maxSpeed`、`jumpHeight`、`jumpSpeed`和`currentSpeed`浮点值，以及最后用于检查玩家是否存活的布尔变量：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's start passing these values into the animation state machine. The movement
    and the `currentSpeed` value of the character are controlled by the left analog
    joystick, so if we push the joystick just a little bit, the character should play
    the walk animation. If we push it all the way it should play the run animation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始将这些值传递到动画状态机中。角色的移动和`currentSpeed`值由左侧模拟摇杆控制，所以如果我们稍微推动摇杆，角色应该播放行走动画。如果我们完全推动它，它应该播放跑步动画。
- en: '![](img/6bb4d0fe-d1bb-4a3d-a98d-2280d370d7bb.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6bb4d0fe-d1bb-4a3d-a98d-2280d370d7bb.png)'
- en: 'In the `Animator` section, we can choose between four parameters, and for the
    locomotion of the character we have chosen Float. We now need to link this value
    with the `currentSpeed` variable that we have in our code. We will assign this
    at the beginning of the `Update` function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Animator`部分，我们可以选择四个参数之一，对于角色的移动，我们选择了Float。现在我们需要将这个值与代码中存在的`currentSpeed`变量链接起来。我们将在`Update`函数的开始处进行赋值：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We've already connected the two parameters. This way, the animation state machine
    can use the same value of the `currentSpeed` found in the code. We gave it exactly
    the same name in the `Animator` section that we have in the code. It's not necessary,
    but it makes it easier to understand which values they represent.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经连接了这两个参数。这样，动画状态机就可以使用代码中找到的`currentSpeed`的相同值。我们在`Animator`部分给它取的名字与代码中的完全一样。这不是必需的，但它使得理解它们代表什么值变得更容易。
- en: '![](img/5945cefe-5158-4784-941a-4c55f7860aa7.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5945cefe-5158-4784-941a-4c55f7860aa7.png)'
- en: 'So at this point, we can start defining the values of the links that connect
    the locomotion animations of the character. In this case, we can click on the
    link and a new window will open so we can add the values that will change the
    animations from one state to another:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个阶段，我们可以开始定义连接角色移动动画的链接值。在这种情况下，我们可以点击链接，将打开一个新窗口，以便我们可以添加将动画从一个状态切换到另一个状态的值：
- en: '![](img/aa9cf293-f4c1-403d-8fda-122949bba915.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aa9cf293-f4c1-403d-8fda-122949bba915.png)'
- en: 'We can also click on the animation that we want to configure, such as the IDLE
    animation, and then a new window opens with all the animations connected to this
    one. We can select the link that we want to allow the next animation to play.
    This is demonstrated in the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以点击我们想要配置的动画，例如闲置动画，然后会打开一个新窗口，显示与该动画连接的所有动画。我们可以选择允许播放下一个动画的链接。以下截图展示了这一过程：
- en: '![](img/d2ecbeab-b937-432f-9252-67166d777375.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2ecbeab-b937-432f-9252-67166d777375.png)'
- en: 'We have clicked on idle to walk and added the condition that we previously
    created, currentSpeed:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们点击了闲置以行走，并添加了我们之前创建的条件，currentSpeed：
- en: '![](img/f3e5ba32-2566-41cc-8420-8b06b3e71d27.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3e5ba32-2566-41cc-8420-8b06b3e71d27.png)'
- en: 'Here, we can choose if the value needs to be Greater or Less than the desired
    value that will start playing the next animation. For this example, we have set
    the value to be greater than 0.1, so as soon as the character starts moving, it
    will stop the IDLE animation and play the WALK animation. We don''t need to write
    anything inside the code because the animation state machine acts independently
    to the code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以选择值是否需要大于或小于期望的值以开始播放下一个动画。对于这个例子，我们将值设置为大于0.1，所以一旦角色开始移动，它就会停止闲置动画并播放行走动画。我们不需要在代码中写任何内容，因为动画状态机独立于代码工作：
- en: '![](img/59b0b0bb-806c-496d-8d25-7570894e4c5b.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59b0b0bb-806c-496d-8d25-7570894e4c5b.png)'
- en: 'However, because we have another animation playing after the WALK animation,
    we need to set a limit value for the WALK animation. In this case, let''s assume
    that our character starts running when the `currentSpeed` is at 5; this means
    that our character stops walking at 4.9\. So, we are going to add another condition
    here that tells to our character that he stops walking once his `currentSpeed`
    reaches 4.9:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，因为我们还有另一个动画在行走动画之后播放，我们需要为行走动画设置一个限制值。在这种情况下，让我们假设当`currentSpeed`达到5时，我们的角色开始奔跑；这意味着我们的角色在4.9时停止行走。所以，我们在这里添加另一个条件，告诉角色一旦他的`currentSpeed`达到4.9，他就停止行走：
- en: '![](img/7a31ce54-7bdc-4e3b-9a08-f119fb075541.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a31ce54-7bdc-4e3b-9a08-f119fb075541.png)'
- en: Now that we have defined when the character starts walking, we also need to
    do the inverse, to define when it's time to stop walking and play the IDLE animation.
    We need to remember that this does not affect the gameplay, so it means that if
    we start the game at this point, the character will start playing the WALK animation
    because we have already set that to happen. But even if we hadn't, the character
    would move in the environment even without the animation. We are simply using
    the values that are stored in our code to connect with the animation states, and
    we need to define what animation will be played at a certain value. If we forget
    to set that value to all animations, the character will still perform the behavior,
    but without the correct animation. So with that said, we need to check if all
    the links have conditions assigned to them.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了角色何时开始行走，我们还需要做相反的操作，即定义何时停止行走并播放闲置动画。我们需要记住，这不会影响游戏玩法，这意味着如果我们从这个点开始游戏，角色将开始播放行走动画，因为我们已经设置了这一点。但即使我们没有，角色在没有动画的情况下也会在环境中移动。我们只是在代码中存储的值来连接动画状态，并需要定义在某个值时将播放哪个动画。如果我们忘记为所有动画设置该值，角色仍然会执行行为，但没有正确的动画。所以，我们还需要检查是否所有链接都分配了条件。
- en: 'Now to make the character go back to the IDLE animation once he stops moving,
    we click on the link that goes from the WALK to IDLE, and we add a new condition
    that expresses if the currentSpeed is Less than 0.1, he stops playing the WALK
    animation and starts playing the IDLE animation:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为了让角色在停止移动后回到闲置动画，我们点击从行走到闲置的链接，并添加一个新条件，表示如果当前速度小于0.1，他就停止播放行走动画并开始播放闲置动画：
- en: '![](img/b616d689-ac68-4d6b-8d6b-a95a5045fca4.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b616d689-ac68-4d6b-8d6b-a95a5045fca4.png)'
- en: 'Now we can do this for the rest of the animations that use the `currentSpeed`
    value and finish the `Locomotion` states. Once we have all of that ready, we can
    move on to the Crouch animations. They use the currentSpeed value as well, but
    we need to have an additional value that invalidates the WALK animation and enables
    the Crouch animation. There are two ways of doing this: by pressing a Crouch button
    at the same time that we move forward, or to define zones on the map where the
    character goes directly to CROUCH mode. For this example, and because we are working
    on an AI character, we''ll be using the second option and define zones on the
    map that will make the character enter CROUCH mode:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为使用`currentSpeed`值的其余动画完成`Locomotion`状态。一旦我们准备好了所有这些，我们就可以继续到蹲下动画。它们也使用`currentSpeed`值，但我们需要一个额外的值来使WALK动画无效并启用蹲下动画。有两种方法可以实现这一点：在向前移动的同时按下蹲下按钮，或者定义地图上的区域，使角色直接进入蹲下模式。对于这个例子，因为我们正在处理一个AI角色，我们将使用第二种选项，在地图上定义区域，使角色进入蹲下模式：
- en: '![](img/25e33e17-2dde-4d84-b33c-0e1e0a868250.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25e33e17-2dde-4d84-b33c-0e1e0a868250.png)'
- en: In this example, let's assume that the character shouldn't be walking on the
    grass, and for that reason he tries to hide by crouching. We could also choose
    a small location that is impossible to enter if he was walking upright, and for
    that reason the character automatically starts to walk in the crouch position.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，让我们假设角色不应该在草地上行走，因此他试图通过蹲下来隐藏。我们也可以选择一个如果直立行走就不可能进入的小地点，因此角色会自动开始以蹲下的姿势行走。
- en: 'So, to do this we need to create trigger positions on our map that change the
    animations according to the position that the character is currently in. In the
    code, we create a new Boolean variable and call it `steppingGrass`, right after
    the line where we connect the `currentSpeed` value with the animation state machine.
    We are going to add a new line that connects this Boolean to a new parameter that
    we are going to create on the animation state machine as well. We can start by
    creating the new parameter:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了做到这一点，我们需要在地图上创建触发位置，根据角色当前的位置改变动画。在代码中，我们创建一个新的布尔变量，并将其命名为`steppingGrass`，在将`currentSpeed`值与动画状态机连接的行之后。我们将添加一个新行，将这个布尔值连接到我们将在动画状态机上创建的新参数。我们可以从创建新参数开始：
- en: '![](img/e68f302d-152b-457f-99f2-163237e928a2.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e68f302d-152b-457f-99f2-163237e928a2.png)'
- en: 'In our code, we are going to add collision detection that will turn on this
    value once our character is on the grass, and turn it off soon as he leaves that
    area:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们将添加碰撞检测，一旦我们的角色在草地上，就会打开这个值，一旦他离开这个区域，就会关闭它：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we can proceed and add this new parameter to the CROUCH animations. We
    start by choosing the link between the IDLE to CROUCH animation and set the `currentSpeed`
    value and the new `steppingGrass` parameter. Because we have a Crouch Idle animation,
    even if the character is not moving, it will play that animation instead of the
    normal IDLE animation:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续并添加这个新参数到蹲下动画。我们首先选择从IDLE到蹲下动画的链接，并设置`currentSpeed`值和新的`steppingGrass`参数。因为我们有一个蹲下空闲动画，即使角色没有移动，它也会播放这个动画而不是正常的IDLE动画：
- en: '![](img/259985ef-d40a-4117-a173-12e1bfce82b5.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/259985ef-d40a-4117-a173-12e1bfce82b5.png)'
- en: We have set the `currentSpeed` to be less than 0.1, which means that the character
    is not moving, and the `steppingGrass` set to true, which stops the normal IDLE
    animation and starts playing the Crouch Idle animation. The rest of the CROUCH
    animations follow the same principles as the WALK and RUN animation. Once the
    character starts to move, that represents the `currentSpeed` value, the Crouch
    Idle stops and the Crouch Walk plays. At the end, we link Crouch Idle to IDLE
    and Crouch Walk to WALK, making sure that if the character is walking away from
    the grass, the WALK animation doesn't stop and the character keeps walking upright.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`currentSpeed`设置为小于0.1，这意味着角色没有移动，并将`steppingGrass`设置为true，这停止了正常的IDLE动画并开始播放蹲下空闲动画。其余的蹲下动画遵循与WALK和RUN动画相同的原理。一旦角色开始移动，这代表`currentSpeed`值，蹲下空闲停止，蹲下行走开始。最后，我们将蹲下空闲链接到IDLE，将蹲下行走链接到WALK，确保如果角色离开草地，WALK动画不会停止，角色会继续直立行走。
- en: Regarding the attacks, we will be using integers to randomize a number between
    1 to 10, and if the number is higher than `5` it will play the KICK animation.
    If the number is below `5` it will play the PUNCH animation. So, when the character
    enters fight mode against an opponent, it will play different attacks. Once again,
    using this method allows us to add more animations in the future, increasing the
    diversity of attacks.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 关于攻击，我们将使用整数在1到10之间随机生成一个数字，如果这个数字大于`5`，它将播放踢动画。如果数字小于`5`，它将播放拳动画。因此，当角色进入与对手的战斗模式时，它将播放不同的攻击。再次强调，使用这种方法允许我们在未来添加更多动画，从而增加攻击的多样性。
- en: 'Once again, we create a new parameter, and for this example we are going to
    create an integer parameter and call it `attackRandomNumber`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们创建一个新的参数，在这个例子中，我们将创建一个整数参数，并称之为`attackRandomNumber`：
- en: '![](img/f203ad22-22a5-4c93-bd39-4999b6816924.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f203ad22-22a5-4c93-bd39-4999b6816924.png)'
- en: 'In our code, we are going to add a new variable and give it the same name (it
    is not necessary to create it with the same name, but it does make everything
    organized). Right after the lines with which we previously connected the variables
    with the animation state machine parameters, we are going to create a new one
    that connects to the `attackRandomNumber` value. Then we create a function that
    randomizes a number once the character enters fight mode:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们将添加一个新的变量，并给它相同的名字（不需要用相同的名字创建它，但这确实使一切更有条理）。在之前连接变量与动画状态机参数的行之后，我们将创建一个新的变量，将其连接到`attackRandomNumber`值。然后我们创建一个函数，一旦角色进入战斗模式，就会随机生成一个数字：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After doing this, we need to assign the values to the animations. The process
    is the same as the previous animations, only this time we are using a different
    value. If `attackRandomNumber` is higher than 1, it means that he is attacking,
    and the attack animations should start playing. Because we have two different
    attacks, we decided to use them randomly, but if it was a player controlling the
    character, we could manually assign the number inside the code, and when the player
    pressed a specific button on the gamepad, the character would punch or kick.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这个步骤后，我们需要将值分配给动画。这个过程与之前的动画相同，只是这次我们使用了一个不同的值。如果`attackRandomNumber`大于1，这意味着他在攻击，攻击动画应该开始播放。因为我们有两种不同的攻击，我们决定随机使用它们，但如果是一个玩家控制的角色，我们可以在代码内部手动分配数字，当玩家按下游戏手柄上的特定按钮时，角色就会出拳或踢腿。
- en: Smooth transitions
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平滑过渡
- en: Another important aspect that is worth mentioning is the smooth transition between
    animations. It is very important to maintain the integrity of the animations,
    so that every action performed by the character looks fluid, helping the virtual
    immersion of the player.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的重要方面是动画之间的平滑过渡。保持动画的完整性非常重要，这样角色的每一个动作看起来都流畅，有助于玩家的虚拟沉浸感。
- en: On this subject, 2D and 3D animations have considerable differences. If we are
    using 2D sprites, we need to draw the necessary frames that will be used for every
    transition, and every time we want the character to change from one animation
    to another, the transition animation will be played.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个问题，2D和3D动画有相当大的不同。如果我们使用2D精灵，我们需要绘制每个过渡所需的必要帧，并且每次我们想要角色从一个动画切换到另一个动画时，都会播放过渡动画。
- en: '![](img/7ba7418f-25c1-475f-8a03-917cf01aae30.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7ba7418f-25c1-475f-8a03-917cf01aae30.png)'
- en: On the other hand, with 3D characters we can use the bone structure to create
    the transitions automatically, where the coordinates for each bone will move from
    the previous animation to the new one. Even if we choose to use the bone structure
    to help create the transitions, sometimes it might be necessary, or it would be
    a better option, to manually create new animations that will be used as transitions.
    This is a common process if the character is using an object or weapon that needs
    to be saved before playing the next animation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对于3D角色，我们可以使用骨骼结构自动创建过渡，其中每个骨骼的坐标将从上一个动画移动到新的动画。即使我们选择使用骨骼结构来帮助创建过渡，有时可能有必要，或者这可能是更好的选择，手动创建新的动画作为过渡。如果角色在使用需要保存到下一个动画之前使用的对象或武器，这是一个常见的流程。
- en: '![](img/7f36b03b-a82f-4294-b741-27a4c9d88161.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7f36b03b-a82f-4294-b741-27a4c9d88161.png)'
- en: To create a smooth transition, we need the first frame of the next animation
    to be equal to the last frame of the current animation. We need to start the next
    animation from the same position of the current one. This is crucial to avoid
    noticing any cut in between the transition. Then we can use the game engine to
    our advantage and use the transition system for the animations. This will help
    to create a smoother transition. As we can see on the image above, we can adjust
    how long the transition will take, we can make a quick transition or a longer
    one, always experimenting with what looks better for the results that we want.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建平滑的过渡，我们需要下一个动画的第一帧与当前动画的最后一帧相等。我们需要从当前动画的相同位置开始下一个动画。这是避免在过渡过程中注意到任何断裂的关键。然后我们可以利用游戏引擎的优势，使用过渡系统来处理动画。这将有助于创建更平滑的过渡。正如我们上图所看到的，我们可以调整过渡将持续多长时间，我们可以创建一个快速过渡或一个较长的过渡，始终尝试哪种方式对我们想要的结果看起来更好。
- en: Sometimes we would need to sacrifice a smoother transition in order to have
    a better gameplay experience. One example of this is during a fighting game, where
    it's more important to have quick transitions rather than smooth ones, and for
    that reason we need to take in consideration the time that it takes for the character
    to change from one state to another.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，为了获得更好的游戏体验，我们需要牺牲更平滑的过渡。一个例子是在格斗游戏中，快速过渡比平滑过渡更重要，因此我们需要考虑角色从一个状态转换到另一个状态所需的时间。
- en: Summary
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has described how to use 2D or 3D animations to complement the
    actions of a character. Animations play an important part in the development of
    a believable AI character, and by using them correctly, the character can transmit
    to the player a real sensation that the character is alive and that they react
    autonomously. Even if the character has limited actions, we can use animations
    to fake or hide some of them, giving the impression that it is reacting that way
    because it thinks for itself.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何使用二维或三维动画来补充角色的动作。动画在可信的AI角色开发中扮演着重要的角色，并且通过正确使用它们，角色可以向玩家传达一种角色是活生生的，并且能够自主反应的真实感觉。即使角色动作有限，我们也可以使用动画来模拟或隐藏其中的一些，给人一种角色这样反应是因为它在自己思考的印象。
- en: In the next chapter, we'll be talking about navigation behavior and pathfinding,
    that is how to program the AI character to walk towards the desired position and
    choose the best route.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论导航行为和路径查找，即如何编程AI角色走向目标位置并选择最佳路线。
