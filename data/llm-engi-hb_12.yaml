- en: Appendix
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: MLOps Principles
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MLOps原则
- en: Building robust and scalable ML systems requires more than creating powerful
    models. It demands an all-encompassing approach to operationalizing the entire
    ML lifecycle. Let’s explore the **six core principles** that guide the MLOps field.
    These principles are independent of any tool and are at the core of building robust
    and scalable ML systems. They provide a guideline for designing production-ready
    applications, ensuring consistency, reliability, and scalability at every stage.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 构建稳健且可扩展的机器学习系统不仅需要创建强大的模型，还需要对整个机器学习生命周期进行全面的实施方法。让我们探讨指导MLOps领域的**六个核心原则**。这些原则与任何工具无关，是构建稳健且可扩展机器学习系统的核心。它们为设计生产就绪的应用程序提供指导，确保在各个阶段的一致性、可靠性和可扩展性。
- en: 'With that in mind, let’s begin with the foundation: automation or operationalization.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们从基础开始：自动化或运营化。
- en: 1\. Automation or operationalization
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 自动化或运营化
- en: 'To adopt MLOps, there are three core tiers that most applications build up
    gradually, from manual processing to full automation:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要采用MLOps，大多数应用程序会逐步构建三个核心层级，从手动处理到完全自动化：
- en: '**Manual process**: The process is experimental and iterative in the early
    stages of developing an ML application. The data scientist manually performs each
    pipeline step, such as data preparation and validation, model training, and testing.
    At this point, they commonly use Jupyter notebooks to train their models. This
    stage’s output is the code used to prepare the data and train the models.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手动流程**：在开发机器学习应用的早期阶段，该流程是实验性和迭代的。数据科学家手动执行每个管道步骤，例如数据准备和验证、模型训练和测试。在这个阶段，他们通常使用Jupyter笔记本来训练他们的模型。这一阶段的输出是用于准备数据和训练模型的代码。'
- en: '**Continuous** **training** (**CT**): The next level involves automating model
    training. This is known as continuous training, which triggers model retraining
    whenever required. At this point, you often automate your data and model validation
    steps. This step is usually done by an orchestration tool, such as ZenML, that
    glues all your code together and runs it on specific triggers. The most common
    triggers are on a schedule, for example, every day or when a specific event comes
    in, such as when new data is uploaded or the monitoring system detects a drop
    in performance, offering you the flexibility to adapt to various triggers.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续** **训练** (**CT**)：下一级涉及自动化模型训练。这被称为持续训练，它会在需要时触发模型重新训练。在这个阶段，你通常会自动化你的数据和模型验证步骤。这一步通常由一个编排工具，如ZenML，来完成，它将所有代码粘合在一起并在特定的触发器上运行。最常见的触发器是按计划，例如每天或当发生特定事件时，例如新数据上传或监控系统检测到性能下降，这为你提供了适应各种触发器的灵活性。'
- en: '**CI/CD**: In the final stage, you implement your CI/CD pipelines to enable
    fast and reliable deployment of your ML code into production. The key advancement
    at this stage is the automatic building, testing, and deployment of data, ML models,
    and training pipeline components. CI/CD is used to quickly push new code into
    various environments, such as staging or production, ensuring efficient and reliable
    deployment.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CI/CD**：在最终阶段，你实施CI/CD管道，以实现将你的机器学习代码快速且可靠地部署到生产环境。这一阶段的关键进步是自动构建、测试和部署数据、机器学习模型和训练管道组件。CI/CD用于快速将新代码推送到各种环境，如预发布或生产环境，确保高效且可靠的部署。'
- en: As we build our LLM system using the **FTI** (**feature**, **training**, **inference**)
    architecture, we can quickly move from a manual process to CI/CD/CT. In *Figure
    A.1*, we can observe that the CT process can be triggered by various events, such
    as a drop in performance detected by the monitoring pipeline or a batch of fresh
    data arriving. Also, *Figure A.1* is split into two main sections; the first one
    highlights the automated processes, while at the bottom, we can observe the manual
    processes performed by the data science team while experimenting with various
    data processing methods and models. Once they improve the model by tinkering with
    how the data is processed or the model architecture, they push the code to the
    code repository, which triggers the CI/CD pipeline to build, test, package, and
    deploy the new changes to the FTI pipelines.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用**FTI**（**特征**、**训练**、**推理**）架构构建我们的LLM系统时，我们可以快速地从手动流程过渡到CI/CD/CT。在*图A.1*中，我们可以观察到CT流程可以被各种事件触发，例如监控管道检测到的性能下降或一批新数据的到达。此外，*图A.1*被分为两个主要部分；第一个部分突出了自动化流程，而在底部，我们可以观察到数据科学团队在尝试各种数据处理方法和模型时进行的手动流程。一旦他们通过调整数据处理方式或模型架构来改进模型，他们就会将代码推送到代码仓库，这会触发CI/CD流程来构建、测试、打包并将新更改部署到FTI管道中。
- en: '![](img/B31105_12_01.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31105_12_01.png)'
- en: 'Figure A.1: CI/CD/CT on top of the FTI architecture'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.1：FTI架构上的CI/CD/CT
- en: To conclude, CT automates the FTI pipelines, while CI/CD builds, tests, and
    pushes new versions of the FTI pipeline code to production.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，CT自动化FTI管道，而CI/CD构建、测试并将FTI管道代码的新版本推送到生产环境中。
- en: 2\. Versioning
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 版本控制
- en: By now, we understand that the whole ML system changes if the code, model, or
    data changes. Thus, it is critical to track and version these three elements individually.
    But what strategies can we adopt to track the code, model, and data separately?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解到如果代码、模型或数据发生变化，整个ML系统都会发生变化。因此，跟踪和单独版本控制这三个元素至关重要。但我们能采用哪些策略来分别跟踪代码、模型和数据？
- en: The **code** is tracked by Git, which helps us create a new commit (a snapshot
    of the code) on every change added to the codebase. Also, Git-based tools usually
    allow us to make releases, which typically pack multiple features and bug fixes.
    While the commits contain unique identifiers that are not human-interpretable,
    a release follows more common conventions based on their major, minor, and patch
    versions. For example, in a release with version “v1.2.3,” 1 is the major version,
    2 is the minor version, and 3 is the patch version. Popular tools are GitHub and
    GitLab.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码**通过Git进行跟踪，这有助于我们在代码库中添加每个更改时创建一个新的提交（代码的快照）。此外，基于Git的工具通常允许我们进行发布，通常包含多个功能和错误修复。虽然提交包含独特的标识符，这些标识符对人类不可解释，但发布遵循基于它们的重大、次要和修补版本的更常见约定。例如，在版本为“v1.2.3”的发布中，1是主版本，2是次要版本，3是修补版本。流行的工具包括GitHub和GitLab。'
- en: To version the **model**, you leverage the model registry to store, share, and
    version all the models used within your system. It usually follows the same versioning
    conventions used in code releases, defined as **Semantic Versioning**, which,
    along with the major, minor, and patch versions, also supports alpha and beta
    releases that signal applications. At this point, you can also leverage the ML
    metadata store to attach information to the stored model, such as what data it
    was trained on, its architecture, performance, latency, and whatever else makes
    sense to your specific use case. Doing so creates a clear catalog of models that
    can easily be navigated across your team and company.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要对**模型**进行版本控制，你可以利用模型注册表来存储、共享和版本化系统中使用的所有模型。它通常遵循与代码发布相同的版本控制约定，定义为**语义版本控制**，它除了主版本、次要版本和修补版本之外，还支持alpha和beta发布，这些发布向应用程序发出信号。在此阶段，你还可以利用ML元数据存储将信息附加到存储的模型上，例如它是在什么数据上训练的、其架构、性能、延迟以及对你特定用例有意义的任何其他信息。这样做可以创建一个清晰的模型目录，可以轻松地在你的团队和公司中导航。
- en: Versioning the **data** isn’t as straightforward as versioning the code and
    model because it depends on the type of data you have (structured or unstructured)
    and the scale of data you have (big or small). For example, for structured data,
    you can leverage a SQL database with a version column that helps you track the
    changes in the dataset. However, other popular solutions are based on Git-like
    systems, such as **Data Version Control** (**DVC**), that track every change made
    to the dataset. Other trendy solutions are based on artifacts similar to a model
    registry that allows you to add a virtual layer to your dataset, tracking and
    creating a new version for every change made to your data. Comet.ml, **W&B** (**Weights
    & Biases**), and ZenML offer powerful artifact features. For all solutions, you
    must store the data on-premises or use cloud object storage solutions such as
    AWS S3\. These tools provide features that allow you to structure your datasets
    and versions, track, and access them.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制**数据**并不像版本控制代码和模型那样直接，因为它取决于你所拥有的数据类型（结构化或非结构化）以及数据规模（大或小）。例如，对于结构化数据，你可以利用带有版本列的SQL数据库来跟踪数据集的变化。然而，其他流行的解决方案基于类似于Git的系统，如**数据版本控制**（**DVC**），它跟踪数据集的每一个变化。其他流行的解决方案基于类似于模型注册表的工件，它允许你为你的数据集添加一个虚拟层，跟踪并创建每次对数据进行更改时的新版本。Comet.ml、**W&B**（**权重与偏差**）、ZenML提供了强大的工件功能。对于所有解决方案，你必须将数据存储在本地或使用如AWS
    S3之类的云对象存储解决方案。这些工具提供了允许你结构化你的数据集和版本、跟踪和访问它们的功能。
- en: 3\. Experiment tracking
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 实验跟踪
- en: Training ML models is an entirely iterative and experimental process. Unlike
    traditional software development, it involves running multiple parallel experiments,
    comparing them based on a set of predefined metrics, and deciding which one should
    advance to production. An experiment tracking tool allows you to log all the necessary
    information, such as metrics and visual representations of your model predictions,
    to compare all your experiments and easily select the best model. Popular tools
    are Comet ML, W&B, MLflow, and Neptune.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 训练机器学习模型是一个完全迭代和实验的过程。与传统的软件开发不同，它涉及运行多个并行实验，根据一组预定义的指标进行比较，并决定哪一个应该推进到生产。实验跟踪工具允许你记录所有必要的信息，例如模型预测的指标和可视化表示，以便比较所有实验并轻松选择最佳模型。流行的工具包括Comet
    ML、W&B、MLflow和Neptune。
- en: 4\. Testing
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 测试
- en: 'The same trend is followed when testing ML systems. Hence, we must test our
    application across all three dimensions: the data, the model, and the code. We
    must also ensure that the feature, training, and inference pipeline are well integrated
    with external services, such as the feature store, and work together as a system.
    When working with Python, the most common tool to write your tests is `pytest`,
    which we also recommend.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试机器学习系统时，遵循相同的趋势。因此，我们必须在所有三个维度上测试我们的应用程序：数据、模型和代码。我们还必须确保特征、训练和推理管道与外部服务（如特征存储）良好集成，并作为一个系统协同工作。当使用Python时，编写测试最常用的工具是`pytest`，我们也推荐使用它。
- en: Test types
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试类型
- en: 'In the development cycle, six primary types of tests are commonly employed
    at various stages:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发周期中，六个主要类型的测试在各个阶段被普遍采用：
- en: '**Unit tests**: These tests focus on individual components with a single responsibility,
    such as a function that adds two tensors or one that finds an element in a list.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：这些测试专注于具有单一职责的个别组件，例如一个添加两个张量的函数或一个在列表中查找元素的函数。'
- en: '**Integration tests**: These tests evaluate the interaction between integrated
    components or units within a system, such as the data evaluation pipeline or the
    feature engineering pipeline, and how they are integrated with the data warehouse
    and feature store.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：这些测试评估系统内集成组件或单元之间的交互，例如数据评估管道或特征工程管道，以及它们如何与数据仓库和特征存储集成。'
- en: '**System tests**: System tests play a crucial role in the development cycle
    as they examine the entire system, including the complete and integrated application.
    These tests rigorously evaluate the end-to-end functionality of the system, including
    performance, security, and overall user experience—for example, testing an entire
    ML pipeline, from data ingestion to model training and inference, ensuring the
    system produces the correct outputs for given inputs.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统测试**: 系统测试在开发周期中扮演着至关重要的角色，因为它们检查整个系统，包括完整和集成的应用程序。这些测试严格评估系统的端到端功能，包括性能、安全性和整体用户体验——例如，测试整个机器学习管道，从数据摄取到模型训练和推理，确保系统对于给定的输入产生正确的输出。'
- en: '**Acceptance tests**: These tests, often called **user acceptance testing**
    (**UAT**), are designed to confirm that the system meets specified requirements,
    ensuring it is ready for deployment.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验收测试**: 这些测试通常被称为**用户验收测试**（UAT），旨在确认系统满足指定的要求，确保其可以部署。'
- en: '**Regression tests**: These tests check for previously identified errors to
    ensure that new changes do not reintroduce them.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回归测试**: 这些测试检查以前识别的错误，以确保新的更改不会重新引入它们。'
- en: '**Stress tests**: These tests evaluate the system’s performance and stability
    under extreme conditions, such as high load or limited resources. They aim to
    identify breaking points and ensure the system can handle unexpected spikes in
    demand or adverse situations without failing.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压力测试**: 这些测试评估系统在极端条件下的性能和稳定性，例如高负载或资源有限。它们的目的是识别故障点，并确保系统在需求意外激增或不利情况下不会失败。'
- en: '![](img/B31105_12_02.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B31105_12_02.png)'
- en: 'Figure A.2: Test types'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.2：测试类型
- en: We’ve intentionally left regression tests out of the preceding figure because
    they aren’t a distinct testing phase. Instead, regression testing is applied across
    all levels—unit, integration, system, acceptance, and stress tests—to ensure that
    changes don’t reintroduce previous errors. It’s an ongoing process within these
    phases, not a separate type of test, which is why it’s not shown as a separate
    category.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意在先前的图中省略了回归测试，因为它们不是一个独立的测试阶段。相反，回归测试应用于所有级别——单元、集成、系统、验收和压力测试——以确保更改不会重新引入以前的错误。这是一个在这些阶段中的持续过程，而不是一种单独的测试类型，这就是为什么它没有作为一个单独的类别显示。
- en: What do we test?
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们要测试什么？
- en: 'When writing most tests, you take a component and treat it as a black box.
    Thus, what you have control over is the input and output. You want to test that
    you get an expected output for a given input. With that in mind, here are a few
    things you should usually test:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写大多数测试时，您将一个组件视为一个黑盒。因此，您能控制的是输入和输出。您想要测试的是对于给定的输入，您是否得到了预期的输出。考虑到这一点，以下是一些您通常应该测试的内容：
- en: '**Inputs**: Data types, format, length, and edge cases (min/max, small/large,
    etc.)'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入**: 数据类型、格式、长度和边缘情况（最小/最大、小/大等）'
- en: '**Outputs**: Data types, formats, exceptions, and intermediary and final outputs'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出**: 数据类型、格式、异常、中间和最终输出'
- en: Test examples
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试示例
- en: When testing your code, you can leverage the standards from classic software
    engineering. Here are a few examples of code tests you can include when writing
    unit tests to get a better idea of what we want to test at this point—for instance,
    you want to check that a sentence is cleaned as expected.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试您的代码时，您可以利用经典软件工程的标准。以下是一些您在编写单元测试时可以包含的代码测试示例，以更好地了解我们在这个阶段想要测试的内容——例如，您想要检查一个句子是否按预期清理。
- en: Also, you can look at your chunking algorithm and assert that it works properly
    by using various sentences and chunk sizes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以查看您的分块算法，并通过使用各种句子和分块大小来断言它是否正常工作。
- en: When we talk about **data** **tests**, we mainly refer to data validity. Your
    data validity code usually runs when raw data is ingested from the data warehouse
    or after computing the features. It is part of the feature pipeline. Thus, by
    writing integration or system tests for your feature pipeline, you can check that
    your system responds properly to valid and invalid data.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论**数据**测试时，我们主要指的是数据的有效性。您的数据有效性代码通常在从数据仓库摄取原始数据或计算特征后运行。它是特征管道的一部分。因此，通过为您的特征管道编写集成或系统测试，您可以检查系统对有效和无效数据的响应是否正确。
- en: Testing data validity depends a lot on your application and data type. For example,
    when working with tabular data, you can check for non-null values, that a categorical
    variable contains only the expected values, or that a float value is always positive.
    You can check for length, character encoding, language, special characters, and
    grammar errors when working with unstructured data such as text.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 测试数据的有效性很大程度上取决于你的应用程序和数据类型。例如，当处理表格数据时，你可以检查非空值，一个分类变量只包含预期的值，或者一个浮点值始终为正。当处理文本等非结构化数据时，你可以检查长度、字符编码、语言、特殊字符和语法错误。
- en: '**Model tests** are the trickiest, as model training is the most non-deterministic
    process of an ML system. However, unlike traditional software, ML systems can
    successfully complete without throwing any errors. However, the real issue is
    that they produce incorrect results that can only be observed during evaluations
    or tests. Some standard model test techniques involve checking:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型测试**是最棘手的，因为模型训练是机器学习系统中最非确定性的过程。然而，与传统软件不同，机器学习系统可以成功完成而不会抛出任何错误。然而，真正的问题是它们会产生只有在评估或测试期间才能观察到的错误结果。一些标准的模型测试技术包括检查：'
- en: The shapes of the input and model output tensors
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入和模型输出张量的形状
- en: That the loss decreases after one batch (or more) of training
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个批次（或更多）的训练后损失减少
- en: Overfit on a small batch, and the loss approaches 0
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在小批次上过度拟合，损失接近0
- en: That your training pipeline works on all the supported devices, such as the
    CPU and GPU
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的训练管道可以在所有支持的设备上工作，例如CPU和GPU
- en: That your early stopping and checkpoint logic works
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的早期停止和检查点逻辑正常工作
- en: All the tests are triggered inside the CI pipeline. If some tests are more costly,
    for example, the model ones, you can execute them only on special terms, such
    as only when modifying the model code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试都是在CI管道内部触发的。如果某些测试成本较高，例如模型测试，你可以在特殊条件下执行它们，例如仅在修改模型代码时。
- en: 'At the other end of the spectrum, you can also perform **behavioral testing**
    on your **model**, which tries to adopt the strategy from code testing and treats
    the model as a black box while looking solely at the input data and expected outputs.
    This makes the behavioral testing methods model agnostic. A fundamental paper
    in this area is *Beyond Accuracy: Behavioral Testing of NLP Models with CheckList*,
    which we recommend if you want to dig more into the subject. However, as a quick
    overview, the paper proposes that you test your model against three types of tests.
    We use a model that extracts the main subject from a sentence as an example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在光谱的另一端，你也可以对你的**模型**进行**行为测试**，这试图采用代码测试的策略，将模型视为黑盒，在查看输入数据和预期输出时仅关注输入数据。这使得行为测试方法对模型无感知。该领域一篇基础论文是《超越准确性：使用CheckList对NLP模型进行行为测试》，如果你想要深入了解这个主题，我们推荐这篇论文。然而，作为一个快速概述，该论文提出你应该对你的模型进行三种类型的测试。我们以一个从句子中提取主要主题的模型为例：
- en: '**Invariance**: Changes in your input should not affect the output—for example,
    below is an example based on synonym injection:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不变性**：输入的变化不应该影响输出——例如，以下是基于同义词注入的示例：'
- en: '[PRE0]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Directional**: Changes in your input should affect the outputs—for example,
    below is an example where we know the outputs should change based on the provided
    inputs:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方向性**：输入的变化应该影响输出——例如，以下是一个我们知道输出应该基于提供的输入而变化的示例：'
- en: '[PRE1]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Minimum functionality**: The most simple combination of inputs and expected
    outputs—for example, below is a set of simple examples that we expect the model
    should always get right:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小功能**：输入和预期输出的最简单组合——例如，以下是一组我们期望模型始终能够正确处理的简单示例：'
- en: '[PRE2]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For more on testing, we recommend reading *Testing Machine Learning Systems:
    Code, Data, and Models* by Goku Mohandas: [https://madewithml.com/courses/mlops/testing/](https://madewithml.com/courses/mlops/testing/).'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于测试的更多信息，我们推荐阅读Goku Mohandas所著的《测试机器学习系统：代码、数据和模型》：[https://madewithml.com/courses/mlops/testing/](https://madewithml.com/courses/mlops/testing/).
- en: 5\. Monitoring
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 监控
- en: Monitoring is vital for any ML system that reaches production. Traditional software
    systems are rule-based and deterministic. Thus, once it is built, it will always
    work as defined. Unfortunately, that is not the case with ML systems. When implementing
    ML models, we haven’t explicitly described how they should work. We have used
    data to compile a probabilistic solution, which means that our ML model will constantly
    be exposed to a level of degradation. This happens because the data from production
    might differ from the data the model was trained on. Thus, it is natural that
    the shipped model doesn’t know how to handle these scenarios.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 监控对于任何达到生产阶段的机器学习系统至关重要。传统的软件系统是基于规则和确定性的。因此，一旦构建完成，它将始终按定义工作。不幸的是，机器学习系统并非如此。在实施机器学习模型时，我们没有明确描述它们应该如何工作。我们使用数据来编译一个概率解决方案，这意味着我们的机器学习模型将不断面临降级的风险。这是因为生产中的数据可能与模型训练时的数据不同。因此，交付的模型不知道如何处理这些场景是自然的。
- en: We shouldn’t try to avoid these situations but create a strategy to catch and
    fix these errors in time. Intuitively, monitoring detects the model’s performance
    degradation, which triggers an alarm that signals that the model should be retrained
    manually, automatically, or with a combination of both.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该试图避免这些情况，而应该制定一个策略来及时捕捉和修复这些错误。直观地说，监控检测到模型性能下降，这会触发一个警报，表明模型应该手动、自动或两者结合重新训练。
- en: '*Why retrain the model?* As the model performance degrades due to a drift in
    the training dataset and what it inputs from production, the only solution is
    to adapt or retrain the model on a new dataset that captures all the new scenarios
    from production.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么要重新训练模型？* 由于训练数据集的漂移和从生产中输入的内容，模型性能下降，唯一的解决方案是在一个新数据集上调整或重新训练模型，该数据集捕获了生产中的所有新场景。'
- en: As training is a costly operation, there are some tricks that you can perform
    to avoid retraining, but before describing them, let’s quickly understand what
    we can monitor to understand our ML system’s health.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 训练是一个成本高昂的操作，有一些技巧可以避免重新训练，但在描述它们之前，让我们快速了解我们可以监控什么来了解我们的机器学习系统的健康状况。
- en: Logs
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志
- en: 'The approach to logging is straightforward, which is to capture everything,
    such as:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录的方法很简单，即捕获一切，例如：
- en: Document the system configurations.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录系统配置。
- en: Record the query, the results, and any intermediate outputs.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录查询、结果以及任何中间输出。
- en: Log when a component begins, ends, crashes, and so on.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录组件开始、结束、崩溃等情况。
- en: Ensure that each log entry is tagged and identified in a way that clarifies
    its origin within the system.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保每个日志条目都带有标签并按一种方式标识，以便阐明其在系统中的来源。
- en: While capturing all activities can rapidly increase the volume of logs, you
    can take advantage of numerous tools for automated log analysis and anomaly detection
    that leverage AI to efficiently scan all the logs, providing you with the confidence
    to manage the logs effectively.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然捕获所有活动可以迅速增加日志量，但你可以利用众多工具进行自动日志分析和异常检测，这些工具利用AI高效地扫描所有日志，为你提供有效管理日志的信心。
- en: Metrics
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指标
- en: To quantify your application’s healthiness, you must define a set of metrics.
    Each metric measures different aspects of your application, such as the infrastructure,
    data, and model.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了量化应用程序的健康状况，你必须定义一组指标。每个指标衡量应用程序的不同方面，例如基础设施、数据和模型。
- en: System metrics
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统指标
- en: The system metrics are based on monitoring service-level metrics (latency, throughput,
    error rates) and infrastructure health (CPU/GPU, memory). These metrics are used
    both in traditional software and ML as they are crucial to understanding whether
    the infrastructure works well and the system works as expected to provide a good
    user experience to the end users.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 系统指标基于监控服务级别指标（延迟、吞吐量、错误率）和基础设施健康（CPU/GPU、内存）。这些指标在传统软件和机器学习中都至关重要，因为它们对于理解基础设施是否运行良好以及系统是否按预期工作以提供良好的用户体验至关重要。
- en: Model metrics
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型指标
- en: Merely monitoring the system’s health won’t suffice to identify the deeper issues
    within our model. Therefore, moving on to the next layer of metrics that focus
    on the model’s performance is crucial. This includes quantitative evaluation metrics
    like accuracy, precision, and F1 score, as well as essential business metrics
    influenced by the model, such as ROI and click rate.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 仅监控系统的健康状况不足以识别我们模型中的深层问题。因此，转向下一层指标，这些指标专注于模型的性能至关重要。这包括定量评估指标，如准确率、精确率和F1分数，以及受模型影响的业务指标，如投资回报率和点击率。
- en: Analyzing cumulative performance metrics over the entire deployment period is
    often ineffective. Instead, evaluating performance over time intervals relevant
    to our application, such as hourly, is essential. Thus, in practice, you window
    your inputs and compute and aggregate the metrics at the window level. These sliding
    metrics can provide a clearer picture of the system’s health, allowing us to detect
    issues more promptly without them being obscured by historical data.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 分析整个部署期间的累积性能指标通常效果不佳。相反，评估与我们的应用相关的特定时间间隔的性能，例如每小时，是至关重要的。因此，在实践中，你会在窗口级别对输入进行窗口化，并计算和汇总指标。这些滑动指标可以提供系统健康状况的更清晰图景，使我们能够更及时地检测问题，而这些问题不会被历史数据所掩盖。
- en: We may not always have access to ground-truth outcomes to evaluate the model’s
    performance on production data. This is particularly challenging when there is
    a significant delay or when real-life data requires annotation. To address this
    issue, we can develop an approximate signal to estimate the model’s performance
    or label a small portion of our live dataset to assess performance. When talking
    about ML monitoring, an approximate signal is also known as a **proxy metric**,
    usually implemented by drift detection methods, which are discussed in the following
    section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能无法始终访问真实结果来评估模型在生产数据上的性能。这在存在重大延迟或现实生活中的数据需要标注时尤其具有挑战性。为了解决这个问题，我们可以开发一个近似信号来估计模型的性能，或者对一小部分实时数据集进行标注以评估性能。在谈论机器学习监控时，近似信号也被称为**代理指标**，通常由漂移检测方法实现，这些方法将在下一节中讨论。
- en: Drifts
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Drifts
- en: '**Drifts** are proxy metrics that help us detect potential issues with the
    production model in time without requiring any ground truths/labels. *Table A.1*
    shows three kinds of drifts.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**Drifts**是代理指标，帮助我们及时检测生产模型中可能存在的问题，而无需任何真实值/标签。*表A.1*显示了三种类型的漂移。'
- en: '| **What drifts** | **Description** | **Drift formulation** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **What drifts** | **Description** | **Drift formulation** |'
- en: '| ![](img/B31105_12_001.png) | Inputs (features) | ![](img/B31105_12_002.png)
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/B31105_12_001.png) | 输入（特征） | ![](img/B31105_12_002.png) |'
- en: '| ![](img/B31105_12_003.png) | Outputs (ground truths/labels) | ![](img/B31105_12_004.png)
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/B31105_12_003.png) | 输出（真实值/标签） | ![](img/B31105_12_004.png) |'
- en: '| ![](img/B31105_12_005.png) | ![](img/B31105_12_006.png) | ![](img/B31105_12_007.png)
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/B31105_12_005.png) | ![](img/B31105_12_006.png) | ![](img/B31105_12_007.png)
    |'
- en: 'Table A.1: Relationship between data, model, and code changes'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 表A.1：数据、模型和代码更改之间的关系
- en: Data drift
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Data drift
- en: Data drift, also called feature drift or covariate shift, occurs when the distribution
    of the production data deviates from that of the training data, as shown in *Figure
    A.3*. This difference means the model cannot handle the changes in feature space,
    leading to potentially unreliable predictions. Drift can result from natural real-life
    changes or systemic problems like missing data, pipeline errors, and schema modifications.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 数据漂移，也称为特征漂移或协变量偏移，发生在生产数据的分布偏离训练数据分布时，如图A.3所示。这种差异意味着模型无法处理特征空间中的变化，导致可能不可靠的预测。漂移可能源于自然现实生活中的变化或系统问题，如数据缺失、管道错误和模式修改。
- en: '![](img/B31105_12_03.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31105_12_03.png)'
- en: 'Figure A.3: Data drift examples'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.3：数据漂移示例
- en: When data begins to drift, the degradation in our model’s performance might
    not be immediately noticeable, particularly if the model interpolates effectively.
    Nevertheless, this presents an ideal chance to consider retraining before the
    drift affects the model’s performance.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据开始漂移时，我们模型性能的下降可能不会立即明显，尤其是如果模型插值效果良好。然而，这提供了一个理想的机会，在漂移影响模型性能之前考虑重新训练。
- en: Target drift
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Target drift
- en: In addition to changes in input data (data drift), we might also encounter shifts
    in output distribution. The shift could involve changes in the shape of the distribution
    or the addition and removal of classes in categorical tasks. While retraining
    the model can help reduce performance degradation due to target drift, you can
    often prevent it by adapting the head processing steps and model head to support
    the new schema of the output class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 除了输入数据（数据漂移）的变化之外，我们还可能遇到输出分布的偏移。这种偏移可能涉及分布形状的变化或在分类任务中类别的增加和删除。虽然重新训练模型可以帮助减少由于目标漂移导致的性能下降，但通过调整头部处理步骤和模型头部以支持输出类的新架构，通常可以预防它。
- en: For example, if you have a classifier that predicts if an image contains animals
    or people, and you get a picture with buildings, you can either adapt your model
    to support an unknown class or adjust the head of the model to add the new class
    for future predictions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有一个预测图像是否包含动物或人类的分类器，而你得到的是一些建筑物的图片，你可以调整你的模型以支持未知类别，或者调整模型的头部以添加新的类别以供未来的预测。
- en: Concept drift
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 概念漂移
- en: 'In addition to changes in input and output data, their relationship can also
    shift. This phenomenon, known as **concept drift**, makes our model ineffective
    because the patterns it previously learned to associate inputs with outputs become
    outdated. As illustrated in the following figure, concept drifts can manifest
    in various ways:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 除了输入和输出数据的变化，它们之间的关系也可能发生变化。这种现象被称为**概念漂移**，使得我们的模型变得无效，因为之前学会将输入与输出关联的模式已经过时。如图所示，概念漂移可以以各种方式表现出来：
- en: Gradually over time
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着时间的推移逐渐
- en: Suddenly, due to an external event
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 突然，由于外部事件
- en: Periodically, due to recurring events
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期，由于重复发生的事件
- en: '![](img/B31105_12_04.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B31105_12_04.png)'
- en: 'Figure A.4: Concept drift examples'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.4：概念漂移示例
- en: For example, this happens when using the model in a different geographic area.
    Let’s assume you want to build a model that predicts whether a person will buy
    a specific car. You initially built it for the American market. Now, you want
    to use it in the European market, where people tend to buy smaller cars, creating
    a drift between the size feature of the car and the output probability of purchasing
    the vehicle. Of course, concept drifts can be more subtle than this example.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当在不同的地理区域使用模型时，这种情况会发生。假设你想要构建一个预测某人是否会购买特定汽车的模型。你最初是为美国市场构建的。现在，你想要在欧洲市场使用它，那里的人们倾向于购买更小的汽车，这会在汽车的大小特征和购买车辆的概率输出之间产生漂移。当然，概念漂移可能比这个例子更微妙。
- en: All these types of drift can happen simultaneously, complicating pinpointing
    the exact sources of drift.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些类型的漂移都可能同时发生，这使得确定漂移的确切来源变得复杂。
- en: How to detect and measure drifts
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 如何检测和衡量漂移
- en: 'Now that we’ve recognized the various types of drift, it’s crucial to understand
    how to detect and measure it. To do so, you need two types of windows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经识别了各种类型的漂移，了解如何检测和衡量它就变得至关重要。为此，你需要两种类型的窗口：
- en: '**A reference window**: This is the collection of data points used as a baseline
    to compare against the production data distributions for drift identification.
    It is usually gathered from the training dataset.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参考窗口**：这是用作基准来比较生产数据分布以识别漂移的数据点集合。它通常来自训练数据集。'
- en: '**A test window**: This collects data points gathered while the ML system is
    in production. It is compared with the reference window to ascertain if drift
    has occurred.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试窗口**：这是在ML系统处于生产状态时收集的数据点。它被与参考窗口比较，以确定是否发生了漂移。'
- en: To measure the drifts, you leverage hypothesis tests that verify the change
    in distribution between the two windows. For example, you can use the **Kolmogorov-Smirnov**
    (**KS**) test to monitor a single continuous feature. This is known as a **univariate**
    (**1D**) test. Thus, you must run it for every feature you want to monitor. You
    can leverage a chi-squared univariate test to monitor categorical variables and
    determine if the frequency of events in production is consistent with the reference
    window distribution.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了衡量漂移，你利用假设检验来验证两个窗口之间分布的变化。例如，你可以使用**科尔莫哥洛夫-斯米尔诺夫**（**KS**）检验来监控单个连续特征。这被称为**单变量**（**1D**）检验。因此，你必须为每个你想要监控的特征运行它。你可以利用卡方单变量检验来监控分类变量，并确定生产中事件的发生频率是否与参考窗口分布一致。
- en: '[PRE3]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When working with text data in an embedding representation, we have to model
    a multivariate distribution, which is how LLMs work with text. A popular approach
    is to take the embeddings of the test and reference windows, apply a dimensionality
    reduction algorithm, and apply an algorithm such as **maximum mean discrepancy**
    (**MMD**). This algorithm is a kernel-based approach that measures the distance
    between two distributions by computing the distance between the mean of the embeddings
    of the two windows.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用嵌入表示的文本数据时，我们必须建模一个多元分布，这就是LLMs如何处理文本的方式。一种流行的方法是取测试窗口和参考窗口的嵌入，应用降维算法，然后应用如**最大均值差异**（**MMD**）之类的算法。这是一种基于核的方法，通过计算两个窗口嵌入的平均值之间的距离来衡量两个分布之间的距离。
- en: '[PRE4]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Monitoring vs. observability
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监控与可观察性
- en: Monitoring involves the collection and visualization of data, whereas observability
    provides insights into system health by examining its inputs and outputs. For
    instance, monitoring allows us to track a specific metric to detect potential
    issues.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 监控涉及数据的收集和可视化，而可观察性通过检查系统的输入和输出来提供对系统健康状况的见解。例如，监控使我们能够跟踪特定的指标以检测潜在的问题。
- en: On the other hand, a system is considered observable if it generates meaningful
    data about its internal state, which is essential for diagnosing root causes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果一个系统生成有关其内部状态的有意义数据，那么它被认为是可观察的，这对于诊断根本原因至关重要。
- en: Alerts
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警报
- en: 'Once we define our monitoring metrics, we need a way to get notified. The most
    common approaches are to send an alarm in the following scenarios:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了我们的监控指标，我们需要一种被通知的方式。最常见的方法是在以下场景下发送警报：
- en: A metric passes the values of a static threshold—for example, when the accuracy
    of the classifier is lower than 0.8, send an alarm.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指标通过了静态阈值的值——例如，当分类器的准确率低于0.8时，发送警报。
- en: Tweaking the p-value of the statistical tests that check for drifts. A lower
    p-value means a higher confidence that the production distribution differs from
    the reference one.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整检查漂移的统计测试的p值。较低的p值意味着对生产分布与参考分布不同的置信度更高。
- en: These thresholds and p-values depend on your application. However, it is essential
    to find the correct values, as you don’t want to overcrowd your alarming system
    with false positives. In that case, your alarm system won’t be trustworthy, and
    you will either overreact or not react at all to issues in your system. Some common
    channels for sending alarms to your stakeholders are Slack, Discord, your email,
    and PagerDuty. The system’s stakeholders can be the core engineers, managers,
    or anyone interested in the system.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些阈值和p值取决于您的应用。然而，找到正确的值至关重要，您不希望您的警报系统因为误报而过于拥挤。在这种情况下，您的警报系统将不可信，您可能会对系统中的问题反应过度或完全无动于衷。向您的利益相关者发送警报的一些常见渠道包括Slack、Discord、您的电子邮件和PagerDuty。系统的利益相关者可以是核心工程师、经理或任何对系统感兴趣的人。
- en: Depending on the nature of the alarm, you have to react differently. But before
    taking any action, you should be able to inspect it and understand what caused
    it. You should inspect what metric triggered the alarm, with what value, the time
    it happened, and anything else that makes sense to your application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 根据警报的性质，您需要采取不同的反应。但在采取任何行动之前，您应该能够检查它并了解导致其发生的原因。您应该检查触发警报的指标、其值、发生的时间以及任何对您的应用有意义的信息。
- en: When the model’s performance degrades, the first impulse is to retrain it. But
    that is a costly operation. Thus, you first have to check that the data is valid,
    the schema hasn’t changed, and the data point was not an isolated outlier. If
    neither is true, you should trigger the training pipeline and train the model
    on the newly shifted dataset to solve the drift.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当模型的表现下降时，第一个冲动是重新训练它。但这是一项昂贵的操作。因此，您首先必须检查数据是否有效，模式是否没有改变，数据点是否不是一个孤立的外部异常。如果这两个条件都不成立，您应该触发训练流程，并在新移动的数据集上训练模型以解决漂移问题。
- en: 6\. Reproducibility
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 可重现性
- en: '**Reproducibility** means that every process within your ML systems should
    produce identical results given the same input. This has two main aspects.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**可重现性**意味着在您的机器学习系统中，每个过程都应该在相同的输入下产生相同的结果。这有两个主要方面。'
- en: The first one is that you should always know what the inputs are—for example,
    when training a model, you can use a plethora of hyperparameters. Thus, you need
    a way to always track what assets were used to generate the new assets, such as
    what dataset version and config were used to train the model.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第一，您应该始终知道输入是什么——例如，当训练一个模型时，您可以使用大量的超参数。因此，您需要一种方法来始终跟踪用于生成新资产所使用的资产，例如用于训练模型的哪些数据集版本和配置。
- en: The second aspect is based on the non-deterministic nature of ML processes.
    For example, when training a model from scratch, all the weights are initially
    randomly initialized. Thus, even if you use the same dataset and hyperparameters,
    you might end up with a model with a different performance. This aspect can be
    solved by always using a seed before generating random numbers, as in reality,
    we cannot digitally create randomness, only pseudo-random numbers. Thus, by providing
    a seed, we ensure that we always produce the same trace of pseudo-random numbers.
    This can also happen at the feature engineering step, in case we impute values
    with random values or randomly remove data or labels. But as a general rule of
    thumb, always try to make your processes as deterministic as possible, and in
    case you have to introduce randomness, always provide a seed that you have control
    over.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方面是基于机器学习过程的非确定性。例如，当从头开始训练一个模型时，所有权重最初都是随机初始化的。因此，即使您使用相同的dataset和超参数，最终得到的模型性能也可能不同。这一方面可以通过在生成随机数之前始终使用一个种子来解决，因为在现实中，我们无法数字上创建随机性，只能创建伪随机数。因此，通过提供种子，我们确保始终产生相同的伪随机数序列。这也可以发生在特征工程步骤中，如果我们用随机值填充值或随机删除数据或标签。但作为一个一般规则，始终尽量使您的过程尽可能确定，如果您必须引入随机性，请始终提供一个您能控制的种子。
- en: Join our book’s Discord space
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们书籍的Discord空间。
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/llmeng](https://packt.link/llmeng)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/llmeng](https://packt.link/llmeng)'
- en: '[![](img/QR_Code79969828252392890.png)](https://packt.link/llmeng)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](img/QR_Code79969828252392890.png)](https://packt.link/llmeng)'
- en: '![](img/New_Packt_Logo1.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/New_Packt_Logo1.png)'
- en: '[packt.com](https://www.packt.com)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[packt.com](https://www.packt.com)'
- en: Subscribe to our online digital library for full access to over 7,000 books
    and videos, as well as industry leading tools to help you plan your personal development
    and advance your career. For more information, please visit our website.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅我们的在线数字图书馆，全面访问超过7000本书籍和视频，以及领先的工具，帮助您规划个人发展并推进职业生涯。更多信息，请访问我们的网站。
- en: Why subscribe?
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么订阅？
- en: Spend less time learning and more time coding with practical eBooks and Videos
    from over 4,000 industry professionals
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用来自4000多名行业专业人士的实用电子书和视频，节省学习时间，增加编码时间。
- en: Improve your learning with Skill Plans built especially for you
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过为您量身定制的技能计划提高您的学习效果。
- en: Get a free eBook or video every month
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每月免费获得一本电子书或视频。
- en: Fully searchable for easy access to vital information
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全可搜索，便于快速访问关键信息。
- en: Copy and paste, print, and bookmark content
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制粘贴、打印和收藏内容。
- en: At [www.packt.com](https://www.packt.com), you can also read a collection of
    free technical articles, sign up for a range of free newsletters, and receive
    exclusive discounts and offers on Packt books and eBooks.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在[www.packt.com](https://www.packt.com)网站上，您还可以阅读一系列免费的技术文章，注册各种免费通讯，并享受Packt书籍和电子书的独家折扣和优惠。
- en: Other Books You May Enjoy
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您可能还喜欢的其他书籍
- en: 'If you enjoyed this book, you may be interested in these other books by Packt:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢这本书，您可能对Packt的其他这些书籍也感兴趣：
- en: '[![](img/9781836200918.png)](https://www.packtpub.com/en-in/product/rag-driven-generative-ai-9781836200918)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](img/9781836200918.png)](https://www.packtpub.com/en-in/product/rag-driven-generative-ai-9781836200918)'
- en: '**RAG-Driven Generative AI**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**RAG-Driven Generative AI**'
- en: Denis Rothman
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Denis Rothman
- en: 'ISBN: 9781836200918'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 'ISBN: 9781836200918'
- en: Scale RAG pipelines to handle large datasets efficiently
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规模化RAG管道以高效处理大数据集。
- en: Employ techniques that minimize hallucinations and ensure accurate responses
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用最小化幻觉并确保准确响应的技术。
- en: Implement indexing techniques to improve AI accuracy with traceable and transparent
    outputs
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施索引技术，通过可追溯和透明的输出提高AI的准确性。
- en: Customize and scale RAG-driven generative AI systems across domains
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在各个领域定制和扩展RAG驱动的生成式AI系统。
- en: Find out how to use Deep Lake and Pinecone for efficient and fast data retrieval
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用Deep Lake和Pinecone进行高效快速的数据检索。
- en: Control and build robust generative AI systems grounded in real-world data
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制和构建基于真实世界数据的强大生成式AI系统。
- en: Combine text and image data for richer, more informative AI responses
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合文本和图像数据，以生成更丰富、更有信息量的AI响应。
- en: '[![](img/9781835462317.jpg)](https://www.packtpub.com/en-in/product/building-llm-powered-applications-9781835462317)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](img/9781835462317.jpg)](https://www.packtpub.com/en-in/product/building-llm-powered-applications-9781835462317)'
- en: '**Building LLM Powered Applications**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**Building LLM Powered Applications**'
- en: Valentina Alto
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Valentina Alto
- en: 'ISBN: 9781835462317'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 'ISBN: 9781835462317'
- en: Explore the core components of LLM architecture, including encoder-decoder blocks
    and embeddings
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 LLM 架构的核心组件，包括编码器-解码器块和嵌入
- en: Understand the unique features of LLMs like GPT-3.5/4, Llama 2, and Falcon LLM
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 GPT-3.5/4、Llama 2 和 Falcon LLM 等LLM的独特功能
- en: Use AI orchestrators like LangChain, with Streamlit for the frontend
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 LangChain 等人工智能编排器，配合 Streamlit 进行前端开发
- en: Get familiar with LLM components such as memory, prompts, and tools
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉 LLM 的组件，如记忆、提示和工具
- en: Learn how to use non-parametric knowledge and vector databases
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用非参数知识和向量数据库
- en: Understand the implications of LFMs for AI research and industry applications
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 LFM 对人工智能研究和行业应用的影响
- en: Customize your LLMs with fine tuning
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过微调来定制你的 LLM
- en: Learn about the ethical implications of LLM-powered applications
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 LLM 驱动的应用的伦理影响
- en: Packt is searching for authors like you
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Packt 正在寻找像你这样的作者
- en: If you’re interested in becoming an author for Packt, please visit [authors.packtpub.com](https://authors.packtpub.com)
    and apply today. We have worked with thousands of developers and tech professionals,
    just like you, to help them share their insight with the global tech community.
    You can make a general application, apply for a specific hot topic that we are
    recruiting an author for, or submit your own idea.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对成为 Packt 的作者感兴趣，请访问 [authors.packtpub.com](https://authors.packtpub.com)
    并今天申请。我们已与成千上万的开发者和技术专业人士合作，就像你一样，帮助他们将见解分享给全球技术社区。你可以提交一般申请，申请我们正在招募作者的特定热门话题，或者提交你自己的想法。
- en: Share your thoughts
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分享你的想法
- en: Now you’ve finished *LLM Engineer’s Handbook, First Edition*, we’d love to hear
    your thoughts! If you purchased the book from Amazon, please [click here to go
    straight to the Amazon review page](https://packt.link/r/1836200072) for this
    book and share your feedback or leave a review on the site that you purchased
    it from.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了 *《LLM 工程师手册，第一版》*，我们非常想听听你的想法！如果你在亚马逊购买了这本书，请[点击此处直接进入该书的亚马逊评论页面](https://packt.link/r/1836200072)并分享你的反馈或在该购买网站上留下评论。
- en: Your review is important to us and the tech community and will help us make
    sure we’re delivering excellent quality content.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你的评论对我们和整个技术社区都很重要，并将帮助我们确保我们提供高质量的内容。
