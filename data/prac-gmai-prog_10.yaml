- en: Awareness
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 意识
- en: In our last chapter, we will be looking at how we can develop AI characters
    that use **tactics** and awareness to accomplish their goals. Here we will be
    using everything that we have explored before, understanding how we can combine
    everything together to create artificial intelligent characters that can be used
    in stealth games or games that also rely on tactics or awareness.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最后一章中，我们将探讨如何开发使用**战术**和意识来实现其目标的AI角色。在这里，我们将使用之前探索的一切，了解我们如何将所有这些结合起来，以创建可用于潜行游戏或也依赖战术或意识的游戏的AI角色。
- en: Stealth sub-genre
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 潜行子类型
- en: Stealth games are a very popular sub-genre where the main objective of the player
    is to use stealth elements, being undetected by the opponents in order to complete
    the main goals. Even being a genre that is widely popular in military games it
    is possible to see this sub-genre being applied in almost any game. If we take
    a deep look, any game where the enemy character is triggered by noise or vision
    of the player, is using stealth elements. This means that at some point or another,
    having awareness or even tactics implemented on our AI characters can be very
    useful regardless of the game genre that we are working on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 潜行游戏是一个非常受欢迎的子类型，其中玩家的主要目标是利用潜行元素，不被对手发现以完成主要目标。尽管这个子类型在军事游戏中非常流行，但几乎可以在任何游戏中看到它的应用。如果我们深入观察，任何游戏中如果敌人角色被玩家的噪音或视觉触发，就是在使用潜行元素。这意味着在某个时候，在我们的AI角色中实现意识甚至战术可能非常有用，无论我们正在开发的游戏类型是什么。
- en: About tactics
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于战术
- en: The tactics is the process that the character or a group of characters take
    in order to achieve certain objectives. It usually means that the characters can
    use all of their abilities, choosing the best ones depending on the situations,
    to defeat the opponent. The concept of tactics in video games is to give to the
    AI the power of decision, making him behave smartly while trying to reach the
    main goal. We can compare this to the tactics that are used by the soldiers or
    police officers in order to catch the bad guys of the real world.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 战术是指角色或一组角色为了实现特定目标所采取的过程。这通常意味着角色可以使用他们所有的能力，根据情况选择最佳的能力来击败对手。在视频游戏中，战术的概念是赋予AI决策能力，使其在试图达到主要目标时表现得聪明。我们可以将此与士兵或警察在现实世界中用来抓捕坏蛋的战术进行比较。
- en: They have a wide array of technology and human resources to catch a bandit,
    but in order to accomplish that task with success they need to choose wisely what
    they are going to do, step by step. The same principles can be applied to our
    AI characters; we can make them choose the best options available in order to
    accomplish their objective.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 他们拥有广泛的技术和人力资源来捕捉强盗，但为了成功完成这项任务，他们需要明智地选择他们将采取的行动，一步一步来。同样的原则也可以应用于我们的AI角色；我们可以让它们选择实现其目标的最佳选项。
- en: To create this, we can use every topic that was covered before in this book
    and with that, we are able to develop an AI character capable of choosing the
    best tactic that takes down the player or achieving his goal.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这个，我们可以使用这本书中之前涵盖的每一个主题，并且通过这样，我们能够开发出一个能够选择最佳战术以击败玩家或实现其目标的AI角色。
- en: About awareness
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于意识
- en: One very important aspect that correlates with the tactics is the awareness
    of the character. Some common factors can make part of the awareness of an AI
    character such as audio, vision, and perception, for example. These factors are
    inspired on the human features that we all have, vision, audio, touch, and perception
    of what is happening around us.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与战术相关的一个非常重要的方面是角色的意识。一些常见的因素可以构成AI角色的意识的一部分，例如音频、视觉和感知。这些因素受到了我们所有人共有的特征——视觉、音频、触觉和对周围发生的事情的感知——的启发。
- en: Therefore, what we are looking for is to create artificial intelligent characters
    that can process all of that information at the same time that they are doing
    other things making them aware of the surroundings, making better judgment of
    what decisions should be taken on that given moment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们追求的是创建能够同时处理所有这些信息的人工智能角色，在它们做其他事情的同时，使它们对周围环境保持警觉，对在那个特定时刻应该做出的决策做出更好的判断。
- en: Implementing vision awareness
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现视觉意识
- en: Before starting out with the tactics, we will take a look at how we can implement
    an awareness system into our characters.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始战术之前，我们将看看如何将意识系统实现到我们的角色中。
- en: 'Let''s start by implementing a vision awareness into our game character. The
    idea is to simulate the human vision, where we can see very good at close range
    and not so good when something is really far away. Many games have adopted this
    system and they all have differences, some have a more complex system while others
    have a basic one. The basic example can be found especially on a more juvenile
    adventure game such as *Zelda - Ocarina of Time* for example, where the enemies
    will only appear or react when you reach a certain trigger zone as shown in the
    following screenshot:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将视觉感知融入到我们的游戏角色中开始。这个想法是模拟人类的视觉，我们可以在近距离看得很清楚，而当某物真的很远时，我们看不清楚。许多游戏都采用了这个系统，它们都有所不同，有些系统更复杂，而有些则更简单。基本示例可以在像《塞尔达传说
    - 时之笛》这样的更幼稚的冒险游戏中找到，例如，敌人只有在达到某个触发区域时才会出现或做出反应，如下面的截图所示：
- en: '![](img/7e634c2a-2595-451a-b6cc-c9e2a4445eac.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e634c2a-2595-451a-b6cc-c9e2a4445eac.jpg)'
- en: For example, in this situation if the player goes back and exits the enemy trigger
    zone, the enemy will stay in an idle position, even if he is clearly able to see
    the player. This is a basic system of awareness and we can include it in the vision
    section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这种情况下，如果玩家返回并退出敌人的触发区域，敌人将保持在空闲位置，即使他显然能看到玩家。这是一个基本的感知系统，我们可以将其包括在视觉部分。
- en: Meanwhile, other games have developed their entire gameplay around this subject
    (vision awareness), where the vision range has an extremely important aspect on
    the gameplay itself. One of the several examples can be the Ubisoft title, Splinter
    Cell.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，其他游戏已经围绕这个主题（视觉感知）开发了整个游戏玩法，其中视觉范围对游戏本身有极其重要的方面。几个例子之一是育碧的《细胞分裂》。
- en: '![](img/4c0e34f2-de5e-46c0-9652-709813e5cfc2.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4c0e34f2-de5e-46c0-9652-709813e5cfc2.jpg)'
- en: In this game all types of awareness systems are used, sound, vision, touch,
    and perception. If the player stays quiet in a shadowy area, it has less chance
    of being discovered than being quiet in a well-illuminated area and the same for
    the sound. So, for the example in the preceding screenshot, the player has approached
    very close to the enemy that is looking in another direction.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中使用了所有类型的感知系统，包括声音、视觉、触觉和感知。如果玩家在阴暗区域保持安静，被发现的机会比在明亮区域保持安静要小，声音也是如此。因此，在前面截图的例子中，玩家已经非常接近正在看向另一个方向的敌人。
- en: In order for the player to get this near, it was necessary to move very quietly
    and in the shadows. If the player was making noise or walking straight into illuminated
    areas, the enemy would have spotted him. This is a much more complex system than
    the *Zelda* game, but once again, it all depends on the game that we are creating
    and which system fits better on the gameplay that we are looking for. We will
    be demonstrating basic examples and then moving on to more advanced ones.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让玩家接近到这种程度，必须非常安静地移动并在阴影中行动。如果玩家发出噪音或直接走进明亮区域，敌人就会注意到他。这比《塞尔达》游戏中的系统要复杂得多，但同样，这完全取决于我们正在创建的游戏以及哪个系统更适合我们寻找的游戏玩法。我们将演示基本示例，然后转向更高级的示例。
- en: Basic vision detection
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本视觉检测
- en: First, we start by creating and adding a scene into our game, and then we add
    the player.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们开始在游戏中创建并添加一个场景，然后添加玩家。
- en: '![](img/43d47bd0-21c0-4543-9e03-e731913062e0.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/43d47bd0-21c0-4543-9e03-e731913062e0.png)'
- en: We assign all the necessary codes into the player so it is possible for us to
    move and test the game. For this example, we have quickly assigned some basic
    movement information into our player, because that is the only interaction that
    will occur between the player and the AI character.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有必要的代码分配给玩家，这样我们就可以移动并测试游戏。在这个例子中，我们迅速将一些基本的移动信息分配给我们的玩家，因为这是玩家和AI角色之间唯一会发生的交互。
- en: '![](img/b737f4f7-884b-4436-9704-aeb9e6d8e543.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b737f4f7-884b-4436-9704-aeb9e6d8e543.png)'
- en: So now, we have our character moving freely on the scene and we are ready to
    start working on the enemy character. We want to replicate that specific moment
    on the *Zelda* game, where the enemy comes from the ground when the player gets
    near from his position and once the player gets far away, the enemy goes back
    into the ground.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的角色可以在场景中自由移动，我们准备开始处理敌人角色。我们想要复制《塞尔达》游戏中那个特定的时刻，即当玩家从他的位置靠近时，敌人从地面出现，而当玩家远离时，敌人回到地面。
- en: '![](img/1c1e20d6-31c5-4d0d-9afc-677e27a5c4cf.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1c1e20d6-31c5-4d0d-9afc-677e27a5c4cf.png)'
- en: The rabbit that we can see in the screenshot is the AI character that we have
    just imported into the game and now we need to define the area around him that
    will serve as awareness. Therefore, if the player gets near the rabbit he will
    detect the player and will eventually get out of his hole.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在截图中所看到的兔子是我们刚刚导入游戏的AI角色，现在我们需要定义围绕它的区域，这将作为它的感知区域。因此，如果玩家靠近兔子，它将检测到玩家，并最终从洞中出来。
- en: '![](img/6d504395-bf16-4b46-ac42-99bac8e2e8ff.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6d504395-bf16-4b46-ac42-99bac8e2e8ff.png)'
- en: Let's say that we want the rabbit to be able to see from his hole the area that
    is represented by the dashed line. How can we proceed from now? We can do two
    things here, one is adding the trigger `Collider` into the hole object, where
    it will detect the player and instantiate the rabbit from the hole position, two
    is adding the trigger `Collider` directly to the rabbit that will be invisible
    (hypothetically inside the hole) and in the code we have a state for when the
    rabbit is inside the hole and another state for the moment when he is outside.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想让兔子能够从它的洞中看到由虚线表示的区域。我们接下来该如何操作？在这里我们可以做两件事，一是将触发器`Collider`添加到洞对象中，它将检测到玩家并从洞的位置实例化兔子，二是将触发器`Collider`直接添加到兔子身上（假设它在洞内不可见）并在代码中有一个当兔子在洞内时的状态，以及当它在外面的状态。
- en: We decided for this example to use the hole as the main object for that moment
    where the rabbit is hiding and at the moment that the player enters the trigger
    area, the hole object instantiates the AI character.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们决定将洞作为兔子藏身的主要对象，以及玩家进入触发区域的那一刻，洞对象实例化AI角色。
- en: '![](img/5e3beb94-d755-4f89-be6e-9e9d28596418.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5e3beb94-d755-4f89-be6e-9e9d28596418.png)'
- en: We transformed the rabbit into a prefab, so we can instantiate it later and
    then we removed him from the scene. Then we have created a cube inside the game
    and we positioned it on the hole position. Because we don't need the hole to be
    visible for this example, we will be turning off the mesh from this object.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将兔子转换成了一个预制体，这样我们就可以稍后实例化它，然后我们从场景中移除了它。然后我们在游戏中创建了一个立方体，并将其放置在洞的位置。由于在这个例子中我们不需要洞是可见的，我们将关闭这个对象的网格。
- en: Creating a cube instead of an empty object allow us to better visualize the
    object inside the game editor in case we need to change something or simply have
    a notion of where we have those objects.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用立方体而不是空对象，使我们能够在游戏编辑器中更好地可视化对象，以防我们需要更改某些内容或只是有一个关于这些对象的位置概念。
- en: At this point, we need to make this object detect the player and so we will
    be adding a trigger with the dimension that we previously planned to use.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要让这个对象检测到玩家，因此我们将添加一个具有我们之前计划使用的维度的触发器。
- en: '![](img/aa95e62c-686b-4076-8ba6-48180128656f.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aa95e62c-686b-4076-8ba6-48180128656f.png)'
- en: We deleted the default cube trigger that appears automatically when you create
    the cube and then we assigned a new sphere trigger. Why are we not using the cube
    trigger? We could be using the cube trigger and technically it would work too,
    but the covered area would be completely different from the circular area that
    we planned and for that reason we deleted the default trigger and assigned a new
    one that fits our purpose.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们删除了当创建立方体时自动出现的默认立方体触发器，然后分配了一个新的球体触发器。为什么我们不使用立方体触发器？我们本可以使用立方体触发器，技术上它也会工作，但覆盖的区域将与我们计划的圆形区域完全不同，因此我们删除了默认触发器，并分配了一个适合我们目的的新触发器。
- en: 'Now that we have the sphere trigger covering the area that we want, we need
    to make it detect the player. For this, we need to create the script that will
    be assigned to the cube/hole:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经用球体触发器覆盖了我们想要覆盖的区域，我们就需要让它检测到玩家。为此，我们需要创建一个将被分配给立方体/洞的脚本：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Inside the script, we add this line of code. It is a simple trigger check for
    when the object gets inside the trigger area (we have used this to demonstrate
    previous examples). For now we simply have the trigger to check if the player
    gets detected using `Debug.Log("Player Detected");`. We assign this script to
    the cube/hole object and then we can test it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本内部，我们添加了这一行代码。这是一条简单的触发器检查，用于当对象进入触发区域时（我们曾用它来演示之前的例子）。目前我们只是让触发器检查是否检测到玩家，使用`Debug.Log("玩家被检测到");`。我们将这个脚本分配给立方体/洞对象，然后我们可以测试它。
- en: '![](img/9e357aff-bca8-4c18-9d77-528c9011aafc.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9e357aff-bca8-4c18-9d77-528c9011aafc.png)'
- en: If we move the player into the trigger area that we created, we can see the
    message Player Detected.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将玩家移动到我们创建的触发区域内，我们可以看到“玩家被检测到”的消息。
- en: '![](img/6cb7af3a-3a51-4556-8ab7-17e5b6f1a714.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6cb7af3a-3a51-4556-8ab7-17e5b6f1a714.png)'
- en: Well this is the first part of the basic example; we have the player moving
    around the map and the hole that is capable of detecting the player when he is
    near.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是基本示例的第一部分；我们有玩家在地图上移动，洞能够检测到玩家靠近时的情况。
- en: This method where we use the trigger Collider to detect something isn't directly
    associated with any kind of awareness because this is just the technical part,
    the way we use it is what will determine if this is meant to be the vision of
    our AI character or not.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用触发Collider来检测某种东西的方法并不直接与任何类型的意识相关联，因为这仅仅是技术部分，我们使用它的方式将决定这是否是我们AI角色的视野。
- en: 'Now, we can work on the rabbit, our AI character. We already have him created
    and set as a prefab, ready to appear in the game. So the next step is for the
    hole object to instantiate the rabbit, transmitting the sensation to the player
    that the rabbit saw him and for that reason he decided to get out of the hole.
    On the hole object code we update the `Player Detected` message to the `instantiate`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始处理兔子，我们的AI角色。我们已经有它创建并设置为预制体，准备在游戏中出现。所以下一步是让洞对象实例化兔子，将兔子看到玩家的感觉传递给玩家，因此兔子决定从洞中出来。在洞对象代码中，我们将`Player
    Detected`消息更新为`instantiate`：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So what we have done is define what would be the instantiated object, which
    in this case is the character AI `rabbit`. Then we added the `startPosition` variable
    that will set the position where we want the character to appear, in alternative
    we could also use the hole object position that would work just fine for this
    example. Finally, we added a simple Boolean `isOut` to prevent the hole creating
    more than one rabbit at the same time.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们做的是定义了将要实例化的对象，在这个例子中是AI角色“兔子”。然后我们添加了`startPosition`变量，它将设置我们希望角色出现的位置，作为替代，我们也可以使用洞对象的位置，这对于这个例子来说效果同样好。最后，我们添加了一个简单的布尔值`isOut`，以防止洞在同一时间创建多个兔子。
- en: When the player gets inside the trigger zone, the rabbit gets instantiated and
    jumps out of the hole.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家进入触发区域时，兔子就会被实例化并从洞中跳出来。
- en: '![](img/fdd9bccc-80e9-4448-8a58-6951a968870e.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fdd9bccc-80e9-4448-8a58-6951a968870e.png)'
- en: Now, we have a rabbit that jumps out of the hole when he sees the player. Our
    next step is to also add the same vision to the rabbit itself, but this time we
    want the rabbit to constantly check if the player is inside the trigger zone,
    this would represent that it can see the player and if the player gets away from
    his vision, the rabbit cannot see him anymore and returns to the hole.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个兔子，当它看到玩家时会从洞中跳出来。我们的下一步是也给兔子本身添加相同的视野，但这次我们希望兔子能够持续检查玩家是否在触发区域内，这表示它可以看到玩家，如果玩家离开它的视野，兔子就再也看不到他，并返回洞中。
- en: For the AI character, we can use a wider area than the hole.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于AI角色，我们可以使用比洞更宽的区域。
- en: '![](img/064e7d41-56cf-4232-9338-69760341c0df.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/064e7d41-56cf-4232-9338-69760341c0df.png)'
- en: So as we can see, that would be the area where the rabbit can see the player,
    if the player gets out of that area, the rabbit can't see the player no more.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正如我们所看到的，那将是兔子可以看到玩家的区域，如果玩家离开那个区域，兔子就再也看不到玩家了。
- en: '![](img/e8e0c30a-b820-40c6-a666-037c85207eda.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e8e0c30a-b820-40c6-a666-037c85207eda.png)'
- en: Once again, let's add a sphere `Collider`, but this time to the rabbit.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们给兔子添加一个球体`Collider`。
- en: Enable the Is Trigger option in order to turn the Collider into activation zones.
    Otherwise it won't work.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 启用“是触发器”选项，以便将Collider转换为激活区域。否则它将不起作用。
- en: '![](img/078db524-bf56-4d32-ae1c-8e00a5579b24.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/078db524-bf56-4d32-ae1c-8e00a5579b24.png)'
- en: This is what we have so far, the sphere `Collider` with the dimensions that
    we planned and ready to receive the player position information that will serve
    as the vision to our AI character.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们目前所做的工作，球体`Collider`具有我们计划的尺寸，并准备好接收玩家位置信息，这将作为我们AI角色的视野。
- en: 'Now, what we need to do is add to the rabbit script the portion of the code
    that is responsible for the trigger zone:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要做的是将负责触发区域的代码部分添加到兔子脚本中：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What we have here is a trigger check to see if the player continues inside the
    trigger zone, to do this we simply use the `OnTriggerStay`, which works perfectly
    to this example that we are creating.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有一个触发检查，用来查看玩家是否继续在触发区域内，为此我们简单地使用`OnTriggerStay`，这对于我们正在创建的例子来说工作得非常好。
- en: We use `Debug.Log("I can see the player");` simply to test if this is working
    as intended.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Debug.Log("I can see the player");`只是为了测试这是否按预期工作。
- en: '![](img/ef9de8f0-baef-4eb6-a81a-150b6e9d72e5.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef9de8f0-baef-4eb6-a81a-150b6e9d72e5.png)'
- en: We test the game and we can notice that when the player gets inside the rabbit
    area, we receive the console message that we wrote and this means that it is working.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试了游戏，并注意到当玩家进入兔子区域时，我们收到了我们编写的控制台消息，这意味着它正在工作。
- en: 'Now, let''s add the second part of the rabbit vision, where the player gets
    out of the trigger zone and the rabbit can''t see him no more. To do this we need
    to add another trigger check, which will serve to check if the player already
    left the area:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加兔子视觉的第二部分，即玩家离开触发区域，兔子再也无法看到他。为此，我们需要添加另一个触发检查，用来检查玩家是否已经离开了该区域：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Following is the `OnTriggerStay` that we added into the AI character code,
    we add some new lines of code that checks if the player has left the trigger zone.
    To do this we use the `OnTriggerExit` that does what the name says, checks the
    exit of the object that has entered the trigger zone. But to make this work we
    need to first set an `OnTriggerEnter`, otherwise it won''t count if the player
    entered the zone or not, it only knows if he is there or not:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们在AI角色代码中添加的`OnTriggerStay`，我们添加了一些新的代码行来检查玩家是否已经离开了触发区域。为此，我们使用了`OnTriggerExit`，它做的是名字所描述的事情，检查进入触发区域的对象的退出。但为了使这个功能正常工作，我们首先需要设置一个`OnTriggerEnter`，否则它不会计算玩家是否进入了区域，它只知道玩家是否在那里：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, we have the trigger counting when the player gets inside the area, when
    he keeps inside the area, and also the moment that he exits that same area. This
    represents the moment that the rabbit starts seeing the player, when he keeps
    seeing him, and when he loses eye contact with the player.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了玩家进入区域、保持在区域内部以及离开该区域的触发计数。这代表了兔子开始看到玩家、持续看到他以及与玩家失去目光接触的时刻。
- en: '![](img/634c1045-8a71-4703-b133-88a9ce03ee0b.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/634c1045-8a71-4703-b133-88a9ce03ee0b.png)'
- en: At this point, we can test the game and see if what we have done is working
    correctly or not. When we start the game, we can confirm that by looking at the
    console messages that we wrote to see if everything is working as intended.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以测试游戏，看看我们所做的是否工作正常。当我们开始游戏时，我们可以通过查看我们编写的控制台消息来确认一切是否按预期工作。
- en: '![](img/e8e5353b-0612-489b-b423-d3df3180d983.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8e5353b-0612-489b-b423-d3df3180d983.png)'
- en: It is normal to see a higher number on the `OnTriggerStay` function because
    it is constantly checking every frame for the player, so as we can see in the
    preceding screenshot, our AI character now has the basic vision check working.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnTriggerStay`函数上看到更高的数字是正常的，因为它会不断检查每一帧的玩家，所以正如我们在前面的截图中所见，我们的AI角色现在已经实现了基本的视觉检测。
- en: Advanced vision detection
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级视觉检测
- en: Now that we understand how a basic vision detection that we can find in many
    action/adventure games works, we can move on and take a look at the advanced vision
    detection that can be found in stealth games. Let's take a deep look into the
    *Metal Gear* game and see how the AI characters have their vision developed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了在许多动作/冒险游戏中可以找到的基本视觉检测是如何工作的，我们可以继续前进，看看潜行游戏中可以找到的高级视觉检测。让我们深入探讨一下《合金装备》游戏，看看AI角色的视觉是如何发展的。
- en: '![](img/21de399f-a13e-485a-a98f-0bda9bc35904.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21de399f-a13e-485a-a98f-0bda9bc35904.png)'
- en: If we take a look at this screenshot, we notice that the enemy AI cannot see
    the player, but the player is inside of the area where the enemy is well capable
    of seeing. So why doesn't the AI character turn to the player and start attacking
    him? Simply because the trigger area is set only to be in front of the enemy eyes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下这张截图，我们会注意到敌人AI看不到玩家，但玩家就在敌人能够清晰看到的位置区域内。那么为什么AI角色不转向玩家并开始攻击他呢？简单来说，是因为触发区域只设置在敌人视线前方。
- en: For that reason, if the player is behind the enemy, he won't notice the player.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果玩家在敌人后面，敌人就不会注意到玩家。
- en: '![](img/9376beea-2a4f-46a5-8bda-eb95074f9b10.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9376beea-2a4f-46a5-8bda-eb95074f9b10.png)'
- en: As we can see in the second screenshot, everything that is in the darker area,
    the enemy doesn't have any way of getting information regarding the players presence,
    while the light area represents the vision of the character and there he can see
    everything that is happening. Now we will be taking a look at how we can develop
    a similar system into our AI characters.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在第二张截图中所见，在较暗的区域中，敌人无法获取有关玩家存在的任何信息，而明亮区域则代表了角色的视野，在那里他可以看到所有发生的事情。现在我们将探讨如何将类似系统开发到我们的AI角色中。
- en: Let's start by creating a test scenario. It can be simple cube meshes for now
    and later on we can change them into a better looking object.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个测试场景。现在可以使用简单的立方体网格，稍后我们可以将它们改为外观更好的对象。
- en: '![](img/a51a55a1-eaeb-486d-8ca0-677bbd014fe7.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a51a55a1-eaeb-486d-8ca0-677bbd014fe7.png)'
- en: We have created a few cube meshes and placed them randomly on top of a plane
    (that will be the ground). The next step will be creating the character, we'll
    be using a capsule to represent the character.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一些立方体网格，并将它们随机放置在一个平面上（这将是地面）。下一步将是创建角色，我们将使用胶囊来表示角色。
- en: '![](img/376b44cb-3496-49c9-8d3b-d03b7687e10e.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/376b44cb-3496-49c9-8d3b-d03b7687e10e.png)'
- en: We can place the newly created capsule anywhere on the map. Now, we need to
    create some targets that will be spotted by our AI character.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将新创建的胶囊放置在地图上的任何位置。现在，我们需要创建一些目标，这些目标将被我们的AI角色发现。
- en: '![](img/ce7aec7e-ad9f-42ab-b59a-d7a765a111c9.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce7aec7e-ad9f-42ab-b59a-d7a765a111c9.png)'
- en: We can distribute the target objects anywhere on the map as well. Now, we need
    to define two different layers, one for the obstacles and another one for the
    targets.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将目标对象放置在地图上的任何位置。现在，我们需要定义两个不同的图层，一个用于障碍物，另一个用于目标。
- en: '![](img/a2333f05-eb2a-4e4e-969a-243af5bf1a31.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2333f05-eb2a-4e4e-969a-243af5bf1a31.png)'
- en: In Unity we click under the Layers button to expand more options, and then we
    click where it says Edit Layers....
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，我们点击图层按钮下方的部分以展开更多选项，然后点击显示为“编辑图层....”的地方。
- en: '![](img/159cbdd1-f4c1-4cb5-9364-ef0d3cede3f6.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/159cbdd1-f4c1-4cb5-9364-ef0d3cede3f6.png)'
- en: This column will open and here we can write the layers we need to create. As
    we can see, there's already the two layers that we need, one called Obstacles
    and the other called Targets. After this, we need to assign them to the objects.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这列将展开，在这里我们可以写下我们需要创建的图层。正如我们所看到的，已经有我们需要的两个图层，一个称为障碍物，另一个称为目标。之后，我们需要将它们分配给对象。
- en: '![](img/d1e4d60e-6596-4a80-8e2f-6f4514afc08c.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1e4d60e-6596-4a80-8e2f-6f4514afc08c.png)'
- en: To do this we simply need to select the Obstacles objects and then click on
    the Layers button and choose the Obstacles layer. We also do the same for the
    Target objects, choosing the Targets layer.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们只需选择障碍物对象，然后点击图层按钮，选择障碍物图层。我们同样也为目标对象做同样的操作，选择目标图层。
- en: 'The next thing to do is start adding the necessary code into our character.
    We will also need to add to the character a rigid body and freeze all the rotation
    axis demonstrated in the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要做的事情是将必要的代码添加到我们的角色中。我们还需要为角色添加一个刚体，并冻结以下截图中所展示的所有旋转轴：
- en: '![](img/fdc08b62-156b-4eb1-acc4-c700048a4268.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fdc08b62-156b-4eb1-acc4-c700048a4268.png)'
- en: 'Then we can create a new script for the character:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以为角色创建一个新的脚本：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What we have here is the basic movement of our character, so we can test it
    ourselves by controlling the character to move anywhere we want to. With this
    done, we are able to move around the map with the character and with the mouse
    we can simulate the direction in which the character is looking at.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的是我们角色的基本移动，因此我们可以通过控制角色移动到任何我们想要的地方来自行测试它。完成这些后，我们能够用角色在地图上移动，并且用鼠标可以模拟角色所看的方向。
- en: 'Now, let''s work on the script that simulates the vision of our character:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来编写模拟我们角色视力的脚本：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We start out with two public floats, one for the `viewRadius` and another one
    for `viewAngle`. Then we create a public `Vector3` called `DirFromAngle` and we
    want the results to be in degrees and so we will be using trigonometry to solve
    this.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从两个公共浮点数开始，一个用于`viewRadius`，另一个用于`viewAngle`。然后我们创建一个名为`DirFromAngle`的公共`Vector3`，我们希望结果以度为单位，因此我们将使用三角学来解决这个问题。
- en: '![](img/1097ca5f-880c-4d4d-a98e-da65a7ebaba1.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1097ca5f-880c-4d4d-a98e-da65a7ebaba1.png)'
- en: The preceding diagram represents the default trigonometry values in degrees,
    where it starts from the right side with the number zero and the values will increase
    in a counter-clockwise way.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表表示默认的度数三角学值，它从右侧的零开始，值以逆时针方向增加。
- en: '![](img/55cfbbda-2541-4ae9-b953-ca465958f95a.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55cfbbda-2541-4ae9-b953-ca465958f95a.png)'
- en: Because we are developing this example in Unity, we need to keep in mind that
    the trigonometry values are in a different order, as we can see in the preceding
    diagram. Here, the zero number starts on the top and the value increase in a clockwise
    way.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这个Unity示例中开发，我们需要记住三角学值的顺序是不同的，正如前面图表所示。在这里，零数字从顶部开始，值以顺时针方向增加。
- en: 'With this information in mind, we can now proceed with the direction angle
    in which our character will be looking at:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解这些信息后，我们现在可以继续处理角色将查看的方向角度：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we have the basic foundation of our exercise done, but in order to visually
    see it on the game editor we need to create a new script that will show the radius
    of the character vision:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的练习的基本基础已经完成，但为了在游戏编辑器上直观地看到它，我们需要创建一个新的脚本，以显示角色视野的半径：
- en: '![](img/e38b974d-71ae-487a-be08-dda6e03d466e.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e38b974d-71ae-487a-be08-dda6e03d466e.png)'
- en: 'To do this, we go ahead and create a new folder in the project section:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们首先在项目部分创建一个新的文件夹：
- en: '![](img/4716b447-8e41-479b-9411-6737f25dbcfd.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4716b447-8e41-479b-9411-6737f25dbcfd.png)'
- en: In order for the game engine to use this content that will appear in the game
    editor we need to name the folder as `Editor`. Everything inside this folder can
    be used/seen in the game editor, without clicking the play button, which can be
    very handy in many situations just like the one we are creating.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让游戏引擎使用将在游戏编辑器中出现的这个内容，我们需要将文件夹命名为`Editor`。这个文件夹内的所有内容都可以在游戏编辑器中使用/查看，无需点击播放按钮，这在许多情况下都非常方便，就像我们正在创建的那样。
- en: 'Then inside of the `Editor` folder that we just created, we create a new script
    that will be responsible for the visualization of the character field of view:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在刚刚创建的`Editor`文件夹内部，我们创建一个新的脚本，该脚本将负责角色视场的可视化：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Because we want to use this script in editor mode, we need to specify that on
    the top of our script. To do that, we start by adding `using UnityEditor`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们想在编辑模式下使用这个脚本，所以我们需要在脚本顶部指定这一点。为此，我们首先添加`using UnityEditor`。
- en: 'Then after that we add one more line in which we will be connecting with the
    previous script we created to be able to use that in editor mode:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们再添加一行，以便与之前创建的脚本连接，以便在编辑模式下使用：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And now let''s work on what is going to appear on the screen to represent the
    field of view that we created:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来处理屏幕上将要出现的内容，以表示我们创建的视野：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We created a `void OnSceneGUI()` and this will contain all the information
    that we want to be visible on our game editor. We start by adding the target of
    the field of view; this will get the field of view object reference:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`void OnSceneGUI()`，这将包含我们希望在游戏编辑器上可见的所有信息。我们首先添加视野的目标；这将获取视野对象引用：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next we define the color that we want to represent the vision of our character,
    to do this we added the `Handles.color` and we have chosen the color to be white.
    This won''t be visible on the export version of our game, so we can choose the
    color that is easier for us to see in the editor:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义我们想要表示角色视野的颜色，为此我们添加了`Handles.color`，并选择了白色。这不会在我们游戏的导出版本中可见，因此我们可以选择在编辑器中更容易看到的颜色：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'What we have done now is give a form to the visualization that we are creating.
    The form is set to be in an arch and that is why we use `DrawWireArc`. Now, let''s
    take a look at what we have done so far:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在所做的是给正在创建的可视化赋予一个形状。形状被设置为弓形，这就是为什么我们使用`DrawWireArc`。现在，让我们看看到目前为止我们做了什么：
- en: '![](img/79738248-3fd4-45f8-9be7-5515b8cc397c.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79738248-3fd4-45f8-9be7-5515b8cc397c.png)'
- en: On the script that we created and assigned to the character, we need to change
    the value of View Radius to any desired value.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为角色创建并分配的脚本中，我们需要将视场半径的值更改为任何期望的值。
- en: '![](img/6e536add-dc73-498c-932c-f7d311bc6915.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e536add-dc73-498c-932c-f7d311bc6915.png)'
- en: When increasing that value, we will notice a circle growing around the character,
    this means that our script is working well so far. The circle is representing
    the vision of our character and now let's change a few things to make it look
    like the *Metal Gear Solid* image that we used as a reference.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当增加这个值时，我们会注意到围绕角色生长的圆圈，这意味着我们的脚本到目前为止工作得很好。这个圆圈代表我们角色的视野，现在让我们做一些修改，使其看起来像我们用作参考的*《合金装备固体》*图像。
- en: 'Let''s open the character `FieldOfView` script again to add new modifications:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次打开`FieldOfView`脚本以添加新的修改：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We added a range for the `viewRadius` so that way we can make sure that the
    circle does not surpass the `360` degrees mark. Then we added a Boolean parameter
    to `public Vector3 DirFromAngle` to check if the angle value is set to global,
    so that way we can control the direction that our character is facing.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`viewRadius`添加了一个范围，以确保圆圈不会超过`360`度的标记。然后我们添加了一个布尔参数到`public Vector3 DirFromAngle`，以检查角度值是否设置为全局，这样我们就可以控制角色面向的方向。
- en: 'Then we are going to open the `FieldOfViewEditor` script once again to add
    the `viewAngle` information:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们再次打开 `FieldOfViewEditor` 脚本来添加 `viewAngle` 信息：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let''s test it again to see the new modifications that we have done:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次测试以查看我们所做的新的修改：
- en: '![](img/78418ef8-559d-443d-9dff-48b02acdd1ec.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/78418ef8-559d-443d-9dff-48b02acdd1ec.png)'
- en: 'On the `View Angle` option we are going to change the value from zero to any
    other to see what it is doing:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `View Angle` 选项中，我们将值从零更改为任何其他值以查看它在做什么：
- en: '![](img/f7d5a8ad-8d76-4bbe-82fd-4b53cfe05133.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f7d5a8ad-8d76-4bbe-82fd-4b53cfe05133.png)'
- en: Now, if we look at the circle that is around the character, we will notice a
    triangular shape inside. The size of that shape can be controlled precisely with
    the `View Angle` option, and the triangle shape represents the vision of our character,
    so at this moment we can notice that the character is looking slightly to the
    bottom right.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们观察围绕角色的圆圈，我们会注意到里面有一个三角形形状。该形状的大小可以通过 `View Angle` 选项精确控制，三角形形状代表角色的视野，因此此刻我们可以注意到角色略微朝向右下方看。
- en: '![](img/30a6878a-9e4a-40ad-9348-f841e9c96efb.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/30a6878a-9e4a-40ad-9348-f841e9c96efb.png)'
- en: Because we have set the angle value to be at a global angle, we can rotate the
    character and the view angle will follow the character rotation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将角度值设置为全局角度，因此我们可以旋转角色，视图角度将跟随角色旋转。
- en: 'Now let''s work on the vision raycast, this part is responsible for detecting
    what exists in the direction that our character is looking at. Once again, we
    are going to edit our `FieldOfView` script that we created for our character:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们处理视野射线投射，这部分负责检测角色正在注视的方向上存在什么。再次，我们将编辑我们为角色创建的 `FieldOfView` 脚本：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'What we have done here, is add the `Physics` information into our script, detecting
    only the objects that can be found inside of the character `View Angle`. To check
    if something is in sight of our character, we use a `Raycast` to check if any
    object with the layer `obstacleMask` is detected. Now let''s create an `IEnumerator`
    function to implement a small delay for our character detecting new obstacles:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是将 `Physics` 信息添加到我们的脚本中，仅检测角色 `View Angle` 内可以找到的对象。为了检查是否有东西在我们的角色视野中，我们使用
    `Raycast` 来检查是否有带有 `obstacleMask` 层的对象被检测到。现在让我们创建一个 `IEnumerator` 函数来实现角色检测新障碍物时的小延迟：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that, we have created an `IEnumerator`, the character has a small reaction
    time that in this case is set to `.2f` to find targets inside of his vision zone.
    In order to test this we need to make some new modifications inside of our `FieldOfViewEditor`
    script. So let''s open it and add a few new lines of code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了一个 `IEnumerator`，角色有一个小的反应时间，在这个例子中设置为 `.2f` 以在视野区域内寻找目标。为了测试这一点，我们需要在我们的
    `FieldOfViewEditor` 脚本中做一些新的修改。所以让我们打开它并添加几行新的代码：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With the new modifications on the code, we should be able to see when the character
    has detected an obstacle and when that obstacle get out of his vision zone.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的新修改后，我们应该能够看到角色何时检测到障碍物，以及何时障碍物脱离了他的视野区域。
- en: '![](img/4398190c-ffd9-48e9-b252-338b396fc9ac.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4398190c-ffd9-48e9-b252-338b396fc9ac.png)'
- en: 'To test this out we first need to select all the obstacles that we have inside
    of our game:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，我们首先需要选择游戏中的所有障碍物：
- en: '![](img/4dff5f35-6ed4-41f5-a130-5060fd93419d.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4dff5f35-6ed4-41f5-a130-5060fd93419d.png)'
- en: 'Then assign them the Obstacles layer:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将它们分配到障碍层：
- en: '![](img/9415dad8-b0fc-4f0f-867a-0341fd843eba.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9415dad8-b0fc-4f0f-867a-0341fd843eba.png)'
- en: 'We also need to select all of the Targets inside of the game:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要选择游戏中的所有目标：
- en: '![](img/5845b7ee-386c-4923-a4fe-d6afca4fd8b6.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5845b7ee-386c-4923-a4fe-d6afca4fd8b6.png)'
- en: 'We then assign them the Targets layer. This step is very important so that
    our Raycast can identify what is inside of the character field of view. Now, let''s
    click on the character object and define which layer represents the Targets and
    which layer represents the Obstacles:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将它们分配到目标层。这一步非常重要，以便我们的射线投射能够识别角色视野内的内容。现在，让我们点击角色对象并定义哪个图层代表目标，哪个图层代表障碍物：
- en: '![](img/f7df547b-b1e7-401b-a477-1f85a1881182.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f7df547b-b1e7-401b-a477-1f85a1881182.png)'
- en: 'We go to the Layer Mask option that can be found in the Field Of View script
    options:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们转到视野脚本选项中的图层遮罩选项：
- en: '![](img/37a177a9-443e-4d69-bb69-ced606aa47fd.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/37a177a9-443e-4d69-bb69-ced606aa47fd.png)'
- en: 'And we choose the Targets layer:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们选择目标层：
- en: '![](img/b0ba92b9-9c58-466b-899e-4b6b23d5108e.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b0ba92b9-9c58-466b-899e-4b6b23d5108e.png)'
- en: 'Then we go to the Obstacles option:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们转到障碍物选项：
- en: '![](img/1289f14d-ed96-4f32-9b76-8335278b63af.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1289f14d-ed96-4f32-9b76-8335278b63af.png)'
- en: And we choose the Obstacles layer.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择障碍层。
- en: With this part done we can finally test the exercise to see what happens when
    the character finds a target.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分完成之后，我们最终可以测试练习，看看当角色找到目标时会发生什么。
- en: '![](img/ac684402-40d5-4e88-b964-3beede2eaa5a.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ac684402-40d5-4e88-b964-3beede2eaa5a.png)'
- en: When playing the exercise, we can see that a red line appears connecting the
    character and the target, when a target gets inside of the vision zone. This represents
    that our character has spotted an enemy for example.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行练习时，我们可以看到当目标进入视野区域时，会出现一条连接角色和目标的红色线条。这表示我们的角色已经发现了敌人，例如。
- en: '![](img/b681cc3a-af97-4dda-817b-a3e19420e60e.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b681cc3a-af97-4dda-817b-a3e19420e60e.png)'
- en: But, when we move our character and we have an obstacle in front of a target,
    even if the target is inside the vision zone, the character cannot detect him
    because there is an object in front of him blocking his view. This is why we need
    to assign the Obstacle layer to every object that might block the character vision,
    that way he won't have any X-Ray vision.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当我们移动我们的角色并且目标前方有障碍物时，即使目标在视野区域内，角色也无法检测到它，因为有一个物体在他面前阻挡了他的视线。这就是为什么我们需要将障碍层分配给可能阻挡角色视线的每个对象，这样他就不会有任何X射线视野。
- en: '![](img/46329859-33d4-4704-8634-40ebc544b164.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/46329859-33d4-4704-8634-40ebc544b164.png)'
- en: We can also point our character to two targets that both of them will connect
    to, this means that our character is also able to detect more than one target
    at the same time, which is very useful to define better strategies and tactics.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将我们的角色指向两个目标，这两个目标都会连接到，这意味着我们的角色也能够同时检测到多个目标，这对于制定更好的策略和战术非常有用。
- en: Realistic field of view effect
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逼真的视野效果
- en: Now that we have the vision detection working, we can move on to the next step
    and add a realistic field of view effect. This will allow the character to have
    peripheral vision, making what is seen on the sides less detailed and what is
    seen in the front more detailed. It is a simulation of our real human vision,
    where we tend to focus more on what is in front of us and if we need to check
    something that is on the sides, we need to turn into that direction in order to
    have a better look.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使视觉检测工作正常，我们可以继续下一步并添加一个逼真的视野效果。这将使角色具有边缘视野，使得看到的侧面内容更不详细，而前面看到的内容更详细。这是对我们真实人类视觉的模拟，我们倾向于更多地关注我们面前的事物，如果我们需要检查侧面的某个东西，我们需要转向那个方向以便更好地查看。
- en: 'Let''s start by opening our `FieldOfView` script. Then we add a new float variable
    called `meshResolution`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开我们的`FieldOfView`脚本开始。然后我们添加一个新的浮点变量，称为`meshResolution`：
- en: '[PRE18]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we need to create a new method and we are going to call it `DrawFieldOfView`.
    Inside of this method, we will define the amount of `Raycast` lines that our field
    of view will have. Also we will define the angle of each line that will be drawn:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个新的方法，我们将称之为`DrawFieldOfView`。在这个方法中，我们将定义我们的视野将有多少条`Raycast`线。我们还将定义每条将被绘制的线的角度：
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After creating this new method, we simply need to call it from the update:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了这个新方法之后，我们只需要从更新中调用它：
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'At this point, we can open the game editor and test it to visualize what we
    have created:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以打开游戏编辑器并测试它，以可视化我们所创建的内容：
- en: '![](img/f630c4ad-fc30-417f-a05e-2f1eccffc35e.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f630c4ad-fc30-417f-a05e-2f1eccffc35e.png)'
- en: Right away when we press play to test our script, we won't see any difference
    between the old version and the new one. This is normal because we need to increase
    the Mesh Resolution of our character.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们按下播放按钮来测试我们的脚本，我们不会在旧版本和新版本之间看到任何区别。这是正常的，因为我们需要增加我们角色的网格分辨率。
- en: '![](img/fbeb3b37-d971-4b52-aec0-de7e0f2652bb.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fbeb3b37-d971-4b52-aec0-de7e0f2652bb.png)'
- en: As we can see in the preceding screenshot, we need to add a value in the Mesh
    Resolution variable in order to see the desirable results.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的屏幕截图中所看到的，我们需要在网格分辨率变量中添加一个值，以便看到期望的结果。
- en: '![](img/a9f5c71a-1b2d-4b44-b89a-38acc21c00d3.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a9f5c71a-1b2d-4b44-b89a-38acc21c00d3.png)'
- en: Adding 0.08 into the Mesh Resolution variable, we can notice already that on
    the game editor window, a few red lines appear and that's exactly what we wanted.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将0.08添加到网格分辨率变量中，我们就可以注意到在游戏编辑器窗口中已经出现了一些红色线条，这正是我们想要的。
- en: 'If we keep increasing the value, more lines will be added, meaning that more
    detailed the vision will be, which is exemplified in the following screenshot:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续增加这个值，将会添加更多的线条，这意味着视野将更加详细，这在下面的屏幕截图中有示例：
- en: '![](img/3b826825-f63f-4f31-a0cd-afcf2658e88c.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b826825-f63f-4f31-a0cd-afcf2658e88c.png)'
- en: But, we need to remember that increasing this value also increases the device
    CPU usage and we need to take this into consideration, especially if we are going
    to have multiple characters at once on the screen.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们需要记住，增加这个值也会增加设备的CPU使用率，我们需要考虑这一点，尤其是如果我们打算在屏幕上同时显示多个角色时。
- en: 'Now let''s get back to our script and add a collision detection for each line,
    allowing our character to receive information from multiple lines at once. We
    start by creating a new method in which we will store all the information regarding
    the raycasts that will be created:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的脚本，并为每行添加碰撞检测，使我们的角色能够同时接收来自多条线的信息。我们首先创建一个新的方法，我们将存储有关将要创建的射线投射的所有信息：
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once this new method is created we can go back to our `DrawFieldOfView()` method
    and start adding the raycasts that will detect the collisions for each line:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了新的方法，我们就可以回到我们的 `DrawFieldOfView()` 方法，并开始添加将检测每行碰撞的射线投射：
- en: '[PRE22]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To understand the next steps, let''s see how a mesh is generated from a script:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解下一步，让我们看看如何从脚本中生成网格：
- en: '![](img/8e577532-6cde-4c04-a4bc-f0b619d54ea6.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e577532-6cde-4c04-a4bc-f0b619d54ea6.jpg)'
- en: In the preceding diagram, we can see one dark circle that represents the character
    and four with circles, representing the raycast finish position.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到一个代表角色的黑色圆圈和四个带有圆圈的圆圈，代表射线投射的结束位置。
- en: '![](img/bd643b69-4fe1-405d-8f2b-bc3af4098046.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd643b69-4fe1-405d-8f2b-bc3af4098046.jpg)'
- en: Each vertices has a value assigned to them, the first vertex that starts from
    the character, is the number zero, then it goes on a clockwise sense with the
    next vertex starting on the left and continuing counting to the right side.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 每个顶点都分配了一个值，从角色开始的第一个顶点是数字零，然后以顺时针方向继续，下一个顶点从左侧开始，并继续向右计数。
- en: '![](img/3d80f535-0054-421d-ac84-5a3c7a2fa642.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d80f535-0054-421d-ac84-5a3c7a2fa642.jpg)'
- en: The vertex zero connects to the vertex **1**.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点零连接到顶点 **1**。
- en: '![](img/3b28398f-7ccc-4f4a-89b9-85a9088a81eb.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b28398f-7ccc-4f4a-89b9-85a9088a81eb.jpg)'
- en: Then vertex one connects to vertex **2**.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后顶点一连接到顶点 **2**。
- en: '![](img/7c1ce432-df92-4de6-aa0b-3ea4eb7ad587.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c1ce432-df92-4de6-aa0b-3ea4eb7ad587.jpg)'
- en: And then vertex two connects back to vertex **0**, creating a triangle mesh.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后顶点二连接回顶点 **0**，创建一个三角形网格。
- en: '![](img/fd33acfe-727d-4d67-9b79-e5912f4fb855.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd33acfe-727d-4d67-9b79-e5912f4fb855.jpg)'
- en: 'Once the first triangle mesh is created, it continues to the next one, starting
    from *0 > 2 > 3 > 0* and the second triangle is also created. And finally the
    last one, *0 > 3 > 4 > 0*. Now, we want to transcribe this information into our
    code, so in this case the array of the field of view is:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了第一个三角形网格，它将继续到下一个，从 *0 > 2 > 3 > 0* 开始，第二个三角形也被创建。最后一个是 *0 > 3 > 4 > 0*。现在，我们想要将这个信息转录到我们的代码中，所以在这种情况下，视野的数组是：
- en: '`[0,1,2,0,2,3,0,3,4]`'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`[0,1,2,0,2,3,0,3,4]`'
- en: 'The total number of vertices on this example is five:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中的顶点总数是五个：
- en: '`v = 5`'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`v = 5`'
- en: 'The total number of triangles created is three:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的三角形总数是三个：
- en: '`t = 3`'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`t = 3`'
- en: 'So the number of triangles is:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，三角形的数量是：
- en: '`t = v-2`'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`t = v-2`'
- en: 'That means that the length of our array will be:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们数组的长度将是：
- en: '`(v-2)*3`'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`(v-2)*3`'
- en: 'Now let''s get back to our script and add the information that we have solved
    here:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的脚本，并添加我们在这里解决的信息：
- en: '[PRE23]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, let''s go to the top of our script and add two new variables, `public
    MeshFilter viewMeshFilter` and `Mesh viewMesh`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到脚本的顶部并添加两个新的变量，`public MeshFilter viewMeshFilter` 和 `Mesh viewMesh`：
- en: '[PRE24]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we need to call those variables into our start method:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在我们的 `start` 方法中调用这些变量：
- en: '[PRE25]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![](img/95763e1f-765a-4c97-aa1b-254e556b4080.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95763e1f-765a-4c97-aa1b-254e556b4080.png)'
- en: 'The next step is to select our Character object inside the game editor:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在游戏编辑器中选择我们的 `Character` 对象：
- en: '![](img/9a9b1fb9-0d47-4921-8bdf-3fd1e66b0eb8.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a9b1fb9-0d47-4921-8bdf-3fd1e66b0eb8.png)'
- en: 'Go to the GameObejct section and select Create Empty Child:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 `GameObejct` 部分，并选择创建空子对象：
- en: '![](img/4c1a9279-a634-46f5-9c9f-e509234a12a7.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c1a9279-a634-46f5-9c9f-e509234a12a7.png)'
- en: Rename the object to View Visualization.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象重命名为 View Visualization。
- en: '![](img/7c219883-29ed-4ef9-a3b0-106a78f48dc9.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c219883-29ed-4ef9-a3b0-106a78f48dc9.png)'
- en: 'With the same object selected, we go to: Component | Mesh | Mesh Filter, to
    add a mesh filter to our object.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的选择对象，我们转到：组件 | 网格 | 网格过滤器，为我们对象添加一个网格过滤器。
- en: '![](img/123ea51a-f0c6-4ebf-81ed-cdccaca7b551.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/123ea51a-f0c6-4ebf-81ed-cdccaca7b551.png)'
- en: Then we need to do the same for the Mesh Renderer, Component | Mesh | Mesh Renderer.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要对Mesh Renderer，组件 | 网格 | 网格渲染器做同样的操作。
- en: '![](img/d592e1a7-f96e-45d3-a88a-53c5a9d43da9.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d592e1a7-f96e-45d3-a88a-53c5a9d43da9.png)'
- en: We can turn off the Cast Shadows and Receive Shadows.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以关闭“投射阴影”和“接收阴影”。
- en: '![](img/0ce28d17-f2cb-4d11-9753-e19552e3c95e.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ce28d17-f2cb-4d11-9753-e19552e3c95e.png)'
- en: Finally, we add the object that we just created into our script variable View
    Mesh Filter and change the Mesh Resolution to any desirable value, in this case
    we have chosen 1.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将我们刚刚创建的对象添加到我们的脚本变量View Mesh Filter中，并将网格分辨率更改为任何期望的值，在这种情况下我们选择了1。
- en: 'Now, we can return to our script and add edit once again the `DrawFieldOfView`
    method:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以回到我们的脚本中，再次编辑`DrawFieldOfView`方法：
- en: '[PRE26]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s test the game, to see what we have done here:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试游戏，看看我们在这里做了什么：
- en: '![](img/66995580-5e1c-475e-8e8e-a6093f2f6952.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66995580-5e1c-475e-8e8e-a6093f2f6952.png)'
- en: When we play the game, we will notice the mesh being rendered on the game and
    that's our objective so far.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们玩游戏时，我们会注意到网格在游戏中的渲染，这是我们目前的目标。
- en: Remember to remove the `Debug.DrawLine` line of code, otherwise the mesh won't
    show on the game editor.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 记得删除`Debug.DrawLine`这一行代码，否则网格在游戏编辑器中不会显示。
- en: 'In order to optimize the visualization, we need to change the `viewPoints`
    from global to local space points. To do this we are going to use `InverseTransformPoint`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化可视化，我们需要将`viewPoints`从全局空间点更改为局部空间点。为此，我们将使用`InverseTransformPoint`：
- en: '[PRE27]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, if we test it again it will be more accurate.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次测试它，它将更加准确。
- en: '![](img/8b85c7e6-45b2-4d6d-8112-5dbd61cf1c9e.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b85c7e6-45b2-4d6d-8112-5dbd61cf1c9e.png)'
- en: 'It looks good already, but we can still improve it by changing from `Update`
    to `LateUpdate`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来已经不错了，但我们可以通过将`Update`改为`LateUpdate`来进一步改进：
- en: '[PRE28]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Doing this the movement of our mesh will be smoother.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做，我们网格的移动将更加平滑。
- en: '![](img/3c05259b-0101-4e75-83f9-93d968b1c1da.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c05259b-0101-4e75-83f9-93d968b1c1da.png)'
- en: With this part of the script updated, we conclude our example, completing a
    realistic field of view system into our character.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 更新了这部分脚本后，我们总结了我们的示例，将一个逼真的视野系统整合到我们的角色中。
- en: '![](img/06eb7e13-eeb5-4708-9ec3-db14387c3f68.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06eb7e13-eeb5-4708-9ec3-db14387c3f68.png)'
- en: All we need is to change the values in order to fit the results that we are
    looking for, making our character more or less aware of his surroundings.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要改变数值以适应我们想要的结果，使我们的角色或多或少地意识到他的周围环境。
- en: '![](img/a5b0af90-f822-48c7-acc6-fde42381d24c.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5b0af90-f822-48c7-acc6-fde42381d24c.png)'
- en: For example, if we set the `View Angle` value to `360`, that makes our character
    completely aware of what is happening around and if we decrease the value, we
    will reach a more realistic vision, just like it's used in a *Metal Gear Solid*
    game.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们设置`View Angle`值为`360`，这将使我们的角色完全意识到周围发生的事情，如果我们降低值，我们将达到更逼真的视野，就像在*合金装备固体*游戏中使用的那样。
- en: '![](img/33e412a2-e599-4054-a96f-d385b03c160a.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33e412a2-e599-4054-a96f-d385b03c160a.png)'
- en: At this point we are able to pick a stealth game and copy their most iconic
    features such as realistic vision and audio awareness. We have learned the foundations
    and now we can start from there and develop our own game.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们能够选择一个潜行游戏，并复制它们最标志性的特征，如逼真的视野和音频意识。我们已经学到了基础，现在我们可以从这里开始，开发我们自己的游戏。
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we unveiled how stealth games work and how we can recreate
    that same system so we can use it in our games. We went from a simple approach
    to a complex one, allowing us to decide what fits better in the game that we are
    creating, if it relies heavily on stealth or if we simply need a basic system
    to make our character detect the player by vision or audio awareness. The features
    that we have learned in this chapter can also be expanded and used in practically
    any example that we have created before, amplifying the collision detection, the
    pathfinding, the decisions, animations, and many more features, turning them from
    functional to realistic.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们揭示了潜行游戏的工作原理以及我们如何重新创建相同的系统，以便我们可以在游戏中使用它。我们从简单的方法过渡到复杂的方法，使我们能够决定在创建的游戏中什么更适合，如果它高度依赖于潜行，或者我们只需要一个基本系统来使我们的角色通过视觉或听觉意识来探测玩家。本章学到的特性也可以扩展并用于我们之前创建的任何实际例子中，增强碰撞检测、路径查找、决策、动画以及许多其他特性，将它们从功能性转变为现实性。
- en: The way we create games is constantly updating, every game published brings
    a new or different method to create something, which is only possible if we are
    willing to experiment and blend everything we know, adjusting our knowledge to
    achieve the results we want to even if they look extremely complicated. Sometimes
    it is just a matter of exploring basic concepts and expanding them, turning a
    simple idea into a complex system.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建游戏的方式不断更新，每款发布的游戏都带来了一种新的或不同的创建方法，这只有在我们愿意实验并融合我们所知道的一切，调整我们的知识以实现我们想要的结果，即使它们看起来极其复杂的情况下才可能。有时这仅仅是一个探索基本概念并扩展它们的问题，将一个简单想法转变为复杂系统。
