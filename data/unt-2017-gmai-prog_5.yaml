- en: Flocks and Crowds
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鸟群和人群
- en: 'Flocks and crowds are two additional core AI concepts we''ll be exploring in
    this book. As you''ll see in this chapter, flocks are relatively simple to implement,
    and they add a fairly extraordinary amount of realism to your simulation in just
    a few lines of code. Crowds can be a bit more complex, but we''ll be exploring
    some of the powerful tools that come bundled with Unity to get the job done. In
    this chapter, we''ll cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 鸟群和人群是本书中将探讨的两个额外的核心人工智能概念。正如你将在本章中看到的那样，鸟群相对容易实现，只需几行代码就能为你的模拟增加相当多的真实感。人群可能更复杂一些，但我们将探讨Unity附带的一些强大工具来完成这项工作。在本章中，我们将涵盖以下主题：
- en: Learning the history of flocks and herds
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习鸟群和兽群的历史
- en: Understanding the concepts behind flocks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解鸟群背后的概念
- en: Flocking using the traditional algorithm
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用传统算法进行群聚
- en: Using realistic crowds
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用逼真的人群
- en: Learning the origins of flocks
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习鸟群的起源
- en: The flocking algorithm dates all the way back to the mid-80s. It was first developed
    by *Craig Reynolds*, who developed it for use in films, the most famous adaptation
    of the technology being the swarm of bats in *Batman Returns* in 1992, for which
    he won an Oscar. Since then, the use of the flocking algorithm has expanded beyond
    the world of film into various fields, from games to scientific research. Despite
    being relatively efficient and accurate, the algorithm is also very simple to
    understand and implement.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 群聚算法可以追溯到80年代中期。它最初是由**克雷格·雷诺斯**开发的，用于电影制作，最著名的应用是1992年电影《蝙蝠侠归来》中的蝙蝠群，为此他赢得了奥斯卡奖。从那时起，群聚算法的应用已经从电影领域扩展到各个领域，从游戏到科学研究。尽管相对高效和准确，但该算法也非常简单易懂和实现。
- en: Understanding the concepts behind flocks and crowds
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解鸟群和人群背后的概念
- en: As with previous concepts, it's easiest to understand flocks and herds by relating
    them to the real-life behaviors they model. As simple as it sounds, these concepts
    describe a group of objects, or boids as they are called in artificial intelligence
    lingo, moving together as a group. The flocking algorithm gets its name from the
    behavior birds exhibit in nature, where a group of birds follow one another toward
    a common destination, mostly keeping a fixed distance from each other. The emphasis
    here is on the group. We've explored how single agents can move and make decisions
    on their own, but flocks are a relatively computationally efficient way of simulating
    large groups of agents moving in unison while modeling unique movement in each
    boid that doesn't rely on randomness or predefined paths.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的概念一样，通过将它们与它们所模拟的现实生活中的行为联系起来，最容易理解鸟群和兽群。听起来很简单，这些概念描述了一组对象，或者如人工智能术语中所称的“鸟群”，作为一个群体一起移动。群聚算法的名字来源于自然界中鸟类表现出的行为，一群鸟跟随彼此向一个共同的目的地移动，大多数情况下保持固定的距离。这里的重点是群体。我们已经探讨了单个代理如何自主移动和做出决策，但鸟群是一种相对计算效率高的模拟大量代理同时移动的方式，同时每个鸟的独特移动方式不依赖于随机性或预定义的路径。
- en: 'The implementation that we''ll be building in this chapter for flocking is
    built upon the concepts originally developed by Craig Reynolds himself. There
    are many ways to approach Reynolds'' flocking behavior, and in our example we''ve
    gone with a single-threaded optimized version that allocates no memory. Performance
    will vary based on the hardware, but generally speaking, the more boids in your
    flock, the more CPU time it will take to compute the swarm''s direction. There
    are three basic concepts that define how a flock works, and these concepts have
    been around since the algorithm''s introduction in the 80s:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将构建的群聚实现是基于克雷格·雷诺斯本人最初开发的概念。雷诺斯的群聚行为有多种实现方式，在我们的示例中，我们采用了单线程优化版本，不分配任何内存。性能将根据硬件而变化，但一般来说，你的鸟群中的鸟越多，计算鸟群方向的CPU时间就会越长。有三个基本概念定义了鸟群的工作方式，这些概念自80年代算法引入以来一直存在：
- en: '**Separation**: This means maintaining a distance with other neighbors in the
    flock to avoid collision. The following diagram illustrates this concept:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分离**：这意味着与其他鸟群中的邻居保持距离，以避免碰撞。以下图解说明了这一概念：'
- en: '![](img/5376f28d-d54f-44bd-a6e5-c7d01e066b7e.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5376f28d-d54f-44bd-a6e5-c7d01e066b7e.png)'
- en: Diagram of separation in flocking
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 群聚中分离的图解
- en: In the preceding image, the middle boid is shown moving in a direction away
    from the rest of the boids, without changing its heading.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一张图中，中间的鸟以不改变航向的方式向其他鸟移动。
- en: '**Alignment**: This means to moving in the same direction as the flock, and
    with the same velocity. The following image illustrates this concept:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对齐**：这意味着与鸟群以相同的方向和速度移动。以下图像说明了这个概念：'
- en: '![](img/3aaf5ba6-bd9e-42cb-8ada-f15b9a95c815.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3aaf5ba6-bd9e-42cb-8ada-f15b9a95c815.png)'
- en: Diagram of alignment in flocking
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 集群中的对齐图
- en: In the preceding image, the boid in the middle is shown changing its heading
    toward the arrow to match the heading of the boids surrounding it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，中间的boid正在改变其航向，以匹配其周围的boid的航向。
- en: '**Cohesion**: This means maintaining a maximum distance from the flock''s center.
    The following image illustrates this concept:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**凝聚力**：这意味着保持与鸟群中心的最大距离。以下图像说明了这个概念：'
- en: '![](img/f7a635d5-684e-45b9-9556-04746229e91e.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7a635d5-684e-45b9-9556-04746229e91e.png)'
- en: Diagram of cohesion in flocking
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 集群中的凝聚力图
- en: In the preceding image, the boid to the right of the flock moves in the direction
    of the arrow to be within the minimum distance to its nearest group of boids.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，鸟群右侧的boid移动到箭头方向，以确保其与最近的boid组的距离最小。
- en: Using the Reynolds algorithm
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用雷诺兹算法
- en: 'Without further ado, let''s dive into the Reynolds flocking algorithm. There
    are two main scripts for our flocking implementation: `Boid.cs` and `FlockController.cs`.
    The sample code for this chapter provides a scene with all the necessary setup
    for testing. You''ll also notice a third script named `TargetMovement.cs`, which
    we use to move a target that our flock will follow around the scene.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，让我们深入了解雷诺兹集群算法。我们的集群实现有两个主要的脚本：`Boid.cs`和`FlockController.cs`。本章的示例代码提供了一个包含所有必要设置的场景，用于测试。你还会注意到一个名为`TargetMovement.cs`的第三个脚本，我们使用它来移动场景中我们的鸟群将跟随的目标。
- en: 'For our boid, we can use a simple cube as a prefab. Of course, feel free to
    replace the cube with any art you want. Let''s add the `Boid.cs` script to our
    boid prefab. The code looks like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的boid，我们可以使用一个简单的立方体作为预制件。当然，你可以随意用任何你想要的美术作品替换立方体。让我们将`Boid.cs`脚本添加到我们的boid预制件中。代码看起来是这样的：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Right off the bat, you'll notice a reference to `FlockController`, which we
    will create next. You can think of `FlockController` as the shared brain of the
    swarm/flock. Each boid does not need to be aware of its neighbors directly, because
    `FlockController` handles this information separately. This allows us to keep
    the boid code nice and tidy.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，你就会注意到对`FlockController`的引用，我们将在下一步创建它。你可以将`FlockController`视为集群/鸟群的共享大脑。每个boid不需要直接意识到其邻居，因为`FlockController`会单独处理这些信息。这使我们能够保持boid代码整洁。
- en: We initialize the direction vector in our `Awake` method, and we make sure that
    the `FlockController` is assigned, or we log an error. There are several ways
    you can enforce null-safety, such as creating the instance if not provided, but
    in our case we'll assume you assigned the value via the inspector.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Awake`方法中初始化方向向量，并确保`FlockController`被分配，或者我们记录一个错误。你可以通过多种方式强制执行空安全，例如，如果没有提供，则创建实例，但在我们的情况下，我们将假设你通过检查器分配了值。
- en: The `Update` method does the rest of the workit calls the `Flock()` method on `FlockController`
    and passes in a reference to itself, its local position, and its direction. This
    will return a vector that we then normalize to keep movement from appearing jerky
    or too fast, and apply the movement by using `Transform.Translate()`. As usual,
    make sure you're easing the movement over the `Time.deltaTime` to ensure smooth
    frame-to-frame movement.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update`方法完成其余的工作——它在`FlockController`上调用`Flock()`方法，并传入对自身的引用、其局部位置和其方向。这将返回一个向量，然后我们将其归一化以保持运动看起来不会太突然或太快，并使用`Transform.Translate()`应用运动。像往常一样，确保你在`Time.deltaTime`上平滑运动，以确保帧与帧之间的平滑运动。'
- en: It's important to note that we make sure to cache as many `Vector3` variables
    as needed. Avoid allocations by avoiding the use of `new Vector3()` where possible.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们确保缓存尽可能多的`Vector3`变量。通过避免使用`new Vector3()`来避免分配，尽可能减少分配。
- en: Implementing the FlockController
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现FlockController
- en: 'The `FlockController` is going to handle the orchestration of the entire flock.
    There is a quite a bit going on here in terms of variables. Let''s take a look
    at `FlockController.cs` chunk by chunk:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlockController`将处理整个鸟群的协调。在变量方面，这里有很多事情要做。让我们逐块查看`FlockController.cs`：'
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we simply assign the size of our flock. You''ll see this value being
    used up ahead in the `Awake` method:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简单地分配我们鸟群的规模。你将在后面的`Awake`方法中看到这个值的使用：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We then declare a series of modifier and weight values. `speedModifier` directly
    affects how fast our boids can move. Tweak this as needed. The three values following
    `speedModifier` are weight values for alignment, cohesion, and separation, respectively.
    These values will multiply their weight in the final calculation of all the direction
    vectors that drive the movement of the boid. `followWeight` is used to weight
    the effect of the target's delta versus the boid. If you want the boids to follow
    the target more closely, increase this value.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们声明一系列的修改器和权重值。`speedModifier` 直接影响我们的鸟可以移动多快。根据需要调整这个值。`speedModifier`
    后面的三个值分别是对齐、凝聚和分离的权重值。这些值将在最终计算所有驱动鸟移动的方向向量的权重中乘以其权重。`followWeight` 用于权衡目标的变化量与鸟的变化量。如果你想使鸟更紧密地跟随目标，增加这个值。
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The following chunk of variables defines some more setup variables that we assign
    in the inspector. First, we have the prefab of the boid to spawn (which should
    have the `Boid.cs` component attached to it). `spawnRadius` is used to avoid artifacts
    that may come from spawning all the boids on top of each other if we were to spawn
    them all on one point. Instead, we spawn them within the given radius, as defined
    in this variable. Lastly, `target` is a reference to the transform of the target
    our flock/swarm will follow. In our test scene, it's a sphere with the `TargetMovement.cs`
    component attached to it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下变量块定义了一些更多的设置变量，我们在检查器中分配这些变量。首先，我们有要生成的鸟的预制体（它应该附加了 `Boid.cs` 组件）。`spawnRadius`
    用于避免在所有鸟群成员都生成在同一个点上时可能出现的错误。相反，我们在给定的半径内生成它们，如这个变量所定义的。最后，`target` 是我们鸟群/群体的目标变换的引用。在我们的测试场景中，它是一个带有
    `TargetMovement.cs` 组件的球体。
- en: 'Let''s take a look at the `Awake` method:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Awake` 方法：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We iterate through a loop enough times to spawn enough boids for our `flockSize`
    variable. This is where our `spawnLocation` and `spawnRadius` come into play.
    Unity's `Random.insideUnitSphere` generates the random position, which we add
    to our transform's position to get the actual spawn location. We then instantiate
    the boid prefab, while assigning to a `Boid` instance, which we then add to our
    `flockList`. Also note that we assign the boid instance's `FlockController` property
    in this step.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过循环足够多次来生成足够的鸟以填充我们的 `flockSize` 变量。这是我们的 `spawnLocation` 和 `spawnRadius`
    发挥作用的地方。Unity 的 `Random.insideUnitSphere` 生成随机位置，我们将它添加到我们的变换位置以得到实际的生成位置。然后我们实例化鸟的预制体，将其分配给一个
    `Boid` 实例，然后将其添加到我们的 `flockList` 中。此外，请注意，我们在这一步分配了鸟实例的 `FlockController` 属性。
- en: Keep in mind that instantiating prefabs can be slow in Unity, so increasing
    the number of boids in the flock will lead to a huge performance dip during the
    instantiation frame.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在 Unity 中实例化预制体可能会很慢，因此增加鸟群中的鸟的数量会导致实例化帧期间性能大幅下降。
- en: 'The only other method in this class is the `Flock()` method, which we saw being
    called from `Boid` earlier. This does all the computation for the individual boids''
    directions. It looks like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本类中唯一的另一种方法是 `Flock()` 方法，我们之前在 `Boid` 中看到过它被调用。这个方法负责计算单个鸟群成员的方向。它看起来是这样的：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The method takes some information about our `Boid`, as well as a copy of it.
    We then iterate through every boid in the `flockList` and assign the boid at the
    current iteration''s index to a temporary value called `neighbor`. To avoid doing
    multiple loops, we do several things in the same `for` loop:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受有关我们的 `Boid` 的某些信息，以及它的一个副本。然后我们遍历 `flockList` 中的每个鸟，并将当前迭代索引处的鸟分配给一个临时值，称为
    `neighbor`。为了避免进行多个循环，我们在同一个 `for` 循环中做几件事情：
- en: Sum up all the neighbors' directions
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 求所有邻居的方向之和
- en: Sum up all the neighbors' positions
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 求所有邻居的位置之和
- en: Sum up the position deltas to all neighbors
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 求到所有邻居的位置变化量之和
- en: 'Once done with the loop (and thus aggregating all of the preceding values),
    we calculate the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成循环（从而汇总所有前面的值），我们计算以下内容：
- en: The flock direction, which we get by averaging the direction of all the boids.
    Since we've already got the sum of all the directions, we just divide it by the
    number of boids, the `flockSize`. We then normalize the value and apply the weight
    we defined earlier. This will give us our alignment.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鸟群方向，通过平均所有鸟的方向得到。由于我们已经得到了所有方向的总和，我们只需将其除以鸟的数量，即 `flockSize`。然后我们规范化这个值并应用我们之前定义的权重。这将给我们我们的对齐。
- en: Similarly, we get the centroid of the flock by averaging all the positions of
    all the boids. As with direction, we normalize the vector before applying the
    weighting. The `flockCenter` gives us our cohesion vector.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，我们通过平均所有鸟群的位置来获取鸟群的质心。与方向一样，我们在应用加权之前对向量进行归一化。`flockCenter`给我们提供了我们的凝聚力向量。
- en: You may be seeing a pattern here, right? As with the previous two values, we
    average, normalize, then weight our separation value.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在这里看到了一个模式，对吧？就像前两个值一样，我们取平均值，然后归一化，最后对分离值进行加权。
- en: '`targetDirection` is a bit different. We first take the delta between the boid''s
    position and the target''s position, then we apply the weight. We don''t normalize
    this value in this implementation, but feel free to experiment by doing so. Normalizing
    this value won''t break the simulation, but you may notice your boids casually
    floating away from the target if it moves too fast.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`targetDirection`有一点不同。我们首先计算鸟群位置和目标位置之间的差值，然后应用权重。在这个实现中，我们不归一化这个值，但你可以自由地通过这样做来实验。归一化这个值不会破坏模拟，但你可能会注意到如果你的目标移动得太快，鸟群可能会随意地漂浮离目标。'
- en: With all of the values—cohesion, alignment, and separation—calculated, we add
    them up and return them to the `Boid` instance that called the method. The boid
    will use this vector as its target direction, as we saw in the `Boid.cs` file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算出所有的值——凝聚力、对齐和分离——之后，我们将它们加起来，并将结果返回给调用该方法的`Boid`实例。鸟群将使用这个向量作为它的目标方向，正如我们在`Boid.cs`文件中看到的。
- en: 'Because we could potentially have dozens or hundreds of boids, it''s important
    to avoid any unnecessary computations at runtime. If you profile our implementation,
    you''ll notice it allocates no memory whatsoever, meaning you won''t have any
    annoying stuttering due to garbage collection. While the system will slow down
    as the boid count goes into the hundreds due to its single-threaded nature, having
    a few dozen boids is very fast. As you can see in the following screenshot, having
    a small flock flying around can be computed in less than a millisecond:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可能有一打或几百个鸟群，因此在运行时避免任何不必要的计算是很重要的。如果你对我们的实现进行性能分析，你会注意到它根本不分配任何内存，这意味着你不会因为垃圾回收而遇到任何令人烦恼的卡顿。由于系统的单线程特性，随着鸟群数量的增加，系统会变慢，但几十个鸟群运行得非常快。正如你在下面的屏幕截图中所看到的，一个小鸟群在飞行中的计算可以在不到一毫秒内完成：
- en: '![](img/55fe85bc-eac2-400e-a151-842a32fae26a.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/55fe85bc-eac2-400e-a151-842a32fae26a.png)'
- en: The stats panel showing our scene's performance
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 显示我们场景性能的统计面板
- en: The flock target
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鸟群目标
- en: 'Last, but not least, we have our flock target. To reiterate, you can use any
    art you like, or you can stick with the handsome little sphere in the provided
    sample project. The code for the target component is in the `TargetMovement.cs`
    file. The contents look like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们有我们的鸟群目标。再次强调，你可以使用你喜欢的任何艺术作品，或者你可以坚持使用提供的示例项目中那个英俊的小球体。目标组件的代码位于`TargetMovement.cs`文件中。内容看起来是这样的：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are two main chunks of work in this class. First, `Update` moves the game
    object towards the `forward` vector, while rotating it towards the `targetPosition`.
    We provide two variables to modify the move and turn speed: `moveSpeed` and `turnSpeed`,
    respectively. We then check whether we've arrived at the destination point by
    comparing the distance to it against a tolerance radius that we define in `targetPointTolerance`.
    If we're close enough, we then set the next target point by calling `CalculateNextMovementPoint()`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中有两个主要的工作部分。首先，`Update`方法将游戏对象移动到`forward`向量方向，同时旋转它朝向`targetPosition`。我们提供了两个变量来修改移动和转向速度：`moveSpeed`和`turnSpeed`。然后我们通过比较到达目标点的距离与我们在`targetPointTolerance`中定义的容差半径来检查我们是否已经到达目的地。如果我们足够接近，我们就通过调用`CalculateNextMovementPoint()`来设置下一个目标点。
- en: In `CalculateNextMovementPoint()`, we set a random target position, but constrain
    it based on our bounds values, relative to the position of the target when we
    first run the script, as we set the `initialPosition` in `Awake`. Constraining
    this point will prevent the target from slowly deviating away from our game area
    and floating off into the sunset. Dramatic as it may be, it's not quite the effect
    we're going for here.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CalculateNextMovementPoint()`中，我们设置一个随机的目标位置，但基于我们边界值进行约束，相对于我们首次运行脚本时目标的位置，因为我们已经在`Awake`中设置了`initialPosition`。约束这个点将防止目标慢慢偏离我们的游戏区域，并飘向日落。虽然这可能很戏剧化，但这并不是我们在这里追求的效果。
- en: The scene layout
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景布局
- en: 'Now that we have all of our code covered, let''s take a look at our scene.
    Our sample scene looks like the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经覆盖了所有代码，让我们看看我们的场景。我们的示例场景看起来如下截图所示：
- en: '![](img/fb0618ef-90db-4055-be9c-5c970a4da466.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb0618ef-90db-4055-be9c-5c970a4da466.png)'
- en: An overview of our scene layout
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们场景布局的概述
- en: 'As you can see in the preceding screenshot, there isn''t a lot of complexity
    to our setup. We have a plane, some environment cubes for perspective, a light,
    a camera, and our target. The full hierarchy looks like the following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一张截图所示，我们的设置并没有太多复杂性。我们有一个平面，一些用于透视的环境立方体，一盏灯，一个摄像机和我们的目标。完整的层次结构如下截图所示：
- en: '![](img/e3512b5a-05c6-446e-a545-a47b397cf1bd.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e3512b5a-05c6-446e-a545-a47b397cf1bd.png)'
- en: Our scene hierarchy with FlockController highlighted
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 FlockController 高亮的场景层次结构
- en: As you can see from the preceding screenshot, we have a Directional light, and
    nested underneath it is a reflection probe. This is strictly for making the scene
    look nice, and has essentially no functional value, but hey, a little vanity never
    hurt anyone! We then have an empty game object named FlockController, which our
    `FlockController` script is attached to. The Target game object is a sphere with
    a bright yellow material and the `TargetMovement` script attached to it. All of
    the environment blocks are nested under the Environment game object, which in
    this case is a plane. The last three items are there to drive our camera, which
    will automatically lock on to our target, and keep it in frame. As it is outside
    the scope of this book, we'll skip over how the camera works, but if you're the
    curious type, you'll want to explore the official Unity documentation for more
    information on **Cinemachine** and **Timeline**, which drive the camera in our
    scene.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一张截图所示，我们有一个方向光，其下嵌套了一个反射探针。这完全是出于让场景看起来更美观的目的，实际上几乎没有功能价值，但嘿，一点虚荣心永远不会伤害任何人！然后我们有一个名为
    FlockController 的空游戏对象，我们的 `FlockController` 脚本附加到它上面。目标游戏对象是一个带有明亮的黄色材质的球体，并附加了
    `TargetMovement` 脚本。所有环境块都嵌套在 Environment 游戏对象下，在这个例子中是一个平面。最后三项是为了驱动我们的摄像机，它将自动锁定到我们的目标，并保持在画面中。由于这超出了本书的范围，我们将跳过摄像机的工作原理，但如果你是好奇的类型，你可能会想探索官方
    Unity 文档，了解更多关于 **Cinemachine** 和 **Timeline** 的信息，它们驱动着我们的场景中的摄像机。
- en: 'Back to the matter at hand—let''s take a look at the `FlockController`, which
    looks like the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 回到正题——让我们看看 `FlockController`，它看起来如下截图所示：
- en: '![](img/a75fa6d5-c731-4065-89cb-7d2ec8322047.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a75fa6d5-c731-4065-89cb-7d2ec8322047.png)'
- en: The FlockController component
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: FlockController 组件
- en: 'The preceding screenshot shows the values we have set in the sample scene.
    As you can see, the separation weight is a bit higher than the rest. Feel free
    to tweak the weight values in play mode to see how it affects the boids'' behavior.
    Next, let''s take a look at the target game object. The following screenshot shows
    our sample setup:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了我们在示例场景中设置的值。正如你所见，分离权重略高于其他设置。在播放模式下自由调整权重值，看看它如何影响 boids 的行为。接下来，让我们看看目标游戏对象。以下截图显示了我们的示例设置：
- en: '![](img/3b639f13-9322-4063-9078-79fe5cf80c49.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3b639f13-9322-4063-9078-79fe5cf80c49.png)'
- en: The test values for our target movement script
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目标移动脚本的测试值
- en: 'The screenshot shows the optimal values for our test scene. Tweaking the bounds
    might result in some wild camera movement, but play with the move and turn speed
    to see how it affects the scene in play mode. Lastly, let''s take a look at our
    boid prefab, which has the `Boid` component on it. The provided sample project''s
    boid settings can be seen in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 截图显示了测试场景的最佳值。调整边界可能会导致一些疯狂的摄像机移动，但请尝试调整移动和转向速度，看看它如何在播放模式下影响场景。最后，让我们看看我们的
    boid 预制件，它上面有 `Boid` 组件。提供的示例项目的 boid 设置可以在以下截图中看到：
- en: '![](img/6d7cd9c4-38d7-4dd5-880a-2e7c785a7cf7.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6d7cd9c4-38d7-4dd5-880a-2e7c785a7cf7.png)'
- en: All the components and setup for the Boid game object
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Boid 游戏对象的全部组件和设置
- en: There isn't too much excitement in the preceding screenshot. As you can see,
    the Flock Controller is empty (because we assign it via code at runtime), and
    there are no other values to be tweaked on the boid itself, besides the appearance
    if you feel so inclined, but our neon green cube is a work of art, if I do say
    so myself.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前一张截图并没有太多激动人心的内容。正如你所见，Flock Controller 是空的（因为我们通过代码在运行时分配它），boid 本身没有其他可调整的值，除非你愿意调整外观，但我们的霓虹绿立方体确实是一件艺术品，如果我说了算的话。
- en: 'When you hit play, you''ll see your boids spawn and follow the target as it
    zooms around the scene. It''ll look something like the following screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你按下播放时，你会看到你的鸟群孵化并跟随目标在场景中移动。它看起来可能像下面的屏幕截图：
- en: '![](img/a2c2f552-2999-4cd5-a261-ee41ca3f3e40.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2c2f552-2999-4cd5-a261-ee41ca3f3e40.png)'
- en: Our flock of boids swarming towards the target sphere
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的一群鸟群正涌向目标球体
- en: And just like that, we've created our very own flocking system. It's highly
    encouraged that you not only tweak the values in the inspector, but that you take
    a stab at modifying the code. The easiest way to see how a value affects the entire
    system is to either remove it, or increase it by a ridiculous amount. Next, we'll
    take a look at crowds in Unity 2017.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们创建了自己的群体系统。强烈建议您不仅调整检查器中的值，还尝试修改代码。查看一个值如何影响整个系统的最简单方法就是将其移除，或者将其增加到荒谬的程度。接下来，我们将探讨Unity
    2017中的群体。
- en: Using crowds
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用群体
- en: Crowd simulations are far less cut-and-dried. There really isn't any *one* way
    to implement them in a general sense. While not a strict definition, the term
    "crowd simulation" generally refers to simulating crowds of humanoid agents navigating
    an area while avoiding each other and the environment. Like flocks, the use of
    crowd simulations has been widely used in films. For example, the epic armies
    of Rohan, Gondor, and Mordor battling one another in *The Lord of the Rings* were
    completely procedurally generated using the crowd simulation software **Massive**,
    which was created for use in the film. While the use of crowd algorithms is not
    as widespread in video games as in films, certain genres rely on the concept more
    than others. Real-time strategy games often involve armies of characters moving
    in unison across the screen, and many sandbox games simulate dense cities with
    many agents on-screen going about their day while avoiding each other, the player,
    and even traffic.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 群体模拟远非一目了然。在广义上，并没有任何一种方法可以实施它们。虽然不是一个严格的定义，但“群体模拟”这个术语通常指的是模拟人群化代理在区域内导航，同时避免彼此和环境。像鸟群一样，群体模拟在电影中的应用已经非常广泛。例如，在《指环王》中，罗翰、刚铎和魔多的史诗般的军队相互战斗，这些军队完全是通过群体模拟软件**Massive**进行程序化生成的，该软件是为电影制作的。虽然群体算法在视频游戏中的应用不如在电影中广泛，但某些类型比其他类型更依赖于这一概念。实时策略游戏通常涉及屏幕上移动的军队，而许多沙盒游戏模拟了密集的城市，屏幕上有许多代理在避免彼此、玩家甚至交通的同时度过他们的日常生活。
- en: Implementing a simple crowd simulation
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个简单的群体模拟
- en: 'Our implementation will be quick, simple, and effective, and it will focus
    on using Unity''s NavMesh feature. Thankfully, NavMesh will handle much of the
    heavy lifting for us. Our sample Crowds scene has a simple walking surface with
    a NavMesh baked onto it, a couple of targets, and two teams of capsules, as shown
    in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现将快速、简单且有效，并将专注于使用Unity的NavMesh功能。幸运的是，NavMesh将为我们处理大部分繁重的工作。我们的示例群体场景有一个简单的行走表面，上面烘焙了NavMesh，一些目标，以及两个胶囊队伍，如下面的屏幕截图所示：
- en: '![](img/1959a40f-bac4-421e-bb75-c5579d0a08f1.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1959a40f-bac4-421e-bb75-c5579d0a08f1.png)'
- en: 'The classic scenario: red versus blue'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 经典场景：红色对蓝色
- en: 'In the preceding screenshot, we can see that our red and blue targets are opposite
    their teams: red and blue, respectively. Your guess is as good as mine as to why
    the blue and red clans just can''t get along, but it''ll work for our sample,
    so I''m just going to let them do their thing. The setup is straightforward. Each
    capsule has a `CrowdAgent.cs` component attached to it, and when you hit play,
    each agent will head towards their target while avoiding each other and the oncoming
    capsules from the opposite team. Once they reach their destination, they will
    gather around the target.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到我们的红色和蓝色目标分别与他们的队伍相反：红色和蓝色。关于为什么蓝色和红色部落无法相处，你的猜测和我的一样，但这对我们的样本来说适用，所以我将让他们按自己的方式行事。设置很简单。每个胶囊都附加了一个`CrowdAgent.cs`组件，当你按下播放时，每个代理将朝着他们的目标前进，同时避免彼此和来自对方队伍的迎面而来的胶囊。一旦他们到达目的地，他们将在目标周围聚集。
- en: This setup takes our example from [Chapter 4](503803fe-f343-4a0c-835f-463c98005182.xhtml),
    *Finding Your Way *and takes it to the next level. Now we have large groups of
    agents that are not only navigating to a target location, but doing so while avoiding
    large groups of agents at the same time. As you can see, Unity's NavMesh handles
    these interactions beautifully. The system is efficient and very robust.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置将我们的例子从[第4章](503803fe-f343-4a0c-835f-463c98005182.xhtml)，《寻找你的路》提升到了下一个层次。现在我们有了大量智能体，它们不仅正在导航到目标位置，而且在避免大量其他智能体的同时这样做。正如你所见，Unity的NavMesh优雅地处理了这些交互。该系统既高效又非常健壮。
- en: 'While the game is running, you can even select a single capsule or a group
    of them in the editor to see their behavior visualized. As long as you have the
    navigation window active, you''ll be able to see some debugging information about
    your NavMesh and the agents on it, as you can see in the following screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏运行时，你甚至可以在编辑器中选择单个胶囊或一组胶囊，以查看它们的可视化行为。只要你的导航窗口处于活动状态，你就能看到一些关于你的NavMesh及其上智能体的调试信息，如以下屏幕截图所示：
- en: '![](img/54ded18e-6ecc-4350-ae27-39cf54c1c6a0.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/54ded18e-6ecc-4350-ae27-39cf54c1c6a0.jpg)'
- en: The debug view from an agent's perspective
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从智能体视角的调试视图
- en: 'It''s worth checking this out in the editor to really get an idea of how this
    looks in motion, but we''ve labeled a few key elements in the preceding screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器中查看这一点，以真正了解它在运动中的样子是值得的，但我们已经在先前的屏幕截图中标出了一些关键元素：
- en: This is the destination arrow that points toward the `NavMeshAgent` destination,
    which for this little guy is `RedTarget`. All this arrow cares about is where
    the destination is, regardless of the direction the agent is facing or moving
    toward.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是指向`NavMeshAgent`目的地的目的地箭头，对于这个小家伙来说，它是`RedTarget`。这个箭头所关心的只是目的地在哪里，而不管智能体面向或移动的方向如何。
- en: This arrow is the heading arrow. It shows the actual direction the agent is
    moving in. The direction of the agent takes into account several factors, including
    the position of its neighbors, space on the NavMesh, and the destination.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个箭头是方向箭头。它显示了智能体实际移动的方向。智能体的方向考虑了多个因素，包括其邻居的位置、NavMesh上的空间以及目的地。
- en: This debug menu allows you to show a few different things. In our case, we enabled
    Show Avoidance and Show Neighbours.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个调试菜单允许你显示几个不同的事物。在我们的例子中，我们启用了显示规避和显示邻居。
- en: Speaking of avoidance, this cluster of squares, ranging from dark to light and
    floating over the agents, represents the areas to avoid between our agent and
    the destination. The darker squares indicate areas that are densely populated
    by other agents or blocked by the environment, while the lighter-white squares
    indicate areas that are safe to walk through. Of course, this is a dynamic display,
    so watch it change as you play in the editor.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 说到规避，这个从深色到浅色、悬浮在智能体上方的正方形群代表了我们智能体和目的地之间需要规避的区域。较暗的正方形表示其他智能体密集分布或被环境阻挡的区域，而较浅的白色正方形表示可以安全穿过的区域。当然，这是一个动态显示，所以当你在这个编辑器中玩耍时，你会看到它如何变化。
- en: Using the CrowdAgent component
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CrowdAgent组件
- en: 'The `CrowdAgent` component is incredibly simple, but gets the job done. As
    mentioned earlier, Unity does most of the heavy lifting for us. The following
    code gives our `CrowdAgent` a destination:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`CrowdAgent`组件非常简单，但能完成任务。如前所述，Unity为我们做了大部分繁重的工作。以下代码为我们的`CrowdAgent`提供了一个目的地：'
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The script requires a component of type `NavMeshAgent`, which it assigns to
    the `agent` variable on `Start()`. We then set its speed randomly between two
    values for some added visual variety in our simulation. Lastly, we set its destination
    to be the position of the target marker. The target marker is assigned via the
    inspector, as you can see in the following screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本需要一个类型为`NavMeshAgent`的组件，它在`Start()`中将它分配给`agent`变量。然后我们随机设置其速度在两个值之间，为我们的模拟增加一些视觉多样性。最后，我们将其目的地设置为目标标记的位置。目标标记通过检查器分配，如以下屏幕截图所示：
- en: '![](img/ab320924-64ec-410f-809f-2b8ca35d8525.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ab320924-64ec-410f-809f-2b8ca35d8525.png)'
- en: The inspector settings for the NavMeshAgent
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: NavMeshAgent的检查器设置
- en: The preceding screenshot illustrates a red capsule's `CrowdAgent` component
    with RedTarget (Transform) set as its Target. For fun, you can try setting different
    targets. Since the only requirement is that it be of type `Transform`, you could
    even set another agent as the target!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的屏幕截图展示了红色胶囊的`CrowdAgent`组件，其目标设置为RedTarget（变换）。为了好玩，你可以尝试设置不同的目标。由于唯一的要求是该目标必须是`Transform`类型，你甚至可以将另一个智能体设置为目标！
- en: Adding some fun obstacles
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一些有趣的障碍物
- en: 'Without having to do anything else in our code, we can make a few changes to
    our scene layout and enable a few components provided by Unity to dramatically
    alter the behavior of our agents. In our `CrowdsObstacles` scene, we''ve added
    a few walls to the environment, creating a maze-like layout for our red and blue
    teams of capsules to traverse, as you can see in the following screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要在我们的代码中做任何其他操作，我们只需对我们的场景布局做一些修改，并启用Unity提供的一些组件，就可以显著改变智能体的行为。在我们的`CrowdsObstacles`场景中，我们在环境中添加了几堵墙，为我们的红色和蓝色胶囊团队创建了一个迷宫式的布局，如下面的截图所示：
- en: '![](img/248be45b-ff66-4947-9771-ba2dcfdc1296.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/248be45b-ff66-4947-9771-ba2dcfdc1296.png)'
- en: Let the games begin!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让游戏开始吧！
- en: 'The fun part about this example is that, because of the randomized speed of
    each agent, the results will be totally different each time you run the game.
    As the agents move through the environment, they''ll be blocked by teammates or
    opposing agents and will be forced to re-route and find the quickest route to
    their target. Of course, this concept is not new to us, as we saw `NavMeshAgent`
    avoiding obstacles in [Chapter 4](503803fe-f343-4a0c-835f-463c98005182.xhtml),
    *Finding Your Way*, except that we have many, many more agents in this scenario.
    To add a bit more fun to the example, we''ve also added a simple up-down animation
    to one of the walls and a `NavMeshObstacle` component, which looks something like
    this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子有趣的部分在于，由于每个智能体的随机速度，每次运行游戏时结果都会完全不同。当智能体在环境中移动时，它们会被队友或对手的智能体阻挡，并被迫重新规划路线，找到到达目标的最快路径。当然，这个概念对我们来说并不陌生，因为我们已经在[第4章](503803fe-f343-4a0c-835f-463c98005182.xhtml)“寻找路径”中看到了`NavMeshAgent`如何避开障碍物，除了在这个场景中我们有很多、很多更多的智能体。为了使这个例子更有趣，我们还给一面墙和一个`NavMeshObstacle`组件添加了一个简单的上下动画，看起来就像这样：
- en: '![](img/e4d97355-d9ae-465b-9eb5-67d6500a0d9d.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e4d97355-d9ae-465b-9eb5-67d6500a0d9d.png)'
- en: NavMeshObstacle looks a bit different in Unity 2017
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: NavMeshObstacle在Unity 2017中看起来略有不同
- en: 'Note that our obstacle does not need to be set to Static when we are using
    this component. Our obstacle is mostly box-like, so we leave the default Shape
    setting as Box (Capsule is another choice). The Size and Center options let us
    move the outline of our shape around and resize it, but the default settings fit
    our shape perfectly, which is what we want, so let''s leave that alone. The next
    option, Carve, is important. It essentially does exactly what it says; it carves
    a space out of the NavMesh, as shown in the following screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们使用这个组件时，我们的障碍物不需要设置为静态。我们的障碍物主要是箱形的，所以我们保留默认的形状设置为箱形（胶囊形也是一个选择）。大小和中心选项让我们可以移动形状的轮廓并调整它的大小，但默认设置完美地适合我们的形状，这正是我们想要的，所以让我们保持这个设置不变。下一个选项“雕刻”非常重要。它基本上就是它所说的那样；它从NavMesh中雕刻出一个空间，如下面的截图所示：
- en: '![](img/12c743d8-ed57-48d0-9ec6-e2b15056d012.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/12c743d8-ed57-48d0-9ec6-e2b15056d012.jpg)'
- en: The same obstacle at two different points of its up-down animation
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下动画的两个不同点上的相同障碍物
- en: The left screenshot shows the space carved out when the obstacle is on the surface,
    while the NavMesh is connected in the right screenshot when the obstacle is raised
    off the surface. We can leave Time to Stationary and Move Threshold as they are,
    but we do want to make sure that Carve Only Stationary is turned off. This is
    because our obstacle is moving, and if we didn't tick this box, it would not carve
    out the space from the NavMesh, and our agents would be trying to move through
    the obstacle whether it was up or down, which is not the behavior we are after
    in this case.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧截图显示了障碍物在表面上的空间，而右侧截图显示了当障碍物抬起时NavMesh的连接。我们可以保持时间到静止和移动阈值为默认设置，但我们确实想确保“仅雕刻静止”选项是关闭的。这是因为我们的障碍物是移动的，如果我们不勾选这个框，它就不会从NavMesh中雕刻出空间，我们的智能体就会试图穿过障碍物，无论它是上升还是下降，而这并不是我们想要的这种行为。
- en: As the obstacle moves up and down and the mesh is carved out and reconnected,
    you'll notice the agents changing their heading. With the navigation debug options
    enabled, we can also see a very interesting visualization of everything going
    on with our agents at any given moment. It may seem a bit cruel to mess with our
    poor agents like this, but we're doing it for science!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当障碍物上下移动并且网格被雕刻出来并重新连接时，你会注意到智能体在改变航向。当启用导航调试选项时，我们还可以看到在任何给定时刻我们智能体所发生的一切的非常有趣的可视化。这样对待我们可怜的智能体可能有点残忍，但我们这样做是为了科学！
- en: 'The following screenshot gives us a glimpse into the chaos and disorder we''re
    subjecting our poor agents to:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图让我们一窥我们让可怜的代理所承受的混乱和无序：
- en: '![](img/8d98f34b-bff9-4c65-ad54-1be5fd8138bf.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8d98f34b-bff9-4c65-ad54-1be5fd8138bf.jpg)'
- en: I'm secretly rooting for the blue team
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我在秘密地为蓝队加油
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to implement a flocking behavior system. We
    implemented it using custom direction vectors to control the boids' movement that
    we calculated by applying Craig Reynolds' three main flocking concepts—alignment,
    coherence, and separation. We then applied our flocking behavior to the flying
    objects, but you can apply the techniques in these examples to implement other
    character behaviors, such as fish shoaling, insects swarming, or land animals
    herding. You'll only have to implement different leader movement behaviors, such
    as limiting movement along the *y* axis for characters that can't move up and
    down. For a 2D game, we would just freeze the *y* position. For 2D movement along
    uneven terrain, we would have to modify our script to not put any forces in the
    *y* direction.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何实现一个群体行为系统。我们通过自定义方向向量来实现它，这些向量控制着通过应用克雷格·雷诺兹的三个主要群体概念——对齐、凝聚和分离——计算出的鸟群运动。然后，我们将我们的群体行为应用于飞行物体，但你也可以将这些示例中的技术应用于实现其他角色行为，例如鱼群游动、昆虫集群或陆地动物的放牧。你只需实现不同的领导者运动行为，例如限制不能上下移动的角色沿
    *y* 轴的运动。对于二维游戏，我们只需冻结 *y* 位置。对于不规则的地面上的二维运动，我们必须修改我们的脚本，以确保在 *y* 方向上不施加任何力。
- en: We also took a look at crowd simulation and even implemented our own version
    of it using Unity's NavMesh system, which we first learned about in [Chapter 4](503803fe-f343-4a0c-835f-463c98005182.xhtml),
    *Finding Your Way*. We learned how to visualize our agents' behavior and decision-making
    process.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了人群模拟，并使用Unity的NavMesh系统实现了我们自己的版本，这是我们首次在[第4章](503803fe-f343-4a0c-835f-463c98005182.xhtml)，*找到你的路*中了解到的。我们学习了如何可视化我们的代理的行为和决策过程。
- en: In the next chapter, we'll look at the behavior tree pattern and learn to implement
    our own version of it from scratch.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨行为树模式，并学习从头开始实现我们自己的版本。
