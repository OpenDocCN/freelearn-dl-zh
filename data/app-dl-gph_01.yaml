- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Introduction to Graph Learning
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图学习简介
- en: Graph data is a powerful and intuitive way of expressing information, and several
    practical scenarios can be better expressed using graph data than tabular approaches.
    Analyzing graph data has been a topic of study for decades, but it has only recently
    begun to capture the limelight due to advances in compute capabilities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 图形数据是一种强大且直观的信息表达方式，许多实际场景使用图形数据表达要比表格方式更为合适。图形数据分析已经是几十年的研究课题，但由于计算能力的提升，它最近才开始受到关注。
- en: In this book, we aim to introduce you to the world of **graphs** . Here, we’ll
    begin by discussing what graph data is and the fundamental mathematical terminologies
    surrounding graphs. Next, we’ll take a small detour and discuss some common graph
    algorithms and their applications in graph data analytics. We’ll extend our discussion
    on graph data analytics to the requirement of graph deep learning and why it stands
    as a specialized subdomain compared to applying existing architectures.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们旨在向你介绍**图形**的世界。我们将从讨论图形数据是什么以及图形相关的基本数学术语开始。接下来，我们将绕道讨论一些常见的图算法及其在图形数据分析中的应用。我们还将扩展关于图形数据分析的讨论，涉及图形深度学习的需求，以及为何它作为一个专门子领域，与应用现有架构有所不同。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Do we need graphs?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要图形吗？
- en: Formalizing graphs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图的形式化
- en: Types and properties of graphs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图的类型和属性
- en: Graph data structures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形数据结构
- en: Traditional graph-based solutions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统的基于图的解决方案
- en: The need for **representation learning**
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示学习**的需求'
- en: '**Graph neural networks** ( **GNNs** ) and the need for a separate vertical'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图神经网络**（**GNNs**）及其作为独立领域的需求'
- en: Do we need graphs?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们需要图形吗？
- en: The recent **artificial intelligence** ( **AI** ) revolution is the tip of the
    iceberg of a megatrend that has been impacting the computing industry for decades
    now. Over time, computing performance has increased exponentially against power
    consumed and cost; information storage costs have also decreased exponentially.
    To put this into perspective, while a terabyte of data can be stored in a disk
    costing around 100 US dollars in 2024, it would have taken more than a million
    dollars in the early 1990s!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的**人工智能**（**AI**）革命只是一个大趋势的冰山一角，这一趋势已影响计算机行业数十年。随着时间的推移，计算性能在消耗功率和成本上指数级增长；信息存储成本也在指数级下降。为了更好理解这一点，2024年，一个100美元的硬盘可以存储一TB数据，而在1990年代初，存储同样数据的成本超过一百万美元！
- en: 'Using computers and their derivative products, such as software, web applications,
    games, and multimedia content, has become deeply tied to our normal lifestyle.
    This dependence led to the need for understanding the behavior of all the interacting
    entities: humans, computer hardware, software such as web applications, and even
    organizations as a whole. The end goal was to find ways to make interactions more
    efficient, which could lead to unprecedented business opportunities.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用计算机及其衍生产品，如软件、网页应用程序、游戏和多媒体内容，已深深融入我们的日常生活。这种依赖关系催生了对所有交互实体行为的理解需求：人类、计算机硬件、像网页应用程序这样的软件，甚至整个组织。最终目标是找到方法提高交互效率，从而可能带来前所未有的商业机会。
- en: 'Initially, given the constraints of the time, the information that was collected
    was less organized and the recorded truth provided a very high-level overview
    of systems, and only about a handful of variables within the system (for data
    scientists, think of data at aggregated levels, and with a small number of dimensions).
    At some point, someone realized computing power and data storage were cheap enough
    that you could record facts more granularly: not only could individual scenarios
    be recorded separately and more frequently, but other variables could also be
    recorded every time a snapshot was taken. The data revolution had begun, and stakeholders
    realized that by capturing and reviewing enough data about these interacting entities,
    a holistic picture of their behavior in the ecosystem could be drawn. The 2010s
    were spent commoditizing data and its products, to the point that even Series
    A-funded startups have adopted a data solution: be it warehousing, Elasticsearch,
    or recommendation engines.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，由于时间的限制，收集到的信息较为零散，记录的事实提供了系统的一个非常高层次的概述，且仅涉及系统中的少量变量（对于数据科学家来说，类似于聚合级别的数据，且维度较少）。在某个时刻，有人意识到计算能力和数据存储已经足够便宜，可以更加细致地记录事实：不仅可以更频繁地单独记录每个场景，还可以在每次拍摄快照时记录其他变量。数据革命开始了，利益相关者意识到，通过捕捉并审查这些交互实体的足够数据，可以绘制出它们在生态系统中的行为全貌。2010年代人们致力于数据及其产品的商品化，以至于即使是获得A轮融资的初创公司也采用了数据解决方案：无论是数据仓库、Elasticsearch，还是推荐引擎。
- en: Taking a step back, let’s understand what data means. A data point is essentially
    just a factual statement. Very little discussion exists *on how the fact is represented
    in the data* . The de facto representation of data is tabular, and this has generally
    worked well for the capabilities built around the current data ecosystem. The
    focus on data science research and engineering has revolved around existing database
    architectures, which is why the tabular form of representation is the most widespread.
    However, the tabular form need isn’t the only form of representation. The purpose
    of this chapter is to build a case around the graph form of representation and
    why graph representations can be the best option for several practical scenarios.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 回到原点，让我们理解数据的含义。一个数据点本质上只是一个事实陈述。关于*事实在数据中的表示方式*，讨论非常少。数据的事实表示方式通常是表格形式，这对于围绕现有数据生态系统构建的能力而言通常运作良好。数据科学研究和工程的重点一直围绕现有的数据库架构，这也是表格形式的表示最为广泛的原因。然而，表格形式并不是唯一的表示方式。本章的目的是围绕图形表示法构建案例，并说明为什么图形表示法可以成为许多实际场景中的最佳选择。
- en: 'Graph data is represented using **nodes** (also called objects, vertices, or
    nouns) and **edges** (also called relationships, links, or verbs). Certain real-life
    scenarios necessitate emphasizing the relationships between the objects rather
    than just treating each object as an independent entity. Graph data structures
    provide us with a natural way to express these scenarios, as opposed to something
    such as the tabular format. Using the simple construct of treating entities as
    nodes and relationships as edges between two nodes, graph representations can
    effectively model information from a wide range of domains: from network topology
    to biological systems and supply chains to molecular structure.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图数据通过**节点**（也称为对象、顶点或名词）和**边**（也称为关系、链接或动词）来表示。某些现实生活中的场景需要强调对象之间的关系，而不仅仅是将每个对象视为独立实体。图数据结构为我们提供了一种自然的方式来表达这些场景，这与表格格式等其他方式不同。通过将实体视为节点、关系视为两个节点之间的边这一简单结构，图形表示能够有效地建模来自各个领域的信息：从网络拓扑到生物系统，再到供应链和分子结构。
- en: A case study
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究
- en: 'To make this point clearer, let’s consider a common question that arises in
    social networks. For a user (say John), we want to ascertain whether another user
    (say Mary) is a second-degree connection (to John). A second-degree connection
    simply means Mary and John have a common connection, but Mary isn’t directly connected
    (is friends with) to John. The social media platform commonly tracks this piece
    of information between a pair of users and determines whether they should be recommended
    by the platform to connect. We’ll tackle this problem from two perspectives: first
    using the tabular representation, and then using the graph representa tion.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地说明这一点，让我们考虑社交网络中常见的一个问题。对于一个用户（比如 John），我们想要确定另一个用户（比如 Mary）是否是其二度连接。二度连接简单来说是指
    Mary 和 John 有共同的连接，但 Mary 并不直接与 John 相连接（即 Mary 是 John 的朋友）。社交媒体平台通常在用户对之间跟踪这一信息，并决定是否应该推荐他们连接。我们将从两个角度解决这个问题：首先使用表格表示，然后使用图形表示。
- en: Tabular representation
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表格表示
- en: 'First, we need to understand what the schema of the tables in the database
    would be. In a typical social media platform database, there would be several
    tables – one for users (capturing demographic information such as age, location,
    date of joining, and so on), one for posts (containing details about a post made,
    such as the user who made the post, the contents of the post, the date of making
    the post, the visibility level, and so on), and many more. The table of concern
    for us would be something called the **connections table** . It should capture
    information about which users are connected directly (that is, they have a first-degree
    connection). The schema should go somewhat like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要了解数据库中表的架构。在典型的社交媒体平台数据库中，可能会有几个表 – 一个用于用户（包含年龄、位置、加入日期等人口统计信息）、一个用于帖子（包含关于发布帖子的详细信息，如发布帖子的用户、帖子内容、发布日期、可见性等），以及其他许多表。对我们而言关键的表是所谓的
    **连接表**。它应该记录直接连接的用户信息（即具有一度连接的用户）。架构应该类似于这样：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Table 1.1* shows a table that contains a few data points:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 1.1* 显示了一个包含几个数据点的表：'
- en: '| **conn_id** | **user_id_1** | **user_id_2** | **date_of_conn** | **status_of_conn**
    |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **conn_id** | **user_id_1** | **user_id_2** | **date_of_conn** | **status_of_conn**
    |'
- en: '| conn_uuid_0 | john_uuid | alex_uuid | 2022-10-30 | active |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| conn_uuid_0 | john_uuid | alex_uuid | 2022-10-30 | active |'
- en: '| conn_uuid_1 | alex_uuid | greg_uuid | 2023-03-12 | active |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| conn_uuid_1 | alex_uuid | greg_uuid | 2023-03-12 | active |'
- en: '| conn_uuid_2 | greg_uuid | mary_uuid | 2023-04-11 | active |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| conn_uuid_2 | greg_uuid | mary_uuid | 2023-04-11 | active |'
- en: '| conn_uuid_3 | mary_uuid | alex_uuid | 2023-06-09 | active |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| conn_uuid_3 | mary_uuid | alex_uuid | 2023-06-09 | active |'
- en: Table 1.1 – Example data stored in tabular format
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.1 – 以表格格式存储的示例数据
- en: 'To determine whether John and Mary have a second-degree connection, a SQL query
    similar to the following can be executed:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定 John 和 Mary 是否具有二度连接，可以执行类似以下的 SQL 查询：
- en: '![Figure 1.1 – A SQL query being performed over tables that were introduced
    previously to retrieve second-degree connections](img/B22118_01_1.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 在先前介绍的表上执行的 SQL 查询，以检索二度连接](img/B22118_01_1.jpg)'
- en: Figure 1.1 – A SQL query being performed over tables that were introduced previously
    to retrieve second-degree connections
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 在先前介绍的表上执行的 SQL 查询，以检索二度连接
- en: The crux of this query contains a recursive self-join operation, where each
    recursion level contains the connections of a certain degree. The initial filter
    of **user_id_1 =** **'john_uuid'** OR **user_id_2 = 'john_uuid'** ensures that
    we only concern ourselves with users who are on some level and connected to John.
    Finally, by filtering by **degree = 2** , we can get the list of all users who
    have a second-degree connection to John.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 该查询的关键部分包含递归自连接操作，其中每个递归级别包含特定程度的连接。初始过滤条件 **user_id_1 = 'john_uuid'** 或 **user_id_2
    = 'john_uuid'** 确保我们只关注与 John 有某种级别连接的用户。最后，通过过滤条件 **degree = 2** ，我们可以获取所有与 John
    有二度连接的用户列表。
- en: How efficient is this approach? The worst-case time complexity can be evaluated
    asymptotically and expressed in **Big-O notation** . Let ![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/1.png)
    be the count of users present on the social media platform and ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/2.png)
    be the count of all first-degree connections (or the number of entries in the
    connections table). Join algorithms have evolved, and current join operations
    are very efficient, but if we look at the naive approach, where two tables have
    lengths ![<mml:math  ><mml:mi>L</mml:mi></mml:math>](img/3.png) and ![<mml:math  ><mml:mi>R</mml:mi></mml:math>](img/4.png)
    , a join operation would have an ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>L</mml:mi><mml:mi>*</mml:mi><mml:mi>R</mml:mi><mml:mo>)</mml:mo></mml:math>](img/5.png)
    time complexity. Applying this logic   to the preceding recursion, we’ll see   that
    the time complexity of the entire query is ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>E</mml:mi><mml:mi>*</mml:mi><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/6.png)
    or ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math>](img/7.png)
    .
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的效率如何？最坏情况下的时间复杂度可以渐进地评估，并用**大 O 记法**表示。设 ![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/1.png)
    为社交媒体平台上用户的数量，![
- en: Graph representation
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图形表示
- en: 'Now, let’s look at the graph representation for the same problem. Let each
    node of the graph represent a user and each edge connecting two nodes represent
    a first-degree connection between the users that the connected nodes represent.
    An illustration using *Table 1.1* would look like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下这个问题的图形表示。图中的每个节点代表一个用户，连接两个节点的每条边代表这两个节点所代表的用户之间的一度连接。使用*表 1.1* 的示意图如下所示：
- en: '![Figure 1.2 – Representing data from Table 1.1 in a graph](img/B22118_01_2.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 将表 1.1 中的数据表示为图](img/B22118_01_2.jpg)'
- en: Figure 1.2 – Representing data from Table 1.1 in a graph
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 将表 1.1 中的数据表示为图
- en: 'How do we find the answer to whether John and Mary have a second-degree connection
    here? We can employ an intuitive algorithm over this graph:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何找到约翰和玛丽是否有二度连接的答案呢？我们可以在这个图上应用一个直观的算法：
- en: '**Start from a source** : Begin at a chosen starting point, often called the
    *source* or **initial node** of the graph. This is your current position for exploration.
    For our use case, the initial node would be that of John.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从源点开始**：从选择的起始点开始，通常称为图的*源点*或**初始节点**。这是你当前的探索位置。在我们的用例中，初始节点将是约翰的节点。'
- en: '**Explore neighbors level by level** : Visit all the neighbors of the current
    node before moving on to their neighbors. Imagine exploring the graph in layers,
    moving outward one level at a time. This ensures that you discover all nodes at
    a certain distance before moving farther away.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**按层级探索邻居**：在进入它们的邻居之前，先访问当前节点的所有邻居。想象一下按层次探索图形，每次向外扩展一级。这确保你在继续探索更远的节点之前，先发现所有距离较近的节点。'
- en: '**Mark visited nodes** : As you visit each node, mark it as visited to avoid
    revisiting the same node. Use a queue to keep track of the order in which you
    encounter nodes. While marking the nodes, you can also keep track of how many
    jumps from the initial node were made to reach this node. Continue this process
    until you’ve visited all reachable nodes from the starting point.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**标记访问的节点**：当你访问每个节点时，将其标记为已访问，以避免重新访问同一节点。使用队列来跟踪你遇到节点的顺序。在标记节点时，你还可以跟踪从初始节点跳跃到达该节点的次数。继续这个过程，直到访问到从起始点能够到达的所有节点。'
- en: 'In simpler terms, this algorithm explores the graph by gradually moving away
    from the starting point, checking neighboring nodes level by level, and keeping
    track of visited nodes to avoid duplication. It’s like ripples spreading out from
    a pebble dropped in a pond, exploring nearby areas before moving to more distant
    ones. This algorithm is called **breadth-first search** ( **BFS** ), and it’s
    one of the most popular graph algorithms:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，这个算法通过逐渐远离起始点来探索图，逐层检查相邻节点，并跟踪已访问的节点以避免重复。这就像一颗小石子落入池塘，产生的涟漪先向周围扩散，然后再向更远的地方扩展。这个算法叫做**广度优先搜索**（**BFS**），它是最流行的图算法之一：
- en: '![Figure 1.3 – Running BFS on the graph](img/B22118_01_3.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 在图上运行 BFS](img/B22118_01_3.jpg)'
- en: Figure 1.3 – Running BFS on the graph
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 在图上运行 BFS
- en: By using this algorithm, if Mary’s node is marked as visited and has a jump
    count of *2* , then we can safely say that John and Mary have a second-degree
    connection.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个算法，如果玛丽的节点被标记为已访问，并且跳数为*2*，那么我们可以放心地说，约翰和玛丽有二度连接。
- en: What’s the time complexity of BFS? As mentioned previously, the number of users
    is assumed to be ![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/1.png) , and
    the number of first-degree connections is ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/2.png)
    . Effectively, BFS touches all vertices and edges of the graph at most once, so
    the time complexity is simply ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>+</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/10.png)
    . In a practical scenario, the number of connections far outweighs the number
    of users on the platform, so the time complexity can be approximated to ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/11.png)
    .
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: BFS 的时间复杂度是多少？如前所述，用户的数量假定为 ![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/1.png)
    ，一度连接的数量为 ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/2.png) 。实际上，BFS 至多访问图中的所有顶点和边一次，所以时间复杂度就是简单的
    ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>+</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/10.png)
    。在实际场景中，连接数远远超过平台上的用户数，因此时间复杂度可以近似为 ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/11.png)
    。
- en: Is ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/12.png)
    better than ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math>](img/13.png)
    ? Definitely. We can see that just by changing the perspective of approaching
    the problem, we achieve a much more efficient solution. To further test your understanding,
    think of a scenario where the problem was kept the same, except you now have to
    check whether John and Mary were third-degree connections instead of second-degree
    connections. How would the time complexities of both approaches be affected?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 是 ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/12.png)
    比 ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math>](img/13.png)
    更好吗？当然好。我们可以看到，通过改变问题的解决方法视角，我们可以实现一个更高效的解决方案。为了进一步测试你的理解，假设问题保持不变，只是你现在需要检查约翰和玛丽是否为三度连接，而不是二度连接。那么这两种方法的时间复杂度会受到什么影响？
- en: Graphs are useful in practice. But before we talk about how certain properties
    of graphs and algorithms are used to solve graph problems, we need to define a
    common language that we can use to refer to graphs and their properties. The following
    section will cover how graphs are commonly defined in mathematics, and how a simple
    representation can cover all the different types of data that graphs can represent.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图在实际应用中非常有用。但在我们讨论图的某些属性和算法如何用于解决图问题之前，我们需要定义一种通用语言，用来指代图及其属性。以下部分将介绍数学中图的常见定义，以及如何通过简单的表示方式涵盖图所能表示的所有不同类型的数据。
- en: Formalizing graphs
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图的形式化
- en: Graphs are a very popular concept in mathematics. In this domain, a common terminology
    is well accepted. Let’s take a closer look.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图是数学中非常流行的概念。在这个领域，常用的术语已经得到了广泛的接受。让我们仔细看一下。
- en: Definition and semantics
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和语义
- en: With the argument being made for graph representations to be a relevant topic
    for practical problems, let’s take a moment to define what a graph is. A graph
    is an abstract concept. Mathematically, it’s generally repre sented as ![<mml:math  ><mml:mi>G</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/14.png)
    , where ![<mml:math  ><mml:mi>G</mml:mi></mml:math>](img/15.png) is the graph,
    which contains a set of vertices, ![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/1.png)
    , and a set of edges, ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/17.png)
    . Each element of ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/17.png) is
    a tuple, ![<mml:math  ><mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mo>,</mml:mo><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:math>](img/19.png)
    , where ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mo>,</mml:mo><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:math>](img/20.png)
    , and represents a connection between the two vertices. That’s all there is to
    the mathematical definition; how you choose to apply semantics to this is completely
    up to you.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 随着对图表示作为实际问题相关话题的论述，我们先花点时间来定义什么是图。图是一个抽象概念。从数学角度来看，通常表示为 ![<mml:math  ><mml:mi>G</mml:mi><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/14.png)
    ，其中 ![<mml:math  ><mml:mi>G</mml:mi></mml:math>](img/15.png) 是图，包含一组顶点 ![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/1.png)
    和一组边 ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/17.png) 。每个 ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/17.png)
    的元素是一个元组 ![<mml:math  ><mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mo>,</mml:mo><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:math>](img/19.png)
    ，其中 ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mo>,</mml:mo><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:math>](img/20.png)
    ，表示两个顶点之间的连接。数学定义就是这些；如何将语义应用于此完全取决于你。
- en: 'In the example mentioned in the previous section, the users of the social media
    platform were represented by the vertices, and the connection between the two
    users was represented by the edges. Also, vertices and edges need not be so homogeneous.
    Consider the graph representation of a home network:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中提到的例子中，社交媒体平台的用户由顶点表示，两个用户之间的连接由边表示。此外，顶点和边不一定是完全相同的。考虑一下家庭网络的图表示：
- en: '![Figure 1.4 – A classic heterogeneous graph, where there are multiple types
    of elements represented as nodes. There is also heterogeneity in the interactions
    represented by edges](img/B22118_01_4.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – 一个经典的异构图，其中有多种类型的元素作为节点进行表示。边所代表的交互也具有异质性](img/B22118_01_4.jpg)'
- en: Figure 1.4 – A classic heterogeneous graph, where there are multiple types of
    elements represented as nodes. There is also heterogeneity in the interactions
    represented by edges
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 一个经典的异构图，其中有多种类型的元素作为节点进行表示。边所代表的交互也具有异质性
- en: 'Here, the nodes represent all entities present in the home network, from human
    users to **Internet of Things** ( **IoT** ) devices, routers, and smart TVs. The
    semantics of the edges range from interaction to network communication and media
    streaming. Formally, the set of vertices and edges can be defined as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，节点表示家庭网络中所有的实体，从人类用户到**物联网**（**IoT**）设备、路由器和智能电视。边的语义范围从互动到网络通信，再到媒体流播放。形式上，顶点和边的集合可以定义如下：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Graph representations can be further supercharged by adding more information
    specific to the nodes or edges. A popular way to represent this information is
    by using a feature vector. We’ll learn more about how node and edge features can
    be added in future chapters.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为节点或边添加更多特定信息，可以进一步增强图表示。一种常见的表示方法是使用特征向量。我们将在未来的章节中学习如何为节点和边添加特征。
- en: The key takeaway here is that graphs are an incredibly powerful way of representing
    facts. With this definition at hand, let’s try to investigate a few derived characteristics
    of graphs. Certain characteristics of graphs imply certain high-level facts about
    how the nodes and edges in the graph are organized. The next section focuses on
    a few such popular properties and graph types.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键是，图是一种非常强大的事实表示方式。理解了这个定义后，我们可以尝试探讨一些图的派生特性。图的某些特性暗示了关于图中节点和边如何组织的高层次事实。接下来的部分将重点介绍几种流行的图属性和类型。
- en: Types and properties of graphs
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图的类型和属性
- en: Several types of graphs have been identified, each with its unique properties,
    but we’ll focus on the ones that are most popular. Note that these types need
    not be mutually exclusive, meaning a graph can be labeled as more than one type
    at a time.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 已识别出几种类型的图，每种图都有其独特的属性，但我们将重点讨论最流行的几种。请注意，这些类型不一定是互斥的，也就是说，一个图可以同时标记为多种类型。
- en: Directed graphs
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有向图
- en: Graphs are **directed** when the edges have a one-way relationship between their
    connecting nodes. There are many scenarios where the relationship that’s represented
    is unidirectional. In a graph representing a family tree, an edge might represent
    the relation “ *is a parent of,* ” and another might represent the relation “
    *is a pet of.* ” Such relationships can’t be inverted between the nodes and hold
    the same meaning.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当图的边具有单向关系时，图就是**有向图**。许多场景中，表示的关系是单向的。在表示家谱的图中，一条边可能代表“*是父母*”的关系，而另一条边可能代表“*是宠物*”的关系。这样的关系无法在节点之间倒转，并且保持相同的含义。
- en: Bipartite graphs
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二分图
- en: A **bipartite graph** is a type of graph whose vertices can be divided into
    two disjoint sets such that every edge connects a vertex from one set to a vertex
    in the other set. In other words, there are no edges that connect vertices within
    the same set. Mathematically, a graph, ![<mml:math  ><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/21.png)
    , is bipartite if the vertex set, ![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/1.png)
    , is partitioned into two non-empty sets, ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/23.png)
    and ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/24.png)
    , such that every edge in ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/25.png)
    connects a vertex in ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/26.png)
    to a vertex in ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/27.png)
    .
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**二分图**是一种图，其顶点可以被划分为两个不相交的集合，使得每条边都连接一个集合中的顶点和另一个集合中的顶点。换句话说，图中没有连接同一集合内顶点的边。从数学上讲，图，![<mml:math  ><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo>(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo>)</mml:mo></mml:math>](img/21.png)，是二分图当且仅当顶点集![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/1.png)被划分为两个非空集合，![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/23.png)和![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/24.png)，使得图中每条边![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/25.png)都连接![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/26.png)中的一个顶点和![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/27.png)中的一个顶点。'
- en: Bipartite graphs are often denoted as ![<math ><mrow><mrow><mrow><msub><mrow><mi>G</mi><mo>(</mo><mi>V</mi></mrow><mn>1</mn></msub><mo>,</mo><msub><mi>V</mi><mn>2</mn></msub><mo>,</mo><mi>E</mi><mo>)</mo></mrow></mrow></mrow></math>](img/28.png)
    , where ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/29.png)
    and ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/30.png)
    are the two disjoint sets of vertices, and ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/31.png)
    is the set of edges connecting vertices from ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/32.png)
    to ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/33.png)
    One common application of bipartite graphs is in modeling relationships between
    two distinct types of entities, where edges represent connections or relationships
    between entities of different types.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 二分图通常表示为 ![<math ><mrow><mrow><mrow><msub><mrow><mi>G</mi><mo>(</mo><mi>V</mi></mrow><mn>1</mn></msub><mo>,</mo><msub><mi>V</mi><mn>2</mn></msub><mo>,</mo><mi>E</mi><mo>)</mo></mrow></mrow></mrow></math>](img/28.png)
    ，其中 ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/29.png)
    和 ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/30.png)
    是两个不相交的顶点集合，! [<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/31.png) 是连接 ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/32.png)
    到 ![<mml:math  ><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/33.png)
    的边集合。二分图的一个常见应用是在建模两种不同类型实体之间的关系，其中边表示不同类型实体之间的连接或关系。
- en: 'Bipartite graphs occur very commonly in the wild. In e-commerce, **recommendation
    systems** , also known as **recommender systems** (see *Chapters 2* and *9* ),
    are built on bipartite graph data, where the nodes consist of users and items.
    The users and items never interact within their own kind; only interactions between
    users and items exist. This interaction can be in the form of clicks or orders
    of items made by the user:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 二分图在实际应用中非常常见。在电子商务中，**推荐系统**（也称为**推荐引擎**，参见*第2章*和*第9章*）是建立在二分图数据上的，其中节点由用户和商品组成。用户和商品之间的交互仅限于用户与商品之间的互动，而用户与用户、商品与商品之间没有交互。这种互动可以表现为用户点击或订购商品的形式：
- en: '![Figure 1.5 – A classic example of a bipartite graph, from an e-commerce application](img/B22118_01_5.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5 – 二分图的经典示例，来自电子商务应用](img/B22118_01_5.jpg)'
- en: Figure 1.5 – A classic example of a bipartite graph, from an e-commerce application
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 二分图的经典示例，来自电子商务应用
- en: Another example of a bipartite graph is the **marriage problem** , where vertices
    in one set represent men, vertices in the other set represent women, and edges
    represent marriages between couples. Another example is modeling interactions
    between customers and products in recommender systems.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个二分图的例子是**婚姻问题**，其中一个集合中的顶点代表男性，另一个集合中的顶点代表女性，边表示夫妻之间的婚姻关系。另一个例子是建模推荐系统中客户与产品之间的互动。
- en: Connected graphs
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连通图
- en: Fully **connected graphs** , also known as **complete graphs** , are graphs
    in which every pair of distinct vertices is connected by an edge, forming a network
    where each node is directly linked to every other node. They exhibit high connectivity
    but can become computationally intensive as the number of nodes increases.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 完全**连通图**，也称为**完全图**，是每一对不同顶点都通过边连接的图，形成一个每个节点与其他每个节点都直接相连的网络。它们具有很高的连通性，但随着节点数量的增加，计算复杂度也会增加。
- en: Weighted graphs
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加权图
- en: Graphs can also be appended with additional information on both the nodes and
    edges. When the edges are added as scalar additional information, the graph is
    said to be **weighted** .
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图还可以附加额外的信息，包括节点和边。当边作为标量附加信息添加时，图被称为**加权图**。
- en: While on the topic of graph types, let’s complete our discussion by introducing
    a few commonly noted properties of graphs. These aren’t labels that are attached
    to graphs, as we discussed previously regarding the different types of graphs,
    but certain measures or attributes of graphs that are agnostic of the type of
    graph under concern.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论图的类型时，我们来介绍一些图的常见属性。这些不是我们之前提到的附加到图上的标签，而是一些度量或属性，独立于所讨论的图的类型。
- en: Subgraphs
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子图
- en: A **subgraph** is a graph that’s formed from a subset of the vertices and edges
    of the original graph. More formally, let ![<mml:math  ><mml:mi>G</mml:mi></mml:math>](img/34.png)
    be a graph with vertex set ![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/1.png)
    and edge set ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/2.png) . A subgraph
    of ![<mml:math  ><mml:mi>G</mml:mi></mml:math>](img/34.png) is a graph, ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi><mml:mi>'</mml:mi></mml:math>](img/38.png)
    , such that ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi><mml:mo>(</mml:mo><mml:mi>G</mml:mi><mml:mi>'</mml:mi><mml:mo>)</mml:mo></mml:math>](img/39.png)
    is a subset of ![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/40.png) and E(
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi><mml:mi>'</mml:mi><mml:mo>)</mml:mo></mml:math>](img/41.png)
    is a subset of ![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/2.png) . Often,
    searching for subgraphs with useful properties such as being bipartite, or connected,
    is an important step for the bigger problem at hand.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**子图**是由原始图的一个顶点和边的子集构成的图。更正式地说，设![<mml:math  ><mml:mi>G</mml:mi></mml:math>](img/34.png)是一个具有顶点集![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/1.png)和边集![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/2.png)的图。图![<mml:math  ><mml:mi>G</mml:mi></mml:math>](img/34.png)的一个子图是一个图，记作![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi><mml:mi>''</mml:mi></mml:math>](img/38.png)，使得![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>V</mml:mi><mml:mo>(</mml:mo><mml:mi>G</mml:mi><mml:mi>''</mml:mi><mml:mo>)</mml:mo></mml:math>](img/39.png)是![<mml:math  ><mml:mi>V</mml:mi></mml:math>](img/40.png)的子集，且E(
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>G</mml:mi><mml:mi>''</mml:mi><mml:mo>)</mml:mo></mml:math>](img/41.png)是![<mml:math  ><mml:mi>E</mml:mi></mml:math>](img/2.png)的子集。通常，寻找具有有用性质（如二分图或连通图）的子图是解决更大问题的重要步骤。'
- en: Centrality
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中心性
- en: '**Centrality** is a measure in graph theory that quantifies the importance
    or influence of a node within a network. Nodes with high centrality are more central
    to the network, playing a more significant role in its structure and dynamics.
    There are several centrality measures, each capturing different aspects of a node’s
    importance. Here are some common centrality measures:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**中心性**是图论中的一个度量，它量化了一个节点在网络中的重要性或影响力。具有高中心性的节点在网络中更为中心，在其结构和动态中发挥着更重要的作用。中心性有多种度量方式，每种方式捕捉节点重要性的不同方面。以下是一些常见的中心性度量：'
- en: '**Degree centrality** : The degree centrality of a node is the number of edges
    connected to it (that is, the number of neighbors it has). Nodes with a high degree
    of centrality are well-connected and may play a crucial role in spreading information
    or influence.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**度数中心性**：一个节点的度数中心性是连接到它的边的数量（即它的邻居数量）。具有高度数中心性的节点通常连接紧密，可能在传播信息或影响力方面起着关键作用。'
- en: '**Closeness centrality** : Closeness centrality measures how close a node is
    to all other nodes in the network. It’s the reciprocal of the sum of the shortest
    path distances from a node to all other nodes. Nodes with high closeness centrality
    can quickly interact with other nodes and are often central in terms of communication
    efficiency.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接近中心性**：接近中心性衡量一个节点与网络中所有其他节点的接近程度。它是从一个节点到所有其他节点的最短路径距离之和的倒数。具有高接近中心性的节点可以迅速与其他节点进行交互，并且在通信效率方面通常处于中心位置。'
- en: '**Betweenness centrality** : Betweenness centrality quantifies the number of
    shortest paths that pass through a node. A node with high betweenness centrality
    has a significant influence on communication between other nodes. Nodes with high
    betweenness centrality act as bridges or gatekeepers in the network, controlling
    the flow of information.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**介数中心性**：介数中心性量化了通过一个节点的最短路径数量。具有高介数中心性的节点对其他节点之间的通信有显著影响。高介数中心性的节点在网络中充当桥梁或门控者，控制着信息流动。'
- en: '**Eigenvector centrality** : Eigenvector centrality considers not only the
    number of connections a node has but also the centrality of its neighbors. It’s
    based on the principle that connections to high-scoring nodes contribute more
    to a node’s centrality. Nodes with high eigenvector centrality are connected to
    other central nodes, making them important in the overall network structure.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特征向量中心性**：特征向量中心性不仅考虑节点的连接数，还考虑其邻居的中心性。它基于这样的原则：与高评分节点的连接对节点的中心性贡献更大。具有高特征向量中心性的节点通常与其他中心节点连接，使其在整个网络结构中非常重要。'
- en: '**PageRank** : PageRank is a centrality measure that’s used in web search algorithms
    (for example, Google’s PageRank). It assigns importance to a node based on both
    the number and quality of its incoming links. Nodes with high PageRank are considered
    influential as they are linked to other important nodes.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PageRank**：PageRank 是一种用于网页搜索算法（例如，谷歌的 PageRank）的中心性度量。它根据节点的入链数量和质量来赋予节点重要性。具有高
    PageRank 的节点被认为是有影响力的，因为它们与其他重要节点相连。'
- en: Centrality measures help identify key nodes in a network, which can be important
    for understanding information flow, identifying influential individuals, or targeting
    nodes for interventions in various applications such as social networks, transportation
    systems, and biological networks. Different centrality measures may be appropriate,
    depending on the specific context and goals of the analysis.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 中心性度量有助于识别网络中的关键节点，这对于理解信息流动、识别有影响力的个体或在各种应用中（如社交网络、交通系统和生物网络）针对节点进行干预都非常重要。根据分析的具体背景和目标，可能需要不同的中心性度量。
- en: Community structure
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 社区结构
- en: In terms of graphs, **community structure** refers to dividing a network or
    graph into groups or clusters of nodes that are densely connected internally but
    have fewer connections between groups. Nodes within a community are more likely
    to share similar properties, interests, or functions, and identifying community
    structure is a fundamental aspect of analyzing the organization and dynamics of
    complex networks. Detecting communities in a graph is crucial for understanding
    the modular organization of the system and can have applications in various fields,
    including social network analysis, biology, and information retrieval.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在图论中，**社区结构**指的是将网络或图分为节点的群组或簇，这些节点在内部连接密集，但组与组之间的连接较少。社区内的节点更可能具有相似的属性、兴趣或功能，识别社区结构是分析复杂网络的组织和动态的基础。检测图中的社区对理解系统的模块化组织至关重要，并且在许多领域（如社交网络分析、生物学和信息检索）都有应用。
- en: Isomorphism
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同构
- en: '**Isomorphism** is a concept in graph theory that deals with the structural
    similarity between two graphs. Two graphs are considered isomorphic if a one-to-one
    correspondence exists between their vertices such that the adjacency relationships
    are preserved. In other words, the graphs are essentially the same from a structural
    point of view, even if the vertex and edge labels may differ.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**同构**是图论中的一个概念，处理两个图之间的结构相似性。若两个图的顶点之间存在一一对应关系，并且邻接关系得以保持，则认为这两个图是同构的。换句话说，从结构角度来看，这两个图本质上是相同的，即使顶点和边的标签可能不同。'
- en: 'Graph isomorphism is a fundamental problem in computer science and has applications
    in various areas, such as chemistry, computer-aided design, and pattern recognition.
    Despite its practical importance, finding a fast algorithm for graph isomorphism
    has proven to be a challenging problem, and it remains an open question whether
    such an algorithm exists with polynomial time complexity:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图同构是计算机科学中的一个基础问题，应用广泛，如化学、计算机辅助设计和模式识别等领域。尽管它在实际应用中非常重要，但找到一个快速的图同构算法仍然是一个具有挑战性的问题，而且是否存在具有多项式时间复杂度的算法仍然是一个悬而未决的问题：
- en: '![Figure 1.6 – G and H are isomorphic graphs. To understand this, notice the
    mapping: g1→h1, g2→h2, g3→h3, and so on](img/B22118_01_6.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6 – G 和 H 是同构图。要理解这一点，请注意以下映射关系：g1→h1，g2→h2，g3→h3，依此类推](img/B22118_01_6.jpg)'
- en: 'Figure 1.6 – G and H are isomorphic graphs. To understand this, notice the
    mapping: g 1 →h 1 , g 2 →h 2 , g 3 →h 3 , and so on'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – G 和 H 是同构图。要理解这一点，请注意以下映射关系：g 1 →h 1，g 2 →h 2，g 3 →h 3，依此类推。
- en: The properties of specialized graphs can be exploited to derive further insights
    into the scenarios represented by these graphs. Now, let’s take a look at how
    graphs can be fed into machines so that they can be read algorithmically.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 专用图的属性可以被利用，以进一步洞察这些图所表示的场景。现在，让我们来看看如何将图输入到机器中，以便它们可以被算法读取。
- en: Graph data structures
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图数据结构
- en: How should we feed graph data into computer programs so that we can apply graph-based
    algorithms to solve problems? This will be addressed in this section. Each representation
    has its advantages and disadvantages, and we’ll explore them from the perspective
    of the time complexity of determining whether an edge exists and updating the
    graph.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该如何将图数据输入到计算机程序中，以便能够应用基于图的算法来解决问题？这一点将在本节中讨论。每种表示方法都有其优缺点，我们将从确定边是否存在以及更新图的时间复杂度的角度来探讨它们。
- en: Adjacency matrix
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 邻接矩阵
- en: The **adjacency matrix** aims to record the graph structure via a matrix. A
    matrix, say ![<mml:math  ><mml:mi>A</mml:mi></mml:math>](img/43.png) , of size
    ![<mml:math  ><mml:mi>v</mml:mi><mml:mo>×</mml:mo><mml:mi>v</mml:mi></mml:math>](img/44.png)
    is created (where ![<mml:math  ><mml:mi>v</mml:mi></mml:math>](img/45.png) denotes
    the number of nodes, or mathematically, ![<mml:math  ><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo>|</mml:mo></mml:math>](img/46.png)
    ). We start with all entries of ![<mml:math  ><mml:mi>A</mml:mi></mml:math>](img/47.png)
    being 0. Next, if ![<mml:math  ><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/48.png)
    , ![<mml:math  ><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:math>](img/49.png)
    , then element ![<mml:math  ><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo></mml:math>](img/50.png)
    of ![<mml:math  ><mml:mi>A</mml:mi></mml:math>](img/47.png) is labeled * 1 * .
    If the graph is undirected, then if ![<mml:math  ><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/52.png)
    , ![<mml:math  ><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:math>](img/53.png)
    , then both elements of ![<mml:math  ><mml:mi>A</mml:mi></mml:math>](img/43.png)
    , ![<mml:math  ><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo></mml:math>](img/55.png)
    , and ![<mml:math  ><mml:mo>(</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:math>](img/56.png)
    , are labeled * 1 * .
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**邻接矩阵**旨在通过矩阵记录图的结构。创建一个矩阵，例如 ![<mml:math  ><mml:mi>A</mml:mi></mml:math>](img/43.png)
    ，大小为 ![<mml:math  ><mml:mi>v</mml:mi><mml:mo>×</mml:mo><mml:mi>v</mml:mi></mml:math>](img/44.png)
    （其中 ![<mml:math  ><mml:mi>v</mml:mi></mml:math>](img/45.png) 表示节点数，或者从数学角度来看，!['
- en: The time complexity to check whether an edge exists in an adjacency matrix is
    ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/57.png)
    since it just involves checking a particular cell in the matrix. However, adding
    a new vertex to the graph would be difficult, and depending on the matrix implementation,
    it might need an entirely new initialization. Finally, the space complexity of
    the adjacency matrix is also large, in the order of ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>V</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math>](img/58.png)
    . Sparse matrix implementations exist, which might reduce the space required by
    the matrix in memory, but they come with their own set of drawbacks. Adjacency
    matrices are a good choice when the graph is fairly small and   static and   also
    requires frequent lookup.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在邻接矩阵中检查边是否存在的时间复杂度是 ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/57.png)，因为它只涉及检查矩阵中的特定单元格。然而，向图中添加新顶点会比较困难，并且根据矩阵的实现，可能需要完全重新初始化。最后，邻接矩阵的空间复杂度也较大，按
    ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>V</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math>](img/58.png)
    的顺序计算。存在稀疏矩阵的实现，它们可能减少矩阵在内存中所需的空间，但它们也有自己的缺点。当图较小且静态且需要频繁查找时，邻接矩阵是一个不错的选择。
- en: Adjacency list
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 邻接表
- en: 'Another popular data structure that’s used to store graph data is an **adjacency
    list** . It contains a dictionary that has keys as node names, and each entry
    contains a list of all nodes connected to the key node with an edge. Unlike adjacency
    matrices, whose space complexity is ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>V</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math>](img/59.png)
    , adjacency lists have a space complexity of ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo>|</mml:mo></mml:math>](img/60.png)
    ). However, adjacency lists are far more flexible with efficient time complexities
    for many data-related tasks. Inserting vertices and edges is ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/61.png)
    ; accessing neighbors takes ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/62.png)
    as well, while finding whether an edge exists or not can take ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfenced><mml:mo>)</mml:mo></mml:math>](img/63.png)
    time. Adjacency lists are a good choice when the graph is inherently sparse:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常用于存储图数据的流行数据结构是**邻接表**。它包含一个字典，字典的键是节点名称，每个条目包含一个与该键节点通过边连接的所有节点的列表。与邻接矩阵不同，邻接矩阵的空间复杂度是
    ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>V</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math>](img/59.png)
    ，而邻接表的空间复杂度是 ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mfenced open="|"
    close="|" separators="|"><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo>|</mml:mo></mml:math>](img/60.png)
    。然而，邻接表在许多数据相关任务中更具灵活性，且具有更高效的时间复杂度。插入顶点和边的操作是 ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/61.png)；访问邻居节点的操作也需要
    ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/62.png)，而判断一条边是否存在则可能需要
    ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mfenced open="|" close="|"
    separators="|"><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfenced><mml:mo>)</mml:mo></mml:math>](img/63.png)
    的时间。如果图本身稀疏，邻接表是一个不错的选择：
- en: '![Figure 1.7 – For the given graph, G, M and L are the adjacency matrix and
    list, respectively](img/B22118_01_7.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.7 – 对于给定的图 G，M 和 L 分别是邻接矩阵和邻接表](img/B22118_01_7.jpg)'
- en: Figure 1.7 – For the given graph, G, M and L are the adjacency matrix and list,
    respectively
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – 对于给定的图 G，M 和 L 分别是邻接矩阵和邻接表
- en: So far, we’ve talked about adjacency matrices and adjacency lists as the two
    most popular data structures that are used to represent graphs in algorithms.
    However, several other graph data structures can be used based on the problem
    statement. Each graph data structure has its own set of advantages and disadvantages,
    and this serves as a great domain on which further research can be performed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了邻接矩阵和邻接表这两种在算法中常用的图表示数据结构。然而，根据问题的不同，还有许多其他图数据结构可以使用。每种图数据结构都有其优缺点，这是一个很好的研究领域，值得进一步探讨。
- en: Traditional graph-based solutions
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统的基于图的解决方案
- en: Many computer scientists have etched their names in history by devising elegant
    solutions to seemingly complex problems involving graphs. However, graphs aren’t
    just confined to the algorithm books, and graph-based problems are common in the
    wild. Lots of business problems and scientific research can be boiled down to
    graph-based problems, on which existing solutions can be implemented to generate
    the required output. In this section, we’ll talk about the most popular problems
    in the domain of graphs, a few approaches to solving them, and where these problems
    are encountered in practical scenarios.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 许多计算机科学家通过设计优雅的解决方案解决了涉及图的看似复杂问题，留下了浓厚的历史印记。然而，图并不仅仅局限于算法书籍中，图相关的问题在实际中也非常常见。许多商业问题和科学研究实际上可以转化为图问题，现有的解决方案可以在这些问题上实施，以生成所需的输出。在这一节中，我们将讨论图领域中最常见的问题、一些解决这些问题的方法，以及这些问题在实际场景中常见的应用。
- en: Searching
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索
- en: 'There are two fundamental approaches when performing a search over a graph:
    breadth-first and depth-first. Both are means to traverse a graph from a starting
    point to all nodes that can be reached from the initial node, but the differentiating
    factor is their approach.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 执行图搜索时有两种基本的方法：广度优先搜索（BFS）和深度优先搜索（DFS）。这两种方法都是从起始点开始遍历图，直到所有可以从初始节点到达的节点，但它们的区别在于各自的处理方式。
- en: In BFS, the algorithm explores a graph level by level, starting from the source
    vertex and visiting all its neighbors before moving on to the next level. This
    approach ensures that nodes closer to the source are visited before deeper nodes.
    On the other hand, **depth-first search** ( **DFS** ) explores a graph by going
    as deep as possible along each branch before backtracking. It explores one branch
    of the graph until it reaches the end before moving on to the next branch.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在广度优先搜索（BFS）中，算法逐层探索图，从源顶点开始，先访问所有邻居节点，再进入下一层。这种方法确保了离源节点较近的节点会先被访问，而更深层的节点则会后访问。另一方面，**深度优先搜索**（**DFS**）则是沿着每个分支尽可能深入，直到无法继续，然后回溯。它会在到达某个分支的末端之前，先深入探索这一分支，才会转向下一个分支。
- en: BFS is well-suited for finding the shortest path in unweighted graphs and is
    commonly used in network routing protocols and social network analysis. DFS, with
    its deep exploration, is useful in topological sorting, cycle detection, and solving
    problems such as maze exploration and puzzle-solving.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先搜索（BFS）非常适合在无权图中寻找最短路径，并且常用于网络路由协议和社交网络分析中。深度优先搜索（DFS）则通过深度探索，非常适合用于拓扑排序、环检测，以及解决迷宫探索和拼图问题等。
- en: Now that we have a basic understanding of search algorithms, let’s look at another
    class of problems, called **partitioning** . The need to understand graph partitions
    occurs frequently in practice.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对搜索算法有了基本的了解，接下来让我们来看另一类问题——**划分**。在实际中，理解图划分的需求非常频繁。
- en: Partitioning
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 划分
- en: 'In graph theory, partitioning refers to dividing the vertices or edges of a
    graph into disjoint subsets or components. The goal of partitioning is to group
    elements of the graph in such a way that certain properties are satisfied, or
    specific objectives are achieved. There are different types of graph partitioning,
    and the choice of partitioning criteria depends on the application or problem
    at hand:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在图论中，划分指的是将图的顶点或边分割成互不相交的子集或组件。划分的目标是以某种方式将图的元素分组，以满足特定的属性或达成某个目标。图划分有不同的类型，选择哪种划分标准取决于应用或当前问题的需求：
- en: '**Vertex partitioning** : This involves dividing the set of vertices of a graph
    into disjoint subsets. Vertex partitioning is done to achieve balance in terms
    of the number of vertices in each subset. This is a problem that’s commonly encountered
    in load balancing in parallel computing, network design, and social network analysis.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点划分**：这涉及将图的顶点集合划分为互不重叠的子集。顶点划分的目的是为了在每个子集中的顶点数量上实现平衡。这是并行计算中的负载平衡、网络设计和社交网络分析中常见的问题。'
- en: '**Edge partitioning** : As the name suggests, this involves dividing the set
    of edges of a graph into disjoint subsets. Just like vertex partitioning, the
    objective here is to balance the number of edges or the total weight of edges
    in each subset. Edge partitioning problems generally find application in communication
    optimization in distributed computing, minimizing inter-partition communication.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边划分**：顾名思义，这涉及将图的边集合划分为互不重叠的子集。与顶点划分类似，这里的目标是平衡每个子集中边的数量或边的总权重。边划分问题通常应用于分布式计算中的通信优化，最小化子集间的通信。'
- en: '**Graph cut** : This involves partitioning a graph by removing a minimum number
    of edges. This is done to minimize the cut size (total weight of removed edges)
    while achieving certain constraints. Applications include image segmentation and
    community detection in social networks.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图割**：这涉及通过去除最少数量的边来划分图。目的是在满足某些约束条件的同时，最小化割的大小（去除边的总权重）。应用包括图像分割和社交网络中的社区检测。'
- en: '**K-way partitioning** : This is a generalization of the aforementioned ideas
    and involves dividing the vertices or edges into ![<mml:math  ><mml:mi>k</mml:mi></mml:math>](img/64.png)
    disjoint subsets. We find k-way partitioning problems where we need to achieve
    balance in terms of the number of elements in each of the ![<mml:math  ><mml:mi>k</mml:mi></mml:math>](img/64.png)
    subsets, such as in domains such as ** very-large-scale integration ** ( ** VLSI
    ** ) design   and parallel computing. You can read more here: [ https://patterns.eecs.berkeley.edu/?page_id=571
    ](https://patterns.eecs.berkeley.edu/?page_id=571) .'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**K-路划分**：这是上述概念的推广，涉及将顶点或边划分为 ![<mml:math  ><mml:mi>k</mml:mi></mml:math>](img/64.png)
    个互不重叠的子集。在K-路划分问题中，我们需要在每个 ![<mml:math  ><mml:mi>k</mml:mi></mml:math>](img/64.png)
    子集中的元素数量上实现平衡，这类问题出现在 **超大规模集成**（**VLSI**）设计和并行计算等领域。你可以在这里阅读更多内容：[ https://patterns.eecs.berkeley.edu/?page_id=571
    ](https://patterns.eecs.berkeley.edu/?page_id=571)。'
- en: Graph partitioning problems are often NP-hard, meaning finding an optimal solution
    may be computationally intractable for large graphs. Therefore, various heuristics,
    approximation algorithms, and optimization techniques are employed to find good
    solutions in a reasonable amount of time.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图划分问题通常是NP难的，这意味着对于大型图而言，找到最优解在计算上可能是不可行的。因此，各种启发式算法、近似算法和优化技术被用来在合理的时间内找到良好的解决方案。
- en: Another important problem in the domain of graphs is path optimization, and
    a lot of supply chain businesses and network researchers have been traditionally
    interested in solutions to such problems.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在图论领域中，另一个重要问题是路径优化，许多供应链企业和网络研究人员一直对此类问题的解决方案感兴趣。
- en: Path optimization
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径优化
- en: Two common problems in graph theory are finding the shortest path and finding
    the widest path between two nodes in a weighted graph. Their applications are
    obvious and involve route optimization in supply chains and social network analysis
    (the problem mentioned in the preceding case study can also be viewed as a shortest
    path problem between the two nodes, especially if a slight modification was made
    by needing the edges to be weighted).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图论中两个常见问题是找到两节点之间的最短路径和最宽路径。它们的应用显而易见，涉及供应链中的路线优化和社交网络分析（前述案例研究中提到的问题也可以视为两节点之间的最短路径问题，特别是如果通过要求边加权进行了轻微修改的话）。
- en: 'The widest path problem is a variant of the shortest path problem. Formally,
    the problem is defined thus: given a weighted graph, the widest path problem seeks
    a path from a source vertex to a target vertex such that the minimum edge weight
    (bottleneck) along the path is maximized. This can be particularly relevant in
    network design or communication systems, where the goal is to maximize the capacity
    of the bottleneck link.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最宽路径问题是最短路径问题的变种。正式地，问题定义如下：给定一个加权图，最宽路径问题寻找一条从源顶点到目标顶点的路径，使得路径上最小的边权（瓶颈）最大化。这在网络设计或通信系统中尤为相关，目标是最大化瓶颈链路的容量。
- en: 'The most popular solution to find the shortest path between two nodes is **Dijkstra’s
    algorithm** . While not diving too much into the details, here’s a short step-by-step
    summary of the algorithm:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找两个节点之间最短路径的最流行方法是**迪杰斯特拉算法**。虽然不深入细节，这里是该算法的简短步骤总结：
- en: '**Initialization** :'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初始化**：'
- en: Start at the source vertex.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从源顶点开始。
- en: Assign a tentative distance of 0 to the source and infinity to all other vertices.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将源顶点的临时距离设为0，所有其他顶点的临时距离设为无穷大。
- en: Mark all vertices as unvisited.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有顶点标记为未访问。
- en: '**Iterative exploration** :'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**迭代探索**：'
- en: Select the unvisited vertex with the smallest tentative distance.
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择未访问的临时距离最小的顶点。
- en: For the selected vertex, consider all its neighbors.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于选定的顶点，考虑它的所有邻居。
- en: Update the tentative distance of each neighbor by adding the distance from the
    current vertex.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将当前顶点到每个邻居的距离加起来，更新每个邻居的临时距离。
- en: If the updated distance is smaller than the current tentative distance, update
    it.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果更新后的距离小于当前的临时距离，则更新它。
- en: Mark the current vertex as visited.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前顶点标记为已访问。
- en: '**Termination** :'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**终止**：'
- en: Repeat the iterative process until the destination vertex is visited or all
    vertices have been visited.
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复迭代过程，直到目标顶点被访问或所有顶点都被访问。
- en: The final assigned distances represent the shortest paths from the source to
    all other vertices.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终分配的距离表示从源顶点到所有其他顶点的最短路径。
- en: Reconstruct the shortest path by backtracking from the destination to the source
    using the information that was stored about the shortest distances.
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从目标顶点回溯到源顶点，利用存储的最短距离信息来重建最短路径。
- en: In summary, Dijkstra’s algorithm explores the graph in a step-by-step manner,
    always choosing the vertex with the smallest tentative distance. It gradually
    builds up the shortest paths from the source to all other vertices while marking
    visited vertices. The final result is a set of shortest distances and paths from
    the source to all other vertices in the graph. The widest path problem can also
    be solved by the same algorithm, but instead of maintaining the smallest tentative
    distance per node, we maintain the bottleneck weight (or the maximum of the minimum
    weights across all paths). The time complexity of this algorithm depends heavily
    on the implementation used, and the complexity ranges from ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfenced open="|" close="|" separators="|"><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi>E</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mi>*</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo>|</mml:mo><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math>](img/66.png)
    ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi>E</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mi>*</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo>|</mml:mo><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math>](img/67.png)
    to ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>V</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math>](img/68.png)
    . Dijkstra’s algorithm fails when the edge weights are negative, however, and
    is also inefficient if the graph is nearly fully connected. In such scenarios,
    alternatives such as the ** Bellman-Ford ** ** algorithm ** can   be used.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Dijkstra算法以逐步的方式探索图，始终选择具有最小暂定距离的顶点。它逐渐构建从源点到所有其他顶点的最短路径，同时标记已访问的顶点。最终的结果是从源点到图中所有其他顶点的一组最短距离和路径。最宽路径问题也可以通过相同的算法解决，但不是保持每个节点的最小暂定距离，而是保持瓶颈权重（或者是所有路径中最小权重的最大值）。该算法的时间复杂度很大程度上依赖于所使用的实现方法，复杂度范围从![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfenced open="|" close="|" separators="|"><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi>E</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mi>*</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo>|</mml:mo><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math>](img/66.png)
    ![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi>E</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mi>*</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo>|</mml:mo><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math>](img/67.png)
    到![<mml:math  ><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>V</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math>](img/68.png)。然而，当边权为负时，Dijkstra算法会失败，而且当图几乎完全连接时也会效率低下。在这种情况下，可以使用**Bellman-Ford**
    **算法**等替代方法。
- en: Now that we have a basic understanding of what kind of analytics are performed
    on graph data, let’s look at another powerful way of learning patterns within
    graph data. The core ideas of representation learning are described in the following
    section; we’ll learn how representation learning is an important first step for
    solving many complex problems involving graphs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经基本了解了图数据上执行的各种分析方法，接下来让我们看看另一种强大的学习图数据中模式的方式。表示学习的核心思想将在以下部分中介绍；我们将学习表示学习是解决许多涉及图的复杂问题的重要第一步。
- en: The need for representation learning
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表示学习的需求
- en: 'Here, we’ll introduce a new concept called **representation learning for graphs**
    . Let’s use a small analogy to understand what this means. A typical corporate
    organization has several entities: employees, IT equipment, offices, and so on.
    All these entities maintain different types of relationships with each other:
    employees can be related to each other based on organizational hierarchy; one
    employee may use several pieces of IT equipment; several pieces of equipment,
    such as servers, can be networked with each other; employees and equipment can
    report physically or be located in a particular office, respectively; and so on.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将介绍一个新概念——**图形的表示学习**。让我们通过一个小类比来理解这意味着什么。一个典型的公司组织包含几个实体：员工、IT 设备、办公室等。所有这些实体之间保持不同类型的关系：员工之间可以基于组织层级相关联；一个员工可能使用几件
    IT 设备；几件设备，如服务器，可以相互连接；员工和设备可以分别在某个特定办公室报到或位于该办公室，等等。
- en: 'A graph, quite rightly, seems like a natural way to represent this information,
    like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图形，确实是表示这些信息的一种自然方式，如下所示：
- en: '![Figure 1.8 – A graph showing the different entities in an organization interacting
    with each other](img/B22118_01_8.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.8 – 显示组织中不同实体相互作用的图形](img/B22118_01_8.jpg)'
- en: Figure 1.8 – A graph showing the different entities in an organization interacting
    with each other
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – 显示组织中不同实体相互作用的图形
- en: 'Graphs are very visually intuitive. However, performing algorithmic calculations
    on graphs isn’t trivial. Could we find a way to capture the characteristics as
    well as the relationship information of each entity as much as possible, but within
    some common fields? Consider a sort of unique ID card for each entity that contains
    the following fields: Name, Sub-Organization, Date of Initiation, Years in Industry,
    and Geographic Location. So, a few ID cards may look like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图形在视觉上非常直观。然而，对图形进行算法计算并不是一件简单的事情。我们能否找到一种方法，在一些共同的字段中尽可能捕捉每个实体的特征和关系信息？考虑为每个实体设计一张独特的
    ID 卡，其中包含以下字段：姓名、子组织、启动日期、行业年限和地理位置。因此，几张 ID 卡可能长这样：
- en: '![Figure 1.9 – Examples of a few ID cards with the same fields for all entities](img/B22118_01_9.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.9 – 几个具有相同字段的实体 ID 卡示例](img/B22118_01_9.jpg)'
- en: Figure 1.9 – Examples of a few ID cards with the same fields for all entities
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 – 几个具有相同字段的实体 ID 卡示例
- en: Now, if you’re presented with a set of ID cards of all entities and not the
    preceding graph, could you answer questions such as which employee reports to
    whom? Alternatively, which ID card is that of an employee, which of the office,
    and which of a piece of IT equipment? It’s not easy (or completely feasible) to
    determine the answers to such questions using just the information in the ID cards,
    but we can get close to the correct answer. To answer whether an employee is under
    some other employee in the hierarchy, we can check whether both employees have
    the same **Sub-Organization** and **Geographic-Location** values and whether the
    employee higher in the hierarchy has a higher **Years-in-Industry** value than
    the other. Guessing whether an ID card belongs to an office might simply mean
    checking whether the **Sub-Organization** value of the entity is blank, and so
    on.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你只看到了所有实体的 ID 卡而没有看到前面的图形，你能回答一些问题吗？比如哪个员工汇报给谁？或者，哪张 ID 卡是员工的，哪张是办公室的，哪张是
    IT 设备的？仅凭 ID 卡上的信息，确定这些问题的答案并不容易（或完全可行），但我们可以接近正确答案。要回答一个员工是否在另一个员工的层级下，我们可以检查两个员工是否具有相同的**子组织**和**地理位置**值，并且层级更高的员工在**行业年限**上是否高于另一个员工。猜测某张
    ID 卡是否属于办公室，可能只需要检查该实体的**子组织**值是否为空，等等。
- en: While this approach sounds non-intuitive at first, using such heuristics to
    try to answer these practical questions based simply on the ID cards, and not
    the graph, can be performed efficiently by computers and modern-day implementations.
    The ID card here tries to *represent* the characteristics of the entities and
    relationships in the graph.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法一开始听起来不太直观，但仅仅通过 ID 卡而不是图形，使用这种启发式方法来尝试回答这些实际问题，计算机和现代实现可以高效地完成。这里的 ID
    卡试图*表示*图形中实体的特征和关系。
- en: More formally, the ID cards in the preceding example are vector embeddings of
    a fixed dimension that’s associated with each node of the graph. A learning algorithm
    is applied that tries to capture as much information present in the graph structure
    within these embeddings. These sets of embeddings are then used to answer difficult
    questions regarding the graph, instead of relying on the original graph itself.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 更正式地说，前面示例中的身份证是与图的每个节点相关的固定维度的向量嵌入。应用了一种学习算法，旨在在这些嵌入向量中尽可能多地捕捉图结构中的信息。这些嵌入向量集随后用于回答有关图的难题，而不依赖于原始图形本身。
- en: 'Why should we try to learn representations? What benefits do working with embeddings
    present over working with the original graph in itself? Let’s take a look:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要尝试学习表示？与直接处理原始图形相比，使用嵌入向量有什么好处？让我们来看看：
- en: '**Scalability** : Traditional graph algorithms can become computationally expensive
    and impractical for large-scale graphs. Representation learning allows compact
    embeddings to be generated that capture essential graph information, enabling
    more scalable and efficient computations.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：传统的图算法对于大规模图形可能会变得计算上昂贵且不切实际。表示学习方法通过生成紧凑的嵌入向量来捕捉图形的关键信息，从而实现更可扩展和高效的计算。'
- en: '**Task flexibility** : Representation learning produces embeddings that are
    task-agnostic, meaning they can be used for a variety of downstream tasks. Traditional
    graph algorithms are often designed for specific problems, and adapting them to
    different tasks might be challenging. Embeddings provide a more flexible and versatile
    way to approach diverse tasks.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务灵活性**：表示学习生成的嵌入向量是与任务无关的，这意味着它们可以用于各种下游任务。传统的图算法通常是针对特定问题设计的，将其适配到不同的任务中可能会面临挑战。而嵌入向量提供了更灵活和多功能的方式来处理各种任务。'
- en: '**Incorporating node and edge features** : Many real-world graphs come with
    additional features associated with nodes and edges. Representation learning methods
    can naturally incorporate these features into the learning process, allowing for
    a more comprehensive understanding of the graph’s characteristics. Traditional
    graph algorithms might not easily integrate external features.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含节点和边的特征**：许多现实世界的图形都带有与节点和边相关的额外特征。表示学习方法可以自然地将这些特征纳入学习过程，从而对图形特征进行更全面的理解。传统的图算法可能不容易集成外部特征。'
- en: '**Handling dynamic graphs** : Representation learning is well-suited for dynamic
    graphs where the structure evolves. The learned embeddings can capture temporal
    patterns and changes, providing a more adaptive approach compared to traditional
    graph algorithms, which might not inherently address temporal aspects.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理动态图**：表示学习非常适合处理结构不断演变的动态图。学习到的嵌入向量可以捕捉时间模式和变化，提供比传统图算法更适应的方式，而传统算法可能未能本质上解决时间因素。'
- en: '**Generalization to unseen data** : Representation learning aims to generate
    embeddings that generalize well to unseen data. This is particularly useful in
    scenarios where the graph structure is not completely known or is subject to change.
    Traditional graph algorithms may not generalize as effectively to new or unseen
    graph instances.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对未见数据的泛化能力**：表示学习旨在生成能够很好地泛化到未见数据的嵌入向量。这在图结构不完全已知或可能发生变化的情况下尤为有用。传统的图算法可能无法有效地对新的或未见过的图实例进行泛化。'
- en: '**Noise robustness** : Embeddings can be more robust to noisy or incomplete
    graph data. Traditional graph algorithms may be sensitive to noise, but representation
    learning methods can learn to ignore irrelevant information and focus on the most
    informative aspects of the graph.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**噪声鲁棒性**：嵌入向量可以对噪声或不完整的图数据更具鲁棒性。传统的图算法可能对噪声敏感，但表示学习方法可以学会忽略无关信息，专注于图形的最重要部分。'
- en: '**Integration with machine learning models** : Representation learning facilitates
    the integration of graph data with machine learning models. The learned embeddings
    can serve as input features for various machine learning tasks, allowing practitioners
    to leverage the power of both graph-based and non-graph-based algorithms in a
    unified framework.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与机器学习模型的集成**：表示学习促进了图数据与机器学习模型的集成。学习到的嵌入向量可以作为各种机器学习任务的输入特征，使得实践者能够在统一框架中利用图基算法和非图基算法的优势。'
- en: By capturing essential information in compact embeddings, it becomes more feasible
    to apply machine learning techniques to graph-structured data and address a wide
    range of tasks efficiently.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过捕捉图数据中的关键信息并将其压缩成嵌入，应用机器学习技术于图结构数据变得更加可行，并且可以高效地处理各种任务。
- en: GNNs and the need for a separate vertical
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GNN和需要单独关注的领域
- en: We won’t dive into the details of what GNNs do or how they differ from other
    popular neural network architectures in this chapter. Here, we’ll merely attempt
    to explain why there’s a need to study GNNs separately from other deep learning
    architectures.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不会深入讨论GNN的具体工作原理或它们与其他流行的神经网络架构的不同之处。在这里，我们只是尝试解释为什么有必要将GNN单独研究，而不是与其他深度学习架构一起研究。
- en: 'Before talking about the differences, we must discuss the similarities. GNNs
    are an architecture choice that’s specialized for processing graph data and outputting
    representations or node embeddings. Similar to how convolutional networks are
    fundamental for reading pixel data, the set of architectures under GNNs are optimized
    for reading graph data. GNN-based learning tasks follow the same trajectory as
    other deep learning solutions: to iteratively optimize the parameters of the model
    so that a loss function can be minimized. In the case of GNNs, the loss function
    often tries to capture and preserve meaningful information about the graph structure.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论差异之前，我们必须先讨论相似性。GNN是一种专门用于处理图数据并输出表示或节点嵌入的架构选择。类似于卷积网络对于读取像素数据的重要性，GNN架构集被优化用于读取图数据。基于GNN的学习任务与其他深度学习解决方案的轨迹相同：通过迭代优化模型的参数，以使损失函数最小化。在GNN的情况下，损失函数通常尝试捕捉并保留关于图结构的有意义信息。
- en: 'Now, let’s have a look at the differences, and why GNNs require special attention:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看这些差异，以及为什么GNN需要特别关注：
- en: '**Irregular graph structures** : Graphs can have irregular and varying structures,
    with nodes having different numbers of neighbors. This irregularity poses challenges
    for traditional deep learning architectures, which often assume fixed input sizes.
    For example, in a social network, individuals may have varying numbers of connections
    (friends, followers, and so on).'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不规则的图结构**：图可以具有不规则和变化的结构，节点可能有不同数量的邻居。这种不规则性对传统的深度学习架构构成挑战，因为传统架构通常假设输入大小是固定的。例如，在社交网络中，个体可能有不同数量的连接（朋友、关注者等等）。'
- en: '**Permutation invariance** : The order of nodes in a graph shouldn’t affect
    the output of a GNN. Achieving permutation invariance is crucial to ensure that
    the model can generalize across different node orders. A good example of permutation
    invariance is in molecular graphs in chemistry. The properties of a molecule depend
    only on its structure, not the order in which the atoms are labeled.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**置换不变性**：图中节点的顺序不应影响GNN的输出。实现置换不变性对于确保模型能够跨不同节点顺序进行泛化至关重要。一个置换不变性的好例子是化学中的分子图。分子的性质仅依赖于其结构，而不是原子标号的顺序。'
- en: '**Graph isomorphism problem** : Determining whether two graphs are isomorphic
    is a computationally complex problem. GNNs need to be able to capture and differentiate
    between different graph structures.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图同构问题**：确定两个图是否同构是一个计算上复杂的问题。GNN需要能够捕捉并区分不同的图结构。'
- en: '**Node and graph classification** : GNNs often need to perform tasks such as
    node classification or graph classification. These tasks require the model to
    capture both local and global information from the graph, which can be challenging.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点和图分类**：GNN通常需要执行如节点分类或图分类等任务。这些任务要求模型能够捕获图的局部和全局信息，这可能是一个挑战。'
- en: '**Handling different types of edges** : Graphs may have different types of
    edges, each representing a different kind of relationship between nodes. GNNs
    need to be able to model and leverage this heterogeneity in edge types.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理不同类型的边**：图可能具有不同类型的边，每种边代表节点之间不同的关系。GNN（图神经网络）需要能够建模并利用这种边类型的异质性。'
- en: '**Pooling and aggregation** : Aggregating information from neighbors in a graph
    is a fundamental operation in GNNs. Designing effective pooling and aggregation
    strategies to capture important information while avoiding information loss or
    redundancy is a challenge. A good example is when recommendation systems pool
    information from the user’s friends’ preferences. The representations should capture
    this pooling idea as well.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**池化与聚合**：在图中聚合邻居信息是GNNs中的一个基本操作。设计有效的池化和聚合策略，以捕获重要信息，同时避免信息丢失或冗余，是一个挑战。一个很好的例子是推荐系统如何从用户朋友的偏好中池化信息。表示应当能够捕捉到这种池化的思路。'
- en: '**Capturing long-range dependencies** : GNNs need to capture long-range dependencies
    in graphs. Unlike sequential data in **recurrent neural networks** ( **RNNs**
    ), where dependencies are often local, graphs may have dependencies that span
    long distances.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**捕捉长程依赖**：GNNs需要捕捉图中的长程依赖关系。与**递归神经网络**（**RNNs**）中的顺序数据不同，后者的依赖关系通常是局部的，图可能存在跨越长距离的依赖关系。'
- en: '**Interpretable representations** : Understanding and interpreting the learned
    representations in GNNs is crucial, especially in applications where interpretability
    is essential. Interpretability is crucial in medical diagnosis with electronic
    health records. GNNs can be used to analyze patient records where nodes represent
    different health parameters. Interpretable representations are crucial for healthcare
    professionals to understand and trust the model’s decision-making process in diagnosing
    diseases or predicting patient outcomes.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可解释的表示**：在图神经网络（GNNs）中，理解和解释学习到的表示是至关重要的，尤其是在那些可解释性至关重要的应用中。可解释性在使用电子健康记录进行医学诊断时尤为关键。GNNs可以用来分析患者记录，其中节点表示不同的健康参数。可解释的表示对于医疗专业人员理解并信任模型在诊断疾病或预测患者结果时的决策过程至关重要。'
- en: GNNs provide a lot of the benefits that machine learning approaches have in
    terms of boosting our capabilities with tabular data, but in terms of graph data.
    There are several important implications of using GNNs as an intermediary step
    to solve relevant problems related to graphs. We’ll explore more such topics in
    the coming chapters.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: GNNs提供了机器学习方法在处理表格数据时所具备的许多优势，但它们是在图数据的背景下发挥作用。使用GNNs作为解决与图相关问题的中介步骤有几个重要的意义。我们将在接下来的章节中探索更多类似的话题。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the foundational concepts in graph learning and
    representation. We began with motivating examples of how graph structures naturally
    capture relationships between entities, making them a powerful data representation.
    Then, formal definitions of graphs, common graph types, and key properties were
    discussed. We also looked at popular graph algorithms such as searching, partitioning,
    and path optimization, along with their real-world use cases.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了图学习和表示的基础概念。我们从激励性示例开始，说明了图结构如何自然地捕捉实体之间的关系，使其成为一种强大的数据表示。接着，我们讨论了图的正式定义、常见图类型和关键属性。我们还介绍了流行的图算法，如搜索、划分和路径优化，以及它们的实际应用场景。
- en: A key idea presented here was the need for representation learning on graphs.
    Converting graph data into vector embeddings allows us to leverage the capabilities
    of machine learning models. Benefits such as scalability, flexibility, and robustness
    make graph embeddings an enabling technique.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提出的一个关键观点是图上表示学习的需求。将图数据转化为向量嵌入使我们能够利用机器学习模型的能力。诸如可扩展性、灵活性和鲁棒性等好处使得图嵌入成为一种促进技术。
- en: Finally, we justified the need for specialized GNN architectures. Factors such
    as irregular structure, permutation invariance, and complex operations such as
    aggregation and pooling necessitate tailored solutions. GNNs open up new possibilities
    for learning from relational data across domains.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们证明了专门化GNN架构的必要性。诸如不规则结构、排列不变性以及复杂操作如聚合和池化等因素都要求定制化的解决方案。GNNs为跨领域学习关系数据开辟了新的可能性。
- en: In the next chapter, we’ll discuss how graph learning is applied in practice.
    There are several levels to graph learning and representation, and all of them
    have business and academic significance. The topics covered here will act as a
    foundation for your understanding of the concepts in the chapters that follow.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论图学习如何在实际中应用。图学习和表示有多个层次，所有这些层次都有商业和学术意义。本章所涵盖的主题将作为你理解后续章节中概念的基础。
