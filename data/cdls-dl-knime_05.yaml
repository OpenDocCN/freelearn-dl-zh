- en: '*Chapter 4:* Building and Training a Feedforward Neural Network'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第四章：* 构建和训练前馈神经网络'
- en: 'In [*Chapter 3*](B16391_03_Final_PG_ePUB.xhtml#_idTextAnchor073), *Getting
    Started with Neural Networks*, you learned the basic theory behind neural networks
    and deep learning. This chapter sets that knowledge into practice. We will implement
    two very simple classification examples: a multiclass classification using the
    **iris flower** dataset, and a binary classification using the adult dataset,
    also known as the **census income** dataset.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第三章*](B16391_03_Final_PG_ePUB.xhtml#_idTextAnchor073)，*开始使用神经网络*，您学习了神经网络和深度学习背后的基本理论。本章将这些知识付诸实践。我们将实现两个非常简单的分类示例：使用**鸢尾花**数据集的多类别分类，以及使用成人数据集（也称为**人口普查收入**数据集）的二元分类。
- en: These two datasets are quite small and the corresponding classification solutions
    are also quite simple. A fully connected feedforward network will be sufficient
    in both examples. However, we decided to show them here as toy examples to describe
    all of the required steps to build, train, and apply a fully connected feedforward
    classification network with **KNIME Analytics Platform** and **KNIME Keras Integration**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个数据集都相当小，相应的分类解决方案也相当简单。在这两个示例中，完全连接的前馈网络就足够了。然而，我们决定在这里展示它们作为玩具示例，描述使用KNIME
    Analytics Platform和KNIME Keras Integration构建、训练和应用全连接前馈分类网络的所有必需步骤。
- en: These steps include commonly used preprocessing techniques, the design of the
    neural architecture, the setting of the activation functions, the training and
    application of the network, and lastly, the evaluation of the results.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤包括常用的预处理技术、神经网络架构的设计、激活函数的设置、网络的训练和应用，最后是结果的评估。
- en: 'Thus, this chapter covers the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章涵盖以下主要主题：
- en: Preparing the Data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备数据
- en: Building a Feedforward Neural Architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建前馈神经网络架构
- en: Training the Network
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练网络
- en: Testing and Applying the Network
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和应用网络
- en: Preparing the Data
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备数据
- en: In [*Chapter 3*](B16391_03_Final_PG_ePUB.xhtml#_idTextAnchor073), *Getting Started
    with Neural Networks*, we introduced the backpropagation algorithm, which is used
    by gradient descent algorithms to train a neural network. These algorithms work
    on numbers and can't handle nominal/categorical input features or class values.
    Therefore, nominal input features or nominal output values must be encoded into
    numerical values if we want the network to make use of them. In this section,
    we will show several numerical encoding techniques and the corresponding nodes
    in KNIME Analytics Platform to carry them out.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第三章*](B16391_03_Final_PG_ePUB.xhtml#_idTextAnchor073)，*开始使用神经网络*，我们介绍了反向传播算法，它被梯度下降算法用于训练神经网络。这些算法处理数字，无法处理名义/分类输入特征或类值。因此，如果我们希望网络利用它们，名义输入特征或名义输出值必须被编码为数字值。在本节中，我们将展示几种数值编码技术及其在KNIME
    Analytics Platform中相应的节点来执行它们。
- en: 'Besides that, we will also go through many other classic data preprocessing
    steps to feed machine learning algorithms: creating training, validation, and
    test sets from the original dataset; normalization; and missing value imputation.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们还将通过许多经典的数据预处理步骤来为机器学习算法提供数据：从原始数据集创建训练、验证和测试集；归一化；以及缺失值插补。
- en: 'Along the way, we will also show you how to import data, how to perform a few
    additional data operations, and some commonly used tricks within KNIME Analytics
    Platform. The workflows described in this chapter are available on the KNIME Hub:
    [https://hub.knime.com/kathrin/spaces/Codeless%20Deep%20Learning%20with%20KNIME/latest/Chapter%204/](https://hub.knime.com/kathrin/spaces/Codeless%20Deep%20Learning%20with%20KNIME/latest/Chapter%204/).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们还将向您展示如何导入数据，如何执行一些额外的数据操作，以及KNIME Analytics Platform中一些常用的技巧。本章描述的工作流程可以在KNIME
    Hub上找到：[https://hub.knime.com/kathrin/spaces/Codeless%20Deep%20Learning%20with%20KNIME/latest/Chapter%204/](https://hub.knime.com/kathrin/spaces/Codeless%20Deep%20Learning%20with%20KNIME/latest/Chapter%204/)。
- en: Datasets and Classification Examples
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据集和分类示例
- en: 'Before we dive into the different preprocessing steps, let''s have a quick
    look at the two selected datasets and the associated classification examples:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究不同的预处理步骤之前，让我们快速查看两个选定的数据集和相关的分类示例：
- en: Classification of three iris flowers based on the Iris dataset
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于鸢尾花数据集对三种鸢尾花进行分类
- en: Classification of income (binary class) based on the data from the adult dataset
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于成人数据集对收入进行分类（二元类别）
- en: Our first dataset gives us an example of a multiclass classification problem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个数据集为我们提供了一个多类分类问题的示例。
- en: 'The Iris dataset consists of examples of flowers from three species of iris
    plants: Iris-setosa, Iris-virginica, and Iris-versicolor. Each flower is described
    through four measures: sepal length (cm), sepal width (cm), petal length (cm),
    and petal width (cm). This is a small dataset with 50 examples for each species,
    with 150 samples in total. *Figure 4.1* shows an overview of the dataset.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 鸢尾花数据集包含来自三种鸢尾植物（Iris-setosa、Iris-virginica 和 Iris-versicolor）的花朵示例。每朵花通过四个特征进行描述：花萼长度（cm）、花萼宽度（cm）、花瓣长度（cm）和花瓣宽度（cm）。这是一个小型数据集，每个品种有50个示例，总共有150个样本。*图
    4.1*展示了数据集的概览。
- en: The goal is to train a neural network with one hidden layer (eight units and
    the ReLU activation function) to distinguish the three species from each other
    based on the four input features.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是训练一个具有一个隐藏层（八个单元和ReLU激活函数）的神经网络，根据四个输入特征来区分三种花卉。
- en: 'Part of the Iris dataset is displayed in the following tables:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 部分鸢尾花数据集显示在以下表格中：
- en: '![Figure 4.1 – Overview of the Iris dataset, used here to implement a multiclass
    classification](img/B16391_04_001.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 鸢尾花数据集概述，本文用于实现多类分类](img/B16391_04_001.jpg)'
- en: Figure 4.1 – Overview of the Iris dataset, used here to implement a multiclass
    classification
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 鸢尾花数据集概述，本文用于实现多类分类
- en: The second example dataset provides us with a binary classification problem.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例数据集为我们提供了一个二分类问题。
- en: 'The adult dataset consists of 32,561 samples of people living in the US. Each
    record describes a person through 14 demographics features, including their current
    annual income (> 50K/<= 50K). *Figure 4.2* shows an overview of the features in
    the dataset: numerical features, such as age and hours worked per week, and nominal
    features, such as work class and marital status.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 成人数据集包含32,561个住在美国的人的样本。每条记录通过14个人口统计特征描述一个人，其中包括其当前的年收入（> 50K/<= 50K）。*图 4.2*展示了数据集中特征的概览：数值特征，如年龄和每周工作小时数，以及名义特征，如工作类别和婚姻状况。
- en: The goal is to train a neural network to predict whether a person earns more
    or less than 50K per year, using all the other attributes as input features. The
    network we want to use should have two hidden layers, each one with eight units
    and the ReLU activation function.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是训练一个神经网络，预测一个人是否每年赚取超过50K美元，使用所有其他属性作为输入特征。我们希望使用的网络应该有两个隐藏层，每个层有八个单元，并采用ReLU激活函数。
- en: 'Some of the census income dataset displayed in tables looks as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一些显示在表格中的人口普查收入数据集如下所示：
- en: '![Figure 4.2 – Overview of the adult dataset, used here to implement a binary
    class classification](img/B16391_04_002.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 成人数据集概述，本文用于实现二分类问题](img/B16391_04_002.jpg)'
- en: Figure 4.2 – Overview of the adult dataset, used here to implement a binary
    class classification
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 成人数据集概述，本文用于实现二分类问题
- en: Tip
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: To get an overview of the dataset, you can use the **Data Explorer** node. This
    node displays some statistical measures of the input data within an interactive
    view. In *Figure 4.1* and *Figure 4.2*, you can see the view of the node for the
    two example datasets.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得数据集的概览，你可以使用**数据探索器**节点。此节点以交互式视图显示输入数据的一些统计量。在*图 4.1*和*图 4.2*中，你可以看到两个示例数据集的节点视图。
- en: To summarize the Iris dataset, it consists of four numerical features, plus
    the iris nominal class; the adult dataset consists of 14 mixed features, numerical
    and nominal. The first step in the data preparation would, therefore, be to transform
    all nominal features into numerical ones. Let's move on, then, to the encoding
    techniques.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 总结鸢尾花数据集，它包含四个数值特征和一个鸢尾花的名义类别；成人数据集则包含14个混合特征，包括数值特征和名义特征。因此，数据准备的第一步是将所有名义特征转换为数值特征。接下来，我们将介绍编码技术。
- en: Encoding of Nominal Features
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名义特征的编码
- en: Nominal features, sometimes also called categorical features, can assume only
    string-type values. For example, the only possible values for a feature describing
    hair color can be a string type, such as `black`, `brown`, `blond`, and `red`;
    a feature describing gender traditionally assumes only two string-type values,
    `female` and `male`; and the possible values for an education feature can be strings,
    such as `Doctorate`, `Masters`, `Bachelors`, or `Some-college`. This last example
    is taken from the column named `education` in the adult dataset. These values
    should be transformed into numbers before being fed to a neural network.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 名义特征，有时也称为类别特征，只能采用字符串类型的值。例如，描述发色的特征的唯一可能值可以是字符串类型，如`black`、`brown`、`blond`和`red`；描述性别的特征传统上只接受两种字符串类型的值，`female`和`male`；教育特征的可能值可以是字符串，如`Doctorate`、`Masters`、`Bachelors`或`Some-college`。这个例子来自成人数据集中名为`education`的列。这些值应在输入神经网络之前转换为数字。
- en: 'There are two common ways to encode nominal features:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种常见的方式来编码名义特征：
- en: '**Integer encoding**'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整数编码**'
- en: '**One-hot encoding**'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独热编码**'
- en: Integer encoding assigns an integer value to each possible nominal value of
    a feature. For example, `"black"` can be 1, `"brown"` can be 2, `"blond"` can
    be 3, and `"red"` can be 4\. We have chosen the numbers 1, 2, 3, and 4 but it
    could have been any other set of numbers. This approach introduces an artificial
    relationship between the different values – for example, that `"black"` is closer
    to `"brown"` than to `"red"`. This can reflect a true relationship across values
    in ordinal or hierarchical features, such as education, where `"Doctorate"` is
    closer to `"Masters"` than to `"Some-college"`. However, in other cases, such
    as the previously mentioned hair color one, it introduces a new additional relationship
    that does not reflect reality and can bias the model during learning. Generally
    speaking, using the integer encoding approach on nominal unordered features can
    lead to worse-performing models.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 整数编码为特征的每个可能的名义值分配一个整数值。例如，`"black"`可以是1，`"brown"`可以是2，`"blond"`可以是3，`"red"`可以是4。我们选择了数字1、2、3和4，但它也可以是任何其他数字组合。该方法在不同值之间引入了一种人工关系——例如，`"black"`比`"red"`更接近`"brown"`。这种关系可以反映有序或层次特征中的真实关系，例如教育领域，其中`"Doctorate"`比`"Masters"`更接近`"Some-college"`。然而，在其他情况下，例如之前提到的发色示例，它引入了一种不反映现实的新附加关系，并且可能在学习过程中对模型产生偏见。一般来说，在名义无序特征上使用整数编码方法可能会导致模型性能较差。
- en: One-hot vector encoding overcomes this problem by representing each feature
    with a vector, where the distance across all the vectors is always the same. The
    vector consists of the same quantity of binary components as possible values in
    the original feature. Each component is then associated with one of the values
    and is set to `1` for that value; the other components remain set to `0`. In the
    hair color example, `"black"` becomes ![](img/Formula_B16391_04_001.png), `"brown"`
    becomes ![](img/Formula_B16391_04_002.png), `"blond"` becomes ![](img/Formula_B16391_04_003.png),
    and `"red"` becomes ![](img/Formula_B16391_04_004.png).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 独热编码通过用向量表示每个特征来克服这个问题，在所有向量之间的距离始终相同。该向量由与原始特征中可能值相同数量的二进制组件组成。然后，将每个组件与其中一个值关联，并为该值设置为`1`；其他组件保持为`0`。在发色示例中，`"black"`变成
    ![](img/Formula_B16391_04_001.png)，`"brown"`变成 ![](img/Formula_B16391_04_002.png)，`"blond"`变成
    ![](img/Formula_B16391_04_003.png)，`"red"`变成 ![](img/Formula_B16391_04_004.png)。
- en: Important note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: A one-hot vector is a vector with a single `1` and all other values being `0`.
    It can be used to encode different classes without adding any artificial distance
    between them.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 独热向量是一个只有一个`1`，所有其他值为`0`的向量。它可以用来编码不同的类别，而不会在它们之间添加任何人工距离。
- en: Let's see now how to implement these encodings with KNIME nodes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何通过KNIME节点实现这些编码。
- en: Integer Encoding in KNIME Analytics Platform
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: KNIME Analytics Platform中的整数编码
- en: 'To perform integer encoding, you can use the **Category to Number** node. This
    node has one data input port (represented by a black triangle in the following
    diagram) and two output ports:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行整数编码，可以使用**Category to Number**节点。该节点有一个数据输入端口（在下图中由黑色三角形表示）和两个输出端口：
- en: A data output port (black triangle) with the integer-encoded data
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据输出端口（黑色三角形）与整数编码数据
- en: A PMML model output port (blue square) with the mapping rules
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PMML模型输出端口（蓝色方块）与映射规则
- en: '*Figure 4.3* shows you the node, as well as its configuration window:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4.3*显示了该节点及其配置窗口：'
- en: '![Figure 4.3 – The Category to Number node performs an integer encoding on
    the selected columns](img/B16391_04_003.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – **类别到数字**节点对选定的列执行整数编码](img/B16391_04_003.jpg)'
- en: Figure 4.3 – The Category to Number node performs an integer encoding on the
    selected columns
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – **类别到数字**节点对选定的列执行整数编码
- en: In the upper part of the configuration window, you can select the string-type
    input columns to apply the integer encoding to. The columns in the **Include**
    framework will be transformed, while the columns in the **Exclude** framework
    will be left unchanged. You can move columns from one framework to the other using
    the buttons between them.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置窗口的上半部分，您可以选择字符串类型的输入列，应用整数编码。**包含**框架中的列将会被转换，而**排除**框架中的列将保持不变。您可以通过框架之间的按钮将列从一个框架移动到另一个框架。
- en: By default, values in the original columns are replaced with the integer-encoded
    values. However, the **Append columns** checkbox creates additional columns for
    the integer-encoded values so as not to overwrite the original columns. If you
    activate this checkbox, you can also define a custom suffix for the new columns'
    headers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，原始列中的值会被整数编码值替换。然而，**附加列**复选框会为整数编码值创建额外的列，以免覆盖原始列。如果您启用此复选框，您还可以为新列的列头定义自定义后缀。
- en: 'In the lower part of the configuration window, you can define the encoding
    rule: the start value, the increment, the maximum allowed number of categories,
    and an integer value for all missing values.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置窗口的下半部分，您可以定义编码规则：起始值、增量、允许的最大类别数以及所有缺失值的整数值。
- en: The default integer value is transferred to the output PMML transformation model.
    **PMML** stands for **Predictive Model Markup Language** and is a way to describe
    and exchange predictive models between different applications. The PMML model
    at the blue square output port contains the mapping function built in this node
    and to be applied to other datasets. When applying this integer encoding PMML
    model, the default value is assigned to all input values not represented by the
    current mapping (if any). If no default value is present, a missing value will
    be used instead.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的整数值会被传输到输出PMML转换模型中。**PMML**代表**预测模型标记语言**，是一种描述和交换预测模型的方式，可以在不同应用程序之间进行交换。输出端口的蓝色方框中的PMML模型包含此节点中内置的映射函数，并将应用于其他数据集。在应用此整数编码PMML模型时，默认值会分配给所有当前映射（如果有）未表示的输入值。如果没有默认值，则会使用缺失值代替。
- en: Tip
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: To apply the same integer encoding mapping stored in the PMML output port to
    another dataset, you can use the **Category to Number (Apply)** node.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 若要将存储在PMML输出端口中的相同整数编码映射应用于另一个数据集，您可以使用**类别到数字（应用）**节点。
- en: 'The **Category to Number** node defines the mapping automatically. This means
    you cannot manually define which nominal value should be represented by which
    integer value. If you wish to do so, you have other options in KNIME Analytics
    Platform, and we will introduce two of them: the **Cell Replacer** node and the
    **Rule Engine** node.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**类别到数字**节点会自动定义映射。这意味着您无法手动定义哪个名义值应由哪个整数值表示。如果您希望手动定义，可以在KNIME Analytics平台中选择其他选项，我们将介绍其中两个：**单元格替换器**节点和**规则引擎**节点。'
- en: 'The **Cell Replacer** node replaces cell values in a column according to a
    dictionary table. It has two inputs:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元格替换器**节点根据字典表替换列中的单元格值。它有两个输入：'
- en: The top input for the table with the target column whose values are to be replaced
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换值的目标列所在表格的上输入
- en: The lower input for the dictionary table
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典表的下输入
- en: '*Figure 4.4* shows the configuration window of the Cell Replacer node:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.4*显示了单元格替换器节点的配置窗口：'
- en: '![Figure 4.4 – The Cell Replacer node implements an encoding mapping based
    on a dictionary](img/B16391_04_004.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 单元格替换器节点根据字典实现编码映射](img/B16391_04_004.jpg)'
- en: Figure 4.4 – The Cell Replacer node implements an encoding mapping based on
    a dictionary
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 单元格替换器节点根据字典实现编码映射
- en: In the upper part of the configuration window, you can select the target column
    from the input table at the top input port; this means the column whose values
    you want to replace based on the dictionary values.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置窗口的上半部分，您可以从顶部输入端口的输入表中选择目标列；即，您希望根据字典值替换其值的列。
- en: In the **Dictionary table** part of the configuration window, you can select,
    from the data table at the lower input port, the column with the lookup values
    – that is, the **Input (Lookup)** column – and the column containing the replacement
    values – that is, the **Output (Replacement)** column.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置窗口的 **字典表** 部分，您可以从底部输入端口的数据表中选择查找值列——即 **输入（查找）** 列——以及包含替换值的列——即 **输出（替换）**
    列。
- en: Any occurrence in the target column (first input) that matches the lookup value
    is replaced with the corresponding replacement value. The result is stored in
    the output column, which is either added to the table or replaces the original
    target column.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 目标列（第一个输入）中任何与查找值匹配的出现都将被相应的替换值替换。结果将存储在输出列中，该列要么被添加到表中，要么替换原始目标列。
- en: Missing values are treated as ordinary values; that is, they are valid values
    both as lookup and replacement values. If there are duplicates in the lookup column
    in the dictionary table, the last occurrence (lowest row) defines the replacement
    pair.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 缺失值被视为普通值；也就是说，它们既可以作为查找值，也可以作为替换值。如果字典表中的查找列存在重复项，则最后一次出现（最下面的行）定义替换对。
- en: For the integer encoding example, you need a dictionary table to map the nominal
    values and the integer values. For example, each education level should be mapped
    to a corresponding integer value. You can then feed the original dataset into
    the top input port and this map/dictionary table into the lowest input port.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于整数编码示例，您需要一个字典表来映射名义值和整数值。例如，每个教育水平应映射到一个对应的整数值。然后，您可以将原始数据集输入到顶部输入端口，将此映射/字典表输入到最底部的输入端口。
- en: Tip
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The **Table Creator** node can be helpful to manually create the lookup table.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**表创建器** 节点可以帮助手动创建查找表。'
- en: If you don't have a dictionary table and you don't want to create one, you can
    use the **Rule Engine** node.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有字典表且不想创建，可以使用 **规则引擎** 节点。
- en: The Rule Engine node transforms the values in the input columns according to
    a set of manually defined rules, which are defined in its configuration window.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 规则引擎节点根据一组手动定义的规则转换输入列中的值，这些规则在其配置窗口中定义。
- en: '*Figure 4.5* shows you the configuration window of the Rule Engine node:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.5* 显示了规则引擎节点的配置窗口：'
- en: '![Figure 4.5 – The Rule Engine node implements an integer encoding from user-defined
    rules](img/B16391_04_005.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 规则引擎节点实现来自用户定义规则的整数编码](img/B16391_04_005.jpg)'
- en: Figure 4.5 – The Rule Engine node implements an integer encoding from user-defined
    rules
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 规则引擎节点实现来自用户定义规则的整数编码
- en: 'In the `=>`, in the form of `"antecedent => consequence"`. The results are
    either inserted into a new column or replace the values in a selected column.
    For each data row in the input table, the rule-matching process moves from the
    top rule to the lowest: the first matching rule determines the outcome, and then
    the rule process stops. The last default condition, collecting all the remaining
    data rows, is expressed as `"TRUE => consequence"`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `=>` 中，以 `"前提 => 结果"` 的形式。结果要么插入到新列中，要么替换选定列中的值。对于输入表中的每一行数据，规则匹配过程从顶部规则开始，直到最后一行：第一个匹配的规则决定结果，然后规则过程停止。最后的默认条件，将所有剩余数据行汇总，表示为
    `"TRUE => 结果"`。
- en: The outcome of a rule may be a string (in between `"` or `/` symbols), a number,
    a Boolean constant, or a reference to another column. If no rule matches, the
    outcome is a missing value. References to other columns are represented by the
    column name in between `$`. You can insert a column reference by hand or by double-clicking
    on a column in **Column List** on the left side of the configuration window.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 规则的结果可以是一个字符串（用 `"` 或 `/` 符号括起来）、一个数字、一个布尔常量，或对另一个列的引用。如果没有规则匹配，则结果是缺失值。对其他列的引用通过
    `$` 包围列名表示。您可以手动插入列引用，或通过双击配置窗口左侧的 **列列表** 中的列来插入。
- en: Besides the **Expression** panel, you find the **Function**, **Column List**,
    and **Flow Variable List** panels. The **Function** panel lists all functions,
    the **Column List** panel lists all input columns, and **Flow Variable List**
    contains all the available flow variables. Double-clicking on any of them adds
    them to the **Expression** window with the right syntax. Also, selecting any of
    the functions shows a description as well as an example.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 **表达式** 面板，你还会看到 **函数**、**列列表** 和 **流变量列表** 面板。**函数** 面板列出了所有函数，**列列表** 面板列出了所有输入列，而
    **流变量列表** 面板则包含了所有可用的流变量。双击其中的任何一个，都会将它们以正确的语法添加到 **表达式** 窗口中。此外，选择任何一个函数时会显示该函数的描述以及示例。
- en: 'To summarize, there are many ways to implement integer encoding in KNIME Analytics
    Platform. We introduced three options:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，在 KNIME Analytics Platform 中有很多种实现整数编码的方法。我们介绍了三种选项：
- en: The **Category to Number** node offers an automatic, easy approach if you do
    not want to define the mapping by hand.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类别到数字**节点提供了一种自动且简单的方法，如果你不想手动定义映射的话。'
- en: The **Cell Replacer** node is really useful if you have a lookup table at hand.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元格替换器**节点如果你手头有查找表会非常有用。'
- en: The **Rule Engine** node is useful if you want to manually define the mapping
    between the nominal values and the integer values via a set of rules.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则引擎**节点在你想通过一组规则手动定义名义值与整数值之间的映射时非常有用。'
- en: Next, let's look at one-hot encoding in KNIME Analytics Platform.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下 KNIME Analytics Platform 中的独热编码。
- en: One-Hot-Encoding in KNIME Analytics Platform
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: KNIME Analytics Platform 中的独热编码
- en: 'To perform one-hot encoding on nominal features, there is the **One to Many**
    node. This node takes the list of nominal values available in a column, builds
    a vector with as many components, and produces the one-hot encoding of each value:
    one value to become many binary cells, hence the name.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要对名义特征执行独热编码，可以使用 **One to Many** 节点。该节点获取列中可用的名义值列表，构建一个包含相同数量分量的向量，并生成每个值的独热编码：一个值变成多个二进制单元格，因此得名。
- en: In the configuration window, you can select the string-type columns on which
    to perform the one-hot encoding. For each column, as many new columns will be
    created as there are different values. The header of each new column will be the
    original value in the nominal column and its cells take a value of either `0`
    or `1`, depending on the presence or absence of the header value in the original
    column.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置窗口中，你可以选择执行独热编码的字符串类型列。对于每一列，将根据不同的值创建相同数量的新列。每个新列的标题将是名义列中的原始值，其单元格的值为 `0`
    或 `1`，取决于原始列中是否存在该标题值。
- en: '*Figure 4.6* shows the configuration window of the node:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.6* 显示了该节点的配置窗口：'
- en: '![Figure 4.6 – The One to Many node implements the one-hot encoding for nominal
    features](img/B16391_04_006.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – One to Many 节点实现名义特征的独热编码](img/B16391_04_006.jpg)'
- en: Figure 4.6 – The One to Many node implements the one-hot encoding for nominal
    features
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – One to Many 节点实现名义特征的独热编码
- en: Creating one-hot encoded vectors leads to very large and very sparse data tables
    with many zeros. This can weigh on the workflow performance during execution.
    The Keras Learner node does accept large and sparse one-hot-encoded data tables.
    However, it also offers a very nice optional feature that avoids this whole step
    of explicitly creating the data table with the one-hot-encoded vectors. It can
    create the one-hot-encoded vectors internally from an integer-encoded version
    of the original column. In this way, the one-hot encoding representation of the
    data remains hidden within the **Keras Network Learner** node and is never passed
    from node to node. In this case, the value of each integer-encoded cell must be
    presented to the Keras Network Learner node as a collection type cell. To create
    a collection type cell, you can use the **Create Collection Column** node. In
    the *Training the Network* section of this chapter, you will see how to configure
    the Keras Network Learner node properly to make use of this feature.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 one-hot 编码向量会导致非常大且稀疏的数据表，充满了大量零值。这可能会在执行过程中影响工作流性能。Keras Learner 节点确实可以接受大且稀疏的
    one-hot 编码数据表。然而，它还提供了一个非常好的可选功能，避免了显式创建带有 one-hot 编码向量的数据表的整个步骤。它可以从原始列的整数编码版本内部创建
    one-hot 编码向量。这样，数据的 one-hot 编码表示会被隐藏在 **Keras Network Learner** 节点内部，并且永远不会从节点传递到节点。在这种情况下，每个整数编码单元的值必须以集合类型单元的形式传递给
    Keras Network Learner 节点。要创建集合类型单元，可以使用 **Create Collection Column** 节点。在本章的 *Training
    the Network* 部分，您将看到如何正确配置 Keras Network Learner 节点以利用此功能。
- en: '*Figure 4.7* shows the configuration window of the **Create Collection Column**
    node. In the **Exclude-Include** frame, you select one or more columns to aggregate
    in a collection-type column. In the lower part of the configuration window, you
    can decide whether to remove the original columns and define the new collection
    type column''s name:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.7* 显示了 **Create Collection Column** 节点的配置窗口。在 **Exclude-Include** 框中，您可以选择一个或多个列以将其聚合为集合类型列。在配置窗口的下部，您可以决定是否移除原始列，并定义新集合类型列的名称：'
- en: '![Figure 4.7 – The Create Collection Column node aggregates the values from
    multiple columns as a collection into one single column](img/B16391_04_007.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – **Create Collection Column** 节点将多个列的值作为集合聚合为单一列](img/B16391_04_007.jpg)'
- en: Figure 4.7 – The Create Collection Column node aggregates the values from multiple
    columns as a collection into one single column
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – **Create Collection Column** 节点将多个列的值作为集合聚合为单一列
- en: 'Notice that for this two-step one-hot encoding – first integer encoding, then
    one-hot encoding – you need to create the integer encoding column with one of
    the nodes listed in the previous section, and then apply the **Create Collection
    Column** node to just one column: the integer-encoded column that we have just
    created.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于这种两步 one-hot 编码——首先进行整数编码，然后进行 one-hot 编码——您需要使用前一节中列出的节点创建整数编码列，然后仅对一个列应用
    **Create Collection Column** 节点：我们刚刚创建的整数编码列。
- en: Encoding of Categorical Target Variables
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类别目标变量的编码
- en: In the last chapter, we talked about different activation functions and loss
    functions that can be used to build network architectures and train networks to
    solve classification problems. Of course, the activation function in the output
    layer and the loss function must match. Not only that, but the class encoding
    must also match the chosen activation and loss function. This means that not only
    must nominal input features be encoded, but class values too. The same encoding
    techniques and nodes, as described in this section, can be used for class encoding
    as well.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了可以用于构建网络架构并训练网络解决分类问题的不同激活函数和损失函数。当然，输出层的激活函数和损失函数必须匹配。不仅如此，类别编码还必须与所选的激活函数和损失函数匹配。这意味着，不仅名义型输入特征需要进行编码，类别值也需要进行编码。与本节中描述的相同的编码技术和节点，也可以用于类别编码。
- en: A common approach to binary classification is to encode the two classes with
    ![](img/Formula_B16391_04_005.png) and ![](img/Formula_B16391_04_006.png) and
    then to train the network to predict the probability for the ![](img/Formula_B16391_04_007.png)
    class. In this case, either the Category to Number node or the Rule Engine node
    can work.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 二分类的常见方法是使用 ![](img/Formula_B16391_04_005.png) 和 ![](img/Formula_B16391_04_006.png)
    对两个类别进行编码，然后训练网络预测 ![](img/Formula_B16391_04_007.png) 类别的概率。在这种情况下，**Category
    to Number** 节点或 **Rule Engine** 节点都可以使用。
- en: 'In the case of a multiclass problem, there are also two options to encode the
    class column: the **One to Many** node on its own or the Category to Number followed
    by the Create Collection Column node.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在多分类问题中，编码类别列也有两个选择：**一对多**节点本身，或者是类别到数字节点后接创建集合列节点。
- en: Another recommended preprocessing step for neural networks is normalization.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个推荐的神经网络预处理步骤是归一化。
- en: Normalization
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 归一化
- en: Most neural networks are trained using some variant of stochastic gradient descent
    with the backpropagation algorithm to calculate the gradient. Input features with
    non-comparable ranges can create problems during learning, as the input features
    with the largest range can overpower the calculation of the weight update, possibly
    even overshooting a local minimum. This can create oscillations and slow down
    the convergence of the learning process. To speed up the learning phase, it is
    recommended to normalize the data in advance; for example, by using the z-score
    normalization so that the values in each column are Gaussian-distributed with
    a mean of 0.0 and a standard deviation of 1.0.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数神经网络是使用带反向传播算法的随机梯度下降变体来训练的，以计算梯度。具有不可比拟范围的输入特征可能会在学习过程中造成问题，因为范围最大的输入特征可能会在计算权重更新时占据主导，甚至可能会越过局部最小值。这可能导致振荡并减慢学习过程的收敛速度。为了加速学习阶段，建议提前对数据进行归一化；例如，使用z-score归一化，使得每列中的值符合高斯分布，均值为0.0，标准差为1.0。
- en: 'In *Figure 4.8*, you can see the **Normalizer** node and its configuration
    window, as well as the **Normalizer (Apply)** node:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图4.8*中，您可以看到**Normalizer**节点及其配置窗口，以及**Normalizer（Apply）**节点：
- en: '![Figure 4.8 – The Normalizer node creates a normalization function for the
    selected input columns. The Normalizer (Apply) node applies the same normalization
    function to another dataset](img/B16391_04_008.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8 – Normalizer节点为选定的输入列创建归一化函数。Normalizer（Apply）节点将相同的归一化函数应用于另一个数据集](img/B16391_04_008.jpg)'
- en: Figure 4.8 – The Normalizer node creates a normalization function for the selected
    input columns. The Normalizer (Apply) node applies the same normalization function
    to another dataset
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 – Normalizer节点为选定的输入列创建归一化函数。Normalizer（Apply）节点将相同的归一化函数应用于另一个数据集
- en: The Normalizer node creates a normalization function on the selected input columns
    and normalizes them. The Normalizer (Apply) node takes an external predefined
    normalization function and applies it to the input data. A classic case for the
    application of this pair of nodes is on training and test sets. The Normalizer
    node normalizes the training data and the Normalizer (Apply) node applies the
    same normalization transformation to the test data.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Normalizer节点在选定的输入列上创建一个归一化函数并进行归一化处理。Normalizer（Apply）节点采用一个外部预定义的归一化函数并将其应用于输入数据。这个节点对的经典应用场景是在训练集和测试集上。Normalizer节点对训练数据进行归一化，而Normalizer（Apply）节点则对测试数据应用相同的归一化转换。
- en: 'The Normalizer node has one data input port and two output ports:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Normalizer节点有一个数据输入端口和两个输出端口：
- en: One data output port with the normalized input data
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数据输出端口，包含归一化后的输入数据
- en: One model output port containing the normalization parameters, which can be
    used on another dataset in a Normalizer (Apply) node
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个模型输出端口，包含归一化参数，可在Normalizer（Apply）节点中用于另一个数据集
- en: In the configuration window of the Normalizer node, you can select the numerical
    columns to normalize and the normalization method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在Normalizer节点的配置窗口中，您可以选择要归一化的数值列和归一化方法。
- en: The configuration window of the Normalizer (Apply) node is minimal since all
    of the necessary parameters are contained in the input normalization model.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Normalizer（Apply）节点的配置窗口非常简洁，因为所有必要的参数都包含在输入的归一化模型中。
- en: Tip
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: With a Partitioning node, you can create the training and test sets *before*
    normalizing the data.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Partitioning节点，您可以在归一化数据之前创建训练集和测试集。
- en: Other Helpful Preprocessing Nodes
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他有用的预处理节点
- en: Missing values can be a problem when training a neural network, as the backpropagation
    algorithm can't handle them. The placeholder value to represent missing values
    in a KNIME data table is a red question mark.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在训练神经网络时，缺失值可能会成为问题，因为反向传播算法无法处理它们。在KNIME数据表中，用来表示缺失值的占位符是一个红色的问号。
- en: A powerful node to impute missing values is the **Missing Value** node. This
    node allows you to select between many imputation methods, such as mean value,
    fixed value, and most frequent value, to name just a few.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个强大的节点来填补缺失值是**缺失值**节点。该节点允许你从多种填补方法中进行选择，比如均值、固定值和最常见值等。
- en: '*Figure 4.9* shows the two tabs of the configuration window of the node. In
    the first tab, the **Default** tab, you can select an imputation method to apply
    to all columns of the same type in the dataset; all columns besides those set
    in the second tab of the configuration, the **Column Settings** tab. In this second
    tab, you can define the imputation method for each individual column:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.9*展示了节点配置窗口的两个选项卡。在第一个选项卡，即**默认**选项卡中，你可以选择应用于数据集中所有同类型列的填补方法；所有除了在配置窗口第二个选项卡——**列设置**选项卡中设置的列。在第二个选项卡中，你可以为每个单独的列定义填补方法：'
- en: '![Figure 4.9 – The Missing Value node selects among many imputation methods
    for missing values](img/B16391_04_009.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9 – 缺失值节点从多种缺失值填补方法中进行选择](img/B16391_04_009.jpg)'
- en: Figure 4.9 – The Missing Value node selects among many imputation methods for
    missing values
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 缺失值节点从多种缺失值填补方法中进行选择
- en: Most neural networks are trained in a supervised way. Therefore, another necessary
    step is the creation of a training set and a test set, and optionally a validation
    set. To create different disjoint subsets, you can use the **Partitioning** node.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数神经网络都是以监督方式训练的。因此，另一个必要的步骤是创建训练集和测试集，及可选的验证集。为了创建不同的不相交子集，你可以使用**分区**节点。
- en: 'In the configuration window of the Partitioning node in *Figure 4.10*, you
    can set the size for the first partition, by either an absolute or a relative
    percentage number. Below that, you can set the sampling technique to create this
    first subset, by random extraction following the data distribution according to
    the categories in a selected column (stratified sampling), linearly every *n*
    data rows, or just sequentially starting from the top. The top output port produces
    the resulting partition; the lower output port produces all other remaining data
    rows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 4.10*的分区节点配置窗口中，你可以通过绝对值或相对百分比来设置第一个分区的大小。在下面，你可以设置采样技术来创建第一个子集，可以选择根据所选列中的类别按数据分布进行随机抽取（分层抽样）、每隔*n*行按线性方式抽取，或者从顶部按顺序抽取。上方的输出端口生成结果分区；下方的输出端口生成所有其他剩余的数据行：
- en: '![Figure 4.10 – The Partitioning node creates two disjoint subsets](img/B16391_04_010.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10 – 分区节点创建两个不相交的子集](img/B16391_04_010.jpg)'
- en: Figure 4.10 – The Partitioning node creates two disjoint subsets
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 分区节点创建两个不相交的子集
- en: For classification problems, the **Stratified sampling** option is recommended.
    It ensures that the distribution of the categories in the selected column is (approximately)
    retained in the two partitions. For time-series analysis, the **Take from top**
    option is preferable, if your data is sorted ascending by date. Samples further
    back in time will be in one partition and more recent samples in the other.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于分类问题，建议使用**分层抽样**选项。它确保所选列中的类别分布在两个分区中（大致）保持不变。对于时间序列分析，如果你的数据按日期升序排列，建议使用**从顶部提取**选项。较早的样本将进入一个分区，较新的样本进入另一个分区。
- en: To create an additional validation set, a sequence of two Partitioning nodes
    is needed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 若要创建额外的验证集，需要两个分区节点的顺序操作。
- en: We have talked about encoding for categorical features, normalization for numerical
    features, missing value imputation, and partitioning of the dataset. It is likely
    that those are not the only nodes you might need to prepare your data for the
    neural network.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了类别特征的编码、数值特征的标准化、缺失值填补和数据集的分区。很可能这些并不是你为神经网络准备数据时可能需要的唯一节点。
- en: Let's see how the data preparation works in practice, by implementing the data
    preparation part on the two example datasets we have described previously.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在前面提到的两个示例数据集上实现数据准备部分，来看数据准备在实际中是如何工作的。
- en: Data Preparation on the Iris Dataset
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 鸢尾花数据集的数据准备
- en: In *Figure 4.11*, you can see the part of the workflow dedicated to accessing
    and preparing the data for the upcoming neural network.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 4.11*中，你可以看到工作流中用于访问和准备即将用于神经网络的数据的部分。
- en: The workflow starts with reading the Iris dataset using the **Table Reader**
    node.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流从使用**表格读取器**节点读取鸢尾花数据集开始。
- en: Tip
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You can find the dataset in the data folder for this chapter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本章的数据文件夹中找到数据集。
- en: 'As the dataset has only numerical input features (petal and sepal measures),
    there is no need for encoding:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据集只有数值型输入特征（花瓣和萼片的度量），因此不需要进行编码：
- en: '![Figure 4.11 – This workflow snippet shows the preprocessing for the data
    in the iris dataset example](img/B16391_04_011.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图4.11 – 该工作流片段展示了Iris数据集示例中的数据预处理](img/B16391_04_011.jpg)'
- en: Figure 4.11 – This workflow snippet shows the preprocessing for the data in
    the iris dataset example
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 – 该工作流片段展示了Iris数据集示例中的数据预处理
- en: 'However, the target variable contains three different categories: the names
    of each flower species. The categories in this nominal column need to be converted
    into numbers via some encoding technique. To avoid the introduction of non-existent
    relationships, we opted for one-hot encoding. To implement the one-hot encoding,
    we chose the combination of integer encoding via nodes and one-hot encoding within
    the Keras Learner node. We will talk about the one-hot encoding internal to the
    Keras Learner node in the *Training the Network* section. Here, we will focus
    on the creation of an integer encoding of the flower classes inside a collection
    type column:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，目标变量包含三种不同的类别：每种花卉物种的名称。这个名义型列中的类别需要通过某些编码技术转换成数字。为了避免引入不存在的关系，我们选择了独热编码。为了实现独热编码，我们选择通过节点进行整数编码，并在Keras
    Learner节点中进行独热编码。我们将在*训练网络*部分讨论Keras Learner节点内部的独热编码。在这里，我们将重点介绍如何在集合类型列中创建花卉类别的整数编码：
- en: In order to transform the species names into an index, we use the `class` column.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将物种名称转化为索引，我们使用`class`列。
- en: Afterward, we pass the results from the Rule Engine node through a `class` column,
    and we exclude all other columns in the configuration window.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将规则引擎节点的结果通过一个`class`列传递，并在配置窗口中排除其他所有列。
- en: Next, the training and test sets are created with a **Partitioning** node, using
    75% of the data for training and the remaining 25% for testing.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用**分区**节点创建训练集和测试集，使用75%的数据进行训练，剩下的25%用于测试。
- en: Lastly, the data is normalized using the z-score normalization.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，数据通过z-score标准化进行规范化处理。
- en: The Iris dataset is quite small and quite well defined. Only a few nodes, the
    minimum required, were sufficient to implement the data preparation part.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Iris数据集非常小且定义清晰。只有几个节点，满足最小需求，足以实现数据准备部分。
- en: Let's see now what happens on a more complex (but still small) dataset, such
    as the adult dataset.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下在一个更复杂（但仍然较小）的数据集上会发生什么，例如成人数据集。
- en: Data Preparation on the Adult Dataset
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成人数据集的数据准备
- en: 'The workflow in *Figure 4.12* is part of the example on income prediction that
    reads and preprocesses the adult dataset:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4.12*中的工作流是关于收入预测示例的一部分，读取并预处理成人数据集：'
- en: '![Figure 4.12 – This workflow snippet shows the preprocessing for the data
    in the adult dataset example](img/B16391_04_012.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图4.12 – 该工作流片段展示了成人数据集示例中的数据预处理](img/B16391_04_012.jpg)'
- en: Figure 4.12 – This workflow snippet shows the preprocessing for the data in
    the adult dataset example
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12 – 该工作流片段展示了成人数据集示例中的数据预处理
- en: 'Like for the Iris dataset, you can find the two datasets used in the workflow
    in the data folder for this chapter: the adult dataset and a dictionary Excel
    sheet. In the adult dataset, education levels are spelled out as text. The dictionary
    Excel file provides a map between the education levels and the corresponding standard
    integer codes. We could use these integer codes as the numerical encoding of the
    education input feature.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 和Iris数据集一样，你可以在本章的数据文件夹中找到工作流中使用的两个数据集：成人数据集和字典Excel表格。在成人数据集中，教育水平以文本形式表示。字典Excel文件提供了教育水平与对应标准整数编码之间的映射。我们可以使用这些整数编码作为教育输入特征的数值编码。
- en: Next, the **Cell Replacer** node replaces all educational levels with the corresponding
    codes. We get one encoding practically without effort.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，**单元替换**节点将所有教育水平替换为相应的编码。我们几乎不费力就得到了一个编码。
- en: Some of the nominal columns have missing values. Inside the `"Missing"`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一些名义型列有缺失值。位于“Missing”中。
- en: 'Next, we proceed with the encoding of all other nominal features, besides education.
    For the following features, an integer encoding is used, implemented by the **Category
    to Number** node: marital status, race, and sex. We can afford to use the integer
    encoding here, because the features are either binary or with just a few categories.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们对所有其他名义特征（除了教育）进行编码。对于以下特征，使用整数编码，由**类别转数字**节点实现：婚姻状况、种族和性别。我们可以在这里使用整数编码，因为这些特征要么是二进制的，要么只有少数几个类别。
- en: For the remaining nominal features – work class, occupation, relationship, and
    native-country – one-hot encoding is used, implemented by the **One to Many**
    node. Remember that this node creates one new column for each value in each of
    the selected columns. So, after this transformation, the dataset has 82, instead
    of the original 14, features.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其余的名义特征——工作类别、职业、关系和本国——使用的是独热编码，由**一对多**节点实现。请记住，该节点为所选列中的每个值创建一个新列。因此，在此转换之后，数据集的特征数从原始的14个变为82个。
- en: Next, the training, validation, and test sets are created with a sequence of
    two `Income` class column.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用两列`Income`类创建训练集、验证集和测试集。
- en: Lastly, the `Income` column gets integer encoded on all subsets and all their
    data is normalized.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Income`列在所有子集上进行整数编码，且所有数据都被归一化。
- en: Tip
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: To hide complexity and to tidy up your workflows, you can create **metanodes**.
    Metanodes are depicted as gray nodes and contain sub-workflows of nodes. To create
    a metanode, select the nodes you want to hide, right-click, and select **Create
    Metanode**.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了隐藏复杂性并整理您的工作流程，您可以创建**元节点**。元节点以灰色节点表示，并包含子工作流节点。要创建元节点，请选择您要隐藏的节点，右键单击并选择**创建元节点**。
- en: Our data is ready. Let's now build the neural network.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据已准备好。现在让我们开始构建神经网络。
- en: Building a Feedforward Neural Architecture
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建前馈神经网络架构
- en: To build a neural network architecture using the KNIME Keras integration, you
    can use a chain of Keras layer nodes. The available nodes to construct layers
    are grouped by categories in the **Keras->Layers** folder in the **Node Repository**,
    such as **Advanced Activations**, **Convolution**, **Core**, **Embedding**, and
    **Recurrent**, to name just a few.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用KNIME Keras集成构建神经网络架构，您可以使用一系列Keras层节点。用于构建层的可用节点在**节点库**中的**Keras->Layers**文件夹中按类别分组，例如**高级激活**、**卷积**、**核心**、**嵌入**和**递归**等。
- en: Each layer displayed in the **Keras->Layers** folder has a specialty. For example,
    layers in **Advanced Activations** create layers with units with specific activation
    functions; layers in **Convolution** create layers for convolutional neural networks;
    **Core** contains all classic layers, such as the **Input** layer to collect the
    input values and the **Dense** layer for a fully connected feedforward neural
    network; and so on.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**Keras->Layers**文件夹中显示的每个层都有其特色。例如，**高级激活**中的层创建具有特定激活函数的单元层；**卷积**中的层创建用于卷积神经网络的层；**核心**包含所有经典层，如用于收集输入值的**输入**层和用于全连接前馈神经网络的**密集**层；等等。'
- en: We will explore many of these layers along the way in this book. However, in
    this current chapter, we will limit ourselves to the basic layers needed in a
    fully connected feedforward neural network.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中沿途探索这些层中的许多内容。然而，在本章中，我们将仅限于构建一个全连接前馈神经网络所需的基础层。
- en: The first layer in any network is the layer that receives the input values.
    Let's start from the Keras Input Layer node.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中的第一层是接收输入值的层。让我们从Keras输入层节点开始。
- en: The Keras Input Layer Node
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Keras 输入层节点
- en: Building a neural network always starts with defining the input layer of the
    network. The **Keras Input Layer** node can help you with this task. Indeed, this
    node builds the required inputs for the network to accept the input values.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 构建神经网络总是从定义网络的输入层开始的。**Keras 输入层**节点可以帮助您完成这一任务。实际上，这个节点构建了网络所需的输入，以便接受输入值。
- en: 'On the left of *Figure 4.13*, you can see the Keras Input Layer node and on
    the right its configuration window. As you can see, the node does not have an
    input port, just one output port of a different shape and color (red square) from
    the nodes encountered so far: this is the **Keras Network Port**:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 4.13*的左侧，您可以看到Keras输入层节点，右侧是其配置窗口。如您所见，该节点没有输入端口，只有一个输出端口，其形状和颜色（红色方块）与之前遇到的节点不同：这就是**Keras
    网络端口**：
- en: '![Figure 4.13 – The Keras Input Layer node defines the input layer of your
    neural network](img/B16391_04_013.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.13 – Keras输入层节点定义了神经网络的输入层](img/B16391_04_013.jpg)'
- en: Figure 4.13 – The Keras Input Layer node defines the input layer of your neural
    network
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – Keras输入层节点定义了神经网络的输入层
- en: Tip
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The color and shape of a port indicate which ports can be connected with each
    other. Most of the time, only ports of the same color and shape can be connected,
    but there are exceptions. For example, you can connect a gray square, which is
    a Python DL port, with a Keras port, a red square.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 端口的颜色和形状表示哪些端口可以互相连接。通常情况下，只有相同颜色和形状的端口才能连接，但也有例外。例如，你可以将一个灰色方块（Python DL端口）与一个Keras端口（红色方块）连接。
- en: Each layer node has a configuration window, with the setting options required
    for this specific layer. Compared to other layer nodes, this node has a simple
    configuration window with only a few setting options.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 每个层节点都有一个配置窗口，其中包含该特定层所需的设置选项。与其他层节点相比，这个节点的配置窗口较为简单，只有少数设置选项。
- en: The most important setting is **Shape**. **Shape** allows you to define the
    input shape of your network, meaning how many neurons your input layer has. Remember,
    the number of neurons in the input layer has to match the number of your preprocessed
    input columns.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的设置是**形状**。**形状**允许你定义网络的输入形状，意味着输入层有多少个神经元。记住，输入层的神经元数量必须与预处理过的输入列的数量匹配。
- en: 'The Iris dataset has four features that we will use as inputs: sepal length,
    sepal width, petal length, and petal width. Therefore, the input shape here is
    4.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Iris 数据集有四个特征，我们将作为输入使用：花萼长度、花萼宽度、花瓣长度和花瓣宽度。因此，这里的输入形状是4。
- en: 'In addition, in the configuration window of the Keras Input Layer node, you
    can set the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在Keras输入层节点的配置窗口中，你还可以设置以下内容：
- en: A **Name prefix** for the layer, so it is easier to identify it later on (optional).
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层名称前缀**，便于以后识别（可选）。'
- en: A **Batch size** (optional). Remember, the batch size is one of the setting
    options for the training. The recommended way is to define the batch size in the
    learner and executor node. In addition, you have the option to define it here.
    If a batch size is defined, then the batch size option in the learner and executor
    nodes are not available.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**批量大小**（可选）。请记住，批量大小是训练设置选项之一。推荐的方式是在学习器节点和执行器节点中定义批量大小。此外，你也可以选择在这里定义它。如果定义了批量大小，那么学习器和执行器节点中的批量大小选项将不可用。'
- en: The **Data type** and **Data format** of the input.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入的**数据类型**和**数据格式**。
- en: Your network now has its first layer, the input layer. Now, you can continue
    to build your network by creating and connecting the next layer node to the output
    of the Keras Input Layer node – for example, a **Keras Dense Layer** node.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你的网络现在已经有了第一个层——输入层。现在，你可以通过创建并将下一个层节点连接到Keras输入层节点的输出，继续构建你的网络——例如，**Keras密集层**节点。
- en: Tip
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: To create a node and immediately connect it to an existing node, select the
    existing node in the workflow editor and double-click the new node in the Node
    Repository. This will create the new node and connect it automatically to the
    selected existing node.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 若要创建一个节点并立即将其连接到现有节点，请在工作流编辑器中选择现有节点，并双击节点库中的新节点。这将创建新节点并自动将其连接到所选的现有节点。
- en: The Keras Dense Layer Node
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Keras密集层节点
- en: The **Keras Dense Layer** node implements a classic layer in a feedforward fully
    connected network. The parameters to set here are the number of neural units and
    the activation function.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**Keras密集层**节点实现了一个经典的前馈全连接网络层。此处需要设置的参数是神经单元的数量和激活函数。'
- en: '*Figure 4.14* shows the configuration window of this node. The setting options
    are split into two tabs: **Options** and **Advanced**.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.14* 显示了此节点的配置窗口。设置选项分为两个标签：**选项**和**高级**。'
- en: The **Options** tab contains the most important settings, such as the number
    of neurons, also known as units, and the activation function.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**选项**标签包含最重要的设置，如神经元的数量，也称为单元，以及激活函数。'
- en: In addition, the **Input tensor** setting defines the part of the input tensor
    coming from the previous node. In a feedforward network, the input tensor is the
    output tensor from the previous layer. However, some layer nodes – such as, for
    example, the **Keras LSTM Layer** node – create not just one hidden output tensor,
    but multiple. In such cases, you must select one among the different input tensors,
    or hidden states, produced by the previous layer node. Keras Input Layer, like
    Keras Dense Layer, produces only one output vector and this is what we select
    as input tensor to our Keras Dense Layer node.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，**输入张量**设置定义了来自前一个节点的输入张量部分。在前馈网络中，输入张量是前一层的输出张量。然而，一些层节点——例如，**Keras LSTM
    Layer** 节点——不仅创建一个隐藏的输出张量，而是多个。在这种情况下，您必须从前一层节点产生的不同输入张量或隐藏状态中选择一个。Keras 输入层与
    Keras Dense Layer 一样，只产生一个输出向量，这就是我们选择作为输入张量传递给 Keras Dense Layer 节点的内容。
- en: In the upper part of the **Advanced** tab, you can select how to randomly initialize
    the weights and biases of the network; this means the starting values for all
    weights and biases before the first iteration of the learning process.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在**高级**选项卡的上半部分，您可以选择如何随机初始化网络的权重和偏置；这意味着在学习过程的第一次迭代之前，所有权重和偏置的初始值。
- en: The lower part of the **Advanced** tab allows you to add norm regularization
    for the weights in this layer. Norm regularization is a technique to avoid overfitting,
    which we introduced in [*Chapter 3*](B16391_03_Final_PG_ePUB.xhtml#_idTextAnchor073),
    *Getting Started with Neural Networks*. In the configuration window, you can select
    whether to apply it to the kernel weight matrix, the bias vector, and/or the layer
    activation. After activating the corresponding checkbox, you can select between
    using the L1 norm as a penalty term, the L2 norm as a penalty term, or both. Lastly,
    you can set the value for the regularization parameter, ![](img/Formula_B16391_04_008.png),
    for the penalty terms and constraints on the weight and bias values.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**高级**选项卡的下半部分允许您为该层的权重添加范数正则化。范数正则化是一种避免过拟合的技术，我们在[*第 3 章*](B16391_03_Final_PG_ePUB.xhtml#_idTextAnchor073)《神经网络入门》中介绍过。在配置窗口中，您可以选择是否将其应用于核权重矩阵、偏置向量和/或层激活。激活相应的复选框后，您可以选择使用
    L1 范数作为惩罚项、L2 范数作为惩罚项，或两者都使用。最后，您可以为正则化参数设置值，![](img/Formula_B16391_04_008.png)，用于惩罚项和权重、偏置值的约束。'
- en: 'By using the **Keras Input Layer** node and multiple Keras Dense Layer nodes,
    you can build a feedforward network for many different tasks, such as, for example,
    to classify iris flowers:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用**Keras 输入层**节点和多个 Keras Dense Layer 节点，您可以为许多不同的任务构建一个前馈网络，例如，用于分类鸢尾花：
- en: '![Figure 4.14 – The Keras Dense Layer node allows you to add a fully connected
    layer to your neural network, including a selection of commonly used activation
    functions](img/B16391_04_014.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.14 – Keras Dense Layer 节点允许您向神经网络添加一个全连接层，包括选择常用的激活函数](img/B16391_04_014.jpg)'
- en: Figure 4.14 – The Keras Dense Layer node allows you to add a fully connected
    layer to your neural network, including a selection of commonly used activation
    functions
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – Keras Dense Layer 节点允许您向神经网络添加一个全连接层，包括选择常用的激活函数。
- en: Configuration of the other layer nodes is similar to what was described here
    for the dense and input layers, and you will learn more about them in the next
    chapters.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 其他层节点的配置与此处描述的密集层和输入层类似，您将在接下来的章节中学习更多内容。
- en: Since both basic examples used in this chapter refer to feedforward networks,
    we now have all of the necessary pieces to build both feedforward neural networks.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章中使用的两个基本示例都涉及前馈网络，我们现在已经具备了构建这两种前馈神经网络的所有必要部分。
- en: Building a Neural Network for Iris Flower Classification
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建用于鸢尾花分类的神经网络。
- en: 'For the multiclass classification problem using the Iris dataset, the goal
    was to build a fully connected feedforward neural network with three layers:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用鸢尾花数据集的多类分类问题，目标是构建一个具有三层的全连接前馈神经网络：
- en: One input layer with four units, one for each input feature
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个输入层，包含四个单元，每个输入特征一个。
- en: One hidden layer with eight units and the ReLU activation function
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含八个单元并使用 ReLU 激活函数的隐藏层。
- en: One output layer with three units, one for each output class, meaning one for
    each iris species, with the softmax activation function
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个输出层，包含三个单元，每个输出类一个，意味着每个鸢尾花品种一个，使用 softmax 激活函数。
- en: We opted for the ReLU activation function in the hidden layer for its better
    performance when used in hidden layers, and for the softmax activation function
    in the output layer for its probabilistic interpretability. The output unit with
    the highest output from the softmax function is the unit with the highest class
    probability.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择在隐藏层使用 ReLU 激活函数，因为它在隐藏层中的表现更好，而在输出层使用 softmax 激活函数，具有较好的概率解释性。softmax 函数输出中最大值对应的单元是具有最高类别概率的单元。
- en: '*Figure 4.15* shows the neural network architecture used for the iris classification
    problem:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.15* 展示了用于鸢尾花分类问题的神经网络架构：'
- en: '![Figure 4.15 – A diagram of the feedforward network used for the iris flower
    example](img/B16391_04_015.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.15 – 用于鸢尾花示例的前馈网络示意图](img/B16391_04_015.jpg)'
- en: Figure 4.15 – A diagram of the feedforward network used for the iris flower
    example
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – 用于鸢尾花示例的前馈网络示意图。
- en: '*Figure 4.16* shows the workflow snippet with the three layer nodes building
    the network and their configuration windows, including the number of units and
    activation functions:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.16* 展示了带有三个层节点并构建网络的工作流片段，以及它们的配置窗口，包括单元数量和激活函数：'
- en: '![Figure 4.16 – This workflow snippet builds the neural network in Figure 4.15
    for the Iris dataset example. The configuration windows below them show you the
    nodes'' configurations](img/B16391_04_016.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.16 – 该工作流片段构建了图 4.15 中用于鸢尾花数据集示例的神经网络。下方的配置窗口显示了各节点的配置。](img/B16391_04_016.jpg)'
- en: Figure 4.16 – This workflow snippet builds the neural network in Figure 4.15
    for the Iris dataset example. The configuration windows below them show you the
    nodes' configurations
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 – 该工作流片段构建了图 4.15 中用于鸢尾花数据集示例的神经网络。下方的配置窗口显示了各节点的配置。
- en: The input layer has four input units, `Shape = 4`, for the four numerical input
    features. The first Keras Dense Layer node, which is the hidden layer, has eight
    units and uses the ReLU activation function. In the output layer, the softmax
    activation function is used with three units, one unit for each class.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 输入层有四个输入单元，`Shape = 4`，对应四个数值输入特征。第一个 Keras Dense Layer 节点是隐藏层，包含八个单元，并使用 ReLU
    激活函数。在输出层，使用 softmax 激活函数，包含三个单元，每个类对应一个单元。
- en: Tip
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: In the last layer, the name prefix **Output** has been used. This makes it easier
    to identify the layer in the **Executor** node and has the advantage that the
    layer name doesn't change if more Keras Dense Layer nodes are added as hidden
    layers.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一层，使用了“**Output**”作为名称前缀。这使得在 **Executor** 节点中更容易识别该层，并且如果添加更多 Keras Dense
    Layer 节点作为隐藏层时，该层名称不会改变。
- en: Building a Neural Network for Income Prediction
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个用于收入预测的神经网络
- en: 'The second proposed example was a binary classification problem: predicting
    income (greater or lower than 50K per year) in the adult dataset. Here, we adopted
    a neural network with two hidden layers, with four layers in total:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例是一个二分类问题：预测收入（每年是否大于 50K）在成人数据集中的情况。在这里，我们采用了一个包含两个隐藏层的神经网络，总共四层：
- en: One input layer with 81 units, as many as input features
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个输入层，包含 81 个单元，与输入特征数量相同。
- en: One hidden layer with six units and the ReLU activation function
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个隐藏层，包含六个单元，并使用 ReLU 激活函数。
- en: One more hidden layer with six units and the ReLU activation function
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个隐藏层，包含六个单元，并使用 ReLU 激活函数。
- en: One output layer with one unit and the sigmoid activation function
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个输出层，包含一个单元，并使用 sigmoid 激活函数。
- en: 'The output layer uses a classic implementation for the binary classification
    problem: one single unit with the sigmoid activation function. The sigmoid function,
    spanning a range of 0 and 1, can easily implement class attribution using `0`
    for one class and `1` for the other. Thus, for a binary classification problem,
    where the two classes are encoded as `0` and `1`, one sigmoid function alone can
    produce the probability for the class encoded as `1`.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 输出层使用经典的二分类实现：一个单一的单元，采用 sigmoid 激活函数。sigmoid 函数的输出范围是 0 和 1，可以通过 `0` 表示一个类，`1`
    表示另一个类。因此，对于一个二分类问题，其中两个类分别编码为 `0` 和 `1`，仅使用一个 sigmoid 函数就可以生成类为 `1` 的概率。
- en: '*Figure 4.17* shows you the workflow snippet that builds this fully connected
    feedforward neural network:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.17* 向你展示了构建该全连接前馈神经网络的工作流片段：'
- en: '![Figure 4.17 – This workflow snippet builds the fully connected feedforward
    neural network used as a solution for the adult dataset example](img/B16391_04_017.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.17 – 该工作流片段构建了用于成人数据集示例的全连接前馈神经网络](img/B16391_04_017.jpg)'
- en: Figure 4.17 – This workflow snippet builds the fully connected feedforward neural
    network used as a solution for the adult dataset example
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 – 这个工作流片段构建了一个完全连接的前馈神经网络，用作成人数据集示例的解决方案。
- en: After preprocessing, the adult dataset ends up having 82 columns, 81 input features,
    and the target column. Therefore, the input layer has `Shape = 81`. Next, the
    two hidden layers are built using two Keras Dense Layer nodes with `Units = 6`
    and the ReLU activation function. The output layer consists of a Keras Dense Layer
    node, again with `Units = 1` and the sigmoid activation function.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 经过预处理后，成人数据集包含 82 列，其中 81 列为输入特征，1 列为目标列。因此，输入层的`形状 = 81`。接下来，使用两个 Keras Dense
    Layer 节点构建了两个隐藏层，`单元 = 6`，并使用 ReLU 激活函数。输出层由一个 Keras Dense Layer 节点组成，`单元 = 1`，并使用
    sigmoid 激活函数。
- en: In this section, you've learned how to build a feedforward neural network using
    the KNIME Keras integration nodes. The next step is to set the other required
    parameters for the network training, such as, for example, the loss function,
    and then to train the network.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您已经学习了如何使用 KNIME Keras 集成节点构建前馈神经网络。下一步是设置网络训练所需的其他参数，例如损失函数，然后开始训练网络。
- en: Training the Network
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练网络
- en: We have the data ready and we have the network. The goal of this section is
    to show you how to train the network with the data in the training set. This requires
    the selection of the loss function, the setting of the training parameters, the
    specification of the training set and the validation set, and the tracking of
    the training progress.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了数据，也有了网络。本节的目标是向您展示如何使用训练集中的数据来训练网络。这需要选择损失函数、设置训练参数、指定训练集和验证集，并跟踪训练进度。
- en: 'The key node for network training and for all these training settings is the
    **Keras Network Learner** node. This is a really powerful, really flexible node,
    with many possible settings, distributed over four tabs: **Input Data**, **Target
    Data**, **Options**, and **Advanced Options**.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 网络训练和所有这些训练设置的关键节点是 **Keras 网络学习器** 节点。这个节点非常强大且灵活，具有许多可能的设置，分布在四个标签页中：**输入数据**、**目标数据**、**选项**和
    **高级选项**。
- en: 'The Keras Network Learner node has three input ports:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Keras 网络学习器节点有三个输入端口：
- en: '**Top port**: The neural network you want to train'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶部端口**：您想要训练的神经网络'
- en: '**Middle port**: The training set'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间端口**：训练集'
- en: '**Lowest port**: The optional validation set'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最底端口**：可选的验证集'
- en: It has one output port, exporting the trained network.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个输出端口，用于导出训练好的网络。
- en: In addition, the node has the **Learning Monitor** view, which you can use to
    monitor the network training progress.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，节点还具有 **学习监控器** 视图，您可以使用它来监控网络的训练进度。
- en: Let's find out first how to select the loss function before we continue with
    the training parameters.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续设置训练参数之前，让我们先了解如何选择损失函数。
- en: Selecting the Loss Function
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择损失函数
- en: 'In [*Chapter 3*](B16391_03_Final_PG_ePUB.xhtml#_idTextAnchor073), *Getting
    Started with Neural Networks*, we introduced many loss functions, each one suitable
    for a specific task, as the last design choice for your network. For example,
    mean squared error is commonly used in regression problems or categorical cross-entropy
    in multiclass classification problems. In the lower part of the **Target Data**
    tab, you can either select between different standard prepackaged loss functions
    or define your own custom loss function using Python (see *Figure 4.18*):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 3 章*](B16391_03_Final_PG_ePUB.xhtml#_idTextAnchor073)《神经网络入门》中，我们介绍了许多损失函数，每个损失函数适用于特定任务，作为网络设计的最后选择。例如，均方误差通常用于回归问题，或者在多类分类问题中使用分类交叉熵。在
    **目标数据** 标签页的下方，您可以选择不同的标准预打包损失函数，或者使用 Python 定义自定义损失函数（见*图 4.18*）：
- en: '![Figure 4.18 – In the Target Data tab of the Keras Network Learner node, you
    can select the target columns and the loss function](img/B16391_04_018.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.18 – 在 Keras 网络学习器节点的“目标数据”标签页中，您可以选择目标列和损失函数](img/B16391_04_018.jpg)'
- en: Figure 4.18 – In the Target Data tab of the Keras Network Learner node, you
    can select the target columns and the loss function
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18 – 在 Keras 网络学习器节点的“目标数据”标签页中，您可以选择目标列和损失函数。
- en: Now that the network structure is defined and you have selected the correct
    loss function, the next step is to define which columns of the input dataset are
    the inputs for your network and which column contains the target values.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在网络结构已定义，并且你已选择正确的损失函数，下一步是定义输入数据集中哪些列是网络的输入，哪些列包含目标值。
- en: Defining the Input and Output Data
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义输入和输出数据
- en: Defining the input and output columns is something you can do in the **Input
    Data** and **Target Data** tabs. Let's focus first on the input data.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 定义输入列和输出列是你可以在**输入数据**和**目标数据**选项卡中完成的操作。让我们首先关注输入数据。
- en: 'The input data is the data that your network expects as input, which means
    the columns that fit the input size of the network. In the **Input Data** tab,
    the number of input neurons for the selected network and the consequent shape
    are reported at the very top:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数据是网络期望的输入数据，这意味着适合网络输入大小的列。在**输入数据**选项卡中，所选网络的输入神经元数及相应形状会显示在顶部：
- en: '![Figure 4.19 – In the Input Data tab of the Keras Network Learner node, you
    can'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.19 – 在 Keras 网络学习节点的输入数据选项卡中，你可以'
- en: select the input column(s) and the correct conversion](img/B16391_04_019.jpg)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 选择输入列和正确的转换](img/B16391_04_019.jpg)
- en: Figure 4.19 – In the Input Data tab of the Keras Network Learner node, you can
    select the input column(s) and the correct conversion
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.19 – 在 Keras 网络学习节点的输入数据选项卡中，你可以选择输入列和正确的转换
- en: 'Next, you must select the conversion type; this means the transformation for
    the selected input columns into a format that is accepted by the network input
    specification. The possible conversion types are as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你必须选择转换类型；这意味着将所选输入列转换为网络输入规范所接受的格式。可能的转换类型如下：
- en: '**From Collection of Number (integer) to One-Hot Tensor**'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从数字集合（整数）到独热张量**'
- en: '**From Number (double)**'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从数字（双精度浮点）**'
- en: '**From Number (integer)**'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从数字（整数）**'
- en: '**From Collection of Number (double)**'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从数字集合（双精度浮点）**'
- en: '**From Collection of Number (integer)**'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从数字集合（整数）**'
- en: '**From Image**'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从图像**'
- en: Conversion type 1, **From Collection of Numbers (integer) to One-Hot Tensor**,
    is a really helpful transformation when the network requires one-hot vectors.
    Instead of creating a matrix with all the one-hot vectors, which takes up space
    and resources, you can input a sequence of integer-encoded values and then transform
    them, one by one, into one-hot vectors. During execution, the node creates the
    one-hot vectors and inputs them into the network. The whole process is hidden
    from the end user and no additional large, sparse data tables are created.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 转换类型1，**从数字集合（整数）到独热张量**，是当网络需要独热向量时非常有用的转换方式。与其创建一个包含所有独热向量的矩阵（这会占用空间和资源），不如输入一系列整数编码的值，然后逐一将它们转换为独热向量。在执行过程中，节点创建独热向量并将其输入到网络中。整个过程对最终用户是透明的，并且不会创建额外的庞大稀疏数据表。
- en: The other conversion types just take the input columns in the specified format
    (double, integer, or image) and present them to the network.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 其他转换类型仅接受指定格式（双精度浮点、整数或图像）的输入列，并将其呈现给网络。
- en: After selecting the conversion type, you can select the input columns to the
    network through an include-exclude frame. Notice that the frame has been pre-loaded
    with all the input columns matching the selected conversion type.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 选择转换类型后，你可以通过包含-排除框选择输入列到网络。请注意，该框已预加载所有与所选转换类型匹配的输入列。
- en: Let's now select the target column. The target data must match the specifications
    from the output layer. This means that, if your output layer has 20 units, your
    target data must be 20-dimensional vectors; or, if your output layer has only
    one unit, your target data must also consist of one single value for each training
    sample or data row.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们选择目标列。目标数据必须符合输出层的规范。这意味着，如果输出层有20个单元，则目标数据必须是20维的向量；或者，如果输出层只有一个单元，则目标数据必须包含每个训练样本或数据行的一个单一值。
- en: In the **Target Data** tab, at the very top, the number of neurons in the output
    layer of the network and the resulting shape is reported. Like in the **Input
    Data** tab, here you can select from many conversion options to translate from
    the input dataset into the network specifications. The menu, with all the available
    conversion types to select from, has been preloaded with the conversion types
    that fit the specifications of the output layer of the network.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在**目标数据**标签中，最上方显示的是网络输出层中神经元的数量和结果形状。与**输入数据**标签中的操作类似，在这里你可以选择多种转换选项，将输入数据集转换为网络规格。菜单中预先加载了适合网络输出层规格的所有转换类型供你选择。
- en: For multiclass classification problems, the conversion type from a collection
    of numbers (integer) to one-hot tensor is really helpful. Instead of creating
    the one-hot vectors in advance, you need only to encode the position of the class
    (1) in the input collection cell.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多类分类问题，将一组数字（整数）转换为 one-hot 张量的方式非常有用。你不需要提前创建 one-hot 向量，只需编码输入集合单元中类别的位置（1）即可。
- en: Let's move on to the training parameters.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论训练参数。
- en: Setting the Training Parameters
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置训练参数
- en: Now that the network and the loss function have been defined, the next step
    is to set the training parameters. For example, which optimizer do you want to
    use? How many epochs do you want to train for? There are many parameters to be
    defined.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在网络和损失函数已经定义，下一步是设置训练参数。例如，你想使用哪种优化器？你希望训练多少个纪元？有很多参数需要定义。
- en: 'All the training parameters can be found in the **Options** and **Advanced
    Options** tabs. In *Figure 4.20*, you can see the **Options** tab of the **Keras
    Network Learner** node:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 所有训练参数可以在**选项**和**高级选项**标签中找到。在*图 4.20*中，你可以看到**Keras 网络学习器**节点的**选项**标签：
- en: '![Figure 4.20 – In the Options tab of the Keras Network Learner node, you can
    set all the training parameters](img/B16391_04_020.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.20 – 在 Keras 网络学习器节点的“选项”标签中，你可以设置所有的训练参数](img/B16391_04_020.jpg)'
- en: Figure 4.20 – In the Options tab of the Keras Network Learner node, you can
    set all the training parameters
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.20 – 在 Keras 网络学习器节点的“选项”标签中，你可以设置所有的训练参数。
- en: In the upper part of the **Options** tab, in the configuration window, you can
    define the number of epochs and the batch size. This determines the number of
    data rows from the training and validation sets to feed the network in batches
    within each training iteration.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在**选项**标签的上部，在配置窗口中，你可以定义纪元数和批次大小。这决定了在每次训练迭代中，从训练集和验证集中按批次喂入网络的数据行数。
- en: Important note
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you defined a batch size in the Keras Input Layer node, the batch size settings
    are deactivated.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 Keras 输入层节点中定义了批次大小，则批次大小设置将被禁用。
- en: Under that, there are two checkboxes. One shuffles the training data randomly
    before each epoch, and one sets a random seed. Shuffling the training data often
    improves the learning process. Indeed, updating the network with the same batches
    in the same order in each epoch can have a detrimental effect on the convergence
    speed of the training. If the shuffling checkbox is selected, the random seed
    checkbox becomes active and the displayed number is used to generate the random
    sequence for the shuffling operation. The usage of a random seed produces a repeatable
    random shuffling procedure and therefore allows us to repeat the results of a
    specific training run. Clicking the **New seed** button generates a new random
    seed and a new random shuffling procedure. Disabling the checkbox for the random
    seed creates a new seed for each node execution.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面，有两个复选框。一个是在每个纪元之前随机打乱训练数据，另一个是设置随机种子。随机打乱训练数据通常有助于提高学习过程。实际上，使用相同的批次和相同的顺序更新网络可能会对训练的收敛速度产生不利影响。如果选中打乱数据的复选框，则随机种子的复选框会变为激活状态，并且显示的数字用于生成打乱操作的随机序列。使用随机种子可以生成可重复的随机打乱过程，从而使我们能够重复特定训练运行的结果。点击**新种子**按钮会生成一个新的随机种子和一个新的随机打乱过程。禁用随机种子的复选框会为每次节点执行生成新的种子。
- en: In the lower part of the **Options** tab, you can select the **Optimizer algorithm**,
    and its parameters to use during training. The optimizer algorithm is the training
    algorithm. For example, you can select the **RMSProp** optimizer and then the
    corresponding **Learning rate** and **Learning rate decay** values. When the node
    is selected, the **Description** panel on the right is populated with details
    about the node. A list of optimizers is provided, as well as links to the original
    Keras library explaining all the parameters required in this frame.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在**选项**标签页的下部，您可以选择训练时使用的**优化器算法**及其参数。优化器算法是训练算法。例如，您可以选择**RMSProp**优化器，然后设置相应的**学习率**和**学习率衰减**值。当选择节点时，右侧的**描述**面板会显示关于该节点的详细信息。提供了优化器列表以及链接，链接指向原始Keras库，解释此框架中所有必需的参数。
- en: At the very bottom of the **Options** tab, you can constrain the size of the
    gradient values. If **Clip norm** is checked, the gradients whose L2 norm exceeds
    the given norm will be clipped to that norm. If **Clip value** is checked, the
    gradients whose absolute value exceeds the given value will be clipped to that
    value (or the negated value, respectively).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在**选项**标签页的最下方，您可以限制梯度值的大小。如果选中**剪辑范数**，则L2范数超过给定范数的梯度会被剪辑到该范数。如果选中**剪辑值**，则绝对值超过给定值的梯度会被剪辑到该值（或其相反值）。
- en: The **Advanced Options** tab contains a few additional settings for special
    termination and learning rate reduction cases. The last option allows you to specify
    which GPU to use on systems with multiple GPUs.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**高级选项**标签页包含一些用于特殊终止和学习率衰减的额外设置。最后一个选项允许您在有多个GPU的系统上指定使用哪个GPU。'
- en: Tracking the Training Progress
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪训练进度
- en: 'After setting all the training parameters, you can start training your network
    by executing the node. While executing the node, you can check the learning progress
    in the **Learning Monitor** view. You can open the **Learning Monitor** view by
    right-clicking on the Keras Network Learner node and selecting **View: Learning
    Monitor**; see *Figure 4.21*.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置完所有训练参数后，您可以通过执行节点来开始训练网络。在执行节点时，您可以在**学习监控**视图中查看学习进度。您可以通过右键点击Keras网络学习节点并选择**查看：学习监控**来打开**学习监控**视图；参见*图
    4.21*。
- en: By default, the **Learning Monitor** view shows the evolution of the accuracy
    curve, in red, on the training set after each weight update, which means after
    a data batch has passed through the network. The accuracy values are reported
    on the *y* axis and the progressive number of the batch on the *x* axis.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，**学习监控**视图会显示训练集上每次权重更新后的准确度曲线变化，显示为红色，这意味着在数据批次通过网络后。准确度值显示在*y*轴上，批次的进度编号显示在*x*轴上。
- en: Clicking on **Loss** above the line plot shows the loss curve on the training
    set instead of the accuracy.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 点击上方的**损失**按钮可以显示训练集上的损失曲线，而不是准确度曲线。
- en: 'More information about the training progress is available in the **Keras Log
    Output** view. This can be selected in the top part of the Keras Learning node''s
    view, in the last tab after **Accuracy** and **Loss**:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于训练进度的信息可以在**Keras日志输出**视图中找到。您可以在Keras学习节点视图的顶部选项卡中选择它，位于**准确度**和**损失**之后的最后一个标签。
- en: '![Figure 4.21 – The Learning Monitor view shows the progress of the learning
    process](img/B16391_04_021.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.21 – 学习监控视图显示学习过程的进展](img/B16391_04_021.jpg)'
- en: Figure 4.21 – The Learning Monitor view shows the progress of the learning process
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.21 – 学习监控视图显示学习过程的进展
- en: Tip
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'The **Learning Monitor** view of the Keras Network Learner node allows you
    to track the learning of your model. You can open it by right-clicking on the
    executing node and selecting **View: Learning Monitor**.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**学习监控**视图属于Keras网络学习节点，您可以通过右键点击执行节点并选择**查看：学习监控**来打开它。'
- en: If you are using a validation set, a blue line appears in the accuracy/loss
    plot. The blue line shows the corresponding progress of the training procedure
    on the validation set.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用验证集，准确度/损失图中会出现一条蓝色线。蓝色线显示的是训练过程在验证集上的对应进度。
- en: Under the plot, you have the option to zoom in on the *x* axis – the batch axis
    – to see the progress after each batch in more detail.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表下方，您可以选择缩放*x*轴—即批次轴—以便更详细地查看每个批次后的进度。
- en: The **Smoothing** checkbox introduces the moving average curve of the original
    accuracy or loss curve. The **Log Scale** checkbox changes the curve representation
    to a logarithmic scale for a more detailed evaluation of the training run.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**平滑**复选框引入了原始准确度或损失曲线的移动平均曲线。**对数刻度**复选框将曲线表示更改为对数刻度，以便更详细地评估训练运行。'
- en: Finally, at the bottom of the view, you can see the **Stop learning** button.
    This is an option for on-demand early stopping of the training process. If training
    is stopped before it is finished, the network is saved in the current status.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在视图底部，您可以看到**停止学习**按钮。这是一种按需提前停止训练过程的选项。如果在完成训练之前停止训练，则网络保存在当前状态。
- en: Training Settings for Iris Flower Classification
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Iris 花分类训练设置
- en: For the iris flower classification example based on the Iris dataset, we used
    the following settings in the Network Learner node.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于 Iris 数据集的 Iris 花分类示例，我们在网络学习节点中使用了以下设置。
- en: In the first tab, the **Input Data** tab, the four numerical inputs are selected
    as the input features. During the data preparation part, we applied no nominal
    feature encoding on the input features. So, we just feed them as they are into
    the input layer of the network, by using the **From Number (double)** conversion
    type.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个标签页，**输入数据**标签页中，选择四个数值输入作为输入特征。在数据准备阶段，我们对输入特征没有进行标称特征编码。因此，我们将它们原封不动地馈送到网络的输入层，使用**从数字（双精度）**转换类型。
- en: In the second tab, the `class_collection` input column, containing the integer-encoded
    class as a collection, and we applied the **From Collection of Number (integer)
    to One-Hot Tensor** conversion. Therefore, during the execution, the Keras Network
    Learner node creates the one-hot encoding version of the three classes in a three-dimensional
    vector, as it is also required to match the network output. In the lower part
    of this second tab, select the **Categorical cross entropy** loss function.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个标签页中，包含整数编码类作为集合的`class_collection`输入列，并且我们应用了**从数字集合（整数）到独热张量**转换。因此，在执行过程中，Keras
    网络学习节点创建了三维向量的独热编码版本，以匹配网络输出。在此第二个标签页的下半部分，选择**分类交叉熵**损失函数。
- en: In the third tab, named **Options**, the training parameters are defined. The
    network is trained using 50 epochs, a training batch size of 5, and the **RMSProp**
    optimizer.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在名为**选项**的第三个标签页中，定义了训练参数。网络使用 50 个 epoch 进行训练，训练批次大小为 5，并使用**RMSProp**优化器。
- en: The settings in the **Advanced Options** tab are left inactive, by default.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**高级选项**标签页中的设置默认处于未激活状态。'
- en: Training Settings for Income Prediction
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收入预测的训练设置
- en: For a multiclass classification problem, such as the income prediction example
    based on the adult dataset, the settings are a bit different. We used the following
    settings.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 对于诸如基于成人数据集的收入预测示例之类的多类分类问题，设置略有不同。我们使用了以下设置。
- en: In the first tab, `Income`, is in the `Exclude` part. Here, in the data preparation
    phase, some of the input features were already numerical and have not been encoded,
    some have been integer encoded, and some have been one-hot encoded via KNIME native
    nodes. So, all input features are ready to be fed as they are into the network.
    Notice that, since we decided to mix integer encoding, one-hot encoding, and original
    features, the only possible encoding applicable to all those different features
    is a simple **From Number** type of transformation.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个标签页中，`Income` 在`Exclude`部分。在这里，在数据准备阶段，一些输入特征已经是数值的，并且没有被编码，一些已经被整数编码，并且一些已经通过
    KNIME 原生节点被独热编码。因此，所有输入特征都准备好按原样馈送到网络中。请注意，由于我们决定混合整数编码、独热编码和原始特征，唯一适用于所有这些不同特征的编码是简单的**从数字**类型转换。
- en: Also, in the second tab, `0` or `1`. This also fits the one output from the
    sigmoid function in the output layer of the network. In the include-exclude frame,
    only the target column, `Income`, is included. Next, the **Binary cross entropy**
    loss function is selected, to fit a binary classification problem such as this
    one.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个标签页中，`0` 或 `1`。这也适用于网络输出层的 Sigmoid 函数的单输出。在包含-排除框架中，只包括目标列`Income`。接下来，选择**二元交叉熵**损失函数，以适应这样的二元分类问题。
- en: In the third tab, **Options**, we set the network to be trained for 80 epochs
    with a training batch size of 80 data rows. In this example, we also use a validation
    set, to be able to already see, during training, the network progress on data
    not included in the training set. For the processing of the validation set, a
    batch size of 40 data rows is set. Lastly, we select **Adam** as the optimizer
    for this training process.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个标签页，**选项**，我们将网络设置为训练80个周期，训练批次大小为80条数据。在此示例中，我们还使用了验证集，以便在训练过程中能够看到网络在未包含在训练集中的数据上的进展。对于验证集的处理，设置了批次大小为40条数据。最后，我们选择**Adam**作为该训练过程的优化器。
- en: Again, the settings in the last tab, **Advanced Options**, are disabled by default.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，最后一个标签页，**高级选项**中的设置默认是禁用的。
- en: Testing and Applying the Network
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和应用网络
- en: Now that the neural network has been trained, the last step is to apply the
    network to the test set and evaluate its performance.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在神经网络已经训练完成，最后一步是将网络应用于测试集并评估其性能。
- en: Executing the Network
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行网络
- en: 'To execute a trained network, you can use the **Keras Network Executor** node,
    as in *Figure 4.22*. The node has two input ports: a Keras network port for the
    trained network and a data input port for the test set or new data.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行训练好的网络，您可以使用**Keras网络执行器**节点，如*图4.22*所示。该节点有两个输入端口：一个是用于训练好的Keras网络的端口，另一个是用于测试集或新数据的数据输入端口。
- en: In the first tab of the configuration window, named **Options**, you can select,
    in the upper part, the backend engine, the batch size for the input data, and
    whether to also keep the original input columns in the output data table.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置窗口的第一个标签页，名为**选项**，您可以在上方选择后端引擎、输入数据的批处理大小，以及是否在输出数据表中保留原始输入列。
- en: Under that, you can specify the input columns and the required conversion. Like
    in the Keras Network Learner node, the input specifications from the neural network
    are printed at the top. Remember that, since you are using the same network and
    the same format for the data, the settings for the input features must be the
    same as the ones in the Keras Network Learner node.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在此下方，您可以指定输入列和所需的转换。与Keras网络学习器节点中的输入规格一样，神经网络的输入规格会显示在顶部。请记住，由于您使用的是相同的网络和相同的数据格式，因此输入特征的设置必须与Keras网络学习器节点中的设置相同。
- en: 'In the last part of this tab, you can add the settings for the output(s). First,
    you need to specify where to take the output from; this should be the output layer
    from the input network. To add one output layer, click on the **add output** button.
    In the new window, you see a menu containing all layers from the input network.
    If you configured prefixes in the layer nodes, you could see them in the drop-down
    menu, making it easier for you to recognize the layer of interest. Select the
    output layer:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在此标签的最后部分，您可以添加输出的设置。首先，您需要指定输出的来源；这应该是输入网络中的输出层。要添加一个输出层，请点击**添加输出**按钮。在新窗口中，您会看到一个包含输入网络所有层的菜单。如果您在层节点中配置了前缀，您可以在下拉菜单中看到它们，这样可以更轻松地识别感兴趣的层。选择输出层：
- en: '![Figure 4.22 – The Keras Network Executor node runs the network on new data.
    In the configuration window, you can select the outputs by clicking on the add
    output button](img/B16391_04_022.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图4.22 – Keras网络执行节点在新数据上运行网络。在配置窗口中，您可以通过点击添加输出按钮来选择输出](img/B16391_04_022.jpg)'
- en: Figure 4.22 – The Keras Network Executor node runs the network on new data.
    In the configuration window, you can select the outputs by clicking on the add
    output button
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.22 – Keras网络执行节点在新数据上运行网络。在配置窗口中，您可以通过点击添加输出按钮来选择输出。
- en: In all use cases included in this book, the last layer of the network is used
    as the output layer. This layer is easily recognizable, as it is the only one
    without the **(hidden)** suffix in the drop-down list.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中所有的使用案例中，网络的最后一层作为输出层。这一层很容易识别，因为它是下拉列表中唯一没有**（隐藏）**后缀的层。
- en: Tip
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You can also output the output of a hidden layer, for example, for debugging
    purposes.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以输出隐藏层的输出，例如用于调试目的。
- en: Finally, select the appropriate conversion type, to get the output values in
    the shape you prefer – for example, in one cell as a list (**To List of Number
    (double)**) or with a new column for each output unit (**To Number (double)**).
    In this last case, you can define a prefix to append to the names of the output
    columns.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，选择适当的转换类型，以便以你喜欢的格式获取输出值——例如，将值放在一个单元格中作为列表（**转为数字列表（双精度）**），或者为每个输出单元创建一个新列（**转为数字（双精度）**）。在最后一种情况下，你可以定义一个前缀，附加到输出列的名称上。
- en: The **Advanced Options** part contains settings to let the network run on GPU-enabled
    machines.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**高级选项（Advanced Options）**部分包含设置，允许网络在支持 GPU 的机器上运行。'
- en: Extracting the Predictions and Evaluating the Network Performance
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取预测结果并评估网络性能
- en: Depending on the use case, the network outputs might need some postprocessing
    to extract the predictions. For example, in a binary classification problem, with
    one output unit and a sigmoid activation function, the output value is the probability
    for the class encoded as `1`. In this case, to produce the actual class assignment,
    you could apply a threshold to the probability inside a Rule Engine node.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 根据使用场景，网络输出可能需要一些后处理来提取预测结果。例如，在二分类问题中，若只有一个输出单元且使用了 Sigmoid 激活函数，则输出值为表示类别
    `1` 的概率。在这种情况下，你可以在规则引擎节点中应用一个阈值来产生实际的类别分配。
- en: The last step is the evaluation of the model. To evaluate a classification model,
    you can use either the **Scorer** node or the **ROC Curve** node. The output of
    the Scorer node gives you common performance metrics, such as the accuracy, Cohen's
    kappa, or the confusion matrix.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是评估模型。要评估分类模型，你可以使用**评分器（Scorer）**节点或**ROC 曲线（ROC Curve）**节点。评分器节点的输出提供了常见的性能指标，如准确率、Cohen's
    Kappa 或混淆矩阵。
- en: Tip
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'Another really nice node to evaluate the performance for the binary classification
    problem is the **Binary Classification Inspector** node. The node is part of the
    KNIME Machine Learning Interpretability Extension: [https://hub.knime.com/knime/extensions/org.knime.features.mli/latest](https://hub.knime.com/knime/extensions/org.knime.features.mli/latest).'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常不错的节点，用于评估二分类问题的性能，是**二分类检查器（Binary Classification Inspector）**节点。该节点是
    KNIME 机器学习可解释性扩展的一部分：[https://hub.knime.com/knime/extensions/org.knime.features.mli/latest](https://hub.knime.com/knime/extensions/org.knime.features.mli/latest)。
- en: For the evaluation of regression solutions, the **Numeric Scorer** node calculates
    some error measures, such as mean squared error, root mean squared error, mean
    absolute error, mean absolute percentage error, mean signed difference, and R-squared.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 对于回归解决方案的评估，**数值评分器（Numeric Scorer）**节点计算一些误差指标，如均方误差、均方根误差、平均绝对误差、平均绝对百分比误差、平均符号差异和
    R 平方值。
- en: Testing the Network Trained to Classify Iris Flowers
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试训练好的鸢尾花分类网络
- en: 'In *Figure 4.23*, you can see the part of the workflow that applies the trained
    network, extracts the predictions, and evaluates the network trained to classify
    iris flowers:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 4.23*中，你可以看到应用训练好的网络、提取预测结果并评估用于分类鸢尾花的网络部分：
- en: '![Figure 4.23 – This workflow snippet applies the trained network and extracts'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.23 – 该工作流片段应用训练好的网络并提取'
- en: and evaluates the predictions for the iris flower example](img/B16391_04_023.jpg)
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 并评估鸢尾花示例的预测结果](img/B16391_04_023.jpg)
- en: Figure 4.23 – This workflow snippet applies the trained network and extracts
    and evaluates the predictions for the iris flower example
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.23 – 该工作流片段应用训练好的网络，提取并评估鸢尾花示例的预测结果
- en: In the configuration window of the `"dense_2/Softmax:0_"`, as a **Conversion**
    type of **To Number (double)** is selected. As the Iris dataset has three different
    possible class values, the node adds three new columns with the three probabilities
    for the three classes. Another conversion option is **To List of Number (double)**.
    This conversion option would lead to only one new column, with all the class probabilities
    in one cell packaged as a list.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `"dense_2/Softmax:0_"` 的配置窗口中，已选择**转换类型：转为数字（双精度）**。由于鸢尾花数据集有三种不同的类别值，节点添加了三个新列，分别表示这三类的概率。另一种转换选项是**转为数字列表（双精度）**。这种转换选项会导致只新增一个列，将所有类别的概率以列表形式放入一个单元格中。
- en: Next, the predictions are extracted with the Rule Engine node. The probabilities
    for the different classes are in the `$Output_1/Softmax:0_0for class 0`, and `Output_1/Softmax:0_1`
    columns for class 1, and `Output_1/Softmax:0_2` for class 2\. Here, the class
    with the highest probability is selected as the predicted outcome.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 Rule Engine 节点提取预测结果。不同类别的概率在 `$Output_1/Softmax:0_0for class 0` 列中为类别
    0，在 `Output_1/Softmax:0_1` 列中为类别 1，在 `Output_1/Softmax:0_2` 列中为类别 2。此处，选取具有最高概率的类别作为预测结果。
- en: The first rule checks whether the class encoded as `0` has the highest probability
    by comparing it to the probability for the other two classes. The second rule
    does the same for the class encoded as `1`, and the third rule for the class encoded
    as `2`. The last rule defines a default value.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条规则通过将编码为 `0` 的类别与其他两个类别的概率进行比较，检查是否其概率最大。第二条规则对编码为 `1` 的类别执行相同的操作，第三条规则则检查编码为
    `2` 的类别。最后一条规则定义了默认值。
- en: 'These rules are applied with the following code:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则通过以下代码应用：
- en: '[PRE0]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Lastly, the Scorer node is used to evaluate network performance.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 Scorer 节点评估网络性能。
- en: Testing the Network Trained for Income Prediction
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试用于收入预测的训练网络
- en: The same node combination with different settings can be used to apply the trained
    network, extract the predictions, and evaluate the model for the income prediction
    example on the adult dataset.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的节点组合，并调整设置，可以应用训练后的网络，提取预测结果，并评估成人数据集上的收入预测模型。
- en: In the configuration window of the Keras Network Executor node, in the `dense_3`
    output layer is added as the output. In this case, the output of the network is
    the probability for the class encoded as `1`, `">50K"`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Keras Network Executor 节点的配置窗口中，将 `dense_3` 输出层作为输出添加。在此情况下，网络的输出为编码为 `1`（`">50K"`）的类别的概率。
- en: 'Finally, the Rule Engine node checks whether the output probability is higher
    or lower than the `0.5` threshold using the following code:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Rule Engine 节点通过以下代码检查输出概率是否高于或低于 `0.5` 阈值：
- en: '[PRE1]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Lastly, the network performance is evaluated with the Scorer node.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 Scorer 节点评估网络性能。
- en: With this, we have gone through the whole process, from data access and data
    preparation to defining, training, applying, and evaluating a neural network using
    KNIME Analytics Platform.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里，我们已经完成了整个过程，从数据访问和数据准备，到使用 KNIME Analytics Platform 定义、训练、应用和评估神经网络。
- en: Summary
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have reached the end of this chapter, where you have learned how to perform
    the different steps involved in training a neural network in KNIME Analytics Platform.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已接近尾声，在这里你学会了如何在 KNIME Analytics Platform 中执行训练神经网络的不同步骤。
- en: We started with common preprocessing steps, including different encodings, normalization,
    and missing value handling. Next, you learned how to define a neural network architecture
    by using different Keras layer nodes without writing code. We then moved on to
    the training of the neural network and you learned how to define the loss function,
    as well as how you can monitor the learning progress, apply the network to new
    data, and extract the predictions.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从常见的预处理步骤开始，包括不同的编码、归一化和缺失值处理。接下来，你学习了如何通过使用不同的 Keras 层节点而不编写代码来定义神经网络架构。然后，我们进入了神经网络的训练，你学习了如何定义损失函数，以及如何监控学习进度、应用网络到新数据并提取预测结果。
- en: Each section closed with small example sessions, preparing you to perform all
    these steps on your own.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分结束时都有小的示例环节，帮助你准备独立完成所有这些步骤。
- en: 'In the next chapter, you will see how these steps can be applied to the first
    use case of the book: fraud detection using an autoencoder.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将看到如何将这些步骤应用于本书的第一个用例：使用自编码器进行欺诈检测。
- en: Questions and Exercises
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题与练习
- en: 'Check your level of understanding of the concepts presented in this chapter
    by answering the following questions:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题，检查你对本章中概念的理解程度：
- en: How can you set the loss function to train your neural network?
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何设置损失函数来训练你的神经网络？
- en: a) By using the Keras Loss Function node
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 通过使用 Keras 损失函数节点
- en: b) By using the Keras Output Layer node
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 通过使用 Keras 输出层节点
- en: c) In the configuration window of the Keras Network Learner node
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) 在 Keras Network Learner 节点的配置窗口中
- en: d) In the configuration window of the Keras Network Executor node
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d) 在 Keras Network Executor 节点的配置窗口中
- en: How can you one-hot encode your features?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何对你的特征进行 one-hot 编码？
- en: a) By using the One Hot Encoding node
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 通过使用 One Hot Encoding 节点
- en: b) By using the One to Many node
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 通过使用 One to Many 节点
- en: c) By creating an integer encoding using the Category to Number node and afterward,
    the Integer to One Hot Encoding node
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) 通过使用 Category to Number 节点创建整数编码，然后使用 Integer to One Hot Encoding 节点。
- en: d) By creating an integer encoding, transforming it into a collection cell,
    and selecting the right conversion
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d) 通过创建整数编码，将其转换为集合单元，并选择正确的转换。
- en: How can you define the number of neurons for the input of your network?
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何定义网络输入层的神经元数量？
- en: a) By using a Keras Input Layer node.
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 通过使用 Keras 输入层节点。
- en: b) By using a Keras Dense Layer node without any input network.
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 通过使用没有任何输入网络的 Keras 全连接层节点。
- en: c) The input dimension is set automatically based on the selected features in
    the Keras Network Learner node.
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) 输入维度根据在 Keras Network Learner 节点中选择的特征自动设置。
- en: d) By using a Keras Start Layer node.
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d) 通过使用 Keras 起始层节点。
- en: How can you monitor the training of your neural network on a validation set?
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何监控神经网络在验证集上的训练过程？
- en: a) Feed a validation set into the optional input port of the Keras Network Learner
    node and open the training monitor view. The performance of the validation set
    is shown in red.
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 将验证集输入到 Keras Network Learner 节点的可选输入端口，并打开训练监视器视图。验证集的性能以红色显示。
- en: b) Click on the **apply on validation set** button in the training monitor view.
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 在训练监视器视图中点击**应用于验证集**按钮。
- en: c) Feed a validation set into the optional input port of the Keras Network Learner
    node and open the training monitor view. The performance of the validation set
    is shown in blue.
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) 将验证集输入到 Keras Network Learner 节点的可选输入端口，并打开训练监视器视图。验证集的性能以蓝色显示。
- en: d) Feed a validation set into the optional input port of the Keras Network Learner
    node and open the validation set tab of the training monitor view. Build a workflow
    to read the Iris dataset and to train a neural network with one hidden layer (eight
    units and the ReLU activation function) to distinguish the three species from
    each other based on the four input features.
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d) 将验证集输入到 Keras Network Learner 节点的可选输入端口，并打开训练监视器视图中的验证集标签。构建一个工作流来读取 Iris
    数据集，并训练一个包含一个隐藏层（八个单元和 ReLU 激活函数）的神经网络，根据四个输入特征区分三种物种。
