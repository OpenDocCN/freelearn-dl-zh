- en: 12\. Evolutionary Strategies for RL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12. **强化学习**的进化策略
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will be identifying the limitations of gradient-based methods
    and the motivation for evolutionary strategies. We will break down the components
    of genetic algorithms and implement them in **Reinforcement Learning** (**RL**).
    By the end of this chapter, you will be able to combine evolutionary strategies
    with traditional machine learning methods, specifically in the selection of neural
    network hyperparameters, and also identify the limitations of these evolutionary
    methods.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将识别梯度方法的局限性以及进化策略的动机。我们将分解遗传算法的组成部分，并将其应用于**强化学习**（**RL**）。在本章结束时，你将能够将进化策略与传统机器学习方法结合，特别是在选择神经网络超参数时，同时识别这些进化方法的局限性。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: In the previous chapter, we looked at various policy-based methods and their
    advantages. In this chapter, we are going to learn about gradient-free methods,
    namely genetic algorithms; develop these algorithms step by step; and use them
    to optimize neural networks and RL-based algorithms. This chapter discusses the
    limitations of gradient-based methods, such as getting stuck at local optima and
    slower convergence when dealing with noisy input. This chapter presents an alternative
    optimization solution to gradient methods through genetic algorithms, as they
    ensure global optimum convergence. You will examine and implement the structure
    of genetic algorithms and implement them through hyperparameter selection for
    neural networks and evolving network topologies, as well as using them in combination
    with RL for a cart-pole balancing activity. Hybrid neural networks that use genetic
    algorithms are used to solve complex problems, such as modeling plasma chemical
    reactors, designing fractal frequency selective surfaces, or optimizing production
    processes. In the following section, you will be examining the problems posed
    by gradient-based methods.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了各种基于策略的方法及其优势。在本章中，我们将学习无梯度方法，即遗传算法；逐步开发这些算法，并利用它们优化神经网络和基于RL的算法。本章讨论了梯度方法的局限性，如在局部最优解处停滞，以及在处理噪声输入时收敛速度较慢。本章通过遗传算法提供了梯度方法的替代优化解决方案，因为遗传算法确保全局最优收敛。你将研究并实现遗传算法的结构，并通过神经网络的超参数选择和网络拓扑结构的演化来实现它们，同时将其与RL结合用于平衡车杆活动。使用遗传算法的混合神经网络用于解决复杂问题，如建模等离子体化学反应器、设计分形频率选择性表面或优化生产过程。在接下来的部分中，你将审视梯度方法带来的问题。
- en: Problems with Gradient-Based Methods
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 梯度方法的问题
- en: In this section, you will learn about the differences between value-based and
    policy-based methods and the use of gradient-based methods in policy search algorithms.
    You will then examine the advantages and disadvantages of using gradient-based
    methods in policy-based approaches and implement stochastic gradient descent using
    TensorFlow to solve a cubic function with two unknowns.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解基于价值的方法与基于策略的方法的区别，以及在策略搜索算法中使用梯度方法。你将进一步分析在基于策略的方法中使用梯度方法的优缺点，并通过TensorFlow实现随机梯度下降，以解决带有两个未知数的立方函数。
- en: 'There are two approaches when doing RL: value-based and policy-based. These
    approaches are used to solve complex decision problems related to **Markov Decision**
    **Processes** (**MDPs**) and **Partially Observable Markov Decision Processes**
    (**POMDPs**). Value-based approaches rely on identifying and deriving the optimal
    policy based on the identification of the optimal value function. Algorithms such
    as Q-learning or SARSA(λ) are included within this category, and for tasks involving
    lookup tables, their implementation leads to convergence on a return that is optimal,
    globally. As the algorithms rely on a known model of the environment, for partially
    observable or continuous spaces, there are no guarantees for convergence on a
    solution that is optimal using these value search methods.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 强化学习有两种方法：基于价值的方法和基于策略的方法。这些方法用于解决与**马尔可夫决策过程**（**MDPs**）和**部分可观察马尔可夫决策过程**（**POMDPs**）相关的复杂决策问题。基于价值的方法依赖于通过识别最优价值函数来确定和推导最优策略。像Q-learning或SARSA(λ)这样的算法属于这一类，对于涉及查找表的任务，它们的实现能导致全局最优的回报收敛。由于这些算法依赖于已知的环境模型，因此对于部分可观察或连续空间，使用这些价值搜索方法时无法保证收敛到最优解。
- en: Conversely, policy-based approaches, instead of relying on the value function
    to maximize the return, use gradient methods (stochastic optimization) to explore
    the policy space. Gradient-based methods or policy gradient methods map the parametrized
    space (environment) to the policy space using loss functions, thus enabling the
    RL agent to explore directly the entirety, or a portion, of the policy space.
    One of the most widely used methods (which is going to be implemented in this
    section) is gradient descent.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，基于策略的方法不是依赖于价值函数来最大化回报，而是使用梯度方法（随机优化）来探索策略空间。基于梯度的方法或策略梯度方法通过使用损失函数将参数化空间（环境）映射到策略空间，从而使RL代理能够直接探索整个策略空间或其一部分。其中最常用的方法（将在本节中实现）是梯度下降。
- en: Note
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For further reading on gradient descent, please refer to the technical paper
    by *Marbach, 2001*, at the following link: https://link.springer.com/article/10.1023/A:1022145020786.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有关梯度下降的进一步阅读，请参考*Marbach, 2001*的技术论文，链接如下：https://link.springer.com/article/10.1023/A:1022145020786。
- en: The advantages of the gradient approaches (stochastic gradient descent or ascent)
    are that they are suitable for POMDPs or non-MDPs, especially for solving robotics
    problems with multiple constraints. However, there are several disadvantages to
    employing gradient-based methods. The most notable one is that algorithms such
    as **REINFORCE** and **DPG** determine a local optimum of the expected reward.
    As the local optimum is found, the RL agent does not expand its search globally.
    For example, a robot solving a maze problem will get stuck in a corner and will
    continuously try to move in the same location. Additionally, when dealing with
    high return variance or noisy input data, algorithm performance is affected as
    they converge slower. This happens when, for instance, a robotic arm is programmed
    to pick up and place a blue component in a tray, but the table has blue hues to
    its color, which interferes with the detection of the component through the sensors
    (such as a camera).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度方法（随机梯度下降或上升法）的优点是它们适用于POMDP或非MDP问题，尤其是在解决具有多个约束的机器人问题时。然而，采用基于梯度的方法也有几个缺点。最显著的一个缺点是像**REINFORCE**和**DPG**这样的算法只能确定期望回报的局部最优解。当局部最优解被找到时，RL代理不会进行全局搜索。例如，解决迷宫问题的机器人可能会被困在一个角落，并且会不断尝试在同一位置移动。此外，在处理高回报方差或噪声输入数据时，算法的性能会受到影响，因为它们的收敛速度较慢。例如，当一个机器人臂被编程为捡起并放置一个蓝色部件到托盘中，但桌面颜色带有蓝色调，导致传感器（如摄像头）无法正确识别部件时，算法的表现就会受到干扰。
- en: Note
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For further reading on the **REINFORCE** algorithm, please refer to the technical
    paper by *Williams, 1992*, at the following link: https://link.springer.com/article/10.1007/BF00992696.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有关**REINFORCE**算法的进一步阅读，请参考*Williams, 1992*的技术论文，链接如下：https://link.springer.com/article/10.1007/BF00992696。
- en: 'Similarly, please read about the **DPG** algorithm by *Silvester, 2014*, at
    the following link: http://proceedings.mlr.press/v32/silver14.pdf.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，请阅读*Silvester, 2014*的**DPG**算法，链接如下：http://proceedings.mlr.press/v32/silver14.pdf。
- en: An alternative to gradient-based methods is the use of gradient-free methods,
    which rely on evolutionary algorithms to achieve a global optimum for the return.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 基于梯度的方法的替代方案是使用无梯度方法，这些方法依赖于进化算法来实现回报的全局最优解。
- en: The following exercise will enable you to understand the potential of gradient
    methods for converging on optimal solutions and the lengthy process that is undertaken
    as the method searches step by step for the optimal solution. You will be presented
    with a mathematical function (loss function) that maps the input values, ![1](img/B16182_12_00a.png),
    to an output value, ![2](img/B16182_12_00b.png). The goal is to identify the optimal
    values of the inputs that lead to the lowest value of the output; however, this
    is step-dependent and is at risk of staying at a local optimum. We will be using
    the `GradientTape()` function to calculate the gradients, which are nothing but
    differentiation solutions. This will help you understand the limitations of such
    optimization strategies.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习将帮助你理解梯度方法在收敛到最优解过程中的潜力以及在方法逐步寻找最优解时所需的漫长过程。你将面对一个数学函数（损失函数），它将输入值，![1](img/B16182_12_00a.png)，映射到输出值，![2](img/B16182_12_00b.png)。目标是确定输入的最优值，以使输出值达到最低；然而，这个过程依赖于每一步，并且存在停留在局部最优解的风险。我们将使用`GradientTape()`函数来计算梯度，这实际上就是求导的解决方案。这将帮助你理解这种优化策略的局限性。
- en: 'Exercise 12.01: Optimization Using Stochastic Gradient Descent'
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.01：使用随机梯度下降法进行优化
- en: This exercise aims to enable you to apply gradient methods, most notably **Stochastic
    Gradient Descent** (**SGD**), available in TensorFlow by following the steps required
    to converge on an optimal solution.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习旨在使你能够应用梯度方法，最著名的 **随机梯度下降法** (**SGD**)，并通过遵循所需步骤收敛到最优解。
- en: 'The following loss function has two unknowns, ![3](img/B16182_12_00c.png):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下损失函数有两个未知数， ![3](img/B16182_12_00c.png)：
- en: '![Figure 12.1: Sample loss function'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.1：示例损失函数'
- en: '](img/B16182_12_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16182_12_01.jpg)'
- en: 'Figure 12.1: Sample loss function'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1：示例损失函数
- en: Find the optimum values for ![4](img/B16182_12_01a.png) within 100 steps with
    a learning rate of `0.1`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 100 步内，使用学习率 `0.1` 查找 ![4](img/B16182_12_01a.png) 的最优值。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: Create a new Jupyter Notebook.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Jupyter Notebook。
- en: 'Import the `tensorflow` package as `tf`:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `tensorflow` 包导入为 `tf`：
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Define a function that outputs ![5](img/B16182_12_01b.png) :'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个输出 ![5](img/B16182_12_01b.png) 的函数：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Define a function for initializing the `x` and `y` variables and initialize
    them with the values `5` and `10`:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个初始化 `x` 和 `y` 变量的函数，并将它们初始化为值 `5` 和 `10`：
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code snippet, we have used decimal format for the values assigned
    to `x` and `y` to start the optimization process, as the `Variable()` constructor
    needs to have a tensor type of `float32`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们使用了十进制格式为 `x` 和 `y` 分配初始值，以启动优化过程，因为 `Variable()` 构造函数需要具有 `float32`
    类型的张量。
- en: 'Instantiate the optimizer by selecting `SGD` from `keras` in TensorFlow and
    input the learning rate of 0.1:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择 TensorFlow 中 `keras` 的 `SGD` 来实例化优化器，并输入学习率 0.1：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Set a loop of `100` steps, where you calculate the loss, use the `GradientTape()`
    function for automatic differentiations, and process the gradients:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个 `100` 步的循环，其中你计算损失，使用 `GradientTape()` 函数进行自动微分，并处理梯度：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we have used `GradientTape()` from TensorFlow to calculate
    the gradients (which essentially are differentiation solutions). We created a
    loss parameter that stores the ![37](img/B16182_12_01c.png) value when calling
    the function. `GradientTape()` is activated when calling the `gradient()` method,
    which essentially is used to compute multiple gradients in a single computation.
    The gradients are stored in a `p_gradients` array.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了 TensorFlow 的 `GradientTape()` 来计算梯度（本质上是微分解）。我们创建了一个损失参数，当调用该函数时，存储了
    ![37](img/B16182_12_01c.png) 值。`GradientTape()` 在调用 `gradient()` 方法时激活，后者用于在单次计算中计算多个梯度。梯度被存储在
    `p_gradients` 数组中。
- en: 'Use the `zip()` function to aggregate the gradients to the values:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `zip()` 函数将梯度与值聚合：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Print the step and the values of ![6](img/B16182_12_01d.png):'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印步骤和 ![6](img/B16182_12_01d.png) 的值：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Apply the optimizer using the gradients that were processed:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用已处理的梯度应用优化器：
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Run the application.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。
- en: 'You will get the following output:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '![Figure 12.2: Step-by-step optimization using SGD'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 12.2：使用 SGD 逐步优化'
- en: '](img/B16182_12_02.jpg)'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16182_12_02.jpg)'
- en: 'Figure 12.2: Step-by-step optimization using SGD'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2：使用 SGD 逐步优化
- en: You can observe in the output that from `Step=25` onward, the ![36](img/B16182_12_02a.png)
    values do not change; therefore, they are considered to be the optimum values
    for the respective loss function.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在输出中看到，从 `Step=25` 开始， ![36](img/B16182_12_02a.png) 的值没有变化；因此，它们被认为是相应损失函数的最优值。
- en: 'By printing the steps and values of the inputs and outputs, you can observe
    that the algorithm converges before the termination of the 100 steps to the optimal
    values of ![35](img/B16182_12_02a.png). However, you can observe that the problem
    is step-dependent: if the optimization is stopped before global optimum convergence,
    the solution would be sub-optimal.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过打印输入和输出的步骤和值，你可以观察到算法在 100 步之前就收敛到最优值 ![35](img/B16182_12_02a.png)。然而，你可以观察到问题是与步骤相关的：如果优化在全局最优收敛之前停止，得到的解将是次优解。
- en: Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2C10rXD](https://packt.live/2C10rXD).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考 [https://packt.live/2C10rXD](https://packt.live/2C10rXD)。
- en: You can also run this example online at [https://packt.live/2DIWSqc](https://packt.live/2DIWSqc).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 [https://packt.live/2DIWSqc](https://packt.live/2DIWSqc) 在线运行此示例。
- en: This exercise helped your understanding and application of SGD when solving
    a loss function, developing your analysis skills as well as your skills in programming
    using TensorFlow. This will help you in your choice of optimization algorithm,
    giving you an understanding of the limitations of gradient-based methods.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这项练习帮助你理解并应用SGD来求解损失函数，提升了你的分析能力以及使用TensorFlow编程的技能。这将有助于你选择优化算法，让你理解基于梯度方法的局限性。
- en: 'In this section, we have explored the benefits and disadvantages of gradient
    methods with respect to RL algorithms, identifying the types of problems that
    they are suitable for within the context of decision-making processes. The example
    offered a simple application of gradient descent, where the optimal solution for
    two unknowns was identified using SGD optimization in TensorFlow. In the next
    section, we will be exploring an optimization alternative that is gradient-free:
    genetic algorithms.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了梯度方法在强化学习（RL）算法中的优缺点，识别了它们在决策过程中的适用问题类型。示例展示了梯度下降法的简单应用，通过使用SGD优化算法在TensorFlow中找到了两个未知数的最优解。在下一节中，我们将探讨一种不依赖梯度的优化方法：遗传算法。
- en: Introduction to Genetic Algorithms
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遗传算法简介
- en: As the problem with gradient methods is that the solution can get stuck at a
    single local optimum, other methods, such as gradient-free algorithms, can be
    considered as alternatives. In this section, you will learn about gradient-free
    methods, specifically evolutionary algorithms (for example, genetic algorithms).
    This section provides an overview of the steps taken for the implementation of
    genetic algorithms and exercises on how to implement an evolutionary algorithm
    to solve the loss function given in the previous section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于梯度方法的一个问题是解决方案可能会卡在某个局部最优点，其他方法如不依赖梯度的算法可以作为替代方案。在本节中，你将学习关于不依赖梯度的方法，特别是进化算法（例如遗传算法）。本节概述了遗传算法实现的步骤，并通过练习教你如何实现进化算法来求解上一节给出的损失函数。
- en: When multiple local optima exist or function optimization is required, gradient-free
    methods are recommended. These methods include evolutionary algorithms and particle
    swarm optimizations. A characteristic of these methods is that they rely on sets
    of optimization solutions that are commonly referred to as populations. The methods
    rely on iteratively searching for a good solution or a distribution that can solve
    a problem or a mathematical function. The search pattern for the optimal solution
    is modeled based on Darwin's natural selection paradigm and the biological phenomenon
    of genetic evolution. Evolutionary algorithms draw inspiration from biological
    evolution patterns such as mutation, reproduction, recombination, and selection.
    Particle swarm algorithms are inspired by group social behavior, such as a beehive
    organization or ant farms, where single solutions are termed as particles that
    can evolve over time.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在多个局部最优解或需要进行函数优化时，推荐使用不依赖梯度的方法。这些方法包括进化算法和粒子群优化。此类方法的特点是依赖于一组优化解，这些解通常被称为种群。方法通过迭代搜索找到一个良好的解或分布，从而解决问题或数学函数。寻找最优解的模式基于达尔文的自然选择范式以及遗传进化的生物学现象。进化算法从生物进化模式中汲取灵感，如突变、繁殖、重组和选择。粒子群算法受到群体社会行为的启发，比如蜜蜂巢或蚁群，在这些群体中，单一的解被称为粒子，能够随着时间演化。
- en: 'Natural selection stems from the premise that genetic material (the chromosome)
    encodes the survival of a species, in a certain way. The evolution of the species
    relies on how well it adapts to its external environment and the information passed
    from parents to children. In genetic material, there are variations (mutations)
    between generations that can lead to successful or unsuccessful adaptation to
    the environment (especially in dire conditions). Therefore, there are three steps
    to genetic algorithms: selection, reproduction (crossover), and mutation.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 自然选择的前提是遗传物质（染色体）以某种方式编码了物种的生存。物种的进化依赖于它如何适应外部环境以及父母传递给子代的信息。在遗传物质中，不同代之间会发生变异（突变），这些变异可能导致物种成功或不成功地适应环境（尤其在恶劣环境下）。因此，遗传算法有三个步骤：选择、繁殖（交叉）和突变。
- en: Evolutionary algorithms go about things by creating an original population of
    solutions, selecting a sub-set, and using recombination or mutation to obtain
    different solutions. This new set of solutions can replace, partly or fully, the
    original set. For the replacement to take place, the solutions go through a selection
    process that relies on analyzing their fitness. This increases the chances of
    solutions that are more suited to being utilized to develop a new set of solutions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 演化算法通过创建一个原始解的种群、选择一个子集，并使用重组或突变来获得不同的解来进行处理。这一新解集可以部分或完全替代原始解集。为了实现替代，这些解会经历一个基于适应度分析的选择过程。这增加了更适合用于开发新解集的解的机会。
- en: 'Other than the development of solutions, evolutionary algorithms can be used
    for parameter adaptation, using probability distributions. A population is still
    generated; however, a fitness method is used to select the parameters of the distribution
    instead of the actual solutions. After the new parameters are identified, the
    new distribution is used to generate a new set of solutions. Some strategies of
    parameter selection include the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除了解的开发外，演化算法还可以通过使用概率分布来进行参数适应。仍然会生成种群；然而，使用适应度方法来选择分布的参数，而不是实际的解。在确定新参数后，新的分布将用于生成新的解集。以下是一些参数选择的策略：
- en: Using natural gradient ascent after the gradients of the parameters are estimated
    from the original population, also known as **Natural Evolutionary Strategies**
    (**NESes**)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在估算出原始种群的参数梯度后，使用自然梯度上升，也称为**自然进化策略**（**NESes**）。
- en: Selecting solutions with a specific parameter and using the mean of this sub-set
    to find a new distribution mean, known as **Cross-Entropy Optimization** (**CEO**)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择具有特定参数的解，并使用该子集的均值来寻找新的分布均值，这被称为**交叉熵优化**（**CEO**）。
- en: Attributing a weight to each solution based on its fitness, using the weighted
    average as a new distribution mean – **Covariance Matrix Adaptation Evolution
    Strategies** (**CMAESes**)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据每个解的适应度赋予权重，使用加权平均值作为新的分布均值 —— **协方差矩阵适应进化策略**（**CMAESes**）。
- en: One of the major problems identified with evolutionary strategies is that achieving
    solution fitness can be computationally expensive and noisy.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 演化策略中发现的一个主要问题是，实现解的适应度可能会在计算上昂贵且噪声较大。
- en: '**Genetic Algorithms** (**GAs**) keep the solution population and conduct searches
    in multiple directions (through the chromosomes), furthering the exchange of information
    in these directions. The algorithms are most notably implemented on strings, which
    are either binary or character-based. The two main operations performed are mutation
    and crossover. The selection of the progenies is based on how close the solution
    is to the target (objective function), which denotes their fitness.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**遗传算法**（**GAs**）保持解种群，并通过多个方向进行搜索（通过染色体），进一步促进这些方向上的信息交换。算法最常见的实现是字符串处理，字符串可以是二进制或基于字符的。主要的两个操作是突变和交叉。后代的选择基于解与目标（目标函数）的接近程度，这表示它们的适应度。'
- en: 'As an overview, GAs have the following steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，遗传算法（GAs）有以下几个步骤：
- en: Population creation.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 种群创建。
- en: Fitness score creation and assignment to each solution of the population.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适应度得分的创建并分配给种群中的每个解。
- en: The selection of two parents to reproduce based on the fitness scores (potentially
    the solutions with the best performance).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择两个父代进行繁殖，依据适应度得分（可能是表现最好的解）。
- en: The creation of the two child solutions by combining and re-organizing the code
    of the two parents.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过结合和重新组织两个父代的代码，创建两个子代解。
- en: The application of a random mutation.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用随机突变。
- en: Child generation is repeated until the new population size is achieved and weights
    (fitness scores) for the population are assigned.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 孩子代的生成会重复进行，直到达到新的种群规模，并为种群分配权重（适应度得分）。
- en: The process is repeated until the maximum number of generations is reached or
    the target performance is achieved.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该过程将重复进行，直到达到最大代数或实现目标性能。
- en: We will be looking at each of these steps in detail further in this chapter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中进一步详细查看这些步骤。
- en: Among the many differences between gradient-based algorithms and GAs, one difference
    is the process of development. Gradient-based algorithms rely on differentiation,
    whereas GAs use the genetic processes of selection, reproduction, and mutation.
    The following exercise will enable you to implement GAs and evaluate their performance.
    You will be using a simple genetic algorithm in TensorFlow to identify the GA
    hyperparameter optimization for finding the optimal solution for `tensorflow_probability`
    package.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在梯度算法和遗传算法之间有许多差异，其中一个差异是开发过程。基于梯度的算法依赖于微分，而遗传算法则使用选择、繁殖和变异等遗传过程。以下练习将使你能够实现遗传算法并评估其性能。你将使用一个简单的遗传算法在TensorFlow中进行优化，找到`tensorflow_probability`包的最佳解决方案。
- en: 'Exercise 12.02: Implementing Fixed-Value and Uniform Distribution Optimization
    Using GAs'
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.02：使用遗传算法实现固定值和均匀分布优化
- en: 'In this exercise, you will still need to solve the following function, as in
    the previous exercise:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，你仍然需要像前一个练习那样求解以下函数：
- en: '![Figure 12.3: Sample loss function'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.3：样本损失函数'
- en: '](img/B16182_12_03.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16182_12_03.jpg)'
- en: 'Figure 12.3: Sample loss function'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3：样本损失函数
- en: Find the optimum values for ![7](img/B16182_12_03a.png) for a population size
    of 100, starting from ![8](img/B16182_12_03b.png) initialized to 5 and 10, and
    then extending to random samples from a distribution similar to the gradient-based
    method.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 找到种群大小为100时的![7](img/B16182_12_03a.png)的最优值，初始值为![8](img/B16182_12_03b.png)，然后扩展到从类似于基于梯度方法的分布中随机抽样。
- en: 'The goal of this exercise is to enable you to analyze the differences in applying
    GAs and gradient-descent methods, by starting from a single pair of variables
    and a variety of potential solutions. The algorithm aids in optimization problems
    by applying selection, crossover, and mutation to reach an optimal or nearly optimal
    solution. Additionally, you will sample the values ![9](img/B16182_12_00c.png)
    from a uniform distribution for a population of 100\. By the end of this exercise,
    you will have evaluated the differences between starting from a fixed variable
    and sampling from a distribution:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目标是让你分析应用遗传算法（GAs）和梯度下降方法的差异，从一对变量和多种潜在解决方案开始。该算法通过应用选择、交叉和变异来帮助优化问题，达到最优或接近最优的解决方案。此外，你将从一个均匀分布中抽样100个样本的值![9](img/B16182_12_00c.png)。在本练习结束时，你将评估从固定变量开始和从分布中抽样之间的差异：
- en: Create a new Jupyter Notebook.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Jupyter Notebook。
- en: 'Import the `tensorflow` package and download and import `tensorflow_probability`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`tensorflow`包，并下载和导入`tensorflow_probability`：
- en: '[PRE8]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Define a function that outputs ![10](img/B16182_12_03d.png):'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，输出![10](img/B16182_12_03d.png)：
- en: '[PRE9]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Identify the initial step by defining the ![11](img/B16182_12_03e.png) variables
    with values of 5 and 10:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过定义值为5和10的![11](img/B16182_12_03e.png)变量来确定初始步长：
- en: '[PRE10]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Instantiate the optimizer by selecting the `tensorflow_probability` optimizer
    named `differential_evolution_minimize`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择名为`differential_evolution_minimize`的`tensorflow_probability`优化器来实例化优化器：
- en: '[PRE11]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Print the final values of ![34](img/B16182_12_03f.png), by using the `objective_value`
    and `position` functions:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`objective_value`和`position`函数打印![34](img/B16182_12_03f.png)的最终值：
- en: '[PRE12]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the application. You will get the following output. You can observe that
    the final values are identical to the `Step=25.0` value in *Figure 12.2*:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。你将获得以下输出。你可以观察到最终的值与*图 12.2*中`Step=25.0`的值是相同的：
- en: '[PRE13]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this exercise, the final optimal solution will be displayed. There are no
    additional optimization steps needed to reach the same solution as the gradient-based
    method. You can see that you are using fewer lines of code and that the time taken
    for the algorithm to converge is shorter.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本练习中，将显示最终的最优解。不需要额外的优化步骤来达到与基于梯度的方法相同的解决方案。你可以看到，你使用的代码行数更少，并且算法收敛所需的时间更短。
- en: 'For uniform optimization, the steps to modify the code are as follows:'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于均匀优化，修改代码的步骤如下：
- en: 'Import the `random` package:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`random`包：
- en: '[PRE14]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Initialize the population size and create the initial population sampling the
    ![33](img/B16182_12_03h.png) variables from a random uniform distribution of the
    population size:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化种群大小，并通过从种群大小的随机均匀分布中抽样![33](img/B16182_12_03h.png)变量来创建初始种群：
- en: '[PRE15]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Use the same optimizer, change the `initial_position` parameter to `initial_population`;
    use the same seed:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的优化器，将`initial_position`参数更改为`initial_population`；使用相同的种子：
- en: '[PRE16]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Print the final values of ![12](img/B16182_12_03i.png), by using the `objective_value`
    and `position` functions:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`objective_value`和`position`函数打印最终值！[12](img/B16182_12_03i.png)：
- en: '[PRE17]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output will be as follows:'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE18]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You will get the same result despite the variation in values. This means that
    we can randomly sample or choose a specific set of initial values, and the GA
    will still converge to the optimal solution faster, meaning we can improve our
    code by using fewer lines of code than if we'd used a gradient-based method.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管值有所不同，你仍然会得到相同的结果。这意味着我们可以随机采样或选择一组特定的初始值，遗传算法仍然会更快地收敛到最优解，这意味着我们可以通过使用比梯度法更少的代码行来改进我们的代码。
- en: Note
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2MQmlPr](https://packt.live/2MQmlPr).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 若要访问该特定部分的源代码，请参考[https://packt.live/2MQmlPr](https://packt.live/2MQmlPr)。
- en: You can also run this example online at [https://packt.live/2zpH6hJ](https://packt.live/2zpH6hJ).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在线运行这个例子，访问[https://packt.live/2zpH6hJ](https://packt.live/2zpH6hJ)。
- en: The solution will converge to the optimal values irrespective of the initial
    starting point, whether using a fixed value for the inputs or a random sampling
    of the population of chromosomes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 该解将收敛到最优值，无论初始起点如何，无论是使用固定的输入值还是随机采样的染色体种群。
- en: 'This section offered a general overview of evolutionary algorithms, explaining
    the differences between evolutionary strategies and GAs. You''ve had the opportunity
    to implement differential evolution using the `tensorflow_probabilities` package
    to optimize the solution of a loss function, analyzing the implementation of two
    different techniques: starting from fixed input values and using random sampling
    for the input values. You also had the opportunity to evaluate the implementation
    of GAs compared to gradient descent methods. GAs can use independent starting
    values and their convergence to a global optimum is faster and less prone to disturbances
    that gradient descent methods, whereas gradient descent is step-dependent and
    has higher sensitivity to the input variable.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了进化算法的概述，解释了进化策略和遗传算法（GA）之间的区别。你有机会使用`tensorflow_probabilities`包实现差分进化，以优化损失函数的解法，分析了两种不同技术的实现：从固定输入值开始和使用输入值的随机采样。你还可以评估遗传算法与梯度下降方法的实施。遗传算法可以使用独立的起始值，并且其收敛到全局最优解的速度更快，不容易受到梯度下降方法的干扰，而梯度下降方法是逐步依赖的，并且对输入变量更敏感。
- en: In the following section, we will build on the principles of developing GAs,
    starting with a look at population creation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将基于开发遗传算法的原则，首先从种群创建的角度开始。
- en: 'Components: Population Creation'
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件：种群创建
- en: In the previous section, you were introduced to evolutionary methods for function
    optimization. In this section, we will concentrate on population creation, fitness
    score creation, and the task of creating the genetic algorithm.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你已经了解了用于函数优化的进化方法。在本节中，我们将重点讨论种群创建、适应度得分创建以及创建遗传算法的任务。
- en: 'The population, ![32](img/B16182_12_03g.png), is identified as a group of individuals
    or chromosomes:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 种群，![32](img/B16182_12_03g.png)，被识别为一组个体或染色体：
- en: '![Figure 12.4: Expression for the population'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.4：种群表达式'
- en: '](img/B16182_12_04.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16182_12_04.jpg)'
- en: 'Figure 12.4: Expression for the population'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4：种群表达式
- en: Here, `s` represents the total number of chromosomes (population size) and `i`
    is the iteration. Each chromosome is a possible solution to the presented problem
    in an abstract form. For a binary problem, the population can be a matrix with
    randomly generated ones and zeros.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`s` 代表染色体的总数（种群大小），`i` 是迭代次数。每个染色体是以抽象形式表示的、对所提出问题的可能解决方案。对于二元问题，种群可以是一个随机生成的包含一和零的矩阵。
- en: 'The chromosome is a combination of input variables (genes):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 染色体是输入变量（基因）的组合：
- en: '![Figure 12.5: Expression for the chromosome'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.5：染色体表达式'
- en: '](img/B16182_12_05.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16182_12_05.jpg)'
- en: 'Figure 12.5: Expression for the chromosome'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5：染色体表达式
- en: Here, `m` is the maximum number of genes (or variables).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`m` 是基因（或变量）的最大数量。
- en: 'When translated to code, population creation can be demonstrated as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为代码后，种群创建可以如下所示：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Each chromosome is then compared using a fitness function:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每个染色体将通过适应度函数进行比较：
- en: '![Figure 12.6: Fitness function'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.6：适应度函数'
- en: '](img/B16182_12_06.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16182_12_06.jpg)'
- en: 'Figure 12.6: Fitness function'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6：适应度函数
- en: 'The fitness function can be translated to code as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 适应度函数可以通过如下方式转化为代码：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The output of the function is a score indicating how close the chromosome is
    to the target (optimal solution). The target is represented by the maximization
    of the fitness function. There cases where the optimization problem relies on
    minimizing a cost function. The function can be a mathematical one, a thermodynamic
    model, or a computer game. This can be done either by considering the chromosomes
    with low weightings (scores) or by adapting the cost function into a fitness one.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的输出是一个分数，表示染色体与目标（最优解）之间的接近程度。目标通过最大化适应度函数来表示。有些优化问题依赖于最小化一个成本函数。这个函数可以是数学函数、热力学模型，或者计算机游戏。这可以通过考虑权重较低（分数较低）的染色体，或者将成本函数转化为适应度函数来完成。
- en: Once the fitness function is identified and defined, the evolution process can
    start. The initial population is generated. A characteristic of the initial population
    is diversity. To offer this diversity, the elements can be randomly generated.
    To make the population evolve, the iterative process starts by selecting the parents
    that offer the best fit to start the reproduction process.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦适应度函数被识别并定义，进化过程就可以开始。初始种群被生成。初始种群的一个特点是多样性。为了提供这种多样性，元素可以是随机生成的。为了使种群进化，迭代过程从选择适应度最佳的父代开始，进而启动繁殖过程。
- en: 'Exercise 12.03: Population Creation'
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.03：种群创建
- en: 'In this exercise, we will be creating an original population of binary chromosomes
    of length 5\. Each chromosome should have eight genes. We will define a target
    solution and output the similarity of each chromosome to it. This exercise aims
    to allow you to design and establish the first set of steps for a GA and find
    the binary solution that fits the target. The exercise is similar to matching
    the output of a control system with a target:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个原始的二进制染色体种群，长度为5。每个染色体应该包含八个基因。我们将定义一个目标解，并输出每个染色体与目标的相似度。这个练习的目的是让你设计并建立GA的第一组步骤，并找到适应目标的二进制解。这个练习类似于将一个控制系统的输出与目标匹配：
- en: 'Create a new Jupyter Notebook. Import the `random` and `numpy` libraries:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Jupyter Notebook。导入`random`和`numpy`库：
- en: '[PRE21]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a function for the random population:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个生成随机种群的函数：
- en: '[PRE22]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Define a function for creating the target solution:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个创建目标解的函数：
- en: '[PRE23]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Define a function for calculating the fitness weighting for each chromosome:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数来计算每个染色体的适应度权重：
- en: '[PRE24]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code, you are comparing each chromosome of the population with
    the target and cataloging the similarity as a Boolean – `True` if similar or `False`
    if different – in the matrix called `identical_to_target`. Count all the elements
    that are true and output them as the weights.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，你正在将种群中的每个染色体与目标进行比较，并将相似度以布尔值的形式记录下来——如果相似则为`True`，如果不同则为`False`，这些值保存在名为`identical_to_target`的矩阵中。统计所有为`True`的元素，并将它们作为权重输出。
- en: 'Initialize the population with `5` chromosomes and `8` genes and calculate
    `weights`:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化种群，包含`5`个染色体和`8`个基因，并计算`weights`：
- en: '[PRE25]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, we calculate `population`, `target`, and `weights` based
    on the three developed functions.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们根据三个开发的函数计算`population`、`target`和`weights`。
- en: 'Print the target solution, the index of the chromosome, the chromosome, and
    the weight using a `for` loop:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`for`循环打印目标解、染色体的索引、染色体和权重：
- en: '[PRE26]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the application. You will get a similar output to this, as the population
    elements are randomized:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序，你将得到类似如下的输出，因为种群元素是随机化的：
- en: '[PRE27]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You will notice that each chromosome is compared to the target and the similarity
    (based on the fitness function) is printed out.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，每个染色体都会与目标进行比较，并且相似度（基于适应度函数）会被打印出来。
- en: Note
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2zrjadT](https://packt.live/2zrjadT).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2zrjadT](https://packt.live/2zrjadT)。
- en: You can also run this example online at [https://packt.live/2BSSeEG](https://packt.live/2BSSeEG).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在线运行这个例子，网址是[https://packt.live/2BSSeEG](https://packt.live/2BSSeEG)。
- en: 'This section showcased the first steps of genetic algorithm development: the
    generation of a random population, fitness score assignment for each element of
    the population (chromosome), and getting the number of elements that are the best
    fit compared to the target (in this case have the highest similarity with an optimal
    solution). The following sections will expand on the code generation that occurs
    until the optimal solution is reached. To do this, in the next section, you will
    explore the selection of the parents for the reproduction process.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了遗传算法开发的第一步：生成随机种群、为种群中的每个元素（染色体）分配适应度分数，以及获得与目标最匹配的元素数量（在此情况下与最优解的相似度最高）。接下来的章节将扩展代码生成，直到达到最优解。为了实现这一点，在下一节中，你将探索用于繁殖过程的父代选择。
- en: 'Components: Parent Selection'
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组成部分：父代选择
- en: The previous section showcased the concepts of populations; we looked at creating
    a target solution and comparing that solution with the elements (chromosomes)
    of the population. These concepts were implemented in an exercise that will be
    continued in this section. In this section, you will explore the concept of selection
    and implement two selection strategies.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节展示了种群的概念；我们讨论了创建目标解并将其与种群中的元素（染色体）进行比较。这些概念已在一个练习中实现，接下来将在本节继续。在本节中，你将探索选择的概念，并实现两种选择策略。
- en: 'For the reproduction process (which is the quintessential part of GAs, as they
    rely on creating future generations of stronger chromosomes), there are three
    steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于繁殖过程（这是遗传算法的核心部分，因为它依赖于创建更强的后代染色体），有三个步骤：
- en: Parent selection
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 父代选择
- en: Mixing the parents to create new children (crossover)
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 混合父代以创建新的子代（交叉）
- en: Replacing them with the children in the population
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用子代替代种群中的父代
- en: Selection essentially consists of choosing two or more parents for the mixing
    process. Once a fitness criterion is selected, the way in which the selection
    of the parents will be performed needs to be chosen, as does how many children
    will come from the parents. Selection is a vital step in performing genetic evolution,
    as it involves determining the children with the highest fitness. The most common
    way to select the best individuals is by the "survival of the fittest." This means
    the algorithm will improve the population in a step-by-step manner. The convergence
    of the GA is dependent upon the degree to which chromosomes with higher fitness
    are chosen. Therefore, the convergence speed is highly dependent on the successful
    selection of chromosomes. If the chromosomes with the highest fitness are prioritized,
    there is a chance that a sub-optimal solution will be found; if the candidates
    have consistently low fitness, then convergence will be extremely slow.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 选择本质上是选择两个或更多父代进行混合过程。一旦选择了适应度标准，就需要决定如何进行父代选择，以及将从父代中产生多少子代。选择是进行遗传进化的重要步骤，因为它涉及确定适应度最高的子代。选择最佳个体的最常见方法是通过“适者生存”。这意味着算法将逐步改进种群。遗传算法的收敛性依赖于选择更高适应度的染色体的程度。因此，收敛速度高度依赖于染色体的成功选择。如果优先选择适应度最高的染色体，可能会找到一个次优解；如果候选染色体的适应度始终较低，那么收敛将非常缓慢。
- en: 'The available selection methods are as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的选择方法如下：
- en: '**Top-to-bottom pairing**: This refers to creating a list of chromosomes and
    pairing them two by two. The chromosomes with odd indexes are paired with the
    even chromosomes, thus generating mother-father couples. The chromosomes at the
    top of the list are selected.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自上而下配对**：这是指创建一个染色体列表，并将其两两配对。奇数索引的染色体与偶数索引的染色体配对，从而生成母-父对。列表顶部的染色体会被选中。'
- en: '**Random Selection**: This involves using a uniform number generator to select
    the parents.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机选择**：这涉及使用均匀分布的数字生成器来选择父代。'
- en: '**Random Weighted Selection or a Roulette Wheel**: This involves calculating
    the probability of the suitability of a chromosome compared to the entire population.
    The selection of the parent is done randomly. The probability (weight) can be
    determined either by rank or fitness. The first approach (see *Figure 12.7*) relies
    on the rank of the chromosome ![31](img/B16182_12_06a.png), which can constitute
    the index of the chromosome in the population list, and ![30](img/B16182_12_06b.png)
    represents the number of required chromosomes (parents):![Figure 12.7: Probability
    using rank'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机加权选择或轮盘赌法**：这涉及到计算染色体相对于整个种群的适应度概率。父代的选择是随机进行的。概率（权重）可以通过排名或适应度来确定。第一种方法（见*图12.7*）依赖于染色体的排名
    (![31](img/B16182_12_06a.png))，它可以作为染色体在种群列表中的索引，![30](img/B16182_12_06b.png)
    表示所需的染色体数量（父代）：![图12.7：基于排名的概率'
- en: '](img/B16182_12_07.jpg)'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16182_12_07.jpg)'
- en: 'Figure 12.7: Probability using rank'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7：基于排名的概率
- en: 'The second approach (see *Figure 12.8*) relies on the fitness of the chromosome
    (![29](img/B16182_12_07a.png)) compared to the sum of the fitness of the entire
    population ( ![28](img/B16182_12_07b.png) ):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法（见*图12.8*）依赖于染色体的适应度 (![29](img/B16182_12_07a.png)) 与整个种群适应度之和的比较（![28](img/B16182_12_07b.png)）：
- en: '![Figure 12.8: Probability using chromosome fitness'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.8：基于染色体适应度的概率'
- en: '](img/B16182_12_08.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16182_12_08.jpg)'
- en: 'Figure 12.8: Probability using chromosome fitness'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：基于染色体适应度的概率
- en: 'As an alternative, the probability (see *Figure 12.9*) can also be calculated
    based on the fitness of the chromosome (![13](img/B16182_12_08a.png)) compared
    with the highest fitness of the population ![14](img/B16182_12_08b.png). In all
    of the cases, the probabilities are compared to the randomly selected numbers
    to identify the parents with the best weights:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，概率（见*图12.9*）也可以基于染色体的适应度 (![13](img/B16182_12_08a.png)) 与种群中最高适应度的比较来计算 (![14](img/B16182_12_08b.png))。在所有这些情况下，概率将与随机选择的数字进行比较，以识别具有最佳权重的父代：
- en: '![Figure 12.9: Probability using the highest fitness of the population'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.9：基于种群中最高适应度的概率'
- en: '](img/B16182_12_09.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16182_12_09.jpg)'
- en: 'Figure 12.9: Probability using the highest fitness of the population'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9：基于种群中最高适应度的概率
- en: '**Selection by Tournament**: This method is based on the random selection of
    a subset of chromosomes, out of which the chromosome with the highest fitness
    is selected as a parent. This repeats until the required number of parents is
    identified.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**锦标赛选择法**：该方法基于从染色体子集中随机选择染色体，其中适应度最高的染色体被选为父代。这个过程会重复，直到确定所需数量的父代。'
- en: The roulette wheel and tournament techniques are among the most popular selection
    methods implemented in GAs, as they are inspired by biological processes. The
    problem with the roulette technique is that it can be noisy, and depending on
    which type of selection is used, the convergence rate can be affected. A benefit
    of the tournament method is that it can deal with large populations, leading to
    smoother convergence. The roulette wheel method is used to include random elements
    in the population, whereas when you are aiming to identify the parents with the
    highest similarity to the target, you use the tournament method. The following
    exercise will enable you to implement the tournament and roulette wheel techniques
    and evaluate your understanding of them.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 轮盘赌和锦标赛技术是遗传算法中最常用的选择方法，因为它们受到生物过程的启发。轮盘赌方法的问题是它可能会有噪音，而且根据所使用的选择类型，收敛速度可能会受到影响。锦标赛方法的一个优点是它可以处理大规模种群，从而实现更平滑的收敛。轮盘赌方法用于在种群中加入随机元素，而当你希望识别与目标最相似的父代时，则使用锦标赛方法。以下练习将帮助你实现锦标赛和轮盘赌技术，并评估你对它们的理解。
- en: 'Exercise 12.04: Implementing the Tournament and Roulette Wheel Techniques'
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.04：实现锦标赛和轮盘赌选择技术
- en: 'In the exercise, you will implement the tournament and roulette wheel methods
    for the population of binary chromosomes of *Exercise 12.02, Implementing Fixed
    Value and Uniform Distribution Optimization Using GAs*. Each chromosome should
    have eight genes. We will define a target solution and print two sets of parents:
    one based on the tournament method and the other by roulette from the remaining
    population. Once each parent is chosen, set the fitness rank to the minimum:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，你将实现锦标赛选择和轮盘选择方法，针对的是 *Exercise 12.02, Implementing Fixed Value and Uniform
    Distribution Optimization Using GAs* 中的二进制染色体种群。每个染色体应该包含八个基因。我们将定义一个目标解决方案，并打印出两组父母：一组基于锦标赛方法，另一组基于轮盘选择，从剩余种群中选出。每次选择父母后，适应度排名都将设为最小值：
- en: 'Create a new Jupyter Notebook. Import the `random` and `numpy` libraries:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Jupyter Notebook，导入 `random` 和 `numpy` 库：
- en: '[PRE28]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a function for the random population:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于生成随机种群的函数：
- en: '[PRE29]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Define a function for creating the target solution:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，用于创建目标解决方案：
- en: '[PRE30]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Define a function for calculating the fitness weighting for each chromosome:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，用于计算每个染色体的适应度权重：
- en: '[PRE31]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Define a function for selecting the pair of parents with the highest weighting
    (the highest fitness score). Since the population is reduced, the chromosomes
    are competing more. This method is also known as tournament selection:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，用于选择权重最高（适应度评分最高）的父母对。由于种群规模缩小，染色体之间的竞争更加激烈。这个方法也被称为锦标赛选择：
- en: '[PRE32]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a function for the roulette wheel by selecting a random number from
    a uniform distribution:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个轮盘函数，通过从均匀分布中选择一个随机数来实现：
- en: '[PRE33]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the function, calculate the sum of all the fitness scores:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数中，计算所有适应度评分的总和：
- en: '[PRE34]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Calculate the probability of the fitness of the chromosome compared to the
    sum of all fitness scores and compared to the chromosome with the highest fitness
    score:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算染色体的适应度概率，与所有适应度评分的总和以及与适应度最高的染色体相比：
- en: '[PRE35]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Run through all the chromosomes and select the parent that has a higher fitness
    probability compared to the sum of fitness scores higher than the `draw`, or the
    parent with the highest probability compared to the maximum fitness score:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历所有染色体，选择适应度概率更高的父母，条件是其适应度评分总和高于 `draw`，或者其适应度评分比最大适应度评分的父母概率更高：
- en: '[PRE36]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Initialize `population`, calculate `target` and the fitness scores, and print
    the scores and `target`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化 `population`，计算 `target` 和适应度评分，并打印出评分和 `target`：
- en: '[PRE37]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You will get a similar output to this:'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将会得到类似于这样的输出：
- en: '[PRE38]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Apply the first selection method and print out the parents and the new scores:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用第一个选择方法，并打印出父母和新的评分：
- en: '[PRE39]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You will get a similar output to this for the tournament selection process:'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将会看到锦标赛选择过程的类似输出：
- en: '[PRE40]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You can observe that for parent 1, the score has been replaced with `0`. For
    parent 2, the score stays the same.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以观察到，对于父母 1，分数已被替换为 `0`。对于父母 2，分数保持不变。
- en: 'Use the roulette function to select the next two parents and print out the
    parents and the weights:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用轮盘函数选择下一个父母对，并打印出父母和权重：
- en: '[PRE41]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You will have a similar output to this:'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将会看到类似于这样的输出：
- en: '[PRE42]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You can see that parents 2 and 3 are the same. This time, the weight for the
    respective parent is changed to 0\. Additionally, parent 4 is selected and has
    its weighting changed to 0.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到父母 2 和父母 3 是相同的。这一次，父母的权重被修改为 0。此外，父母 4 被选中，并且它的权重也被改为 0。
- en: Note
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2MTsKJO](https://packt.live/2MTsKJO).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 若要访问该部分的源代码，请参考 [https://packt.live/2MTsKJO](https://packt.live/2MTsKJO)。
- en: You can also run this example online at [https://packt.live/2YrwMhP](https://packt.live/2YrwMhP).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在线运行这个示例，网址是 [https://packt.live/2YrwMhP](https://packt.live/2YrwMhP)。
- en: With this exercise, you have implemented a tournament-like method, by selecting
    the parents with the highest scores, and the roulette wheel selection technique.
    Also, you have developed a method of avoiding the double-selection of the same
    chromosome. The first set of parents was chosen using the first method, whereas
    the second method was used in selecting the second set of parents. We have also
    identified a need for a method of replacing indexes to avoid double-selection
    of the same chromosome, which is one of the pitfalls of the selection process.
    This helped you to understand the differences between the two methods and allowed
    you to put into practice GA-related methods from population generation to selection.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个练习，你实现了一种类似锦标赛的方法，通过选择得分最高的父代，以及轮盘选择技术。同时，你还开发了一种避免重复选择相同染色体的方法。第一组父代是使用第一种方法选择的，而第二种方法用于选择第二组父代。我们还发现需要一种替换索引的方法，以避免重复选择相同的染色体，这是选择过程中可能出现的陷阱之一。这帮助你理解了这两种方法之间的差异，并使你能够将与遗传算法相关的方法从种群生成到选择实际运用。
- en: 'Components: Crossover Application'
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件：交叉应用
- en: This section expands on recombining the genetic code of the parents by means
    of crossover into children (that is, the creation of the two child solutions by
    combining and re-organizing the code of the two parents). Various techniques can
    be used to create new solutions for generating a new population. The binary information
    of two viable solutions in machine learning can be recombined by a process called
    crossover, which is similar to biological genetic exchange, where genetic information
    is transmitted from parents to children. Crossover ensures that the genetic material
    of a solution is transmitted to the next generation.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 本节扩展了通过交叉将父代的遗传代码重组到子代中的方法（即通过结合和重新组织两个父代的代码创建两个子代解决方案）。可以使用各种技术来创建新的解决方案，从而生成新的种群。机器学习中两个有效解的二进制信息可以通过一种称为交叉的过程重新组合，这类似于生物遗传交换，其中遗传信息从父代传递到子代。交叉确保了解决方案的遗传物质传递到下一代。
- en: 'Crossover is the most common form of reproduction technique, or mating. Between
    the first and last bits of the parents (selected chromosomes), the crossover point
    represents the splitting point of the binary code that will be passed onto the
    children (offspring): the part to the left of the crossover point of the first
    parent will be inherited by the first child, and everything to the right side
    of the crossover point of the second parent will become the part of the first
    child. The left side of the second parent combined with the right side of the
    first parent results in the second child:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉是最常见的繁殖技术或交配方式。在父代（选定染色体）的第一个和最后一个基因之间，交叉点表示二进制代码的分裂点，这些代码将传递给子代（后代）：第一个父代交叉点左侧的部分将由第一个子代继承，而第二个父代交叉点右侧的部分将成为第一个子代的一部分。第二个父代的左侧部分与第一个父代的右侧部分结合，形成第二个子代：
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'There are multiple crossover techniques, as listed follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种交叉技术，如下所示：
- en: Single-point crossover (which you can see in the preceding code) involves splitting
    the genetic code of the parents at one point and passing the first part to the
    first child, and the second part to the second child. It is used by traditional
    GAs; the crossover point is identical for both chromosomes and is selected randomly.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单点交叉（你可以在前面的代码中看到）涉及在一个点上分割父代的遗传代码，并将第一部分传递给第一个子代，第二部分传递给第二个子代。传统遗传算法使用这种方法；交叉点对于两个染色体是相同的，并且是随机选择的。
- en: Two-point crossover involves two crossover points impacting the gene exchange
    between the two parents. The more crossover points are introduced, the more the
    performance of the GA can be reduced as the genetic makeup is lost. However, introducing
    two-point crossover can lead to a better exploration of the state or parameter
    space.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两点交叉涉及两个交叉点，影响两个父代之间的基因交换。引入更多的交叉点可能会降低遗传算法的性能，因为遗传信息会丧失。然而，采用两点交叉可以更好地探索状态或参数空间。
- en: Multi-point crossover involves a number of splits. If the number of splits is
    even, then the splits are selected randomly and the sections in the chromosome
    are exchanged. If the number is odd, then the splits are alternating the exchanges
    of section.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多点交叉涉及多个分裂。如果分裂次数是偶数，那么分裂点是随机选择的，染色体中的各部分会交换。如果次数是奇数，则交换的部分是交替进行的。
- en: Uniform crossover involves the random selection (as in a coin toss) of the parent
    that will provide an element of the chromosome (gene).
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 均匀交叉涉及随机选择（如同抛硬币一样）一个父代，提供染色体（基因）中的某个元素。
- en: Three-parent crossover entails the comparison of each gene between two parents.
    If they have the same value, the child inherits the gene; if not, the child inherits
    the gene from the third parent.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三父代交叉涉及对比两个父代的每个基因。如果它们的值相同，子代继承该基因；如果不同，子代从第三个父代继承该基因。
- en: 'Consider the following code example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下代码示例：
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding code, we define the crossover function between two parents.
    We have defined the parents separately and then randomly assigned a certain point
    for crossover. Then, we have defined the children to be created by joining the
    parents at the defined crossover point.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了两个父代之间的交叉函数。我们分别定义了父代，然后随机指定一个交叉点。接着，我们定义了通过在定义的交叉点将父代结合起来创建子代。
- en: In the following exercise, you will continue the process of implementing the
    components of GAs to create child chromosomes.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，你将继续实现遗传算法的组件，创建子代染色体。
- en: 'Exercise 12.05: Crossover for a New Generation'
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.05：为新一代实施交叉
- en: 'In this exercise, we will be implementing crossover between two parents, for
    a new generation. Following the steps from *Exercise 12.04, Implementing Tournament
    and Roulette Wheel*, and using the chromosomes with the highest weight, we will
    apply single-point crossover to create the first new set of children:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现两个父代之间的交叉，以生成新的子代。按照*练习 12.04：实现锦标赛和轮盘赌*中的步骤，并使用权重最高的染色体，我们将应用单点交叉来创建第一组新的子代：
- en: 'Create a new Jupyter Notebook. Import the `random` and `numpy` libraries:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Jupyter Notebook。导入`random`和`numpy`库：
- en: '[PRE45]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create the function for a random population:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个随机种群的函数：
- en: '[PRE46]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As you can see in the previous code, we have created a `population` function.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你在前面的代码中所见，我们已经创建了一个`population`函数。
- en: 'Define a function to create the target solution:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数来创建目标解：
- en: '[PRE47]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Define a function for calculating the fitness weighting for each chromosome:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数来计算每个染色体的适应度权重：
- en: '[PRE48]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Define a function for selecting the pair of parents with the highest weighting
    (highest fitness score). Since the population is smaller, the chromosomes are
    competing more. This method is also known as tournament selection:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数来选择具有最高权重（最高适应度得分）的父代对。由于种群较小，染色体之间的竞争更为激烈。此方法也被称为锦标赛选择：
- en: '[PRE49]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Define a function for crossover by using a randomly selected crossover point:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个使用随机选择的交叉点的交叉函数：
- en: '[PRE50]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Initialize the population with `5` chromosomes and `8` genes and calculate
    `weights`:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化种群，设置`5`个染色体和`8`个基因，并计算`权重`：
- en: '[PRE51]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Print the `target` solution:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印`目标`解：
- en: '[PRE52]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output will be as follows:'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE53]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Select the parents with the highest weight and print the final selection:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择权重最高的父代并打印最终选择：
- en: '[PRE54]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output will be as follows:'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE55]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Apply the `crossover` function and print the children:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用`crossover`函数并打印子代：
- en: '[PRE56]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The output will be as follows:'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE57]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Run the application.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。
- en: 'You will get a similar output to that shown in the following snippet. As you
    can see, the population elements are randomized. Check that the elements of `Child
    1` and `Child 2` are the same as those of `Parent 1` and `Parent 2`:'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将获得与以下代码片段相似的输出。正如你所见，种群元素是随机化的。检查`Child 1`和`Child 2`的元素是否与`Parent 1`和`Parent
    2`的元素相同：
- en: '[PRE58]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You can check that the starting elements from the crossover point in the array
    of `Child 1` have the same array elements as `Parent 2`, and that `Child 2` has
    the same array elements as `Parent 1`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以检查`Child 1`的交叉点之后的元素与`Parent 2`的数组元素是否相同，且`Child 2`的元素与`Parent 1`的数组元素相同。
- en: Note
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/30zHbup](https://packt.live/30zHbup).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考[https://packt.live/30zHbup](https://packt.live/30zHbup)。
- en: You can also run this example online at [https://packt.live/3fueZxx](https://packt.live/3fueZxx).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在网上运行这个示例：[https://packt.live/3fueZxx](https://packt.live/3fueZxx)。
- en: 'In this section, we identified the various strategies for the recombination
    technique known as crossover. A basic implementation of single-point crossover,
    where the crossover point is randomly generated, was represented. In the following
    section, we will examine the last element of GA design: population mutation.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们识别了称为交叉的重新组合技术的各种策略。展示了随机生成交叉点的单点交叉的基本实现。在接下来的章节中，我们将讨论遗传算法设计的最后一个元素：群体变异。
- en: 'Components: Population Mutation'
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件：群体变异
- en: In the previous sections, you have implemented population generation, parent
    selection, and crossover reproduction. This section will concentrate on the application
    of random mutation and the repetition of child generations until a new population
    size is achieved and weights (fitness scores) for the population of the genetic
    algorithm are assigned. This section will include an explanation of the mutation
    technique. This will be followed by a presentation of the available mutation techniques
    as well as a discussion about population replacement. Finally, an exercise implementing
    mutation techniques will be presented.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你已经实现了群体生成、父代选择和交叉繁殖。本节将集中讨论随机变异的应用，以及重复生成子代直到达到新的群体大小，并为遗传算法群体分配权重（适应度评分）。本节将包括对变异技术的解释。接下来将介绍可用的变异技术，并讨论群体替换。最后，将提供一个实施变异技术的练习。
- en: A caveat of gradient methods is that the algorithms can stop at a local optimum
    solution. To prevent this from happening, mutations can be introduced to the population
    of solutions. Mutation generally occurs after the crossover process. Mutation
    relies on randomly assigning binary information in either a set of chromosomes
    or in the entire population. Mutation provides an avenue of problem space exploration
    by introducing a random change in the population. This technique prevents rapid
    convergence and encourages the exploration of new solutions. In the final steps
    (the last generations) or when the optimal solution is reached, mutation ceases
    to be applied.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度方法的一个警告是算法可能会停留在局部最优解。为了防止这种情况发生，可以向解决方案群体引入变异。变异通常发生在交叉过程之后。变异依靠随机分配二进制信息，可以是在染色体集合中，也可以是在整个群体中。变异通过引入群体中的随机变化来提供问题空间的探索途径。这种技术防止了快速收敛，并鼓励探索新的解决方案。在最后几代（最后的世代）或者达到最优解时，变异不再被应用。
- en: 'There are various mutation techniques, as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种变异技术，如下：
- en: Single-point mutation (flipping) involves randomly selecting genes from different
    chromosomes and changing their binary values to their opposites (from 0 to 1 and
    1 to 0).
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单点变异（翻转）涉及随机选择不同染色体的基因，并将它们的二进制值更改为它们的相反值（从0到1，从1到0）。
- en: Interchanging involves selecting two sections of the chromosome of one parent
    and swapping them, thus generating a new child.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交换涉及选择一个父代染色体的两个部分并交换它们，从而生成一个新的子代。
- en: You can also reverse a randomly selected segment within the parent or the population
    of chromosomes, and all the binary values are changed to their opposites.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还可以在父代或染色体群体中随机选择一个段落进行反转，所有的二进制值都会变成它们的相反值。
- en: The occurrence of a mutation is determined by its probability. The probability
    defines the frequency at which mutations occur within the population. If the probability
    is 0%, then after the crossover, the children are unaltered; if a mutation occurs,
    one or more parts of the chromosome or the population are changed. If the probability
    is 100%, then the entire chromosome is changed.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 变异的发生由其概率决定。概率定义了在群体内发生变异的频率。如果概率为0%，那么在交叉后，子代不变；如果发生变异，染色体或整个群体的一部分将被改变。如果概率为100%，则整个染色体都将被改变。
- en: After the mutation process occurs, the fitness of the new children is calculated,
    and the population is altered to include them. This leads to a new generation
    of the population. Depending on the strategy used, the parents with the lowest
    fitness scores are discarded to leave room for the newly generated children.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 变异过程发生后，计算新子代的适应度，并将它们包含在群体中。这导致了群体的新一代。根据使用的策略，适应度最低的父代被丢弃，以给新生成的子代腾出位置。
- en: 'Exercise 12.06: New Generation Development Using Mutation'
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.06：使用变异开发新的子代
- en: 'In this exercise, we will be focusing on the development of a new generation.
    We will again create a new population, select two parent chromosomes, and use
    crossover to develop two children. We will then add the two new chromosomes to
    the population and mutate the entire population with a probability of 0.05:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将专注于新一代的开发。我们将再次创建一个新种群，选择两个父代染色体，并使用交叉操作来生成两个子代。然后我们将这两个新染色体添加到种群中，并以0.05的概率对整个种群进行突变：
- en: 'Create a new Jupyter Notebook. Import the `random` and `numpy` libraries:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Jupyter Notebook。导入`random`和`numpy`库：
- en: '[PRE59]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create a function for the random population:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于生成随机种群的函数：
- en: '[PRE60]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Define a function to create the target solution:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个创建目标解的函数：
- en: '[PRE61]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Define a function to calculate the fitness weighting for each chromosome:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数来计算每个染色体的适应度权重：
- en: '[PRE62]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Define a function to select the pair of parents with the highest weighting
    (highest fitness score). Since the population is small, the chromosomes are competing
    more. This method is also known as tournament selection:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数来选择具有最高权重（最高适应度得分）的父代对。由于种群较小，染色体之间的竞争更为激烈。这种方法也称为锦标赛选择：
- en: '[PRE63]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Define a function for crossover by using a randomly selected crossover point:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个使用随机选择交叉点的交叉函数：
- en: '[PRE64]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Define a function for a mutation that uses the probability and the population
    as inputs:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个突变函数，使用概率和种群作为输入：
- en: '[PRE65]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In the preceding code snippet, the condition set for the mutation selection
    is to check that each element of the array is higher than the mutation probability
    which acts as a threshold. If the element is higher than the threshold, mutation
    is applied.
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，设置突变选择的条件是检查数组中的每个元素是否大于突变概率，该概率作为阈值。如果元素大于阈值，则应用突变。
- en: 'Append the array of `children` to the original population, creating a new crossover
    `population`, and use the `print()` function to display it:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`children`数组附加到原始种群中，创建一个新的交叉`population`，并使用`print()`函数显示它：
- en: '[PRE66]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output will be as follows:'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE67]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, append `population` with `children`:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`population`与`children`合并：
- en: '[PRE68]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The population will be as follows:'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 种群将如下所示：
- en: '[PRE69]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Use the crossover population and the mutation probability of `0.05` to create
    a new population and display the mutated population:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用交叉种群和突变概率`0.05`来创建一个新种群，并显示突变后的种群：
- en: '[PRE70]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: As you can see, the threshold(mutation_probability) is 0.05\. Hence, if the
    elements are higher than this threshold, they will incur a mutation (so there
    is a 95% chance of the mutation occurring to the gene).
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，阈值（mutation_probability）是0.05。因此，如果元素大于这个阈值，它们将发生突变（所以基因发生突变的几率是95%）。
- en: 'The output will be as follows:'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE71]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: You will get a similar output as the population elements are randomized. You
    can see that the chromosomes resulting from crossover are added to the original
    population and that after mutation, the population has the same number of chromosomes,
    but the genes are different. The crossover and mutation steps can be repeated
    until the target solution is reached by looping the functions. These cycles are
    also known as generations.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到一个类似的输出，因为种群元素是随机化的。你可以看到交叉操作生成的染色体被添加到原始种群中，且在突变后，种群的染色体数量相同，但基因不同。交叉和突变步骤可以通过循环函数重复，直到达到目标解。这些循环也被称为代。
- en: Note
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3dXaBqi](https://packt.live/3dXaBqi).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考 [https://packt.live/3dXaBqi](https://packt.live/3dXaBqi)。
- en: You can also run this example online at [https://packt.live/2Ysc5Cl](https://packt.live/2Ysc5Cl).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在网上运行这个示例，网址是 [https://packt.live/2Ysc5Cl](https://packt.live/2Ysc5Cl)。
- en: In this section, mutation was described. The benefit of mutation is that it
    introduces random variation to chromosomes, encouraging exploration and helping
    to avoid local optima. Various mutation techniques were presented. The example
    we used showed the impact of mutation probability by implementing reverse mutation
    on a population after the crossover process was finalized.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，描述了突变的概念。突变的好处在于它为染色体引入了随机变异，促进了探索，并帮助避免局部最优。介绍了不同的突变技术。我们使用的示例展示了通过在交叉过程完成后对种群实施反向突变来观察突变概率的影响。
- en: Application to Hyperparameter Selection
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用于超参数选择
- en: In this section, we will explore the use of GAs for parameter selection, especially
    when using neural networks. GAs are widely used for optimization problems in scheduling
    in both production and railway management. The solutions to these types of problems
    rely on creating a combination of neural networks and GAs as function optimizers.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨遗传算法（GAs）在参数选择中的应用，尤其是在使用神经网络时。遗传算法广泛应用于生产调度和铁路管理中的优化问题。这类问题的解决方案依赖于将神经网络与遗传算法结合，作为函数优化器。
- en: The exercise in this section provides a platform for tuning hyperparameters
    for a neural network to predict wind flow patterns. You will apply a simple genetic
    algorithm to optimize the values of the hyperparameters used to train a neural
    network.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的练习提供了一个平台，用于调整神经网络的超参数，以预测风流模式。您将应用一个简单的遗传算法来优化用于训练神经网络的超参数值。
- en: '**Artificial Neural Networks** (**ANNs**) model the biological processes and
    structures of neurons in the brain. The neurons in ANNs rely on a combination
    of input information (parameters) and weights. The product (which has an added
    bias) passes through a transfer function, which is a set of neurons arranged in
    parallel with each other to form a layer.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**人工神经网络**（**ANNs**）模拟了大脑中神经元的生物学过程和结构。人工神经网络中的神经元依赖于输入信息（参数）和权重的组合。该乘积（加上偏置）通过传递函数，这是一组并行排列的神经元，形成一个层。'
- en: For weight and bias optimization, ANNs use gradient descent methods for their
    training processes and backpropagation processes. This impacts the development
    of the neural network, as before training even commences, the neural network topology
    needs to be fully designed. Because the design is pre-set, some neurons may not
    be used in the training process, but they may still be active, therefore making
    them redundant. Additionally, neural networks using gradient methods can become
    stuck at a local optimum, and therefore need to rely on alternative methods to
    help them continue their processes, such as regularization, ridge regression,
    or lasso regression. ANNs are widely used in speech recognition, feature detection
    (whether for image, topology, or signal processing), and disease detection.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 对于权重和偏置优化，人工神经网络使用梯度下降法进行训练和反向传播过程。这影响了神经网络的发展，因为在训练开始之前，神经网络拓扑结构需要完全设计。由于设计是预设的，某些神经元在训练过程中可能没有被使用，但它们可能仍然处于活跃状态，因此变得冗余。此外，使用梯度方法的神经网络可能会陷入局部最优，因此需要依赖其他方法来帮助其继续处理，如正则化、岭回归或套索回归。人工神经网络广泛应用于语音识别、特征检测（无论是图像、拓扑还是信号处理）和疾病检测。
- en: To prevent these problems and enhance the training of neural networks, GAs can
    be implemented. GAs are used for function optimization, while crossover and mutation
    techniques help with problem space exploration. Initially, GAs were used to optimize
    the weights and number of nodes of neural networks. For this, the chromosomes
    of the GA are encoded with possible variations of weights and nodes. The fitness
    function generated by the ANN relies on the mean squared error of the potential
    values and the exact values of the parameters.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这些问题并增强神经网络的训练，遗传算法可以被实现。遗传算法用于函数优化，而交叉和变异技术则有助于问题空间的探索。最初，遗传算法被用于优化神经网络的权重和节点数。为此，遗传算法的染色体编码了可能的权重和节点变动。神经网络生成的适应度函数依赖于潜在值与参数的实际值之间的均方误差。
- en: However, research has expanded to implementations of **Recurrent Neural Networks**
    (**RNNs**) and combining them with RL, aiming towards multi-processor performance.
    An RNN is a type of ANN that produces outputs that are not only a result of the
    weighting process of the input but also of a vector containing previous input
    and outputs. This enables the neural network to maintain prior knowledge of previous
    training instances.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，研究已经扩展到**递归神经网络**（**RNNs**）的实现，并将其与强化学习（RL）结合，旨在提高多处理器性能。递归神经网络是一种人工神经网络（ANN），其输出不仅是输入加权过程的结果，还包含了一个包含先前输入和输出的向量。这使得神经网络能够保持对先前训练实例的知识。
- en: GAs serve in expanding the topology of the neural networks beyond weighting
    adjustments. One example is EDEN, whereby encoding is done within the chromosome
    and the architecture of the network, and the learning rate achieves high accuracy
    rates on multiple TensorFlow datasets. One of the most challenging problems in
    training neural networks is the quality of the features (or input hyperparameters)
    that are fed to the network. If the parameters are not appropriate, the mapping
    of inputs and outputs will be erroneous. Therefore, GAs can act as a wrapper alternative
    to the ANNs by optimizing the selection of features.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法有助于扩展神经网络的拓扑结构，超越权重调整。一例是 EDEN，其中编码在染色体内进行，并且网络架构和学习率在多个 TensorFlow 数据集上实现了高精度。训练神经网络时，最具挑战性的问题之一是馈送给网络的特征（或输入超参数）的质量。如果参数不合适，输入和输出的映射将会错误。因此，遗传算法可以作为人工神经网络的替代方法，通过优化特征选择来发挥作用。
- en: The following exercise will teach you how to apply a simple genetic algorithm
    to identify the optimal parameters (window size and number of units) for an RNN.
    The genetic algorithm implemented is using the `deap` package, through the `eaSimple()`
    function, which enables you to create, using toolbox-based code, a simple GA that
    includes population creation, selection through the `selRandom()` function, reproduction
    through the `cxTwoPoint()` function, and mutation through the `mutFlipBit()` function.
    For comparing and hyperparameter selection, the `selBest()` function is used.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习将教你如何应用简单的遗传算法来识别 RNN 的最佳参数（窗口大小和单元数量）。所实现的遗传算法使用 `deap` 包，通过 `eaSimple()`
    函数，可以使用基于工具箱的代码创建一个简单的遗传算法，包括种群创建、通过 `selRandom()` 函数进行选择、通过 `cxTwoPoint()` 函数进行交叉和通过
    `mutFlipBit()` 函数进行变异。为了进行比较和超参数选择，使用 `selBest()` 函数。
- en: 'Exercise 12.07: Implementing GA Hyperparameter Optimization for RNN Training'
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.07：为 RNN 训练实现遗传算法超参数优化
- en: 'Our goal in this exercise is to identify the best hyperparameters to use for
    an RNN using a simple genetic algorithm. In this exercise, we are using a dataset
    that was part of a weather forecasting challenge in 2012\. A single feature, `wp2`,
    is used in the training and validation of the parameters. The two hyperparameters
    used are the number of units and the window size. These hyperparameters represent
    the genetic material for the chromosome:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 本次练习的目标是通过简单的遗传算法识别 RNN 使用的最佳超参数。在本次练习中，我们使用的是一个 2012 年天气预报挑战赛中的数据集。训练和验证参数时仅使用一个特征
    `wp2`。使用的两个超参数是单元数量和窗口大小。这些超参数代表染色体的遗传物质：
- en: Note
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The dataset can be found in the GitHub repository at the following link: https://packt.live/2Ajjz2F.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集可以在以下 GitHub 仓库中找到：https://packt.live/2Ajjz2F。
- en: 'The original dataset can be found at the following link: https://www.kaggle.com/c/GEF2012-wind-forecasting/data.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据集可以在以下链接找到：https://www.kaggle.com/c/GEF2012-wind-forecasting/data。
- en: 'Create a new Jupyter Notebook. Import the `pandas` and `numpy` libraries and
    functions:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Jupyter Notebook。导入 `pandas` 和 `numpy` 库及其函数：
- en: '[PRE72]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: From the `sklearn` package, import `mean_squared_error` and `train_test_split`.
    Also, from the `tensorflow` and `keras` packages, import `SimpleRNN`, `Input`,
    `Dense` (from the `layers` folder), and the model (from the `Model` class). To
    create the GA, it is necessary to call from the `deap` package `base`, `creator`,
    `tools`, and `algorithms`. For statistics, we are using the Bernoulli equation;
    therefore, we will call `bernoulli` from the `scipy.stats` package. From `bitstrings`,
    we will call `BitArray`.
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从 `sklearn` 包中导入 `mean_squared_error` 和 `train_test_split`。同时，从 `tensorflow`
    和 `keras` 包中导入 `SimpleRNN`、`Input`、`Dense`（来自 `layers` 文件夹）和模型（来自 `Model` 类）。为了创建遗传算法，必须从
    `deap` 包中调用 `base`、`creator`、`tools` 和 `algorithms`。对于统计学，我们使用的是伯努利方程；因此，我们将从
    `scipy.stats` 包中调用 `bernoulli`。从 `bitstrings` 中，我们将调用 `BitArray`。
- en: 'Use a random seed for model development; `998` is an initialization number
    for the seed:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用随机种子进行模型开发；`998` 是种子的初始化数字：
- en: '[PRE73]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Load data from the `train.csv` file, use `np.reshape()` to modify the data
    into an array that only contains column `wp2`, and select the first 1,501 elements:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `train.csv` 文件加载数据，使用 `np.reshape()` 将数据修改为只包含 `wp2` 列的数组，并选择前 1,501 个元素：
- en: '[PRE74]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Define a function to split the dataset based on window size:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，根据窗口大小划分数据集：
- en: '[PRE75]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Define a function to train the RNN to identify the optimal hyperparameters
    using a simple genetic algorithm:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，通过简单的遗传算法训练 RNN，识别最佳超参数：
- en: '[PRE76]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The first step is identifying the sections of the chromosome pertaining to window
    size and the number of units. The next step is to return an extremely high fitness
    score, if there are no window sizes or the number of units. Split the two arrays
    into training and validation arrays with a 90:10 split.
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一阶段是识别与窗口大小和单元数量相关的染色体部分。接下来，如果没有窗口大小或单元数量，则返回一个极高的适应度得分。将两个数组按90:10的比例分割为训练数组和验证数组。
- en: 'Initialize the input features, and use the `SimpleRNN` model with the training
    dataset. For optimization, use the Adam algorithm with mean squared error as the
    loss function. To train the model, use the `fit` function with `5` for `epochs`
    and a batch size of `4`. To generate the predicted values, use the input values
    stored in `X_validate` in the `predict` function for the model. Calculate the
    `RMSE`:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化输入特征，并使用训练数据集训练`SimpleRNN`模型。为了优化，使用Adam算法，并将均方误差作为损失函数。为了训练模型，使用`fit`函数，设置`epochs`为`5`，批次大小为`4`。要生成预测值，使用存储在`X_validate`中的输入值，在模型的`predict`函数中进行预测。计算`RMSE`：
- en: '[PRE77]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Instantiate the population size, the number of generations used for the genetic
    algorithm, and the length of the gene with `4`, `5`, and `10`, respectively:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化种群大小、遗传算法使用的代数和基因长度，分别设置为`4`、`5`和`10`：
- en: '[PRE78]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Use the toolbox available in the `deap` package to instantiate the genetic
    algorithm, `eaSimple()`. To do this, use the creator tool to instantiate the fitness
    function as `RMSE`:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`deap`包中的工具箱实例化遗传算法，`eaSimple()`。为此，使用创建器工具将适应度函数实例化为`RMSE`：
- en: '[PRE79]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The last few lines of the output will be as follows:'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出的最后几行如下所示：
- en: '[PRE80]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The lower the `RMSE` value, the better the hyperparameters. The Bernoulli distribution
    serves to randomly initialize the chromosome genes. Based on the chromosome, the
    population is initialized. Within the toolbox, there are four steps for creating
    a new population: `cxTwoPoint()` refers to the parents crossing information at
    two points in a crossover), `mutFlipBit()` will only mutate one of the elements
    of the chromosome with a `0.6` probability of occurrence), `selRandom()` function),
    **evaluate** (this uses the RNN training function from *Step 6* and *Step 7*).'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`RMSE`值越低，超参数越好。伯努利分布用于随机初始化染色体基因。基于染色体，初始化种群。在工具箱中，创建新种群有四个步骤：`cxTwoPoint()`表示父代在两个点交叉信息（交叉），`mutFlipBit()`会以`0.6`的概率仅突变染色体的一个元素，`selRandom()`函数，**evaluate**（这使用来自*第6步*和*第7步*的RNN训练函数）。'
- en: 'Use the `selBest()` function for a single optimal solution, `k=1`, compare
    the solutions to the fitness function, and select the one with the highest similarity.
    To get the optimal window size and number of units, loop through the chromosome
    and convert the bit values to unsigned integers and print the optimal hyperparameters:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`selBest()`函数选择单一最佳解，`k=1`，比较解的适应度函数，选择与最优解最相似的那个。为了获得最佳窗口大小和单元数量，遍历染色体，将比特值转换为无符号整数，并打印最优超参数：
- en: '[PRE81]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The output will be as follows:'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE82]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Run the application. You will get a similar output to what you see here. The
    initial values for the window size and number of units will be displayed. The
    GA will run using the RNN for the total number of epochs. At the end of each epoch,
    the `RMSE` value is displayed. Once all the epochs have executed, the optimal
    values are displayed:![Figure 12.10: Optimization of the window size and number
    of units using GA'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，你将得到类似的输出。窗口大小和单元数量的初始值将显示。遗传算法将使用RNN运行指定的代数。在每个代的结束时，`RMSE`值会显示出来。一旦所有代数完成，最佳值将显示出来：![图12.10：使用遗传算法优化窗口大小和单元数量
- en: '](img/B16182_12_10.jpg)'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16182_12_10.jpg)'
- en: 'Figure 12.10: Optimization of the window size and number of units using GA'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10：使用遗传算法优化窗口大小和单元数量
- en: We started with an initial window size of `51` and `15` units; the optimal window
    size is reduced to `28`, and the number of units to `4`. The difference between
    the parameters based on `RMSE` is reduced to `0.05`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从初始窗口大小`51`和`15`个单元开始；最佳窗口大小减少为`28`，单元数量减少到`4`。根据`RMSE`计算，参数之间的差异减少至`0.05`。
- en: Note
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/37sgQA6](https://packt.live/37sgQA6).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问该特定部分的源代码，请参考[https://packt.live/37sgQA6](https://packt.live/37sgQA6)。
- en: You can also run this example online at [https://packt.live/30AOKRK](https://packt.live/30AOKRK).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/30AOKRK](https://packt.live/30AOKRK)在线运行此示例。
- en: This section has covered combining GAs with neural networks as an alternative
    to using gradient descent methods. GAs mainly served in optimizing the number
    of neurons and weights for the neural networks, but their use can be expanded,
    through hybridization, to optimizing the structure of the network and hyperparameter
    selection. This exercise tested your ability to apply a genetic algorithm to find
    the optimal values of two features related to a weather forecasting problem. The
    features were used to train an RNN to estimate wind flow using RMSE values. In
    the following section, you will expand your knowledge of hybrid optimization techniques
    for the entire architecture of a neural network using NEAT.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 本节内容已经涵盖了将遗传算法与神经网络结合，作为替代梯度下降方法的方案。遗传算法主要用于优化神经网络的神经元数量和权重，但通过混合方法，其应用可以扩展到优化网络结构和超参数选择。本次练习测试了你应用遗传算法来寻找与天气预测问题相关的两个特征的最佳值的能力。这些特征被用来训练一个递归神经网络（RNN），利用RMSE值估计风流。在接下来的部分中，你将扩展对整个神经网络架构优化的混合技术的知识，使用NEAT方法。
- en: NEAT and Other Formulations
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NEAT与其他形式
- en: Neuroevolution is a term that refers to evolving neural networks using GAs.
    This branch of machine learning is shown to outperform RL in various problems
    and can be coupled with RL, as it is a method for unsupervised learning. As mentioned
    in the previous section, neuroevolution systems concentrate on changing the weights,
    the number of neurons (in the hidden layers), and the topology of ANNs.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 神经进化是指使用遗传算法（GA）进化神经网络的术语。这一机器学习分支在各种问题中已被证明优于强化学习（RL），并且可以与强化学习结合使用，因为它是一种无监督学习方法。如前一节所述，神经进化系统专注于改变人工神经网络（ANN）的权重、神经元数量（在隐藏层中）和拓扑结构。
- en: '**Neuroevolution of Augmented Topologies** (**NEAT**) focuses on topology evolution
    for ANNs. It involves training a simple ANN structure, consisting of input and
    output neurons and units to represent the bias, but no hidden layers. Each ANN
    structure is encoded within a chromosome that contains node genes and connection
    genes (the mapping or link between two node genes). Each connection specifies
    the input, output, weight node, activation of the connection, and innovation number
    that serves as a link between genes for the crossover process.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**增强拓扑的神经进化**（**NEAT**）专注于人工神经网络（ANN）的拓扑进化。它涉及训练一个简单的ANN结构，该结构由输入和输出神经元以及表示偏置的单元组成，但没有隐藏层。每个ANN结构都在一个染色体中编码，其中包含节点基因和连接基因（即两个节点基因之间的映射或连接）。每个连接指定输入、输出、权重节点、连接的激活以及创新编号，这个编号作为基因交叉过程中的链接。'
- en: Mutations relate to the weights of the connections or the structure of the full
    system. Structural mutations can appear either by including a connection between
    two nodes that are not linked or by including a new node to a pre-existing connection,
    which causes two new connections to be built (one between the existing pair of
    nodes and one that includes the newly created node).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 突变与连接的权重或整个系统的结构相关。结构突变可以通过在两个未连接的节点之间加入连接，或者通过在已有连接上增加一个新节点，从而产生两个新的连接（一个是在现有的节点对之间，另一个是包含新创建节点的连接）。
- en: The crossover process entails the identification of common genes between different
    chromosomes within the population. This relies on the historical information about
    gene derivation, using a global innovation number. The genes resulting from the
    mutation receive incremented numbers from the gene they mutated, whereas through
    crossover, the genes keep their original numbers. This technique helps in solving
    the problems with gene matching that cause issues for neural network topologies.
    The genes that do not have the same innovation number are selected from the parent
    with the highest fitness. If both parents have the same fitness, the genes are
    selected randomly from each of the parents.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉过程涉及识别种群中不同染色体之间的共同基因。这依赖于关于基因派生的历史信息，使用全球创新编号。由突变产生的基因会从其突变的基因获得递增编号，而通过交叉产生的基因保持原来的编号。这项技术有助于解决因基因匹配问题而导致的神经网络拓扑结构问题。没有相同创新编号的基因从具有最高适应度的父本中选择。如果两个父本具有相同的适应度，基因将从每个父本中随机选择。
- en: 'Chromosomes that have similar topologies are grouped based on how far apart
    they are ![15](img/B16182_12_10a.png); individuals are therefore evaluated based
    on the genes that are different ![16](img/B16182_12_10b.png), supplementary genes
    ![17](img/B16182_12_10c.png) , and the differences in weight ![18](img/B16182_12_10d.png)
    for the similar genes compared to the average number of genes ![20](img/B16182_12_10e.png).
    Each of the coefficients ![19](img/B16182_12_10f.png) acts as a weight that highlights
    the significance of each parameter:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有相似拓扑的染色体根据它们之间的距离进行分组 ![15](img/B16182_12_10a.png)；因此，个体根据与平均基因数 ![20](img/B16182_12_10e.png)
    的差异，以及不同的基因 ![16](img/B16182_12_10b.png)、附加基因 ![17](img/B16182_12_10c.png) 和权重差异
    ![18](img/B16182_12_10d.png) 进行评估。每个系数 ![19](img/B16182_12_10f.png) 作为一个权重，强调每个参数的重要性：
- en: '![Figure 12.11: Topology distance calculation'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.11：拓扑距离计算'
- en: '](img/B16182_12_11.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16182_12_11.jpg)'
- en: 'Figure 12.11: Topology distance calculation'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.11：拓扑距离计算
- en: 'To categorize the chromosomes into species, the distance ![21](img/B16182_12_11a.png)
    is compared with a threshold ![22](img/B16182_12_11b.png). If ![23](img/B16182_12_11c.png),
    then the chromosome belongs to the first species where this condition is fulfilled.
    To prevent species dominance, all the elements of the species need to have the
    same fitness level, which is calculated based on the number of members in the
    species. The evolution of the species (how many new chromosomes are included,
    ![24](img/B16182_12_11d.png) depends on the comparison between the fitness of
    the species, ![25](img/B16182_12_11e.png), and the average fitness of the population,
    ![26](img/B16182_12_11f.png):'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将染色体分类到不同物种中，比较距离 ![21](img/B16182_12_11a.png) 与阈值 ![22](img/B16182_12_11b.png)。如果
    ![23](img/B16182_12_11c.png)，那么染色体属于满足此条件的第一个物种。为了防止物种主导，物种中的所有元素需要具有相同的适应度水平，该水平是根据物种中的成员数量计算的。物种的进化（包括多少新染色体被包含，![24](img/B16182_12_11d.png)）取决于物种适应度与种群平均适应度之间的比较，![25](img/B16182_12_11e.png)：
- en: '![Figure 12.12: Calculation of the number of new chromosomes'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.12：新染色体数量的计算'
- en: '](img/B16182_12_12.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16182_12_12.jpg)'
- en: 'Figure 12.12: Calculation of the number of new chromosomes'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.12：新染色体数量的计算
- en: The advantage of NEAT is that, unlike neuroevolution algorithms that have a
    random set of topology parameters, it starts with the simplest topological form
    of a neural network and progressively evolves it to find the optimal solution,
    significantly reducing the number of used generations.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: NEAT 的优势在于，与那些具有随机拓扑参数的神经进化算法不同，它从最简单的神经网络拓扑形式开始，并逐步进化以寻找最优解，从而显著减少了所使用的代数数量。
- en: Evolving topology algorithms are categorized as **Weight Evolving Artificial
    Neural Networks** (**TWEANNs**), which include EDEN, **Cellular Encoding** (**CE**),
    **Enforced Subpopulations** (**SE**) – a fixed topology system (out of which NEAT
    outperforms the latter two on CartPole) – **Parallel Distributed Genetic Programming**
    (**PDGP**), and **Generalized Acquisition of Recurrent Links** (**GNARL**).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 进化拓扑算法被分类为 **权重进化人工神经网络** (**TWEANNs**)，包括 EDEN、**细胞编码** (**CE**)、**强制子群体**
    (**SE**) —— 这是一种固定拓扑系统（其中 NEAT 在 CartPole 上优于后两者）—— **并行分布式遗传编程** (**PDGP**)，和
    **广义递归链接获取** (**GNARL**).
- en: We will now see an exercise on applying NEAT to solve a simple XNOR gate, a
    logic gate that has a binary output. The binary inputs and output are quantified
    using a truth table, which is a representation of the sets of the functional values
    of Boolean logic expressions showcasing the combination of the logical values.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过一个练习，展示如何应用 NEAT 来解决一个简单的 XNOR 门问题，XNOR 门是一种具有二进制输出的逻辑门。二进制输入和输出通过真值表进行量化，真值表是布尔逻辑表达式功能值集合的表示，展示了逻辑值的组合。
- en: 'Exercise 12.08: XNOR Gate Functionality Using NEAT'
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.08：使用 NEAT 实现 XNOR 门功能
- en: In the exercise, you will see the impact that NEAT has on solving a simple Boolean
    algebra problem. The problem involves implementing the NEAT algorithm to identify
    the optimal neural network topology for reproducing the binary output of an exclusive
    NOR (XNOR) gate. This is a type of logic gate where, when both inputs have the
    same signal (either 0 or 1 – equivalent to off and on, respectively), the output
    of the logic gate will be 1 (on), whereas when one of the inputs is high (1) and
    the other is low (0), the output will be 0 (off).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在练习中，您将看到NEAT在解决简单布尔代数问题中的影响。该问题涉及实现NEAT算法以识别用于再现互斥非（XNOR）门的二进制输出的最佳神经网络拓扑结构。这是一种逻辑门，当两个输入信号相同时（即0或1
    - 分别等同于关闭和打开），逻辑门的输出将为1（打开），而当一个输入为高（1）而另一个输入为低（0）时，输出将为0（关闭）。
- en: 'We have the following truth table for the XNOR logic gate:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下XNOR逻辑门的真值表：
- en: '![Figure 12.13: Truth table for the XNOR gate'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.13：XNOR门的真值表'
- en: '](img/B16182_12_13.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16182_12_13.jpg)'
- en: 'Figure 12.13: Truth table for the XNOR gate'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13：XNOR门的真值表
- en: Use the NEAT algorithm to create a feedforward neural network that can mimic
    the output of an XNOR gate.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NEAT算法创建一个前馈神经网络，可以模拟XNOR门的输出。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成练习：
- en: 'In your Anaconda environment, execute the following command:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的Anaconda环境中执行以下命令：
- en: '[PRE83]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Create a new Jupyter Notebook.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Jupyter Notebook。
- en: 'Import `print_function` from the `__future__` file, and import the `neat` and
    `os` packages:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`__future__`文件中导入`print_function`，并导入`neat`和`os`包：
- en: '[PRE84]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Initialize the inputs and the output of the XNOR gate based on the truth table:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据真值表初始化XNOR门的输入和输出：
- en: '[PRE85]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Create a fitness function that uses the squared difference between the actual
    output and the output of a feedforward neural network using NEAT:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个适应性函数，该函数使用实际输出和使用NEAT的前馈神经网络输出之间的平方差：
- en: '[PRE86]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Create a new text file with the name `config-feedforward-xnor`. Include in
    the file the following parameters for the NEAT algorithm. For the fitness function,
    select the maximal value, with a threshold close to `4` and a population size
    of `200`:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`config-feedforward-xnor`的新文本文件。在文件中包含以下NEAT算法的参数。对于适应性函数，选择最大值，阈值接近`4`，人口大小为`200`：
- en: '[PRE87]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In the same `config-feedforward-xnor` file, include the `sigmoid` function
    for node activation with a mutation rate of `0.01`. The aggregation options are
    mostly about adding the values, with a mutation rate of 0 for aggregation:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一`config-feedforward-xnor`文件中，包括使用`0.01`的变异率的节点激活的`sigmoid`函数。聚合选项主要是添加值，聚合的变异率为0：
- en: '[PRE88]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Set the `bias` parameters for the algorithm:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为算法设置`bias`参数：
- en: '[PRE89]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: For the bias, the minimum and maximum values are `-30` and `30`. Set the initial
    standard deviation at `0.05`, as low as possible, with a power of `0.5`, a mutation
    rate of `0.8`, and a replacement rate of `0.1`. These values are essential for
    implementing the genetic algorithm optimization.
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于偏置，最小值和最大值分别为`-30`和`30`。将初始标准差设置为`0.05`，尽可能低，幂为`0.5`，变异率为`0.8`，替换率为`0.1`。这些值对实施遗传算法优化至关重要。
- en: 'Define the coefficients ![27](img/B16182_12_13a.png), as we are only considering
    the difference between the genes (how disjointed they are) and the difference
    in weights:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义系数![27](img/B16182_12_13a.png)，因为我们仅考虑基因之间的差异（它们的不一致性）和权重之间的差异：
- en: '[PRE90]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Include the information about topology, connection, and node inclusion or removal-related
    parameters:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括关于拓扑、连接以及与节点的包含或移除相关的参数信息：
- en: '[PRE91]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Start with a simple network without any hidden layers and set the response
    parameters for the nodes and connections:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个没有任何隐藏层的简单网络开始，并设置节点和连接的响应参数：
- en: '[PRE92]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Select the default parameters for the distance threshold, species fitness function,
    and parent selection. This is the final set of parameters to be included in the
    `config-feedforward-xnor` file:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择距离阈值、物种适应性函数和父代选择的默认参数。这是要包含在`config-feedforward-xnor`文件中的最终参数集：
- en: '[PRE93]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now, in the main code file, use the `config-feedforward-xnor` file to configure
    the NEAT formulation of the neural network and output each configuration of the
    network within `Exercise 12.08`:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在主代码文件中，使用`config-feedforward-xnor`文件配置神经网络的NEAT公式，并输出网络的每个配置在`Exercise 12.08`内：
- en: '[PRE94]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The output will be as follows:'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE95]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Get the population based on the configuration of the NEAT algorithm and include
    the progress to the terminal to monitor the statistical differences:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据 NEAT 算法的配置获取种群，并将进度输出到终端，以监控统计差异：
- en: '[PRE96]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Run the algorithm for `200` generations and select the best solution for the
    neural network topology:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行算法`200`代，并为神经网络拓扑选择最佳解决方案：
- en: '[PRE97]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The output will be similar to the following:'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将类似于以下内容：
- en: '[PRE98]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Use functions to compare the output of the neural network with the desired
    output:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用函数将神经网络的输出与期望输出进行比较：
- en: '[PRE99]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The output will be as follows:'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE100]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Run the code and you will get a similar output to what you see here. As the
    chromosomes are populated randomly, the algorithm will converge to a nearly optimal
    solution in a different number of generations for you:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码后，你将得到类似于此处所见的输出。由于染色体是随机生成的，算法将在不同的代数中收敛到一个接近最优的解：
- en: '[PRE101]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: By running this experiment, you can see that the conversion to a nearly optimal
    solution happened in less than the maximum number of generations (`200`). The
    output of the feedforward neural network is nearly optimal, as the values are
    integers. Their values are close to 1 and 0\. You can also observe that from a
    neural network with no hidden layers, the ANN has evolved to have `1149` nodes
    with various connections.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行这个实验，你可以看到转换到接近最优解的过程发生在小于最大代数（`200`）的情况下。前馈神经网络的输出几乎是最优的，因为它的值是整数。它们的值接近
    1 和 0。你还可以观察到，从一个没有隐藏层的神经网络开始，ANN 进化成了具有 `1149` 个节点和各种连接的网络。
- en: Note
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to https://packt.live/2XTBs0M.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 若要访问此特定部分的源代码，请参考 [https://packt.live/2XTBs0M](https://packt.live/2XTBs0M)。
- en: This section does not currently have an online interactive example, and will
    need to be run locally.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 本节目前没有在线互动示例，需在本地运行。
- en: In this section, the NEAT algorithm, a neuroevolution algorithm that varies
    the topology of neural networks, was presented. What sets the NEAT algorithm apart
    from alternative TWEANNs is the way in which mutation, crossover, and selection
    take place to optimize the structure of the neural network, starting from a simple
    network with no hidden layers and evolving into a more complex one with an increased
    number of nodes and connections.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，介绍了 NEAT 算法，这是一种变异神经网络拓扑的神经进化算法。NEAT 算法与其他 TWEANNs（拓扑进化神经网络）的不同之处在于变异、交叉和选择的方式，这些操作优化神经网络的结构，从一个没有隐藏层的简单网络开始，并演化成一个更复杂的网络，节点和连接的数量增加。
- en: This exercise, which involved implementing NEAT to reproduce the output of an
    XNOR logic gate, enabled you to understand the structure of the NEAT algorithm
    and analyze the benefits and implications of applying neuroevolutionary techniques
    as alternatives to simple electronic problems. In the next section, you will test
    your programming abilities and your knowledge of GAs by solving the cart-pole
    problem.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习涉及实现 NEAT 来重现 XNOR 逻辑门的输出，使你能够理解 NEAT 算法的结构，并分析将神经进化技术应用于简单电子问题的好处和意义。在下一节中，你将通过解决小车摆杆问题来测试你的编程能力和遗传算法（GA）的知识。
- en: 'Activity 12.01: Cart-Pole Activity'
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 12.01：小车摆杆活动
- en: Automatic control is a challenge, especially when operating specific equipment
    using robotic arms or carts that are transporting equipment on a shop floor. This
    problem is often generalized as the cart-pole problem. You are going to program
    an automated cart to balance a pole. The goal is to maximize the time that the
    pole is balanced for. To solve this problem, an agent can use a neural network
    for the state-action mapping. The challenge lies in identifying the structure
    of the neural network and a solution for determining the optimal values for the
    weights, bias, and number of neurons for each layer of the neural network. We
    will use a GA to identify the best values for these parameters.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 自动控制是一项挑战，尤其是在使用机械臂或小车运输车间设备时。这个问题通常被概括为小车摆杆问题。你将编写程序控制一个自动化小车以保持一根杆子平衡。目标是最大化杆子保持平衡的时间。为了解决这个问题，代理可以使用神经网络进行状态-动作映射。挑战在于确定神经网络的结构，并为神经网络每一层确定最优的权重、偏差和神经元数量的解决方案。我们将使用遗传算法（GA）来确定这些参数的最佳值。
- en: 'This activity aims to implement a GA for parameter selection for an ANN that,
    after 20 generations, can obtain a high average score for 500 trials. You will
    output the average scores for both the generations and the episodes, and you will
    monitor the convergence to an optimal policy by tuning the parameters of the neural
    network using a genetic algorithm in the form of a graph. This activity has the
    purpose of testing your programming abilities by implementing concepts from previous
    chapters and the current one. The following are the steps needed to implement
    this activity:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的目标是实现一个遗传算法，用于选择人工神经网络（ANN）的参数，经过 20 代之后，可以在 500 次试验中获得高的平均分数。你将输出每代和每集的平均分数，并通过调整神经网络的参数，使用遗传算法监控收敛到最优策略的过程，以图形方式呈现。此活动旨在通过实现前几章和本章的概念，测试你的编程能力。以下是实现此活动所需的步骤：
- en: 'Create a Jupyter Notebook file and import the appropriate packages as follows:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 Jupyter Notebook 文件并导入适当的包，如下所示：
- en: '[PRE102]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Initialize the environment and the state and action space shapes.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化环境以及状态和动作空间的形状。
- en: Create a function to generate randomly selected initial network parameters.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，用于生成随机选择的初始网络参数。
- en: Create a function to generate the neural network using the set of parameters.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，使用一组参数生成神经网络。
- en: Create a function to get the total reward for 300 steps when using the neural
    network.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，获取使用神经网络时 300 步的总奖励。
- en: Create a function to get the fitness scores for each element of the population
    when running the initial random selection.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，在运行初始随机选择时，获取种群中每个元素的适应度分数。
- en: Create a mutation function.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个突变函数。
- en: Create a single-point crossover function.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个单点交叉函数。
- en: Create a function for the next-generation creation by selecting the pair with
    the highest rewards.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，通过选择奖励最高的对来生成下一代。
- en: Select the parameters within the function to construct the neural network that
    adds the parameters.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数中选择参数，构建神经网络并添加这些参数。
- en: Build the neural network using the identified parameters and obtain a new reward
    based on the constructed neural network.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用识别的参数构建神经网络，并根据构建的神经网络获得新的奖励。
- en: Create a function to output the convergence graph.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，用于输出收敛图。
- en: Create a function for the genetic algorithm that outputs the parameters of the
    neural network based on the highest average reward.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个遗传算法函数，根据最高的平均奖励输出神经网络的参数。
- en: Create a function that decodes the array of parameters to each neural network
    parameter.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，将参数数组解码为每个神经网络参数。
- en: 'Set the generations to 50, the number of trial tests to 15, and the number
    of steps and trials to 500\. You will get a similar output to this (only the first
    few lines are displayed here):'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置代数为 50，试验次数为 15，步骤数和试验数为 500。你将得到类似以下的输出（这里只显示前几行）：
- en: '[PRE103]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The plot of rewards against generations will be similar to the following:'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 奖励与代数的关系图将类似于以下内容：
- en: '![Figure 12.14: Rewards obtained over the generations'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 12.14：代数中获得的奖励'
- en: '](img/B16182_12_14.jpg)'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16182_12_14.jpg)'
- en: 'Figure 12.14: Rewards obtained over the generations'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.14：代数中获得的奖励
- en: 'The output for the average rewards (just the last few lines are shown here)
    will be similar to the following:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 平均奖励的输出（这里只显示最后几行）将类似于以下内容：
- en: '[PRE104]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Note
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 774.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在第 774 页找到。
- en: Summary
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have explored gradient-based and gradient-free methods
    of algorithm optimization, with an emphasis on the potential of evolutionary algorithms
    – in particular, GAs – to solve optimization problems, such as sub-optimal solutions,
    using a nature-inspired approach. GAs consist of specific elements, such as population
    generation, parent selection, parent reproduction or crossover, and finally mutation
    occurrence, which they use to create a binary optimal solution.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你探讨了基于梯度和非基于梯度的算法优化方法，重点介绍了进化算法的潜力——特别是遗传算法——通过模仿自然的方式解决优化问题，比如亚优解。遗传算法由特定元素组成，如种群生成、父代选择、父代重组或交叉、以及最终突变发生，利用这些元素生成二进制最优解。
- en: Then, the use of GAs for hyperparameter tuning and selection for neural networks
    was explored, helping us to find the most suitable window size and unit number.
    We saw implementations of state-of-the-art algorithms that combined deep neural
    networks and evolutionary strategies, such as NEAT for XNOR output estimation.
    Finally, you had a chance to implement what was studied in this chapter through
    an OpenAI Gym cart-pole simulation, where we examined the application of GAs for
    parameter tuning with action selection using a deep neural network.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，探索了遗传算法（GAs）在神经网络的超参数调优和选择中的应用，帮助我们找到最合适的窗口大小和单元数。我们看到了结合深度神经网络和进化策略的最先进算法的实现，例如用于
    XNOR 输出估计的 NEAT。最后，你有机会通过 OpenAI Gym 的平衡杆模拟来实现本章所学的内容，在这个模拟中，我们研究了使用深度神经网络进行动作选择时，遗传算法在参数调优中的应用。
- en: The development of hybrid methods in RL systems is one of the most recent optimization
    developments. You have developed and implemented optimization methods for model-free
    RL systems. In the bonus chapter (which is available on the interactive version
    of the workshop at [courses.packtpub.com](http://courses.packtpub.com)), you will
    be exploring model-based RL methods and state-of-the-art advances in deep RL for
    control systems that can be applied in the robotics, manufacturing, and transportation
    fields.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 强化学习（RL）系统中混合方法的发展是最近的优化发展之一。你已经开发并实现了适用于无模型 RL 系统的优化方法。在附加章节中（该章节可以通过互动版本的研讨会在
    [courses.packtpub.com](http://courses.packtpub.com) 上访问），你将探索基于模型的 RL 方法以及深度 RL
    在控制系统中的最新进展，这些进展可以应用于机器人技术、制造业和交通领域。
- en: You are now capable of applying the concepts that you learned about in this
    book using various coding techniques and various models that can help further
    enhance your field of expertise and potentially bring new changes and advancements.
    Your journey has just begun – you have taken the first steps to deciphering the
    world of RL, and you now have the tools to enhance your Python programming skills
    for RL, all of which you can independently apply.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经能够利用本书中学到的概念，使用各种编码技术和模型来进一步提升你的专业领域，并可能带来新的变化和进步。你的旅程才刚刚开始——你已经迈出了破解强化学习（RL）世界的第一步，并且你现在拥有了提升
    Python 编程技能的工具，所有这些你都可以独立应用。
