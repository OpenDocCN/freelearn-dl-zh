- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Staging the OpenAI API for Application Development
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenAI API 在应用开发中的分阶段应用
- en: So far, we have used the OpenAI API by connecting directly to OpenAI’s endpoint
    and making a request. When building applications and workflows, however, it is
    not typical to connect directly to OpenAI. Instead, developers tend to stage and
    call OpenAI’s API from their own backend APIs, which then return information to
    the application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过直接连接到 OpenAI 的端点并发送请求来使用 OpenAI API。然而，在构建应用和工作流时，通常不会直接连接到 OpenAI。相反，开发人员倾向于通过他们自己的后端
    API 来分阶段调用 OpenAI API，然后将信息返回给应用程序。
- en: Essentially, there is a layer between the frontend of an application and the
    OpenAI API, as depicted in *Figure 5**.1*. This layer normally processes requests
    from the frontend, calls the OpenAI API (or a series of other endpoints), receives
    the completion, processes it, and then returns the data back to the frontend.
    We will refer to this layer as the **backend layer** or the **server layer**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，应用程序的前端和 OpenAI API 之间存在一层，如*图 5.1*所示。此层通常处理来自前端的请求，调用 OpenAI API（或一系列其他端点），接收完成内容，处理后再将数据返回给前端。我们将这层称为**后端层**或**服务器层**。
- en: '![Figure 5.1 – Demonstration of typical application architecture using the
    OpenAI API](img/B21007_05_01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 使用 OpenAI API 的典型应用架构示意图](img/B21007_05_01.jpg)'
- en: Figure 5.1 – Demonstration of typical application architecture using the OpenAI
    API
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 使用 OpenAI API 的典型应用架构示意图
- en: 'Integrating OpenAI’s API into an application usually involves an architecture
    where the frontend layer (the user interface) communicates with a backend layer
    (the server), which in turn interacts with OpenAI’s API. This approach has several
    advantages:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 将 OpenAI API 集成到应用程序中通常涉及一种架构，其中前端层（用户界面）与后端层（服务器）通信，后者又与 OpenAI API 进行交互。这种方法有几个优势：
- en: '*Security and API key management*: The OpenAI API key is not exposed to the
    frontend, reducing the risk of it being compromised. The backend can securely
    store and manage the API key.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安全性与 API 密钥管理*：OpenAI API 密钥不会暴露给前端，从而降低了被泄露的风险。后端可以安全地存储和管理 API 密钥。'
- en: '*Control and customization*: The backend can control the rate and nature of
    requests sent to OpenAI’s API. It can also preprocess requests from the frontend
    or post-process responses from OpenAI, customizing the data according to application
    needs.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*控制与定制*：后端可以控制发送到 OpenAI API 的请求的速率和性质。它还可以对来自前端的请求进行预处理，或对 OpenAI 的响应进行后处理，根据应用需求定制数据。'
- en: '*Integration with other services*: Often, applications require data from multiple
    sources. The backend can integrate OpenAI’s API with other APIs or data sources,
    creating a centralized point for data processing and distribution.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与其他服务的集成*：通常，应用程序需要来自多个来源的数据。后端可以将 OpenAI API 与其他 API 或数据源集成，创建一个集中式的数据处理和分发点。'
- en: '*User authentication and authorization*: The backend can implement security
    measures such as user authentication and authorization, ensuring that only authorized
    users can access certain functionalities.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用户身份验证和授权*：后端可以实施安全措施，如用户身份验证和授权，确保只有授权用户才能访问某些功能。'
- en: This *backend* layer is typically staged and hosted on a **serverless** system
    such as Azure Functions, Amazon Web Services Lambda, or Google Cloud Functions.
    Using a serverless architecture offers several benefits, the paramount of which
    is simplified operations – it’s easy and quick to create a backend layer with
    serverless architecture.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*后端*层通常被分阶段并托管在像 Azure Functions、Amazon Web Services Lambda 或 Google Cloud
    Functions 这样的**无服务器**系统上。使用无服务器架构有几个好处，其中最重要的是简化操作——创建一个无服务器架构的后端层既简单又快速。
- en: In this chapter, we will take the first step into application development with
    the OpenAI API. We will learn how to create a serverless backend layer that connects
    and processes data from OpenAI API. We will then learn how to integrate that with
    the frontend layer, using both no-code and code platforms. By the end of this
    chapter, you will have everything you need to start creating your own intelligent
    applications.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将迈出使用 OpenAI API 进行应用开发的第一步。我们将学习如何创建一个无服务器的后端层，以连接和处理来自 OpenAI API 的数据。然后，我们将学习如何将其与前端层集成，使用无代码平台和代码平台。到本章结束时，您将具备开发自己智能应用所需的一切。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下内容：
- en: Creating a public endpoint server that calls the OpenAI API
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个调用 OpenAI API 的公共端点服务器
- en: Extending the endpoint server to accept parameters and return data
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展端点服务器以接受参数并返回数据
- en: Calling the user-created endpoint from no-code applications
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从无代码应用程序调用用户创建的端点
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the recipes in this chapter require you to have access to the OpenAI API
    (via a generated API key) and have an API client installed. You can refer to the
    [*Chapter 1*](B21007_01.xhtml#_idTextAnchor021) recipe *Making OpenAI API requests
    with Postman* for more information on how to obtain your API key. This will also
    require knowledge of Python and the Python OpenAI library, which we covered in
    the first recipe within [*Chapter 4*](B21007_04.xhtml#_idTextAnchor074).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有教程都要求您能够访问OpenAI API（通过生成的API密钥）并安装API客户端。有关如何获取API密钥的更多信息，请参阅[*第1章*](B21007_01.xhtml#_idTextAnchor021)中的教程*使用Postman发出OpenAI
    API请求*。这还需要了解Python以及Python OpenAI库，我们在[*第4章*](B21007_04.xhtml#_idTextAnchor074)的第一个教程中有详细介绍。
- en: We will also use the **Google Cloud Platform** (**GCP**) to host our public
    endpoint. GCP is a suite of cloud computing services offered by Google. It provides
    a range of hosting and computing services for databases, data storage, data analytics,
    machine learning, and more, all hosted on Google’s infrastructure.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用**Google Cloud Platform**（**GCP**）来托管我们的公共端点。GCP是Google提供的一套云计算服务。它提供一系列托管和计算服务，包括数据库、数据存储、数据分析、机器学习等，所有服务都托管在Google的基础设施上。
- en: 'In order to do this, you need to create a Google Cloud account, which you can
    do here: [https://cloud.google.com/](https://cloud.google.com/).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，您需要创建一个Google Cloud账户，您可以在这里创建：[https://cloud.google.com/](https://cloud.google.com/)。
- en: Creating a public endpoint server that calls the OpenAI API
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个调用OpenAI API的公共端点服务器
- en: As discussed previously, there are many important benefits of creating your
    own public endpoint server that calls the OpenAI API, instead of connecting to
    the OpenAI API directly – the biggest being control and customization, which we
    will explore in this recipe and the next recipe.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，创建您自己的公共端点服务器来调用OpenAI API，而不是直接连接OpenAI API，有许多重要的好处——最大的好处是控制和定制，我们将在本教程和下一个教程中进一步探讨。
- en: In this recipe, we will use GCP to host our public endpoint. When this endpoint
    is called, it will make a request to OpenAI for a slogan for an ice cream company
    and then will return the answer to the user. This sounds simple and almost unnecessary
    to make a public endpoint, but it is the final step we need to build a truly intelligent
    application that leverages OpenAI.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将使用GCP来托管我们的公共端点。每当调用此端点时，它将向OpenAI请求一个冰淇淋公司的口号，然后将结果返回给用户。这听起来简单，几乎不需要创建一个公共端点，但这是我们构建一个真正智能应用程序的最后一步，利用了OpenAI的强大功能。
- en: To do this, we will create a GCP resource called **Cloud Functions**, which
    we will explore later in the *How it works…* section of the recipe.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将创建一个名为**Cloud Functions**的GCP资源，稍后将在教程的*工作原理…*部分进行探讨。
- en: Getting ready
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure you have an OpenAI platform account with available usage credits. If
    you don’t, please follow the *Setting up your OpenAI Playground environment* recipe
    in [*Chapter 1*](B21007_01.xhtml#_idTextAnchor021).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您拥有OpenAI平台账户并且有可用的使用配额。如果没有，请参阅[*第1章*](B21007_01.xhtml#_idTextAnchor021)中的*设置OpenAI
    Playground环境*教程。
- en: Furthermore, ensure you have created a GCP account. To do this, navigate to
    [https://cloud.google.com/](https://cloud.google.com/), then select **Start Free**
    from the top right, and follow the instructions that you see.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请确保您已创建了一个GCP账户。为此，请访问[https://cloud.google.com/](https://cloud.google.com/)，然后从右上角选择**开始免费使用**，并按照页面上的指示进行操作。
- en: You may need to provide a billing profile as well to create any GCP resources.
    Note that GCP does have a free tier, and in this recipe, we will not go above
    the free tier (so, essentially, you should not be billed for anything).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还需要提供一个计费资料，以便创建任何GCP资源。请注意，GCP确实提供免费的层级，在本教程中，我们不会超出免费层级（因此，基本上，您不应该为任何费用付费）。
- en: You may need to create a project if this is your first time logging in to **Google
    Cloud Platform**. After you log in, select **Select a project** from the top left
    and then select **New Project**. Provide a **project name** and then select **Create**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是您第一次登录**Google Cloud Platform**，可能需要创建一个项目。登录后，从左上角选择**选择项目**，然后选择**新建项目**。提供**项目名称**后，点击**创建**。
- en: The next recipe in this chapter will also have this same requirement.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的下一个教程也有相同的要求。
- en: How to do it…
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Navigate to [https://console.cloud.google.com/](https://console.cloud.google.com/).
    In the **Search** field at the top of the page, type in **Cloud Functions** and
    select the top choice from the drop-down menu, **Cloud Functions**.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航至[https://console.cloud.google.com/](https://console.cloud.google.com/)。在页面顶部的**搜索**字段中，键入**Cloud
    Functions**并从下拉菜单中选择第一个选项，**Cloud Functions**。
- en: '![Figure 5.2 – Cloud Functions in the dropdown](img/B21007_05_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – 下拉菜单中的云函数](img/B21007_05_02.jpg)'
- en: Figure 5.2 – Cloud Functions in the dropdown
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 下拉菜单中的云函数
- en: Select **Create Function** from the top of the page. This will begin to create
    our custom backend endpoint and start the configuration steps.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从页面顶部选择**创建函数**。这将开始创建我们的自定义后端端点并启动配置步骤。
- en: 'On the **Configuration** page, fill in the following steps:'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在**配置**页面中，填写以下步骤：
- en: '**Environment**: Select **2nd gen** from the drop-down menu.'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境**：从下拉菜单中选择**第二代**。'
- en: '**Function name**: Since we’re creating a backend endpoint that will produce
    company slogans, the function name will be **slogan_creator**.'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数名称**：由于我们正在创建一个生成公司标语的后端端点，函数名称将为**slogan_creator**。'
- en: '**Region**: Choose the environment location nearest you.'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区域**：选择离您最近的环境位置。'
- en: In the **Trigger** menu, choose **HTTPS**. In the **Authentication** sub-menu,
    select **Allow unauthenticated invocation**. We need to check this as we are going
    to create a public endpoint that will be accessible from our frontend services.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**触发器**菜单中，选择**HTTPS**。在**身份验证**子菜单中，选择**允许未经身份验证的调用**。我们需要勾选这个选项，因为我们将创建一个可以从前端服务访问的公共端点。
- en: '![Figure 5.3 – Sample configuration settings of a Google Cloud Function](img/B21007_05_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – Google Cloud Function 配置示例](img/B21007_05_03.jpg)'
- en: Figure 5.3 – Sample configuration settings of a Google Cloud Function
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – Google Cloud Function 配置示例
- en: Select the **Next** button on the bottom of the page to then move on to the
    **Code** section.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择页面底部的**下一步**按钮，然后进入**代码**部分。
- en: From the **Runtime** dropdown, select **Python 3.12**. This ensures that our
    backend endpoint will be coded using the Python programming language.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**运行时**下拉菜单中，选择**Python 3.12**。这确保我们的后端端点将使用Python编程语言进行编码。
- en: For that **Entry point** option, type in **create_slogan**. This refers to the
    name of the function in Python that is called when the public endpoint is reached
    and triggered.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**入口点**选项，输入**create_slogan**。这指的是在公共端点被访问并触发时调用的Python函数名称。
- en: 'On the left-hand side menu, you will see two files: **main.py** and **requirements.txt**.
    Select the **requirements.txt** file. This will list all the Python packages that
    need to be installed for our Cloud Function to operate.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧菜单中，您会看到两个文件：**main.py**和**requirements.txt**。选择**requirements.txt**文件。这将列出我们为使Cloud
    Function正常运行而需要安装的所有Python包。
- en: In the center of the screen where the contents of **requirements.txt** are displayed,
    enter a new line and type in **openai**. This will ensure that the latest **openai**
    library package is installed. Your screen should look like what’s displayed in
    *Figure 5**.4*.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕中央显示**requirements.txt**内容的地方，输入一行新内容并键入**openai**。这将确保安装最新的**openai**库包。您的屏幕应显示为*图5.4*所示。
- en: '![Figure 5.4 – Snapshot of the requirements.txt file](img/B21007_05_04.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – requirements.txt 文件快照](img/B21007_05_04.jpg)'
- en: Figure 5.4 – Snapshot of the requirements.txt file
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – requirements.txt 文件快照
- en: 'From the left-hand side menu, select **main.py**. Copy and paste the following
    code into the center of the screen (where the content for that file is displayed).
    These are the instructions that the public endpoint will run when it is triggered:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧菜单中，选择**main.py**。将以下代码复制并粘贴到屏幕中央（该文件的内容显示区域）。这些是公共端点在触发时运行的指令：
- en: '[PRE0]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, it simply calls the OpenAI endpoint, requests a chat completion,
    and then returns the output to the user. You will also need your OpenAI API key.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，它仅调用OpenAI端点，请求聊天完成，然后将输出返回给用户。您还需要您的OpenAI API密钥。
- en: Next, deploy the function by selecting the **Deploy** button at the bottom of
    your page.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过点击页面底部的**部署**按钮来部署该函数。
- en: Wait for your function to be fully deployed, which typically takes two minutes.
    You can verify whether the function has been deployed or not by observing the
    progress in the top left section of the page (shown in *Figure 5**.5*). Once it
    is green and checkmarked, the build is successful, and your function has been
    deployed.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待函数完全部署，通常需要两分钟。你可以通过观察页面左上方的进度来验证函数是否已部署（如*图 5.5*所示）。一旦它变为绿色并打上勾，构建就成功了，你的函数已经部署。
- en: '![Figure 5.5 – The Cloud Function deployment page](img/B21007_05_05.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – Cloud Function 部署页面](img/B21007_05_05.jpg)'
- en: Figure 5.5 – The Cloud Function deployment page
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – Cloud Function 部署页面
- en: Now, let’s verify that our function works. Select the endpoint URL, found on
    the top of the page near **URL**. It’s typically in the form **https://[location]-[project-name].cloudfunctions.net/[function-name]**.
    It is also highlighted in *Figure 5**.5*.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们验证一下我们的函数是否正常工作。选择位于页面顶部、接近**URL**的位置的端点 URL。它通常是**https://[location]-[project-name].cloudfunctions.net/[function-name]**的形式。它也在*图
    5.5*中有所突出显示。
- en: This will open a new web page that will trigger our custom public endpoint,
    and return a chat completion, which, in this case, is the slogan for an ice cream
    business. Note that this is a public endpoint – this will work on your computer,
    phone, or any device connected to the internet.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开一个新网页，触发我们的自定义公共端点，并返回一个聊天完成内容，在本例中是一个冰淇淋业务的标语。请注意，这是一个公共端点——它可以在您的计算机、手机或任何连接到互联网的设备上工作。
- en: '![Figure 5.6 – Output of a Google Cloud Function](img/B21007_05_06.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – Google Cloud Function 输出](img/B21007_05_06.jpg)'
- en: Figure 5.6 – Output of a Google Cloud Function
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – Google Cloud Function 输出
- en: How it works…
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'In this recipe, we created a public endpoint. This endpoint can be accessed
    by anyone (including your application in future recipes). The logic of the endpoint
    is simple and something we have covered prior: return a slogan for a company that
    sells ice cream. What’s new, however, is that this is our very own public endpoint
    that is hosted in Google Cloud, using the Cloud Function resource.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们创建了一个公共端点。任何人都可以访问这个端点（包括你在未来食谱中的应用）。这个端点的逻辑很简单，之前也有提到：为一个销售冰淇淋的公司返回一个标语。新的地方在于，这是我们自己在
    Google Cloud 中托管的公共端点，使用了 Cloud Function 资源。
- en: Note that we used the free tier of Google Cloud Functions, which does have limitations
    such as a cap on the number of function invocations per month, limited execution
    time, and constrained computational resources. However, for our current purposes,
    these limitations are not a hindrance, allowing us to deploy and test our functions
    effectively without incurring costs. This setup is ideal for small-scale applications
    or for learning and experimentation purposes, providing a practical way to understand
    cloud functionalities and serverless architecture in a cost-effective manner.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用了 Google Cloud Functions 的免费层，该层有一些限制，例如每月函数调用次数的上限、执行时间的限制以及计算资源的约束。然而，对于我们当前的目的，这些限制并不构成障碍，让我们能够有效地部署和测试函数，而无需产生费用。这种设置非常适合小规模应用，或者用于学习和实验，提供了一种以低成本方式理解云功能和无服务器架构的实用方法。
- en: Code in the Cloud Function
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cloud Function 中的代码
- en: The code that we used within the Cloud Function should appear familiar – it’s
    the exact code we used in the first recipe within [*Chapter 4*](B21007_04.xhtml#_idTextAnchor074),
    but wrapped into a function called `create_slogan`. This code simply makes an
    OpenAI chat completion with the `system` and `user` messages being `You are an
    AI assistant that creates one slogan based on company descriptions` and `A company
    that sells ice cream` respectively. What are GCP Cloud Functions?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Cloud Function 中使用的代码应该很熟悉——它正是我们在[*第 4 章*](B21007_04.xhtml#_idTextAnchor074)中第一个食谱中使用的代码，不过它被封装成了一个名为`create_slogan`的函数。这个代码仅仅是创建了一个
    OpenAI 聊天完成，其中`system`和`user`消息分别是`你是一个根据公司描述创建标语的 AI 助手`和`一个销售冰淇淋的公司`。什么是 GCP
    Cloud Functions？
- en: '**Cloud Functions**, commonly referred to as **serverless functions** or **Function
    as a Service (FaaS)**, are a key component of serverless computing. In this model,
    developers write and deploy individual functions – small, single-purpose pieces
    of code – that are executed in the cloud. These functions are typically event-driven,
    meaning they are designed to respond to specific triggers or events.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**云函数**，通常称为**无服务器函数**或**函数即服务（FaaS）**，是无服务器计算的关键组成部分。在这种模型中，开发者编写并部署单个函数——小的、单一目的的代码块——这些函数在云中执行。这些函数通常是事件驱动的，意味着它们设计来响应特定的触发器或事件。'
- en: 'There are two main benefits of Cloud Functions that make them perfect for creating
    our backend layer and a public endpoint:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 云函数有两个主要优势，使其非常适合创建我们的后端层和公共端点：
- en: '*No server management*: Developers don’t need to provision or manage any servers.
    The cloud provider dynamically allocates and manages the infrastructure. There
    is no need for setup or maintenance. We created it in less than 10 minutes.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无需服务器管理*：开发者无需配置或管理任何服务器。云服务提供商动态分配并管理基础设施，无需任何设置或维护。我们在不到 10 分钟内就创建好了它。'
- en: '*Automatic scaling*: Cloud Functions automatically scale up or down based on
    the number of incoming event triggers. This means they can handle a single request
    per day or thousands per second. This is especially important when building applications
    – you want them to work whether there’s one user on your apps, or millions.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自动扩展*：云函数会根据传入事件触发的数量自动扩展或缩减。这意味着它们可以处理每天一个请求，或者每秒处理成千上万的请求。在构建应用程序时，尤其重要——无论应用程序上只有一个用户，还是有数百万用户，你都希望它能正常工作。'
- en: Nevertheless, it’s essential to keep in mind that just like any other tool,
    Cloud Functions come with their own set of pros and cons. They’re selected in
    this scenario primarily because they offer economical and simple setup benefits
    during the initial stages. As with every choice, it’s always worth weighing up
    the potential challenges alongside the advantages.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，必须牢记的是，和任何其他工具一样，云函数也有其自身的优缺点。它们在此场景中主要被选择是因为在初期阶段，它们提供了经济且简单的设置优势。就像每个选择一样，权衡潜在的挑战与优势总是值得的。
- en: GCP offers free-tier Cloud Functions, which means you can set them up for free
    (assuming they receive less than 2 million requests and some other thresholds
    (see [https://cloud.google.com/functions/pricing](https://cloud.google.com/functions/pricing)),
    which we will certainly not pass in these recipes).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: GCP 提供免费的云函数服务，这意味着您可以免费设置它们（前提是它们的请求量低于 200 万次以及其他一些阈值（参见 [https://cloud.google.com/functions/pricing](https://cloud.google.com/functions/pricing)），在这些配方中我们肯定不会超过这些限制）。
- en: Setting up a Cloud Function
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置云函数
- en: 'When setting up a Cloud Function, there were several configurations options
    that we purposely chose. Here is an explanation of the important configurations:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置云函数时，我们故意选择了几项配置选项。以下是对这些重要配置的解释：
- en: '**Trigger**: This setting defines how your Cloud Function is invoked. In simple
    terms, it specifies the event or condition that will cause your function (or the
    code in the function) to run. There are generally two options:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触发器**：此设置定义了如何调用您的云函数。简单来说，它指定了将导致您的函数（或函数中的代码）运行的事件或条件。通常有两个选项：'
- en: '**HTTP Trigger**: The function is invoked through an HTTP request, which is
    the same protocol we have used in previous recipes to call the OpenAI API within
    Postman. This is useful if you are creating public endpoints that will be called
    manually by other applications, which is why we have chosen this option.'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP 触发器**：该函数通过 HTTP 请求触发，这是我们在之前的配方中使用的协议，用来在 Postman 中调用 OpenAI API。如果您正在创建将由其他应用程序手动调用的公共端点，这会非常有用，这也是我们选择此选项的原因。'
- en: '**Event Trigger**: This option allows your function to respond to events from
    your cloud environment (e.g., changes in a Cloud Storage bucket).'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件触发器**：此选项允许您的函数响应来自云环境的事件（例如，Cloud Storage 存储桶中的更改）。'
- en: '**Authentication**: This setting controls who can invoke your Cloud Function.
    It’s a crucial part of securing your function against unauthorized access. For
    now, we have chosen **Allow Unauthenticated Invocations**, meaning that anyone
    can invoke your public endpoint. Even though this isn’t the most secure option,
    it is the most convenient option as you do not need to create authentication logic
    within Postman or any other frontend layer that needs to call the Google Cloud
    Function. It’s important to note that this is not the most secure choice and we
    highly discourage its use in real-world applications. This option has been utilized
    in this instance for convenience – to avoid creating authentication logic within
    Postman or any other frontend layer that interacts with the Google Cloud Function.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**：此设置控制谁可以调用你的云函数。这是保护你的函数免受未经授权访问的重要部分。目前，我们选择了**允许未经身份验证的调用**，这意味着任何人都可以调用你的公共端点。尽管这不是最安全的选项，但它是最方便的选择，因为你不需要在
    Postman 或任何其他需要调用 Google Cloud Function 的前端层中创建身份验证逻辑。需要注意的是，这不是最安全的选择，我们强烈不建议在实际应用中使用。此选项在此实例中被使用是出于方便考虑——避免在
    Postman 或任何其他与 Google Cloud Function 交互的前端层中创建身份验证逻辑。'
- en: '**Entry Point**: This refers to the name of the function in Python that is
    called when the public endpoint is reached and triggered. Essentially, this is
    the function or portion of the code that is run when the public endpoint is invoked.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**入口点**：指的是在访问公共端点并触发时，Python 中被调用的函数名称。本质上，这就是在公共端点被调用时执行的函数或代码部分。'
- en: Essentially, now that we have created a public endpoint that calls the OpenAI
    API, we no longer need to worry about hosting it on our own computers or servers.
    It can now be reached by anyone globally, even an intelligent application (which
    I am foreshadowing). This is important because wrapping it in a public endpoint
    is the first step in building an intelligent application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，现在我们已经创建了一个调用 OpenAI API 的公共端点，我们不再需要担心将其托管在自己的计算机或服务器上。现在，任何人都可以全球访问它，甚至是一个智能应用（这是我在暗示的）。这非常重要，因为将其包装在公共端点中是构建智能应用的第一步。
- en: Extending the endpoint server to accept parameters and return data
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展端点服务器以接受参数并返回数据
- en: 'In the previous recipe, we successfully created a Cloud Function that, when
    invoked, returned a slogan for an ice cream company. While this is useful as it
    sits on the cloud, we want to amend this function so that it can do two things:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个教程中，我们成功创建了一个云函数，当被调用时，它会返回一个冰淇淋公司的口号。虽然它作为云端服务有用，但我们希望修改这个函数，让它能够做两件事：
- en: '*Accept parameters*: We need to modify the function to accept input parameters
    as part of the HTTP request. This means we will be able to create a Cloud Function
    that not only returns the slogan for an ice cream business but any type of business
    for which we provide a description.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*接受参数*：我们需要修改函数，以便将输入参数作为 HTTP 请求的一部分进行接受。这意味着我们将能够创建一个云函数，该函数不仅返回冰淇淋业务的口号，还能返回任何我们提供描述的业务类型的口号。'
- en: '*Structure the output*: We don’t want to simply output the chat completion
    (which, in this case, is the slogan). Instead, we want to process the data and
    output a JSON object, as it is widely used and easy to work with in web applications.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构建输出结构*：我们不想只是简单地输出聊天完成内容（在本例中为口号）。相反，我们希望处理数据并输出一个 JSON 对象，因为它在 web 应用中广泛使用且容易操作。'
- en: In this recipe, we will create a public endpoint server that will accept a parameter
    called `business_description` and will return the generated slogan in a structured
    output form.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将创建一个公共端点服务器，该服务器将接受一个名为`business_description`的参数，并以结构化的输出形式返回生成的口号。
- en: How to do it…
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: Navigate to [https://console.cloud.google.com/](https://console.cloud.google.com/).
    On the **Search** field at the top of the page, type in **Cloud Functions** and
    select the top choice from the drop-down menu called **Cloud Functions**.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 [https://console.cloud.google.com/](https://console.cloud.google.com/)。在页面顶部的**搜索**框中输入**Cloud
    Functions**，然后从下拉菜单中选择名为**Cloud Functions**的第一个选项。
- en: Select **Create Function** from the top of the page. This will begin to create
    our custom backend endpoint and start the configuration steps.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从页面顶部选择**创建函数**。这将开始创建我们的自定义后端端点，并开始配置步骤。
- en: 'On the **Configuration** page, fill in the following steps:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在**配置**页面，填写以下步骤：
- en: '**Environment**: Select **2nd gen** from the drop-down menu.'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境**：从下拉菜单中选择**2nd gen**。'
- en: '**Function** **name**: **slogan_creator_with_parameters**.'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数** **名称**：**slogan_creator_with_parameters**。'
- en: '**Region**: Choose the environment location nearest you, as the closer the
    server is to you, the faster the response.'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区域**：选择离你最近的环境位置，因为服务器离你越近，响应速度越快。'
- en: From the **Trigger** menu, choose **HTTPS**. From the **Authentication** sub-menu,
    select **Allow** **unauthenticated invocation**.
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从**Trigger**菜单中选择**HTTPS**。在**Authentication**子菜单中，选择**允许** **无身份验证的调用**。
- en: Select the **Next** button at the bottom of the page to then move on to the
    **Code** section.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面底部的**Next**按钮，进入**Code**部分。
- en: From the **Runtime** dropdown, select **Python 3.12**. This ensures that our
    backend endpoint will be coded using the Python programming language.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Runtime**下拉菜单中选择**Python 3.12**。这确保我们的后台端点将使用Python编程语言进行编码。
- en: For that **Entry point** option, type in **create_slogan_with_parameters**.
    This refers to the name of the function in Python that is called when the public
    endpoint is reached and triggered.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**Entry point**选项，输入**create_slogan_with_parameters**。这指的是当公共端点被访问并触发时，在Python中调用的函数名称。
- en: 'In the menu on the left-hand side, you will see two files: **main.py** and
    **requirements.txt**. Select the **requirements.txt** file. This will list all
    the Python packages that need to be installed for our Cloud Function to operate.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧菜单中，你将看到两个文件：**main.py**和**requirements.txt**。选择**requirements.txt**文件。这将列出所有需要安装的Python包，以便我们的云函数正常运行。
- en: At the center of the screen where the contents of **requirements.txt** are displayed,
    enter a new line and type in **openai**. This will ensure that the latest **openai**
    library package is installed.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕中央显示**requirements.txt**内容的区域，输入新的一行并键入**openai**。这将确保安装最新的**openai**库包。
- en: 'From the left-hand side menu, select **main.py**. Copy and paste the following
    code into the center of the screen (where the content for that file is displayed).
    You will again need your OpenAI API key. As you can see, the code is very similar
    to the previous recipe, with two key changes that are highlighted:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧菜单中选择**main.py**。将以下代码复制并粘贴到屏幕中央（显示该文件内容的地方）。你仍然需要你的OpenAI API密钥。如你所见，代码与之前的示例非常相似，有两个关键的变化已被高亮显示：
- en: '[PRE1]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, deploy the function by selecting the **Deploy** button at the bottom of
    your page. Wait for your function to be fully deployed, which typically takes
    two minutes. Make note of the Cloud Function URL. It is typically in the form
    **https://[location]-[project-name].cloudfunctions.net/[function-name]**.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过点击页面底部的**Deploy**按钮部署函数。等待函数完全部署，通常需要两分钟。记下云函数的URL，通常形式为**https://[location]-[project-name].cloudfunctions.net/[function-name]**。
- en: Now, we can test our function. Since we have created a Cloud Function that takes
    a JSON body as input, we need to use Postman to make the HTTP request to our public
    endpoint.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以测试我们的函数了。由于我们创建了一个接受JSON体作为输入的云函数，我们需要使用Postman向我们的公共端点发出HTTP请求。
- en: In Postman, create a new request by selecting the **New** button from the top
    left menu bar and then selecting **HTTP**.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Postman中，通过点击左上方菜单栏的**New**按钮然后选择**HTTP**来创建一个新请求。
- en: Change **HTTP Request type** from **GET** to **POST** by selecting the **Method**
    drop-down menu (by default, it will be set to **GET**).
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**Method**下拉菜单（默认为**GET**），将**HTTP请求类型**从**GET**更改为**POST**。
- en: Enter the Cloud Function URL from *step 9* as the **Endpoint**.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*第9步*中的云函数URL作为**Endpoint**输入。
- en: 'Select **Headers** in the sub-menu and add the following key-value pairs to
    the table below it:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在子菜单中选择**Headers**，并将以下键值对添加到下面的表格中：
- en: '| *Key* | *Value* |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| *键* | *值* |'
- en: '| --- | --- |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Content-Type` | `application/json` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `Content-Type` | `application/json` |'
- en: '14. Select **Body** in the sub-menu and then select **raw** for the request
    type. Enter the following request body. After that, select **Send**:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在子菜单中选择**Body**，然后选择**raw**作为请求类型。输入以下请求体。之后，点击**Send**：
- en: '[PRE2]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '15. After sending the HTTP request, you should see the following response from
    your public endpoint. Note that your message value may be different, but the structure
    should be the same:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 发送HTTP请求后，你应该会看到来自公共端点的以下响应。注意，你的消息值可能不同，但结构应保持一致：
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works…
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: In this recipe, we created a Cloud Function that simply was able to take in
    inputs and produce structured output. This is important as, when we build our
    intelligent applications, we will need to create endpoints like these that the
    application relies on.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建了一个云函数，它能够接受输入并生成结构化输出。这很重要，因为当我们构建智能应用时，我们需要创建像这样的端点，应用程序依赖于它们。
- en: To do this, we made two sets of edits to the Python code we used from the first
    recipe.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们对第一个示例中使用的 Python 代码进行了两次修改。
- en: Accepting inputs
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接受输入
- en: Cloud Functions have an object assigned to collect inputs made from HTTP Post
    requests. This object can be found as an argument to the input function, which
    in this case is `create_slogan_with_parameters (request)`, and so the object is
    `request`. This object stores the HTTP request (along with its request body and
    headers) and can be converted to JSON using the code. We can then parse through
    the JSON object to retrieve the particular input, which in this case is `name`,
    and assign it to the `business_description` variable.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 云函数有一个对象，用于收集来自 HTTP Post 请求的输入。这个对象作为输入函数的参数，在本例中是 `create_slogan_with_parameters
    (request)`，因此对象就是 `request`。这个对象存储了 HTTP 请求（包括其请求体和头部），并且可以通过代码转换为 JSON。我们随后可以解析
    JSON 对象来获取特定的输入，在这种情况下是 `name`，并将其赋值给 `business_description` 变量。
- en: In this way, we have created a Cloud Function that can take in and parse any
    input from the request body of HTTP requests.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们创建了一个云函数，能够从 HTTP 请求的请求体中接收并解析任何输入。
- en: Creating structured outputs
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建结构化输出
- en: 'Next, we need to return outputs from the Cloud Function in a structured form,
    such as JSON. Using JSON instead of a string to obtain outputs is important for
    two main reasons:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要以结构化的形式（如 JSON）从云函数返回输出。使用 JSON 而不是字符串来获取输出有两个主要原因：
- en: '*Structured multiple outputs*: JSON allows us to structure multiple data points
    in an organized manner. You can easily represent different outputs as separate
    key-value pairs within a single JSON object. This structure makes it straightforward
    to handle and access multiple pieces of data returned by the Cloud Function.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结构化的多个输出*：JSON 允许我们以有序的方式构建多个数据点。你可以轻松地将不同的输出表示为单个 JSON 对象内的独立键值对。这种结构使得处理和访问云函数返回的多个数据变得简单。'
- en: '*Nested and complex data*: JSON can handle nested structures, meaning you can
    have JSON objects within JSON objects. This feature is particularly useful when
    your Cloud Function needs to return complex data with multiple layers or hierarchical
    information.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*嵌套和复杂数据*：JSON 可以处理嵌套结构，意味着你可以在 JSON 对象内嵌套 JSON 对象。这个特性在你的云函数需要返回具有多个层次或层级信息的复杂数据时特别有用。'
- en: 'In the code, we did this in Python by defining a JSON object with two elements:
    `slogan` and `number of characters`. In this way, whoever or whatever uses our
    endpoint will be able to parse through these outputs with ease.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们通过定义一个包含两个元素的 JSON 对象来实现这一点：`slogan` 和 `number of characters`。通过这种方式，无论是谁或什么调用我们的端点，都能够轻松解析这些输出。
- en: In this recipe, we took another leap into creating intelligent applications
    with the OpenAI API, by creating an endpoint that takes in a user-defined customizable
    input, processes it, calls the OpenAI API, and then returns a structured JSON
    output that can be parsed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们通过创建一个端点，将用户自定义的可定制输入进行处理，调用 OpenAI API，然后返回可以解析的结构化 JSON 输出，迈出了构建智能应用的又一步。
- en: Calling the user-created endpoint from no-code applications
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从无代码应用程序调用用户创建的端点
- en: In this recipe, we will finalize the development process by creating an application
    (or a frontend user interface) that will call the public endpoint from the previous
    recipe. To do this efficiently, we will use a no-code application development
    platform called *Bubble*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将通过创建一个应用程序（或前端用户界面）来完成开发过程，应用程序将调用前面示例中的公共端点。为了高效地完成此操作，我们将使用一个名为*Bubble*的无代码应用程序开发平台。
- en: '**No-code application development** refers to a method of creating software
    applications without the need for traditional programming. It uses graphical interfaces
    and configuration instead of writing code in a programming language. This approach
    makes app development accessible to people without a programming background, democratizing
    the ability to create and deploy applications.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**无代码应用程序开发** 是一种无需传统编程的方式来创建软件应用程序。它使用图形界面和配置，而不是编写编程语言中的代码。这种方法使没有编程背景的人也能参与应用程序开发，民主化了创建和部署应用程序的能力。'
- en: Platforms such as Bubble are prominent examples of no-code development environments.
    Bubble is a popular no-code development platform that enables individuals and
    businesses to create web applications without the need for traditional programming.
    It enables users to create web applications with robust functionality without
    needing to understand or write any programming code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Bubble 这样的平台是无代码开发环境的典型例子。Bubble 是一个流行的无代码开发平台，使个人和企业能够在无需传统编程的情况下创建 Web 应用程序。它使用户能够创建具有强大功能的
    Web 应用程序，而无需理解或编写任何编程代码。
- en: This approach is increasingly popular for small businesses and start-ups, and
    within enterprise settings for developing internal tools and prototypes. Bubble
    also enables users to create applications that call public endpoints and APIs,
    which we will leverage in this recipe.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在小企业和初创公司中越来越流行，并且在企业环境中用于开发内部工具和原型。Bubble 还使用户能够创建调用公共端点和 API 的应用程序，我们将在本教程中利用这一功能。
- en: In this recipe, we will create a simple application in Bubble that calls the
    public endpoint we’ve created, that returns marketing slogans.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将创建一个简单的 Bubble 应用，它调用我们创建的公共端点，该端点返回营销口号。
- en: Getting ready
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You must create a Bubble account to follow this recipe. You can create a free
    Bubble account by following the steps at [http://bubble.io](http://bubble.io).
    There is no need to pay for a paid tier – all the features we will use in this
    book can be done through the free tier.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须创建一个 Bubble 账户才能按照本书的步骤操作。你可以通过访问 [http://bubble.io](http://bubble.io) 创建一个免费的
    Bubble 账户。无需支付付费套餐—本书中使用的所有功能都可以通过免费套餐完成。
- en: How to do it…
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: After you have created an account in Bubble and logged in, navigate to [https://bubble.io/home/apps](https://bubble.io/home/apps)
    and select **Create an app** in the top-right corner of the screen.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你创建并登录 Bubble 账户后，前往 [https://bubble.io/home/apps](https://bubble.io/home/apps)，然后选择屏幕右上角的
    **创建一个应用**。
- en: Leave the **Start from a template** option blank. Name your app something unique,
    such as **marketingslogan154**. Select the **Start with basic** **features** button.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 留空 **从模板开始** 选项。为你的应用取一个独特的名称，如 **marketingslogan154**。选择 **从基础功能开始** 按钮。
- en: If an option called **Skip application assistant** appears, select it, as we
    will be going through all the steps manually ourselves. You should now see the
    Bubble **UI Builder**, which is a blank canvas with a menu bar on the left-hand
    side, as shown in *Figure 5**.7*.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果出现名为 **跳过应用助手** 的选项，请选择它，因为我们将手动逐步完成所有步骤。现在你应该能看到 Bubble **UI Builder**，这是一个空白的画布，左侧是菜单栏，如
    *图 5.7* 所示。
- en: '![Figure 5.7 – Bubble UI Builder screen](img/B21007_05_07.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – Bubble UI Builder 屏幕](img/B21007_05_07.jpg)'
- en: Figure 5.7 – Bubble UI Builder screen
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – Bubble UI Builder 屏幕
- en: The first thing we are going to do is set up the endpoint/API connection. Select
    **Plugins** from the left-hand menu, and then select **Add plugins**.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是设置端点/API 连接。选择左侧菜单中的 **插件**，然后选择 **添加插件**。
- en: '![Figure 5.8 – Selecting plugins for our app](img/B21007_05_08.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – 为我们的应用选择插件](img/B21007_05_08.jpg)'
- en: Figure 5.8 – Selecting plugins for our app
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 为我们的应用选择插件
- en: Install the **API Connector** by selecting the **Install** button on the API
    Connector element. This will enable your Bubble app to call endpoints and APIs.
    After it has been installed, select **Done**.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择 **安装** 按钮来安装 **API 连接器** 元素。这将使你的 Bubble 应用能够调用端点和 API。安装完成后，选择 **完成**。
- en: After that, you should see the API connector on your **Plugins** page. Select
    the **Add another API** button. A set of configuration options will appear.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，你应该能在 **插件** 页面上看到 API 连接器。选择 **添加另一个 API** 按钮。一个配置选项的集合将会出现。
- en: 'Now, we need to initialize our API/endpoint connection. For the configuration
    options, select or type in the following. Note that you may need to select the
    *expand* button near `Content-Type` and `application/json`:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要初始化我们的 API/端点连接。对于配置选项，请选择或输入以下内容。请注意，您可能需要选择位于`Content-Type`和`application/json`旁边的*展开*按钮：
- en: '**Body** **type**: **JSON**'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正文** **类型**：**JSON**'
- en: '**Body**:'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正文**：'
- en: '[PRE4]'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Your screen should look like *Figure 5**.9*.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的屏幕应类似于*图 5.9*。
- en: '![Figure 5.9 – API Connector configurations](img/B21007_05_09.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – API 连接器配置](img/B21007_05_09.jpg)'
- en: Figure 5.9 – API Connector configurations
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – API 连接器配置
- en: Select the **Initialize** call button near the bottom of the page. If you do
    receive the *500 error*, review the previous recipe to ensure your endpoint/API
    is reachable and that it works. Sometimes, you may need to repeat this step multiple
    times if the GCP servers are busy at the time you are testing this call.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择页面底部附近的**初始化**调用按钮。如果您遇到*500 错误*，请检查前面的步骤，确保您的端点/API 可访问并且正常工作。有时，如果 GCP 服务器在您测试调用时很繁忙，您可能需要多次重复此步骤。
- en: You should now see a screen called **Returned values – API call**. Ensure that
    you see two rows and that for each row, the data type is set up correctly as shown
    as follows (these should be the default values). Select **Save**.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您应该会看到一个名为**返回值 – API 调用**的屏幕。确保看到两行数据，并且每一行的数据类型都正确设置，如下所示（这些应该是默认值）。选择**保存**。
- en: '| `number_of_characters` | `number` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `字符数` | `数字` |'
- en: '| --- | --- |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `slogan` | `text` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `slogan` | `text` |'
- en: Now that we have set up Bubble, let’s go ahead and add some elements. Select
    the **Design** button from the left-hand menu. Then select the **Text** element
    and drag it to the middle of the screen. You should now see the element highlighted,
    with a property menu for that element on the right side.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经设置好 Bubble，接下来让我们添加一些元素。从左侧菜单中选择**设计**按钮。然后选择**文本**元素，并将其拖动到屏幕中央。此时，您应该看到该元素被高亮显示，并且右侧会显示该元素的属性菜单。
- en: '![Figure 5.10 – Text element in Bubble UI Builder](img/B21007_05_10.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10 – Bubble UI 构建器中的文本元素](img/B21007_05_10.jpg)'
- en: Figure 5.10 – Text element in Bubble UI Builder
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – Bubble UI 构建器中的文本元素
- en: In the property menu, select the box that says **...edit me…** and select **Insert**
    **dynamic data**.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在属性菜单中，选择显示**...编辑我…**的框，并选择**插入** **动态数据**。
- en: In the drop-down menu, select **Get data from an external API** and a pop-up
    menu will appear on the left.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下拉菜单中，选择**从外部 API 获取数据**，左侧将弹出一个菜单。
- en: '![Figure 5.11 – Text menu from Bubble](img/B21007_05_11.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11 – Bubble 中的文本菜单](img/B21007_05_11.jpg)'
- en: Figure 5.11 – Text menu from Bubble
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – Bubble 中的文本菜单
- en: From the drop-down menu, select the API that was created in *step 7*. In the
    **Body (JSON object)** menu, ensure that it reflects the JSON data from *step
    7*. Then, select the text box and select **slogan**.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中，选择在*第 7 步*中创建的 API。在**正文（JSON 对象）**菜单中，确保它反映出*第 7 步*中的 JSON 数据。然后，选择文本框并选择**slogan**。
- en: '![Figure 5.12 – Text menu from Bubble](img/B21007_05_12.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12 – Bubble 中的文本菜单](img/B21007_05_12.jpg)'
- en: Figure 5.12 – Text menu from Bubble
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – Bubble 中的文本菜单
- en: Our no-code Bubble application is complete!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的无代码 Bubble 应用程序已经完成！
- en: Click the **Preview** button in the top-right corner of the screen to open the
    web application we have just created.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击屏幕右上角的**预览**按钮，以打开我们刚刚创建的 Web 应用程序。
- en: '![Figure 5.13 – Output in Bubble](img/B21007_05_13.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.13 – Bubble 中的输出](img/B21007_05_13.jpg)'
- en: Figure 5.13 – Output in Bubble
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 – Bubble 中的输出
- en: As you can see, we have now created a web application that generates slogans
    for ice cream companies. Continue refreshing the screen and you can see additional
    slogans.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，我们现在已经创建了一个生成冰淇淋公司标语的 Web 应用程序。继续刷新屏幕，您将看到更多的标语。
- en: Note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Every time you refresh the screen, you will use tokens from the OpenAI API,
    so it is wise not to do it too many times in a row.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 每次刷新屏幕时，您将使用 OpenAI API 的令牌，因此不宜连续刷新太多次。
- en: How it works…
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we created a frontend application that invoked the public endpoint
    that we set up in the previous recipe. This was the final building block in creating
    an intelligent application using the OpenAI API. We also did this completely using
    no-code tools.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们创建了一个前端应用程序，调用了我们在前一个步骤中设置的公共端点。这是使用 OpenAI API 创建智能应用程序的最终构建模块。我们也完全是使用无代码工具完成的。
- en: Bubble HTTP requests
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bubble HTTP 请求
- en: The main achievement of this recipe was being able to make an HTTP request from
    a frontend application such as Bubble. Most application platforms can make external
    API requests and this is certainly the case if you are building an application
    using traditional coding languages, such as JavaScript.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方案的主要成就是能够从前端应用程序（如 Bubble）发出 HTTP 请求。大多数应用平台都可以发出外部 API 请求，使用传统编程语言（如 JavaScript）构建应用程序时，也可以如此操作。
- en: In Bubble, we did this through the API connector plugin, which simplifies the
    process of integrating with external APIs. This plugin acts as a bridge between
    Bubble and the external service, allowing us to send and receive data seamlessly.
    By configuring the API connector with the appropriate endpoints, authentication,
    and parameters, we were able to extend the functionality of our Bubble application
    to interact with other web services.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Bubble 中，我们通过 API 连接器插件完成了这项工作，该插件简化了与外部 API 集成的过程。这个插件充当了 Bubble 与外部服务之间的桥梁，允许我们无缝地发送和接收数据。通过配置
    API 连接器与适当的端点、身份验证和参数，我们能够扩展 Bubble 应用程序的功能，与其他 web 服务进行交互。
- en: Connecting Bubble directly to OpenAI
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接将 Bubble 连接到 OpenAI
- en: It is worth noting why we had to create our own backend layer endpoint instead
    of connecting directly to OpenAI. Why did we have an intermediary layer?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们为什么必须创建自己的后台层端点，而不是直接连接到 OpenAI。为什么我们需要一个中间层？
- en: '*Security concerns*: Directly integrating external APIs, especially those handling
    sensitive data or requiring authentication, can pose security risks. By using
    a backend layer, sensitive information such as our OpenAI API keys or authentication
    tokens can be kept secure and not exposed in the client-side code that users may
    be able to see.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安全问题*：直接集成外部 API，特别是处理敏感数据或需要身份验证的 API，可能会带来安全风险。通过使用后台层，可以将敏感信息（如 OpenAI
    API 密钥或身份验证令牌）保密，避免在用户可能看到的客户端代码中暴露这些信息。'
- en: '*Data processing and caching*: The intermediary layer can process, filter,
    or cache the data before sending it to the frontend. This can optimize performance,
    reduce the load on the client side, and manage data flow more effectively. For
    example, we process the data in the backend to also extract **number_of_characters**.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据处理和缓存*：中间层可以在将数据发送到前端之前进行处理、过滤或缓存。这可以优化性能，减少客户端负担，更有效地管理数据流。例如，我们在后台处理数据时，还会提取**number_of_characters**。'
- en: '*Custom logic implementation*: The backend layer allows for the implementation
    of custom logic that might not be possible or efficient to handle on the client
    side. This includes data transformation, complex calculations, or decision-making
    processes based on the data received from OpenAI.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自定义逻辑实现*：后台层允许实现一些在客户端可能无法处理或不高效的自定义逻辑。这包括数据转换、复杂计算或基于从 OpenAI 接收到的数据进行决策的过程。'
- en: Overall, in this chapter, we took the significant next steps toward staging
    and hosting the OpenAI API and building an intelligent application. We did this
    by creating a backend layer that took in inputs, processed them, and produced
    structured outputs, and we proved that we could invoke this endpoint from a frontend
    application.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，在本章中，我们迈出了重要的一步，向 OpenAI API 的分阶段部署和托管以及构建智能应用程序迈进。我们通过创建一个后台层，接收输入、处理并生成结构化输出，证明了我们可以从前端应用程序调用这个端点。
