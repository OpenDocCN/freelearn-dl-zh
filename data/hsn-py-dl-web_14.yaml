- en: Securing Web Apps with Deep Learning
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用深度学习保障Web应用的安全
- en: Security is of the utmost importance to any website—and all software, in general.
    These days, security threats are evolving with the rise of available computing
    power and developments in the field of technology. So, it is important that websites
    employ the best possible measures of security to keep their data and user information
    secure. Websites with online commercial activities are always at high risk and
    it is very common for them to face security attacks that have not been seen before.
    New attacks are particularly difficult for rule-based security systems to identify
    and stop; so, you can look at the options offered by deep learning-powered security
    systems, which can effectively replace rule-based systems and are also capable
    of correctly identifying and blocking new threats.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性对任何网站而言都是至关重要的——同样对所有软件也是如此。如今，随着可用计算能力的增加以及技术领域的发展，安全威胁正在不断演变。因此，网站需要采用最好的安全措施来保护数据和用户信息的安全。具有在线商业活动的网站通常面临较高的风险，并且很常见它们会遭遇前所未见的安全攻击。新的攻击特别难以被基于规则的安全系统识别和阻止，因此，你可以考虑使用深度学习驱动的安全系统，这些系统能够有效替代基于规则的系统，并且能够正确识别和阻挡新的威胁。
- en: 'This chapter discusses several tricks and techniques that you can use to secure
    websites using deep learning with Python. We will present reCAPTCHA and Cloudflare
    and discuss how they are used to enhance the security of websites. We will also
    show you how to implement security mechanisms to detect malicious users on websites
    using deep learning-based techniques and a Python backend. The following topics
    will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了你可以使用深度学习与Python来保障网站安全的几种技巧和技术。我们将介绍reCAPTCHA和Cloudflare，并讨论它们如何用于增强网站的安全性。我们还将向你展示如何通过基于深度学习的技术和Python后端实现安全机制，以检测网站上的恶意用户。本章将涵盖以下主题：
- en: The story of reCAPTCHA
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: reCAPTCHA的故事
- en: DIY – malicious user detection on Django
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DIY——在Django中检测恶意用户
- en: Using reCAPTCHA in web applications with Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Web应用中使用Python的reCAPTCHA
- en: Website security with Cloudflare
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cloudflare提升网站安全
- en: We will begin this chapter's discussion with the story of reCAPTCHA—an ingenious
    tool, created by Google, that changed the internet.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的讨论将从reCAPTCHA的故事开始——这是一个由Google创建的巧妙工具，它改变了互联网。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can access the code for this chapter at [https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/tree/master/Chapter10).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下链接访问本章的代码：[https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/tree/master/Chapter10)。
- en: 'You''ll need the following software to run the code in this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要以下软件来运行本章的代码：
- en: Python 3.6+
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.6+
- en: TensorFlow 1.14
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TensorFlow 1.14
- en: Keras compatible with TensorFlow 1.14
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Keras兼容TensorFlow 1.14
- en: Django 2.x
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django 2.x
- en: The story of reCAPTCHA
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: reCAPTCHA的故事
- en: '*Easy on Humans, Hard on Bots*—that is the tagline of reCAPTCHA, which states
    the simple idea that reCAPTCHA is a system that establishes whether a user on
    an application or website is a genuine human user or an automated script. reCAPTCHA is
    a specific implementation of the CAPTCHA technology—a method that uses visuals
    with distorted, squiggly letters and numbers and challenges the user to decipher
    the contents of the visual image and write it out in a plain format.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*对人类友好，对机器人难*——这是reCAPTCHA的标语，表达了reCAPTCHA的基本理念：它是一个用来判定应用或网站上的用户是否为真实人类用户还是自动脚本的系统。reCAPTCHA是验证码技术的具体实现，采用扭曲、弯曲的字母和数字图像，挑战用户去解读并将其以简单的文本形式输入。'
- en: 'If you were a regular internet user in the early 2000s, you would have seen
    images resembling the following CAPTCHA on a number of websites:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是2000年代初的普通互联网用户，你可能在许多网站上看到过类似于以下的验证码（CAPTCHA）图片：
- en: '![](img/bdf82cb8-25df-4316-ab30-7c488e38f119.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bdf82cb8-25df-4316-ab30-7c488e38f119.png)'
- en: '**CAPTCHA** is an acronym for **Completely Automated Public Turing Test To
    Tell Computers and Humans Apart**.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**验证码（CAPTCHA）**是**完全自动化的公共图灵测试，用以区分计算机和人类**的缩写。'
- en: Popularized by Yahoo, the CAPTCHA system was rapidly adopted for use on millions
    of websites. However, despite the boost to security this system provided to websites,
    it was time-consuming and was often being beaten by rogue programmers. Every so
    often, people would create new CAPTCHA systems with varied designs and combinations
    of elements in the visuals.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: CAPTCHA系统由雅虎推广，迅速被数百万个网站采纳。然而，尽管这个系统为网站提供了安全性保障，它却耗时且经常被恶意程序员攻破。人们时不时会创建新的CAPTCHA系统，设计和视觉元素的组合各不相同。
- en: At the same time, developers were tackling a very different problem—one of digitizing
    printed books and other texts. A quick solution was to scan books; that is, using
    an **Optical Character Reader** (**OCR**) to convert books into preliminary digital
    text form. The conversions were fine for printed content that was made with standard
    fonts and whose scans were obtainable in good quality. However, the conversion
    accuracy suffered for malformed prints and manuscripts. People were increasingly
    uploading images to online platforms in the quest to extract text from those images
    and to use them for several purposes, such as determination of content in images,
    locations, or brands mentioned.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，开发者们正在解决另一个完全不同的问题——数字化印刷书籍和其他文本。一个快速的解决方案是扫描书籍；即使用**光学字符识别**（**OCR**）将书籍转换成初步的数字文本形式。对于使用标准字体且扫描质量良好的印刷内容，这些转换效果良好。然而，对于印刷不规范的书籍和手稿，转换的准确性则大打折扣。人们越来越多地将图像上传到在线平台，试图从这些图像中提取文本并用于多种目的，如确定图像中的内容、地点或品牌。
- en: The origin of CAPTCHA is disputed with claims of invention from multiple groups,
    but it was in 2003 that Luis von Ahn coined the term CAPTCHA, and he later became
    the founder of reCAPTCHA, which was acquired by Google.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: CAPTCHA的起源存在争议，多个小组声称自己是发明者，但正是在2003年，路易斯·冯·安创造了“CAPTCHA”这一术语，并随后成为了reCAPTCHA的创始人，该项目后来被谷歌收购。
- en: A pioneer of crowdsourcing, Luis von Ahn used the reCAPTCHA program to display
    very small chunks of text cropped from scans of printed books. Only humans would
    be able to solve these challenges easily, and automated programs would fail. At
    the same time, these books were being slowly digitized by contributions from a
    large number of human users, through unknown crowdsourcing activity. reCAPTCHA
    still remained a nuisance for users but the issue of digitizing books was solved.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 群体外包的先驱路易斯·冯·安（Luis von Ahn）使用reCAPTCHA程序来展示从印刷书籍扫描中裁剪出来的极小文本块。只有人类才能轻松解决这些挑战，而自动化程序会失败。与此同时，这些书籍正通过大量人类用户的贡献被缓慢地数字化，这是一种未知的群体外包活动。reCAPTCHA对用户而言仍然是一个麻烦，但书籍数字化的问题得以解决。
- en: Over time, reCAPTCHA evolved to use AI-based systems to identify real and fake
    users. At the time of writing this book, reCAPTCHA is being actively developed
    by Google and is currently on its third version, where it allows the invisible
    verification of users in the background of the web page and only displays a challenge
    when the user cannot be successfully verified. This saves a lot of time for genuine
    users and poses a challenge to machines.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，reCAPTCHA演变为使用基于AI的系统来识别真实用户和假用户。在写这本书时，reCAPTCHA仍在谷歌的积极开发下，目前已经进入第三个版本，它允许在网页的后台进行隐形验证，仅当用户无法成功验证时，才会显示挑战。这为真正的用户节省了大量时间，并对机器构成了挑战。
- en: We will now build a website to use deep learning-based models and reCAPTCHA
    to provide security elements to a website.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将构建一个网站，使用基于深度学习的模型和reCAPTCHA提供安全元素。
- en: Malicious user detection
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恶意用户检测
- en: A malicious user on a website is any user who attempts to perform tasks that
    they are not authorized to do. In today's world, the threats posed by malicious
    users are increasing exponentially, with huge databases of personal information
    from several global tech giants, government agencies, and other private firms
    being exposed to the public by hackers. It is important to have systems in place that
    can automatically mitigate these malicious attacks.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 网站上的恶意用户是指任何试图执行未授权任务的用户。在当今世界，恶意用户带来的威胁正在呈指数增长，多个全球科技巨头、政府机构和其他私营公司巨大的个人信息数据库被黑客公开曝光。必须建立能够自动缓解这些恶意攻击的系统。
- en: In order to recognize the malicious users in our sample web app, we have created
    a model that is able to learn the usual behavior of a user and raises the alarm
    if the user behavior at any instance changes significantly from their past usage.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别我们样本网站中的恶意用户，我们创建了一个模型，它能够学习用户的正常行为，并在用户的行为与过去的使用模式发生显著变化时发出警报。
- en: 'Anomaly detection is a popular branch of machine learning. It is a collection
    of algorithms that are used to detect data samples in a given dataset that do
    not fall along with the majority of the data sample properties. To detect a cat
    in a dog shelter would be anomaly detection. Anomaly detection is performed in
    several ways:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 异常检测是机器学习的一个热门分支。它是一组算法，用于检测给定数据集中的数据样本，这些样本与大多数数据样本的属性不一致。比如，在一个狗狗收容所中检测到一只猫就是异常检测。异常检测可以通过多种方式进行：
- en: By using minimum-maximum ranges of columns
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用列的最小最大范围
- en: By finding out sudden spikes in the plots of the data
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在数据的图表中发现突发的异常点
- en: By marking points lying on the extreme ends as outliers (anomalies) when data
    is plotted under a Gaussian curve
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据在高斯曲线下绘制时，将位于极端位置的点标记为异常（异常点）
- en: Support vector machines, k-nearest neighbors, and Bayesian networks are some
    of the most popular algorithms used for anomaly detection.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 支持向量机、k近邻和贝叶斯网络是一些最常用的异常检测算法。
- en: How can we define usual behavior for users on a website?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何定义用户在网站上的正常行为呢？
- en: Assume that you use a website where you normally log in using your laptop. Mostly,
    it takes you a maximum of two attempts to successfully log in to the website.
    If one day you suddenly start using a new laptop, the login would be suspicious
    and would probably be a malicious attempt to hack your account. It would be more
    so if the location of the new device was somewhere you have not been to recently
    or ever before. It would also be highly suspicious if you took 10 attempts to
    log in to your account. The state of not being in any suspicious state of usage
    is the usual behavior of the user on a website.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你使用一个网站，通常通过笔记本电脑登录。一般来说，你最多只需要两次尝试就能成功登录该网站。如果有一天你突然开始使用一台新笔记本电脑，那么登录过程就会显得可疑，可能是恶意尝试黑客入侵你的账户。如果新设备的位置是你最近没有去过的地方，或者是你从未去过的地方，那么就更加可疑。如果你尝试登录账户的次数达到10次，那么这种行为也会显得异常。没有任何可疑使用状态的情况是用户在网站上的正常行为。
- en: Sometimes, the anomaly may not be due to the irregular behavior of any specific
    user. Due to changes in the server, the regular traffic of the users and so their
    behavior might change. We have to be careful to not mark all users as malicious
    in such circumstances. Also, the irregular behavior of a user may be caused due
    to reasons other than hacking attempts on their account. If a genuine user suddenly
    starts accessing parts of the website that they should not have access to, it
    is an anomaly and needs to be prevented.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，异常可能不是由于某个特定用户的不正常行为引起的。由于服务器的变化，用户的常规流量以及他们的行为可能会发生变化。我们必须小心，避免在这种情况下将所有用户都标记为恶意用户。此外，用户的不正常行为可能是由于其他原因引起的，而不仅仅是黑客攻击他们的账户。如果一个真实的用户突然开始访问他们本不该访问的网站部分，这也是一种异常，需要加以防止。
- en: In our sample website, we will integrate a system like this. To do so, we will
    be putting a check on the login page of the website where we will try to determine
    whether a user's login is normal or anomalous. We will be taking into consideration
    the page that the user logs in from, as a website may have multiple login pages,
    and try to determine whether it is a usual page for the user to login from. If
    the user attempts to log in from a page that they generally do not log in from,
    we will mark it as an anomaly. This is just one simple criterion for checking
    anomalous users, with a scope of several hundreds of other parameters.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例网站中，我们将集成这样的系统。为此，我们将在网站的登录页面上进行检查，尝试确定用户的登录行为是正常的还是异常的。我们将考虑用户从哪个页面登录，因为一个网站可能有多个登录页面，并且尝试确定该页面是否是用户常用的登录页面。如果用户尝试从一个他们通常不登录的页面登录，我们将把它标记为异常。这只是一个简单的标准，用于检查异常用户，实际上还有数百个其他参数。
- en: An LSTM-based model for authenticating users
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于LSTM的用户身份验证模型
- en: 'We will break down this section into two major sub-sections:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这一部分分为两个主要子部分：
- en: Building the security check model
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建安全检查模型
- en: Hosting the model as an API
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模型托管为API
- en: Let's begin with the first section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一部分开始。
- en: Building a model for an authentication validity check
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建身份验证有效性检查模型
- en: 'To authenticate the user based on their login activity, we will need an API
    that checks the requests. We can build this model using the following steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据用户的登录活动对其进行身份验证，我们需要一个检查请求的API。我们可以按以下步骤构建此模型：
- en: 'Let''s begin by developing the authentication model that determines whether
    a user is not acting in a regular manner. We begin by importing the necessary
    modules in a Jupyter notebook running Python 3.6+, as shown:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从开发身份验证模型开始，该模型确定用户是否未按常规方式操作。我们在运行Python 3.6+的Jupyter笔记本中导入所需的模块，如下所示：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can now import the data into the project. We will be using the dataset at [https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/blob/master/Chapter10/model/data/data-full.csv](https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/blob/master/Chapter10/model/data/data-full.csv).
    We load the dataset into the project, as shown:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以将数据导入到项目中。我们将使用以下数据集：[https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/blob/master/Chapter10/model/data/data-full.csv](https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/blob/master/Chapter10/model/data/data-full.csv)。如下图所示，我们将数据集加载到项目中：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will see some general statistics about the data, as shown:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到关于数据的一些一般统计信息，如下所示：
- en: '![](img/db398383-b1d7-407a-9f2a-ed4f4223c548.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db398383-b1d7-407a-9f2a-ed4f4223c548.png)'
- en: 'You will observe that the data contains text, as shown:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现数据包含文本，如下所示：
- en: '![](img/8d84d0b7-32b3-4ac3-a3d1-d1ba262ee005.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d84d0b7-32b3-4ac3-a3d1-d1ba262ee005.png)'
- en: This observation is important and we'll be referring to this screenshot in future
    steps.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这一观察很重要，我们将在后续步骤中参考此屏幕截图。
- en: 'However, all the data is in string format. We need to convert it into appropriate
    types of values. Also, the dataset currently consists of just one DataFrame; we
    will break it into two parts—the training columns and the labels column—with the
    following code:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，所有的数据都是字符串格式。我们需要将其转换为适当类型的值。此外，数据集目前仅包含一个DataFrame；我们将使用以下代码将其拆分为两部分——训练列和标签列：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Also, we need to lose some of the columns as we only want to use features in
    the dataset that are relevant to our task:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，我们需要删除一些列，因为我们只想使用数据集中与我们任务相关的特征：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With this done, we are now ready to proceed with tokenizing the request body.
    Tokenizing is a method where we break large paragraphs down into sentences and
    sentences into words. We can perform tokenization with the following code:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，我们现在准备对请求主体进行标记。标记是一种方法，我们将大段的段落拆分为句子，并将句子拆分为单词。我们可以使用以下代码执行标记化：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With the tokenization done, we convert each request body entry into vectors.
    We do so because we need a numerical representation of the data for the computer
    to be able to perform calculations on it. After that, we further split the dataset
    into two more parts—75% of the dataset is for training and the rest is for testing
    purposes. Similarly, the labels column is split using the following code:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标记化完成后，我们将每个请求主体条目转换为向量。我们这样做是因为计算机需要对数据进行数值表示才能进行计算。然后，我们进一步将数据集分成两部分——75%的数据集用于训练，其余的用于测试。同样，使用以下代码将标签列拆分：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Remember from step 2 that this data mainly contained text. When it comes to
    text data, there is most likely a context and a specific order associated with
    it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，从第2步中可以看出，这些数据主要包含文本。在处理文本数据时，通常会有一个上下文和一个特定的顺序。
- en: For example, consider the words of this sentence—*Sachin Tendulkar is a great
    cricketer*. The order of the words must not be changed in order to convey the
    expected meaning. This is where the importance of maintaining order and context
    comes into the picture when you deal with text data in machine learning.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑这句话中的单词——*萨钦·坦度尔卡尔是一位伟大的板球运动员*。为了传达预期的含义，单词的顺序不能改变。在处理机器学习中的文本数据时，维护顺序和上下文的重要性就体现在这里。
- en: In our case, we will use a special type of recurrent neural network—**Long Short-Term
    Memory** (**LSTM**)—which will learn to recognize the regular user behavior.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将使用一种特殊类型的递归神经网络——**长短期记忆网络**（**LSTM**），它将学习识别常规用户行为。
- en: A detailed discussion on LSTM is beyond the scope of this book but if you are
    interested, you can refer to [http://bit.ly/2m0RWnx](http://bit.ly/2m0RWnx) to
    learn about it in detail.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对LSTM的详细讨论超出了本书的范围，但如果您感兴趣，可以参考[http://bit.ly/2m0RWnx](http://bit.ly/2m0RWnx)以获取详细信息。
- en: 'We now add the layers, along with the word embeddings, which helps maintain
    the relationship between the numerically encoded text and the actual words, using
    the following code:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们添加层和词嵌入，帮助保持数字编码文本与实际单词之间的关系，使用以下代码：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our output is a single neuron that either holds `0` or `1` in the case of a
    non-anomalous or an anomalous login attempt, respectively.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输出是一个单神经元，如果是非异常登录尝试则为 `0`，如果是异常登录尝试则为 `1`。
- en: 'We then compile the model and print a summary using the following code:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用以下代码编译模型并打印摘要：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The summary of the model is produced, as shown:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的摘要已生成，如下所示：
- en: '![](img/0a057f86-a447-49f8-a185-d82dc84ada58.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a057f86-a447-49f8-a185-d82dc84ada58.png)'
- en: 'Now, we are ready to move on to training the model:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好继续训练模型：
- en: 'We use the `fit()` method of the model as shown:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用模型的`fit()`方法，如下所示：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will quickly check the accuracy achieved by the model. We can see that the
    model is more than 96% accurate on the validation data. This score is quite impressive
    given that this is our first model. We can check the accuracy of the model using
    the following code:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将快速检查模型的准确性。我们可以看到该模型在验证数据上的准确率超过了 96%。考虑到这是我们的第一个模型，这个分数相当令人印象深刻。我们可以使用以下代码检查模型的准确性：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should see an output as in this screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到如下截图中的输出：
- en: '![](img/15fc01ad-104b-40c0-a6f4-5490fed2bbf6.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15fc01ad-104b-40c0-a6f4-5490fed2bbf6.png)'
- en: 'Let''s save these weights. We will use them to create an API that is used for
    authenticating the users. We can save the model using the following code:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们保存这些权重。我们将使用它们创建一个用于认证用户的 API。我们可以使用以下代码保存模型：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With the model ready, we can now move on to hosting it as a Flask API.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 模型准备好后，我们可以继续将其作为 Flask API 托管。
- en: Hosting the custom authentication validation model
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 托管自定义认证验证模型
- en: 'Let''s now create the API that will accept the login attempt from the user
    and return its confidence in the validity of the login:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个 API，该 API 将接受用户的登录尝试并返回对登录有效性的信心值：
- en: 'We begin by importing the required modules for creating a Flask server, as
    shown:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先导入创建 Flask 服务器所需的模块，如下所示：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We now need to import the saved model and weights from the `model` training
    step. Once we do so, we need to recompile the model and make its `predict` function
    using the `make_predict_function()` method:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要导入从`model`训练步骤中保存的模型和权重。一旦导入，我们需要重新编译模型并使用`make_predict_function()`方法创建其`predict`函数：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will be using a data cleaning function to strip out numbers and other non-useful
    text in the incoming queries from the client app:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用一个数据清理函数，从客户端应用程序中剥离数字和其他无用文本：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, we create the `/login` route in the app, which will accept the login credentials
    and other request header details from the client app when the user attempts to
    log in. Notice that we still drop out some extra request headers as we did during
    the training.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在应用程序中创建 `/login` 路由，当用户尝试登录时，该路由将接受客户端应用程序的登录凭证和其他请求头信息。请注意，我们仍然像训练时那样去掉了一些额外的请求头。
- en: 'Once we clean the data, we tokenize and vectorize it. These steps are the same
    as the preprocessing we did during training. This is to ensure that the incoming
    request is processed exactly as it was during the training phase:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理完数据后，我们对其进行标记化和向量化。这些步骤与我们在训练期间所做的预处理相同。这样做是为了确保传入的请求与训练阶段处理方式一致：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Finally, the app returns its confidence in the user being authenticated in the
    form of a JSON.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，应用程序以 JSON 格式返回其对用户认证的信心值。
- en: 'To run the server on the desired port, we need to add the following lines at
    the end of the script:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在所需端口上运行服务器，我们需要在脚本末尾添加以下几行：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Lastly, we save the server script file as `main.py`. We will get the server
    running by using the following command on the system:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将服务器脚本文件保存为`main.py`。我们将通过在系统上使用以下命令来启动服务器：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will start the Flask server, which listens in on the loopback IP `127.0.0.1`,
    and at port `9000`. You can easily host this script on a virtual machine in the
    cloud and make it available to all your apps and websites as a common security
    checkpoint API.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动 Flask 服务器，该服务器在回环 IP `127.0.0.1` 和端口 `9000` 上监听。你可以轻松地将此脚本托管在云中的虚拟机上，并作为通用安全检查点
    API，使其对所有应用程序和网站开放。
- en: We can now move on to creating our web app that runs on the Django framework.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续创建在 Django 框架上运行的 Web 应用程序。
- en: A Django-based app for using an API
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于 Django 的应用程序，用于使用 API
- en: The website that we are creating to consume the user-authentication check API
    will be a simple billboard demo. The website will have provisions for users to
    log in and then post bills to a billboard. While the app is simple, it contains
    two major features of deep learning-based security integrations—anomaly detection
    during user authentication and the implementation of reCAPTCHA during posting
    bills—to avoid spam.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的网站用于调用用户认证检查 API，将是一个简单的公告板演示。该网站将允许用户登录，然后将账单发布到公告板。虽然该应用程序很简单，但它包含基于深度学习的安全集成的两个主要功能——用户认证过程中的异常检测和发布账单时实现
    reCAPTCHA——以避免垃圾邮件。
- en: The steps to create the application are discussed in the following sections.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 创建应用程序的步骤将在以下部分讨论。
- en: The Django project setup
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Django 项目设置
- en: In this section, we'll be working with Django. Make sure that you have a working
    Django installation on your system before proceeding with this section. You can
    find installation instructions for Django in the *A brief introduction to Django
    web development* section in [Chapter 8](3bf31fe1-d41c-4410-a83c-1651da439c70.xhtml)*,
    Deep Learning on Microsoft Azure Using Python*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 Django。请确保在继续本节之前，您的系统上已安装了 Django。您可以在[第8章](3bf31fe1-d41c-4410-a83c-1651da439c70.xhtml)*，《在
    Microsoft Azure 上使用 Python 进行深度学习》*一节中的 *简要介绍 Django Web 开发* 部分找到 Django 的安装说明。
- en: 'Now, we will create a Django project. To do so, we use the following command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个 Django 项目。为此，我们使用以下命令：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will create the `webapp` directory in the current folder. We will be adding
    all of our future code in this directory. The current directory structure looks
    as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建当前文件夹中的`webapp`目录。我们将在此目录中添加所有未来的代码。当前的目录结构如下所示：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With this done, we are now ready to create an app inside the project, which
    is shown in the next section.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此步骤后，我们现在准备好在项目中创建应用程序，具体内容将在下一部分展示。
- en: Creating an app in the project
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在项目中创建应用程序
- en: 'As discussed in [Chapter 8](3bf31fe1-d41c-4410-a83c-1651da439c70.xhtml), *Deep
    Learning on Microsoft Azure Using Python*, we must now add apps to the website
    project. To do so, we use the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[第8章](3bf31fe1-d41c-4410-a83c-1651da439c70.xhtml)中讨论的，*使用 Python 在 Microsoft
    Azure 上进行深度学习*，我们现在必须将应用程序添加到网站项目中。为此，我们使用以下命令：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding command will create an app called `billboard` in the project.
    However, we still have to link this app to the project.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将创建一个名为`billboard`的应用程序。然而，我们仍然需要将此应用程序与项目连接。
- en: Linking the app to the project
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将应用程序链接到项目
- en: 'To add the app to the project, we need to add the app name to the list of apps
    in `settings.py` in the project settings file, as in the following code. In `settings.py`,
    add the following change:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要将应用程序添加到项目中，我们需要在项目设置文件`settings.py`的应用程序列表中添加应用程序名称，如下所示。在`settings.py`中，添加以下更改：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With this, we are ready to create the routes on the website.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们准备好在网站上创建路由。
- en: Adding routes to the website
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向网站添加路由
- en: 'To add routes to the project, we edit the `urls.py` file of `webapp`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要向项目添加路由，我们需要编辑`webapp`的`urls.py`文件：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: However, the `billboard.urls` path does not exist. We'll create the path to
    proceed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`billboard.urls`路径并不存在。我们将创建该路径以继续。
- en: Creating the route handling file in the billboard app
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在公告板应用中创建路由处理文件
- en: 'Create a new file, called `urls.py`, in the `billboard` folder, as shown:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在`billboard`文件夹中创建一个名为`urls.py`的新文件，如下所示：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Save this as `webapp/billboard/urls.py`. Notice that we have imported some `views` items
    to this route handling file. Also, we have used the `login_required` method. This
    indicates that we can start working on the authentication of the website.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存为`webapp/billboard/urls.py`。注意，我们已经将一些`views`项导入到此路由处理文件中。同时，我们使用了`login_required`方法。这表示我们可以开始进行网站的认证工作。
- en: Adding authentication routes and configurations
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加认证路由和配置
- en: 'To add the routes for authentication, add the following at the end of the `webapp/settings.py`
    file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加认证的路由，在`webapp/settings.py`文件的末尾添加以下内容：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: These lines indicate that we will need a `/login` and a `/logout` route.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行表示我们需要一个`/login`和一个`/logout`路由。
- en: Creating the login page
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建登录页面
- en: 'To create the login page, we''ll need to add the `/login` route to `urls.py`
    in the billboard app. However, we''ve already done that. Next, we need to add
    the `loginView` view to the `views.py` file of the billboard app:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建登录页面，我们需要将`/login`路由添加到公告板应用中的`urls.py`文件中。然而，我们已经完成了这一步。接下来，我们需要将`loginView`视图添加到公告板应用的`views.py`文件中：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding function first checks whether the username and password being
    passed to it exist in the user database. So, we'll need a user model, in the future,
    to store users in the database file, `db.sqlite3`, which was created during the
    project creation step.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数首先检查传入的用户名和密码是否存在于用户数据库中。因此，我们将需要一个用户模型，将来将用户存储在`db.sqlite3`数据库文件中，该文件是在项目创建步骤中创建的。
- en: 'The function will then make a call to the authentication check model API to
    validate whether the user login is of normal behavior. The validation is carried
    out as in the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，函数将调用身份验证检查模型API，以验证用户登录是否符合正常行为。验证过程如以下代码所示：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding code block validates the user login and, if it's found to be invalid,
    performs a logout action and redirects the user back to log in again.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块验证用户登录，如果发现无效，则执行注销操作并将用户重定向回重新登录。
- en: 'We''ll need to add some necessary imports to the `view.py` file for this, as
    shown:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要在`view.py`文件中添加一些必要的导入，如下所示：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice that we also imported the `logout` method from `django.contrib.auth`.
    This will be used to create a `logout` view.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还从`django.contrib.auth`导入了`logout`方法。它将用于创建`logout`视图。
- en: Creating a logout view
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建注销视图
- en: 'Now, let''s create the `logout` view. This is very simple to do, as shown:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建`logout`视图。这非常简单，如下所示：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, let's create a template of the login page.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建登录页面的模板。
- en: Creating a login page template
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建登录页面模板
- en: To create a template, we first need to create the folders required.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建模板，我们首先需要创建所需的文件夹。
- en: 'Create a folder called `templates` in the `billboard` directory. The directory
    structure will now look as in the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在`billboard`目录下创建一个名为`templates`的文件夹。目录结构将如下所示：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Inside the `templates` folder, we'll place our template files. Let's first create `base.html`,
    which we will extend in all other templates. This will contain the `CSS` and `JS`
    includes, along with the general block structure of the page.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在`templates`文件夹中，我们将放置我们的模板文件。首先创建`base.html`，我们将在所有其他模板中扩展它。它将包含`CSS`和`JS`引入，以及页面的通用块结构。
- en: We have provided a sample of this file at [https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/blob/master/Chapter10/webapp/billboard/templates/base.html](https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/blob/master/Chapter10/webapp/billboard/templates/base.html).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/blob/master/Chapter10/webapp/billboard/templates/base.html](https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/blob/master/Chapter10/webapp/billboard/templates/base.html)提供了此文件的示例。
- en: 'Once this is done, we''re ready to create the `login.html` file, which will
    carry out the process of sending the login values to the server:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，我们就可以创建`login.html`文件，它将执行将登录值发送到服务器的过程：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that we have extended the `base.html` template in the preceding view
    template.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在前述视图模板中扩展了`base.html`模板。
- en: You can read more about extending Django templates at [https://tutorial.djangogirls.org/en/template_extending/](https://tutorial.djangogirls.org/en/template_extending/).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://tutorial.djangogirls.org/en/template_extending/](https://tutorial.djangogirls.org/en/template_extending/)了解更多关于扩展Django模板的信息。
- en: The form in this login page makes a `POST` request and so requires the passing
    of the CSRF token. We can now create the page that renders after the login is
    done.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 登录页面中的表单发出`POST`请求，因此需要传递CSRF令牌。现在我们可以创建在登录完成后渲染的页面。
- en: The billboard page template
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公告板页面模板
- en: 'Since we''ve already set up the `base.html` file, we can simply extend it in
    the `board.html` template file to create the billboard display page:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经设置了`base.html`文件，因此可以简单地在`board.html`模板文件中扩展它，以创建公告板展示页面：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding block of code, we have iterated over all the available `bills` items
    in the billboard's database and displayed them using a `for` loop in the template.
    The use of the `base.html` template allows us to reduce the amount of repeated
    code in the view templates.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码块中，我们遍历了公告板数据库中所有可用的`bills`项，并通过`for`循环在模板中显示它们。使用`base.html`模板使我们能够减少视图模板中的重复代码量。
- en: After this, we will create the page that will have the code to add a new bill
    to the billboard.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个页面，页面中将包含添加新账单到公告板的代码。
- en: Adding to Billboard page template
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加到公告板页面模板
- en: 'To create the page template that adds a bill to the billboard, we use the following
    code to create the `add.html` template file:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建将账单添加到公告板的页面模板，我们使用以下代码创建`add.html`模板文件：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding block of code, we have extended the `base.html` template to
    add a form that allows us to add bills. Notice the use of the CSRF token in the
    `form` element. In Django, we always need to pass valid CSRF tokens while making
    POST requests.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们扩展了 `base.html` 模板，添加了一个表单，允许我们添加账单。请注意在 `form` 元素中使用了 CSRF token。在
    Django 中，我们在进行 POST 请求时，始终需要传递有效的 CSRF token。
- en: You can read more about CSRF tokens in Django at [https://docs.djangoproject.com/en/3.0/ref/csrf/](https://docs.djangoproject.com/en/3.0/ref/csrf/).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://docs.djangoproject.com/en/3.0/ref/csrf/](https://docs.djangoproject.com/en/3.0/ref/csrf/)
    阅读更多关于 CSRF token 的内容。
- en: But wait, we've not yet added the views to handle the billboard page and the
    addition of the bills page. Let's add them now!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等，我们还没有添加处理公告板页面和添加账单页面的视图。现在就来添加吧！
- en: The billboard model
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公告板模型
- en: We need to add the views to see all the bills on the billboard page. However,
    for this, we first need to create the model to hold all the bills.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加视图来查看公告板页面上的所有账单。不过，为此，我们首先需要创建一个模型来存储所有账单。
- en: 'In the `models.py` file, add the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `models.py` 文件中，添加以下代码：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, we created a new model called `Bills`. This will store
    the details for all of the bills added by users on the billboard. The `user` model
    is linked with this model as a foreign key. Save this file as `webapp/billboard/models.py`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个名为 `Bills` 的新模型。这个模型将存储用户在公告板上添加的所有账单的详细信息。`user` 模型通过外键与这个模型关联。将此文件保存为
    `webapp/billboard/models.py`。
- en: You can read more about foreign keys and other keys at [https://www.sqlite.org/foreignkeys.html](https://www.sqlite.org/foreignkeys.html).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://www.sqlite.org/foreignkeys.html](https://www.sqlite.org/foreignkeys.html)
    阅读更多关于外键和其他键的信息。
- en: With this done, we can now use the `Bills` model in the views.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，我们现在可以在视图中使用 `Bills` 模型了。
- en: Creating the billboard view
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建公告板视图
- en: To start using the `Bills` model in the app, we first need to import it to the
    `views.py` file.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要在应用中开始使用 `Bills` 模型，首先需要将其导入到 `views.py` 文件中。
- en: 'Add the following line at the top of the `view.py` file:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `view.py` 文件的顶部添加以下代码：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we can add the view for the billboard, as shown:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以添加公告板的视图，如下所示：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Next, we need to create the view for adding the bills.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个用于添加账单的视图。
- en: Creating bills and adding views
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建账单并添加视图
- en: 'In this view, we will create the bills. If a valid `POST` request is made to
    the route served by the `addbill` method, we create a new `Bill` object and save
    it to the database. Otherwise, we display the form for adding bills to the user.
    Let''s see how we can do this in the following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个视图中，我们将创建账单。如果收到有效的 `POST` 请求，我们会创建一个新的 `Bill` 对象并保存到数据库中。否则，我们会显示添加账单的表单给用户。我们来看一下如何在以下代码中实现：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: However, we still need to create the admin user before using the app.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用该应用之前，我们仍然需要创建管理员用户。
- en: Creating the admin user and testing it
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建管理员用户并进行测试
- en: 'To create the admin user, we use the following command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建管理员用户，请使用以下命令：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can now migrate the database change by using the following commands:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令迁移数据库更改：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'An output similar to the following is produced:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 会生成如下所示的输出：
- en: '![](img/e0506807-c8f7-4fa1-b8c1-2b79d7600dd8.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0506807-c8f7-4fa1-b8c1-2b79d7600dd8.png)'
- en: Now, let's secure the billboard postings using the reCAPTCHA tool.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 reCAPTCHA 工具来保护公告板的发布内容。
- en: Using reCAPTCHA in web applications with Python
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Web 应用中使用 Python 和 reCAPTCHA
- en: 'To add the reCAPTCHA to the website, we first need to obtain the API keys from
    the Google reCAPTCHA console:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 reCAPTCHA 添加到网站中，首先需要从 Google reCAPTCHA 控制台获取 API 密钥：
- en: First, log in to your Google account and go to [https://www.google.com/recaptcha](https://www.google.com/recaptcha).
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，登录到您的 Google 账户，并访问 [https://www.google.com/recaptcha](https://www.google.com/recaptcha)。
- en: Next, click on Admin Console at the top-right.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击右上角的 Admin Console。
- en: Add your site to the console by following the steps shown on your screen. If
    you're testing on your local system, you'll have to specify `127.0.0.1` as one
    of the URLs.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照屏幕上的步骤将您的网站添加到控制台。如果您在本地系统上进行测试，您需要将 `127.0.0.1` 作为其中一个网址指定。
- en: Obtain the API keys for your domain.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取您的域名的 API 密钥。
- en: 'The screen that you get your domain''s API keys on should look similar to the
    following screenshot:'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您在获取域名 API 密钥的页面应该类似于以下截图：
- en: '![](img/fee62e08-e223-469d-a77e-82bac332aa67.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fee62e08-e223-469d-a77e-82bac332aa67.png)'
- en: 'Now, add the secret key to the `settings.py` file of the web app, as shown:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将密钥添加到 web 应用的 `settings.py` 文件中，如下所示：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we need to add the scripts to be loaded to the `add.html` template. We''ll
    add it to the billboard app page template, as shown:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将要加载的脚本添加到`add.html`模板中。我们将其添加到广告牌应用页面模板中，如下所示：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that the key used in this step is the client/site key.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此步骤中使用的密钥是客户端/站点密钥。
- en: 'Finally, we need to validate the reCAPTCHA in the add billboard view, as shown:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要在添加广告牌视图中验证reCAPTCHA，如下所示：
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You can grab the full working version of the `addbill` method in the previous
    code block from [https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/blob/master/Chapter10/webapp/billboard/views.py](https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/blob/master/Chapter10/webapp/billboard/views.py).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下链接获取前述代码块中的`addbill`方法的完整工作版本：[https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/blob/master/Chapter10/webapp/billboard/views.py](https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/blob/master/Chapter10/webapp/billboard/views.py)。
- en: 'With the previous changes made, we''re finally ready to test run the website
    with all its security measures in place. Run the following command to start the
    website server:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成前述更改后，我们终于准备好进行网站的测试，确保所有安全措施已到位。运行以下命令启动网站服务器：
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You should be able to see the website''s login page, as shown:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够看到网站的登录页面，如下所示：
- en: '![](img/6be54474-9af3-4242-a2ac-c55719a38b51.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6be54474-9af3-4242-a2ac-c55719a38b51.png)'
- en: Note that at this point, you'll need to have the Flask server, which performs
    the login validation, running at the same time.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此时，你需要同时运行Flask服务器来执行登录验证。
- en: 'Upon login, you''ll see the billboard page with bills posted on it. Head over
    to the Add Bill button to add a new bill, as shown:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，你将看到带有账单的广告牌页面。点击“添加账单”按钮以添加新账单，如下所示：
- en: '![](img/d28fc58c-b859-4882-869e-c5c3d783772d.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d28fc58c-b859-4882-869e-c5c3d783772d.png)'
- en: Notice the reCAPTCHA logo at the bottom-right corner of the screen. This indicates
    that the page is protected against spamming by using reCAPTCHA. If you are able
    to post successfully, the billboard is displayed again with the submitted bill.
    If not, you'll be presented with a reCAPTCHA verify challenge.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意屏幕右下角的reCAPTCHA标志。这表示该页面已通过使用reCAPTCHA防止垃圾信息。如果你能够成功提交，广告牌将显示已提交的账单。如果未成功提交，你将看到一个reCAPTCHA验证挑战。
- en: Website security with Cloudflare
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cloudflare提升网站安全性
- en: Cloudflare is the industry's leading web infrastructure and website security
    provider. It creates a layer of security and fast content delivery between a website
    and its users, hence routing all the traffic through its servers, which enables
    security and other features on websites. In 2017, Cloudflare provided DNS services
    to over 12 million websites. These services include content delivery networks,
    **Distributed Denial of Service** (**DDoS**) attack protection, hacking attempt
    protection, and other internet security services, such as leeching protection.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Cloudflare是业内领先的网络基础设施和网站安全提供商。它在网站与用户之间创建了一个安全层和快速内容传输层，从而将所有流量通过其服务器路由，这使得网站能够实现安全保护和其他功能。2017年，Cloudflare为超过1200万个网站提供了DNS服务。这些服务包括内容分发网络、**分布式拒绝服务（**DDoS**）**攻击保护、黑客攻击防护，以及其他互联网安全服务，如防止盗链。
- en: In 2014, Cloudflare reported mitigating a 400 Gib/s DDoS attack on a customer,
    which was soon followed by a 500 Gib/s attack the next year. The largest attack
    on any website recorded has been on GitHub, where it faced a DDoS of 1.4Tb/s flooding.
    GitHub was using Akamai Prolexic (an alternative to Cloudflare) and was able to
    withstand the attack, going down only for 10 minutes before coming back up entirely.
    Cloudflare offers DDoS protection to all its users free of charge.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年，Cloudflare报告成功缓解了一次400 Gib/s的DDoS攻击，目标是某客户，随后在第二年发生了500 Gib/s的攻击。迄今为止，最大规模的DDoS攻击发生在GitHub，GitHub遭遇了1.4Tb/s的洪水式攻击。GitHub当时使用的是Akamai
    Prolexic（Cloudflare的替代品），成功抵御了这次攻击，网站仅停机了10分钟后就完全恢复了。Cloudflare为所有用户免费提供DDoS防护。
- en: 'To get started with deploying the services of Cloudflare on your website, you
    need to set up Cloudflare as an intermediate layer between your users and the
    hosting server. The following diagram depicts how Cloudflare sits on the network:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始在你的网站上部署Cloudflare服务，你需要将Cloudflare设置为用户与托管服务器之间的中介层。以下图示展示了Cloudflare如何在网络中部署：
- en: '![](img/ada2acb7-d8a7-4b38-8329-e7e64ba13a85.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ada2acb7-d8a7-4b38-8329-e7e64ba13a85.png)'
- en: So, the detection of spam and malicious users that we created the previous custom
    solutions for, with the help of Google's reCAPTCHA, is automatically taken care
    of by Cloudflare to a basic extent (in the free tier, with more powerful solutions
    in the higher tiers as you upgrade). It is, therefore, very intuitive and simple
    for a small team of developers to push off their security needs to Cloudflare's
    systems and to rest assured that they are protected against a number of security
    breaches.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过 Google 的 reCAPTCHA 的帮助，我们之前为垃圾邮件和恶意用户创建的定制解决方案，Cloudflare 已在基础层面（免费层次中，升级后更强大的解决方案会出现在更高的层级）自动处理了。这使得小型开发团队能够轻松地将安全需求交给
    Cloudflare 的系统，并放心他们会受到保护，免受一系列安全漏洞的影响。
- en: Summary
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw how we can provide security to websites using Cloudflare's
    services. We also saw how to create security APIs that can be used in integration
    with web applications and other security services such as reCAPTCHA. It is crucial
    for any website—small or large—to have these security measures in place in order
    for their website services to function properly. There have been major breaches
    in recent times, and countless others that have been attempted by AI-powered systems
    that do not make it onto the news because they were not an issue. Security using
    deep learning is a burning topic of research and it is believed that in the near
    future, security systems will all rely strongly on deep learning to recognize
    and eliminate threats.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何利用 Cloudflare 的服务为网站提供安全保护。我们还学习了如何创建可以与 Web 应用程序以及其他安全服务（如 reCAPTCHA）集成使用的安全
    API。对于任何网站——无论大小——都至关重要，必须实施这些安全措施，以确保其网站服务正常运行。近期发生了重大数据泄露事件，还有许多尝试被 AI 驱动的系统进行的攻击，尽管它们没有成为新闻报道，因为它们并未引起问题。利用深度学习进行安全防护是一个热门的研究课题，预计在不久的将来，所有的安全系统将会高度依赖深度学习来识别和消除威胁。
- en: In the next chapter, we will discuss how to set up a production-grade deep learning
    environment. We will discuss the architecture designs you could follow, depending
    on their size requirements, and the state-of-the-art service providers and tools.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何设置一个生产级别的深度学习环境。我们将讨论根据需求规模，可以遵循的架构设计，以及最先进的服务提供商和工具。
