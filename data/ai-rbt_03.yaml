- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Conceptualizing the Practical Robot Design Process
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构想实用机器人设计过程
- en: This chapter represents a *bridge* between the preceding chapters on general
    theory, introduction, and setup, and the following chapters, where we will apply
    problem-solving methods that use **artificial intelligence** (**AI**) techniques
    to robotics. The first step is to clearly state our problem, from the perspective
    of the use of the robot, which is different from our view as the designer/builder
    of the robot. Then, we need to decide how to approach each of the hardware- and
    software-based challenges that we and the robot will attempt. By the end of this
    chapter, you will be able to understand the process of how to design a robot systematically.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代表了前几章关于一般理论、介绍和设置的桥梁，以及接下来的章节，我们将应用使用人工智能技术（**AI**）的解决问题的方法。第一步是清楚地表述我们的问题，从机器人的使用角度出发，这与作为机器人设计师/建造者的我们的观点不同。然后，我们需要决定如何应对我们和机器人将尝试的每个基于硬件和软件的挑战。到本章结束时，你将能够理解如何系统地设计机器人的过程。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: A systems engineering-based approach to robotics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于系统工程的机器人方法
- en: Understanding our task – cleaning up the playroom
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解我们的用例范围
- en: How to state the problem with the help of use cases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何借助用例来表述问题
- en: How to approach solving problems with storyboards
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过故事板来解决问题
- en: Understanding the scope of our use case
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解我们的用例范围
- en: Identifying our hardware needs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定我们的硬件需求
- en: Breaking down our software needs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件需求分解
- en: Writing a specification
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写规范
- en: A systems engineering-based approach to robotics
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于系统工程的机器人方法
- en: When you set out to create a complex robot with AI-based software, you can’t
    just jump in and start slinging code and throwing things together without some
    sort of game plan as to how the robot goes together and how all the parts communicate
    with one another. We will discuss a systematic approach to robot design based
    on **systems engineering** principles. We will be learning about use cases and
    will use storyboards as techniques to understand what we are building and what
    parts – hardware and software – are needed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当你着手创建一个基于人工智能软件的复杂机器人时，你不能没有某种关于机器人如何组装以及所有部件如何相互通信的游戏计划就盲目地开始编写代码和拼凑东西。我们将讨论基于**系统工程**原则的机器人设计系统方法。我们将学习用例，并使用故事板作为理解我们正在构建的内容以及需要哪些部分（硬件和软件）的技术。
- en: Understanding our task – cleaning up the playroom
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解我们的任务 – 清理游戏室
- en: We have already talked a bit about our main task for Albert, our example robot
    for this book, which is to clean up the playroom in my house after my grandchildren
    come to visit. We need to provide a more formal definition of our problem, and
    then turn that into a list of tasks for the robot to perform along with a plan
    of action on how we might accomplish those tasks.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经就本书的示例机器人 Albert 的主要任务谈了一些内容，这个机器人是用来在我孙子辈来访后清理我家的游戏室的。我们需要为我们的问题提供一个更正式的定义，然后将其转化为机器人要执行的列表任务，以及我们可能如何完成这些任务的行动计划。
- en: 'Why are we doing this? Well, consider this quote by Steve Maraboli:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要这样做呢？让我们考虑一下史蒂夫·马拉博利的这句话：
- en: “If you don’t know where you are going, how do you know when you get there?”
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: “如果你不知道你要去哪里，你怎么知道你到了那里？”
- en: '![Figure 3.1 – It’s important to know what your robot does](img/B19846_03_1.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 了解你的机器人做什么很重要](img/B19846_03_1.jpg)'
- en: Figure 3.1 – It’s important to know what your robot does
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 了解你的机器人做什么很重要
- en: 'The internet and various robot websites are littered with dozens of robots
    that share one fatal character flaw: the robot and its software were designed
    first and then they went out to look for a job for it. In the robot business,
    this is called the **ready, fire, aim problem**. The task, the customer, the purpose,
    the use, and the job of the robot comes first. Another way of saying this is:
    to create an effective tool, the first step is to decide what you do with it.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网和各种机器人网站上充斥着成百上千的机器人，它们有一个共同的致命缺陷：机器人和它的软件是先设计出来的，然后才去寻找适合它的工作。在机器人行业中，这被称为**有备无患，瞄准再射击的问题**。机器人的任务、客户、目的、用途和工作是首要的。另一种说法是：要创造一个有效的工具，第一步是决定你用它做什么。
- en: I could have written this book as a set of theories and exercises that would
    have worked well in a classroom setting, which would have introduced you to a
    whole lot of new tools you would not know how to apply. However, this chapter
    is here to provide you with tools and methods to provide a path from having a
    good idea to having a good robot, with as little misdirection, pain, suffering,
    tears, and torn-out hair as possible.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我本可以将这本书写成一套理论和练习，这些在课堂环境中会非常有效，这将让你接触到许多你不知道如何应用的新工具。然而，这一章的目的在于为你提供工具和方法，以尽可能少的误导、痛苦、苦难、眼泪和拔掉的头发，从有一个好想法到拥有一个优秀的机器人提供一个路径。
- en: Important note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You are on your own with burns; please be careful with the soldering iron.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在烧伤方面，你需要自己小心处理；请在使用烙铁时格外小心。
- en: 'The process we will use is straightforward:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的流程是直接的：
- en: The first step is to look at the robot from the user’s perspective and then
    describe what it does. We will call these descriptions **use cases** – examples
    of how the robot will be used.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是从用户的角度审视机器人，然后描述它的功能。我们将把这些描述称为**用例**——机器人将被如何使用的例子。
- en: Next, we will break each use case down into **storyboards** (step-by-step illustrations),
    which can be word pictures or actual pictures. From the storyboards, we can extract
    tasks – a to-do list for our robot to accomplish.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将每个用例分解成**故事板**（逐步插图），这些可以是文字图片或实际图片。从故事板中，我们可以提取任务——我们机器人要完成的待办事项清单。
- en: The final step for this part of the process is to separate the to-do list into
    things we can do with software and things we will need hardware for. This will
    give us detailed information for designing our robot and its AI-based software.
    Keep in mind that one of the robot’s uses is to be a good example for this book.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个流程部分的最后一步是将待办事项清单分为我们可以用软件完成的事情和我们需要硬件来完成的事情。这将为我们设计机器人和其基于AI的软件提供详细的信息。记住，机器人的一个用途是作为这本书的好例子。
- en: Let’s start by looking at use cases.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看用例开始。
- en: Use cases
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例
- en: Let’s begin our task with a statement of the problem.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从陈述问题开始我们的任务。
- en: Our robot’s task – part 1
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们机器人的任务 – 第一部分
- en: 'About once or twice a month, my five delightful, intelligent, and playful grandchildren
    come to visit me and my wife. Like most grandparents, we keep a box full of toys
    in our upstairs playroom for them to play with during their visits. The first
    thing they do upon arrival – at least the older grandkids– is take every single
    toy out of the toy box and start playing. This results in the scene shown in the
    following photograph – toys randomly and uniformly distributed throughout the
    playroom:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 大约每个月一两次，我那五个可爱、聪明且好动的孙子孙女会来拜访我和我的妻子。像大多数祖父母一样，我们在楼上的游戏室里放了一个装满玩具的盒子，让他们在来访时玩耍。他们一到——至少是年长的孙子孙女们——就会把玩具盒里的每一个玩具都拿出来开始玩。这导致了以下照片中所示的场景——玩具在游戏室里随机且均匀地分布：
- en: '![Figure 3.2 – The playroom in the aftermath of the grandchildren](img/B19846_03_2.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 孙辈来访后的游戏室](img/B19846_03_2.jpg)'
- en: Figure 3.2 – The playroom in the aftermath of the grandchildren
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 孙辈来访后的游戏室
- en: Honestly, you could not get a better random distribution. They are really good
    at this. Since, as grandparents, our desire is to maximize the amount of time
    that our grandchildren have fun at our house and we want them to associate Granddad
    and Grandmother’s house with having fun, we don’t make them pick up the toys when
    they go home. You can see where this is heading.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你找不到比这更好的随机分布了。他们在这方面真的很擅长。由于作为祖父母，我们希望最大化孙子孙女在我们家玩耍的时间，并希望他们把祖父和祖母的房子与玩耍联系起来，所以我们不让他们回家时收拾玩具。你可以看到这会走向何方。
- en: By the way, if you are a parent, let me apologize to you in advance; this is
    indeed an evil plot on our, the grandparents, part, and you’ll understand when
    you get grandkids of your own – and you will do this, too.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，如果你是父母，让我提前向你道歉；这确实是我们祖父母这边的一个邪恶计划，当你有了自己的孙子孙女时，你就会理解——你也会这样做。
- en: 'Where were we...? Yes, a room full of randomly and uniformly distributed foreign
    objects – toys – scattered about an otherwise serviceable playroom, which need
    to be removed. Normally, I’d just have to sigh heavily and pick up all this stuff
    myself, but I am a robot designer, so what I want to do is to make a robot that
    does the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在哪里……？是的，一个满是随机且均匀分布的外来物品——玩具——散落在原本可用的游戏室里，需要被清理。通常，我只需要重重地叹口气，自己把这些东西都收拾起来，但我是机器人设计师，所以我想要做的是制造一个能够完成以下任务的机器人：
- en: Pick up the toys – and not the furniture, lights, books, speakers, or other
    items in the room that are not toys.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拾起玩具——而不是房间的家具、灯光、书籍、扬声器或其他非玩具物品。
- en: Put them in the toy box.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们放入玩具箱中。
- en: Continue to do this until there are no more toys to be found and then stop.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续这样做，直到找不到更多的玩具，然后停止。
- en: 'Here is a visual representation of this process:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个过程的视觉表示：
- en: '![Figure 3.3 – Use case: pick up toys](img/B19846_03_3.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 用例：捡起玩具](img/B19846_03_3.jpg)'
- en: 'Figure 3.3 – Use case: pick up toys'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 用例：捡起玩具
- en: 'Now we can ask some pertinent questions. I took journalism classes in school
    and I was taught the usefulness of the *5 Ws and an H* – *Who*, *What*, *When*,
    *Where*, *Why*, and *How*. These are just as useful for examining use cases. I’ve
    got one firm rule here in this section: no implementation details. Don’t worry
    about how you are going to do this. Just worry about defining the results. So
    we’ll leave out the *H* for now and focus on the *Ws*. Let’s give this a try:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以提出一些相关的问题。我在学校上过新闻学课程，我被教导了“5W1H”的有用性——*谁*、*什么*、*何时*、*何地*、*为什么*和*如何*。这些对于检查用例同样有用。在这个部分，我有一个坚定的规则：不要涉及实现细节。不要担心你将如何做到这一点。只需关注定义结果。所以，我们现在暂时不考虑“如何”（H），而专注于“W”。让我们试一试：
- en: '**Who**: The robot. That was easy. We want the robot to do something, as in
    the robot does this and not me. What do we want the robot to do?'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**谁**：机器人。这很简单。我们希望机器人做某事，就像机器人做这件事而不是我做一样。我们希望机器人做什么？'
- en: '**What**: This question can be answered in two ways:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**做什么**：这个问题可以用两种方式回答：'
- en: '**Pick up toys and put them in the toy box**: What does this answer tell us?
    It says we are going to be grasping and lifting something – toys. What are toys?
    We could also rephrase this as a negative, which brings us to the second answer.'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**捡起玩具并将它们放入玩具箱中**：这个答案告诉我们什么？它说我们将要抓住并抬起一些东西——玩具。什么是玩具？我们也可以将其重新表述为否定，这引出了第二个答案。'
- en: '**Pick up and put away in the toy box the items that were not previously in
    the room**: The toys were not in the room before the grandkids pulled them all
    out. So we either want to classify items as toys or as things that were not in
    the room before. *Not in the room* implies that the robot somehow knows what belongs
    in the room, possibly by making a survey prior to the children’s arrival. However,
    *toys* implies that the robot can classify objects at least as *toys* and *not
    toys*. Let’s stick with that for now. We may have some items in the room that
    are not toys but are out of place, and thus don’t belong in the toy box. You can
    already see these questions shaping what comes later in this process.'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将不在房间中的物品捡起并放入玩具箱中**：玩具在孙子辈把它们全部拿出来之前不在房间里。所以，我们要么将物品分类为玩具，要么分类为之前不在房间中的物品。“不在房间中”意味着机器人以某种方式知道房间中应该有什么，可能是在孩子们到来之前进行一次调查。然而，“玩具”意味着机器人至少可以将物体分类为*玩具*和*非玩具*。让我们先坚持这一点。我们可能会有一些不在玩具箱中的物品，它们不是玩具但放错了地方，因此不属于玩具箱。您已经可以看到这些问题正在塑造这个过程中后续的内容。'
- en: '**When**: After the grandchildren have visited and they have left, continue
    to pick up toys until there are none left.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**何时**：在孙子辈来访并离开后，继续捡起玩具，直到没有剩余。'
- en: 'That gives us two conditions for *when*: a start and a stop. In this case,
    the start is defined as the grandkids have visited and they have left. Now, it
    is perfectly fair for me to state in the use case that I’ll tell the robot when
    these conditions are met, since that is not putting me out. I’ll be here, and
    I know when the room needs to be cleaned. Besides, I need to get the robot out
    and put it into the room. When not working, it stays on a bookshelf. So, let’s
    change our *when* statement to the following:'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这为我们提供了两个“何时”的条件：开始和结束。在这种情况下，开始定义为孙子辈来访并离开。现在，我在用例中声明我将告诉机器人何时满足这些条件是完全合理的，因为这不会给我带来不便。我会在这里，我知道房间需要打扫。此外，我需要将机器人取出并放入房间。当机器人不工作时，它放在书架上。所以，让我们将我们的“何时”语句改为以下内容：
- en: '*When I (the user) tell you to, and don’t stop until there are no more toys
    to* *be found.*'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*当我（用户）告诉你时，直到找不到更多的玩具为止。*'
- en: Now, we could have decided that the robot needs to figure this out for itself
    and turn itself on after the grandchildren leave, but what is the return on investment
    for that? That would be a lot of work for not a lot of gain. The pain point for
    me, the user, is picking up toys, not deciding when to do it. This is a lot simpler.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们本可以决定机器人需要自己解决这个问题，在孙子辈离开后自动开启，但这样做的投资回报率是多少？那将是一大堆工作，但收益却不多。对我来说，作为用户，痛点在于捡玩具，而不是决定何时去做。这要简单得多。
- en: Note that my *when* statement has a start and an end. Anyone who watched Mickey
    Mouse in the *Sorcerer’s Apprentice* segment of *Fantasia* understands that when
    you have a robot, telling it when to stop can be important. Another important
    concept is defining the end condition. I did not say *stop when all of the toys
    are picked up* because that would imply the robot needed to know all of the toys,
    either by sight or number. It is easier as a task definition to say *stop when
    you see no more toys* instead, which accomplishes what we want without adding
    additional requirements to our robot.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我的*when*语句有一个开始和一个结束。任何看过《幻想曲》中米老鼠的《魔法师的学徒》片段的人都会明白，当你有一个机器人时，告诉它何时停止是很重要的。另一个重要的概念是定义结束条件。我没有说*当所有玩具都被捡起时停止*，因为这会意味着机器人需要知道所有的玩具，无论是通过视觉还是数量。作为任务定义来说，说*当你看不到更多玩具时停止*更容易，这样就能达到我们的目的，而不需要给我们的机器人增加额外的要求。
- en: It is perfectly normal to have to revisit use cases as the robot designer understands
    more about the problem – sometimes you can be working hard to solve a problem
    that is not relevant to solving the user’s task. You can imagine some robot engineer
    in a team being given the task of *pick up all the toys* as meaning all toys ever
    invented, in all cultures, in all parts of the world! Then, you get a request
    for a $500,000 database software license and a server farm to house it. We just
    want to pick up the toys found in the playroom.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当机器人设计师对问题了解得更多时，重新审视用例是很正常的——有时你可能正在努力解决一个与解决用户任务无关的问题。你可以想象一些团队中的机器人工程师被分配了一个任务，即*捡起所有玩具*，这意味着所有文化、所有地区发明的所有玩具！然后，你得到了一个需要500,000美元数据库软件许可和服务器农场来存放它的请求。我们只想捡起游戏室里找到的玩具。
- en: '**Where**: The playroom upstairs. Now we have some tricky parts. The area to
    be cleaned is a specific area of the house, but it is not really bound by walls.
    And it is upstairs – there is a stairway going down in the playroom that we don’t
    want our robot tumbling down. How would you have known this? You won’t unless
    you ask these kinds of questions! The environment the robot operates in is just
    as important as what it does. In this case, let’s go back and ask the user. I’ll
    stick in a floor plan for you here to define what I mean by *playroom*. On the
    bright side, we don’t need to climb or descend stairs in this task. But we do
    need to look out for the staircase as a hazard:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置**：楼上的游戏室。现在有一些棘手的部分。要清洁的区域是房子的一个特定区域，但它并不是真正由墙壁所界定。而且它在上楼的地方——游戏室里有一个通往楼下的楼梯，我们不希望我们的机器人滚下去。你怎么会知道这些？除非你问这类问题！机器人运作的环境和它所做的事情一样重要。在这种情况下，让我们回头去询问用户。我会在这里插入一个楼层平面图来定义我所说的*游戏室*。从积极的一面来看，我们在这个任务中不需要爬楼梯或下楼。但我们确实需要留意楼梯作为一个潜在的危险：'
- en: '![Figure 3.4 – The floor plan of my house, upstairs](img/B19846_03_4.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 - 我家的楼层平面图，楼上](img/B19846_03_4.jpg)'
- en: Figure 3.4 – The floor plan of my house, upstairs
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 - 我家的楼层平面图，楼上
- en: '**Why**: So why is the robot picking up toys? I’m tempted to just write “Because
    *someone* has to do it.” However, the answer is that I don’t want the grandkids
    to pick up toys so that they have the maximum time to play, and I don’t want to
    do it, either. So we are making a robot for this task. One maxim in the robot
    world is that proper tasks for robots are *dirty*, *dull*, or *dangerous*. This
    one definitely falls into the *dull* category.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原因**：那么，为什么机器人要捡起玩具呢？我差点就写下“因为*有人*得做这件事。”然而，答案是我不想让孙子辈的孩子们捡玩具，这样他们就有更多的时间玩耍，我也不想这么做。所以，我们为这个任务制作了一个机器人。机器人世界中的一个格言是，适合机器人的任务通常是*脏乱*、*枯燥*或*危险*的。这个任务无疑属于*枯燥*类别。'
- en: Our robot has more than one use case – it has more than one function to perform.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的这个机器人有多种用途——它有多种功能要执行。
- en: Our robot’s task – part 2
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们机器人的任务——第二部分
- en: The robot needs to interact with my grandchildren. Why is this important? As
    I told you in [*Chapter 1*](B19846_01.xhtml#_idTextAnchor015), the grandchildren
    were introduced to some of my other robots, and the oldest grandkid, William,
    always tries to talk to the robots. I have three grandchildren who are on the
    autistic spectrum, so this is not an idle desire – I’ve read the research, such
    as *Robots for Autism* ([https://www.robokind.com/](https://www.robokind.com/)),
    which states that robots can be helpful in such situations. While I’m not trying
    to do therapy, I’d like my robot to interact with my grandchildren verbally. I
    also have one specific request – the robot must be able to tell knock-knock jokes
    and respond to them, as they are a favorite of William. I want this robot to be
    verbally interactive.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人需要与我孙子孙女互动。为什么这很重要？正如我在[*第 1 章*](B19846_01.xhtml#_idTextAnchor015)中告诉你的，孙子孙女们被介绍了一些我的其他机器人，最大的孙子威廉总是试图与机器人交谈。我有三个在自闭症谱系上的孙子孙女，所以这不是一个无足轻重的愿望——我阅读了相关的研究，例如
    *Robots for Autism* ([https://www.robokind.com/](https://www.robokind.com/))，该研究指出，在这种情况下机器人可能会有所帮助。虽然我不是在尝试进行治疗，但我希望我的机器人能够以口头方式与我的孙子孙女互动。我还有一个具体的要求——机器人必须能够讲敲门笑话并回应它们，因为这是威廉的最爱。我希望这个机器人能够进行口头互动。
- en: 'So, here is a diagram of this use case:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里是这个用例的图示：
- en: '![Figure 3.5 – Use case: interact with people](img/B19846_03_5.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 用例：与人互动](img/B19846_03_5.jpg)'
- en: 'Figure 3.5 – Use case: interact with people'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 用例：与人互动
- en: 'So let’s go through the same exercise with this use case. We ask the pertinent
    questions: *who*, *what*, *when*, *where*, and *why*? Let’s break these down:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用这个用例进行同样的练习。我们提出相关的问题：*谁*，*什么*，*何时*，*何地*，和*为什么*？让我们来分解这些：
- en: '**Who**: The robot, the user (granddad), and the grandchildren.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**人物**：机器人、用户（爷爷）和孙子孙女们。'
- en: In this case, user interaction is part of the task. Who are we interacting with?
    I need to be able to command the robot to begin to interact. Then, we want the
    robot to both talk to and listen to the children.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，用户交互是任务的一部分。我们与谁互动？我需要能够命令机器人开始互动。然后，我们希望机器人既能与孩子交谈也能听孩子说话。
- en: '**What**: Receive commands and verbally interact (hold a conversation) with
    children, which must include knock-knock jokes. We keep the two kinds of functions:
    receive commands from – let’s call me the **robot controller**, to make this more
    generic. The other function is to have a conversation with the children, including
    telling knock-knock jokes. We’ll define *conversation* further on in our breakdown.
    You can refer to [*Chapter 6*](B19846_06.xhtml#_idTextAnchor205) on using the
    robot as a **digital assistant**. We are going to use an open source digital assistant
    called *Mycroft* to act as a voice interface for the robot. We will add our own
    skills to the base Mycroft capability, which is actually quite versatile. The
    robot can get the weather, set timers, play music, look up information on Google
    (such as how many tablespoons in a quarter cup), and even tell you where the International
    Space Station is right now. But what it can’t do is tell knock-knock jokes – until
    now, as we are adding this feature to the robot. Fortunately for us, the knock-knock
    joke has a very structured form based on puns and a call-and-response format that
    goes like this:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能**：接收命令并以口头方式与孩子互动（进行对话），这必须包括敲门笑话。我们保留两种功能：接收来自——让我们称我为**机器人控制器**的命令，使这个更通用。另一种功能是与孩子进行对话，包括讲敲门笑话。我们将在我们的分解中进一步定义*对话*。你可以参考[*第
    6 章*](B19846_06.xhtml#_idTextAnchor205)关于使用机器人作为**数字助理**的内容。我们将使用一个名为*Mycroft*的开源数字助理作为机器人的语音界面。我们将在Mycroft的基本功能上添加我们自己的技能，这实际上非常灵活。机器人可以获取天气信息，设置定时器，播放音乐，在谷歌上查找信息（例如，四分之一杯有多少汤匙），甚至告诉你国际空间站现在在哪里。但它不能讲敲门笑话——直到现在，因为我们正在为机器人添加这个功能。幸运的是，敲门笑话有一个非常结构化的形式，基于双关语和这样的问答格式：'
- en: '*Robot*: Knock knock.'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*机器人*：敲门。'
- en: '*Child*: Who’s there?'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*孩子*：谁在那里？'
- en: '*Robot*: Lettuce.'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*机器人*：让我们进来。'
- en: '*Child*: Lettuce who?'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*孩子*：让我们进来谁？'
- en: '*Robot*: Lettuce (let us) in, we’re freezing out here!'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*机器人*：让我们进来，这里太冷了！'
- en: I’ll leave diagramming the opposite form – responding to a knock-knock joke
    – to you.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我会把相反形式的绘图——回应敲门笑话——留给你。
- en: '**When**: As requested by the robot controller, then when the child speaks
    to the robot.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间**：根据机器人控制器的请求，然后当孩子对机器人说话时。'
- en: 'I think this is fairly self-explanatory: the robot interacts when sent a command
    to do so. It then waits for someone to talk to it. One thing we can extrapolate
    from this information is that when we are picking up toys, we are not expecting
    the robot to talk – the two activities are exclusive. We only pick up toys after
    the kids are gone, ergo there is one to talk to.'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我认为这相当直观：当机器人收到执行命令时，它会进行交互。然后它等待有人与之交谈。我们可以从这个信息中推断出，当我们正在捡玩具时，我们并不期望机器人说话——这两个活动是互斥的。我们只在孩子们离开后捡玩具，因此有一个可以与之交谈的对象。
- en: '**Where**: In the playroom, within about six feet of the robot.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置**：在游戏室里，距离机器人大约六英尺。'
- en: We have to set some limits on how far we can hear – there is a limit on how
    sensitive our microphone can be. I’m suggesting six feet as a maximum distance.
    We may revisit this later. When you come to a requirement like this, you can ask
    the customer *Why six feet?* They may say, *Well, that sounds like a reasonable
    distance*. You can then ask, *Well, if it was five feet, would that be a failure
    of this function?* And the user might respond, *No, but it would not be as comfortable*.
    You can continue to ask questions on distances until you get a feeling for the
    required distance (how far away to not fail), which might be three feet in this
    case (so that the child does not have to bend over the robot to be heard), and
    the desired distance, which is how far the user wants the function to work. These
    are important distinctions when we get around to testing. Where is the pass-fail
    line for this requirement?
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们必须设定一些关于我们能听到多远的限制——我们的麦克风的灵敏度是有极限的。我建议六英尺作为最大距离。我们可能稍后会重新考虑这个距离。当你遇到这样的需求时，你可以问客户“为什么是六英尺？”他们可能会说，“嗯，这听起来像是一个合理的距离。”然后你可以问，“如果它是五英尺，这会是这个功能的失败吗？”用户可能会回答，“不，但会不那么舒适。”你可以继续询问距离，直到你对所需的距离（多远才算不失败）有一个感觉，在这个例子中可能是三英尺（这样孩子就不需要弯腰到机器人那里才能被听到），以及期望的距离，即用户希望功能能工作的距离。当我们开始测试时，这些是重要的区分点。这个需求的通过-失败界限在哪里？
- en: '**Why**: Because my grandchildren want to talk to the robot, and have it respond
    (i.e., the users have specifically requested this feature).'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原因**：因为我的孙子辈想要和机器人交谈，并希望它做出回应（即，用户明确要求了这个功能）。'
- en: Now, let’s delve deeper into our robot’s tasks.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更深入地探讨我们的机器人任务。
- en: What is our robot to do?
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的机器人要做什么？
- en: 'Now we are going to do some detailed analysis of what the robot needs to do
    by using the storyboard process. This works like this: We take each of our two
    tasks and break them down as completely as we can based on the answers to all
    of our *W* questions. Then we picturize each step. The pictures can be either
    a drawing or a word picture (a paragraph) describing what happens in that step.
    I like to start the decomposition process by describing the robot in terms of
    a **state machine**, which, for the first part of our problem, may be a good approach
    to understanding what is going on inside the robot at each step.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用故事板过程对机器人需要执行的操作进行详细分析。这个过程是这样的：我们根据所有关于“W”问题的答案，尽可能详细地将我们的两个任务分解。然后我们描绘出每个步骤。这些图片可以是绘画或文字描述（一段话），描述该步骤中发生的事情。我喜欢通过描述机器人作为一个**状态机**来开始分解过程，对于我们问题的前一部分，这可能是一个理解机器人每一步内部发生情况的好方法。
- en: 'You are probably familiar with **state machine diagrams**, but just in case,
    a state machine diagram describes the robot’s behavior as a series of discrete
    states or sets of conditions that define what actions are available to the robot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉**状态机图**，但以防万一，状态机图描述了机器人的行为作为一系列离散的状态或条件集，这些状态或条件定义了机器人可以执行哪些操作：
- en: "![Figure 3.6 – Robot state machine\uFEFF diagram](img/B19846_03_6.jpg)"
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – 机器人状态机图](img/B19846_03_6.jpg)'
- en: Figure 3.6 – Robot state machine diagram
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 机器人状态机图
- en: Our first state is simply *Off* – the robot has no power turned on.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个状态仅仅是**关闭**——机器人没有开启电源。
- en: Each state is an event (or events) that causes the state to change. These are
    called **transitions**. To get from the *Off* state to whatever is next, some
    event has to occur – such as the human operator turning on the power. We’ll call
    that transition event *Power applied*. Now what state are we in? There is some
    amount of time to get the computer booted and the programs loaded (*Initializing*).
    Once everything boots up and initializes, the robot will be ready to accept commands.
    Let’s call this state *Standby*. The robot is just sitting waiting for instructions.
    Now we want to start cleaning the room. I send a *Begin cleaning* command to the
    robot, which changes the state to – what? What do we need to happen next? We could
    define a state called *Cleaning*, but that would encompass a lot of complex functions
    and we would not learn much from that. We need the robot to look for toys using
    its camera. If it does not find a toy, it needs to drive forward a short distance
    – avoiding obstacles – and then look again. In practice, we should be able to
    look for toys while driving without pausing constantly. We will need to make the
    *Look for toys* function interrupt driving when it sees a toy.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每个状态都是一个事件（或事件），它会导致状态发生变化。这些被称为**转换**。要从“关闭”状态转换到下一个状态，必须发生某些事件——例如，人类操作员打开电源。我们将称这个转换事件为“施加电源”。现在我们处于什么状态？需要一些时间来启动计算机并加载程序（“初始化”）。一旦一切启动并初始化，机器人将准备好接受命令。让我们称这个状态为“待机”。机器人只是坐着等待指令。现在我们想要开始清洁房间。我向机器人发送一个“开始清洁”命令，这将状态转换为——什么？接下来需要发生什么？我们可以定义一个名为“清洁”的状态，但那将包括很多复杂的功能，而且我们不会从中学到很多东西。我们需要机器人使用其摄像头寻找玩具。如果它找不到玩具，它需要向前移动一小段距离——避开障碍物——然后再次寻找。在实践中，我们应该能够在驾驶的同时寻找玩具而无需不断停车。我们需要使“寻找玩具”功能在看到玩具时中断驾驶。
- en: 'If it does find a toy, then the robot needs to position itself so that the
    toy is within reach of the robot arm. In the state machine diagram, we already
    added the transition *Begin cleaning*, which changes the state from *Standby*
    to *Look for toys*. Now we can add two more transitions: one called *Toy = no*
    and one called *Toy = yes*. The *Toy = no* branch goes to a state called *Drive
    ahead*, where the robot moves forward – while avoiding obstacles – and then goes
    back to the *Look for toys* state and tries again to find a toy. We will need
    some sort of means to tell the software how often to look for toys. We could use
    a simple timer – so many seconds elapsed. Or we could use some sort of distance
    function based on wheel motion.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果机器人找到了玩具，那么它需要调整自己的位置，使得玩具在机器人手臂的触及范围内。在状态机图中，我们已经添加了名为“开始清洁”的转换，它将状态从“待机”转换为“寻找玩具”。现在我们可以添加两个额外的转换：一个叫做“玩具=无”，另一个叫做“玩具=有”。“玩具=无”分支会进入一个名为“前进”的状态，在那里机器人向前移动——同时避开障碍物——然后返回到“寻找玩具”状态并再次尝试找到玩具。我们需要某种方式来告诉软件多久查找一次玩具。我们可以使用一个简单的计时器——经过多少秒。或者我们可以使用基于轮子运动的某种距离函数。
- en: So, now we have found a toy, what do we do? We need to drive to the toy, which
    puts it in range of our robot arm. We try to grip the toy with the robot’s arm
    and hand. We may not be successful on the first try, in which case we want to
    try again. The loop transition, which is labeled *Grip unsuccessful*, says to
    go back and try again if you don’t succeed the first time. Where have I heard
    that before? You can see the same with *Pick up toy*. Why are there two parts?
    We need to first get a hold of the toy before we can lift it. So I thought it
    needed two states, since we may fail to get a grip – the toy falls out of the
    hand, separately from picking the toy up, where the toy is too heavy or awkward
    to lift.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，现在我们已经找到了玩具，我们该怎么办？我们需要开车到玩具那里，使其进入我们机器人手臂的范围内。我们尝试用机器人的手臂和手握住玩具。我们可能不会在第一次尝试就成功，在这种情况下，我们想要再次尝试。标记为“抓握失败”的循环转换表示如果你第一次尝试不成功，就回去再试一次。我以前在哪里听过这样的话？你可以看到同样的情况在“拿起玩具”中。为什么有两个部分？在我们能够举起玩具之前，我们需要首先抓住它。所以我认为需要两个状态，因为我们可能无法成功抓住——玩具从手中掉落，这独立于拿起玩具，玩具太重或太笨重而无法举起。
- en: OK, we found a toy and picked it up. What is next? We need to put it in the
    toy box. The next state is *Drive to toy box*. Don’t worry about *how* at this
    stage; this is just what we need to do. Later, we can further decompose this state
    into a more detailed version. We drive until we get to the event *Toy box found*.
    That means we see the toy box. Then we go to the *Position for drop* state, which
    moves the robot to a place where it can drop the toy in the box. The final state,
    *Drop toy*, is self-explanatory. We’ve dropped the toy, the robot has nothing
    in its gripper, and guess what? We start over by returning to the *Look for toys*
    state. If the robot decides that the drop was not successful (the toy is still
    in the gripper), then we have it try that step again, by repositioning the hand
    over the toy box and trying to drop the toy again by opening the hand. How do
    we know whether the gripper is empty? We try to close the grip and see what position
    the hand servo is in. If the gripper can close (go to a minimum state), then it
    is empty. If the toy falls outside the toy box (the robot misses the box entirely),
    then it is once again a toy on the floor, and will be treated in the normal manner
    – the robot will find it, pick it up, and try again.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们找到了一个玩具并把它拿了起来。接下来是什么？我们需要把它放进玩具箱。下一个状态是*驶向玩具箱*。在这个阶段不用担心*如何*做；我们只需要做这件事。稍后，我们可以进一步将这个状态分解成更详细版本。我们驾驶直到到达事件*找到玩具箱*。这意味着我们看到了玩具箱。然后我们进入*放置放下位置*状态，这个状态将机器人移动到可以放下玩具的位置。最终状态*放下玩具*是显而易见的。我们放下了玩具，机器人的爪子中没有东西了，而且你知道吗？我们通过回到*寻找玩具*状态重新开始。如果机器人决定放下不成功（玩具仍然在爪子中），那么我们将它再次尝试那个步骤，通过重新定位手在玩具箱上方并尝试通过打开手放下玩具。我们如何知道爪子是否为空？我们尝试关闭握持并观察手伺服机构的位置。如果爪子可以关闭（达到最小状态），那么它是空的。如果玩具掉出玩具箱（机器人完全错过了箱子），那么它又变成了地板上的玩具，并且会以正常方式处理——机器人会找到它，拿起它，并再次尝试。
- en: 'This is all well and good, and our little robot goes around forever looking
    for toys, right? We’ve left out two important transitions. We need a *No more
    toys* event, and we need a way to get back to the *Off* state. Getting to *Off*
    is easy – the user turns off the power. I use the shorthand method of having a
    block labeled *Any state* since we can hit the off button at any time, no matter
    what else the robot is doing, and there is nothing the robot can or should do
    about it. It may be more proper to draw a line from each state back to *Off*,
    but that clutters the diagram, and this notation still gets the meaning across.
    The new state machine diagram looks like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很不错，我们的这个小机器人会永远四处寻找玩具，对吧？我们忽略了两个重要的转换。我们需要一个*没有更多玩具*的事件，并且我们需要一种方法回到*关闭*状态。回到*关闭*状态很简单——用户关闭电源。我使用了一个标记为*任何状态*的简写方法，因为我们可以在机器人做任何事情的时候随时按下关闭按钮，而且机器人对此无能为力。也许从每个状态画一条线回到*关闭*状态会更合适，但这会使图表变得杂乱，而这种记法仍然能够传达意思。新的状态机图看起来是这样的：
- en: '![Figure 3.7 – New state machine diagram](img/B19846_03_7.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7 – 新的状态机图](img/B19846_03_7.jpg)'
- en: Figure 3.7 – New state machine diagram
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 新的状态机图
- en: Let’s take a minute and talk about the concept of *No more toys*. How do we
    define this? This may take some experimentation, but for now, we’ll say if we
    have not found a toy after 10 minutes of trying, then we are satisfied that there
    are no more toys to be found. Later, we can adjust that time as necessary. It
    is possible that 5 minutes is totally adequate for a room our size. Note that
    the *No more toys* event can only come from the *Look for toys* state, which should
    make sense.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一分钟时间来谈谈*没有更多玩具*的概念。我们如何定义这个？这可能需要一些实验，但到目前为止，我们会说如果我们尝试了10分钟还没有找到玩具，那么我们就满意了，没有更多玩具可以找到。稍后，我们可以根据需要调整这个时间。可能5分钟对我们这个大小的房间来说已经足够了。请注意，*没有更多玩具*事件只能从*寻找玩具*状态产生，这应该是合理的。
- en: We mentioned that the robot needs to avoid obstacles. But we don’t have a state
    called *Avoid obstacles*. Why is that? That is because several of the states include
    driving, and each of those includes avoiding obstacles. It would not be appropriate
    to have a state for avoiding obstacles, since it is not unique to one state. What
    we need is a separate state machine that describes the robot’s driving. As I mentioned
    in the *Introducing subsumption architecture* section in the last chapter, we
    can have more than one goal operational at a time.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到机器人需要避开障碍物。但我们没有“避开障碍物”的状态。为什么是这样？那是因为几个状态包括驾驶，每个状态都包括避开障碍物。为避开障碍物设立一个状态是不合适的，因为它不是特定于一个状态的。我们需要的是一个描述机器人驾驶的独立状态机。正如我在上一章的“介绍子吸收架构”部分提到的，我们可以同时有多个目标处于操作状态。
- en: The task of picking up toys is the mission, which is the overall goal of the
    robot. *Avoid obstacles* is a goal of the driving engine, the mid-level manager
    of our robot.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 拾取玩具的任务是任务，这是机器人的总体目标。“避开障碍物”是驱动引擎的目标，是我们机器人的中级管理者。
- en: We’ve discussed our use cases and drawn a state machine diagram, so now let’s
    move on to the next step, which is to create our storyboards.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了我们的用例并绘制了状态机图，现在让我们继续下一步，即创建我们的故事板。
- en: Using storyboards
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用故事板
- en: In this section, we are going to decompose our use cases further in order to
    understand the various tasks our robot must undertake on our behalf in the course
    of its two missions. I’ve created some **storyboards** – quick little drawings
    – to illustrate each point.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将进一步分解我们的用例，以便了解我们的机器人在执行两次任务过程中必须代表我们完成的各项任务。我创建了一些**故事板**——简短的草图——来阐述每个要点。
- en: The concept of storyboards is borrowed from the movie industry, where a comic-strip-like
    narration is used to translate words on a page in the script into a series of
    pictures or cartoons that convey additional information not found in the script,
    such as framing, context, movement, props, sets, and camera moves. The practice
    of storyboarding goes all the way back to silent movies and is still used today.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 故事板的概念借鉴自电影行业，在那里使用类似漫画的叙述方式，将剧本中的文字转换成一系列图片或卡通，以传达剧本中未包含的额外信息，例如构图、背景、动作、道具、场景和摄像机移动。故事板的实践可以追溯到无声电影时代，至今仍在使用。
- en: 'We can use storyboards in robotics design for the same reasons: to convey additional
    information not found in the words of the use cases. Storyboards should be simple,
    quick, and just convey enough information to help you understand what is going
    on.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在机器人设计中使用故事板的原因相同：为了传达用例文字中未包含的额外信息。故事板应该是简单、快捷的，并且只需传达足够的信息，帮助你理解正在发生的事情。
- en: Let’s get started. We are not going to create storyboards for *Power applied*,
    *Initializing*, or *Standby* because a storyboard is not really needed for those
    simple concepts. We will jump ahead to the *Begin cleaning* event in our state
    diagram.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。我们不会为“电源应用”、“初始化”或“待机”创建故事板，因为对于这些简单概念来说，故事板实际上并不需要。我们将跳到状态图中的“开始清洁”事件。
- en: Storyboard – put away the toys
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故事板 – 收起玩具
- en: When our story begins, what is the robot doing? It has been turned on, and is
    in a standby state waiting to be told what to do. How does it receive a command?
    A nice, hands-free way would be to receive a voice command to *begin cleaning*,
    or some similar words that mean the same thing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的故事开始时，机器人正在做什么？它已经被打开，处于待机状态，等待被告知要做什么。它是如何接收命令的？一种很好的、免提的方式是接收一个语音命令来“开始清洁”，或者一些意思相同的话。
- en: 'The next step in our process after *Begin cleaning* is *Look for toys*. This
    storyboard frame is *what the robot sees* as it is commanded to start cleaning.
    It sees the room, which has three kinds of objects visible – that is, toys, things
    that are not toys (the ottoman and the fireplace), and the room itself, including
    the walls, and the floor:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在“开始清洁”之后的下一步是“寻找玩具”。这个故事板帧是当机器人被命令开始清洁时“机器人所看到的”。它看到了房间，其中可见三种类型的物体——也就是说，玩具、不是玩具的东西（扶手椅和壁炉），以及房间本身，包括墙壁和地板：
- en: '![Figure 3.8 – Waiting for a voice command to begin cleaning](img/B19846_03_8.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8 – 等待语音命令开始清洁](img/B19846_03_8.jpg)'
- en: Figure 3.8 – Waiting for a voice command to begin cleaning
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – 等待语音命令开始清洁
- en: We could select any sort of sensor to detect our toys and direct our robot.
    We could have a LiDAR, thermal, or sonar scanner. Let’s hypothesize that the best
    sensor tool for this task is a regular USB camera. We have control of the lighting,
    the toys are not particularly warmer or cooler than the surroundings, and we need
    enough information to identify objects by type. So, video it is. We will determine
    later exactly what kind of camera we need, so add that to our *to-do list*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择任何类型的传感器来检测我们的玩具并指导我们的机器人。我们可以有一个激光雷达、热传感器或声纳扫描仪。让我们假设这个任务的最佳传感器工具是一个普通的USB摄像头。我们可以控制照明，玩具并不比周围环境更暖或更冷，我们需要足够的信息来按类型识别对象。所以，视频就是了。我们将在稍后确定我们确切需要什么类型的摄像头，所以把它加到我们的*待办事项列表*中。
- en: '![Figure 3.9 – Look for toys](img/B19846_03_9.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9 – 寻找玩具](img/B19846_03_9.jpg)'
- en: Figure 3.9 – Look for toys
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – 寻找玩具
- en: Our next storyboard is to *look for toys*. We need to run some sort of algorithm
    or technique to classify objects by type. The results of that algorithm are to
    find the objects – separate them from the background of the floor – and then classify
    each object as a toy or not a toy. We don’t really care to have any more breakdown
    than that – we leave all *Not toy* objects alone, and pick up all *Toy* objects.
    Note that we draw circles around the objects that are toys, which is another way
    of saying that we must locate them in the camera frame.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个故事板是*寻找玩具*。我们需要运行某种算法或技术来按类型分类对象。该算法的结果是找到对象——将它们从地板的背景中分离出来——然后对每个对象进行分类，判断它是玩具还是非玩具。我们并不关心有更多的细分——我们忽略所有*非玩具*对象，并捡起所有*玩具*对象。注意，我们在玩具对象周围画圆圈，这也是另一种说法，即我们必须在相机帧中定位它们。
- en: 'So what does this simple picture tell us we did not know before? It tells us
    the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这张简单的图片告诉我们我们之前不知道什么？它告诉我们以下内容：
- en: We need to segment the camera image by objects
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要通过对象来分割相机图像。
- en: We need to locate the objects in the camera frame
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要在相机帧中定位对象。
- en: We need to classify the objects as either *Toy* or *Not toy*
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要将对象分类为*玩具*或*非玩具*。
- en: We need to be able to store and remember this information
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要能够存储和记住这些信息。
- en: 'We only can pick up and move one toy at a time – we only have one hand, and
    nobody said in the use cases that we need to pick up more than one at a time.
    So, we only care about one toy – and let’s arbitrarily say we pick up the closest
    one to the robot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一次只能捡起和移动一个玩具——我们只有一只手，而且没有人说在用例中我们需要一次捡起多个。所以，我们只关心一个玩具——让我们随意说我们捡起离机器人最近的那个：
- en: '![Figure 3.10 – Select nearest toy](img/B19846_03_10.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10 – 选择最近的玩具](img/B19846_03_10.jpg)'
- en: Figure 3.10 – Select nearest toy
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – 选择最近的玩具
- en: We might also say that it’s the toy that is easiest to get to, which might be
    a slightly different process than choosing the closest one. We set that toy to
    be the target for our next action, which is what? If you said to drive to the
    toy, you would be correct. However, we must not just drive to the toy but put
    the robot’s body in a position to use the robot arm to grasp the toy. By the way,
    that means the robot arm must be able to reach the ground or very close to the
    ground, as we have some small toys.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以说，这是最容易拿到手的玩具，这可能是一个与选择最近的玩具略有不同的过程。我们将这个玩具设定为下一次行动的目标，那么这个目标是什么呢？如果你说是开车去玩具，你就说对了。然而，我们不仅要开车去玩具，还要将机器人的身体放置到一个位置，以便使用机器人手臂抓取玩具。顺便说一句，这意味着机器人手臂必须能够触及地面或非常接近地面，因为我们有一些小玩具。
- en: 'Our robot must plan a route from its current position to a spot where it can
    attempt to pick up the toy. We set a target goal an arms-length away from the
    center of the toy:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的机器人必须规划一条从当前位置到可以尝试捡起玩具的位置的路线。我们在玩具中心手臂长度处设定一个目标目标：
- en: '![Figure 3.11 – Plan route to target](img/B19846_03_11.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11 – 规划到目标的路](img/B19846_03_11.jpg)'
- en: Figure 3.11 – Plan route to target
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – 规划到目标的路
- en: 'The robot needs to make sure that there are no obstacles en route. There are
    two ways of doing this. As illustrated, we can clear the path that the robot is
    traveling on by adding the width of the robot (plus a bit of extra) and see whether
    any obstacles are in that area, or we can add a border around obstacles and see
    whether our path goes into those boundaries. Regardless, we need to have a path
    free of obstacles:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人需要确保路上没有障碍物。有两种方法可以做到这一点。如图所示，我们可以通过增加机器人的宽度（再加上一点）来清除机器人正在行驶的道路，看看是否有障碍物在那个区域，或者我们可以在障碍物周围添加一个边界，看看我们的路径是否进入那些边界。无论如何，我们需要一个没有障碍物的路径：
- en: '![Figure 3.12 – Look for obstacles on the route](img/B19846_03_12.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.12 – 在路线上寻找障碍物](img/B19846_03_12.jpg)'
- en: Figure 3.12 – Look for obstacles on the route
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – 在路线上寻找障碍物
- en: 'The robot determines for itself the proper alignment to prepare to pick up
    the toy:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人自己决定合适的对准方式，为拾取玩具做准备：
- en: '![Figure 3.13 – Position robot hand](img/B19846_03_13.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.13 – 定位机器人手](img/B19846_03_13.jpg)'
- en: Figure 3.13 – Position robot hand
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 – 定位机器人手
- en: 'Now that the robot has completed its drive, the robot can move the robot hand
    to a position to pick up the toy. We need to put the robot hand over the center
    of mass of the toy, and then rotate the hand to match a narrow part of the toy
    so we can pick it up. One of our goals for this project is to not dictate how
    the robot does this, but rather to let it learn for itself. So, we can say for
    this storyboard panel that the robot uses its training and machine learning to
    use an appropriate hand pose to prepare to grasp the object. We can surmise that
    that includes lining the hand up:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在机器人已经完成了它的行驶，机器人可以将机器人手移动到拾取玩具的位置。我们需要将机器人手放在玩具的重心上方，然后旋转手以匹配玩具的狭窄部分，这样我们就可以拾取它。我们这个项目的目标之一不是规定机器人如何做，而是让它自己学习。因此，我们可以说对于这个故事板面板，机器人使用其培训和机器学习来使用适当的手势来准备抓取物体。我们可以推断这包括将手对齐：
- en: '![Figure 3.14 – Pick up toy](img/B19846_03_14.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.14 – 拾取玩具](img/B19846_03_14.jpg)'
- en: Figure 3.14 – Pick up toy
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14 – 拾取玩具
- en: Probably *storyboard 6* is the hard part (*Figure 3**.13*), and in *storyboard
    7*, the robot completes the grasp of the object and picks it up (*Figure 3**.14*).
    The robot has to be able to determine whether the pick-up was successful, and
    if not, try again. That was in the state machine diagram we did before. We have
    now picked up the toy. What’s next? Find the toy box!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能 *故事板 6* 是难点 (*图 3**.13*)，而在 *故事板 7* 中，机器人完成了对物体的抓取并拾起了它 (*图 3**.14*)。机器人必须能够确定拾取是否成功，如果不成功，则再次尝试。那是在我们之前做的状态机图中。我们现在已经拾起了玩具。接下来是什么？找到玩具箱！
- en: '![Figure 3.15 – Find toy box](img/B19846_03_15.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.15 – 找到玩具箱](img/B19846_03_15.jpg)'
- en: Figure 3.15 – Find toy box
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15 – 找到玩具箱
- en: Now we need the robot to find the toy box. Again, we don’t care how at this
    point. We are still worried about *what* and not *how*. Somehow, the robot looks
    around and finds the toy box, which, in this case, is large, against the wall,
    and has a distinctive color. Regardless, the robot has to find the toy box on
    its own. The labels in the picture indicate that the robot can distinguish the
    toy box and that it considers all other objects it perceives as obstacles. We
    can see we don’t need to have the *Toy*/*Not toy* capability active at the same
    time, only the *Toy box*/*Not toy box* decision-making process. This does reduce
    some of the required processing and will make machine learning easier.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要机器人找到玩具箱。同样，目前我们并不关心它是如何做到的。我们仍然担心的是 *什么* 而不是 *如何*。不知何故，机器人四处张望并找到了玩具箱，在这个例子中，它很大，靠墙，并且有独特的颜色。无论如何，机器人必须自己找到玩具箱。图片中的标签表明机器人可以区分玩具箱，并且它将感知到的所有其他物体视为障碍物。我们可以看到我们不需要同时激活
    *玩具*/*非玩具* 功能，只需要 *玩具箱*/*非玩具箱* 决策过程。这确实减少了一些所需的处理，并将使机器学习更容易。
- en: 'Now that we have found the toy box, we illustrate a slightly more complex task
    of navigating around an obstacle to get there. In this example, we show the purple
    outline of the robot’s base, compared to a red outline around the obstacle, which
    I labeled *Keep out zone*. This gives us more guidance on how to avoid obstacles:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经找到了玩具箱，我们展示了稍微复杂一些的任务，即绕过障碍物到达那里。在这个例子中，我们展示了机器人底座的紫色轮廓，与障碍物周围的红色轮廓相比，我将其标记为
    *禁止进入区域*。这为我们提供了更多关于如何避开障碍物的指导：
- en: '![Figure 3.16 – Plan path to toy box](img/B19846_03_16.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.16 – 计划到达玩具箱的路径](img/B19846_03_16.jpg)'
- en: Figure 3.16 – Plan path to toy box
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16 – 计划到达玩具箱的路径
- en: 'We want to keep the center of the robot out of the *Keep out zone*. We need
    to get close enough to the toy box to drop our toy into it:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将机器人的中心保持在 *禁止进入区域* 之外。我们需要足够接近玩具箱，以便将玩具放入其中：
- en: '![Figure 3.17 – Align toy with box](img/B19846_03_17.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.17 – 将玩具与箱子对齐](img/B19846_03_17.jpg)'
- en: Figure 3.17 – Align toy with box
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.17 – 将玩具与箱子对齐
- en: In *storyboard 10*, we lift the toy high above the top of the toy box and position
    our toy to fall inside the toy box when we let go of it. Make a note that we have
    to have the toy lifted before the final few inches to the toy box. We put the
    robot hand over the top of the opening of the toy box, just as far forward as
    we can and in the middle of the toy box.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在*故事板10*中，我们将玩具高高举起，超过玩具盒顶部，并在我们放手时将玩具定位在玩具盒内。请注意，我们必须在距离玩具盒最后几英寸之前将玩具举起。我们将机器人手放在玩具盒开口的顶部，尽可能向前，并在玩具盒的中间位置。
- en: '![Figure 3.18 – Drop toy in box](img/B19846_03_18.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图3.18 – 将玩具放入盒子](img/B19846_03_18.jpg)'
- en: Figure 3.18 – Drop toy in box
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18 – 将玩具放入盒子
- en: Our final step in the toy saga is to open the robot hand and let the toy hopefully
    fall into the toy box. I predict that we will have to spend some trial and error
    time getting this right. We may have to tilt the open hand right and left to get
    the toy to drop. If the toy falls outside of the box, then it is not put away
    and we have to start all over and try to put it away again. We don’t need a new
    state for this because it returns to being a toy on the floor, and we already
    have a state for that.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩具传奇的最终步骤中，我们要打开机器人手，让玩具有可能落入玩具盒中。我预测我们可能需要花费一些试错时间来做到这一点。我们可能需要将张开的手左右倾斜，以使玩具掉落。如果玩具掉出盒子外，那么它就没有被收好，我们必须从头开始，再次尝试收好它。我们不需要为这个状态创建新的状态，因为它会回到地板上的玩具状态，而我们已经有了一个对应的状态。
- en: I hope that you have seen in the storyboard process how this provides insight
    into visualizing the robot’s tasks. I would say the most important benefit is
    that it forces you to think about what the robot is doing and to break down each
    step into smaller and smaller parts. Don’t hesitate to take this storyboard and
    break an individual panel down into its own storyboard, if that is what you feel
    you need to do.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你在故事板过程中已经看到了这如何为可视化机器人的任务提供洞察力。我会说最重要的好处是它迫使你思考机器人正在做什么，并将每个步骤分解成越来越小的部分。如果你觉得需要这样做，不要犹豫，将单个画板分解成自己的故事板。
- en: Project goals
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目目标
- en: Since this is an AI/machine learning project, we must add to our project goals
    not just putting away toys but also using machine learning, adaptive systems,
    neural networks, and other tools to provide a new approach to solving these sorts
    of problems. You may think, “*Why bother? You can do this better with a standard
    programming approach.*” I would say from experience that these problems are difficult
    to solve that way, and you can do your own research to see where companies, large
    and small, have tried to solve this sort of problem and failed – or at least not
    succeeded. This problem is not easily solved by any means, and using an AI-based
    approach has a far greater chance of success than standard programming techniques.
    Now, I’m not saying we are going to succeed beyond our wildest dreams at this
    task in this book, but our objective is to learn a whole lot along the way!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个AI/机器学习项目，我们必须在项目目标中增加不仅仅是收好玩具，还要使用机器学习、自适应系统、神经网络和其他工具来提供一种解决这类问题的新方法。你可能想，“*为什么要费这个劲？你用标准的编程方法做得更好。*”
    我会从经验告诉你，这种方法很难解决问题，你可以自己进行研究，看看大小公司都尝试过解决这类问题但失败了——或者至少没有成功。这个问题用任何方法都很难解决，而使用基于AI的方法成功的可能性比标准编程技术要大得多。现在，我并不是说我们在这本书的任务中会取得超乎想象的巨大成功，但我们的目标是在这个过程中学到很多东西！
- en: So, we pause at this point in defining our project to say that we are deliberately
    choosing to use artificial intelligence and machine learning as an approach to
    solving a problem that has proven to be difficult with other means.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在定义项目的过程中暂停一下，明确表示我们故意选择使用人工智能和机器学习作为解决其他方法难以证明的问题的方法。
- en: Since we are going to be teaching the robot various tasks, it will be more effective
    if we can teleoperate the robot and drive it around like a radio-controlled car,
    in order to collect data and take pictures that we will use for object recognition
    later. We don’t need this for operations, we need this for training. We will add
    this required operation to our *to-do list.*
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将教机器人各种任务，如果我们能够远程操作机器人，像遥控车一样驾驶它，以便收集数据并拍照，这些数据我们将用于后续的对象识别，这将更有效。我们不需要这个用于操作，我们需要这个用于训练。我们将把这个必需的操作添加到我们的*待办事项列表*中。
- en: In our next step, we are going to extract from all of our hard work the **hardware**
    and **software** tasks that our robot will have to accomplish. But before we do
    this, let’s pause for a moment to discuss a common mistake made in defining the
    scope of the use case.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一步中，我们将从所有努力中提取出我们的机器人必须完成的**硬件**和**软件**任务。但在我们这样做之前，让我们暂停一下，讨论在定义用例范围时常见的错误。
- en: Understanding the scope of our use case
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解我们用例的范围
- en: '**Desirements** (a word made up by combining *desire* and *requirements*) are
    functions that would be *nice to have* but not strictly necessary. For example,
    if we decided to add flashing lights to the robot because it looks cool, that
    would be a desirement. You may want to have it, but it does not contribute to
    the mission of the robot or the task it needs to perform.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**愿望**（由*desire*和*requirements*组合而成的词）是那些“想要有”但不是严格必要的功能。例如，如果我们决定添加闪烁的灯光到机器人上因为它看起来很酷，那将是一个愿望。你可能想要它，但这并不有助于机器人的任务或它需要执行的任务。'
- en: Another example would be if we added that the robot must operate in the dark.
    There is no reason for this in the current context, and nothing we’ve stated in
    the use cases said that the robot would operate in the dark – just in an indoor
    room. This would be an example of **scope creep**, or extending the operation
    conditions without a solid reason why. It’s important to work very hard to keep
    requirements and use cases to a minimum, and even to throw out use cases that
    are unnecessary or redundant. I might have added a requirement for sorting the
    toys by color, but sorting does not help with picking up the toys, and besides,
    I’ve only got one toy box. I might have added the task in the interest of education
    for you, my readers, but it does not help with that objective either, so color
    sorting is not included.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，如果我们添加了机器人必须在黑暗中运行的条件。在当前情况下，这没有理由，我们也没有在用例中提到机器人将在黑暗中运行——只是在室内房间中。这将是**范围蔓延**的一个例子，即在没有充分理由的情况下扩展操作条件。重要的是要非常努力地将需求和用例保持在最低限度，甚至要丢弃不必要或冗余的用例。我可能添加了一个按颜色排序玩具的要求，但排序并不能帮助捡起玩具，而且，我只有一个玩具箱。我可能添加这个任务是为了教育我的读者，但这也不助于那个目标，所以颜色排序不包括在内。
- en: Now, let’s proceed to identifying our hardware requirements.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续确定我们的硬件需求。
- en: Identifying our hardware needs
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定我们的硬件需求
- en: 'Based on our storyboards, I extracted or derived the following hardware tasks:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的故事板，我提取或推导出以下硬件任务：
- en: Drive the robot base
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驱动机器人底座
- en: Carry the robot arm
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承载机器人手臂
- en: Lift toys
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉起玩具
- en: Put toys in the toy box (arm length)
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将玩具放入玩具箱（手臂长度）
- en: 'Sensors:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传感器：
- en: Arm location
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机械臂位置
- en: Hand status (open/close)
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手臂状态（开/关）
- en: Robot vision (camera) for obstacle avoidance
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人视觉（摄像头）用于避障
- en: 'Provide power for all systems:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为所有系统提供电源：
- en: 5V for Nvidia Nano
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Nvidia Nano提供5V电源
- en: 5V for Arduino
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Arduino提供5V电源
- en: Arm power – 7.2V
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机械臂电源 – 7.2V
- en: Motor power – 7.2V
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电机电源 – 7.2V
- en: 'Onboard computers:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 板载计算机：
- en: 'A computer that can receive commands remotely (Wi-Fi Nano):'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台可以接收远程命令的计算机（Wi-Fi Nano）：
- en: Runs ROS 2
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行ROS 2
- en: Runs Python 3
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Python 3
- en: A computer that can interface with a camera
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台可以与相机接口的计算机
- en: A computer that can control motors (Arduino)
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台可以控制电机的计算机（Arduino）
- en: An interface that can drive servo motors for the robot arm (servo controller)
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可以驱动机器人手臂伺服电机的接口（伺服控制器）
- en: Now, let’s take a look at the software requirements.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看软件需求。
- en: Breaking down our software needs
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆解我们的软件需求
- en: 'This list of software tasks was composed by reviewing the state machine diagram,
    the use cases, and the storyboards. I’ve highlighted the steps that will require
    AI and will be covered in detail in the coming chapters:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这份软件任务列表是通过审查状态机图、用例和故事板编制的。我已经突出显示了需要AI并将在后续章节中详细介绍的步骤：
- en: '**Power on** **self-test** (**POST**):'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**开机自检**（**Power on** **self-test** (**POST**））：'
- en: Start up robot programs.
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动机器人程序。
- en: Check that the Nano can talk to the Arduino and back.
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查Nano能否与Arduino通信并返回。
- en: Try to establish communications with the control station.
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试与控制站建立通信。
- en: Report POST success or failure as appropriate and enter in the log.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据适当的情况报告POST成功或失败并记录在日志中。
- en: 'Receive commands via Wi-Fi for teleoperation:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过Wi-Fi接收遥控命令：
- en: Drive motor base (right/left/forward/back)
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驱动电机底座（右/左/前进/后退）
- en: Move hand up/down/right/left/in/out/twist
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手臂上下/左右/旋转移动
- en: Record video or record pictures as image files
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 录制视频或记录图片作为图像文件
- en: Send telemetry via Wi-Fi.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过Wi-Fi发送遥测数据。
- en: Monitor progress.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监控进度。
- en: Send video.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送视频。
- en: 'Navigate safely:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全导航：
- en: Learn to avoid obstacles
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习避免障碍
- en: Learn to not fall down stairs
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习不摔倒楼梯
- en: 'Find toys:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到玩具：
- en: Detect objects
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测物体
- en: Learn to classify objects (Toy/Not toy)
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习分类物体（玩具/非玩具）
- en: Determine which toy is closest
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定哪个玩具最近
- en: 'Pick up toys:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿起玩具：
- en: Move to the position where the arm can reach the toy
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到手臂可以触及玩具的位置
- en: Devise a strategy for grasp
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制定掌握策略
- en: Attempt grasp
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试抓取
- en: Determine whether grasping was successful
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定抓取是否成功
- en: If not, try again with a different strategy
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有，尝试用不同的策略再次尝试
- en: Reweight grasp technique score based on success
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据成功率重新加权抓取技术得分
- en: 'Put toys in the toy box:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 把玩具放进玩具箱：
- en: Learn to identify the toy box
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习识别玩具箱
- en: Find the toy box
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到玩具箱
- en: Drive to the known toy box location using navigation
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用导航驾驶到已知的玩具箱位置
- en: 'Move to the dump location:'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动到垃圾投放点：
- en: Avoid obstacles
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免障碍
- en: Lift the toy above the toy box lid
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将玩具举过玩具箱盖
- en: Drop the toy
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放下玩具
- en: Check to see whether the toy drop was successful
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查玩具是否成功掉入玩具箱
- en: If not, reposition and try again
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不行，重新定位再试一次
- en: If the toy misses the toy box, we treat it as a toy on the floor again
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩具没有掉进玩具箱，我们将其视为地板上的玩具
- en: Determine there are no more toys.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定没有更多的玩具。
- en: Stand by for instructions.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待指令。
- en: 'Teleoperate:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 远程操作：
- en: Move base forward/backward/left/right
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动底盘前后左右
- en: Move arm up/down/right/left
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动手臂上下左右
- en: Move hand in/out/twist/open/close
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手臂进出/扭转/张开/合上
- en: Record video/take pictures
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 录制视频/拍照
- en: 'Simulate personality:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟个性：
- en: Talk
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 说话
- en: Listen/recognize words
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 听/识别单词
- en: Understand some commands
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解一些命令
- en: Tell knock-knock jokes
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讲讲敲门笑话
- en: Understand knock-knock jokes
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解敲门笑话
- en: 'Voice commands:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 语音命令：
- en: Clean-up room
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理房间
- en: Put this away
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 把这个收起来
- en: Come here
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过来
- en: Stop
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止
- en: Wait
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待
- en: Resume
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简历
- en: Go home
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回家
- en: Turn left/ right
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向左/向右转
- en: Forward/ back
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前进/后退
- en: Hand up/hand down
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手举/手放
- en: Hand left/hand right
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左手/右手
- en: Open hand/close hand
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 张开手/合上手
- en: In this list, where did I get *teleoperate*? We don’t remember discussing that
    in the use cases and storyboards. We are going to need to teach the robot to navigate
    and find toys, and for that, we need to move the robot around and take pictures.
    One easy way to do that is by driving the robot around with **teleoperations**
    (remote control).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，我在哪里看到了*远程操作*？我们不记得在用例和故事板中讨论过这一点。我们需要教会机器人导航和找到玩具，为此，我们需要移动机器人并拍照。一个简单的方法是通过**远程操作**（遥控）来驾驶机器人。
- en: Writing a specification
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写规格说明
- en: 'Our next task is to write specifications for our various components. I’ll go
    through an example here that we must do as part of our toy-grasping robot project:
    we need to *select a camera*. Just any old camera will not do – we need one that
    meets our needs. But what are those needs? We need to write a camera specification
    so that when we are looking at cameras to buy, we can tell which one will do the
    job.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是编写我们各种组件的规格说明。这里我将通过一个例子来讲解，这是我们玩具抓取机器人项目必须完成的部分：我们需要*选择一个相机*。任何旧的相机都不适用——我们需要一个满足我们需求的相机。但那些需求是什么？我们需要编写一个相机规格说明，这样当我们查看要购买的相机时，我们可以判断哪一台能够胜任这项工作。
- en: 'We’ve created our storyboard and our use cases, so we have the information
    we need to figure out what our camera needs to do. We can reverse engineer this
    process somewhat: let’s discuss what things make one camera different from another.
    First of all is the interface: this camera goes on board the robot, so it has
    to interface with the robot’s computer, which has USB, Ethernet, and a special
    camera bus. What other things about cameras do we care about? We certainly care
    about cost. We don’t want (or need) to use a $1,000 camera for our inexpensive
    robot. Cameras have resolution: the number of pixels in each image. That can vary
    from 320 x 240 to 4,000 x 2,000 (4K). Cameras also have a field of view, which
    is the number of angular degrees the camera can see. This can vary from 2.5 degrees
    (very narrow) to 180 degrees (very wide). There are also cameras that see in the
    dark or have various types of infrared sensitivity. Finally, there is size and
    weight; we need a small camera that fits on our robot.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了我们的故事板和用例，因此我们有了确定我们的相机需要做什么所需的信息。我们可以某种程度上逆向工程这个过程：让我们讨论一下是什么让一个相机与另一个相机不同。首先当然是接口：这个相机安装在机器人上，因此它必须与机器人的计算机接口，该计算机有USB、以太网和专门的相机总线。我们还需要关注相机的哪些其他方面？我们当然关心成本。我们不希望（或需要）为我们的低成本机器人使用价值1000美元的相机。相机有分辨率：每张图片中的像素数。这可以从320
    x 240变化到4,000 x 2,000（4K）。相机还有视野，这是相机可以看到的角度数。这可以从2.5度（非常窄）变化到180度（非常宽）。还有一些相机可以在黑暗中看到或者有各种类型的光学红外灵敏度。最后，还有尺寸和重量；我们需要一个适合我们机器人的小型相机。
- en: 'This makes the parameters that we need to decide the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这决定了我们需要决定的以下参数：
- en: '**Field of view**: [180 - > 2.5]'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视野**：[180 - > 2.5]'
- en: '**Resolution**: [320 x 280 -> 4,000 x 2,000]'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分辨率**：[320 x 280 -> 4,000 x 2,000]'
- en: '**Cost**: (low to high) – cheaper is better'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本**：（从低到高）——越便宜越好'
- en: '**Sees in the** **dark**: Yes/no'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在黑暗中看**：是/否'
- en: '**Size and weight**: Smaller and lighter is much better; must fit on the robot'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尺寸和重量**：越小越轻越好；必须适合安装在机器人上'
- en: '**Interface**: USB, Ethernet, or camera bus; power >11V'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口**：USB、以太网或相机总线；电源 >11V'
- en: 'The reason for listing these parameters like this is that we can now concentrate
    on those features that we can select, so we are not wasting time looking at other
    parameters that we don’t care about. Let’s see whether we can knock off some of
    the parameters:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 列出这些参数的原因是，我们现在可以集中精力选择那些我们可以选择的功能，这样我们就不会浪费时间查看我们不关心的其他参数。让我们看看我们是否可以取消一些参数：
- en: If we use USB as the **interface**, the power is provided by the connector,
    and we don’t need extra cables or routers. This is also the lowest cost method,
    so we choose USB as the interface.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用USB作为**接口**，电源由连接器提供，我们不需要额外的电缆或路由器。这也是成本最低的方法，因此我们选择USB作为接口。
- en: We also don’t have any requirements in our use cases to **see in the dark**,
    so we don’t need a special infrared camera.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的用例中，我们没有对**在黑暗中看**的要求，因此我们不需要特殊的红外相机。
- en: The next question is to determine the **field of view**. We need to see the
    entire area where the robot arm can move in as it picks up a toy. We also need
    enough field of view to see when we are driving to avoid obstacles. We can take
    some measurements from the robot, but we can quickly see that we mostly need to
    see close to the robot, and we can’t see past the tracks on either side. This
    sets the field of view required to be close to 90 degrees. More field of view
    than this is acceptable, less is not.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个问题是要确定**视野**。我们需要看到机器人手臂在拿起玩具时可以移动的整个区域。我们还需要足够的视野来避免障碍物时驾驶。我们可以从机器人上获取一些测量数据，但我们可以很快地看到我们主要需要看到靠近机器人的地方，而且我们看不到两侧轨道之外的地方。这确定了所需的视野接近90度。比这更大的视野是可以接受的，比这更小的则不行。
- en: Our final problem is determining the **resolution** we need to perform our object
    recognition. For that, we need an additional data point – how many pixels do we
    need to recognize an object as a toy? That is what we will do with this camera
    – recognize toys and things that are not toys. We also have to pick a distance
    at which we can recognize the toy. We don’t have a firm requirement out of the
    use cases, so we have to make an educated guess. We know that our room is 17 feet
    long, and it has furniture in it. Let’s guess that we need 8 feet of distance.
    How do we know this is correct? We do a thought experiment. If we can identify
    a toy 8 feet away, can we accomplish our task? We can see the toy half a room
    away. That gives the robot plenty of space to go drive to the toy and it won’t
    spend much time looking for toys. As a check, if the robot had to be 4 feet away
    to recognize a toy, would that be unusable? The answer is probably not – the robot
    would work OK. How about 3 feet? Now we are getting to the point where the robot
    has to drive right up to the toy to determine what it is, and that might result
    in more complicated logic to examine toys. So, we say that 3 feet is not enough,
    4 feet is acceptable, and 8 feet would be great.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们最终的问题是确定进行物体识别所需的**分辨率**。为此，我们需要一个额外的数据点——我们需要多少像素才能将一个物体识别为玩具？这就是我们将用这个摄像头做的——识别玩具和不是玩具的东西。我们还必须选择一个可以识别玩具的距离。我们没有从用例中得出一个明确的要求，所以我们必须做出一个有根据的猜测。我们知道我们的房间长17英尺，里面有家具。让我们猜测我们需要8英尺的距离。我们怎么知道这是正确的呢？我们做一个思想实验。如果我们能在8英尺远的地方识别一个玩具，我们能完成我们的任务吗？我们可以看到房间一半远处的玩具。这给机器人提供了足够的空间去驾驶到玩具那里，而且它不会花太多时间寻找玩具。作为一个检查，如果机器人必须距离4英尺才能识别一个玩具，那会不可用吗？答案可能是不会——机器人会正常工作。3英尺呢？现在我们到了机器人必须直接开到玩具那里才能确定它是什么的程度，这可能会导致检查玩具的逻辑更加复杂。所以，我们说3英尺不够，4英尺可以接受，而8英尺会很好。
- en: What resolution is required in the camera to recognize a toy at 8 feet with
    a 90-degree lens? I can tell you that the ImageNet database requires a sample
    35 pixels wide to recognize an object, so we can use that as a benchmark. We assume
    at this point that we need an image at least 35 pixels across. Let’s start with
    a camera with *1,024 x 768* pixels, which is 1,024 pixels wide. We divide by 90
    degrees to get that each degree has 11.3 pixels (*1,024/90*). How big is our smallest
    toy at 8 feet? Our smallest toy is a Hot Wheels toy, which is approximately 3
    inches long. At 8 feet, this is 1.79 degrees or 20.23 pixels (*1.79 degrees x
    11.3 pixels/degree*). That is not enough. Solving the distance equation for 3
    inches, we get a maximum distance of 4.77 feet for a camera with *1,024 x 768*
    pixels. That is just barely acceptable. What if we had an HD sensor with *1,900
    x 1200* pixels? Then, at 8 feet, I get 75 pixels – more than enough to give us
    the best possible distance. If we use a sensor 1,200 pixels wide, we have a recognition
    distance of 5.46 feet, which is adequate but not great.
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 摄像头需要多少分辨率才能在8英尺远的地方用90度镜头识别一个玩具？我可以告诉你，ImageNet数据库需要宽度至少为35像素的样本才能识别一个物体，所以我们可以将其作为一个基准。我们假设在这个阶段，我们需要至少35像素宽的图像。让我们从一个拥有*1,024
    x 768*像素的摄像头开始，它的宽度是1,024像素。我们将它除以90度，得到每个度有11.3像素（*1,024/90*）。我们的最小玩具在8英尺处有多大？我们的最小玩具是一个Hot
    Wheels玩具，大约3英寸长。在8英尺处，这是1.79度或20.23像素（*1.79度 x 11.3像素/度*）。这还不够。解出3英寸的距离方程，我们得到一个具有*1,024
    x 768*像素的摄像头的最大距离为4.77英尺。这勉强可以接受。如果我们有一个具有*1,900 x 1200*像素的HD传感器呢？那么，在8英尺处，我得到75像素——足够给我们提供最佳距离。如果我们使用宽度为1,200像素的传感器，我们的识别距离为5.46英尺，这足够但不是很好。
- en: I walked you through this process to show you how to write a specification and
    the types of questions you should be asking yourself as you decide what sensors
    to acquire for your project.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我带你走过了这个过程，以展示如何编写规范，以及在你决定为你的项目获取哪些传感器时，你应该问自己哪些类型的问题。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter outlined a suggested process for developing your to-do list as
    you develop your robot project. This process is called systems engineering. Our
    first step was to create use cases or descriptions of how the robot is to behave
    from a user’s perspective. Then, we created more detail behind the use cases by
    creating storyboards, where we went step by step through the use case. Our example
    followed the robot finding and recognizing toys, before picking them up and putting
    them in the toy box. We extracted our hardware and software needs, creating a
    to-do list of what the robot will be able to do. Finally, we wrote a specification
    for one of our critical sensors: the camera.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了在开发机器人项目时，如何开发待办事项列表的建议流程。这个过程被称为系统工程。我们的第一步是创建用例或描述机器人从用户角度应该如何表现。然后，我们通过创建分镜脚本，逐步通过用例来创建更多细节。我们的例子是机器人找到并识别玩具，然后拿起它们并将它们放入玩具箱。我们提取了我们的硬件和软件需求，创建了一个待办事项列表，列出了机器人将能够做什么。最后，我们为我们的关键传感器之一——摄像头编写了规范。
- en: In the next chapter, we will dive into our first robot task – teaching the robot
    to recognize toys using computer vision and neural networks.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨我们的第一个机器人任务——使用计算机视觉和神经网络教机器人识别玩具。
- en: Questions
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Describe some of the differences between a storyboard for a movie or cartoon
    and a storyboard for a software program.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述一下电影或卡通的分镜脚本与软件程序的分镜脚本之间的区别。
- en: What are the five *W* questions? Can you think of any more questions that would
    be relevant to examine a use case?
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是五个“W”问题？你能想到任何其他与检查用例相关的问题吗？
- en: 'Complete this sentence: A use case shows what the robot does but not _____.'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这个句子：用例显示了机器人做什么，但没有显示______。
- en: Take *storyboard 9* in *Figure 3**.16*, where the robot is driving to the toy
    box, and break it down into more sequenced steps in your own storyboard. Think
    about all that must happen between *frames 9* *and 10*.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以图3**.16**中的*分镜9*为例，其中机器人正在驶向玩具箱，并在你自己的分镜脚本中将它分解成更多有序的步骤。考虑在*第9帧*和*第10帧*之间必须发生的一切。
- en: Complete the reply form of the knock-knock joke, where the robot answers the
    user telling the joke. What do you think is the last step?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成敲敲门笑话的回复表格，其中机器人回答用户讲述的笑话。你认为最后一步是什么？
- en: Look at the teleoperate operations. Would you add any more, or does this look
    like a good list?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看远程操作操作。你会添加更多吗，或者这个列表看起来已经很好了？
- en: Write a specification for a sensor that uses distance measurement to prevent
    the robot from driving downstairs.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为一个使用距离测量来防止机器人驶下楼梯的传感器编写规范。
- en: What is the distance at which a camera with 320 x 200 pixels and a 30-degree
    field of view can see a 6-inch wide stuffed animal, still assuming we need 35
    pixels for recognition?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个摄像头在320 x 200像素和30度视野下，能看到多远处的6英寸宽的填充动物，仍然假设我们需要35像素来进行识别？
- en: Further reading
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information on the topics in this chapter, you can refer to the following
    resources:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章主题的更多信息，您可以参考以下资源：
- en: '*A Practical Guide to SysML: The Systems Modeling Language*, by Sanford Friedenthal,
    Alan Moore, and Rick Steiner, published by Morgan Kaufman; this is the standard
    introduction to **Model-Based Systems** **Engineering** (**MBSE**)'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《SysML实用指南：系统建模语言》*，由Sanford Friedenthal、Alan Moore和Rick Steiner著，由Morgan
    Kaufman出版；这是**基于模型的系统工程**（MBSE）的标准入门书籍。'
- en: '*The Agile Developer’s Handbook* by Paul Flewelling, published by Packt'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《敏捷开发者手册》*，由Paul Flewelling著，由Packt出版。'
- en: 'Part 2: Adding Perception, Learning, and Interaction to Robotics'
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：将感知、学习和交互添加到机器人技术
- en: To see, understand, and interact with the environment, robots need to have perception.
    AI is one approach that can be used for recognizing objects and navigation. This
    part empowers you with the essential skills to efficiently operate your robots
    using AI techniques. Our example in this book is creating a robot that picks up
    toys, so we start with recognizing toys with a **neural network**. Then we work
    with the robot arm to pick up toys using tools such as **reinforcement learning**
    and **genetic algorithms**. The next chapter covers the creation of a robot digital
    assistant that can listen and understand your commands, and even tell knock-knock
    jokes.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了观察、理解和与环境互动，机器人需要具备感知能力。人工智能是识别物体和导航的一种方法。本部分将赋予你使用人工智能技术高效操作机器人的基本技能。本书的例子是创建一个能够拾取玩具的机器人，因此我们首先从使用**神经网络**识别玩具开始。然后，我们与机器人手臂合作，使用**强化学习**和**遗传算法**等工具拾取玩具。下一章将介绍创建一个能够倾听和理解你的命令，甚至讲笑话的机器人数字助手。
- en: 'This part has the following chapters:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 4*](B19846_04.xhtml#_idTextAnchor126), *Recognizing Objects Using
    Neural Networks and Supervised Learning*'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B19846_04.xhtml#_idTextAnchor126), *使用神经网络和监督学习识别物体*'
- en: '[*Chapter 5*](B19846_05.xhtml#_idTextAnchor159), *Picking Up and Putting Away
    Toys Using Reinforcement Learning and Genetic Algorithms*'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B19846_05.xhtml#_idTextAnchor159), *使用强化学习和遗传算法拾取和放置玩具*'
- en: '[*Chapter 6*](B19846_06.xhtml#_idTextAnchor205), *Teaching the Robot to Listen*'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B19846_06.xhtml#_idTextAnchor205), *教机器人学会倾听*'
