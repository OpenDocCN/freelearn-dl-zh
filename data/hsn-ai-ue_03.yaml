- en: Behavior Trees and Blackboards
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为树和黑板
- en: '*A tree to decide how we should behave, a blackboard to remember it!*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个决定我们如何行动的树，一个黑板来记住它！**'
- en: Welcome to [Chapter 2](00781951-41e3-4e33-8512-052e7aecfd15.xhtml), *Behavior
    Trees and Blackboards*. This is where things start to get a bit more interesting
    because we will learn how to use the two main Unreal AI Framework structures.
    First, we will look at ***Behavior Tree**s*** and learn all about their principal
    components, such as tasks, decorators, and services. Next, we will learn about
    ***Blackboards*** and how to integrate them with ***Behavior Trees***. After we
    have covered this, will be able to set up AI controllers that use ***Behavior
    Trees***, which is key in implementing the rest of the techniques in this book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到**第2章**[Chapter 2](00781951-41e3-4e33-8512-052e7aecfd15.xhtml)，*行为树和黑板*。从这里开始，事情开始变得更有趣，因为我们将会学习如何使用两个主要的虚幻AI框架结构。首先，我们将查看**行为树**并了解它们的主要组件，如任务、装饰器和服务。接下来，我们将学习关于**黑板**的内容以及如何将其与**行为树**集成。在完成这些之后，我们将能够设置使用**行为树**的AI控制器，这对于实现本书中其余的技术至关重要。
- en: As you may notice, there is a pattern in which we first learn a little bit about
    the theory, and then we jump straight into practice to understand how it all works.
    This is a pattern that we will follow in each chapter. So, let's get going.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，我们首先学习一点理论，然后直接进入实践来理解它是如何运作的。这是我们将在每一章中遵循的模式。所以，让我们开始吧。
- en: 'In the field of *Decision-Making*, there are many mathematical structures that
    can be used. **Finite State Machines** (**FSM**s) are an easy, yet powerful example
    of systems that are able to make complex decisions. However, in the world of Artificial
    Intelligence for games, there is another structure that can also be used by non-AI
    experts: ***Behavior Trees***.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在决策领域，有许多可以使用的数学结构。**有限状态机**（FSM）是一个简单而强大的例子，它能够做出复杂的决策。然而，在游戏人工智能的世界中，还有一个结构可以被非AI专家使用：**行为树**。
- en: As a result, one of the design choices of Unreal Engine is that it has built-in
    support for Behavior Trees, and is actually part of the main core of the AI Framework.
    This does not imply that you cannot implement other decision-making processes
    or structures, but using the built-in support for Behavior Trees will greatly
    benefit your team's budget (in terms of time). So, before you implement a different
    Decision-Making structure in Unreal, think twice about whether that is a good
    decision (of course, a Behavior Tree might not be optimal for your game, but keep
    in mind that they have built-in support and might be a great time-saver). Nonetheless,
    you can still implement sub-structures within the ***Behavior Tree*** to extend
    its functionality, but do not rush too much; first, let's learn about the basics
    of ***Behav******ior Trees***.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虚幻引擎的设计选择之一是它内置了对行为树的支持，并且实际上是AI框架的主要核心部分。这并不意味着你不能实现其他决策过程或结构，但使用内置的行为树支持将大大有利于你团队的预算（从时间角度考虑）。所以，在你实现在虚幻引擎中的不同决策结构之前，请三思是否这是一个好的决定（当然，行为树可能不是你游戏的最佳选择，但请记住它们有内置支持，可能是一个节省时间的好方法）。然而，你仍然可以在行为树中实现子结构来扩展其功能，但不要急于求成；首先，让我们来了解一下行为树的基础知识。
- en: 'In particular, in this chapter, we will learn about the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，在本章中，我们将学习以下主题：
- en: What a ***Behavior Tree*** is, both in broader terms and within the Unreal Context.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为树**是什么，从更广泛的角度和虚幻引擎的上下文中来看。'
- en: How a ***Behavior Tree works*** within Unreal, including its different components
    and how they interact with the tree
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，**行为树**是如何工作的，包括其不同的组件以及它们如何与树交互
- en: What a ***Blackboard*** is and how it can be used to store data for the Behavior
    Tree
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是**黑板**以及它如何用于存储行为树的数据
- en: How to ***start running a Behavior Tree*** by using the AI Controller, both
    in Blueprint and C++
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过使用AI控制器**启动运行行为树**，无论是在蓝图还是C++中
- en: So, let's dive in!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们深入探讨！
- en: How Behavior Trees work
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为树是如何工作的
- en: The easiest way to think about the role that a Behavior Tree assumes within
    our AI Agent is to imagine it as a brain. It makes decisions and, as a consequence,
    acts on them. It is the processor for the artificial intelligence within our agent.
    Before we get started, if you have any experience with Behavior Trees in other
    contexts, it is important to understand that they differ in the context of Unreal.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到行为树在我们AI代理中的作用，最简单的方法是将其想象成一个大脑。它做出决定，并相应地采取行动。它是我们代理中人工智能的处理器。在我们开始之前，如果你在其他环境中对行为树有任何经验，重要的是要理解它们在虚幻引擎中的不同。
- en: 'If you want to learn more about how they are different, you can do so by visiting
    the following link: [https://docs.unrealengine.com/en-US/Engine/AI/BehaviorTrees/HowUE4BehaviorTreesDiffer](https://docs.unrealengine.com/en-US/Engine/AI/BehaviorTrees/HowUE4BehaviorTreesDiffer).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于它们如何不同的信息，你可以通过访问以下链接来了解：[https://docs.unrealengine.com/en-US/Engine/AI/BehaviorTrees/HowUE4BehaviorTreesDiffer](https://docs.unrealengine.com/en-US/Engine/AI/BehaviorTrees/HowUE4BehaviorTreesDiffer)。
- en: 'It is, however, important to highlight one key difference here: ***Unreal Behavior
    Trees*** are read from the top to the bottom, and nodes will be executed from
    left to right. In other contexts, you might have found this to the other way around,
    in which the tree is read from left to right, and the nodes are executed from
    top to bottom.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这里强调一个关键的区别是很重要的：***虚幻引擎的行为树***是从上到下读取的，节点将从左到右执行。在其他环境中，你可能发现顺序相反，即树是从左到右读取的，节点是从上到下执行的。
- en: If this is the first time you have encountered a Behavior Tree, then this will
    make sense when you read the next section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你第一次遇到行为树，那么当你阅读下一节时，这将会变得有意义。
- en: The structure of a Mathematical Tree
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学树的结构
- en: Alright, it's time to understand how a ***Behavior Tree*** works. First of all,
    as the name suggests, it is a tree, mathematical speaking.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在是时候了解一个***行为树***是如何工作的了。首先，正如其名所示，它是一个树，从数学的角度来说。
- en: 'If you are interested to learn more about trees in graph theory, you can consult
    the following Wikipedia page: [https://en.wikipedia.org/wiki/Tree_(graph_theory)](https://en.wikipedia.org/wiki/Tree_(graph_theory)).
    Alternatively, if you want to get even more technical, you can consult the following
    page: [http://mathworld.wolfram.com/Tree.html](http://mathworld.wolfram.com/Tree.html).
    However, the definitions that are found at both the links are pretty mathematical,
    and you don''t need them to understand Behavior Trees.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于图论中树的信息，你可以查阅以下维基百科页面：[https://zh.wikipedia.org/wiki/树_(图论)](https://zh.wikipedia.org/wiki/树_(图论))。或者，如果你想了解得更深入，你可以查阅以下页面：[http://mathworld.wolfram.com/Tree.html](http://mathworld.wolfram.com/Tree.html)。然而，两个链接中找到的定义都非常数学化，你不需要它们来理解行为树。
- en: 'It is important to specify that a (mathematical) tree expresses relationships
    between nodes. In this sense, the same relationship that describes a family (e.g.
    parent, child, sibling) has been adopted in technical terms. To simplify the understanding
    of a tree, you can imagine your genealogical tree: each node is a person, and
    the branches (that connect people) are the relationships between the various people.
    However, the structure is still slightly different.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 需要明确的是，一个（数学）树表达了节点之间的关系。在这个意义上，描述家庭（例如，父母、子女、兄弟姐妹）的技术术语中采用了相同的关系。为了简化对树的了解，你可以想象你的家谱树：每个节点是一个人，连接人们的分支（即关系）是各种人之间的关系。然而，结构还是略有不同。
- en: So, what is a tree? It is a graph that describes relationships between different
    nodes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是树？它是一个描述不同节点之间关系的图。
- en: 'In particular, there is a "***Root***" node, which is *the only node without
    a parent*. From there, *every node can have one or more children*, *but only one
    parent*. The end nodes, which are the ones that do not have any child, are called
    ***leaves***. Here is a simple diagram to help you understand the basic structure
    of a *Mathematical Tree* in general:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，有一个***根***节点，它是*唯一没有父节点的节点*。从那里，*每个节点可以有一个或多个子节点*，*但只有一个父节点*。没有子节点的终端节点被称为***叶子节点*。以下是一个简单的图表，帮助你理解一般*数学树*的基本结构：
- en: '![](img/d49467c4-7e43-45bd-bebc-0a0ccd1d2733.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d49467c4-7e43-45bd-bebc-0a0ccd1d2733.png)'
- en: It might sound complicated, but it really isn't. Things will start getting interesting
    as we move on and talk about BehaviorTrees.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来很复杂，但实际上并不复杂。当我们继续前进并讨论行为树时，事情将会变得有趣起来。
- en: Behavior Tree components
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为树组件
- en: If you go through the official documentation, you will find that there are five
    types of nodes (***Task***, ***Decorator***, ***Service***, ***Composite***, and
    ***Root***) available to use, depending on the type of behavior that you're trying
    to create (and subsequently, how the AI should act in the world). However, I'd
    like to reformulate this to you in order to make it easier to understand and hopefully
    more practical.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看官方文档，你会发现有五种类型的节点（**任务**、**装饰器**、**服务**、**组合**和**根**）可供使用，具体取决于你试图创建的行为类型（以及随后AI在世界上应该如何行动）。然而，我想以更易于理解的方式重新表述这一点，并希望它更实用。
- en: 'Besides the ***Root*** node, the only kind of nodes (that are not leaves) are
    the ***Composites*** nodes. Leaves are called ***Tasks***. ***Decorators*** and
    ***Services*** are *add-ons* for either a *Composite* node or a *Task* leaf. Although
    Unreal lets you leave a *Composite* node as a leaf, you shouldn''t, because it
    means that you can remove that node and the Behavior Tree will still work in the
    same way. Here is an example of a tree showing all the different types of node
    (actually, we will build this *Behavior Tree* later in this book):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了**根**节点之外，唯一的一种不是叶子的节点是**组合**节点。叶子被称为**任务**。**装饰器**和**服务**是**组合**节点或**任务**叶子的附加功能。尽管虚幻引擎允许你将**组合**节点作为叶子使用，但你不应该这样做，因为这意味着你可以移除该节点，而行为树仍然会以相同的方式工作。以下是一个显示所有不同类型节点的树形结构的示例（实际上，我们将在本书的后面部分构建这个**行为树**）：
- en: '![](img/c71a9cbe-925e-4e5f-8e48-548b7d9efc47.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c71a9cbe-925e-4e5f-8e48-548b7d9efc47.png)'
- en: When a tree is executing, you need to start following from the root node and
    go down the tree, reading the nodes from left to right. You traverse all the different
    branches (***Composite*** nodes) in a specific way (we are going to see this in
    a little while), until we reach a leaf, which is a ***Task***. In this case, the
    AI performs that ***Task***. It is important to note that a ***Task*** can fail,
    for instance, if the AI is unable to complete it. The fact that a *Task* can fail
    will be useful for understanding how Composite nodes work. After all, a decision-making
    process is just choosing which task to perform to achieve a goal in a better way
    (e.g. killing the player). Thus, based on which task failed to execute (or, as
    we will see, a Decorator can make a task or a whole branch fail), the Composite
    nodes will determine the next tasks in the tree.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当树在执行时，你需要从根节点开始，沿着树向下，从左到右读取节点。你以特定的方式遍历所有不同的分支（**组合**节点），直到我们达到一个叶子，即**任务**。在这种情况下，AI将执行那个**任务**。重要的是要注意，**任务**可能会失败，例如，如果AI无法完成它。*任务*可能会失败的事实将有助于理解组合节点的工作原理。毕竟，决策过程只是选择执行哪个任务以更好地实现目标（例如，杀死玩家）。因此，根据哪个任务未能执行（或者，正如我们将看到的，装饰器可以使任务或整个分支失败），组合节点将确定树中的下一个任务。
- en: 'In addition, when you create your ***Behavior Tree***, each node can be selected,
    and some settings to adjust the behavior of the node/leaf can be found in the
    *Detail Panel*. Moreover, since the order is important, the nodes in the Behavior
    Tree have numbers (in the top-right corner) to help you understand the ordering
    of the node (although it is always from top to bottom, left to right). The following
    screenshot shows where you can find these numbers:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当你创建你的**行为树**时，每个节点都可以被选中，你可以在**详细面板**中找到一些调整节点/叶子的行为设置的选项。此外，由于顺序很重要，行为树中的节点有数字（在右上角）来帮助你理解节点的顺序（尽管它始终是从上到下，从左到右）。以下截图显示了你可以找到这些数字的位置：
- en: '![](img/bb35abb8-d2b7-441b-93c1-1370be2b29d6.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bb35abb8-d2b7-441b-93c1-1370be2b29d6.png)'
- en: 'A value of "*-1*" means that the node will never be executed in any order,
    and the color around the node will be a bit darker. This might be due to the fact
    that the node is not connected in some way to the root, and so it is isolated:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: “*-1*”的值意味着节点将不会以任何顺序执行，节点周围的色彩会略暗。这可能是由于节点以某种方式未连接到根，因此它是孤立的：
- en: '![](img/f6e82db7-47f6-4d5b-86d8-9ad6695ec0ec.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f6e82db7-47f6-4d5b-86d8-9ad6695ec0ec.png)'
- en: Let's look at these components in detail and pay particular attention to ***Composite***
    nodes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这些组件，并特别注意**组合**节点。
- en: Root
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根
- en: 'There isn''t much to say about the ***ROOT*** node. The tree needs to begin
    somewhere, so the Root node is just where the tree starts its execution. Here
    is what it looks like:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**根**节点，没有太多可说的。树需要从某个地方开始，所以根节点就是树开始执行的地方。下面是这个节点的样子：
- en: '![](img/bca76338-5fba-4d62-b753-d1d82d74f05b.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bca76338-5fba-4d62-b753-d1d82d74f05b.png)'
- en: 'Please note that the ***Root*** node can have only one child, and this must
    be a ***Composite*** node. You cannot attach any *Decorator* or *Service* to the
    ***Root***. If you select the ***Root*** node, it doesn''t have any property,
    but you will be able to assign a ***Blackboard*** (which we will cover later in
    this chapter), as shown in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，***根节点***只能有一个子节点，并且这个子节点必须是***组合节点***。您不能将任何***装饰器***或***服务***附加到***根节点***。如果您选择***根节点***，它没有任何属性，但您将能够分配一个***黑板***（我们将在本章后面介绍），如下面的屏幕截图所示：
- en: '![](img/ee43b04f-4fae-4aca-b9be-5a6f1dc9d828.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee43b04f-4fae-4aca-b9be-5a6f1dc9d828.png)'
- en: Tasks
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务
- en: When we think of a tree, we often picture a large trunk with branches, and on
    those branches are leaves. In the context of UE4, those “*leaves*” are what we
    call “***Tasks***”. These are nodes that perform various actions, such as moving
    an AI, and can have *Decorator* or *Service* nodes attached to them. However,
    they do not have an output, which means that they do not play a role in the decision-making
    process itself, which is left entirely to Composite nodes. Instead, they define
    what an AI should do if that task needs to be executed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想到一棵树时，我们通常会想象一个粗大的树干和树枝，树枝上长着叶子。在UE4的上下文中，那些“***叶子***”就是我们所说的“***任务***”。这些是执行各种动作的节点，例如移动AI，并且可以附加***装饰器***或***服务***节点。然而，它们没有输出，这意味着它们本身不参与决策过程，这个决策完全由组合节点负责。相反，它们定义了如果该任务需要执行，AI应该做什么。
- en: Please note that ***Tasks*** can be as complex as you like. They can be as simple
    as waiting an amount of time, to being as complex as solving a puzzle while shooting
    at the player. Huge tasks are hard to debug and maintain, while small tasks can
    make the ***Behavior Tree*** easily overcrowded and huge. As a good AI Designer,
    you should try to find a balance between the size of the task and write them in
    such a way that they can be reused in different parts of the tree (or even in
    other trees).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，***任务***可以像您喜欢的那样复杂。它们可以像等待一段时间那样简单，也可以像在射击玩家的同时解决谜题那样复杂。大任务难以调试和维护，而小任务可能会使***行为树***变得过于拥挤和庞大。作为一名优秀的AI设计师，您应该尝试在任务的大小之间找到平衡，并以一种方式编写它们，以便它们可以在树的各个部分（甚至在其他树中）重复使用。
- en: A *Task* can either ***Fail*** (report ***Failure***) or ***Succeed*** (report ***Success***),
    and it will not stop its execution until one of these two results is reported.
    *Composite* nodes are responsible for taking care of this result and deciding
    on what to do next. Thus, a Task might need several frames to executed, but it
    will end only when it reports either *Failure* or *Success*. Keep this in mind
    when you move on to[Chapter 6](e8c4d8a9-579e-4e38-b02a-a9002f1c48ce.xhtml), *Extending
    Behavior Trees*, where you will create your own Tasks.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*任务*可以***失败***（报告***失败***）或***成功***（报告***成功***），并且它不会停止执行直到报告这两个结果之一。***组合节点***负责处理这个结果并决定下一步要做什么。因此，一个任务可能需要几个帧来执行，但它只有在报告了***失败***或***成功***时才会结束。当您继续到[第6章](e8c4d8a9-579e-4e38-b02a-a9002f1c48ce.xhtml)，*扩展行为树*时，请记住这一点，在那里您将创建自己的任务。
- en: '*Tasks* can have parameters (which you will be able to set in the *Details
    Panel* once a *Task* has been selected), and usually, they are either hard-coded
    values or *Blackboard Key references* (more on *Blackboards* later in this chapter).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*任务*可以有参数（一旦选择了一个*任务*，您就可以在*详细信息面板*中设置这些参数），通常它们是硬编码的值或***黑板键引用***（关于***黑板***的更多内容将在本章后面介绍）。'
- en: 'Within the Behavior Tree editor, a Task appears as a purple box. In the following
    screenshot, you can see some examples of Tasks and how they look within the Editor:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在行为树编辑器中，任务以紫色框的形式出现。在下面的屏幕截图中，您可以查看一些任务的示例以及它们在编辑器中的外观：
- en: '![](img/ab90dd1b-0e74-41cc-8102-551541615f3c.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab90dd1b-0e74-41cc-8102-551541615f3c.png)'
- en: Unreal comes with some built-in Tasks that are ready to be used. They are general
    and cover the basic cases that you will probably need. Obviously, they cannot
    be specific to your game, so you will need to create your own *Tasks* (we will
    look at this in [Chapter 6](e8c4d8a9-579e-4e38-b02a-a9002f1c48ce.xhtml), *Extending
    Behavior Trees*).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal自带一些内置的任务，可以直接使用。它们是通用的，涵盖了您可能需要的最基本的情况。显然，它们不能针对您的游戏特定，因此您需要创建自己的*任务*（我们将在[第6章](e8c4d8a9-579e-4e38-b02a-a9002f1c48ce.xhtml)，*扩展行为树*)中查看这一点）。
- en: 'Here is the list of the built-in tasks in Unreal:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Unreal内置任务的列表：
- en: '![](img/8a1a9e32-3274-4e95-bac9-8d737562fe47.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a1a9e32-3274-4e95-bac9-8d737562fe47.png)'
- en: '***Finish with Result***: Forces the Task to return a *Finish Result* (either
    *Fail* or *Succeed*) for this task immediately.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***完成并返回结果***：强制任务立即返回一个*完成结果*（无论是*失败*还是*成功*）。'
- en: '***Make Noise***: Produces a noise stimulus, which is used by the *Perception
    System* (this will be explored in [Chapter 5](94d71bd8-35a2-481e-adac-1fc3494350ba.xhtml),
    *Agent Awareness*).'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***制造噪音***：产生一个噪音刺激，由*感知系统*（这将在[第5章](94d71bd8-35a2-481e-adac-1fc3494350ba.xhtml)，*代理意识*）使用。'
- en: '***Move Directly Toward***: Like the following node, but it disregards the
    *Navigation System*.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***直接朝向移动***：与下面的节点类似，但它忽略了*导航系统*。'
- en: '***Move To***: Moves the Pawn (by using the *Navigation System*, which we will
    explore in [Chapter 3](fe5b7602-fcb4-4d39-bf8c-e1742909205a.xhtml), *Navigation*)
    to a location that''s specified from the *Blackboard* (we will explore *Blackboards*
    later in this chapter).'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***移动到***：使用*导航系统*（我们将在[第3章](fe5b7602-fcb4-4d39-bf8c-e1742909205a.xhtml)，*导航*）将Pawn移动到从*黑板*中指定的位置（我们将在本章后面介绍*黑板*）。'
- en: '***Play Animation***: As the name suggests, this node plays an animation. However,
    exceptions aside (and this is the reason why this node exists), it is good practice to
    separate animation logic and behavior logic. Therefore, try not to use this node,
    and instead improve your Animation Blueprint.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***播放动画***：正如其名所示，此节点播放动画。然而，除了例外情况（这也是此节点存在的原因）之外，将动画逻辑和行为逻辑分开是良好的实践。因此，尽量不使用此节点，而是改进你的动画蓝图。'
- en: '***Play Sound***: As the name suggests, this node plays a sound.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***播放声音***：正如其名所示，此节点播放声音。'
- en: '***Push Pawn Action***: Performs a *Pawn Action* (unfortunately, we will not
    cover them in this book).'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***推送Pawn动作***：执行一个*Pawn动作*（不幸的是，我们不会在本章中介绍它们）。'
- en: '***Rotate to face BBEntry***: Rotates the AI pawn to face a specific key that''s
    been memorized inside the Blackboard (we will look at what *Blackboards* are later
    in this chapter).'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***旋转以面对BB条目***：将AI Pawn旋转以面对在Blackboard中记住的特定键（我们将在本章后面介绍*黑板*）。'
- en: '***Run Behavior***: Runs another *Behavior Tree* as a whole sub-tree. As a
    result, it is possible to nest *Behavior Trees* to create and compose very complex
    behaviors.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***运行行为***：作为一个整体子树运行另一个*行为树*。因此，可以嵌套*行为树*以创建和组合非常复杂的行为。'
- en: '***Run Behavior Dynamic***: Like the previous node, but it is possible to change
    which (*sub-*)*Behavior Tree* to execute at runtime.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***运行行为动态***：与前面的节点类似，但在运行时可以更改要执行的(*子*)*行为树*。'
- en: '***Run EQSQuery***: Performs an *EQS Query* (we will see what they are in [Chapter
    4](1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml)*, Environment Querying System*)
    and stores the result within the *Blackboard*.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***运行EQS查询***：执行一个*EQS查询*（我们将在[第4章](1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml)中看到它们，环境查询系统）并将结果存储在*黑板*中。'
- en: '***Set Tag Cooldown***: Sets the timer (by using a tag) for a specific *Cooldown*
    node (which is a decorator that we will look at later in this chapter).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***设置标签冷却时间***：通过使用标签为特定的*冷却时间*节点设置计时器（我们将在本章后面介绍装饰器）。'
- en: '***Wait***: Stops the behavior for a specific amount of time. Arandom deviation
    can be specified to make the amount of time to wait different each time.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***等待***：停止行为一段时间。可以指定一个随机偏差，使等待的时间每次都不同。'
- en: '***Wait Blackboard Time***: Like the previous node, but the amount of time
    is retrieved from the *Blackboard* (more on *Blackboards* later in this chapter).'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***黑板时间等待***：与上一个节点类似，但时间是从*黑板*中获取的（关于*黑板*的更多内容将在本章后面介绍）。'
- en: Now that we have looked at how a *Task* node works, let's explore *Composite*
    nodes, which make decisions based up whether a *Task* returns Failure or Success.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了*任务*节点的工作方式，让我们来探索*组合*节点，这些节点根据*任务*返回的是失败还是成功来做出决策。
- en: Composite
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**组合**'
- en: Composite nodes are at the core of the decision-making capabilities of ***Behavior
    Trees*** in Unreal, and understanding how they work is key.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 组合节点是Unreal中*行为树*决策能力核心，理解它们的工作方式是关键。
- en: 'There are three kinds of Composite nodes: *Selector*, *Sequence*, and *Simple
    Parallel*. The last one has been added recently, and you will find that by using
    a combination of *Selectors* and *Sequences*, you will be able to cover most of
    your cases. Here is how they work:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种组合节点：*选择器*、*序列*和*简单并行*。最后一种最近被添加，你会发现通过使用*选择器*和*序列*的组合，你将能够覆盖大多数情况。以下是它们的工作方式：
- en: '**Selector**: This kind of node will try to find one of its children to execute,
    which means it tries to find either a branch (so another *Composite* node attached
    as a child) or a *Task* (another child, but it is a leaf) to execute. So, the
    ***Selector*** starts from the left-most child node and tries to execute it. If
    it fails (either the *Task* failed to be executed, or the whole branch failed),
    then it tries the second left-most, and so on. If one of the children returns
    *Success*, which means that either the Task has been completed or a whole branch
    has been completed, then the ***Selector*** reports *Success* to its parent, and
    stop executing other children. On the other hand, if all the children of the ***Selector***
    report a *fail*, then the ***Selector*** reports a *fail* to its parent as well.
    In the following screenshot, you can see what the ***Selector*** node looks like:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择器**：这种节点会尝试找到其子节点中的一个来执行，这意味着它会尝试找到一个分支（因此作为子节点附加的另一个**复合**节点）或一个**任务**（另一个子节点，但它是一个叶子）。因此，**选择器**从最左边的子节点开始尝试执行它。如果它失败了（无论是**任务**未能执行，还是整个分支失败了），那么它将尝试第二个最左边的，依此类推。如果一个子节点返回**成功**，这意味着任务已经完成或整个分支已经完成，那么**选择器**将向其父节点报告**成功**，并停止执行其他子节点。另一方面，如果**选择器**的所有子节点都报告**失败**，那么**选择器**也将向其父节点报告**失败**。在下面的屏幕截图中，你可以看到**选择器**节点的外观：'
- en: '![](img/390d6972-3055-4ef2-ad83-02242c41cf80.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/390d6972-3055-4ef2-ad83-02242c41cf80.png)'
- en: '**Sequence**: This kind of node works a bit like the opposite of the *Selector*.
    To report a success to its parent, all of the Sequence''s children must report
    a success. This means that the Sequence will start executing the left-most child
    node. If it is a success, it carries on with the second left-most, and so on if
    it is successful as well. If all the children until the right-most are a success,
    then the ***Sequence*** reports a *Success* to its parent. Otherwise, if just
    one the children fail, then the ***Sequence*** will stop executing its children,
    and report a *fail* to the parent. In the following screenshot, you can see what
    the ***Sequence*** node looks like:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**序列**：这种节点的工作方式有点像**选择器**的反面。为了向其父节点报告成功，序列的所有子节点都必须报告成功。这意味着序列将开始执行最左边的子节点。如果它成功了，它将继续执行第二个最左边的，依此类推，如果也成功了。如果所有子节点直到最右边的都是成功，那么**序列**将向其父节点报告一个**成功**。否则，如果只有一个子节点失败，那么**序列**将停止执行其子节点，并向父节点报告一个**失败**。在下面的屏幕截图中，你可以看到**序列**节点的外观：'
- en: '![](img/bf17f5fe-6ef0-45b4-94a0-b7c783960ef2.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bf17f5fe-6ef0-45b4-94a0-b7c783960ef2.png)'
- en: '**Simple Parallel**: This is a particular kind of *Composite* node, which is
    used in specific cases. In fact, it can only have two children. The left-most
    child must be a *Task*, whereas the right-most child can be either a *Task* or
    a *Composite* (thus giving birth to a sub-tree). The ***Simple Parallel*** starts
    to execute both its children in parallel, although the left-most is considered
    the main one. If the main one fails, it reports a fail, but if the main one succeeds,
    then it reports a success. Based on its settings, the Simple Parallel, once it
    has finished executing the main task, can either wait until the end of execution
    of the sub-tree or directly report success or fail the main one to its parent
    and stop executing the sub-tree. In the following screenshot, you can see what
    the ***Simple Parallel*** node looks like. Please note that it is possible to
    drag only two children, in which the left-most must be a *Task* (the purple block
    is the draggable area):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单并行**：这是一种特定的**复合**节点，用于特定情况。实际上，它只能有两个子节点。最左边的子节点必须是一个**任务**，而最右边的子节点可以是**任务**或**复合**（从而产生一个子树）。**简单并行**开始并行执行其所有子节点，尽管最左边的一个被认为是主要的。如果主要的一个失败了，它将报告一个失败，但如果主要的一个成功了，那么它将报告一个成功。根据其设置，简单并行一旦完成了主要任务的执行，可以选择等待子树执行结束，或者直接向父节点报告主要任务的成功或失败，并停止执行子树。在下面的屏幕截图中，你可以看到**简单并行**节点的外观。请注意，只能拖动两个子节点，其中最左边的一个必须是一个**任务**（紫色块是可拖动区域）：'
- en: '![](img/34d7e425-1a2a-49e6-8848-0076f66a06b3.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/34d7e425-1a2a-49e6-8848-0076f66a06b3.png)'
- en: In this way, *Composite* nodes can "*decide*" which tasks to execute, based
    on what their children report (fail or success), and the *Composite* node reports
    back (either fail or success) to their parent. Even if the only-child of the root
    (which is a *Composite* node) reports back a success to the ***Root***, then the
    tree has been executed with success. A good ***Behavior Tree*** design should
    always allow for success.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，*复合* 节点可以根据其子节点报告的内容（失败或成功）来“决定”执行哪些任务，并且 *复合* 节点会向其父节点报告（要么失败要么成功）。即使根节点（也是一个
    *复合* 节点）的唯一子节点向 ***根节点*** 报告成功，那么整个树已经成功执行。一个好的 ***行为树*** 设计应该始终允许成功。
- en: Decorators
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器
- en: '***Decorator*** nodes (also known as conditionals) are attached to either a
    *Composite* or *Task* node. ***Decorator*** nodes make decisions on whether a
    branch in the *Behavior Tree*, or even a single node, can be executed. In their
    essence, they are a condition; they check whether something should be occurring.
    In other words, a ***Decorator*** can check whether it is worthwhile continuing
    on that branch and can report a preventive F*ailure* if, based on a condition,
    we know for sure that the *Task* (or the sub-tree) will fail. This will avoid
    the Decorator trying to perform a *Task* (or sub-tree) that is impossible (for
    any reason: lack of information, the goal is no longer relevant, etc...).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '***装饰器*** 节点（也称为条件）附加到 *复合* 或 *任务* 节点上。***装饰器*** 节点决定 *行为树* 中的某个分支，甚至单个节点是否可以执行。本质上，它们是一个条件；它们检查是否应该发生某事。换句话说，一个
    ***装饰器*** 可以检查是否值得继续该分支，并且如果根据条件我们确定 *任务*（或子树）将失败，它可以报告一个预防性的 *失败*。这将避免装饰器尝试执行一个不可能的任务（或子树）（由于任何原因：信息不足，目标不再相关等...）。'
- en: In general, Decorator nodes can assume the role of a ***Gate*** between the
    parent and the rest of the sub-tree. Thus, Decorators have the power to loop the
    sub-tree until a certain condition is met, or to not make execute within that
    sub-tree until a specific timer has expired, or even change the return result
    of the *Sub-Tree*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，装饰器节点可以充当父节点和其余子树之间的 ***门***。因此，装饰器有权力循环子树直到满足某个条件，或者直到特定计时器到期才在子树中执行，甚至可以改变
    *子树* 的返回结果。
- en: For a (simple) example, imagine that there is a sub-tree dedicated to killing
    the player (it will make decisions so that the Agent will try and kill the player).
    Checking if the player is in range (and not from the other side of the map), or
    even if the player is still alive, might give us a preventive fail without us
    even having to execute that sub-tree. Consequently, the tree can continue with
    other events or parts of the tree, for example, in another sub-tree, which will
    be responsible for the wander behavior.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象有一个专门用于杀死玩家的子树（它将做出决策，使代理尝试杀死玩家）。检查玩家是否在范围内（并且不是来自地图的另一侧），或者甚至玩家是否仍然存活，可能会在没有执行该子树的情况下给我们一个预防性的失败。因此，树可以继续执行其他事件或树的其余部分，例如，在另一个子树中，该子树将负责游荡行为。
- en: '*Decorators* can have parameters (which you will be able to set in the *Details
    Panel* once a *Decorator* has been selected), and usually they are either hard-coded
    values or *Blackboard Key references* (more on *Blackboards* later in this chapter).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*装饰器* 可以有参数（一旦选择了一个 *装饰器*，你将在 *详情面板* 中能够设置这些参数），通常它们是硬编码的值或 *黑板键引用*（关于 *黑板*
    的更多内容将在本章后面介绍）。'
- en: Almost every *Decorator* has a checkbox in its parameters that allows you to
    invert the conditions (as a result, you will have more freedom, and you can use
    the same decorator on two different parts of the tree to execute different conditions).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个 *装饰器* 都有一个复选框在其参数中，允许你反转条件（因此，你将拥有更多的自由，并且可以在树的两个不同部分使用相同的装饰器来执行不同的条件）。
- en: 'The following screenshot shows how a decorator can be attached to a *Composite*
    node. Note that it is possible to have more than one Decorator per node:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了如何将装饰器附加到 *复合* 节点上。请注意，每个节点可以有多个装饰器：
- en: '![](img/d46cee45-42c5-404b-a191-17d34b1695a9.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d46cee45-42c5-404b-a191-17d34b1695a9.png)'
- en: For those who are familiar with Conditional nodes in other Behavior Tree systems,
    it is important not to confuse them with Task leaf nodes in Unreal Engine. More
    information can be found at [https://docs.unrealengine.com/en-us/Engine/AI/BehaviorTrees/HowUE4BehaviorTreesDiffer](https://docs.unrealengine.com/en-us/Engine/AI/BehaviorTrees/HowUE4BehaviorTreesDiffer).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉其他行为树系统中条件节点的用户来说，重要的是不要将它们与Unreal Engine中的任务叶节点混淆。更多信息可以在[https://docs.unrealengine.com/en-us/Engine/AI/BehaviorTrees/HowUE4BehaviorTreesDiffer](https://docs.unrealengine.com/en-us/Engine/AI/BehaviorTrees/HowUE4BehaviorTreesDiffer)找到。
- en: Like Tasks, Unreal comes with some built-in Decorators that are ready to be
    used. They are general and cover the basic cases that you will probably need,
    but obviously, they cannot be specific for your game or application, and so you
    will need to create your own *Decorators* (we will look at this in detail in [Chapter
    6](e8c4d8a9-579e-4e38-b02a-a9002f1c48ce.xhtml)*, Extending Behavior Trees*).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与任务类似，Unreal自带一些内置的装饰器，它们可以立即使用。它们是通用的，涵盖了你可能需要的最基本的情况，但显然，它们不能针对你的游戏或应用程序进行特定化，因此你需要创建自己的*装饰器*（我们将在第6章[扩展行为树](e8c4d8a9-579e-4e38-b02a-a9002f1c48ce.xhtml)中详细讨论）。
- en: 'Here is the list of the built-in tasks in Unreal:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Unreal内置任务列表：
- en: '![](img/c0ed724e-39d8-4f0a-a9e9-a4ef8b4a0f71.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c0ed724e-39d8-4f0a-a9e9-a4ef8b4a0f71.png)'
- en: '***Blackboard***: Checks if a specific key on the *Blackboard* *Is Set* (or
    *Is Not Set*).'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***黑板***：检查*黑板*上的特定键是否*设置*（或*未设置*）。'
- en: '***Check Gameplay Tags on Actor***: As the name suggests, it checks if there
    is a specific Gameplay Tag(s) on an Actor that''s been specified by a Blackboard
    value.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***检查演员游戏标签***：正如其名所示，它检查是否有由黑板值指定的特定游戏标签（或多个标签）在指定的演员上。'
- en: '***Compare BBEntries***: Compares two Blackboard values and checks if they
    are equal (or not equal) to each other.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***比较BB条目***：比较两个黑板值，并检查它们是否相等（或不相等）。'
- en: '***Composite***: This allows you to compose different *Decorators* at once
    with boolean logic. Once you have placed this *Decorator*, you can open its editor
    by double-clicking on it. From there, you will be able to build a graph with boolean
    operators and other *Decorators*.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***组合***：这允许你使用布尔逻辑一次性组合不同的*装饰器*。一旦放置了此*装饰器*，你可以通过双击它来打开其编辑器。从那里，你将能够使用布尔运算符和其他*装饰器*构建一个图。'
- en: '***Conditional Loop***: As long as the condition is satisfied (whether a *Blackboard
    Key* *Is Set* or *Is Not Set*), it will keep looping through the sub-tree.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***条件循环***：只要条件得到满足（无论*黑板键*是否*设置*或*未设置*），它将不断循环通过子树。'
- en: '***Cone Check***: This checks if one point (usually another Actor) is within
    a cone, starting from another point (usually the AI agent); the cone angle and
    direction can be changed. An example of its use is if you want to check whether
    the Player is in front of the enemy or not—you could use this code to determine
    this condition.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***锥形检查***：这检查一个点（通常另一个演员）是否在从另一个点（通常为AI代理）开始的锥形内；锥形角度和方向可以更改。其使用的一个例子是，如果你想检查玩家是否在敌人前方——你可以使用此代码来确定此条件。'
- en: '***Cooldown***: Once the execution exits from the branch containing this *Decorator*,
    a *Cooldown timer* will start, and this *Decorator* doesn''t allow the execution
    to enter again until this timer has expired (it reports *Failure* immediately).
    This node is used so that you don''t repeat the same sub-tree too frequently.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***冷却时间***：一旦执行从包含此*装饰器*的分支退出，将启动*冷却计时器*，并且此*装饰器*不允许执行在此计时器过期之前再次进入（它立即报告*失败*）。此节点用于确保你不频繁地重复相同的子树。'
- en: '***Does Path Exist***: This uses the Navigation System (more on this in [Chapter
    3](fe5b7602-fcb4-4d39-bf8c-e1742909205a.xhtml), *Navigation*) to determine (and
    check) whether or not a Path exists for a specific point.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***路径是否存在***：这使用导航系统（关于这一点，请参阅第3章[导航](fe5b7602-fcb4-4d39-bf8c-e1742909205a.xhtml)）来确定（并检查）是否存在特定点的路径。'
- en: '***Force Success***: As the name suggests, it forces the Success of the sub-tree,
    regardless of whether a *Failure* (or a *Success*) has been reported from below.
    This is useful for creating optional branches in a Sequence.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***强制成功***：正如其名所示，它强制子树成功，无论是否从下面报告了*失败*（或*成功*）。这对于在序列中创建可选分支非常有用。'
- en: Note that Force Failure doesn't exist, since it wouldn't make sense. If this
    were to be placed on a Selection, this would make it a Sequence, and if it were
    placed on a Sequence, it would only make one child execute.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，强制失败不存在，因为这没有意义。如果将其放置在选择上，这将使其成为一个序列，如果将其放置在序列上，它将只执行一个子节点。
- en: '***Is at Location***: As the name suggests, it checks if the Pawn is (near
    or) at a specific Location (optionally, using the *Navigation System*).'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***位于位置***：正如其名所示，它检查Pawn是否（靠近或）位于特定位置（可选地，使用*导航系统*）。'
- en: '***Is BBEntry of Class***:As the name suggests, it checks if a specific Blackboard
    Entry is of a specific Class. This is useful when the Blackboard Entry is of type
    Object, and you need to check if the reference within the Blackboard is of a specific
    class (or inherits from one).'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***是类的BB条目***：正如其名所示，它检查特定的黑板条目是否属于特定的类。当黑板条目是Object类型，并且需要检查黑板内的引用是否属于特定类（或继承自一个类）时，这很有用。'
- en: '***Keep in Cone***: Similar to *Cone Check*, this *Decorator* (continuously)
    checks if the *Observer* is within a *Cone*.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***保持圆锥内***：与*圆锥检查*类似，这个*装饰器*（持续地）检查*观察者*是否在*圆锥*内。'
- en: '***Loop***: As the name suggests, it loops within the sub-tree for a specific
    number of times (or even an infinite number of times; in this case, something
    else is needed to stop the behavior of the sub-tree, e.g. another *Decorator*).'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***循环***：正如其名所示，它会在特定子树中循环特定次数（甚至无限次数；在这种情况下，需要其他东西来停止子树的行为，例如另一个*装饰器*）。'
- en: '***Set Tag Cooldown***: Similar to its homonym *Task*, when this *Decorator*
    becomes relevant (or if you imagine it as a gate, when it is traversed), it will
    change the *Cooldown* timer for a specific *Tag* (see the following node).'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***设置标签冷却时间***：与同名的*任务*类似，当这个*装饰器*变得相关（或者如果你将其想象为一个门，当它被穿越时），它将改变特定*标签*的*冷却时间计时器*（参见以下节点）。'
- en: '***Tag Cooldown***: This is the same as the *Cooldown* node, but it has a timer
    associated with a *Tag*. As a result, this timer can be changed by the "*Set Tag
    Cooldown*" *Task* and by the "*Set Tag Cooldown*" *Decorator*.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***标签冷却时间***：这与*冷却时间*节点相同，但它与一个*标签*相关联的计时器。因此，这个计时器可以通过"*设置标签冷却时间*" *任务*和"*设置标签冷却时间*"
    *装饰器*来改变。'
- en: '***Time Limit***: As the name suggests, it provides a time limit for the sub-tree
    to finish its execution. Otherwise, this Decorator will stop execution and return
    a *Failure*.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***时间限制***：正如其名所示，它为子树完成其执行提供时间限制。否则，这个装饰器将停止执行并返回*失败*。'
- en: Now that we have seen how *Decorator* nodes work, let's explore the last type
    of nodes of the Behavior Tree, *Service* nodes, which will continuously update
    and provide information in real time.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了*装饰器*节点的工作方式，让我们探索行为树中的最后一种节点类型，*服务*节点，这些节点将连续更新并提供实时信息。
- en: Service
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: '***Service*** nodes attach to *Composite* or *Task* nodes and will execute
    if their branch is being executed. This means that as long as a node below the
    node is attached, it doesn''t matter how many levels of parent-children are being
    executed—the Service will run as well. The following screenshot will help you
    visualize this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '***服务***节点连接到*组合*或*任务*节点，并且如果它们的分支正在执行，它们将执行。这意味着只要节点下方有节点连接，无论父-子级别有多少层正在执行——服务也会运行。以下截图将帮助您可视化这一点：'
- en: '![](img/0508789a-67b2-425b-b713-99a88cd2190a.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0508789a-67b2-425b-b713-99a88cd2190a.png)'
- en: This means that Service nodes are the eyes on the Behavior Tree's execution.
    In fact, they run continuously (if the sub-tree is active) and can perform checks
    and/or update *Blackboard* (see later) values in real-time.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着服务节点是行为树执行的眼睛。实际上，它们会持续运行（如果子树是活跃的），并且可以实时执行检查和/或更新*黑板*（稍后介绍）的值。
- en: '***Service*** nodes are really specific for your *Behavior Tree* application,
    so there are only two default ones. An example of their usage might be providing/updating
    information to the sub-tree. For instance, imagine a situation where a sub-tree
    (the enemy) is trying to kill the player. However, it would be dumb (well, it
    depends of the enemy type, trolls might not be so smart) to pursue this objective,
    even when the player isn''t shooting back at the enemy. Thus, while the sub-tree
    is trying to kill the player, the sub-tree needs to find cover to reduce the damage
    the enemy takes. However, the enemy might be moving in the map, or the player
    might destroy the cover where our AI is hiding. Thus, the sub-tree needs information
    regarding the location of the nearest and safest cover, which is still in range
    of the player (an *EQS Query* can calculate that). A service can update this information
    in real-time so that when the sub-tree needs to use the data regarding the cover,
    they are ready. In this particular example, to find cover, running an *Environment
    Query* on the Service is a dynamic way to handle the task (we will look at this
    topic in [Chapter 4](1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml), *Environmental
    Querying System*). Otherwise, the *Service* might check certain specified points
    in the map that have been placed by a designer and evaluate which one is the best
    for its given action.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '***服务节点*** 确实是为你的 *行为树* 应用程序量身定制的，因此只有两个默认节点。它们的一个用法示例可能是向子树提供/更新信息。例如，想象一个场景，子树（敌人）试图杀死玩家。然而，即使玩家没有向敌人射击，追求这个目标也是愚蠢的（好吧，这取决于敌人的类型，巨魔可能并不那么聪明）。因此，当子树试图杀死玩家时，子树需要找到掩护来减少敌人受到的伤害。然而，敌人可能在地图上移动，或者玩家可能摧毁了我们AI藏身的掩护。因此，子树需要有关最近且最安全的掩护位置的信息，这个位置仍在玩家的射程内（一个
    *EQS 查询* 可以计算出这个信息）。服务可以实时更新这些信息，以便当子树需要使用有关掩护的数据时，它们已经准备好了。在这个特定的例子中，为了找到掩护，在服务上运行
    *环境查询* 是处理这个任务的动态方式（我们将在 [第4章](1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml)，*环境查询系统*）中探讨这个话题）。否则，*服务*
    可能会检查地图上设计师放置的某些指定点，并评估哪个最适合其给定的动作。'
- en: As you can see, ***Service*** nodes can be really powerful, but they are also
    specific to the application you are using them for. Thus, they really depend on
    the AIs you are programming for your game.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，***服务节点*** 可以非常强大，但它们也特定于你使用它们的应用程序。因此，它们确实取决于你为你的游戏编写的AI。
- en: 'The following screenshot shows a couple of examples of Services. Please notice
    that *Services* can be used along with *Decorators*, and that a *Composite* node
    can have more than one ***Service***:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了几个服务示例。请注意，*服务* 可以与 *装饰器* 一起使用，并且一个 *组合节点* 可以有多个 ***服务***：
- en: '![](img/12559947-1cc8-4ce0-be57-f6504a1174b1.png)*Service nodes* replace traditional
    *Parallel nodes* in other *Behavior Tree systems*.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![截图](img/12559947-1cc8-4ce0-be57-f6504a1174b1.png)*服务节点* 替换了其他 *行为树系统* 中的传统
    *并行节点*。'
- en: 'The only two available default *Services* (since you will need to program your
    own for your game, which we will do in [Chapter 6](e8c4d8a9-579e-4e38-b02a-a9002f1c48ce.xhtml)*,
    Extending Behavior Trees*) are shown in the following screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的两个默认 *服务*（因为你将需要为你的游戏编写自己的服务，我们将在 [第6章](e8c4d8a9-579e-4e38-b02a-a9002f1c48ce.xhtml)*，扩展行为树*）在下面的屏幕截图中显示：
- en: '![](img/edab27c3-7245-4fb9-84a8-2dde04d5ab59.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/edab27c3-7245-4fb9-84a8-2dde04d5ab59.png)'
- en: '***Set Default Focus***: When this node becomes active, it automatically sets
    the *Default Focus* for the *AI controller*.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***设置默认焦点***：当这个节点变为活动状态时，它会自动为 *AI控制器* 设置 *默认焦点*。'
- en: '***Run EQS*** *(Query on a regular basis)*: As the name suggests, it runs an
    *Environmental Query* (check out [Chapter 4](1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml),
    *Environment Querying System*, for more information) on a regular basis to check
    for specific locations or actors. This was the kind of service that we needed
    in our example of finding cover for the enemy.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***运行EQS*** *(定期查询)*：正如其名所示，它定期运行 *环境查询*（有关更多信息，请参阅 [第4章](1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml)，*环境查询系统*），以检查特定的位置或演员。这是我们例子中寻找掩护所需的这种服务。'
- en: 'You will learn more about *Environmental Queries* in [Chapter 4](1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml),
    *Environment Querying System*. However, for now, all you need to know is that
    this is a system for spatial reasoning, and running these queries can find locations
    (or actors) within the space with specific properties (in the example of finding
    cover for the enemy, the one that maximizes these properties: the nearest, the
    safest, and still in rage to shoot to the player).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[第4章](1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml)“环境查询系统”中了解更多关于*环境查询*的内容。然而，目前你需要知道的是，这是一个用于空间推理的系统，运行这些查询可以在空间中找到具有特定属性的位置（或演员）（在寻找掩护敌人的例子中，最大化这些属性的那个：最近的、最安全的，并且仍然在射程内可以射击玩家）。
- en: Now, we have learned about the different kind of nodes that compose a *Behavior
    Tree*. Now, it is time to explore Blackboards!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解了组成**行为树**的不同类型的节点。现在，是时候探索黑板了！
- en: Blackboards and their integration with Behavior Trees
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 黑板及其与行为树集成
- en: Considering the *Behavior Tree* as a brain, we can think of a ***Blackboard***
    as its memory—more specifically, the memory of the AI. The ***Blackboard*** stores
    (and sets) key values for the *Behavior Tree* to use.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将**行为树**视为大脑，我们可以将**黑板**视为其记忆——更具体地说，是AI的记忆。**黑板**存储（并设置）用于**行为树**使用的键值。
- en: They are called blackboards because, in a classroom, the blackboard is a place
    where a lot of information is conveyed, but most of it is shared among students;
    the single notes that are given out to students are personal. You can imagine
    the students as the different tasks (and nodes) of the *Behavior Tree*, and the
    ***Blackboard*** as a shared place for data.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 它们被称为黑板，因为在教室里，黑板是一个传递大量信息的地方，但其中大部分信息是学生之间共享的；分发给学生的单独笔记是私人的。你可以将学生想象为不同的任务（和节点），而**黑板**则是一个共享的数据空间。
- en: '***Blackboards*** are fairly simple to understand, since they are only a little
    more complex than a data structure. The only difference lies in the possibility
    to assign to a *Behavior Tree* to a particular ***Blackboard***, which is shared
    by every node of the tree. As a result, each node can read and/or write back to
    the *Blackboard*.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**黑板**相对简单易懂，因为它们只比数据结构复杂一点。唯一的区别在于可以将一个**黑板**分配给特定的**行为树**，这个黑板被树中的每个节点共享。因此，每个节点都可以读取和/或写回**黑板**。'
- en: For those of you who are familiar with the ***Design Pattern of Blackboards***,
    within the context of Unreal, they just cover the role of holding the memory for
    a *Behavior Tree*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些熟悉**黑板设计模式**的人来说，在虚幻引擎中，它们只是承担了为**行为树**保存记忆的角色。
- en: It works like a *dictionary* (the data structure), in which a key corresponds
    to a specific value type (e.g. a vector, a float, an actor, etc…, even another
    *Blackboard Key*). So, by using or recalling the key, it is possible to write
    or read the associated value.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式就像一个*字典*（数据结构），其中键对应一个特定的值类型（例如，一个向量、一个浮点数、一个演员等……，甚至是另一个**黑板键**）。因此，通过使用或回忆键，可以写入或读取相关的值。
- en: Another cool feature of ***Blackboards*** is that they can be extended through
    inheritance. This means that another ***Blackboard*** can be a parent, and the
    child will inherit all the parent's pairs key-value, plus some specific ones that
    are contained in the child itself.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**黑板**的另一个酷炫特性是它们可以通过继承来扩展。这意味着另一个**黑板**可以作为一个父类，子类将继承所有父类的键值对，再加上子类本身包含的一些特定键值对。'
- en: Now that we have covered the theory, let's look at how we can create a *Behavior
    Tree* and make it run. To do that, let's start by creating a new project.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了理论部分，让我们看看如何创建一个**行为树**并让它运行。要做到这一点，让我们先创建一个新的项目。
- en: Creating our AI project
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的AI项目
- en: From now on, we will get our feet wet by creating a project, and get a gist
    of what we have learned about ***Behavior Trees***. In this section, we are going
    to create a simple tree, but as we learn more about other topics in the following
    chapters, we will iterate over the tools for ***Behavior Trees***. As a result,
    this will provide you with a better understanding of the tools that are required
    to create awesome ***Behavior Trees***. Then, in [Chapter 8](6995bf12-0f10-47a9-a48c-cec31696df87.xhtml),
    *Designing Behavior Trees - Part I*, [Chapter 9](063dda79-cb3c-49e7-bfa5-11f8680ee358.xhtml),
     *Designing Behavior Trees - Part II*, and [Chapter 10](039565e6-4f8d-4c73-936f-f5974e9c8226.xhtml),
    *Designing Behavior Trees - Part III*, we will be focusing on how to *create and
    design* a ***Behavior Tree*** from scratch that chases the player, which will
    give you a practical approach to ***Behavior Trees***.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，我们将通过创建项目来实践，并了解我们关于***行为树***所学的知识。在本节中，我们将创建一个简单的树，但随着我们在下一章学习更多其他主题，我们将迭代***行为树***的工具。这将为你提供更好的理解，了解创建出色的***行为树***所需的工具。然后，在[第8章](6995bf12-0f10-47a9-a48c-cec31696df87.xhtml)，*设计行为树
    - 第一部分*，[第9章](063dda79-cb3c-49e7-bfa5-11f8680ee358.xhtml)，*设计行为树 - 第二部分*，和[第10章](039565e6-4f8d-4c73-936f-f5974e9c8226.xhtml)，*设计行为树
    - 第三部分*中，我们将专注于如何从头开始*创建和设计*一个追逐玩家的***行为树***，这将为你提供关于***行为树***的实用方法。
- en: So, to be able test the techniques that we are going to explore in this book,
    we need to create a project. By doing this, you will be able to follow the practical
    aspects that will be covered throughout this book.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够测试本书将要探索的技术，我们需要创建一个项目。通过这样做，你将能够跟随本书中将要涵盖的实践方面。
- en: You can create a new project from a template. The Third Person template works
    particularly well. In fact, it already has a character set up inside it, which
    can be easily possessed by an AI. This means that you don't have to worry too
    much about non-AI related details, such as animations. You can choose either the
    Blueprint version or the C++ one. I'll explain the concepts that we'll cover in
    both Blueprint and C++ terms throughout, but do note that some techniques in this
    book will work better if they're programmed in C++. As a result, I'm choosing
    the C++ version of the Third Person template, although this initial choice doesn't
    affect us much (we are programming AIs, not a Player or Gameplay).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从模板创建一个新项目。第三人称模板特别适用。实际上，它已经内置了一个角色，可以很容易地被AI控制。这意味着你不必过多担心与AI无关的细节，例如动画。你可以选择蓝图版本或C++版本。我将在整个过程中用蓝图和C++术语解释我们将要覆盖的概念，但请注意，本书中的一些技术如果用C++编写将运行得更好。因此，我选择了第三人称模板的C++版本，尽管这个初始选择对我们影响不大（我们是在编写AI，而不是玩家或游戏玩法）。
- en: 'Finally, I''m naming my project `UnrealAIBook`, as shown in the following screenshot.
    Once again, you will be able to find the project files at the following link: [http://hog.red/AIBook2019ProjectFiles](http://hog.red/AIBook2019ProjectFiles)
    (the link is case-sensitive):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我将我的项目命名为`UnrealAIBook`，如下面的截图所示。你可以在以下链接找到项目文件：[http://hog.red/AIBook2019ProjectFiles](http://hog.red/AIBook2019ProjectFiles)（该链接区分大小写）：
- en: '![](img/690fb145-83c8-4a15-9941-04460e4d954e.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/690fb145-83c8-4a15-9941-04460e4d954e.png)'
- en: Starting Behavior Trees from AI Controllers
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从AI控制器开始行为树
- en: Now that we have covered the basics of what Behavior Trees are and what they
    consist of, let's create our own. Recall from the previous chapter, the class
    in charge of possessing a Pawn and controlling it is the AI Controller. Thus,
    our ***Behavior Trees*** should run on *AI Controllers*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了行为树的基本概念及其构成，让我们来创建自己的行为树。回顾前一章，负责拥有并控制棋子的类是AI控制器。因此，我们的***行为树***应该在*AI控制器*上运行。
- en: We have two ways we can do this. The first one is by using Blueprints. Usually,
    even if you are a programmer, it is best to create a ***Behavior Tree*** using
    Blueprints, since the logic is really easy and the controller is simple. On the
    other hand, if you are a C++ fan and you want to use it as much as possible, even
    for small tasks, don't worry—I'll recreates the same logic we will do in Blueprint
    again, but this time in C++. In any case, ***Behavior Tree*** assets should be
    created and modified within the editor. What you will eventually program are different
    nodes than the ones that are available by default (we will see this later in this
    book), but the tree itself is always made in the editor.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方法可以做到这一点。第一种是使用蓝图。通常，即使你是程序员，最好也使用蓝图来创建一个**行为树**，因为逻辑非常简单，控制器也很简单。另一方面，如果你是C++爱好者，并且想尽可能多地使用它，即使是对于小任务，不用担心——我会再次重构我们在蓝图中所做的相同逻辑，但这次是在C++中。无论如何，**行为树**资产应该在编辑器中创建和修改。你最终要编写的程序节点将不同于默认可用的节点（我们将在本书的后面看到这一点），但树本身始终是在编辑器中制作的。
- en: Creating the Behavior Tree and the Blackboard
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建行为树和黑板
- en: 'To begin, we will need to create four Blueprint Classes: ***AI Controller***,
    ***Character***, ***Behavior Tree***, and ***Blackboard***. We will cover the
    AI controller later. If you chose one of the two Third Person templates, you should
    already have a *Character* ready to go. Thus, you just need to create a ***Behavior
    Tree*** and a ***Blackboard***.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要创建四个蓝图类：**AI控制器**、**角色**、**行为树**和**黑板**。我们将在后面介绍AI控制器。如果你选择了两个第三人称模板之一，你应该已经有一个**角色**准备好了。因此，你只需要创建一个**行为树**和一个**黑板**。
- en: In the *Content Browser*, create a new folder and name it `Chapter2`. This will
    help keep things organized. Then, create a sub-folder and name it `AI`. As a result,
    we can keep our project tidy and ensure that we don't mix up items from this chapter
    with other *non-AI-related* classes and/or objects we might create. We will put
    all the assets we are going to create for the AI in this folder.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在**内容浏览器**中创建一个新的文件夹，并将其命名为`Chapter2`。这将有助于保持事物有序。然后，创建一个子文件夹并将其命名为`AI`。结果，我们可以保持我们的项目整洁，并确保我们不会将本章的内容与其他**非人工智能相关**的类和/或对象混淆。我们将把为AI创建的所有资产放在这个文件夹中。
- en: Creating the Blackboard
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建黑板
- en: Now, we need to add a ***Blackboard***, which should always be within the `AI`
    folder. To do this, go to the **Content Browser** and select **Add New** > **Artificial
    Intelligence** > **Blackboard**.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加一个**黑板**，它应该始终位于`AI`文件夹中。为此，请转到**内容浏览器**并选择**添加新项** > **人工智能** > **黑板**。
- en: For now, we will call our Blackboard `BB_MyFirstBlackboard`. Here, I'm using
    the naming convention to prefix all Blackboards with `BB_`. Unless you have a
    specific reason to not follow this naming convention, please use it. By doing
    this, you will be in sync with the rest of this book.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将我们的黑板命名为`BB_MyFirstBlackboard`。在这里，我使用命名约定，将所有黑板的前缀命名为`BB_`。除非你有特定的理由不遵循这个命名约定，请使用它。通过这样做，你将与本书的其余部分保持同步。
- en: 'Since it is not possible to have multiple Blackboards on the same *Behavior
    Tree*, you can use inheritance with Parent and Child within the **Blackboard Details**
    panel, as shown in the following screenshot on the right):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在同一**行为树**上无法拥有多个黑板，您可以在**黑板详情**面板中使用继承，父级和子级，如下所示（右边的截图）：
- en: '![](img/e49c8321-5531-4b68-ad1d-74fda84e703f.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/e49c8321-5531-4b68-ad1d-74fda84e703f.png)'
- en: Creating the Behavior Tree
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建行为树
- en: 'Let''s add a *Behavior Tree* by going to the **Content Browser** and selecting **Add
    New** > **Artificial Intelligence** > **Behavior Tree**, as shown in the following
    screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过转到**内容浏览器**并选择**添加新项** > **人工智能** > **行为树**来添加一个**行为树**，如下面的截图所示：
- en: '![](img/54632525-d656-4f2e-8b63-746deeeba315.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/54632525-d656-4f2e-8b63-746deeeba315.png)'
- en: For now, we will call our Behavior Tree `BT_MyFirstBehaviorTree`. Again, here,
    I'm using a specific naming convention to prefix all Behavior Tree assets with
    `BT_`. Once again, please follow the naming convention, unless you have a specific
    reason not to.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将我们的行为树命名为`BT_MyFirstBehaviorTree`。再次强调，这里我使用特定的命名约定，将所有行为树资产的前缀命名为`BT_`。请再次遵循命名约定，除非你有特定的理由不这样做。
- en: 'When you open the *Behavior Tree* window, you will see a single node called
    **Root**, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开**行为树**窗口时，你会看到一个名为**根**的单个节点，如下所示：
- en: '![](img/e44e6054-d9fb-4b2f-905c-6e4fbaedaea1.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/e44e6054-d9fb-4b2f-905c-6e4fbaedaea1.png)'
- en: The **Root** is where the execution of your *Behavior Tree* begins (from top
    to bottom and left to right). The Root itself only has one reference and that
    is the Blackboard, so it cannot be connected to anything else. It is the tip of
    the tree, and all subsequent nodes are below it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**根节点**是您的*行为树*执行开始的地方（从上到下，从左到右）。根节点本身只有一个引用，那就是黑板，因此它不能连接到其他任何东西。它是树的顶端，所有后续的节点都在其下方。'
- en: 'If you drag from the ***Root*** Node, you will be able to add ***Composite***
    nodes:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从***根节点***拖动，您将能够添加***组合***节点：
- en: '![](img/ce9e5a41-1bee-40c0-bd09-89af8162c83f.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ce9e5a41-1bee-40c0-bd09-89af8162c83f.png)'
- en: 'For this, the *Behavior Tree Editor* is very intuitive. You can keep dragging
    out from the nodes to add ***Composite*** or ***Tasks*** nodes. To add a ***Decorator***
    or a ***Service***, you can right-click on a node and select "***Add Decorator...***"
    or "***Add Service...***", respectively, as shown in the following screenshot:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此，*行为树编辑器*非常直观。您可以从节点拖动以添加***组合***或***任务***节点。要添加***装饰器***或***服务***，您可以在节点上右键单击并选择“***添加装饰器...***”或“***添加服务...***”，如图所示：
- en: '![](img/ca3285ef-4156-434c-aa1c-8757ec4a9ab2.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ca3285ef-4156-434c-aa1c-8757ec4a9ab2.png)'
- en: 'Finally, if you click on a node, it is possible to choose its parameters in
    the *Details Panel* (the following screenshot shows an example of a *Move To Node*):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您单击一个节点，可以在*详细信息面板*中选择其参数（以下截图显示了一个*移动到节点*的示例）：
- en: '![](img/e3975fc3-c7f6-4b68-a779-8e91f7ad82a8.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e3975fc3-c7f6-4b68-a779-8e91f7ad82a8.png)'
- en: The AI Controller to run a Behavior Tree
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行行为树的AI控制器
- en: The next step is to run the *Behavior Tree* from an *AI Controller*. Usually,
    this is an easy task that it is implemented in Blueprint (in which it is possible
    to directly refer to a specific Behavior Tree). Even if we have a complex *C++
    AI Controller*, we can extend the controller in Blueprint and *Run* the *Behavior
    Tree* from Blueprint. In any case, if a hard reference doesn't work (e.g. you
    are using C++ or because you want to have more flexibility), then you can store
    the *Behavior Tree* in the *Character/Pawn* that needs to run that specific *Behavior
    Tree*, and retrieve it when the *AI Controller* possesses the *Pawn*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是从*AI控制器*运行*行为树*。通常，这是一个简单的任务，在蓝图（其中可以直接引用特定的行为树）中实现。即使我们有复杂的*C++ AI控制器*，我们也可以在蓝图扩展控制器并从蓝图*运行*行为树。在任何情况下，如果硬引用不起作用（例如，您正在使用C++或因为您想要有更多的灵活性），那么您可以将*行为树*存储在需要运行该特定*行为树*的*角色/单位*中，并在*AI控制器*拥有*单位*时检索它。
- en: Let's explore how we can do this both in Blueprint (we will reference the *Behavior
    Tree* in a variable, in which we can decide on the default value) and in C++ (in
    which we will store the *Behavior Tree* in the *Character*).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何在蓝图（我们将在一个变量中引用*行为树*，我们可以决定其默认值）和C++（我们将把*行为树*存储在*角色*中）中实现这一点。
- en: AI Controller in Blueprint
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝图中的AI控制器
- en: 'We can create a Blueprint AI Controller by clicking on **Add New** | **Blueprint
    Class** | **AI** **Controller.** You will have to click **All Classes** and search
    for **AI Controller** to access it. You can see an example of this in the following
    screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过单击**添加新** | **蓝图类** | **AI** **控制器**来创建蓝图AI控制器。您必须单击**所有类**并搜索**AI控制器**来访问它。您可以在以下截图中看到一个示例：
- en: '![](img/e050bec6-3b7f-425c-a8b8-388c924585cf.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e050bec6-3b7f-425c-a8b8-388c924585cf.png)'
- en: For now, we will call our **AI Controller** `BP_MyFirstAIController`. Double-click
    on it to open the *Blueprint Editor*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将我们的**AI控制器**命名为`BP_MyFirstAIController`。双击它以打开*蓝图编辑器*。
- en: 'First, we need to create a variable so that we can store our ***Behavior Tree***.
    Although it''s not necessary to keep reference of the *Behavior Tree*, it''s good
    practice to do so. To create a variable, we need to press the ***+ Variable ***button
    in the *My Blueprint *panel, next to the ***Variables*** tab, as shown in the
    following screenshot (keep in mind that your cursor needs to be on the Variables
    tab for the button to show up):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个变量，以便我们可以存储我们的***行为树***。尽管保留对*行为树*的引用不是必需的，但这是一个好的实践。要创建变量，我们需要在*我的蓝图*面板中按下***+
    变量 ***按钮，位于***变量***标签旁边，如图所示（请注意，您的光标需要位于变量标签上，按钮才会显示）：
- en: '![](img/a7851d84-9f87-4b1a-b664-a061dd73f5c0.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a7851d84-9f87-4b1a-b664-a061dd73f5c0.png)'
- en: 'Then, as a variable type, you need to select *Behavior Tree* and give it a
    name, such as ***BehaviorTreeReference***. This is how what your variable should
    look like:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，作为一个变量类型，你需要选择**行为树**并给它一个名称，例如**BehaviorTreeReference**。这就是你的变量应该看起来像的样子：
- en: '![](img/e519b4d5-55f8-4b5e-8412-630d53473810.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e519b4d5-55f8-4b5e-8412-630d53473810.png)'
- en: 'Then, in the *Detail Panel*, we will set the Default value (remember that to
    set the default value, the Blueprint needs to be compiled):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在**详细面板**中，我们将设置默认值（记住，为了设置默认值，蓝图需要编译）：
- en: '![](img/c558b0b0-f5f3-401f-b3ea-7d4b152305af.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c558b0b0-f5f3-401f-b3ea-7d4b152305af.png)'
- en: 'Then, we need to override the ***On Possess*** function, as shown in the following
    screenshot:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要重写**On Possess**函数，如下面的截图所示：
- en: '![](img/cfaf02f5-051a-424b-95ae-030256348ed0.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cfaf02f5-051a-424b-95ae-030256348ed0.png)'
- en: 'Finally, in the ***Event On Possess*** of the *AI Controller*, we need to start
    running/executing the *Behavior Tree*. We can achieve this by using the following
    simple node, named ***Run Behavior Tree***:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在**AI控制器的事件拥有**中，我们需要开始运行/执行**行为树**。我们可以通过使用以下简单的节点，命名为**运行行为树**来实现这一点：
- en: '![](img/a481b8ea-9642-47eb-957e-ec36be49a6c4.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a481b8ea-9642-47eb-957e-ec36be49a6c4.png)'
- en: As a result, your AI controller will be able to execute the *Behavior Tre**e* that's
    stored within the ***BehaviorTreeReference***.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，你的AI控制器将能够执行存储在**BehaviorTreeReference**中的**行为树**。
- en: AI Controller in C++
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的AI控制器
- en: 'If you have decided to create this simple AI controller in C++, let''s get
    started. I''m assuming that your Unreal Editor is already set up to work in C++
    (e.g. you have Visual Studio installed, symbols for debugs, etc.... Here is a
    reference link so that you can get started: [https://docs.unrealengine.com/en-us/Programming/QuickStart](https://docs.unrealengine.com/en-us/Programming/QuickStart))
    and that you have basic knowledge of how C++ works in Unreal. Here is a link for
    the naming convention so that you understand why some classes are prefixed with
    letters in the code: [https://docs.unrealengine.com/en-us/Programming/Development/CodingStandard](https://docs.unrealengine.com/en-us/Programming/Development/CodingStandard).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经决定在C++中创建这个简单的AI控制器，让我们开始吧。我假设你的Unreal编辑器已经设置为C++工作（例如，你已经安装了Visual Studio，调试符号等），并且你对C++在Unreal中的基本工作原理有基本的了解。以下是一个参考链接，以便你可以开始：[https://docs.unrealengine.com/en-us/Programming/QuickStart](https://docs.unrealengine.com/en-us/Programming/QuickStart)以及一个命名规范的链接，以便你理解为什么一些类在代码中带有字母前缀：[https://docs.unrealengine.com/en-us/Programming/Development/CodingStandard](https://docs.unrealengine.com/en-us/Programming/Development/CodingStandard)。
- en: 'Before you start, remember that in order to work on AI in C++, you need to
    add the public dependencies in your your `.cs` file (in this case, ***UnrealAIBook.cs***),
    and add **GameplayTasks** and **AIModule** as public dependencies, like in the
    following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始之前，请记住，为了在C++中工作AI，你需要在你的`.cs`文件中添加公共依赖项（在这个例子中，是**UnrealAIBook.cs**），并将**GameplayTasks**和**AIModule**作为公共依赖项添加，如下面的代码所示：
- en: '`PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject",
    "Engine", "InputCore", "HeadMountedDisplay", **"GameplayTasks", "AIModule"** });`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject",
    "Engine", "InputCore", "HeadMountedDisplay", **"GameplayTasks", "AIModule"** });`'
- en: This will ensure that your code will compile without problems.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保你的代码可以无问题编译。
- en: 'Let''s create a new C++ class, as shown in the following screenshot:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的C++类，如下面的截图所示：
- en: '![](img/3139ede6-da33-4d59-ac3b-4b2863792098.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3139ede6-da33-4d59-ac3b-4b2863792098.png)'
- en: 'The class needs to inherits from the ***AIController*** class. You might need
    to check the *Show All Classes* checkbox in the right-top corner and then use
    the search bar, as shown in the following screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类需要从**AIController**类继承。你可能需要检查右上角的**显示所有类**复选框，然后使用搜索栏，如下面的截图所示：
- en: '![](img/6f085bf2-d334-40bb-a6e1-2e5a1a00db98.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6f085bf2-d334-40bb-a6e1-2e5a1a00db98.png)'
- en: 'Click on *Next* and name the class ***MyFirstAIController***. Moreover, I''d
    suggest that you keep our project tidy. Thus, click on the ***Choose Folder*** button.
    Unreal will prompt you to go to your system folder explorer. Here, create a folder
    named `Chapter2`, and within it a sub-folder named `AI`. Choose this folder as
    the place where you are going to store the piece of code we are going to create.
    This is what the dialogue box should look like, just before you click on *Create*:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 点击*下一步*并命名类为***MyFirstAIController***。此外，我建议你保持我们的项目整洁。因此，点击***选择文件夹***按钮。Unreal会提示你打开系统文件夹资源管理器。在这里，创建一个名为`Chapter2`的文件夹，并在其中创建一个名为`AI`的子文件夹。选择这个文件夹作为你将要存储我们即将创建的代码的地方。在你点击*创建*之前，对话框应该看起来像这样：
- en: '![](img/3b74268a-2b98-4910-817b-68634caf997d.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b74268a-2b98-4910-817b-68634caf997d.png)'
- en: 'Now, click on *Create* and wait for your editor to load. You might see something
    like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击*创建*并等待你的编辑器加载。你可能看到如下内容：
- en: '![](img/b2f65620-b4cb-4792-b5af-171ce4c74753.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2f65620-b4cb-4792-b5af-171ce4c74753.png)'
- en: 'The structure of our code will be slightly different compared to the Blueprint
    version. In fact, we cannot assign a ***Behavior Tree*** directly from the AI
    Controller class (mainly because it would be hard to reference it directly); instead,
    we need to take it from the Character. As I mentioned previously, this is a good
    approach when you''re working with Blueprints too, but since we have chosen a
    C++ project, we should look at some code. In Visual Studio, open the `UnrealAIBookCharacter.h`
    file, and just below the public variables, add the following lines of code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码的结构将与蓝图版本略有不同。实际上，我们不能直接从AI控制器类（主要因为直接引用它会很困难）分配一个***行为树***；相反，我们需要从角色中获取它。正如我之前提到的，当你使用蓝图时，这也是一个好的方法，但既然我们选择了C++项目，我们应该看看一些代码。在Visual
    Studio中，打开`UnrealAIBookCharacter.h`文件，并在公共变量下方添加以下代码行：
- en: '[PRE0]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For those who are still unfamiliar, here is a larger chunk of code so that
    you can understand where to place the preceding code within the class:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些仍然不熟悉的人来说，这里有一段更大的代码块，以便你可以理解如何在类中放置前面的代码：
- en: '[PRE1]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Moreover, to compile the preceding code, we also have to include the following
    statement at the top of the class, just above `.generated`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了编译前面的代码，我们还需要在类的顶部包含以下语句，就在`.generated`上方：
- en: '[PRE2]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Close the *Character class*, since we have finished with it. As a result, every
    time we have an instance of that character placed in the world, we will be able
    to specify a *Behavior Tree* from the *Details* panel, as shown in the following
    screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭*角色类*，因为我们已经完成了它。因此，每次我们在世界中放置该角色的实例时，我们都能在*详细信息*面板中指定一个*行为树*，如下面的截图所示：
- en: '![](img/a8890c1f-47aa-4dc9-bb45-e9d180b264bb.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8890c1f-47aa-4dc9-bb45-e9d180b264bb.png)'
- en: 'Let''s open the header (`.h`) file of our newly created AI controller (it should
    already be open in *Visual Studio* if you are using it as an *IDE*). In particular,
    we need to override a function of the AI Controller class. The function we are
    going to override is called `Possess()`, and it allows us to run some code as
    soon as this AI Controller possess a new Pawn (that is, when it takes control
    of the character, which is a Pawn). Add the following code in bold (within a protected
    visibility):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开我们新创建的AI控制器的头文件（`.h`）。特别是，我们需要覆盖AI控制器类的一个函数。我们要覆盖的函数叫做`Possess()`，它允许我们在AI控制器拥有一个新的Pawn（即它控制的角色，它是一个Pawn）时立即运行一些代码。在受保护的可见性中添加以下加粗代码：
- en: '[PRE3]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, open the implementation (`.cpp`) file. Once again, to use *Behavior Trees*,
    we have to include both *Behavior Trees* and the `UnrealAIBookCharacter` class:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开实现文件（`.cpp`）。再次使用*行为树*，我们必须包含*行为树*和`UnrealAIBookCharacter`类：
- en: '[PRE4]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we need to assign a functionality to the `Possess()` function. We need
    to check whether the *Pawn* is actually an ***UnrealAIBookCharacter***, and if
    so, we retrieve the *Behavior Tree* and run it. Of course, this is surrounded
    by an `if` statement to avoid our pointers being `nullptr` :'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为`Possess()`函数分配一个功能。我们需要检查*Pawn*是否实际上是***UnrealAIBookCharacter***，如果是，我们就检索*行为树*并运行它。当然，这被一个`if`语句包围，以避免我们的指针是`nullptr`：
- en: '[PRE5]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If, for any reason, you cannot get the code to work, you can just use a Blueprint
    controller to start the *Behavior Tree*, or just inherit the C++ controller, and
    make sure that all rest of the code runs, and make a call to the `RunBehaviorTree()`
    function in Blueprint.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于任何原因您无法使代码运行，您可以使用蓝图控制器来启动*行为树*，或者直接继承C++控制器，并确保所有其他代码都能运行，然后在蓝图中的`RunBehaviorTree()`函数中进行调用。
- en: 'Once we have compiled our project, we will be able to use this controller.
    Select our AI character from the Level (if you don''t have it, you can create
    one) and this time, in the *Details* panel, we can set our C++ controller, as
    follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编译了我们的项目，我们就能使用这个控制器。从层级中选择我们的AI角色（如果您没有，您可以创建一个），这次，在*详细信息*面板中，我们可以设置我们的C++控制器，如下所示：
- en: '![](img/2ca2c2d3-949d-4a87-a980-858ee4285383.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ca2c2d3-949d-4a87-a980-858ee4285383.png)'
- en: 'Also, don''t forget to assign the *Behavior Tree* as well, which we always
    do in the *Details Panel*:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，别忘了在*详细信息面板*中将*行为树*分配好，我们总是这样做：
- en: '![](img/b8129073-f0fa-4531-9556-ab97d878ab78.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8129073-f0fa-4531-9556-ab97d878ab78.png)'
- en: As a result, once the game starts, the enemy will start executing the Behavior
    Tree. At the moment, the tree is empty, but this gives us the structure we need
    so that we can start working with *Behavior Trees*. In the following chapters,
    we are going to explore *Behavior Trees* more in detail, especially in chapters
    8, 9, and 10, where we will look at a more practical approach to designing and
    building *Behavior Trees*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦游戏开始，敌人将开始执行行为树。目前，树是空的，但这给了我们所需的架构，以便我们可以开始使用*行为树*。在接下来的章节中，我们将更详细地探讨*行为树*，特别是在第8章、第9章和第10章，我们将探讨设计和构建*行为树*的更实际的方法。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered what a ***Behavior Tree*** is and some of the
    things that they consist of, including *Tasks*, *Decorators*, and *Services*.
    Next, we learned about ***Blackboards*** and how to integrate them with *Behavior
    Trees*. Then, we created a *Behavior Tree* and learned how to make it start from
    an *AI Controller* (both in Blueprint and C++). By doing this, we have developed
    a solid foundation that has provided us with key knowledge so that we can tackle
    the other parts of this book.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了什么是***行为树***以及它们包含的一些内容，包括*任务*、*装饰器*和*服务*。接下来，我们学习了***黑板***以及如何将其与*行为树*集成。然后，我们创建了一个*行为树*并学习了如何从*AI控制器*（在蓝图和C++中）启动它。通过这样做，我们建立了一个坚实的基础，为我们提供了关键知识，以便我们可以处理这本书的其他部分。
- en: As a result, we will meet more ***Behavior Trees*** throughout this book, and
    you will have a chance to master them. But before that, there are certain topics
    we need to learn about first. Once we have a solid foundation of navigation and
    perception (including EQS), we can iterate over ***Behavior Trees*** to understand
    the role of *Composite* nodes, along with *Decorator* and *Tasks*. Moreover, we
    will be able to create our own. Chapters 8, 9, and 10 will guide you through the
    process of creating a Behavior Tree from scratch, from the designing phase to
    realization.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这本书中，我们将遇到更多的***行为树***，您将有机会掌握它们。但在那之前，我们首先需要了解一些特定的主题。一旦我们有了导航和感知（包括EQS）的坚实基础，我们就可以迭代***行为树***来理解*复合*节点的作用，以及*装饰器*和*任务*。此外，我们还将能够创建自己的。第8章、第9章和第10章将指导您从头开始创建行为树的过程，从设计阶段到实现阶段。
- en: But until then, let's move on to the next chapter, in which we are going to
    discuss *Navigation* and *Pathfinding*!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 但在那之前，让我们继续到下一章，我们将讨论*导航*和*路径查找*！
