- en: Finding Your Way
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找路径
- en: Obstacle avoidance is a simple behavior that allows AI entities to reach a target
    point. It's important to note that the specific behavior implemented in this chapter
    is meant to be used for behaviors such as crowd simulation, where the main objective
    of each agent entity is just to avoid the other agents and reach the target. There's
    no consideration of what would be the most efficient and shortest path. We'll
    learn about the A* Pathfinding algorithm in the next section.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 障碍物避免是一种简单的行为，允许AI实体到达目标点。需要注意的是，本章中实现的具体行为旨在用于如人群模拟等行为，其中每个代理实体的主要目标只是避免其他代理并到达目标。这里没有考虑最有效和最短的路径。我们将在下一节学习A*路径查找算法。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Path following and steering
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟随路径和转向
- en: A custom A* Pathfinding implementation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义A*路径查找实现
- en: Unity's built-in NavMesh
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity内置的NavMesh
- en: Following a path
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 沿路径行进
- en: Before diving into A*, which is a procedural approach to pathfinding, we'll
    implement a more rudimentary waypoint-based system. While more advanced techniques,
    such as the aforementioned A* method or Unity's NavMesh, will often be the preferred
    method for pathfinding, looking at a simpler, more pure version will help set
    the foundation for understanding more complex pathfinding approaches. Not only
    that, but there are many scenarios in which a waypoint-based system will be more
    than enough, and will allow more fine-tuned control over your AI agent's behavior.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨A*算法之前，这是一种路径查找的进程式方法，我们将先实现一个更基础的基于航点的系统。虽然更高级的技术，如前面提到的A*方法或Unity的NavMesh，通常会是路径查找的首选方法，但查看一个更简单、更纯粹版本将有助于为理解更复杂的路径查找方法打下基础。不仅如此，还有许多场景中，基于航点的系统将绰绰有余，并允许对AI代理的行为进行更精细的控制。
- en: 'In this example, we''ll create a path, which is made up of individual waypoints.
    For our purposes, a waypoint is simply a point in space with an X, Y, and Z value;
    we can simply use a `Vector3` to represent this data. By making a serialized array
    of `Vector3` in our script, we''ll be able to edit the points in the inspector
    without much fuss. If you want to challenge yourself and tweak this system to
    be a bit more user-friendly, you may want to consider using an array of game objects
    instead, and using their position (a `Vector3` ) instead. For demonstration purposes,
    the example provided will stick to the `Vector3` array. After setting up some
    points in our array, we want to end up with a path that looks like the following
    screenshot:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个路径，它由单独的航点组成。就我们的目的而言，航点只是一个具有X、Y和Z值的空間点；我们可以简单地使用`Vector3`来表示这些数据。通过在我们的脚本中创建一个`Vector3`的序列化数组，我们可以在检查器中轻松编辑这些点。如果你想挑战自己并调整这个系统使其更具用户友好性，你可能想要考虑使用游戏对象的数组，并使用它们的位置（一个`Vector3`）来代替。为了演示目的，提供的示例将坚持使用`Vector3`数组。在设置好数组中的某些点之后，我们希望得到的路径看起来像以下截图：
- en: '![](img/d7a9aa21-88e5-4b75-a064-bbd18eb1eefd.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d7a9aa21-88e5-4b75-a064-bbd18eb1eefd.png)'
- en: An object path
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对象路径
- en: In the preceding screenshot, we use some debug lines to draw the connections
    between waypoints. Don't worry, there isn't any magic happening here. By using
    Unity's debug features, we can visualize the path we'll be having our agent traverse.
    Let's deconstruct our `Path.cs` script to see how we achieve this.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图，我们使用了一些调试线来绘制航点之间的连接。别担心，这里没有发生任何魔法。通过使用Unity的调试功能，我们可以可视化我们的代理将要穿越的路径。让我们分解`Path.cs`脚本，看看我们是如何实现这一点的。
- en: The path script
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路径脚本
- en: 'Here is our `Path.cs` script, which is responsible for managing our waypoints:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`Path.cs`脚本，它负责管理我们的航点：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `SerializeField` property can be used to force Unity to serialize a private
    field, and display it in the inspector.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`SerializeField`属性可以用来强制Unity序列化一个私有字段，并在检查器中显示它。'
- en: 'Our waypoints'' `Vector3` array is the collection of waypoints in the path
    mentioned earlier. To initialize the waypoints, we must add the script to a game
    object in our scene. In the sample scene, we simply create an empty game object
    and attach the `Path.cs` script to it. For the sake of clarity, we''ve also renamed
    our game object to `Path`. With the `Path` game object ready to go, we can assign
    the path values in the inspector. The sample values look like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们航点的`Vector3`数组是之前提到的路径中航点的集合。为了初始化航点，我们必须将脚本添加到场景中的游戏对象。在示例场景中，我们简单地创建了一个空的游戏对象并将`Path.cs`脚本附加到它。为了清晰起见，我们还把我们的游戏对象重命名为`Path`。有了准备好的`Path`游戏对象，我们可以在检查器中分配路径值。示例值如下所示：
- en: '![](img/0964a4e7-6420-4f16-a8a1-120044e65020.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0964a4e7-6420-4f16-a8a1-120044e65020.png)'
- en: Path values provided in the sample project
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 样本项目提供的路径值
- en: The values in the screenshot here are arbitrary, and can be tweaked to your
    liking. You just need to make sure you have at least two waypoints along your
    path.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里截图中的值是任意的，可以根据您的喜好进行调整。您只需确保沿路径至少有两个航点。
- en: The `PathLength` property simply returns the length of our waypoint array. It
    provides a public getter for our private field, and is later used by another script.
    The `radius` variable allows us to define the tolerance for our pathfinding. Rather
    than expecting our agent to be at the precise location of our waypoint, we'll
    use a radius to determine when the agent is *close enough* to consider the waypoint
    visited. The `GetPoint` method is a simple helper to get a waypoint from the array
    at a given index.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`PathLength`属性简单地返回我们的航点数组的长度。它为我们私有的字段提供了一个公共的获取器，并被后来的脚本使用。`radius`变量允许我们定义路径查找的容差。我们不会期望代理精确地位于航点的位置，而是将使用一个半径来确定代理何时“足够接近”以考虑航点已被访问。`GetPoint`方法是一个简单的辅助方法，用于从数组中获取给定索引的航点。'
- en: It is common and proper practice to make fields `private` by default, especially
    when the data contained is integral to the functionality of the class. In our
    case, the waypoint order, array size, and more should not be modified at runtime,
    so we ensure that external classes can only get data from them by using helper
    methods and properties, and protect them from external changes by making them
    private.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 默认将字段设置为`private`是一种常见且合适的做法，尤其是在包含的数据对类的功能至关重要时。在我们的例子中，航点顺序、数组大小等都不应在运行时修改，因此我们确保外部类只能通过使用辅助方法和属性从它们获取数据，并通过将它们设置为私有来保护它们免受外部更改。
- en: Finally, we use `OnDrawGizmos`, which is a `MonoBehaviour` method that Unity
    automatically calls for us, to draw debug information in the scene view in the
    editor. We can toggle this functionality on and off by setting the value of `isDebug`
    to `true` or `false`, respectively.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`OnDrawGizmos`，这是一个Unity自动为我们调用的`MonoBehaviour`方法，在编辑器的场景视图中绘制调试信息。我们可以通过将`isDebug`的值设置为`true`或`false`来切换此功能。
- en: Using the path follower
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路径跟随器
- en: 'Next, we''ll set up our agent to follow the path defined in the previous section.
    We''ll use a simple cube in the example, but feel free to use any art you want.
    Let''s take a closer look at the `Pathing.cs` script provided in the sample code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将设置我们的代理以跟随上一节中定义的路径。在示例中，我们将使用一个简单的立方体，但您可以使用任何您想要的美术资源。让我们更仔细地看看示例代码中提供的`Pathing.cs`脚本：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first group of fields are variables we want serialized so that they can
    be set via the inspector. `path` is a reference to the `Path` object we created
    earlier; we can simply drag and drop the component from the `path` game object
    into this field. `speed` and `mass` are used to calculate the movement of the
    agent along the path. `isLooping` is used to determine whether or not we should
    loop around the path. When true, the agent will reach the last waypoint, then
    go to the first waypoint on the path and start over. Once the values are all assigned,
    the inspector should look something like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组字段是我们希望序列化的变量，以便可以通过检查器设置。`path`是我们之前创建的`Path`对象的引用；我们可以简单地从`path`游戏对象中拖放组件到这个字段。`speed`和`mass`用于计算代理沿路径的运动。`isLooping`用于确定是否应该沿着路径循环。当为`true`时，代理将到达最后一个航点，然后转到路径上的第一个航点并重新开始。一旦所有值都分配完毕，检查器应该看起来像这样：
- en: '![](img/37e3073c-4ecc-4d97-8e2f-6c2c3fe32255.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/37e3073c-4ecc-4d97-8e2f-6c2c3fe32255.png)'
- en: The pathfinding script inspector with its default values
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 带有默认值的路径查找脚本检查器
- en: 'Our `Start` method handles the initialization for some of the remaining private
    fields—`direction` and `targetPoint`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Start`方法处理一些剩余的私有字段——`direction`和`targetPoint`的初始化：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our `Update` method does a few things for us. First, it does some boilerplate
    null safety checks, it updates the speed of the agent, checks whether the target
    has been reached, calls the `SetNextTarget` method to determine the next target
    point, and finally, applies the direction and rotation changes as needed:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Update`方法为我们做了几件事情。首先，它进行了一些模板化的空安全检查，更新代理的速度，检查目标是否已到达，调用`SetNextTarget`方法来确定下一个目标点，最后，根据需要应用方向和旋转变化：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To keep things nice and readable, we moved some of the functionality out of
    the `Update` method. `TargetReached` is fairly straightforward. It uses the radius
    of `path` to determine if the agent is *close enough* to the target waypoint,
    as you can see here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使内容更加清晰易读，我们将一些功能从`Update`方法中移出。`TargetReached`方法相当直接。它使用`path`的半径来判断代理是否足够接近目标航点，正如你在这里看到的：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `SetNextTarget` method is a bit more interesting.  As you can see, it returns
    a `bool`. If we haven''t reached the end of the array, it''ll just increment the
    value, but if the method is unable to set the next point, because we''ve reached
    the end of the array, and `isLooping` is false, it returns false. If you go back
    to our `Update` method for a moment, you''ll see that when this happens, we simply
    return out of `Update` and do nothing. This is because we''ve reached the end
    of the road, and there is nowhere else for our agent to go. In the same scenario,
    but with `isLooping == true` evaluating to true, we reset our next target point
    to the first in the array (0):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetNextTarget`方法有点更有趣。正如你所见，它返回一个`bool`。如果我们还没有到达数组的末尾，它将只增加值，但如果方法无法设置下一个点，因为我们已经到达数组的末尾，并且`isLooping`为`false`，它将返回`false`。如果你回到我们的`Update`方法，你会看到当这种情况发生时，我们只是简单地退出`Update`并什么都不做。这是因为我们已经到达了路的尽头，我们的代理没有其他地方可以去。在相同的场景中，但`isLooping
    == true`评估为`true`时，我们将下一个目标点重置为数组中的第一个（0）：'
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Steer` method uses the given target point and does some calculations to
    get the new direction and rotation. By subtracting the target point (*b*) from
    the current position (*a*), we get a vector for the direction from *a* to *b*.
    We normalize that vector, then apply the current speed to determine how far to
    move this frame along the new `targetDirection`.  Lastly, we use the mass to ease
    the acceleration between our `targetDirection` and our current direction, and
    return that value as `acceleration`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Steer`方法使用给定的目标点进行一些计算，以获得新的方向和旋转。通过从当前位置（*a*）减去目标点（*b*），我们得到从*a*到*b*的方向向量。我们对该向量进行归一化，然后应用当前速度来确定这一帧在新`targetDirection`上的移动距离。最后，我们使用质量来平滑`targetDirection`和当前方向之间的加速度，并将该值作为`acceleration`返回：'
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you run the scene, the agent cube will follow the path as expected. If
    you toggle `isLooping` off, the agent will reach the final waypoint and stop there,
    but if you leave it on, the agent will loop around the path infinitely. Try tweaking
    the various settings to see how it affects the outcome.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行场景时，代理立方体将按照预期跟随路径。如果你关闭`isLooping`，代理将到达最终航点并停止在那里，但如果你保持它开启，代理将无限循环路径。尝试调整各种设置，看看它如何影响结果。
- en: Avoiding obstacles
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免障碍
- en: 'Next, we''ll look at an obstacle avoidance mechanic. To get started, pop open
    the same scene, named `ObstacleAvoidance`. The sample scene is quite straightforward.
    Aside from the camera and directional light, there is a plane with a series of
    blocks that will act as our obstacles, a cube that will act as our agent, and
    a canvas containing some instructional text. The scene will look like the following
    screenshot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看一个避障机制。要开始，打开名为`ObstacleAvoidance`的相同场景。样本场景相当直接。除了相机和方向光之外，还有一个带有一系列块的面，这些块将作为我们的障碍物，一个立方体将作为我们的代理，以及包含一些说明文本的画布。场景将如下截图所示：
- en: '![](img/57fe2cb7-788a-4b9e-8f71-1d2a7f44ad45.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/57fe2cb7-788a-4b9e-8f71-1d2a7f44ad45.png)'
- en: The sample scene setup
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 样本场景设置
- en: 'The hierarchy for the preceding scene pictures looks like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 前一场景图片的层次结构如下所示：
- en: '![](img/e0ee092c-27b6-450d-943c-8988f5a6d3a4.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e0ee092c-27b6-450d-943c-8988f5a6d3a4.png)'
- en: The organized hierarchy
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有序的层次结构
- en: It is worth noting that this `Agent` object is not a pathfinder. As such, if
    we set too many walls up, our `Agent` might have a hard time finding the target.
    Try a few wall setups and see how our `Agent` performs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这个`Agent`对象不是一个路径查找器。因此，如果我们设置太多的墙壁，我们的`Agent`可能很难找到目标。尝试几种墙壁设置，看看我们的`Agent`的表现如何。
- en: Adding a custom layer
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加自定义层
- en: 'Our mechanic relies on raycasting to detect obstacles. Rather than just assuming
    every single object is an obstacle, we specifically use a layer named Obstacles
    and filter out everything else. This is not a default layer in Unity, so we have
    to set it up manually. The sample project already has this set up for you, but
    if you wanted to add your own layer, you could access the layer setup window in
    two different ways. The first is through the menus—Edit | **Project Settings**
    | Tags and Layers—and the second method is by selecting the layer dropdown in
    the hierarchy and selecting Add Layer....The following screenshot shows the menu''s
    location in the upper-right corner of the inspector:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的机制依赖于射线投射来检测障碍物。我们不是假设每个对象都是障碍物，而是特别使用一个名为“障碍物”的层，并过滤掉其他所有内容。这不是Unity中的默认层，因此我们必须手动设置它。示例项目已经为您设置了，但如果您想添加自己的层，您可以通过两种不同的方式访问层设置窗口。第一种是通过菜单——编辑
    | **项目设置** | 标签和层——第二种方法是在层次结构中选择层下拉菜单，然后选择添加层...以下截图显示了菜单在检查器右上角的位置：
- en: '![](img/4de9590a-a78c-40f6-b125-8e3cdf75d258.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/4de9590a-a78c-40f6-b125-8e3cdf75d258.png)'
- en: 'Selecting the Tags and Layers menu through the menu shown in the preceding
    screenshot, or through Unity''s menu bar, will open up a window where you can
    freely add, edit, or remove layers (and tags, but we''re not interested in those
    at the moment). Let''s add `Obstacles` in the 8th slot, as shown in this screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前一个截图所示的菜单或通过Unity的菜单栏选择“标签和层”菜单，将打开一个窗口，您可以在其中自由添加、编辑或删除层（以及标签，但我们目前对此不感兴趣）。让我们在第八个插槽中添加“障碍物”，如下面的截图所示：
- en: '![](img/533c8c62-0818-4eaf-a114-585bf6655687.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/533c8c62-0818-4eaf-a114-585bf6655687.png)'
- en: Creating a new layer
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新层
- en: 'You should save the project after you make any changes to the settings, but
    there is no dedicated save button for layers specifically. You can now assign
    the layer in the same dropdown in the inspector as the one we just used, as depicted
    in the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在对设置进行任何更改后，您应该保存项目，但层没有专门的保存按钮。现在您可以在检查器中相同的下拉菜单中分配层，就像我们刚刚使用的那样，如下面的截图所示：
- en: '![](img/6a4ce7da-241d-474f-9292-678523a9bcc8.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/6a4ce7da-241d-474f-9292-678523a9bcc8.png)'
- en: Assigning our new layer
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 分配我们的新层
- en: Layers are most commonly used by cameras to render a part of the scene, and
    by lights to illuminate only some parts of the scene. But they can also be used
    by raycasting to selectively ignore colliders or create collisions. You can learn
    more about this at [http://docs.unity3d.com/Documentation/Components/Layers.html.](https://docs.unity3d.com/Manual/Layers.html)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 层最常被摄像机用来渲染场景的一部分，以及被灯光用来照亮场景的某些部分。但它们也可以被射线投射用来选择性地忽略碰撞体或创建碰撞。您可以在[http://docs.unity3d.com/Documentation/Components/Layers.html](https://docs.unity3d.com/Manual/Layers.html)了解更多信息。
- en: Obstacle avoidance
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避障
- en: 'Now that our scene is set up, let''s take a look at our avoidance behavior
    script. It contains all the logic for driving our agent, and applies the avoidance
    to the movement of the agent. In the sample project, take a look at the `Avoidance.cs`
    script:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了场景，让我们看看我们的避障行为脚本。它包含驱动我们的代理的所有逻辑，并将避障应用于代理的运动。在示例项目中，查看`Avoidance.cs`脚本：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You''ll find some familiar field names in the preceding code snippet. Values
    such as movement speed, rotation speed, tolerance radius, and more are similar
    to values we used in our waypoint system. Similarly, we use the `SerializeField` attribute
    to expose our private fields in the inspector for easy editing and assignment,
    while protecting our values from being tampered with by external objects at runtime.
    In the `Start` method, we simply initialize some values. For example, we cache
    a reference to our `Camera.main` here so that we don''t have to do the lookup
    every single time we need a reference to it. Next, let''s look at the `Update`
    method:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在前面的代码片段中找到一些熟悉的字段名称。例如，移动速度、旋转速度、容差半径等值与我们使用的航点系统中的值相似。同样，我们使用`SerializeField`属性在检查器中公开我们的私有字段，以便于编辑和分配，同时保护我们的值在运行时免受外部对象的篡改。在`Start`方法中，我们只是初始化一些值。例如，我们在这里缓存了对`Camera.main`的引用，这样我们就不必每次需要引用它时都进行查找。接下来，让我们看看`Update`方法：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Right off the bat, we call `CheckInput()`, which looks like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 立刻调用 `CheckInput()` 函数，它看起来是这样的：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We check whether the user has clicked the left mouse button (by default, it
    is the button mapped to "`0`"). If so, we check for a physics raycast originating
    from the main camera, shooting to the position of the mouse. If we get a positive
    hit, we simply assign the hit point from `mouseHit` to be our new `targetPoint`.
    This is where our agent will attempt to move to. Back to `Update`, we have the
    following lines, right after our `CheckInput()` method:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查用户是否点击了左鼠标按钮（默认情况下，它映射到 "`0`"）。如果是这样，我们检查从主摄像机发出的物理射线投射，射向鼠标的位置。如果我们得到一个积极的命中，我们只需将
    `mouseHit` 中的命中点分配给新的 `targetPoint`。这就是我们的代理将尝试移动到的位置。回到 `Update` 函数，我们有以下几行，紧随
    `CheckInput()` 方法之后：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We calculate the direction to our target point, in the same way we did in our
    `Pathing.cs` script, and we normalize that vector so that it has a magnitude of
    no more than 1\. Next, we modify that direction and apply avoidance, by sending
    that direction vector to our `ApplyAvoidance()` method, which looks like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以与我们在 `Pathing.cs` 脚本中所做的方式计算到目标点的方向，并归一化该向量，使其大小不超过 1。接下来，我们修改该方向并应用规避，通过将那个方向向量发送到我们的
    `ApplyAvoidance()` 方法，该方法看起来像这样：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Before digging into the preceding code, it's important to understand how Unity
    handles masking layers. As we mentioned earlier, we want our raycast to only hit
    the layers we care about, in this case, our `Obstacles` layer. If you were observant,
    you might have noticed our layer's array has 32 slots, from index 0 to 31\. We
    put our `Obstacles` layer on slot 8 (index 9). The reason for this is that Unity
    represents the layers using a 32-bit int, and each bit represents one of the slots,
    from right to left. Let's break that down visually.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究前面的代码之前，了解 Unity 如何处理掩码层非常重要。正如我们之前提到的，我们希望我们的射线投射只击中我们关心的层，在这种情况下，我们的
    `Obstacles` 层。如果你很细心，你可能已经注意到我们的层数组有 32 个槽位，从索引 0 到 31。我们将 `Obstacles` 层放在槽位 8（索引
    9）。这样做的原因是 Unity 使用 32 位整数值来表示层，每个位代表一个槽位，从右到左。让我们用图示来分解这一点。
- en: 'Let''s say we want to represent a layer mask, where only the first slot (the
    first bit) is active. In this case, we''d assign the bit a value of 1\. It would
    look like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要表示一个层掩码，其中只有第一个槽位（第一个位）是激活的。在这种情况下，我们将位赋予值为 1。它看起来会是这样：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And if you''re still solid on your computer science fundamentals, you''ll remember,
    that in binary, that value translates to an int value of 1\. Let''s say you have
    a mask that only has the first four slots/indices selected. That would like like
    this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对计算机科学基础知识非常扎实，你会记得，在二进制中，这个值转换为一个整数值为 1。假设你有一个只选择了前四个槽位/索引的掩码。它看起来会是这样：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once again, converting from binary, it gives us an int value of *15 (1 + 2+
    4 + 8)*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 再次将二进制数转换，它给我们一个整数值为 *15 (1 + 2 + 4 + 8)*。
- en: 'In our script, we want a mask with only the 9th position active, which would
    look like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的脚本中，我们想要一个只有第 9 个位置激活的掩码，它看起来会是这样：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Again, doing the math, we know that the int value for that mask is 256\. But
    doing the math manually is inconvenient. Luckily, C# provides some operators to
    manipulate bits. This line in the preceding code does just that:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 再次进行数学计算，我们知道该掩码的整数值为 256。但手动进行计算不方便。幸运的是，C# 提供了一些操作位的方法。前面代码中的这一行正是这样做的：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It uses a bit shift operator—the left-shift operator, specifically—to create
    our mask. The way it works is fairly straightforward: it takes an int operand
    (the int value on the left-hand side of the expression) with a value of 1, then
    shifts that bit representation to the left eight times. It looks something like
    this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用位运算符——具体来说是左移运算符——来创建我们的掩码。它的工作方式相当简单：它取一个整数值操作数（表达式左侧的整数值）为 1，然后将该位表示向左移动八次。它看起来像这样：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, bitwise operators are helpful, and though they don't always
    lead to very readable code, they're very handy in situations like this one.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，位运算符很有帮助，尽管它们并不总是导致非常可读的代码，但在这种情况下它们非常方便。
- en: You can also find a good discussion on using layermasks on Unity3D online. The
    question-and-answer site can be found at [http://answers.unity3d.com/questions/8715/how-do-i-use-layermasks.html](http://answers.unity3d.com/questions/8715/how-do-i-use-layermasks.html).
    Alternatively, you may consider using `LayerMask.GetMask()`, which is Unity's
    built-in method for dealing with named layers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在网上找到关于在Unity3D中使用图层掩码的良好讨论。问答网站可以在[http://answers.unity3d.com/questions/8715/how-do-i-use-layermasks.html](http://answers.unity3d.com/questions/8715/how-do-i-use-layermasks.html)找到。或者，你也可以考虑使用`LayerMask.GetMask()`，这是Unity内置的用于处理命名图层的函数。
- en: 'With that out of the way, let''s go back to the rest of our `ApplyAvoidance()`
    code. After creating the layer mask, the following lines look like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 清理完这些后，让我们回到`ApplyAvoidance()`代码的其余部分。在创建图层掩码后，接下来的几行代码如下所示：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once again, we use a raycast, but this time, the origin is the position of the
    agent, and the direction is its forward vector. You'll also notice that we use
    an overload of the `Physics.Raycast()` method that takes our `layerMask` as an
    argument, meaning our raycast will only hit objects in our obstacles layer. When
    a hit does occur, we get the normal of the surface we hit and calculate the new
    direction vector.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用射线投射，但这次，原点是代理的位置，方向是它的前进向量。你也会注意到我们使用了`Physics.Raycast()`方法的重载，它将我们的`layerMask`作为参数，这意味着我们的射线投射只会击中我们的障碍物层中的对象。当发生击中时，我们得到我们击中的表面的法线并计算新的方向向量。
- en: 'The last bit of our `Update` function looks like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`Update`函数的最后部分看起来是这样的：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Again, you may recognize some of this code, as it's very similar to the code
    used in the `Pathing.cs` script. If we've come within the acceptable radius of
    our destination, we do nothing. Otherwise, we rotate the agent and move it forward.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你可能认出一些这段代码，因为它与`Pathing.cs`脚本中使用的代码非常相似。如果我们已经到达目的地可接受半径内，我们就不做任何事情。否则，我们旋转代理并向前移动它。
- en: 'In the sample scene, you can find an `Agent` game object with the `Avoidance.cs`
    script attached. The inspector with all the values assigned will look like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例场景中，你可以找到一个带有`Avoidance.cs`脚本的`Agent`游戏对象。所有值都已分配的检查器看起来如下所示：
- en: '![](img/6145a7df-3c30-4bf1-b6be-bbb983ae9fe8.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6145a7df-3c30-4bf1-b6be-bbb983ae9fe8.png)'
- en: Agent inspector view
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 代理检查视图
- en: Try tweaking the values to see what kinds of results you can get. Simply hit
    play and click around the scene to tell your agent to move. You may notice that,
    even though the agent is intelligently avoiding the obstacles, it won't always
    take the most efficient route to its target destination. That's where A* comes
    in.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整这些值，看看你能得到什么样的结果。简单地按播放并点击场景，告诉你的代理移动。你可能注意到，尽管代理智能地避开障碍物，但它并不总是选择到达目标的最有效路径。这就是A*算法发挥作用的地方。
- en: A* Pathfinding
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: A*路径查找
- en: Next up, we'll  implement the A* algorithm in a Unity environment using C#.
    The A* Pathfinding algorithm is widely used in games and interactive applications
    even though there are other algorithms, such as Dijkstra's algorithm, because
    of its simplicity and effectiveness. We've briefly covered this algorithm previously,
    in [Chapter 1](070df6ee-a9ba-4dca-b175-06a95a96eb7c.xhtml), *The Basics of AI
    in Games*, but let's review the algorithm again from an implementation perspective.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用C#在Unity环境中实现A*算法。尽管还有其他算法，如Dijkstra算法，但A*路径查找算法因其简单性和有效性而被广泛应用于游戏和交互式应用程序中。我们之前在[第1章](070df6ee-a9ba-4dca-b175-06a95a96eb7c.xhtml)《游戏AI基础》中简要介绍了这个算法，但现在让我们从实现的角度再次回顾这个算法。
- en: Revisiting the A* algorithm
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 再次探讨A*算法
- en: We briefly touched on the A* algorithm earlier in the book, so let's review
    the basics before we dive into our implementation. For starters, we need to create
    a grid-based representation of our map. The best option for this is a 2D array.
    This grid and all of its associated data will be contained in our `GridManager`
    class. The `GridManager` class will contain a list of `Node` objects that represent
    each cell in our grid. The nodes themselves will contain some additional data
    about themselves, such as their heuristic cost and whether or not they are an
    obstacle node.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在书中简要提到了A*算法，所以在我们深入实现之前，让我们先回顾一下基础知识。首先，我们需要创建我们地图的基于网格的表示。最好的选择是2D数组。这个网格及其所有相关数据都将包含在我们的`GridManager`类中。`GridManager`类将包含一个`Node`对象列表，代表我们网格中的每个单元格。节点本身将包含一些关于它们自己的额外数据，例如它们的启发式成本以及它们是否是障碍物节点。
- en: We'll also need to keep two lists—our open list, that is, our list of nodes
    to explore, and our closed list, which will contain nodes we've already visited.
    We'll implement these in our `PriorityQueue` class, which provides some additional
    helper functionality.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要保留两个列表——我们的开放列表，即要探索的节点列表，以及我们的关闭列表，它将包含我们已访问的节点。我们将在`PriorityQueue`类中实现这些，它提供了一些额外的辅助功能。
- en: 'In essence, our A* algorithm, implemented in the `AStar` class, must do the
    following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，我们实现的A*算法，在`AStar`类中，必须执行以下操作：
- en: Begin at the starting node and put it in the open list.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从起始节点开始，并将其放入开放列表。
- en: 'As long as the open list has some nodes in it, we''ll perform the following
    processes:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只要开放列表中还有节点，我们就会执行以下过程：
- en: Pick the first node from the open list and keep it as the current node. (This
    is assuming that we've sorted the open list and the first node has the least cost
    value, which will be mentioned at the end of the code.)
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从开放列表中选择第一个节点并将其保留为当前节点。（这是假设我们已经对开放列表进行了排序，并且第一个节点具有最小的成本值，这一点将在代码的末尾提到。）
- en: Get the neighboring nodes of this current node that are not obstacle types,
    such as a wall or canyon, that can't be passed through.
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取当前节点的相邻节点，这些相邻节点不是障碍物类型，例如墙壁或峡谷，无法通过。
- en: 'For each neighbor node, check if this neighbor node is already in the closed
    list. If not, we''ll calculate the total cost (`F`) for this neighbor node using
    the following formula:'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个相邻节点，检查此相邻节点是否已经在关闭列表中。如果没有，我们将使用以下公式计算此相邻节点的总成本（`F`）：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding formula, `G` is the total cost from the start node to this
    node and `H` is the total cost from this node to the final target node.
  id: totrans-105
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的公式中，`G`是从起始节点到该节点的总成本，`H`是从该节点到最终目标节点的总成本。
- en: Store this cost data in the neighbor node object. Also, store the current node
    as the parent node as well. Later, we'll use this parent node data to trace back
    the actual path.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此成本数据存储在相邻节点对象中。同时，将当前节点作为父节点存储。稍后，我们将使用此父节点数据来追踪实际路径。
- en: Put this neighbor node in the open list. Sort the open list in ascending order,
    ordered by the total cost to reach the target node.
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此相邻节点放入开放列表。按到达目标节点的总成本对开放列表进行升序排序。
- en: If there are no more neighbor nodes to process, put the current node in the
    closed list and remove it from the open list.
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有更多的相邻节点要处理，将当前节点放入关闭列表，并从开放列表中删除它。
- en: Go back to step 2 using the next node in the open list.
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用开放列表中的下一个节点回到步骤2。
- en: Once you have completed this process, your current node should be in the target
    goal node position, but only if there's an obstacle-free path to reach the goal
    node from the start node. If it is not at the goal node, there's no available
    path to the target node from the current node position. If there's a valid path,
    all we have to do now is trace back from the current node's parent node until
    we reach the start node again. This will give us a path list of all the nodes
    that we chose during our pathfinding process, ordered from the target node to
    the start node. We then just reverse this path list, since we want to know the
    path from the start node to the target goal node.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此过程后，你的当前节点应该位于目标目标节点位置，但前提是从起始节点到目标节点的路径无障碍。如果它不在目标节点，则从当前节点位置到目标节点的路径不可用。如果存在有效路径，我们现在要做的就是从当前节点的父节点开始追踪，直到再次到达起始节点。这将给我们一个在路径查找过程中选择的节点路径列表，从目标节点到起始节点排序。然后我们只需反转这个路径列表，因为我们想知道从起始节点到目标目标节点的路径。
- en: This is a general overview of the algorithm we're going to implement in Unity
    using C#. So, let's get started.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将在Unity中使用C#实现的算法的一般概述。那么，让我们开始吧。
- en: Implementation
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: 'In order to get started with A*, we''ll have to take the concepts and apply
    them as concrete implementations in the code. In our sample code, we break the
    A* system into a few key components: the `Node`, `GridManager`, `PriorityQueue`,
    and `AStart` classes.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始使用A*，我们必须将概念应用到代码中的具体实现。在我们的示例代码中，我们将A*系统分解为几个关键组件：`Node`、`GridManager`、`PriorityQueue`和`AStart`类。
- en: Let's break down what each class does in the following few sections.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的几个部分中分解每个类的作用。
- en: The Node class
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点类
- en: 'We can think of the `Node` class as a container for all of the relevant information
    about each tile in our grid. We store information about things such as the cost
    of the node, the parent of the node, and its position:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以把 `Node` 类想象成包含我们网格中每个瓦片相关信息的容器。我们存储有关节点成本、节点父节点和其位置等信息：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In code, we represent our G and H costs as `gCost` and `hCost`, respectively.
    G refers to the cost from the start node to this node, and H refers to the estimated
    cost from this node to the end node. Depending on how comfortable you get with
    A*, you might consider renaming them something a bit more descriptive. In our
    example, we want to adhere as closely as possible to the *on paper* version of
    the names of concepts, for the purpose of explaining the C# implementation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们分别用 `gCost` 和 `hCost` 来表示我们的 G 和 H 成本。G 指的是从起始节点到该节点的成本，而 H 指的是从该节点到终点节点的估计成本。根据你对
    A* 的熟悉程度，你可能考虑将它们重命名为更具描述性的名称。在我们的例子中，我们希望尽可能接近于纸上概念名称的 *实际版本*，以便解释 C# 实现。
- en: The class provides a simple constructor that takes no arguments, and one overload
    that takes in a position, which prepopulates the position field with the passed-in
    value. There's nothing too fancy here.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 该类提供了一个简单的构造函数，它不接受任何参数，并且有一个重载函数接受一个位置，它将传递的值预先填充到位置字段中。这里没有什么太复杂的。
- en: You may have noticed that our class implements the `IComparable` interface,
    which requires us to implement the `CompareTo()` method to satisfy the interface
    contract requirements.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们的类实现了 `IComparable` 接口，这要求我们实现 `CompareTo()` 方法以满足接口合同要求。
- en: You can think of an interface as a contract. On its own, it does nothing. You
    cannot implement any logic in an interface. By inheriting from an interface, you're
    simply agreeing to implement all the methods with the provided signatures in the
    implementing class. That way, any other class that wants to call a given method
    from an interface on your class can assume that the method exists.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把接口想象成一个合同。单独来看，它什么也不做。你无法在接口中实现任何逻辑。通过从接口继承，你只是同意在实现类中实现所有具有提供签名的所有方法。这样，任何其他想要调用你类中接口给定方法的类都可以假设该方法存在。
- en: The actual implementation of the method compares the given node to this node
    based on their `hCost`. We'll take a look at its usage later on.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的实际实现根据给定的节点与该节点的 `hCost` 进行比较。我们稍后会看看它的用法。
- en: Establishing the priority queue
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立优先队列
- en: 'We represent our open and closed list using the `PriorityQueue` class. This
    approach allows us to implement some helper methods for our own convenience. The
    `PriorityClass.cs` file looks like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `PriorityQueue` 类来表示我们的开放列表和关闭列表。这种方法允许我们实现一些方便的辅助方法。`PriorityClass.cs`
    文件看起来像这样：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There isn't much of note in this code, but the `Sort()` method in particular
    is interesting. Remember the `CompareTo()` method in the `Node` class? The `ArrayList.Sort()`
    actually relies on the implementation of `CompareTo()` in the node class to sort
    the array. More specifically, it will sort according to the node's `hCost`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中没有太多值得注意的，但特别是 `Sort()` 方法很有趣。还记得 `Node` 类中的 `CompareTo()` 方法吗？`ArrayList.Sort()`
    实际上依赖于节点类中 `CompareTo()` 的实现来排序数组。更具体地说，它将根据节点的 `hCost` 进行排序。
- en: Setting up our grid manager
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的网格管理器
- en: 'The `GridManager` class does a lot of the heavy lifting in terms of arranging
    and visualizing our grid. Compared to some of the code we''ve seen so far in this
    book, it''s a fairly lengthy class, since it provides several helper methods.
    Pop open the `GridManager.cs` class to follow along:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`GridManager` 类在安排和可视化我们的网格方面做了很多繁重的工作。与这本书中我们迄今为止看到的某些代码相比，它是一个相当长的类，因为它提供了几个辅助方法。打开
    `GridManager.cs` 类以继续阅读：'
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We start off by setting up some variables. We specify how many rows and columns
    are in our grid, and we specify their size (in world units). There isn't much
    else of note here, but we should point out that the `Node[,]` syntax indicates
    that we are initializing a 2D array of `nodes`, which makes sense, since a grid
    is a 2D array itself.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置一些变量。我们指定网格中的行数和列数，并指定它们的大小（以世界单位计）。这里没有太多值得注意的，但我们应该指出，`Node[,]` 语法表示我们正在初始化一个
    `nodes` 的二维数组，这是有意义的，因为网格本身就是一个二维数组。
- en: 'In our `Awake` method, we see the following line:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `Awake` 方法中，我们看到以下行：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This simply initializes the `obstacleList` game object array by finding things
    tagged as `"Obstacle"`. `Awake` then calls two setup methods: `InitializeNodes()`
    and `CalculateObstacles()`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是通过查找标记为 `"Obstacle"` 的对象来初始化 `obstacleList` 游戏对象数组。然后 `Awake` 调用两个设置方法：`InitializeNodes()`
    和 `CalculateObstacles()`：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The names of these methods are to the point, so as you may have guessed, `InitializeNodes()`
    initializes our nodes, and does so by populating the `nodes` 2D array. This code
    invokes a helper method, `GetGridCellCenter()`, which we''ll look at later on,
    but the approach is fairly straightforward. We loop through the 2D array, column
    by column and row by row, and we create nodes spaced apart according to the grid
    size:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的名称非常直接，所以正如你可能猜到的，`InitializeNodes()` 初始化我们的节点，并通过填充 `nodes` 2D 数组来实现。此代码调用一个辅助方法
    `GetGridCellCenter()`，我们稍后会看到，但方法相当直接。我们按列和行的顺序遍历 2D 数组，并创建根据网格大小间隔的节点：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `CalculateObstacles()` method simply runs through the list of obstacles
    we initialized during `Awake`, determines which grid slot the obstacle occupies,
    and marks the node at that grid slot as an obstacle using `MarkAsObtacle()`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`CalculateObstacles()` 方法简单地遍历我们在 `Awake` 期间初始化的障碍物列表，确定障碍物占据的网格槽位，并使用 `MarkAsObtacle()`
    将该网格槽位的节点标记为障碍物。'
- en: 'The `GridManager` class has a few helper methods to traverse the grid and get
    the grid cell data. The following is a list of some of them with brief descriptions
    of what they do. The implementation is simple, so we won''t go into the details:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`GridManager` 类有几个辅助方法来遍历网格并获取网格单元格数据。以下是一些它们的列表，以及它们所做简要描述。实现很简单，所以我们不会深入细节：'
- en: '`GetGridCellCenter`: Given an index for a cell, it returns the center position
    (in world space) of that cell.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetGridCellCenter`：给定一个单元格的索引，它返回该单元格的中心位置（在世界空间中）。'
- en: '`GetGridCellPositionAtIndex`: Returns the origin position of the cell (the
    corner). Used as a helper for `GetGridCellCenter`.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetGridCellPositionAtIndex`：返回单元格的起点位置（角落）。用作 `GetGridCellCenter` 的辅助工具。'
- en: '`GetGridIndex`: Given a position (as a `Vector3` in world space), it returns
    the cell closest to the position.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetGridIndex`：给定一个位置（作为世界空间中的 `Vector3`），它返回最接近该位置的单元格。'
- en: '`GetRowOfIndex` and `GetColumnOfIndex`: Just as the names say, they return
    the row or column of the cell at the given index. For example, in a 2 x 2 grid,
    the cell at index 2 (starting from 0), would be in row 2, column 1.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetRowOfIndex` 和 `GetColumnOfIndex`：正如其名称所示，它们返回给定索引的单元格的行或列。例如，在一个 2 x 2
    的网格中，索引为 2 的单元格（从 0 开始），位于第 2 行，第 1 列。'
- en: 'Next, we have some methods that help with figuring out the neighbors to a given
    node:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一些帮助确定给定节点的邻居的方法：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First, we have `GetNeighbors()`, which uses the given node's position in the
    grid to figure out which cells are to the bottom, top, right, and left of it.
    It assigns the node as a neighbor using `AssignNeighbor()`, which does some validation,
    such as checking that the potential neighbor is within bounds (of the array),
    and that the neighbor is not marked as an obstacle.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有 `GetNeighbors()`，它使用给定节点在网格中的位置来确定其下方、上方、右侧和左侧的单元格。它使用 `AssignNeighbor()`
    将节点作为邻居，该函数执行一些验证，例如检查潜在的邻居是否在数组范围内，以及邻居是否未标记为障碍物。
- en: Lastly, we have `OnDrawGizmos()` and `DebugDrawGrid()`, which display the grid
    of the size we specified in our scene view for debugging. Next up, the meat and
    potatoes. We tie it all together with our `AStar` class.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有 `OnDrawGizmos()` 和 `DebugDrawGrid()`，它们用于显示我们在场景视图中指定的网格，以便进行调试。接下来，是主要内容。我们使用我们的
    `AStar` 类将这些内容整合在一起。
- en: Diving into our A* implementation
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解 A* 的实现
- en: 'The `AStar` class is the actual implementation of the A* algorithm. This is
    where the magic happens. The code in the `AStar.cs` file looks like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`AStar` 类是 A* 算法的实际实现。这里发生了魔法。`AStar.cs` 文件中的代码如下：'
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'There is quite a bit to go over here, so let''s break it down, step by step:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多内容需要讲解，所以让我们一步一步来分析：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We start off by declaring our open and closed lists, which will contain visited
    and non-visited nodes, respectively:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明我们的开放列表和关闭列表，它们将分别包含已访问和未访问的节点：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, we implement a method called `EstimateHeuristicCost`
    to calculate the cost between the two given nodes. The calculation is simple.
    We just find the direction vector between the two by subtracting one position
    vector from another. The magnitude of this resultant vector gives the direct distance
    from the current node to the goal node.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们实现了一个名为`EstimateHeuristicCost`的方法来计算两个给定节点之间的成本。计算很简单。我们只需通过从一个位置向量减去另一个位置向量来找到两个节点之间的方向向量。这个结果向量的幅度给出了从当前节点到目标节点的直接距离。
- en: 'Next, we have our `FindPath` method, which does most of the work:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有我们的`FindPath`方法，它做了大部分工作：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It initializes our open and closed lists. At first, we'll only have the starting
    node in our `openList`. We also initialize the `gCost`, which is zero, because
    the distance to the starting node (itself) is zero. We then assign the `hCost`
    using the `EstimateHeuristicCost()` method we just discussed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 它初始化我们的开放和关闭列表。一开始，我们`openList`中只有起始节点。我们还初始化`gCost`，它为零，因为到起始节点（它自己）的距离为零。然后我们使用我们刚才讨论的`EstimateHeuristicCost()`方法分配`hCost`。
- en: 'We''ll need a reference to our `GridManager` going forward, so we get it using
    `FindObjectOfType()` and do some null checking. Next, we begin processing the
    open list:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们需要引用我们的`GridManager`，所以我们使用`FindObjectOfType()`获取它，并进行一些空值检查。接下来，我们开始处理开放列表：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This code implementation resembles the  A* algorithm that we have previously
    discussed. This would be a good time to brush up on it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码实现类似于我们之前讨论过的A*算法。现在是复习它的好时机。
- en: 'In plain English, the preceding code can be described as following these steps:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的话来说，前面的代码可以描述为以下步骤：
- en: Get the first node of our `openList`. Keep in mind that our `openList` is always
    sorted after a new node is added so that the first node is always the node with
    the lowest estimated cost to the goal node.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取我们的`openList`的第一个节点。请注意，每次添加新节点后，我们的`openList`总是排序的，这样第一个节点总是具有到目标节点最低估计成本的节点。
- en: Check whether the current node is already at the goal node. If so, exit the
    `while` loop and build the `path` array.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查当前节点是否已经到达目标节点。如果是，退出`while`循环并构建`path`数组。
- en: Create an array list to store the neighboring nodes of the current node being
    processed. Use the `GetNeighbors()` method to retrieve the neighbors from the
    grid.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个数组列表来存储正在处理的当前节点的相邻节点。使用`GetNeighbors()`方法从网格中检索相邻节点。
- en: For every node in the `neighbors` array, we check whether it's already in the `closedList`.
    If not, we calculate the cost values, update the node properties with the new
    cost values as well as the parent node data, and put it in `openList`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`neighbors`数组中的每个节点，我们检查它是否已经在`closedList`中。如果没有，我们计算成本值，使用新的成本值以及父节点数据更新节点属性，并将其放入`openList`。
- en: Push the current node to `closedList` and remove it from `openList`. Rinse and
    repeat.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前节点推入`closedList`并从`openList`中移除。重复此过程。
- en: 'If there are no more nodes in the `openList`, our current node should be at
    the target node if there''s a valid path available. Then, we just call the `CalculatePath()` method
    with the current node as the argument. The `CalcualtePath()` method looks like
    this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`openList`中没有更多的节点，那么如果存在有效路径，我们的当前节点应该位于目标节点。然后，我们只需将当前节点作为参数调用`CalculatePath()`方法。`CalcualtePath()`方法看起来像这样：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `CalculatePath` method traces through each node's parent node object and
    builds an array list. This gives us an array list with nodes from the target node
    to the start node. Since we want a path array from the start node to the target
    node, we just call the `Reverse` method. And that's it! With our algorithm and
    helper classes out of the way, we can move on to our test script, which ties it
    all together.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`CalculatePath`方法遍历每个节点的父节点对象并构建一个数组列表。这给我们一个从目标节点到起始节点的节点数组列表。由于我们想要从起始节点到目标节点的路径数组，我们只需调用`Reverse`方法。就这样！随着我们的算法和辅助类已经处理完毕，我们可以继续到我们的测试脚本，它将所有这些整合在一起。'
- en: Implementing a TestCode class
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个TestCode类
- en: 'Now that we have the A* algorithm implemented via our `AStar` class (and the
    associated helper classes), we actually implement it using the `TestCode` class.
    The `TestCode.cs` file looks like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过我们的`AStar`类（以及相关的辅助类）实现了A*算法，我们实际上使用`TestCode`类来实现它。`TestCode.cs`文件看起来像这样：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We declare our variables here, and once again set up a variable to hold a reference
    to our `GridManager`. Then, the `Start` method does some initialization and fires
    off our `FindPath()` method, as shown in this code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里声明我们的变量，并再次设置一个变量来保存对`GridManager`的引用。然后，`Start`方法进行一些初始化并触发我们的`FindPath()`方法，如下所示代码：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the `Update` method, we check for the path at intervals, which is a brute
    force approach to refreshing the path if the goal moves at runtime. You may want
    to consider implementing this code using an event to avoid unnecessary overhead
    in every frame (or interval, in this case).  The `FindPath()` method called in
    `Start` looks like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Update`方法中，我们以一定的时间间隔检查路径，这是一种在运行时目标移动时刷新路径的暴力方法。你可能希望考虑使用事件来实现此代码，以避免在每一帧（或在这种情况下，间隔）中产生不必要的开销。在`Start`中调用的`FindPath()`方法如下所示：
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: First, it takes the positions of our start and end game objects. Then, it creates
    new `Node` objects using the helper methods `GridManager` and `GetGridIndex` to
    calculate their respective row and column index positions inside the grid. With
    those necessary values ready to go, we just call the `AStar.FindPath` method with
    the start node and goal node, and store the returned array list in the local `pathArray` variable.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它获取我们的起始和结束游戏对象的位置。然后，它使用`GridManager`和`GetGridIndex`辅助方法创建新的`Node`对象，以计算它们在网格中的相应行和列索引位置。有了这些必要的值，我们只需调用`AStar.FindPath`方法并使用起始节点和目标节点，然后将返回的数组列表存储在局部`pathArray`变量中。
- en: 'Next, we implement the `OnDrawGizmos` method to draw and visualize the path
    found:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实现`OnDrawGizmos`方法来绘制和可视化找到的路径：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We look through our `pathArray` and use the `Debug.DrawLine` method to draw
    the lines connecting the nodes from the `pathArray`. With this, we'll be able
    to see a green line connecting the nodes from start to end, forming a path, when
    we run and test our game.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历`pathArray`并使用`Debug.DrawLine`方法绘制连接`pathArray`中节点的线条。这样，当我们运行并测试游戏时，我们将能够看到一条从起点到终点的绿色线条，形成一个路径。
- en: Testing it in the sample scene
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在示例场景中测试它
- en: 'The sample scene looks like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 示例场景看起来如下：
- en: '![](img/9bf044e3-b835-4b83-a532-d91330a844ec.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9bf044e3-b835-4b83-a532-d91330a844ec.png)'
- en: Our sample scene with the pathfinding grid drawn over it
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在路径寻优网格上绘制的我们的示例场景
- en: As you can see in the preceding screenshot, there is a red starting node, a
    green goal node, a plane, and some light grey obstacles.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，有一个红色起始节点，一个绿色目标节点，一个平面和一些浅灰色障碍物。
- en: 'The following screenshot is a snapshot of our scene hierarchy:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是我们场景层次结构的快照：
- en: '![](img/cbba19a3-4926-4f98-a3a6-1c838fb01703.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cbba19a3-4926-4f98-a3a6-1c838fb01703.png)'
- en: 'There are a few things to note in the preceding screenshot (and yes, you can
    ignore the Directional light, as it''s just here to make our scene look pretty).
    First, we have grouped all of our obstacles under a parent `Obstacles` transform.
    Second, we have separate game objects for our `TestCode` class and our `GridManager`
    class as children under the `Scripts` game object. As you saw in the code sample
    earlier, there are some fields exposed in the `GridManager`, which should look
    like the following screenshot in our sample scene:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中有几点需要注意（是的，你可以忽略方向光，因为它只是在这里让我们的场景看起来更漂亮）。首先，我们将所有的障碍物都分组在父`Obstacles`变换下。其次，我们在`Scripts`游戏对象下有单独的游戏对象用于我们的`TestCode`类和`GridManager`类。正如你之前在代码示例中看到的，`GridManager`中暴露了一些字段，它们在我们的示例场景中应该看起来像以下截图：
- en: '![](img/55d90b5e-b284-45aa-89fa-8cadb8d5b5db.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/55d90b5e-b284-45aa-89fa-8cadb8d5b5db.png)'
- en: As you can see in the previous screenshot, we have Show Grid ticked to true.
    This will enable us to see the grid in the scene view.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，我们已将“显示网格”选项设置为true。这将使我们能够在场景视图中看到网格。
- en: Testing all the components
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试所有组件
- en: 'Now that we''ve looked at how everything is wired up, hit the play button and
    observe how a path will be drawn from our start node to our goal node, as shown
    in the following screenshot:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了所有组件的连接方式，点击播放按钮并观察从我们的起始节点到目标节点的路径是如何绘制的，如下所示截图：
- en: '![](img/2787783f-c474-4af1-9961-a2922a66afc2.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2787783f-c474-4af1-9961-a2922a66afc2.png)'
- en: 'Since we''re checking for the path at intervals inside the `Update` loop, we
    can move the goal node in play mode, and see the path updated. The following screenshot
    shows the new path after moving our goal node to a different location:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`Update`循环中每隔一段时间检查路径，我们可以在播放模式下移动目标节点，并看到路径更新。以下截图显示了将目标节点移动到不同位置后的新路径：
- en: '![](img/5df973a4-dca9-429c-a40d-da569c2122c2.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5df973a4-dca9-429c-a40d-da569c2122c2.png)'
- en: As you can see, since the goal is closer, so is the most optimal path to reach
    it. In a little more than a nutshell, that is A*. A very powerful algorithm can
    be distilled down to a few classes totaling a few hundred lines of code (with
    most of it due to formatting and commenting).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，由于目标更近，所以到达它的最佳路径也近。简而言之，这就是A*。一个非常强大的算法可以浓缩为几个类，总共只有几百行代码（其中大部分是由于格式化和注释）。
- en: A* vs IDA*
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: A* vs IDA*
- en: In [Chapter 1](070df6ee-a9ba-4dca-b175-06a95a96eb7c.xhtml), *The Basics of AI
    in Games*, we mentioned some of the differences between A* and IDA*. Now that
    you've implemented A*, you can see that the A* implementation keeps a few things
    in memory—the path array, the open list, and the closed list. At different points
    in the implementation, you may allocate more or less memory as you iterate through
    your lists. In this regard, A* is greedier than IDA*, but keep in mind that in
    most cases, on modern hardware, this is not an issue—even with much larger grids
    than ours.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](070df6ee-a9ba-4dca-b175-06a95a96eb7c.xhtml)《游戏AI基础》中，我们提到了A*和IDA*之间的一些区别。现在你已经实现了A*，你可以看到A*实现会保留一些内容在内存中——路径数组、开放列表和关闭列表。在实现的不同阶段，你可能会在遍历你的列表时分配更多或更少的内存。在这方面，A*比IDA*更贪婪，但请记住，在大多数情况下，在现代硬件上，这并不是一个问题——即使是我们更大的网格。
- en: The IDA* approach only looks at the the current iteration's adjacent/neighbor
    spots, and because it keeps no record of the visited nodes, it may end up visiting
    the same node multiple times. In similar circumstances, this means a much lower
    memory overhead than the faster A* version.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: IDA*方法只关注当前迭代的相邻/邻近位置，并且因为它不记录访问过的节点，所以可能会多次访问相同的节点。在类似情况下，这意味着比更快的A*版本低得多的内存开销。
- en: While the point can be argued, it is this humble author's opinion that IDA*
    is not a relevant pattern in modern game development—even on resource-conscious
    applications, such as mobile games. In other fields, one could make a stronger
    case for the iterative deepening approach, but, fortunately, even aging mobile
    devices have copious amounts of memory relative to the needs of the 99% of games
    that will implement some sort of pathfinding.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个观点可以争论，但这位谦逊的作者认为IDA*在现代游戏开发中不是一个相关的模式——即使在资源敏感的应用程序，如移动游戏中也是如此。在其他领域，人们可以为迭代加深方法提出更有力的论据，但幸运的是，即使是老化的移动设备相对于将实现某种寻路功能的99%的游戏的需求来说，也有大量的内存。
- en: Navigation mesh
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航网格
- en: Next, we'll learn how to use Unity's built-in navigation mesh generator that
    can make pathfinding for AI agents a lot easier. Early in the Unity 5.x cycle,
    NavMesh was made available to all users, including personal edition licensees,
    whereas it was previously a Unity Pro-only feature. Before the release of 2017.1,
    the system was upgraded to allow a component-based workflow, but as it requires
    an additional downloadable package that, at the time of writing is only available
    as a preview, we will stick to the default scene-based workflow. Don't worry,
    the concepts carry over, and when the final implementation eventually makes its
    way to 2017.x, there shouldn't be drastic changes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何使用Unity内置的导航网格生成器，它可以使AI代理的寻路变得容易得多。在Unity 5.x周期的早期，NavMesh对所有用户开放，包括个人版许可证持有者，而在此之前，它仅是Unity
    Pro的独占功能。在2017.1版本发布之前，该系统已升级以允许基于组件的工作流程，但由于它需要额外的可下载包，而截至写作时，这个包仅作为预览版提供，我们将坚持默认的场景基础工作流程。不用担心，概念是一致的，当最终实现最终进入2017.x版本时，不应该有剧烈的变化。
- en: For more information on Unity's NavMesh component system, head over to GitHub: [https://github.com/Unity-Technologies/NavMeshComponents](https://github.com/Unity-Technologies/NavMeshComponents).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于Unity的NavMesh组件系统信息，请访问GitHub：[https://github.com/Unity-Technologies/NavMeshComponents](https://github.com/Unity-Technologies/NavMeshComponents)。
- en: Now, we will dive in and explore all that this system has to offer. AI pathfinding
    needs a representation of the scene in a particular format; we've seen that using
    a 2D grid (array) for A* Pathfinding on a 2D map. AI agents need to know where
    the obstacles are, especially the static obstacles. Dealing with collision avoidance
    between dynamically moving objects is another subject, primarily known as steering
    behaviors. Unity has a built-in tool for generating a NavMesh that represents
    the scene in a context that makes sense for our AI agents to find the optimum
    path to the target. Pop open the demo project and navigate to the NavMesh scene
    to get started.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将深入探索这个系统所能提供的一切。AI路径查找需要一个特定格式的场景表示；我们已经看到在2D地图上使用2D网格（数组）进行A*路径查找。AI代理需要知道障碍物的位置，特别是静态障碍物。处理动态移动对象之间的碰撞避免是另一个主题，主要称为转向行为。Unity有一个内置工具用于生成NavMesh，该工具以对AI代理有意义的方式表示场景，以便它们可以找到到目标的最优路径。打开演示项目，导航到NavMesh场景以开始。
- en: Inspecting our map
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查我们的地图
- en: 'Once you have the demo scene, NavMesh, open, it should look something like
    this screenshot:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您打开了演示场景、NavMesh，它应该看起来像以下截图：
- en: '![](img/02e11547-8b78-46c9-9dc8-c33d3dc12349.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/02e11547-8b78-46c9-9dc8-c33d3dc12349.png)'
- en: A scene with obstacles and slopes
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一个带有障碍物和斜坡的场景
- en: This will be our sandbox to explain and test the NavMesh system functionality.
    The general setup is similar to an RTS (real-time strategy) game. You control
    the blue tank. Simply click at a location to make the tank move to that location.
    The yellow indicator is the current target location for the tank.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们的沙盒，用于解释和测试NavMesh系统功能。一般的设置类似于实时策略（RTS）游戏。您控制蓝色坦克。只需点击一个位置，坦克就会移动到该位置。黄色指示器是坦克当前的目标位置。
- en: Navigation Static
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航静态
- en: 'The first thing to point out is that you need to mark any geometry in the scene
    that will be baked into the NavMesh as Navigation Static. You may have encountered
    this elsewhere, such as in Unity''s light-mapping system, for example. Setting
    game objects as static is easy. You can easily toggle the `Static` flag on for
    all purposes (navigation, lighting, culling, batching and so on), or you can use
    the dropdown to specifically select what you want. The toggle is found in the
    top-right corner of the inspector for the selected object(s). Look at this screenshot
    for a general idea of what you''re looking for:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要指出的是，您需要将场景中将被烘焙到NavMesh中的任何几何体标记为导航静态。您可能在其他地方遇到过这种情况，例如在Unity的光照映射系统中。将游戏对象设置为静态很容易。您可以轻松切换所有目的的`Static`标志（导航、光照、剔除、批处理等），或者您可以使用下拉菜单来具体选择您想要的内容。切换按钮位于所选对象（s）检查器的右上角。查看以下截图以了解您要寻找的一般概念：
- en: '![](img/0161c6b5-9d49-441d-95d0-2ae159fb52bf.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0161c6b5-9d49-441d-95d0-2ae159fb52bf.png)'
- en: The Navigation Static property
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 导航静态属性
- en: You can do this on a per-object basis, or, if you have a nested hierarchy of
    game objects in your hierarchy, you can apply the setting to the parent and Unity
    will prompt you to apply it to all children.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按对象逐个进行此操作，或者，如果您在层次结构中有嵌套的游戏对象层次结构，您可以将设置应用于父对象，Unity将提示您将其应用于所有子对象。
- en: Baking the navigation mesh
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 烘焙导航网格
- en: The navigation settings for the navigation mesh are applied via the Navigation
    window on a scene-wide basis. You can open the window by navigating to **Window**
    | Navigation in the menu bar. Like any other window, you can detach it to be free-floating,
    or you can dock it. Our screenshots show it docked as a tab next to the hierarchy,
    but you can place this window anywhere you please.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 导航网格的导航设置是通过导航窗口在场景范围内应用的。您可以通过菜单栏中的**窗口** | 导航来打开此窗口。像任何其他窗口一样，您可以将其分离为自由浮动，或者将其停靠。我们的截图显示它停靠在层次结构旁边的选项卡中，但您可以将此窗口放置在任何您想要的位置。
- en: 'With the window open, you''ll notice four separate tabs. It''ll look something
    like this screenshot:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口打开后，您会注意到四个独立的选项卡。它看起来可能像以下截图：
- en: '![](img/68e75312-5685-42a9-96e3-b01c3f0626d0.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/68e75312-5685-42a9-96e3-b01c3f0626d0.png)'
- en: The Navigation window
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 导航窗口
- en: In our case, the preceding screenshot shows the Bake tab selected, but your
    editor might have one of the other tabs selected by default.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，前面的截图显示了已选择“烘焙”选项卡，但你的编辑器可能默认选择了其他选项卡之一。
- en: 'Let''s take a look at each tab, starting from the left and working our way
    to the right, starting with the Agents tab, which looks like the following screenshot:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看每个选项卡，从左侧开始，向右工作，从以下截图所示的“代理”选项卡开始：
- en: '![](img/a779bdea-6e25-4b36-9b20-3755c36c7b83.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/a779bdea-6e25-4b36-9b20-3755c36c7b83.png)'
- en: The Agents tab
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 代理标签页
- en: 'If you''re working on a different project, you may find that some of these
    settings are different than what we set them to in the sample project from which
    the preceding screenshot was taken. At the top of the tab, you can see a list
    where you can add additional agent types by pressing the "+" button. You can remove
    any of these additional agents by selecting it and pressing the "-" button. The
    window provides a nice visual of what the various settings do as you tweak them.
    Let''s take a look at what each setting does:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理不同的项目，你可能会发现其中一些设置与我们从先前的截图所用的示例项目中设置的设置不同。在标签页的顶部，你可以看到一个列表，你可以通过按“+”按钮添加额外的代理类型。你可以通过选择并按“-”按钮来移除任何这些额外的代理。窗口提供了一个很好的视觉，展示了当你调整这些设置时各种设置的作用。让我们看看每个设置的作用：
- en: '**Name**: The name of the agent type to be displayed in the Agent Types dropdown.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**: 要在代理类型下拉列表中显示的代理类型的名称。'
- en: '**Radius**: Think of it as the agent''s "personal space". Agents will try to
    avoid getting too cozy with other agents based on this value, as it uses it for
    avoidance.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半径**: 可以将其视为代理的“个人空间”。代理将根据此值尝试避免与其他代理过于亲近，因为它用它来进行回避。'
- en: '**Height**: As you may have guessed, it dictates the height of the agent, which
    it can use for vertical avoidance (passing under things, for example).'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高度**: 如你所猜，它决定了代理的高度，它可以用于垂直回避（例如，穿过东西）。'
- en: '**Step Height**: This value determines how high of an obstacle the agent can
    climb over.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步高**: 此值决定了代理可以爬越的障碍物的高度。'
- en: '**Max Slope**: As we''ll see in the coming section, this value determines the
    max angle up which an agent can climb. This can be used to make steep areas of
    the map inaccessible to the agent.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大坡度**: 正如我们将在下一节中看到的，此值决定了代理可以爬升的最大角度。这可以用来使地图上的陡峭区域对代理不可达。'
- en: 'Next, we have the Areas tab, which looks like the following screenshot:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有“区域”标签页，它看起来如下截图所示：
- en: '![](img/3b31fe55-c3a0-472e-87cd-78a44d7518d2.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/3b31fe55-c3a0-472e-87cd-78a44d7518d2.png)'
- en: 'As you can see in the preceding screenshot, Unity provides some default area
    types that cannot be edited: Walkable, Not Walkable, and Jump. In addition to
    naming and creating new areas, you can assign default costs to these areas.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在先前的截图中所见，Unity提供了一些默认的区域类型，这些类型不能被编辑：可通行、不可通行和跳跃。除了命名和创建新的区域外，你还可以将这些区域的默认成本分配给它们。
- en: 'Areas serve two purposes: making areas accessible or inaccessible per agent,
    and marking areas as less desirable in terms of navigation cost. For example,
    you may have an RPG where demon enemies cannot enter areas marked as "holy ground."
    You could also have areas of your map marked something like "marsh" or "swamp,"
    which your agent could avoid based on the cost.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 区域有两个作用：根据代理使区域可访问或不可访问，以及将区域标记为导航成本较低。例如，你可能有RPG游戏，其中恶魔敌人不能进入标记为“圣地”的区域。你也可以在你的地图上标记一些像“沼泽”或“湿地”的区域，你的代理可以根据成本避免这些区域。
- en: 'The third tab, Bake, is probably the most important. It allows you to create
    the actual NavMesh for your scene. You''ll recognize some of the settings. The
    Bake tab looks like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个标签页“烘焙”可能是最重要的。它允许你为场景创建实际的NavMesh。你会认出一些设置。烘焙标签页看起来如下：
- en: '![](img/f9482433-91a8-4304-89d5-7925486b76e0.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/f9482433-91a8-4304-89d5-7925486b76e0.png)'
- en: The Bake tab
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 烘焙标签页
- en: The agent size settings in this tab dictate how agents interact with the environment,
    whereas the settings in the Agents tab dictate how they interact with other agents
    and moving objects, but they control the same parameters, so we'll skip those
    here. The Drop Height and Jump Distance control how far an agent can "jump" to
    reach a portion of the NavMesh that is not directly connected to the one the agent
    is currently on. We'll go over this in more detail up ahead, so don't sweat it
    if you're not quite sure what that means yet.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在此标签页中的代理大小设置决定了代理如何与环境交互，而代理标签页中的设置决定了它们如何与其他代理和移动对象交互，但它们控制相同的参数，所以我们在这里将跳过这些设置。下落高度和跳跃距离控制代理可以“跳跃”多远以到达与当前所在区域不直接相连的NavMesh部分。我们将在稍后详细介绍这一点，所以如果你现在还不完全清楚这意味着什么，请不要担心。
- en: There are also some advanced settings that are generally collapsed by default.
    Simply click the drop-down triangle by the Advanced heading to unfold these options.
    You can think of the Manual Voxel Size setting as the "quality" setting. The smaller
    the size, the more detail you can capture in the mesh. The Min Region Area is
    used to skip baking platforms or surfaces below the given threshold. The Height
    Mesh gives you more detailed vertical data when baking the mesh. For example,
    it will help preserve the proper placement of your agent when climbing up stairs.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些默认情况下通常折叠的高级设置。只需单击“高级”标题旁边的下拉三角形即可展开这些选项。您可以将“手动体素大小”设置视为“质量”设置。大小越小，您可以在网格中捕获的细节就越多。最小区域面积用于跳过低于给定阈值的平台或表面烘焙。高度网格在烘焙网格时提供更详细的垂直数据。例如，它将帮助在爬楼梯时保持代理的正确位置。
- en: 'The Clear button will clear any NavMesh data for the scene, and the Bake button
    will create the mesh for your scene. The process is fairly fast. As long as you
    have the window selected, you''ll be able to see the NavMesh generated by the
    Bake button in your scene view. Go ahead and hit the Bake button to see the results.
    In our sample scene, you should end up with something that looks like the following
    screenshot:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 清除按钮将清除场景中的任何NavMesh数据，而烘焙按钮将为您的场景创建网格。此过程相当快。只要您选择了窗口，您就可以在场景视图中看到由烘焙按钮生成的NavMesh。请点击烘焙按钮以查看结果。在我们的示例场景中，您应该得到以下截图所示的内容：
- en: '![](img/635a02ba-4a0d-4ee6-9277-a65afb81f0f7.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/635a02ba-4a0d-4ee6-9277-a65afb81f0f7.png)'
- en: 'The blue areas represent the NavMesh. We''ll revisit this up ahead. For now,
    let''s move on to the final tab, the Object tab, which looks like the following
    screenshot:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色区域代表NavMesh。我们稍后会再次讨论这个问题。现在，让我们继续到最后一个标签页，即对象标签页，它看起来如下截图所示：
- en: '![](img/c5ffe1e0-94f7-4695-8040-59605f694720.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c5ffe1e0-94f7-4695-8040-59605f694720.png)'
- en: The three buttons pictured in the preceding screenshot, All, Mesh Renderers,
    and Terrains, act as filters for your scene. These are helpful when working in
    complex scenes with lots of objects in the hierarchy. Selecting an option will
    filter out that type in your hierarchy to make them easier to select. You can
    use this when digging through your scene looking for objects to mark as navigation
    static.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中所显示的三个按钮，全部、网格渲染器和地形，是您场景的过滤器。当在具有大量对象的复杂场景中工作时，这些非常有用。选择一个选项将过滤出您层次结构中的该类型，以便更容易选择。您可以使用此功能在场景中查找要标记为导航静态的对象。
- en: Using the NavMesh agent
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NavMesh代理
- en: 'Now that we have our scene set up with a NavMesh, we need a way for our agent
    to use this information. Luckily for us, Unity provides a Nav Mesh Agent component
    we can throw onto our character. The sample scene has a game object named `Tank` with
    the component already attached to it. Take a look at it in the hierarchy, and
    it should look like the following screenshot:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了带有NavMesh的场景，我们需要让我们的代理使用这些信息。幸运的是，Unity提供了一个可以附加到我们的角色上的Nav Mesh Agent组件。示例场景中有一个名为`Tank`的游戏对象，该组件已经附加到它上面。在层次结构中查看它，应该看起来像以下截图：
- en: '![](img/499a8c22-cba6-4488-bef5-93251b35904d.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/499a8c22-cba6-4488-bef5-93251b35904d.png)'
- en: 'There are quite a few settings here, and we won''t go over all of them, since
    they''re fairly self-explanatory and you can find the full descriptions in the
    official Unity documentation, but let''s point out a few key things:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有相当多的设置，我们不会全部介绍，因为它们相当直观，您可以在官方Unity文档中找到完整的描述，但让我们指出一些关键点：
- en: 'Agent Type: Remember the Agents tab in the Navigation window? The agent types
    you define there will be selectable here.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理类型：还记得导航窗口中的代理标签吗？您在那里定义的代理类型将在这里可选择。
- en: 'Auto Traverse Off Mesh Link: We''ll get into Off Mesh Links up ahead, but this
    setting allows the agent to automatically use that feature.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动穿越离网链接：我们稍后会详细介绍离网链接，但此设置允许代理自动使用该功能。
- en: 'Area Mask: The areas you set up in the Areas tab of the Navigation window will
    be selectable here.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区域遮罩：您在导航窗口的区域标签页中设置的区域将在这里可选择。
- en: 'That''s it. The component handles 90% of the heavy lifting for you: placement
    on the path, pathfinding, obstacle avoidance, and so on. The only thing you need
    to do is provide the agent with a target destination. Let''s look at that next.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。该组件为您处理了90%的繁重工作：路径放置、路径查找、障碍物避免等。您唯一需要做的是为代理提供一个目标目的地。让我们看看下一个。
- en: Setting a destination
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置目的地
- en: Now that we've set up our AI agent, we need a way to tell it where to go. Our
    sample project provides a script named `Target.cs` that does just that.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了我们的AI代理，我们需要一种方法来告诉它去哪里。我们的示例项目提供了一个名为`Target.cs`的脚本，它正是这样做的。
- en: 'This is a simple class that does three things:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的类，它做了三件事：
- en: Shoots a ray from the camera origin to the mouse world position using a ray
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用射线从相机原点射向鼠标世界位置
- en: Updates the marker position
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新标记位置
- en: Updates the destination property of all the NavMesh agents
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新所有导航网格代理的目标属性
- en: 'The code is fairly straightforward. The entire class looks like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当简单。整个类看起来是这样的：
- en: '[PRE37]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There are a few things happening here. In the `Start` method, we initialize
    our `navAgents` array by using the `FindObjectsOfType()` method.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了一些事情。在`Start`方法中，我们使用`FindObjectsOfType()`方法初始化我们的`navAgents`数组。
- en: The `UpdateTargets()` method runs through our `navAgents` array and sets their
    target destination to the given `Vector3`. This is really the key to making it
    work. You can use any mechanism you wish to actually get the target destination,
    and all you need to do to get the agent to move there is set the `NavMeshAgent.destination`
    field; the agent will do the rest.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateTargets()`方法遍历我们的`navAgents`数组，并将它们的目标目的地设置为给定的`Vector3`。这实际上是使其工作的关键。你可以使用任何你想要的机制来获取目标目的地，而你需要做的只是设置`NavMeshAgent.destination`字段；代理会完成剩下的工作。'
- en: Our sample uses a click-to-move approach, so whenever the player clicks, we
    shoot a ray from the camera into the world towards the mouse cursor, and if we
    hit something, we assign that hit position as the new `targetPosition` for the
    agent. We also set the target marker accordingly for easy in-game visualization
    of the target destination.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例使用点击移动的方法，所以每当玩家点击时，我们就从相机向世界中的鼠标光标发射一条射线，如果击中了什么，我们就将击中的位置分配给代理的新`targetPosition`。我们还相应地设置了目标标记，以便在游戏中轻松可视化目标目的地。
- en: To test it out, make sure you baked the NavMesh as described in the previous
    section, then enter play mode, and select any area on the map. If you go click-happy,
    you may notice there are some areas your agent *can't *reach—the top of the red
    cubes, the top-most platform, and the platform towards the bottom of the screen.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试它，请确保你已按照上一节所述烘焙了导航网格，然后进入游戏模式，并选择地图上的任何区域。如果你点击得过于频繁，可能会注意到有些区域你的代理**无法**到达——红色立方体的顶部，最上面的平台，以及屏幕底部的平台。
- en: 'In the case of the red cubes, they''re too far up. The ramp leading up to the
    top-most platform is too steep, as per our Max Slope settings, and the agent can''t
    climb up to it. The following screenshots illustrate how the Max Slope settings
    affect the NavMesh:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在红色立方体的例子中，它们太高了。通往最上面平台的斜坡太陡峭，根据我们的最大坡度设置，代理无法爬上去。以下截图说明了最大坡度设置如何影响导航网格：
- en: '![](img/904da452-21f6-4b35-a585-2345c9ba07c3.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/904da452-21f6-4b35-a585-2345c9ba07c3.png)'
- en: NavMesh with the max slope value set to 45
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最大坡度设置为45的导航网格
- en: 'If you tweak the Max Slope to something like 51, then hit the Bake button again
    to re-bake the NavMesh, it will yield results like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将最大坡度调整到大约51，然后再次点击烘焙按钮重新烘焙导航网格，它将产生如下结果：
- en: '![](img/54e13722-f590-42e5-ba54-3183912d0e99.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/54e13722-f590-42e5-ba54-3183912d0e99.png)'
- en: NavMesh with the max slope value set to 51
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最大坡度设置为51的导航网格
- en: As you can see, you can tweak your level design to make entire areas inaccessible
    by foot with a simple value tweak. An example where this would be helpful is if
    you had a platform or ledge that you need a rope, ladder, or elevator to get to.
    Maybe even a special skill, such as the ability to climb? I'll let your imagination
    do the work and think of all the fun ways to use this.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以通过简单的数值调整来调整你的关卡设计，使整个区域无法步行进入。一个这样的例子是，如果你有一个平台或边缘，你需要绳子、梯子或电梯才能到达。也许甚至需要特殊技能，比如攀爬能力？我会让你的想象力去工作，想出所有有趣的用法。
- en: Making sense of Off Mesh Links
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解离网链接
- en: 'You may have noticed that our scene features two gaps. The first one is accessible
    to our agent, but the one near the bottom of the screen is too far away. This
    is not completely arbitrary. Unity''s **Off Mesh Links **effectively bridge the
    gap between segments of the NavMesh that are not connected. You can see these
    links in the editor, as shown in the next screenshot:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们的场景有两个缺口。第一个缺口我们的代理可以到达，但屏幕底部的那个太远了。这并不是完全随机的。Unity的**离网链接**有效地在未连接的导航网格段之间架起了桥梁。你可以在编辑器中看到这些链接，如下一张截图所示：
- en: '![](img/4693841c-e10a-4d94-af62-ffd22c91c00f.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4693841c-e10a-4d94-af62-ffd22c91c00f.png)'
- en: The blue circles with the connecting lines are links
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 带有连接线的蓝色圆圈是链接
- en: There are two ways that Unity can generate these links. The first we've already
    covered. Remember the Jump Distance value in the Bake tab of the Navigation window?
    Unity will automatically use that value to generate the links for us when baking
    the NavMesh. Try tweaking the value in our test scene to 5 and re-baking. Notice
    how, now, the platforms are linked? That's because the meshes are within the newly-specified
    threshold.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Unity可以以两种方式生成这些链接。第一种我们已经讨论过了。还记得导航窗口的烘焙选项卡中的跳跃距离值吗？当烘焙NavMesh时，Unity会自动使用该值为我们生成链接。尝试在我们的测试场景中将该值调整为5并重新烘焙。注意，现在平台是如何连接起来的？这是因为网格现在位于新指定的阈值内。
- en: 'Set the value back to 2 and re-bake. Now, let''s look at the second method.
    Create spheres that will be used to connect the two platforms. Place them roughly
    as shown in the following screenshot:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 将值恢复到2并重新烘焙。现在，让我们看看第二种方法。创建将用于连接两个平台的球体。将它们大致放置如下面的截图所示：
- en: '![](img/afb8605c-b1bf-415e-bd12-df06565ec324.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/afb8605c-b1bf-415e-bd12-df06565ec324.png)'
- en: 'You may already see where this is going, but let''s walk through the process
    to get these connected. In this case, I''ve named the sphere on the right `start`,
    and the sphere on the left `end`. You''ll see why in a second. Next up, add the
    Off Mesh Link component on the platform on the right (relative to the preceding
    screenshot). You''ll notice the component has `start` and `end` fields. As you
    may have guessed, we''re going to drop the spheres we created earlier into their
    respective slots—the start sphere in the `start` field, and the end sphere in
    the `end` field. Our inspector will look something like this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经看到了这里的发展方向，但让我们通过这个过程来了解如何连接这些。在这种情况下，我将右侧的球体命名为`start`，左侧的球体命名为`end`。您将在下一秒看到原因。接下来，在右侧的平台（相对于前面的截图）上添加Off
    Mesh Link组件。您会注意到组件有`start`和`end`字段。如您所猜，我们将把之前创建的球体放入相应的槽中——将起始球体放入`start`字段，将结束球体放入`end`字段。我们的检查器将看起来像这样：
- en: '![](img/fc74506a-1d1a-4785-88a9-5ccf1d71e15d.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fc74506a-1d1a-4785-88a9-5ccf1d71e15d.png)'
- en: The Cost Override value kicks in when you set it to a positive number. It will
    apply a cost multiplier to using this link, as opposed to, potentially, a more
    cost-effective route to the target.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将其设置为正数时，成本覆盖值开始起作用。它将对使用此链接应用成本乘数，而不是，可能的话，一条更经济的到达目标的路线。
- en: The Bi Directional value allows the agent to move in both directions when set
    to true. You can turn this off to create one-way links in your level design. The
    Activated value is just what it says. When set to false, the agent will ignore
    this link. You can turn it on and off to create gameplay scenarios where the player
    has to hit a switch to activate it, for example.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 双向值允许代理在设置为true时向两个方向移动。您可以将它关闭以在级别设计中创建单向链接。激活值正如其名。当设置为false时，代理将忽略此链接。您可以打开和关闭它以创建游戏场景，例如，玩家必须按下开关来激活它。
- en: 'You don''t have to re-bake to enable this link. Take a look at your NavMesh
    and you''ll see that it looks like the following screenshot:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您无需重新烘焙即可启用此链接。看看您的NavMesh，您会看到它看起来像以下截图：
- en: '![](img/20e91bab-332b-4d17-95f5-69100fbe091e.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/20e91bab-332b-4d17-95f5-69100fbe091e.png)'
- en: 'As you can see, the smaller gap is still automatically connected, and now we
    have a new link generated by our Off Mesh Link component between the two spheres.
    Enter play mode and click on the far platform, and, as expected, the agent can
    now navigate to the detached platform, as you can see in the following screenshot:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，较小的间隙仍然自动连接，现在我们在两个球体之间通过我们的Off Mesh Link组件生成了一个新的链接。进入游戏模式并点击远处的平台，正如预期的那样，代理现在可以导航到分离的平台，如下面的截图所示：
- en: '![](img/97ffd6be-d9c6-45ad-9478-ab8bff38fa9e.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/97ffd6be-d9c6-45ad-9478-ab8bff38fa9e.png)'
- en: In your own levels, you may need to tweak these settings to get the exact results
    you expect, but combining these features gives you a lot of power out-of-the-box.
    You can have a simple game up and running fairly quickly using Unity's NavMesh
    feature.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在您自己的级别中，您可能需要调整这些设置以获得您期望的确切结果，但结合这些功能，您将获得很多即插即用的功能。您可以使用Unity的NavMesh功能相当快地将一个简单的游戏运行起来。
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You have now navigated your way to the end of this chapter (pun unapologetically
    intended). From simple waypoints, to the efficient and fast A* algorithm, to Unity's
    own powerful and robust NavMesh system, we've added some important and flexible
    tools to your game-making toolbelt. Not only do these concepts play well with
    each other, but they also work well with other systems we've already seen in this
    book, and we'll explore in those next few chapters.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经顺利地导航到了本章的结尾（无耻地开个玩笑）。从简单的航点，到高效快速的A*算法，再到Unity自带的强大且稳健的NavMesh系统，我们已经为你制作游戏工具箱添加了一些重要且灵活的工具。这些概念不仅彼此兼容，而且与本书中我们已经看到的其他系统也配合得很好，我们将在接下来的几章中对其进行探讨。
- en: In the next chapter,we'll start to look at how we can create efficient and realistic
    simulations for groups of agents that need to move in unison. Let's get to it!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始探讨如何为需要统一移动的多个智能体创建高效且逼真的模拟。让我们开始吧！
