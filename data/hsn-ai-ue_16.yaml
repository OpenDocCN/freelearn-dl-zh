- en: Debugging Methods for AI - The Gameplay Debugger
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工智能调试方法 - 游戏调试器
- en: In this chapter, we are going to face a powerful debugging tool. It is so powerful
    that it was worth having a separate chapter for it, and it is the best friend
    of any AI developer within Unreal. Actually, it's the best friend of any developer
    in Unreal, since it can have different uses, especially when it comes to covering
    *Gameplay* (although it has been mainly used for AI so far).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将面对一个强大的调试工具。它如此强大，以至于为它单独设立一章是值得的，它是任何Unreal引擎中人工智能开发者的最佳拍档。实际上，它是任何Unreal开发者的最佳拍档，因为它可以有不同的用途，尤其是在涉及**游戏**方面（尽管到目前为止它主要被用于人工智能）。
- en: We are going to explore the ***Gameplay Debugger*** (as it is referred to in
    the official documentation), but sometimes people or books use ***Visual Debugger***
    to refer to it. I presume that the reason it is called *Gameplay Debugger* is
    due to the fact that the tool has a **great level of abstraction to debug any
    gameplay aspects (including AI)**. However, the built-in categories of the *Gameplay
    Debugger* are AI-related, and this is the reason why it is included in this book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索**游戏调试器**（正如官方文档中所述），但有时人们或书籍使用**视觉调试器**来指代它。我认为它被称为**游戏调试器**的原因是因为这个工具具有**高度抽象化**来调试任何游戏方面（包括人工智能）。然而，**游戏调试器**的内置类别与人工智能相关，这也是它被包含在这本书中的原因。
- en: Do not confuse the Visual Logger with the Visual Debugger, which is the ***Gameplay
    Debugger***!!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将视觉记录器与**游戏调试器**混淆，后者是**视觉调试器**！！
- en: 'In particular, we are going to cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将特别介绍以下主题：
- en: Explore the ***anatomy of the Gameplay Debugger***
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索**游戏调试器**的解剖结构
- en: Learn about the ***Extensions and Categories*** of the Gameplay Debugger
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解游戏调试器的**扩展和类别**
- en: Understand what kind of ***information each Category displays***
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解每个**类别**显示的信息类型
- en: Create a custom module by ***creating a new plugin*** (we need this to extend
    the *Gameplay Debugger*)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过**创建一个新的插件**来创建自定义模块（我们需要这个来扩展**游戏调试器**）
- en: '***Extend the Gameplay Debugger*** by adding a new ***Category***'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加新的**类别**来**扩展游戏调试器**
- en: '***Extend the Gameplay Debugger*** by adding a new ***Extension***'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加新的**扩展**来**扩展游戏调试器**
- en: This is the last technical part of this book before the last chapter, in which
    we will explore *Game AI* in broader terms. Thus, without further ado, let's dive
    in!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书最后一章之前的最后一个技术部分，我们将更广泛地探讨**游戏人工智能**。因此，无需多言，让我们直接进入正题！
- en: The anatomy of the Gameplay Debugger
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**游戏调试器**的解剖结构'
- en: While the game is running, you can open the ***Gameplay Debugger*** (or *Visual
    Debugger*) by pressing the " ' " (apostrophe) key.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏运行时，你可以通过按“'”（撇号）键打开**游戏调试器**（或**视觉调试器**）。
- en: All the key bindings of the visual debugger can be changed/customized. We will
    see how we can change them in the *Project Settings* section, later in this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有视觉调试器的快捷键都可以更改/自定义。我们将在本章后面的**项目设置**部分看到如何更改它们。
- en: 'The ***Gameplay Debugger*** is divided into two: ***Extensions*** and ***Categories***:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**游戏调试器**分为两部分：**扩展**和**类别**：'
- en: '***Extensions*** are specific key bindings (toggles) that trigger a specific
    function.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展**是触发特定功能的特定快捷键（切换）。'
- en: '***Categories*** are *toggleable* pieces of information that appear on the
    screen (and also in 3D spaces) in regards to a specific system'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类别**是可**切换**的信息块，它出现在屏幕上（以及3D空间中）与特定系统相关'
- en: 'On-screen, the ***Gameplay Debugger*** is visually divided into two sections:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上，**游戏调试器**在视觉上分为两部分：
- en: '![](img/eac0d6f8-2ba6-4375-a614-4748009c59fa.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eac0d6f8-2ba6-4375-a614-4748009c59fa.png)'
- en: 'The top section is the control section and shows which options are available.
    In particular, it displays which *Extensions* are available and highlights the
    active *Categories* that are displayed in the bottom part:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部部分是控制部分，显示哪些选项可用。特别是，它显示了哪些**扩展**可用，并突出显示底部部分显示的活动的**类别**：
- en: '![](img/6273680f-db3c-4af6-b1d0-a19bdbb454fe.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6273680f-db3c-4af6-b1d0-a19bdbb454fe.png)'
- en: 'The bottom section, instead, displays different information for each of the
    selected *Categories. *Here is an example with some Categories showing:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 而底部部分，则显示每个选定**类别**的不同信息。以下是一些**类别**的示例：
- en: '![](img/eaf51a68-f423-4c6a-820c-6f120fac26c0.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eaf51a68-f423-4c6a-820c-6f120fac26c0.png)'
- en: Gameplay Debugger Extensions
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏调试器扩展
- en: 'The *Gameplay Debugger* has only two default ***Extensions*** and a built-in
    one, as you can see in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在以下屏幕截图中所见，**游戏调试器**只有两个默认**扩展**和一个内置扩展：
- en: '![](img/ae6b7938-cc4c-4fe4-b391-975943aa49ed.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ae6b7938-cc4c-4fe4-b391-975943aa49ed.png)'
- en: 'The two default Extensions and a built-in one are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为默认扩展和内置扩展：
- en: The ***Spectator Extension*** allows you (at runtime, while the game is playing)
    to detach the control from the *Player Character* and control a *Spectator Pawn* so
    that you are free to fly over the level and have an external point of view. At
    any time, you can gain back control of the *Player Character* by toggling the *Spectator
    Extension* or by closing the *Gameplay Debugger*. The default key to toggle the
    *Spectator Extension* is the *Tab* key.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观众扩展**允许你在游戏运行时（游戏进行时）将控制权从**玩家角色**分离出来，并控制一个**观众角色**，这样你就可以自由地在关卡上飞行并拥有外部视角。任何时候，你都可以通过切换**观众扩展**或关闭**游戏调试器**来重新获得对**玩家角色**的控制权。切换**观众扩展**的默认键是**Tab**键。'
- en: The ***HUD Extensions*** allows you to toggle the *HUD* on and off (in particular,
    the *HUD* class contained in the *Game Mode* instance). The default key to toggle
    the *HUD Extension* is *Ctrl + Tilde*.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HUD扩展**允许你切换**HUD**的开启和关闭（特别是包含在**游戏模式**实例中的**HUD**类）。切换**HUD扩展**的默认键是*Ctrl
    + Tilde*。'
- en: '***DebugMessages*** is the *built-in Extension*, and as its name suggests,
    it toggles the debug messages. The default key is *Ctrl* + *Tab*.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试消息**是**内置扩展**，正如其名称所示，它切换调试消息。默认键是*Ctrl* + *Tab*。'
- en: Gameplay Debugger categories
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏调试器类别
- en: The *Gameplay Debugger* is divided into different categories, which can be enabled
    and disabled (with the use of the *Keypad (or Numpad)*, not just the numbers of
    your keyboard).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**游戏调试器**被分为不同的类别，可以通过使用**键盘（或数字键盘）**来启用和禁用（而不仅仅是键盘上的数字）。'
- en: If you don't have a *Keypad/Numpad* (e.g. you are using a small laptop), later
    in this chapter, you will find the settings of the *Gameplay Debugger* in which
    you can change the key binding to something that your keyboard has.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有**键盘/数字键盘**（例如，你正在使用小型笔记本电脑），在本章的后面，你将找到**游戏调试器**的设置，你可以更改键绑定，使其与你的键盘相匹配。
- en: The number next to the ***Category*** indicates its default position (and the
    number to press on the *Keypad* to activate it). However, this can be changed
    in the settings later.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**类别**旁边的数字表示其默认位置（以及需要在**键盘**上按下的数字以激活它）。然而，这可以在设置中稍后更改。'
- en: To explore the *Categories*, I have created a simple test map, in which there
    should be a bit of everything so that we can see all the *Gameplay Debugger *categories in
    action. This test map is available in the project files associated with this book.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索**类别**，我创建了一个简单的测试地图，其中应该包含一些内容，这样我们就可以看到所有**游戏调试器**类别在实际操作中的表现。这个测试地图包含在本书的关联项目文件中。
- en: Category 0 – Navmesh
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类别 0 – 导航网格
- en: The first category is ***Navmesh***, which is assigned to the "***0***" key
    by default.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个类别是**导航网格**，默认分配给“***0***”键。
- en: Once you toggle it, you will be able to see the ***Navmesh*** directly on the
    map – simple as that. This is very useful when you need to check the *Nav Mesh*
    in real time, especially if you have dynamic obstacles so that the *Nav Mesh*
    is rebuilt at runtime.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦切换，你将能够直接在地图上看到**导航网格**——就这么简单。当你需要实时检查**导航网格**时，这非常有用，尤其是如果你有动态障碍物，那么**导航网格**将在运行时重建。
- en: 'This is how it appears when this category is enabled:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当此类别启用时，它看起来是这样的：
- en: '![](img/759cd92d-e20d-4238-bcb6-314cd2861dd9.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/759cd92d-e20d-4238-bcb6-314cd2861dd9.png)'
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出截图。其他（模糊显示）的信息在这里并不重要
- en: Category 1 – AI
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类别 1 – AI
- en: This category, once enabled, shows a lot of information about the selected AI. By
    default, it is assign to the "***1***" key.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此类别一旦启用，就会显示有关所选AI的大量信息。默认情况下，它分配给“***1***”键。
- en: If no actor is selected, no information will be shown in this category. However,
    it will highlight the available AIs with their affiliation (in a 3D space).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有选择演员，这个类别将不会显示任何信息。然而，它将突出显示具有其隶属关系的可用AI（在3D空间中）。
- en: 'When the category is toggled (and a *Debug Actor* is selected), it looks as
    follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当切换类别（并选择**调试演员**）时，它看起来如下：
- en: '![](img/d2c2b600-3516-48e3-938f-567cbab90595.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d2c2b600-3516-48e3-938f-567cbab90595.png)'
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出截图。其他（模糊显示）的信息在这里并不重要
- en: In this category, all of the AIs on the map are displayed with their affiliation
    (in a 3D space), and the selected *Debug Actor* also has the name of the controller
    (always in a 3D space). However, the information that's displayed directly on
    the screen is of the single *Debug Actor*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在此类别中，地图上的所有AI及其所属关系（在3D空间中）都会显示出来，并且选定的**调试演员**也显示了控制器的名称（始终在3D空间中）。然而，直接显示在屏幕上的信息是单个**调试演员**的信息。
- en: 'The following is the kind of information that this category displays (with
    a close-up of *Categories Information*):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该类别显示的信息类型（带有**类别信息**的特写）：
- en: '![](img/6784d451-7bc6-4e6f-a208-53f93dbb998b.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6784d451-7bc6-4e6f-a208-53f93dbb998b.png)'
- en: '**Controller Name**: This displays the name of the *AI Controller* that possesses
    this *Pawn*.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器名称**：此部分显示拥有此**Pawn**的**AI控制器**的名称。'
- en: '**Pawn Name**: This displays the name of the *Pawn* that is currently possessed
    by the *AI*.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pawn名称**：此部分显示当前被**AI**拥有的**Pawn**的名称。'
- en: '**Movement Mode**: If there is a *Character Movement Component* attached to
    the Pawn, then this displays the current movement mode (e.g. walking, running,
    swimming, flying, falling, etc…)'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动模式**：如果Pawn附加了**角色移动组件**，则此部分显示当前的移动模式（例如行走、跑步、游泳、飞行、下落等…）'
- en: '**Base**: If there is a *Character Movement Component* attached to the Pawn,
    this displays on the base that the character is grounded on. In the case of walking
    or running, this is the mesh of the piece of floor where the AI is currently walking
    or running. In the case of falling, this is "*none*".'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础**：如果Pawn附加了**角色移动组件**，则此部分显示角色站立的基础。在行走或跑步的情况下，这是AI当前行走或跑步的地面网格。在下落的情况下，这是“*无*”。'
- en: '**NavData**: This displays that *NavData* that the AI is currently using. Most
    likely, the value will be "*Default*", unless you gave a specific *NavData* to
    the AI character by using C++.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NavData**：此部分显示AI当前正在使用的**NavData**。最可能的情况是，值将是“*默认*”，除非您通过C++为AI角色指定了特定的**NavData**。'
- en: '**Path following**: This displays the state of the Path to follow when the
    AI character is moving. Information such as the *Dot-Product*, the *2D-Distance*,
    and the *Z**-Distance* are displayed as well. Here is an example when the character
    is moving:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路径跟随**：当AI角色移动时，此部分显示要跟随的路径的状态。还会显示诸如**点积**、**2D距离**和**Z距离**等信息。以下是一个角色移动时的示例：'
- en: '![](img/88fd83f8-f69e-4d22-b63d-ce588b0fa5e2.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88fd83f8-f69e-4d22-b63d-ce588b0fa5e2.png)'
- en: '**Behavior**: This indicates whether there is a behavior running or not (e.g.
    is a *Behavior Tree* running on this *AI Controller*?).'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为**：此部分指示是否有行为正在运行（例如，此**AI控制器**上是否正在运行**行为树**？）。'
- en: '**Tree**: This indicates which *Behavior Tree* the AI is currently running
    (if a *Behavior* is running).'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**树**：此部分指示AI当前正在运行的**行为树**（如果正在运行行为）。'
- en: '**Active Task**: This indicates which *Behavior Tree Task* is currently executing,
    along with the *Task number* (the number that that Task is ordered in the Tree).'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活动任务**：此部分指示当前正在执行的**行为树任务**，以及**任务编号**（该任务在树中的顺序编号）。'
- en: For more information aregarding the current task in the *Behavior Tree Category*,
    see the next section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有关**行为树类别**中当前任务的更多信息，请参阅下一节。
- en: '**Gameplay Tasks**: This displays how many *Gameplay Tasks* are currently assigned
    to this AI.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏任务**：此部分显示当前分配给此AI的**游戏任务**数量。'
- en: '**Montage**: This displays the current montage that the Character is playing
    (if any).'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蒙太奇**：此部分显示角色当前正在播放的**蒙太奇**（如果有的话）。'
- en: Although we didn't touch on this topic in this book, syncing AI actions with
    Animations is an in-between land for AI programmers and Animators.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在这本书中没有涉及这个话题，但同步AI动作与动画是AI程序员和动画师之间的中间地带。
- en: 'It is worth mentioning that if the AI is moving, even if the *Navmesh* category
    is not toggling, it will show the piece of the *Nav Mesh* that the AI is currently
    using to navigate, as shown in the following screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，如果AI正在移动，即使**导航网格**类别没有切换，它也会显示AI当前用于导航的**导航网格**的一部分，如下面的截图所示：
- en: '![](img/99c4e67d-eb87-4eb6-98d5-63dbf3f82bdd.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99c4e67d-eb87-4eb6-98d5-63dbf3f82bdd.png)'
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出截图。其他（模糊）信息在此处不重要。
- en: Category 2 – Behavior Tree
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类别2 – **行为树**
- en: This category displays information about the ***Behavior Tree*** that's currently
    running on the AI. By default, it is assigned to the "***2***" key.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此类别显示关于当前正在AI上运行的***行为树***的信息。默认情况下，它被分配给“***2***”键。
- en: If no *Behavior Tree* is running, this section will not display anything.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有运行 *行为树*，则此部分将不会显示任何内容。
- en: 'When activated, the ***Behavior Tree Category*** looks as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当激活时，***行为树分类*** 看起来如下：
- en: '![](img/0c165e2c-858c-41a2-9391-d541ced483d7.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0c165e2c-858c-41a2-9391-d541ced483d7.png)'
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一张输出截图。其他（模糊处理）的信息在这里并不重要
- en: 'This category only displays information on the screen (so nothing in the 3D
    space). In particular, it shows the following information on the left-hand side:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分类仅显示屏幕上的信息（所以在 3D 空间中没有显示）。特别是，它在左侧显示了以下信息：
- en: '![](img/14c31c9a-95cf-42be-84e6-45afbc491993.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/14c31c9a-95cf-42be-84e6-45afbc491993.png)'
- en: '**Brain Component**: This shows which kind of *Brain Component* the *AI Controller*
    is currently using, which will be of the *BTComponent* type.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大脑组件**：这显示了当前 AI 控制器正在使用的哪种类型的 *大脑组件*，它将是 *BTComponent* 类型。'
- en: Since Unreal is developed with *modularity* in mind, a *Brain Component* is
    anything that can hold AI logic. At the time of writing, the only built-in *Brain
    Component* is the *Behavior Tree* (*BTComponent*).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Unreal 是以 *模块化* 为目标开发的，所以任何可以包含 AI 逻辑的东西都可以称为 *大脑组件*。在撰写本文时，唯一的内置 *大脑组件*
    是 *行为树* (*BTComponent*)。
- en: '**Behavior Tree**: This is the name of the *Behavior Tree* that the AI is using.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为树**：这是 AI 正在使用的 *行为树* 的名称。'
- en: '**Task Tree**: After the *Behavior Tree* property, there is the all branch
    of the task that is currently being executed. This is the path from the root (with
    all the node names and their respective numbers) to the *Task* the AI is executing.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务树**：在 *行为树* 属性之后，显示了当前正在执行的所有任务分支。这是从根节点（包含所有节点名称及其相应的编号）到 AI 正在执行的任务的路径。'
- en: This is very useful when you need to understand why a determined tasks has been
    chosen, rather than another, by following the path along the tree.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有用，当你需要了解为什么选择了特定的任务，而不是另一个任务，可以通过沿着树路径跟踪来理解。
- en: 'On the right, instead, the name of the *Blackboard* asset that''s being used
    by the *Behavior Tree *is displayed. Below this, there''s the keys of the *Blackboard* that''s
    being used, along with their current value:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，相反，显示了正在使用的 *黑板* 资产的名称。在此之下，是正在使用的 *黑板* 的键及其当前值：
- en: '![](img/4b302a24-3789-4cc8-9c7e-abddea763d45.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4b302a24-3789-4cc8-9c7e-abddea763d45.png)'
- en: 'The following example shows just two *Blackboard keys*, *Destination* and *Self
    Actor*. Try to test the *Gameplay Debugger* in the *Designing Behavior Tree Project* to
    see more and get a better feeling of what it is going on, since you have been
    building these structures from scratch. Here is a sneak peek of what you will
    see:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了两个 *黑板键*，*目的地* 和 *Self Actor*。尝试在 *设计行为树项目* 中测试 *游戏调试器*，以查看更多内容并获得更好的感觉，因为你已经从零开始构建了这些结构。以下是你将看到的一瞥：
- en: '![](img/95f453a5-856d-478e-b700-c087d7dc1ba5.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/95f453a5-856d-478e-b700-c087d7dc1ba5.png)'
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一张输出截图。其他（模糊处理）的信息在这里并不重要
- en: Of course, this is very useful when you want to test that the right values in
    the *Blackboard* are set.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当你想要测试 *黑板* 中是否设置了正确的值时，这非常有用。
- en: 'Here is one more example, showing the character moving:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个更多示例，展示了角色移动的情况：
- en: '![](img/2e3c0028-6f79-4a16-b55e-c5d854738d36.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2e3c0028-6f79-4a16-b55e-c5d854738d36.png)'
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一张输出截图。其他（模糊处理）的信息在这里并不重要
- en: Category 3 – EQS
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分类 3 – EQS
- en: This category displays the ***Environmental Queries*** that the AI is currently
    performing. By default, it is assigned to the "***3***" key.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分类显示了 AI 当前正在执行的 ***环境查询***。默认情况下，它被分配到 "***3***" 键。
- en: If the AI is not performing any *Environment Query*, than this category will
    just show that the number of queries is zero.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 AI 没有执行任何 *环境查询*，那么这个分类将只显示查询数量为零。
- en: 'When the ***EQS Category*** is activated, we get the following output on-screen:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当 ***EQS 分类*** 被激活时，屏幕上会得到以下输出：
- en: '![](img/f803fa22-0174-4306-82c2-49b63ee1bcda.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f803fa22-0174-4306-82c2-49b63ee1bcda.png)'
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一张输出截图。其他（模糊处理）的信息在这里并不重要
- en: From the preceding screenshot, we can see that this *Category* highlights the
    different points that are generated by the query, along with their score. Depending
    on the *Run Mode* of the query, it is possible to see which of these points is
    the winner (it has the highest score and its color is a brighter green than the
    other colors).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从先前的截图中，我们可以看到这个*类别*突出了查询生成的不同点及其得分。根据查询的*运行模式*，可以看到哪个点是获胜者（它有最高的得分，其颜色比其他颜色更亮）。
- en: Furthermore, a red arrow on top of a point means that it has been selected (which
    means that it is the closest that you are looking at). This is useful because,
    in the information displayed on the side, it is possible to check at which place
    of the scoreboard that specific point has been ranked.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个点上面的红色箭头表示它已被选中（这意味着它是你正在查看的最近的一个点）。这很有用，因为在侧面的信息显示中，你可以检查这个特定的点在排行榜上的排名位置。
- en: 'On the side, you will find some extra information about the query:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在旁边，你可以找到关于查询的一些额外信息：
- en: '![](img/0e62bce3-9199-42b6-8a7b-84e5840f83f5.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e62bce3-9199-42b6-8a7b-84e5840f83f5.png)'
- en: 'In particular, the following information is shown:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，以下信息被显示：
- en: '***Queries***: This is the number of queries that the *Debug Actor* is running.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***查询***：这是*调试演员*正在运行的查询数量。'
- en: '***Query Name(s) and Run Mode***: This displays which *Query* has been (or
    currently is being) executed. Then, after an underscore, it displays the *Run
    Mode* (in the preceding screenshot, it is *Single Result*).'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***查询名称和运行模式***：这显示了哪个*查询*已被（或目前正在执行）。然后，在下划线之后，它显示了*运行模式*（在先前的截图中，它是*单个结果*）。'
- en: '***Time Stamp***: This is the timestamp of when the *Query* was executed, along
    with how long ago this occurred.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***时间戳***：这是*查询*被执行的时间戳，以及它发生的时间。'
- en: '***Options***: This displays which the *Generator* for the Query.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***选项***：这显示了查询的*生成器*。'
- en: '***Selected Item***: This displays the *position/rank* of the selected item
    in the scoreboard. In the preceding screenshot, the item we have selected is 11th
    on the scoreboard (from the full-screen screenshot, you can see that it has a
    score of *1.31*, against the winner point, which has a score of *2.00*). This
    is very useful for checking how the point you are looking at is ranked, since
    it gives you a quick idea of the relative score among the points.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***所选项目***：这显示了所选项目在排行榜中的*位置/排名*。在先前的截图中，我们选择的项目在排行榜上是第11位（从全屏截图可以看到，它的得分为*1.31*，而获胜点的得分为*2.00*）。这对于检查你正在查看的点是如何排名的非常有用，因为它能快速给出这些点之间相对分数的概念。'
- en: 'Keep in mind that when a point is ranked, ***the rank starts from zero***,
    and so the ***Winner Point is ranked 0th***. So, in the preceding screenshot,
    "*Selected Item: 11*" means that it is 11th on the scoreboard, but it is the 12th
    point in the list.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当一个点被排名时，***排名从零开始***，因此***获胜点排名为0***。所以，在先前的截图中，"*所选项目：11*"意味着它在排行榜上是第11位，但它是在列表中的第12个点。
- en: 'For your convenience, here is another example, in which the Selected Point
    is the Winner Point (notice that its rank is 0):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，这里还有一个例子，其中所选点是获胜点（注意它的排名是0）：
- en: '![](img/b522b6a7-9697-4c93-b3dd-399d46e2db8c.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b522b6a7-9697-4c93-b3dd-399d46e2db8c.png)'
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一张输出结果的截图。其他（被模糊处理）的信息在这里并不重要
- en: Category 4 – Perception
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类别 4 – 感知
- en: This category displays information regarding the *Perception* of the *AI agent*
    that has been selected. By default, it is assigned to the "***4***" key, that
    is, unless the "*NavGrid*" *Category* is enabled; in that case, the default key
    is "***5***".
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类别显示了关于所选*AI代理*的*感知*信息。默认情况下，它被分配给"***4***"键，也就是说，除非"*导航网格*"类别被启用；在这种情况下，默认键是"***5***"。
- en: This category doesn't show anything if no Actor has been selected.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有选择任何演员，这个类别不会显示任何内容。
- en: 'When activated, the ***Perception Category*** appears as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当激活时，***感知类别***显示如下：
- en: '![](img/2b5dc888-a378-4179-8091-90ebff80a652.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b5dc888-a378-4179-8091-90ebff80a652.png)'
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一张输出结果的截图。其他（被模糊处理）的信息在这里并不重要
- en: 'On-screen, this category displays all the senses that have been implemented,
    along with their debug colors. Then, each sense can show additional information,
    depending on the implementation of their `DescribeSelfToGameplayDebugger()` function.
    For instance, in the case of Sight, there is the debug colors for **RangeIn**
    and **RangeOut**, as shown in the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上，这个类别显示了所有已实现的感官，以及它们的调试颜色。然后，每个感官可以根据其`DescribeSelfToGameplayDebugger()`函数的实现显示额外的信息。例如，在视觉的情况下，有**RangeIn**和**RangeOut**的调试颜色，如下面的截图所示：
- en: '![](img/a4d34e3f-1add-42da-a61e-472c9db23f62.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a4d34e3f-1add-42da-a61e-472c9db23f62.png)'
- en: 'In the level, you will be able to see the stimuli of a given sense as a sphere
    (along with the name of the sense, the stimulus strength, and the age of the stimulus,
    which is zero when on sight). Then, there is a line connecting the AI Pawn to
    each of the *stimuli*, and a line connecting the single *stimulus* to the target
    (e.g. the *Player*) if the target is not on sight. This is how it appears in the
    case of Sight:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在关卡中，您将能够看到特定感官的刺激物以球形呈现（包括感官名称、刺激强度和刺激物的年龄，当为视觉时年龄为零）。然后，有一条线连接到每个*刺激物*，如果目标不在视线范围内，还有一条线连接到单个*刺激物*和目标（例如*玩家*）。这是在视觉情况下的显示方式：
- en: '![](img/80a36625-4a65-4ada-b8ec-c611589d9167.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/80a36625-4a65-4ada-b8ec-c611589d9167.png)'
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一张输出截图。其他（被模糊处理）的信息在这里并不重要。
- en: 'To show off how it appears when the target (e.g. the *Player*) is not in sight,
    and thus the *stimulus* has an age greater than zero and it is possible to see
    the black line connecting the *stimulus* to the target, here is another screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示当目标（例如*玩家*）不在视线范围内时的情况，因此*刺激物*的年龄大于零，并且可以看到连接*刺激物*到目标的黑色线条，这里还有另一张截图：
- en: '![](img/cfbf37ae-765e-4eea-ac49-d42aaaf832ae.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cfbf37ae-765e-4eea-ac49-d42aaaf832ae.png)'
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一张输出截图。其他（被模糊处理）的信息在这里并不重要。
- en: 'If we were to add the sense of *Hearing* as well, this is what it would look
    like:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还要添加*听觉*感官，这将是这样显示的：
- en: '![](img/efe1d48d-7a23-488e-9639-8bf79fd89551.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/efe1d48d-7a23-488e-9639-8bf79fd89551.png)'
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一张输出截图。其他（被模糊处理）的信息在这里并不重要。
- en: Please note that the *Hearing Sense* (in yellow) is displayed on a different
    level (z-axis) of the *Sight Sense*. As a result, even if we have the same value,
    like in the preceding screenshot where both have a range of 1500, they stack up
    nicely.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*听觉感官*（黄色）在*视觉感官*的不同级别（z轴）上显示。因此，即使我们具有相同的值，例如在前面的截图中，两者都有1500的范围，它们也会很好地叠加。
- en: 'Of course, the information on the side gives you more information about the
    debug colors that are being displayed in the game world:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，侧面的信息提供了更多关于在游戏世界中显示的调试颜色的信息：
- en: '![](img/a36caf58-f35a-4e1f-8a4d-5fbda4337fe1.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a36caf58-f35a-4e1f-8a4d-5fbda4337fe1.png)'
- en: The Nav Grid Category
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航网格类别
- en: Depending on your settings, you might have enabled the ***Nav Grid*** Category,
    which is different from the *NavMesh* *Category*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的设置，您可能已经启用了***导航网格***类别，这与*导航网格*类别不同。
- en: 'This *Category* should deal with grid movement, which we haven''t covered in
    this book. However, if you activate this *Category* in our example map, it will
    just show that the number of sources is equal to zero:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*类别*应该处理网格移动，这是我们在这本书中没有涉及到的。然而，如果您在我们的示例地图中激活这个*类别*，它只会显示源的数量为零：
- en: '![](img/03d08b2d-a625-4230-85f7-d5d07d986498.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/03d08b2d-a625-4230-85f7-d5d07d986498.png)'
- en: Multiple Categories on-screen
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 屏幕上的多个类别
- en: 'We have seen how each of the categories behave individually. However, just
    to be clear, it is possible to have as many categories as you like on display.
    This means that you can have multiple categories showing up at the same time.
    Actually, often, you will need to see more that one system at the same time:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了每个类别是如何单独表现的。然而，为了明确起见，您可以在显示上拥有尽可能多的类别。这意味着您可以同时显示多个类别。实际上，通常您需要同时看到多个系统：
- en: '![](img/0c225cd5-5cd2-472e-846a-2431722e573b.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0c225cd5-5cd2-472e-846a-2431722e573b.png)'
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一张输出截图。其他（被模糊处理）的信息在这里并不重要。
- en: One thing that I personally like about the *Gameplay Debugger* is that once
    you get the hang of it, even with so many *Categories* open, the information is
    not overwhelming the screen, and is nicely displayed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人非常喜欢 *Gameplay Debugger* 的一个地方是，一旦您掌握了它，即使有这么多 *Categories* 打开，信息也不会使屏幕显得拥挤，并且显示得很好。
- en: More Categories
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多类别
- en: Although it seems that we went through all the different *Categories*, we haven't.
    In fact, there are some extra *Gameplay Debugger Categories* built into the Engine,
    for instance, the ones related to *HTN Planner* or the *Ability System*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来我们已经走过了所有不同的 *Categories*，但实际上我们还没有。事实上，引擎中内置了一些额外的 *Gameplay Debugger
    Categories*，例如与 *HTN Planner* 或 *Ability System* 相关的类别。
- en: Unfortunately, they are outside the scope of this book, but you can search for
    them in C++. You can start your research by searching for ***GameplayDebuggerCategory***
    in the *Engine Source* to find out more about them.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，它们超出了本书的范围，但您可以在 C++ 中搜索它们。您可以通过在 *Engine Source* 中搜索 ***GameplayDebuggerCategory***
    来开始您的搜索，以了解更多相关信息。
- en: Gameplay Debugger settings
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gameplay Debugger 设置
- en: As we mentioned previously, it is possible to configure the *Gameplay Debugger*
    by changing its settings.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，您可以通过更改其设置来配置 *Gameplay Debugger*。
- en: 'If you navigate to the ***Project Settings***, it is possible to find a whole
    section dedicated to the *Gameplay Debugger*, as shown in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您导航到 ***Project Settings***，您可能会找到一个专门针对 *Gameplay Debugger* 的部分，如下面的截图所示：
- en: '![](img/8ad92e61-6ce9-4210-b806-483089824dfb.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ad92e61-6ce9-4210-b806-483089824dfb.png)'
- en: 'The ***Input*** tab allows you to override the default keys for opening and
    closing the *Gameplay Debugger* (the default is the " ''" apostrophe key) and
    for triggering the different categories (by default, the numbers from 0 to 9 on
    the *keypad/numpad*):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '***Input*** 标签允许您覆盖打开和关闭 *Gameplay Debugger*（默认是 " ''" 引号键）以及触发不同类别（默认为 *keypad/numpad*
    上的 0 到 9 的数字）的默认键：'
- en: '![](img/9233b8de-3eaa-4e05-be1d-2d6f3044e823.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9233b8de-3eaa-4e05-be1d-2d6f3044e823.png)'
- en: 'The ***Display*** tab allows you to define some padding on so that you can
    show information about the *Gameplay Debugger*. By doing this, you don''t have
    it attached to the screen. The default values are all *10*:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '***Display*** 标签允许您定义一些填充，以便您可以显示有关 *Gameplay Debugger* 的信息。通过这样做，您不需要将其附加到屏幕上。默认值都是
    *10*：'
- en: '![](img/a23ddea7-5951-4410-ba59-a9f82225a3d5.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a23ddea7-5951-4410-ba59-a9f82225a3d5.png)'
- en: 'The ***Add-Ons tab***,allows you to configure the single settings for both
    ***Categories*** (when a category is enabled by default, and which key/number
    it is associated with) and ***Extension*** (to override their input key):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '***Add-Ons tab*** 允许您为 ***Categories***（当类别默认启用时，以及它关联的键/数字）和 ***Extension***（覆盖它们的输入键）配置单个设置：'
- en: '![](img/30aa8ce0-bd0e-41ef-8c2c-27fb89871255.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30aa8ce0-bd0e-41ef-8c2c-27fb89871255.png)'
- en: A value of "-1" for a *Category* means that the *number/position/key* of the
    *Category* has been assigned by the Editor, since this *Category* doesn't have
    a "*preference*" of its position on the screen.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *Category* 的 "-1" 值意味着该 *number/position/key* 已由编辑器分配，因为此 *Category* 没有在屏幕上的
    "*preference*" 位置。
- en: Extending the Gameplay Debugger
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展 Gameplay Debugger
- en: So far, we have seen how all the different categories of the ***Gameplay Debugger***
    can help us understand how our *AI Character* is behaving. However, wouldn't it
    be awesome if we could have our own category so that we can visualize the data
    of a custom (sub-)system we have developed for our game?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到所有不同的 ***Gameplay Debugger*** 类别如何帮助我们理解我们的 *AI Character* 的行为。然而，如果我们能有一个自己的类别来可视化我们为游戏开发的定制（子）系统的数据，那岂不是很棒？
- en: The answer is yes, and this section explains how to do it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是肯定的，本节将解释如何做到这一点。
- en: Keep in mind that the tool is called ***Gameplay Debugger***, so you can extend
    it not only for AI, but for anything in your game, especially related to *Gameplay*
    (since it is a real-time tool to visualize information). So far, it has been extensively
    used for AI, but it has the potential to be used for anything else!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这个工具被称为 ***Gameplay Debugger***，因此您不仅可以扩展它用于 AI，还可以用于游戏中的任何事物，特别是与 *Gameplay*
    相关的事物（因为它是一个实时工具，用于可视化信息）。到目前为止，它已被广泛用于 AI，但它有潜力用于其他任何事物！
- en: As we already have seen, the ***Gameplay Debugger*** is divided into ***Categories***
    and ***Extensions***.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，***Gameplay Debugger*** 被分为 ***Categories*** 和 ***Extensions***。
- en: 'First, we will explore how to create a ***Custom Category*** in more detail,
    starting from creating a separate module for it, along with all the dependencies
    and compiler directives that we need. We will see how we can create the class
    that controls the ***Category***, and how we can register it to the *Gameplay
    Debugger*. As a result, we will have a fully functioning ***Gameplay Debugger
    Category*** that will print the location of our *Debug Actor* on-screen:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将更详细地探讨如何创建一个***自定义类别***，从为它创建一个独立的模块开始，包括我们需要的所有依赖项和编译器指令。我们将看到我们如何创建控制***类别***的类，以及我们如何将其注册到*游戏调试器*。结果，我们将拥有一个完全功能的***游戏调试类别***，它将在屏幕上打印我们的*调试Actor*的位置：
- en: '![](img/ce1c0b50-9055-4ae5-bd70-002540853491.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ce1c0b50-9055-4ae5-bd70-002540853491.png)'
- en: Lastly, we will look at how to create a ***Custom Extension*** for the ***Gameplay
    Debugger***, which will be able to print the Player's location when a specific
    key is pressed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨如何为***游戏调试器***创建一个***自定义扩展***，当按下特定键时，它将能够打印玩家的位置。
- en: With this being said, let's get into creating a new *plugin*!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，让我们开始创建一个新的*插件*！
- en: Creating a module with the use of a new plugin
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用新插件创建模块
- en: To extend the *Gameplay Debugger* with a new ***Category***, you will need a
    new module in your game. In fact, the engine is a collection of different modules,
    and your game is as well (usually, the game is just one module, especially if
    the game is small; it is created with only one module when you start a fresh project
    in C++, so you will need to add more if need be).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过一个新的***类别***扩展***游戏调试器***，您需要在您的游戏中创建一个新的模块。实际上，引擎是由不同的模块组成的，您的游戏也是如此（通常，游戏只是一个模块，尤其是如果游戏很小；在您使用C++开始一个新项目时，游戏只是一个模块，所以如果您需要，您将需要添加更多）。
- en: There are different ways in which we can create a module, and I'm not going
    to go into the details of how module works, and how to create one for your project.
    Rather, I will guide you on how to set up a custom module for running a new ***Gameplay
    Debugger Category***.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种创建模块的方法，我不会深入讲解模块的工作原理以及如何为您的项目创建一个模块。相反，我将指导您如何设置一个用于运行新的***游戏调试类别***的自定义模块。
- en: The easiest way to create another module is to create a plugin. As a result,
    the code is separated from the rest of our game, which has good and bad implications.
    However, we aren't going to discuss this in this section. Instead, I will show
    you how to create a custom ***Gameplay Debugger Category*** that you will then
    adapt to your specific needs.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 创建另一个模块最简单的方法是创建一个插件。因此，代码被从我们的游戏的其他部分分离出来，这既有好的一面也有不好的一面。然而，我们不会在本节中讨论这一点。相反，我将向您展示如何创建一个自定义的***游戏调试类别***，然后您可以根据自己的需求进行适配。
- en: 'Let''s start by opening the ***Plugins*** menu, from the ***Settings*** menu
    button on top of the *Viewport*, as shown in the following screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开***插件***菜单开始，从*视口*顶部的***设置***菜单按钮，如下面的截图所示：
- en: '![](img/5c5abd63-5d1b-4331-bfdd-377d2c35cd64.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5c5abd63-5d1b-4331-bfdd-377d2c35cd64.png)'
- en: 'Once the ***Plugins*** windows is open, you will need to click on the New Plugin
    button in the bottom right-corner:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦打开***插件***窗口，您需要点击右下角的“新建插件”按钮：
- en: '![](img/f12b9f5f-92d1-4f3b-9853-bf473a1a5982.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f12b9f5f-92d1-4f3b-9853-bf473a1a5982.png)'
- en: It is not the only way to create a *Plugin*, but this is the fastest, since
    Unreal contains a simple Wizard to create different templates of *Plugins*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是创建*插件*的唯一方法，但这是最快的，因为Unreal包含一个简单的向导来创建不同模板的*插件*。
- en: 'As a result, we will open the ***New Plugin*** windows, which is a wizard for
    creating new plugins:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将打开***新插件***窗口，这是一个用于创建新插件的向导：
- en: '![](img/fe4c4f83-bb82-49b4-821e-be8b8ebc99c3.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fe4c4f83-bb82-49b4-821e-be8b8ebc99c3.png)'
- en: 'We need to select the Blank template (since we just want a bare-bones a module
    to load). Then, we can fill in the *Name*, which in our case is ***GameplayDebugger_Locator***.
    Next, there are input fields to fill for your plugin: *Author* and *Description*.
    I put myself as *Author*, and for the description, I inserted "*A custom Gameplay
    Debugger Category for visualizing the position of an Actor*". This is what the
    screen should look like now:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要选择空白模板（因为我们只想加载一个基本的模块）。然后，我们可以填写*名称*，在我们的例子中是***GameplayDebugger_Locator***。接下来，有输入字段需要填写您的插件：*作者*和*描述*。我将自己作为*作者*，在描述中插入"*一个用于可视化Actor位置的定制游戏调试类别*"。这就是现在屏幕应该看起来像的样子：
- en: '![](img/89d7ba34-cb35-404f-8b1c-d901cabeac10.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/89d7ba34-cb35-404f-8b1c-d901cabeac10.png)'
- en: 'Press Create Plugin and our plugin will be created. It might take some time
    to process, so be patient:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 点击创建插件，我们的插件将被创建。这可能需要一些时间来处理，所以请耐心等待：
- en: '![](img/4d16dad0-59c8-4ad8-91a2-158654eb4513.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4d16dad0-59c8-4ad8-91a2-158654eb4513.png)'
- en: 'Once it has compiled, you will have the basic structure and code of the *Plugin*
    as a single module. You can check it out in *Visual Studio*. Under the *Plugins*
    folder, you should have the following structure:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编译完成，你将拥有 *Plugin* 的基本结构和代码作为一个单独的模块。你可以在 *Visual Studio* 中查看它。在 *Plugins*
    文件夹下，你应该有以下结构：
- en: '![](img/1fe85ef2-02b3-41cc-b163-a4c27600dd8e.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1fe85ef2-02b3-41cc-b163-a4c27600dd8e.png)'
- en: 'Also, if you go back to the *Plugin* window, you will be able to see our *Plugin*
    (and ensure that it is enabled):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你回到 *Plugin* 窗口，你将能够看到我们的 *Plugin*（并确保它已启用）：
- en: '![](img/51dcf318-369b-4c70-aeb7-e135ce1534eb.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/51dcf318-369b-4c70-aeb7-e135ce1534eb.png)'
- en: Of course, you are free to "*edit*" the *Plugin*, for instance, to change its
    icon or the category.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以自由地 "*编辑*" 插件，例如，更改其图标或类别。
- en: Setting up the module to work with the Gameplay Debugger
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置模块以与 Gameplay Debugger 一起工作
- en: Before we add the code for a new category of our *Gameplay Debugger*, there
    are some considerations to make.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为 *Gameplay Debugger* 的新类别添加代码之前，有一些考虑事项需要考虑。
- en: First of all, the *Gameplay Debugger* is, as its name suggests, a Debug tool.
    This means that it shouldn't be shipped with the game. As such, we need a way
    to strip away all the code related to the *Gameplay Debugger* if we are compiling
    a shipping version of the game. Of course, the *Plugin* we are creating only includes
    code for the *Gameplay Debugger*, but in your game, it is more likely that it
    lives in a broader context.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，正如其名所示，*Gameplay Debugger* 是一个调试工具。这意味着它不应该与游戏一起发布。因此，如果我们正在编译一个发布版本的游戏，我们需要一种方法来去除所有与
    *Gameplay Debugger* 相关的代码。当然，我们正在创建的 *Plugin* 只包含 *Gameplay Debugger* 的代码，但在你的游戏中，它更有可能存在于一个更广泛的环境中。
- en: To strip away the code, you need to defy a compilation variable that can be
    used with compilation macros; however, we only want to define this variable as
    true (value equal to one) if the game is not being shipped. To achieve this, we
    need to navigate to our Plugin ***.build.cs*** file. In our case, it is called ***GameplayDebugger_Locator.build.cs***,
    and you can find it within the hierarchy of files of our *Plugin* in *Visual Studio*
    (or the code editor of your choice). In fact, Unreal runs some tools before compiling
    (e.g. to generate reflection code and replace the macro in the C++ code), and
    these tools are written in C#. Therefore, we can modify their behavior with a
    piece of C# code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要去除代码，你需要违反一个可以与编译宏一起使用的编译变量；然而，我们只想在游戏未发布时将此变量定义为真（值等于一）。为了实现这一点，我们需要导航到我们的插件
    ***.build.cs*** 文件。在我们的例子中，它被称为 ***GameplayDebugger_Locator.build.cs***，你可以在 *Visual
    Studio*（或你选择的代码编辑器）中找到它，位于我们的 *Plugin* 文件夹的层次结构中。实际上，Unreal 在编译前运行一些工具（例如，生成反射代码和替换
    C++ 代码中的宏），这些工具是用 C# 编写的。因此，我们可以用一段 C# 代码来修改它们的行为。
- en: 'Once you open the file, you will find one function, which defines the different
    dependencies of the module. At the end of this function, add the following code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦打开文件，你将找到一个函数，该函数定义了模块的不同依赖项。在此函数的末尾添加以下代码：
- en: '[PRE0]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is an if statement that checks whether ***BuildDeveloperTools*** is true
    OR the Target Configuration (the configuration we are going to compile the C++
    code with) is different from ***Shipping*** or ***Test***. If this condition is
    verified, then we add a ***Private Dependency*** for this module, that is, the
    ***GameplayDebugger*** module, and define the `WITH_GAMEPLAY_DEBUGGER` variable
    as true (for compiling C++ code). Otherwise, we just declare the `WITH_GAMEPLAY_DEBUGGER` variable
    false.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个检查 ***BuildDeveloperTools*** 是否为真或目标配置（我们将用其编译 C++ 代码的配置）是否不同于 ***Shipping***
    或 ***Test*** 的 if 语句。如果这个条件得到验证，那么我们为这个模块添加一个 ***Private Dependency***，即 ***GameplayDebugger***
    模块，并将 `WITH_GAMEPLAY_DEBUGGER` 变量定义为真（用于编译 C++ 代码）。否则，我们只声明 `WITH_GAMEPLAY_DEBUGGER`
    变量为假。
- en: 'As a result, we are able to use the `WITH_GAMEPLAY_DEBUGGER` variable in our
    compiler directives to include of exclude (depending which kind of configuration
    we are building) specific code related to the ***Gameplay Debugger***. So, from
    now on, when we write code for our ***Gameplay Debugger*** category, let''s not
    forget to wrap it in the following compile directives:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们能够使用编译器指令中的 `WITH_GAMEPLAY_DEBUGGER` 变量来包含或排除（取决于我们正在构建哪种配置）与 ***游戏调试器***
    相关的特定代码。所以，从现在开始，当我们为我们的 ***游戏调试器*** 类别编写代码时，不要忘记将其包裹在以下编译器指令中：
- en: '[PRE1]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating a new Gameplay Debugger Category
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的游戏调试器类别
- en: The next step is to create a new class for our ***Gameplay Debugger Category***.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为我们的 ***游戏调试器类别*** 创建一个新的类。
- en: 'As usual, we can create a new C++ class, but this time, we will select ***None***
    as the Parent class (we will write the class on our own and manually make the
    inheritance):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们可以创建一个新的 C++ 类，但这次，我们将选择 ***None*** 作为父类（我们将自己编写类并手动实现继承）：
- en: '![](img/fd081aec-e7ce-4e66-a6e5-ec7836f47da8.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd081aec-e7ce-4e66-a6e5-ec7836f47da8.png)'
- en: 'Then, we can rename it ***GameplayDebuggerCategory_Locator*** (which follows
    the convention of starting the class name with *GameplayDebuggerCategory_*, followed
    by the *Category Name*). Now, be careful and select the right module; next to
    the module''s name, you can choose the module that the class belongs to. So far,
    we have always worked with one module, so we didn''t have this problem. You need
    to select the ***GameplayDebugger_Locator (Runtime)*** module, as shown in the
    following screenshot:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将其重命名为 ***GameplayDebuggerCategory_Locator***（遵循以 *GameplayDebuggerCategory_*
    开头类名的约定，后跟 *类别名称*）。现在，请小心选择正确的模块；在模块名称旁边，你可以选择该类所属的模块。到目前为止，我们一直只使用一个模块，所以没有这个问题。你需要选择
    ***GameplayDebugger_Locator (Runtime)*** 模块，如下面的截图所示：
- en: '![](img/37aedcf6-5206-409b-838b-66cb6b51c07a.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37aedcf6-5206-409b-838b-66cb6b51c07a.png)'
- en: Create the class, and wait until it is added to our *Plug**in*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 创建类，并等待它被添加到我们的 *插件* 中。
- en: 'Now, it''s time to actively start creating our class. Go into the header (`.h`)
    file of our newly created class and remove everything. We will start by including
    the engine minimal core, and then within the `#if WITH_GAMEPLAY_DEBUGGER` compiler
    directive, we will also include the `GameplayDebuggerCategory.h` file, since it
    will be our Parent class:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候开始积极创建我们的类了。进入我们新创建的类的头文件（`.h` 文件）并删除所有内容。我们将首先包含引擎最小核心，然后在 `#if WITH_GAMEPLAY_DEBUGGER`
    编译器指令中，我们还将包含 `GameplayDebuggerCategory.h` 文件，因为它是我们的父类：
- en: '[PRE2]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we need to create the class itself. By following conventions, we can
    rename the class so it has the same name as the file, ***FGameplayDebuggerCategory_Locator***,
    and make it inherit from ***FGameplayDebuggerCategory***:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要创建类本身。遵循约定，我们可以将类重命名为与文件名相同的名称，***FGameplayDebuggerCategory_Locator***，并使其继承自
    ***FGameplayDebuggerCategory***：
- en: '[PRE3]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The *Gameplay Debugger* is a powerful tool, and as such it as many functionalities.
    One of those is its ability to support replication. As a result, we need to set
    up a structure that supports that. If you open the source files (from the Engine)
    of the other *Gameplay Debugger Categories*, you will see that they follow the
    convention of declaring a protected structure named ***FRepData***. Within this
    structure, we declare all the variables that we need in order to visualize the
    category. In our case, we just need a string, which we will call ***ActorLocationString***.
    It is also important that this structure has a way to be serialized, so we need
    to add the `void Serialize(FArchive& Ar)` function, or at least its declaration.
    Finally, we can create (always under "*protected*") a variable of the ***FRepData*** type
    named ***DataPack***, as shown in the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*游戏调试器* 是一个强大的工具，因此它具有许多功能。其中之一是它支持复制的功能。因此，我们需要设置一个支持该功能的结构。如果你打开其他 *游戏调试器类别*
    的源文件（来自引擎），你会看到它们遵循声明一个名为 ***FRepData*** 的受保护结构的约定。在这个结构中，我们声明了所有我们需要可视化的变量。在我们的例子中，我们只需要一个字符串，我们将称之为
    ***ActorLocationString***。此外，这个结构需要有序列化的方式，因此我们需要添加 `void Serialize(FArchive&
    Ar)` 函数，或者至少它的声明。最后，我们可以在 "*受保护*" 下创建一个名为 ***DataPack*** 的 ***FRepData*** 类型的变量，如下面的代码所示：'
- en: '[PRE4]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we will need to override some public functions to make our category to
    work. These functions are as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要重写一些公共函数以使我们的类别工作。这些函数如下：
- en: '***Constructor***: This sets the initial parameter of the class, and will set
    the data replication for the *DataPack*.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***构造函数***: 这设置了类的初始参数，并将为 *DataPack* 设置数据复制。'
- en: '***MakeInstance()***: This creates an instance of this category (using a shared
    reference). This is required from the *Gameplay Debugger* when we register our
    category at a later date (meaning that we will add it to the editor).'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***MakeInstance()***: 这将创建此类的一个实例（使用共享引用）。当我们稍后注册我们的类别时，*Gameplay Debugger*
    需要这个操作（这意味着我们将将其添加到编辑器中）。'
- en: '***CollectData()***: This collects and stores the data that we would like to
    show, which we then store in the *DataPack* (which can be replicated). It is given
    in input (so that we can use it), the *Player Controller*, and the ***DebugActor***
    (if available), which is the Actor we have set the focus on in the *Gameplay Debugger*
    (remember that we selected a specific Character when we were analyzing its behavior;
    here, under the hood, it is passed as a parameter to the `CollectData()` function).'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***CollectData()***: 这收集并存储我们想要显示的数据，然后将其存储在 *DataPack*（可以复制）中。它作为输入（以便我们可以使用它），*Player
    Controller*，以及 ***DebugActor***（如果可用），这是我们已在 *Gameplay Debugger* 中设置的焦点 Actor（记住，当我们分析特定角色的行为时，我们选择了特定的角色；在这里，幕后，它作为参数传递给
    `CollectData()` 函数）。'
- en: '***DrawData()***: This displays the data on-screen; we will use the *DataPack*
    variable to retrieve the data that was collected in the `CollectData()` function.
    It is given in input (so that we can use it), the *Player Controller*, and the
    ***CanvasContext***, which is what we will use to actually display the data on-screen.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***DrawData()***: 这将在屏幕上显示数据；我们将使用 *DataPack* 变量来检索在 `CollectData()` 函数中收集的数据。它作为输入（以便我们可以使用它），*Player
    Controller*，以及 ***CanvasContext*** 提供，这是我们将在屏幕上实际显示数据的工具。'
- en: 'Now, we can declare them in our header (`.h`) file:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的头文件（`.h`）文件中声明它们：
- en: '[PRE5]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This concludes what we need in the header (`.h`) file. For your convenience,
    here is the whole code for the header (`.h`) file:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们在头文件（`.h`）文件中需要的内容。为了方便起见，以下是头文件（`.h`）文件的完整代码：
- en: '[PRE6]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The next step is to write the implementation. So, open the `.cpp` file and wipe
    everything off (if you haven't already) so that you can start clean.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是编写实现。因此，打开 `.cpp` 文件，如果尚未这样做，清除所有内容，以便你可以从头开始。
- en: 'Once again, we need to include some headers. Of course, we need to include
    the header file of our class itself (the header file we just edited). Then, under
    the `#if WITH_GAMEPLAY_DEBUGGER` compiler directive, we need to include the *Actor*
    class, since we will need to retrieve the position of an *Actor*:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们需要包含一些头文件。当然，我们需要包含我们自己的类头文件（我们刚刚编辑的头文件）。然后，在 `#if WITH_GAMEPLAY_DEBUGGER`
    编译器指令下，我们需要包含 *Actor* 类，因为我们需要检索 *Actor* 的位置：
- en: '[PRE7]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, we can start implementing all of our functions. We will start from our
    ***Constructor*** of the main class. Here, we can set the default parameters of
    the *Gameplay Debugger Category*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始实现所有我们的函数。我们将从主类的 ***构造函数*** 开始。在这里，我们可以设置 *Gameplay Debugger Category*
    的默认参数。
- en: For instance, we can set **bShowOnlyWithDebugActor** to ***false***, which,
    as its name suggests, allows this category to be displayed, even if we haven't
    selected a *Debug Actor*. In fact, even if our *Category* will need the *DebugActor*
    to show its location, we can still print other information (in our case, we will
    do a simple print). Of course, when you create your category, you can decide whether
    this bool will be true or not.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将 **bShowOnlyWithDebugActor** 设置为 ***false***，正如其名称所暗示的，这允许即使我们没有选择 *Debug
    Actor*，此类别也可以显示。实际上，即使我们的 *Category* 需要使用 *DebugActor* 来显示其位置，我们仍然可以打印其他信息（在我们的情况下，我们将进行简单的打印）。当然，当你创建你的类别时，你可以决定这个布尔值是否为真。
- en: 'However, it is more important to set our ***DataPack*** variable for replication
    through the `SetDataPackReplication<FRepData>(&DataPack)` function:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，更重要的是通过 `SetDataPackReplication<FRepData>(&DataPack)` 函数设置我们的 ***DataPack***
    变量以进行复制：
- en: '[PRE8]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we need to implement our `Serialize()` function for our ***RepData***
    structure. Since we just have a String, its implementation is quite straightforward;
    we just need to insert the *String* in the *Archive*:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现我们的 `Serialize()` 函数，用于我们的 ***RepData*** 结构。由于我们只有一个字符串，其实现相当简单；我们只需要将
    *String* 插入到 *Archive* 中：
- en: '[PRE9]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To register this *Category* to the *Gameplay Debugger*, we have to implement
    the `MakeInstance()` function, which will return a shared reference to an instance
    of this *Category*. Hence, here, the code is quite straightforward as well; just
    create a new instance of this class as a shared reference and return the value:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这个***类别***注册到*游戏调试*中，我们必须实现`MakeInstance()`函数，该函数将返回一个对这种***类别***实例的共享引用。因此，这里的代码也很简单；只需创建一个新的实例作为共享引用并返回值：
- en: '[PRE10]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have two more functions to implement. The former collects the data, while
    the latter displays it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有两个函数需要实现。前者收集数据，而后者显示数据。
- en: 'The `CollectData()` function already has the *DebugActor* passed as a parameter.
    Thus, after we have verified that the reference is valid, we can retrieve the
    *DebugActor''s* position and assign it within the ***ActorLocationString*** variable
    inside the *FRepData* structure that''s contained in the ***DataPack*** variable.
    It''s easier to show this than explain it:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`CollectData()`函数已经将*调试演员*作为参数传递。因此，在我们验证引用有效后，我们可以检索*调试演员*的位置并将其分配到包含在***DataPack***变量中的*FRepData*结构体内部的***ActorLocationString***变量中。这比解释更容易展示：'
- en: '[PRE11]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Of course, within the `CollectData()` function, you can run any logic to retrieve
    your own data. Just remember to store it within the ***DataPack*** variable, which
    is the pointer to the ***FRepData*** structure, which can be as complex as you
    like (and remember to serialize that as well).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在`CollectData()`函数中，你可以运行任何逻辑来检索你自己的数据。只需记住将其存储在***DataPack***变量中，它是***FRepData***结构的指针，它可以像你喜欢的那么复杂（并且记得也要序列化它）。
- en: Finally, the `DrawData()` function is responsible for actually displaying the
    information we have collected. In particular, we have a reference to the ***Canvas
    Context***, which we will use to "*print*" the information. We even have some
    formatting options, such as coloring the text by prefixing it with "*{color}*".
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`DrawData()`函数负责实际显示我们收集到的信息。特别是，我们有一个对***画布上下文***的引用，我们将用它来"*打印*"信息。我们甚至有一些格式化选项，例如通过在文本前加上"*{颜色}*"来给文本上色。
- en: 'First, we will print some text, and then print the location of the *DebugActor*
    (if available). We will use colors too, so let''s learn about how to use them:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将打印一些文本，然后打印*调试演员*的位置（如果有的话）。我们也会使用颜色，所以让我们了解一下如何使用它们：
- en: '[PRE12]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This was the last function for our implementation (`.cpp`) file. For your convenience,
    here is the whole file:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们实现（`.cpp`）文件中的最后一个函数。为了方便起见，这里是有整个文件的内容：
- en: '[PRE13]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, we have our *Gameplay Debugger Category*, but we need to "***register***"
    it to make it appear in the *Gameplay Debugger*. So, without further ado, let's
    jump into the next section.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了*游戏调试类别*，但我们需要将其***注册***到*游戏调试*中。所以，无需多言，让我们直接进入下一节。
- en: Registering the Gameplay Debugger Category
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册游戏调试类别
- en: In the previous section, we created a *Gameplay Debugger Category*, but now
    we need to "***register***" it to the *Gameplay Debugger*.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了一个*游戏调试类别*，但现在我们需要将其***注册***到*游戏调试*中。
- en: The easiest way to do this is by registering the category inside the `StartupModule()`
    function of our module, so let's open the `GameplayDebugger_Locator.cpp` file.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的最简单方法是在我们模块的`StartupModule()`函数内部注册类别，所以让我们打开`GameplayDebugger_Locator.cpp`文件。
- en: 'The first thing we need to do is include the *Gameplay Debugger Module*, along
    with the *Gameplay Debugger Category* we have created. We need to surround the
    `#include` statements with the `#if WITH_GAMEPLAY_DEBUGGER` compiler directive,
    as shown in the following piece of code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是包含*游戏调试模块*，以及我们创建的*游戏调试类别*。我们需要用`#if WITH_GAMEPLAY_DEBUGGER`编译指令将`#include`语句包围起来，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Inside the `StartupModule()` function, we need to check whether the *Gameplay
    Debugger Module* is available, and if so, retrieve a reference to it. Then, we
    can use this reference to register our category with the `RegisterCategory()`
    function, which takes three parameters (the name of the *Category*, a reference
    to the function to create an instance of the category, and some options as enum).
    Finally, we need to notify the changes. Of course, once again, this code is wrapped
    up by the `#if WITH_GAMEPLAY_DEBUGGER` compiler directive:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在`StartupModule()`函数内部，我们需要检查*游戏调试器模块*是否可用，如果可用，则检索其引用。然后，我们可以使用这个引用通过`RegisterCategory()`函数注册我们的类别，该函数接受三个参数（*类别*的名称、创建类别实例的函数的引用以及一些枚举选项）。最后，我们需要通知更改。当然，再次强调，此代码由`#if
    WITH_GAMEPLAY_DEBUGGER`编译器指令包装：
- en: '[PRE15]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So far, so good, but when we register something in a module, we also need to
    "***unregister***" when the module shuts down. Thus, in the `ShutdownModule()`
    function, we need to follow the same steps as before, but this time *unregister*
    the category. First, we need to check the validity of the *Gameplay Debugger Module*,
    and then we retrieve it, *unregister* the category, and notify the changes. Once
    again, the code is wrapped up by the `#if WITH_GAMEPLAY_DEBUGGER` compiler directive:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利，但当我们在一个模块中注册某些内容时，我们还需要在模块关闭时“***注销***”。因此，在`ShutdownModule()`函数中，我们需要执行与之前相同的步骤，但这次*注销*类别。首先，我们需要检查*游戏调试器模块*的有效性，然后检索它，*注销*类别，并通知更改。同样，代码再次由`#if
    WITH_GAMEPLAY_DEBUGGER`编译器指令包装：
- en: '[PRE16]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For your convenience, here is the full code of the file:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了您的方便，以下是文件的完整代码：
- en: '[PRE17]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Compile, and our code is ready to go. Also, ensure that the *Plugin* is activated,
    and then close and reopen the editor (sothat we are sure that our module has been
    loaded properly).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，我们的代码就准备好了。此外，请确保*插件*已激活，然后关闭并重新打开编辑器（这样我们可以确保我们的模块已正确加载）。
- en: Let's explore how what we have created works in Unreal.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索我们在虚幻中创建的内容是如何工作的。
- en: Visualizing the custom Gameplay Debugger Category
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化自定义游戏调试器类别
- en: 'Once we have restarted the editor, our *Plugin* will be loaded as well, which
    means that our ***Gameplay Debugger Category*** has been loaded as well. To check
    this, we can navigate to the *Project Settings*, under the *Gameplay Debugger
    Section*. Here, we have all the options to configure the *Gameplay Debugger*,
    including the categories that have been loaded. Thus, if we scroll down, we should
    be able to find our ***Locator Category***, as shown in the following screenshot:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们重新启动了编辑器，我们的*插件*也会被加载，这意味着我们的***游戏调试器类别***也被加载了。要检查这一点，我们可以导航到*项目设置*下的*游戏调试器部分*。在这里，我们有所有配置*游戏调试器*的选项，包括已加载的类别。因此，如果我们向下滚动，我们应该能够找到我们的***定位器类别***，如下面的截图所示：
- en: '![](img/b4440423-5ce9-43cb-aeb3-ce5bd4005b19.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b4440423-5ce9-43cb-aeb3-ce5bd4005b19.png)'
- en: 'As you can see, all the options are set to "***Use Default***", which we set
    when we passed the third parameter for registering the category. However, you
    can also override them here (for instance, by ensuring that it is always enabled).
    Optionally, you can change the key that this category is triggered on, or just
    leave the default settings as is if you don''t have any preference. The *Editor*
    will assign one for you:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有选项都设置为“***使用默认设置***”，这是我们注册类别时传递第三个参数时设置的。然而，您也可以在这里覆盖它们（例如，确保它始终处于启用状态）。可选地，您可以更改触发此类别的键，或者如果您没有偏好，可以保留默认设置。*编辑器*将为您分配一个：
- en: '![](img/2f04e8f4-1bc4-42ee-99c2-37ecd57ac1ee.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2f04e8f4-1bc4-42ee-99c2-37ecd57ac1ee.png)'
- en: 'If you are having trouble making the plugin load with the Gameplay Debugger
    available, you should navigate from the top menu of Unreal to ***Window | Developer
    Tools | Modules***. From here, search for our Locator Module, and then press on
    Reload, as shown in the following screenshot:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在尝试加载带有游戏调试器的插件时遇到困难，您应该从虚幻的顶部菜单导航到***窗口 | 开发者工具 | 模块***。从这里，搜索我们的定位器模块，然后按如下截图所示按重新加载：
- en: '![](img/f89065e7-18f5-4883-bc99-5220d10f9b86.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f89065e7-18f5-4883-bc99-5220d10f9b86.png)'
- en: You may need to do this every time you load the editor in order to use your
    Categories and/or Extension.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要每次加载编辑器时都这样做，以便使用您的类别和/或扩展。
- en: 'Now, if we press play and activate the *Gameplay Debugger*, we will see our
    category listed (it may be active or not by default, depending on the settings
    you set previously):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们按下播放并激活*游戏调试器*，我们将看到我们的类别被列出（它可能默认处于激活或非激活状态，具体取决于您之前设置的设置）：
- en: '![](img/06bb15b5-bc3b-4080-a203-bdd4e42e18e6.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/06bb15b5-bc3b-4080-a203-bdd4e42e18e6.png)'
- en: 'If we select another Actor, we will be able to see that the ***Locator Category***
    will display its position:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择另一个演员，我们将能够看到**定位类别**将显示其位置：
- en: '![](img/12f908b1-44e9-4c9e-909f-1ebbc4d4eda7.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/12f908b1-44e9-4c9e-909f-1ebbc4d4eda7.png)'
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一张输出截图。其他（被模糊处理）的信息在这里并不重要。
- en: 'Here is a close-up:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个特写镜头：
- en: '![](img/726e566f-1b8c-4476-bd90-b08be70dd47d.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/726e566f-1b8c-4476-bd90-b08be70dd47d.png)'
- en: This concludes our discussion on creating a ***Custom Gameplay Debugger Category***.
    Of course, it was a very simple example, but you can easily imagine the potential
    of such a tool and how this can be used in your project workflow.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对创建**自定义游戏调试器类别**的讨论。当然，这是一个非常简单的例子，但你很容易想象这种工具的潜力以及它如何在你的项目工作流程中使用。
- en: Before we conclude this chapter, as we mentioned previously, let's have a look
    at how we could extend the *Gameplay Debugger* by adding an *Extension*.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这一章之前，正如我们之前提到的，让我们看看我们如何通过添加一个*扩展*来扩展*游戏调试器*。
- en: Creating an Extension for the Gameplay Debugger
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为游戏调试器创建扩展
- en: As we mentioned previously, the *Gameplay Debugger* is composed of *Categories* (we
    have already seen how to create a custom one) and ***Extensions***. Once again,
    creating an ***Extension*** is only available in C++.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，*游戏调试器*由*类别*（我们已经看到了如何创建一个自定义的）和**扩展**组成。再次强调，创建**扩展**仅限于C++。
- en: Like the *Gameplay Debugger Category*, an *Extension* needs to live on a *Custom
    Module*, but it can be the same one as the *Category* (or *Categories*). Thus,
    I'm going to use the same plugin we just developed.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 与*游戏调试器类别*一样，一个*扩展*需要存在于一个*自定义模块*上，但它可以是与*类别*（或*类别集*）相同的。因此，我将使用我们刚刚开发的相同插件。
- en: In particular, we are going to create a simple extension that, when we press
    a specific key, prints the position of the Player in the output log.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们将创建一个简单的扩展，当我们按下特定的键时，会在输出日志中打印玩家的位置。
- en: The structure of the Extension
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展的结构
- en: 'We need to create a new C++ class and inherit from ***GameplayDebuggerExtension*** (by
    starting from an empty class, like we did when extending the Categories, and then
    build on that). The naming convention that we''ll be using here is "*GameplayDebuggerExtension_Name*"
    (however, keep in mind that there might be a limit of *32* characters for the
    file name). In our case, we will go for ***GameplayDebuggerExtension_Player***:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个新的C++类，并从**游戏调试器扩展**继承（从一个空类开始，就像我们在扩展类别时做的那样，然后在此基础上构建）。我们将在这里使用的命名约定是"*GameplayDebuggerExtension_Name*"（然而，请记住，文件名可能存在*32*个字符的限制）。在我们的例子中，我们将选择**GameplayDebuggerExtension_Player**：
- en: '![](img/75791a25-7329-4479-b293-3ed45354e0e9.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/75791a25-7329-4479-b293-3ed45354e0e9.png)'
- en: 'The structure of a *Gameplay Debugger Extension* is quite straightforward,
    since we will need to implement and/or override the following functions:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*游戏调试器扩展*的结构非常简单，因为我们需要实现和/或覆盖以下函数：'
- en: '***Constructor***: This sets the default value for the extensions, including
    settings. More importantly, it sets the key binding for the extension (and passes
    a reference to the function you wish to bind).'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数**：这为扩展设置默认值，包括设置。更重要的是，它为扩展设置键绑定（并传递你希望绑定的函数的引用）。'
- en: '***MakeInstance()***: This creates an instance of the *Gameplay Debugger Extension*
    as a shared reference. This function is required when the *Extension* is registered.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MakeInstance()**：这创建了一个*游戏调试器扩展*的实例作为共享引用。当*扩展*注册时，此函数是必需的。'
- en: '***OnActivated()***: This performs initialization when the *Extension* is activated
    (e.g. the *Gameplay Debugger* opens).'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OnActivated()**：当*扩展*被激活时执行初始化（例如，*游戏调试器*打开）。'
- en: '***OnDeactivated()***: This cleans up when the *Extension* is deactivated (e.g.
    the *Gameplay Debugger* closes). For instance, the Spectator extension uses this
    function to destroy the spectator controller (if it exists) and return control
    to the *Player Controller* that was there before.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OnDeactivated()**：当*扩展*被停用时进行清理（例如，*游戏调试器*关闭）。例如，观众扩展使用此函数来销毁观众控制器（如果存在）并将控制权返回给之前的*玩家控制器*。'
- en: '***GetDescription()***: This describes the *Extension* to the *Gameplay Debugger*.
    This means that this function returns a *String* that''s used to display the text
    in the Gameplay Debugger; the usual format with the color is allowed. Moreover,
    you are able to use *`FGameplayDebuggerCanvasStrings::ColorNameEnabled`* and `*FGameplayDebuggerCanvasStrings::ColorNameDisabled*`
    for the String that describes the colors of enabled or disabled for the extension,
    respectively. This is very useful if your *Extension* uses a toggle.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***GetDescription()***：这描述了*扩展*到*游戏调试器*的功能。这意味着该函数返回一个用于在游戏调试器中显示文本的*字符串*；允许使用带有颜色的常规格式。此外，您可以使用*`FGameplayDebuggerCanvasStrings::ColorNameEnabled`*和`*FGameplayDebuggerCanvasStrings::ColorNameDisabled*`来分别描述扩展的启用或禁用颜色。如果您的*扩展*使用切换功能，这将非常有用。'
- en: '***Action Function***: This performs the action that you want your *Extension*
    to do, so here, it can be whatever you want. This function will be passed to the
    Input Binding in the *Constructor*.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***动作函数***：这执行您希望您的*扩展*执行的操作，因此在这里，它可以是你想要的任何东西。此函数将在构造函数中将传递给输入绑定。'
- en: Creating the Extension class
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建扩展类
- en: 'Of course, we don''t need all the functions we just looked at. In our case,
    we can start by declaring the `Constructor`, `GetDescription()`, and `MakeInstance()`
    functions in the header (`.h`) file:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不需要查看的所有函数。在我们的情况下，我们可以在头文件（`.h`）中声明`Constructor`、`GetDescription()`和`MakeInstance()`函数：
- en: '[PRE18]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we will need a protected function, which we will bind to a specific input:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个受保护的函数，我们将将其绑定到特定的输入：
- en: '[PRE19]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we will need some protected variables: a boolean variable to check if
    an input has been binded, another boolean variable to see if the description has
    been cached, and a third variable that contains the cached description itself:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要一些受保护的变量：一个布尔变量用于检查是否已绑定输入，另一个布尔变量用于查看是否已缓存描述，以及一个包含缓存描述本身的变量：
- en: '[PRE20]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For performance reasons, it is always good practice to cache the description
    of a *Gameplay Debugger Extension*.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了性能原因，始终缓存*游戏调试器扩展*的描述是一个好的做法。
- en: 'Of course, don''t forget to enclose the whole class within the conditional
    compiler directive and the `*WITH_GAMEPLAY_DEBUGGER*` macro. This is what the
    header (`.h`) file should look like:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，不要忘记将整个类包含在条件编译指令和`*WITH_GAMEPLAY_DEBUGGER*`宏中。这是头文件（`.h`）应该看起来像的：
- en: '[PRE21]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For the implementation, we can start by adding the following `#include` statements,
    since we will need to have access to the Player Controller and its Pawn to retrieve
    the Player''s location. Also, we will need to bind inputs, so we need to include
    the *Input Core Types* as well:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实现，我们可以从添加以下`#include`语句开始，因为我们需要访问玩家控制器及其Pawn以检索玩家的位置。此外，我们还需要绑定输入，因此需要包含*输入核心类型*：
- en: '[PRE22]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we will implement our Constructor. Here is where we bind the input to
    a specific key. In our case, we can bind it to the *P* key. Of course, we will
    need a delegate, and we can pass our `PrintPlayerLocation()` function to do so:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现构造函数。在这里，我们将输入绑定到特定的键。在我们的例子中，我们可以将其绑定到*P*键。当然，我们需要一个委托，我们可以传递我们的`PrintPlayerLocation()`函数来完成此操作：
- en: '[PRE23]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As we mentioned previously, if you can, cache your description so that your
    *Extension* gains some performance. Here is the code structure for caching our
    description:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，如果您能的话，缓存您的描述，这样您的*扩展*就能获得一些性能。以下是缓存我们描述的代码结构：
- en: '[PRE24]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we need to get the Description. In this case, it can just be the Input
    Handler (so that we remember which key this Extension is bound to, and the word
    "Player" to remember that this is the Extension that retrieves the Player''s location.
    As for the colors, the Gameplay Debugger Extension provides some shortcuts for
    accessing specific colors (for instance, for toggling different kinds of Extensions,
    the color can changed based on whether it is toggled or not). We won''t pay much
    attention to colors at the moment, and we will use the default ones, assuming
    that everything is always enabled. As a result, this is the `GetDescription()`
    function:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要获取描述。在这种情况下，它可以是输入处理程序（这样我们就能记住这个扩展绑定到哪个键，以及单词“玩家”来记住这是一个检索玩家位置的扩展。至于颜色，游戏调试器扩展提供了一些访问特定颜色的快捷方式（例如，对于切换不同类型的扩展，颜色可以根据是否切换而改变）。我们目前不会过多关注颜色，我们将使用默认的颜色，假设一切总是启用的。因此，这是`GetDescription()`函数：
- en: '[PRE25]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `MakeInstance()` function, on the other hand, is pretty straightforward
    and very similar to the one we used for the *Gameplay Debugger Categories*; it
    just needs to return a shared reference to this Extension:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`MakeInstance()` 函数相当简单，并且非常类似于我们用于 *游戏调试器类别* 的一个；它只需要返回对这个扩展的共享引用：
- en: '[PRE26]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, in our `PrintPlayerPosition()` function, we can just use a *UE_LOG*
    to print the Player''s location. However, in a *Gameplay Debugger Extension*,
    its in these kind of functions (which are bound to the input) that the real magic
    happens:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的 `PrintPlayerPosition()` 函数中，我们只需使用一个 *UE_LOG* 来打印玩家的位置。然而，在一个 *游戏调试器扩展*
    中，真正的魔法发生在这些（绑定到输入）函数中：
- en: '[PRE27]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once again, don't forget to wrap your C++ class with the compiler directive.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，不要忘记用编译器指令包裹你的 C++ 类。
- en: 'As a result, this is the `.cpp` file of our class:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是我们班级的 `.cpp` 文件：
- en: '[PRE28]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Registering the Extension
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册扩展
- en: Just like we did for *Gameplay Debugger Categories*, we need to register the
    *Extensions* as well.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对 *游戏调试器类别* 所做的那样，我们还需要注册 *扩展*。
- en: 'However, before we do that, if we try to compile, we will get an error. In
    fact, since we handle inputs for the *Extension*, the module in which the *Extension*
    lives requires the ***Public Dependency*** to the "***InputCore***". Add the following
    line to your `.build.cs` file:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们这样做之前，如果我们尝试编译，我们将得到一个错误。实际上，由于我们处理 *扩展* 的输入，*扩展* 所在的模块需要向 "***InputCore***"
    的 ***公共依赖***。在你的 `.build.cs` 文件中添加以下行：
- en: '[PRE29]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Specifically, for our Locator Module, this is how you should insert this dependency
    in the `GameplayDebugger_Locator.build.cs` file:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，对于我们的定位模块，你应该在 `GameplayDebugger_Locator.build.cs` 文件中这样插入这个依赖项：
- en: '[PRE30]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you compile after this modification, you shouldn't get any errors.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在此修改后编译，你不应该得到任何错误。
- en: 'Now, it''s time to register the Extension and notify the *Gameplay Debugger* of
    this change. We need to use specific functions to do so. Thus, in our `StartupModule()`
    function (in the `GameplayDebugger_Locatot.cpp` file), we need to add the following
    bold lines of code so that we can register and notify the *Gameplay Debugger*
    accordingly (note that we need to do this for both *Extensions* and *Categories*,
    since they are two different functions):'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候注册扩展并通知 *游戏调试器* 这个变化了。为此，我们需要使用特定的函数。因此，在我们的 `StartupModule()` 函数（在 `GameplayDebugger_Locatot.cpp`
    文件中），我们需要添加以下加粗的代码行，以便相应地注册和通知 *游戏调试器*（注意，我们需要为 *扩展* 和 *类别* 都这样做，因为它们是两个不同的函数）：
- en: '[PRE31]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The same goes for unregistering the *Extension* when the module shuts down.
    Here is the code we need to add in the `ShutdownModule()` function:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块关闭时注销 *扩展* 时，同样的方法也适用。以下是我们在 `ShutdownModule()` 函数中需要添加的代码：
- en: '[PRE32]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Compile the code, and your plugin will be ready. You might need to restart the
    editor for the effects to take place.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 编译代码，你的插件就准备好了。你可能需要重新启动编辑器才能使效果生效。
- en: 'If you are still having trouble making the plugin load with the Gameplay Debugger
    available, navigate from the top menu of Unreal to ***Window -> Developer Tools
    | Modules***. From here, search for our Locator Module and then press on Reload,
    as shown in the following screenshot:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然在使用游戏调试器可用的情况下加载插件时遇到麻烦，请从虚幻引擎的顶部菜单导航到 ***窗口 -> 开发者工具 | 模块***。从这里，搜索我们的定位模块，然后按如下截图所示按下重新加载：
- en: '![](img/5bd100ac-6a94-4806-b7e3-c32ef8201dca.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5bd100ac-6a94-4806-b7e3-c32ef8201dca.png)'
- en: You may need to do this every time you load the editor in order to use your
    Categories and/or Extension.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能每次加载编辑器时都需要这样做，以便使用你的类别和/或扩展。
- en: 'If you go into the *Gameplay Debugger Settings*, you will find our *Extension*
    listed (and you will be able to change the key bind if you wish):'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进入 *游戏调试器设置*，你将找到我们的 *扩展* 列表（如果你愿意，你还可以更改按键绑定）：
- en: '![](img/8b1c68ab-fd44-4a62-8245-4f52a0a8c966.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b1c68ab-fd44-4a62-8245-4f52a0a8c966.png)'
- en: 'This is how it will appear in-game:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它在游戏中的样子：
- en: '![](img/380779c3-7e34-4d76-aef5-663bf986a9a2.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](img/380779c3-7e34-4d76-aef5-663bf986a9a2.png)'
- en: This is a screenshot of the output. The other (blurred out) information is not
    important here
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出截图。其他（模糊显示）的信息在这里并不重要
- en: 'Here is a close-up:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个特写：
- en: '![](img/c311ca72-1515-4acd-a8ce-155eeba46ee8.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c311ca72-1515-4acd-a8ce-155eeba46ee8.png)'
- en: 'If you press *P*, then the Extension will produce the following result in the
    *Output Log*:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按下 *P*，那么扩展将在 *输出日志* 中产生以下结果：
- en: '![](img/02166dd5-76dc-41a0-970f-fdf03147d002.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02166dd5-76dc-41a0-970f-fdf03147d002.png)'
- en: For more information about *Gameplay Debugger Extensions*, you should have a
    look at the classes contained in `GameplayDebuggerExtension.h` (the vase class
    to create an *Extension* of the *Gameplay Debugger*) and `GameplayDebuggerExtension_Spectator.h` (an
    implementation of an *Extension*, with an example of *Input Binding* and *Cached
    Description* as well).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 关于*游戏玩法调试器扩展*的更多信息，你应该查看`GameplayDebuggerExtension.h`中包含的类（创建*扩展*的*游戏玩法调试器*的基类）以及`GameplayDebuggerExtension_Spectator.h`（一个*扩展*的实现，其中包含*输入绑定*和*缓存描述*的示例）。
- en: This concludes our adventure into extending the *Gameplay Debugger*.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们扩展*游戏玩法调试器*的冒险之旅结束。
- en: Summary
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we look at how to take advantage of the ***Gameplay Debugger***
    for testing our AI systems. In particular, we looked at the default ***Categories
    and Extensions*** of the *Gameplay Debugger*, how they work, and which kind of
    information they display.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨如何利用**游戏玩法调试器**来测试我们的AI系统。特别是，我们研究了*游戏玩法调试器*的默认**类别和扩展**，它们是如何工作的，以及它们显示哪种类型的信息。
- en: Then, we saw how it is possible to ***extend the Gameplay Debugger*** by ***creating
    a new Category*** and a ***new Extension*** within a ***Plugin***. As a result,
    we unlocked great potential for debugging our own systems.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看到了如何通过**创建一个新的类别**和一个**新的扩展**在**插件**中**扩展游戏玩法调试器**。结果，我们解锁了我们自己系统调试的巨大潜力。
- en: In the next chapter, we will explore ***AI in Games*** further, and see what's
    beyond.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步探讨**游戏中的AI**，并看看还有哪些可能性。
