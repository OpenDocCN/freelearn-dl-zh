- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Constructing a Recommendation Graph with H&M Personalization Dataset
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用H&M个性化数据集构建推荐图
- en: While Neo4j is great for building knowledge graphs, it would be prudent to look
    at how we model the data. A good data persistence model can make data retrieval
    optimal and handle large loads better. In this chapter, we will take a step back
    to look at what constitutes a **knowledge graph** and how a different look at
    data modeling with a Neo4j data persistence approach can help build more powerful
    knowledge graphs. You might need to revisit the approaches defined in [*Chapter
    3*](Preface.xhtml#_idTextAnchor012), which will enable you to build a knowledge
    graph with Personalized Fashion Recommendations (H&M personalization) data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Neo4j非常适合构建知识图谱，但审慎地考虑我们如何建模数据是很重要的。一个好的数据持久化模型可以使数据检索最优化并更好地处理大量负载。在本章中，我们将回顾一下构成**知识图谱**的内容，以及使用Neo4j数据持久化方法对数据建模的不同视角如何帮助构建更强大的知识图谱。您可能需要重新阅读[*第3章*](Preface.xhtml#_idTextAnchor012)中定义的方法，这将使您能够使用个性化时尚推荐（H&M个性化）数据构建知识图谱。
- en: 'We will cover these topics in this chapter as we tackle data modeling evolution:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在解决数据建模演变问题时涵盖这些主题：
- en: Modeling a recommendation graph with the H&M Personalization dataset
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用H&M个性化数据集建模推荐图
- en: 'Optimizing for recommendations: Best practices in graph modeling'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化推荐：图建模的最佳实践
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need to be familiar with SQL and Cypher. We will be using SQLite and
    Neo4j to understand the various aspects of data modeling. We will use the following
    tools in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要熟悉SQL和Cypher。我们将使用SQLite和Neo4j来理解数据建模的各个方面。在本章中，我们将使用以下工具：
- en: Neo4j Desktop ([https://neo4j.com/docs/desktop-manual/current/](https://neo4j.com/docs/desktop-manual/current/))
    or Neo4j Aura ([https://neo4j.com/docs/aura/](https://neo4j.com/docs/aura/))
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Neo4j Desktop ([https://neo4j.com/docs/desktop-manual/current/](https://neo4j.com/docs/desktop-manual/current/))
    或 Neo4j Aura ([https://neo4j.com/docs/aura/](https://neo4j.com/docs/aura/))
- en: 'The H&M dataset to create the recommendation system: This dataset is available
    at [https://www.kaggle.com/c/h-and-m-personalized-fashion-recommendations/overview](https://www.kaggle.com/c/h-and-m-personalized-fashion-recommendations/overview)
    (Carlos García Ling, ElizabethHMGroup, FridaRim, inversion, Jaime Ferrando, Maggie,
    neuraloverflow, and xlsrln. H&M Personalized Fashion Recommendations. 2022\. Kaggle)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于创建推荐系统的H&M数据集：此数据集可在[https://www.kaggle.com/c/h-and-m-personalized-fashion-recommendations/overview](https://www.kaggle.com/c/h-and-m-personalized-fashion-recommendations/overview)（Carlos
    García Ling, ElizabethHMGroup, FridaRim, inversion, Jaime Ferrando, Maggie, neuraloverflow,
    和 xlsrln. H&M个性化时尚推荐。2022。Kaggle）找到。
- en: Remember from [*Chapter 3*](Preface.xhtml#_idTextAnchor012) that a good graph
    data model makes the *retrieval* part of RAG flow more effective. It makes retrieving
    relevant data faster and easier. You may revisit [*Chapter 3*](Preface.xhtml#_idTextAnchor012)
    for a quick recap of graph data modeling. In this chapter, we model the data with
    time as a dimension. The chain of transactions with the time as a dimension makes
    data retrieval very efficient and performant.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 记住从[*第3章*](Preface.xhtml#_idTextAnchor012)中提到的，一个好的图数据模型可以使RAG流程中的*检索*部分更加有效。它使得检索相关数据更快、更简单。您可以重新阅读[*第3章*](Preface.xhtml#_idTextAnchor012)以快速回顾图数据建模。在本章中，我们将时间作为一个维度来建模数据。以时间为维度的交易链使得数据检索非常高效和性能优良。
- en: Modeling the recommendation graph with the H&M personalization dataset
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用H&M个性化数据集建模推荐图
- en: In this section, we will create a graph data model with the real-life large-scale
    H&M Personalization dataset. This graph data model will enable us to power up
    the recommendation engine that we will create in upcoming chapters.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用现实生活中的大规模H&M个性化数据集创建一个图数据模型。这个图数据模型将使我们能够增强我们在后续章节中创建的推荐引擎。
- en: In 2022, H&M posted customer transaction data along with other metadata related
    to customers, products, and so on, as part of a competition to build a recommendation
    engine. This dataset contains data from previous transactions, as well as from
    customer and product metadata. The available metadata spans simple data, such
    as garment type and customer age, to text data from product descriptions, to image
    data from garment images.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在2022年，H&M发布了客户交易数据以及其他与客户、产品等相关联的元数据，作为构建推荐引擎竞赛的一部分。此数据集包含以前交易的数据以及客户和产品元数据。可用的元数据范围从简单的数据，如服装类型和客户年龄，到产品描述中的文本数据，再到服装图像中的图像数据。
- en: We will discuss the dataset’s characteristics and load the data into a knowledge
    graph as we go, step by step.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论数据集的特征，并逐步将数据加载到知识图谱中。
- en: 'We will take a look at the data available in this dataset:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看此数据集中可用的数据：
- en: '`images/:` This contains the images for a given `article_id.` Not all articles
    in the dataset may have images associated with them. We will not be using this
    data to build the graph. Storing the images in a graph would not only be inefficient,
    but it is not necessary for the graph flow we are building.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`images/:` 这包含与给定`article_id.`关联的图片。数据集中并非所有文章都有与之关联的图片。我们不会使用这些数据来构建图。在图中存储图片不仅效率低下，而且对于我们要构建的图流程来说也不是必要的。'
- en: '`articles.csv:` This file contains the metadata for each article available
    for purchase. Each row represents one unique article with metadata such as the
    product family, color, style, section the article belongs to, and department.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`articles.csv:` 该文件包含可供购买的商品的元数据。每一行代表一个独特的商品，包括产品系列、颜色、风格、商品所属的章节和部门。'
- en: '`customers.csv:` This file contains the metadata for each customer in the dataset,
    including customer ID, age, fashion news frequency, active flag, H&M club member
    status, and postal code.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`customers.csv:` 该文件包含数据集中每个客户的元数据，包括客户ID、年龄、时尚新闻频率、活动标志、H&M俱乐部会员状态和邮政编码。'
- en: '`transactions_train.csv:` This file contains the transactions made by customers.
    If a customer made multiple purchases of the same item, that data might come as
    multiple rows – one row for each item purchased, with the transaction date, article
    ID, customer ID, price, and sales channel.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transactions_train.csv:` 该文件包含客户进行的交易。如果客户购买了同一件商品多次，数据可能以多行形式出现——每行代表一件购买的物品，包括交易日期、商品ID、客户ID、价格和销售渠道。'
- en: We will take a look at the **graph data model** of this data in the next section
    and load the data for that model. When we build the knowledge graph for the H&M
    personalization dataset recommendations, we will have a list of transactions made
    by customers, and representing these as a chain of transactions with time as a
    dimension might work very well for us. By adding our understanding of the data
    into the graph data model can make our recommendations more valuable. For instance,
    the transactions are a sequence of events; hence modeling them as a sequence makes
    more sense. Unlike traditional databases, Neo4j makes it possible to store these
    transactions as a graph that is connected sequentially using relationships.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节查看这些数据的**图数据模型**，并加载数据以支持该模型。当我们为H&M个性化数据集构建推荐知识图谱时，我们将有一个客户进行的交易列表，将这些交易表示为按时间维度的交易链可能对我们非常有效。通过将我们对数据的理解添加到图数据模型中，可以使我们的推荐更有价值。例如，交易是一系列事件；因此，将它们建模为序列更有意义。与传统数据库不同，Neo4j使得将这些交易作为通过关系顺序连接的图存储成为可能。
- en: We can say, we are persisting our knowledge of data into the graph, thus creating
    a knowledge graph.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，我们将对数据的了解持久化到图中，从而创建一个知识图谱。
- en: Building your recommendation graph
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建您的推荐图
- en: 'To build the recommendation model graph, we will take a look at the data within
    each of the files in the dataset and how they contribute to the graph. We will
    apply the process we discussed previously, in [*Chapter 3*](Preface.xhtml#_idTextAnchor012)*,*
    to build the graph. Before loading the data, we need to use Neo4j Desktop and
    perform these steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建推荐模型图，我们将查看数据集中每个文件中的数据以及它们如何贡献到图中。我们将应用之前讨论过的过程，在[*第3章*](Preface.xhtml#_idTextAnchor012)*,*
    来构建图。在加载数据之前，我们需要使用Neo4j Desktop并执行以下步骤：
- en: Create a local database. You can follow the instructions at [https://neo4j.com/docs/desktop-manual/current/operations/create-dbms/](https://neo4j.com/docs/desktop-manual/current/operations/create-dbms/)
    to perform this operation.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建本地数据库。您可以按照[https://neo4j.com/docs/desktop-manual/current/operations/create-dbms/](https://neo4j.com/docs/desktop-manual/current/operations/create-dbms/)中的说明执行此操作。
- en: Copy the CSV files from the H&M recommendation dataset to the `import` directory
    of this database. If you are not sure how to do this, please visit [https://community.neo4j.com/t/where-is-neo4j-home/6488/5](https://community.neo4j.com/t/where-is-neo4j-home/6488/5)
    for reference.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将H&M推荐数据集的CSV文件复制到该数据库的`import`目录。如果您不确定如何操作，请访问[https://community.neo4j.com/t/where-is-neo4j-home/6488/5](https://community.neo4j.com/t/where-is-neo4j-home/6488/5)以获取参考。
- en: Now let us load the data into the graph database.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将数据加载到图数据库中。
- en: Loading the customer data
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载客户数据
- en: 'The customer data contains these elements: customer ID, age, fashion news frequency,
    active flag, H&M club member status, and postal code.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 客户数据包含以下元素：客户ID、年龄、时尚新闻频率、活跃标志、H&M俱乐部会员状态和邮政编码。
- en: The customer ID is the unique ID of the customer. To make sure we have unique
    nodes representing the customer, we need to have a `UNIQUE` constraint. Also,
    we will make the postal code a node, as we might want to segregate customers by
    postal code easily.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 客户ID是客户的唯一ID。为了确保我们有代表客户的唯一节点，我们需要有一个 `UNIQUE` 约束。此外，我们将邮政编码作为一个节点，因为我们可能想要轻松地按邮政编码隔离客户。
- en: 'Before loading this data, we need to create these unique constraints, by connecting
    to the Neo4j database we created:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载这些数据之前，我们需要通过连接到我们创建的Neo4j数据库来创建这些唯一约束：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once unique constraints are created, we can use this Cypher to load the data
    into the database:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了唯一约束，我们就可以使用这个Cypher将数据加载到数据库中：
- en: '**Note**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: For the `LOAD` `CSV` queries, we need to prefix them with `auto` to be able
    to run them in Neo4j Browser.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `LOAD` `CSV` 查询，我们需要在它们前面加上 `auto` 前缀，以便能够在Neo4j浏览器中运行它们。
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This script loads the customer data into the database, using 1,000 rows as
    one batch to commit. In this script, we can notice a couple of things:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本使用1000行作为一个批次提交，将客户数据加载到数据库中。在这个脚本中，我们可以注意到几个问题：
- en: We have only one property, named `age`, on the `Customer` node, apart from the
    unique ID, `customer_id`
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了唯一的ID `customer_id` 之外，`Customer` 节点上只有一个名为 `age` 的属性
- en: We map the other properties of the customer data as labels on the `Customer`
    node
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将客户数据的其他属性映射到 `Customer` 节点的标签上
- en: This approach follows the *consumption-based approach* to data modeling we discussed
    previously. Say we want to understand how the customers who are regular fashion
    news subscribers behave – this gives us an easy way to retrieve this information.
    Neo4j optimizes this type of retrieval using a label-based approach. We could
    make this customer behavior (fashion news subscription) a property and create
    an index to retrieve this data, but that would require more storage, as well as
    having an index lookup cost. Say we want to use the customers who are active club
    members and are regular fashion news consumers – this label-based approach gives
    us an edge to retrieve this information more effectively when compared to storing
    it as a property. Also, when we display this information as a graph, users can
    easily see the information in the labels, rather than looking for a property.
    It feels more natural to consume the data in this manner and queries also look
    more natural.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法遵循我们之前讨论过的基于消费的数据建模方法。比如说，我们想要了解那些定期订阅时尚新闻的顾客的行为——这为我们提供了一个简单的方式来检索这些信息。Neo4j通过基于标签的方法优化这种检索。我们可以将顾客行为（时尚新闻订阅）作为一个属性，并创建一个索引来检索这些数据，但这将需要更多的存储空间，以及索引查找的成本。如果我们想要使用那些活跃的俱乐部会员和定期消费时尚新闻的顾客——这种基于标签的方法与将它们作为属性存储相比，能更有效地检索这些信息。此外，当我们以图形的形式展示这些信息时，用户可以很容易地看到标签中的信息，而不是寻找属性。以这种方式消费数据感觉更自然，查询也更自然。
- en: Next, we will load the article data.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将加载文章数据。
- en: Loading the article data
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载文章数据
- en: The article data contains other categories that describe the article, apart
    from the unique article ID and description. We will make other attributes that
    describe articles nodes themselves.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 文章数据包含除了唯一的文章ID和描述之外的其他描述文章的类别。我们将创建其他描述文章本身的属性。
- en: 'For this purpose, we need to create these unique constraints:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们需要创建这些唯一约束：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can see that we have converted most of the attributes of the articles into
    nodes. This sort of normalizes the data represented in the graph. This Cypher
    will load the data into the graph:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们已经将文章的大多数属性转换成了节点。这种类型的数据规范化在图中表示。这个Cypher将数据加载到图中：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For each row, create an article, product, and product group and associate them:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一行，创建一个文章、产品以及产品组，并将它们关联起来：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now add the graphical appearance and colors associated with the article:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加与文章相关的图形外观和颜色：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now let us connect the department associated with it:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们连接与之相关的部门：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, let us connect the section the article belongs to and the garment
    group:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将文章所属的章节和服装组连接起来：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: From the Cypher query, we can see that, in the graph, we are persisting the
    normalized data, without duplicating values for various aspects that describe
    the article.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从Cypher查询中，我们可以看到，在图中，我们正在持久化规范化数据，而没有对描述文章的各个方面重复值。
- en: We will load the transactions next.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将加载数据。
- en: Loading the transaction data
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载交易数据
- en: 'The `transaction_train.csv` data is in the order transactions have occurred.
    This makes it possible to load the data and preserve the sequence in the graph
    in an easy manner. We have this data in each row for transactions: transaction
    date, article ID, customer ID, price, and sales channel.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`transaction_train.csv` 数据按照交易发生的顺序排列。这使得我们可以轻松地加载数据并保留图中数据的顺序。对于每一笔交易，我们都有以下数据：交易日期、商品ID、客户ID、价格和销售渠道。'
- en: '**Note**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: We don’t have a unique ID for each of the transactions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有为每一笔交易分配一个唯一的ID。
- en: 'We can use this Cypher to load the data:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下 Cypher 加载数据：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: From this Cypher, we can see that we take the first transaction we find for
    a given customer and connect it to the customer using a *START_TRANSACTION* relationship.
    We use a *LATEST* relationship to track the last transaction the customer made.
    As we keep getting more transactions for the customer, we keep moving the *LATEST*
    relationship to the newest transaction. We connect the earlier transaction that
    was connected using a *LATEST* relationship and the new transaction with a *NEXT*
    relationship. So, in this graph, we are representing the transactions made by
    customers as a transaction train, true to the name of the dataset file `transaction_train.csv`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个 Cypher 查询中，我们可以看到我们取给定客户的第一个交易，并使用一个 *START_TRANSACTION* 关系将其连接到客户。我们使用一个
    *LATEST* 关系来跟踪客户所做的最后交易。随着我们为客户获取更多交易，我们将 *LATEST* 关系移动到最新的交易。我们使用 *NEXT* 关系将之前通过
    *LATEST* 关系连接的交易和新的交易连接起来。因此，在这个图中，我们代表客户所做的交易就像 `transaction_train.csv` 数据集文件名所暗示的那样，是一个交易列车。
- en: Final graph
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终图
- en: After loading all the data, our graph model will look as shown in *Figure 8.1*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 加载所有数据后，我们的图模型将如图 *图8.1* 所示。
- en: '![Figure 8.1 — Graph data model after loading the H&M data](img/B31107_08_01.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 — 加载 H&M 数据后的图数据模型](img/B31107_08_01.png)'
- en: Figure 8.1 — Graph data model after loading the H&M data
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 — 加载 H&M 数据后的图数据模型
- en: We can see from this graph that the article attributes are fanned out into various
    individual nodes. The **Customer** node is connected to the postal code and first
    and last transactions. **Transaction** is associated with **Article**. The **Transaction**
    nodes are also connected to any next transactions available for a given customer.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个图中我们可以看到，商品属性已经分散到各个单独的节点中。**客户** 节点连接到邮政编码和第一笔和最后交易。**交易** 与 **商品** 关联。**交易**
    节点还连接到给定客户可用的任何后续交易。
- en: Now that we have loaded the data, let us explore how we can further enhance
    the graph from this data, to add our own understanding of the data and ideas into
    the graph.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载数据，让我们探索如何从这些数据中进一步增强图，将我们对数据的理解和想法添加到图中。
- en: 'Optimizing for recommendations: best practices in graph modeling'
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化推荐：图建模的最佳实践
- en: We have a graph now, with data loaded the way we want to consume it and representing
    the context of the data. Still, the graph represents only the original context
    provided. Say we want to consume the data by season and year – we still need to
    build queries to retrieve it. Since Neo4j is schema optional, maybe we can do
    some post-processing and add extra relationships to consume the data in that way.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个图，数据以我们想要消费的方式加载，并代表数据的上下文。尽管如此，图仍然只代表提供的原始上下文。如果我们想按季节和年份消费数据，我们仍然需要构建查询来检索它。由于
    Neo4j 是可选模式的，我们可能可以进行一些后处理并添加额外的关联，以便以这种方式消费数据。
- en: 'In this Cypher script, we are creating seasonal relationships:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 Cypher 脚本中，我们正在创建季节性关系：
- en: 'For each customer, iterate through the transactions and assign a season value
    based on month and year:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个客户，遍历交易并根据月份和年份分配一个季节值：
- en: '[PRE9]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For example, if the month is `1` and the year is `2020`, we assign `WINTER_2019`
    as the season name for that transaction as the context:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，如果月份是 `1` 且年份是 `2020`，我们将 `WINTER_2019` 作为该交易的季节名称作为上下文：
- en: '[PRE10]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Collect transactions for each season value:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集每个季节值对应的交易：
- en: '[PRE11]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Get the first record of the collection for each season value:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取每个季节值集合的第一个记录：
- en: '[PRE12]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a relationship between the customer and that transaction with the season
    value as the relationship name. We are using the `apoc` method to create the relationship
    as the relationship name is dynamic:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用季节值作为关系名称，在客户和该交易之间创建一个关系。我们使用 `apoc` 方法创建关系，因为关系名称是动态的：
- en: '[PRE13]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Do note that this is a very basic approach. This shows we can create extra context
    in the graph based on our understanding of the data. These approaches make Neo4j
    very suitable for building knowledge graphs. When we make it easy to access data
    in this way, it can open up more ideas on how we can look at the same data differently
    to extract more *intelligence* in a simple manner that’s traceable and understandable
    at the same time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是一个非常基础的途径。这表明我们可以根据我们对数据的理解在图中创建额外的上下文。这些方法使 Neo4j 非常适合构建知识图谱。当我们以这种方式轻松访问数据时，它可以开启更多关于如何以不同方式观察相同数据的想法，以简单、可追踪和可理解的方式提取更多*智能*。
- en: If you do not want to load the data manually, you can download the database
    snapshot from the following URL:  [https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/Building+Neo4j-Powered+Applications+with+LLMs+Database+Dump+files.zip](https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/Building+Neo4j-Powered+Applications+with+LLMs+Database+Dump+files.zip)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想手动加载数据，您可以从以下网址下载数据库快照：  [https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/Building+Neo4j-Powered+Applications+with+LLMs+Database+Dump+files.zip](https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/Building+Neo4j-Powered+Applications+with+LLMs+Database+Dump+files.zip)
- en: We have now added more context to the data. Let’s look at the graph data model
    next.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经为数据添加了更多上下文。接下来，让我们看看图数据模型。
- en: '![Figure 8.2 — H&M graph data model after enhancing with seasonal relationships](img/B31107_08_02.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 — 增强季节关系后的 H&M 图数据模型](img/B31107_08_02.png)'
- en: Figure 8.2 — H&M graph data model after enhancing with seasonal relationships
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 — 增强季节关系后的 H&M 图数据模型
- en: 'Let us use our understanding of the data to write a query to get articles bought
    by a random customer in the summer of 2019:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用我们对数据的理解来编写一个查询，以获取 2019 年夏季随机客户购买的文章：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this query, we find customers who bought items both in the summer and fall
    of 2019, pick one customer from that list, and retrieve the article descriptions.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个查询，我们找到在 2019 年夏季和秋季都购买过物品的客户，从那个列表中选取一个客户，并检索文章描述。
- en: 'The output of the query will look like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 查询的输出将如下所示：
- en: '![Figure 8.3 — Cypher query to retrieve SUMMER_2019 purchases for a customer](img/B31107_08_03.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 — 查询 SUMMER_2019 客户购买的 Cypher 查询](img/B31107_08_03.png)'
- en: Figure 8.3 — Cypher query to retrieve SUMMER_2019 purchases for a customer
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 — 查询 SUMMER_2019 客户购买的 Cypher 查询
- en: By looking at the query, it is easy to understand what the query is doing. We
    use `SUMMER_2019` as the starting point and a transaction before `FALL_2019` relationship
    as the endpoint, traverse from the start point to the endpoint, and retrieve the
    articles of those transactions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看查询，可以很容易地理解查询正在做什么。我们使用 `SUMMER_2019` 作为起点，以及一个在 `FALL_2019` 关系之前的交易作为终点，从起点遍历到终点，并检索那些交易的物品。
- en: We can see that we are completely relying on the graph traversals instead of
    property-based filters, which makes executing this query very efficient. Neo4j
    is built to execute these kinds of queries very efficiently.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们完全依赖于图遍历而不是基于属性的过滤器，这使得执行此查询非常高效。Neo4j 就是构建来高效执行这类查询的。
- en: Summary
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how to look at a graph data model and how building
    a model based on how we consume it makes it easier to retrieve the data efficiently.
    We looked at the H&M recommendations dataset and loaded it using those principles,
    and also augmented it using the properties and our understanding of that data.
    This added more context to the graph and also made it simple to query the data
    – queries are more readable and explainable to others in a simpler way.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何观察图数据模型，以及如何根据我们消费数据的方式构建模型，使其更易于高效地检索数据。我们研究了 H&M 推荐数据集，并使用这些原则加载了它，还利用属性和我们对这些数据的理解对其进行了增强。这为图添加了更多上下文，并使得查询数据变得简单——查询更易于阅读和以更简单的方式向他人解释。
- en: In the next chapter, we will build on this data, using an LLM to enhance it
    further, and will see how LLMs can provide us with more capable knowledge graphs.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将在此基础上构建数据，使用 LLM 进一步增强它，并看看 LLM 如何为我们提供更强大的知识图谱。
