- en: Understanding the Depth-First Search Algorithm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解深度优先搜索算法
- en: Search algorithms have various applications in industrial and research-based
    AI solutions, related to computer vision, machine learning, and robotics. As we
    progress through the chapters in this book, we will teach you how to use AI in
    search applications. Searching is something that we do every day, whether we are
    searching for a song in our filesystem, searching for a friend or colleague on
    a social network, or finding the best route to a destination. In this chapter,
    you will learn about the **Depth-First Search **(**DFS**) algorithm and develop
    a file search application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索算法在工业和研究领域的人工智能解决方案中有广泛的应用，涉及计算机视觉、机器学习和机器人技术。在本书的后续章节中，我们将教你如何在搜索应用程序中使用人工智能。搜索是我们每天都会进行的操作，无论是搜索文件系统中的歌曲、在社交网络中寻找朋友或同事，还是寻找前往目的地的最佳路线。在这一章中，你将学习
    **深度优先搜索**（**DFS**）算法并开发一个文件搜索应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Installing and setting up libraries
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装并设置库
- en: Introducing file search applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍文件搜索应用程序
- en: Formulation of the search problem
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索问题的表述
- en: Building search trees with nodes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用节点构建搜索树
- en: Stacks and DFS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈与 DFS
- en: Recursive DFS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归 DFS
- en: Installing and setting up libraries
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装并设置库
- en: 'Before we get into the basic concepts of searching, we will take a look at
    the following libraries that have to be installed and how to install them in Windows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨搜索的基本概念之前，我们将先了解以下需要安装的库以及如何在 Windows 中安装它们：
- en: '**Python**: You can download and install Python libraries from [https://www.python.org/downloads/](https://www.python.org/downloads/),
    depending on your operating system'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python**：你可以根据操作系统，从 [https://www.python.org/downloads/](https://www.python.org/downloads/)
    下载并安装 Python 库。'
- en: '**Graphviz**: This open source graph visualization software can be downloaded
    from [http://graphviz.org/download/](http://graphviz.org/download/)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Graphviz**：这款开源图形可视化软件可以从 [http://graphviz.org/download/](http://graphviz.org/download/)
    下载。'
- en: '**Pip**: The tools for installing Python packages are as follows:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pip**：用于安装 Python 包的工具如下：'
- en: '**Pydot**: A Python interface to Graphviz''s DOT language'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pydot**：Graphviz 的 DOT 语言的 Python 接口'
- en: '**Matplotlib**: This is a Python 2D plotting library'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Matplotlib**：这是一款 Python 2D 绘图库。'
- en: Execute the steps in the following section to install the preceding libraries.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下部分中的步骤来安装前述库。
- en: Setting up Python
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Python
- en: 'The steps for setting up Python are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Python 的步骤如下：
- en: For the applications in this book, we'll be using Python 2.7.6, which we can
    download from [https://www.python.org/downloads/](https://www.python.org/downloads/).
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于本书中的应用程序，我们将使用 Python 2.7.6，可以从 [https://www.python.org/downloads/](https://www.python.org/downloads/)
    下载。
- en: Once an appropriate installer has been downloaded, double-click on it and go
    ahead with the default options.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载适当的安装程序后，双击它并继续使用默认选项进行安装。
- en: 'Based on your operating system, select the Python installer to download, as
    shown in the following screenshot:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据你的操作系统，选择合适的 Python 安装程序进行下载，如下截图所示：
- en: '![](img/a69f6903-1c5b-4389-8ab6-7a57d3fd8060.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a69f6903-1c5b-4389-8ab6-7a57d3fd8060.png)'
- en: Figure 1
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1
- en: 'The following screenshot shows the location where Python will be installed;
    make a note of this location:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了 Python 将被安装的位置；请记下此位置：
- en: '![](img/d654d4e8-ce32-49b9-8ccd-376ea8c70543.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d654d4e8-ce32-49b9-8ccd-376ea8c70543.png)'
- en: Figure 2
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2
- en: Now, Python will be installed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Python 将会安装。
- en: The next step is to add Python's path to the Path environment variable. In the System
    Properties | Advanced tab, click on the Environment Variables... button.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将 Python 的路径添加到 Path 环境变量中。在系统属性 | 高级标签下，点击“环境变量...”按钮。
- en: In the Environment Variables… window, go to System variables | Path and add
    the Python location that you made a note of in step 4 (which is `C:\Python27` in
    our case).
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“环境变量…”窗口中，进入系统变量 | Path，并添加你在步骤 4 中记下的 Python 位置（在我们的例子中是 `C:\Python27`）。
- en: 'Now, to check whether Python works, open the Command Prompt and type in the
    `python -- version` command. You will get the following output:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，检查 Python 是否工作，打开命令提示符并输入 `python -- version` 命令。你将看到以下输出：
- en: '![](img/a3add63b-bf93-4f72-b373-1d1d30dd67d4.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3add63b-bf93-4f72-b373-1d1d30dd67d4.png)'
- en: Figure 3
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3
- en: The output shown in the preceding screenshot confirms that Python has been installed
    successfully.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图显示的输出确认 Python 已成功安装。
- en: Depending on your OS, Python might already be installed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的操作系统，Python 可能已经安装好了。
- en: Setting up Graphviz
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Graphviz
- en: 'The following steps describe how to set up Graphviz:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述如何设置 Graphviz：
- en: We can download the graph visualization software from [https://graphviz.gitlab.io/download/](https://graphviz.gitlab.io/download/).
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以从 [https://graphviz.gitlab.io/download/](https://graphviz.gitlab.io/download/)
    下载图形可视化软件。
- en: 'Since we are using Windows, we select the option that says Stable 2.38 Windows
    install packages, as shown in the following screenshot:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们使用的是 Windows 操作系统，我们选择标有“稳定 2.38 Windows 安装包”的选项，如下图所示：
- en: '![](img/22dc30da-0297-4cc3-ae22-084a6b1ea628.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22dc30da-0297-4cc3-ae22-084a6b1ea628.png)'
- en: Figure 4
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4
- en: 'Select the `.msi` downloadable file, shown as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 选择可下载的 `.msi` 文件，如下所示：
- en: '![](img/a3024418-040a-4e8a-b209-048d6ebc6b3d.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3024418-040a-4e8a-b209-048d6ebc6b3d.png)'
- en: Figure 5
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5
- en: 'Once the Graphviz executable has downloaded, go ahead and install the file
    with the default options; again, make a note of the path, as shown in the following
    screenshot:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 Graphviz 可执行文件下载完成，继续安装该文件并选择默认选项；再次记录安装路径，如下图所示：
- en: '![](img/ae569a58-5e7c-4210-b63d-317742b8a89f.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae569a58-5e7c-4210-b63d-317742b8a89f.png)'
- en: Figure 6
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6
- en: 'Now, we will add Graphviz''s `bin` folder to the path variable, as we did when
    installing Python in the previous section. Then, copy the location where Graphviz
    is installed and append `\bin`, as shown in the following screenshot:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将像安装 Python 时一样，将 Graphviz 的 `bin` 文件夹添加到路径变量中。然后，复制 Graphviz 安装的路径，并在后面加上
    `\bin`，如下图所示：
- en: '![](img/808cf99e-6ab7-4f65-bfe7-ee2656286d14.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/808cf99e-6ab7-4f65-bfe7-ee2656286d14.png)'
- en: Figure 7
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7
- en: 'To validate whether this library has been installed properly, open a new Command
    Prompt window and type the `dot -V` command, and you will get the following result:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证这个库是否已正确安装，打开一个新的命令提示符窗口，输入 `dot -V` 命令，你将看到以下结果：
- en: '![](img/f2250773-1e65-431f-b114-355718b635fa.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2250773-1e65-431f-b114-355718b635fa.png)'
- en: Figure 8
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8
- en: The output shown in the preceding screenshot confirms that Graphviz has been
    installed successfully.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示的输出确认 Graphviz 已成功安装。
- en: Installing pip
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 pip
- en: 'The steps for installing `pip` are as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 `pip` 的步骤如下：
- en: To install `pip`, you need to download the `get-pip.py` file from [https://bootstrap.pypa.io/get-pip.py](https://bootstrap.pypa.io/get-pip.py),
    and make a note of the path where the file is located. In my case, the file is
    located at `Documents\ai\softwares`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了安装 `pip`，你需要从 [https://bootstrap.pypa.io/get-pip.py](https://bootstrap.pypa.io/get-pip.py)
    下载 `get-pip.py` 文件，并记录该文件所在的路径。在我的例子中，文件位于 `Documents\ai\softwares`。
- en: 'Open the Command Prompt and go to the `Documents\ai\softwares` folder by using
    the `cd` command, as shown in the following screenshot:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符，并使用 `cd` 命令进入 `Documents\ai\softwares` 文件夹，如下图所示：
- en: '![](img/2243f76b-e104-4999-81f8-fb565ef2309f.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2243f76b-e104-4999-81f8-fb565ef2309f.png)'
- en: Figure 9
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9
- en: 'Use the `dir` command to take a look at the contents of this folder, where
    you will see `get-pip.py`, shown in the following screenshot:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dir` 命令查看该文件夹的内容，你将看到 `get-pip.py`，如下图所示：
- en: '![](img/836efaf0-29f1-4d98-9a4a-d7db0d3d16fd.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/836efaf0-29f1-4d98-9a4a-d7db0d3d16fd.png)'
- en: Figure 10
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10
- en: Next, we'll run the `python get-pip.py` command.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将运行 `python get-pip.py` 命令。
- en: Now, let's add Python's `scripts` folder to the Path environment variable.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将 Python 的 `scripts` 文件夹添加到 Path 环境变量中。
- en: 'Open another Command Prompt window and test the installation of `pip` by typing
    the `pip --version` command. Upon successful installation, you will get the following
    output:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开另一个命令提示符窗口，通过输入 `pip --version` 命令来测试 `pip` 的安装。如果安装成功，你将看到以下输出：
- en: '![](img/9bf3bf4a-7a5c-4267-913f-aa551af882a4.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9bf3bf4a-7a5c-4267-913f-aa551af882a4.png)'
- en: Figure 11
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11
- en: 'Once `pip` has installed, you can install `pydot` by running the following
    command:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 `pip` 安装完成，你可以通过运行以下命令来安装 `pydot`：
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Finally, install `matplotlib` by executing the following command:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过执行以下命令安装 `matplotlib`：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can check whether the libraries have been installed properly by using the
    `import` command in Python''s interpreter, as shown in the following screenshot:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过在 Python 解释器中使用 `import` 命令来检查库是否已正确安装，如下图所示：
- en: '![](img/4a0338f6-f0f9-4095-9aa5-5150ca6cd333.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a0338f6-f0f9-4095-9aa5-5150ca6cd333.png)'
- en: Figure 12
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12
- en: Now, we're done installing the libraries that we will need in Windows for this
    book . In the next topic, we will look at how we can go about developing a file
    search application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经在Windows中安装好了本书所需的所有库。接下来，我们将探讨如何开发一个文件搜索应用。
- en: Introduction to file searching applications
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件搜索应用介绍
- en: In file managers, file searching is used to find files with specific names.
    In IDEs, file searching is used to find program files with specific code text.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件管理器中，文件搜索用于查找特定名称的文件；在集成开发环境（IDE）中，文件搜索用于查找包含特定代码文本的程序文件。
- en: 'In this topic, we''ll develop the first example in order to find a file named
    `f211.txt`. The folder structure is shown in the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本主题中，我们将开发第一个示例，以便查找一个名为`f211.txt`的文件。文件夹结构如下截图所示：
- en: '![](img/ed824895-a7c2-4a7c-85c4-3f8515362903.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed824895-a7c2-4a7c-85c4-3f8515362903.png)'
- en: Figure 13
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13
- en: 'This folder structure can be represented as a tree, as shown in the following
    diagram; the file that we''re trying to find is shown with a green border:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件夹结构可以表示为树形结构，如下图所示；我们要寻找的文件用绿色边框标出：
- en: '![](img/ccfcc91d-f6a5-4b22-b0aa-2851f5f318c5.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ccfcc91d-f6a5-4b22-b0aa-2851f5f318c5.png)'
- en: Figure 14
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14
- en: 'Let''s go ahead and look at how file searching will work to find this file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看文件搜索是如何工作的，以便找到这个文件：
- en: File searching starts in the **current directory**; it opens the first folder
    inside of that (**d1**) and opens the first folder in **d1** (**d11**). Inside
    of **d11,** it compares all of the filenames.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件搜索从**当前目录**开始；它打开第一个文件夹（**d1**），然后打开**d1**中的第一个文件夹（**d11**）。在**d11**中，它会比较所有的文件名。
- en: Since there's no more content inside of **d11**, the algorithm gets out of **d11**,
    goes inside of **d1**, and goes for the next folder, which is **d12**, comparing
    all of its files.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于**d11**中没有更多内容，算法退出**d11**，进入**d1**，然后去下一个文件夹，即**d12**，并比较所有文件。
- en: Now, it moves outside of **d12** and goes for the next folder inside of **d1** (**f11**),
    and then the next folder (**f12**).
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，它离开了**d12**，去访问**d1**中的下一个文件夹（**f11**），然后是下一个文件夹（**f12**）。
- en: Now, the search algorithm has covered all of the contents inside of the **d1**
    folder. So, it gets out of **d1 **and goes for the next folder inside of the **current
    directory**, which is **d2**.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，搜索算法已经覆盖了**d1**文件夹中的所有内容。于是，它退出**d1**，进入**当前目录**中的下一个文件夹，即**d2**。
- en: Inside of **d2**, it opens the first folder (**d21**). Inside of **d21**, it
    compares all of the files, and we find the **f211** file that we're looking for.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**d2**中，它打开第一个文件夹（**d21**）。在**d21**中，它比较所有文件，并找到了我们要找的**f211**文件。
- en: If you refer to the preceding folder structure, you will see that there's a
    pattern that is being repeated. When we reached **f111**, the algorithm had explored
    the leftmost part of the tree, upto its maximum depth. Once the maximum depth
    was reached, the algorithm backtracked to the previous level and went for the
    next subtree to the right. Again, in this case, the leftmost part of the subtree
    is explored, and, when we reach the maximum depth, the algorithm goes for the
    next subtree. This process is repeated until the file that we are searching for
    is found.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你参考前面的文件夹结构，你会发现一个被反复使用的模式。当我们到达**f111**时，算法已经探索了树的最左边部分，直到它的最大深度。一旦达到了最大深度，算法就会回溯到上一级，然后开始探索右侧的子树。再次地，在这种情况下，子树的最左边部分被探索，当我们达到最大深度时，算法会去下一棵子树。这个过程会一直重复，直到找到我们正在搜索的文件。
- en: Now that we understand how the search algorithm functions logically, in the
    next topic, we will go through the main ingredients of searching, which are used
    for performing searching in this application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了搜索算法的逻辑功能，在下一个主题中，我们将探讨执行搜索所需的搜索主要组成部分，这些组成部分在本应用中被用来进行搜索。
- en: Basic search concepts
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本搜索概念
- en: 'To understand the functionality of search algorithms, we first need to understand
    basic searching concepts, such as the state, the ingredients of a search, and
    the nodes:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解搜索算法的功能，我们首先需要了解一些基本的搜索概念，如状态、搜索的组成部分和节点：
- en: '**State**: The state is defined as the space where the search process takes
    place. It basically answers the question—*what are we searching for?* For example,
    in a navigation application, a state is a place. In our search application, a
    state is a file or folder.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：状态被定义为搜索过程发生的空间。它基本上回答了这个问题——*我们在搜索什么？* 例如，在一个导航应用中，状态是一个地点；在我们的搜索应用中，状态是一个文件或文件夹。'
- en: '**Ingredients of a search**: There are three main ingredients in a search algorithm.
    These ingredients are as follows, using the example of a treasure hunt:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索的元素**：搜索算法中有三个主要元素。这些元素如下，以寻宝为例：'
- en: '**Initial state**: This answers the question—*where do we begin our search?*
    In our example, the initial state would be the location where we begin our treasure
    hunt.'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始状态**：这是回答问题——*我们从哪里开始搜索？* 在我们的例子中，初始状态就是我们开始寻宝的地点。'
- en: '**Successor function**: This answers the question—*how do we explore from the
    initial state?* In our example, the successor function should return all of the
    paths from the location where we began our treasure hunt.'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后继函数**：这是回答问题——*我们如何从初始状态开始探索？* 在我们的例子中，后继函数应该返回我们开始寻宝时的所有路径。'
- en: '**Goal function**: This answers the question—*how will we know when we''ve
    found the solution?* In our example, the goal function returns true if you''ve
    found the place marked as the treasure.'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标函数**：这是回答问题——*我们如何知道何时找到了解决方案？* 在我们的例子中，目标函数返回true，如果你找到了标记为宝藏的地方。'
- en: 'The search ingredients are illustrated in the following diagram:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索元素在下图中进行了说明：
- en: '![](img/52509359-a71b-4cda-bfe1-39100207b526.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52509359-a71b-4cda-bfe1-39100207b526.png)'
- en: Figure 15
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图15
- en: '**Node**: A node is the basic unit of a tree. It may consist of data or links
    to other nodes.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点**：节点是树的基本单元。它可以包含数据或指向其他节点的链接。'
- en: Formulating the search problem
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制定搜索问题
- en: 'In a file searching application, we start searching from the current directory,
    so our initial state is the current directory. Now, let''s write the code for
    the state and the initial state, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件搜索应用程序中，我们从当前目录开始搜索，因此我们的初始状态是当前目录。现在，让我们编写状态和初始状态的代码，如下所示：
- en: '![](img/c442b940-76bb-45e9-9208-82e45997e897.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c442b940-76bb-45e9-9208-82e45997e897.png)'
- en: Figure 16
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图16
- en: In the preceding screenshot, we have created two Python modules, `State.py`
    and `StateTest.py`. The `State.py` module will contain the code for the three
    search ingredients mentioned in the previous section. The `StateTest` module is
    a file where we can test these ingredients.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们创建了两个Python模块，`State.py`和`StateTest.py`。`State.py`模块将包含前一部分提到的三个搜索元素的代码。`StateTest`模块是一个可以用来测试这些元素的文件。
- en: 'Let''s go ahead and create a constructor and a function that returns an initial
    state, as shown in the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建一个构造函数和一个返回初始状态的函数，如下所示的代码：
- en: '[PRE2]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code, the following apply:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下内容适用：
- en: We have the constructor (the constructor name) and we have created a property
    called `path`, which stores the actual path of the state. In the preceding code
    example, we can see that the constructor takes `path` as an argument. The `if...else`
    block suggests that if the path is not provided, it will initialize the state
    as the initial state, and if the path is provided, it will create a state with
    that particular path.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有构造函数（构造函数名称），并且我们创建了一个名为`path`的属性，用于存储状态的实际路径。在前面的代码示例中，我们可以看到构造函数将`path`作为参数。`if...else`块表示如果没有提供路径，则将状态初始化为初始状态；如果提供了路径，则会创建具有该特定路径的状态。
- en: The `getInitialState()` function returns the current working directory.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getInitialState()`函数返回当前工作目录。'
- en: 'Now, let''s go ahead and create some sample states, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续创建一些示例状态，如下所示：
- en: '[PRE3]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code, we have created the following three states:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了以下三个状态：
- en: '`initialState`, which points to the current directory'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialState`，指向当前目录'
- en: '`interState`, which is the intermediate function that points to the `d21` folder'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interState`，是指向`d21`文件夹的中间函数'
- en: '`goalState`, which points to the `f211.txt` folder'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`goalState`，指向`f211.txt`文件夹'
- en: 'Next, we will look at the `successor` function. If we''re in a particular folder,
    the `successor` function should return the folders and files inside of that folder,
    and, if you''re currently looking at a file, it should return an empty array. Considering
    the following diagram, if the current state is `d2`, it should return paths to
    the `d21` and `d22` folders:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下`successor`函数。如果我们在某个特定文件夹中，`successor`函数应该返回该文件夹内的文件夹和文件。如果你当前查看的是一个文件，它应该返回一个空数组。考虑下图，如果当前状态是`d2`，它应该返回指向`d21`和`d22`文件夹的路径：
- en: '![](img/f23a39a5-3c83-4357-92f0-0dd93bc88518.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f23a39a5-3c83-4357-92f0-0dd93bc88518.png)'
- en: Figure 17
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图17
- en: 'Now, let''s create the preceding function with the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下代码创建前面的函数：
- en: '[PRE5]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding  function checks whether the current path is a directory. If it
    is a directory, it gets a sorted list of all of the folders and files inside it,
    and prepends the current path to them. If it is a file, it returns an empty array.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 前述函数检查当前路径是否为目录。如果是目录，它会获取目录中所有文件夹和文件的排序列表，并将当前路径添加到它们前面。如果是文件，它会返回一个空数组。
- en: 'Now, let''s test this function with some input. Open the `StateTest` module
    and take a look at the successors to the initial state and intermediate state:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用一些输入来测试这个函数。打开`StateTest`模块，查看初始状态和中间状态的后继状态：
- en: '[PRE7]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As shown in the preceding code, the successors to the current directory (or
    the initial state) are the LiClipse project files and the folders `d1`, `d2`,
    and `d3`, and the successor of the intermediate state is the `f211.txt` file.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，当前目录（或初始状态）的后继状态是LiClipse项目文件和文件夹`d1`、`d2`和`d3`，而中间状态的后继状态是`f211.txt`文件。
- en: 'The output of running the preceding code is shown in the following screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前述代码的输出结果如下图所示：
- en: '![](img/d8e41019-2d22-46c1-ac85-9392e155af13.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8e41019-2d22-46c1-ac85-9392e155af13.png)'
- en: Figure 18
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图18
- en: 'Finally, we will look at the goal function. So, how do we know that we have
    found the target file, `f211.txt`? Our goal function should return `False` for
    the `d21`  folder, and `True` for the `f211.txt` file . Let''s look at how to
    implement this function in code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来看看目标函数。那么，我们如何知道我们已经找到了目标文件`f211.txt`呢？我们的目标函数应该对`d21`文件夹返回`False`，对`f211.txt`文件返回`True`。我们来看看如何在代码中实现这个函数：
- en: '[PRE8]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As shown in the preceding code, the function `checkGoalState()` is our goal
    function; this checks whether the current path is a directory. Now, since we are
    looking for a file, this returns `False` if it's a directory. If it is a file,
    it extracts the filename from the path. The filename is the substring of the path
    from the last occurrence of a slash to the end of the string. So, we extract the
    filename and compare it with `f211.txt`. If they match, we return `True`; otherwise,
    we return `False`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，`checkGoalState()`函数是我们的目标函数；它检查当前路径是否为目录。现在，因为我们要找的是文件，如果是目录，它会返回`False`。如果是文件，它会从路径中提取文件名。文件名是从路径中最后一个斜杠到字符串结尾的子串。所以，我们提取文件名并与`f211.txt`进行比较。如果匹配，我们返回`True`；否则，返回`False`。
- en: 'Again, let''s test this function for the states that we''ve created. To do
    so, open the `StateTest` module, as shown in the following screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 再次测试这个函数，测试我们创建的状态。为此，打开`StateTest`模块，如下图所示：
- en: '![](img/7987435d-366a-4c80-9456-cee0ed4dcf01.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7987435d-366a-4c80-9456-cee0ed4dcf01.png)'
- en: Figure 19
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图19
- en: As you can see, the function returns `False` for the current directory, it returns
    `False` for the `d21` folder, and it returns `True` for the `f211.txt` file.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，该函数对当前目录返回`False`，对`d21`文件夹返回`False`，对`f211.txt`文件返回`True`。
- en: Now that we understand the three ingredients in search algorithms, in the next
    section, we will look at building search trees with nodes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了搜索算法中的三个要素，在接下来的章节中，我们将讨论如何使用节点构建搜索树。
- en: Building trees with nodes
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用节点构建树
- en: In this topic, you'll be learning how to create a search tree with nodes. We
    will look at the concepts of states and nodes and the properties and methods of
    the node class, and we will show you how to create a tree with node objects. In
    our application, while the state is the path of the file or folder we are processing
    (for example, the current directory), the node is a node in the search tree (for
    example, the current directory node).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何使用节点创建搜索树。我们将讨论状态和节点的概念、节点类的属性和方法，并展示如何用节点对象创建一棵树。在我们的应用中，状态是我们正在处理的文件或文件夹的路径（例如，当前目录），而节点是搜索树中的一个节点（例如，当前目录节点）。
- en: 'A node has many properties, and one of them is the state. The other properties
    are as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一个节点有许多属性，其中之一是状态。其他属性如下：
- en: '**Depth**: This is the level of the node in the tree'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度**：这是节点在树中的层级'
- en: '**Reference to the parent node**: This consists of links to the parent node'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对父节点的引用**：这包括指向父节点的链接'
- en: '**References to the child nodes**: This consists of links to the child nodes'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对子节点的引用**：这包括指向子节点的链接'
- en: 'Let''s look at a few examples, in order to understand these concepts more clearly:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些例子，以便更清楚地理解这些概念：
- en: 'An example of these concepts in the **current directory** node is as follows:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些概念在**当前目录**节点中的示例如下：
- en: '**Depth**: 0'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度**：0'
- en: '**Reference to parent node**: None'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**父节点引用**：无'
- en: '**References to children nodes**: d1, d2, d3'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子节点引用**：d1、d2、d3'
- en: '![](img/b022eb2a-8994-490d-aa23-ed2490d9fc43.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b022eb2a-8994-490d-aa23-ed2490d9fc43.png)'
- en: Figure 20
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20
- en: 'An example of these concepts in node **d3** is as follows:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些概念在节点**d3**中的一个示例如下：
- en: '**Depth**: 1'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度**：1'
- en: '**Reference to parent node**: Current directory node'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**父节点引用**：当前目录节点'
- en: '**Reference to children nodes**: f31'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子节点引用**：f31'
- en: '![](img/49246848-b68a-416b-bbc4-f52529a620ed.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49246848-b68a-416b-bbc4-f52529a620ed.png)'
- en: Figure 21
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21
- en: 'An example of the concepts for these file node **f111** is as follows:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些文件节点**f111**概念的一个示例如下：
- en: '**Depth**: 3'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度**：3'
- en: '**Reference to parent node**: d11'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**父节点引用**：d11'
- en: '**Reference to children node**: []'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子节点引用**：[]'
- en: '![](img/a36b6308-e459-4f2b-ad3b-dca28765cdca.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a36b6308-e459-4f2b-ad3b-dca28765cdca.png)'
- en: Figure 22
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 22
- en: 'Let''s create a class called `Node`, which includes the four properties that
    we just discussed:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`Node`的类，其中包含我们刚才讨论的四个属性：
- en: '[PRE9]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As shown in the preceding code, we have created a class called `Node`, and
    this class has a constructor that takes `state` as an argument. The `state` argument
    is assigned to the `state` property of this node, and the other properties are
    initialized as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如上面代码所示，我们创建了一个名为`Node`的类，这个类有一个构造函数，接受`state`作为参数。`state`参数被分配给该节点的`state`属性，其他属性初始化如下：
- en: The depth is set to `0`
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度设置为`0`
- en: The reference to children is set to a blank array
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子节点的引用被设置为空数组
- en: The reference to parent nodes is set to `None`
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父节点引用设置为`None`
- en: This constructor creates a blank node for the search tree.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 该构造函数为搜索树创建一个空节点。
- en: 'Aside from the constructor, we need to create the following two methods:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了构造函数，我们还需要创建以下两个方法：
- en: '`addChild()`:  This method adds a child node under a parent node'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addChild()`：该方法在父节点下添加一个子节点'
- en: '`printTree()`: This method prints a tree structure'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`printTree()`：该方法打印树形结构'
- en: 'Consider the following code for the `addChild()` function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下`addChild()`函数的代码：
- en: '[PRE10]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `addChild()` method takes the child node as an argument; the child node
    is added to the children array, and the parent of the child node is assigned as
    its parent node. The depth of the child node is the parent node plus one.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`addChild()`方法将子节点作为参数；子节点被添加到子节点数组中，并且子节点的父节点被设置为其父节点。子节点的深度是父节点深度加一。'
- en: 'Let''s look at this in the form of a block diagram for a clearer understanding:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以块图的形式来看这个，以便更清晰地理解：
- en: '![](img/3fa34ee8-15ae-447b-a6c7-b4c80f899674.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3fa34ee8-15ae-447b-a6c7-b4c80f899674.png)'
- en: Figure 23
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 23
- en: Let's suppose that we're adding node **f31** under node **d3**. So, **f31**
    will be added to the `children` property of **d3**, and the parent property of
    **f31** will be assigned as **d3**. In addition to that, the depth of the child
    node will be one more than the parent node. Here, the depth of node **d3** is
    **1**, so the depth of **f31** is **2**.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们要在节点**d3**下添加节点**f31**。那么，**f31**将被添加到**d3**的`children`属性中，并且**f31**的父节点属性将被设置为**d3**。此外，子节点的深度将比父节点深度多一。在这里，节点**d3**的深度是**1**，因此**f31**的深度是**2**。
- en: 'Let''s look at the `printTree` function, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`printTree`函数，如下所示：
- en: '[PRE11]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, this function prints the depth and the state of the current node; then,
    it looks through all of its children and calls the `printTree` method for each
    of them.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，该函数打印当前节点的深度和状态；然后，遍历所有子节点，并对每个子节点调用`printTree`方法。
- en: 'Let''s try to create the search tree shown in the following diagram:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试创建下图所示的搜索树：
- en: '![](img/a3f71cb8-67c0-40fc-b0c4-da5cf715a657.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3f71cb8-67c0-40fc-b0c4-da5cf715a657.png)'
- en: Figure 24
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 24
- en: As shown in the preceding diagram, as a root node we have the **Current directory**
    node; under that node, we have nodes **d1**, **d2**, and **d3**.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，作为根节点，我们有**当前目录**节点；在该节点下，有**d1**、**d2**和**d3**节点。
- en: 'We will create a `NodeTest` module, which will create the sample search tree:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`NodeTest`模块，它将创建示例搜索树：
- en: '[PRE12]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As shown in the preceding code, we created an initial state by creating a `State`
    object with no arguments, and then we passed this initial state to the `Node`
    class constructor, which creates a root node. To get the folders `d1`, `d2`, and
    `d3`, we called the `successorFunction` method on the initial state and we looped
    each of the child states (to create a node from each of them); we added each child
    node under the root node.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们通过创建一个没有参数的 `State` 对象来创建初始状态，然后将这个初始状态传递给 `Node` 类的构造函数，进而创建根节点。为了获取文件夹
    `d1`、`d2` 和 `d3`，我们在初始状态上调用 `successorFunction` 方法，并遍历每个子状态（从每个子状态创建一个节点）；我们将每个子节点添加到根节点下。
- en: 'When we execute the preceding code, we get the following output:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行上述代码时，我们将得到如下输出：
- en: '![](img/dda8ba44-3175-4f65-b077-43ce41ce39cd.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dda8ba44-3175-4f65-b077-43ce41ce39cd.png)'
- en: Figure 25
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 25
- en: Here, we can see that the current directory has a depth of `0`, and all of its
    contents have a depth `1`, including `d1`, `d2`, and `d3`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到当前目录的深度为 `0`，它的所有内容的深度为 `1`，包括 `d1`、`d2` 和 `d3`。
- en: With that, we have successfully built a sample search tree using the `Node`
    class.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们已经成功地使用 `Node` 类构建了一个示例搜索树。
- en: In the next topic, you'll be learning about the stack data structure, which
    will help us to create the DFS algorithm.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，你将学习栈数据结构，这将帮助我们创建 DFS 算法。
- en: Stack data structure
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈数据结构
- en: 'A **stack** is a pile of objects placed one atop another (for example, a stack
    of books, a stack of clothes, or a stack of papers). There are two stacking operations:
    one for adding items to a stack, and one for removing items from a stack.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**栈** 是一堆物体，一个叠一个地放置（例如，一堆书、一堆衣服或一堆纸）。栈有两个操作：一个用于将元素添加到栈中，另一个用于从栈中移除元素。'
- en: The operation used for adding items to a stack is called **push**, while the
    operation used for removing items is called as **pop**. Items are popped in the
    reverse order to push; that is why this data structure is called **last-in first-out**
    (**LIFO**).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 用于将元素添加到栈中的操作叫做 **push**，而移除元素的操作叫做 **pop**。元素是按压入顺序的逆序弹出的；这就是为什么这个数据结构叫做 **后进先出**（**LIFO**）的原因。
- en: 'Let''s experiment with the stack data structure in Python. We''ll be using
    the list data structure as a stack in Python. We''ll use the `append()` method
    to push items to the stack and the `pop()` method to pop them out:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Python 中实验栈数据结构。我们将使用列表数据结构作为栈来进行操作。在 Python 中，我们将使用 `append()` 方法将元素压入栈中，并使用
    `pop()` 方法将它们弹出：
- en: '[PRE13]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As shown in the preceding code, we have created an empty stack and we are printing
    it out. One by one, we are adding the numbers `1`, `2`, `3`, and `4` to the stack
    and printing them out. Then, one by one, we are popping the items and printing
    them out; finally, we are printing the remaining stack.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们创建了一个空栈并打印出来。我们一个接一个地将数字 `1`、`2`、`3` 和 `4` 添加到栈中并打印它们。然后，我们一个接一个地弹出这些元素并打印出来；最后，我们打印剩余的栈。
- en: 'If we execute the preceding code, `Stack.py`, we get the following output:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行上述代码，`Stack.py`，我们将得到如下输出：
- en: '![](img/6bb18db6-a7fe-4142-a56f-fb41715ed011.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6bb18db6-a7fe-4142-a56f-fb41715ed011.png)'
- en: Figure 26
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 26
- en: Initially, we have an empty stack, and when items `1`, `2`, `3`, and `4` are
    pushed to the stack, we have `4` at the top of the stack. Now, when you pop the
    items out, the first one to come out is `4`, then `3`, then `2`, and then `1`;
    this is the reverse of the order of entry. Then, finally, we have an empty stack.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最开始，我们有一个空栈，当元素 `1`、`2`、`3` 和 `4` 被压入栈时，栈顶为 `4`。现在，当你弹出元素时，第一个弹出的将是 `4`，然后是
    `3`，接着是 `2`，最后是 `1`；这正是入栈顺序的逆序。最后，我们会得到一个空栈。
- en: Now that we are clear on how stacks work, let's use these concepts to actually
    create a DFS algorithm.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们清楚了栈的工作原理，让我们将这些概念应用到实际的 DFS 算法创建中。
- en: The DFS algorithm
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DFS 算法
- en: Now that you understand the basic concepts of searching, we'll look at how DFS
    works by using the three basic ingredients of search algorithms—the initial state,
    the successor function, and the goal function. We will use the stack data structure.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了搜索的基本概念，我们将通过使用搜索算法的三大基本要素——初始状态、后继函数和目标函数，来了解 DFS 是如何工作的。我们将使用栈数据结构。
- en: 'Let''s first represent the DFS algorithm in the form of a flowchart, to offer
    a better understanding:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先用流程图来表示 DFS 算法，以便更好地理解：
- en: '![](img/c0aac8c3-b1e3-4226-aece-bc2a3276b23d.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0aac8c3-b1e3-4226-aece-bc2a3276b23d.png)'
- en: Figure 27
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 27
- en: 'The steps in the preceding flowchart are as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 前面流程图中的步骤如下：
- en: We create a root node using the initial state, and we add this to our stack
    and tree
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用初始状态创建根节点，并将其添加到我们的栈和树中。
- en: We pop a node from the stack
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从栈中弹出一个节点。
- en: We check whether it has the goal state; if it has the goal state, we stop our
    search here
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查它是否具有目标状态；如果它具有目标状态，我们就停止搜索。
- en: If the answer to the condition in step 3 is **No**, then we find the child nodes
    of the pop node, and add them to the tree and stack
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果步骤3中的条件答案是**否**，那么我们找到弹出节点的子节点，并将它们添加到树和栈中。
- en: We repeat steps 2 to 4 until we either find the goal state or exhaust all of
    the nodes in the search tree
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重复步骤2到4，直到找到目标状态或搜索树中的所有节点都被耗尽。
- en: 'Let''s apply the preceding algorithm to our filesystem, as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将前面的算法应用到我们的文件系统，如下所示：
- en: '![](img/5e9203c1-f883-4946-b17f-aed016d7cd96.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5e9203c1-f883-4946-b17f-aed016d7cd96.png)'
- en: Figure 28
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图28
- en: We create our root node, add it to the search tree, and add it to the stack.
    We pop a node from the stack, which is the **current directory** node.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建根节点，将其添加到搜索树，并将其添加到栈中。我们从栈中弹出一个节点，它是**当前目录**节点。
- en: The **current directory** node doesn't have the goal state, so we find its child
    nodes and add them to the tree and stack.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当前目录**节点没有目标状态，因此我们找到它的子节点，并将它们添加到树和栈中。'
- en: When we add nodes to the stack, they have to be added in reverse order, so that
    the node on the top of the stack is on the leftmost side of the search tree.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将节点添加到栈中时，必须按相反的顺序添加，以确保栈顶的节点在搜索树的最左侧。
- en: We pop a node from the stack (**d1**); it doesn't have the goal state, so we
    find its child nodes and add it to the tree and stack.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从栈中弹出一个节点（**d1**）；它没有目标状态，因此我们找到它的子节点，并将它们添加到树和栈中。
- en: We pop a node from the stack (**d11**); it doesn't have the goal state, so we
    find its child node, add it to the tree and stack.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从栈中弹出一个节点（**d11**）；它没有目标状态，因此我们找到它的子节点，并将它们添加到树和栈中。
- en: We pop a node (**f111**); it doesn't have the goal state, and it also doesn't
    have child nodes, so we carry on.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们弹出一个节点（**f111**）；它没有目标状态，而且也没有子节点，因此我们继续。
- en: We pop the next node, **d12**; we find its child nodes and add them to the tree
    and stack.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们弹出下一个节点，**d12**；我们找到它的子节点，并将它们添加到树和栈中。
- en: We pop the next node, **f121**, and it doesn't have any child nodes, so we carry
    on.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们弹出下一个节点，**f121**，它没有任何子节点，因此我们继续。
- en: We pop the next node, **f122**, and it doesn't have any child nodes, so we carry
    on.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们弹出下一个节点，**f122**，它没有任何子节点，因此我们继续。
- en: We pop the next node, **f11**, and we encounter the same case (where we have
    no child nodes), so we carry on; the same goes for **f12**.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们弹出下一个节点，**f11**，我们遇到了相同的情况（没有子节点），所以我们继续；**f12**也一样。
- en: We pop the next node, **d2**, and we find its child nodes and add them to the
    tree and stack.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们弹出下一个节点，**d2**，我们找到它的子节点，并将它们添加到树和栈中。
- en: We pop the next node, **d21**, and we find its child node and add it to the
    tree and stack.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们弹出下一个节点，**d21**，我们找到它的子节点，并将它添加到树和栈中。
- en: We pop the next node, **f211**, and we find that it has the goal state, so we
    end our search here.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们弹出下一个节点，**f211**，我们发现它具有目标状态，因此我们在这里结束搜索。
- en: 'Let''s try to implement these steps in code, as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将这些步骤实现为代码，如下所示：
- en: '[PRE14]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have created a Python module called `StackDFS.py`, and it has a method called
    `performStackDFS()`. In this method, we have created an empty stack, which will
    hold all of our nodes, the `initialState`, a root node containing the `initialState`,
    and finally we have added this root node to the stack.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`StackDFS.py`的Python模块，它有一个名为`performStackDFS()`的方法。在这个方法中，我们创建了一个空栈，它将存储我们所有的节点，`initialState`，一个包含`initialState`的根节点，最后我们将这个根节点添加到栈中。
- en: 'Remember that in `Stack.py`, we wrote a `while` loop to process all of the
    items in the stack. So, in the same way, in this case we will write a `while`
    loop to process all of the nodes in the stack:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在`Stack.py`中，我们写了一个`while`循环来处理栈中的所有项目。因此，在这种情况下，我们将编写一个`while`循环来处理栈中的所有节点：
- en: '[PRE15]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As shown in the preceding code, we pop the node from the top of the stack and
    call it `currentNode()`, and then we print it so that we can see the order in
    which the nodes are processed. We check whether the current node has the goal
    state, and if it does, we end our execution here. If it doesn't have the goal
    state, we find its child nodes and add it under `currentNode`, just like we did
    in `NodeTest.py`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如上面的代码所示，我们从栈顶弹出节点并将其称为 `currentNode()`，然后打印它，这样我们就可以看到节点处理的顺序。我们检查当前节点是否具有目标状态，如果有，我们在此处结束执行。如果没有目标状态，我们会找到它的子节点并将其添加到
    `currentNode` 下，就像我们在 `NodeTest.py` 中所做的那样。
- en: 'We will also add these child nodes to the stack, but in reverse order, using
    the following `for` loop:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将这些子节点按相反顺序添加到栈中，使用以下的 `for` 循环：
- en: '[PRE16]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, when we exit the `while` loop, we print the tree. Upon successful
    execution of the code, we will get the following output:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们退出 `while` 循环时，我们打印出树。代码成功执行后，我们将得到以下输出：
- en: '![](img/aa4c4d6e-6443-4809-9330-f3643fa353f3.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa4c4d6e-6443-4809-9330-f3643fa353f3.png)'
- en: Figure 29
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 29
- en: 'The output displays the order in which the nodes are processed, and we can
    see the first node of the tree. Finally, we encounter our goal state, and our
    search stops:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了节点处理的顺序，我们可以看到树的第一个节点。最终，我们遇到了我们的目标状态，搜索停止：
- en: '![](img/f1bf82a9-481d-46e1-95bd-d597c1f2ef6d.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1bf82a9-481d-46e1-95bd-d597c1f2ef6d.png)'
- en: Figure 30
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图 30
- en: The preceding screenshot displays the search tree. Note that the preceding output
    and the one before it are almost the same. The only difference is that in the
    preceding screenshot, we can find two nodes, `d22` and `d3`, because their parent
    nodes were explored.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图显示了搜索树。请注意，上面的输出和之前的输出几乎相同。唯一的区别是，在上面的截图中，我们可以找到两个节点，`d22` 和 `d3`，因为它们的父节点已经被探索过了。
- en: Recursive DFS
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归 DFS
- en: 'When a function calls itself, we say that the function is a **recursive** function.
    Let''s look at the example of the Fibonacci series. It is defined as follows: `f(1)`
    is equal to `1`, `f(2)` is equal to `1`, and for `n` greater than `2`, `f(n)`
    is equal to `f(n-1) + f(n-2)`. Let''s look at the implementation of this function
    in code, as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数调用自身时，我们说这个函数是**递归**函数。让我们看看斐波那契数列的例子。它的定义如下：`f(1)` 等于 `1`，`f(2)` 等于 `1`，对于
    `n` 大于 `2`，`f(n)` 等于 `f(n-1) + f(n-2)`。让我们看看这个函数在代码中的实现，代码如下：
- en: '[PRE17]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, we have created our function, `fibonacci`, which takes
    a number, `n`, as input. If `n` is less than or equal to `2`, it returns `1`;
    otherwise, it returns `fibonacci(n-1) + fibonacci(n-2)`. Toward the end of the
    code, we have calculated the value of `fibonacci(5)`, which is `5`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们创建了我们的函数，`fibonacci`，它接受一个数字 `n` 作为输入。如果 `n` 小于或等于 `2`，它返回 `1`；否则，它返回
    `fibonacci(n-1) + fibonacci(n-2)`。在代码的末尾，我们计算了 `fibonacci(5)` 的值，即 `5`。
- en: 'The output of running the preceding code is shown in the following screenshot:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上面代码的输出如下截图所示：
- en: '![](img/8028501a-a5ef-4830-9278-60900c68c837.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8028501a-a5ef-4830-9278-60900c68c837.png)'
- en: Figure 31
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 31
- en: If we want to visualize the recursion tree of the `fibonacci` function, we can
    go to [https://visualgo.net/en/recursion](https://visualgo.net/en/recursion).
    This website has visualizations of various data structures and algorithms.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想可视化 `fibonacci` 函数的递归树，可以访问 [https://visualgo.net/en/recursion](https://visualgo.net/en/recursion)。这个网站提供了各种数据结构和算法的可视化。
- en: 'The visualization of a recursion tree is as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 递归树的可视化如下：
- en: '![](img/7042a331-bc4a-43a9-9946-7e0d617e9f73.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7042a331-bc4a-43a9-9946-7e0d617e9f73.png)'
- en: Figure 32
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 32
- en: As shown in the preceding screenshot, the output that we get here is the same
    as the output we got with the code, and the order in which the nodes were explored
    is similar to DFS.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如上面的截图所示，我们在这里得到的输出与我们用代码得到的输出相同，并且节点被探索的顺序与深度优先搜索（DFS）相似。
- en: So, *what happens when function 1 calls function 2?* The program adds a stack
    frame to the program stack. A stack frame contains the local variables in function
    1, the arguments passed to function 1, and the return addresses of function 2
    and function 1.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，*当函数 1 调用函数 2 时会发生什么？* 程序会在程序栈上添加一个栈帧。栈帧包含函数 1 的局部变量、传递给函数 1 的参数，以及函数 2 和函数
    1 的返回地址。
- en: 'Let''s look at the example of the Fibonacci sequence again:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看斐波那契数列的例子：
- en: '![](img/c469c95e-871a-4864-891c-063b617ba61c.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c469c95e-871a-4864-891c-063b617ba61c.png)'
- en: Figure 33
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 33
- en: As you can see, the Fibonacci code has been modified for the sake of clarity.
    Suppose that the program is executing the line in bold, **val2 = fibonacci(n-2)**.
    Then, the stack frame created will contain the following values—local variables
    is equal to **val1**, arguments passed is equal to **n**, and return address is
    the address of the code in bold.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，斐波那契代码为了更清晰而进行了修改。假设程序正在执行加粗的那一行，**val2 = fibonacci(n-2)**。那么，创建的栈帧将包含以下值——局部变量为
    **val1**，传递的参数为 **n**，返回地址为加粗部分代码的地址。
- en: This means that the return address points to the unprocessed curve. Because
    in recursion the program stack keeps a stack of unprocessed calls, instead of
    storing nodes in the stack, we will call DFS recursively on the child nodes, so
    that the stack is indirectly maintained.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着返回地址指向未处理的曲线。因为在递归中，程序栈保持一堆未处理的调用，而不是将节点存储在栈中，我们会递归地对子节点调用 DFS，这样栈就间接地得到了维护。
- en: 'Let''s look at the steps of recursive DFS in the following diagram:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下递归 DFS 在以下图示中的步骤：
- en: '![](img/3c4cd97a-bc72-4994-9b8b-24b26481219a.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c4cd97a-bc72-4994-9b8b-24b26481219a.png)'
- en: Figure 34
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 34
- en: 'The steps in the preceding diagram are explained as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示中的步骤解释如下：
- en: We create an initial state.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个初始状态。
- en: We create a root node with this initial state.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用这个初始状态创建了一个根节点。
- en: We add the root node to the search tree and call DFS on the root node.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将根节点添加到搜索树中，并对根节点调用 DFS。
- en: 'Recursive DFS is defined as follows: check whether the node has a goal state.
    If yes, then it returns the path; if no, then DFS finds the children node, and
    for each child node DFS adds the node to the tree, finally calling itself on the
    child node.'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归 DFS 定义如下：检查节点是否具有目标状态。如果是，则返回路径；如果没有，则 DFS 会找到子节点，对于每个子节点，DFS 会将该节点添加到树中，最后在子节点上递归调用自身。
- en: 'Now, we will apply the preceding algorithm to our filesystem, the steps for
    which are as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将上述算法应用于我们的文件系统，步骤如下：
- en: '![](img/1ea9aa73-f110-4a16-991e-f669760d0f94.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ea9aa73-f110-4a16-991e-f669760d0f94.png)'
- en: Figure 35
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图 35
- en: We create the root node and add it to the search tree, and we call DFS on this
    root node.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建根节点并将其添加到搜索树中，并对该根节点调用 DFS。
- en: When we call DFS on this root node, the function checks whether this node has
    the goal state, and it doesn't, so it finds its children nodes (**d1**, **d2**,
    and **d3**). It takes the first node, **d1**, adds it to the search tree, and
    calls DFS on the node.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们对这个根节点调用 DFS 时，函数会检查该节点是否具有目标状态，如果没有，它会找到其子节点（**d1**，**d2** 和 **d3**）。它选取第一个节点
    **d1**，将其添加到搜索树中，并对该节点调用 DFS。
- en: When it calls DFS on **d1**, the function creates a program. When DFS is called
    on **d1**, then the program creates a stack frame and adds it to the program stack.
    In this case, we'll show the remaining nodes to be processed in the `for` loop.
    Here, we're adding **d2** and **d3** in the program stack.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当对 **d1** 调用 DFS 时，函数会创建一个程序。当对 **d1** 调用 DFS 时，程序会创建一个栈帧并将其添加到程序栈中。在这种情况下，我们将在
    `for` 循环中展示剩余需要处理的节点。这里，我们将 **d2** 和 **d3** 添加到程序栈中。
- en: When DFS is called on **d1**, it finds the children nodes **d11**, **d12**,
    **f11**, and **f12**, and adds **d11** to the search tree.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当对 **d1** 调用 DFS 时，它会找到子节点 **d11**，**d12**，**f11** 和 **f12**，并将 **d11** 添加到搜索树中。
- en: It calls DFS on **d11**, and when it does so, it creates an entry in the program
    stack with the unprocessed nodes. Now, when DFS is called on **d11**, it finds
    the child node **f111**, adds **f111** to the search tree, and calls DFS on the
    node.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它对 **d11** 调用 DFS，当它这么做时，它会在程序栈中创建一个包含未处理节点的条目。现在，当对 **d11** 调用 DFS 时，它会找到子节点
    **f111**，将 **f111** 添加到搜索树中，并对该节点调用 DFS。
- en: When DFS is called on **f111,** it has no children nodes, so it returns back;
    when this happens, the program stack is unwounded, which means that the program
    returns execution and processes the last unprocessed nodes in the stack. In this
    case, it starts processing node **d12**. So, the program adds node **d12** to
    the search tree, and calls DFS on **d1**.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当对 **f111** 调用 DFS 时，它没有子节点，所以它会返回；当这种情况发生时，程序栈会被解开，意味着程序会返回执行并处理栈中最后一个未处理的节点。在这种情况下，它开始处理节点
    **d12**。因此，程序将节点 **d12** 添加到搜索树中，并对 **d1** 调用 DFS。
- en: When DFS is called on **d12**, it finds the children nodes **f121** and **f122**.
    It adds node **f121** to the search tree, and calls DFS on it. When DFS is called
    on **f121**, it adds the unprocessed node **f122** to the stack.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当对 **d12** 调用 DFS 时，它会找到子节点 **f121** 和 **f122**。它将节点 **f121** 添加到搜索树，并对其调用 DFS。当对
    **f121** 调用 DFS 时，它将未处理的节点 **f122** 添加到栈中。
- en: When DFS is called on **f121,** it has no children nodes, so again the stack
    is unwounded. So, we process node **f122**. This node is added to the search tree
    and DFS is called on it. So, we continue processing the last node, **f11**, add
    it to the search tree, and call DFS on it.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当对**f121**调用DFS时，它没有子节点，因此栈会被解开。然后，我们处理节点**f122**。这个节点被添加到搜索树中，并对其调用DFS。接着，我们继续处理最后一个节点**f11**，将其添加到搜索树中，并对其调用DFS。
- en: When we call DFS on **f11,** it has no children nodes, so again the stack is
    unwounded. We continue processing node **f12**, it is added to the search tree,
    and DFS is called on **f12**. We encounter this case, and we continue processing
    node **d2**. We add it to the search tree, and we call DFS on **d2**.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们对**f11**调用DFS时，它没有子节点，因此栈再次被解开。我们继续处理节点**f12**，将其添加到搜索树中，并对其调用DFS。我们遇到了这种情况，然后继续处理节点**d2**。我们将其添加到搜索树中，并对**d2**调用DFS。
- en: 'When we call DFS on **d2,** we find that is has children nodes: **d21** and
    **d22**. We add **d21** to the search tree, and we call DFS on **d21**; when we
    call DFS on **d21,** it creates an entry for **d22**. In the program stack, when
    DFS is called on **d21,** we find that it has a child, **f211**. This node is
    added to the search tree and DFS is called on **f211**.'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们对**d2**调用DFS时，发现它有子节点：**d21**和**d22**。我们将**d21**添加到搜索树中，并对**d21**调用DFS；当我们对**d21**调用DFS时，它会为**d22**创建一个入口。在程序栈中，当对**d21**调用DFS时，发现它有一个子节点**f211**。这个节点被添加到搜索树中，并对**f211**调用DFS。
- en: When DFS is called an **f211**, we realize that it has the goal state, and we
    end our search process here.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当对**f211**调用DFS时，我们意识到它包含目标状态，搜索过程在此结束。
- en: 'Let''s look at how we can implement recursive DFS, as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现递归DFS，代码如下：
- en: '[PRE18]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As shown in the preceding code, we have created a Python module called `RecursiveDFS.py`.
    It has a class called `RecursiveDFS`, and, in the constructor, it has a property
    called `found`, which indicates whether the solution has been found. We'll look
    at the significance of the `found` variable later.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们创建了一个名为`RecursiveDFS.py`的Python模块。它包含一个名为`RecursiveDFS`的类，在构造函数中有一个名为`found`的属性，用来表示是否已找到解决方案。稍后我们将查看`found`变量的重要性。
- en: 'Let''s look at the following lines of code:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下以下几行代码：
- en: '[PRE19]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we have a method called `search`, in which we are creating the `initialState`,
    and the `rootNode` we''re calling the DFS function on the `rootNode`. Finally,
    we print the tree after we perform the DFS search, as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个名为`search`的方法，在其中我们创建了`initialState`，并在`rootNode`上调用DFS函数。最后，在执行DFS搜索后，我们打印出树的内容，如下所示：
- en: '[PRE20]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `DFS` function can be defined as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`DFS` 函数可以定义如下：'
- en: If the solution has not been found, then the node that is being processed is
    printed
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未找到解决方案，则打印当前正在处理的节点。
- en: We check whether the node has the goal state, and if it does, we print that
    the goal state has been reached
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们检查节点是否包含目标状态，如果包含，我们就打印出已经达成目标状态。
- en: If it doesn't have the goal state, we find the child states; next, we create
    the child node for each child state, we add them to the tree, and we call `DFS`
    on each of the child nodes
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它没有目标状态，我们就寻找子状态；接下来，我们为每个子状态创建子节点，将它们添加到树中，并对每个子节点调用`DFS`。
- en: 'Let''s execute the program; we will get the following output:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行程序，我们将得到以下输出：
- en: '![](img/17689949-b959-4be7-b181-6193c705ce0b.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17689949-b959-4be7-b181-6193c705ce0b.png)'
- en: Figure 36
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图 36
- en: 'When we processed `f211`, we reached the goal state, but here we have three
    extra lines; this is because these nodes have been added to the program stack.
    To remove these lines, we have created a variable called `found`, so that when
    the goal state is found, the variable will be set to `True`. Once we encounter
    `f211`, the remaining nodes in the program stack will not be processed:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理`f211`时，达到了目标状态，但这里有三行多余的输出；这是因为这些节点已经被添加到程序栈中。为了去除这些行，我们创建了一个名为`found`的变量，当目标状态被找到时，变量将被设置为`True`。一旦遇到`f211`，程序栈中的剩余节点将不会被处理：
- en: '![](img/3ed5768f-f868-4d3b-9929-514e6a724a7f.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ed5768f-f868-4d3b-9929-514e6a724a7f.png)'
- en: Figure 37
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图 37
- en: 'Let''s run this code again and see what happens:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行这段代码，看看会发生什么：
- en: '![](img/b3096f63-5186-404a-bb0a-790a9bb10ec0.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3096f63-5186-404a-bb0a-790a9bb10ec0.png)'
- en: Figure 38
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图 38
- en: As you can see, once we've processed `f211` and reached the goal state, the
    node processing stops. The output of the `printTree` function is the same as what
    we store in `StackDFS.py`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一旦我们处理了`f211`并达到了目标状态，节点处理就停止了。`printTree`函数的输出与我们在`StackDFS.py`中存储的内容相同。
- en: Now that you understand how DFS can be made into a recursive function, in the
    next topic we will look at an application that you can develop by yourself.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了如何将DFS实现为递归函数，在下一个主题中，我们将讨论一个你可以自己开发的应用。
- en: Do it yourself
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自己动手
- en: In this section, we will look at an application that you can develop by yourself.
    We will take a look at a new application and discuss the changes that are required.
    In the *Introduction to file search applications* section, we discussed two applications
    of file searching; now, we will develop the second type of example. Our aim is
    to develop a search application that is able to find program files containing
    specific program text.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一个你可以自己开发的应用程序。我们将看看一个新的应用，并讨论需要进行的修改。在*文件搜索应用介绍*部分，我们讨论了两种文件搜索的应用；现在，我们将开发第二种类型的示例。我们的目标是开发一个能够查找包含特定程序文本的程序文件的搜索应用。
- en: 'In the code for recursive DFS, we mainly used three classes, as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在递归DFS的代码中，我们主要使用了三个类，如下所示：
- en: '**State**: This has the three main ingredients of the search process'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态（State）**：包含搜索过程的三个主要要素'
- en: '**Node**: This is used to build search trees'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点（Node）**：用于构建搜索树'
- en: '**Recursive** **DFS**: This has the actual algorithm implementation'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**递归** **DFS**：包含实际的算法实现'
- en: 'Suppose that we want to adapt this code or file search application to new application.
    We will need to change three methods: `getInitialState`, `successorFunction`,
    and `checkGoalState`. For the new application of program searching, you will need
    to change just one method: `checkGoalState`.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将这个代码或文件搜索应用程序适配到新的应用程序中。我们需要修改三个方法：`getInitialState`、`successorFunction`和`checkGoalState`。对于新的程序搜索应用，你只需要修改一个方法：`checkGoalState`。
- en: In your new `checkGoalState` function, you will need to open the file, read
    the contents of the file line by line, and perform a substring check or regular
    expression check. Lastly, based on the results of the check, you will return true
    or false.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的新`checkGoalState`函数中，你需要打开文件，逐行读取文件内容，并进行子字符串检查或正则表达式检查。最后，根据检查结果返回true或false。
- en: So, go ahead and try it out for yourself!
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，去试试看吧！
- en: Summary
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小结
- en: 'In this chapter, we looked at four basic concepts related to searching: the
    state, which is the condition of our search process; the node, which is used for
    building a search tree; the stack, which helps to traverse the search tree and
    decides the order in which the nodes are traversed; and recursion, which eliminates
    the need for an explicit stack. You also learned about DFS, which explores the
    search tree in a depth-first order.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了与搜索相关的四个基本概念：状态（state），即我们搜索过程的当前状态；节点（node），用于构建搜索树；栈（stack），用于帮助遍历搜索树，并决定遍历节点的顺序；递归（recursion），它消除了显式栈的需求。你还学习了深度优先搜索（DFS），它以深度优先的顺序探索搜索树。
- en: In the next chapter, you'll learn about **breadth-first search** (**BFS**),
    which explores a search tree in a breadth-first order. See you there!
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习**广度优先搜索**（**BFS**），它以广度优先的顺序探索搜索树。到时候见！
- en: Please refer to the link [https://www.packtpub.com/sites/default/files/downloads/HandsOnArtificialIntelligenceforSearch_ColorImages.pdf](https://www.packtpub.com/sites/default/files/downloads/HandsOnArtificialIntelligenceforSearch_ColorImages.pdf) for
    the colored images of this chapter.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考链接 [https://www.packtpub.com/sites/default/files/downloads/HandsOnArtificialIntelligenceforSearch_ColorImages.pdf](https://www.packtpub.com/sites/default/files/downloads/HandsOnArtificialIntelligenceforSearch_ColorImages.pdf)，查看本章的彩色图片。
