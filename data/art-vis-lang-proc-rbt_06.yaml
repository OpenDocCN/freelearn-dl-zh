- en: '*Chapter 6*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 6 章*'
- en: Robot Operating System (ROS)
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器人操作系统（ROS）
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Explain Robot Operating System (ROS) essentials and basic concepts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释机器人操作系统（ROS）的基本概念和要点
- en: Create Robot Operating System packages and work with them
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建机器人操作系统软件包并与之协作
- en: Operate a virtual robot with information obtained from sensors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用从传感器获取的信息操作虚拟机器人
- en: Develop and implement working programs for robots
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发并实现机器人的工作程序
- en: This chapter focuses on ROS and the different ways to work with its packages.
    You'll also learn how to operate a virtual robot based on the information received
    from its sensors using ROS.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍 ROS 及其软件包的不同工作方式。你还将学习如何根据从传感器接收到的信息使用 ROS 操作虚拟机器人。
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: Developing software for robots is not as easy as developing any other type of
    software. To build robots, you need methods and functions that enable you to access
    sensor information, control robot parts, and connect with the robot. These methods
    and functions are present in ROS, making it easier to build a virtual robot.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为机器人开发软件并不像为其他类型的软件开发那么简单。要构建机器人，你需要一些方法和功能，这些方法能够让你访问传感器信息、控制机器人部件并与机器人连接。这些方法和功能都包含在
    ROS 中，使得构建虚拟机器人变得更容易。
- en: '**ROS** is a framework that is compatible with Ubuntu (Linux) for writing robot
    software. It is a set of libraries and tools through which it is possible to build
    and create various robotic behaviors. One of the most interesting features about
    this framework is that the developed code can be adapted for any other robot.
    ROS also gives you a chance to work on several machines simultaneously; for instance,
    if you want to use a robot to collect apples, you can use a computer to obtain
    the camera information of the apple and process it, another machine to launch
    the movement that commands the robot, and finally the robot will pick up the apple.
    By following this workflow, computers won''t perform too many computational tasks,
    and the execution turns out to be more fluid.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**ROS** 是一个与 Ubuntu（Linux）兼容的框架，用于编写机器人软件。它是一组库和工具，通过这些工具可以构建和创建各种机器人行为。关于这个框架最有趣的特点之一是，开发的代码可以适配任何其他机器人。ROS
    还允许你在多台机器上同时工作；例如，如果你想用机器人采摘苹果，你可以使用一台计算机获取苹果的摄像头信息并进行处理，另一台机器发出控制机器人的运动命令，最后机器人将摘取苹果。通过这种工作流程，计算机不会执行过多的计算任务，执行过程也更加流畅。'
- en: ROS is the most widely used tool for robotics, both for researchers and companies.
    It is becoming a standard for robotics tasks. Furthermore, ROS is constantly evolving
    to solve new problems and is adapting to different technologies. All these facts
    make it a good topic for studying and practicing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ROS 是机器人领域最广泛使用的工具，既适用于研究人员，也适用于公司。它正成为机器人任务的标准工具。此外，ROS 正在不断发展，以解决新的问题，并适应不同的技术。所有这些事实使它成为学习和实践的好主题。
- en: ROS Concepts
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ROS 概念
- en: 'As mentioned earlier, working with ROS is not easy the first time round. But
    just like any other software, you need to know how ROS works and how to perform
    certain tasks using it. In order to do that and before installing or working with
    the framework, it is important to understand its basic concepts. The key ideas
    behind ROS'' functions that will help you understand its internal processes are
    mentioned here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，第一次使用 ROS 时并不容易。但就像任何其他软件一样，你需要了解 ROS 是如何工作的，并学会如何使用它执行某些任务。在安装或使用框架之前，理解其基本概念是非常重要的。ROS
    功能背后的关键思想将帮助你理解其内部流程，下面列出了这些关键点：
- en: '**Node**: An ROS node is a process in charge of performing tasks and calculations.
    They can be combined with each other using topics or other more complex tools.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点**：ROS 节点是负责执行任务和计算的进程。它们可以通过话题或其他更复杂的工具相互组合。'
- en: '**Topic**: Topics can be defined as information channels between nodes that
    work in a unidirectional way. This is considered a unidirectional workflow because
    nodes can subscribe to topics, but a topic would not know which nodes are subscribed
    to it.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**话题**：话题可以定义为节点之间的信息通道，工作方式是单向的。这被视为一种单向工作流，因为节点可以订阅话题，但话题并不知道哪些节点已订阅它。'
- en: '**Master**: The ROS master is a service that provides a name and registration
    to the remaining nodes. Its main function is to enable individual nodes so that
    they can locate each other and establish peer-to-peer communication.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Master**：ROS主控是一个提供节点名称和注册的服务。它的主要功能是启用各个节点，使它们能够相互定位并建立点对点通信。'
- en: '**Package**: Packages are the core of ROS organization. Within these packages,
    you can find nodes, libraries, datasets, or useful components to build a robotics
    application.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Package**：包是ROS组织的核心。在这些包中，你可以找到节点、库、数据集或用于构建机器人应用程序的有用组件。'
- en: '**Stack**: An ROS stack is a set of nodes that, all together, provide some
    functionality. It can be useful for dividing tasks between nodes when the functionality
    to develop is too complex.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Stack**：一个ROS栈是一组节点，它们共同提供某些功能。当需要开发的功能过于复杂时，将任务分配给不同的节点可能会非常有用。'
- en: 'Apart from the aforementioned concepts, there are many other concepts that
    can be useful when using ROS, but understanding these basic ones will let you
    implement powerful programs for robots. Let''s look at a simple example in order
    to learn how they would be used in a real situation:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述概念外，还有许多其他概念在使用ROS时也非常有用，但理解这些基础概念将使你能够为机器人实现强大的程序。让我们来看一个简单的例子，了解它们在实际情况中的使用方法：
- en: '![Figure 6.1: A schema of a real example system using ROS](img/C13550_06_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1：使用ROS的真实示例系统的框图](img/C13550_06_01.jpg)'
- en: 'Figure 6.1: A schema of a real example system using ROS'
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.1：使用ROS的真实示例系统的框图
- en: 'The situation here consists of a robot changing its direction when detecting
    a close obstacle. This is how it works step by step:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的情况是，当机器人检测到近距离障碍物时，它会改变方向。其工作原理如下：
- en: The ROS master is enabled. This means the ROS system has been started and can
    have any node run.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ROS主控已启用。这意味着ROS系统已启动，可以运行任何节点。
- en: The proximity node starts and extracts information from the laser sensor. It
    advertises the master to publish this obtained information. If there's no problem
    and the information has the expected type, the master will allow the node to publish
    through a topic.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接近节点启动并提取激光传感器的信息。它会通知主控发布这些获取的信息。如果没有问题，并且信息类型符合预期，主控将允许节点通过话题发布。
- en: Once the master allows the node to publish, the information is passed to a topic
    and published. In this case, the proximity node publishes the information in the
    laser topic.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦主控允许节点发布，信息会被传递到一个话题并发布。在这种情况下，接近节点在激光话题中发布信息。
- en: The movement node asks the master to subscribe to a laser topic. When subscribed,
    it will obtain the published information and work with it to decide the next action
    for the robot to perform.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动节点请求主控订阅激光话题。订阅后，它将获得发布的信息，并使用这些信息决定机器人执行的下一个动作。
- en: To sum up, both nodes can share information using the master service, which
    notifies both nodes about each other's existence.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，两个节点可以通过主控服务共享信息，该服务会通知两个节点彼此的存在。
- en: ROS Commands
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ROS命令
- en: 'ROS doesn''t have a graphical user interface to work with it; every action
    must be performed on the command line as it is compatible with Ubuntu. However,
    before getting your hands on the ROS, you need to learn about its most common
    commands. Here''s a short list of them and their functionality:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ROS没有图形用户界面来进行操作；每个操作必须在命令行中执行，因为它与Ubuntu兼容。然而，在使用ROS之前，你需要了解它最常用的命令。这里有一个简短的命令列表以及它们的功能：
- en: '**roscore**: This is the first command to be run when working with ROS. It
    enables the framework and provides support to any ROS program or operation. It
    should be launched in order to allow node communication.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**roscore**：这是与ROS一起工作时要运行的第一个命令。它启用框架并为任何ROS程序或操作提供支持。必须启动它才能允许节点间的通信。'
- en: '**roscd**: This command switches to a stack or package directory without entering
    a physical path.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**roscd**：此命令用于切换到一个栈或包目录，而无需进入物理路径。'
- en: '**rosnode**: These commands manage nodes and obtain information about them.
    Here, you can see the most used rosnode commands:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rosnode**：这些命令用于管理节点并获取关于它们的信息。在这里，你可以看到最常用的rosnode命令：'
- en: '**rosnode list**: This command prints the information of active nodes.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rosnode list**：此命令打印活动节点的信息。'
- en: '**rosnode info <node_name>**: This informs the user about the entered node.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rosnode info <node_name>**：此命令用于通知用户关于输入节点的信息。'
- en: '**rosnode kill <node_name>**: The function of this command is to stop a node
    process.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rosnode kill <node_name>**：此命令的功能是停止一个节点进程。'
- en: '**rosrun**: Using this command, you can run any application on your system
    without switching to its directory.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rosrun**：使用此命令，你可以运行系统上的任何应用程序，而无需切换到其目录。'
- en: '**rostopic**: This command allows you to manage and check topic information.
    There are several other types for this command:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rostopic**：此命令允许你管理和检查主题信息。此命令还有多个其他类型：'
- en: '**rostopic list**: This type prints the information of active topics.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rostopic list**：此命令打印活动主题的信息。'
- en: '**rostopic info <topic_name>**: This shows information about a concrete topic.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rostopic info <topic_name>**：此命令显示关于具体主题的信息。'
- en: '**rostopic pub <topic_name> [data...]**: The function of this command is to
    publish the given data to the entered topic.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rostopic pub <topic_name> [data...]**：此命令的功能是将给定的数据发布到指定的主题。'
- en: '**rqt_graph**: This is a very useful command that can be used to graphically
    observe active nodes and topics that are being published or subscribed to.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rqt_graph**：这是一个非常有用的命令，可以用来图形化地观察活动节点和正在发布或订阅的主题。'
- en: Installation and Configuration
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装与配置
- en: The first thing to consider before installing ROS is the installed Ubuntu version.
    There are several ROS versions that you will have to choose from depending on
    your operating system version. In this case, we are explaining the installation
    of ROS Kinetic Kame, which is compatible with Ubuntu 16.04 LTS (Xenial Xerus).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 安装ROS之前，首先需要考虑安装的Ubuntu版本。根据你的操作系统版本，有几个ROS版本可供选择。在这种情况下，我们正在解释安装兼容Ubuntu 16.04
    LTS（Xenial Xerus）的ROS Kinetic Kame版本。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If this is not your Ubuntu version, you can head to the ROS website, [http://www.ros.org/](http://www.ros.org/),
    and look for the corresponding distribution.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这不是你的Ubuntu版本，你可以前往ROS官网，[http://www.ros.org/](http://www.ros.org/)，查找对应的发行版。
- en: As happens with almost every other tool, it is recommended to always install
    the latest version, because it may have solved errors or new functionalities;
    but, as mentioned before, don't worry if you're working with an older version.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 就像几乎所有其他工具一样，建议始终安装最新版本，因为它可能已经解决了错误或新增了功能；但如前所述，如果你使用的是旧版本，也不必担心。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: To get detailed steps on how to install ROS, refer to the preface on page vi.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取安装ROS的详细步骤，请参阅前言第vi页。
- en: Catkin Workspaces and Packages
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Catkin工作空间和包
- en: This is the last step before coding your first application and program for robots.
    You have to set up your working environment. To do this, you are going to learn
    what catkin workspaces and packages are and how to work with them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在为机器人编写第一个应用程序和程序之前的最后一步。你需要设置工作环境。为此，你将学习什么是catkin工作空间和包，以及如何使用它们。
- en: A catkin workspace is a ROS directory where catkin packages can be created,
    compiled, and run. A catkin package is a container for creating ROS nodes and
    applications. Each of these packages work as a single project that can contain
    multiple nodes. It is important to know that the ROS code inside catkin packages
    can only be Python or C++.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: catkin工作空间是一个ROS目录，可以在其中创建、编译和运行catkin包。catkin包是用于创建ROS节点和应用程序的容器。每个包作为一个单独的项目，可以包含多个节点。需要了解的是，catkin包中的ROS代码只能是Python或C++语言。
- en: 'Now, let''s see how to create the catkin workspace:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下如何创建catkin工作空间：
- en: Note
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Execute these commands in the same terminal window.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一终端窗口中执行这些命令。
- en: 'Create a standard folder containing a subfolder named "`src`." You can choose
    any location on your system:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个标准文件夹，其中包含一个名为"`src`"的子文件夹。你可以选择系统上的任何位置：
- en: '[PRE0]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Switch to the new `catkin_ws` directory and run the `catkin` compilation command
    to initialize the new workspace:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到新的`catkin_ws`目录并运行`catkin`编译命令来初始化新的工作空间：
- en: '[PRE1]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command must be executed every time you want to compile your workspace
    when making changes in any package.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每次在任何包中进行更改时，必须执行此命令才能编译工作空间。
- en: 'By following these simple steps, you will have your catkin workspace ready
    to work with. But, when working on it, you should always remember to enter this
    command first:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些简单的步骤，你将完成catkin工作空间的设置。但在使用时，你应始终记住先输入以下命令：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This lets ROS know that there can be ROS executables in the created catkin workspace.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这让ROS知道在创建的catkin工作空间中可以存在ROS可执行文件。
- en: 'If you have successfully completed the preceding process, you can now create
    your catkin packages and work on them. Create a package with the steps mentioned
    here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经成功完成了前面的过程，现在可以创建catkin包并开始工作。按照此处提到的步骤创建一个包：
- en: 'Go into the "`src`" folder of your catkin workspace:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入你的catkin工作空间中的"`src`"文件夹：
- en: '[PRE3]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Use this command to create a package:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此命令创建一个包：
- en: '[PRE4]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The dependencies are a set of libraries or tools that the package needs to
    function correctly. For example, in a simple package where you only use Python
    code, the command will be as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项是包正常运行所需的一组库或工具。例如，在一个仅使用Python代码的简单包中，命令将如下所示：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Publishers and Subscribers
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布者和订阅者
- en: When explaining basic ROS concepts, we discussed a few nodes used for publishing
    data and some others used for subscribing to that data. Knowing this, it is not
    hard to imagine that nodes can be classified into two groups, depending on the
    kind of action they perform. They can be **publishers** or **subscribers**. Why
    do you think it is important to distinguish between these two types of nodes?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释基本的ROS概念时，我们讨论了一些用于发布数据的节点和一些用于订阅数据的节点。了解这一点后，我们不难想象，节点可以根据它们执行的操作类型分为两类。它们可以是**发布者**或**订阅者**。你认为区分这两种类型的节点为什么很重要？
- en: As mentioned earlier, publishers are nodes that provide information to other
    nodes. They usually work with sensors to check the environment status and convert
    it into valuable outputs for subscribers that can receive this information.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，发布者是向其他节点提供信息的节点。它们通常与传感器一起工作，检查环境状态并将其转换为有价值的输出，供能够接收这些信息的订阅者使用。
- en: On the other hand, subscribers usually get an understandable input and process
    it. They then decide which action will be launched depending on the obtained result.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，订阅者通常会接收可以理解的输入并进行处理。然后，它们会根据获得的结果决定将启动哪个操作。
- en: As this is a rarely used type of programming, it will be interesting to follow
    some examples of how these nodes really work, before starting to use them with
    robots and simulators. So, let's go through some exercises that will help you
    understand nodes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一种较少使用的编程类型，在开始将其应用于机器人和模拟器之前，跟随一些示例了解这些节点的实际工作方式将会很有趣。所以，让我们通过一些练习来帮助你理解节点的工作原理。
- en: 'Exercise 20: Publishing and Subscribing'
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 20：发布与订阅
- en: 'In this example, we will write a simple publisher and subscriber in Python
    using the following steps:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用以下步骤编写一个简单的发布者和订阅者：
- en: 'Open a new terminal and enter the `roscore` command to start the ROS service:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端并输入`roscore`命令以启动ROS服务：
- en: '[PRE6]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a new package in your catkin workspace that contains the solution to
    this exercise. This package will depend on `rospy` and `std_msgs`, so you must
    create it as follows:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的catkin工作空间中创建一个新包，其中包含该练习的解决方案。此包将依赖于`rospy`和`std_msgs`，因此你必须按如下方式创建它：
- en: '[PRE7]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '`std_msgs` is a package that provides support to ROS primitive data types.
    You can find more information about it, including the concrete types of managed
    data, here: [http://wiki.ros.org/std_msgs](http://wiki.ros.org/std_msgs).'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`std_msgs`是一个为ROS原始数据类型提供支持的包。你可以在这里找到更多有关它的信息，包括管理数据的具体类型：[http://wiki.ros.org/std_msgs](http://wiki.ros.org/std_msgs)。'
- en: 'Switch to the package directory and create a new folder, which will contain
    publisher and subscriber files, for example:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到包目录并创建一个新文件夹，其中将包含发布者和订阅者文件，例如：
- en: '[PRE8]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Go into the new folder and create a corresponding Python file for each node:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入新文件夹并为每个节点创建相应的Python文件：
- en: '[PRE9]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Provide the executable permission to both files:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为两个文件提供可执行权限：
- en: '[PRE10]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Begin with the publisher implementation:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从发布者实现开始：
- en: Initialize the Python environment and import the necessary libraries.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 初始化Python环境并导入必要的库。
- en: Note
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE11]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Create a function to publish the message.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个函数来发布消息。
- en: '[PRE12]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Declare a publisher that publishes a `String` message into a new topic, no matter
    its name.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 声明一个发布者，将一个`String`消息发布到一个新主题，无论其名称是什么。
- en: '[PRE13]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE14]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Use the created publisher variable to publish any desired `String`. For instance:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用创建的发布者变量发布任何所需的`String`。例如：
- en: '[PRE15]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, detect the program entry and call the created function:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，检测程序入口并调用创建的函数：
- en: '[PRE16]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Continue with the subscriber implementation:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续实现订阅者：
- en: Initialize Python and import libraries as you did for your publisher.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 初始化Python并导入库，方法与为发布者所做的一样。
- en: Note
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE17]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a function to subscribe to the topic:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个函数来订阅该主题：
- en: '[PRE18]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Initialize the node in the same way as you did before:'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以与你之前相同的方式初始化节点：
- en: '[PRE19]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Subscribe to `publisher_topic` using this function:'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用此函数订阅`publisher_topic`：
- en: '[PRE20]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE21]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Implement the `callback` function to print a message when it receives any data.
    For this first exercise, let''s kill the subscriber node when receiving the first
    message from the publisher. This can be done with the `signal_shutdown` method,
    which is integrated in `rospy` and only needs the shutdown reason as a parameter:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现`callback`函数，当接收到任何数据时打印消息。对于这个第一个练习，我们将在接收到来自发布者的第一条消息时关闭订阅者节点。这可以通过`signal_shutdown`方法实现，该方法集成在`rospy`中，只需要一个关闭理由作为参数：
- en: '[PRE22]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Call the created function from the main execution thread:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从主执行线程调用创建的函数：
- en: '[PRE23]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Test the functioning of the created nodes. You can do this as described here:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试创建的节点功能。你可以按照这里描述的方式进行测试：
- en: 'Open a new terminal and switch to your workspace. Then, run the following command
    so that ROS checks it for executable files:'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打开一个新的终端并切换到工作区。然后，运行以下命令，让ROS检查是否有可执行文件：
- en: '[PRE24]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the subscriber node. If the implementation is correct, it should remain
    under execution until you run your publisher:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行订阅者节点。如果实现正确，它应该保持运行，直到你启动发布者：
- en: '[PRE25]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Open a new terminal and enter the command again.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打开一个新终端并再次输入命令。
- en: 'Run the publisher node:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行发布者节点：
- en: '[PRE26]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If the nodes are well implemented, the subscriber execution ends after executing
    the publisher node. The output must be the message printed in the callback, in
    this case: `Message received`.'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果节点实现正确，订阅者执行完后会结束，输出必须是回调中打印的消息，在这种情况下是：`Message received`。
- en: Note
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: There is no need to compile the workspace in order to run your package nodes
    because they are written in Python. If they were coded in C++, you would have
    to build a package after every change in code.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不需要编译工作区来运行你的包节点，因为它们是用Python编写的。如果是C++编写的，你每次修改代码后都需要重新构建包。
- en: 'Exercise 21: Publishers and Subscribers'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习21：发布者与订阅者
- en: This exercise is similar to the previous one but is complex. The publisher created
    before could only send one message per execution. Now, we are going to implement
    a publisher that won't stop sending data until we terminate it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习与之前的类似，但更复杂。之前创建的发布者每次执行时只能发送一条消息。而现在，我们将实现一个发布者，直到我们终止它之前，它将不停地发送数据。
- en: 'The goal of this exercise is to create a number-finding system following these
    rules:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的目标是创建一个数字查找系统，遵循以下规则：
- en: The publisher node must publish random numbers into a topic until it is stopped
    by the user.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布者节点必须向主题发布随机数字，直到用户停止它。
- en: 'The subscriber node decides a number to look for and searches for it in the
    received message list. Here, there are two possibilities:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅者节点决定查找的数字，并在接收到的消息列表中查找它。这里有两种可能性：
- en: If the number is found before 1000 tries, a positive message will be printed
    and the number of tries it took to achieve it too.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果在1000次尝试之前找到数字，将打印一条正面消息，并显示达到目标所花费的尝试次数。
- en: If the number is not found in 1000 tries, a negative message will be printed
    telling the user that it was not possible to find the number.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果在1000次尝试内未找到数字，将打印一条负面消息，告知用户无法找到该数字。
- en: 'So, this can be done in the following way:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所以，可以通过以下方式进行：
- en: 'As mentioned earlier, begin by creating the package and files:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，从创建包和文件开始：
- en: '[PRE27]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Begin with the publisher implementation.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从发布者实现开始。
- en: Import the necessary libraries. These libraries are the same as in the preface,
    but this time, you must change the `String` import for `Int32`, as the node is
    going to work with numbers. You should also import a random library to generate
    numbers.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导入必要的库。这些库与前言中的相同，但这次必须将`String`导入更改为`Int32`，因为节点将处理数字。你还应该导入一个随机库来生成数字。
- en: Note
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE28]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create the number generator function:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建数字生成器函数：
- en: '[PRE29]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Declare the publisher and initialize the node as you did in the previous exercise.
    Note that, this time, the data type is different and the queue size is set to
    10, which means that it will be possible to have 10 published numbers. When the
    eleventh number is published, the first will be dropped from the queue:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明发布者并像之前的练习一样初始化节点。注意，这次数据类型不同，队列大小设置为10，这意味着最多可以有10个已发布的数字。当第11个数字发布时，第一个数字会被从队列中丢弃：
- en: '[PRE30]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Configure the rate at which the program loop will iterate. We are setting a
    rate of 10 (Hz), which is not a very high rate and that will allow us to check
    the generated numbers:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置程序循环的迭代频率。我们设置的频率为10（Hz），这是一个不太高的频率，能够让我们检查生成的数字：
- en: '[PRE31]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Implement the loop where the numbers will be generated and published. It has
    to iterate until the user stops it, so you can use the `is_shutdown()` function.
    Use the sleep function on the declared rate so it can take effect:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现生成和发布数字的循环。它必须迭代直到用户停止，因此你可以使用`is_shutdown()`函数。使用声明的速率上的sleep函数，以使其生效：
- en: '[PRE32]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Call the created function from the node entry. Use a try directive so that
    the user shutdown doesn''t produce an error:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从节点入口调用创建的函数。使用try指令，以确保用户关闭时不会产生错误：
- en: '[PRE33]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Continue with the subscriber implementation:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续进行订阅者的实现：
- en: Import the necessary libraries.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导入必要的库。
- en: Note
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE34]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create a class with two attributes: one for establishing the value of the number
    to find and the other one for counting the number of tries:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有两个属性的类：一个用于设置要查找的数字的值，另一个用于计算尝试的次数：
- en: '[PRE35]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Implement the callback function. The logic of the finder has to be coded in
    this function. There are lots of ways to do this but this is a frequently used
    one:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现回调函数。寻找器的逻辑必须在这个函数中编写。有很多方法可以做到这一点，但这是一个常用的方法：
- en: '[PRE36]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, it is a simple function that looks for the number and adds one
    to the counter for each failed try. If the number is found, it prints a positive
    message. If the counter reaches 1000, the search is aborted and a negative message
    is shown.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，这是一个简单的函数，它寻找数字并为每次失败的尝试增加一次计数。如果找到数字，它将打印一个正面的消息。如果计数器达到1000，搜索将中止，并显示负面消息。
- en: 'Create the function for subscribing. Remember that, this time, the published
    data type is `Int32`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建订阅函数。记住，这次发布的数据类型是`Int32`：
- en: '[PRE37]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, from the node entry, create a `Finder` class instance and call the
    `finder` method:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从节点入口创建一个`Finder`类实例，并调用`finder`方法：
- en: '[PRE38]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Test whether the performed implementation is correct.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试执行的实现是否正确。
- en: Open a new terminal and run `roscore`.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打开一个新的终端并运行`roscore`。
- en: 'Open another terminal and execute the subscriber node:'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打开另一个终端并执行订阅者节点：
- en: '[PRE39]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In another terminal, run the publisher node so that numbers are generated and
    the callback function starts working:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个终端中，运行发布者节点，以便生成数字并开始执行回调函数：
- en: '[PRE40]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If the searched number, 50 in this case, is found, the output should be similar
    to this one:![Figure 6.2: Execution example where the number is found](img/C13550_06_02.jpg)'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到要搜索的数字，这里是50，输出应类似于此：![图6.2：找到数字的执行示例](img/C13550_06_02.jpg)
- en: 'Figure 6.2: Execution example where the number is found'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.2：找到数字的执行示例
- en: 'Change the searched number to a value higher than 100 when the number is not
    found. You should obtain an output as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当未找到数字时，将搜索的数字更改为大于100的值。你应该获得如下的输出：
- en: '![Figure 6.3: Execution example where the number is not found](img/C13550_06_03.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3：未找到数字的执行示例](img/C13550_06_03.jpg)'
- en: 'Figure 6.3: Execution example where the number is not found'
  id: totrans-178
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.3：未找到数字的执行示例
- en: 'It will be interesting to use the `rqt_graph` command when both nodes are being
    executed; this way, you can see the structure you just created graphically. So,
    open a new terminal and enter the command. The output should be something like
    this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个节点都在运行时，使用`rqt_graph`命令会很有意思；这样，你可以图形化地看到你刚刚创建的结构。所以，打开一个新的终端并输入命令。输出应该类似于以下内容：
- en: '![Figure 6.4: Output](img/C13550_06_04.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4：输出](img/C13550_06_04.jpg)'
- en: 'Figure 6.4: Output'
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.4：输出
- en: Simulators
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仿真器
- en: Simulators are very good tools for developing and testing robotics software.
    They make robotics affordable for everyone. Imagine that you are working on a
    robotics project, where you constantly have to test functionality improvements
    with your robot. It would require connecting the robot for each test, charging
    it many times, and moving it with you. All of this can be avoided with a simulator,
    which can be launched in your computer at any time; it can even simulate the nodes
    and topics generated by the robot. Do you know any simulator for working with
    robots?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 仿真器是开发和测试机器人软件的非常好工具。它们使机器人技术变得对每个人都能负担得起。想象一下你正在进行一个机器人项目，在这个项目中，你需要不断测试机器人功能的改进。这将需要每次测试时都要连接机器人，充电多次，还要带着它到处移动。所有这些都可以通过仿真器来避免，仿真器可以在任何时候在你的计算机上启动，甚至可以模拟机器人生成的节点和话题。你知道有什么机器人仿真器吗？
- en: 'We are going to use Gazebo, a simulator included in the ROS full installation.
    In fact, if you chose this option while installing it, you can write "**gazebo**"
    in a terminal and it will launch the simulator. The Gazebo interface is shown
    in Figure 6.4:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Gazebo，这是 ROS 完整安装中包含的一个模拟器。事实上，如果您在安装时选择了这个选项，您只需在终端输入“**gazebo**”即可启动模拟器。Gazebo
    界面如图 6.4 所示：
- en: '![Figure 6.5: The Gazebo start point](img/C13550_06_05.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5：Gazebo 启动点](img/C13550_06_05.jpg)'
- en: 'Figure 6.5: The Gazebo start point'
  id: totrans-186
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6.5：Gazebo 启动点
- en: The next step is to install and set up the robot that we are going to simulate.
    In this case, we will use a **Turtlebot**, a wheelie robot that is equipped with
    sensors such as cameras and lasers. Turtlebot may not be compatible with your
    ROS distribution (we are using Kinetic Kame); but don't worry, there are lots
    of robots that you can simulate in Gazebo. You can look up different robots and
    try to use them with your ROS distribution.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是安装并设置我们要模拟的机器人。在这个案例中，我们将使用 **Turtlebot**，它是一种配备有摄像头、激光传感器等的轮式机器人。Turtlebot
    可能与您的 ROS 发行版（我们使用的是 Kinetic Kame）不兼容；但不用担心，Gazebo 中有许多机器人可以模拟。您可以查找不同的机器人并尝试与您的
    ROS 发行版配合使用。
- en: 'Exercise 22: The Turtlebot configuration'
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 22：Turtlebot 配置
- en: 'In this exercise, we are going to go through some things you will need to do
    before using Turtlebot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们将介绍一些在使用 Turtlebot 之前需要做的事情：
- en: 'Install its dependencies:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装其依赖项：
- en: '[PRE41]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Download the `Turtlebot` simulator package in your `catkin` workspace.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 `Turtlebot` 仿真包到您的 `catkin` 工作空间。
- en: Note
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE42]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: After that, you should be able to use Turtlebot with Gazebo.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，您应该能够与 Gazebo 一起使用 Turtlebot。
- en: 'Start ROS services:'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 启动 ROS 服务：
- en: '[PRE43]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Launch Turtlebot World:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 启动 Turtlebot 世界：
- en: '[PRE44]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, you should see the same Gazebo world as before, but with a set of objects,
    including Turtlebot, at the center, as mentioned in figure 6.5:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您应该会看到与之前相同的 Gazebo 世界，但在中心有一组对象，包括 Turtlebot，如图 6.5 所示：
- en: '![Figure 6.6: The Turtlebot simulation using Gazebo](img/C13550_06_06.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6：使用 Gazebo 的 Turtlebot 仿真](img/C13550_06_06.jpg)'
- en: 'Figure 6.6: The Turtlebot simulation using Gazebo'
  id: totrans-202
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6.6：使用 Gazebo 的 Turtlebot 仿真
- en: Once the simulation is correctly running, let's do another exercise for learning
    how to obtain information from sensors and work with it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦仿真成功运行，我们将进行另一个练习，学习如何从传感器获取信息并进行处理。
- en: 'Exercise 23: Simulators and Sensors'
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 23：模拟器与传感器
- en: 'In this exercise, we''ll create a ROS node that subscribes to the Turtlebot
    camera to obtain corresponding images. Follow these steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们将创建一个 ROS 节点，订阅 Turtlebot 摄像头以获取相应的图像。请按照以下步骤进行操作：
- en: 'Create a package with the necessary dependencies and files:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含必要依赖项和文件的软件包：
- en: '[PRE45]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Implement the node.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现节点。
- en: 'Import the necessary libraries. For this exercise, we are going to use `OpenCV`
    to work with the images obtained from the camera:'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导入必要的库。在本练习中，我们将使用 `OpenCV` 来处理从摄像头获取的图像：
- en: '[PRE46]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a class and declare an attribute of type `CvBridge`, which will be used
    later to change the image type to `cv2`:'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个类并声明一个类型为 `CvBridge` 的属性，稍后将用它来将图像类型转换为 `cv2`：
- en: '[PRE47]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Code the callback function, where you will have to obtain the image and convert
    it to the cv2 format:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写回调函数，在该函数中，您需要获取图像并将其转换为 cv2 格式：
- en: '[PRE48]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: We use the `waitKey()` function so that the image remains on the screen. It
    will disappear when the user presses any key.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `waitKey()` 函数，这样图像就会保持在屏幕上，直到用户按下任意键，图像才会消失。
- en: 'Define and implement the subscriber function. Remember that, now, the required
    data has an Image type:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义并实现订阅者函数。记住，现在，所需的数据已经是一个图像类型（Image）：
- en: '[PRE49]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you don''t know the name of the topic to which you want to subscribe, you
    can always enter the `rostopic` list command and check the available nodes. You
    should see a list like the following:'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您不知道想要订阅的主题名称，您可以随时输入 `rostopic` list 命令，查看可用的节点。您应该会看到如下列表：
- en: '![Figure 6.7: Output of the rostopic list command](img/C13550_06_07.jpg)'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 6.7：`rostopic list` 命令的输出](img/C13550_06_07.jpg)'
- en: 'Figure 6.7: Output of the rostopic list command'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6.7：`rostopic list` 命令的输出
- en: 'Call the subscriber function from the program entry:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从程序入口处调用订阅者函数：
- en: '[PRE50]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Check that the node works fine. To do that, you should run `roscore` command,
    Gazebo with Turtlebot, and created the node in different terminals. Note that
    you may also run the `source devel/setup.bash` source if you didn''t do so earlier:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查节点是否正常工作。为此，您需要在不同的终端中运行 `roscore` 命令、Gazebo 和 Turtlebot，同时创建节点。请注意，如果您之前没有这样做，也可以运行
    `source devel/setup.bash` 命令：
- en: '[PRE51]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The result should be something like this:'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果应该类似于这样：
- en: '![Figure 6.8: The execution example of the exercise node](img/C13550_06_08.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8：练习节点的执行示例](img/C13550_06_08.jpg)'
- en: 'Figure 6.8: The execution example of the exercise node'
  id: totrans-229
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6.8：练习节点的执行示例
- en: 'Activity 6: Simulators and Sensors'
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 6：模拟器和传感器
- en: 'Consider the following scenario: you are working for a robotics company that
    has recently acquired a new client, a security surveillance company. So, you are
    asked to implement a surveillance system for a robot that guards the store at
    night. The client wants the robot to stay in the middle of the store and to look
    around constantly.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下情景：你为一家机器人公司工作，该公司最近获得了一位新客户——一家安防监控公司。因此，你被要求为一个守夜机器人实现一个监控系统。客户希望机器人停留在商店的中央，并不断四处查看。
- en: You have to simulate the system and you have been asked to use Turtlebot and
    Gazebo.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要模拟这个系统，并且已经被要求使用 Turtlebot 和 Gazebo。
- en: Implement a node that subscribes to the camera and shows all the images it receives.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个节点，订阅相机并显示它接收到的所有图像。
- en: Implement a node for the robot to turn itself on.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个节点，使机器人能够自启动。
- en: Note
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: To do that, you will have to publish the /mobile_base/commands/velocity topic,
    which works with Twist messages. Twist is a type of message included in the `geometry_msgs`
    library, so you will have to add this as a dependency. To make the robot rotate
    on itself, create an instance of Twist and modify its `angular.z` value. Then,
    publish it.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为此，你需要发布 `/mobile_base/commands/velocity` 主题，该主题与 Twist 消息一起使用。Twist 是 `geometry_msgs`
    库中的一种消息类型，因此你需要将其添加为依赖项。为了使机器人自转，创建一个 Twist 实例并修改其 `angular.z` 值，然后发布它。
- en: Now, run both nodes at the same time.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，同时运行这两个节点。
- en: 'At the end of this activity, you will get an output similar to this:'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个活动的最后，你将得到类似于这样的输出：
- en: '![Figure 6.9: The rotating output that shows the images in the virtual environment](img/C13550_06_09.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9：展示虚拟环境中图像的旋转输出](img/C13550_06_09.jpg)'
- en: 'Figure 6.9: The rotating output that shows the images in the virtual environment'
  id: totrans-240
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6.9：展示虚拟环境中图像的旋转输出
- en: Note
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 318.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第 318 页找到。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to work with ROS, from its installation and
    configuration to the implementation of nodes. You also worked with simulators
    and its sensors, obtaining information from them and making the acquired information
    valuable for solving problems. All the exercises and activities covered in the
    chapter will be useful for you in the following chapters.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用 ROS，从其安装和配置到节点的实现。你还使用了模拟器及其传感器，从中获取信息，并将这些获取的信息应用于解决问题。本章中涵盖的所有练习和活动将在后续章节中对你有所帮助。
- en: In the next chapter, you will work with natural language processing (NPL) and
    learn how to build a chatbot. If you build a good one, it could be a very interesting
    tool to add to a robot. You could even use ROS to develop it.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将学习自然语言处理（NPL）并学会如何构建聊天机器人。如果你能构建一个优秀的聊天机器人，它将成为一个非常有趣的工具，可以添加到机器人中。你甚至可以使用
    ROS 来开发它。
