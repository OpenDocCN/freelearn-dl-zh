- en: '*Chapter 8*: Navigation Mesh'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：导航网格'
- en: As we saw in [*Chapter 7*](B17984_07_Epub.xhtml#_idTextAnchor398), *A* Pathfinding*,
    the most critical decision in pathfinding is how to represent the scene's geometry.
    The AI agents need to know where the obstacles are, and it is our job as AI designers
    to provide the best representation we can to the pathfinding algorithm. Previously,
    we created a custom representation by dividing the map into a 2D grid, and then
    we implemented a custom pathfinding algorithm by implementing A* using that representation.
    But wouldn't it be awesome if Unity could do all that for us?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第7章*](B17984_07_Epub.xhtml#_idTextAnchor398)中看到的，*路径查找*，路径查找中最关键的决策是如何表示场景的几何形状。AI代理需要知道障碍物的位置，作为AI设计师，我们的工作是向路径查找算法提供尽可能好的表示。以前，我们通过将地图划分为2D网格来创建自定义表示，然后通过实现A*算法来使用该表示来实现自定义路径查找算法。但如果我们能让Unity为我们做所有这些工作，那岂不是太棒了？
- en: 'Fortunately, Unity can do this using **Navigation Meshes** (**NavMeshes**).
    While in the previous 2D representation, we divided the world into perfect squares,
    with NavMeshes, we will divide the world using arbitrary convex polygons. This
    representation has two exciting advantages: first, every polygon can be different,
    and therefore we can use a small number of big polygons for vast open areas and
    many smaller polygons for very crowded spaces; second, we do not need to lock
    the Agent on a grid anymore, and so the pathfinding produces more natural paths.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Unity可以使用**导航网格**（**NavMeshes**）来完成这项工作。在之前的2D表示中，我们将世界划分为完美的正方形，而使用NavMeshes，我们将使用任意的凸多边形来划分世界。这种表示有两个令人兴奋的优点：首先，每个多边形都可以不同，因此我们可以使用少量的大多边形来表示广阔的开放区域，以及许多小多边形来表示非常拥挤的空间；其次，我们不再需要将代理锁定在网格上，因此路径查找会产生更自然的路径。
- en: This chapter will explain how we can use Unity's built-in NavMesh generator
    to make pathfinding for AI agents much easier and more performant. Some years
    ago, NavMeshes were an exclusive Unity Pro feature. Fortunately, this is not true
    anymore; NavMeshes are available in the free version of Unity for everyone!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将解释我们如何使用Unity内置的NavMesh生成器来使AI代理的路径查找更加容易和高效。几年前，NavMeshes是Unity Pro的独家功能。幸运的是，这不再是事实；NavMeshes现在在Unity免费版本中对所有用户都可用！
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setting up the map
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置地图
- en: Building the scene with slopes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立带有斜坡的场景
- en: Creating navigation areas
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建导航区域
- en: An overview of Off Mesh Links
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Off Mesh Links概述
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you just need Unity3D 2022\. You can find the example project
    described in this chapter in the `Chapter 8` folder in the book repository: [https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter08).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您只需要Unity3D 2022。您可以在本书存储库的`Chapter 8`文件夹中找到本章中描述的示例项目：[https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter08)。
- en: Setting up the map
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置地图
- en: 'To get started, let''s build a simple scene, as shown in the following screenshot.
    This is the first scene in the example project and is called `NavMesh01-Simple.scene`.
    You can use a plane as the ground object and several cube entities as the wall
    objects:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们构建一个简单的场景，如图下所示。这是示例项目中的第一个场景，称为`NavMesh01-Simple.scene`。您可以使用平面作为地面对象，以及几个立方体实体作为墙壁对象：
- en: '![Figure 8.1 – An image of the NavMesh01-Simple scene, a plane with obstacles'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 – NavMesh01-Simple场景的图像，一个带有障碍物的平面]'
- en: '](img/B17984_08_1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17984_08_1.jpg]'
- en: Figure 8.1 – An image of the NavMesh01-Simple scene, a plane with obstacles
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – NavMesh01-Simple场景的图像，一个带有障碍物的平面
- en: In the following subsections, we will set up the walls as obstacles, bake the
    NavMesh, and configure the tanks.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的子章节中，我们将设置墙壁作为障碍物，烘焙NavMesh，并配置坦克。
- en: Navigation static
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航静态
- en: 'Once we add the floor and the obstacles, it is essential to mark them with
    the **Navigation Static** tag so that the NavMesh generator knows that they need
    to be taken into account during the baking process. To do this, select all of
    the objects, click on the **Static** button, and choose **Navigation Static**,
    as shown in the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们添加了地板和障碍物，就非常重要的是用**导航静态**标签标记它们，这样NavMesh生成器就知道在烘焙过程中需要考虑它们。为此，选择所有对象，点击**静态**按钮，并选择**导航静态**，如图下所示：
- en: '![Figure 8.2 – The Navigation Static property'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – 导航静态属性'
- en: '](img/B17984_08_2.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_08_2.jpg)'
- en: Figure 8.2 – The Navigation Static property
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 导航静态属性
- en: Baking the NavMesh
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 烘焙 NavMesh
- en: 'Now that we have completed the scene, let''s bake the NavMesh. To do that,
    follow these steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了场景，接下来让我们烘焙 NavMesh。为此，请按照以下步骤操作：
- en: 'Navigate to **Window** | **AI** | **Navigation**, and you should be able to
    see this window:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **窗口** | **AI** | **导航**，您应该能看到此窗口：
- en: '![Figure 8.3 – Navigation window'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3 – 导航窗口'
- en: '](img/B17984_08_3.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_08_3.jpg)'
- en: Figure 8.3 – Navigation window
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 导航窗口
- en: Info
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: 'All the properties in the **Navigation** window are pretty self-explanatory:
    **Agent Radius** and **Agent Height** represent the size of the virtual agent
    used by Unity to bake the NavMesh, **Max Slope** is the value in degrees of the
    sharpest incline the character can walk up, and so on. If we have multiple AI
    agents, we should bake the NavMesh using the radius and height of the *smallest*
    AI character. For more information, you can check out the following Unity reference
    documentation: [https://docs.unity3d.com/Manual/Navigation.html](https://docs.unity3d.com/Manual/Navigation.html).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**导航** 窗口中的所有属性都很直观：**代理半径** 和 **代理高度** 代表 Unity 用于烘焙 NavMesh 的虚拟代理的大小，**最大坡度**
    是角色可以爬上的最陡坡度的度数，等等。如果我们有多个 AI 代理，我们应该使用最小的 AI 角色的半径和高度来烘焙 NavMesh。有关更多信息，您可以查看以下
    Unity 参考文档：[https://docs.unity3d.com/Manual/Navigation.html](https://docs.unity3d.com/Manual/Navigation.html)。'
- en: Select the plane and, in the **Object** tab, set its area to **Walkable**.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择平面，在 **对象** 选项卡中，将其区域设置为 **可通行**。
- en: '![Figure 8.4 – The Object section of the Navigation panel'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.4 – 导航面板的对象部分'
- en: '](img/B17984_08_4.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_08_4.jpg)'
- en: Figure 8.4 – The Object section of the Navigation panel
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 导航面板的对象部分
- en: Leave everything else with the default values and click on **Bake**.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其他所有设置保留为默认值，然后点击 **烘焙**。
- en: 'You should see a progress bar baking the NavMesh for your scene, and after
    a while, you should see the NavMesh in your scene, as shown in the following screenshot:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到一个进度条正在烘焙场景的 NavMesh，过一段时间后，您应该能在场景中看到 NavMesh，如下面的截图所示：
- en: '![Figure 8.5 – The baking of a NavMesh'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.5 – NavMesh 的烘焙'
- en: '](img/B17984_08_5.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_08_5.jpg)'
- en: Figure 8.5 – The baking of a NavMesh
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – NavMesh 的烘焙
- en: NavMesh agent
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NavMesh 代理
- en: 'At this point, we have completed the super-simple scene setup. Now, let''s
    add some AI agents to see if it works:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了超级简单的场景设置。现在，让我们添加一些 AI 代理来看看它是否工作：
- en: As a character, we use our trustworthy tank model. However, do not worry if
    you're working in a different scene and have a different model. Everything works
    the same way independently of the model.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为角色，我们使用我们信任的坦克模型。但是，如果您在不同的场景中工作并且有不同的模型，请不要担心。无论模型如何，一切操作都是相同的。
- en: '![Figure 8.6 – Tank entity'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.6 – 坦克实体'
- en: '](img/B17984_08_6.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_08_6.jpg)'
- en: Figure 8.6 – Tank entity
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 坦克实体
- en: Add the **Nav Mesh Agent** component to our tank entity. This component makes
    pathfinding easy. We do not need to implement pathfinding algorithms such as A*
    anymore. Instead, we only need to set the destination property of the component
    at runtime, and the component will compute the path using Unity's internal pathfinding
    algorithm.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Nav Mesh Agent** 组件添加到我们的坦克实体中。此组件使路径查找变得简单。我们不再需要实现 A* 等路径查找算法。相反，我们只需要在运行时设置组件的目标属性，该组件将使用
    Unity 的内部路径查找算法计算路径。
- en: 'Navigate to **Component** | **Navigation** | **Nav Mesh Agent** to add this
    component:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **组件** | **导航** | **Nav Mesh Agent** 以添加此组件：
- en: '![Figure 8.7 – Nav Mesh Agent properties'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.7 – Nav Mesh Agent 属性'
- en: '](img/B17984_08_7.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_08_7.jpg)'
- en: Figure 8.7 – Nav Mesh Agent properties
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – Nav Mesh Agent 属性
- en: Info
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: You can find the official Unity reference for the **Nav Mesh Agent** at [https://docs.unity3d.com/Manual/class-NavMeshAgent.html](https://docs.unity3d.com/Manual/class-NavMeshAgent.html).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://docs.unity3d.com/Manual/class-NavMeshAgent.html](https://docs.unity3d.com/Manual/class-NavMeshAgent.html)
    找到关于 **Nav Mesh Agent** 的官方 Unity 参考。
- en: One property to note is the **Area Mask** property. It specifies the NavMesh
    layers that this NavMesh agent can walk on. We will talk about navigation layers
    in the *Baking navigation areas* section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个属性是 **区域遮罩** 属性。它指定了此 NavMesh 代理可以行走的 NavMesh 层。我们将在 *烘焙导航区域* 部分讨论导航层。
- en: Updating an agent's destinations
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新代理的目标
- en: Now that we have set up our AI agent, we need a way to tell it where to go and
    update the destination of the tank to the mouse click position.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了我们的AI代理，我们需要一种方法来告诉它去哪里，并将坦克的目的地更新为鼠标点击的位置。
- en: So, let's add a sphere entity, which we use as a marker object, and then attach
    the `Target.cs` script to an empty game object. Then, drag and drop this sphere
    entity onto this script's `targetMarker` transform property in the Inspector.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们添加一个球体实体，我们将其用作标记对象，然后将`Target.cs`脚本附加到一个空的游戏对象上。然后，将这个球体实体拖放到检查器中该脚本的`targetMarker`变换属性。
- en: The Target.cs class
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Target.cs类
- en: 'This script contains a simple class that does three things:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本包含一个简单的类，它执行三个操作：
- en: Gets the mouse click position using a ray
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用射线获取鼠标点击位置
- en: Updates the marker position
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新标记位置
- en: Updates the `destination` property of all the NavMesh agents
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新所有NavMesh代理的`destination`属性
- en: 'The following lines show the `Target` class''s code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了`Target`类的代码：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At the start of the game, we look for all the `NavMeshAgent` array (note that
    if you want to spawn new agents at runtime, you need to update the `navAgents`
    list). Then, whenever there's a mouse click event, we do a simple raycast to determine
    the first object colliding with the ray. If the beam hits an object, we update
    the position of our marker and update each NavMesh agent's destination by setting
    the `destination` property with the new position. We will be using this script
    throughout this chapter to tell the destination position for our AI agents.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开始时，我们查找所有的`NavMeshAgent`数组（注意，如果你想在运行时生成新的代理，你需要更新`navAgents`列表）。然后，每当有鼠标点击事件时，我们进行简单的射线投射以确定射线碰撞的第一个对象。如果光线击中一个对象，我们更新标记的位置，并通过将`destination`属性设置为新的位置来更新每个NavMesh代理的目的地。我们将在这个章节的整个过程中使用这个脚本来告诉我们的AI代理目标位置。
- en: Now, test the scene, and click on a point that you want your tanks to go to.
    The tanks should move as close as possible to that point while avoiding every
    static obstacle (in this case, the walls).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试场景，并点击你想要坦克前往的点。坦克应该尽可能接近该点，同时避开所有静态障碍物（在这种情况下，是墙壁）。
- en: Setting up a scene with slopes
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置带有斜坡的场景
- en: 'Let''s build a scene with some slopes, like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个带有一些斜坡的场景，如下所示：
- en: '![Figure 8.8 – Scene with slopes-NavMesh02-Slope.scene'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8 – 带有斜坡的场景-NavMesh02-Slope.scene'
- en: '](img/B17984_08_8.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_08_8.jpg)'
- en: Figure 8.8 – Scene with slopes-NavMesh02-Slope.scene
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – 带有斜坡的场景-NavMesh02-Slope.scene
- en: 'One important thing to note is that the slopes and the wall should be in contact.
    If we want to use NavMeshes, objects need to be perfectly connected. Otherwise,
    there''ll be gaps in the NavMesh, and the Agents will not be able to find the
    path anymore. There''s a feature called **Off Mesh Link** generation to solve
    similar problems, but we will look at Off Mesh Links in the *Using Off Mesh Links*
    section later in this chapter. For now, let''s concentrate on building the slope:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个需要注意的重要事项是斜坡和墙壁应该接触。如果我们想使用NavMesh，对象需要完美连接。否则，NavMesh中会有间隙，代理将无法再找到路径。有一个名为**Off
    Mesh Link**生成功能来解决类似问题，但我们将在这个章节的*使用Off Mesh Links*部分稍后讨论Off Mesh Links。现在，让我们专注于构建斜坡：
- en: 'Make sure to connect the slope properly:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保正确连接斜坡：
- en: '![Figure 8.9 – A well-connected slope'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9 – 良好连接的斜坡'
- en: '](img/B17984_08_9.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_08_9.jpg)'
- en: Figure 8.9 – A well-connected slope
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – 良好连接的斜坡
- en: We can adjust the **Max Slope** property in the Navigation window's **Bake**
    tab according to the level of slope in our scenes that we want to allow the Agents
    to travel. We'll use 45 degrees here. If your slopes are steeper than this, you
    can use a higher **Max Slope** value.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以根据我们场景中允许代理旅行的斜坡程度调整导航窗口的**烘焙**选项卡中的**Max Slope**属性。这里我们将使用45度。如果你的斜坡比这个更陡，你可以使用更高的**Max
    Slope**值。
- en: 'Bake the scene, and you should have generated a NavMesh, like this:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 烘焙场景，你应该已经生成了一个NavMesh，如下所示：
- en: '![Figure 8.10 – The generated NavMesh'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.10 – 生成的NavMesh'
- en: '](img/B17984_08_10.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_08_10.jpg)'
- en: Figure 8.10 – The generated NavMesh
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 – 生成的NavMesh
- en: We will place some tanks with the **Nav Mesh Agent** component.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将放置一些带有**Nav Mesh Agent**组件的坦克。
- en: Create a new cube object and use it as the target reference position.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的立方体对象，并使用它作为目标参考位置。
- en: We will be using our previous `Target.cs` script to update the destination property
    of the AI agent.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用之前的`Target.cs`脚本来更新AI代理的`destination`属性。
- en: Test run the scene, and you should see the AI agent crossing the slopes to reach
    the target.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试运行场景，你应该看到AI代理正在穿越斜坡以到达目标。
- en: Congratulation, you have implemented your first basic NavMesh-powered AI. Now,
    you can implement agents able to navigate over simple plains. What if we want
    more complex scenarios? That's the topic of the next section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经实现了第一个基于NavMesh的基本AI。现在，你可以实现能够在简单平原上导航的代理。如果我们想要更复杂的场景呢？这就是下一节的主题。
- en: Baking navigation areas with different costs
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以不同的成本值烘焙导航区域
- en: In games with complex environments, we usually have areas that are harder to
    traverse than others. For example, crossing a lake with a bridge is less challenging
    than crossing it without a bridge. To simulate this, we want to make crossing
    the lake more costly than using a bridge. This section will look at navigation
    areas that define different layers with different navigation cost values.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有复杂环境的游戏中，我们通常有一些比其他区域更难以穿越的区域。例如，通过桥梁穿越湖泊比不通过桥梁穿越要简单。为了模拟这种情况，我们希望使穿越湖泊的成本高于使用桥梁。本节将探讨定义不同层级和不同导航成本值的导航区域。
- en: 'For this, we build a scene, as shown in *Figure 8.11*. Three planes represent
    two ground planes separated by a water plane and connected by a bridge-like structure.
    As you can see, crossing over the water plane is the most direct way to traverse
    the lake; however, passing through the water costs more than using the bridge
    and, therefore, the pathfinding algorithm will prefer the bridge to the water:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个，我们构建了一个场景，如图*图8.11*所示。三个平面代表两个由水面隔开且通过类似桥梁的结构连接的地面平面。正如你所见，穿越水面是最直接穿越湖泊的方式；然而，穿越水面的成本比使用桥梁要高，因此路径查找算法将优先选择桥梁而不是水面：
- en: '![Figure 8.11 – Scene with layers – NavMesh03-Layers.scene'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.11 – 带有层级的场景 – NavMesh03-Layers.scene'
- en: '](img/B17984_08_11.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_08_11.jpg)'
- en: Figure 8.11 – Scene with layers – NavMesh03-Layers.scene
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 – 带有层级的场景 – NavMesh03-Layers.scene
- en: 'Let''s follow a step-by-step procedure so that we can create a navigation area:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照一步一步的程序进行，以便我们可以创建一个导航区域：
- en: 'Go to the **Navigation** window and select the **Areas** section:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**导航**窗口并选择**区域**部分：
- en: '![Figure 8.12 – The Areas section in the Navigation window'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.12 – 导航窗口中的区域部分'
- en: '](img/B17984_08_12.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_08_12.jpg)'
- en: Figure 8.12 – The Areas section in the Navigation window
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 – 导航窗口中的区域部分
- en: 'Unity comes with three default layers: **Default**, **Not Walkable**, and **Jump**,
    each with potentially different cost values.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Unity自带三个默认层级：**默认**、**不可行走**和**跳跃**，每个层级可能有不同的成本值。
- en: Let's add a new layer called `Water` and give it a cost of `5`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个新的层级，命名为`Water`，并给它设置成本为`5`。
- en: Select the water plane.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择水面。
- en: 'Go to the **Navigation** window and, in the **Object** tab, set **Navigation
    Area** to **Water**:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**导航**窗口，在**对象**选项卡中，将**导航区域**设置为**Water**：
- en: '![Figure 8.13 – Water layer'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.13 – 水面层级'
- en: '](img/B17984_08_13.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_08_13.jpg)'
- en: Figure 8.13 – Water layer
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 – 水面层级
- en: Bake the NavMesh for the scene and run it to test it.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为场景烘焙NavMesh并运行以测试它。
- en: You should see that the AI agents now choose the slope rather than going through
    the plane marked as the water layer because it's more expensive to traverse the
    water. Try experimenting with placing the target object at different points on
    the water plane. You should see that the AI agents sometimes swim back to the
    shore and sometimes take the bridge rather than trying to swim across the water.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到AI代理现在选择斜坡而不是穿越标记为水面层级的平面，因为穿越水面的成本更高。尝试在水面平面上不同位置放置目标对象。你应该看到AI代理有时会游回岸边，有时会走桥梁而不是尝试穿越水面。
- en: Info
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: You can find the official Unity documentation for **NavMesh Areas** at [https://docs.unity3d.com/Manual/nav-AreasAndCosts.html](https://docs.unity3d.com/Manual/nav-AreasAndCosts.html).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Unity官方文档中找到关于**NavMesh区域**的说明，网址为[https://docs.unity3d.com/Manual/nav-AreasAndCosts.html](https://docs.unity3d.com/Manual/nav-AreasAndCosts.html)。
- en: Using Off Mesh Links to connect gaps between areas
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Off Mesh Links连接区域之间的间隙
- en: Sometimes, there may be some gaps in the scene that can make the NavMeshes disconnected.
    For instance, the Agents do not find a path in our previous examples if we do
    not tightly connect the slopes to the walls, so we need to make it possible to
    jump over such gaps. In another example, we may want to set up points where our
    agents can jump off the wall onto the plane below. Unity has a feature called
    **Off Mesh Links** to connect such gaps. Off Mesh Links can be set up manually
    or can be automatically generated by Unity's NavMesh generator.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，场景中可能会有一些间隙，这会使导航网格断开。例如，如果我们将斜坡与墙壁连接得不够紧密，那么在先前的示例中，代理将找不到路径，因此我们需要使其能够跳过这样的间隙。在另一个示例中，我们可能希望设置一些点，让我们的代理可以从墙上跳到下面的平面上。Unity
    有一个名为**离网链接**的功能来连接这样的间隙。离网链接可以手动设置或由 Unity 的导航网格生成器自动生成。
- en: Here's the scene that we're going to build in this example. As you can see in
    *Figure 8.14*, there's a small gap between the two planes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将在本例中构建的场景。如图 *图 8.14* 所示，两个平面之间有一个小间隙。
- en: '![Figure 8.14 – The scene with Oﬀ Mesh Links – NavMesh04-OﬀMeshLinks.scene'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.14 – 带有离网链接的场景 – NavMesh04-OﬀMeshLinks.scene'
- en: '](img/B17984_08_14.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_08_14.jpg)'
- en: Figure 8.14 – The scene with Oﬀ Mesh Links – NavMesh04-OﬀMeshLinks.scene
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.14 – 带有离网链接的场景 – NavMesh04-OﬀMeshLinks.scene
- en: In this section, we will learn how to connect these two planes using **Off Mesh
    Links**.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用**离网链接**连接这两个平面。
- en: Generated Off Mesh Links
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成的离网链接
- en: 'Firstly, we use autogenerated Off Mesh Links to connect the two planes. To
    do that, we need to follow these steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用自动生成的离网链接连接两个平面。为此，我们需要遵循以下步骤：
- en: 'Mark these two planes as **Off Mesh Link Generation** and **Static** in the
    property Inspector, as shown in the following screenshot:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在属性检查器中将这两个平面标记为**离网链接生成**和**静态**，如图所示：
- en: '![Figure 8.15 – Oﬀ Mesh Link Generation and Static'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.15 – 离网链接生成和静态'
- en: '](img/B17984_08_15.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_08_15.jpg)'
- en: Figure 8.15 – Oﬀ Mesh Link Generation and Static
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.15 – 离网链接生成和静态
- en: 'Go to the **Navigation** window and look at the properties on the **Bake**
    tab. You can set the distance threshold to autogenerate Off Mesh Links:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**导航**窗口，查看**烘焙**选项卡上的属性。您可以设置距离阈值来自动生成离网链接：
- en: '![Figure 8.16 – Generated Oﬀ Mesh Links properties'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.16 – 生成的离网链接属性'
- en: '](img/B17984_08_16.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_08_16.jpg)'
- en: Figure 8.16 – Generated Oﬀ Mesh Links properties
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.16 – 生成的离网链接属性
- en: 'Click on **Bake**, and you should have Off Mesh Links connecting the two planes,
    like this:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**烘焙**，您应该会看到连接两个平面的离网链接，如下所示：
- en: '![Figure 8.17 – Generated Oﬀ Mesh Links'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.17 – 生成的离网链接'
- en: '](img/B17984_08_17.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_08_17.jpg)'
- en: Figure 8.17 – Generated Oﬀ Mesh Links
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.17 – 生成的离网链接
- en: 'Now, our AI agents can find the path between the planes. But first, ensure
    that the tanks have **Jump** enabled in the **Area Mask** property of the **Nav
    Mesh Agent** component, as shown in *Figure 8.18*:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的 AI 代理可以在两个平面之间找到路径。但首先，确保在**导航网格代理**组件的**区域遮罩**属性中启用了坦克的**跳跃**功能，如图 *图
    8.18* 所示：
- en: '![Figure 8.18 – The Area Mask configuration for the Tanks'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.18 – 坦克的区域遮罩配置'
- en: '](img/B17984_08_18.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_08_18.jpg)'
- en: Figure 8.18 – The Area Mask configuration for the Tanks
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.18 – 坦克的区域遮罩配置
- en: If everything is correct, agents will essentially jump to the other plane once
    they reach the edge of the plane and find an **Off Mesh Link** component. But,
    of course, if jumping agents are not what we want (after all, who has ever seen
    a jumping tank?), we should instead put a bridge for the Agents to cross.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，代理一旦到达平面的边缘并找到**离网链接**组件，就会基本上跳到另一个平面上。但当然，如果我们不希望代理跳跃（毕竟，谁见过会跳跃的坦克？），我们应该为代理搭建一座桥来跨越。
- en: Manual Off Mesh Links
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动离网链接
- en: 'If we don''t want to generate Off Mesh Links along the edge and, instead, we
    want the Agents to reach a certain point before teleporting to the other side,
    then we need to set up the Off Mesh Links manually, as we can see in *Figure 8.19*:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想在边缘生成离网链接，而是希望代理在传送到另一侧之前到达某个点，那么我们需要手动设置离网链接，如图 *图 8.19* 所示：
- en: '![Figure 8.19 – Manual Oﬀ Mesh Links setup'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.19 – 手动离网链接设置'
- en: '](img/B17984_08_19.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_08_19.jpg)'
- en: Figure 8.19 – Manual Oﬀ Mesh Links setup
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.19 – 手动离网链接设置
- en: 'Execute the following steps to set up the Off Mesh Links manually:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以手动设置离网链接：
- en: We initialize a scene with a significant gap between the two planes. Then, we
    place two pairs of sphere entities on each side of the plane.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们初始化一个场景，两个平面之间有一个显著的间隙。然后，我们在平面的每一侧放置两对球体实体。
- en: Choose a sphere and add an **Off Mesh Link** component by navigating to **Component**
    | **Navigation** | **Off Mesh Link**. We only need to add this component to one
    sphere.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个球体，通过导航到**组件** | **导航** | **Off Mesh Link**来添加一个**Off Mesh Link**组件。我们只需要将这个组件添加到一个球体上。
- en: 'Next, drag and drop the first sphere to the **Start** property and the other
    sphere to the **End** property:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将第一个球体拖放到**开始**属性，将另一个球体拖放到**结束**属性：
- en: '![Figure 8.20 – Oﬀ Mesh Link component'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.20 – Off Mesh Link组件'
- en: '](img/B17984_08_20.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17984_08_20.jpg]'
- en: Figure 8.20 – Oﬀ Mesh Link component
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20 – Off Mesh Link组件
- en: Go to the **Navigation** window and bake the scene.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**导航**窗口并烘焙场景。
- en: '![Figure 8.21 – Manually generated Oﬀ Mesh Links'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.21 – 手动生成的Off Mesh Links'
- en: '](img/B17984_08_21.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17984_08_21.jpg]'
- en: Figure 8.21 – Manually generated Oﬀ Mesh Links
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21 – 手动生成的Off Mesh Links
- en: The manual **Off Mesh Links** now connect the two planes, and AI agents can
    use them to traverse terrain, even in the presence of gaps.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在的手动**Off Mesh Links**连接了两个平面，AI代理可以使用它们穿越地形，即使在存在间隙的情况下。
- en: Info
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信息
- en: You can find Unity's official reference for Off Mesh Links at [https://docs.unity3d.com/Manual/nav-CreateOffMeshLink.html](https://docs.unity3d.com/Manual/nav-CreateOffMeshLink.html).
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在Unity的官方文档中找到关于Off Mesh Links的参考：[https://docs.unity3d.com/Manual/nav-CreateOffMeshLink.html](https://docs.unity3d.com/Manual/nav-CreateOffMeshLink.html)。
- en: This last demo concludes our exploration of Unity's NavMeshes. You should now
    know all the basics of this vital tool for AI character development.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的演示结束了我们对Unity的NavMeshes的探索。你现在应该已经了解了这个对AI角色开发至关重要的工具的所有基础知识。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned how to generate and use NavMeshes to implement pathfinding
    for our games. First, we studied how to set up different navigation layers with
    varying costs for pathfinding. Then, using the destination property, we used the
    **Nav Mesh Agent** component to find the path and move toward the target. Next,
    we set up Off Mesh Links to connect the gaps between the NavMeshes using the autogeneration
    feature and a manual setup with the **Off Mesh Link** component.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何生成和使用NavMeshes来实现游戏中的路径查找。首先，我们研究了如何设置具有不同路径查找成本的导航层。然后，使用目标属性，我们使用**Nav
    Mesh Agent**组件找到路径并移动到目标。接下来，我们设置了Off Mesh Links，使用自动生成功能和带有**Off Mesh Link**组件的手动设置来连接NavMeshes之间的间隙。
- en: With all this information, we can now easily create simple games with a reasonably
    complicated AI. For example, you can try to set the destination property of AI
    tanks to the player's tank's position and make them follow it. Then, using simple
    FSMs, they can start attacking the player once they reach a certain distance.
    FSMs have taken us far, but they have their limits. In the next chapter, we will
    learn about Behavior Trees and how we can use them to make AI decisions in even
    the most complex games.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了所有这些信息之后，我们现在可以轻松地创建具有合理复杂AI的简单游戏。例如，你可以尝试将AI坦克的目标属性设置为玩家坦克的位置，并让它们跟随它。然后，使用简单的有限状态机（FSMs），一旦它们达到一定距离，它们就可以开始攻击玩家。FSMs已经带我们走得很远，但它们有其局限性。在下一章中，我们将学习关于行为树（Behavior
    Trees）以及我们如何使用它们在甚至是最复杂的游戏中做出AI决策。
