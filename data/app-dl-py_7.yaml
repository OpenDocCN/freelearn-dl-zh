- en: Productization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品化
- en: This chapter focuses on how to *productize* a deep learning model. We use the
    word *productize* to define the creation of a software product from a deep learning
    model that can be used by other people and applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点讨论如何将深度学习模型进行*产品化*。我们使用“*产品化*”一词来定义将深度学习模型转化为软件产品的过程，使其能够被其他人和应用程序使用。
- en: 'We are interested in models that use new data when it becomes available, continuously
    learning patterns from new data and, consequently, making better predictions.
    We study two strategies to deal with new data: one that re-trains an existing
    model, and another that creates a completely new model. Then, we implement the
    latter strategy in our Bitcoin prices prediction model so that it can continuously
    predict new Bitcoin prices.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关注的是能够在新数据可用时使用它的模型，持续从新数据中学习模式，并因此做出更好的预测。我们研究了处理新数据的两种策略：一种是重新训练现有模型，另一种是创建一个完全新的模型。然后，我们将在比特币价格预测模型中实现后一种策略，以使其能够持续预测新的比特币价格。
- en: This chapter also provides an exercise of how to deploy a model as a web application.
    By the end of this chapter, we will be able to deploy a working web-application
    (with a functioning HTTP API) and modify it to our heart's content.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还提供了如何将模型部署为 Web 应用程序的练习。到本章结束时，我们将能够部署一个有效的 Web 应用程序（具有功能齐全的 HTTP API）并根据需要进行修改。
- en: We use a web application as an example of how to deploy deep learning models
    because of its simplicity and prevalence (after all, web application are quite
    common), but many other possibilities are available.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以 Web 应用程序为例，来展示如何部署深度学习模型，因为它简单且普遍（毕竟，Web 应用程序非常常见），但也有许多其他的可能性。
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Handle new data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理新数据
- en: Deploy a model as a web application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模型部署为 Web 应用程序
- en: Handling New Data
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理新数据
- en: Models can be trained once in a set of data and can then be used to make predictions.
    Such static models can be very useful, but it is often the case that we want our
    model to continuously learn from new data—and to continuously get better as it
    does so.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 模型可以在一组数据上进行训练，然后用来做预测。这些静态模型非常有用，但通常我们希望模型能够从新数据中持续学习——并随着学习的进行不断改进。
- en: In this section, we will discuss two strategies on how to re-train a deep learning
    model and how to implement them in Python.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何重新训练深度学习模型的两种策略，并在 Python 中实现它们。
- en: Separating Data and Model
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据与模型的分离
- en: When building a deep learning application, the two most important areas are
    data and model. From an architectural point of view, we suggest that these two
    areas be separate. We believe that is a good suggestion because each of these
    areas include functions inherently separated from each other. Data is often required
    to be collected, cleaned, organized, and normalized; and models need to be trained,
    evaluated, and able to make predictions. Both of these areas are dependent, but
    are better dealt with separately.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建深度学习应用时，最重要的两个领域是数据和模型。从架构角度来看，我们建议将这两个领域分开。我们认为这是一个好的建议，因为这两个领域各自包含的功能本质上是相互独立的。数据通常需要收集、清洗、组织和规范化；而模型则需要训练、评估，并能够进行预测。这两个领域是相互依赖的，但分别处理会更好。
- en: 'As a matter of following that suggestion, we will be using two classes to help
    us build our web application: `CoinMarketCap()` and `Model()` :'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这一建议，我们将使用两个类来帮助我们构建 Web 应用程序：`CoinMarketCap()` 和 `Model()`：
- en: '`CoinMarketCap()` : This is a class designed for fetching Bitcoin prices from
    the following website: [http://www.coinmarketcap.com](https://coinmarketcap.com/).
    This is the same place where our original Bitcoin data comes from. This class
    makes it easy to retrieve that data on a regular schedule, returning a Pandas
    DataFrame with the parsed records and all available historical data. `CoinMarketCap()`
    is our data component.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CoinMarketCap()` ：这是一个用于从以下网站获取比特币价格的类：[http://www.coinmarketcap.com](https://coinmarketcap.com/)。这也是我们最初比特币数据的来源。这个类使我们能够定期提取该数据，返回一个包含解析记录和所有可用历史数据的
    Pandas DataFrame。`CoinMarketCap()` 是我们的数据组件。'
- en: '`Model()` : This class implements all the code we have written so far into
    a single class. That class provides facilities for interacting with our previously
    trained models, and also allows for the making of predictions using de-normalized
    data— which is much easier to understand. The `Model()` class is our model component.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Model()` : 该类将我们迄今为止编写的所有代码整合成一个类。该类提供了与我们之前训练的模型进行交互的功能，并允许使用去标准化的数据进行预测——这使得理解更加容易。`Model()`
    类是我们的模型组件。'
- en: These two classes are used extensively throughout our example application and
    define the data and model components.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类在我们的示例应用中被广泛使用，定义了数据和模型组件。
- en: Data Component
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据组件
- en: 'The `CoinMarketCap()` class creates methods for retrieving and parsing data.
    It contains one relevant method, `historic()` , which is detailed in the following
    code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`CoinMarketCap()` 类创建了用于检索和解析数据的方法。它包含一个相关方法 `historic()`，其详细代码如下：'
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Snippet 1*: `historic()` method from the `CoinMarketCap()` class.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码片段 1*：`CoinMarketCap()` 类中的 `historic()` 方法。'
- en: This method collects data from the CoinMarketCap website,parses it, and returns
    a Pandas DataFrame.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法从 CoinMarketCap 网站收集数据，解析数据，并返回一个 Pandas DataFrame。
- en: The `historic()` class returns a Pandas DataFrame, ready to be used by the `Model()`
    class.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`historic()` 类返回一个 Pandas DataFrame，准备由 `Model()` 类使用。'
- en: When working in other models, consider creating a program component (for example,
    a Python class) that fulfils the same functions the `CoinMarketCap()` class does.
    That is, create a component that fetches data from wherever it is available, parses
    that data, and makes it available in a usable format for your modeling component.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用其他模型时，考虑创建一个程序组件（例如，Python 类），其功能与 `CoinMarketCap()` 类相同。也就是说，创建一个组件，能够从数据源获取数据，解析数据，并将其以可用格式提供给模型组件。
- en: The `CoinMarketCap()` class uses the parameter `ticker` to determine what cryptocurrency
    to collect. CoinMarketCap has many other cryptocurrencies available, including
    very popular ones like Ethereum (ethereum) and Bitcoin Cash (bitcoin-cash). Use
    the ticker parameter to change the cryptocurrency and train a different model
    than using the Bitcoin model created in this book.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`CoinMarketCap()` 类使用参数 `ticker` 来确定收集哪种加密货币。CoinMarketCap 提供了许多其他加密货币，包括非常流行的以太坊（ethereum）和比特币现金（bitcoin-cash）。使用
    `ticker` 参数可以更改加密货币，训练不同于本书中使用的比特币模型的模型。'
- en: Model Component
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型组件
- en: 'The `Model()` class is where we implement the application''s model component.
    That class contains file methods that implement all the different modeling topics
    from this book. These are:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`Model()` 类是我们实现应用程序模型组件的地方。该类包含实现本书中所有不同建模主题的文件方法。这些方法包括：'
- en: '`build()` : Builds an LSTM model using Keras. This function works as a simple
    wrapper for a manually created model.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build()` : 使用 Keras 构建一个 LSTM 模型。该函数作为一个简单的包装器，封装了手动创建的模型。'
- en: '`train()` : Trains model using data that the class was instantiated with.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`train()` : 使用类实例化时提供的数据训练模型。'
- en: '`evaluate()` : Makes an evaluation of the model using a set of loss functions.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`evaluate()` : 使用一组损失函数对模型进行评估。'
- en: '`save()` : Saves the model as a file locally.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`save()` : 将模型作为文件保存在本地。'
- en: '`predict()` : Makes and returns predictions based on an input sequence of weeks
    ordered observations.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`predict()` : 基于按周排序的观察输入序列进行预测并返回结果。'
- en: We use these methods throughout this chapter to work, train, evaluate, and issue
    predictions with our model. The`Model()` class is an example of how to wrap essential
    Keras functions into a web application. The preceding methods are implemented
    almost exactly as in preceded chapters, but with syntactic sugar added for enhancing
    their interfaces.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中使用这些方法来处理、训练、评估并发出模型预测。`Model()` 类是如何将 Keras 的核心功能封装到 Web 应用中的示例。这些方法的实现几乎与前面章节中的实现完全相同，但增加了语法糖以增强它们的接口。
- en: 'For example, the method `train()` is implemented in the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`train()` 方法在以下代码中实现：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Snippet 2*: `train()` method from the `Model()` class. This method trains
    a model available in self.model using data from self.`X` and self.`Y`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码片段 2*：`Model()` 类中的 `train()` 方法。该方法使用来自 self.`X` 和 self.`Y` 的数据训练自 self.model
    的模型。'
- en: In the preceding snippet, you will be able to notice that the `train()` method
    resembles the solution to *Activities 6* and 7 from C*hapter 6*, *Model Evaluation
    and Optimization*. The general idea is that each of the processes from the Keras
    workflow (build or design, train, evaluate, and predict) can easily be turned
    into distinct parts of a program. In our case, we made them into methods that
    can be invoked from the `Model() class`. This organizes our program and provides
    a series of constraints (such as on the model architecture or certain API parameters)
    which help us deploy our model in a stable environment.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，您会注意到`train()`方法类似于来自*C*hapter 6*的*活动6*和7的解决方案，*模型评估与优化*。其核心思想是，Keras工作流中的每个过程（构建或设计、训练、评估和预测）都可以轻松地转化为程序的不同部分。在我们的案例中，我们将它们变成了可以从`Model()`类调用的方法。这有助于组织我们的程序，并提供一系列约束（例如模型架构或某些API参数），帮助我们在稳定的环境中部署模型。
- en: In the next sections, we explore common strategies for dealing with new data.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨处理新数据的常见策略。
- en: Dealing with New Data
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理新数据
- en: The core idea of machine learning models—neural networks included—is that they
    can learn patterns from data. Imagine that a model was trained with a certain
    dataset and it is now issuing predictions. Now, imagine that new data is available.
    What strategies can we employ so that a model can take advantage of the newly
    available data to learn new patterns and improve its predictions?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习模型的核心思想——包括神经网络——是它们能够从数据中学习模式。假设一个模型已使用某个数据集进行训练，并且现在开始进行预测。现在，假设有新的数据可用。我们可以采用什么策略，使模型能够利用新数据来学习新的模式并改进其预测？
- en: 'In this section, we discuss two strategies: re-training an old model and training
    a new model.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本节我们讨论两种策略：重新训练旧模型和训练新模型。
- en: Re-Training an Old Model
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新训练旧模型
- en: With this strategy, we re-train an existing model with new data. Using this
    strategy, one can continuously adjust the model parameters to adapt to new phenomena.
    However, data used in later training periods may be significantly different to
    other, earlier data. Such differences may cause significant changes to the model
    parameters, making it learn new patterns and forget old patterns. This phenomenon
    is generally referred to as *catastrophic forgetting*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种策略，我们使用新数据重新训练现有模型。通过这种策略，可以不断调整模型参数，以适应新现象。然而，后期训练使用的数据可能与早期数据有显著不同。这些差异可能会导致模型参数发生重大变化，使其学习到新模式并遗忘旧模式。这一现象通常被称为*灾难性遗忘*。
- en: 'Catastrophic forgetting is a common phenomenon affecting neural networks. Deep
    learning researchers have been trying to tackle this problem for many years. DeepMind,
    a Google-owned deep learning research group from the United Kingdom, has made
    notable advancements in finding a solution. The article *Overcoming Catastrophic
    Forgetting in Neural Networks*, by et. al. is a good reference of such work. The
    paper is available at: [https://arxiv. org/pdf/1612.00796.pdf](https://arxiv.org/pdf/1612.00796.pdf).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 灾难性遗忘是影响神经网络的常见现象。深度学习研究人员多年来一直在努力解决这个问题。DeepMind，谷歌旗下的英国深度学习研究小组，在寻找解决方案方面取得了显著进展。文章《克服神经网络中的灾难性遗忘》（*Overcoming
    Catastrophic Forgetting in Neural Networks*）是这类工作的一个良好参考。该论文可在以下链接获得：[https://arxiv.
    org/pdf/1612.00796.pdf](https://arxiv.org/pdf/1612.00796.pdf)。
- en: 'The same interface used for training (`model.fit()` ) for the fist time can
    be used for training with new data:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 用于首次训练的相同接口（`model.fit()`）可以用于用新数据进行训练：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Snippet 3*: Snippet that implements a TensorBoard callback in our LSTM model'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码片段3*：在我们的LSTM模型中实现TensorBoard回调的代码片段'
- en: In Keras, when models are trained, their weight information is kept—this is
    the model's state. When one uses the `model.save()` method, that state is also
    saved. And when one invokes the method `model.fit()` , the model is re-trained
    with the new dataset, using the previous state as a starting point.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Keras中，当模型进行训练时，其权重信息会被保留——这是模型的状态。当使用`model.save()`方法时，该状态也会被保存。当调用`model.fit()`方法时，模型会使用之前的状态作为起点，用新数据集重新训练。
- en: 'In typical Keras models, this technique can be used without further issues.
    However, when working with LSTM models, this technique has one key limitation:
    the shape of both train and validation data must be the same. For example, our
    LSTM model (`bitcoin_lstm_v0`) uses 76 weeks to predict one week into the future.
    If we attempt to re-train the network with 77 weeks in the coming week, the model
    raises an exception with information regarding the incorrect shape of data.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的Keras模型中，这种技术可以顺利使用。然而，在处理LSTM模型时，这种技术有一个关键的限制：训练数据和验证数据的形状必须相同。例如，我们的LSTM模型（`bitcoin_lstm_v0`）使用76周的数据来预测未来一周。如果我们在下一周尝试使用77周的数据重新训练网络，模型将抛出异常，提示数据形状不正确。
- en: One way of dealing with this is to arrange data in the format expected by the
    model. In our case, we would need to configure our model to predict a future week
    using 40 weeks. Using this solution, we fist train the model with the fist 40
    weeks of 2017, then continue to re-train it over the following weeks until we
    reach week 50.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题的一种方法是将数据安排为模型所期望的格式。在我们的例子中，我们需要配置模型，使用40周的数据来预测未来的一周。采用这个解决方案时，我们首先用2017年最初的40周数据训练模型，然后继续在接下来的几周中重新训练，直到达到第50周。
- en: 'We use the `Model()` class to perform this operation in the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Model()`类在以下代码中执行此操作：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Snippet 4*: Snippet that implements a re-training technique'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*Snippet 4*：实现重新训练技术的代码片段'
- en: This technique tends to be fast to train, and also tends to work well with series
    that are large. The next technique is easier to implement and works well in smaller
    series.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术训练速度较快，且通常适用于较大的数据序列。接下来的技术更易于实现，且在较小的数据序列中表现良好。
- en: Training a New Model
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练新模型
- en: Another strategy is to create and train a new model every time new data is available.
    This approach tends to reduce catastrophic forgetting, but training time increases
    as data increases. Its implementation is quite simple.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种策略是每次有新数据时创建并训练一个新模型。这种方法有助于减少灾难性遗忘，但随着数据量的增加，训练时间也会增加。其实现非常简单。
- en: 'Using the Bitcoin model as an example, let''s now assume that we have old data
    for 49 weeks of 2017, and that after a week, new data is available. We represent
    this with the variables `old_data` and `new_data` in the following quotes:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以比特币模型为例，假设我们拥有2017年49周的旧数据，并且在一周后，新的数据可用。我们用以下的`old_data`和`new_data`变量来表示这一点：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Snippet 5*: Snippet that implements a strategy for training a new model when
    new data is available'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*Snippet 5*：实现当新数据可用时训练新模型的策略的代码片段'
- en: This approach is very simple to implement and tends to work well for small datasets.
    This will be the preferred solution for our Bitcoin price-predictions application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法非常简单实现，并且对于小数据集来说效果良好。这将是我们比特币价格预测应用程序的首选解决方案。
- en: Activity:Dealing with New Data
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：处理新数据
- en: In this activity, we re-train our model every time new data is available.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们每次获得新数据时都会重新训练我们的模型。
- en: First, we start by importing `cryptonic`. Cryptonic is a simple software application
    developed for this book that implements all the steps up to this section using
    Python classes and modules. Consider Cryptonic as a template of how you could
    develop similar applications.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过导入`cryptonic`开始。Cryptonic是为本书开发的一个简单软件应用，它使用Python类和模块实现了直到这一部分的所有步骤。可以将Cryptonic看作是一个模板，展示了你如何开发类似的应用程序。
- en: '`cryptonic` is provided as a Python module alongside this activity. First,
    we will start a Jupyter Notebook instance, and then we will load the `cryptonic`
    package.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`cryptonic`作为一个Python模块随本活动一起提供。首先，我们将启动一个Jupyter Notebook实例，然后加载`cryptonic`包。'
- en: 'Using your terminal, navigate to the directory *Chapter_7/activity_8* and execute
    the following code to start a Jupyter Notebook instance:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的终端，导航到目录*Chapter_7/activity_8*，然后执行以下代码以启动一个Jupyter Notebook实例：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Open the URL provided by the application in your browser and open the Jupyter
    Notebook named `Activity_8_Re_training_a_model_dynamically.ipynb`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开应用程序提供的URL，并打开名为`Activity_8_Re_training_a_model_dynamically.ipynb`的Jupyter
    Notebook。
- en: 'Now, we will load both classes from `cryptonic: Model()` and`CoinMarketCap()`
    . These classes facilitate the process of manipulating our model and also the
    process of getting data from the website CoinMarketCap ([https://coinmarketcap.com/](https://coinmarketcap.com/)).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我们将从`cryptonic: Model()`和`CoinMarketCap()`加载两个类。这些类有助于操作我们的模型，并且能够从网站CoinMarketCap
    ([https://coinmarketcap.com/](https://coinmarketcap.com/)) 获取数据。'
- en: 'In the Jupyter Notebook instance, navigate to the header **Fetching Real-Time
    Data**. We will now be fetching updated historical data from `CoinMarketCap`.
    Simply call the method:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Jupyter Notebook 实例中，导航到标题 **获取实时数据**。我们现在将从 `CoinMarketCap` 获取更新的历史数据。只需调用该方法：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The variable `historic_data` is now populated with a Pandas DataFrame that contains
    data up to today or yesterday. This is great and makes it easier to retrain our
    model when more data is available.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `historic_data` 现在被填充为一个 Pandas DataFrame，包含直到今天或昨天的数据。这很棒，并且当更多数据可用时，这使得我们可以更容易地重新训练模型。
- en: The data contains practically the same variables from our earlier dataset. However,
    much of the data comes from an earlier period. Recent Bitcoin prices have gained
    a lot of volatility compared to the prices of a few years ago. Before using this
    data in our model, let's make sure to filter it to dates after January 1, 2017.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 数据基本包含了我们早期数据集中的相同变量。然而，大部分数据来自较早的时期。近期的比特币价格相比几年前已经出现了较大的波动。在将这些数据用于模型之前，让我们确保只使用2017年1月1日之后的日期数据。
- en: 'Using the Pandas API, filter the data for only the dates available in 2017:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Pandas API，过滤仅包含2017年可用日期的数据：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You should be able to do this by using the date variable as the filtering index.
    Make sure the data is filtered before you continue.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该可以使用日期变量作为过滤索引来实现这一点。确保在继续之前过滤数据。
- en: The class `Model()` compiles all the code we have written so far in all of our
    activities. We will use that class to build, train, and evaluate our model in
    this activity.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Model()` 类将我们迄今为止在所有活动中编写的代码汇总起来。我们将使用这个类来构建、训练和评估我们的模型。'
- en: 'Using the Model() class, we now train a model using the preceding filtered
    data:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Model()` 类，我们现在使用之前过滤过的数据来训练模型：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding steps showcase the complete workflow when using the `Model()`
    class for training a model.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上述步骤展示了使用 `Model()` 类训练模型时的完整工作流程。
- en: Next, we'll focus on re-training our model every time more data is available.
    This re-adjusts the weights of the network to new data.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将专注于每次新数据可用时重新训练模型。这会根据新数据调整网络的权重。
- en: In order to do this, we have configured our model to predict a week using 40
    weeks. We now want to use the remaining 10 full weeks to create overlapping periods
    of 40 weeks that include one of those 10 weeks at a time, and re-train the model
    for every one of those periods.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们已经配置了模型，通过使用40周数据来预测一周。现在我们希望使用剩余的10周完整数据，创建包含其中一个完整周的40周重叠周期，并为每个周期重新训练模型。
- en: 'Navigate to the header **Re-Train Old Model** in the Jupyter Notebook. Now,
    complete the range function and the **model_data** filtering parameters, using
    an index to split the data in overlapping groups of seven days. Then, re-train
    our model and collect the results:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Jupyter Notebook 中导航到标题 **重新训练旧模型**。现在，完成范围函数和 **model_data** 过滤参数，使用索引将数据拆分为重叠的七天组。然后，重新训练模型并收集结果：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The variables `A`, `B`, `C`, and `D` are placeholders. Use integers to create
    overlapping groups of seven days in which the overlap is of one day.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `A`、`B`、`C` 和 `D` 是占位符。使用整数创建重叠的七天组，其中重叠部分为一天。
- en: After you have re-trained your model, go ahead and invoke the `M.predict(denormalized=True)`
    function and appreciate the results.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 重新训练模型后，请调用 `M.predict(denormalized=True)` 函数并欣赏结果。
- en: Next, we'll focus on creating and training a new model every time new data is
    available. In order to do this, we now assume that we have old data for 49 weeks
    of 2017, and after a week, we now have new data. We represent this with the variables
    `old_data` and `new_data`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将专注于每次新数据可用时创建并训练一个新模型。为此，我们假设我们已经拥有2017年49周的旧数据，并且一周后，我们将拥有新数据。我们用变量
    `old_data` 和 `new_data` 来表示这一点。
- en: 'Navigate to the header **Training a New Model** and split the data between
    the variables `old_data` and `new_data`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到标题 **训练新模型**，并将数据分割到变量 `old_data` 和 `new_data` 中：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, train the model with `old_data` first:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，首先使用 `old_data` 训练模型：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This strategy is about building the model from scratch and training it when
    new data is available. Go ahead and implement that in the following cells.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个策略是从零开始构建模型，并在有新数据时进行训练。请继续在接下来的单元格中实现这一点。
- en: We now have all the pieces that we need in order to train our model dynamically.
    In the next section, we will deploy our model as a web application, making its
    predictions available in the browser via an HTTP API.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有训练模型所需的所有组件。在下一节中，我们将部署我们的模型为 Web 应用程序，通过 HTTP API 在浏览器中提供预测。
- en: 'In this section, we learned about two strategies for training a model when
    new data is available:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了在新数据可用时训练模型的两种策略：
- en: Re-training an old model
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新训练旧模型
- en: Training a new model
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练新模型
- en: The latter creates a new model that is trained with the full set of data, except
    the observations in the test set. The former trains a model once on available
    data, then continues to create overlapping batches to re-train that same model
    every time new data is available.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 后者创建一个新模型，该模型使用除测试集中的观察数据外的完整数据集进行训练。前者则在可用数据上训练一次模型，然后继续创建重叠的批次，每当有新数据可用时重新训练同一模型。
- en: Deploying a Model as a Web Application
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署模型为 Web 应用程序
- en: In this section, we will deploy our model as a web application. We will use
    an example web application—called "`cryptonic`"—to deploy our model, exploring
    its architecture so that we can make modifications in the future. The intention
    is to have you use this application as a starter for more complex applications;
    a starter that is fully working and can be expanded as you see fit.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将把我们的模型部署为 Web 应用程序。我们将使用一个名为 "`cryptonic`" 的示例 Web 应用程序来部署我们的模型，探索其架构，以便未来可以进行修改。目的是让您将这个应用程序作为更复杂应用程序的起点；它是一个完全可运行的起点，您可以根据需要进行扩展。
- en: Aside from familiarity with Python, this topic assumes familiarity with creating
    web applications. Specifically, we assume that you have some knowledge about web
    servers, routing, the HTTP protocol, and caching. You will be able to locally
    deploy the demonstrated cryptonic application without extensive knowledge of these
    topics, but learning these topics will make any future development much easier.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了熟悉 Python，本主题假设您已了解创建 Web 应用程序。具体来说，我们假设您对 Web 服务器、路由、HTTP 协议和缓存有所了解。您将能够在没有深入了解这些主题的情况下，本地部署示范的
    cryptonic 应用程序，但学习这些内容将使未来的开发变得更加容易。
- en: Finally, Docker is used to deploy our web applications, so basic knowledge of
    that technology is also useful.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Docker 被用于部署我们的 Web 应用程序，因此掌握该技术的基础知识也很有用。
- en: Application Architecture and Technologies
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序架构和技术
- en: 'In order to deploy our web applications, we will use the tools and technologies
    described on Table 1\. Flask is key because it helps us create an HTTP interface
    to our model, allowing us to access an HTTP endpoint (such as /`predict`) and
    receive data back in a universal format. The other components are used because
    they are popular choices when developing web applications:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了部署我们的 Web 应用程序，我们将使用表 1 中描述的工具和技术。Flask 是关键，因为它帮助我们为模型创建 HTTP 接口，使我们能够访问 HTTP
    端点（例如 /`predict`）并以通用格式接收数据。其他组件则是开发 Web 应用程序时的流行选择：
- en: '| **Tool or Technology**  | **Description**  | **Role**  |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| **工具或技术**  | **描述**  | **角色**  |'
- en: '| Docker  | Docker is a technology used for working with applications packaged
    in the form of'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '| Docker  | Docker 是一种用于处理以容器形式打包的应用程序的技术'
- en: containers. Docker is an increasingly popular
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 容器。Docker 是一种日益流行的
- en: technology for building web applications.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 技术，用于构建 Web 应用程序。
- en: '| Packages Python application and UI.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '| 打包 Python 应用程序和 UI。'
- en: '|'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Flask  | Flask is a micro-framework for building web applications in Python.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '| Flask  | Flask 是一个用于构建 Python Web 应用程序的微框架。'
- en: '| Creates application routes'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '| 创建应用程序路由'
- en: '|'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Vue.js  | JavaScript framework that works by dynamically changing templates
    on the'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '| Vue.js  | 通过动态更改模板来工作的 JavaScript 框架'
- en: frontend based on data inputs from the
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 基于来自
- en: backend.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 后端。
- en: '| Renders a user interface.  |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 渲染用户界面。 |'
- en: '| Nginx  | Web server easily configurable to route traffic to Dockerized applications
    and handle SSL'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '| Nginx  | Web 服务器，易于配置，用于将流量路由到 Docker 化的应用程序并处理 SSL'
- en: certificates for an HTTPS connection.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 用于 HTTPS 连接的证书。
- en: '| Routes traffic between user and Flask application.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '| 路由流量在用户和 Flask 应用程序之间。 '
- en: '|'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Redis  | Key-value database. It''s a popular choice for implementing caching
    systems due to its'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '| Redis  | 键值数据库。由于其'
- en: simplicity and speed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 简洁性和速度。
- en: '| Cache API requests.  |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 缓存 API 请求。 |'
- en: '*Table 1*: Tools and technologies used for deploying a deep learning web application'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 1*：用于部署深度学习 Web 应用程序的工具和技术'
- en: 'These components fit together, as shown in the following figure:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件组合在一起，如下图所示：
- en: '![](img/4882144f-5d91-4ae6-9e85-a5da11185a70.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4882144f-5d91-4ae6-9e85-a5da11185a70.png)'
- en: 'Figure 1: System architecture for the web application built in this project'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1：本项目中构建的 Web 应用程序的系统架构
- en: A user visits the web application using their browser. That traffic is then
    routed by `Nginx` to the Docker container containing the Flask application (by
    default, running on port 5000). The Flask application has instantiated our Bitcoin
    model at startup. If a model has been given, it uses that model without training;
    if not, it creates a new model and trains it from scratch using data from CoinMarketCap.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通过浏览器访问 Web 应用程序。然后，`Nginx` 会将流量路由到包含 Flask 应用程序的 Docker 容器（默认情况下，运行在 5000
    端口）。Flask 应用程序在启动时已经实例化了我们的比特币模型。如果给定了模型，它将使用该模型而不进行训练；如果没有，它将创建一个新模型并使用来自 CoinMarketCap
    的数据从头开始训练。
- en: After having a model ready, the application verifies if the request has been
    cached on Redis—if yes, it returns the cached data. If no cache exists, then it
    will go ahead and issue predictions which are rendered in the UI.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备好模型后，应用程序会检查请求是否已缓存于 Redis 中——如果有，则返回缓存的数据。如果没有缓存，它将继续发出预测并在 UI 中渲染结果。
- en: Deploying and Using Cryptonic
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署和使用 Cryptonic
- en: '`cryptonic` is developed as a Dockerized application. In Docker terms, that
    means that the application can be built as a Docker image and then deployed as
    a Docker container in either a development or a production environment.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`cryptonic` 被开发为一个 Docker 化应用程序。从 Docker 的角度来看，这意味着应用程序可以作为 Docker 镜像构建，然后在开发或生产环境中作为
    Docker 容器部署。'
- en: 'Docker uses files called `Dockerfile` for describing the rules for how to build
    an image and what happens when that image is deployed as a container. Cryptonic''s
    Dockerfile is available in the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 使用名为 `Dockerfile` 的文件来描述如何构建镜像以及当镜像作为容器部署时会发生什么。Cryptonic 的 Dockerfile
    可以在以下代码中找到：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Snippet 6*: Docker file for the cryptonic image'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*片段 6*：cryptonic 镜像的 Docker 文件'
- en: 'A Docker file can be used to build a Docker image with the following command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令通过 Docker 文件构建 Docker 镜像：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Snippet 7*: Docker command for building a Docker image locally'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*片段 7*：用于在本地构建 Docker 镜像的 Docker 命令'
- en: This command will make the image `cryptonic:latest` available to be deployed
    as a container. The building process can be repeated on a production server, or
    the image can be directly deployed and then run as a container.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将使镜像 `cryptonic:latest` 可用，并可以作为容器进行部署。构建过程可以在生产服务器上重复，或者直接部署镜像并作为容器运行。
- en: 'After an image has been built and is available, one can run the cryptonic application
    by using the command docker run, as shown in the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在镜像构建并可用后，可以使用 docker run 命令来运行 cryptonic 应用程序，如以下代码所示：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Snippet 8*: Example executing the docker run command in the terminal'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*片段 8*：在终端中执行 docker run 命令的示例'
- en: The `--publish` flag binds port 5000 on localhost to port 5000 on the Docker
    container, and `--detach` runs the container as a daemon in the background.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`--publish` 标志将本地主机的 5000 端口绑定到 Docker 容器的 5000 端口，而 `--detach` 会将容器作为守护进程在后台运行。'
- en: In case you have trained a different model and would like to use that instead
    of training a new model, you can alter the `MODEL_NAME` environment variable on
    the docker-compose. yml, as shown in Snippet 9\. That variable should contain
    the filename of the model you have trained and want served (for example, `bitcoin_lstm_v1_trained.h5`)—it
    should also be a Keras model. If you do that, make sure to also mount a local
    directory into the / models folder. The directory that you decide to mount must
    have your model file.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经训练了一个不同的模型，并希望使用该模型而不是训练一个新模型，您可以在 docker-compose.yml 文件中修改 `MODEL_NAME`
    环境变量，如 *片段 9* 所示。该变量应包含您训练并希望提供的模型的文件名（例如，`bitcoin_lstm_v1_trained.h5`）——它应该也是一个
    Keras 模型。如果您这么做，确保将本地目录挂载到 /models 文件夹中。您决定挂载的目录必须包含您的模型文件。
- en: 'The `cryptonic` application also includes a number of environment variables
    that you may find useful when deploying your own model:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`cryptonic` 应用程序还包括一些环境变量，您在部署自己的模型时可能会觉得很有用：'
- en: '`MODEL_NAME`: Allows one to provide a trained model to be used by the application.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MODEL_NAME`：允许提供一个训练好的模型，以供应用程序使用。'
- en: '`BITCOIN_START_DATE`: Determines which day to use as the starting day for the
    Bitcoin series. Bitcoin prices have a lot more variance in recent years than earlier
    ones. This parameter filters the data to only years of interest. The default is
    January 1, 2017.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BITCOIN_START_DATE`：确定用作比特币系列起始日的日期。近年来，比特币价格的波动性远大于早期的波动性。此参数将过滤数据，仅使用感兴趣年份的数据。默认值是2017年1月1日。'
- en: '`PERIOD_SIZE`: Sets the period size in terms of days. The default is 7.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PERIOD_SIZE`：设置周期大小（以天为单位）。默认值为7。'
- en: '`EPOCHS`: Configures the number of epochs that the model trains on every run.
    The default is 300.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EPOCHS`：配置模型每次运行时训练的轮次。默认值为300。'
- en: 'These variables can be configured in the `docker-compose.yml` file, as shown
    in the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量可以在`docker-compose.yml`文件中进行配置，如下所示：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Snippet 9*: `docker-compose.yml` file including environment variables'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码片段 9*：包含环境变量的`docker-compose.yml`文件'
- en: 'The easiest way to deploy cryptonic is to use the `docker-compose.yml` file
    from Snippet 9\. This file contains all the specifications necessary for the application
    to run, including instructions on how to connect with the Redis cache, and what
    environment variables to use. After navigating to the location of the `docker-compose.yml
    file`, cryptonic can then be started with the command `docker-compose up`, as
    shown in the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 部署cryptonic最简单的方法是使用代码片段9中的`docker-compose.yml`文件。该文件包含应用程序运行所需的所有规格，包括如何连接Redis缓存以及使用哪些环境变量的说明。导航到`docker-compose.yml`文件所在的位置后，可以使用命令`docker-compose
    up`启动cryptonic，如下所示：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Snippet 10*: Starting a Docker application with docker-compose. The flag -d
    executes the application in the background.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码片段 10*：使用docker-compose启动Docker应用程序。`-d`标志将在后台执行应用程序。'
- en: 'After being deployed, cryptonic can be accessed on port `5000` via a web browser.
    The application has a simple user interface with a time-series plot depicting
    real historical prices (in other words, observed) and predicted future prices
    from the deep learning model (in other words, predicted). One can also read, in
    the text, both the RMSE and the MAPE calculated using the `Model().evaluate()`
    method:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 部署后，可以通过Web浏览器在`5000`端口访问cryptonic。该应用程序具有一个简单的用户界面，显示一个时间序列图，其中展示了真实的历史价格（即观察到的）和深度学习模型预测的未来价格（即预测的）。还可以在文本中看到使用`Model().evaluate()`方法计算的RMSE和MAPE：
- en: '![](img/c4f9e7fd-36c2-4123-a2f4-1b7bfb335b64.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c4f9e7fd-36c2-4123-a2f4-1b7bfb335b64.png)'
- en: 'Figure 2: Screenshot of the deployed cryptonic application'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2：部署后的cryptonic应用程序截图
- en: Aside from its user interface (developed using `Vue.js`), the application has
    an HTTP API that makes predictions when invoked.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其用户界面（使用`Vue.js`开发），该应用程序还具有一个HTTP API，在调用时进行预测。
- en: 'The API has the endpoint /`predict`, which returns a JSON object containing
    the de-normalized Bitcoin prices prediction for a week into the future:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: API有`/predict`端点，该端点返回一个JSON对象，包含未来一周内的去归一化比特币价格预测：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Snippet 11*: Example JSON output from the /predict endpoint'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码片段 11*：/predict端点的示例JSON输出'
- en: The application can now be deployed in a remote server and used to continuously
    predict Bitcoin prices.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序现在可以部署在远程服务器上，并用于持续预测比特币价格。
- en: Activity:Deploying a Deep Learning Application
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：部署深度学习应用程序
- en: 'In this activity, we deploy our model as a web application locally. This allows
    us to connect to the web application using a browser or to use another application
    through the application''s HTTP API. Before we continue, make sure that you have
    the following applications installed and available in your computer:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本次活动中，我们将模型作为本地Web应用程序部署。这使得我们可以通过浏览器连接到该Web应用程序，或通过应用程序的HTTP API使用其他应用程序。在继续之前，请确保您的计算机中已安装并可用以下应用程序：
- en: Docker (Community Edition) 17.12.0-ce or later
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker（社区版）17.12.0-ce或更高版本
- en: Docker Compose (docker-compose) 1.18.0 or later
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose (docker-compose) 1.18.0或更高版本
- en: 'Both of the components above can be downloaded and installed in all major systems
    from the website: [http://docker.com/.](https://www.docker.com/) These are essential
    for completing this activity. Make sure these are available in your system before
    moving forward.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 上述两个组件可以从网站[http://docker.com/.](https://www.docker.com/)下载并安装到所有主要系统中。这些是完成此活动的必要组件。在继续之前，请确保这些组件在您的系统中可用。
- en: 'Using your terminal, navigate to the cryptonic directory and build the docker images
    for all the required components:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用终端导航到cryptonic目录并构建所有必需组件的Docker镜像：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Those two commands build the two images that we will use in this application:
    cryptonic (containing the Flask application) and cryptonic-cache (containing the
    Redis cache).'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两条命令构建了我们将在此应用中使用的两个镜像：cryptonic（包含 Flask 应用）和 cryptonic-cache（包含 Redis 缓存）。
- en: 'After building the images, identify the `docker-compose.yml` file and open
    it in a text editor. Change the parameter `BITCOIN_START_DATE` to a date other
    than 2017- 01-01:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建完镜像后，找到 `docker-compose.yml` 文件并用文本编辑器打开。将参数 `BITCOIN_START_DATE` 改为除 2017-01-01
    以外的其他日期：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As a final step, deploy your web application locally using docker-compose,
    as follows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后的步骤是使用 docker-compose 在本地部署你的网页应用，步骤如下：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You should see a log of activity on your terminal, including training epochs
    from your model.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在终端中看到一份活动日志，其中包括模型的训练周期。
- en: 'After the model has been trained, you can visit your application on `http://
    localhost:5000` and make predictions on `http://localhost:5000/predict`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模型训练完成后，你可以访问 `http://localhost:5000` 你的应用，并在 `http://localhost:5000/predict`
    进行预测：
- en: '![](img/b5aed7a8-3696-433f-8f2d-21b8f41ec65f.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5aed7a8-3696-433f-8f2d-21b8f41ec65f.png)'
- en: 'Figure 3: Screenshot of the cryptonic application deployed locally'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3：在本地部署的 Cryptonic 应用程序的截图
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter concludes our journey into creating a deep learning model and deploying
    it as a web application. Our very last steps included deploying a model that predicts
    Bitcoin prices built using Keras and using a TensorFlow engine. We finished our
    work by packaging the application as a Docker container and deploying it so that
    others can consume the predictions of our model—as well as other applications
    via its API.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 本章总结了我们创建深度学习模型并将其作为网页应用部署的过程。我们的最后一步是部署一个使用 Keras 和 TensorFlow 引擎构建的比特币价格预测模型。我们通过将应用打包成
    Docker 容器并进行部署，使得其他人可以使用我们的模型进行预测——以及通过其 API 使用其他应用。
- en: 'Aside from that work, you have also learned that there is much that can be
    improved. Our Bitcoin model is only an example of what a model can do (particularly
    LSTMs). The challenge now is two fold: how can you make that model perform better
    as time passes? And, what features can you add to your web application to make
    your model more accessible? Good luck and keep learning!'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些工作，你还会发现有许多地方可以改进。我们的比特币模型仅仅是模型可以做的一个示例（特别是 LSTM 模型）。现在的挑战有两个方面：如何随着时间的推移让这个模型表现得更好？以及，如何在你的网页应用中添加一些功能，使得你的模型更易于访问？祝你好运，继续学习！
