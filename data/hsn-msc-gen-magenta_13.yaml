- en: Making Magenta Interact with Music Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使Magenta与音乐应用程序互动
- en: In this chapter, we'll see how Magenta fits into a broader picture by showing
    how to make it interact with other music applications such as **Digital Audio
    Workstations** (**DAWs**) and synthesizers. We'll explain how to send MIDI sequences
    from Magenta to FluidSynth and DAWs using the MIDI interface. By doing so, we'll
    learn how to handle MIDI ports on all platforms and how to loop MIDI sequences
    in Magenta. We'll show how to synchronize multiple applications using MIDI clocks
    and transport information. Finally, we'll cover Magenta Studio, a standalone packaging
    of Magenta based on Magenta.js that can also integrate into Ableton Live as a
    plugin.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示Magenta如何融入更广泛的应用场景，展示如何使其与其他音乐应用程序（如**数字音频工作站**（**DAWs**）和合成器）互动。我们将解释如何通过MIDI接口将MIDI序列从Magenta发送到FluidSynth和DAW。通过这种方式，我们将学习如何在所有平台上处理MIDI端口，以及如何在Magenta中循环MIDI序列。我们还将展示如何使用MIDI时钟和传输信息同步多个应用程序。最后，我们将介绍Magenta
    Studio，它是基于Magenta.js的Magenta独立包装，可以作为插件集成到Ableton Live中。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Sending MIDI to a DAW or synthesizer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将MIDI发送到DAW或合成器
- en: Looping the generated MIDI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环生成的MIDI
- en: Using Magenta as a standalone application with Magenta Studio
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Magenta作为独立应用程序与Magenta Studio一起使用
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we''ll use the following tools:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用以下工具：
- en: The **command line** or **Bash** to launch Magenta from the Terminal
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**命令行**或**Bash**从终端启动Magenta
- en: '**Python** and its libraries to write music generation code using Magenta'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Python**及其库编写音乐生成代码，使用Magenta
- en: '**Magenta** to generate music in MIDI and synchronize with other applications'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Magenta**生成MIDI音乐并与其他应用程序同步
- en: '**Mido** and other MIDI tools to send MIDI notes and clock'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Mido**及其他MIDI工具发送MIDI音符和时钟
- en: '**FluidSynth** to receive MIDI from Magenta'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**FluidSynth**接收来自Magenta的MIDI
- en: A **DAW** of your choice (Ableton Live, Bitwig, and so on) to receive MIDI from
    Magenta
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你选择的**DAW**（例如Ableton Live、Bitwig等）来接收来自Magenta的MIDI
- en: '**Magenta Studio** as a standalone application or Ableton Live plugin'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Magenta Studio**作为独立应用程序或Ableton Live插件'
- en: In Magenta, we'll make the use of the **MIDI interface** to send MIDI sequences
    and MIDI clock to other music applications. We'll cover its usage in depth, but
    if you feel like you need more information, the Magenta MIDI interface, `README.md`,
    in the Magenta source code ([github.com/tensorflow/magenta/tree/master/magenta/interfaces/midi](https://github.com/tensorflow/magenta/tree/master/magenta/interfaces/midi))
    is a good place to start. You can also take a look at Magenta's code, which is
    well documented. We also provide additional content in the *Further reading* section
    at the end of this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Magenta中，我们将使用**MIDI接口**将MIDI序列和MIDI时钟发送到其他音乐应用程序。我们将深入讨论其使用方法，但如果你需要更多信息，可以查看Magenta源代码中的Magenta
    MIDI接口`README.md`，链接为([github.com/tensorflow/magenta/tree/master/magenta/interfaces/midi](https://github.com/tensorflow/magenta/tree/master/magenta/interfaces/midi))，这是一个很好的起点。你还可以查看Magenta的代码，里面有很好的文档。我们还在本章末尾的*进一步阅读*部分提供了额外的内容。
- en: We'll also make the use of the **Magenta Studio** project on which you can find
    more information on its GitHub page at [github.com/tensorflow/magenta-studio](https://github.com/tensorflow/magenta-studio).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用**Magenta Studio**项目，你可以在其GitHub页面上找到更多信息，链接为[github.com/tensorflow/magenta-studio](https://github.com/tensorflow/magenta-studio)。
- en: The code for this chapter is in this book's GitHub repository in `Chapter09` folder,
    located at [github.com/PacktPublishing/hands-on-music-generation-with-magenta/tree/master/Chapter09](https://github.com/PacktPublishing/hands-on-music-generation-with-magenta/tree/master/Chapter09).
    The examples and code snippets will assume you are located in this chapter's folder.
    For this chapter, you should go to `cd Chapter09` before you start. Check out
    the following video to see the Code in Action: [http://bit.ly/2RGkEaG](http://bit.ly/2RGkEaG).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码位于本书GitHub仓库中的`Chapter09`文件夹，地址为[github.com/PacktPublishing/hands-on-music-generation-with-magenta/tree/master/Chapter09](https://github.com/PacktPublishing/hands-on-music-generation-with-magenta/tree/master/Chapter09)。示例和代码片段假定你位于该章节的文件夹中。开始之前，你应使用`cd
    Chapter09`进入该文件夹。查看以下视频，了解代码的实际操作：[http://bit.ly/2RGkEaG](http://bit.ly/2RGkEaG)。
- en: Sending MIDI to a DAW or synthesizer
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将MIDI发送到DAW或合成器
- en: Since the start of this book, we've been generating MIDI as physical files and
    then listening to them using either MuseScore or FluidSynth. This is a good way
    of composing music, generating new sequences, keeping the ones we like, and generating
    more based on them. But what if we'd like the MIDI notes to play continuously
    as the model generates them? This is a good way of making an autonomous music
    generation system, where Magenta is the composer, and an external program is a
    player, as it plays the notes it receives using instruments.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书开始，我们一直在生成MIDI作为物理文件，然后使用MuseScore或FluidSynth进行播放。这是一种很好的作曲方式，能够生成新的序列，保留我们喜欢的部分，并基于它们生成更多内容。但是，如果我们希望MIDI音符在模型生成它们时持续播放呢？这就是建立一个自主的音乐生成系统的好方法，Magenta作为作曲者，外部程序作为播放器，播放它收到的音符并使用乐器。
- en: In this section, we'll be looking at how to send MIDI from Magenta to synthesizers
    or DAWs. We'll also show how to loop the sequences that are generated in Magenta
    and how to synchronize our Magenta program with the application it is sending
    the sequences to.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将介绍如何将MIDI从Magenta发送到合成器或DAW。我们还将展示如何循环Magenta生成的序列，并如何将我们的Magenta程序与发送序列的应用程序同步。
- en: Introducing some DAWs
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍一些DAW
- en: 'Producing music using a DAW has many advantages over simple synthesizers such
    as FluidSynth:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DAW制作音乐相较于简单的合成器（如FluidSynth）有很多优势：
- en: Recording and **editing MIDI** sequences
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 录制和**编辑MIDI**序列
- en: Recording and **editing audio**, either for the master track or single (instrument)
    track
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 录制和**编辑音频**，无论是母带轨道还是单一（乐器）轨道
- en: Creating our own **synthesizers** using oscillators, envelopes, filters, and
    so on
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用振荡器、包络、滤波器等创建我们自己的**合成器**
- en: Using **effects** such as reverb, delay, saturation, and so on
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**效果**（如混响、延迟、饱和度等）
- en: Applying **EQ** and **mastering** to the audio tracks
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对音轨应用**均衡器**（EQ）和**母带处理**（mastering）
- en: Cutting, merging, and mixing **audio clips** to produce a whole track
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剪辑、合并和混合**音频片段**以制作完整的轨道
- en: 'There are many DAWs on the market, but unfortunately, not many of them are
    open source or free to use. We''ll give a small tour (which is not extensive by
    any means) of some DAWs that we think are interesting to use with Magenta:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 市面上有很多DAW，但不幸的是，其中很少有开源或免费的可供使用。我们将对一些我们认为与Magenta搭配使用时很有趣的DAW进行简要介绍（这并不是全面的介绍）：
- en: '**Ableton Live** ([www.ableton.com](https://www.ableton.com) – *not free*)
    is a well known product in the music industry and has been around for a long time.
    Ableton Live is one of the most complete DAWs on the market but is sold at a hefty
    price for all of the features. It works only on Windows and macOS.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ableton Live**（[www.ableton.com](https://www.ableton.com) – *非免费*）是音乐行业中广为人知的产品，已有很长历史。Ableton
    Live是市场上最完整的DAW之一，但其所有功能的价格较高。它仅支持Windows和macOS系统。'
- en: '**Bitwig** ([www.bitwig.com](https://www.bitwig.com) – *not free*) is also
    a very complete product, similar to Ableton Live, and is a bit less pricey than
    its counterpart. It is a good DAW with many features and is available on all platforms,
    Windows, macOS, and Linux.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bitwig**（[www.bitwig.com](https://www.bitwig.com) – *非免费*）也是一款非常完整的产品，类似于Ableton
    Live，价格略低于其对手。它是一款功能丰富的DAW，支持所有平台：Windows、macOS和Linux。'
- en: '**Reason** ([www.reasonstudios.com/](https://www.reasonstudios.com/) – *not
    free*) is a DAW that focuses on instruments and effects rather than composition.
    It works really well when integrated with another software for the MIDI sequencing,
    such as Ableton Live or Magenta. It works only on Windows and macOS.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reason**（[www.reasonstudios.com/](https://www.reasonstudios.com/) – *非免费*）是一款专注于乐器和效果的DAW，而非作曲。它与其他软件（如Ableton
    Live或Magenta）结合使用时，MIDI编排效果特别好。它仅支持Windows和macOS系统。'
- en: '**Cubase** ([new.steinberg.net/cubase/](https://new.steinberg.net/cubase/) –
    *not free*), from Steinberg, a renowned company making all sorts of audio software
    and hardware, is one of the oldest DAWs out there. It works only on Windows and
    macOS.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cubase**（[new.steinberg.net/cubase/](https://new.steinberg.net/cubase/) –
    *非免费*），由著名的音频软件和硬件公司Steinberg开发，是市场上最古老的DAW之一。它仅支持Windows和macOS系统。'
- en: '**Cakewalk** ([www.bandlab.com/products/cakewalk](https://www.bandlab.com/products/cakewalk) –
    *free*) by Bandlab is a complete and easy-to-use DAW. This is the only non-open
    source DAW that is free to use. It works only on Windows, unfortunately.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cakewalk**（[www.bandlab.com/products/cakewalk](https://www.bandlab.com/products/cakewalk)
    – *免费*）是Bandlab推出的一个完整且易于使用的DAW。这是唯一一款非开源但免费的DAW。遗憾的是，它仅支持Windows系统。'
- en: '**SuperCollider** ([supercollider.github.io/](https://supercollider.github.io/) –
    *free and open source*) is a platform for audio synthesis and algorithmic composition,
    enabling the development of synthesizers and effects using code, with a language
    called `sclang`. It works on all platforms and is open source.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SuperCollider** ([supercollider.github.io/](https://supercollider.github.io/)
    – *免费且开源*) 是一个音频合成和算法作曲的平台，允许通过编程开发合成器和效果器，使用的编程语言叫做`sclang`。它适用于所有平台并且是开源的。'
- en: '**VCV Rack** ([vcvrack.com/](https://vcvrack.com/) – *free and open source*)
    is a DAW that reproduces the joys of modular synthesis in software form. It works
    on all platforms and is open source.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VCV Rack** ([vcvrack.com/](https://vcvrack.com/) – *免费且开源*) 是一个DAW，它以软件形式再现了模块化合成的乐趣。它适用于所有平台并且是开源的。'
- en: We'll be giving our examples using Ableton Live, but all DAWs have similar features
    when it comes to receiving MIDI, so the examples should work well for all software.
    We'll highlight caveats when possible, such as handling MIDI routing on Linux.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Ableton Live来做示例，但所有DAW在接收MIDI方面都有类似的功能，所以这些示例应该适用于所有软件。如果有必要，我们会重点说明一些注意事项，比如在Linux上处理MIDI路由的问题。
- en: Looking at MIDI ports using Mido
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Mido查看MIDI端口
- en: First things first, we need to find what MIDI ports are available on the machine,
    if any, to send MIDI messages between applications, such as Magenta to FluidSynth
    or a DAW. There is a great library called Mido, MIDI Objects for Python ([mido.readthedocs.io](https://mido.readthedocs.io)),
    that is really useful in finding MIDI ports, creating new ones, and sending data
    over.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要查找机器上可用的MIDI端口（如果有的话），以便在应用程序之间发送MIDI信息，比如从Magenta到FluidSynth或DAW。这里有一个非常实用的库叫做Mido，它是Python的MIDI对象库（[mido.readthedocs.io](https://mido.readthedocs.io)），在查找MIDI端口、创建新端口和发送数据方面非常有用。
- en: Since Magenta has a dependency on Mido, it is already installed in our Magenta
    environment.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Magenta依赖于Mido，它已经在我们的Magenta环境中安装好了。
- en: You can follow this example in the `chapter_09_example_01.py` file in the source
    code of this chapter. There are more comments and content in the source code,
    so you should go check it out.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本章的源代码中的`chapter_09_example_01.py`文件中跟随这个示例。源代码中有更多的注释和内容，所以你应该去查看一下。
- en: 'Let''s look at the MIDI ports that are available on our machine:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下我们机器上可用的MIDI端口：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This should produce an output similar to the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生类似于以下的输出：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On Linux and macOS, one input port and one output port should already be present,
    as in the preceding output. On Windows, the list is either empty, because the
    OS doesn't create any virtual MIDI ports automatically, or contains only `Microsoft
    GS Wavetable Synth`, a MIDI synthesizer like FluidSynth.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux和macOS上，应该已经有一个输入端口和一个输出端口，如前面的输出所示。在Windows上，列表可能是空的，因为操作系统不会自动创建任何虚拟MIDI端口，或者列表只包含`Microsoft
    GS Wavetable Synth`，这是一个类似FluidSynth的MIDI合成器。
- en: Let's have a look at how to create new ports for our applications to communicate.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何为我们的应用程序创建新的端口以进行通信。
- en: Creating a virtual MIDI port on macOS and Linux
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在macOS和Linux上创建虚拟MIDI端口
- en: What is nice about FluidSynth is that it opens a Virtual MIDI port automatically
    at launch. Unfortunately, it doesn't work on Windows, so we'll be looking at how
    to create Virtual MIDI ports works first.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: FluidSynth的一个优点是它在启动时会自动打开一个虚拟MIDI端口。不幸的是，它在Windows上无法使用，因此我们首先会了解如何创建虚拟MIDI端口。
- en: A Virtual MIDI port is a MIDI port that can be created for **applications to
    send MIDI messages between them**. This is essential for all music production
    applications. For Magenta to send MIDI data to another program such as a DAW,
    we'll need to open a virtual port for them to communicate.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟MIDI端口是可以创建的MIDI端口，**用于应用程序之间发送MIDI消息**。这是所有音乐制作应用程序的必备功能。为了让Magenta将MIDI数据发送到其他程序（如DAW），我们需要为它们打开一个虚拟端口以便进行通信。
- en: Like we saw in the previous example, Virtual MIDI ports are either **input**
    ports or **output** ports. That means we can create an input port named `magenta` and
    an output port named `magenta`. More often then not, it is clearer to use two
    different names when doing this, for example, `magenta_out` for the output port,
    and `magenta_in` for the input port. It is also simpler when mapping the ports
    in a DAW.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一个例子中看到的，虚拟MIDI端口分为**输入**端口和**输出**端口。这意味着我们可以创建一个名为`magenta`的输入端口和一个名为`magenta`的输出端口。通常来说，使用两个不同的名称会更清晰，例如，`magenta_out`用于输出端口，`magenta_in`用于输入端口。在DAW中映射端口时，这样也会更简单。
- en: We'll be choosing the port names from Magenta's perspective, meaning `magenta_out`
    is named as such because Magenta is sending information.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从Magenta的角度选择端口名称，也就是说，`magenta_out`之所以被命名为`magenta_out`，是因为Magenta正在发送信息。
- en: 'On macOS and Linux, creating new virtual ports is easy, since Mido supports
    the RtMidi backend that can create them. Using `MidiHub` in Magenta, we can provide
    a string for each of the input and output, for the virtual port names we want
    to create:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS和Linux上，创建新的虚拟端口非常简单，因为Mido支持可以创建端口的RtMidi后台。在Magenta中使用`MidiHub`，我们可以为每个输入和输出提供一个字符串，表示我们想要创建的虚拟端口名称：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will create two virtual ports, `magenta_in` and `magenta_out`, if they
    don''t exist, or use the existing ones if they do. Using only Mido, we can use
    the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果端口不存在，这将创建两个虚拟端口，`magenta_in`和`magenta_out`，如果已存在，则使用现有的。仅使用Mido，我们可以使用以下代码：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that an input port has a `receive` method and an output port has a `send`
    method. When printing the ports, we should see this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输入端口有一个`receive`方法，而输出端口有一个`send`方法。当打印端口时，我们应该看到以下内容：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The named virtual ports are now available, until restart, for applications to
    use.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，命名的虚拟端口可以在重启前供应用程序使用。
- en: However, depending on the DAW, this might or might not work. For example, Bitwig
    in Linux doesn't work well with ALSA virtual ports, so opening one with RtMidi
    is not sufficient; you'll have to look at the documentation for a workaround using
    **JACK Audio Connection Kit** (**JACK**). Other DAWs on Linux, such as VCV Rack,
    will work properly and show the virtual ports.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，具体是否有效取决于所使用的DAW。例如，Linux下的Bitwig与ALSA虚拟端口配合不佳，因此仅仅通过RtMidi打开一个端口是不够的；你需要查看文档，寻找使用**JACK音频连接工具包**（**JACK**）的解决方法。其他Linux上的DAW，例如VCV
    Rack，则能正常工作并显示虚拟端口。
- en: Creating a virtual MIDI port on Windows using loopMIDI
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用loopMIDI在Windows上创建虚拟MIDI端口
- en: On Windows, we can't create virtual ports using the code provided earlier. Fortunately,
    we have the **loopMIDI** software ([www.tobias-erichsen.de/software/loopmidi.html](https://www.tobias-erichsen.de/software/loopmidi.html)),
    a small and rather old program that is a godsend when using MIDI on Windows. The
    only thing it does is that it creates named virtual MIDI ports on the machine.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，我们无法使用之前提供的代码创建虚拟端口。幸运的是，我们有**loopMIDI**软件（[www.tobias-erichsen.de/software/loopmidi.html](https://www.tobias-erichsen.de/software/loopmidi.html)），这是一款小而老的程序，在Windows上使用MIDI时简直是救星。它唯一的功能就是在机器上创建命名的虚拟MIDI端口。
- en: 'Once installed, launch the software and create two new ports named `magenta_in` and
    `magenta_out` using the name field at the bottom and the plus button:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，启动软件，并使用底部的名称字段和加号按钮创建两个新的端口，命名为`magenta_in`和`magenta_out`：
- en: '![](img/d7c81c12-7fb1-405f-8035-9690b479f7d4.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7c81c12-7fb1-405f-8035-9690b479f7d4.png)'
- en: The virtual ports named `magenta_in` and `magenta_out` should now be available
    both for Ableton Live and Magenta to communicate. When creating a new port, **loopMIDI**
    always creates both the input port and the output port, meaning we can both send
    and receive MIDI from the `magenta_in` port. We'll be keeping both ports separate
    for simplicity.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为`magenta_in`和`magenta_out`的虚拟端口现在应该可以同时用于Ableton Live和Magenta进行通信。当创建新端口时，**loopMIDI**总是同时创建输入端口和输出端口，这意味着我们可以从`magenta_in`端口发送和接收MIDI。为了简便起见，我们将保持两个端口分开。
- en: 'On Windows, if you have to the following error when launching the Magenta `MidiHub`,
    this is because you haven''t properly created or named your virtual ports:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，如果启动Magenta `MidiHub`时遇到以下错误，那是因为你没有正确创建或命名虚拟端口：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Notice the port name, `magenta_out 2`, also contains the port index, `2`. This
    is important when referring to ports in Windows, as they are named using the format:
    name index. This is kind of a pain because the port index might change if you
    create new ports (or plugin new MIDI devices) that shift the indexes.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意端口名称`magenta_out 2`中也包含了端口索引`2`。这在Windows中引用端口时非常重要，因为它们是使用格式：名称 索引进行命名的。这有点麻烦，因为如果你创建新的端口（或插件新的MIDI设备）来改变索引，端口索引可能会发生变化。
- en: To fix that issue, we make sure we filter the ports using string contains and
    not exact matching (all of our provided examples work properly in this matter).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们确保使用字符串包含而不是精确匹配来过滤端口（我们提供的所有示例在这方面都能正常工作）。
- en: Adding a virtual MIDI port on macOS
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在macOS上添加虚拟MIDI端口
- en: 'On macOS, we can either use the previous method described in the *Looking at
    virtual MIDI ports* section or use the built-in macOS interface to create a new
    virtual port. Using the built-in interface is easy:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，我们可以使用前面在*查看虚拟 MIDI 端口*部分中描述的那种方法，或者使用内置的 macOS 界面创建一个新的虚拟端口。使用内置界面很简单：
- en: Launch the **Audio MIDI Setup**.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动**音频 MIDI 设置**。
- en: Open the **Window** menu and click on **Show MIDI Studio**.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**窗口**菜单并点击**显示 MIDI 工作室**。
- en: Choose the **IAC Driver** icon.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**IAC 驱动程序**图标。
- en: Activate the **Device is online** checkbox.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用**设备在线**复选框。
- en: We can then create named virtual ports using the **+** button.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用**+**按钮创建命名的虚拟端口。
- en: Sending generated MIDI to FluidSynth
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送生成的 MIDI 到 FluidSynth
- en: To send generated MIDI from Magenta to FluidSynth, we'll take one of the first
    examples we wrote in [Chapter 2](b60deee5-c58f-45eb-88a2-23718802e580.xhtml),
    *Generating Drum Sequences with the DrumsRNN*, and add some code to send the MIDI
    messages directly to the software synthesizer.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 Magenta 生成的 MIDI 发送到 FluidSynth，我们将从[第 2 章](b60deee5-c58f-45eb-88a2-23718802e580.xhtml)中编写的第一个示例中，*使用
    DrumsRNN 生成鼓序列*，并添加一些代码将 MIDI 消息直接发送到软件合成器。
- en: You can follow this example in the `chapter_09_example_02.py` file in the source
    code of this chapter. There are more comments and content in the source code,
    so you should go check it out.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本章的源代码中找到`chapter_09_example_02.py`文件中的示例。源代码中有更多的注释和内容，所以你应该去查看一下。
- en: 'This is similar to what we did in the previous chapter when we used the Web
    MIDI API to send MIDI notes to FluidSynth from the browser:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在上一章中使用 Web MIDI API 从浏览器将 MIDI 音符发送到 FluidSynth 时所做的类似：
- en: 'First, we''ll start FluidSynth using one of the following:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用以下之一启动 FluidSynth：
- en: 'Linux: `fluidsynth -a pulseaudio -g 1 PATH_TO_SF2`'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux: `fluidsynth -a pulseaudio -g 1 PATH_TO_SF2`'
- en: 'macOS: `fluidsynth -a coreaudio -g 1 PATH_TO_SF2`'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'macOS: `fluidsynth -a coreaudio -g 1 PATH_TO_SF2`'
- en: 'Windows: `fluidsynth -g 1 -o midi.winmidi.device=magenta_out PATH_TO_SF2`'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Windows: `fluidsynth -g 1 -o midi.winmidi.device=magenta_out PATH_TO_SF2`'
- en: Note the `-o` flag in the Windows command, which tells FluidSynth to listen
    to this MIDI port because, on Windows, it doesn't open up a port automatically.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 Windows 命令中的`-o`标志，它告诉 FluidSynth 监听这个 MIDI 端口，因为在 Windows 上，它不会自动打开端口。
- en: Also, notice how we aren't using the `-n` and `-i` flags this time since we
    want to keep incoming MIDI messages and use the synth command line. The program
    should stop in the command-line interface and should have created a new input
    MIDI port automatically (or will use the provided one).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意我们这次没有使用`-n`和`-i`标志，因为我们希望保留传入的 MIDI 消息并使用合成器命令行。程序应该会停留在命令行界面，并且应该自动创建一个新的输入
    MIDI 端口（或者使用提供的端口）。
- en: 'On Windows, if you see the following error message upon starting FluidSynth:
    **fluidsynth: error: no MIDI in devices found** or **Failed to create the MIDI
    thread**, this means you either misspelled the MIDI port or didn''t open **loopMIDI**.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '在 Windows 上，如果你在启动 FluidSynth 时看到以下错误消息：**fluidsynth: error: no MIDI in devices
    found** 或 **Failed to create the MIDI thread**，这意味着你可能拼写错误了 MIDI 端口名，或者没有打开**loopMIDI**。'
- en: 'On macOS and Linux, you can run the previous example code again, you should
    see an output similar to this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 和 Linux 上，你可以再次运行之前的示例代码，应该会看到类似如下的输出：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, the `FLUID Synth (7171): Synth input port (7171:0) 129:0` port is the
    FluidSynth port. We also have the `magenta_out` and `magenta_in` ports from the
    previous example.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，`FLUID Synth (7171): Synth input port (7171:0) 129:0`端口是 FluidSynth 端口。我们还可以看到来自前一个示例的`magenta_out`和`magenta_in`端口。'
- en: 'On Windows, running the previous example code again should give you this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，重新运行之前的示例代码应该会给你这个：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The FluidSynth input port that we'll use is the `magenta_out 3` port, which
    should match the `-o midi.winmidi.device=magenta_out` flag provided to FluidSynth.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的 FluidSynth 输入端口是`magenta_out 3`端口，它应该与提供给 FluidSynth 的`-o midi.winmidi.device=magenta_out`标志匹配。
- en: 'Then, we''ll copy the `chapter_02_example_01.py` example:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将复制`chapter_02_example_01.py`示例：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We add a `--midi_port` flag to change the MIDI output port (remember the input
    and output terminology is from Magenta's perspective) easily for our examples.
    We'll be writing the code to send the MIDI content (which is in the `sequence`
    variable) at the end of the `generate` method.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个`--midi_port`标志来轻松更改 MIDI 输出端口（记住，输入和输出术语是从 Magenta 的角度看待的）。我们将在`generate`方法的末尾编写代码，以发送
    MIDI 内容（它存储在`sequence`变量中）。
- en: 'We find the provided output port and initialize `MidiHub` using the port:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们找到提供的输出端口并使用该端口初始化`MidiHub`：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We then start a new MIDI hub on that port; it will serve as a communication
    interface between our app and the synth. It is useful because it enables us to
    use `NoteSequence` objects directly without the need of converting them by hand.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在该端口上启动一个新的 MIDI 中心；它将作为我们应用程序与合成器之间的通信接口。它很有用，因为它使我们能够直接使用`NoteSequence`对象，而无需手动转换它们。
- en: The `midi_hub` module is located in Magenta in the `magenta.interfaces.midi`
    module and contains useful utilities for handling MIDI.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`midi_hub`模块位于 Magenta 的`magenta.interfaces.midi`模块中，并包含处理 MIDI 的有用工具。'
- en: 'Next, we''ll get a player instance from the hub and set the playback channel
    to `9`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将从中心获取一个播放器实例，并将播放通道设置为`9`：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Remember that GM 1 compatible synthesizers will play the drums sound bank if
    the MIDI channel is `10` (but the channel is zero-indexed in Magenta MIDI hub
    so we have to use `9`). We'll be starting the playback on an empty sequence, allowing the
    update of the sequence later.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，兼容 GM 1 的合成器如果 MIDI 通道为`10`时会播放鼓声音色（但在 Magenta MIDI 中，通道是从零开始计数的，因此我们需要使用`9`）。我们将在一个空序列上开始播放，允许稍后更新序列。
- en: 'Now we can play our `sequence`, but we need to adjust it first so that the
    player knows when it starts:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以播放我们的`sequence`，但首先需要调整它，以便播放器知道何时开始：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The MIDI player will play `sequence` according to wall time, but our sequence
    starts at `0` (the wall time is the time since epoch). For example, if the wall
    time (which is given by `time.time()`) is `1564950205`, then we need to update
    the start of the sequence forward by that amount. We do that by keeping our current
    sequence intact and making a copy that will be given to the player. We use the
    `adjust_sequence_times` function from Magenta to do that.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: MIDI 播放器将根据墙时（wall time）播放`sequence`，但我们的序列从`0`开始（墙时是从纪元开始的时间）。例如，如果墙时（由`time.time()`提供）为`1564950205`，那么我们需要将序列的起始时间向前调整这个数值。我们通过保持当前序列不变，并制作一个副本交给播放器来做到这一点。我们使用
    Magenta 中的`adjust_sequence_times`函数来完成这个操作。
- en: Notice here the usage of the `CopyFrom` method, which is present on Protobuf
    message objects. You can always go check the methods on the `google.protobuf.message.Message`
    class to find useful methods for `NoteSequence`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意这里使用了`CopyFrom`方法，该方法存在于 Protobuf 消息对象中。你可以随时检查`google.protobuf.message.Message`类中的方法，以便找到对`NoteSequence`有用的方法。
- en: 'Now that we adjusted our sequence to the proper time, let''s play it! We use
    the `update_sequence` method on the player to do this, which is the equivalent
    of `play`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将序列调整到正确的时间，让我们播放它吧！我们使用播放器上的`update_sequence`方法来实现这一点，它相当于`play`：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We also give the `start_time` argument to the player `instance`, which is equal
    to the start of our adjusted (shifted forward) sequence.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还向播放器的`instance`提供了`start_time`参数，这个参数等于我们调整后的（向前偏移的）序列的起始时间。
- en: Since `player` is a thread, we need to wait for it to finish before exiting
    or the program will exit before the sequence has played. We do that by using the
    `join` method on the player instance, which is present on any thread class. That
    method will block until the thread finishes, but because the player thread never
    stops, this call will block indefinitely. By adding a timeout of `generation_end_time`,
    which is the length of the generated sequence, the call will return after the
    end of the sequence being played. A blocked join call can always be interrupted
    by pressing *Ctrl *+ *C*, which can be caught using the `KeyboardInterrupt` exception
    class.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`player`是一个线程，我们需要等它完成后再退出，否则程序会在序列播放之前退出。我们通过在播放器实例上使用`join`方法来做到这一点，`join`方法存在于任何线程类中。这个方法会阻塞，直到线程完成，但因为播放器线程永远不会停止，这个调用将无限期阻塞。通过添加`generation_end_time`（即生成序列的长度）作为超时，这个调用将在序列播放结束后返回。被阻塞的`join`调用可以通过按*Ctrl
    + C*中断，此操作会被`KeyboardInterrupt`异常类捕获。
- en: 'We can now launch the program by using the following on Linux and macOS:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在 Linux 和 macOS 上使用以下命令启动程序：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By keeping the default `--midi_port` flag, it will use the port started by FluidSynth.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过保持默认的`--midi_port`标志，它将使用 FluidSynth 启动的端口。
- en: 'Or we can use the `magenta_out` MIDI port on Windows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以在 Windows 上使用`magenta_out` MIDI 端口：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You should now hear your music play from FluidSynth! When executing the code,
    you might see the following warning:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能听到你的音乐从 FluidSynth 播放！在执行代码时，你可能会看到以下警告：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is because the MIDI hub can also receive a MIDI message, but we haven't
    provided any MIDI port to do so. This is only a warning and shouldn't be an issue.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 MIDI 中心（MIDI hub）也可以接收 MIDI 消息，但我们尚未提供任何 MIDI 端口来接收。因此，这仅仅是一个警告，不应该成为问题。
- en: Sending generated MIDI to a DAW
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将生成的 MIDI 发送到 DAW
- en: Sending MIDI to FluidSynth is nice, but you probably want to use another software
    for producing music. We won't be looking at every DAW, but we'll show examples
    that can be applied for most music production software.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将 MIDI 发送到 FluidSynth 很不错，但你可能希望使用其他软件来制作音乐。我们不会讨论所有 DAW，但会展示一些适用于大多数音乐制作软件的示例。
- en: Now that we have Virtual MIDI ports opened for transferring MIDI from our Magenta
    application, let's try it out in Ableton Live. You can also try this in any other
    DAW that has MIDI functionalities.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为从 Magenta 应用程序传输 MIDI 打开了虚拟 MIDI 端口，接下来在 Ableton Live 中进行测试。你也可以在任何其他具备
    MIDI 功能的 DAW 中尝试此方法。
- en: You can find the Ableton Live set (with the `.als` file extension) in the `chapter_09_example_02.als` file
    in the source code of this chapter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本章的源代码中找到 Ableton Live 设置（扩展名为 `.als` 文件），路径为 `chapter_09_example_02.als`
    文件。
- en: You can use this Ableton set along with the Python code we've shown in the previous
    example, `chapter_09_example_02.py`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个 Ableton 设置与我们在前一个示例中展示的 Python 代码 `chapter_09_example_02.py` 一起使用。
- en: 'Let''s configure the `magenta_out` port in Ableton Live that will be also used
    by the Magenta app:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Ableton Live 中配置 `magenta_out` 端口，该端口也将被 Magenta 应用程序使用：
- en: 'First, in Ableton, go to **File** > **Options** > **Preferences...** > **Link**
    **MIDI** and find the `magenta_out` input:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 Ableton 中，进入 **文件** > **选项** > **首选项...** > **链接 MIDI**，然后找到 `magenta_out`
    输入：
- en: '![](img/9ae7cc95-2305-4537-b10f-8c7b4f93b034.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ae7cc95-2305-4537-b10f-8c7b4f93b034.png)'
- en: We need to activate both **Track** and **Remote** to **On** to receive the MIDI
    notes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将 **轨道** 和 **远程** 都设置为 **开启** 以接收 MIDI 音符。
- en: Now that the MIDI input is activated, we can create a new MIDI track by right-clicking
    in the **Drop Files and Devices Here** section and choosing **Insert MIDI track**.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在 MIDI 输入已被激活，我们可以通过右键点击 **在此处拖放文件和设备** 区域，选择 **插入 MIDI 轨道** 来创建一个新的 MIDI 轨道。
- en: 'In the new track, we see the following **MIDI from** section:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新轨道中，我们可以看到以下的 **MIDI From** 区域：
- en: '![](img/d15f36d7-c478-42ea-8091-00dc5864132e.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d15f36d7-c478-42ea-8091-00dc5864132e.png)'
- en: 'In the screenshot, we highlighted three parts:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在截图中，我们标出了三个部分：
- en: The **MIDI From** section, which is available for a MIDI track, where we can
    now select the `magenta_out` MIDI port. We also selected **Ch. 10** for the drum
    channel 10 and **Monitor** to **In**.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **MIDI From** 区域，这是一个 MIDI 轨道的设置，我们现在可以选择 `magenta_out` MIDI 端口。我们还选择了 **Ch.
    10** 作为鼓道 10 和 **监视器** 设置为 **输入**。
- en: The **third octave** on the 8-octave strip that represents all of the 127 possible
    MIDI values, where the **808 Core Kit** is defined. This corresponds to MIDI notes
    36 to 52 and you can see note 38 is currently playing.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三八度** 位于表示所有 127 种可能 MIDI 值的 8 个八度音阶条上，其中定义了 **808 核心套件**。这对应于 MIDI 音符 36
    到 52，你可以看到音符 38 当前正在播放。'
- en: The currently playing note, the **Snare 808**, in the **808 Core Kit** instrument.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前播放的音符，**808 小军鼓**，属于 **808 核心套件** 乐器。
- en: On the top-right corner, a yellow indicator shows whether there is incoming
    MIDI or not, which is useful for debugging.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在右上角，一个黄色指示灯显示是否有输入 MIDI，这对于调试非常有用。
- en: 'Now that we have our Ableton Live setup, we can launch our application by using
    this:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了 Ableton Live，可以通过以下方式启动我们的应用程序：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You should receive MIDI in Ableton Live and hear the **808 Core Kit** play the
    percussion.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在 Ableton Live 中接收到 MIDI 信号，并听到 **808 核心套件** 播放打击乐音效。
- en: Using NSynth generated samples as instruments
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 NSynth 生成的样本作为乐器
- en: In the previous [Chapter 5](feb070b7-92ac-4762-a4ac-7c1a797a47ef.xhtml), *Audio
    Generation with NSynth and GANSynth*, we talked about using our generated samples
    by sequencing them using the generated MIDI from Magenta. Since we can now dynamically
    send the generated MIDI to a DAW, now is a good time to test this out.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章节 [第 5 章](feb070b7-92ac-4762-a4ac-7c1a797a47ef.xhtml)，*使用 NSynth 和 GANSynth
    生成音频*，我们讨论了如何通过使用 Magenta 生成的 MIDI 来编排我们生成的样本。现在我们可以动态地将生成的 MIDI 发送到 DAW，这正是一个很好的测试时机。
- en: 'In Ableton Live, in the **808 Core Kit** section, we can drag and drop a generated
    sample to replace an existing drum kit sample. For example, we could change the
    **Cowbell 808** instrument with one of our samples, for example, `160045_412017`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ableton Live 中，在 **808 核心套件** 区域，我们可以拖放一个生成的样本来替换现有的鼓组样本。例如，我们可以将 **Cowbell
    808** 乐器替换为我们的一个样本，例如 `160045_412017`：
- en: '![](img/fffb1961-7ba1-4d2e-8d16-7cfb417bc7f0.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fffb1961-7ba1-4d2e-8d16-7cfb417bc7f0.png)'
- en: When double-clicking on the new sound, the sampler interface will open, which
    lets you modify the start and the end of the loop, as well as the volume. We choose
    that sample because it has a strong attack (the sound envelope goes up fast),
    which is perfect for a percussive sample. Go ahead and experiment with your own
    samples.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当双击新声音时，采样器界面将打开，你可以修改循环的开始和结束位置，以及音量。我们选择这个样本是因为它有很强的攻击性（声音包络上升得很快），非常适合做打击乐样本。你也可以尝试自己的样本。
- en: 'When mapping drum sounds on channel 10, remember the percussion instrument
    is chosen according to the MIDI pitch note. In the previous figure, the 16 instruments
    in the grid are mapped to the MIDI pitches as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在映射通道10上的鼓声时，请记住打击乐器是根据MIDI音高选择的。在之前的图中，网格中的16种乐器被映射到MIDI音高，如下所示：
- en: '| **48** | **49** | **50** | **51** |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **48** | **49** | **50** | **51** |'
- en: '| **44** | **45** | **46** | **47** |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **44** | **45** | **46** | **47** |'
- en: '| **40** | **41** | **42** | **43** |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| **40** | **41** | **42** | **43** |'
- en: '| **36** | **37** | **38** | **39** |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **36** | **37** | **38** | **39** |'
- en: Here, pitch 36 corresponds to **Kick 808**, pitch 37 to **Rim 808**, pitch 51
    to our `160045_412017` sample, and so on. You can compare that grid with the MIDI
    plot that is outputted by our program (in `output/out.html`).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，音高36对应于**Kick 808**，音高37对应于**Rim 808**，音高51对应于我们的`160045_412017`样本，依此类推。你可以将这个网格与我们的程序输出的MIDI图（在`output/out.html`中）进行对比。
- en: 'This works well for drum elements. But if you are sending a melody to your
    DAW, you will want to use a sampler, which will change the pitch of the sound,
    depending on the incoming note. To do that, in Ableton Live, follow these steps:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于鼓元素非常有效。但如果你将旋律发送到DAW，你可能会想使用采样器，它会根据输入音符改变声音的音高。为此，在Ableton Live中，按照以下步骤操作：
- en: Create a new MIDI track by right-clicking in the **Drop Files and Devices Here** section
    and choosing **Insert MIDI track**.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击**Drop Files and Devices Here**区域，选择**Insert MIDI track**来创建一个新的MIDI轨道。
- en: Find the **Sampler** instrument by choosing **Instruments** > **Sampler**.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**Instruments** > **Sampler**来找到**Sampler**乐器。
- en: Drag and drop the **Sampler** in the **Drop Audio Effects Here** at the bottom
    (in the new MIDI track).
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Sampler**拖放到底部的**Drop Audio Effects Here**区域（在新的MIDI轨道中）。
- en: Drag and drop the `412017_83249` generated sample (or another of your choice)
    in the **Drop Sample Here** at the bottom (in the **Sampler**).
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的`412017_83249`样本（或你选择的其他样本）拖放到底部的**Drop Sample Here**区域（在**Sampler**中）。
- en: 'We''ve chosen the `412017_83249` generated sample since the cat sound makes
    a good (and funny) note when played as a melody. You should have the following
    interface:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了`412017_83249`生成的样本，因为猫的声音在作为旋律播放时发出一个不错的（且有趣的）音符。你应该看到以下界面：
- en: '![](img/96079478-eace-493b-8250-ca73b5c224e6.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/96079478-eace-493b-8250-ca73b5c224e6.png)'
- en: Now when you send a melody from your Magenta program, you will hear the sample,
    `412017_83249`, getting played and pitched up and down, following the melody notes
    pitch.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你从Magenta程序发送旋律时，你会听到样本`412017_83249`被播放并根据旋律音符的音高进行升降调。
- en: Looping the generated MIDI
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环生成的MIDI
- en: Now that we can send generated MIDI to a DAW, let's have a look at how to loop
    the generated MIDI. This opens up many different use cases, such as building a
    system that **generates music continuously**. We'll first have a look at how to
    loop `NoteSequence`. We'll also cover how to synchronize Magenta with a DAW using
    a MIDI clock, which is important in long-running live music systems.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将生成的MIDI发送到DAW，让我们来看一下如何循环生成的MIDI。这开启了许多不同的用例，例如构建一个**持续生成音乐**的系统。我们将首先看看如何循环`NoteSequence`。我们还将讨论如何使用MIDI时钟将Magenta与DAW同步，这在长时间运行的现场音乐系统中非常重要。
- en: Using the MIDI player to loop a sequence
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MIDI播放器循环一个序列
- en: In this example, we'll be using the `player` instance from Magenta to loop a
    generated `NoteSequence`, by copying the sequence and playing it at a later time,
    before the player ends its playback.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用Magenta中的`player`实例来循环生成的`NoteSequence`，通过复制序列并在稍后的时间播放，直到播放器结束播放。
- en: You can follow this example in the `chapter_09_example_03.py` file in the source
    code of this chapter. There are more comments and content in the source code,
    so you should go check it out.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本章源代码中的`chapter_09_example_03.py`文件中跟随这个示例。源代码中有更多注释和内容，所以你应该去查看。
- en: 'Let''s take our previous example and make the sequence loop indefinitely:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用之前的例子并让序列无限循环：
- en: 'First, let''s find the period, which is equivalent to the loop time in seconds:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们来找出周期，这相当于循环时间（以秒为单位）：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we want a period (in seconds) of 4 bars, which is the loop length. Using
    240/QPM, we get the period for 1 bar (for example, 2 seconds at 120 QPM). We then
    multiply that by 4 bars (`num_bars + 1`), which is our loop length. Also, we are
    using the `Decimal` class, which doesn't have rounding errors like the built-in
    `float`, for increased accuracy for the timing.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要一个4小节的周期（以秒为单位），即循环长度。使用240/QPM，我们可以得到1小节的周期（例如，120 QPM下为2秒）。然后我们将其乘以4小节（`num_bars
    + 1`），这就是我们的循环长度。此外，我们使用`Decimal`类，它不像内置的`float`那样有舍入误差，以提高时间精度。
- en: We make use of the `Sleeper` class from Magenta, which implements a more precise
    version of `sleep` than the one present in the `time` module, so it should wake
    up more consistently with proper timing.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用Magenta的`Sleeper`类，它实现了比`time`模块中的`sleep`更精确的版本，因此它应该能以正确的时间更加一致地唤醒。
- en: 'Let''s now define the main loop, which will copy the current sequence, adjust
    it in time, and play it using the player:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们定义主循环，它将复制当前序列，调整时间并使用播放器播放：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s break the code down a bit:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微解析一下代码：
- en: On each loop start, we get the current time since epoch (in `now`).
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个循环开始时，我们获取当前的自纪元以来的时间（以`now`表示）。
- en: We get the current tick number, by dividing the current time by the period (in
    `tick_number`). The tick number corresponds to the current index in a separation
    of the time from epoch to now in intervals of `period`.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过将当前时间除以周期来获取当前的节拍数（以`tick_number`表示）。节拍数对应于从纪元到现在的时间区间按`period`分割后的当前索引。
- en: We get the current tick time by multiplying the period with the tick number
    (in `tick_time`).
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过将周期与节拍数相乘来获取当前的节拍时间（以`tick_time`表示）。
- en: For example, if the start time is `1577021349`, we have a ticking time of `1577021344`
    and a next tick time of `1577021352` (for a period of 8 seconds). In this case,
    we are on the first iteration of the loop, which is why there is such a big difference
    between the start time and the ticking time. On the second loop, the start time
    will be `1577021352` (approximately) because the thread will wake up with proper
    timing.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果起始时间是`1577021349`，我们有一个滴答时间`1577021344`和下一个滴答时间`1577021352`（周期为8秒）。在这种情况下，我们处于循环的第一次迭代，这就是为什么起始时间和滴答时间之间有如此大的差异。第二次循环时，起始时间将是`1577021352`（大约），因为线程将在正确的时间唤醒。
- en: Because of the start time difference on the first loop, this means that when
    the player starts, it might start in the middle of the generated sequence. If
    we want to make it start at the beginning of the sequence, we need to subtract
    the start time when calculating the tick number. See the `Metronome` class in
    the `magenta.interfaces.midi.midi_hub` module for a more complete implementation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第一次循环的起始时间差异，这意味着当播放器启动时，它可能会从生成的序列的中间开始。如果我们希望它从序列的开头开始，我们需要在计算节拍数时减去起始时间。请查看`magenta.interfaces.midi.midi_hub`模块中的`Metronome`类，了解更完整的实现。
- en: Finally, we update the sequence and the player using `tick_time` and we sleep
    until `tick_time_next`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`tick_time`更新序列和播放器，并在`tick_time_next`之前休眠。
- en: 'We can now launch the program by using this:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以通过以下方式启动程序：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You should now hear a 4-bar loop of 8 seconds at 120 QPM playing in the DAW
    you are using.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能在你使用的DAW中听到一个120 QPM、持续8秒的4小节循环。
- en: Synchronizing Magenta with a DAW
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Magenta与DAW同步
- en: Synchronizing devices when playing instruments is important. Two instruments
    that are in sync will have the **same QPM** (**tempo**) and start on the **same
    beat** (**phase**). Addressing those problems is simple on the surface, but good
    sync is hard to achieve because precise timing is difficult.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在演奏乐器时，同步设备非常重要。两个同步的乐器会有**相同的QPM**（**节奏**）并且在**相同的拍子**（**相位**）上开始。解决这些问题表面看起来很简单，但良好的同步非常难以实现，因为精确的时间控制很困难。
- en: Syncing our Magenta application with a DAW has many usages, such as recording
    the MIDI sequences in a DAW with proper timing (tempo and phase), or playing multiple
    sequences at the same time, some coming from Magenta and the others coming from
    the DAW.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的Magenta应用与DAW同步有很多用途，例如，在DAW中以正确的时间（节奏和相位）录制MIDI序列，或者同时播放多个序列，其中一些来自Magenta，另一些来自DAW。
- en: Sending MIDI clock and transport
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送MIDI时钟和传输
- en: In this example, we'll synchronize Magenta with a DAW using a MIDI clock and
    transport (start, stop, and reset) information. The MIDI clock is one of the oldest
    and more popular ways of synchronizing devices, which is available for pretty
    much every instrument and music software.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将使用MIDI时钟和传输（启动、停止和重置）信息将Magenta与数字音频工作站（DAW）同步。MIDI时钟是最古老且最流行的设备同步方式之一，几乎所有的乐器和音乐软件都支持它。
- en: We'll be giving the example in Ableton Live, but you can also try this in any
    DAW that has MIDI clock functionality.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将给出在Ableton Live中的示例，但你也可以在任何具有MIDI时钟功能的DAW中尝试此操作。
- en: You can follow this example in the `chapter_09_example_04.py` file in the source
    code of this chapter. There are more comments and content in the source code,
    so you should go check it out.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本章的源代码中的`chapter_09_example_04.py`文件中查看此示例。源代码中有更多的注释和内容，你应该去查看一下。
- en: 'To sync our Magenta program to Ableton Live, we''ll launch a metronome thread
    that wakes up on every beat and sends a clock message:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的Magenta程序与Ableton Live同步，我们将启动一个节拍器线程，该线程将在每个节拍上唤醒并发送一个时钟消息：
- en: 'First, let''s declare the `Metronome` class that extends the `Thread` class:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们声明`Metronome`类，它继承自`Thread`类：
- en: '[PRE20]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'At instantiation, we use Mido to define the following messages (see the last
    section, *Further reading*, for more documentation on the messages supported by
    Mido and to what they correspond in the MIDI specification):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化时，我们使用Mido定义以下消息（有关Mido支持的消息及其在MIDI规范中的对应项，请参阅最后一节，*进一步阅读*）：
- en: The `clock` message, which is sent every beat
  id: totrans-192
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clock`消息，每个节拍发送一次'
- en: The `start` message, which is sent when the sequence starts
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`消息，在序列开始时发送'
- en: The `stop` message, which is sent when the sequence ends, or when the program
    exits
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop`消息，在序列结束时或程序退出时发送'
- en: The `reset` message, which is sent before the start message, making sure that
    the synced device restarts from the beginning in terms of beat count
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset`消息，在`start`消息之前发送，确保同步的设备从节拍计数的开始重新启动'
- en: The `continue` message, which we won't use, but can be used to restart the playback
    without resetting the beat count
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`continue`消息，我们不会使用它，但它可以用来在不重置节拍计数的情况下重新启动播放'
- en: We also define the period, which is the exact time between each thread wake
    up. The thread needs to wake up at each beat, so in 4/4 time at 120 QPM, it needs
    to wake up every 0.5 seconds, which is the period.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了周期，即每次线程唤醒之间的确切时间。线程需要在每个节拍时唤醒，因此在120 QPM的4/4拍中，它需要每0.5秒唤醒一次，这就是周期。
- en: Here, we choose to synchronize both applications using one message (or pulse)
    per beat, which is our period, since it is easy to do. In the MIDI specification
    ([www.midi.org/specifications/item/table-1-summary-of-midi-message](https://www.midi.org/specifications/item/table-1-summary-of-midi-message)),
    another synchronization period is described, which is called **24** **Pulses Per
    Quarter Note** (**24** **PPQN**), which is more precise than what we are implementing
    here.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们选择使用每个节拍一个消息（或脉冲）来同步两个应用程序，这是我们的周期，因为这样做很简单。在MIDI规范中（[www.midi.org/specifications/item/table-1-summary-of-midi-message](https://www.midi.org/specifications/item/table-1-summary-of-midi-message)），还描述了另一种同步周期，称为**24**
    **每四分之一音符脉冲**（**24** **PPQN**），它比我们这里实现的更精确。
- en: One pulse per beat and 24 PPQN are both used in many DAWs and instruments. There
    are other synchronization pulses, however, such as 48 PPQN for Korg instruments.
    There are also other ways of synchronizing instruments, such as the **MIDI Time
    Code** (**MTC**), which we won't see here.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节拍一个脉冲和24 PPQN都在许多DAW和乐器中使用。然而，还有其他的同步脉冲，例如Korg乐器使用的48 PPQN。还有其他同步乐器的方式，例如**MIDI时间码**（**MTC**），我们在这里不讨论。
- en: Depending on the software or hardware you are trying to sync, make sure to check
    what type of synchronization pulse they are configured to handle. If this doesn't
    work, it is probably because you are sending an unexpected pulse rate.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你尝试同步的软件或硬件，确保检查它们配置处理的同步脉冲类型。如果这个方法不起作用，可能是因为你发送了一个意外的脉冲率。
- en: 'Let''s now implement the `run` method in the `# Run code` comment:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现`# Run code`注释中的`run`方法：
- en: '[PRE21]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following list further explains the code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表进一步解释了代码：
- en: When the thread first starts, it sends a `reset` message followed by a `start` message,
    meaning Ableton Live will reset its beat count to 0, and then start the playback.
  id: totrans-204
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当线程首次启动时，它发送一个`reset`消息，紧接着发送一个`start`消息，意味着Ableton Live将其节拍计数重置为0，然后开始播放。
- en: Then, we calculate the next tick time and make the thread sleep to that time
    (see the previous section explanation on the ticking time). At wake up, we send
    the `clock` message, which will happen at every beat.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们计算下一个时钟滴答的时间，并让线程休眠至该时间（请参见前面关于滴答时间的解释）。醒来后，我们发送 `clock` 消息，这将在每个节拍时发生。
- en: Finally, if the `stop` method is called, `self._stop_signal` is set to `True`,
    which will exit the loop, sending the `stop` message.
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果调用 `stop` 方法，`self._stop_signal` 将被设置为 `True`，这将退出循环，并发送 `stop` 消息。
- en: 'Let''s initialize the thread and launch it:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们初始化线程并启动它：
- en: '[PRE22]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following list explains it further:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表将进一步解释：
- en: The code is similar to our previous example. The first thing we change is that
    we keep a reference to the `midi_hub._outport` port so that we can send the MIDI
    clock to it.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码与我们之前的示例类似。我们首先改变的内容是，我们保留对 `midi_hub._outport` 端口的引用，以便将 MIDI 时钟发送到该端口。
- en: Then, we initialize the `Metronome` class using `outport` and start it using
    `start`. This will execute the `run` method in the thread.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们使用 `outport` 初始化 `Metronome` 类，并通过 `start` 启动它。这将执行线程中的 `run` 方法。
- en: We then `join` on the thread with a timeout of 16 (seconds), meaning we'll play
    8 bars before exiting and calling the `stop` method. We do this solely to show
    the stop usage and its impact on Ableton Live.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们通过 16 秒的超时调用 `join` 方法，意味着我们将在退出并调用 `stop` 方法之前播放 8 小节。我们这样做只是为了展示 `stop`
    方法的使用及其对 Ableton Live 的影响。
- en: 'In Ableton Live, we need to make sure that the **Sync** button is **On** for
    the `magenta_out` port:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Ableton Live 中，我们需要确保 **Sync** 按钮已为 `magenta_out` 端口 **开启**：
- en: '![](img/5d0955ca-b0c0-416c-9548-9204dc051d27.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d0955ca-b0c0-416c-9548-9204dc051d27.png)'
- en: 'Once we''ve done that, we need to make sure that the **Ext** button on the
    top-left of the screen is activated:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成这一步，我们需要确保屏幕左上角的 **Ext** 按钮已激活：
- en: '![](img/8de26762-ee96-4ef3-b1d7-f2c8aaf269ae.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8de26762-ee96-4ef3-b1d7-f2c8aaf269ae.png)'
- en: The **Ext** button, short for **External**, means that Ableton won't use its
    internal clock, but rather rely on an external source for the clock.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ext** 按钮，代表 **External**，意味着 Ableton 不会使用其内部时钟，而是依赖外部时钟源。'
- en: Most DAWs and hardware synths have a similar **External** option but this is
    often deactivated by default. Make sure to check how to activate that for the
    software or hardware you are trying to sync.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 DAW 和硬件合成器都有类似的 **External** 选项，但默认情况下通常是禁用的。确保查看如何为你正在同步的软件或硬件激活该选项。
- en: 'On the right of the **Ext** button, two indicators show incoming and outgoing
    MIDI clock messages, which is useful for debugging. We''ve also highlighted the
    following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Ext** 按钮右侧，两个指示器显示进出 MIDI 时钟消息，这对于调试非常有用。我们还突出显示了以下内容：
- en: The **QPM indicator**, which will get updated to 120 during playback (currently
    at 110 QPM for testing purpose)
  id: totrans-220
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QPM 指标**将在播放过程中更新为 120（目前为了测试目的，设置为 110 QPM）'
- en: The **Arrangement position** section, that shows **9.1.1**, which is the value
    the beat count will be at when our Python program exists and sends the `stop` message
    (because we stop after 8 bars)
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Arrangement position** 部分，显示 **9.1.1**，这是当我们的 Python 程序退出并发送 `stop` 消息时节拍计数的值（因为我们在
    8 小节后停止）'
- en: The **Transport section** with the start, stop and record buttons, which will
    update when we start and stop the program
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Transport section** 部分，其中包含开始、停止和录音按钮，当我们启动和停止程序时，按钮会更新'
- en: We can now send the MIDI clock to Ableton Live.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以向 Ableton Live 发送 MIDI 时钟。
- en: 'Finally, let''s launch our Magenta application:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，启动我们的 Magenta 应用程序：
- en: '[PRE23]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In Ableton Live, you should see the BPM change to 120 QPM. It might take time
    to get there, and it might oscillate up and down while it stabilizes, but it should
    converge to 120 QPM. After 16 seconds, Ableton Live should stop, with a final
    beat count of 8 full beats (shown as **9.1.1**).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ableton Live 中，你应该看到 BPM 改为 120 QPM。虽然可能需要一些时间才能达到这个值，并且可能会在稳定过程中上下波动，但最终应该稳定在
    120 QPM。16 秒后，Ableton Live 应该停止，最终的节拍计数为 8 个完整的节拍（显示为 **9.1.1**）。
- en: Using MIDI control message
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MIDI 控制消息
- en: Sending the MIDI clock is the most common way of synchronizing devices because
    all devices support the MIDI clock. Another way of synchronizing Magenta with
    a DAW would be to use **MIDI control messages**.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 发送 MIDI 时钟是最常见的设备同步方式，因为所有设备都支持 MIDI 时钟。另一种将 Magenta 与 DAW 同步的方法是使用 **MIDI 控制消息**。
- en: 'A MIDI control message is a message that sends `control` and `value`. For example,
    we could be using the following Mido message to send MIDI control: `mido.Message(type="control_change",
    control="...", value"...")`. Let''s define some control message for the actions
    we want to make:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: MIDI控制消息是一个发送`control`和`value`的消息。例如，我们可以使用以下Mido消息来发送MIDI控制：`mido.Message(type="control_change",
    control="...", value"...")`。让我们定义一些控制消息来执行我们想要的操作：
- en: '**Start/stop**: This is to start and stop the transport, which will be used
    to synchronize the phase (using `control="1"` and `control="2"`, respectively).'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始/停止**：用于启动和停止传输，用于同步相位（分别使用`control="1"`和`control="2"`）。'
- en: '**QPM**: This is to set the tempo before the transport starts (using `control="3"`).'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QPM**：这是在传输开始前设置节奏的方式（使用`control="3"`）。'
- en: This is just an example of control values; you can use whatever value you want,
    as long as it is properly mapped on the DAW side. In most DAWs, mapping a control
    message to input is easy. Often, a `learn` function is provided, which, once activated,
    will map the selected input in the DAW to whatever MIDI message comes next.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个控制值的示例；你可以使用任何你想要的值，只要它在DAW端正确映射即可。在大多数DAW中，将控制消息映射到输入是很容易的。通常，DAW会提供一个`learn`功能，激活后，它会将选定的输入映射到接下来到来的任何MIDI消息。
- en: 'Let''s try this in Ableton Live:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Ableton Live中尝试一下：
- en: Activate the MIDI mapping mode using the **MIDI** button in the upper-right
    corner (all of the mappable inputs in Ableton will turn to purple).
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用右上角的**MIDI**按钮激活MIDI映射模式（Ableton中的所有可映射输入会变成紫色）。
- en: Select the input you want to map (**QPM**, for example) and then send the corresponding
    MIDI control message (see the previous code snippet), which will map the input
    to the control message.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你想映射的输入（例如**QPM**），然后发送相应的MIDI控制消息（参见前面的代码片段），它将把输入映射到控制消息。
- en: After the MIDI control message is received, the input in Ableton will be mapped
    to it.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接收到MIDI控制消息后，Ableton中的输入将会与之映射。
- en: Exit the MIDI mapping mode, then send the same MIDI control message. The mapped
    input should activate.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出MIDI映射模式，然后发送相同的MIDI控制消息。映射的输入应该会被激活。
- en: Once all of our inputs are mapped, we can send the corresponding messages from
    our Magenta application, to start, stop, and change the QPM when needed. For example,
    the Magenta application can send the QPM before starting, and then when sending
    the first MIDI note, send the MIDI control message **start** at the same time.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们所有的输入都被映射，我们就可以从Magenta应用程序发送相应的消息，按需开始、停止或更改QPM。例如，Magenta应用程序可以在开始之前发送QPM，然后在发送第一个MIDI音符时，同时发送MIDI控制消息**开始**。
- en: The downside of this approach is that if any of the two applications become
    desynced, there isn't any way of syncing the applications back together without
    stopping and restarting the playback. MIDI clock, on the other hand, is constantly
    syncing the devices together.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，如果两个应用程序中的任何一个出现不同步的情况，就无法在不停止并重新启动播放的情况下将它们重新同步。另一方面，MIDI时钟则会持续地同步设备。
- en: Using Ableton Link to sync devices
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ableton Link同步设备
- en: Ableton Link ([github.com/Ableton/link](https://github.com/Ableton/link)) is
    an open source standard aimed at synchronizing software devices. It enables auto-discovery
    across a local network and is easy to use. A lot of DAWs now support Ableton Link,
    which is yet another way of syncing our Magenta application to a DAW but necessitates
    implementing the specification.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Ableton Link ([github.com/Ableton/link](https://github.com/Ableton/link))是一个旨在同步软件设备的开源标准。它支持在本地网络上的自动发现，并且易于使用。现在许多DAW都支持Ableton
    Link，这又是另一种将Magenta应用程序与DAW同步的方式，但需要实现该规范。
- en: Sending MIDI to a hardware synthesizer
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向硬件合成器发送MIDI
- en: Sending MIDI to a hardware synthesizer is very similar to what we've been doing
    in the previous sections, with the exception that the hardware synthesizer should
    open a new MIDI port by itself (just like FluidSynth) so we don't need to create
    a virtual port for it.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 向硬件合成器发送MIDI与我们在前面章节中的操作非常相似，唯一不同的是硬件合成器需要自己打开一个新的MIDI端口（就像FluidSynth一样），所以我们不需要为它创建虚拟端口。
- en: 'We''ll be using an Arturia BeatStep Pro for our example, but this should work
    with any MIDI-enabled device:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Arturia BeatStep Pro作为示例，但这应该适用于任何支持MIDI的设备：
- en: First, we need to install the drivers for the synthesizer, which might or might
    not be necessary, depending on the synth and the platform.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要为合成器安装驱动程序，是否需要安装取决于合成器和平台。
- en: Then, we connect the synthesizer using USB to the computer and run the first
    example to find what are the declared MIDI ports. For the Arturia BeatStep Pro
    on Windows, we have the output port, `MIDIIN2 (Arturia BeatStep Pro) 1`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过 USB 将合成器连接到计算机，并运行第一个示例，以找出已声明的 MIDI 端口。对于 Windows 上的 Arturia BeatStep
    Pro，我们有输出端口 `MIDIIN2 (Arturia BeatStep Pro) 1`。
- en: 'Now, we can run our previous example, by changing the Magenta output port with
    the synthesizer input port:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过将 Magenta 输出端口更改为合成器输入端口来运行之前的示例：
- en: '[PRE24]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This should send the MIDI directly to the hardware synthesizer.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该直接将 MIDI 发送到硬件合成器。
- en: This example sends MIDI using USB MIDI, which is not available on all synthesizers.
    Some synthesizers only support MIDI using a MIDI cable, not a USB cable, which
    means you'll need a sound card or a USB to MIDI converter. The procedure is still
    the same, but you'll have to go through the sound card or the converter.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用 USB MIDI 发送 MIDI，然而并不是所有合成器都支持这种方式。有些合成器仅支持通过 MIDI 电缆连接，而非 USB 电缆，这意味着你需要一个声卡或
    USB 转 MIDI 转换器。过程依然相同，但你必须通过声卡或转换器。
- en: Using Magenta as a standalone application with Magenta Studio
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Magenta 作为独立应用程序与 Magenta Studio 一起使用
- en: Magenta Studio is the closest you can get to a Magenta standalone application,
    in the sense that it doesn't require any installation and any knowledge of technologies
    to make it work. This is especially important, because Magenta and the technology
    that powers it is complex, but in the end, it is **important that everybody can
    use it**.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Magenta Studio 是最接近 Magenta 独立应用程序的工具，因为它不需要任何安装，也不需要了解任何技术来使其工作。这一点尤为重要，因为
    Magenta 及其技术是复杂的，但最终，**每个人都能使用它** 这一点是非常重要的。
- en: 'We''ll be looking at how Magenta Studio works and find many elements we''ve
    already covered in the previous chapters. Magenta Studio comes in two packagings:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将了解 Magenta Studio 的工作原理，并找到我们在前几章中已经覆盖过的许多元素。Magenta Studio 有两种打包方式：
- en: As **Ableton Live Plugins** ([magenta.tensorflow.org/studio/ableton-live](https://magenta.tensorflow.org/studio/ableton-live)),
    which integrates Magenta into Ableton Live using the Max for Live integration
    and Magenta.js applications (supported on Windows and macOS)
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如 **Ableton Live 插件** ([magenta.tensorflow.org/studio/ableton-live](https://magenta.tensorflow.org/studio/ableton-live))，它通过
    Max for Live 集成和 Magenta.js 应用程序将 Magenta 集成到 Ableton Live 中（支持 Windows 和 macOS）
- en: As **Standalone Applications** ([magenta.tensorflow.org/studio/standalone](https://magenta.tensorflow.org/studio/standalone)),
    which are Electron applications (supported on all platforms)
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如 **独立应用程序** ([magenta.tensorflow.org/studio/standalone](https://magenta.tensorflow.org/studio/standalone))，它们是
    Electron 应用程序（支持所有平台）
- en: We won't be talking about the standalone applications too much because we've
    already covered everything we need to know about them. Indeed, an Electron application
    is a Node.js application packaged with its runtime and a Chromium browser, so
    we've already covered that content in the previous [Chapter 8](cafc52b5-bd8c-41ba-a6f0-eb002405ffca.xhtml),
    *Magenta in the Browser with Magenta.js*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会过多讨论独立应用程序，因为我们已经涵盖了关于它们的所有必要知识。实际上，Electron 应用程序是一个带有其运行时和 Chromium 浏览器的
    Node.js 应用程序，因此我们已经在前一章 [第 8 章](cafc52b5-bd8c-41ba-a6f0-eb002405ffca.xhtml) 中讲解了这些内容，*Magenta.js
    中的 Magenta 浏览器*。
- en: Looking at Magenta Studio's content
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看 Magenta Studio 的内容
- en: 'Since both packagings are based on Magenta.js, they both contain the same features:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两种打包方式都基于 Magenta.js，它们包含相同的功能：
- en: '**CONTINUE** makes use of MusicRNN (LSTM based), either the DrumsRNN model
    or the MelodyRNN model depending on the usage, to continue a sequence from a primer.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CONTINUE** 使用 MusicRNN（基于 LSTM），根据使用情况选择 DrumsRNN 模型或 MelodyRNN 模型，从一个引导器开始继续一个序列。'
- en: '**GENERATE** makes use of the MusicVAE model, using a 4 bar model for the drums
    or the melody generation.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GENERATE** 使用 MusicVAE 模型，使用一个 4 小节的模型来生成鼓点或旋律。'
- en: '**INTERPOLATE** also makes use of the MusicVAE model.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**INTERPOLATE** 也使用 MusicVAE 模型。'
- en: '**GROOVE** makes the use of the GrooVAE model to add groove to a quantized
    sequence.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GROOVE** 使用 GrooVAE 模型为量化序列添加 groove。'
- en: '**DRUMIFY** uses the GrooVAE tap model to convert a **tap sequence** into a
    **drum sequence**.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DRUMIFY** 使用 GrooVAE tap 模型将 **tap 序列** 转换为 **鼓点序列**。'
- en: 'When downloading the standalone version, you''ll be able to install (using
    `.exe` or `.dmg` depending on the platform) any of the five applications. When
    installed and launched, the applications are shown as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 下载独立版本时，你将能够安装任何五个应用程序（取决于平台使用 `.exe` 或 `.dmg`）。安装并启动后，应用程序将如下所示：
- en: '![](img/bf8f39f5-7eb5-489b-9845-343216c956b9.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf8f39f5-7eb5-489b-9845-343216c956b9.png)'
- en: 'You can find many parameters we already talked about: temperature, length,
    variations (number of generated sequences), steps (number of interpolations),
    and so on. The difference between the standalone and the Ableton packaging is
    how they integrate with our music tool: the standalone application can work with
    files on disk (as shown in the previous screenshot, with the **Choose file...** button)
    and the Ableton Live plugin can directly read and write clips in the **Session
    View**.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以找到我们之前讨论过的许多参数：温度、长度、变化（生成序列的数量）、步数（插值的数量）等。独立应用程序和Ableton包装版本的区别在于它们如何与我们的音乐工具集成：独立应用程序可以处理磁盘上的文件（如前述截图所示，使用**选择文件...**按钮），而Ableton
    Live插件则可以直接读取和写入**Session View**中的剪辑。
- en: Let's have a look at the Ableton Live Plugins integration.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Ableton Live插件的集成。
- en: Integrating Magenta Studio in Ableton Live
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Ableton Live中集成Magenta Studio
- en: The Magenta Studio plugin integration in Ableton Live is nice because it corresponds
    to the idea of a **machine learning augmented** music production environment.
    In general, the integration of Magenta in existing tools is important, and Magenta
    Studio is a good example of that.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Magenta Studio在Ableton Live中的插件集成非常棒，因为它符合**机器学习增强**音乐制作环境的理念。一般来说，Magenta在现有工具中的集成非常重要，Magenta
    Studio就是一个很好的例子。
- en: 'It is interesting to understand how the Ableton Live plugins are designed since
    it is quite clever. In Ableton Live, you can integrate a Max MSP application as
    a plugin or device. Max MSP ([cycling74.com/products/max-features/](https://cycling74.com/products/max-features/))
    is a powerful visual programming language for music. The Ableton Live Plugins
    works as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Ableton Live插件的设计很有趣，因为它非常巧妙。在Ableton Live中，你可以将Max MSP应用程序作为插件或设备集成。Max MSP（[cycling74.com/products/max-features/](https://cycling74.com/products/max-features/)）是一个强大的音乐视觉编程语言。Ableton
    Live插件的工作方式如下：
- en: Ableton Live launches the `magenta.amxd` patch, which is a Max MSP program.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ableton Live启动了`magenta.amxd`补丁，这是一个Max MSP程序。
- en: The Max MSP program shows a UI in Ableton Live, in which we can choose any of
    the **Continue**, **Generate**, and other programs.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Max MSP程序会在Ableton Live中显示一个UI界面，我们可以选择**Continue**、**Generate**等程序。
- en: When chosen, the Max MSP program will launch a Node.js process, containing the
    Magenta.js application (which is the same as the standalone application).
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择后，Max MSP程序将启动一个Node.js进程，包含Magenta.js应用程序（与独立应用程序相同）。
- en: Using the Max MSP API, the Magenta.js application can see the Ableton Live **Session
    View** content, including clips and tracks, and write content.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Max MSP API，Magenta.js应用程序可以查看Ableton Live的**Session View**内容，包括剪辑和轨道，并进行内容写入。
- en: For now, Magenta Studio integrates only in Ableton Live. Other DAWs might be
    integrated in the future, as Magenta Studio's implementation has nothing specific
    to Ableton Live.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Magenta Studio仅在Ableton Live中集成。未来可能会集成其他DAW，因为Magenta Studio的实现并没有什么特定于Ableton
    Live的内容。
- en: For this example to work, we need Ableton Live 10.1 Suite since the integration
    of Max For Live (only in the **Suite** version) is necessary for Magenta Studio
    to work. You can try the demo at [www.ableton.com/en/trial/](https://www.ableton.com/en/trial/)
    if you don't have the program handy.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个示例生效，我们需要Ableton Live 10.1 Suite版，因为Magenta Studio的运行需要集成Max For Live（仅在**Suite**版中可用）。如果你没有该程序，可以在[www.ableton.com/en/trial/](https://www.ableton.com/en/trial/)尝试演示版。
- en: 'Let''s go through a complete example using the **Continue** application:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个完整的示例来演示**Continue**应用程序：
- en: From [magenta.tensorflow.org/studio/ableton-live](https://magenta.tensorflow.org/studio/ableton-live),
    download the Max MSP patch using the **Download** button for your platform, which
    should download the `magenta_studio-VERSION-windows.amxd` file.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[magenta.tensorflow.org/studio/ableton-live](https://magenta.tensorflow.org/studio/ableton-live)下载适用于你平台的Max
    MSP补丁，点击**下载**按钮，这将下载`magenta_studio-VERSION-windows.amxd`文件。
- en: 'Open Ableton Live, create a new MIDI track, and drag and drop the file in the
    MIDI track devices (it might take a while to load):'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Ableton Live，创建一个新的MIDI轨道，将文件拖放到MIDI轨道设备中（加载可能需要一些时间）：
- en: '![](img/ee302ade-3546-490e-a3c2-65c6c8223659.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee302ade-3546-490e-a3c2-65c6c8223659.png)'
- en: In the previous screenshot, we see that we recorded two MIDI clips from our
    previous example, **MIDI from Magenta 1** and **MIDI from Magenta 2**, which we'll
    use to generate new content using the **Continue** plugin. We can see the Magenta
    Studio patch in the **Magenta Studio Plugin** track, which shows at the bottom.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们看到我们从之前的示例中录制了两个 MIDI 片段，**MIDI from Magenta 1** 和 **MIDI from Magenta
    2**，我们将使用这些片段通过 **Continue** 插件生成新内容。我们可以在 **Magenta Studio Plugin** 轨道的底部看到 Magenta
    Studio 补丁。
- en: 'Now, let''s click on **CONTINUE** in the Magenta Studio Plugin. You should
    see the **Continue** Node.js application start:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们点击 Magenta Studio 插件中的 **CONTINUE**。你应该看到 **Continue** Node.js 应用程序启动：
- en: '![](img/dbd326a8-92fc-48b8-a9eb-bdb0f6310ccd.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dbd326a8-92fc-48b8-a9eb-bdb0f6310ccd.png)'
- en: In the **Input Clip** section, we've added from the **MIDI from Magenta** track
    the **MIDI from Magenta 2** MIDI clip, which will be used by the DrumsRNN model
    for its primer. The four variations will be added automatically to Ableton Live
    after the primer clip, with the name `x/4 [MIDI from Magenta 2]`, with *x* being
    the index of the generated clip.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Input Clip** 部分，我们从 **MIDI from Magenta** 轨道中添加了 **MIDI from Magenta 2**
    的 MIDI 片段，这将由 DrumsRNN 模型作为启动器使用。四种变化将在启动器片段后自动添加到 Ableton Live 中，名称为 `x/4 [MIDI
    from Magenta 2]`，其中 *x* 是生成的片段的索引。
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've covered the interaction of Magenta with established music
    production software.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 Magenta 与已建立的音乐制作软件的互动。
- en: First, we have shown how to send MIDI from Magenta to DAWs or synthesizers.
    We started by looking at MIDI ports using Mido, a powerful Python library to handle
    MIDI operations. We've shown examples of how to loop MIDI in Magenta, which requires
    proper timing and threading tools. We also looked at synchronization between Magenta
    and a DAW using various methods, most notably using the MIDI clock messages and
    transport messages. We finished the MIDI section by showing how Magenta could
    send MIDI directly to hardware synthesizers, such as keyboards.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们展示了如何将 MIDI 从 Magenta 发送到 DAW 或合成器。我们首先使用 Mido，这是一个强大的 Python 库，用于处理 MIDI
    操作，查看了 MIDI 端口。我们展示了如何在 Magenta 中循环 MIDI 的示例，这需要正确的时序和线程工具。我们还讨论了 Magenta 和 DAW
    之间的同步，使用了各种方法，最著名的是使用 MIDI 时钟消息和传输消息。我们通过展示 Magenta 如何直接将 MIDI 发送到硬件合成器（如键盘）来结束
    MIDI 部分。
- en: Finally, we introduced Magenta Studio, both as a standalone application and
    as an Ableton Live plugin. We looked at its integration in Ableton Live and the
    importance of integrating Magenta in existing music tools.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了 Magenta Studio，既作为独立应用程序，又作为 Ableton Live 插件。我们查看了它在 Ableton Live 中的整合，以及将
    Magenta 集成到现有音乐工具中的重要性。
- en: Looking at Magenta's integration in a music production ecosystem is the perfect
    closing chapter. It reminds us that Magenta is not an end by itself, but rather
    a tool that needs to be used in conjunction with other music production tools
    to be truly useful. Magenta is becoming more usable by a broader, non-technical
    audience, by developing projects such as Magenta.js and Magenta Studio.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 观察 Magenta 在音乐制作生态系统中的整合是完美的结尾。它提醒我们，Magenta 不是一个独立的终点，而是一个需要与其他音乐制作工具结合使用才能真正有用的工具。通过开发像
    Magenta.js 和 Magenta Studio 这样的项目，Magenta 正在变得更加易于更广泛的非技术用户使用。
- en: There is still a lot that can be done for Magenta to grow in terms of usability
    for everybody. This is, however, the start of a great music production tool.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在提高 Magenta 对所有人可用性方面，仍然有很多工作要做。然而，这是一个伟大音乐制作工具的开始。
- en: Questions
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between a software synthesizer, such as FluidSynth, and
    a DAW, such as Ableton Live?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 软件合成器（如 FluidSynth）和数字音频工作站（DAW）（如 Ableton Live）之间有什么区别？
- en: Why is opening MIDI virtual ports required to make music software interact with
    each other?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么打开 MIDI 虚拟端口是使音乐软件相互互动所必需的？
- en: Write the code based on `chapter_09_example_03.py` that, instead of looping
    the four bars sequence, generates a new sequence every four bars.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于 `chapter_09_example_03.py` 编写代码，而不是循环四小节的序列，每四小节生成一个新序列。
- en: Why is syncing based on the MIDI control message not robust?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么基于 MIDI 控制消息的同步不够稳定？
- en: Why is Magenta Studio such an important project in the music composition ecosystem?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么 Magenta Studio 在音乐创作生态系统中如此重要？
- en: What are the technologies behind Magenta Studio Plugins and Magenta Studio Standalone?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Magenta Studio 插件和 Magenta Studio 独立版背后的技术是什么？
- en: Further Reading
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**Learn Live** (**Ableton Live**): Amazing tutorials on Ableton Live, which
    are far the best tutorials available on music production in general, with advanced
    content on many topics that can be used in many DAWs ([www.ableton.com/en/live/learn-live/](https://www.ableton.com/en/live/learn-live/))'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Learn Live** (**Ableton Live**)：关于Ableton Live的精彩教程，是目前关于音乐制作的最佳教程，涵盖了多个高级内容，适用于许多DAW（[www.ableton.com/en/live/learn-live/](https://www.ableton.com/en/live/learn-live/)）'
- en: '**Session View** (**Ableton Live**): More information on Ableton Live''s **Session
    View** which is a useful view for using Magenta Studio ([www.ableton.com/en/manual/session-view/](https://www.ableton.com/en/manual/session-view/))'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话视图** (**Ableton Live**)：关于Ableton Live **会话视图**的更多信息，适用于使用Magenta Studio（[www.ableton.com/en/manual/session-view/](https://www.ableton.com/en/manual/session-view/)）'
- en: '**Community Learning** (**Bitwig**): Good tutorials for Bitwig ([www.bitwig.com/en/community/learning.html](https://www.bitwig.com/en/community/learning.html))'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社区学习** (**Bitwig**)：Bitwig的优秀教程（[www.bitwig.com/en/community/learning.html](https://www.bitwig.com/en/community/learning.html)）'
- en: '**Tutorials** (**Reason**): Tutorials for Reason in the form of blog posts
    ([www.reasonstudios.com/blog/category/tutorials](https://www.reasonstudios.com/blog/category/tutorials))'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**教程** (**Reason**)：Reason的教程以博客文章的形式提供（[www.reasonstudios.com/blog/category/tutorials](https://www.reasonstudios.com/blog/category/tutorials)）'
- en: '**Getting Started With SC** (**SuperCollider**): The best way to get into SuperCollider
    and its programming language, `sclang`—the examples are also bundled with the
    software when downloaded ([doc.sccode.org/Tutorials/Getting-Started/00-Getting-Started-With-SC.html](http://doc.sccode.org/Tutorials/Getting-Started/00-Getting-Started-With-SC.html))'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始使用SC** (**SuperCollider**)：进入SuperCollider及其编程语言`scalang`的最佳方式——示例也与软件一起打包下载（[doc.sccode.org/Tutorials/Getting-Started/00-Getting-Started-With-SC.html](http://doc.sccode.org/Tutorials/Getting-Started/00-Getting-Started-With-SC.html)）'
- en: '**VCV Rack Manual** (**VCV Rack**): VCV documentation along with the developer
    API if you want to write code for the software ([vcvrack.com/manual/](https://vcvrack.com/manual/))'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VCV Rack手册** (**VCV Rack**)：VCV文档及开发者API，供你编写软件代码使用（[vcvrack.com/manual/](https://vcvrack.com/manual/)）'
- en: '**Ports**: Mido documentation on Virtual MIDI ports differences between platforms
    ([mido.readthedocs.io/en/latest/ports.html](https://mido.readthedocs.io/en/latest/ports.html))'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口**：关于虚拟MIDI端口在不同平台间差异的Mido文档（[mido.readthedocs.io/en/latest/ports.html](https://mido.readthedocs.io/en/latest/ports.html)）'
- en: '**Summary of MIDI Messages**: List of MIDI messages, including the MIDI clock
    and transport message we''re using ([www.midi.org/specifications/item/table-1-summary-of-midi-message](https://www.midi.org/specifications/item/table-1-summary-of-midi-message))'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MIDI消息总结**：MIDI消息列表，包括我们使用的MIDI时钟和传输消息（[www.midi.org/specifications/item/table-1-summary-of-midi-message](https://www.midi.org/specifications/item/table-1-summary-of-midi-message)）'
- en: '**Message Types**: Supported message types in Mido from the MIDI spec ([mido.readthedocs.io/en/latest/message_types.html](https://mido.readthedocs.io/en/latest/message_types.html))'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息类型**：Mido支持的消息类型，来自MIDI规范（[mido.readthedocs.io/en/latest/message_types.html](https://mido.readthedocs.io/en/latest/message_types.html)）'
- en: '**Magenta Studio**: Blog post from the Magenta team on Magenta Studio ([magenta.tensorflow.org/studio-announce](https://magenta.tensorflow.org/studio-announce))'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Magenta Studio**：Magenta团队关于Magenta Studio的博客文章（[magenta.tensorflow.org/studio-announce](https://magenta.tensorflow.org/studio-announce)）'
