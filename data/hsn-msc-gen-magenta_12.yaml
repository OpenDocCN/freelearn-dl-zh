- en: Magenta in the Browser with Magenta.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Magenta.js 在浏览器中运行 Magenta。
- en: In this chapter, we'll talk about Magenta.js, a JavaScript implementation of
    Magenta that has gained in popularity for its ease of use, since it runs in the
    browser and can be shared as a web page. We'll introduce TensorFlow.js, the technology
    upon which Magenta.js is built, and show which models are available in Magenta.js,
    including how to convert our previously trained models. Then, we'll create small
    web applications using GANSynth and MusicVAE, for sampling audio and sequences
    respectively. Finally, we'll see how Magenta.js can interact with other applications,
    using the Web MIDI API and Node.js.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍 Magenta.js，这是 Magenta 的 JavaScript 实现，由于它运行在浏览器中并且可以作为网页共享，因此在易用性上获得了广泛的关注。我们将介绍
    TensorFlow.js，它是构建 Magenta.js 的技术，并展示 Magenta.js 中可用的模型，包括如何转换我们之前训练的模型。然后，我们将使用
    GANSynth 和 MusicVAE 创建小型 Web 应用程序，分别用于采样音频和序列。最后，我们将看到 Magenta.js 如何通过 Web MIDI
    API 和 Node.js 与其他应用程序交互。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing Magenta.js and TensorFlow.js
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Magenta.js 和 TensorFlow.js。
- en: Creating a Magenta.js web application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Magenta.js Web 应用程序。
- en: Making Magenta.js interact with other apps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使 Magenta.js 与其他应用程序交互。
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求。
- en: 'In this chapter, we''ll use the following tools:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使用以下工具：
- en: '**Command line** or **Bash** to launch Magenta from the terminal'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **命令行** 或 **Bash** 从终端启动 Magenta。
- en: '**Python** and **Magenta** to convert trained models for Magenta.js'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python** 和 **Magenta** 用于将训练好的模型转换为 Magenta.js 可用格式。'
- en: '**TensorFlow.js** and **Magenta.js** to create music generation apps in the
    browser'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **TensorFlow.js** 和 **Magenta.js** 在浏览器中创建音乐生成应用程序。
- en: '**JavaScript**, **HTML**, and **CSS** to write Magenta.js web applications'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **JavaScript**、**HTML** 和 **CSS** 编写 Magenta.js Web 应用程序。
- en: A **recent browser** (Chrome, Firefox, Edge, Safari) for up-to-date web APIs
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **最新版本的浏览器**（Chrome、Firefox、Edge、Safari），以支持最新的 Web API。
- en: '**Node.js** and **npm** to install Magenta.js and its dependencies server side'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js** 和 **npm** 用于安装 Magenta.js 及其依赖项（服务器端）。'
- en: '**FluidSynth** to listen to generated MIDI from the browser'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **FluidSynth** 从浏览器中播放生成的 MIDI。
- en: In Magenta.js, we'll make the use of the **Music RNN** and **MusicVAE** models
    for MIDI sequence generation and **GANSynth** for audio generation. We'll cover
    their usage in depth, but if you feel like you need more information, the Magenta.js
    Music README in the Magenta.js source code ([github.com/tensorflow/magenta-js/tree/master/music](https://github.com/tensorflow/magenta-js/tree/master/music))
    is a good place to start. You can also take a look at the Magenta.js code, which
    is well documented. We also provide additional content in the last section, *Further
    reading*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Magenta.js 中，我们将使用 **Music RNN** 和 **MusicVAE** 模型来生成 MIDI 序列，使用 **GANSynth**
    进行音频生成。我们将深入探讨它们的使用方法，但如果你觉得需要更多信息，Magenta.js 源代码中的 Magenta.js Music README（[github.com/tensorflow/magenta-js/tree/master/music](https://github.com/tensorflow/magenta-js/tree/master/music)）是一个不错的起点。你还可以查看
    Magenta.js 代码，它有详细的文档。最后一部分 *进一步阅读* 中也提供了额外的内容。
- en: The code for this chapter is in the book's GitHub code repository in the `Chapter08` folder,
    located at [github.com/PacktPublishing/hands-on-music-generation-with-magenta/tree/master/Chapter08](https://github.com/PacktPublishing/hands-on-music-generation-with-magenta/tree/master/Chapter08).
    The examples and code snippets used assume you are located in the chapter folder.
    For this chapter, you should run `cd Chapter08`, before you start.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码位于本书 GitHub 代码库的 `Chapter08` 文件夹中，位置在 [github.com/PacktPublishing/hands-on-music-generation-with-magenta/tree/master/Chapter08](https://github.com/PacktPublishing/hands-on-music-generation-with-magenta/tree/master/Chapter08)。所用示例和代码片段假设你在章节文件夹中。对于本章，你应该在开始之前运行
    `cd Chapter08`。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，观看代码演示：
- en: Placeholder link
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符链接。
- en: Introducing Magenta.js and TensorFlow.js
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Magenta.js 和 TensorFlow.js。
- en: In the previous chapters, we've covered Magenta in Python, its usage, and its
    inner workings. We'll now be looking at Google's Magenta.js, a smaller implementation
    of Magenta in JavaScript. Magenta and Magenta.js both have their advantages and
    disadvantages; let's compare them to see which one we should use, depending on
    the use case.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们已经介绍了 Python 中的 Magenta、其使用方法和内部工作原理。现在我们将关注 Google 的 Magenta.js，它是
    Magenta 在 JavaScript 中的精简实现。Magenta 和 Magenta.js 各有优缺点；让我们进行比较，看看在不同使用场景下应该选择哪一个。
- en: 'A Magenta.js application is easy to use and deploy since it executes in the
    browser. **Developing and deploying a web application is easy**: all you need
    is an HTML file and a web server, and your application is available for the whole
    world to see and use. This is a major advantage of making a browser-based application,
    since not only does it enable us to create our own music generation application
    easily, but it also makes it easy to use it collaboratively. See the *Further
    reading* section at the end of the chapter for great examples of popular Magenta.js
    web applications.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Magenta.js 应用程序易于使用和部署，因为它在浏览器中执行。**开发和部署一个 Web 应用程序非常简单**：你只需要一个 HTML 文件和一个
    Web 服务器，应用程序就可以让全世界看到和使用。这是基于浏览器的应用程序的一大优势，因为它不仅让我们能够轻松创建自己的音乐生成应用程序，而且使得协作使用变得更加容易。有关流行
    Magenta.js Web 应用程序的精彩示例，请参见本章末尾的 *进一步阅读* 部分。
- en: 'This is the power of a web browser: everyone has one, and a web page requires
    no installation to run. The downside of a Magenta.js web application is that it
    also runs in a browser: it isn''t the best place to handle quality, real-time
    audio, and making your application interact with traditional music production
    tools, such as **digital audio workstations** (**DAWs**), is harder.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Web 浏览器的强大之处：每个人都有一个，而且网页不需要安装即可运行。Magenta.js Web 应用程序的缺点是它也运行在浏览器中：浏览器并不是处理高质量、实时音频的最佳场所，而且使你的应用程序与传统音乐制作工具（如
    **数字音频工作站** (**DAWs**)）交互变得更加困难。
- en: We'll be looking at the specifics of working in the browser as we go along.
    First, we'll be looking at Tone.js in the *Introducing Tone.js for sound synthesis
    in the browser* section, which describes the usage of the Web Audio API. Then,
    we'll be looking at the Web Workers API in the *Using the Web Workers API to offload
    computations from the UI thread* section, to make real-time audio easier. Finally,
    we'll be looking at making Magenta.js interact with other music applications,
    in the *Making Magenta.js interact with other apps* section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 随着内容的深入，我们将逐步了解在浏览器中工作的具体细节。首先，我们将在 *在浏览器中介绍 Tone.js 用于声音合成* 部分中，了解 Web Audio
    API 的使用。接着，我们将在 *使用 Web Workers API 将计算从 UI 线程卸载* 部分中，讨论如何让实时音频变得更加轻松。最后，我们将在
    *使 Magenta.js 与其他应用程序交互* 部分中，讨论如何让 Magenta.js 与其他音乐应用程序互动。
- en: Introducing TensorFlow.js for machine learning in the browser
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器中介绍 TensorFlow.js 机器学习
- en: First, let's introduce TensorFlow.js ([www.tensorflow.org/js](https://www.tensorflow.org/js)),
    the project upon which Magenta.js is built. As its name suggests, TensorFlow.js
    is a JavaScript implementation of TensorFlow, making it possible to **use and
    train** **models in the browser**. Importing and running pre-trained models from
    TensorFlow SavedModel or Keras is possible.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们介绍 TensorFlow.js（[www.tensorflow.org/js](https://www.tensorflow.org/js)），Magenta.js
    构建的项目。正如其名称所示，TensorFlow.js 是 TensorFlow 的 JavaScript 实现，使得在浏览器中**使用和训练** **模型**成为可能。也可以导入并运行来自
    TensorFlow SavedModel 或 Keras 的预训练模型。
- en: 'Using TensorFlow.js is easy. You can use a `script` tag, as shown in the following
    code block:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TensorFlow.js 很简单。你可以使用 `script` 标签，如以下代码块所示：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, you can use the `npm` or `yarn` command to run the following
    code block:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以使用 `npm` 或 `yarn` 命令来运行以下代码块：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice in both code snippets the usage of the `tf` variable, which is imported
    with the script (we'll be seeing more `tf` usage in this chapter's examples).
    We won't be looking at TensorFlow.js specifically, but we are going to use it
    in our Magenta.js code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在这两个代码片段中 `tf` 变量的使用，它是通过脚本导入的（在本章的示例中我们将看到更多 `tf` 的使用）。我们不会特别研究 TensorFlow.js，但我们将在
    Magenta.js 代码中使用它。
- en: Another nice thing about TensorFlow.js is that it uses WebGL ([www.khronos.org/registry/webgl/specs/latest/](https://www.khronos.org/registry/webgl/specs/latest/))
    for its computation, meaning it is **graphics processing unit** (**GPU**) accelerated
    (if you have a GPU), without having to install CUDA libraries. The mathematical
    operations are implemented in WebGL shaders and the tensors are encoded in WebGL
    textures, which is a very clever use of WebGL. We don't have to do anything for
    GPU acceleration since the TensorFlow.js backend will handle it for us. When using
    the Node.js server side, the TensorFlow C API is used for hardware acceleration,
    meaning that the usage of CUDA libraries is possible.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow.js 另一个优点是它使用 WebGL（[www.khronos.org/registry/webgl/specs/latest/](https://www.khronos.org/registry/webgl/specs/latest/)）进行计算，这意味着它是
    **图形处理单元**（**GPU**）加速的（如果你有 GPU），且无需安装 CUDA 库。数学运算在 WebGL 着色器中实现，张量被编码为 WebGL
    纹理，这是 WebGL 的一种非常巧妙的使用方法。我们无需做任何事来启用 GPU 加速，因为 TensorFlow.js 后端会为我们处理。当使用 Node.js
    服务器时，TensorFlow C API 用于硬件加速，这意味着也可以使用 CUDA 库。
- en: Using WebGL has a few caveats, though, most notably that the computations might
    block the UI thread in some cases and that the memory used by a tensor allocation
    must be reclaimed (disposed) after usage. Regarding computation threading, we'll
    be looking at this in more depth when we look at web workers. Regarding memory
    management, we'll be showing proper usage in the code as we go along. See the
    *Further reading* section for more information on these issues.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 WebGL 有一些注意事项，最显著的是计算在某些情况下可能会阻塞 UI 线程，以及张量分配所使用的内存必须在使用后进行回收（释放）。关于计算线程，我们将在讨论
    Web Workers 时更深入地探讨。关于内存管理，我们将在代码中展示正确的使用方法。有关这些问题的更多信息，请参见 *进一步阅读* 部分。
- en: Introducing Magenta.js for music generation in the browser
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器中生成音乐的 Magenta.js 介绍
- en: Now that we understand what Tensorflow.js is, let's talk about Magenta.js. First,
    we need to understand what Magenta.js can and cannot do. For now, models cannot
    be trained in Magenta.js (with the exception of the partial training in MidiMe),
    but the models we've trained in the previous chapter can be converted and imported
    easily. Another limitation of Magenta.js is that not all models are present, but
    the most important ones are. While writing Magenta.js code, we'll see that most
    of the concepts we've already covered are there, sometimes with a different syntax.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了 TensorFlow.js，接下来讨论 Magenta.js。首先，我们需要了解 Magenta.js 能做什么，不能做什么。目前，Magenta.js
    中无法训练模型（除了在 MidiMe 中的部分训练），但我们在前一章中训练的模型可以轻松转换和导入。Magenta.js 的另一个限制是并非所有模型都包含在内，但最重要的模型都包括在内。在编写
    Magenta.js 代码时，我们会发现大部分已覆盖的概念都在其中，只是语法有所不同。
- en: 'Here is an overview of some of the pre-trained models present in Magenta.js:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Magenta.js 中一些预训练模型的概述：
- en: '**Onsets and Frames** for piano transcription, converting raw audio to MIDI'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Onsets and Frames** 用于钢琴转录，将原始音频转换为 MIDI'
- en: '**Music RNN** (**long short-term memory** (**LSTM**)-based networks) for monophonic
    and polyphonic MIDI generation, including the Melody RNN, Drums RNN, Improv RNN
    and Performance RNN models'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Music RNN**（**长短期记忆**（**LSTM**）网络）用于单音和多音 MIDI 生成，包括 Melody RNN、Drums RNN、Improv
    RNN 和 Performance RNN 模型'
- en: '**MusicVAE** for single or trio sampling and interpolation, also including
    GrooVAE'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MusicVAE** 用于单音或三重音采样与插值，另包括 GrooVAE'
- en: '**Piano Genie** that maps an 8-key input to a full 88-key piano'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Piano Genie** 将 8 键输入映射到完整的 88 键钢琴'
- en: We've already talked about these models in the previous chapters. We can find
    the pre-trained checkpoints list either in the Magenta.js source code, in the
    `music/checkpoints/checkpoints.json` file, or in the hosted version, at [goo.gl/magenta/js-checkpoints](https://goo.gl/magenta/js-checkpoints).
    Most of the checkpoints (or bundles) we've used are present in Magenta.js, plus
    some new additions such as longer 4-bar MusicVAE and GrooVAE models.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在前面的章节中讨论了这些模型。我们可以在 Magenta.js 源代码中找到预训练检查点列表，路径为 `music/checkpoints/checkpoints.json`
    文件，或者在托管版本中，通过 [goo.gl/magenta/js-checkpoints](https://goo.gl/magenta/js-checkpoints)
    访问。我们使用的大多数检查点（或模型包）都包含在 Magenta.js 中，还有一些新增加的模型，例如更长的 4 小节 MusicVAE 和 GrooVAE
    模型。
- en: Converting trained models for Magenta.js
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将训练好的模型转换为 Magenta.js 格式
- en: Using pre-trained models is great, but we can also import our own trained models,
    such as the ones we trained in the previous chapter—[Chapter 7](6f012812-5c24-44d4-b8cb-ddfd3ed78f5c.xhtml),
    *Training Magenta Models*. We are doing that by using the `checkpoint_converted.py`
    script that dumps the weights from a Magenta checkpoint to a format Magenta.js
    can use.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用预训练模型非常好，但我们也可以导入我们自己训练的模型，比如我们在上一章中训练的模型——[第7章](6f012812-5c24-44d4-b8cb-ddfd3ed78f5c.xhtml)，*训练
    Magenta 模型*。我们通过使用 `checkpoint_converted.py` 脚本实现这一点，该脚本将 Magenta 检查点中的权重转储到 Magenta.js
    可以使用的格式。
- en: You can find this code in the `chapter_08_example_01.html` file in the source
    code of this chapter. There are more comments and content in the source code—you
    should go and check it out.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本章节的源代码中找到这段代码，文件名为 `chapter_08_example_01.html`。源代码中有更多的注释和内容，你应该去查看它。
- en: 'Let''s convert a simple RNN model for Magenta.js, by following these steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤，将一个简单的 RNN 模型转换为适用于 Magenta.js 的格式：
- en: 'First, we''ll need the `checkpoint_converter.py` script from Magenta.js. The
    easiest way is to download the script directly from the source code on GitHub,
    as follows:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要从 Magenta.js 获取 `checkpoint_converter.py` 脚本。最简单的方法是直接从 GitHub 上的源代码下载该脚本，如下所示：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This should create the `checkpoint_converter.py` file locally.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在本地创建 `checkpoint_converter.py` 文件。
- en: 'Now, we''ll need the TensorFlow.js Python packaging on which the `checkpoint_converter.py`
    script depends. Run the following code:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要 TensorFlow.js Python 打包文件，这是 `checkpoint_converter.py` 脚本所依赖的。运行以下代码：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can now run the conversion script using, for example, one of our previously
    trained DrumsRNN models (replacing `PATH_TO_TRAINING_DIR` with a proper value),
    as follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以运行转换脚本，例如，使用我们之前训练的 DrumsRNN 模型（将 `PATH_TO_TRAINING_DIR` 替换为合适的值），如下所示：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will create the `checkpoints/drums_rnn_dance_small` directory with a JSON
    metadata file and the checkpoint binary files that will get loaded by TensorFlow.js.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建 `checkpoints/drums_rnn_dance_small` 目录，其中包含一个 JSON 元数据文件和将由 TensorFlow.js
    加载的检查点二进制文件。
- en: Remember that when referencing checkpoints in TensorFlow, you need to provide
    the prefix—for example, `model.ckpt-20000`, but not followed by `.data`, `.index`,
    or `.meta`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在引用 TensorFlow 检查点时，您需要提供前缀——例如，`model.ckpt-20000`，但不应加上 `.data`、`.index`
    或 `.meta`。
- en: 'Then, we need to create a JSON configuration file that describes the model
    configuration. Open the `checkpoints/drums_rnn_dance_small/config.json` file and
    enter this content:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要创建一个 JSON 配置文件，描述模型的配置。打开 `checkpoints/drums_rnn_dance_small/config.json`
    文件，并输入以下内容：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is a minimal example for the DrumsRNN model, without any further configuration.
    Note that the `args` key for the `dataConverter` key is necessary, even if no
    arguments are provided. The `type` of `dataConverter` is one of the subclasses
    of `DataConverter`, located in the `data.ts` file in `music/src/core` in the Magenta.js
    source code. Other possible data converters could be `MelodyConverter`, `TrioConverter`,
    or `GrooveConverter`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DrumsRNN 模型的一个最小示例，没有进一步的配置。请注意，即使没有提供任何参数，`dataConverter` 的 `args` 键也是必要的。`dataConverter`
    的 `type` 是 `DataConverter` 的子类之一，位于 Magenta.js 源代码中的 `music/src/core` 文件夹下的 `data.ts`
    文件中。其他可能的数据转换器包括 `MelodyConverter`、`TrioConverter` 或 `GrooveConverter`。
- en: Other models and converters will require more configuration. The easiest way
    to find the proper configuration for a specific model is to find a similar Magenta
    pre-trained model and use similar values. To do that, follow the *Downloading
    pre-trained models locally* section, and find the information you want in the
    downloaded `config.json` file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 其他模型和转换器将需要更多的配置。找到适当配置的最简单方法是找到一个类似的 Magenta 预训练模型，并使用类似的值。为此，按照 *下载预训练模型到本地*
    部分操作，并在下载的 `config.json` 文件中找到所需的信息。
- en: 'Our custom model is now converted to a format TensorFlow.js understands. Let''s
    create a small web page that imports and initializes that model to test it, as
    follows:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的自定义模型现在已转换为 TensorFlow.js 可以理解的格式。接下来，让我们创建一个小型网页，导入并初始化该模型进行测试，如下所示：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Don't worry too much about the content of the HTML page, since it will be thoroughly
    explained in the following sections. The important part here is that the MusicRNN
    constructor (`mm.MusicRNN("URL")`) is loading our converted DrumsRNN checkpoint
    in the MusicRNN model.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 不必过于担心 HTML 页面中的内容，因为它将在接下来的章节中得到详细解释。这里重要的是，MusicRNN 构造函数（`mm.MusicRNN("URL")`）正在加载我们转换后的
    DrumsRNN 检查点到 MusicRNN 模型中。
- en: You might have noticed that the URL of the checkpoint is local, at `http://0.0.0.0:8000`.
    This is because most browsers implement **Cross-Origin Resource Sharing** (**CORS**)
    restrictions, one of them being that a local file can only fetch resources starting
    with a **Uniform Resource Identifier** (**URI**) scheme of `http` or `https`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到检查点的URL是本地的，位于`http://0.0.0.0:8000`。这是因为大多数浏览器实现了**跨源资源共享**（**CORS**）限制，其中之一是本地文件只能获取以**统一资源标识符**（**URI**）方案`http`或`https`开头的资源。
- en: 'The easiest way of circumventing that is to start a web server locally, like
    this:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绕过这一点的最简单方法是本地启动一个web服务器，如下所示：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will start a web server serving the current folder at `http://0.0.0.0:8000`,
    meaning the HTML file from the previous snippet will be served at `http://0.0.0.0:8000/example.html`,
    and our checkpoint at `http://0.0.0.0:8000/checkpoints/drums_rnn_dance_small`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个web服务器，在`http://0.0.0.0:8000`提供当前文件夹的内容，这意味着前面代码片段中的HTML文件将通过`http://0.0.0.0:8000/example.html`提供，且我们的检查点将位于`http://0.0.0.0:8000/checkpoints/drums_rnn_dance_small`。
- en: 'Open the HTML file and check the console. You should see the following:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开HTML文件并检查控制台。你应该会看到以下内容：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This means that our model was successfully initialized.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的模型已成功初始化。
- en: Downloading pre-trained models locally
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地下载预训练模型
- en: 'Downloading pre-trained models locally is useful if we want to serve them ourselves
    or if we want to check the `config.json` content:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本地下载预训练模型很有用，如果我们想自己提供模型或检查`config.json`的内容：
- en: 'First, we''ll need the `checkpoint_converter.py` script from Magenta.js. The
    easiest way is to download the script directly from the source code on GitHub,
    as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要Magenta.js中的`checkpoint_converter.py`脚本。最简单的方法是直接从GitHub的源代码下载该脚本，如下所示：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This should create the `checkpoint_converter.py` file locally.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在本地创建`checkpoint_converter.py`文件。
- en: 'We can then call the script by entering the following code:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以通过输入以下代码来调用该脚本：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will download the `mel_16bar_small_q2` MusicVAE pre-trained model in the
    `checkpoints` folder.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载`mel_16bar_small_q2` MusicVAE预训练模型到`checkpoints`文件夹中。
- en: Introducing Tone.js for sound synthesis in the browser
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器中引入Tone.js进行声音合成
- en: In this chapter, you'll hear generated audio in the browser, which means that
    audio synthesis, analogous to when we used FluidSynth in the previous chapters
    to listen to MIDI files, is happening in the browser, using the Web Audio API.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将听到在浏览器中生成的音频，这意味着音频合成，类似于我们在前几章中使用FluidSynth来播放MIDI文件的方式，是在浏览器中发生的，使用的是Web
    Audio API。
- en: The **Web Audio API** ([www.w3.org/TR/webaudio/](https://www.w3.org/TR/webaudio/))
    provides fairly low-level concepts to handle sound sources, transformations, and
    routing, through the usage of audio nodes. First, we have a sound source that
    provides an array of sound intensities (see [Chapter 1](c5602f6c-c094-42f2-936f-98746cf04a49.xhtml),
    *Introduction on Magenta and Generative Art*, for a refresher on that), which
    could be a sound file (a sample) or an oscillator. Then, the sound source node
    can be connected to a transformation node such as a gain (to change the volume).
    Finally, the result needs to be connected to a destination (an output) for the
    sound to be heard in the speakers.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web Audio API**（[www.w3.org/TR/webaudio/](https://www.w3.org/TR/webaudio/)）提供了相当低级的概念，通过音频节点来处理声音源、转换和路由。首先，我们有一个声音源，它提供一组声音强度（有关这一点的复习，请参见[第1章](c5602f6c-c094-42f2-936f-98746cf04a49.xhtml)，*关于Magenta和生成艺术的介绍*），它可以是一个声音文件（样本）或一个振荡器。然后，声音源节点可以连接到一个转换节点，如增益（用于改变音量）。最后，结果需要连接到一个目标（输出），使声音能够通过扬声器播放出来。'
- en: The specification is quite mature, listed as *W3C Candidate Recommendation,
    September 18, 2018*, so some implementation details might change, but it can be
    considered stable. In terms of support, all the major browsers support the Web
    Audio API, which is great. See the *Further reading* section for more information.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 该规范已经相当成熟，列为*W3C候选推荐，2018年9月18日*，因此一些实现细节可能会发生变化，但可以认为它是稳定的。就支持而言，所有主要浏览器都支持Web
    Audio API，这非常好。有关更多信息，请参阅*进一步阅读*部分。
- en: We won't be using the Web Audio API directly. Rather, we'll be using **Tone.js**
    ([tonejs.github.io](https://tonejs.github.io/)), which is a JavaScript library
    built on top of the Web Audio API, providing higher-level functionalities. Another
    advantage of using Tone.js is that it can be resilient to change, in the event
    of the underlying Web Audio API changing.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会直接使用 Web Audio API，而是使用 **Tone.js** ([tonejs.github.io](https://tonejs.github.io/))，这是一个建立在
    Web Audio API 之上的 JavaScript 库，提供更高层次的功能。使用 Tone.js 的另一个优势是，它能够适应底层 Web Audio
    API 的变化。
- en: Since the Web Audio API implementation changes from browser to browser, the
    quality of the audio might vary. For example, layering multiple audio samples
    from GANSynth resulted in audio clipping in Firefox but worked correctly in Chrome.
    Remember that for professional-grade audio quality, audio synthesis in the browser
    might not be the best choice.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Web Audio API 在不同浏览器中的实现有所不同，音频质量可能会有所不同。例如，在 Firefox 中叠加多个来自 GANSynth 的音频样本时会出现音频削波问题，但在
    Chrome 中则可以正常工作。请记住，对于专业级别的音频质量，浏览器中的音频合成可能不是最佳选择。
- en: Creating a Magenta.js web application
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 Magenta.js Web 应用
- en: Now that we have introduced the concepts surrounding Magenta.js, we'll be creating
    a web application using Magenta.js. Let's create a web application where we generate
    a trio of instruments (the drum kit, the bass, and the lead) using MusicVAE, where
    we can change the lead instrument for a GANSynth-generated instrument.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了 Magenta.js 的相关概念，接下来我们将使用 Magenta.js 创建一个 Web 应用。让我们创建一个 Web 应用，使用
    MusicVAE 生成三种乐器（鼓组、低音和主音），并且可以将主乐器替换为 GANSynth 生成的乐器。
- en: We'll be building this application step by step. First, we'll make an app that
    generates instruments, using GANSynth. Then, we'll create an app in which we can
    sample a trio sequence. Finally, we'll merge the two apps together.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一步步构建这个应用。首先，我们将做一个生成乐器的应用，使用 GANSynth。然后，我们将创建一个可以采样三重奏序列的应用。最后，我们将把这两个应用合并在一起。
- en: Generating instruments in the browser using GANSynth
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器中使用 GANSynth 生成乐器
- en: For the first part of our example, we'll use GANSynth to sample single instrument
    notes, which are short audio clips of 4 seconds. We'll be able to layer multiple
    audio clips, for interesting effects.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们示例的第一部分，我们将使用 GANSynth 来采样单个乐器音符，这些音符是时长为 4 秒的短音频片段。我们将能够将多个音频片段叠加，从而产生有趣的效果。
- en: First, we'll create the HTML page and import the required scripts. Then, we'll
    write the GANSynth sampling code and explain each step in detail. We'll finish
    the example by listening to the generated audio.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建 HTML 页面并导入所需的脚本。接下来，我们将编写 GANSynth 采样代码，并详细解释每一步。最后，我们将通过聆听生成的音频来完成示例。
- en: Writing the page structure
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写页面结构
- en: We'll be keeping the page structure and style at a minimum, to focus on the
    Magenta.js code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持页面结构和样式的简洁，专注于 Magenta.js 的代码。
- en: You can find this code in the `chapter_08_example_02.html` file in the source
    code of this chapter. There are more comments and content in the source code—you
    should go and check it out.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本章源代码中的 `chapter_08_example_02.html` 文件中找到这段代码。源代码中有更多的注释和内容，你应该去查看一下。
- en: 'First, let''s create the page structure and import the required scripts, as
    follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建页面结构并导入所需的脚本，如下所示：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The page structure contains only a button that will call the GANSynth generation
    and a container in which we'll draw the generated spectrogram.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 页面结构只包含一个按钮，用于调用 GANSynth 生成音频，以及一个容器，用于绘制生成的频谱图。
- en: 'There are two ways of using Magenta.js in the browser, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中使用 Magenta.js 有两种方式，具体如下：
- en: We can import the whole Magenta.js music distribution in `dist/magentamusic.min.js`.
    In the Magenta documentation, this is referred to as the **ES5 bundle** method.
    This will include Magenta.js (bound on `mm`) and all its dependencies, including
    TensorFlow.js (bound on `mm.tf`) and Tone.js (bound on `mm.Player.tone`).
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在 `dist/magentamusic.min.js` 中导入整个 Magenta.js 音乐库。在 Magenta 文档中，这被称为 **ES5
    bundle** 方法。这将包括 Magenta.js（绑定为 `mm`）及其所有依赖项，包括 TensorFlow.js（绑定为 `mm.tf`）和 Tone.js（绑定为
    `mm.Player.tone`）。
- en: We can import only the Magenta.js elements that we need, under the `es6` folder.
    In the Magenta documentation, this is referred to as the **ES6 bundle** method.
    For example, if we only need the GANSynth model, we will need to import Tone.js
    (bound on `Tone`), Tensorflow.js (bound on `tf`), Magenta.js core (bound on `core`),
    and Magenta.js GANSynth (bound on `gansynth`).
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以仅导入我们需要的 Magenta.js 元素，这些元素位于 `es6` 文件夹中。在 Magenta 文档中，这称为 **ES6 打包** 方法。例如，如果我们只需要
    GANSynth 模型，我们需要导入 Tone.js（绑定到 `Tone`），TensorFlow.js（绑定到 `tf`），Magenta.js 核心（绑定到
    `core`），以及 Magenta.js GANSynth（绑定到 `gansynth`）。
- en: We won't talk about the differences between the ES5 and the ES6 bundles here.
    Just remember that the easiest way to go is to use the ES5 bundle method, importing
    one big file with everything. If you want more control over what is sent to the
    client (for performance reasons, for example), you'll want to use the ES6 bundle
    method. Remember that the module bindings are not the same between both methods,
    so you'll have to adapt your code if you change the imports.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们不讨论 ES5 和 ES6 打包文件之间的差异。只需记住，最简单的方法是使用 ES5 打包方式，导入一个包含所有内容的大文件。如果你想对发送到客户端的内容有更多控制（例如，出于性能原因），你将需要使用
    ES6 打包方式。请记住，两种方法之间的模块绑定不同，因此如果你更改了导入，你需要调整代码。
- en: 'Here are the ES6 bundle imports for the GANSynth model only:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是仅包含 GANSynth 模型的 ES6 打包导入：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This imports only the GANSynth model, which can be instantiated using `new gansynth.GANSynth(...)`.
    When using ES6 modules, we need to import each script individually. For our example,
    these are Tone.js, TensorFlow.js, Magenta.js core, and GANSynth.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅导入 GANSynth 模型，模型可以通过 `new gansynth.GANSynth(...)` 实例化。在使用 ES6 模块时，我们需要单独导入每个脚本。对于我们的示例，这些脚本是
    Tone.js、TensorFlow.js、Magenta.js 核心和 GANSynth。
- en: We'll stick with ES5 bundles for our example, but feel free to use ES6 bundles
    if you feel like it. We'll be showing where the code differs between each approach
    in our examples.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将坚持使用 ES5 打包方式，但如果你愿意，可以使用 ES6 打包方式。在我们的示例中，我们将展示每种方法之间代码的不同之处。
- en: You can find the ES6 code for this example in the `chapter_08_example_02_es6.html` file,
    in the source code of this chapter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `chapter_08_example_02_es6.html` 文件中找到本例的 ES6 代码，该文件位于本章的源代码中。
- en: Now, let's write the GANSynth code (in the `GANSynth code` comment), and explain
    each step.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写 GANSynth 代码（在 `GANSynth code` 注释中），并解释每一步。
- en: Sampling audio using GANSynth
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GANSynth 采样音频
- en: 'Now that we have properly imported Magenta.js, we can write the GANSynth audio
    generation code by following these steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经正确导入了 Magenta.js，我们可以按照以下步骤编写 GANSynth 音频生成代码：
- en: 'First, we''ll initialize the DOM elements and initialize GANSynth, like this:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将初始化 DOM 元素并初始化 GANSynth，如下所示：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we instantiate GANSynth using `mm.GANSynth(...)`. Remember, the Magenta.js
    context is under the `mm` variable when imported using an ES5 module. The URL
    for the checkpoint is the same that we've used in the previous chapter—[Chapter
    5](feb070b7-92ac-4762-a4ac-7c1a797a47ef.xhtml), *Audio Generation with NSynth
    and GANSynth*. Refer to that chapter if you want more information. We also make
    the reference to `ganSynth` globally so that we can call it later easily.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `mm.GANSynth(...)` 实例化 GANSynth。记住，当使用 ES5 模块导入时，Magenta.js 上下文位于 `mm`
    变量下。检查点的 URL 与我们在上一章中使用的相同——[第 5 章](feb070b7-92ac-4762-a4ac-7c1a797a47ef.xhtml)，*使用
    NSynth 和 GANSynth 生成音频*。如果你想要更多信息，请参考那一章。我们还将 `ganSynth` 引用设置为全局变量，以便稍后可以轻松调用。
- en: 'Using the Magenta.js ES6 bundle, we would have the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Magenta.js ES6 打包时，我们将拥有以下代码：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For the ES6 bundle, the module variable is `gansynth.GANSynth` instead of `mm.GANSynth`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 ES6 打包，模块变量是 `gansynth.GANSynth`，而不是 `mm.GANSynth`。
- en: 'Now, let''s write an asynchronous function that will insert the generated spectrogram
    in the web page using a `canvas`, like this:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个异步函数，使用 `canvas` 将生成的频谱图插入网页中，如下所示：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This method creates a spectrogram plot and inserts it in a `canvas` element
    in the `containerPlots` elements we've previously declared. It will keep adding
    spectrograms for each generation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法创建一个频谱图，并将其插入我们之前声明的 `containerPlots` 元素中的 `canvas` 元素。它将继续为每次生成添加频谱图。
- en: You might have noticed the usage of `tf.tidy` and `dispose` in the example.
    Using those methods is necessary to avoid memory leaks in the TensorFlow.js code.
    This is because TensorFlow.js uses WebGL to make its computations, and **WebGL
    resources need to be explicitly reclaimed** after use. Any `tf.Tensor` needs to
    be disposed of after use by using `dispose`. The `tf.tidy` method can be used
    to dispose of all the tensors that are not returned by a function after executing
    it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到在示例中使用了 `tf.tidy` 和 `dispose`。使用这些方法是为了避免 TensorFlow.js 代码中的内存泄漏。这是因为
    TensorFlow.js 使用 WebGL 来进行计算，而**WebGL 资源在使用后需要显式回收**。任何 `tf.Tensor` 在使用后都需要通过使用
    `dispose` 来进行清理。`tf.tidy` 方法可以在执行完函数后，自动清理所有未返回的张量。
- en: You might wonder what the `async` and `await` keywords are, in the previous
    JavaScript code. Those two keywords mark the usage of **asynchronous methods**.
    When calling a method that is marked with `async`, meaning it is asynchronous,
    the caller needs to mark the calls with `await`, meaning that it will wait (block)
    until a value is returned. The `await` keyword can be used only in `async` methods.
    In our example, the `mm.tf.browser.toPixels` method is marked with `async`, so
    we need to wait for its return using `await`. Calling an `async` method without
    using `await` can be done using the `Promise` syntax—`Promise.all([myAsyncMethod()])`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道在之前的 JavaScript 代码中，`async` 和 `await` 关键字是什么意思。这两个关键字标志着**异步方法**的使用。当调用一个被标记为
    `async` 的方法时，表示它是异步的，调用者需要使用 `await` 来标记调用，这意味着它会等待（阻塞）直到返回一个值。`await` 关键字只能在
    `async` 方法中使用。在我们的示例中，`mm.tf.browser.toPixels` 方法被标记为 `async`，因此我们需要使用 `await`
    等待它的返回。调用一个 `async` 方法而不使用 `await` 可以通过 `Promise` 语法完成—`Promise.all([myAsyncMethod()])`。
- en: 'Promises were introduced in JavaScript to fix a recurring problem when writing
    asynchronous code: the **callback hell**. The callback hell is a problem that
    arises when multiple linked calls are all asynchronous, resulting in nested callbacks
    (from hell).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Promise 是在 JavaScript 中引入的，目的是解决编写异步代码时遇到的一个反复出现的问题：**回调地狱**。回调地狱是一个问题，当多个关联的调用都是异步时，会导致嵌套的回调（地狱般的回调）。
- en: Promises are great because they provide a clean mechanism to handle complex
    chains of asynchronous calls, as well as proper error handling. However, they
    are a bit verbose, which is why the `async` and `await` keywords were introduced
    as syntactic sugar, to alleviate some of the common use cases around using promises.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Promise 非常棒，因为它们提供了一个干净的机制来处理复杂的异步调用链，并且有适当的错误处理。然而，它们有点冗长，这就是为什么引入了 `async`
    和 `await` 关键字作为语法糖，以缓解使用 Promise 时的常见用例。
- en: 'Then, we write an asynchronous function that samples a note from GANSynth,
    plays it, and plots it using our previous method, as follows:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们编写一个异步函数，从 GANSynth 中采样一个音符，播放它，并使用我们之前的方法绘制它，如下所示：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We first sample from GANSynth using the `randomSample` method, using a base
    pitch of `60`, which is C4, as an argument. This tells the model to sample a value
    corresponding to that pitch. Then, the returned spectrogram is converted to audio
    using `specgramsToAudio`. Finally, we use a Tone.js audio buffer to play the sample,
    by instantiating a new player using the audio buffer. Since we instantiate a new
    player for each sample, each new audio sample will get layered on top of the others.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用 `randomSample` 方法从 GANSynth 中采样，传入基准音高 `60`（即 C4）作为参数。这告诉模型从与该音高相对应的值进行采样。然后，返回的频谱图使用
    `specgramsToAudio` 转换为音频。最后，我们使用 Tone.js 的音频缓冲区来播放该采样，通过实例化一个新播放器并使用音频缓冲区。由于我们为每个采样实例化一个新播放器，因此每个新的音频采样都会叠加在其他采样之上。
- en: The code to instantiate the player, `mm.Player.tone.Player`, is a bit convoluted
    since we first need to find the reference to Tone.js that was already instantiated
    by the Magenta.js object using `mm.Player.tone` (here, the `Player` reference
    is a Magenta.js class).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化播放器的代码 `mm.Player.tone.Player` 有些复杂，因为我们首先需要找到已经被 Magenta.js 对象通过 `mm.Player.tone`
    实例化的 Tone.js 引用（这里，`Player` 引用是 Magenta.js 的一个类）。
- en: 'Using ES6 bundles is more straightforward, as can be seen here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ES6 打包文件更为直接，如这里所示：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Since the Magenta.js ES6 bundle doesn't include Tone.js, it is initialized on
    its own and can be referenced directly, using the `Tone` variable.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Magenta.js 的 ES6 打包文件未包含 Tone.js，它需要自行初始化，并可以直接通过 `Tone` 变量进行引用。
- en: 'Finally, let''s wrap up our example by binding the button to an action and
    initializing GANSynth, like this:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过将按钮绑定到一个操作并初始化 GANSynth 来总结我们的示例，如下所示：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, we bind our button the `sampleGanNote` method, then we initialize GANSynth,
    using the `startGanSynth` method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将按钮绑定到 `sampleGanNote` 方法，然后我们初始化 GANSynth，使用 `startGanSynth` 方法。
- en: Launching the web application
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动网页应用
- en: 'Now that we have our web application ready, we can test our code. Let''s open
    the HTML page we''ve created using a browser. We should see a page similar to
    the one shown in the following screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的网页应用已经准备好，可以测试代码了。让我们用浏览器打开我们创建的 HTML 页面。我们应该能看到一个与下图相似的页面：
- en: '![](img/f4912ffc-37a4-4d40-afe7-9d5f9b1acd48.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4912ffc-37a4-4d40-afe7-9d5f9b1acd48.png)'
- en: In the previous figure, we've already generated some GANSynth samples. Each
    generation plots two spectrograms and keeps the previous ones on the page. On
    the right side of the preceding screenshot, in the console debugger, you can see
    Tone.js and GANSynth initializing. When that is completed, the **Sample GANSynth
    note** button will get enabled.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们已经生成了一些 GANSynth 样本。每次生成都会绘制两个频谱图，并将之前的保持在页面上。在前面的截图右侧，您可以在控制台调试器中看到
    Tone.js 和 GANSynth 初始化。当完成后，**Sample GANSynth note** 按钮将启用。
- en: 'Go ahead and generate sounds: you''ll get pretty interesting effects when layering
    many of them. Congratulations—you''ve completed your first Magenta.js web application!'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 继续生成声音：当你叠加很多声音时，会得到非常有趣的效果。恭喜你——你已经完成了第一个 Magenta.js 网页应用！
- en: Generating a trio using MusicVAE
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MusicVAE 生成三重奏
- en: 'We''ll now be using the MusicVAE model in Magenta.js to generate some sequences
    and play them directly in the browser, using Tone.js. The checkpoint we''ll be
    using is a `trio` model, meaning we''ll be generating three sequences at the same
    time: the drum kit, the bass, and the lead.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用 Magenta.js 中的 MusicVAE 模型来生成一些序列，并直接在浏览器中播放，使用 Tone.js。我们将使用的检查点是一个
    `trio` 模型，这意味着我们将同时生成三种序列：打击乐、低音和主旋律。
- en: You can find this code in the `chapter_08_example_03.html` file in the source
    code of this chapter. There are more comments and content in the source code—you
    should go and check it out.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本章源代码的 `chapter_08_example_03.html` 文件中找到这段代码。源代码中有更多的注释和内容，您应该去查看一下。
- en: 'Since the code is similar to the last section, we won''t be going through all
    the content, but we''ll explain the major differences:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这段代码与上一节类似，我们不会逐一讲解所有内容，但会解释主要的区别：
- en: 'First, let''s define the page structure and script imports, as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义页面结构和脚本导入，如下所示：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The page has the same structure as the previous section. We'll be filling in
    the code in the `MusicVAE code` comment.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 页面结构与上一节相同。我们将在 `MusicVAE 代码` 注释中填入代码。
- en: 'Then, let''s initialize the MusicVAE model, as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们初始化 MusicVAE 模型，如下所示：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The URL for the checkpoint is the same as the one we used in the previous chapter—[Chapter
    4](838da33e-26a9-4701-bfd3-5014dfff4146.xhtml), *Latent Space Interpolation with
    MusicVAE*. Refer to this chapter if you want more information on that checkpoint.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 检查点的 URL 与上一章使用的相同——[第 4 章](838da33e-26a9-4701-bfd3-5014dfff4146.xhtml)，*使用
    MusicVAE 进行潜在空间插值*。如果您想了解该检查点的更多信息，请参考本章。
- en: 'We now create a new Tone.js player to play the three generated sequences, as
    follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在创建一个新的 Tone.js 播放器来播放生成的三个序列，如下所示：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This code extends the `mm.BasePlayer` class in Magenta.js, which is useful
    because we only need to implement the `playNote` method to play the sequences.
    First, we define three synths: `bassDrumSynth`, `bassSynth`, and `leadSynth`,
    described here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码扩展了 Magenta.js 中的 `mm.BasePlayer` 类，这很有用，因为我们只需要实现 `playNote` 方法来播放序列。首先，我们定义了三个合成器：`bassDrumSynth`、`bassSynth`
    和 `leadSynth`，如下所示：
- en: 'The **bass drum synth** only plays the bass drum, which is represented by the
    `note.isDrum` property and MIDI notes 35 or 36 and always plays a `C2` frequency
    for an 8-note length `8n`, using the `MembraneSynth` from Tone.js. Remember: in
    the MIDI specification for the percussion channel, the instruments (Bass Drum,
    Snare, etc.) are defined by the note''s pitch—for example, pitch 35 is Acoustic
    Bass Drum.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低音鼓合成器**只播放低音鼓，由`note.isDrum`属性和 MIDI 音符 35 或 36 表示，并且总是播放 `C2` 的频率，长度为 8
    分音符（`8n`），使用 Tone.js 的 `MembraneSynth`。请记住：在 MIDI 规范中，打击乐通道中的乐器（如低音鼓、军鼓等）是通过音符的音高来定义的——例如，音高
    35 是原声低音鼓。'
- en: 'The **bass synth** only plays the programs from 32 to 39 inclusive, using the
    `Synth` from Tone.js with a triangle waveshape. Remember: from the MIDI specification,
    the program specifies which instrument should be played. For example, program
    1 is Acoustic Grand Piano, and program 33 is Acoustic Bass.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低音合成器**只播放从32到39的程序，使用Tone.js中的`Synth`和三角波形。记住：根据MIDI规范，程序指定了应该播放的乐器。例如，程序1是钢琴，而程序33是木吉他。'
- en: The **lead synth** plays the other programs, using the `PolySynth` from Tone.js
    with five voices.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主音合成器**使用Tone.js中的`PolySynth`和五个音轨来演奏其他程序。'
- en: One thing to notice for the bass and lead synths is that we first need to convert
    the MIDI note to a Tone.js frequency, using the `Frequency` class.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，对于低音和主音合成器，我们首先需要将MIDI音符转换为Tone.js的频率，使用`Frequency`类。
- en: Another important thing to talk about is the **note envelope**, used on a synth
    in Tone.js with the `triggerAttackRelease` method. An envelope acts as a filter
    that will let the note be heard for a certain amount of time. You can think of
    a synthesizer as *always* *playing*, and the envelope—when closed—does not let
    the sound through. When opened, the envelope lets the sound be heard, using a
    certain **slope**, meaning the sound can come slowly (or fast), and end slowly
    (or fast). This is called, respectively, **the attack** and **the release** of
    the envelope. Each time we call the trigger method, the synth will be heard for
    the given duration, using a certain slope.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要讨论的重要内容是**音符包络**，它在Tone.js中的合成器上通过`triggerAttackRelease`方法使用。包络充当过滤器，允许音符在一定时间内被听到。你可以把合成器想象成*始终在播放*，而包络—当关闭时—不会让声音通过。当包络打开时，它允许声音被听到，使用一定的**斜率**，意味着声音可以慢慢（或快速）出现，并慢慢（或快速）结束。这分别被称为包络的**起音**和**释放**。每次我们调用触发方法时，合成器会根据给定的持续时间和一定的斜率发出声音。
- en: You might have already heard the term **Attack Decay Sustain Release** (**ADSR**)
    when talking about envelopes. In Tone.js, we are using a simplified version of
    this, using only the **Attack** and the **Release** of the envelope. With an ADSR
    envelope, we have more control over the resulting shape. For the sake of our example,
    we'll stick with the simplified version.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经听说过**起音衰减延音释放**（**ADSR**）这个术语，尤其是在谈论包络时。在Tone.js中，我们使用的是这个概念的简化版，仅使用包络的**起音**和**释放**。如果使用完整的ADSR包络，我们可以更好地控制结果的形状。为了简单起见，我们的例子中将使用简化版。
- en: 'Let''s now sample the MusicVAE model, as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们来采样MusicVAE模型，如下所示：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, we sample the MusicVAE model using the `sample` method and an argument
    of 1, which is the number of required samples. We then plot the resulting note
    sequence, using an `mm.PianoRollCanvasVisualizer` in the previously declared `canvas`.
    Finally, we start the player with the sample at 120 QPM and loop the 8-second
    sequence, using the Tone.js `Transport` class. Remember that the MusicVAE models
    have fixed length, meaning that by using the 4-bar trio model, we generate 8-second
    samples at 120 QPM.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`sample`方法和参数1来采样MusicVAE模型，1表示所需的样本数量。然后，我们使用之前声明的`canvas`中的`mm.PianoRollCanvasVisualizer`绘制结果音符序列。最后，我们以120
    QPM启动播放器，并循环8秒的音序，使用Tone.js中的`Transport`类。记住，MusicVAE模型具有固定的长度，这意味着使用4小节三重奏模型，我们生成8秒的样本，速度为120
    QPM。
- en: 'Finally, let''s wrap up our example by binding the button to an action and
    initializing the MusicVAE model, as follows:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们通过绑定按钮到一个动作并初始化MusicVAE模型来完成我们的示例，如下所示：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First, we bind our button the `sampleMusicVaeTrio` method, then we initialize
    the MusicVAE model using the `startMusicVae` method. You can see here that we
    are using the `Promise.all` call that we previously introduced to launch our asynchronous
    code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将按钮绑定到`sampleMusicVaeTrio`方法，然后我们使用`startMusicVae`方法初始化MusicVAE模型。你可以看到我们这里使用了之前介绍的`Promise.all`调用来启动我们的异步代码。
- en: 'Now that we have our web application ready, we can test our code. Let''s open
    the HTML page we''ve created using a browser. We should see a page similar to
    the one shown in the following screenshot:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好我们的网页应用程序，可以测试我们的代码了。让我们使用浏览器打开我们创建的HTML页面。我们应该能看到一个类似于以下截图的页面：
- en: '![](img/23e2e0b7-42e4-4f8c-86ed-4efcad9bbbf5.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23e2e0b7-42e4-4f8c-86ed-4efcad9bbbf5.png)'
- en: By pressing the **Sample MusicVAE trio** button, the MusicVAE should sample
    a sequence, plot it, and play it using the synths we've defined. The generated
    plot is rather basic, since it doesn't differentiate the three instruments and
    has no time or pitch marker, but it can be customized using the `PianoRollCanvasVisualizer`
    class.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击**Sample MusicVAE trio**按钮，MusicVAE应该会采样一个序列，绘制出来并使用我们定义的合成器播放。生成的图形相当基础，因为它没有区分三个乐器，也没有时间或音高标记，但可以通过`PianoRollCanvasVisualizer`类进行自定义。
- en: To generate a new sequence, reload the page to start again.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成一个新序列，重新加载页面以重新开始。
- en: Using a SoundFont for more realistic-sounding instruments
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SoundFont来获得更真实的乐器音色
- en: When listening to the generated sound, you might notice that the music sounds
    a bit *basic* or *simple*. That is because we've used the default synths in Tone.js,
    which have the advantage of being easy to use, with the downside of not sounding
    as good as more complex synths. Remember that the Tone.js synth can be customized
    to sound better.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当听到生成的声音时，你可能会注意到音乐听起来有点*基础*或*简单*。这是因为我们使用了Tone.js的默认合成器，它的优点是易于使用，但缺点是音质不如更复杂的合成器好。记住，Tone.js的合成器可以进行自定义，以便听起来更好。
- en: 'Instead of using a synthesizer, we can also use a SoundFont. SoundFonts are
    recorded notes of various instruments, and we''ve been using them in FluidSynth
    since the beginning of this book. In Magenta.js, we can use the `SoundFontPlayer`
    for that purpose, instead of using the `Player` instance, as shown in the following
    code block:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用SoundFont代替合成器。SoundFont是多种乐器的录制音符，我们从本书一开始就一直在FluidSynth中使用它们。在Magenta.js中，我们可以使用`SoundFontPlayer`来代替`Player`实例，代码如下所示：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The list of the SoundFonts hosted by the Magenta team can be found in the Magenta.js
    music README ([github.com/tensorflow/magenta-js/tree/master/music](https://github.com/tensorflow/magenta-js/tree/master/music)).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Magenta团队托管的SoundFont列表可以在Magenta.js音乐文档中找到（[github.com/tensorflow/magenta-js/tree/master/music](https://github.com/tensorflow/magenta-js/tree/master/music)）。
- en: Playing generated instruments in a trio
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演奏生成的三重奏乐器
- en: Now that we have MusicVAE generating a three-instrument sequence and GANSynth
    generating audio, let's make the two work together.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了MusicVAE生成三种乐器的序列，以及GANSynth生成音频，接下来让我们让这两者协同工作。
- en: You can find this code in the `chapter_08_example_04.html` file in the source
    code of this chapter. There are more comments and content in the source code—you
    should go and check it out.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本章的源代码中的`chapter_08_example_04.html`文件中找到这段代码。源代码中有更多的注释和内容，你应该去查看一下。
- en: 'Since the code is similar to the last section, we won''t be going through all
    the content, but we''ll explain the major differences:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码与上一节类似，我们不会逐一讲解所有内容，但会解释主要的区别：
- en: 'First, let''s define the page structure and script imports, like this:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们定义页面结构和脚本导入，如下所示：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The page has the same structure as the previous section. We'll be filling in
    the code in the `MusicVAE + GANSynth code` comment.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 该页面与上一节的结构相同。我们将填充`MusicVAE + GANSynth code`注释中的代码。
- en: 'Then, let''s initialize both the MusicVAE model and the GANSynth model, as
    follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们初始化MusicVAE模型和GANSynth模型，如下所示：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we only enable the **MusicVAE sampling** button. The **GANSynth sampling**
    button will get enabled when MusicVAE has completed its generation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们仅启用**MusicVAE sampling**按钮。**GANSynth sampling**按钮将在MusicVAE完成生成后启用。
- en: We keep the same `plotSpectra` method (from the previous example).
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们保持使用相同的`plotSpectra`方法（来自之前的示例）。
- en: We keep the same `Player` class (from the previous example) for the sound synthesis.
    We can set `leadSynth = null` because it will get replaced by the GANSynth generation,
    but it is not necessary.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们保持使用相同的`Player`类（来自之前的示例）进行声音合成。我们可以设置`leadSynth = null`，因为它将被GANSynth生成替代，但这不是必需的。
- en: We keep the same `sampleMusicVaeTrio` method (from the previous example), but
    we also set the instantiated player as a global variable using `window.player
    = player`, since GANSynth will need to change the lead synth later.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们保持使用相同的`sampleMusicVaeTrio`方法（来自之前的示例），但我们还将实例化的播放器设置为全局变量，使用`window.player
    = player`，因为GANSynth稍后需要更改主合成器。
- en: 'We rewrite the `sampleGanNote` method (from the previous example) to add a
    sample player, as follows:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重写了`sampleGanNote`方法（来自之前的示例），以添加一个样本播放器，如下所示：
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: First, we sample a random instrument from GANSynth using `randomSample`, as
    in the previous example. Then, we need to play that sample in a Tone.js synth,
    so we use the `Sampler` class, which takes a dictionary containing a sample for
    each key. Because we sampled the model using the MIDI pitch 60, we are using a
    `C4` for the resulting audio buffer. Finally, we put that synth in our player
    using `window.player.leadSynth = instrument`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `randomSample` 从 GANSynth 中随机采样一个乐器，像前面的示例那样。然后，我们需要在 Tone.js 合成器中播放该样本，因此我们使用
    `Sampler` 类，它接收一个包含每个键的样本字典。因为我们使用 MIDI 音高 60 对模型进行了采样，所以我们使用 `C4` 来表示生成的音频缓冲区。最后，我们通过
    `window.player.leadSynth = instrument` 将该合成器添加到我们的播放器中。
- en: 'Let''s wrap up our example by binding the buttons to their corresponding actions
    and initializing the MusicVAE and GANSynth models, as follows:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过将按钮绑定到相应的操作，并初始化 MusicVAE 和 GANSynth 模型来总结我们的示例，如下所示：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This code will start the models, bind the buttons, and update the button states.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将启动模型，绑定按钮，并更新按钮状态。
- en: 'Now that we have our web application ready, we can test our code. Let''s open
    the HTML page we''ve created using a browser. We should see a page similar to
    the one shown in the following screenshot:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好我们的 Web 应用程序，可以测试我们的代码了。让我们使用浏览器打开我们创建的 HTML 页面。我们应该会看到一个类似于以下屏幕截图的页面：
- en: '![](img/770e58ed-3a0b-41a1-8d4d-cbd2f754af69.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/770e58ed-3a0b-41a1-8d4d-cbd2f754af69.png)'
- en: By pressing the **Sample MusicVAE trio** button, the MusicVAE should sample
    a sequence, plot it, and play it using the synths we've defined. Then, the **Sample
    GANSynth note for the lead synth** button can be used to generate a new sound
    for the lead synth, which can be used multiple times.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按下 **为主合成器采样 MusicVAE 三重奏** 按钮，MusicVAE 应该会采样一个序列，绘制它，并使用我们定义的合成器进行播放。然后，可以使用
    **为主合成器采样 GANSynth 音符** 按钮来生成一个新的声音用于主合成器，这可以多次使用。
- en: To generate a new sequence, reload the page to start again.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成一个新的序列，重新加载页面以重新开始。
- en: Using the Web Workers API to offload computations from the UI thread
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Web Workers API 将计算卸载出 UI 线程
- en: As you might have noticed from the previous example when you use the **Sample
    GANSynth note for the lead synth** button, the audio freezes (you won't hear any
    sound coming from MusicVAE) while GANSynth generates its first sample.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从前面的示例中可能注意到的，当你使用 **为主合成器采样 GANSynth 音符** 按钮时，音频会冻结（你将听不到来自 MusicVAE 的任何声音），这是因为
    GANSynth 正在生成它的第一个样本。
- en: This is because JavaScript's concurrency is built on the event loop pattern,
    meaning that JavaScript is not multithreaded, and everything is executed in a
    single thread called the **UI thread.** This works well because JavaScript uses
    non-blocking I/O, meaning most of its costly operations complete immediately,
    and return their values using events and callbacks**.** Nonetheless, if a long
    computation is synchronous, it will block the UI thread while it executes, which
    is what happens when GANSynth generates its sample (see the previous *Introducing
    TensorFlow.js for machine learning in the browser* section, for more information
    on how Tensorflow handles computations using WebGL).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 JavaScript 的并发是基于事件循环模式构建的，这意味着 JavaScript 不是多线程的，一切都在一个称为**UI 线程**的单线程中执行。这是可行的，因为
    JavaScript 使用非阻塞 I/O，这意味着大多数昂贵的操作可以立即完成，并通过事件和回调**返回它们的值**。然而，如果一个长时间的计算是同步的，它将在执行时阻塞
    UI 线程，这正是 GANSynth 在生成其样本时发生的情况（有关 TensorFlow 如何使用 WebGL 处理计算的更多信息，请参见前面的 *在浏览器中使用
    TensorFlow.js 进行机器学习* 部分）。
- en: One solution to this is the **Web Workers API** ([html.spec.whatwg.org/multipage/workers.html](https://html.spec.whatwg.org/multipage/workers.html)),
    specified by the **Web Hypertext Application Technology Working Group** (**WHATWG**),
    which enables offloading computations to another thread that won't affect the
    UI thread. A web worker is basically a JavaScript file that gets started from
    the main thread and executes in its own thread. It can send and receive messages
    from the main thread. The Web Workers API is mature and well supported across
    browsers. You can read more about web workers in the *Further reading* section.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的一种方法是**Web Workers API**（[html.spec.whatwg.org/multipage/workers.html](https://html.spec.whatwg.org/multipage/workers.html)），由**Web
    超文本应用技术工作组**（**WHATWG**）规范，该 API 使得将计算卸载到不会影响 UI 线程的另一个线程成为可能。Web Worker 基本上是一个
    JavaScript 文件，它从主线程启动并在自己的线程中执行。它可以与主线程发送和接收消息。Web Workers API 已经成熟，并且在浏览器中得到了很好的支持。你可以在
    *进一步阅读* 部分了解更多关于 Web Worker 的信息。
- en: You can find this code in the `chapter_08_example_05.html` and `chapter_09_example_05.js` files
    in the source code of this chapter. There are more comments and content in the
    source code—you should go and check it out.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本章的源代码中找到 `chapter_08_example_05.html` 和 `chapter_09_example_05.js` 文件中的代码。源代码中有更多的注释和内容——你应该去查看一下。
- en: 'Unfortunately, at the time of writing, some parts of Magenta do not work well
    with web workers. We''ll be showing an example using the MusicVAE model, but we
    can''t show the same example using GANSynth, for example, because the model won''t
    load in a web worker. We still provide this example, since it can serve as a base
    for later use:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在撰写本文时，Magenta 的某些部分与 Web 工作线程的兼容性不佳。我们将展示一个使用 MusicVAE 模型的示例，但我们无法展示同样的示例来使用
    GANSynth，因为该模型无法在 Web 工作线程中加载。我们仍然提供此示例，因为它可以作为以后使用的基础：
- en: 'Let''s write the main page code. We''ll include only the JavaScript code from
    the full HTML page since we''ve covered the other parts in the previous sections.
    Proceed as follows:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写主页面的代码。我们将只包括完整 HTML 页面中的 JavaScript 代码，因为前面章节已经涵盖了其他部分。请按以下步骤进行：
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We''ve already covered most of the code shown in the preceding block in the
    previous examples. Let''s break down the new content, covering the web worker
    creation and the message passing between the web worker and the main thread, as
    follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在前面的示例中覆盖了大部分代码，现在让我们分解新的内容，重点讲解 Web 工作线程的创建以及 Web 工作线程与主线程之间的消息传递，如下所示：
- en: First, we need to start the worker, which is done by using `new Worker("chapter_09_example_05.js")`.
    This will execute the content of the JavaScript file and return a handle we can
    assign to a variable.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们需要启动工作线程，方法是使用 `new Worker("chapter_09_example_05.js")`。这将执行 JavaScript
    文件的内容并返回一个可以分配给变量的句柄。
- en: 'Then, we bind the `onmessage` attribute on the worker, which will get called
    when the worker uses its `postMessage` function. In the `data` attribute of the
    `event` object, we can pass anything we want (see the worker''s code described
    here next):'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将 `onmessage` 属性绑定到工作线程，当工作线程使用其 `postMessage` 函数时，该属性会被调用。在 `event` 对象的
    `data` 属性中，我们可以传递任何我们想要的内容（请参见下面描述的工作线程代码）：
- en: If the worker sends `initialized` as the first element of the `data` array,
    it means that the worker is initialized.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果工作线程将 `initialized` 作为 `data` 数组的第一个元素发送，则意味着工作线程已初始化。
- en: If the worker sends `sample` as the first element of the `data` array, it means
    the worker has sampled a MusicVAE sequence and is returning it as the second element
    of the `data` array.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果工作线程将 `sample` 作为 `data` 数组的第一个元素发送，则意味着工作线程已对 MusicVAE 序列进行采样，并将其作为 `data`
    数组的第二个元素返回。
- en: Finally, when the HTML button is clicked, we call the `postMessage` method on
    the worker instance (without arguments, but it needs—at least—an empty array),
    which will start the sampling.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，当点击 HTML 按钮时，我们在工作线程实例上调用 `postMessage` 方法（无参数，但至少需要一个空数组），这将启动采样过程。
- en: Remember that the web workers have no shared state with the main thread, meaning
    all data sharing needs to happen using the `onmessage` and `postMessage` methods
    or functions exclusively.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Web 工作线程与主线程没有共享状态，这意味着所有的数据共享必须通过 `onmessage` 和 `postMessage` 方法或函数来实现。
- en: 'Now, let''s write the JavaScript worker''s code (which sits at the same location
    as the HTML file), as follows:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写 JavaScript 工作线程的代码（该代码与 HTML 文件位于同一位置），如下所示：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first thing you notice here is that we are using Magenta's ES6 bundle since
    we cannot import everything in a web worker. By importing Tone.js, for example,
    we would get an error such as **This browser does not support Tone.js**. Also,
    remember that Magenta.js is not fully compatible yet with web workers, meaning
    importing GANSynth might result in an error.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先会注意到，我们使用了 Magenta 的 ES6 打包版本，因为我们不能在 Web 工作线程中导入所有内容。例如，导入 Tone.js 时会导致类似
    **该浏览器不支持 Tone.js** 的错误。另外，记住 Magenta.js 尚未完全兼容 Web 工作线程，这意味着导入 GANSynth 可能会导致错误。
- en: 'Since we''ve already covered most of the code shown in the preceding block,
    we''ll just talk about the web worker additions, as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在前面的代码块中覆盖了大部分代码，因此我们将只讨论 Web 工作线程的附加内容，如下所示：
- en: First, we need to send an `initialized` message to the main thread using `postMessage`
    when the model is ready to roll.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，当模型准备好运行时，我们需要使用 `postMessage` 向主线程发送一个 `initialized` 消息。
- en: Then, we bind on the module `onmessage` attribute, which will get called when
    the main thread sends the worker a message. Upon reception, we sample the MusicVAE
    model and then use `postMessage` to send the result back to the main thread.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们绑定在模块的 `onmessage` 属性上，当主线程发送消息给工作线程时，这个属性会被调用。接收到消息后，我们对 MusicVAE 模型进行采样，然后使用
    `postMessage` 将结果返回给主线程。
- en: This covers the basic usage of creating a web worker and making it exchange
    data with the main thread.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分涵盖了创建 Web Worker 并使其与主线程交换数据的基本用法。
- en: Using other Magenta.js models
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用其他 Magenta.js 模型
- en: As always, we cannot cover all models here, but the usage of other models will
    be similar to the examples we've provided. There are a lot of Magenta.js examples
    and demos on the internet, and some are very impressive music-generation web applications.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们无法涵盖所有模型，但其他模型的使用方法将与我们提供的示例类似。网上有许多 Magenta.js 示例和演示，一些非常令人印象深刻的音乐生成网页应用程序。
- en: We provide resources to find examples and demos in the *Further reading* section.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *进一步阅读* 部分提供了查找示例和演示的资源。
- en: Making Magenta.js interact with other apps
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让 Magenta.js 与其他应用程序互动
- en: Because Magenta.js sits in the browser, it is a bit harder to make it interact
    with other applications such as a DAWthan a Magenta application, but as web standards
    evolve, this will become easier.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Magenta.js 运行在浏览器中，它与其他应用程序（如 DAW）的交互要比与 Magenta 应用程序的交互难一些，但随着 Web 标准的发展，这将变得更容易。
- en: Using the Web MIDI API
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Web MIDI API
- en: The Web MIDI API ([www.w3.org/TR/webmidi/](https://www.w3.org/TR/webmidi/))
    is a W3C standard with a specification that isn't very mature, with the status
    of *W3C Working Draft March 17, 2015*. It isn't well supported across browsers,
    with Firefox and Edge having no support at all. It works pretty well in Chrome,
    though, so if you require your users to use that browser, your application might
    work. See the last section, *Further reading*, for more information.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Web MIDI API ([www.w3.org/TR/webmidi/](https://www.w3.org/TR/webmidi/)) 是一个
    W3C 标准，其规范还不成熟，状态为 *W3C 工作草案 2015年3月17日*。它在浏览器中并不被广泛支持，Firefox 和 Edge 完全不支持。不过，它在
    Chrome 中表现得相当不错，因此如果你要求用户使用该浏览器，你的应用可能会正常工作。更多信息请参阅最后一部分 *进一步阅读*。
- en: You can find this code in the `chapter_08_example_06.html` file, in the source
    code of this chapter. There are more comments and content in the source code—you
    should go and check it out.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `chapter_08_example_06.html` 文件中找到这段代码，它在本章的源代码中。源代码中有更多的注释和内容——你应该去查看一下。
- en: 'We''ll write a small example using the Web MIDI API, based on the previous
    example on MusicVAE and the trio sampling. You can copy the previous example and
    add the new content:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个小示例，使用 Web MIDI API，基于之前的 MusicVAE 示例和三重奏采样。你可以复制之前的示例并添加新内容：
- en: 'First, let''s add a `select` element to our page, like this:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们向页面中添加一个 `select` 元素，像这样：
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, in the `startMusicVae` method, let''s initialize the list of available
    MIDI outputs, as follows:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `startMusicVae` 方法中，让我们初始化可用的 MIDI 输出列表，如下所示：
- en: '[PRE32]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we use the Magenta.js `MIDIPlayer` class, which makes usage of the `requestMIDIAccess`
    method easier than directly calling the Web MIDI API. Calling this method will
    return a list of `output` that we add, using the `name` attribute in the selection
    list.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 Magenta.js 的 `MIDIPlayer` 类，它使得使用 `requestMIDIAccess` 方法比直接调用 Web
    MIDI API 更加简便。调用此方法将返回一个 `output` 列表，我们通过选择列表中的 `name` 属性来添加。
- en: 'Finally, in the `sampleMusicVaeTrio` method, we use the player to send the
    MIDI directly to that output, as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `sampleMusicVaeTrio` 方法中，我们使用播放器将 MIDI 直接发送到该输出，如下所示：
- en: '[PRE33]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we only need to set the `outputs` list with the element that was selected
    in the dropdown (if any).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需要用从下拉菜单中选择的元素（如果有）来设置 `outputs` 列表。
- en: 'To test our code, we can use our trusty FluidSynth, using the following:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试我们的代码，我们可以使用我们可靠的 FluidSynth，使用以下命令：
- en: 'Linux: `fluidsynth -a pulseaudio -g 1 PATH_TO_SF2`'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux: `fluidsynth -a pulseaudio -g 1 PATH_TO_SF2`'
- en: 'macOS: `fluidsynth -a coreaudio -g 1 PATH_TO_SF2`'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'macOS: `fluidsynth -a coreaudio -g 1 PATH_TO_SF2`'
- en: 'Windows: `fluidsynth -g 1 PATH_TO_SF2`'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Windows: `fluidsynth -g 1 PATH_TO_SF2`'
- en: FluidSynth should start and show a terminal (notice we removed the `-n` and
    `-i` flags so that we can receive MIDI notes).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: FluidSynth 应该启动并显示一个终端（注意我们移除了 `-n` 和 `-i` 标志，以便接收 MIDI 音符）。
- en: 'Now, let''s open our web application. Once the model is initialized, we should
    see the FluidSynth MIDI input port in the **Select MIDI output**—select drop-down
    list. It should look like this: **Synth input port (17921:0)**. Choose the option,
    and then click on **Sample MusicVAE trio**. You should hear the sound coming from
    FluidSynth.'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们打开我们的Web应用。一旦模型初始化完成，我们应该能够在**选择MIDI输出**的下拉列表中看到FluidSynth MIDI输入端口。它应该是这样的：**合成器输入端口
    (17921:0)**。选择这个选项，然后点击**Sample MusicVAE trio**。你应该能听到来自FluidSynth的声音。
- en: You'll notice that all the notes are played as a piano sequence, even if we
    have three instruments. This is because the `MIDIPlayer` is pretty basic and won't
    send the percussion on the drums channel, as specified in the MIDI specification.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到所有的音符都作为钢琴序列播放，即使我们有三种乐器。这是因为`MIDIPlayer`非常基础，它不会在鼓道上发送打击乐信号，这是MIDI规范中规定的。
- en: Running Magenta.js server side with Node.js
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Node.js中运行Magenta.js的服务器端版本
- en: Magenta.js can also be used server side, using Node.js. Using Node.js is nice
    because you can have the same (or almost the same) code running server side and
    client side. Communication between client and server can be handled using WebSockets.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Magenta.js也可以在服务器端使用，通过Node.js来运行。使用Node.js的好处是，你可以在服务器端和客户端运行相同的（或几乎相同的）代码。客户端和服务器之间的通信可以通过WebSockets来处理。
- en: The WebSocket API ([developer.mozilla.org/en-US/docs/Web/API/WebSockets_API](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API))
    is an API that makes it possible to open **two-way communications** between a
    client and a server. We won't be looking at WebSockets here, but they can be a
    good way of transferring the data back and forth between a server-side Magenta
    process (Magenta.js server side using Node.js, or Magenta in Python) and a client
    application. The easiest way of using WebSockets is to use a framework such as
    Socket.IO ([socket.io/](https://socket.io/)).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket API（[developer.mozilla.org/en-US/docs/Web/API/WebSockets_API](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API)）是一个API，它使得客户端和服务器之间能够进行**双向通信**。我们在这里不会详细讨论WebSockets，但它们可以是一个非常好的方式，用于在服务器端Magenta进程（使用Node.js的Magenta.js或Python中的Magenta）和客户端应用程序之间传输数据。使用WebSockets最简单的方式是使用像Socket.IO这样的框架（[socket.io/](https://socket.io/)）。
- en: Another advantage of using Node.js is that our program is running server side,
    which means it isn't dependent on the browser's implementation. A good example
    of this is that we could use a Node.js package to handle sending MIDI to other
    processes, such as `node-midi` ([www.npmjs.com/package/midi](https://www.npmjs.com/package/midi)),
    which alleviates the necessity of using the Web MIDI API.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Node.js的另一个优点是我们的程序在服务器端运行，这意味着它不依赖于浏览器的实现。一个很好的例子是，我们可以使用Node.js的包来处理向其他进程发送MIDI，例如`node-midi`（[www.npmjs.com/package/midi](https://www.npmjs.com/package/midi)），这样就不需要使用Web
    MIDI API。
- en: 'Let''s show a simple example of Magenta.js running with Node.js. The code shown
    here is similar to what we''ve already covered in JavaScript:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们展示一个Magenta.js与Node.js一起运行的简单示例。这里显示的代码与我们之前在JavaScript中讨论的内容类似：
- en: You can find this code in the `chapter_08_example_07.js` file in the source
    code of this chapter. There are more comments and content in the source code—you
    should go and check it out.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本章的源代码中的`chapter_08_example_07.js`文件中找到这段代码。源代码中有更多的注释和内容——你应该去查看一下。
- en: First, let's install Node.js ([nodejs.org/en/download/](https://nodejs.org/en/download/))
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们安装Node.js（[nodejs.org/en/download/](https://nodejs.org/en/download/)）
- en: 'Then, let''s install Magenta.js, using the `npm` command, which is the Node.js
    dependency manager, like this:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们使用`npm`命令安装Magenta.js，`npm`是Node.js的依赖管理工具，命令如下：
- en: '[PRE34]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will install Magenta.js and its dependencies in the `node_modules` directory.
    When Node.js runs, it looks in this directory to find the script's dependencies,
    for each `require` call.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把Magenta.js及其依赖项安装到`node_modules`目录中。当Node.js运行时，它会在这个目录中查找脚本的依赖项，处理每个`require`调用。
- en: 'We can now create a JavaScript file to sample a sequence, as follows:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个JavaScript文件来采样一个序列，如下所示：
- en: '[PRE35]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This code is similar to the previous examples, the only addition being the `require`
    method, which is used in Node.js to import a dependency module.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与之前的示例相似，唯一的区别是添加了`require`方法，该方法在Node.js中用于导入依赖模块。
- en: 'To execute your Node.js application, use the `node` command (replacing `PATH_TO_JAVASCRIPT_FILE`
    by a proper value), as follows:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要执行你的Node.js应用，请使用`node`命令（将`PATH_TO_JAVASCRIPT_FILE`替换为合适的值），如以下所示：
- en: '[PRE36]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The sample should show on the console because we''ve used `console.log`. You
    will also notice a couple of messages on the console, as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了 `console.log`，样本应该显示在控制台上。你还会注意到控制台上有一些信息，内容如下：
- en: '[PRE37]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This reminds us that Tone.js cannot be run on Node.js, because the Web Audio
    API is implemented client side. It also reminds us that Node.js can use CUDA libraries
    for better performance.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这提醒我们，Tone.js 不能在 Node.js 上运行，因为 Web Audio API 是在客户端实现的。它还提醒我们，Node.js 可以使用
    CUDA 库来提升性能。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've looked at Tensorflow.js and Magenta.js, the JavaScript
    implementations of TensorFlow and Magenta. We've learned that TensorFlow.js is
    GPU accelerated using WebGL and that Magenta.js has a limited set of models available
    that can only be used for generation, not training. We've converted a Python-trained
    model from the previous chapter to a format that TensorFlow.js can load. We've
    also introduced Tone.js and the Web Audio API, which is used by Magenta.js to
    synthesize sound in the browser.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们介绍了 Tensorflow.js 和 Magenta.js，分别是 TensorFlow 和 Magenta 的 JavaScript
    实现。我们了解到 TensorFlow.js 是通过 WebGL 加速的，并且 Magenta.js 仅提供有限的模型集，这些模型只能用于生成，不能用于训练。我们还将上一章中使用
    Python 训练的模型转换为 TensorFlow.js 可加载的格式。我们还介绍了 Tone.js 和 Web Audio API，Magenta.js
    使用它们在浏览器中合成声音。
- en: Then, we've created three music generation web applications. The first application
    used GANSynth to sample short audio notes. By doing so, we've learned how to import
    the required scripts, either using a big ES5 bundle or a smaller, split up, ES6
    bundle. The second application used MusicVAE to sample a trio of instruments,
    with the drum kit, the bass, and the lead, and played the sequence in a loop.
    The third application used both models to generate sequences and audio together
    and introduced the usage of the Web Workers API to offload computations to another
    thread.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了三个音乐生成 web 应用程序。第一个应用使用 GANSynth 采样短音频音符。通过这样做，我们学会了如何导入所需的脚本，可以使用一个大的
    ES5 包，也可以使用一个更小的、拆分的 ES6 包。第二个应用使用 MusicVAE 采样三件乐器，分别是鼓组、贝斯和主旋律，并循环播放该序列。第三个应用同时使用了这两个模型生成序列和音频，并介绍了如何使用
    Web Workers API 将计算任务转移到另一个线程。
- en: Finally, we've talked about how to make Magenta.js interact with other applications.
    We've used the Web MIDI API to send the generated sequences to another synthesizer—for
    example, FluidSynth. We've also used Node.js to run a Magenta.js application server
    side.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了如何使 Magenta.js 与其他应用程序进行交互。我们使用 Web MIDI API 将生成的序列发送到另一个合成器——例如，FluidSynth。我们还使用了
    Node.js 在服务器端运行 Magenta.js 应用程序。
- en: Magenta.js is a great project because it makes it easy to create and share music-generation
    applications using web technologies. There are other ways of making Magenta fit
    in a broader context, such as using Magenta Studio (which makes Magenta run in
    Ableton Live) and using MIDI, which is a good way of controlling all types of
    devices, such as software and hardware synthesizers. We'll be showing those subjects
    in the next chapter.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Magenta.js 是一个很棒的项目，因为它使得使用 web 技术创建和分享音乐生成应用程序变得容易。还有其他方法可以将 Magenta 融入更广泛的应用场景，例如使用
    Magenta Studio（它可以让 Magenta 在 Ableton Live 中运行）和使用 MIDI，这是控制各种设备（如软件和硬件合成器）的好方法。我们将在下一章中展示这些内容。
- en: Questions
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Can a model be trained using Tensorflow.js? Using Magenta.js?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否可以使用 Tensorflow.js 来训练模型？使用 Magenta.js 可以吗？
- en: What does the Web Audio API do, and what is the easiest way of using it?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Web Audio API 的作用是什么，使用它的最简单方法是什么？
- en: What is the generation method in GANSynth? What is the argument that needs to
    be provided?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GANSynth 中的生成方法是什么？需要提供什么参数？
- en: What is the generation method in MusicVAE? How many instruments does it generate?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MusicVAE 中的生成方法是什么？它生成多少种乐器？
- en: Why is the Web Workers API useful in JavaScript?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么 Web Workers API 在 JavaScript 中有用？
- en: Name two ways of sending MIDI from a Magenta.js application to another application.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举两种将 MIDI 从 Magenta.js 应用程序发送到另一个应用程序的方法。
- en: Further reading
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**MagentaMusic.js demos**: A Magenta-maintained list of demos using the various
    models and core classes in Magenta.js ([tensorflow.github.io/magenta-js/music/demos/](https://tensorflow.github.io/magenta-js/music/demos/)).'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MagentaMusic.js 演示**：Magenta 维护的演示列表，展示了如何使用 Magenta.js 中的各种模型和核心类 ([tensorflow.github.io/magenta-js/music/demos/](https://tensorflow.github.io/magenta-js/music/demos/))。'
- en: '**Web apps built with Magenta.js**: A community-driven list of demos using
    Magenta.js, with lots of cool stuff ([magenta.tensorflow.org/demos/web/](https://magenta.tensorflow.org/demos/web/)).'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用Magenta.js构建的Web应用**：一个由社区推动的Magenta.js演示列表，包含许多酷炫的内容（[magenta.tensorflow.org/demos/web/](https://magenta.tensorflow.org/demos/web/)）。'
- en: '**Monica Dinculescu—Why you should build silly things**: Interesting talk on
    the importance of Magenta.js and sharing music-creation applications ([www.youtube.com/watch?v=DkiFjzQgJtg](https://www.youtube.com/watch?v=DkiFjzQgJtg)).'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Monica Dinculescu——为什么你应该构建一些傻乎乎的东西**：关于Magenta.js的重要性以及分享音乐创作应用的有趣演讲（[www.youtube.com/watch?v=DkiFjzQgJtg](https://www.youtube.com/watch?v=DkiFjzQgJtg)）。'
- en: '**Celebrating Johann Sebastian Bach**: A good example of a popular music-generation
    application ([www.google.com/doodles/celebrating-johann-sebastian-bach](https://www.google.com/doodles/celebrating-johann-sebastian-bach)).'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**庆祝约翰·塞巴斯蒂安·巴赫**：一个流行的音乐生成应用的好例子（[www.google.com/doodles/celebrating-johann-sebastian-bach](https://www.google.com/doodles/celebrating-johann-sebastian-bach)）。'
- en: '**WebGL Specifications**: The WebGL specification ([www.khronos.org/registry/webgl/specs/latest/](https://www.khronos.org/registry/webgl/specs/latest/)).'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebGL规范**：WebGL规范（[www.khronos.org/registry/webgl/specs/latest/](https://www.khronos.org/registry/webgl/specs/latest/)）。'
- en: '**Platform and environment**: An interesting read on memory management and
    GPU computations using WebGL in TensorFlow.js ([www.tensorflow.org/js/guide/platform_environment](https://www.tensorflow.org/js/guide/platform_environment)).'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台与环境**：关于在TensorFlow.js中使用WebGL进行内存管理和GPU计算的有趣读物（[www.tensorflow.org/js/guide/platform_environment](https://www.tensorflow.org/js/guide/platform_environment)）。'
- en: '**Web Audio API**: The Web Audio API specification from the W3C ([webaudio.github.io/web-audio-api/](https://webaudio.github.io/web-audio-api/)).'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web Audio API**：来自W3C的Web Audio API规范（[webaudio.github.io/web-audio-api/](https://webaudio.github.io/web-audio-api/)）。'
- en: '**Web Audio API**: An introduction to the Web Audio API ([developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API)).'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web Audio API**：Web Audio API的介绍（[developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API)）。'
- en: '**Web Workers**: The Web Workers API specification from the WHATWG ([html.spec.whatwg.org/multipage/workers.html](https://html.spec.whatwg.org/multipage/workers.html)).'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web Workers**：来自WHATWG的Web Workers API规范（[html.spec.whatwg.org/multipage/workers.html](https://html.spec.whatwg.org/multipage/workers.html)）。'
- en: '**Concurrency model and the event loop**: An introduction to the event loop
    pattern in JavaScript ([developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)).'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发模型与事件循环**：JavaScript中事件循环模式的介绍（[developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)）。'
- en: '**Using Web Workers**: An introduction to the Web Workers API ([developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)).'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用Web Workers**：Web Workers API的介绍（[developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)）。'
- en: '**Web MIDI API**: The Web MIDI API specification for the W3C ([webaudio.github.io/web-midi-api/](https://webaudio.github.io/web-midi-api/)).'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web MIDI API**：W3C的Web MIDI API规范（[webaudio.github.io/web-midi-api/](https://webaudio.github.io/web-midi-api/)）。'
- en: '**Web MIDI (MIDI Support in Web Browsers)**: An introduction to the Web MIDI
    API from the MIDI Association, with examples of applications using it ([www.midi.org/17-the-mma/99-web-midi](https://www.midi.org/17-the-mma/99-web-midi)).'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web MIDI（Web浏览器中的MIDI支持）**：来自MIDI协会的Web MIDI API介绍，带有使用示例的应用程序（[www.midi.org/17-the-mma/99-web-midi](https://www.midi.org/17-the-mma/99-web-midi)）。'
