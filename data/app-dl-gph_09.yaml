- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Building Recommendation Systems Using Graph Deep Learning
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用图神经网络构建推荐系统
- en: '**Recommendation systems** have become an integral part of our digital landscape,
    profoundly shaping how we interact with content, products, and services across
    various industries. From e-commerce giants such as Amazon to streaming platforms
    such as Netflix, and social media networks such as Facebook, these systems play
    a crucial role in enhancing user experience, driving engagement, and boosting
    business outcomes. As we delve into the world of building recommendation systems
    using graph deep learning, it’s essential to understand the evolution of these
    systems and the transformative potential of graph-based approaches.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**推荐系统**已经成为我们数字化生活的重要组成部分，深刻地影响了我们与各种内容、产品和服务的互动方式。从电商巨头亚马逊到流媒体平台Netflix，再到社交媒体网络Facebook，这些系统在提升用户体验、推动互动和提升业务成果方面发挥着至关重要的作用。当我们深入探讨使用图神经网络构建推荐系统时，了解这些系统的发展历程以及基于图的方法的变革潜力至关重要。'
- en: Traditionally, recommendation systems have relied on techniques such as **collaborative
    filtering** ( **CF** ), content-based filtering, and hybrid approaches. While
    these methods have been successful to a certain extent, they often fall short
    in capturing the complex, interconnected nature of user-item interactions and
    the rich contextual information surrounding these interactions. This is where
    graph deep learning enters the picture, offering a paradigm shift in how we approach
    recommendation tasks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，推荐系统依赖于**协同过滤**（**CF**）、基于内容的过滤和混合方法等技术。尽管这些方法在一定程度上取得了成功，但它们往往未能充分捕捉到用户-物品交互的复杂性和互联性，以及围绕这些交互的丰富上下文信息。这就是图神经网络进入的地方，它为我们处理推荐任务提供了一种范式转变。
- en: Graph-based methods in recommendation systems offer numerous advantages, including
    providing a rich multi-modal representation of diverse information types, the
    ability to capture higher-order relationships beyond direct user-item interactions,
    handle data sparsity effectively through information propagation, inductive learning
    capabilities for addressing cold start problems, enhanced interpretability through
    graph structure analysis, and flexibility in incorporating various types of side
    information and heterogeneous data. Collectively, these features enable graph-based
    approaches to provide more comprehensive, accurate, and adaptable recommendations
    by leveraging the complex relationships and structures inherent in user-item interaction
    data and associated contextual information.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 基于图的推荐方法提供了诸多优势，包括能够为多种信息类型提供丰富的多模态表示，捕捉超越直接用户-物品交互的高阶关系，通过信息传播有效处理数据稀疏问题，具备解决冷启动问题的归纳学习能力，通过图结构分析增强可解释性，并且灵活地融入各种类型的辅助信息和异构数据。综合来看，这些特点使得基于图的方法能够通过利用用户-物品交互数据及相关上下文信息中固有的复杂关系和结构，提供更全面、准确和适应性强的推荐。
- en: 'As we progress through this chapter, we’ll explore the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章内容中，我们将探讨以下主题：
- en: Fundamentals of recommendation systems
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐系统的基本原理
- en: Graph structures in recommendation systems
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐系统中的图结构
- en: Graph-based recommendation models
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于图的推荐模型
- en: Training graph deep learning models
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练图神经网络模型
- en: Explainability in graph-based recommendations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于图的推荐系统的可解释性
- en: The **cold** **start problem**
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冷启动问题**'
- en: Fundamentals of recommendation systems
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐系统的基本原理
- en: Recommendation systems, also known as **recommender systems** , are intelligent
    algorithms that are designed to predict and suggest items or content that users
    might find interesting or relevant. These systems analyze patterns in user behavior,
    preferences, and item characteristics to generate personalized recommendations.
    The primary purpose of recommendation systems is to enhance the user experience
    by providing relevant content, increasing user engagement and retention, driving
    sales and conversions in e-commerce platforms, facilitating content discovery
    in large item catalogs, and personalizing services across various domains. Recommendation
    systems play a crucial role in addressing the information overload problem by
    filtering and prioritizing content based on user preferences and behavior.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐系统，也称为 **推荐引擎**，是旨在预测和建议用户可能感兴趣或相关的项目或内容的智能算法。这些系统通过分析用户行为、偏好和项目特征中的模式，生成个性化的推荐。推荐系统的主要目的是通过提供相关内容来提升用户体验，增加用户参与度和留存率，推动电子商务平台的销售和转化，帮助在庞大的项目目录中发现内容，并在各个领域个性化服务。推荐系统在解决信息过载问题中发挥着至关重要的作用，通过根据用户偏好和行为过滤和优先排序内容。
- en: Recommendation systems have become an integral part of our digital experiences,
    influencing our choices in various domains, such as e-commerce, entertainment,
    social media, and more. This section delves into the core concepts, types, and
    evaluation metrics of recommendation systems, providing a solid foundation for
    understanding their role in modern applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐系统已经成为我们数字体验中不可或缺的一部分，影响着我们在电子商务、娱乐、社交媒体等各个领域的选择。本节将深入探讨推荐系统的核心概念、类型和评估指标，为理解其在现代应用中的作用奠定坚实的基础。
- en: Let’s consider a streaming service that’s trying to build a recommendation system
    for its users. The company has user-movie interaction data as well as metadata
    for every single movie available. We’ll look at how we can leverage this data
    to provide better recommendations and increase the net promoter scores and watch
    times of the users effectively.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在考虑一个流媒体服务，它正在为其用户构建一个推荐系统。该公司拥有用户与电影的交互数据以及每部电影的元数据。我们将探讨如何利用这些数据提供更好的推荐，并有效地提高用户的净推荐值和观看时长。
- en: Types of recommendation systems
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推荐系统的类型
- en: 'There are three main types of recommendation systems, each with its unique
    approach to generating recommendations:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐系统主要有三种类型，每种类型都有其独特的推荐生成方法：
- en: '**CF** is based on the premise that users with similar preferences in the past
    will have similar preferences in the future. It utilizes user-item interaction
    data to identify patterns and make predictions. There are two main approaches:
    user-based CF, which recommends items liked by similar users, and item-based CF,
    which recommends items similar to those the user has liked in the past. CF has
    the advantage of capturing complex user preferences and working well with sparse
    data. However, it faces challenges such as the cold start problem for new users
    or items and scalability issues with large datasets.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协同过滤（CF）** 基于这样一个前提：过去有相似偏好的用户，未来也会有相似的偏好。它利用用户与物品的交互数据来识别模式并做出预测。主要有两种方法：基于用户的协同过滤，它会推荐类似用户喜欢的物品；基于物品的协同过滤，它会推荐与用户过去喜欢的物品相似的物品。协同过滤的优势在于能够捕捉复杂的用户偏好，并且在数据稀疏的情况下表现良好。然而，它也面临一些挑战，如新用户或新物品的冷启动问题以及在大数据集中的可扩展性问题。'
- en: In our movie recommendation system, let’s consider a user, Alice, who has rated
    several movies highly, including *The Shawshank Redemption* (5 stars), *Pulp Fiction*
    (4 stars), and *The Godfather* (5 stars). User-based CF would find users with
    similar rating patterns to Alice, such as Bob, who has rated these same movies
    similarly and gave a high rating to *Inception* . So, the system might recommend
    *Inception* to Alice based on Bob’s high rating. Item-based CF, on the other hand,
    would find movies similar to those Alice rated highly. It might determine that
    users who liked *The Shawshank Redemption* also enjoyed *The Green Mile* , leading
    to a recommendation for Alice.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的电影推荐系统中，假设有一位用户 Alice，她给几部电影打了很高的分数，包括 *《肖申克的救赎》*（5星）、*《低俗小说》*（4星）和 *《教父》*（5星）。基于用户的协同过滤（CF）会找到与
    Alice 有相似评分模式的用户，例如 Bob，他给这些电影打的分也很相似，并且给 *《盗梦空间》* 打了高分。因此，系统可能会根据 Bob 的高评分推荐
    *《盗梦空间》* 给 Alice。而基于物品的协同过滤（CF）则会找到与 Alice 高评分的电影相似的电影。它可能会发现喜欢 *《肖申克的救赎》* 的用户也喜欢
    *《绿里奇迹》*，从而向 Alice 推荐这部电影。
- en: '**Content-based filtering** recommends items based on their features and the
    user’s past preferences. It builds a profile for each user and item based on their
    characteristics and uses similarity measures between user profiles and item features
    to generate recommendations. This approach has the advantage of providing explanations
    for recommendations and working well for niche items. However, it has limitations
    in expanding a user’s interests and requires rich item metadata. In our movie
    example, we’d analyze the features of movies Alice likes, such as *The Shawshank
    Redemption* (drama, directed by Frank Darabont, starring Tim Robbins and Morgan
    Freeman, released in 1994) and *The Godfather* (crime/drama, directed by Francis
    Ford Coppola, starring Marlon Brando and Al Pacino, released in 1972). In this
    case, the system might recommend other drama movies from the 1970s or 1990s, or
    films featuring Morgan Freeman or Al Pacino.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于内容的过滤**根据物品的特征和用户过去的偏好推荐物品。它为每个用户和物品构建一个基于其特征的档案，并使用用户档案与物品特征之间的相似度来生成推荐。这种方法的优点是能为推荐提供解释，并且对于小众物品效果良好。然而，它在扩展用户兴趣方面存在局限性，并且需要丰富的物品元数据。在我们的电影示例中，我们会分析Alice喜欢的电影特征，如《肖申克的救赎》（剧情片，由弗兰克·达拉邦特执导，蒂姆·罗宾斯和摩根·弗里曼主演，1994年上映）和《教父》（犯罪/剧情片，由弗朗西斯·福特·科波拉执导，马龙·白兰度和阿尔·帕西诺主演，1972年上映）。在这种情况下，系统可能会推荐其他1970年代或1990年代的剧情电影，或者推荐有摩根·弗里曼或阿尔·帕西诺出演的影片。'
- en: '**Hybrid systems** combine multiple recommendation approaches to leverage their
    strengths and mitigate weaknesses. Common hybrid strategies include weighted approaches
    that combine scores from different recommenders, switching methods that choose
    between different recommenders based on the context, and feature combination techniques
    that use features from different sources as input to a single recommender. Hybrid
    systems often provide better performance but come with increased complexity in
    terms of their design and implementation. In our example, a hybrid approach might
    combine CF and content-based filtering. It could use CF to find similar users
    to Alice and then filter those recommendations based on content features she prefers,
    such as favoring dramas or movies from certain decades.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合系统**结合了多种推荐方法，利用它们的优势并减少其弱点。常见的混合策略包括加权方法，这些方法结合来自不同推荐系统的得分；切换方法，根据上下文选择不同的推荐系统；以及特征组合技术，利用来自不同来源的特征作为单一推荐系统的输入。混合系统通常能提供更好的性能，但在设计和实施方面带来了更大的复杂性。在我们的示例中，混合方法可能会结合协同过滤（CF）和基于内容的过滤。它可以使用CF来找到与Alice相似的用户，然后根据她偏好的内容特征，如偏爱某些年代的电视剧或电影，过滤这些推荐结果。'
- en: '*Table 9.1* provides a comparison of the different types, highlighting their
    key characteristics, advantages, and limitations:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 9.1* 提供了不同类型的比较，突出了它们的关键特征、优点和局限性：'
- en: '| **Feature** | **CF** | **Content-based filtering** | **Hybrid systems** |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **特征** | **协同过滤（CF）** | **基于内容的过滤** | **混合系统** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Data required | User-item interactions | Item features and user preferences
    | Both types of data |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 所需数据 | 用户-物品交互 | 物品特征和用户偏好 | 两种类型的数据 |'
- en: '| Strengths | - Captures user preferences well- Discovers new interests- Works
    with minimal item information | - No cold start problem for items- Can explain
    recommendations- Good for niche items | - Better accuracy- Overcomes limitations
    of individual methods- More robust |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 优点 | - 能很好地捕捉用户偏好 - 发现新兴趣 - 在物品信息最少的情况下有效 | - 物品无冷启动问题 - 可以解释推荐 - 适合小众物品
    | - 更高的准确性 - 克服单一方法的局限性 - 更加稳健 |'
- en: '| Weaknesses | - Cold start problem- Sparsity issues- Limited for new items
    | - Limited serendipity- Requires detailed item features- Over-specialization
    | - Complex implementation- Computationally expensive- Requires more data |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 缺点 | - 冷启动问题 - 稀疏性问题 - 对新物品有限制 | - 限制偶然性 - 需要详细的物品特征 - 过度专门化 | - 实现复杂 - 计算开销大
    - 需要更多数据 |'
- en: '| Best use cases | E-commerce, social media | News articles, specialized content
    | Large-scale platforms, streaming services |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 最佳使用场景 | 电子商务、社交媒体 | 新闻文章、专业内容 | 大型平台、流媒体服务 |'
- en: Table 9.1 – Comparing different recommendation system types
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.1 – 不同推荐系统类型的比较
- en: Key metrics and evaluation
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键指标与评估
- en: Evaluating the performance of recommendation systems is crucial for understanding
    their effectiveness and guiding improvements. Several metrics and evaluation techniques
    are commonly used.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 评估推荐系统的性能对于理解其有效性和指导改进至关重要。常用的几个指标和评估技术包括：
- en: Accuracy metrics
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准确性指标
- en: 'This is how we define these commonly used metrics:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们定义这些常用度量的方法：
- en: '**Precision** measures the proportion of relevant items among the recommended
    items:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**精度**衡量推荐项中相关项所占的比例：'
- en: Precision = (Number of relevant recommendations) / (Total number of recommendations)
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精度 = （相关推荐项的数量） / （推荐项的总数）
- en: '**Recall** measures the proportion of relevant items that were successfully
    recommended:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**召回率**衡量成功推荐的相关项所占的比例：'
- en: Recall = (Number of relevant recommendations) / (Total number of relevant items)
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 召回率 = （相关推荐项的数量） / （相关项的总数）
- en: '**F1 score** is the harmonic mean of precision and recall, providing a balanced
    measure:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**F1 得分**是精度和召回率的调和均值，提供一个平衡的衡量：'
- en: F1 = 2 × (Precision × Recall) / (Precision + Recall)
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: F1 = 2 × (精度 × 召回率) / (精度 + 召回率)
- en: 'The **mean average precision** ( **MAP** ) calculates the mean of the average
    precision scores for each user:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**均值平均精度**（**MAP**）计算每个用户的平均精度分数的均值：'
- en: '![<mml:math  ><mml:mi>M</mml:mi><mml:mi>A</mml:mi><mml:mi>P</mml:mi><mml:mi
    mathvariant="normal"> </mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi>U</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfrac><mml:mo>⋅</mml:mo><mml:mi
    mathvariant="normal"> </mml:mi><mml:mi mathvariant="normal">Σ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>A</mml:mi><mml:mi>P</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/217.png)
    , where we have the following:'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math  ><mml:mi>M</mml:mi><mml:mi>A</mml:mi><mml:mi>P</mml:mi><mml:mi
    mathvariant="normal"> </mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="normal"> </mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi>U</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfrac><mml:mo>⋅</mml:mo><mml:mi
    mathvariant="normal"> </mml:mi><mml:mi mathvariant="normal">Σ</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>A</mml:mi><mml:mi>P</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/217.png)，其中我们有以下内容：'
- en: '![<mml:math  ><mml:mfenced open="|" close="|" separators="|"><mml:mrow><mml:mi>U</mml:mi></mml:mrow></mml:mfenced><mml:mi> </mml:mi></mml:math>](img/218.png)
    is the number of users.'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math  ><mml:mfenced open="|" close="|" separators="|"><mml:mrow><mml:mi>U</mml:mi></mml:r</mml:mrow></mml:mfenced><mml:mi> </mml:mi></mml:math>](img/218.png)
    是用户的数量。'
- en: '![<mml:math  ><mml:mi>A</mml:mi><mml:mi>P</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/219.png)
    is the average precision of the user, ![<mml:math  ><mml:mi>u</mml:mi></mml:math>](img/220.png)
    .'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math  ><mml:mi>A</mml:mi><mml:mi>P</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/219.png)
    是该用户的平均精度，![<mml:math  ><mml:mi>u</mml:mi></mml:math>](img/220.png)。'
- en: '![<mml:math  ><mml:mi>A</mml:mi><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">Σ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>P</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced><mml:mo>×</mml:mo><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/221.png)
    / number of relevant items'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math  ><mml:mi>A</mml:mi><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">Σ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>P</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced><mml:mo>×</mml:mo><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/221.png)
    / 相关项的数量'
- en: '![<mml:math  ><mml:mi>P</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/222.png)
    is the precision at the cutoff, ![<mml:math  ><mml:mi>k</mml:mi></mml:math>](img/223.png)
    .'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math  ><mml:mi>P</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/222.png)
    是截断点的精度，![<mml:math  ><mml:mi>k</mml:mi></mml:math>](img/223.png)。'
- en: '![<mml:math  ><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/224.png)
    is the indicator function (1 if item ![<math ><mrow><mi>k</mi></mrow></math>](img/225.png)
    is relevant, 0 otherwise).'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math  ><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/224.png)
    是指示函数（如果项![<math ><mrow><mi>k</mi></mrow></math>](img/225.png) 相关则为1，否则为0）。'
- en: 'The **normalized discounted cumulative gain** ( **NDCG** ) measures the quality
    of ranking while taking into account the position of relevant items in the recommendation
    list:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规范化折扣累积增益**（**NDCG**）衡量排名的质量，同时考虑推荐列表中相关项的位置：'
- en: '![<math ><mrow><mrow><mi>N</mi><mi>D</mi><mi>C</mi><mi>G</mi><mo>=</mo><mi>D</mi><mi>C</mi><mi>G</mi><mspace
    width="0.25em" /><mo>/</mo><mspace width="0.25em" /><mi>I</mi><mi>D</mi><mi>C</mi><mi>G</mi></mrow></mrow></math>](img/226.png)
    , where we have the following:'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<math ><mrow><mrow><mi>N</mi><mi>D</mi><mi>C</mi><mi>G</mi><mo>=</mo><mi>D</mi><mi>C</mi><mi>G</mi><mspace
    width="0.25em" /><mo>/</mo><mspace width="0.25em" /><mi>I</mi><mi>D</mi><mi>C</mi><mi>G</mi></mrow></mrow></math>](img/226.png)，其中我们有以下内容：'
- en: '![<mml:math  ><mml:mi>D</mml:mi><mml:mi>C</mml:mi><mml:mi>G</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>D</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>n</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi
    mathvariant="normal"> </mml:mi><mml:mi>C</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mi>u</mml:mi><mml:mi>l</mml:mi><mml:mi>a</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi><mml:mi
    mathvariant="normal"> </mml:mi><mml:mi>G</mml:mi><mml:mi>a</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">Σ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:math>](img/227.png)'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_IMG
  zh: '![<mml:math  ><mml:mi>D</mml:mi><mml:mi>C</mml:mi><mml:mi>G</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>D</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>n</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi
    mathvariant="normal"> </mml:mi><mml:mi>C</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mi>u</mml:mi><mml:mi>l</mml:mi><mml:mi>a</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi><mml:mi
    mathvariant="normal"> </mml:mi><mml:mi>G</mml:mi><mml:mi>a</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi
    mathvariant="normal">Σ</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi
    mathvariant="normal">log</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>⁡</mml:mo><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:math>](img/227.png)'
- en: '![<math ><mrow><mrow><mi>I</mi><mi>D</mi><mi>C</mi><mi>G</mi></mrow></mrow></math>](img/228.png)
    is the ideal ![<math ><mrow><mrow><mi>D</mi><mi>C</mi><mi>G</mi></mrow></mrow></math>](img/229.png)
    (max possible ![<mml:math  ><mml:mi>D</mml:mi><mml:mi>C</mml:mi><mml:mi>G</mml:mi></mml:math>](img/230.png)
    ).'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<math ><mrow><mrow><mi>I</mi><mi>D</mi><mi>C</mi><mi>G</mi></mrow></mrow></math>](img/228.png)
    是理想的 ![<math ><mrow><mrow><mi>D</mi><mi>C</mi><mi>G</mi></mrow></mrow></math>](img/229.png)（最大可能的
    ![<mml:math  ><mml:mi>D</mml:mi><mml:mi>C</mml:mi><mml:mi>G</mml:mi></mml:math>](img/230.png)）。'
- en: '![<mml:math  ><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/231.png)
    is the relevance score of the item at position ![<mml:math  ><mml:mi>i</mml:mi><mml:mo>.</mml:mo></mml:math>](img/232.png)'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_IMG
  zh: '![<mml:math  ><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/231.png)
    是位置 ![<mml:math  ><mml:mi>i</mml:mi><mml:mo>.</mml:mo></mml:math>](img/232.png)
    上项目的相关性得分。'
- en: '![<mml:math  ><mml:mi>i</mml:mi></mml:math>](img/195.png) is the position in
    the ranked list.'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math  ><mml:mi>i</mml:mi></mml:math>](img/195.png) 是排名列表中的位置。'
- en: Assuming we recommend five movies to Alice, and she ends up liking three of
    them, the precision would be 3/5 = 0.6 or 60%. If there were 10 movies in total
    that Alice would have liked, the recall would be 3/10 = 0.3 or 30%. The F1 score,
    which provides a balanced measure, would be approximately 0.4 or 40% in this case.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们向爱丽丝推荐了五部电影，她最终喜欢了其中三部，那么精度将为 3/5 = 0.6 或 60%。如果爱丽丝总共会喜欢10部电影，那么召回率为 3/10
    = 0.3 或 30%。F1 分数作为一种平衡度量，在这种情况下大约为 0.4 或 40%。
- en: Error metrics
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误度量
- en: 'Error metrics often measure the average difference between predicted and actual
    ratings, such as the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 错误度量通常衡量预测评分与实际评分之间的平均差异，例如以下情况：
- en: 'The **mean absolute error** ( **MAE** ) measures the average absolute difference
    between predicted and actual ratings:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**均方误差**（**MAE**）衡量预测评分与实际评分之间的平均绝对差异：'
- en: '![<math ><mrow><mrow><mi>M</mi><mi>A</mi><mi>E</mi><mo>=</mo><mi mathvariant="normal">Σ</mi><mfenced
    open="|" close="|"><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">c</mi><mi
    mathvariant="normal">t</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">a</mi><mi
    mathvariant="normal">l</mi><mo>−</mo><mi mathvariant="normal">p</mi><mi mathvariant="normal">r</mi><mi
    mathvariant="normal">e</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi
    mathvariant="normal">c</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">d</mi></mrow></mfenced><mo>/</mo><mi>n</mi></mrow></mrow></math>](img/234.png)
    , where ![<mml:math  ><mml:mi>n</mml:mi></mml:math>](img/216.png) is the number
    of predictions'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<math ><mrow><mrow><mi>M</mi><mi>A</mi><mi>E</mi><mo>=</mo><mi mathvariant="normal">Σ</mi><mfenced
    open="|" close="|"><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">c</mi><mi
    mathvariant="normal">t</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">a</mi><mi
    mathvariant="normal">l</mi><mo>−</mo><mi mathvariant="normal">p</mi><mi mathvariant="normal">r</mi><mi
    mathvariant="normal">e</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi
    mathvariant="normal">c</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">d</mi></mrow></mfenced><mo>/</mo><mi>n</mi></mrow></mrow></math>](img/234.png)，其中
    ![<mml:math  ><mml:mi>n</mml:mi></mml:math>](img/216.png) 是预测的数量'
- en: 'The **root mean squared error** ( **RMSE** ) is similar to MAE but penalizes
    large errors more heavily:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**均方根误差**（**RMSE**）与 MAE 相似，但对大误差的惩罚更加严格：'
- en: '![<mml:math  ><mml:mi>R</mml:mi><mml:mi>M</mml:mi><mml:mi>S</mml:mi><mml:mi>E</mml:mi><mml:mo>=</mml:mo><mml:mo>√</mml:mo><mml:mo>(</mml:mo><mml:mi
    mathvariant="normal">Σ</mml:mi><mml:mo>(</mml:mo><mml:mi mathvariant="normal">a</mml:mi><mml:mi
    mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi
    mathvariant="normal">u</mml:mi><mml:mi mathvariant="normal">a</mml:mi><mml:mi
    mathvariant="normal">l</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="normal">p</mml:mi><mml:mi
    mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi
    mathvariant="normal">d</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi
    mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi
    mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">d</mml:mi><mml:msup><mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>/</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/236.png)'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_IMG
  zh: '![<mml:math  ><mml:mi>R</mml:mi><mml:mi>M</mml:mi><mml:mi>S</mml:mi><mml:mi>E</mml:mi><mml:mo>=</mml:mo><mml:mo>√</mml:mo><mml:mo>(</mml:mo><mml:mi
    mathvariant="normal">Σ</mml:mi><mml:mo>(</mml:mo><mml:mi mathvariant="normal">a</mml:mi><mml:mi
    mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi
    mathvariant="normal">u</mml:mi><mml:mi mathvariant="normal">a</mml:mi><mml:mi
    mathvariant="normal">l</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="normal">p</mml:mi><mml:mi
    mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi
    mathvariant="normal">d</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi
    mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi
    mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">d</mml:mi><mml:msup><mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>/</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/236.png)'
- en: For example, if we predicted ratings for five movies and the average difference
    between our predictions and Alice’s actual ratings was 0.42 stars, this would
    be our MAE. This suggests that, on average, our predictions are off by about 0.42
    stars.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们为五部电影预测了评分，且我们预测与 Alice 实际评分之间的平均差距为 0.42 星，这就是我们的 MAE。这表明，平均而言，我们的预测偏差大约是
    0.42 星。
- en: Coverage, diversity, and serendipity
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖率、多样性和意外性
- en: Coverage metrics assess the system’s ability to recommend a wide range of items.
    **Item coverage** measures the percentage of items in the catalog that the system
    can recommend, while **user coverage** indicates the percentage of users for whom
    the system can generate recommendations. In our movie system, we might measure
    what percentage of the 3,000 movies in our catalog we’re able to recommend (item
    coverage) and what percentage of our 1,000 users receive recommendations ( user
    coverage).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率指标评估系统推荐广泛物品的能力。**物品覆盖率**衡量系统能够推荐的目录中物品的百分比，而**用户覆盖率**则表示系统能够为多少用户生成推荐。在我们的电影系统中，我们可能会衡量我们能够推荐目录中
    3,000 部电影的百分比（物品覆盖率），以及我们 1,000 个用户中有多少收到推荐（用户覆盖率）。
- en: 'Meanwhile, diversity metrics evaluate the variety (or dissimilarity) among
    recommended items, ensuring users receive a range of suggestions rather than similar
    ones. **Serendipity** , on the other hand, assesses the system’s ability to provide
    unexpected yet relevant recommendations, creating pleasant surprises for users.
    It combines elements of unexpectedness and relevance, often measured through unexpectedness
    scores and relevance evaluations. While related, diversity and serendipity are
    distinct: diverse recommendations may not always be serendipitous, and serendipitous
    recommendations often contribute to diversity but not vice versa.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，多样性指标评估推荐项目之间的多样性（或不相似性），确保用户收到的建议是多样的，而不是相似的。另一方面，**意外性**则评估系统提供意想不到但相关的推荐的能力，为用户创造愉悦的惊喜。它结合了意外性和相关性两个元素，通常通过意外性得分和相关性评估来衡量。虽然两者相关，但多样性和意外性是不同的：多样化的推荐不一定总是意外的，意外的推荐通常会增加多样性，但反之则不然。
- en: These metrics are essential for creating a balanced recommendation system that
    offers varied, interesting, and delightfully unexpected suggestions to users (for
    more on this topic, see [https://doi.org/10.1145/2926720](https://doi.org/10.1145/2926720)
    ).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指标对于创建一个平衡的推荐系统至关重要，该系统能够为用户提供多样化、有趣且令人惊喜的推荐（更多内容请参见 [https://doi.org/10.1145/2926720](https://doi.org/10.1145/2926720)
    ）。
- en: A/B testing and user feedback
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A/B 测试和用户反馈
- en: While offline metrics provide valuable insights, real-world performance is best
    evaluated through **A/B testing** and **user feedback** . A/B testing involves
    comparing two versions of the recommendation system with real users and measuring
    key performance indicators such as click-through rate, conversion rate, or user
    engagement. User feedback, both explicit (through ratings or surveys) and implicit
    (through clicks or purchase behavior), is crucial for continuously improving and
    validating the recommendation system. Long-term user satisfaction, which is measured
    through user retention and engagement metrics, is also essential for assessing
    the impact of recommendations on user trust and platform loyalty.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管离线指标提供了有价值的见解，但实际表现最好通过**A/B 测试**和**用户反馈**来评估。A/B 测试涉及通过与真实用户比较两个版本的推荐系统，并衡量关键绩效指标，如点击率、转化率或用户参与度。用户反馈，无论是显式（通过评分或调查）还是隐式（通过点击或购买行为），对于持续改进和验证推荐系统至关重要。长期的用户满意度，通过用户留存率和参与度指标来衡量，也是评估推荐对用户信任和平台忠诚度影响的重要因素。
- en: Evaluating recommendation systems requires a holistic approach that considers
    both offline metrics and real-world performance. As recommendation systems become
    more sophisticated, especially with the integration of graph deep learning techniques,
    evaluation methods continue to evolve to capture the nuanced aspects of recommendation
    quality and user satisfaction.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 评估推荐系统需要一种整体性的方法，既考虑离线指标，也考虑实际表现。随着推荐系统的日益复杂，尤其是图深度学习技术的整合，评估方法不断发展，以捕捉推荐质量和用户满意度的细微方面。
- en: Graph structures in recommendation systems
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐系统中的图结构
- en: Graph structures have emerged as a powerful paradigm for modeling complex relationships
    in recommendation systems. By representing users, items, and their interactions
    as nodes and edges in a graph, we can capture rich, multi-dimensional information
    that traditional matrix-based approaches often miss.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图结构已成为建模推荐系统中复杂关系的强大范式。通过将用户、项目及其交互表示为图中的节点和边缘，我们可以捕获传统基于矩阵的方法常常忽略的丰富、多维的信息。
- en: User-item interaction graphs
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户-项目交互图
- en: The foundation of graph-based recommendation systems is the **user-item interaction
    graph** . In this structure, users and items are represented as *nodes* , while
    interactions (such as ratings, views, or purchases) form *edges* between them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 基于图的推荐系统的基础是**用户-项目交互图**。在这个结构中，用户和项目被表示为*节点*，而交互（例如评分、观看或购买）则形成它们之间的*边缘*。
- en: 'For a movie recommendation system, the graph might look like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于电影推荐系统，图可能如下所示：
- en: '**Nodes** : Users (U1, U2, U3…) and movies (M1, M2, M3…)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点** ：用户（U1，U2，U3……）和电影（M1，M2，M3……）'
- en: '**Edges** : Ratings or views (for example, U1 -> M1 with a weight of 4 stars)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边缘** ：评分或观看（例如，U1 -> M1，权重为 4 星）'
- en: 'This simple structure already allows for a more nuanced analysis than a traditional
    user-item matrix. For example, we can easily identify the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的结构已经可以进行比传统用户-项目矩阵更细致的分析。例如，我们可以轻松识别以下内容：
- en: Popular movies (nodes with many incoming edges)
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流行电影（有许多入边的节点）
- en: Active users (nodes with many outgoing edges)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活跃用户（具有许多出边的节点）
- en: Similar users or movies (nodes with similar edge patterns)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相似的用户或电影（具有相似边缘模式的节点）
- en: Consider user U1 who has watched and rated movies M1 (4 stars), M2 (3 stars),
    and M3 (5 stars). To recommend a new movie to U1, we can traverse the graph to
    find users with similar rating patterns and suggest movies they’ve enjoyed that
    U1 hasn’t seen yet.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户 U1 已观看并评价过电影 M1（4 星）、M2（3 星）和 M3（5 星）。为了向 U1 推荐新电影，我们可以遍历图，找到评分模式相似的用户，推荐他们喜欢但
    U1 尚未观看的电影。
- en: Incorporating side information
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 融入附加信息
- en: 'Real-world recommendation systems often have access to additional information
    beyond just user-item interactions. Graph structures excel at incorporating this
    side information seamlessly. For movie recommendations, we might enhance our graph
    with the following aspects:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界的推荐系统通常可以访问超出用户-项目交互的数据。图结构擅长无缝地整合这些附加信息。在电影推荐中，我们可能会通过以下方面来增强我们的图：
- en: '**Movie attributes** :'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电影属性**：'
- en: Genres (action, comedy, drama, and so on)
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型（动作、喜剧、剧情等）
- en: Directors
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导演
- en: Actors
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员
- en: Release year
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上映年份
- en: '**User attributes** :'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户属性**：'
- en: Age
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 年龄
- en: Gender
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性别
- en: Location
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置
- en: '**Social connections** :'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社交连接**：'
- en: Friend relationships between users
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户之间的好友关系
- en: 'These additional nodes and edges create a heterogeneous graph, where different
    types of nodes and relationships coexist. This rich structure allows for more
    sophisticated recommendation algorithms. Let’s expand on our previous example.
    Now, movie M1 has additional connections:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些额外的节点和边缘创建了一个异构图，其中不同类型的节点和关系共存。这种丰富的结构使得更复杂的推荐算法成为可能。让我们扩展一下之前的例子。现在，电影 M1
    有了额外的连接：
- en: '**Genre** : Action'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型**：动作'
- en: '**Director** : D1'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导演**：D1'
- en: '**Actors** : A1, A2'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**演员**：A1, A2'
- en: 'User U1 is connected to the following aspects:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 用户 U1 与以下方面相关联：
- en: '**Age** **group** : 25-34'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**年龄** **组**：25-34'
- en: '**Location** : New York'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置**：纽约'
- en: By traversing this enhanced graph, we can make more nuanced recommendations.
    For instance, we might suggest an action movie directed by D1 that’s popular among
    U1’s age group in New York, even if it doesn’t have a direct connection to U1’s
    previously watched movies.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遍历这个增强后的图，我们可以做出更细致的推荐。例如，我们可以推荐一部由 D1 导演的动作片，这部片子在 U1 所在的纽约地区的同龄人群体中很受欢迎，即使它与
    U1 之前观看的电影没有直接关联。
- en: Temporal graphs
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间图
- en: Time is a crucial factor in recommendation systems, especially for domains such
    as movies, where preferences can change rapidly. **Temporal graphs** incorporate
    time information into the graph structure.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 时间是推荐系统中的一个关键因素，尤其是对于电影这样的领域，偏好变化可能非常迅速。**时间图**将时间信息融入图结构。
- en: 'There are several ways to represent time in a graph:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以在图中表示时间：
- en: '**Time-stamped edges** : Each interaction edge includes a timestamp'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间戳边缘**：每个交互边缘都包含一个时间戳'
- en: '**Time-based node splitting** : Create multiple nodes for the same user or
    item at different time points'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于时间的节点拆分**：为同一用户或项目在不同时间点创建多个节点'
- en: '**Dynamic graphs** : The graph structure itself evolves, with nodes and edges
    appearing or disappearing'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态图**：图结构本身会演变，节点和边缘会出现或消失'
- en: 'For movie recommendations, a temporal graph can capture the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于电影推荐，时间图可以捕捉以下内容：
- en: Changes in user preferences over time
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户偏好的变化
- en: The life cycle of movie popularity
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电影流行度的生命周期
- en: Seasonal trends in viewing habits
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观看习惯的季节性趋势
- en: Consider a user, U1, who watched mostly comedies in 2020 but shifted toward
    dramas in 2021. A temporal graph would preserve this information, allowing the
    recommendation system to prioritize recent preferences while still considering
    long-term patterns.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户 U1 在 2020 年主要观看喜剧片，但在 2021 年转向观看剧情片。时间图会保留这一信息，使推荐系统能够优先考虑用户最近的偏好，同时仍然考虑长期模式。
- en: 'We might represent this as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能这样表示：
- en: '[PRE0]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This structure enables sequential recommendation, where the system suggests
    the next movie based on the user’s recent viewing history and overall trends.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构使得顺序推荐成为可能，系统可以根据用户最近的观看历史和整体趋势推荐下一部电影。
- en: Multi-relational graphs
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多关系图
- en: In complex domains such as movie recommendations, different types of relationships
    often coexist. **Multi-relational graphs** allow us to represent these varied
    connections explicitly.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在电影推荐等复杂领域中，不同类型的关系常常共存。**多关系图**使我们能够显式地表示这些多样化的连接。
- en: 'For movies, we might have these relationships:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于电影，我们可能有以下几种关系：
- en: '**User-movie** : **"rated"** , **"watched"** , and **"added** **to wishlist"**'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户-电影** : **"已评分"** , **"已观看"** , 和 **"已加入心愿单"**'
- en: '**User-user** : **"is friends with"** and **"has similar** **taste to"**'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户-用户** : **"是朋友"** 和 **"有相似的品味"**'
- en: '**Movie-movie** : **"has same genre"** , **"has same director"** , and **"is**
    **sequel to"**'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电影-电影** : **"有相同的类型"** , **"有相同的导演"** , 和 **"是续集"**'
- en: 'Each relationship can have its own semantics and importance in the recommendation
    process. Here’s an example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 每种关系在推荐过程中可以具有不同的语义和重要性。以下是一个例子：
- en: '[PRE1]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This multi-relational structure allows for sophisticated path-based recommendations.
    For instance, we might recommend M2 to U1 because of the following reasons:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这种多关系结构使得基于路径的推荐变得更加复杂。例如，我们可能会因为以下原因推荐M2给U1：
- en: U1’s friend, U2, rated it highly.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: U1的朋友U2给予了高度评价。
- en: It shares a director with M1, which U1 loved.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与U1喜欢的M1有相同的导演。
- en: By leveraging these complex relationships, multi-relational graphs enable more
    contextual and explainable recommendations.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用这些复杂的关系，多关系图使得推荐更加具备上下文性和可解释性。
- en: Graph structures excel at capturing complex relationships, incorporating diverse
    information sources, and modeling temporal dynamics. As we’ll see in subsequent
    sections, these rich graph structures form the foundation for sophisticated deep
    learning models that can generate highly personalized and accurate recommendations.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图结构在捕捉复杂关系、整合多样化信息源和建模时间动态方面表现出色。正如我们在后续章节中所看到的，这些丰富的图结构为复杂的深度学习模型奠定了基础，能够生成高度个性化且精准的推荐。
- en: Graph-based recommendation models
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于图的推荐模型
- en: Graph-based recommendation models have emerged as powerful tools for capturing
    complex relationships between users and items in recommendation systems. These
    models leverage the rich structural information inherent in user-item interaction
    graphs to generate more accurate and personalized recommendations. In this section,
    we’ll explore three major categories of graph-based recommendation models, starting
    with **matrix factorization** ( **MF** ) with graph regularization.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 基于图的推荐模型作为捕捉用户与项目之间复杂关系的强大工具，已在推荐系统中崭露头角。这些模型利用用户-项目交互图中固有的丰富结构信息，生成更加准确和个性化的推荐。在本节中，我们将探讨三种主要的基于图的推荐模型，从带有图正则化的**矩阵分解**（**MF**）开始。
- en: MF with graph regularization
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有图正则化的MF
- en: '**MF** is a fundamental technique in CF, and its integration with graph structures
    has led to significant improvements in recommendation quality. **Graph regularization**
    in MF models helps to incorporate the structural information of the user-item
    interaction graph into the learning process.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**MF**是CF中的一种基本技术，它与图结构的结合使得推荐质量得到了显著提升。**图正则化**在MF模型中的作用是帮助将用户-项目交互图的结构信息纳入学习过程中。'
- en: The basic idea is to add a regularization term to the traditional MF objective
    function that encourages connected nodes in the graph to have similar latent representations.
    This approach helps to capture the local structure of the user-item graph and
    can lead to more accurate recommendations.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思路是向传统MF目标函数中添加一个正则化项，鼓励图中相连的节点具有相似的潜在表示。这种方法有助于捕捉用户-项目图的局部结构，并能产生更准确的推荐。
- en: For movie recommendations, consider a scenario where we have a user-item graph
    with users and movies as nodes, and ratings as edges. The graph regularization
    term would encourage users who have rated similar movies to have similar latent
    factors, and movies that have been rated similarly to also have similar latent
    factors.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于电影推荐，考虑一个场景，其中用户和电影是节点，评分是边。图正则化项会鼓励那些评分相似的用户拥有相似的潜在因素，并且那些被相似评分的电影也会拥有相似的潜在因素。
- en: 'A typical objective function for MF with graph regularization might look like
    this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 带有图正则化的MF的典型目标函数可能如下所示：
- en: '![<math  display="block"><mrow><mrow><mi>L</mi><mspace width="0.25em" /><mo>=</mo><mspace
    width="0.25em" /><msub><mi mathvariant="normal">Σ</mi><mrow><mfenced open="("
    close=")"><mrow><mi>u</mi><mo>,</mo><mi>i</mi></mrow></mfenced><mspace width="0.25em"
    /><mi mathvariant="normal">ϵ</mi><mspace width="0.25em" /><mi>o</mi></mrow></msub><msup><mfenced
    open="(" close=")"><mrow><msub><mi>r</mi><mrow><mi>u</mi><mi>i</mi><mspace width="0.25em"
    /></mrow></msub><mo>−</mo><mspace width="0.25em" /><msubsup><mi>p</mi><mi>u</mi><mi>T</mi></msubsup><msub><mi>q</mi><mi>i</mi></msub></mrow></mfenced><mn>2</mn></msup><mspace
    width="0.25em" /><mo>+</mo><mspace width="0.25em" /><mi>λ</mi><mfenced open="("
    close=")"><mrow><mo>∥</mo><mi>P</mi><msubsup><mo>∥</mo><mi>F</mi><mn>2</mn></msubsup><mspace
    width="0.25em" /><mo>+</mo><mspace width="0.25em" /><mo>∥</mo><mi>Q</mi><msubsup><mo>∥</mo><mi>F</mi><mn>2</mn></msubsup></mrow></mfenced><mspace
    width="0.25em" /><mo>+</mo><mspace width="0.25em" /><mi>α</mi><mspace width="0.25em"
    /><msub><mi mathvariant="normal">Σ</mi><mrow><mfenced open="(" close=")"><mrow><mi>u</mi><mo>,</mo><mi>v</mi></mrow></mfenced><mspace
    width="0.25em" /><mi mathvariant="normal">ϵ</mi><mspace width="0.25em" /><msub><mi
    mathvariant="normal">ℇ</mi><mi>u</mi></msub></mrow></msub><mo>∥</mo><msub><mi>p</mi><mi>u</mi></msub><mo>−</mo><mspace
    width="0.25em" /><msub><mi>p</mi><mi>v</mi></msub><msup><mo>∥</mo><mn>2</mn></msup><mspace
    width="0.25em" /><mo>+</mo><mspace width="0.25em" /><mi>β</mi><mspace width="0.25em"
    /><msub><mi mathvariant="normal">Σ</mi><mrow><mfenced open="(" close=")"><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></mfenced><mspace
    width="0.25em" /><mi mathvariant="normal">ϵ</mi><mspace width="0.25em" /><msub><mi
    mathvariant="normal">ℇ</mi><mi>i</mi></msub></mrow></msub><mspace width="0.25em"
    /><mo>∥</mo><msub><mi>q</mi><mi>i</mi></msub><mo>−</mo><mspace width="0.25em"
    /><msub><mi>q</mi><mi>j</mi></msub><msup><mo>∥</mo><mn>2</mn></msup></mrow></mrow></math>](img/237.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![<math  display="block"><mrow><mrow><mi>L</mi><mspace width="0.25em" /><mo>=</mo><mspace
    width="0.25em" /><msub><mi mathvariant="normal">Σ</mi><mrow><mfenced open="("
    close=")"><mrow><mi>u</mi><mo>,</mo><mi>i</mi></mrow></mfenced><mspace width="0.25em"
    /><mi mathvariant="normal">ϵ</mi><mspace width="0.25em" /><mi>o</mi></mrow></msub><msup><mfenced
    open="(" close=")"><mrow><msub><mi>r</mi><mrow><mi>u</mi><mi>i</mi><mspace width="0.25em"
    /></mrow></msub><mo>−</mo><mspace width="0.25em" /><msubsup><mi>p</mi><mi>u</mi><mi>T</mi></msubsup><msub><mi>q</mi><mi>i</mi></msub></mrow></mfenced><mn>2</mn></msup><mspace
    width="0.25em" /><mo>+</mo><mspace width="0.25em" /><mi>λ</mi><mfenced open="("
    close=")"><mrow><mo>∥</mo><mi>P</mi><msubsup><mo>∥</mo><mi>F</mi><mn>2</mn></msubsup><mspace
    width="0.25em" /><mo>+</mo><mspace width="0.25em" /><mo>∥</mo><mi>Q</mi><msubsup><mo>∥</mo><mi>F</mi><mn>2</mn></msubsup></mrow></mfenced><mspace
    width="0.25em" /><mo>+</mo><mspace width="0.25em" /><mi>α</mi><mspace width="0.25em"
    /><msub><mi mathvariant="normal">Σ</mi><mrow><mfenced open="(" close=")"><mrow><mi>u</mi><mo>,</mo><mi>v</mi></mrow></mfenced><mspace
    width="0.25em" /><mi mathvariant="normal">ϵ</mi><mspace width="0.25em" /><msub><mi
    mathvariant="normal">ℇ</mi><mi>u</mi></msub></mrow></msub><mo>∥</mo><msub><mi>p</mi><mi>u</mi></msub><mo>−</mo><mspace
    width="0.25em" /><msub><mi>p</mi><mi>v</mi></msub><msup><mo>∥</mo><mn>2</mn></msup><mspace
    width="0.25em" /><mo>+</mo><mspace width="0.25em" /><mi>β</mi><mspace width="0.25em"
    /><msub><mi mathvariant="normal">Σ</mi><mrow><mfenced open="(" close=")"><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></mfenced><mspace
    width="0.25em" /><mi mathvariant="normal">ϵ</mi><mspace width="0.25em" /><msub><mi
    mathvariant="normal">ℇ</mi><mi>i</mi></msub></mrow></msub><mspace width="0.25em"
    /><mo>∥</mo><msub><mi>q</mi><mi>i</mi></msub><mo>−</mo><mspace width="0.25em"
    /><msub><mi>q</mi><mi>j</mi></msub><msup><mo>∥</mo><mn>2</mn></msup></mrow></mrow></math>](img/237.png)'
- en: Here, ![<mml:math  ><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub><mml:mi> </mml:mi></mml:math>](img/238.png)
    and ![<mml:math  ><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi> </mml:mi></mml:math>](img/239.png)
    are the latent factors for the user, ![<mml:math  ><mml:mi> </mml:mi><mml:mi>u</mml:mi></mml:math>](img/240.png)
    , and the item, ![<mml:math  ><mml:mi> </mml:mi><mml:mi>i</mml:mi></mml:math>](img/241.png)
    , respectively, ![<mml:math  ><mml:msub><mml:mrow><mml:mi>ℇ</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub></mml:math>](img/242.png)
    and ![<mml:math  ><mml:msub><mml:mrow><mml:mi>ℇ</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/243.png)
    are the sets of edges in the user-user and item-item graphs, and ![<math ><mrow><mi>α</mi></mrow></math>](img/244.png)
    and ![<math ><mrow><mi>β</mi></mrow></math>](img/245.png) are regularization parameters.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![<mml:math  ><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub><mml:mi> </mml:mi></mml:math>](img/238.png)
    和 ![<mml:math  ><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi> </mml:mi></mml:math>](img/239.png)
    分别是用户的潜在因子 ![<mml:math  ><mml:mi> </mml:mi><mml:mi>u</mml:mi></mml:math>](img/240.png)
    和物品的潜在因子 ![<mml:math  ><mml:mi> </mml:mi><mml:mi>i</mml:mi></mml:math>](img/241.png)，![<mml:math  ><mml:msub><mml:mrow><mml:mi>ℇ</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub></mml:math>](img/242.png)
    和 ![<mml:math  ><mml:msub><mml:mrow><mml:mi>ℇ</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/243.png)
    是用户-用户图和物品-物品图中的边集，而 ![<math ><mrow><mi>α</mi></mrow></math>](img/244.png) 和 ![<math
    ><mrow><mi>β</mi></mrow></math>](img/245.png) 是正则化参数。
- en: This approach has shown improved performance over traditional MF, especially
    in scenarios with sparse data, as it can leverage the graph structure to make
    better predictions for users or items with few interactions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法在传统的MF（矩阵分解）方法上表现出更好的性能，特别是在数据稀疏的场景下，因为它能够利用图结构为交互较少的用户或物品做出更好的预测。
- en: Graph neural network models
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图神经网络模型
- en: As we saw in [*Chapter 4*](B22118_04.xhtml#_idTextAnchor078) , **graph neural
    networks** ( **GNNs** ) have revolutionized the field of graph-based recommendations
    by enabling direct learning on graph-structured data. The following models can
    capture high-order connectivity patterns and learn rich node representations that
    incorporate both node features and graph structure.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第4章*](B22118_04.xhtml#_idTextAnchor078)中看到的，**图神经网络** (**GNNs**) 通过在图结构数据上进行直接学习，革命性地改变了基于图的推荐领域。以下模型能够捕捉高阶连接模式，并学习丰富的节点表示，结合了节点特征和图结构。
- en: PinSage
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PinSage
- en: '**PinSage** , developed by Pinterest, is a pioneering GNN model for large-scale
    recommendation systems. It adapts the **GraphSAGE** architecture to generate embeddings
    efficiently for nodes in web-scale graphs.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**PinSage** 是由Pinterest开发的一个开创性GNN模型，用于大规模推荐系统。它采用**GraphSAGE**架构，有效地为Web规模图中的节点生成嵌入。'
- en: In a movie recommendation context, PinSage could be used to generate embeddings
    for both users and movies. The model would aggregate information from a node’s
    local neighborhood, capturing not just direct interactions but also higher-order
    relationships. For example, it could identify that two users who haven’t watched
    the same movies might still have similar tastes if they’ve watched movies that
    are themselves similar.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在电影推荐的背景下，PinSage可以用来为用户和电影生成嵌入。该模型会聚合节点的局部邻域信息，不仅捕捉直接交互，还能捕捉更高阶的关系。例如，它可以识别出两个没有看过相同电影的用户，如果他们观看过相似的电影，可能仍然具有相似的口味。
- en: 'The key steps in PinSage are as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: PinSage的关键步骤如下：
- en: '**Neighborhood sampling** : For each node, sample a fixed number of neighbors
    to make computation feasible on large graphs.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**邻域采样**：对于每个节点，采样固定数量的邻居，以使大规模图上的计算变得可行。'
- en: '**Feature aggregation** : Aggregate features from the sampled neighbors using
    learnable aggregation functions.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**特征聚合**：使用可学习的聚合函数从采样的邻居中聚合特征。'
- en: '**Embedding generation** : Combine the aggregated neighborhood information
    with the node’s features to generate the final embedding.'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**嵌入生成**：将聚合的邻域信息与节点特征结合，生成最终的嵌入。'
- en: Neural graph collaborative filtering
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 神经图协同过滤
- en: '**Neural graph collaborative filtering** ( **NGCF** ) explicitly incorporates
    the user-item graph structure into the embedding learning process. It propagates
    embeddings on the user-item interaction graph to capture collaborative signals.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**神经图协同过滤** (**NGCF**) 显式地将用户-物品图结构融入到嵌入学习过程中。它在用户-物品交互图上传播嵌入，以捕捉协同信号。'
- en: For movie recommendations, NGCF would start with initial embeddings for users
    and movies and then update these embeddings iteratively by passing messages along
    the edges of the user-movie interaction graph. This process allows the model to
    capture high-order connectivity between users and movies.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于电影推荐，NGCF 从用户和电影的初始嵌入开始，然后通过沿着用户-电影交互图的边传递信息，逐步更新这些嵌入。这个过程使得模型能够捕捉用户与电影之间的高阶连接性。
- en: 'The embedding update process in NGCF can be described as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: NGCF 中的嵌入更新过程可以描述如下：
- en: '![<mml:math   display="block"><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:mi> </mml:mi><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi>σ</mml:mi><mml:mi> </mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:mi> </mml:mi><mml:mo>+</mml:mo><mml:mi> </mml:mi><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi> </mml:mi><mml:mi>i</mml:mi><mml:mi>ϵ</mml:mi><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi> </mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msqrt><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:msqrt></mml:mrow></mml:mfrac><mml:msubsup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:mrow></mml:mrow><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:mrow></mml:mfenced></mml:math>](img/246.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math   display="block"><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:mi> </mml:mi><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi>σ</mml:mi><mml:mi> </mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:mi> </mml:mi><mml:mo>+</mml:mo><mml:mi> </mml:mi><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi> </mml:mi><mml:mi>i</mml:mi><mml:mi>ϵ</mml:mi><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi> </mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msqrt><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mli></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:msqrt></mml:mrow></mml:mfrac><mml:msubsup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:mrow></mml:mrow><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/246.png)'
- en: Here, ![<mml:math  ><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/247.png)
    is the embedding of the user, ![<mml:math  ><mml:mi>u</mml:mi></mml:math>](img/248.png)
    , at the ![<mml:math  ><mml:mi>k</mml:mi></mml:math>](img/249.png) th layer. ![<mml:math  ><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub></mml:math>](img/250.png)
    is the set of items that are interacted with   by the user, ![<mml:math  ><mml:mi>u</mml:mi></mml:math>](img/220.png)
    , and ![<mml:math  ><mml:msubsup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>K</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/252.png)
    and ![<mml:math  ><mml:msubsup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>K</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/253.png)
    are   learnable weight matrixes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![<mml:math  ><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/247.png)
    是用户的嵌入，![<mml:math  ><mml:mi>u</mml:mi></mml:math>](img/248.png) ，位于第![<mml:math  ><mml:mi>k</mml:mi></mml:math>](img/249.png)
    层。![<mml:math  ><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub></mml:math>](img/250.png)
    是用户与之交互的项目集，![<mml:math  ><mml:mi>u</mml:mi></mml:math>](img/220.png) ，而![<mml:math  ><mml:msubsup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>K</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/252.png)
    和 ![<mml:math  ><mml:msubsup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>K</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/253.png)
    是可学习的权重矩阵。
- en: LightGCN
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LightGCN
- en: '**LightGCN** simplifies the NGCF model by removing feature transformation and
    nonlinear activation, focusing solely on the most essential component of **graph
    convolutional networks** ( **GCNs** ) for CF: neighborhood aggregation.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**LightGCN** 通过去除特征转换和非线性激活，简化了NGCF模型，专注于**图卷积网络**（**GCNs**）在协同过滤（CF）中的最核心部分：邻域聚合。'
- en: In the context of movie recommendations, LightGCN would represent users and
    movies as nodes in a bipartite graph. The model then performs multiple layers
    of neighborhood aggregation to capture high-order connectivity. The final embeddings
    are a weighted sum of embeddings from all layers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在电影推荐的背景下，LightGCN 将用户和电影表示为二分图中的节点。然后，该模型执行多层邻域聚合，以捕捉高阶连接性。最终的嵌入是所有层的嵌入的加权和。
- en: 'The embedding propagation rule in LightGCN is as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: LightGCN中的嵌入传播规则如下：
- en: '![<mml:math   display="block"><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:mi> </mml:mi><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi> </mml:mi><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi> </mml:mi><mml:mi>i</mml:mi><mml:mi>ϵ</mml:mi><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi> </mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msqrt><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:msqrt></mml:mrow></mml:mfrac><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math>](img/254.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math   display="block"><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:mi> </mml:mi><mml:mo>=</mml:mo><mml:mi> </mml:mi><mml:mi> </mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi> </mml:mi><mml:mi>i</mml:mi><mml:mi>ϵ</mml:mi><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi> </mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msqrt><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:msqrt></mml:mrow></mml:mfrac><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math>](img/254.png)'
- en: The simplicity of LightGCN makes it computationally efficient while still achieving
    state-of-the-art performance on many recommendation tasks.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: LightGCN的简单性使其在计算上非常高效，同时在许多推荐任务上仍能达到最先进的性能。
- en: Training graph deep learning models
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练图深度学习模型
- en: Training graph deep learning models for recommendation systems is a complex
    process that requires various factors to be considered carefully. In this section,
    we’ll provide a comprehensive guide to training these models.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 训练图深度学习模型以用于推荐系统是一个复杂的过程，需要仔细考虑多个因素。在本节中，我们将提供一个全面的训练指南。
- en: Data preprocessing
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据预处理
- en: Effective data preprocessing is crucial for the success of graph-based recommendation
    models. Let’s dive deeper into the steps involved.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的数据预处理对基于图的推荐模型的成功至关重要。让我们深入了解其中的步骤。
- en: Building the interaction graph
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建交互图
- en: 'Creating a high-quality interaction graph is the foundation of graph-based
    recommendation systems. Let’s take a look:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个高质量的交互图是基于图的推荐系统的基础。让我们来看一下：
- en: '**Node creation** :'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**节点创建**：'
- en: Assign unique identifiers to each user and movie.
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个用户和电影分配唯一的标识符。
- en: Create node attributes to store relevant information.
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建节点属性以存储相关信息。
- en: '**Edge creation** :'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**边创建**：'
- en: Create edges based on user-movie interactions.
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据用户-电影交互创建边。
- en: Consider different types of interactions (for example, ratings, views, and likes).
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑不同类型的交互（例如，评分、观看和点赞）。
- en: '**Edge weighting** :'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**边加权**：'
- en: Assign weights to edges based on interaction strength.
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据交互强度为边分配权重。
- en: Normalize weights to ensure consistency across different interaction types.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准化权重，以确保不同交互类型之间的一致性。
- en: '**Handling** **temporal information** :'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理** **时间信息**：'
- en: Incorporate the timestamps of interactions as edge attributes.
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将交互的时间戳作为边的属性。
- en: Consider creating multiple edges for repeated interactions.
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑为重复的交互创建多个边。
- en: 'Here’s some example pseudocode for building a more detailed graph:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建更详细图的示例伪代码：
- en: '[PRE2]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following function normalizes the edge weights in the graph to provide
    a relative measure of interaction strength:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数将图中的边权重标准化，以提供相对的交互强度度量：
- en: '[PRE3]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Feature engineering
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特征工程
- en: 'You can enhance the graph with rich features to improve model performance:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过丰富的特征来增强图的表现，以提升模型性能：
- en: '**User features** :'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户特征**：'
- en: Demographic information, such as age, gender, and location
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人口统计信息，如年龄、性别和位置
- en: Behavioral features, such as average rating, genre preferences, and activity
    level
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为特征，如平均评分、类型偏好和活跃度
- en: Derived features, such as user segments based on viewing patterns
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派生特征，如基于观看模式的用户细分
- en: '**Movie features** :'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电影特征**：'
- en: Basic attributes, such as genre, release year, and duration
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本属性，如类型、发行年份和时长
- en: Production details, such as director, actors, budget, and production company
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作细节，如导演、演员、预算和制作公司
- en: Performance metrics, such as box office revenue and critic ratings
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能指标，如票房收入和评论评分
- en: Derived features, such as popularity score and genre embeddings
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派生特征，如流行度评分和类型嵌入
- en: '**Temporal features** :'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间特征**：'
- en: Time-based user features, such as viewing frequency and time since the last
    activity
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于时间的用户特征，如观看频率和自上次活动以来的时间
- en: Time-based movie features, such as the age of the movie and seasonal popularity
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于时间的电影特征，如电影的年龄和季节性流行度
- en: '**Graph-based features** :'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于图的特征**：'
- en: Node degree, such as the number of movies rated by a user or the number of ratings
    for a movie
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点度数，如用户评分的电影数量或电影的评分数量
- en: Centrality measures, such as PageRank and betweenness centrality
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中心性度量，如PageRank和介数中心性
- en: Community detection – for example, assign community labels to nodes
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社区检测——例如，将社区标签分配给节点
- en: 'Here’s an example of advanced feature engineering:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个高级特征工程的示例：
- en: '[PRE4]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following function calculates genre preferences for a given user. This
    is used as part of the feature engineering process outlined previously:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数计算给定用户的类型偏好。这作为前述特征工程过程的一部分：
- en: '[PRE5]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Model training techniques
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型训练技巧
- en: Training graph deep learning models for recommendation systems involves several
    advanced techniques to improve performance and efficiency.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 训练图深度学习模型用于推荐系统涉及多种先进技术，以提高性能和效率。
- en: Loss functions
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 损失函数
- en: 'You can choose and combine appropriate **loss functions** based on the recommendation
    task:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据推荐任务选择和组合适当的**损失函数**：
- en: '**Binary cross-entropy** ( **BCE** ) can be used for *implicit* feedback:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二元交叉熵**（**BCE**）可以用于*隐式*反馈：'
- en: '[PRE6]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Mean squared error** ( **MSE** ) can be employed for *explicit* feedback
    ( rating prediction):'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**均方误差**（**MSE**）可以用于*显式*反馈（评分预测）：'
- en: '[PRE7]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Bayesian personalized ranking** ( **BPR** ) **loss** can be utilized for
    pairwise ranking:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**贝叶斯个性化排名**（**BPR**）**损失**可以用于成对排名：'
- en: '[PRE8]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Margin ranking loss** is another option for pairwise ranking:'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边际排名损失**是另一种用于成对排名的选项：'
- en: '[PRE9]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Combination of losses** can combine multiple loss functions for multi-task
    learning:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**损失函数组合**可以结合多个损失函数进行多任务学习：'
- en: '[PRE10]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Training loop
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 训练循环
- en: 'You can also implement an advanced **training loop** with various optimization
    techniques:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以实现一个高级**训练循环**，结合各种优化技巧：
- en: '**Gradient accumulation for larger effective batch sizes** : This technique
    allows for larger effective batch sizes by accumulating gradients over multiple
    batches before performing an optimizer step:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**梯度累积以获得更大的有效批次大小**：这项技术通过在多个批次上累积梯度，允许更大的有效批次大小，然后再进行优化器步骤：'
- en: '[PRE11]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Learning rate scheduling** : The **ReduceLROnPlateau** scheduler adjusts
    the learning rate based on the validation loss, reducing it when the loss plateaus:'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学习率调度**：**ReduceLROnPlateau**调度器根据验证损失调整学习率，当损失趋于平稳时降低学习率：'
- en: '[PRE12]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Early stopping based on validation performance** : This technique stops training
    when the validation loss doesn’t improve for a specified number of epochs, preventing
    overfitting:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于验证性能的早停**：当验证损失在指定数量的训练轮次内没有改善时，这项技术会停止训练，防止过拟合：'
- en: '[PRE13]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Gradient clipping to prevent exploding gradients** : Gradient clipping prevents
    gradients from becoming too large, which can cause instability during training:'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**梯度裁剪防止梯度爆炸**：梯度裁剪防止梯度过大，避免训练过程中出现不稳定：'
- en: '[PRE14]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Scalability and optimization
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展性和优化
- en: Handling large-scale graphs requires advanced techniques for efficient training
    and inference. We covered the challenge of scalability in [*Chapter 5*](B22118_05.xhtml#_idTextAnchor093)
    ; here, we’ll look at practical examples of techniques that can help us address
    this issue.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 处理大规模图形需要高级技术来提高训练和推理效率。我们在[*第5章*](B22118_05.xhtml#_idTextAnchor093)中讨论了可扩展性问题；在这里，我们将查看一些实用的技术示例，帮助我们解决这一问题。
- en: Mini-batch training with neighborhood sampling
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用邻域采样的迷你批量训练
- en: 'Instead of processing the entire graph, we can use **mini-batch training**
    with neighborhood sampling:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**小批量训练**与邻域采样来代替处理整个图：
- en: 'Sample a subset of user nodes:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 采样一部分用户节点：
- en: '[PRE15]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This step randomly selects a subset of user nodes to form the mini-batch.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这一步随机选择一部分用户节点来形成小批量。
- en: 'For each user, sample a fixed number of positive and negative movie interactions.
    Here, we sample positive movie interactions from the user’s neighbors and negative
    interactions from movies the user hasn’t interacted with:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个用户，采样固定数量的正向和负向电影交互。这里，我们从用户的邻居中采样正向电影交互，从用户未交互过的电影中采样负向交互：
- en: '[PRE16]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Perform **multi-hop neighborhood sampling** to create a subgraph containing
    the relevant nodes and their neighbors:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行**多跳邻域采样**来创建一个包含相关节点及其邻居的子图：
- en: '[PRE17]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we create the subgraph and conduct message passing within the sampled
    subgraph:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建子图并在采样的子图中进行消息传递：
- en: '[PRE18]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Distributed training
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式训练
- en: 'For extremely large graphs, you can implement **distributed training** :'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于极大的图，你可以实现**分布式训练**：
- en: '**Graph partitioning** : Divide the graph across multiple machines to enable
    distributed processing:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**图划分**：将图分割到多个机器上，以便进行分布式处理：'
- en: '[PRE19]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Distributed message passing** : Implement efficient communication protocols
    for distributed message passing across machines:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分布式消息传递**：为跨机器的分布式消息传递实现高效的通信协议：'
- en: '[PRE20]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Parameter server architecture** : Use **DistributedDataParallel** ( **DDP**
    ) to centralize model parameter updates across all processes:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**参数服务器架构**：使用**DistributedDataParallel**（**DDP**）将模型参数更新集中在所有进程中：'
- en: '[PRE21]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By implementing all the strategies outlined in this section, such as efficient
    graph construction, comprehensive feature engineering, sophisticated loss functions,
    and scalable training methods, you can develop powerful and effective graph-based
    recommendation systems.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实施本节中概述的所有策略，如高效的图构建、全面的特征工程、复杂的损失函数和可扩展的训练方法，你可以开发出强大且有效的基于图的推荐系统。
- en: Explainability in graph-based recommendations
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于图的推荐的可解释性
- en: As recommendation systems become more sophisticated, the need for **explainable
    AI** ( **XAI** ) in these systems grows. Graph-based models offer unique opportunities
    for enhancing the explainability of recommendations.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 随着推荐系统变得更加复杂，对**可解释人工智能**（**XAI**）的需求也在增加。基于图的模型为增强推荐的可解释性提供了独特的机会。
- en: Attention mechanisms for interpretability
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释性机制的注意力
- en: As we saw in [*Chapter 4*](B22118_04.xhtml#_idTextAnchor078) , **graph attention
    networks** ( **GATs** ) can be leveraged to provide insights into which nodes
    or features contribute most to a recommendation. For movie recommendations, this
    could reveal which actors, directors, or genres have the most significant influence
    on a user’s preferences.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第4章*](B22118_04.xhtml#_idTextAnchor078) 中看到的，**图注意力网络**（**GATs**）可以被用来提供哪些节点或特征对推荐贡献最大的洞察。对于电影推荐，这可以揭示哪些演员、导演或类型对用户的偏好有最重要的影响。
- en: Consider a user who frequently watches action movies starring Tom Cruise. The
    attention mechanism might highlight that the presence of Tom Cruise in a movie’s
    cast graph node has a higher weight in the recommendation process for this user
    compared to other factors.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 设想一个用户，他经常观看由汤姆·克鲁斯主演的动作电影。注意力机制可能会突出显示汤姆·克鲁斯在电影演员图节点中的存在，在该用户的推荐过程中，这一因素的权重会比其他因素更高。
- en: Path-based explanations
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于路径的解释
- en: '**Metapath-based models** can offer intuitive explanations by showing the reasoning
    path that led to a recommendation.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于元路径的模型**可以通过展示导致推荐的推理路径，提供直观的解释。'
- en: 'For example, a movie recommendation might be explained as follows: *We recommended
    “Inception” because you enjoyed “The Dark Knight” (same director: Christopher
    Nolan) and “Interstellar” (similar genre:* *sci-fi thriller).*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，电影推荐可以这样解释：*我们推荐“盗梦空间”是因为你喜欢“黑暗骑士”（相同导演：克里斯托弗·诺兰）和“星际穿越”（相似类型：* *科幻惊悚片）。*
- en: One of the major challenges that businesses face is a lack of data. A new product
    might not have enough customer data to build these sophisticated recommendation
    models. This challenge is called the cold start problem, and we’re going to look
    into how we can leverage graph algorithms to solve it.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 企业面临的主要挑战之一是缺乏数据。一款新产品可能没有足够的客户数据来构建这些复杂的推荐模型。这个挑战被称为冷启动问题，我们将探讨如何利用图算法来解决它。
- en: The cold start problem
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冷启动问题
- en: The cold start problem in recommendation systems refers to the challenge of
    making accurate recommendations for new users or new items that have little to
    no interaction data. In movie recommendation systems, this occurs when a new user
    joins the platform and has no viewing history or when a new movie is released
    and has no user ratings or interactions.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐系统中的冷启动问题是指为没有多少或没有交互数据的新用户或新项目做出准确推荐的挑战。在电影推荐系统中，当一个新用户加入平台并且没有观看历史，或者当一部新电影发布并且没有用户评分或互动时，就会发生这种情况。
- en: The cold start problem is particularly challenging in movie recommendation systems,
    especially for new users or newly released movies.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 冷启动问题在电影推荐系统中特别具有挑战性，尤其是对于新用户或新发布的电影。
- en: Graph embedding transfer
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图嵌入传递
- en: 'One solution to the cold start problem is **graph embedding transfer** , a
    technique that’s used to initialize representations for new nodes (movies or users)
    in a recommendation graph when there’s no interaction data available. Here’s a
    general description:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 解决冷启动问题的一种方法是**图嵌入传递**，这是一种在没有交互数据的情况下，用于初始化推荐图中新节点（电影或用户）表示的技术。以下是一般描述：
- en: 'For new items (for example, movies):'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于新项目（例如电影）：
- en: Identify similar existing items based on metadata or content features.
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据元数据或内容特征识别相似的现有项目。
- en: Use the embeddings of these similar items to initialize the embedding of the
    new item.
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这些相似项目的嵌入来初始化新项目的嵌入。
- en: This gives the new item a starting point in the embedding space that reflects
    its likely characteristics.
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这为新项目在嵌入空间中提供了一个起始点，反映了其可能的特征。
- en: 'For new users:'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于新用户：
- en: Use available demographic or preference information to find similar existing
    users.
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可用的人口统计或偏好信息来寻找相似的现有用户。
- en: Initialize the new user’s embedding based on these similar users’ embeddings.
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据这些相似用户的嵌入初始化新用户的嵌入。
- en: As the new user interacts with the system, their embedding can be fine-tuned.
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当新用户与系统交互时，他们的嵌入表示可以进行微调。
- en: 'For example, when a new superhero movie is released, we can initialize its
    embedding by averaging the embeddings of other superhero movies in the graph:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当一部新的超级英雄电影上映时，我们可以通过对图中其他超级英雄电影的嵌入进行平均，来初始化它的嵌入表示：
- en: '[PRE22]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Content-based feature integration
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于内容的特征集成
- en: Another effective approach to mitigate cold start issues is to leverage content-based
    features from available metadata or item descriptions. By integrating multiple
    content-based features such as text attributes, categorical information, and any
    available numerical data, a system can generate initial recommendations even for
    new items or users with no interaction history. This integrated feature representation
    can be used to compute item similarities or train machine learning models that
    predict user preferences based on item characteristics.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种有效的减少冷启动问题的方法是利用来自可用元数据或项目描述的基于内容的特征。通过集成多种基于内容的特征，如文本属性、分类信息以及任何可用的数值数据，系统可以为没有交互历史的新项目或用户生成初步推荐。这种集成的特征表示可以用来计算项目相似性或训练机器学习模型，根据项目特征预测用户偏好。
- en: 'For instance, when a new user signs up, we can create edges to movies based
    on their stated preferences (genres, actors, and directors), even before they’ve
    watched anything:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当一个新用户注册时，我们可以根据他们的偏好（如类型、演员和导演）创建与电影的边缘连接，即使他们还没有观看任何内容：
- en: '[PRE23]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: These are just a couple of ways we can approach a cold start problem in a recommendation
    system that leverages graphs.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是我们在利用图形的推荐系统中解决冷启动问题的几种方法。
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced graph deep learning as an advanced approach to
    recommendation systems. You learned about the fundamental concepts of recommendation
    systems, including the different types and evaluation metrics.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了图深度学习作为推荐系统的先进方法。你了解了推荐系统的基本概念，包括不同类型和评估指标。
- en: Then, we delved into graph structures for representing user-item interactions,
    incorporating side information, and capturing temporal dynamics. Various graph-based
    recommendation models were explored, from MF with graph regularization to advanced
    GNN models. You also became familiar with a variety of training techniques, scalability
    challenges, and advanced topics such as explainability and the cold start problem
    in graph-based recommendation systems.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们深入研究了用于表示用户-项目交互的图结构，结合了边信息，并捕捉了时间动态。我们探索了多种基于图的推荐模型，从带有图正则化的MF模型到先进的GNN模型。你还熟悉了各种训练技巧、可扩展性挑战以及图基推荐系统中的高级主题，如可解释性和冷启动问题。
- en: In the next chapter, we’re going to investigate the applications of graph learning
    in computer vision.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探讨图学习在计算机视觉中的应用。
