- en: '*Chapter 7*: Deploying Deep RL Agents to the Cloud'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 7 章*：将深度 RL 代理部署到云端'
- en: The cloud has become the *de facto* platform of deployment for AI-based products
    and solutions. Deep learning models running in the cloud are becoming increasingly
    common. The deployment of reinforcement learning-based agents to the cloud is,
    however, still very limited for a variety of reasons. This chapter contains recipes
    to equip yourself with tools and details to get ahead of the curve and build cloud-based
    Simulation-as-a-Service and Agent/Bot-as-a-Service applications using deep RL.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算已成为基于 AI 的产品和解决方案的*事实上的*部署平台。深度学习模型在云端运行变得越来越普遍。然而，由于各种原因，将基于强化学习的代理部署到云端仍然非常有限。本章包含了帮助你掌握工具和细节的配方，让你走在前沿，构建基于深度
    RL 的云端 Simulation-as-a-Service 和 Agent/Bot-as-a-Service 应用。
- en: 'Specifically, the following recipes are discussed in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章具体讨论了以下配方：
- en: Implementing the RL agent’s runtime components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 RL 代理的运行时组件
- en: Building RL environment simulators as a service
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建作为服务的 RL 环境模拟器
- en: Training RL agents using a remote simulator service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用远程模拟器服务训练 RL 代理
- en: Testing/evaluating RL agents
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试/评估 RL 代理
- en: Packaging RL agents for deployment – a trading bot
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包 RL 代理以进行部署 – 一个交易机器人
- en: Deploying RL agents to the cloud – a trading Bot-as-a-Service
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 RL 代理部署到云端 – 一个交易机器人即服务
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code in the book is extensively tested on Ubuntu 18.04 and Ubuntu 20.04
    and should work with later versions of Ubuntu if Python 3.6+ is available. With
    Python 3.6+ installed along with the necessary Python packages as listed before
    the start of each of the recipes, the code should run fine on Windows and macOS
    X too. It is advised to create and use a Python virtual environment named `tf2rl-cookbook`
    to install the packages and run the code in this book. Miniconda or Anaconda installation
    for Python virtual environment management is recommended.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码在 Ubuntu 18.04 和 Ubuntu 20.04 上经过广泛测试，如果安装了 Python 3.6+，该代码应该能在更新版本的 Ubuntu
    上运行。如果安装了 Python 3.6+ 和前面列出的必要 Python 包，代码也应该能在 Windows 和 macOS X 上运行。建议创建并使用名为
    `tf2rl-cookbook` 的 Python 虚拟环境来安装包并运行本书中的代码。建议使用 Miniconda 或 Anaconda 进行 Python
    虚拟环境管理。
- en: 'The complete code for each recipe in each chapter is available here: [https://github.com/PacktPublishing/Tensorflow-2-Reinforcement-Learning-Cookbook](https://github.com/PacktPublishing/Tensorflow-2-Reinforcement-Learning-Cookbook).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每章每个配方的完整代码可以在这里找到：[https://github.com/PacktPublishing/Tensorflow-2-Reinforcement-Learning-Cookbook](https://github.com/PacktPublishing/Tensorflow-2-Reinforcement-Learning-Cookbook)。
- en: Implementing the RL agent’s runtime components
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 RL 代理的运行时组件
- en: 'We have looked at several agent algorithm implementations in the previous chapters.
    You may have noticed from recipes in the previous chapters (especially [*Chapter
    3*](B15074_03_ePub_AM.xhtml#_idTextAnchor090), *Implementing Advanced Deep RL
    Algorithms*), where we implemented RL agent training code, that some parts of
    the agent code were conditionally executed. For example, the experience replay
    routine was only run when a certain condition (such as the number of samples in
    the replay memory) was met, and so on. That begs the question: what are the essential
    components in an agent that is required, especially when we do not aim to train
    it further and only execute a learned policy?'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们已经讨论了几个代理算法的实现。你可能已经注意到，在之前的章节（特别是 [*第 3 章*](B15074_03_ePub_AM.xhtml#_idTextAnchor090)，*实现高级深度
    RL 算法*）中的一些配方里，我们实现了 RL 代理的训练代码，其中有些部分的代理代码是有条件执行的。例如，经验回放的例程只有在满足某些条件（比如回放记忆中的样本数量）时才会运行，等等。这引出了一个问题：在一个代理中，哪些组件是必需的，特别是当我们不打算继续训练它，而只是执行一个已经学到的策略时？
- en: This recipe will help you distill the implementation of the **Soft Actor-Critic**
    (**SAC**) agent down to the minimal set of components – those that are absolutely
    necessary for the runtime of your agent.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方将帮助你将 **Soft Actor-Critic** (**SAC**) 代理的实现提炼到一组最小的组件——这些是你的代理运行时绝对必要的组件。
- en: Let’s get started!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'To complete this recipe, you will first need to activate the `tf2rl-cookbook`
    Python/conda virtual environment. Make sure to update the environment to match
    the latest conda environment specification file (`tfrl-cookbook.yml`) in the cookbook’s
    code repository. WebGym is built on top of the miniwob-plusplus benchmark ([https://github.com/stanfordnlp/miniwob-plusplus](https://github.com/stanfordnlp/miniwob-plusplus)),
    which is also made available as part of this book’s code repository for ease of
    use. If the following `import` statements run without issues, you are ready to
    get started:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个食谱，首先需要激活`tf2rl-cookbook`的Python/conda虚拟环境。确保更新环境以匹配食谱代码库中的最新conda环境规格文件（`tfrl-cookbook.yml`）。WebGym建立在miniWob-plusplus基准之上（[https://github.com/stanfordnlp/miniwob-plusplus](https://github.com/stanfordnlp/miniwob-plusplus)），该基准也作为本书代码库的一部分提供，便于使用。如果以下的`import`语句没有问题，你就可以开始了：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, let’s begin!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始吧！
- en: How to do it…
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'The following steps provide the implementation details for the minimal runtime
    necessary to utilize an SAC agent. Let’s jump right into the details:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤提供了实现SAC智能体所需的最小运行时的详细信息。让我们直接进入细节：
- en: 'First, let’s implement the actor component, which is going to be a TensorFlow
    2.x model:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们实现演员组件，它将是一个TensorFlow 2.x模型：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, let’s implement the critic component, which is also going to be a TensorFlow
    2.x model:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们实现评论家组件，它也将是一个TensorFlow 2.x模型：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let’s implement a utility function to update the weights of a target model
    given a source TensorFlow 2.x model:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现一个实用函数，用于在给定源TensorFlow 2.x模型的情况下更新目标模型的权重：
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we can begin our SAC agent runtime class implementation. We will split
    our implementation into the following steps. Let’s start with the class implementation
    and define the constructor arguments in this step:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以开始实现SAC智能体的运行时类。我们将把实现分为以下几个步骤。让我们从类的实现开始，并在这一步中定义构造函数的参数：
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s now initialize the state/observation shapes, action shapes, and action
    limits/bounds for the agent and also initialize a deque to store the agent’s memory:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们初始化智能体的状态/观测形状、动作形状、动作限制/边界，并初始化一个双端队列（deque）来存储智能体的记忆：
- en: '[PRE5]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this step, let’s define and initialize the actor component:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步中，让我们定义并初始化演员组件：
- en: '[PRE6]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s now define and initialize the critic components:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义并初始化评论家组件：
- en: '[PRE7]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this step, let’s initialize the temperature and target entropy for the SAC
    agent based on the `auto_alpha` flag:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步中，让我们根据`auto_alpha`标志来初始化SAC智能体的温度和目标熵：
- en: '[PRE8]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s complete the constructor implementation by setting the hyperparameters
    and initializing the training progress summary dictionary for TensorBoard logging:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过设置超参数并初始化用于TensorBoard日志记录的训练进度摘要字典来完成构造函数的实现：
- en: '[PRE9]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the constructor implementation completed, let’s now move on to implement
    the `process_action` function, which takes the raw action from the agent and processes
    it so that it can be executed:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数实现完成后，我们接下来实现`process_action`函数，该函数接收智能体的原始动作并处理它，使其可以被执行：
- en: '[PRE10]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This step is crucial. We are going to implement the `act` method, which will
    take as input the state and generate and return the action to be executed:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一步非常关键。我们将实现`act`方法，该方法将以状态作为输入，生成并返回要执行的动作：
- en: '[PRE11]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, let’s implement utility methods to load the actor and critic model
    weights from previously trained models:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们实现一些实用方法，用于从先前训练的模型中加载演员和评论家的模型权重：
- en: '[PRE12]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That completes the implementation of all the necessary runtime components for
    the SAC RL agent!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经完成了所有必要的SAC RL智能体运行时组件的实现！
- en: How it works…
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we implemented the essential runtime components for the SAC
    agent. The runtime components include the actor and critic model definitions,
    a mechanism to load weights from previously trained agent models, and an agent
    interface to generate actions given states using the actor’s prediction and to
    process the prediction to generate an executable action.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们实现了SAC智能体的基本运行时组件。运行时组件包括演员和评论家模型定义、一个从先前训练的智能体模型中加载权重的机制，以及一个智能体接口，用于根据状态生成动作，利用演员的预测并处理预测生成可执行动作。
- en: The runtime components for other actor-critic-based RL agent algorithms, such
    as A2C, A3C, and DDPG, as well as their extensions and variants, will be very
    similar, if not the same.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他基于演员-评论家的RL智能体算法，如A2C、A3C和DDPG及其扩展和变体，运行时组件将非常相似，甚至可能是相同的。
- en: It’s now time to move on to the next recipe!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候进入下一个教程了！
- en: Building RL environment simulators as a service
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 RL 环境模拟器构建为服务
- en: This recipe will walk you through the process of converting your RL training
    environment/simulator into a service. This will allow you to offer Simulation-as-a-Service
    for training RL agents!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将引导你将你的 RL 训练环境/模拟器转换为一个服务。这将使你能够提供模拟即服务（Simulation-as-a-Service）来训练 RL 代理！
- en: So far, we have trained several RL agents in a variety of environments using
    different simulators depending on the task to be solved. The training scripts
    used the Open AI Gym interface to talk to the environment running in the same
    process, or locally in a different process. This recipe will guide you through
    the process of converting any OpenAI Gym-compatible training environment (including
    your custom RL training environments) into a service that can be deployed locally
    or remotely as a service. Once built and deployed, an agent training client can
    connect to the sim server and train one or more agents remotely.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在多种环境中使用不同的模拟器训练了多个 RL 代理，具体取决于要解决的任务。训练脚本使用 OpenAI Gym 接口与在同一进程中运行的环境或在不同进程中本地运行的环境进行通信。本教程将引导你完成将任何
    OpenAI Gym 兼容的训练环境（包括你自定义的 RL 训练环境）转换为可以本地或远程部署为服务的过程。构建并部署完成后，代理训练客户端可以连接到模拟服务器，并远程训练一个或多个代理。
- en: As a concrete example, we will take our `tradegym` library, which is a collection
    of the RL training environments for cryptocurrency and stock trading that we built
    in the previous chapters, and expose them through a **RESTful HTTP interface**
    for training RL agents.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个具体的例子，我们将使用我们的 `tradegym` 库，它是我们在前几章中为加密货币和股票交易构建的 RL 训练环境的集合，并通过 **RESTful
    HTTP 接口** 将它们暴露出来，以便训练 RL 代理。
- en: Let’s get started!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 开始吧！
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To complete this recipe, you will first need to activate the `tf2rl-cookbook`
    Python/conda virtual environment. Make sure to update the environment to match
    the latest conda environment specification file (`tfrl-cookbook.yml`) in the cookbook’s
    code repository.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本教程，你需要首先激活 `tf2rl-cookbook` Python/conda 虚拟环境。确保更新该环境，使其与最新的 conda 环境规范文件（`tfrl-cookbook.yml`）保持一致，该文件在食谱代码仓库中。
- en: We will also need to create a new Python module called `tradegym`, which contains
    the `crypto_trading_env.py`, `stock_trading_continuous_env.py`, `trading_utils.py`,
    and other custom trading environments we implemented in the previous chapters.
    You will find the `tradegym` module with its contents in the book’s code repository
    as well.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建一个新的 Python 模块，名为 `tradegym`，其中包含 `crypto_trading_env.py`、`stock_trading_continuous_env.py`、`trading_utils.py`
    以及我们在前几章中实现的其他自定义交易环境。你将在书籍的代码仓库中找到包含这些内容的 `tradegym` 模块。
- en: How to do it…
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Our implementation will contain two core modules – the `tradegym` server and
    the `tradegym` client, which are built based on the OpenAI Gym HTTP API. The recipe
    will focus on the customizations and the core components of the HTTP service interface.
    We will first define a minimum set of custom environments exposed as part of the
    `tradegym` library and then build the server and client modules:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现将包含两个核心模块——`tradegym` 服务器和 `tradegym` 客户端，这些模块是基于 OpenAI Gym HTTP API 构建的。本教程将重点介绍
    HTTP 服务接口的定制和核心组件。我们将首先定义作为 `tradegym` 库一部分暴露的最小自定义环境集，然后构建服务器和客户端模块：
- en: 'Let’s first make sure the minimal contents of the `tradegym` library’s `__init__.py`
    file exists so that we can import these environments:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，确保 `tradegym` 库的 `__init__.py` 文件中包含最基本的内容，以便我们可以导入这些环境：
- en: '[PRE13]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can now begin our `tradegym` server implementation as `tradegym_http_server.py`.
    We will finalize the implementation in the following several steps. Let’s begin
    by importing the necessary Python modules:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以开始实现我们的 `tradegym` 服务器，命名为 `tradegym_http_server.py`。我们将在接下来的几个步骤中完成实现。让我们首先导入必要的
    Python 模块：
- en: '[PRE14]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we will import the `tradegym` module to register the available environments
    with the Gym registry:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将导入 `tradegym` 模块，以便将可用的环境注册到 Gym 注册表中：
- en: '[PRE15]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s now look at the skeleton of the environment container class with comments
    describing what each method does. You can refer to the full implementation of
    `tradegym_http_server.py` in the book’s code repository under `chapter7`. We will
    start with the class definition in this step and complete the skeleton in the
    following steps:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看环境容器类的框架，并且有注释说明每个方法的作用。你可以参考本书代码仓库中`chapter7`下的完整实现。我们将从类定义开始，并在接下来的步骤中完成框架：
- en: '[PRE16]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this step, we will look at the two helper methods that are useful for managing
    the environment instances. They enable look up and delete operations:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此步骤中，我们将查看两个有助于管理环境实例的辅助方法。它们支持查找和删除操作：
- en: '[PRE17]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we will look at a few other methods that help with the environment management
    operations:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将查看其他一些有助于环境管理操作的方法：
- en: '[PRE18]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The methods discussed in this step enable the core operation of the RL environment,
    which have 1-1 correspondences with the core Gym API:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本步骤中讨论的方法支持RL环境的核心操作，并且这些方法与核心Gym API一一对应：
- en: '[PRE19]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With the preceding skeleton (and implementation), we can look at a few samples
    to expose these operations as REST APIs using the **Flask** Python library. We
    will discuss the core server application setup and the route setup for the create,
    reset, and step methods in the following steps. Let’s look at the server application
    setup that exposes the endpoint handlers:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了前面的框架（和实现），我们可以通过**Flask** Python库将这些操作暴露为REST API。接下来，我们将讨论核心服务器应用程序的设置以及创建、重置和步骤方法的路由设置。让我们看看暴露端点处理程序的服务器应用程序设置：
- en: '[PRE20]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can now look at the REST API route definition for the `v1/envs`. This takes
    in an `env_id`, which should be a valid Gym environment ID (such as our custom
    `StockTradingContinuous-v0` or `MountainCar-v0`, which is available in the Gym
    registry) and returns an `instance_id`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以查看`v1/envs`的REST API路由定义。它接受一个`env_id`，该ID应该是一个有效的Gym环境ID（如我们的自定义`StockTradingContinuous-v0`或`MountainCar-v0`，这些都可以在Gym注册表中找到），并返回一个`instance_id`：
- en: '[PRE21]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we will look at the REST API route definition for the HTTP POST endpoint
    at `v1/envs/<instance_id>/reset`, where `<instance_id>` can be any of the IDs
    returned by the `env_create()` method:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将查看`v1/envs/<instance_id>/reset`的HTTP POST端点的REST API路由定义，其中`<instance_id>`可以是`env_create()`方法返回的任何ID：
- en: '[PRE22]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we will look at the route definition for the endpoint at `v1/envs/<instance_id>/step`,
    which is the endpoint that will likely be called the most number of times in an
    RL training loop:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将查看`v1/envs/<instance_id>/step`端点的路由定义，这是在RL训练循环中最可能被调用的端点：
- en: '[PRE23]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For the remaining route definitions on the `tradegym` server, refer to the
    book’s code repository. We will implement a `__main__` function in the `tradegym`
    server script to launch the server when executed (which we will be using later
    in this recipe to test):'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`tradegym`服务器上剩余的路由定义，请参考本书的代码仓库。我们将在`tradegym`服务器脚本中实现一个`__main__`函数，用于在执行时启动服务器（稍后我们将在本教程中使用它来进行测试）：
- en: '[PRE24]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will now move on to understand the implementation of the `tradegym` client.
    The full implementation is available in `tradegym_http_client.py` in the book’s
    code repository under `chapter7`. We will begin by importing the necessary Python
    modules in this step and continue to implement the client wrapper in the following
    steps:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将了解`tradegym`客户端的实现。完整实现可在本书代码仓库的`chapter7`中找到`tradegym_http_client.py`文件中。在本步骤中，我们将首先导入必要的Python模块，并在接下来的步骤中继续实现客户端封装器：
- en: '[PRE25]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The client class provides a Python wrapper to interface with the `tradegym`
    HTTP server. The constructor of the client class takes in the server’s address
    (IP and port information) to connect. Let’s look at the constructor implementation:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端类提供了一个Python封装器，用于与`tradegym` HTTP服务器进行接口交互。客户端类的构造函数接受服务器的地址（IP和端口信息）以建立连接。让我们看看构造函数的实现：
- en: '[PRE26]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Reproducing all the standard Gym HTTP client methods here will not be a sensible
    use of the space available for this book and therefore, we will focus on the core
    wrapper methods, such as `env_create`, `env_reset`, and `env_step`, which we will
    use extensively in our agent training script. For a complete implementation, please
    refer to the book’s code repository. Let’s look at the `env_create` wrapper for
    creating an instance of an RL simulation environment on the remote `tradegym`
    server:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里重复所有标准的Gym HTTP客户端方法并不是对本书有限空间的合理利用，因此我们将重点关注核心的封装方法，如`env_create`、`env_reset`和`env_step`，这些方法将在我们的代理训练脚本中广泛使用。有关完整实现，请参阅本书的代码库。让我们看一下用于在远程`tradegym`服务器上创建RL仿真环境实例的`env_create`封装方法：
- en: '[PRE27]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In this step, we will look at the wrapper method that calls the `reset` method
    on a specific environment using the unique `instance_id` returned by the `tradegym`
    server when the `env_create` call is made:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步中，我们将查看调用`reset`方法的封装方法，它通过`tradegym`服务器在`env_create`调用时返回的唯一`instance_id`来操作特定的环境：
- en: '[PRE28]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The most frequently used method on the `tradegym` client’s `Client` class is
    the `step` method. Let’s look at the implementation, which should look straightforward
    to you:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tradegym`客户端的`Client`类中最常用的方法是`step`方法。让我们看一下它的实现，应该对你来说很简单：'
- en: '[PRE29]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With the other client wrapper methods in place, we can implement the `__main__`
    routine to connect to the `tradegym` server and call a few methods as an example
    to test whether everything is working as expected. Let’s write out the `__main__`
    routine:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其他客户端封装方法到位之后，我们可以实现`__main__`例程来连接到`tradegym`服务器，并调用一些方法作为示例，以测试一切是否按预期工作。让我们编写`__main__`例程：
- en: '[PRE30]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can now start to actually create a client instance and check the `tradegym`
    service! First, we need to launch the `tradegym` server by executing the following
    command:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以开始实际创建客户端实例并检查`tradegym`服务！首先，我们需要通过执行以下命令来启动`tradegym`服务器：
- en: '[PRE31]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we can launch the `tradegym` client by running the following command in
    a separate terminal:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过在另一个终端运行以下命令来启动`tradegym`客户端：
- en: '[PRE32]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You should see an output similar to the following in the terminal where you
    launched the `tradegym_http_client.py` script:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该会在你启动`tradegym_http_client.py`脚本的终端中看到类似以下的输出：
- en: '[PRE33]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: That completes the recipe! Let’s briefly recap on how it works.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了整个流程！让我们简要回顾一下它是如何工作的。
- en: How it works…
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The `tradegym` server provides an environment container class and exposes the
    environment interface through a REST API. The `tradegym` client provides Python
    wrapper methods to interact with the RL environment through the REST API.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`tradegym`服务器提供了一个环境容器类，并通过REST API公开环境接口。`tradegym`客户端提供了Python封装方法，通过REST
    API与RL环境进行交互。'
- en: 'The `Envs` class acts as a manager for the environments instantiated on the
    `tradegym` server. It also acts as a container for several environments as a client
    can send a request to create multiple (same or different) environments. When the
    `tradegym` client requests the `tradegym` server using the REST API to create
    a new environment, the server creates an instance of the requested environment
    and returns a unique instance ID (example: `8kdi4289`). From that point on, the
    client can refer to specific environments using the instance ID. This allows the
    client and the agent training code to interact with multiple environments simultaneously.
    Thus, the `tradegym` server acts as a true service with a RESTful interface over
    HTTP.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Envs`类充当`tradegym`服务器上实例化的环境的管理器。它还充当多个环境的容器，因为客户端可以发送请求创建多个（相同或不同的）环境。当`tradegym`客户端使用REST
    API请求`tradegym`服务器创建一个新环境时，服务器会创建所请求环境的实例并返回一个唯一的实例ID（例如：`8kdi4289`）。从此时起，客户端可以使用实例ID来引用特定的环境。这使得客户端和代理训练代码可以同时与多个环境进行交互。因此，`tradegym`服务器通过HTTP提供一个RESTful接口，充当一个真正的服务。'
- en: Ready for the next recipe? Let’s do it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好下一个流程了吗？让我们开始吧。
- en: Training RL agents using a remote simulator service
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用远程模拟器服务训练RL代理
- en: In this recipe, we will look at how we can utilize a remote simulator service
    to train our agent. We will be reusing the SAC agent implementation from one of
    the previous chapters and will focus on how we can train the SAC, or any of your
    RL agents for that matter, using an RL simulator that is running elsewhere (on
    the cloud, for example) as a service. We will leverage the `tradegym` server we
    built in the previous recipe to provide us with the RL simulator service for this
    recipe.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将探讨如何利用远程模拟器服务来训练我们的代理。我们将重用前面章节中的SAC代理实现，并专注于如何使用远程运行的强化学习模拟器（例如在云端）作为服务来训练SAC或任何强化学习代理。我们将使用前一个教程中构建的`tradegym`服务器为我们提供强化学习模拟器服务。
- en: Let’s get started!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To complete this recipe, and to ensure that you have the latest version, you
    will first need to activate the `tf2rl-cookbook` Python/conda virtual environment.
    Make sure to update the environment to match the latest conda environment specification
    file (`tfrl-cookbook.yml`) in the cookbook’s code repository. If the following
    `import` statements run without issues, you are ready to get started:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个教程，并确保你拥有最新版本，你需要先激活`tf2rl-cookbook` Python/conda虚拟环境。确保更新环境，以匹配食谱代码库中的最新conda环境规范文件（`tfrl-cookbook.yml`）。如果以下`import`语句没有问题，说明你已经准备好开始了：
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Let’s get right into it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入正题。
- en: How to do it…
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 怎么做……
- en: We will implement the core parts of the training script and leave out command-line
    configuration and other non-essential functionalities to keep the script concise.
    Let’s name our script `3_training_rl_agents_using_remote_sims.py`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现训练脚本的核心部分，并省略命令行配置及其他非必要功能，以保持脚本简洁。我们将命名脚本为`3_training_rl_agents_using_remote_sims.py`。
- en: Let’s get started!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: 'Let’s first create an application-level child logger, add a stream handler
    to it, and then set the logging level:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先创建一个应用级别的子日志记录器，添加一个流处理器，并设置日志级别：
- en: '[PRE35]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, let’s create a TensorFlow `SummaryWriter` to log the agent’s training
    progress:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个TensorFlow `SummaryWriter`来记录代理的训练进度：
- en: '[PRE36]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can now get to the core of our implementation. Let’s start the implementation
    of the `__main__` function and continue the implementation in the following steps.
    Let’s first set up the client to connect to the sim service using the server address:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以进入实现的核心部分。让我们从实现`__main__`函数开始，并在接下来的步骤中继续实现。首先设置客户端，使用服务器地址连接到模拟服务：
- en: '[PRE37]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, let’s ask the server to create our desired RL training environment to
    train our agent:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们请求服务器创建我们想要的强化学习训练环境来训练我们的代理：
- en: '[PRE38]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, let’s initialize our agent:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们初始化我们的代理：
- en: '[PRE39]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We are now ready to configure our training using a few hyperparameters:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备好使用一些超参数来配置训练：
- en: '[PRE40]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'With that, we are ready to start our outer training loop:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到此，我们已经准备好开始外部训练循环：
- en: '[PRE41]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let’s now handle the case where an episode has ended and `done` is set to `True`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们处理当一个回合结束并且`done`被设置为`True`的情况：
- en: '[PRE42]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now for the crucial steps! Let’s use the agent’s `act` and `train` methods
    to collect experience by acting (take actions) and training the agent using the
    collected experience:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是关键步骤！让我们使用代理的`act`和`train`方法，通过采取行动（执行动作）和使用收集到的经验来训练代理：
- en: '[PRE43]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let’s now update the variables to prepare for the next step in the episode:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们更新变量，为接下来的步骤做准备：
- en: '[PRE44]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'That completes our training loop. It was simple, wasn''t it? Let’s not forget
    to save the agent’s model after training so that we can use the trained model
    when it’s time for deployment:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就完成了我们的训练循环。很简单，对吧？训练完成后，别忘了保存代理的模型，这样在部署时我们就可以使用已训练的模型：
- en: '[PRE45]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can now proceed and run the script using the following command:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以继续并使用以下命令运行脚本：
- en: '[PRE46]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Did we forget something? Which sim server is the client connecting to? Is the
    sim server running?! If you get a long error on the command line that ends with
    a line that looks like the following, it certainly means that the sim server is
    not running:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们是不是忘了什么？客户端连接的是哪个模拟服务器？模拟服务器正在运行吗？！如果你在命令行看到一个类似以下的长错误信息，那么很可能是模拟服务器没有启动：
- en: '[PRE47]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let’s do it correctly this time! Let’s make sure our sim server is running
    by launching the `tradegym` server using the following command:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次我们要做对！让我们通过使用以下命令启动`tradegym`服务器，确保我们的模拟服务器正在运行：
- en: '[PRE48]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can now launch the agent training script using the following command (same
    as before):'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用以下命令启动代理训练脚本（与之前相同）：
- en: '[PRE49]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You should see an output similar to the following:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到类似以下内容的输出：
- en: '[PRE50]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: That completes our script for training RL agents using remote sims!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们用于通过远程仿真训练RL代理的脚本！
- en: How it works…
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: So far, we have been directly using the `gym` library to interact with the sim
    since we were running the RL environment simulators as part of the agent training
    scripts. While this will be good enough for CPU-bound local simulators, as we
    start to use advanced simulators or simulators that we don’t own, or even those
    cases where we don’t want to run or manage the simulator instances, we can leverage
    the client wrapper we built using our previous recipe in this chapter and talk
    to tradegym-like RL environments that expose a REST API for interfacing. In this
    recipe, the agent training script utilizes the `tradegym` client module to interact
    with a remote `tradegym` server to complete the RL training loop.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直直接使用`gym`库与仿真器交互，因为我们在代理训练脚本中运行RL环境仿真器。虽然对于依赖CPU的本地仿真器，这样做已经足够，但随着我们开始使用高级仿真器，或使用我们没有的仿真器，甚至在我们不想运行或管理仿真器实例的情况下，我们可以利用我们在本章之前配方中构建的客户端包装器，连接到像`tradegym`这样的RL环境，它们公开了REST
    API接口。在这个配方中，代理训练脚本利用`tradegym`客户端模块与远程`tradegym`服务器进行交互，从而完成RL训练循环。
- en: With that, let’s move on to the next recipe to see how we can evaluate previously
    trained agents.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，让我们继续下一个配方，看看如何评估之前训练过的代理。
- en: Testing/evaluating RL agents
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试/评估RL代理
- en: Let’s assume that you have trained the SAC agent in one of the trading environments
    using the training script (previous recipe) and that you have several versions
    of the trained agent models, each with different policy network architectures
    or hyperparameters or your own tweaks and customizations to improve its performance.
    When you want to deploy an agent, you want to make sure that you pick the best
    performing agent, don’t you?
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经使用训练脚本（前一个配方）在某个交易环境中训练了SAC代理，并且你有多个版本的训练代理模型，每个模型都有不同的策略网络架构或超参数，或者你对其进行了调整和自定义以提高性能。当你想要部署一个代理时，你肯定希望选择表现最好的代理，对吧？
- en: This recipe will help you build a lean script to evaluate a given pre-trained
    agent model locally so that you can get a quantitative performance assessment
    and compare several trained models before choosing the right agent model for deployment.
    Specifically, we will use the `tradegym` module and the `sac_agent_runtime` module
    that we built earlier in this chapter to evaluate the agent models that we train.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方将帮助你构建一个精简的脚本，用于在本地评估给定的预训练代理模型，从而获得定量性能评估，并在选择合适的代理模型进行部署之前比较多个训练模型。具体来说，我们将使用本章之前构建的`tradegym`模块和`sac_agent_runtime`模块来评估我们训练的代理模型。
- en: Let’s get started!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To complete this recipe, you will first need to activate the `tf2rl-cookbook`
    Python/conda virtual environment. Make sure to update the environment to match
    the latest conda environment specification file (`tfrl-cookbook.yml`) in the cookbook’s
    code repository. If the following `import` statements run without issues, you
    are ready to get started:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此配方，首先需要激活`tf2rl-cookbook`的Python/conda虚拟环境。确保更新环境以匹配最新的conda环境规范文件（`tfrl-cookbook.yml`），该文件位于食谱的代码库中。如果以下`import`语句没有问题，说明你已经准备好开始了：
- en: '[PRE51]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How to do it…
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let’s focus on creating a simple, but complete, agent evaluation script:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于创建一个简单但完整的代理评估脚本：
- en: 'First, let’s import the `tradegym` module for the training environment and
    the SAC agent runtime:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们导入用于训练环境的`tradegym`模块和SAC代理运行时：
- en: '[PRE52]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, let’s create a command-line argument parser to handle command-line configurations:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个命令行参数解析器来处理命令行配置：
- en: '[PRE53]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let’s now add support for the `--env` argument to specify the RL environment
    ID and `–-num-episodes` to specify the number of episodes for evaluating the agent.
    Let’s have some sensible default values for both the arguments so that we can
    run the script even without any arguments for quick (or lazy?!) testing:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为`--env`参数添加支持，以指定RL环境ID，并为`–-num-episodes`添加支持，以指定评估代理的回合数。让我们为这两个参数设置一些合理的默认值，这样即使没有任何参数，我们也能运行脚本进行快速（或者说是懒惰？）测试：
- en: '[PRE54]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let’s also add support for `–-trained-models-dir` to specify the directory
    containing the trained models, and the `–-model-version` flag to specify the specific
    version of the model in that trained directory:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们还为`–-trained-models-dir`添加支持，用于指定包含训练模型的目录，并为`–-model-version`标志添加支持，用于指定该目录中的特定模型版本：
- en: '[PRE55]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We are now ready to finalize the argument parsing:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备好完成参数解析：
- en: '[PRE56]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let’s begin our implementation of the `__main__` method in this step and continue
    its implementation in the following steps. Let’s start by creating a local instance
    of the RL environment in which we want to evaluate the agent:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从实现`__main__`方法开始，并在接下来的步骤中继续实现它。首先，我们从创建一个本地实例的RL环境开始，在该环境中我们将评估代理：
- en: '[PRE57]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let’s now initialize the agent class. For now, we only support the SAC agent,
    but it is quite easy to add support for other agents we have discussed in this
    book:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们初始化代理类。暂时我们只支持SAC代理，但如果你希望支持本书中讨论的其他代理，添加支持非常容易：
- en: '[PRE58]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, let’s load the trained agent models:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们加载训练好的代理模型：
- en: '[PRE59]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We are now ready to evaluate the agent using the trained models in the test
    environment:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备好使用测试环境中的训练模型来评估代理：
- en: '[PRE60]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let’s now try to evaluate the agent in the `StockTradingContinuous-v0` environment.
    Note that the market data source for the stocks trading environment in `data/MSFT.csv`
    and `data/TSLA.csv` can be different from the market data used for training! After
    all, we want to evaluate how well the agent has learned to trade! Run the following
    command to launch the agent evaluation script:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试在`StockTradingContinuous-v0`环境中评估代理。请注意，股票交易环境中的市场数据源（`data/MSFT.csv`和`data/TSLA.csv`）可能与用于训练的市场数据不同！毕竟，我们想要评估的是代理学会如何交易！运行以下命令启动代理评估脚本：
- en: '[PRE61]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Depending on how well your trained agents are, you will see output on the console
    similar to the following (reward values will vary):'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据你训练的代理表现如何，你会在控制台看到类似以下的输出（奖励值会有所不同）：
- en: '[PRE62]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: That’s it!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！
- en: How it works…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理……
- en: We initialized an SAC agent with only the runtime components that are required
    to evaluate the agent using the `sac_agent_runtime` module and then loaded previously
    trained model versions (for both the actor and the critic), which are both customizable
    using the command-line arguments. We then created a local instance of the `StockTradingContinuousEnv-v0`
    environment using the `tradegym` library and evaluated our agents to get the cumulative
    reward as one of the quantitative indicators of the performance of the trained
    agent models.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化了一个SAC代理，只使用了通过`sac_agent_runtime`模块评估代理所需的运行时组件，并加载了先前训练好的模型版本（包括演员和评论家模型），这些都可以通过命令行参数进行自定义。然后，我们使用`tradegym`库创建了一个`StockTradingContinuousEnv-v0`环境的本地实例，并评估了我们的代理，以便获取累积奖励作为评估训练代理模型性能的量化指标。
- en: Now that we know how to evaluate and pick the best performing agent, let’s move
    on to the next recipe to understand how to package the trained agent for deployment!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道如何评估并选择表现最好的代理，让我们进入下一个步骤，了解如何打包训练好的代理以进行部署！
- en: Packaging RL agents for deployment – a trading bot
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包强化学习代理以便部署——一个交易机器人
- en: This is one of the crucial recipes of this chapter, where we will be discussing
    how to package the agent so that we can deploy on the cloud (next recipe!) as
    a service. We will be implementing a script that takes our trained agent models
    and exposes the `act` method as a RESTful service. We will then package the agent
    and the API script into a **Docker** container that is ready to be deployed to
    the cloud! By the end of this recipe, you will have built a deployment-ready Docker
    container with your trained RL agent that is ready to create and offer your Agent/Bot-as-a-Service!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章的一个关键步骤，我们将在这里讨论如何将代理打包，以便我们可以将其作为服务部署到云端（下一个步骤！）。我们将实现一个脚本，该脚本将我们的训练好的代理模型并将`act`方法暴露为一个RESTful服务。接着，我们会将代理和API脚本打包成一个**Docker**容器，准备好部署到云端！通过本步骤，你将构建一个准备好部署的Docker容器，其中包含你的训练好的强化学习代理，能够创建并提供Agent/Bot-as-a-Service！
- en: Let’s jump into the details.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解细节。
- en: Getting ready
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To complete this recipe, you will first need to activate the `tf2rl-cookbook`
    Python/conda virtual environment. Make sure to update the environment to match
    the latest conda environment specification file (`tfrl-cookbook.yml`) in the cookbook’s
    code repository. If the following `import` statements run without issues, you
    are ready to undertake the next step, which is to set up Docker:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个步骤，你需要首先激活`tf2rl-cookbook`的Python/conda虚拟环境。确保更新环境，以便与cookbook代码库中的最新conda环境规格文件（`tfrl-cookbook.yml`）匹配。如果以下`import`语句没有问题，你就可以进行下一步，设置Docker环境：
- en: '[PRE63]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: For this recipe, you will need Docker installed. Please follow the official
    setup instructions to install Docker for your platform. You can find the instructions
    at [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，您需要安装Docker。请按照官方安装说明为您的平台安装Docker。您可以在[https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)找到相关说明。
- en: How to do it…
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'We will first implement the script to expose the agent’s `act` method as a
    REST service and then move on to create the Dockerfile for containerizing the
    agent:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先实现脚本，将代理的`act`方法暴露为REST服务，然后继续创建Dockerfile以将代理容器化：
- en: 'First, let’s import the `sac_agent_runtime` that we built earlier in this chapter:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们导入本章早些时候构建的`sac_agent_runtime`：
- en: '[PRE64]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, let’s create a handler for the command-line argument and `–-agent` as
    the first supported argument to allow specification of the agent algorithm we
    want to use:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们为命令行参数创建一个处理程序，并将`--agent`作为第一个支持的参数，以便指定我们想要使用的代理算法：
- en: '[PRE65]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, let’s add arguments to allow specification of the IP address and the
    port of the host server where our agent will be deployed. We will set and use
    the defaults for now and can change them from the command line when we need to:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们添加参数，以便指定我们代理将要部署的主机服务器的IP地址和端口。现在我们将设置并使用默认值，当需要时可以从命令行更改它们：
- en: '[PRE66]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Next, let’s add support for arguments to specify the directory containing the
    trained agent models and the specific model version to use:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们添加对指定包含训练好的代理模型的目录以及使用的特定模型版本的参数支持：
- en: '[PRE67]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'As the final set of supported arguments, let’s add arguments to allow specification
    of the observation shape and the action space specifications based on the trained
    model configuration:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为支持的最终参数集，让我们添加允许指定基于训练模型配置的观测形状和动作空间规格的参数：
- en: '[PRE68]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We can now finalize the argument parser and start the implementation of the
    `__main__` function:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以完成参数解析器，并开始实现`__main__`函数：
- en: '[PRE69]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'First, let’s load the runtime configurations for the agent:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们加载代理的运行时配置：
- en: '[PRE70]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, let’s create an instance of the agent and load the weights for the agent’s
    actor and critic networks from the pre-trained model:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个代理实例，并从预训练模型中加载代理的演员和评论家网络的权重：
- en: '[PRE71]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We can now set up the service endpoint using Flask, which is going to be as
    simple as shown in the following lines of code. Note that we are exposing the
    agent’s `act` method at the `/v1/act` endpoint:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用Flask设置服务端点，这将和以下代码行一样简单。请注意，我们在`/v1/act`端点暴露了代理的`act`方法：
- en: '[PRE72]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Finally, we just have to add the line that launches the Flask application to
    start the service when executed:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们只需要添加一行代码，当执行时启动Flask应用程序以启动服务：
- en: '[PRE73]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Our REST API implementation for the agent is ready. We can now focus on creating
    a Docker container for the agent service. We will start to implement the Dockerfile
    by specifying the base image to be `nvidia/cuda:*` so that we have the GPU drivers
    that are necessary to utilize the GPU on the server where we will be deploying
    the agent. The following code lines in this and the following steps will go into
    a file named `Dockerfile`:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的代理REST API实现已经完成。现在我们可以集中精力为代理服务创建一个Docker容器。我们将通过指定基础镜像为`nvidia/cuda:*`来开始实现Dockerfile，这样我们就能获得必要的GPU驱动程序，以便在部署代理的服务器上使用GPU。接下来的代码行将放入名为`Dockerfile`的文件中：
- en: '[PRE74]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Let’s now install a few system-level packages that are necessary and clean
    up the files to save disk space:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们安装一些必要的系统级软件包，并清理文件以节省磁盘空间：
- en: '[PRE75]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'To execute our agent runtime with all the necessary packages installed, we
    will make use of the conda Python environment. So, let’s go ahead and go through
    the instructions to download and set up `miniconda` in the container:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了执行我们的代理运行时并安装所有必需的软件包，我们将使用conda Python环境。所以，让我们继续按照说明下载并在容器中设置`miniconda`：
- en: '[PRE76]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Let’s now copy the source code of this chapter into the container and create
    the conda environment using the list of packages specified in the `tfrl-cookbook.yml`
    file:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们将本章的源代码复制到容器中，并使用`tfrl-cookbook.yml`文件中指定的软件包列表创建conda环境：
- en: '[PRE77]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Finally, we just have to set the `ENTRYPOINT` for the container and the `CMD`,
    which will be passed as arguments to the `ENTRYPOINT` when the container is launched:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们只需为容器设置`ENTRYPOINT`和`CMD`，当容器启动时，这些将作为参数传递给`ENTRYPOINT`：
- en: '[PRE78]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'That completes our Dockerfile and we are now ready to package our agent by
    building the Docker container. You can run the following command to build the
    Docker container as per the instructions in the Dockerfile and tag it with a container
    image name of your choice. Let’s use the following command:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这完成了我们的 Dockerfile，现在我们准备通过构建 Docker 容器来打包我们的代理。你可以运行以下命令，根据 Dockerfile 中的指令构建
    Docker 容器，并为其打上你选择的容器镜像名称。让我们使用以下命令：
- en: '[PRE79]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'If you are running the preceding command for the first time, it may take quite
    some time for Docker to build the container. Subsequent runs or updates will run
    faster as intermediate layers might already have been cached when run for the
    first time. When things are running smoothly, you will see an output similar to
    the following (note that most of the layers are cached since I had already built
    the container previously):'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你是第一次运行前面的命令，Docker 可能需要花费较长时间来构建容器。之后的运行或更新将会更快，因为中间层可能已经在第一次运行时被缓存。当一切顺利时，你会看到类似下面的输出（注意，由于我之前已经构建过容器，因此大部分层已经被缓存）：
- en: '[PRE80]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'For the layers that involve COPY/ADD file operations from the disk, the instructions
    will be run as they cannot be cached. For example, you will see that the following
    steps from *step 9* will continue to be run fresh without using any cache. This
    is normal even if you have already built the container:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于涉及从磁盘进行 COPY/ADD 文件操作的层，指令将会执行，因为它们无法被缓存。例如，你会看到以下来自*第 9 步*的步骤会继续执行而不使用任何缓存。即使你已经构建过容器，这也是正常的：
- en: '[PRE81]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Finally, when the Docker container is built, you will see something like the
    following message:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当 Docker 容器构建完成时，你将看到类似以下的消息：
- en: '[PRE82]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Congratulations on successfully packing your RL agent for deployment!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你成功打包了 RL 代理，准备部署！
- en: How it works…
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We leveraged the `sac_agent_runtime` we built earlier in this chapter to create
    and initialize an SAC agent instance. We then loaded pre-trained agent models
    for both the actor and the critic. After that, we exposed the SAC agent’s `act`
    method as a REST API with an HTTP POST endpoint for taking the observations as
    the POST message and returning actions as the response to the POST request. Finally,
    we launched the script as a Flask application to start serving.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用了本章前面构建的 `sac_agent_runtime` 来创建和初始化一个 SAC 代理实例。然后我们加载了预训练的代理模型，分别用于演员和评论员。之后，我们将
    SAC 代理的 `act` 方法暴露为一个 REST API，通过 HTTP POST 端点来接受观察值作为 POST 消息，并将动作作为响应返回。最后，我们将脚本作为
    Flask 应用启动，开始服务。
- en: In the second part of the recipe, we packaged the agent actioa-serving application
    as a Docker container and prepared it for deployment!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱的第二部分，我们将代理应用程序 actioa-serving 打包为 Docker 容器，并准备好进行部署！
- en: We are now on the verge of deploying the agent to the cloud! March on to the
    next recipe and find out how.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在即将将代理部署到云端！继续下一部分食谱，了解如何操作。
- en: Deploying RL agents to the cloud – a trading Bot-as-a-Service
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 RL 代理部署到云端——作为服务的交易机器人
- en: The ultimate goal of training an RL agent is to use it for taking actions given
    new observations. In the case of our stock trading SAC agent, we have so far learned
    to train, evaluate, and package the best performing agent model to build our trading
    bot. While we focused on one particular application (autonomous trading bot),
    you can see how easy it is to change the training environment or agent algorithms
    based on the recipes in earlier chapters of this book. This recipe will walk you
    through the steps to deploy the Docker containerized/packaged RL agent to the
    cloud and run the Bot-as-a-Service.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 训练 RL 代理的终极目标是利用它在新的观察值下做出决策。以我们的股票交易 SAC 代理为例，到目前为止，我们已经学会了如何训练、评估并打包表现最佳的代理模型来构建交易机器人。虽然我们集中在一个特定的应用场景（自动交易机器人），但你可以看到，根据本书前几章中的食谱，如何轻松地更改训练环境或代理算法。本食谱将指导你通过将
    Docker 容器化的 RL 代理部署到云端并运行作为服务的机器人。
- en: Getting ready
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正在准备中
- en: To complete this recipe, you will need access to a cloud service such as Azure,
    AWS, GCP, Heroku or another cloud service provider that allows you to host and
    run your Docker container. If you are a student, you can make use of GitHub’s
    student developer pack ([https://education.github.com/pack](https://education.github.com/pack)),
    which, as of 2020, allows you to avail yourself of several benefits for free,
    including $100 worth of Microsoft Azure credits or $50 platform credit on DigitalOcean
    if you are a new user.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个教程，你需要访问像Azure、AWS、GCP、Heroku等云服务，或其他支持托管和运行Docker容器的云服务提供商。如果你是学生，可以利用GitHub的学生开发者套餐（[https://education.github.com/pack](https://education.github.com/pack)），该套餐从2020年起为你提供一些免费福利，包括100美元的Microsoft
    Azure信用或作为新用户的50美元DigitalOcean平台信用。
- en: 'Several guides exist on how to push your Docker container to the cloud and
    to deploy/run the container as a service. For example, if you have an Azure account,
    you can following the official guide here: [https://docs.microsoft.com/en-us/azure/container-instances/container-instances-quickstart](https://docs.microsoft.com/en-us/azure/container-instances/container-instances-quickstart).'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多指南讲解如何将Docker容器推送到云端并作为服务部署/运行。例如，如果你有Azure账户，可以参照官方指南：[https://docs.microsoft.com/en-us/azure/container-instances/container-instances-quickstart](https://docs.microsoft.com/en-us/azure/container-instances/container-instances-quickstart)。
- en: The guide walks you through the various options (the CLI, Portal, PowerShell,
    ARM templates, and the Docker CLI) to deploy your Docker container-based agent
    service.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南将带你通过多种选项（CLI、门户、PowerShell、ARM模板和Docker CLI）来部署基于Docker容器的代理服务。
- en: How to do it…
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: We will first deploy the trading bot locally and test it out. After that, we
    can deploy it to your cloud service of choice. As an example, this recipe will
    walk you through the steps to deploy it to Heroku ([https://heroku.com](https://heroku.com)).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在本地部署交易机器人并进行测试。之后，我们可以将其部署到你选择的云服务上。作为示例，本教程将带你通过将其部署到Heroku的步骤（[https://heroku.com](https://heroku.com)）。
- en: 'Let’s begin:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始吧：
- en: 'Let’s first build our Docker container containing our trading bot using the
    following command. Note that if you have already built the container by following
    the previous recipe in this chapter, the following command may finish executing
    faster depending on the cached layers and your changes to the Dockerfile:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先使用以下命令构建包含交易机器人的Docker容器。请注意，如果你之前已经按照本章的其他教程构建过容器，那么根据缓存的层和对Dockerfile所做的更改，以下命令可能会更快地执行完毕：
- en: '[PRE83]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Once the Docker container with the bot has been built successfully, we can
    launch the bot using the following command:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Docker容器成功构建，我们可以使用以下命令启动机器人：
- en: '[PRE84]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'If all goes well, you should see console output somewhat similar to the following,
    indicating that the bot is up and running and ready to act:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该会看到类似以下的控制台输出，表示机器人已启动并准备好执行操作：
- en: '[PRE85]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now that you have deployed the trading bot locally (on your own server), let’s
    create a simple script to utilize the Bot-as-a-Service that you have built. Create
    a file named `test_agent_service.py` with the following content:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经在本地（在你自己的服务器上）部署了交易机器人，接下来我们来创建一个简单的脚本，利用你构建的Bot-as-a-Service。创建一个名为`test_agent_service.py`的文件，内容如下：
- en: '[PRE86]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'You can execute the script using the following command:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用以下命令执行该脚本：
- en: '[PRE87]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Note that your bot container still needs to be running. Once you execute the
    preceding command, you will see an output similar to the following line on the
    console output of your bot, indicating that a new POST message was received at
    the `/v1/act` endpoint, which was served with an HTTP response status of 200,
    indicating success:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，您的机器人容器仍需要运行。一旦执行前述命令，你将看到类似以下的输出，表示在`/v1/act`端点接收到新的POST消息，并返回了HTTP响应状态200，表示成功：
- en: '[PRE88]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'You will also notice that your test script will print out an output similar
    to the following on its console window, indicating that it received an action
    from the trading bot:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还会注意到，测试脚本在其控制台窗口中会打印出类似以下的输出，表示它收到了来自交易机器人的一个操作：
- en: '[PRE89]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'It’s time to deploy your trading bot to a cloud platform so that you or others
    can access it over the internet! As discussed in the *Getting started* section,
    you have several options in terms of choosing the cloud provider where you want
    to host your Docker container image and deploy the RL agent Bot-as-a-Service.
    We will use Heroku as an example as it offers free hosting and a simple CLI. First,
    you need to install the Heroku CLI. Follow the official instructions listed at
    [https://devcenter.heroku.com/articles/heroku-cli](https://devcenter.heroku.com/articles/heroku-cli)
    to install the Heroku CLI for your platform (Linux/Windows/macOS X). On Ubuntu
    Linux, we can use the following command:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是将你的交易机器人部署到云平台的时候了，这样你或其他人就可以通过互联网访问它！正如在*入门*部分所讨论的，你在选择云服务提供商方面有多个选择，可以将你的
    Docker 容器镜像托管并部署 RL 代理 Bot-as-a-Service。我们将以 Heroku 为例，它提供免费托管服务和简便的命令行界面。首先，你需要安装
    Heroku CLI。按照 [https://devcenter.heroku.com/articles/heroku-cli](https://devcenter.heroku.com/articles/heroku-cli)
    上列出的官方说明为你的平台（Linux/Windows/macOS X）安装 Heroku CLI。在 Ubuntu Linux 上，我们可以使用以下命令：
- en: '[PRE90]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Once the Heroku CLI is installed, you can log in to the Heroku container registry
    using the following command:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦安装了 Heroku CLI，你可以使用以下命令登录 Heroku 容器注册表：
- en: '[PRE91]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Next, run the following command from the directory containing the Dockerfile
    for the agent; for example:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从包含代理的 Dockerfile 的目录运行以下命令；例如：
- en: '[PRE92]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If you have not logged in to Heroku, you will be prompted to log in:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你尚未登录 Heroku，你将被提示登录：
- en: '[PRE93]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Once you are logged in, you will get an output similar to the following:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，你将看到类似如下的输出：
- en: '[PRE94]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'That’s the address of your container registry on Heroku. You can now build
    your bot container and push it to Heroku using the following command:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是你在 Heroku 上的容器注册表地址。你现在可以使用以下命令构建你的机器人容器并将其推送到 Heroku：
- en: '[PRE95]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Once that process completes, you can release the bot container image to your
    Heroku app using the following command:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦该过程完成，你可以使用以下命令将机器人容器镜像发布到 Heroku 应用：
- en: '[PRE96]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Congratulations! You have just deployed your bot to the cloud! You can now access
    your bot at the new address, such as [https://salty-fortress-4191.herokuapp.com/](https://salty-fortress-4191.herokuapp.com/)
    in the sample used in the preceding code. You should be able to send observations
    to your bot and get the actions in return! Congratulations on deploying your Bot-as-a-Service!
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚将你的机器人部署到了云端！你现在可以通过新的地址访问你的机器人，例如在之前代码中使用的示例地址 [https://salty-fortress-4191.herokuapp.com/](https://salty-fortress-4191.herokuapp.com/)。你应该能够向你的机器人发送观察数据，并获取机器人的回应动作！恭喜你成功部署了你的
    Bot-as-a-Service！
- en: We are now ready to wrap up the chapter.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好结束本章内容了。
- en: How it works…
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: We first built and launched the Docker container locally on your machine by
    using the `docker run` command and specifying that you want the local port `5555`
    to be mapped with the container’s port `5555`. This will allow the host (your
    machine) to communicate with your container using that port as if it were a local
    port on the machine. Following deployment, we used a test script that uses the
    Python `request` library to create a POST request with sample data for the observation
    values and sent it to the bot running in the container. We observed how the bot
    responded to the request via the command-line status output followed by a returned
    success response containing the bot’s trading action.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过使用 `docker run` 命令并指定将本地端口 `5555` 映射到容器的端口 `5555`，在你的机器上本地构建并启动了 Docker
    容器。这将允许主机（你的机器）使用该端口与容器通信，就像它是机器上的本地端口一样。部署后，我们使用了一个测试脚本，该脚本利用 Python 的 `request`
    库创建了一个带有观察值示例数据的 POST 请求，并将其发送到容器中的机器人。我们观察到机器人如何通过命令行的状态输出响应请求，并返回成功的回应，包含机器人的交易动作。
- en: We then deployed the same container with the bot to the cloud (Heroku). Following
    a successful deployment, the bot was accessible over the web using the public
    `herokuapp` URL created automatically by Heroku.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将相同的容器与机器人一起部署到云端（Heroku）。成功部署后，可以通过 Heroku 自动创建的公共 `herokuapp` URL 在网络上访问机器人。
- en: That completes the recipe and the chapter! I hope you enjoyed working through
    it. See you in the next chapter.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了本章的内容和食谱！希望你在整个过程中感到愉快。下章见。
