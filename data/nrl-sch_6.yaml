- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Building Practical Examples with Jina
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jina 构建实际示例
- en: In this chapter, we will build simple real-world applications using Jina’s neural
    search framework. Building on the concepts we have learned in the previous chapters,
    we will now look at how to use Jina to create valuable applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将使用 Jina 的神经搜索框架构建简单的现实应用。基于前几章学到的概念，我们将探讨如何利用 Jina 创建有价值的应用。
- en: We will learn about the practical aspects of the Jina framework and how you
    can leverage them to quickly build and deploy sophisticated search solutions.
    We will walk you through the code base of three different applications built on
    Jina, and see how the different components that you learned about in the previous
    chapter work in tandem to create a search application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习 Jina 框架的实际应用，并了解如何利用它们快速构建和部署复杂的搜索解决方案。我们将带您逐步了解基于 Jina 构建的三个不同应用的代码，并查看上一章中学到的不同组件如何协同工作以创建一个搜索应用。
- en: 'We will cover the following three examples in this chapter, which will get
    you started on the journey of building with Jina:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将介绍以下三个示例，帮助您开始使用 Jina 构建应用：
- en: The Q/A chatbot
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问答聊天机器人
- en: Fashion image search
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时尚图像搜索
- en: Multimodal search
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多模态搜索
- en: With this chapter, we aim to get you started by building practical examples
    to understand the potential of Jina’s neural search framework. It is a great stepping
    stone for venturing into the world of neural search for building state-of-the-art
    search solutions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是通过构建实际示例，帮助您入门并理解 Jina 神经搜索框架的潜力。这是踏入神经搜索领域并构建最先进搜索解决方案的绝佳起点。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow along with the application code discussed in this chapter, clone the
    GitHub repository available at https://github.com/jina-ai/jina/tree/master/jina/helloworld.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章讨论的应用代码，您可以克隆 GitHub 上的代码库，地址为 https://github.com/jina-ai/jina/tree/master/jina/helloworld。
- en: Getting started with the Q/A chatbot
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用问答聊天机器人
- en: The **Q/A chatbot** is a pre-built example that comes with the Jina installation.
    To experience the power of Jina firsthand and quickly get started, you can run
    the Q/A chatbot example directly from the command line without even getting into
    the code. The Q/A chatbot uses the public Covid Q/A dataset (https://www.kaggle.com/datasets/xhlulu/covidqa)
    from Kaggle, which contains 418 Q/A pairs (https://www.kaggle.com/xhlulu/covidqa).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**问答聊天机器人**是一个随 Jina 安装包提供的预构建示例。为了亲身体验 Jina 的强大功能并快速入门，您可以直接从命令行运行问答聊天机器人示例，而无需深入代码。问答聊天机器人使用的是来自
    Kaggle 的公共 Covid 问答数据集（https://www.kaggle.com/datasets/xhlulu/covidqa），该数据集包含
    418 对问答（https://www.kaggle.com/xhlulu/covidqa）。'
- en: 'Follow these instructions to set up the development environment and run the
    Q/A chatbot example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照以下说明设置开发环境并运行问答聊天机器人示例：
- en: 'The first step is to install the Jina library from the **Python Package Index**
    (**PyPI**) along with the required dependencies:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是从**Python 软件包索引**（**PyPI**）安装 Jina 库以及所需的依赖项：
- en: '[PRE0]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After that, simply type the following command to launch your app:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，只需输入以下命令即可启动您的应用：
- en: '[PRE1]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After typing this command, you will see the following text on your **command-line
    interface** (**CLI**):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 输入此命令后，您将在您的**命令行界面**（**CLI**）中看到以下文本：
- en: '![Figure 6.1 – Q/A chatbot command line  ](img/Figure_6.01_B17488.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 问答聊天机器人命令行](img/Figure_6.01_B17488.jpg)'
- en: Figure 6.1 – Q/A chatbot command line
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 问答聊天机器人命令行
- en: If your screen displays the same text on the command line, it means you have
    successfully launched the Q/A chatbot example. Now, it’s time to open the **user
    interface** (**UI**) and play with the chatbot.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的屏幕上显示了相同的命令行文本，说明您已经成功启动了问答聊天机器人示例。现在，是时候打开**用户界面**（**UI**）并与聊天机器人互动了。
- en: By default, a simple chat interface will open up, allowing you to chat with
    the Q/A chatbot. If the page doesn’t open up itself, you can open `index.xhtml`
    by going to `jina/helloworld/chatbot/static`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，系统会打开一个简单的聊天界面，允许您与问答聊天机器人进行对话。如果页面没有自动打开，您可以通过访问 `jina/helloworld/chatbot/static`
    来打开 `index.xhtml` 文件。
- en: 'You will see the following web page either by default or after opening the
    `index.xhtml` file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下网页，默认情况下或打开 `index.xhtml` 文件后都会显示：
- en: '![Figure 6.2 – Q/A chatbot interface ](img/Figure_6.02_B17488.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 问答聊天机器人界面](img/Figure_6.02_B17488.jpg)'
- en: Figure 6.2 – Q/A chatbot interface
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 问答聊天机器人界面
- en: You have successfully launched the Q/A chatbot application; it’s time to play
    with it and have some fun. You can ask the chatbot for any Covid-related facts,
    figures, or queries and see the magic in action!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经成功启动了问答聊天机器人应用程序；现在可以尽情玩耍，享受其中的乐趣。你可以向聊天机器人询问任何与 Covid 相关的事实、数据或问题，并看到魔法的实现！
- en: Navigating through the code
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览代码
- en: Let’s now go through the logic behind the application and see how Jina’s framework
    ties all the components together to produce a functioning Q/A chatbot application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下应用程序背后的逻辑，看看 Jina 的框架是如何将所有组件连接起来，生成一个功能齐全的问答聊天机器人应用程序的。
- en: 'In order to see the code and understand the different components that work
    together to bring up this application after installing Jina, go to the chatbot
    directory by following the `jina/helloworld/chatbot` path. This is the main directory
    that contains the code for the chatbot example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看代码并了解在安装 Jina 后，如何通过不同的组件共同作用来启动这个应用程序，进入聊天机器人目录，按照 `jina/helloworld/chatbot`
    路径操作。这个目录是包含聊天机器人示例代码的主要目录：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following are the files that you will see within the chatbot directory:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你将在聊天机器人目录中看到的文件：
- en: '`app.py`: This is the main entry point/brain of the application.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.py`：这是应用程序的主入口点/大脑。'
- en: '`my_executors.py`: This file is responsible for all the backend processing.
    It includes the logic behind the application, which we call **executors** in Jina
    terminology. It hosts multiple executors to transform, encode, and index the data.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my_executors.py`：该文件负责所有后台处理。它包含应用程序背后的逻辑，我们在 Jina 术语中称之为 **执行器**。它包含多个执行器，用于转换、编码和索引数据。'
- en: '`static`: This folder hosts all the frontend code responsible for rendering
    the chatbot interface on the web browser that helps you interact with the chatbot
    application.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static`：这个文件夹包含所有前端代码，负责在网页浏览器中渲染聊天机器人界面，帮助你与聊天机器人应用程序进行互动。'
- en: We will have a detailed look at the functioning of each of these files in the
    following subsections.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的小节中详细了解这些文件的功能。
- en: app.py
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: app.py
- en: The `app.py` file is the entry point of the example application. As soon as
    you type the `jina hello chatbot` command, the control goes to this file. It’s
    the main entry point for the application and performs all the major tasks of bringing
    up the application’s UI and running the backend code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.py` 文件是示例应用程序的入口点。当你输入 `jina hello chatbot` 命令时，控制权会转到这个文件。它是应用程序的主要入口点，负责启动应用程序的
    UI 并运行后台代码。'
- en: The `app.py` file performs the following tasks to ensure that multiple components
    work in tandem with each other to produce the desired result.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.py` 文件执行以下任务，确保多个组件协同工作，产生预期的结果。'
- en: 'The first thing it does is import the required executors from the `my_executors.py`
    file using the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先做的事情是通过以下代码从 `my_executors.py` 文件中导入所需的执行器：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Both of these executors are derived from the base `Executor` class of Jina:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个执行器都派生自 Jina 的基类 `Executor`：
- en: The `MyTransformer` executor is responsible for encoding and transforming the
    data.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyTransformer` 执行器负责编码和转换数据。'
- en: The `MyIndexer` executor is used for indexing the data.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyIndexer` 执行器用于索引数据。'
- en: We will learn about the functioning of both of these executors in detail when
    we talk about the `my_executors.py` file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在讨论 `my_executors.py` 文件时，详细了解这两个执行器的功能。
- en: '`Flow` allows you to add encoding and indexing in the form of executors, and
    in the chatbot example, we use the following executors. You can use the following
    code to create a flow and add these executors to it:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow` 允许你以执行器的形式添加编码和索引，在聊天机器人示例中，我们使用以下执行器。你可以使用以下代码来创建一个流程并将这些执行器添加到其中：'
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is one of the simple flows with just two executors. For a complex flow
    with many executors, Jina provides the functionality to distinguish each of the
    executors with distinct names (for example, by using the `name` parameter, you
    can give your executors some really cool names). It then allows you to visualize
    the flow to understand how your data flows through different components. Let’s
    visualize this flow by adding a single line to the existing code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的流程，只有两个执行器。对于具有多个执行器的复杂流程，Jina 提供了通过不同的名称区分每个执行器的功能（例如，通过使用 `name` 参数，你可以为你的执行器起一些非常酷的名字）。然后，它允许你可视化流程，以了解数据如何在不同组件之间流动。让我们通过在现有代码中添加一行来可视化这个流程：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Running the preceding code will generate the following `SVG` file that visualizes
    the chatbot flow:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将生成以下`SVG`文件，用于可视化聊天机器人流程：
- en: '![Figure 6.3 – Chatbot flow ](img/Figure_6.3_B17488.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 聊天机器人流程](img/Figure_6.3_B17488.jpg)'
- en: Figure 6.3 – Chatbot flow
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 聊天机器人流程
- en: Note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since we want to call our flow from the browser, it’s important to enable Cross-Origin
    Resource Sharing (https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) within
    Flow (`cors=True`).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想通过浏览器调用流程，因此在Flow中启用跨源资源共享（https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS）非常重要（`cors=True`）。
- en: 'Once we have the flow ready, it’s time to dive into the `hello_world` function
    in the `app.py` file, which brings together everything from different sources
    and opens a query endpoint (a backend endpoint) for you to query and interact
    with the chatbot application:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们准备好流程，就可以开始深入探讨`app.py`文件中的`hello_world`函数，它将不同来源的内容汇集在一起，并为你提供一个查询端点（后端端点），你可以通过这个端点与聊天机器人应用程序进行交互：
- en: The `hello_world` function starts by creating a `workspace` directory to store
    the indexed data and ensures that the required dependencies are imported.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`hello_world`函数首先创建一个`workspace`目录来存储已索引的数据，并确保导入所需的依赖项。'
- en: Note
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To run this example, we require two major dependencies/Python libraries: `torch`
    and `transformers`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，我们需要两个主要的依赖项/Python库：`torch`和`transformers`。
- en: 'Install the dependencies by using the following commands before we move forward
    with the code:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续代码之前，使用以下命令安装依赖项：
- en: '`pip install torch`'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pip install torch`'
- en: '`pip install transformers`'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pip install transformers`'
- en: After installing these dependencies, it’s time to continue with the `hello_world`
    function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 安装这些依赖项后，接下来我们继续`hello_world`函数的编写。
- en: The next step is to download the data from Kaggle. For that, we will use the
    `download_data` function, which basically uses the `urllib` library to fetch and
    save the data from the given URL.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是从Kaggle下载数据。为此，我们将使用`download_data`函数，该函数基本上利用`urllib`库从给定的URL抓取并保存数据。
- en: 'The `urllib` module takes `url` and `filename` as the target and downloads
    the data. You can refer to the following code to see how we set the target:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`urllib`模块接受`url`和`filename`作为目标，并下载数据。你可以参考以下代码查看我们如何设置目标：'
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Passing the target variable into the `download_data` function will download
    the data and save it as a `.csv` file in a random folder within the same working
    directory.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将目标变量传入`download_data`函数，将会下载数据并将其保存为`.csv`文件，保存在同一工作目录中的一个随机文件夹里。
- en: 'Now we have all the basic components required to index the data, we will use
    the dataset downloaded in the previous step and index it using the flow that we
    created previously. Indexing will follow this logic:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了索引数据所需的所有基本组件，我们将使用前一步下载的数据，并使用之前创建的流程进行索引。索引将遵循以下逻辑：
- en: It will use the `MyTransformer` executor to encode and transform the data by
    computing the corresponding embeddings.
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将使用`MyTransformer`执行器通过计算相应的嵌入来编码和转换数据。
- en: It will use the `MyIndexer` executor to index the data via the `/index` endpoint
    and open the `/search` endpoint to query and interact with the chatbot.
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将使用`MyIndexer`执行器通过`/index`端点索引数据，并打开`/search`端点以查询并与聊天机器人进行交互。
- en: 'The following is the code that indexes the data and creates a search endpoint
    to interact with the chatbot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是索引数据并创建搜索端点与聊天机器人进行交互的代码：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code, we open the flow and the dataset with a context manager
    and send the data in the form of a `''question'': ''text''` pair to the index
    endpoint. For this example, we will use the web browser to interact with the chatbot,
    which requires configuring and serving the flow on a specific port with the HTTP
    protocol using the `port_expose` parameter, so that the web browser can make requests
    to the flow. Toward the end, we will use `f.block()` to keep the flow open for
    search queries and to prevent it from exiting.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码中，我们使用上下文管理器打开流程和数据集，并将数据以`''question'': ''text''`对的形式发送到索引端点。对于这个示例，我们将使用网页浏览器与聊天机器人进行交互，这需要通过`port_expose`参数在特定端口上配置并提供流程，使用HTTP协议，使浏览器能够向流程发起请求。最后，我们将使用`f.block()`保持流程打开，以便进行搜索查询，并防止它退出。'
- en: my_executors.py
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: my_executors.py
- en: The other key component of the chatbot example is the `my_executors.py` file,
    which contains the logical elements of the application, also known as **executors**.
    It consists of two different executors, which we will discuss in detail.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天机器人示例的另一个关键组件是`my_executors.py`文件，它包含了应用程序的逻辑元素，也称为**执行器**。该文件包含两个不同的执行器，我们将详细讨论这两个执行器。
- en: The MyTransformer executor
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MyTransformer 执行器
- en: 'The `MyTransformer` executor performs the following tasks:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyTransformer`执行器执行以下任务：'
- en: It loads the pre-trained sentence transformer model from the `sentence-transformers`
    library.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从`sentence-transformers`库加载了预训练的句子变换器模型。
- en: 'It takes in the user arguments and sets up the model parameters (such as `model
    name`/`path`) and `pooling strategy`, fetches the tokenizer corresponding to the
    model, and sets up the device to `cpu`/`gpu`, depending on the user’s preference:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它接收用户的参数并设置模型参数（例如`model name`/`path`）和`pooling strategy`，获取与模型对应的分词器，并根据用户的偏好设置设备为`cpu`/`gpu`：
- en: '[PRE8]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After setting up these parameters, it computes the embedding for the textual
    data and encodes textual data/question-answer as a key-value pair in the form
    of an embedding map.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置完这些参数之后，它会计算文本数据的嵌入，并将文本数据/问答编码为键值对形式的嵌入映射。
- en: Encoding is performed through a `sentence-transformers` model (`paraphrase-mpnet-base-v2`,
    by default). We get the text attributes of documents in batches and then compute
    embeddings, which we later set as the embedding attribute for each of the documents.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编码通过`sentence-transformers`模型（默认使用`paraphrase-mpnet-base-v2`）执行。我们按批次获取文档的文本属性，然后计算嵌入，之后将这些嵌入设置为每个文档的嵌入属性。
- en: The `MyTransformer` executor exposes only one endpoint, `encode`, which is called
    whenever we request the flow, either on a query or index. The endpoint creates
    embeddings for the indexed or query documents so the search endpoint can use similarity
    scores to determine the closest match for a given query.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MyTransformer`执行器只公开一个端点`encode`，每当我们请求流程时（无论是查询还是索引），都会调用该端点。该端点为索引或查询文档创建嵌入，以便搜索端点可以使用相似度分数来确定给定查询的最接近匹配项。'
- en: 'Let’s look at a simplified version of the `encode` function for the `MyTransformer`
    executor that we have in the main chatbot application:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下主聊天机器人应用程序中`MyTransformer`执行器的`encode`函数的简化版本：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The MyIndexer executor
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MyIndexer 执行器
- en: 'The `MyIndexer` executor performs the following tasks:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyIndexer`执行器执行以下任务：'
- en: It uses a document store (SQLite, in our case) that contains all the documents
    of `DocumentArray`. The look and feel of `DocumentArray` with an external store
    are almost the same as a regular in-memory `DocumentArray`, but it makes the process
    more efficient and allows faster retrieval.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用一个文档存储（在我们的例子中是SQLite），该存储包含所有`DocumentArray`的文档。与外部存储的`DocumentArray`在外观和操作上几乎相同于常规的内存中的`DocumentArray`，但它使得处理更加高效，并且允许更快速的检索。
- en: 'The executor exposes two endpoints: `index` and `search`. The `index` endpoint
    is responsible for taking in the documents and indexing them, while the `search`
    endpoint is responsible for traversing the indexed `DocumentArray` to find the
    relevant match for the user queries.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行器公开了两个端点：`index`和`search`。`index`端点负责接收文档并对其进行索引，而`search`端点负责遍历已索引的`DocumentArray`以找到与用户查询相关的匹配项。
- en: The `search` endpoint uses the `match` method (a built-in method associated
    with `DocumentArray`), which returns the top closest match for the query documents
    using cosine similarity.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`search`端点使用`match`方法（这是与`DocumentArray`相关联的内置方法），该方法通过余弦相似度返回查询文档的最接近匹配项。'
- en: 'Let’s look at a simplified version of code for the `MyIndexer` executor that
    we have in the main chatbot application:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下主聊天机器人应用程序中`MyIndexer`执行器的简化代码版本：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These two executors are the building blocks of the chatbot application, and
    combining them allows us to create an interactive and intelligent chatbot backend.
    To interact with the chatbot in the web browser via the UI, you can use the HTML
    template provided in the `static` folder. Running the application by default will
    open a web page with the chatbot UI; if it doesn’t, then you can open the `index.xhtml`
    file from the `static` folder.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个执行器是聊天机器人应用程序的构建模块，结合这两个执行器使我们能够创建一个互动的智能聊天机器人后端。要通过UI在网页浏览器中与聊天机器人互动，您可以使用`static`文件夹中提供的HTML模板。默认情况下，运行应用程序会打开一个包含聊天机器人UI的网页；如果没有自动打开，您可以从`static`文件夹中打开`index.xhtml`文件。
- en: In this section, we looked at the code behind the Q/A chatbot application for
    the Covid-19 dataset. The application is a form of text-to-text search engine
    created using Jina’s framework. The same logic can be used to create a variety
    of text search applications depending on your use case.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们查看了用于Covid-19数据集的问答聊天机器人应用程序背后的代码。该应用程序是一个文本到文本的搜索引擎，使用Jina框架创建。根据您的使用场景，相同的逻辑可以用于创建各种文本搜索应用程序。
- en: In the next section, we will explore how to extend the search capabilities for
    unstructured data types such as images, and see how Jina’s neural search makes
    it easy to build an image-to-image search engine using the fashion image search
    example.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分中，我们将探讨如何扩展对非结构化数据类型（如图像）的搜索能力，并了解Jina的神经搜索如何使构建图像到图像的搜索引擎变得更加容易，使用时尚图像搜索示例。
- en: Understanding fashion image search
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解时尚图像搜索
- en: '**Fashion image search** is another pre-built example that comes with the Jina
    installation, which you can run just like the Q/A chatbot example directly from
    the comfort of your command line without even getting into the code.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**时尚图像搜索**是Jina安装包中另一个预构建的示例，您可以像运行问答聊天机器人示例一样直接从命令行启动，而无需深入代码。'
- en: The fashion image search example uses the famous *Fashion-MNIST* dataset of
    Zalando’s article images (https://github.com/zalandoresearch/fashion-mnist) consisting
    of 60,000 training examples and 10,000 examples in the test set. Each example
    is a 28x28 grayscale image, associated with a label from 10 classes just like
    the original MNIST dataset.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 时尚图像搜索示例使用了Zalando文章图片的著名*Fashion-MNIST*数据集（https://github.com/zalandoresearch/fashion-mnist），该数据集包含60,000个训练样本和10,000个测试样本。每个样本都是一个28x28的灰度图像，并且与10个类别中的一个标签相关联，类似于原始的MNIST数据集。
- en: 'Each training and test set example is assigned one of the following labels:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每个训练和测试集样本都会分配以下标签之一：
- en: '| **Label** | **Description** |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **标签** | **描述** |'
- en: '| 0 | T-shirt/Top |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 0 | T恤/上衣 |'
- en: '| 1 | Trouser |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 长裤 |'
- en: '| 2 | Pullover |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 套头衫 |'
- en: '| **Label** | **Description** |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **标签** | **描述** |'
- en: '| 3 | Dress |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 连衣裙 |'
- en: '| 4 | Coat |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 外套 |'
- en: '| 5 | Sandal |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 凉鞋 |'
- en: '| 6 | Shirt |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 衬衫 |'
- en: '| 7 | Sneaker |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 运动鞋 |'
- en: '| 8 | Bag |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 包 |'
- en: '| 9 | Ankle boot |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 踝靴 |'
- en: Table 6.1 – Fashion dataset labels and description
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.1 – 时尚数据集标签和描述
- en: 'In the previous section, we installed the `jina[demo]` library from PyPI, which
    took care of all the dependencies required to run this example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一部分中，我们从PyPI安装了`jina[demo]`库，该库处理了运行此示例所需的所有依赖项：
- en: 'Let’s go to the command line and run the fashion image search example:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进入命令行并运行时尚图像搜索示例：
- en: '[PRE11]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After typing this command, you will see the following text on your CLI:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入此命令后，您将在命令行界面（CLI）上看到以下文本：
- en: '![Figure 6.4 – Fashion image search command line  ](img/Figure_6.04_B17488.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 时尚图像搜索命令行界面](img/Figure_6.04_B17488.jpg)'
- en: Figure 6.4 – Fashion image search command line
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 时尚图像搜索命令行界面
- en: If your screen displays the same text on the command line, it means you have
    successfully launched the fashion image search example, so now it’s time to open
    the UI and play with the application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的屏幕在命令行上显示相同的文本，说明您已成功启动了时尚图像搜索示例，现在可以打开用户界面并开始使用该应用程序了。
- en: By default, a simple web page will open up with a random sample of images from
    the test set as queries, along with the retrieved results from the training data.
    Behind the scenes, Jina downloads the *Fashion-MNIST* dataset and indexes 60,000
    training images via the indexing flow. After that, it selects randomly sampled
    unseen images from the test set as queries and asks Jina to retrieve relevant
    results.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，将打开一个简单的网页，展示从测试集中的随机样本作为查询的图像，以及从训练数据中检索到的结果。在后台，Jina会下载*Fashion-MNIST*数据集，并通过索引流程对60,000个训练图像进行索引。之后，它会从测试集中随机选择未见过的图像作为查询，并请求Jina检索相关的结果。
- en: 'If the page doesn’t open up itself, you can open the `demo.xhtml` file present
    at the `*/demo.xhtml` path. You will see the following web page either by default
    or after opening the downloaded `demo.xhtml` file manually:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果页面没有自动打开，您可以打开位于`*/demo.xhtml`路径下的`demo.xhtml`文件。您将看到以下网页，无论是默认打开，还是手动打开下载的`demo.xhtml`文件后显示：
- en: '![Figure 6.5 – Fashion image search web interface  ](img/Figure_6.05_B17488.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 时尚图像搜索网页界面](img/Figure_6.05_B17488.jpg)'
- en: Figure 6.5 – Fashion image search web interface
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 时尚图像搜索网页界面
- en: You can see in the preceding figure how Jina does an amazing job in finding
    the relevant search results for the image queries selected randomly from the test
    set.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前面的图中看到，Jina 如何在从测试集中随机选择的图像查询中，出色地找到相关的搜索结果。
- en: Navigating through the code
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航代码
- en: Let’s now go through the logic behind the app and see how Jina’s framework ties
    all the components together to create an image search application.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来了解一下应用程序背后的逻辑，看看 Jina 的框架是如何将所有组件结合起来创建一个图像搜索应用程序的。
- en: 'After installing Jina, go to the chatbot directory by following the `jina/helloworld/fashion`
    path. This is the main directory that contains the code for the fashion image
    search example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Jina 后，按照 `jina/helloworld/fashion` 路径进入聊天机器人目录。这个目录包含了时尚图像搜索示例的代码：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following are the files that you will see within the fashion directory:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你将在时尚目录中看到的文件：
- en: '`app.py`: Similar to the application discussed in the previous section.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.py`：类似于上一节讨论的应用程序。'
- en: '`my_executors.py`: Similar to the application discussed in the previous section.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my_executors.py`：类似于上一节讨论的应用程序。'
- en: '`helper.py`: This consists of the supplementary logic functions to modularize
    the logical code blocks and keep them in a separate file.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`helper.py`：这个文件包含了辅助逻辑函数，用于模块化逻辑代码块并将其保持在单独的文件中。'
- en: '`demo.xhtml`: This hosts all the frontend code responsible for rendering the
    chatbot interface on the web browser, which helps you interact with the chatbot
    application.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`demo.xhtml`：这个文件包含了所有前端代码，负责在网页浏览器中呈现聊天机器人界面，帮助你与聊天机器人应用程序进行互动。'
- en: app.py
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: app.py
- en: The `app.py` file is the entry point of the example application; as soon as
    you type the `jina hello fashion` command, the control goes to this file. This
    is the main entry point for the application and performs all the major tasks to
    bring up the application’s frontend and the backend.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.py` 文件是示例应用程序的入口点；一旦你输入 `jina hello fashion` 命令，控制会跳转到这个文件。这是应用程序的主要入口点，执行所有主要任务以启动应用程序的前端和后端。'
- en: The `app.py` file performs the following tasks to ensure that multiple components
    work in tandem with each other to produce the desired application.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.py` 文件执行以下任务，以确保多个组件协同工作，产生所需的应用程序。'
- en: 'The first thing it does is import the required executors from the `my_executors.py`
    file using the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先通过以下代码从 `my_executors.py` 文件导入所需的执行器：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'All of these executors are derived from the base `Executor` class of Jina:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些执行器都继承自 Jina 的基础 `Executor` 类：
- en: '`MyEncoder` is responsible for transforming and encoding the data.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyEncoder` 负责转换和编码数据。'
- en: '`MyIndexer` is used for indexing the data; after indexing, it hosts a `/search`
    endpoint for querying the data.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyIndexer` 用于对数据进行索引；索引完成后，它托管一个 `/search` 端点用于查询数据。'
- en: We will learn about the functioning of all these executors in detail when we
    talk about the `my_executors.py` file. The flow for this example consists of the
    aforementioned executors.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论 `my_executors.py` 文件时，我们将详细了解所有这些执行器的功能。这个示例的流程包含了上述执行器。
- en: 'You can use the following code to create and visualize the flow:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下代码来创建并可视化流程：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Running the code will generate the following flow diagram, which shows how
    the data moves through different components of the applications:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码将生成以下流程图，展示数据如何在应用程序的不同组件之间流动：
- en: '![Figure 6.6 – Fashion image search flow ](img/Figure_6.6_B17488.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 时尚图像搜索流程](img/Figure_6.6_B17488.jpg)'
- en: Figure 6.6 – Fashion image search flow
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 时尚图像搜索流程
- en: In the preceding code, the `replicas` parameter is set to `2` for the `MyEncoder`
    executor to divide the input data stream into two different executors for faster
    processing and encoding.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`replicas` 参数被设置为 `2`，使得 `MyEncoder` 执行器将输入数据流分成两个不同的执行器，以便更快地处理和编码。
- en: 'Once we have the flow ready, it’s time to dive into the `hello_world` function
    in the `app.py` files, which brings together everything from different sources.
    The `hello_world` function performs the following tasks:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦流程准备好，就可以深入探讨 `app.py` 文件中的 `hello_world` 函数，它将不同来源的内容整合在一起。`hello_world`
    函数执行以下任务：
- en: It creates a `workspace` directory in the root folder to store the indexed data.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在根文件夹中创建一个 `workspace` 目录，用于存储索引的数据。
- en: 'It creates a `targets` dictionary to associate the URL of the data with the
    local filenames where the data will be saved. It saves the training data under
    the `index` and `index-label` files, and the test data under the `query` and `query-label`
    files:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它创建了一个`targets`字典，将数据的URL与数据将被保存的本地文件名关联起来。它将训练数据保存在`index`和`index-label`文件中，将测试数据保存在`query`和`query-label`文件中：
- en: '[PRE15]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After that, it passes the `targets` variable to the `download_data` function
    and downloads the *Fashion-MNIST* dataset. The `download_data` function uses the
    `urllib` package to download the data from the given URL and iterate through the
    dictionary to save the data and the labels for the training and the test set.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，它将`targets`变量传递给`download_data`函数并下载*Fashion-MNIST*数据集。`download_data`函数使用`urllib`包从给定的URL下载数据，并遍历字典保存训练集和测试集的数据及标签。
- en: It creates the flow and adds the `MyEncoder` and `MyIndexer` executors.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它创建了流程并添加了`MyEncoder`和`MyIndexer`执行器。
- en: It opens the flow with the context manager and uses the indexing flow to index
    the data by creating the embeddings for all the images in the training data.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用上下文管理器打开流程，并使用索引流程为训练数据中的所有图像创建嵌入向量，从而对数据进行索引。
- en: It then includes the ground truth (labels) along with the query images, which
    allows us to evaluate the performance of the model.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它还包括真实标签（labels）与查询图像一起，这使我们能够评估模型的性能。
- en: After indexing the data, it calls the `search` function, which randomly samples
    128 unseen images as queries and returns the top 50 similar images for each of
    the query images.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 索引数据后，它调用`search`函数，随机抽取128张未见过的图像作为查询，并返回每个查询图像的前50个最相似图像。
- en: 'Finally, we use the `write_html` function to render the frontend in the web
    browser using the `demo.xhtml` file:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`write_html`函数，通过`demo.xhtml`文件在网页浏览器中渲染前端：
- en: '[PRE16]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: my_executors.py
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: my_executors.py
- en: The other key component of the fashion image search example is the `my_executors.py`
    file. It consists of three different executors that work together in the flow
    to create an end-to-end application experience.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 时尚图片搜索示例的另一个关键组件是`my_executors.py`文件。它由三个不同的执行器组成，这些执行器在流程中协同工作，创建了一个端到端的应用体验。
- en: The MyEncoder executor
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MyEncoder执行器
- en: 'The `MyEncoder` executor performs the following tasks:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyEncoder`执行器执行以下任务：'
- en: It is used in both indexing and the querying flow. It is fed with the index
    and query data yielded from the respective generator functions. It uses **singular
    value decomposition** (**SVD**) to encode the incoming data.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在索引和查询流程中都被使用。它接收来自各自生成器函数的索引数据和查询数据。它使用**奇异值分解**（**SVD**）对传入的数据进行编码。
- en: In the constructor, it creates a random matrix of shape (`784,64`) and applies
    SVD to get `oth_mat`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，它创建了一个形状为(`784,64`)的随机矩阵，并应用SVD来获取`oth_mat`。
- en: In the `encode` function, it fetches the content from the docs array (`DocumentArray`
    in Jina), stacks images together, extracts the single-channel content, and reshapes
    images to make it ready to fetch the embeddings.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`encode`函数中，它从docs数组（Jina中的`DocumentArray`）中获取内容，将图像堆叠在一起，提取单通道内容，并调整图像的形状，以便准备获取嵌入向量。
- en: In the next step, we use the `content` matrix along with `oth_mat` (the result
    of SVD) to get the embeddings.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，我们将`content`矩阵与`oth_mat`（SVD的结果）一起使用，以获得嵌入向量。
- en: It then associates each document tensor with the respective embeddings and converts
    the tensor into a **uniform resource identifier** (**URI**) (a long string that
    is an equivalent representation of an image) for standardized representation and
    then it pops the tensor.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它将每个文档张量与相应的嵌入向量关联，并将张量转换为**统一资源标识符**（**URI**）（一个长字符串，作为图像的等效表示），以便进行标准化表示，然后将张量弹出。
- en: 'It repeats the same process for all the images in the loop to encode the entire
    dataset:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在循环中对所有图像重复相同的过程，以对整个数据集进行编码：
- en: '[PRE17]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The MyIndexer executor
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MyIndexer执行器
- en: 'The `MyIndexer` executor performs the following tasks:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyIndexer`执行器执行以下任务：'
- en: Its constructor creates a `workspace` directory to store the indexed data.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它的构造函数创建了一个`workspace`目录来存储已索引的数据。
- en: It hosts an `index` endpoint, which takes in the documents as input and structures
    them into the `workspace` folder.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它托管一个`index`端点，该端点接收文档作为输入，并将它们组织到`workspace`文件夹中。
- en: 'It also hosts the `search` endpoint, which gives out the best matches for a
    given query. It takes in the document and `top-k` as a parameter and performs
    a cosine similarity match to find the `top-k` results:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它还托管了 `search` 端点，提供给定查询的最佳匹配结果。它接受文档和 `top-k` 作为参数，执行余弦相似度匹配以找到 `top-k` 结果：
- en: '[PRE18]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: helper.py
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: helper.py
- en: The `helper.py` file provides the helper functions to support the logical elements
    in the `app.py` file. It implements key functions such as `index_generator` and
    `query_generator`, which we use in the `app.py` file to index and query the data.
    Let’s go through both of these functions and understand what they do.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`helper.py` 文件提供了支持 `app.py` 文件中逻辑元素的辅助函数。它实现了关键函数，如 `index_generator` 和 `query_generator`，我们在
    `app.py` 文件中使用它们来索引和查询数据。让我们一起了解这两个函数的作用。'
- en: index_generator()
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: index_generator()
- en: 'This function generates the index tag for the training data using the following
    steps:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用以下步骤为训练数据生成索引标签：
- en: This generator will iterate over all 60,000 documents (images) and process each
    one individually to make them index-ready.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该生成器将遍历所有 60,000 个文档（图像），并逐个处理每个文档，使其准备好进行索引。
- en: It fetches the 28x28 images from the dictionary and inverts them to make them
    suitable to be displayed on the web browser.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从字典中提取 28x28 图像并将其反转，以便适合在网页浏览器中显示。
- en: It converts the black and white image into an RGB image and then converts the
    image into Jina’s internal data type, `Document`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将黑白图像转换为 RGB 图像，然后将图像转换为 Jina 的内部数据类型 `Document`。
- en: It then associates a tag ID with the document and yields it as the index data.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它将标签 ID 与文档关联，并将其作为索引数据返回。
- en: 'The following is the code for the `index_generator()` function:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `index_generator()` 函数的代码：
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: query_generator()
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: query_generator()
- en: 'This is similar to the `index_generator` function and follows the same logic
    to generate the query data with some modifications. It fetches a random number
    of documents (based on the value of the `num_docs` parameter) from the dataset
    to generate the query data. The following is the code for the `query_generator()`
    function:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `index_generator` 函数类似，遵循相同的逻辑生成查询数据，稍作修改。它从数据集中获取一定数量的随机文档（根据 `num_docs`
    参数的值），以生成查询数据。以下是 `query_generator()` 函数的代码：
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: demo.xhtml
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: demo.xhtml
- en: To view the query results in the web browser, the application uses the `demo.xhtml`
    file to render the frontend. By default, running the application will open a web
    page with the query images along with the search results; if it doesn’t, then
    you can open the `demo.xhtml` file, which will be available in the random folder
    generated at the start.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在网页浏览器中查看查询结果，应用程序使用 `demo.xhtml` 文件来渲染前端。默认情况下，运行应用程序会打开一个网页，显示查询图像及其搜索结果；如果没有打开，你可以打开
    `demo.xhtml` 文件，该文件将出现在启动时生成的随机文件夹中。
- en: In this section, we saw how Jina’s framework makes it really efficient to build
    search applications for image data types by leveraging state-of-the-art deep learning
    models. The same functionality will be extended to other data types, such as audio,
    video, and even 3D mesh, which you will learn about in [*Chapter 7*](B17488_07.xhtml#_idTextAnchor101),
    *Exploring Advanced Use Cases of Jina*.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了 Jina 框架如何通过利用最先进的深度学习模型，使构建图像数据类型的搜索应用程序变得非常高效。相同的功能将扩展到其他数据类型，如音频、视频，甚至是
    3D 网格，您将在[*第七章*](B17488_07.xhtml#_idTextAnchor101)中学习到更多内容，*探索 Jina 的高级用例*。
- en: Next, we will look at how to combine two data types to create a multimodal search
    that can easily elevate the search experience for your product or platform. We
    will dive into the multimodal search example, which uses the *people-image* dataset
    consisting of *image-caption* pairs to build a search application that lets you
    query using both the image and the text.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将了解如何结合两种数据类型创建一个多模态搜索，轻松提升产品或平台的搜索体验。我们将深入探讨多模态搜索示例，该示例使用 *people-image*
    数据集，其中包含 *image-caption* 对，构建一个搜索应用程序，允许你同时使用图像和文本进行查询。
- en: Working with multimodal search
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多模态搜索
- en: Multimodal search is another pre-built example that comes with the Jina installation,
    which you can run directly from the comfort of your command line without even
    getting into the code.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 多模态搜索是 Jina 安装中另一个预构建的示例，你可以直接通过命令行运行，无需进入代码。
- en: 'This example uses Kaggle’s public people image dataset (https://www.kaggle.com/ahmadahmadzada/images2000),
    which consists of 2,000 image-caption pairs. The data type here is a multimodal
    document containing multiple data types such as a PDF document that contains text
    and images together. Jina lets you build the search for multimodal data types
    with the same ease and comfort:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例使用 Kaggle 的公共人物图像数据集（https://www.kaggle.com/ahmadahmadzada/images2000），其中包含
    2,000 个图像-标题对。这里的数据类型是多模态文档，包含多种数据类型，如包含文本和图像的 PDF 文档。Jina 使你能够以相同的方式轻松构建多模态数据类型的搜索：
- en: 'To run this example from the command line, you need to install the following
    dependencies:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从命令行运行此示例，你需要安装以下依赖项：
- en: '**pip install transformers**'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pip install transformers**'
- en: '**pip install torch**'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pip install torch**'
- en: '**pip install torchvision**'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pip install torchvision**'
- en: '**pip install “jina[demo]”**'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pip install “jina[demo]”**'
- en: 'Once all the dependencies are installed, simply type the following command
    to launch the application:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装所有依赖项后，只需键入以下命令即可启动应用：
- en: '[PRE21]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After typing this command, you will see the following text on your CLI:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入此命令后，你将在命令行界面看到以下文本：
- en: '![Figure 6.7 – Multimodal search command line  ](img/Figure_6.07_B17488.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7 – 多模态搜索命令行](img/Figure_6.07_B17488.jpg)'
- en: Figure 6.7 – Multimodal search command line
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – 多模态搜索命令行
- en: If your screen displays the same text on the command line, it means you have
    successfully launched the Jina multimodal example; now, it’s time to open the
    UI and play with the application.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的屏幕在命令行上显示相同的文本，这意味着你已经成功启动了 Jina 多模态示例；现在，打开 UI 并与应用进行交互吧。
- en: By default, a UI with a query and results section will open up, allowing you
    to query with text and image and get the results in the same form. If the page
    doesn’t open up itself, you can open the `index.xhtml` file by going to `jina/helloworld/multimodal/static`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，将会打开一个包含查询和结果部分的 UI，允许你通过文本和图像进行查询，并以相同的形式获取结果。如果页面没有自动打开，你可以通过进入 `jina/helloworld/multimodal/static`
    目录来手动打开 `index.xhtml` 文件。
- en: 'You will see the following web page either by default or after opening the
    `index.xhtml` file:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下网页，默认情况下或通过打开 `index.xhtml` 文件后可见：
- en: '![Figure 6.8 – Multimodal search interface ](img/Figure_6.08_B17488.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8 – 多模态搜索界面](img/Figure_6.08_B17488.jpg)'
- en: Figure 6.8 – Multimodal search interface
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 – 多模态搜索界面
- en: You have successfully launched the multimodal example application; it’s now
    time to play with it and have some fun.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经成功启动了多模态示例应用，现在是时候与它互动并玩得开心了。
- en: Navigating through the code
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览代码
- en: Let’s now go through the logic behind the app and see how Jina’s framework ties
    all the components together to produce a functioning multimodal search application.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来了解应用背后的逻辑，看看 Jina 的框架如何将所有组件结合起来，形成一个功能完善的多模态搜索应用。
- en: 'Once you install Jina, go to the chatbot directory by following the `jina/helloworld/multimodal`
    path. This is the main directory and contains the code for the multimodal search
    example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Jina 后，按照 `jina/helloworld/multimodal` 路径进入聊天机器人目录。这是主目录，包含多模态搜索示例的代码：
- en: '[PRE22]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following are the files that you will see within the multimodal directory.
    We will go through the functioning of each of them in detail:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你将在多模态目录中看到的文件。我们将详细介绍它们的功能：
- en: '`app.py`: Similar to the previous applications.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.py`：与之前的应用类似。'
- en: '`my_executors.py`: Similar to the previous applications.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my_executors.py`：与之前的应用类似。'
- en: 'The `static` folder: This hosts all the frontend code responsible for rendering
    the UI on the web browser, which helps you interact with the application.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static` 文件夹：此文件夹包含所有前端代码，负责在网页浏览器上呈现 UI，帮助你与应用进行交互。'
- en: '`flow_index.yml`: This contains the YAML code for the indexing flow, which
    is run when we index the data for the first time.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flow_index.yml`：此文件包含索引流程的 YAML 代码，在我们第一次索引数据时运行。'
- en: '`flow_search.yml`: This contains the YAML code for the search flow, which runs
    every time we send any query to the application.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flow_search.yml`：此文件包含搜索流程的 YAML 代码，每次我们向应用发送查询时都会运行该流程。'
- en: This application uses the MobileNet and MPNet models to index the image-caption
    pairs. The indexing process takes about 3 minutes on the CPU. Then, it opens a
    web page where you can query the multimodal documents. We have also prepared a
    YouTube video (https://youtu.be/B_nH8GCmBfc) to walk you through this demo.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用使用 MobileNet 和 MPNet 模型来索引图像-标题对。索引过程在 CPU 上大约需要 3 分钟。然后，它会打开一个网页，你可以在其中查询多模态文档。我们还准备了一个
    YouTube 视频（https://youtu.be/B_nH8GCmBfc），带你一步步体验这个演示。
- en: app.py
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: app.py
- en: When you type the `jina hello multimodal` command, the control of the application
    goes to the `app.py` file. The `app.py` file performs the following tasks to ensure
    that all the components of the multimodal search application work in tandem with
    each other to produce the desired result.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入`jina hello multimodal`命令时，应用程序的控制权会转到`app.py`文件。`app.py`文件执行以下任务，确保多模态搜索应用的所有组件相互协作，从而产生期望的结果。
- en: The first thing it does is import the required libraries. After that, the control
    goes to the `hello_world()` function, which hosts the main logic of the script.
    The `hello_world()` function creates a random directory using the `mkdir` command
    to store the artifacts, such as the downloaded data. Then, it checks to ensure
    that all the required Python libraries are installed and imported.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 它做的第一件事是导入所需的库。之后，控制权转到`hello_world()`函数，该函数包含脚本的主要逻辑。`hello_world()`函数使用`mkdir`命令创建一个随机目录来存储工件，如下载的数据。然后，它检查确保所有所需的Python库都已安装并导入。
- en: Note
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To run this example, we require three major dependencies/Python libraries:
    `torch`, `transformers`, and `torchvision`.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，我们需要三个主要的依赖项/Python库：`torch`、`transformers`和`torchvision`。
- en: 'Following are the steps to understand the functioning of `app.py` file:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是理解`app.py`文件功能的步骤：
- en: Please check that all the aforementioned dependencies are installed correctly
    in your Python environment.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请检查上述所有依赖项是否在你的Python环境中正确安装。
- en: 'After checking that these dependencies are correctly installed, the `hello_world()`
    function calls the `download_data()` function to fetch and download the data from
    Kaggle. The `download_data()` function uses the `urllib` package to fetch and
    save the data from the given URL. `urllib` takes the URL and filename as the targets
    and downloads the data. You can refer to the following code to see how we set
    the targets:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查这些依赖项是否正确安装后，`hello_world()`函数会调用`download_data()`函数，从Kaggle获取并下载数据。`download_data()`函数使用`urllib`包来获取并保存来自给定URL的数据。`urllib`将URL和文件名作为目标并下载数据。你可以参考以下代码查看我们是如何设置目标的：
- en: '[PRE23]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Passing the `targets` variable into the `download_data()` function will download
    the data and save it in the random folder created at the beginning of the `hello_world`
    function. It then loads the indexing flow from the YAML file and passes the image
    metadata to the flow:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 将`targets`变量传入`download_data()`函数将会下载数据，并将其保存在`hello_world`函数开始时创建的随机文件夹中。接着，它从YAML文件加载索引流程，并将图像元数据传递给该流程：
- en: '[PRE24]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Similarly, it then loads the search flow from the YAML file and sets it to
    fetch the input queries from the HTML frontend:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，它随后从YAML文件加载搜索流程，并设置为从HTML前端获取输入查询：
- en: '[PRE25]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In both of the preceding code snippets, we open the flow with a context manager.
    For this example, we will use the web browser to interact with the application.
    It requires configuring and serving the flow on a specific port with the HTTP
    protocol using the `port_expose` parameter. Toward the end, we use the `f.block()`
    method to keep the flow open for search queries and to prevent it from exiting.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面两个代码片段中，我们使用上下文管理器打开流程。对于这个示例，我们将使用Web浏览器与应用程序进行交互。它需要配置并通过HTTP协议在特定端口上提供该流程，使用`port_expose`参数。在最后，我们使用`f.block()`方法保持流程处于开放状态，以便接收搜索查询并防止它退出。
- en: my_executors.py
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: my_executors.py
- en: If `app.py` is the brain of this example, then the `my_executors.py` file contains
    the neurons in the form of executors that power the core logic.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`app.py`是这个示例的大脑，那么`my_executors.py`文件则包含了作为执行器的神经元，驱动核心逻辑的运作。
- en: 'The multimodal example contains two modalities of data: image and text, which
    are stored in the document `tags` and `uri` attributes, respectively. To process
    these two modalities of data, at index time, we need to preprocess, encode, and
    index them separately using the following executors.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 该多模态示例包含两种数据模态：图像和文本，分别存储在文档的`tags`和`uri`属性中。为了处理这两种数据模态，在索引时，我们需要使用以下执行器分别对它们进行预处理、编码和索引。
- en: The Segmenter executor
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Segmenter执行器
- en: 'The `Segmenter` executor takes the documents as the input and splits them into
    two chunks: image chunk and text chunk. The text chunk will contain the plain
    text data and the image chunk (which we call `chunk_uri` in the code) contains
    the URI of the image. Then, we add them both to the document chunks and send them
    further to the pre-processing stage, as shown here:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`Segmenter`执行器以文档为输入，并将其拆分为两个块：图像块和文本块。文本块将包含纯文本数据，而图像块（在代码中我们称之为`chunk_uri`）包含图像的URI。然后，我们将它们都添加到文档块中，并将其发送到预处理阶段，如下所示：'
- en: '[PRE26]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The TextCrafter executor
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`TextCrafter`执行器'
- en: 'For the preprocessing of the text chunk, we use the `TextCrafter` executor,
    which takes the text chunk as the input and returns a flattened traversable sequence
    of all the documents, as shown here:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文本块的预处理，我们使用`TextCrafter`执行器，它以文本块为输入，并返回一个扁平化的可遍历文档序列，如下所示：
- en: '[PRE27]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The ImageCrafter executor
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`ImageCrafter`执行器'
- en: 'Similarly, for the preprocessing of the image chunk, we use the `ImageCrafter`
    executor, which takes the image chunk as the input and returns a flattened traversable
    sequence of all the documents:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于图像块的预处理，我们使用`ImageCrafter`执行器，它以图像块为输入，并返回一个扁平化的可遍历文档序列：
- en: '[PRE28]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The TextEncoder executor
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`TextEncoder`执行器'
- en: 'After the preprocessing step, the preprocessed data of the text chunk goes
    to the `TextEncoder` executor as the input and produces the text embedding as
    the output. We persist the result in the form of embeddings using the `DocVectorIndexer`
    executor. Let’s look at the functioning of `TextEncoder` by starting with the
    code of its constructor:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在预处理步骤之后，文本块的预处理数据进入`TextEncoder`执行器作为输入，并产生文本嵌入作为输出。我们使用`DocVectorIndexer`执行器将结果以嵌入的形式持久化。让我们从`TextEncoder`的构造函数代码开始，了解它的工作原理：
- en: '[PRE29]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To compute the embeddings, it uses the pre-trained `sentence-transformers/paraphrase-mpnet-base-v2`
    model with the `''mean''` pooling strategy. Let’s look at the code for the `compute_embedding()`
    function:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算嵌入，它使用预训练的`sentence-transformers/paraphrase-mpnet-base-v2`模型，采用`'mean'`池化策略。让我们看一下`compute_embedding()`函数的代码：
- en: '[PRE30]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It then uses the `encode()` function to store the embeddings in the `doc.embeddings`
    attribute of the document:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它使用`encode()`函数将嵌入存储在文档的`doc.embeddings`属性中：
- en: '[PRE31]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The ImageEncoder executor
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`ImageEncoder`执行器'
- en: 'Similarly, the preprocessed data of the image chunk goes to the `ImageEncoder`
    executor as the input and produces the embedding as the output. We persist the
    result in the form of embeddings using the `DocVectorIndexer` executor. Let’s
    look at the functioning of `ImageEncoder` by going through the code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，图像块的预处理数据进入`ImageEncoder`执行器作为输入，并产生嵌入作为输出。我们使用`DocVectorIndexer`执行器将结果以嵌入的形式持久化。让我们通过查看代码，了解`ImageEncoder`的工作原理：
- en: '[PRE32]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It uses the pre-trained `mobilenet -v2` model to generate the embeddings. To
    preprocess the images, it uses the `''mean''` pooling strategy to compute the
    average value of all the pixels in the image to compute the embeddings:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用预训练的`mobilenet-v2`模型生成嵌入。为了预处理图像，它使用`'mean'`池化策略，计算图像中所有像素的平均值来生成嵌入：
- en: '[PRE33]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Toward the end, the `encode` function stores the embeddings in the `doc.embeddings`
    attribute of the document.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后，`encode`函数将嵌入存储在文档的`doc.embeddings`属性中。
- en: The DocVectorIndexer executor
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`DocVectorIndexer`执行器'
- en: 'Now, let’s look at the `DocVectorIndexer` executor, which persists the encoding
    from both `TextEncoder` and `ImageEncoder` to index them. Here, we have two different
    modalities of data (text and image), so we need to store the indexed results separately
    in two different files. The `DocVectorIndexer` executor takes care of that. It
    stores the indexed text embeddings into the `text.json` file and the image embeddings
    into the `image.json` file, which we will use in the `flow_index.yml` file as
    `index_file_name`. Let’s look at the code for `DocVectorIndexer` to understand
    its functioning in detail:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下`DocVectorIndexer`执行器，它将`TextEncoder`和`ImageEncoder`的编码结果持久化到索引中。这里，我们有两种不同的数据模态（文本和图像），所以我们需要将索引结果分别存储在两个不同的文件中。`DocVectorIndexer`执行器会处理这些，它将索引后的文本嵌入存储在`text.json`文件中，将图像嵌入存储在`image.json`文件中，我们将在`flow_index.yml`文件中将其作为`index_file_name`使用。让我们看看`DocVectorIndexer`的代码，了解它的具体工作原理：
- en: '[PRE34]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It uses `DocumentArray` to store all the documents directly on the disk because
    we have a large number of documents. It hosts two different endpoints to index
    the data and open the `'search'` flow. It uses the cosine similarity score to
    find the relevant documents.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用`DocumentArray`将所有文档直接存储在磁盘上，因为我们有大量文档。它托管两个不同的端点来索引数据并打开`'search'`流。它使用余弦相似度得分来查找相关文档。
- en: The KeyValueIndexer executor
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: KeyValueIndexer 执行器
- en: 'Apart from `DocVectorIndexer` to persist embeddings, we also create a `KeyValueIndexer`
    executor to help the chunks (text chunk and image chunk) to find their parent/root
    document. Let’s look at the code to understand its functionality in detail:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`DocVectorIndexer`来持久化嵌入外，我们还创建了一个`KeyValueIndexer`执行器，以帮助块（文本块和图像块）找到它们的父/根文档。让我们看一下代码，以更详细地了解其功能：
- en: '[PRE35]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It uses `DocumentArray` just like `DocVectorIndexer` to store all the documents
    directly on the disk.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 它像`DocVectorIndexer`一样使用`DocumentArray`将所有文档直接存储在磁盘上。
- en: It hosts two different endpoints to index the data and open the search flow.
    In the search logic, given a document, it loops through the tree to find its root/parent
    document.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 它托管两个不同的端点来索引数据并打开搜索流。在搜索逻辑中，给定一个文档，它会遍历树查找其根/父文档。
- en: The WeightedRanker executor
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: WeightedRanker 执行器
- en: Toward the end, when both the chunks find their parents, we aggregate the score
    using the `WeightedRanker` executor to produce the final output.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当两个块都找到了它们的父节点时，我们使用`WeightedRanker`执行器聚合得分，生成最终输出。
- en: 'Let’s look at the code to understand its functionality in detail:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下代码，以更详细地了解其功能：
- en: 'It opens a search endpoint to combine the results from both the text and image
    chunks to calculate the final similarity score, which we will use to determine
    the results:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它打开一个搜索端点，将文本块和图像块的结果合并，以计算最终的相似度得分，我们将使用这个得分来确定结果：
- en: '[PRE36]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can assign the `weight` parameter beforehand to determine which modality
    (between text and image) will contribute more toward calculating the final relevance
    score. If you set the weight of the text chunk as `2` and the image chunk as `1`,
    then the text chunk will contribute a higher score to the final relevance.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以预先分配`weight`参数，以确定哪种模态（文本或图像）对计算最终相关性得分的贡献更大。如果您将文本块的权重设置为`2`，图像块的权重设置为`1`，则文本块将在最终相关性得分中贡献更高的分数。
- en: 'The final similarity score is calculated by summing up cosine similarity *
    weight for both the modalities and then sorting them in descending order:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的相似度得分是通过将两个模态的余弦相似度*权重相加，然后按降序排序来计算的：
- en: '[PRE37]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We have looked at how the executors work together to produce the results. Let’s
    now look at how these executors are arranged and utilized in the index and search
    flow.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过了执行器如何协同工作以生成结果。现在让我们看看这些执行器是如何在索引和搜索流中进行排列和使用的。
- en: flow_index.yml
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: flow_index.yml
- en: As you already know, Jina provides two ways to create and work with the flows.
    The first is by using native Python, and the second is by using a YAML file to
    create a flow and call it in the main `app.py` file. Now, we will look at how
    the `flow_index.yml` file is created by leveraging the individual executor components
    that we discussed in the previous section.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经知道的，Jina提供了两种创建和使用流的方法。第一种是使用原生Python，第二种是使用YAML文件创建流并在主`app.py`文件中调用它。现在，我们将查看如何通过利用我们在上一节中讨论的单个执行器组件来创建`flow_index.yml`文件。
- en: 'The `flow_index.yml` file uses different executors that we have defined in
    the `my_executors.py` file and arranges them to produce the indexing flow. Let’s
    go through the YAML code to understand it in detail:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`flow_index.yml`文件使用我们在`my_executors.py`文件中定义的不同执行器，并将它们排列以生成索引流。让我们通过YAML代码详细了解它：'
- en: 'It starts with the `Segmenter` executor, which segments the document into text
    and image chunks:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从`Segmenter`执行器开始，该执行器将文档分割为文本和图像块：
- en: '[PRE38]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After that, we have two different pipelines, one for text and the other for
    the image. The text pipeline preprocesses the data using the `TextCrafter` executor,
    encodes it using the `TextEncoder` executor, and then indexes it using `DocVectorIndexer`:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们有两个不同的管道，一个用于文本，另一个用于图像。文本管道使用`TextCrafter`执行器预处理数据，使用`TextEncoder`执行器进行编码，然后使用`DocVectorIndexer`进行索引：
- en: '[PRE39]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The image pipeline preprocesses the data using the `ImageCrafter` executor,
    encodes it using the `ImageEncoder` executor, and then indexes it using `DocVectorIndexer`:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图像管道使用`ImageCrafter`执行器预处理数据，使用`ImageEncoder`执行器进行编码，然后使用`DocVectorIndexer`进行索引：
- en: '[PRE40]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After indexing the text and image to the respective `text.json` and `image.json`
    files, we join both the indexers with `KeyValueIndexer` to link them together:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将文本和图像分别索引到`text.json`和`image.json`文件后，我们使用`KeyValueIndexer`将两个索引器连接起来：
- en: '[PRE41]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: flow_search.yml
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: flow_search.yml
- en: 'Similar to the `flow_index.yml` file, we also have a `flow_search.yml` file,
    which defines the search/query flow for the multimodal example application. Let’s
    look at the YAML code to understand its functionality in detail:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`flow_index.yml`文件，我们也有一个`flow_search.yml`文件，它定义了多模态示例应用程序的搜索/查询流程。让我们看一下YAML代码，详细了解其功能：
- en: 'It gets the input in the form of text and images and treats them both differently
    using a pipeline of executors. For the text input, it uses the `TextCrafter` executor
    to preprocess the data, followed by the `TextEncoder` executor to encode the textual
    data, and finally, indexes it using `DocVectorIndexer`:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它以文本和图像的形式接收输入，并通过执行器管道分别处理它们。对于文本输入，它使用`TextCrafter`执行器对数据进行预处理，接着使用`TextEncoder`执行器对文本数据进行编码，最后通过`DocVectorIndexer`进行索引：
- en: '[PRE42]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For the image input, it uses the `ImageCrafter` executor to preprocess the
    data, followed by the `ImageEncoder` executor to encode the image data, and finally,
    indexes it using `DocVectorIndexer`:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于图像输入，它使用`ImageCrafter`执行器对数据进行预处理，接着使用`ImageEncoder`执行器对图像数据进行编码，最后通过`DocVectorIndexer`进行索引：
- en: '[PRE43]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It then passes the result of both `TextIndexer` and `ImageIndexer` into the
    `WeightedRanker` executor, which calculates the final relevance score and produces
    the output:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它将`TextIndexer`和`ImageIndexer`的结果传递给`WeightedRanker`执行器，后者计算最终的相关性得分并生成输出：
- en: '[PRE44]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: To interact with the multimodal application in the web browser via the UI, you
    can use the `index.xhtml` file provided in the `static` folder. Running the application
    should open the HTML file by default, but if it doesn’t, then you can open the
    `index.xhtml` file from the `static` folder.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过用户界面在网页浏览器中与多模态应用程序交互，可以使用`index.xhtml`文件，该文件位于`static`文件夹中。运行应用程序应该默认打开HTML文件，但如果没有打开，可以从`static`文件夹中手动打开`index.xhtml`文件。
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have covered how to put together all the components and
    concepts that we have learned in the previous chapters. We have walked you through
    the process of building basic search examples with Jina for different data types,
    including a text-to-text search, image-to-image search, and multimodal search,
    which combines both the text and the images. The things that we learned in this
    chapter will act as a building block for [*Chapter 7*](B17488_07.xhtml#_idTextAnchor101),
    *Exploring Advanced Use Cases of Jina*, where you will learn about building advanced
    examples using Jina.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经讲解了如何将之前章节中学习的所有组件和概念组合在一起。我们引导你完成了使用Jina构建不同数据类型的基本搜索示例的过程，包括文本到文本搜索、图像到图像搜索以及多模态搜索，后者结合了文本和图像。本章中学习的内容将作为构建模块，用于[*第7章*](B17488_07.xhtml#_idTextAnchor101)，*探索Jina的高级用例*，在该章节中，你将学习如何使用Jina构建高级示例。
- en: In the next chapter, we will continue on the same journey and see how to build
    advanced search applications with Jina using what we have learned so far.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续沿着相同的路线，展示如何利用目前所学的内容，使用Jina构建高级搜索应用程序。
