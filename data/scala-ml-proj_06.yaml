- en: Developing Model-based Movie Recommendation Engines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发基于模型的电影推荐引擎
- en: Netflix is an American entertainment company founded by Reed Hastings and Marc
    Randolph on August 29, 1997, in Scotts Valley, California. It specializes in and
    provides streaming media, video-on-demand online, and DVD by mail. In 2013, Netflix
    expanded into film and television production, as well as online distribution.
    Netflix uses a model-based collaborative filtering approach for real-time movie
    recommendation for its subscribers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix 是一家由 Reed Hastings 和 Marc Randolph 于 1997 年 8 月 29 日在加利福尼亚州 Scotts Valley
    创立的美国娱乐公司。它专注于并提供流媒体、视频点播在线服务以及 DVD 邮寄服务。2013 年，Netflix 扩展到电影和电视制作及在线分发。Netflix
    使用基于模型的协同过滤方法，为其订阅用户提供实时电影推荐。
- en: In this chapter, we will see two end-to-end projects and develop a model for
    item-based collaborative filtering for movie similarity measurement and a model-based
    movie recommendation engine with Spark that recommends movies for new users. We
    will see how to interoperate between ALS and **matrix factorization** (**MF**)
    for these two scalable movie recommendation engines. We will use the movie lens
    dataset for the project. Finally, we will see how to deploy the best model in
    production.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将看到两个端到端的项目，并为电影相似度测量开发基于物品的协同过滤模型，以及使用 Spark 的基于模型的电影推荐引擎，后者能够为新用户推荐电影。我们将看到如何在
    ALS 和**矩阵分解**（**MF**）之间进行交互操作，以实现这两个可扩展的电影推荐引擎。我们将使用电影镜头数据集进行该项目。最后，我们将看到如何将最佳模型部署到生产环境中。
- en: 'In a nutshell, we will learn the following topics through two end-to-end projects:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们将通过两个端到端的项目学习以下内容：
- en: Recommendation system—how and why?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐系统—如何以及为什么？
- en: Item**-**based collaborative filtering for movie similarity
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于物品的协同过滤用于电影相似度测量
- en: Model**-**based movie recommendation with Spark
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于模型的电影推荐与 Spark
- en: Model deployment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型部署
- en: Recommendation system
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐系统
- en: A **recommendation system** (that is, **recommendation engine or ****RE**) is
    a subclass of information filtering systems that helps predict the **rating** or
    **preference** based on the ratings given by users to an item. In recent years,
    recommendation systems have become increasingly popular. In short, a recommender
    system tries to predict potential items a user might be interested in based on
    history for other users.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**推荐系统**（即**推荐引擎**或**RE**）是信息过滤系统的一个子类，它帮助根据用户对某个项目的评分预测其**评分**或**偏好**。近年来，推荐系统变得越来越流行。简而言之，推荐系统试图根据其他用户的历史记录预测某个用户可能感兴趣的潜在项目。'
- en: Consequently, they're being used in many areas such as movies, music, news,
    books, research articles, search queries, social tags, products, collaborations,
    comedy, restaurants, fashion, financial services, life insurance, and online dating.
    There are a couple of ways to develop recommendation engines that typically produce
    a list of recommendations, for example, collaborative and content-based filtering
    or the personality-based approach.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它们被广泛应用于电影、音乐、新闻、书籍、研究文章、搜索查询、社交标签、产品、合作、喜剧、餐厅、时尚、金融服务、寿险和在线约会等多个领域。开发推荐引擎的方式有很多，通常会生成一系列推荐结果，例如基于协同过滤和基于内容的过滤，或者基于个性化的方式。
- en: Collaborative filtering approaches
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协同过滤方法
- en: 'Using collaborative filtering approaches, an RE can be built based on a user''s
    past behavior where numerical ratings are given on purchased items. Sometimes,
    it can be developed on similar decisions made by other users who also have purchased
    the same items. From the following figure, you can get some idea of different
    recommender systems:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用协同过滤方法，可以基于用户过去的行为来构建推荐引擎，其中会根据用户购买的物品给出数值评分。有时，它还可以基于其他用户做出的相似决策来开发，这些用户也购买了相同的物品。从下图中，你可以对不同的推荐系统有一些了解：
- en: '![](img/adad368d-b5cb-4177-8105-f17fb2c37b2b.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/adad368d-b5cb-4177-8105-f17fb2c37b2b.png)'
- en: 'Figure 1: A comparative view of different recommendation systems'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1：不同推荐系统的比较视图
- en: 'Collaborative filtering-based approaches often suffer from three problems—cold
    start, scalability, and sparsity:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 基于协同过滤的方法通常会面临三个问题——冷启动、可扩展性和稀疏性：
- en: '**Cold start**: Sometimes gets stuck when a large amount of data about users
    is required for making a more accurate recommendation system.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冷启动**：当需要大量关于用户的数据来做出更准确的推荐时，有时会陷入困境。'
- en: '**Scalability**: A large amount of computation power is often necessary to
    calculate recommendations out of a dataset with millions of users and products.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：通常需要大量的计算能力来从拥有数百万用户和产品的数据集中计算推荐。'
- en: '**Sparsity**: This often happens with a crowd-sourced dataset when a huge number
    of items are sold on major e-commerce sites. In such a case, active users may
    rate only a small subset of the items sold—that is, even the most popular items
    have very few ratings. Accordingly, the user versus items matrix becomes very
    sparse. In other words, a large-scale sparse matrix cannot be handled.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**稀疏性**：当大量商品在主要电商网站上销售时，通常会发生这种情况，尤其是在众包数据集的情况下。在这种情况下，活跃用户可能只会对少数几件商品进行评分——也就是说，即使是最受欢迎的商品也会有很少的评分。因此，用户与商品的矩阵变得非常稀疏。换句话说，不能处理一个大规模的稀疏矩阵。'
- en: To overcome these issues, a particular type of collaborative filtering algorithm
    uses MF, a low-rank matrix approximation technique. We will see an example later
    in this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些问题，一种特定类型的协同过滤算法使用MF，一种低秩矩阵近似技术。我们将在本章后面看到一个例子。
- en: Content-based filtering approaches
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于内容的过滤方法
- en: Using content-based filtering approaches, a series of discrete characteristics
    of an item is utilized to recommend additional items with similar properties.
    Sometimes it is based on a description of the item and a profile of the user's
    preferences. These approaches try to recommend items that are similar to those
    that a user liked in the past or is using currently.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于内容的过滤方法，利用项目的离散特征系列推荐具有相似属性的其他项目。有时它基于对项目的描述和用户偏好的个人资料。这些方法尝试推荐与用户过去喜欢或当前正在使用的项目相似的项目。
- en: A key issue with content-based filtering is whether the system is able to learn
    user preferences from users' actions regarding one content source and use them
    across other content types. When this type of RE is deployed, it can be used to
    predict items or ratings for items that the user is interested in.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 基于内容的过滤的一个关键问题是，系统是否能够从用户对某个内容源的行为中学习用户偏好，并将其应用于其他内容类型。当这种类型的推荐引擎被部署时，它可以用来预测用户感兴趣的项目或项目的评分。
- en: Hybrid recommender systems
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合推荐系统
- en: 'As you have seen, there are several pros and cons of using collaborative filtering
    and content-based filtering. Therefore, to overcome the limitations of these two
    approaches, recent trends have shown that a hybrid approach can be more effective
    and accurate by combining collaborative filtering and content-based filtering.
    Sometimes, factorization approaches such as MF and **Singular Value Decomposition**
    (**SVD**) are used to make them robust. Hybrid approaches can be implemented in
    several ways:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用协同过滤和基于内容的过滤各有优缺点。因此，为了克服这两种方法的局限性，近年来的趋势表明，混合方法通过结合协同过滤和基于内容的过滤，可能更加有效和准确。有时，为了使其更强大，会使用如MF和**奇异值分解**（**SVD**）等因式分解方法。混合方法可以通过几种方式实现：
- en: At first, content-based and collaborative-based predictions are computed separately,
    and later on we combine them, that is, unification of these two into one model.
    In this approach, FM and SVD are used extensively.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最初，基于内容的预测和基于协同的预测是分别计算的，之后我们将它们结合起来，即将这两者统一为一个模型。在这种方法中，FM和SVD被广泛使用。
- en: Adding content-based capabilities to a collaborative-based approach or vice
    versa. Again, FM and SVD are used for better prediction.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向基于协同的方式添加基于内容的能力，或反之。再次，FM和SVD被用来进行更好的预测。
- en: 'Netflix is a good example that uses this hybrid approach to make a recommendation
    to its subscribers. This site makes recommendations in two ways:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix是一个很好的例子，它使用这种混合方法向订阅者推荐内容。该网站通过两种方式进行推荐：
- en: '**Collaborative filtering**: By comparing the watching and searching habits
    of similar users'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协同过滤**：通过比较相似用户的观看和搜索习惯'
- en: '**Content-based filtering**: By offering movies that share characteristics
    with films that a user has rated highly'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于内容的过滤**：通过提供与用户高度评分的电影共享特征的电影'
- en: Model-based collaborative filtering
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于模型的协同过滤
- en: 'AS shown in *Figure 1*, I really planned to implement a systematic project
    using factorization machines it turns out to be time constraint. Therefore, decided
    to develop a movie recommendation using a collaborative filtering  approach. Collaborative
    filtering based methods are classified as:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图1*所示，我确实计划使用因式分解机来实施一个系统化的项目，但最终由于时间限制未能实现。因此，决定开发一个基于协同过滤的方法的电影推荐系统。基于协同过滤的方法可以分为：
- en: Memory-based, that is, a user-based algorithm
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于记忆的算法，即基于用户的算法
- en: Model-based collaborative filtering, that is, kernel-mapping
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于模型的协同过滤算法，即核映射
- en: In the model-based collaborative filtering technique, users and products are
    described by a small set of factors, also called **latent factors** (**LFs**).
    The LFs are then used to predict the missing entries. The **Alternating Least
    Squares** (**ALS**) algorithm is used to learn these LFs. From a computational
    perspective, model-based collaborative filtering is commonly used in many companies
    such as Netflix for real-time movie recommendations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于模型的协同过滤技术中，用户和产品由一组较小的因素描述，这些因素也被称为**潜在因素**（**LFs**）。然后使用这些潜在因素来预测缺失的条目。**交替最小二乘法**（**ALS**）算法用于学习这些潜在因素。从计算的角度来看，基于模型的协同过滤通常用于许多公司，如Netflix，用于实时电影推荐。
- en: The utility matrix
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 效用矩阵
- en: 'In a hybrid recommendation system, there are two classes of entities: users
    and items (examples are movies, products, and so on). Now, as a user, you might
    have preferences for certain items. Therefore, these preferences must be extracted
    from data about items, users, or ratings. Often this data is represented as a
    utility matrix, such as a user-item pair. This type of value can represent what
    is known about the degree of preference of that user for a particular item. The
    entry in the matrix, that is, a table, can come from an ordered set. For example,
    integers 1-5 can be used to represent the number of stars that the user gave as
    a rating for items.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个混合推荐系统中，有两类实体：用户和物品（例如电影、产品等）。现在，作为一个用户，你可能会对某些物品有偏好。因此，这些偏好必须从关于物品、用户或评分的数据中提取出来。通常这些数据表示为效用矩阵，例如用户-物品对。这种值可以表示已知的该用户对某个物品的偏好程度。矩阵中的条目，即一个表格，可以来自有序集合。例如，可以使用整数1-5来表示用户为物品评分的星级。
- en: We have argued that often users might not have rated items; that is, most entries
    are **unknown**. This also means that the matrix might be sparse. An unknown rating
    implies that we have no explicit information about the user's preference for the
    item. *Table 1* shows an example utility matrix. The matrix represents the ratings
    of users about movies on a 1-5 scale, 5 being the highest rating. A blank entry
    means no users have provided any rating about those movies.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们曾指出，通常用户可能没有对物品进行评分；也就是说，大多数条目是**未知的**。这也意味着矩阵可能是稀疏的。一个未知的评分意味着我们没有关于用户对物品偏好的明确反馈。*表1*展示了一个效用矩阵示例。该矩阵表示用户对电影的评分，评分范围为1到5，5为最高评分。空白条目表示没有用户为这些电影提供评分。
- en: 'Here **HP1**, **HP2**, and **HP3** are acronyms for the movies **Harry Potter
    I**, **II**, and **III**, respectively; **TW** is for **Twilight**; and **SW1**,
    **SW2**, and **SW3** represent **Star Wars** episodes **1**, **2**, and **3**,
    respectively. The users are represented by capital letters **A**, **B**, **C**,
    and **D**:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**HP1**、**HP2**和**HP3**分别是电影**哈利·波特 I**、**II**和**III**的缩写；**TW**代表**暮光之城**；**SW1**、**SW2**和**SW3**分别代表**星球大战**系列的第**1**、**2**和**3**部。用户由大写字母**A**、**B**、**C**和**D**表示：
- en: '![](img/1fb37fd3-9a9c-4f08-a4f5-1cb99010989a.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fb37fd3-9a9c-4f08-a4f5-1cb99010989a.png)'
- en: 'Figure 2: Utility matrix (user versus movies matrix)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：效用矩阵（用户与电影矩阵）
- en: There are many blank entries for the user-movie pairs. This means that users
    have not rated those movies. In a real-life scenario, the matrix might be even
    sparser, with the typical user rating only a tiny fraction of all available movies.
    Now, using this matrix, the goal is to predict the blanks in the utility matrix.
    Let's see an example. Suppose we are curious to know whether user **A** likes **SW2**.
    However, this is really difficult to determine since there is little evidence
    in the matrix in *Table 1*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 用户-电影对中有许多空白条目。这意味着用户没有为那些电影评分。在实际场景中，矩阵可能更加稀疏，典型的用户仅为所有可用电影中的一小部分评分。现在，利用这个矩阵，目标是预测效用矩阵中的空白部分。让我们来看一个例子。假设我们想知道用户**A**是否喜欢**SW2**。然而，由于矩阵中在*表1*中几乎没有相关证据，确定这一点是非常困难的。
- en: Thus, in practice, we might develop a movie recommendation engine to consider
    the uncommon properties of movies, such as producer name, director name, lead
    stars, or even the similarity of their names. This way, we can compute the similarity
    of movies **SW1** and **SW2**. This similarity would drive us to conclude that
    since A did not like **SW1**, they are not likely to enjoy **SW2** either.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在实际应用中，我们可能会开发一个电影推荐引擎来考虑电影的一些不常见属性，如制片人名称、导演名称、主演，甚至是它们名称的相似性。通过这种方式，我们可以计算电影**SW1**和**SW2**的相似性。这种相似性会引导我们得出结论：由于A不喜欢**SW1**，他们也不太可能喜欢**SW2**。
- en: However, this might not work for the larger dataset. Therefore, with much more
    data, we might observe that the people who rated both **SW1** and **SW2** were
    inclined to give them similar ratings. Finally, we can conclude that **A** would
    also give **SW2** a low rating, similar to **A**'s rating of **SW1**.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这对于更大的数据集可能不适用。因此，随着数据量的增大，我们可能会观察到那些同时评分过**SW1**和**SW2**的用户倾向于给予它们相似的评分。最终，我们可以得出结论：**A**也会像评分**SW1**那样对**SW2**给出低分。
- en: Spark-based movie recommendation systems
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于Spark的电影推荐系统
- en: The implementation in Spark MLlib supports model-based collaborative filtering.
    In the model-based collaborative filtering technique, users and products are described
    by a small set of factors, also called LFs. In this section, we will see two complete
    examples of how it works toward recommending movies for new users.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Spark MLlib中的实现支持基于模型的协同过滤。在基于模型的协同过滤技术中，用户和产品通过一组小的因子（也称为LF）来描述。在本节中，我们将看到两个完整的示例，展示它如何为新用户推荐电影。
- en: Item-based collaborative filtering for movie similarity
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于物品的协同过滤用于电影相似度计算
- en: 'Firstly, we read the ratings from a file. For this project, we can use the
    MovieLens 100k rating dataset from [http://www.grouplens.org/node/73](http://www.grouplens.org/node/73).
    The training set ratings are in a file called `ua.base`, while the movie item
    data is in `u.item`. On the other hand, `ua.test` contains the test set to evaluate
    our model. Since we will be using this dataset, we should acknowledge the GroupLens
    Research Project team at the University of Minnesota who wrote the following text:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从文件中读取评分数据。对于这个项目，我们可以使用来自[http://www.grouplens.org/node/73](http://www.grouplens.org/node/73)的MovieLens
    100k评分数据集。训练集评分数据保存在一个名为`ua.base`的文件中，而电影项数据保存在`u.item`中。另一方面，`ua.test`包含了用于评估我们模型的测试集。由于我们将使用这个数据集，因此我们应该感谢明尼苏达大学的GroupLens研究项目团队，他们编写了以下文字：
- en: 'F. Maxwell Harper and Joseph A. Konstan. 2015\. The MovieLens Datasets: *History
    and Context*. ACM Transactions on **Interactive Intelligent Systems** (**TiiS**)
    5, 4, Article 19 (December 2015), 19 pages. DOI: [http://dx.doi.org/10.1145/2827872](http://dx.doi.org/10.1145/2827872).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 'F. Maxwell Harper 和 Joseph A. Konstan. 2015\. The MovieLens数据集: *历史与背景*。ACM交互式智能系统交易（**TiiS**）5,
    4, 第19号文章（2015年12月），共19页。DOI：[http://dx.doi.org/10.1145/2827872](http://dx.doi.org/10.1145/2827872)。'
- en: This dataset consists of 100,000 ratings of 1 to 5 from 943 users on 1,682 movies.
    Each user has rated at least 20 movies. It also contains simple demographic info
    about the users (age, gender, occupation, and zip code).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该数据集包含了来自943名用户对1682部电影的1至5分的100,000条评分。每个用户至少评分过20部电影。数据集还包含了关于用户的基本人口统计信息（如年龄、性别、职业和邮政编码）。
- en: Step 1 - Importing necessary libraries and creating a Spark session
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1步 - 导入必要的库并创建Spark会话
- en: 'We need to import a Spark session so that we can create the Spark session,
    the gateway of our Spark app:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要导入一个Spark会话，以便我们可以创建Spark会话，这是我们Spark应用程序的入口：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Step 2 - Reading and parsing the dataset
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2步 - 读取和解析数据集
- en: 'Let''s use Spark''s `textFile` method to read a text file from your preferred
    storage such as HDFS or the local filesystem. However, it''s up to us to specify
    how to split the fields. While reading the input dataset, we do `groupBy` first
    and transform after the join with a `flatMap` operation to get the required fields:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Spark的`textFile`方法从你首选的存储系统（如HDFS或本地文件系统）读取文本文件。然而，我们需要自己指定如何分割字段。在读取输入数据集时，我们首先进行`groupBy`操作，并在与`flatMap`操作进行联接后进行转换，以获取所需字段：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Step 3 - Computing similarity
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3步 - 计算相似度
- en: 'Using item-based collaborative filtering, we can compute how similar two movies
    are to each other. We follow these steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过基于物品的协同过滤，我们可以计算两部电影之间的相似度。我们按照以下步骤进行：
- en: For every pair of movies (**A**, **B**), we find all the users who rated both
    **A** and **B**
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每一对电影（**A**，**B**），我们找出所有同时评分过**A**和**B**的用户。
- en: Now, using the preceding ratings, we compute a Movie **A** vector, say **X**,
    and a Movie **B** vector, say **Y**
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用前述的评分，我们计算出电影**A**的向量，比如**X**，和电影**B**的向量，比如**Y**
- en: Then we calculate the correlation between **X** and **Y**
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们计算**X**和**Y**之间的相关性
- en: If a user watches movie **C**, we can then recommend the most correlated movies
    with it
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个用户观看了电影**C**，我们可以推荐与其相关性最高的电影
- en: 'We then compute the various vector metrics for each ratings vector **X** and
    **Y**, such as size, dot product, norm, and so on. We will use these metrics to
    compute the various similarity metrics between pairs of movies, that is, (**A**,
    **B**). For each movie pair (**A**, **B**), we then compute several measures such
    as cosine similarity, Jaccard similarity correlation, and regularized correlation.
    Let''s get started. The first two steps are as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们计算每个评分向量**X**和**Y**的各种向量度量，如大小、点积、范数等。我们将使用这些度量来计算电影对之间的各种相似度度量，也就是（**A**，**B**）。对于每对电影（**A**，**B**），我们计算多个度量，如余弦相似度、Jaccard相似度、相关性和常规相关性。让我们开始吧。前两步如下：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `ratingsWithSize` variable now contains the following fields: `user`, `movie`,
    `rating`, and `numRaters`. The next step is to make a dummy copy of ratings for
    self-join. Technically, we join to `userid` and filter movie pairs so that we
    do not double-count and exclude self-pairs:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`ratingsWithSize`变量现在包含以下字段：`user`，`movie`，`rating`和`numRaters`。接下来的步骤是创建评分的虚拟副本以进行自连接。技术上，我们通过`userid`进行连接，并过滤电影对，以避免重复计数并排除自对：'
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now let''s compute the raw inputs to similarity metrics for each movie pair:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们计算每对电影的相似度度量的原始输入：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here are the third and the fourth steps for computing the similarity. We compute
    similarity metrics for each movie pair:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是计算相似度的第三步和第四步。我们为每对电影计算相似度度量：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next is the implementation of the methods we just used. We start with the `correlation()`
    method for computing the correlation between the two vectors (*A*, *B*) as *cov(A,
    B)/(stdDev(A) * stdDev(B))*:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们刚才使用的方法的实现。我们从`correlation()`方法开始，用来计算两个向量（*A*，*B*）之间的相关性，公式为*cov(A, B)/(stdDev(A)
    * stdDev(B))*：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, the correlation is regularized by adding virtual pseudocounts over a prior, *RegularizedCorrelation
    = w * ActualCorrelation + (1 - w) * PriorCorrelation where w = # actualPairs /
    (# actualPairs + # virtualPairs)*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，通过在先验上添加虚拟伪计数来对相关性进行常规化，*RegularizedCorrelation = w * ActualCorrelation
    + (1 - w) * PriorCorrelation，其中w = # actualPairs / (# actualPairs + # virtualPairs)*：'
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The cosine similarity between the two vectors A, B is dotProduct(A, B) / (norm(A)
    * norm(B)):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 两个向量A，B之间的余弦相似度为dotProduct(A, B) / (norm(A) * norm(B))：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, the Jaccard Similarity between the two sets *A*, *B* is *|Intersection
    (A, B)| / |Union (A, B)|*:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，两个集合*A*和*B*之间的Jaccard相似度为*|Intersection (A, B)| / |Union (A, B)|*：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Step 4 - Testing the model
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4步 - 测试模型
- en: 'Let''s see the 10 movies most similar to `Die Hard (1998)`, ranked by regularized
    correlation:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看与`Die Hard (1998)`最相似的10部电影，按常规相关性排名：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](img/67671a29-7faf-4d95-8390-626abbb4544f.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67671a29-7faf-4d95-8390-626abbb4544f.png)'
- en: 'In the preceding figure, the columns are Movie 1, Movie 2, Correlation, Reg-Correlation,
    Cosine Similarity, and Jaccard Similarity. Now let''s see the 10 movies most similar
    to *Postino, Il* (1994), ranked by regularized correlation:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，列包括电影1，电影2，相关性，常规相关性，余弦相似度和Jaccard相似度。现在，让我们看看与*Postino, Il*（1994）最相似的10部电影，按常规相关性排名：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](img/5e6ea235-0edc-45a8-8e5f-6e1832daad71.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5e6ea235-0edc-45a8-8e5f-6e1832daad71.png)'
- en: 'Finally, let''s see the 10 movies most similar to `Star Wars (1977)`, ranked
    by regularized correlation:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看与`Star Wars (1977)`最相似的10部电影，按常规相关性排名：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](img/2aae7d60-2323-4dc8-a3c2-e653ab54840c.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2aae7d60-2323-4dc8-a3c2-e653ab54840c.png)'
- en: Now, from the outputs, we can see that some movie pairs have very few common
    raters; it can be seen that using raw correlation resulted in suboptimal similarities.
    Using cosine similarity did not perform well, though it is a standard similarity
    metric for collaborative filtering approaches.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从输出结果中，我们可以看到一些电影对的共同评分者非常少；可以看出，使用原始的相关性计算得出的相似度并不理想。虽然余弦相似度是协同过滤方法中的标准相似度度量，但其表现不佳。
- en: 'The reason is that there are many movies having a cosine similarity of 1.0\.
    By the way, the preceding `evaluateModel()` method, which tests a few movies (substituting
    the contains call with the relevant movie name), goes as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于有许多电影的余弦相似度为1.0。顺便提一下，前面的`evaluateModel()`方法会测试几部电影（用相关的电影名称替代contains调用），具体如下：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can understand the limitations of these types of collaborative filtering-based
    approaches. Of course there are computational complexities, but you're partially
    right. The most important aspects are that these does not have the ability to
    predict missing entries in real-life use cases. They also have some already-mentioned
    problems such as cold start, scalability, and sparsity. Therefore, we will see
    how we can improve these limitations using model-based recommendation systems
    in Spark MLlib.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以理解基于这些协同过滤方法的局限性。当然，这些方法有计算复杂性，但你部分是对的。最重要的方面是，这些方法无法预测在实际应用中缺失的条目。它们还存在一些前面提到的问题，如冷启动、可扩展性和稀疏性。因此，我们将看看如何使用
    Spark MLlib 中的基于模型的推荐系统来改进这些局限性。
- en: Model-based recommendation with Spark
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于模型的推荐（使用 Spark）
- en: 'To make a preference prediction for any user, collaborative filtering uses
    a preference by other users of similar interests and predicts movies of your interests,
    that are unknown to you. Spark MLlib uses **Alternate Least Squares** (**ALS**)
    to make a recommendation. Here is a glimpse of a collaborative filtering method
    used in the ALS algorithm:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为任何用户做出偏好预测，协同过滤使用其他兴趣相似的用户的偏好，并预测你可能感兴趣但未知的电影。Spark MLlib 使用 **交替最小二乘法**（**ALS**）来进行推荐。以下是
    ALS 算法中使用的一种协同过滤方法的概览：
- en: '**Table 1 – User-movie matrix**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1 – 用户-电影矩阵**'
- en: '| **Users** | **M1** | **M2** | **M3** | **M4** |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **用户** | **M1** | **M2** | **M3** | **M4** |'
- en: '| **U1** | 2 | 4 | 3 | 1 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **U1** | 2 | 4 | 3 | 1 |'
- en: '| **U2** | 0 | 0 | 4 | 4 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **U2** | 0 | 0 | 4 | 4 |'
- en: '| **U3** | 3 | 2 | 2 | 3 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **U3** | 3 | 2 | 2 | 3 |'
- en: '| **U4** | 2 | ? | 3 | ? |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| **U4** | 2 | ? | 3 | ? |'
- en: In the preceding table, user ratings on movies are represented as a matrix (that
    is, a user-item matrix), where a cell represents ratings for a particular movie
    by a user. The cell with **?** represents the movies user **U4** is not aware
    of or hasn't seen. Based on the current preference of **U4**, the cell with **?** can
    be filled in with an approximate rating of users who have similar interests as
    **U4**. So at this point, ALS cannot do it alone, but the LFs are then used to
    predict the missing entries.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表格中，用户对电影的评分表示为一个矩阵（即用户-物品矩阵），其中每个单元格表示一个用户对特定电影的评分。单元格中的 **?** 代表用户 **U4**
    不知道或没有看过的电影。根据 **U4** 当前的偏好，单元格中的 **?** 可以通过与 **U4** 兴趣相似的用户的评分来填充。因此，ALS 本身无法完成此任务，但可以利用
    LF 来预测缺失的条目。
- en: 'The Spark API provides the implementation of the ALS algorithm, which is used
    to learn these LFs based on the following six parameters:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Spark API 提供了 ALS 算法的实现，该算法用于基于以下六个参数学习这些 LF：
- en: '`numBlocks`: This is the number of blocks used to parallelize computation (set
    to -1 to auto-configure).'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numBlocks`: 这是用于并行计算的块数（设置为 -1 会自动配置）。'
- en: '`rank`: This is the number of LFs in the model.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rank`: 这是模型中LF（潜在因子）的数量。'
- en: '`iterations`: This is the number of iterations of ALS to run. ALS typically
    converges to a reasonable solution in 20 iterations or less.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iterations`: 这是 ALS 运行的迭代次数。ALS 通常在 20 次迭代或更少的次数内收敛到合理的解决方案。'
- en: '`lambda`: This specifies the regularization parameter in ALS.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lambda`: 这是 ALS 中指定的正则化参数。'
- en: '`implicitPrefs`: This specifies whether to use the explicit feedback from the
    ALS variant (or one user defined) for implicit feedback data.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`implicitPrefs`: 这是指定是否使用 ALS 变体中的显式反馈（或用户定义的）来处理隐式反馈数据。'
- en: '`alpha`: This is a parameter applicable to the implicit feedback variant of
    ALS that governs the baseline confidence in preference observations.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alpha`: 这是 ALS 的隐式反馈变体中的一个参数，用于控制偏好观察的基准信心。'
- en: 'Note that to construct an ALS instance with default parameters, you can set
    the value based on your requirements. The default values are as follows: `numBlocks:
    -1`, `rank: 10`, `iterations: 10`, `lambda: 0.01`, `implicitPrefs: false`, and
    `alpha: 1.0`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，要构造一个使用默认参数的 ALS 实例，可以根据需要设置相应的值。默认值如下：`numBlocks: -1`，`rank: 10`，`iterations:
    10`，`lambda: 0.01`，`implicitPrefs: false`，`alpha: 1.0`。'
- en: Data exploration
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据探索
- en: The movie and the corresponding rating dataset were downloaded from the MovieLens
    website ([https://movielens.org](https://movielens.org)). According to the data
    description on the MovieLens website, all the ratings are described in the `ratings.csv`
    file. Each row of this file, followed by the header, represents one rating of
    one movie by one user.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 电影和相应的评分数据集是从 MovieLens 网站下载的（[https://movielens.org](https://movielens.org)）。根据
    MovieLens 网站上的数据说明，所有评分都记录在 `ratings.csv` 文件中。该文件中的每一行（包括标题行）代表一个用户对某部电影的评分。
- en: 'The CSV dataset has the following columns: `userId`, `movieId`, `rating`, and
    `timestamp`. These are shown in *Figure 14*. The rows are ordered first by `userId` and
    within the user by `movieId`. Ratings are made on a five-star scale, with half-star
    increments (0.5 stars up to a total of 5.0 stars). The timestamps represent the
    seconds since midnight in **Coordinated Universal Time** (**UTC**) on January
    1, 1970\. We have 105,339 ratings from 668 users on 10,325 movies:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 该 CSV 数据集包含以下列：`userId`、`movieId`、`rating` 和 `timestamp`。这些在*图 14*中显示。行按照`userId`排序，并在每个用户内部按`movieId`排序。评分采用五分制，并有半星递增（从
    0.5 星到 5.0 星）。时间戳表示自 1970 年 1 月 1 日午夜以来的秒数，时间格式为**协调世界时**（**UTC**）。我们从 668 个用户那里收到了
    105,339 个评分，涵盖 10,325 部电影：
- en: '**![](img/fd8ab03d-af42-41ae-b656-0a7a5f6a53ff.png)**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/fd8ab03d-af42-41ae-b656-0a7a5f6a53ff.png)**'
- en: 'Figure 2: A snap of the rating dataset'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2：评分数据集的快照
- en: 'On the other hand, movie information is contained in the `movies.csv` file.
    Each row, apart from the header information, represents one movie containing these
    columns: `movieId`, `title`, and `genres` (see *Figure 2*). Movie titles are either
    created or inserted manually or imported from the website of the movie database
    at [https://www.themoviedb.org/](https://www.themoviedb.org/). The release year,
    however, is shown in brackets.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，电影信息包含在`movies.csv`文件中。每行（除去表头信息）代表一部电影，包含这些列：`movieId`、`title` 和 `genres`（见*图
    2*）。电影标题要么是手动创建或插入的，要么是从电影数据库网站（[https://www.themoviedb.org/](https://www.themoviedb.org/)）导入的。上映年份则以括号形式显示。
- en: 'Since movie titles are inserted manually, some errors or inconsistencies may
    exist in these titles. Readers are, therefore, recommended to check the IMDb database
    ([https://www.imdb.com/](https://www.imdb.com/)) to make sure that there are no
    inconsistencies or incorrect titles with the corresponding release year:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于电影标题是手动插入的，因此这些标题可能存在一些错误或不一致的情况。因此，建议读者查阅 IMDb 数据库（[https://www.imdb.com/](https://www.imdb.com/)），确保没有不一致或错误的标题和对应的上映年份：
- en: '![](img/08e1a39e-0aee-406c-8aae-fab36f629624.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08e1a39e-0aee-406c-8aae-fab36f629624.png)'
- en: 'Figure 3: Title and genres for top 20 movies'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3：前 20 部电影的标题和类型
- en: 'Genres are in a separated list and are selected from the following genre categories:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 类型以分隔列表的形式出现，并从以下类型类别中选择：
- en: Action, Adventure, Animation, Children's, Comedy, and Crime
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作、冒险、动画、儿童、喜剧和犯罪
- en: Documentary, Drama, Fantasy, Film-Noir, Horror, and Musical
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纪录片、剧情、幻想、黑色电影、恐怖和音乐剧
- en: Mystery, Romance, Sci-Fi, Thriller, Western, and War
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 神秘、浪漫、科幻、惊悚、西部和战争
- en: Movie recommendation using ALS
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ALS 进行电影推荐
- en: In this subsection, we will show you how to recommend movies to other users
    through a systematic example, from data collection to movie recommendation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将通过一个系统的示例向您展示如何向其他用户推荐电影，从数据收集到电影推荐。
- en: Step 1 - Import packages, load, parse, and explore the movie and rating dataset
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤 1 - 导入软件包，加载、解析并探索电影和评分数据集
- en: 'We will load, parse, and do some exploratory analysis. However, before that,
    let''s import the necessary packages and libraries:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载、解析并进行一些探索性分析。不过，在此之前，我们先导入必要的软件包和库：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This code segment should return you the DataFrame of the ratings:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码段应返回评分的 DataFrame：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following code segment shows you the DataFrame of the movies:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码段展示了电影的 DataFrame：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Step 2 - Register both DataFrames as temp tables to make querying easier
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤 2 - 注册两个 DataFrame 作为临时表，以便更方便地查询
- en: 'To register both datasets, we can use the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册这两个数据集，我们可以使用以下代码：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will help to make in-memory querying faster by creating a temporary view
    as a table in the memory. The lifetime of the temporary table using the `createOrReplaceTempView
    ()` method is tied to `[[SparkSession]]`, which was used to create this DataFrame.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过在内存中创建一个临时视图作为表来加快内存查询的速度。使用`createOrReplaceTempView()`方法创建的临时表的生命周期与用于创建该
    DataFrame 的`[[SparkSession]]`相关联。
- en: Step 3 - Explore and query for related statistics
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤 3 - 探索和查询相关统计数据
- en: 'Let''s check the ratings-related statistics. Just use the following code lines:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查与评分相关的统计数据。只需使用以下代码行：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You should find `105,339` ratings from `668` users on `10,325` movies. Now,
    let's get the maximum and minimum ratings along with the count of users who have
    rated a movie. However, you need to perform an SQL query on the rating table we
    just created in memory in the previous step. Making a query here is simple, and
    it is similar to making a query from a MySQL database or RDBMS.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会发现`668`用户在`10,325`部电影上有`105,339`条评分。现在，让我们获取最大和最小评分以及评分过电影的用户数量。然而，你需要对我们在上一步骤中创建的评分表执行SQL查询。在这里进行查询很简单，类似于从MySQL数据库或关系型数据库管理系统（RDBMS）中进行查询。
- en: 'However, if you are not familiar with SQL-based queries, you are advised to
    look at the SQL query specification to find out how to perform a selection using
    `SELECT` from a particular table, how to perform ordering using `ORDER`, and how
    to perform a joining operation using the `JOIN` keyword. Well, if you know the
    SQL query, you should get a new dataset using a complex SQL query, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你不熟悉基于SQL的查询，建议查看SQL查询规范，了解如何使用`SELECT`从特定表中选择数据，如何使用`ORDER`进行排序，以及如何使用`JOIN`关键字进行连接操作。好吧，如果你熟悉SQL查询，你应该使用复杂的SQL查询来获取新的数据集，如下所示：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Output:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '![](img/6c4cea0d-0c85-441b-a932-51301558c41c.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c4cea0d-0c85-441b-a932-51301558c41c.png)'
- en: 'Figure 4: Max and min ratings along with the count of users who have rated
    a movie'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：最大和最小评分以及评分过电影的用户数量
- en: 'To get some insight, we need to know more about the users and their ratings.
    Now let''s find the 10 most active users and how many times they rated a movie:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得一些洞察，我们需要更多了解用户及其评分。现在，让我们找出排名前10的活跃用户及其评分次数：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![](img/007fce7f-9e51-4c07-878d-7a2c23be60f8.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/007fce7f-9e51-4c07-878d-7a2c23be60f8.png)'
- en: 'Figure 5: Top 10 active users and how many times they rated a movie'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：排名前10的活跃用户及其评分次数
- en: 'Let''s have a look at a particular user and find the movies that, say user, `668` rated
    higher than `4`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下特定用户，并找出例如用户`668`评分高于`4`的电影：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![](img/4cdb1752-2455-4389-a605-843cbf9cdbe2.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4cdb1752-2455-4389-a605-843cbf9cdbe2.png)'
- en: 'Figure 6: Movies that user 668 rated higher than 4'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：用户668评分高于4分的电影
- en: Step 4 - Prepare training and test rating data and check the counts
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤4 - 准备训练和测试评分数据并检查计数
- en: 'The following code splits the ratings RDD into training data RDD (75%) and
    test data RDD (25%). Seed here is optional but is required for reproducibility
    purposes:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将评分RDD拆分为训练数据RDD（75%）和测试数据RDD（25%）。这里的种子是可选的，但为了可重复性，需要指定：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You should notice that there are 78,792 ratings in training and 26,547 ratings
    in the test
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意到，训练数据中有78,792条评分，测试数据中有26,547条评分。
- en: DataFrame.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame。
- en: Step 5 - Prepare the data for building the recommendation model using ALS
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤5 - 准备数据以构建使用ALS的推荐模型
- en: 'The ALS algorithm takes the RDD of ratings for training. To do so, the following
    code illustrates for building the recommendation model using APIs:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ALS算法使用训练数据的评分RDD。为此，以下代码展示了如何使用API构建推荐模型：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `ratingsRDD` is an RDD of ratings that contains `userId`, `movieId`, and
    the corresponding ratings from the training dataset we prepared in the previous
    step. On the other hand, a test RDD is also required for evaluating the model.
    The following `testRDD` also contains the same information coming from the test
    DataFrame we prepared in the previous step:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`ratingsRDD`是一个包含`userId`、`movieId`及相应评分的RDD，来源于我们在上一步骤中准备的训练数据集。另一方面，也需要一个测试RDD来评估模型。以下`testRDD`也包含来自我们在上一步骤中准备的测试DataFrame的相同信息：'
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Step 6 - Build an ALS user product matrix
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤6 - 构建ALS用户-电影矩阵
- en: 'Build an ALS user matrix model based on `ratingsRDD` by specifying the maximal
    iteration, a number of blocks, alpha, rank, lambda, seed, and `implicitPrefs`.
    Essentially, this technique predicts missing ratings for specific users and specific
    movies based on ratings for those movies from other users who gave similar ratings
    for other movies:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 基于`ratingsRDD`构建一个ALS用户矩阵模型，通过指定最大迭代次数、块数、alpha、rank、lambda、种子以及`implicitPrefs`来实现。基本上，这种技术根据其他用户对其他电影的相似评分来预测特定用户和特定电影的缺失评分：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, we iterated the model for learning 15 times. With this setting, we
    got good prediction accuracy. Readers are advised to apply hyperparameter tuning
    to get to know the most optimum values for these parameters. Furthermore, set
    the number of blocks for both user blocks and product blocks to parallelize the
    computation into a pass -1 for an auto-configured number of blocks. The value
    is -1.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们迭代训练了模型15次。在这个设置下，我们得到了良好的预测准确性。建议读者进行超参数调优，以找到这些参数的最优值。此外，将用户块和产品块的块数设置为-1，以便并行化计算并自动配置块数。该值为-1。
- en: Step 7 - Making predictions
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤7 - 进行预测
- en: 'Let''s get the top six movie predictions for user `668`. The following source
    code can be used to make the predictions:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为用户`668`获取前六部电影的预测。以下源代码可以用于进行预测：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![](img/8840f8dc-d0b8-4885-b494-888a164eb7bf.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8840f8dc-d0b8-4885-b494-888a164eb7bf.png)'
- en: Figure 7: Top six movie predictions for user 668
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：用户668的前六部电影预测
- en: Step 8 - Evaluating the model
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤8 - 评估模型
- en: In order to verify the quality of the model, **Root Mean Squared Error** (**RMSE**)
    is used to measure the difference between values predicted by a model and the
    values actually observed. By default, the smaller the calculated error, the better
    the model. In order to test the quality of the model, the test data is used (which
    was split in *step 4*).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证模型的质量，**均方根误差**（**RMSE**）被用来衡量模型预测值与实际观测值之间的差异。默认情况下，计算的误差越小，模型越好。为了测试模型的质量，使用了测试数据（该数据在*步骤4*中已拆分）。
- en: 'According to many machine learning practitioners, RMSE is a good measure of
    accuracy, but only for comparing forecasting errors of different models for a
    particular variable. They say it is not fit for comparing between variables as
    it is scale dependent. The following line of code calculates the RMSE value for
    the model that was trained using the training set:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 根据许多机器学习从业者的说法，RMSE是一个良好的准确度衡量标准，但仅适用于比较不同模型在特定变量上的预测误差。他们表示，RMSE不适合用于比较不同变量之间的误差，因为它依赖于尺度。以下代码行计算了使用训练集训练的模型的RMSE值：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For this setting, we get this output:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个设置，我们得到以下输出：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This method computes the RMSE to evaluate the model. The lesser the RMSE, the
    better the model and its prediction capability. It is to be noted that `computeRmse()`
    is a UDF that goes as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法通过计算RMSE来评估模型。RMSE越小，模型和预测能力越好。需要注意的是，`computeRmse()`是一个UDF，其实现如下：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![](img/49e379f1-e8b2-4546-ad36-bb1be1eb8575.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49e379f1-e8b2-4546-ad36-bb1be1eb8575.png)'
- en: 'Finally, let''s provide some movie recommendation for a specific user. Let''s
    get the top six movie predictions for user `668`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们为特定用户提供一些电影推荐。让我们为用户`668`获取前六部电影的预测：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![](img/798664c9-3a41-49a3-86f1-4b9dfbe45b86.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/798664c9-3a41-49a3-86f1-4b9dfbe45b86.png)'
- en: The performance of the preceding model could be increased more, we believe.
    However, so far, there's no model tuning facility of our knowledge available for
    the MLlib-based ALS algorithm.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们相信，前一个模型的性能可以进一步提高。然而，迄今为止，基于MLlib的ALS算法没有我们所知的模型调优工具。
- en: Interested readers should refer to this URL for more on tuning ML-based ALS
    models: [https://spark.apache.org/docs/preview/ml-collaborative-filtering.html](https://spark.apache.org/docs/preview/ml-collaborative-filtering.html).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有兴趣的读者可以参考这个网址，了解更多关于调优基于ML的ALS模型的内容：[https://spark.apache.org/docs/preview/ml-collaborative-filtering.html](https://spark.apache.org/docs/preview/ml-collaborative-filtering.html)。
- en: Selecting and deploying the best model
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择并部署最佳模型
- en: It is worth mentioning that the first model developed in the first project cannot
    be persisted since it is just a few lines of code for computing movie similarity.
    It also has another limitation that we did not cover earlier. It can compute the
    similarity between two movies, but what about more than two movies? Frankly speaking,
    a model like the first one would rarely be deployed for a real-life movie. So
    let's focus on the model-based recommendation engine instead.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，第一个项目中开发的第一个模型无法持久化，因为它仅是计算电影相似性的几行代码。它还有另一个之前未提到的限制。它可以计算两部电影之间的相似度，但如果是多于两部电影呢？坦率地说，像第一个模型这样的模型很少会应用于真实的电影推荐。因此，我们将重点关注基于模型的推荐引擎。
- en: Although ratings from users will keep coming, still it might be worth it to
    store the current one. Therefore, we also want to persist our current base model
    for later use in order to save time when starting up the server. The idea is to
    use the current model for real-time movie recommendations.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管用户的评分会不断出现，但仍然值得存储当前的评分。因此，我们还希望持久化当前的基础模型，以便以后使用，从而在启动服务器时节省时间。我们的想法是使用当前模型进行实时电影推荐。
- en: 'Nevertheless, we might also save time if we persist some of the RDDs we have
    generated, especially those that took longer to process. The following line saves
    our trained ALS model (see the `MovieRecommendation.scala` script for details):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们持久化一些已生成的 RDD，尤其是那些处理时间较长的 RDD，可能也能节省时间。以下代码保存了我们训练好的 ALS 模型（具体细节请参见`MovieRecommendation.scala`脚本）：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Unlike another Spark model, the ALS model that we saved will contain only data
    and some metadata in parquet format from the training, as shown in the following
    screenshot:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他 Spark 模型不同，我们保存的 ALS 模型将仅包含训练过程中数据和一些元数据，采用 parquet 格式，具体如下图所示：
- en: '![](img/10e58639-6f8a-46f7-bb8b-b08f4e0d79f3.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10e58639-6f8a-46f7-bb8b-b08f4e0d79f3.png)'
- en: 'Now, the next task would be to restore the same model and provide a similar
    workflow as shown in the preceding steps:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，下一个任务是恢复相同的模型，并提供与前面步骤中展示的类似的工作流：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Nevertheless I won''t confuse you, especially if you''re new to Spark and Scala.
    Here''s the complete code that predicts the ratings of user 558:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 不过我不会让你感到困惑，特别是如果你是 Spark 和 Scala 的新手的话。这是预测用户 558 评分的完整代码：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If the preceding script is executed successfully, you should see the following
    output:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的脚本成功执行，您应该会看到以下输出：
- en: '![](img/45a9b0e0-8410-4a69-a6a5-cfaae23112b7.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45a9b0e0-8410-4a69-a6a5-cfaae23112b7.png)'
- en: Well done! We have managed to reuse the model and do the same prediction but
    for a different user, that is, 558\. However, probably due to the randomness of
    the data, we observed a slightly different RMSE.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 做得好！我们成功地重用了模型，并为不同的用户（即 558）进行了相同的预测。然而，可能由于数据的随机性，我们观察到略微不同的 RMSE。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we implemented two end-to-end projects to develop item-based
    collaborative filtering for movie similarity measurement and model-based recommendation
    with Spark. We also saw how to interoperate between ALS and MF and develop scalable
    movie recommendations engines. Finally, we saw how to deploy this model in production.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们实现了两个端到端项目，分别开发了基于项目的协同过滤来进行电影相似度测量和基于模型的推荐，均使用 Spark 完成。我们还展示了如何在 ALS
    和 MF 之间进行互操作，并开发可扩展的电影推荐引擎。最后，我们看到了如何将此模型部署到生产环境中。
- en: As human beings, we learn from past experiences. We haven't gotten so charming
    by accident. Years of positive compliments as well as criticism have all helped
    shape us into what we are today. You learn what makes people happy by interacting
    with friends, family, and even strangers, and you figure out how to ride a bike
    by trying out different muscle movements until it just clicks. When you perform
    actions, you're sometimes rewarded immediately. This is all about **Reinforcement
    Learning** (**RL**).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 作为人类，我们通过过去的经验学习。我们之所以变得如此迷人，并非偶然。多年的正面赞美和批评都帮助我们塑造了今天的自我。你通过与朋友、家人，甚至陌生人互动，学习如何让别人开心；你通过尝试不同的肌肉运动，直到自行车骑行技巧自然流畅，来学会骑车。当你执行某些动作时，有时会立即获得奖励。这一切都是关于**强化学习**（**RL**）。
- en: The next chapter is all about designing a machine learning project driven by
    criticisms and rewards. We will see how to apply RL algorithms for developing
    options trading applications using real-life IBM stock and option price datasets.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论如何设计一个由反馈和奖励驱动的机器学习项目。我们将看到如何应用强化学习（RL）算法，利用现实中的 IBM 股票和期权价格数据集开发期权交易应用。
