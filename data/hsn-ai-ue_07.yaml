- en: Extending Behavior Trees
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展行为树
- en: '*Empowering a tree with more leaves and branches will make it unstoppable.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*赋予树更多的叶子和分支将使其变得不可阻挡*。'
- en: In this chapter, we will understand how to extend *Behavior Trees* by implementing
    our custom **Tasks**, **Decorators**, and **Services**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解如何通过实现我们自定义的 **任务**、**装饰器** 和 **服务** 来扩展 *行为树*。
- en: Since in chapters 8, 9, and 10 we are going to create a concrete example of
    a *Behavior Tree* from scratch and create custom *Tasks*, *Decorators*, and *Services*,
    you can look at this chapter as a quick theoretical introduction to those chapters
    in order to give you a ground base for extending *Behavior Trees*. Thus, this
    chapter might be super fluid and repetitive, but it will teach you about a great
    tool, which we will refine later in this book in a more playful way.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在第8章、第9章和第10章中，我们将从头开始创建一个具体的 *行为树* 示例，并创建自定义的 *任务*、*装饰器* 和 *服务*，您可以将本章视为对这些章节的快速理论介绍，以便为您扩展
    *行为树* 提供一个基础。因此，本章可能会非常流畅且重复，但它将向您介绍一个伟大的工具，我们将在本书的后续部分以更轻松的方式对其进行完善。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How to create a ***Task***, both in *Blueprint and C++*, to make our AI agent
    capable of executing custom actions.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 *Blueprint* 和 *C++* 中创建一个 ***任务***，使我们的 AI 代理能够执行自定义动作。
- en: How to create a ***Decorator***, both in *Blueprint and C++*, to create specific
    conditions that we can enter in certain sub-branches of the *Behavior Tree*
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 *Blueprint* 和 *C++* 中创建一个 ***装饰器***，以创建我们可以在 *行为树* 的某些子分支中输入的特定条件
- en: How to create a ***Service***, both in *Blueprint and C++*, to continuously update
    the data in our *Blackboard* for the *Behavior Tree*
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 *Blueprint* 和 *C++* 中创建一个 ***服务***，以持续更新 *黑板* 中用于 *行为树* 的数据
- en: How to create *Composite nodes*, *new types of nodes*, or even *new trees*
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建 *复合节点*、*新类型的节点* 或甚至 *新树*
- en: So, let's dive in!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们深入探讨吧！
- en: A quick recap on Behavior Trees
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为树的快速回顾
- en: Here is a quick recap on **Behaviors Trees** to refresh you.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个关于 **行为树** 的快速回顾，以帮助您巩固记忆。
- en: A **Behavior Tree** is a structure for decision-making which uses a *Blackboard*
    as its memory. In particular, the flow starts from a special node called the **Root**,
    all the way down to the leaves, which are called Tasks. A **Task** is a single
    action that the AI can take/perform.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为树** 是一种决策结构，它使用 *黑板* 作为其内存。特别是，流程从称为 **根** 的特殊节点开始，一直到底部的叶子节点，这些叶子节点被称为
    **任务**。**任务** 是 AI 可以采取/执行的单一动作。'
- en: Then, all the nodes that are non-leaves (or the root) are **Composite**. A composite
    node chooses which one of the children to execute. The two main **Composite**
    nodes are ***Sequence*** (which tries to execute all the sequences of its children
    in order, and if they succeed, it reports a success back, otherwise it reports
    a fail) and ***Selector*** (which tries each child until it finds one that succeeds
    and reports a success or all of them fail and it reports a fail).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，所有非叶子节点（或根节点）都是 **复合** 节点。复合节点选择执行哪个子节点。两个主要的 **复合** 节点是 ***序列***（它试图按顺序执行其子节点的所有序列，如果它们成功，则返回成功，否则返回失败）和
    ***选择器***（它尝试每个子节点，直到找到一个成功的，并报告成功，或者所有子节点都失败，并报告失败）。
- en: Both **Composite** and **Tasks** nodes can use **Decorators** (which impose
    conditions that must be true so that you can choose that node) or **Services** on
    top (a continuously running piece of code, e.g. what's used to set Blackboard
    values).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**复合** 和 **任务** 节点都可以使用 **装饰器**（它施加必须为真的条件，以便你可以选择该节点）或顶部的 **服务**（一段持续运行的代码，例如用于设置黑板值）。'
- en: If you still have some doubts, please revise [Chapter 2](00781951-41e3-4e33-8512-052e7aecfd15.xhtml),
    *Behavior Trees and Blackboards*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仍有疑问，请复习 [第2章](00781951-41e3-4e33-8512-052e7aecfd15.xhtml)，*行为树和黑板*。
- en: Creating a Task
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个任务
- en: Deep diving into the concepts we looked at earlier, back in [Chapter 2](00781951-41e3-4e33-8512-052e7aecfd15.xhtml),
    *Behavior Trees and Blackboards*, a ***Task*** is a single action that our AI
    Agent can perform. Some examples include walking to a specific location, performing/running
    an EQS, locating something, chasing the players, etc. All of these actions can
    either fail or succeed. The final result of a task is then carried back on the
    *Behavior Tree*, with rules we have seen for Selectors and Sequences.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨我们在[第2章](00781951-41e3-4e33-8512-052e7aecfd15.xhtml)“行为树和黑板”中讨论的概念，**任务**是我们的人工智能代理可以执行的单个动作。一些例子包括走到特定位置、执行/运行EQS、定位某物、追逐玩家等。所有这些动作都可以失败或成功。然后，任务的最终结果会通过**行为树**返回，遵循我们看到的选择器和序列的规则。
- en: A task doesn't necessarily have to be executed in a frame, but it can be extended
    indefinitely. In fact, a Task is not finished until it reports with either a *Failure*
    or a *Success*. However, they can be interrupted/aborted by external nodes, such
    as a *Decorator*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 任务不一定必须在帧中执行，但它可以无限期地扩展。实际上，任务只有在报告了**失败**或**成功**后才会完成。然而，它们可以被外部节点（如**装饰器**）中断/中止。
- en: When you create a Task, regardless of whether this is done in Blueprint or C++,
    you will need to override some functions. Since Blueprint is easier, and share
    the same concepts that we use in C++, we will first look at how the system works
    in Blueprint.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建任务时，无论这是在蓝图还是C++中完成，您都需要覆盖一些函数。由于蓝图更容易，并且与我们在C++中使用的概念相同，我们将首先查看蓝图中的系统是如何工作的。
- en: Creating a Blueprint Task
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建蓝图任务
- en: 'To create a ***Blueprint Task***, we have a few options available to us. The
    easiest one is in the *Behavior Tree Editor*, in which we press the "***New Task***"
    button in the top bar, as shown in the following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个**蓝图任务**，我们有几种选择可供选择。最简单的一种是在**行为树编辑器**中，我们在顶部栏中按下“**新建任务**”按钮，如下面的截图所示：
- en: '![](img/da0c1058-4cb4-4104-bba6-7b559850a1ff.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/da0c1058-4cb4-4104-bba6-7b559850a1ff.png)'
- en: However, you will need to manually rename the file and place it in the folder
    that you wish it to be in.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您需要手动重命名文件并将其放置在您希望它所在的文件夹中。
- en: 'Another way to create a Task is to create a new Blueprint that inherits from
    ***BTTask_BlueprintBase***, as shown in the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 创建任务的另一种方法是创建一个新的蓝图，它继承自**BTTask_BlueprintBase**，如下面的截图所示：
- en: '![](img/4aceb3ad-af67-4eb2-8b2b-209c41de92d1.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/4aceb3ad-af67-4eb2-8b2b-209c41de92d1.png)'
- en: 'The convention is to prefix the Tasks with "*BBTask_*" (which stands for *Behavior
    Tree Task*). For instance, we could call our Task something like *BTTask_BPMyFirstTask*:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 习惯上，在任务前加上“*BBTask_*”（代表**行为树任务**）。例如，我们可以将我们的任务命名为*BTTask_BPMyFirstTask*：
- en: '![](img/1bb229e7-b40e-49e8-ad4a-fab724aaf32f.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/1bb229e7-b40e-49e8-ad4a-fab724aaf32f.png)'
- en: 'Once a *Blueprint Task* has been created, there are three type functions that
    we can override:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了**蓝图任务**，我们可以覆盖三种类型函数：
- en: '![](img/7f1ba58f-6c0f-40c9-86d1-087b3541d714.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/7f1ba58f-6c0f-40c9-86d1-087b3541d714.png)'
- en: '**Receive Execute**: This is called when the *Task* starts, and here you should
    implement all the initialization for your task.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收执行**：当**任务**开始时调用此功能，在这里您应该实现您任务的全部初始化。'
- en: '**Receive Tick**: This is called every time the Task ticks, and so you can
    use it to continuously do something. However, since there might be many agents
    executing many *Behaviors Trees*, it would be advisable to keep this Tick function
    as short as possible or not implement it at all (for performance reasons), and
    use either timers or delegates to handle the task.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收时钟**：每次任务时钟滴答时都会调用此功能，因此您可以使用它来持续做某事。然而，由于可能有许多代理执行许多**行为树**，建议尽可能保持此时钟函数尽可能短，或者根本不实现它（出于性能原因），并使用计时器或委托来处理任务。'
- en: '**Receive Abort**: This is called every time that the Task is executing, but
    the *Behavior Tree* requested to abort it. You need to use this function to clean
    up your tasks (e.g. restore some Blackboard values).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收中止**：每次任务执行时都会调用此功能，但**行为树**请求中止它。您需要使用此功能来清理您的任务（例如，恢复一些黑板值）。'
- en: In Blueprint, these three functions exist in two forms, ***AI*** and ***non-AI***,
    and are also known as being *generic* (e.g. *Receive Execute* and *Receive Execute
    AI*). There is not much difference between them. If only one is implemented (as
    a suggestion, implement the AI version to keep your project consistent), that
    is the function that is called. Otherwise, the most convenient will be called,
    which means that the AI version is called when the Pawn is possessed by an *AI
    Controller*, and the *non-AI* version is called in all the other cases. Of course,
    most of your cases would be that the *Behavior Tree* is running on top of an *AI
    Controller*, so the *non-AI* version is for very specific and rarer cases.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图（Blueprint）中，这三个功能以两种形式存在，即***AI***和***非AI***，也被称为是*通用的*（例如*接收执行*和*接收执行AI*）。它们之间没有太大的区别。如果只实现了一个（建议实现AI版本以保持项目一致性），那么调用的是这个功能。否则，最方便的版本将被调用，这意味着当Pawn被*AI控制器*控制时，将调用AI版本，而在所有其他情况下将调用*非AI*版本。当然，在大多数情况下，*行为树*都是在*AI控制器*上运行的，所以*非AI*版本是为非常特定且较少见的情况准备的。
- en: 'So far, the system has no way of understanding when a *Task* has finished its
    execution or has finished to clean up after an abort. For this reason, there are
    two functions you will need to call:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，系统没有方法理解一个*任务*何时完成执行或完成清理操作。因此，你需要调用两个函数：
- en: '![](img/3343947a-a17c-4fb1-b240-9f88833757df.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3343947a-a17c-4fb1-b240-9f88833757df.png)'
- en: '**Finish Execute**: This will indicate that the *Task* has finished its execution.
    It has a Boolean parameter to indicate whether the *Task* has ***succeeded***
    (***true*** value) or ***failed*** (***false*** value).'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完成执行**：这将表明*任务*已完成其执行。它有一个布尔参数来指示*任务*是否***成功***（***true***值）或***失败***（***false***值）。'
- en: '**Finish Abort**: This will indicate that the *Task* has finished to abort.
    It has no parameters.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完成中止**：这将表明*任务*已完成中止。它没有参数。'
- en: Please note that if you don't call these two functions, the task will hang there
    forever, which is not a desired behavior. Although it would be advisable to call
    the Finish Abort function at the end of the *Receive Abort* event, there are cases
    in which you will need more than one frame to clean up. In this case, you can
    call the *Finish Abort* somewhere else (e.g. in a delegate).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你不调用这两个函数，任务将永远挂在那里，这不是期望的行为。虽然建议在*接收中止*事件的末尾调用*完成中止*函数，但在某些情况下你可能需要多帧来清理。在这种情况下，你可以在其他地方（例如在委托中）调用*完成中止*。
- en: There are also other ways to finish executing a Task, for example, by using
    AI Messages, but we will not cover them in this book.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 完成执行一个*任务*还有其他方法，例如使用AI消息，但在这本书中我们不会涉及这些内容。
- en: This is all you need to know to create a *Task*. You just create the graph that
    you want, and remember to call the *Finish Execute* node when you are done (either
    with a *Success* or a *Fail*). We will look at a concrete example of creating
    a new Task in the following three chapters.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 创建*任务*你需要知道的所有内容。你只需创建你想要的图，记得在完成（无论是*成功*还是*失败*）时调用*完成执行*节点。我们将在接下来的三个章节中查看创建新任务的实例。
- en: Creating a Task in C++
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++中创建任务
- en: The concept of creating a ***Task in C++*** share the same concepts as its Blueprint
    counterpart.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 创建C++中*任务*的概念与蓝图中的对应概念相同。
- en: 'First all of, to create a new C++ Task, we need to create a C++ class that
    inherits from ***BTTaskNode***, as shown in the following screenshot:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要创建一个新的C++任务，我们需要创建一个继承自***BTTaskNode***的C++类，如下面的截图所示：
- en: '![](img/3e6ad68c-8037-42f2-b501-8840f3db93e6.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e6ad68c-8037-42f2-b501-8840f3db93e6.png)'
- en: 'Just like for a Blueprint Task, the convention is to prefix the *Task* with
    "***BTTask_***" (*Behavior Tree Task*). Therefore, we could name our Task something
    like "*BTTask_MyFirstTask*":'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 就像蓝图中的任务一样，惯例是在*任务*前加上"***BTTask_***"（*行为树任务*）。因此，我们可以将我们的任务命名为"*BTTask_MyFirstTask*"：
- en: '![](img/98a53e83-5688-461c-8c6c-c6654cf30a38.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98a53e83-5688-461c-8c6c-c6654cf30a38.png)'
- en: Once you have created the *Task*, you need to override some functions, which
    have very similar functionalities to the ones in Blueprint. However, there are
    some differences.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了*任务*，你需要重写一些函数，这些函数的功能与蓝图中的非常相似。然而，也有一些区别。
- en: 'One of the main differences is how to report that the Task has finished its
    execution (or has finished to abort). For these cases, there is a special enum
    structure called `EBTNodeResult`. It needs to be returned by a function so that
    the *Behavior Tree* "*knows*" if it needs to keep calling the Task or not. This
    structure can have four values:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别之一是如何报告任务已完成其执行（或已完成取消）。对于这些情况，有一个特殊的枚举结构称为`EBTNodeResult`。它需要由一个函数返回，这样*行为树*才能“知道”是否需要继续调用任务。这个结构可以有四个值：
- en: '**Succeeded**: The Tasks finishes with a success'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成功**：任务以成功结束'
- en: '**Failed**: The Tasks finishes with a failure'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**失败**：任务以失败结束'
- en: '**Aborted**: The Task has aborted'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已取消**：任务已取消'
- en: '**InProgress**: The Task hasn''t finished yet'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进行中**：任务尚未完成'
- en: Another difference lies in the fact that the twin of the Blueprint *Receive
    Execute* has to finish and thus it needs to return a `EBTNodeResult` structure
    to communicate and state whether the task has finished or whether it needs more
    than one frame. If so, other functions are then called, as we will see.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别在于，蓝图*接收执行*的双胞胎必须完成，因此它需要返回一个`EBTNodeResult`结构来通信并声明任务是否已完成或是否需要多个帧。如果是这样，那么将调用其他函数，正如我们将看到的。
- en: Moreover, in C++, there are other special concepts and structures that you can
    use that in Blueprint you cannot. For example, you have access to `NodeMemory`,
    which holds a specific memory for the Task that has been executed. For the correct
    use of this structure, watch the engine source code, and in particular, the file
    that's suggested at the end of this section.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在C++中，还有一些其他特殊的概念和结构，你可以在蓝图中使用，而在蓝图中不能使用。例如，你可以访问`NodeMemory`，它为已执行的任务保留特定的内存。为了正确使用这个结构，请查看引擎源代码，特别是本节末尾建议的文件。
- en: The last difference is that there are not the *AI* and the *non-AI* (G*eneric*)
    versions of the functions. You will have to determine by yourself if you have
    an AI controller and what to do (if you do anything).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个区别是，没有*AI*和*非AI*（通用*）版本的函数。你必须自己判断是否有AI控制器以及要做什么（如果你做了什么）。
- en: 'The functions to are as follows (this has been taken directly from the source
    code of the engine, with the two most important functions in bold):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 函数如下（这直接取自引擎的源代码，其中两个最重要的函数用粗体表示）：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, there's quite a lot of code, and it might be a bit confusing
    at first. However, if you have understood Blueprint well, making the jump to understand
    the C++ functions should be much easier. For instance, the `ExecuteTask()` function
    starts the execution of the task, but it doesn't complete it if it returns that
    the Task is still in progress.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码量相当大，一开始可能会有些混乱。然而，如果你已经很好地理解了蓝图，那么理解C++函数应该会容易得多。例如，`ExecuteTask()`函数开始执行任务，但如果它返回任务仍在进行中，则不会完成它。
- en: 'Here is a comment from the Engine Source code, which might help clarify this
    a bit:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是来自引擎源代码的注释，可能有助于澄清这一点：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The two best ways that I know of to get a better feeling of how to create a
    C++ Task is to either create one yourself, or read the source code of other Tasks.
    For instance, you can read the code in the `BTTask_MoveTo.cpp` file within the
    engine source for a complete example on how to create a C++ Task. Don't be discouraged,
    because using C++ is awesome!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道的两个最好的方法是更好地了解如何创建C++任务，要么自己创建一个，要么阅读其他任务的源代码。例如，你可以阅读引擎源代码中的`BTTask_MoveTo.cpp`文件，以了解如何创建一个完整的C++任务的示例。不要气馁，因为使用C++很酷！
- en: In any case, we will go through the process of creating a C++ Task from scratch
    in the following three chapters.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，我们将在接下来的三个章节中从头开始创建一个C++任务的过程。
- en: Creating a Decorator
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个装饰器
- en: Recalling from [Chapter 2](00781951-41e3-4e33-8512-052e7aecfd15.xhtml)*, Behavior
    Trees and Blackboards*, a ***Decorator*** is a conditional node (which can also
    be seen as a gate) that controls the execution flow of the sub-branch that it
    is attached to (if the execution would enter in the sub-branch in the first place).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第2章](00781951-41e3-4e33-8512-052e7aecfd15.xhtml)*，行为树和黑板*中回忆起，**装饰器**是一个条件节点（也可以看作是一个门），它控制着它所附加的子分支的执行流程（如果执行首先进入子分支的话）。
- en: In a similar fashion on how we *extended/created* a *Task*, we can *extend/create*
    a ***Decorator***. Once again, we will first dive into how to do it in Blueprint,
    and then move on to how to extend it in C++.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们如何*扩展/创建*一个*任务*类似，我们也可以*扩展/创建*一个***装饰器***。再次强调，我们首先将深入探讨如何在蓝图（Blueprint）中实现它，然后继续讨论如何在C++中扩展它。
- en: Creating a Decorator in Blueprint
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在蓝图（Blueprint）中创建一个装饰器
- en: 'To create a ***Blueprint ******Decorator***, like we did for *Tasks*, you can
    press the "***New Decorator***" button in the top bar of the *Behavior Tree Editor*,
    as shown in the following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个与*任务*类似的***蓝图装饰器***，你可以按下*行为树编辑器*顶部栏中的“***新建装饰器***”按钮，如下面的截图所示：
- en: '![](img/95acded1-f9f6-4e78-bf7e-a1091c192aab.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/95acded1-f9f6-4e78-bf7e-a1091c192aab.png)'
- en: 'Alternatively, you can generate the *Blueprint* class that inherits from ***BTDecorator_BlueprintBase***,
    as shown in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以生成继承自***BTDecorator_BlueprintBase***的*蓝图*类，如下面的截图所示：
- en: '![](img/3224587e-daa9-4311-ae3b-4200c68086e5.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3224587e-daa9-4311-ae3b-4200c68086e5.png)'
- en: 'In any case, the naming convention is to prefix the *Decorator* with "***BTDecorator_***"
    (which stands for *Behavior Tree Decorator*). For instance, we can call our class
    something like *BTDecorator_BPMyFirstDecorator*:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，命名约定是在*装饰器*前加上“***BTDecorator_***”（代表*行为树装饰器*）。例如，我们可以将我们的类命名为*BTDecorator_BPMyFirstDecorator*：
- en: '![](img/fbc9a933-225f-40c2-96f5-6631c0540466.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fbc9a933-225f-40c2-96f5-6631c0540466.png)'
- en: 'As for Tasks, all the *overridable* functions come in two flavors: *AI* and
    *non-AI*. The concept is exactly the same. If only one of them is implemented
    (to keep your project consistent, it is advisable to override the AI version),
    then that function is called. If both are implemented, the *AI* is called when
    the Pawn is possessed by the AI Controller, and the *non-AI* function instead
    in all the other cases.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任务，所有*可重写*的函数都有两种风味：*AI*和*非AI*。概念完全相同。如果只实现其中之一（为了保持项目一致性，建议重写AI版本），则调用该函数。如果两者都实现了，当Pawn被AI控制器拥有时，调用*AI*，而在所有其他情况下调用*非AI*函数。
- en: 'Here are the six functions that a *Decorator* can extend:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是*装饰器*可以扩展的六个函数：
- en: '![](img/7f8880f6-c133-447a-9c0e-bd6b2a55df49.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7f8880f6-c133-447a-9c0e-bd6b2a55df49.png)'
- en: '**Perform Condition Check**: This is the most important function and the only
    one you might need to override (if you don''t have dynamic things to handle).
    It has a return value of a bool, which indicates whether the conditional check
    has succeeded or not.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行条件检查**：这是最重要的函数，也是唯一可能需要重写的函数（如果你没有动态事物要处理）。它返回一个bool值，表示条件检查是否成功。'
- en: '**Receive Execution Start**: This is called when the execution of the underlying
    node (either a Composite or a Task) starts. Use this to initialize the decorator.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收执行开始**：当底层节点（无论是组合节点还是任务）的执行开始时，会调用此函数。使用此函数来初始化装饰器。'
- en: '**Receive Execution Finish**: This is called when the execution of the underlying
    node (either a Composite or a Task) is finished. Use this to clean up the decorator.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收执行完成**：当底层节点（无论是组合节点还是任务）的执行完成时，会调用此函数。使用此函数来清理装饰器。'
- en: '**Receive Tick**: This is the Tick function, in case you need to continuously
    update something. Performance-wise, is not advisable to use it for heavy operation,
    but it''s even better if it''s not used at all (e.g. use timers or delegates).'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收tick**：这是tick函数，以防你需要持续更新某些内容。从性能的角度来看，不建议用于重操作，但如果完全不使用它就更好（例如，使用计时器或委托）。'
- en: '**Receive Observer Activated**: As the name suggests, it is called when the
    Observer is activated.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收观察者激活**：正如其名所示，当观察者被激活时，会调用此函数。'
- en: '**Receive Observer Deactivated**: As the name suggests, it is called when the
    Observer is deactivated.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收观察者禁用**：正如其名所示，当观察者被禁用时，会调用此函数。'
- en: 'As you can see, *Decorators* are pretty easy (at least in Blueprint); mainly,
    you only need to *override/implement* the *Perform Condition Check* function,
    which returns a boolean value:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，*装饰器*相当简单（至少在蓝图（Blueprint）中是这样）；主要来说，你只需要*重写/实现*一个名为*Perform Condition
    Check*的函数，该函数返回一个布尔值：
- en: '![](img/568ad0bc-c704-447c-a3d8-2e978eac9f11.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/568ad0bc-c704-447c-a3d8-2e978eac9f11.png)'
- en: In any case, we will look at a concrete example of creating a *Blueprint Decorator*
    from scratch in the following three chapters.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，我们将在接下来的三个章节中查看从零开始创建*蓝图装饰器*的具体示例。
- en: Creating a Decorator in C++
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++中创建一个装饰器
- en: 'In a very similar fashion to how we extended a *Task* in C++, you can extend
    a ***Decorator in C++*** as well. The base class to inherit from is ***BTDecorator***,
    as shown in the following screenshot:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在 C++ 中扩展 *Task* 的方式非常相似，你还可以扩展一个 ***Decorator in C++***。要继承的基类是 ***BTDecorator***，如下面的截图所示：
- en: '![](img/3effa149-b0b5-4253-8507-dcacdcae57a0.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3effa149-b0b5-4253-8507-dcacdcae57a0.png)'
- en: 'The convention, as usual, is to prefix the *Decorator* with "***BTDecorator_***"
    (*Behavior Tree Decorator*). A possible name for our *Decorator* could be "*BTDecorator_MyFirstDecorator*":'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '习惯上，是在 *Decorator* 前缀为 "***BTDecorator_***"（*Behavior Tree Decorator*）。我们的
    *Decorator* 的一个可能名称可以是 "*BTDecorator_MyFirstDecorator*":'
- en: '![](img/0d68be21-df09-4423-83c8-889b37ec5a3b.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d68be21-df09-4423-83c8-889b37ec5a3b.png)'
- en: 'Diving directly into C++, these are the overridable functions, as taken from
    the Engine Source code (there are quite a lot):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 直接进入 C++，这些是可重写的函数，如从引擎源代码中获取（有很多）：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Moreover, in the Engine Source code, we can find the following comment, which
    explains a couple of implementation choices:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在引擎源代码中，我们可以找到以下注释，它解释了一些实现选择：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Unfortunately, we don't have the time to go through all of them in detail, but
    most of them are very intuitive, and so it shouldn't be hard for you to understand
    their meaning. In any case, we will look at a concrete example of how to create
    a ***C++ Decorator*** from scratch (and we will be using many of these functions)
    in the next three chapters.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们没有时间详细讲解它们，但大多数都非常直观，所以你不应该很难理解它们的含义。无论如何，我们将在接下来的三个章节中查看如何从头创建一个 ***C++
    Decorator*** 的具体示例（我们将使用许多这些函数）。
- en: Creating a Service
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务
- en: Recalling from [Chapter 2](00781951-41e3-4e33-8512-052e7aecfd15.xhtml)*, Behavior
    Trees and Blackboards*, a ***Service*** is a node that runs constantly if attached
    to one of the parents of the sub-branch. The main use of this node is to update
    the data in the *Blackboard* for the *Behavior Tree*, and it is among the nodes
    that you will need to create since they are very specific to your Gameplay.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾 [第 2 章](00781951-41e3-4e33-8512-052e7aecfd15.xhtml)*，行为树和黑板*，一个 ***Service***
    是一个节点，如果附加到子分支的父节点之一，则持续运行。此节点的主要用途是更新 *Behavior Tree* 的 *Blackboard* 中的数据，并且它是你需要创建的节点之一，因为它们非常特定于你的游戏玩法。
- en: In a similar fashion to how we extended both Tasks and *Decorators*, we can
    also *extend/create* ***Services*** as well. We will go through how to implement
    the extension in Blueprint first, and then understand how to do it in C++ as well.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们扩展任务和 *Decorators* 的方式类似，我们也可以 *扩展/创建* ***Services***。我们首先将介绍如何在蓝图中进行扩展实现，然后了解如何在
    C++ 中实现。
- en: Creating a Service in Blueprint
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在蓝图创建服务
- en: 'Just like you did for *Tasks* and *Decorators*, you can create a new ***Blueprint
    Service*** by pressing the ***New Service*** button on the top bar of the *Behavior
    Tree Editor*, as shown in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你对 *Tasks* 和 *Decorators* 所做的那样，你可以通过按 *Behavior Tree Editor* 顶部的 ***New Service***
    按钮创建一个新的 ***Blueprint Service***，如下面的截图所示：
- en: '![](img/177b1552-524f-4249-98d7-bf5679bb6163.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/177b1552-524f-4249-98d7-bf5679bb6163.png)'
- en: 'Alternatively, you can generate the *Blueprint* class that inherits from ***BTService_BlueprintBase***,
    as shown in the following screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以生成继承自 ***BTService_BlueprintBase*** 的 *Blueprint* 类，如下面的截图所示：
- en: '![](img/88357201-1e22-4ac7-9f2c-a8093f501756.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88357201-1e22-4ac7-9f2c-a8093f501756.png)'
- en: 'In any case, the naming convention is to prefix the *Service* with "***BTService_***"
    (which stands for *Behavior Tree Service*). For instance, we can call our class
    something like *BTService_BPMyFirstService*:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，命名约定是在 *Service* 前缀为 "***BTService_***"（代表 *Behavior Tree Service*）。例如，我们可以将我们的类命名为
    *BTService_BPMyFirstService*：
- en: '![](img/7169615a-8396-4d62-b6ac-5cc016dd706e.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7169615a-8396-4d62-b6ac-5cc016dd706e.png)'
- en: 'Just like the *Tasks* and *Decorators*, all the *overridable* functions come
    in two different versions: AI and *non-AI* (*Generic*). The concept is exactly
    the same: if only one of them is implemented (to keep your project consistent,
    it is advisable to override the AI version), then that function is called. If
    both are implemented, the AI is called when the Pawn is possessed by the AI Controller,
    otherwise the generic function is called instead.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 就像对 *Tasks* 和 *Decorators* 所做的那样，所有 *可重写* 的函数都有两种不同的版本：AI 和 *非-AI* (*通用*)。概念完全相同：如果只实现了一个（为了保持项目一致性，建议重写
    AI 版本），则调用该函数。如果两者都实现了，当 Pawn 被 AI 控制器控制时调用 AI，否则调用通用函数。
- en: 'Here there are the four *overridable* functions:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是四个*可重写*的函数：
- en: '![](img/18ec6bbb-d361-4378-b833-e77d6f20ab76.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18ec6bbb-d361-4378-b833-e77d6f20ab76.png)'
- en: '**Receive Activation**: This is called when the *Service* becomes active. Use
    it to initialize the *Service*.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收激活**：当*服务*变为活动状态时，会调用此函数。使用它来初始化服务。'
- en: '**Receive Tick**: This is called when the Service ticks. Mainly, a *Service*
    does something continuously (e.g. update a *Blackboard* variables), and so this
    is the most important function for the service. Performance-wise, it would be
    advisable to keep it as short as possible. Moreover, back to the *Behavior Tree*,
    it is possible to adjust how often a Service ticks (with a random value between
    min and max). However, the implementation, in theory, should not be aware of how
    often the Service ticks; it just needs to offer a "*service"*. Then, the user
    of the service, the *Behavior Tree*, will decide how often it wants this service.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收时钟**：当服务时钟滴答时，会调用此函数。主要地，一个*服务*会持续进行某些操作（例如更新*黑板*变量），因此这是服务最重要的函数。从性能的角度来看，建议将其保持尽可能短。此外，回到*行为树*，可以调整服务滴答的频率（使用介于最小值和最大值之间的随机值）。然而，从理论上讲，实现应该不知道服务滴答的频率；它只需要提供一个"*服务*"。然后，服务的使用者，即*行为树*，将决定它希望这个服务多频繁。'
- en: '**Receive Search Start**: This is a special case in which the service is active
    (so you should have initialized the service, but in theory, the service should
    not have performed anything yet). This function is called before a *Task/Node*
    is searched. In fact, a *Behavior Tree* needs to evaluate which *Task* or *Node*
    to pick next to execute. In doing so, the *Behavior Tree* checks the conditions
    of the decorators on top of the possible *Tasks* or *Nodes*. As a result, in this
    function, you can adjust values before the next *Task* or *Node* is searched,
    and therefore choose something that influences the choice into being the correct
    one.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收搜索开始**：这是一个特殊案例，其中服务是活动的（因此你应该已经初始化了服务，但在理论上，服务不应该已经执行任何操作）。在搜索*任务/节点*之前，会调用此函数。实际上，*行为树*需要评估下一个要执行的*任务*或*节点*。在这个过程中，*行为树*会检查可能*任务*或*节点*上装饰器的条件。因此，在这个函数中，你可以在下一个*任务*或*节点*被搜索之前调整值，并因此选择影响选择成为正确选择的东西。'
- en: '**Receive Deactivation**: This is called when the service becomes inactive.
    Use it to clean up the Service.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收停用**：当服务变为非活动状态时，会调用此函数。使用它来清理服务。'
- en: Mainly, you will need to implement your logic in the ***Receive Tick*** function,
    so that you can constantly update the information in the Blackboard. A *Service*
    is a layer between the Behavior Tree and the game world.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 主要，你需要在***Receive Tick***函数中实现你的逻辑，以便你能够不断更新黑板上的信息。*服务*是行为树和游戏世界之间的一个层。
- en: We will implement a *Blueprint Service* during the course of the next three
    chapters, in which we will face a much more practical and concrete example.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的三章中实现一个*蓝图服务*，我们将面对一个更加实际和具体的例子。
- en: Creating a Service in C++
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++中创建一个*服务*
- en: 'In a very similar fashion to how we extended *Tasks* and *Decorators* in C++,
    you can extend ***Services in C++*** as well. The base class to inherit from is ***BTService***,
    as shown in the following screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在C++中扩展*任务*和*装饰器*的方式非常相似，你还可以在C++中扩展***服务***。要继承的基类是***BTService***，如下面的截图所示：
- en: '![](img/b210ca98-7182-45b1-894c-d22f8aa78633.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b210ca98-7182-45b1-894c-d22f8aa78633.png)'
- en: 'The convention is to prefix the Service class name with "***BTService_***"
    (*Behavior Tree Service*).  A possible name for our class could be *BTService_MyFirstService*:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 习惯上，在*服务*类名前加上"***BTService_***"（*行为树服务*）。我们类的可能名称可以是*BTService_MyFirstService*：
- en: '![](img/063bee02-8793-4140-95eb-0c5d152e5cef.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/063bee02-8793-4140-95eb-0c5d152e5cef.png)'
- en: 'Once we have created the ***Service in C++***, the rest is done in a really
    similar fashion to e*xtending/creating* a *Decorator* in C++. Here there are the
    functions to override (taken from the Engine Source Code):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了***C++中的服务***，其余的工作就与在C++中*扩展/创建*一个*装饰器*非常相似。这里有一些需要重写的函数（来自引擎源代码）：
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here there is a comment at the beginning (always taken from the Engine Source
    Code) that explains some implementation choices:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个开头注释（总是来自引擎源代码），它解释了一些实现选择：
- en: '[PRE5]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Unfortunately, we cannot go into detail about each function, but they are all
    quite easy to understand. In any case, we will explore further ***Services* **in
    the following three chapters, when we build a *Behavior Tree* from scratch, as
    well as when we implement a ***C++ Service***.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们无法详细说明每个函数，但它们都相当容易理解。无论如何，我们将在接下来的三章中进一步探讨 *服务*，当我们从头开始构建 *行为树* 以及实现
    *C++服务* 时。
- en: Creating a Composite Node
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个组合节点
- en: In most of these cases, you ***will not need to extend a Composite Node***.
    By "*most of these cases"*, I mean that you can create very complex *AI Behavior
    Trees* that can perform very complicated tasks, and that you really shouldn't
    extend or create a Composite Node unless you really need to.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数这些情况下，你**不需要扩展一个组合节点**。通过“大多数这些情况”，我的意思是你可以创建非常复杂的 *AI行为树*，它可以执行非常复杂的任务，而且你真的不需要扩展或创建一个组合节点，除非你真的需要。
- en: 'In fact, a Composite Node influences the flow of the *Behavior Tree*, including
    which node to execute, which *Decorators* to check, and which *Service* to activate.
    By default, there are only three: *Selector*, *Sequence*, and *Simple Parallel*.
    These will be more than enough for covering most of our cases.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，组合节点会影响 *行为树* 的流程，包括要执行哪个节点、要检查哪些 *装饰器* 以及要激活哪个 *服务*。默认情况下，只有三个：*选择器*、*序列*
    和 *简单并行*。这些将足以覆盖我们的大部分情况。
- en: However, if you really have specific needs, then Unreal Engine is so flexible
    that it allows you to extend a *Composite Node* as well.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你真的有特定的需求，那么虚幻引擎非常灵活，它允许你扩展一个 *组合节点*。
- en: First of all, this is impossible to do in Blueprint, so the only way you can
    extend a (or create a new) *Composite Node* is through C++.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这在蓝图（Blueprint）中是不可能的，所以唯一能够扩展一个（或创建一个新的）*组合节点*的方法是通过C++。
- en: Let's look at an example of why you would like to create a new *Composite Node*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个具体的例子，说明为什么你可能想要创建一个新的 *组合节点*。
- en: '**Why**: Because you can implement a flow in the Behavior Tree that might be
    hard to achieve (or impossible) with the current composite nodes.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**原因**：因为你可以实现一个在行为树中可能难以实现（或不可能实现）的流程。'
- en: '**An Example**: You could potentially simulate a Behavior Tree with Simple
    Parallel nodes, with another one that does not use them. But this would be really
    complicated and not very clean. Thus, using Simple Parallel nodes simplifies a
    lot the workflow (originally, in the first versions of the engine, there were
    no Simple Parallel nodes).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**：你可以用简单的并行节点模拟一个行为树，也可以不用它们。但这会非常复杂，而且不够整洁。因此，使用简单的并行节点可以大大简化工作流程（最初，在引擎的第一版中，没有简单的并行节点）。'
- en: '**A Concrete Example**: You want to pick which tasks should execute at random,
    below this custom Composite node, based on some weights. For instance, the weights
    can be evaluated by a special type of *Decorators*. Thus, extending a *Composite* might
    require additional work on other type of nodes.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**具体示例**：你想要根据某些权重随机选择在这个自定义组合节点下应该执行的任务。例如，权重可以通过一种特殊的 *装饰器* 来评估。因此，扩展 *组合*
    可能需要在其他类型的节点上做额外的工作。'
- en: '**Another Concrete example**: You can create a composite node that keeps picking
    a random child so that it succeeds until either a threshold is reached, or one
    of the children reports a fail.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**另一个具体示例**：你可以创建一个组合节点，它不断随机选择一个子节点，直到达到阈值或其中一个子节点报告失败。'
- en: Despite this being a very interesting topic, unfortunately, it is outside the
    scope of this book. Therefore, we will limit our selves to creating new *Tasks*,
    *Decorators*, and *Services*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个非常有趣的话题，但不幸的是，它超出了本书的范围。因此，我们将限制自己只创建新的 *任务*、*装饰器* 和 *服务*。
- en: Creating new type of nodes or new types of Trees
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的节点类型或新的树类型
- en: In theory, you can create new types of nodes (for *Behavior Trees*, it's not
    really needed, because you would create a different kind of structure). Actually,
    you can create different tree structures that are not *Behavior Trees* anymore
    (e.g. a *Dialogue Tree*), which are far more useful than creating another node
    for a Behavior Tree. *Dialogue Trees* are really interesting, because they use
    a very similar structure to a *Behavior Tree*, and you can use the same *Editor*
    (or better, a slightly modified version of it) to edit the tree.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，你可以创建新的节点类型（对于 *行为树* 而言，这实际上并不需要，因为你将创建不同类型的结构）。实际上，你可以创建不再是 *行为树* 的不同树结构（例如，一个
    *对话树*），这比为行为树创建另一个节点更有用。*对话树* 非常有趣，因为它们使用与 *行为树* 非常相似的结构，你可以使用相同的 *编辑器*（或者更好的是，它的一个稍微修改过的版本）来编辑树。
- en: As much as I would like to dive into these topics, the main focus of this book
    is on AI, and so talking about *Dialogue Trees* is outside the scope of this book.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我很想深入探讨这些主题，但本书的主要焦点是人工智能，因此讨论 *对话树* 超出了本书的范围。
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have explored how it is possible to *extend/create* ***Tasks***,
    ***Decorators***, and ***Services*** both in *Blueprint and in C++*. As a result,
    this gives us the ability to create complex behaviors for our AI agents, especially
    if combined with what we learned in the previous chapters, such as *navigation*,
    *EQS*, and *perception*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何在 *Blueprint* 和 *C++* 中 *扩展/创建* **任务**、**装饰器** 和 **服务** 的可能性。因此，这使我们能够为我们的
    AI 代理创建复杂的行为，尤其是如果与我们在前几章中学到的内容相结合，如 *导航*、*EQS* 和 *感知*。
- en: In the next chapter, we will deal with *Crowds*, before jumping into creating
    a concrete example in [Chapter 8](6995bf12-0f10-47a9-a48c-cec31696df87.xhtml),
    *Designing Behavior Trees – Part I*, [Chapter 9](063dda79-cb3c-49e7-bfa5-11f8680ee358.xhtml),
    *Designing Behavior Trees – Part II*, and [Chapter 10](039565e6-4f8d-4c73-936f-f5974e9c8226.xhtml),
    *Designing Behavior Trees – Part III*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将处理 *人群*，然后再跳转到在 [第 8 章](6995bf12-0f10-47a9-a48c-cec31696df87.xhtml)
    *设计行为树 – 第 I 部分*、[第 9 章](063dda79-cb3c-49e7-bfa5-11f8680ee358.xhtml) *设计行为树 –
    第 II 部分* 和 [第 10 章](039565e6-4f8d-4c73-936f-f5974e9c8226.xhtml) *设计行为树 – 第 III
    部分* 中创建具体示例。
