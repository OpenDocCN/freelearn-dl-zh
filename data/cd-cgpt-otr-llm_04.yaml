- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Demystifying Generated Code for Readability
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解密生成代码的可读性
- en: This chapter delves into making LLM-generated code less ambiguous, and more
    accessible and comprehensible. We’ll explore techniques to enhance the explainability
    of code from LLMs, ensuring the logic and decision-making behind LLM-generated
    code are clear. By aiding a better understanding of code from LLMs, the chapter
    aims to promote transparency and trust in software development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了如何使LLM生成的代码更加清晰，易于访问和理解。我们将探索增强LLM生成的代码可解释性的技巧，确保LLM生成代码背后的逻辑和决策过程清晰可见。通过帮助更好地理解LLM生成的代码，本章旨在促进软件开发中的透明度和信任。
- en: This chapter has bad and good code and prompt examples.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有不良和良好的代码及提示示例。
- en: This chapter will help you gain insights into strategies for improving the readability
    of code from LLMs, nurturing a collaborative and informed approach to leveraging
    these powerful language models in coding practices.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助你了解提高LLM生成代码可读性的策略，培养一种协作和知情的方式来利用这些强大的语言模型进行编码实践。
- en: From this chapter, you should learn how to use LLMs/chatbots to generate more
    readable code and summarize lengthy code blocks for understanding by humans using
    LLMs to create documentation and comments to aid readability.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教你如何使用LLM/chatbots生成更易读的代码，并使用LLM生成文档和注释来帮助理解代码，简化复杂的代码块，便于人类理解。
- en: 'This chapter covers the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Generating more readable code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成更易读的代码
- en: Summarizing code for understanding
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总结代码以便理解
- en: Generating documentation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成文档
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you’ll need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章你将需要以下内容：
- en: Access to an LLM/chatbot such as GPT-4, Gemini, or Claude 3 – each requires
    a login. For GPT-4, you’ll need an OpenAI account, and for Gemini, you’ll need
    a Google account.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问LLM/chatbot，如GPT-4、Gemini或Claude 3——每个都需要登录。对于GPT-4，你需要一个OpenAI账户，对于Gemini，你需要一个Google账户。
- en: A Python IDE such as Spyder, IDLE, PyCharm, Eclipse, or Visual Studio. An online
    interpreter will not be good enough here.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Python IDE，如Spyder、IDLE、PyCharm、Eclipse或Visual Studio。在线解释器在这里不够用。
- en: 'An HTML interpreter, such as [https://htmledit.squarefree.com/](https://htmledit.squarefree.com/)
    , [https://onecompiler.com/html](https://onecompiler.com/html) , or [https://www.w3schools.com/tryit/](https://www.w3schools.com/tryit/)
    , or a website editor: Wix, GoDaddy, One.com, and so on.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个HTML解释器，如[https://htmledit.squarefree.com/](https://htmledit.squarefree.com/)
    、[https://onecompiler.com/html](https://onecompiler.com/html) 或[https://www.w3schools.com/tryit/](https://www.w3schools.com/tryit/)
    ，或者网站编辑器：Wix、GoDaddy、One.com等。
- en: 'Get the code in this book here: [https://github.com/PacktPublishing/Coding-with-ChatGPT-and-other-LLMs/tree/main/Chapter4](https://github.com/PacktPublishing/Coding-with-ChatGPT-and-other-LLMs/tree/main/Chapter4)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取本书中的代码： [https://github.com/PacktPublishing/Coding-with-ChatGPT-and-other-LLMs/tree/main/Chapter4](https://github.com/PacktPublishing/Coding-with-ChatGPT-and-other-LLMs/tree/main/Chapter4)
- en: Now, let’s find out how to use Claude, Gemini, and ChatGPT to start off well
    and write code that is very readable.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看如何使用Claude、Gemini和ChatGPT来从一开始就写出非常易读的代码。
- en: Generating more readable code
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成更易读的代码
- en: In this section, you will learn how to generate code that others can easily
    read and get moving without them having to ponder its inner workings for hours.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何生成别人可以轻松阅读并立即开始使用的代码，而不需要花费几个小时去思考它的内部原理。
- en: If we are writing code, we want it to be used and that means it should be understood
    by other people, especially if we want someone to expand upon it. They’re much
    more likely to bother if we make our code easy to read.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们写代码，我们希望它被他人使用，这意味着代码应该容易被别人理解，特别是当我们希望别人对其进行扩展时。如果我们使代码易于阅读，他们更有可能愿意去理解和修改。
- en: In the subsection *Code to compress data, written in Python 3.10* , we’ll ask
    an LLM for some code to compress data, but first, here’s an intro to what data
    compression is, so we know a bit more about what we’re doing. Data compression
    is important for using devices and the internet.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在子章节*用Python 3.10编写的数据压缩代码*中，我们将请求LLM生成一些数据压缩的代码，但首先，这里是关于数据压缩的简介，帮助我们更好地了解正在做的事情。数据压缩对于使用设备和互联网非常重要。
- en: Introduction to data compression methods
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据压缩方法介绍
- en: Here’s some background on what data compression is so that the following section
    is easier to understand.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关于数据压缩的一些背景信息，帮助你更容易理解接下来的内容。
- en: Lossless data compression
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无损数据压缩
- en: Lossless data compression means the signal and the noise are compressed, nothing
    is lost, and everything can be re-created [ *Wiki_LZMA2* ].
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 无损数据压缩意味着信号和噪声都被压缩，没有任何损失，所有内容都可以重新创建 [*Wiki_LZMA2*]。
- en: 'An example of lossless compression would be a dataset like this: [1,1,1,1,1,1,1….1,1,1,1,1,1,0,0,0,0,0,0…].'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 无损压缩的一个例子是这样的数据集：[1,1,1,1,1,1,1….1,1,1,1,1,1,0,0,0,0,0,0…]。
- en: This dataset could have any number of ones and any number of zeros, but a value
    can be represented by just the count of each and the name of each. If there were
    213 ones and 789 zeros, the lossless compression method **Run-Length Encoding**
    ( **RLE** ) would call it [(213, 1), (789,0)]. The data is now just 4 numbers,
    not 213+789 = 1,002 numbers, which is a compression ratio of 1002/4 = 250.5 [
    *WikiDataComp* ]. This has managed a good compression ratio without losing anything.
    This could be real data, for example, the answer to the question, “Is the windscreen
    wiper on?”.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据集可能包含任意数量的1和0，但可以通过每个值的计数和名称来表示。如果有213个1和789个0，那么无损压缩方法**游程编码**（**RLE**）会将其表示为[(213,
    1), (789,0)]。现在，数据只包含4个数字，而不是213+789 = 1,002个数字，这样的压缩比为1002/4 = 250.5 [*WikiDataComp*]。这种方法在不丢失任何信息的情况下，成功地实现了良好的压缩比。这可以是实际数据，例如，“雨刷是否开启？”的问题答案。
- en: Use lossless compression when you have a signal that tends to be constant for
    a long while. If you use it for very precise or always varying data, it’ll, instead,
    take up more space on your drive!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个长时间保持不变的信号时，使用无损压缩。如果你用它处理非常精确或始终变化的数据，它反而会占用更多的磁盘空间！
- en: LZMA is another type of lossless compression method, which we shall use in a
    moment.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: LZMA 是另一种无损压缩方法，我们稍后将使用它。
- en: Lossy compression
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有损压缩
- en: 'A second type of compression is called lossy compression, where the algorithm
    or method tries to keep the signal and eliminate some level of noise. For lossy
    compression, there can be different levels of compression, offering a trade-off
    of fidelity and file size: more compression means less fidelity – more of the
    signal and noise are thrown out or zeroed.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种压缩方法叫做有损压缩，其中算法或方法尝试保持信号并去除一定程度的噪声。对于有损压缩，有不同的压缩级别，可以在保真度和文件大小之间进行权衡：更多的压缩意味着较低的保真度——更多的信号和噪声被丢弃或抑制。
- en: Examples of lossy compression include **Discrete Fourier Transforms** ( **DFTs**
    ), **Discrete Wavelet Transforms** ( **DWTs** ), or, best yet, **Discrete Cosine
    Transforms** ( **DCTs** ) [ *Wiki_Wavelets* ].
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有损压缩的例子包括**离散傅里叶变换**（**DFTs**）、**离散小波变换**（**DWTs**）或最常见的**离散余弦变换**（**DCTs**）
    [*Wiki_Wavelets*]。
- en: DCTs are used in a lot of standard compression methods for images ( **JPEG**
    ), video ( **MPEG** ), audio (Dolby Digital, MP3, AAC), digital television (HDTV,
    SDTV), and digital radio (AAC+, DAB) [Wiki_Cosine].
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: DCTs 被广泛应用于许多标准的图像压缩方法（**JPEG**）、视频压缩（**MPEG**）、音频压缩（杜比数字、MP3、AAC）、数字电视（高清电视、标准清晰电视）以及数字广播（AAC+、DAB）
    [Wiki_Cosine]。
- en: 'DCTs transform data from changing over time to being made up of lots of cosine
    waves of differing frequencies. It sounds ridiculously simple, but you can represent
    most things this way. I did simplify it. You generally keep the low-frequency
    waves and zero out the high-frequency waves, which are assumed to be noise. Then
    the signal is changed back to the original time-based form: varying over time.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: DCTs 将数据从随时间变化的形式转换为由不同频率的余弦波组成的形式。这听起来非常简单，但你可以用这种方式表示大多数事物。我简化了一下。你通常保留低频波形，抑制高频波形，假定它们是噪声。然后信号会变回原来的基于时间的形式：随时间变化。
- en: If you want more fidelity – a better signal – you’ll zero out fewer of the high-frequency
    waves but will have to suffer a file size that’s not reduced much. If you really
    need a small file size, you’ll zero out more waves but that’ll leave you with
    a worse signal, image, or sound. Another way to look at the compression ratio
    is the bit rate, measured in bits/second. A higher bit rate can give a higher
    quality stream of data (e.g., video or sound) and, if it’s stored in a file, this
    means larger file sizes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更高的保真度——更好的信号——你将减少对高频波的抑制，但文件大小几乎不会减少。如果你确实需要较小的文件大小，你将需要抑制更多的波形，但这会导致信号、图像或声音变差。另一种看压缩比的方法是比特率，单位是比特/秒。更高的比特率可以提供更高质量的数据流（例如视频或声音），如果它被存储在文件中，意味着更大的文件大小。
- en: Alternatively, instead of zeroing the values, you can quantize them. Here, rather
    than having highly precise values, you could turn them into less precise values
    – for example, 3.48724 could fit into the [3.4 to 3.5] bin or, even less precise,
    the [3 to 4] bin. The values become a histogram – discrete and not so continuous.
    This saves space.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以选择量化它们，而不是将值置零。在这里，值不再是精确的，而是变得不那么精确——例如，3.48724可以适合到[3.4到3.5]这个范围，甚至更不精确的[3到4]这个范围。值变成了一个直方图——离散的而不是连续的。这可以节省空间。
- en: To get the ideal compressed data, there needs to be a balance between good compression
    and a good quality of signal, image, or video.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得理想的压缩数据，需要在良好的压缩和良好的信号、图像或视频质量之间找到平衡。
- en: Learned compression or neural compression
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习压缩或神经压缩
- en: A third type of compression is learned compression, where an ML method tries
    to learn what the signal is and keep that, at the expense of the noise.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种压缩方式是学习压缩，在这种方法中，ML方法试图学习信号是什么，并保留它，同时牺牲噪声。
- en: The first two kinds of compression, lossless and lossy, are rule based, but
    in learned compression, neural networks are used to learn the patterns in the
    data and extract specific statistical properties. These learned methods are more
    adaptive [Gemini]. When I compressed tables or files of data with lossless and
    lossy methods, I had to try different methods and select the best method for each
    type of data [ *Taylor_2022* ]. This is an excellent method but is less adaptive
    than learned compression.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种压缩方式，无损压缩和有损压缩，都是基于规则的，但在学习压缩中，神经网络被用来学习数据中的模式并提取特定的统计属性。这些学习方法更具适应性 [Gemini]。当我用无损和有损方法压缩表格或数据文件时，我必须尝试不同的方法并为每种数据类型选择最佳的方法
    [*Taylor_2022*]。这是一种很好的方法，但比学习压缩的适应性差。
- en: Learned compression models are more adaptable and the model can continuously
    learn, thus improving with new data [ *Gemini* ].
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 学习压缩模型更具适应性，模型可以不断学习，因此随着新数据的加入而改进 [*Gemini*]。
- en: A method of learned compression is the **autoencoder** ( **AE** ). It is a palindromic
    or mirror-shaped neural network that takes in data, compresses it in a tiny space
    – a **latent space** , then reproduces the input data. The output layer looks
    like and is the same size as the input layer. These are the biggest layers, with
    layers reducing in size toward the middle, similar to two triangles, or perhaps
    a bowtie. This is useful because the latent space is a really compressed version
    of the data – there’s no space for excess! The first side or triangle is the encoder
    and the second side is the decoder. The encoder first compresses the data, then
    the decoder reconstructs the input data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一种学习压缩方法是**自编码器**（**AE**）。它是一个回文或镜像形状的神经网络，接受数据，将其压缩到一个小空间——**潜在空间**，然后再重建输入数据。输出层看起来与输入层相同，且大小相同。这些是最大的层，其他层在中间逐渐变小，类似两个三角形，或者像一个蝴蝶结。这很有用，因为潜在空间是数据的压缩版本——没有多余的空间！第一边或三角形是编码器，第二边是解码器。编码器首先压缩数据，然后解码器重建输入数据。
- en: In learned compression, the balance between good compression and good quality
    is the loss function [ *Ioijilai* ].
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习压缩中，良好的压缩与良好的质量之间的平衡是损失函数 [*Ioijilai*]。
- en: Advantages of learned compression
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 学习压缩的优势
- en: '**Adaptability** : Unlike more traditional compression methods, learned compression
    models can adapt to complex and diverse data types, such as scientific data, because
    of relationships between variables.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适应性**：与更传统的压缩方法不同，学习压缩模型可以适应复杂和多样的数据类型，比如科学数据，因为变量之间存在关系。'
- en: '**Efficiency** : Learned compression models can sometimes compress better than
    older methods:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：学习压缩模型有时能比旧方法压缩得更好：'
- en: Learned models can learn the statistical properties of language and underlying
    structures in audio data, so can compress data more efficiently.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习型模型可以学习语言的统计特性和音频数据中的潜在结构，因此可以更高效地压缩数据。
- en: '**Convolutional Neural Networks** ( **CNNs** ) are especially adept at detecting
    patterns and redundancies in images and videos, so can compress more effectively
    than JPEG and MPEG. The effect is more pronounced in higher-resolution data.'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卷积神经网络**（**CNNs**）特别擅长检测图像和视频中的模式和冗余，因此比JPEG和MPEG压缩更有效。在更高分辨率的数据中，这种效果更加明显。'
- en: Overall, the higher possible complexity of ML models can enable the learning
    of more intricate structures, leading to better compression.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总体来说，ML模型可能更高的复杂度能够学习更复杂的结构，从而实现更好的压缩。
- en: '**Generating data** : Decoders can create more data examples like the input
    data.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成数据**：解码器可以创建更多的数据示例，就像输入数据一样。'
- en: Disadvantages of learned compression
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 学习压缩的缺点
- en: '**Complexity** : It can be more effective, but it is also more difficult to
    understand.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性**：它可能更有效，但也更难理解。'
- en: '**Computational costs** : These ML models can be very expensive to train and
    run. This is a bigger disadvantage for applications that require real-time processing,
    such as autonomous vehicles. You might well have to deploy a simplified and optimized
    trained model to the edge or use specially designed hardware.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算成本**：这些 ML 模型可能非常昂贵，需要大量的训练和运行成本。这对于需要实时处理的应用程序（如自动驾驶车辆）是一个更大的劣势。您可能需要将简化和优化的训练模型部署到边缘或使用专门设计的硬件。'
- en: '**Lossy** : Learned compression can be lossy. This means the trade-off between
    quality and compression needs to be struck.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有损**：学习压缩可以是有损的。这意味着需要在质量和压缩之间达成平衡。'
- en: 'My background includes creating data compression software. Working with others
    at the University of Warwick, I created data compression software methodologies
    for Jaguar Land Rover and Onsemi, an American semiconductor manufacturer. If you
    want to know more, I’ve got a paper or two on compression, as well as other ML
    research here: [https://scholar.google.com/citations?user=9lCeU94AAAAJ&hl](https://scholar.google.com/citations?user=9lCeU94AAAAJ&hl)
    .'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我的背景包括创建数据压缩软件。与华威大学的其他人一起工作，我为捷豹路虎和安森美半导体制造商创建了数据压缩软件方法论。如果您想了解更多信息，我在压缩方面有一两篇论文，以及其他
    ML 研究，请访问此处：[https://scholar.google.com/citations?user=9lCeU94AAAAJ&hl](https://scholar.google.com/citations?user=9lCeU94AAAAJ&hl)。
- en: After compression, you can store or transmit data. But to get the data back,
    you’ll need to decompress it, usually.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩后，您可以存储或传输数据。但是要取回数据，通常需要解压缩。
- en: Now, let’s get some code to do compression ourselves.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们获取一些自行进行压缩的代码。
- en: Code to compress data, written in Python 3.10
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用Python 3.10编写的数据压缩代码
- en: 'There are at least three types of data compression: lossless compression, lossy
    compression, and learned compression.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有三种类型的数据压缩：无损压缩、有损压缩和学习压缩。
- en: Let’s try the following code (see “Claude 3 provides the following output”);
    this is to compress data and make it smaller on file with a commonly used compression
    algorithm called the **Lempel-Ziv-Markov chain algorithm** or **LZMA2** . For
    this code, we will use lossless data compression, courtesy of LZMA.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试以下代码（参见“克劳德 3 提供以下输出”）；这是使用一种常用的压缩算法**Lempel-Ziv-Markov 链算法**或**LZMA2**来压缩数据并使其在文件中变小。对于这段代码，我们将使用无损数据压缩，感谢LZMA。
- en: LZMA2 is more powerful than LZMA; it’s a container format for uncompressed and
    LZMA data, as well as the compression of data that’s partially incompressible
    [ *Wiki_LZMA2, Taylor_2022* ].
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: LZMA2比LZMA更强大；它是一个用于未压缩和LZMA数据的容器格式，以及部分无法压缩的数据的压缩[ *Wiki_LZMA2，Taylor_2022*
    ]。
- en: Anyway, the code here should compress data with LZMA2.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，在这里的代码应该使用 LZMA2 压缩数据。
- en: The code is courtesy of the Claude 3 LLM.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 代码由克劳德 3 LLM 提供。
- en: Asking Claude 3 to write some bad code
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请求克劳德 3 写一些糟糕的代码
- en: Let’s start with how to get code that works but is hard to read. This is to
    compare it with code that you might have already but could be more explainable.
    LLMs will hopefully never give you this kind of code unless you explicitly ask
    for poorly written code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从如何获得功能正常但难以阅读的代码开始。这是为了将其与您可能已经拥有但可能更易于解释的代码进行比较。希望 LLMs 永远不会给您这种类型的代码，除非您明确要求编写质量较差的代码。
- en: 'We will use the following prompt:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下提示：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Claude 3 provides the following output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 克劳德 3 提供以下输出：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can find this code in the **LZMAcompress_bad.py** file in our GitHub repo
    found here:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在我们的 GitHub 仓库中的**LZMAcompress_bad.py**文件中找到此代码，位置在这里：
- en: '[https://github.com/PacktPublishing/Coding-with-ChatGPT-and-Other-LLMs/tree/main/Chapter4//LZMAcompress_bad.py](https://github.com/PacktPublishing/Coding-with-ChatGPT-and-Other-LLMs/tree/main/Chapter4//LZMAcompress_bad.py)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Coding-with-ChatGPT-and-Other-LLMs/tree/main/Chapter4//LZMAcompress_bad.py](https://github.com/PacktPublishing/Coding-with-ChatGPT-and-Other-LLMs/tree/main/Chapter4//LZMAcompress_bad.py)'
- en: This code took a few rounds of debugging, but what you have here works for the
    little toy dataset given. Claude 3 was very helpful. It made one mistake not correcting
    a bug, but the whole process was very easy. You just need to mention the code
    again if the chatbot has already seen it or paste it into the chat field if it’s
    not been seen, then state the problem, giving the line the error message says
    the error is about. Then, the chatbot should give a better version of the code.
    Do this until the code works nicely for you, then test it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码经过了几轮调试，但你现在看到的适用于给定的小型玩具数据集。Claude 3非常有帮助。它犯了一个错误，没能修复一个bug，但整个过程非常简单。你只需重新提到代码（如果聊天机器人已经看过它）或把它粘贴到聊天框里（如果它没有见过），然后陈述问题，并给出错误消息所指示的那一行代码。接着，聊天机器人应该给出更好的版本。继续这样做，直到代码对你有效，然后进行测试。
- en: There’s not much commenting. The variable and function names are really unclear.
    It sometimes does a great deal in one line, and in a **for** statement line at
    that! Conditional statements shouldn’t have calculations or string operations
    in them! It prints **G** at the end, whatever that is. Variables are sometimes
    single lowercase letters and sometimes single uppercase letters – no convention.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码几乎没有注释。变量和函数的命名非常不清晰。有时一行代码做了很多事情，尤其是在一个**for**语句的行中！条件语句中不应该包含计算或字符串操作！它在最后打印**G**，不管那是什么。变量有时是单个小写字母，有时是单个大写字母——没有任何规范。
- en: I don’t really like that the ages are strings – couldn’t they be **ints** or
    at least **floats** ?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我不太喜欢年龄是字符串的形式——它们能不能是**int**类型，或者至少是**float**类型？
- en: It’s using **try/except** , which is good, and it’s using different functions,
    which are not large, so the code is not necessarily poor from an operation point
    of view.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用了**try/except**，这是好的，并且使用了不同的函数，这些函数都不大，因此从操作角度来看，代码不一定很差。
- en: I’m not sure if **l()** will always return something.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我不确定**l()**是否总会返回某些东西。
- en: This code is really unclear. I would have to look at it for a while to figure
    out what’s going on.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码真的很不清晰。我得花一段时间才能搞明白发生了什么。
- en: It uses **for** statements, which are unpopular because they’re slow in languages
    like Python compared with vectorized ways.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用了**for**语句，这在像Python这样的语言中不太受欢迎，因为与向量化的方式相比，它们较慢。
- en: Well, that’s what I caught from a quick look.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这就是我快速浏览所发现的内容。
- en: Here is what Claude 3 says about its own example of bad code
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这是Claude 3对其自己的坏代码示例的评价：
- en: 'The intentionally obfuscated and poorly written code that compresses tabular
    data using the LZMA2 algorithm in Python 3.10 exhibits several characteristics
    that make it hard to read and understand. Here are some of the main issues with
    the code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这段故意混淆且写得很差的代码使用LZMA2算法在Python 3.10中压缩表格数据，展示了几个使其难以阅读和理解的特点。以下是代码的一些主要问题：
- en: '**Poor variable naming** : The code uses single-letter variable names such
    as **a, b, c, d, e, f, m, n, o, p, q, r, s, t, u, v, w, x, y,** and **z** , which
    provide no meaningful information about the purpose or content of the variables.
    This makes it extremely difficult to understand what each variable represents
    or what it’s being used for.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**差的变量命名**：代码使用了像**a, b, c, d, e, f, m, n, o, p, q, r, s, t, u, v, w, x, y,**
    和 **z** 这样的单字母变量名，这些变量名并没有提供有关变量用途或内容的任何有意义的信息。这使得理解每个变量代表什么，或者它是用来做什么的变得非常困难。'
- en: '**Lack of comments** : The code is completely devoid of comments or docstrings,
    which would normally provide explanations of the code’s purpose, functionality,
    and logic. Without any comments, it becomes a guessing game to understand what
    the code is trying to accomplish.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺乏注释**：代码完全没有注释或文档字符串，通常这些可以提供代码的目的、功能和逻辑的解释。没有注释的代码，理解它试图实现什么成了一个猜谜游戏。'
- en: '**Convoluted logic** : The logic for compressing and decompressing the tabular
    data is spread across multiple functions ( **j, l,** and **k** ) and is unnecessarily
    complex. The code uses nested list comprehensions, unnecessary type conversions,
    and obscure operations that make it challenging to follow the flow of execution.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂的逻辑**：压缩和解压表格数据的逻辑分散在多个函数中（**j, l,** 和 **k**），且不必要地复杂。代码使用了嵌套的列表推导、不必要的类型转换以及晦涩的操作，导致很难跟踪执行的流程。'
- en: '**Violation of coding conventions** : The code violates several Python coding
    conventions and best practices, such as using meaningful variable names, proper
    indentation and formatting, and separation of concerns. This makes it harder for
    developers familiar with Python conventions to understand the code.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**违反编码规范**：该代码违反了多个Python编码规范和最佳实践，例如使用有意义的变量名、正确的缩进和格式化、以及关注点的分离。这使得熟悉Python规范的开发者更难理解该代码。'
- en: '**Lack of error handling** : The code does not include any error handling mechanisms
    or exception handling, which can lead to unexpected behavior and crashes in the
    case of errors or edge cases.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺乏错误处理**：该代码没有包含任何错误处理机制或异常处理，这可能导致在发生错误或遇到边缘情况时出现意外行为或崩溃。'
- en: '**Mixing of functionality** : The code mixes functionality related to compression,
    decompression, and data manipulation, making it harder to follow and maintain.
    Ideally, these concerns should be separated into distinct functions or modules.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能混合**：该代码混合了与压缩、解压缩和数据操作相关的功能，使得它更难以理解和维护。理想情况下，这些功能应分离成不同的函数或模块。'
- en: '**Obscure type annotations** : While the code uses type annotations, the annotations
    themselves are obscure and unhelpful due to the poor variable naming conventions
    – for example, the type annotation **Any** is used for all variables, which defeats
    the purpose of type annotations.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**晦涩的类型注解**：虽然代码使用了类型注解，但由于变量命名不规范，注解本身显得晦涩且无用——例如，类型注解**Any**被用于所有变量，这削弱了类型注解的意义。'
- en: '**Unnecessary complexity** : The code introduces unnecessary complexity by
    using obscure techniques and terse expressions, sacrificing readability for brevity.
    This makes it harder for developers to understand and maintain the code, especially
    if they are unfamiliar with such techniques.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不必要的复杂性**：该代码通过使用晦涩的技术和简洁的表达式引入了不必要的复杂性，牺牲了可读性以追求简洁。这使得开发者，尤其是那些不熟悉此类技术的开发者，更难理解和维护代码。'
- en: '**Lack of modularity** : The code is not designed in a modular way, making
    it difficult to integrate or reuse in larger applications or libraries.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺乏模块化**：该代码没有以模块化的方式设计，使得它难以在更大的应用程序或库中集成或重用。'
- en: '**Limited extensibility** : Due to the obfuscated nature of the code and the
    lack of proper documentation or comments, it becomes challenging to extend or
    modify the code without risking unintended consequences or introducing new bugs.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展性有限**：由于代码的晦涩性质以及缺乏适当的文档或注释，扩展或修改代码变得困难，且容易引发意外后果或引入新错误。'
- en: Overall, the code exhibits numerous examples of poor coding practices and intentional
    obfuscation, making it extremely difficult to read, understand, and maintain.
    While this exercise is valuable for understanding the challenges of working with
    poorly written code, it serves as a reminder of the importance of writing clear,
    readable, and well-documented code in real-world software development scenarios.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，该代码展示了许多不良编码实践和故意的晦涩处理，导致它非常难以阅读、理解和维护。虽然这一练习对理解处理糟糕编写代码的挑战非常有价值，但它也提醒我们在实际软件开发中，编写清晰、易读和文档完善的代码的重要性。
- en: That was the end of the Claude 3 output.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以上是Claude 3输出的结尾。
- en: Next, we must get some code that both works well and is easy to read, following
    good practices. Again, I went with the best coder LLM at the time, Claude 3.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须找到一些既能正常运行又易于阅读的代码，并遵循良好的实践。再次，我选择了当时最好的编码LLM——Claude 3。
- en: Let’s look at some well-written code
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们来看一些写得很好的代码
- en: 'We will now ask Claude 3 for some good code like the preceding: data compression
    with Python:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将请Claude 3提供一些好的代码，类似于之前的例子：使用Python进行数据压缩：
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Claude 3 gives us the following output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Claude 3给出了以下输出：
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This code executes successfully. You can find this code in the **LZMAcompress_good.py**
    file in the GitHub repo here: [https://github.com/PacktPublishing/Coding-with-ChatGPT-and-other-LLMs/tree/main/Chapter4//LZMAcompress_good.py](https://github.com/PacktPublishing/Coding-with-ChatGPT-and-other-LLMs/tree/main/Chapter4//LZMAcompress_good.py)
    .'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码可以成功执行。你可以在GitHub仓库的**LZMAcompress_good.py**文件中找到这段代码，链接如下：[https://github.com/PacktPublishing/Coding-with-ChatGPT-and-other-LLMs/tree/main/Chapter4//LZMAcompress_good.py](https://github.com/PacktPublishing/Coding-with-ChatGPT-and-other-LLMs/tree/main/Chapter4//LZMAcompress_good.py)。
- en: What Claude 3 says about its own good code
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Claude 3对其自己写的好代码的评价
- en: 'This code is easy to read and understand for the following reasons:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码易于阅读和理解，原因如下：
- en: '**Clear function names** : The function names **compress_tabular_data** and
    **decompress_tabular_data** clearly describe the purpose of each function'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清晰的函数名称**：函数名**compress_tabular_data**和**decompress_tabular_data**清楚地描述了每个函数的目的。'
- en: '**Type hints** : The code uses type hints to specify the expected types of
    function arguments and return values, making it easier to understand the input
    and output formats'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型提示**：代码使用类型提示来指定函数参数和返回值的预期类型，使得理解输入和输出格式更加容易。'
- en: '**Docstrings** : Each function has a docstring that provides a brief description
    of the function’s purpose, its arguments, and its return value'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档字符串**：每个函数都有一个文档字符串，简要描述了函数的目的、参数和返回值。'
- en: '**Meaningful variable names** : The variable names used in the code are descriptive
    and self-explanatory, making it easier to understand what each variable represents'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有意义的变量名**：代码中使用的变量名具有描述性，能够自解释，使得理解每个变量的含义变得更容易。'
- en: '**Separation of concerns** : The code separates the compression and decompression
    logic into two distinct functions, making it easier to maintain and extend'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**：代码将压缩和解压缩逻辑分成了两个独立的函数，使得维护和扩展变得更加容易。'
- en: '**Proper indentation and formatting** : The code is properly indented and formatted,
    making it readable and visually appealing'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正确的缩进和格式化**：代码的缩进和格式化正确，使得代码可读且视觉上令人愉悦。'
- en: '**Error handling** : While not explicitly shown in this example, the code can
    be extended to include error-handling mechanisms to handle potential exceptions
    or errors during compression or decompression.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理**：虽然在这个示例中没有明确显示，但代码可以扩展以包括错误处理机制，以处理在压缩或解压缩过程中可能出现的异常或错误。'
- en: '**Modular design** : The code is designed in a modular way, allowing for easy
    integration into larger applications or libraries.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化设计**：代码以模块化的方式设计，便于集成到更大的应用程序或库中。'
- en: '**Use of standard library** : The code uses the standard **lzma** module from
    the Python standard library, which is well-documented and widely used'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用标准库**：代码使用了 Python 标准库中的标准**lzma**模块，该模块有良好的文档支持并被广泛使用。'
- en: '**Example usage** : The code includes an example usage in the **if __name__
    == ''__main__''** block, making it easy to understand how to use the functions'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例用法**：代码在**if __name__ == ''__main__''**块中包含了一个示例用法，使得理解如何使用这些函数变得更加容易。'
- en: Overall, this code follows best practices for writing clean, readable, and maintainable
    Python code. It should be easy to understand for developers familiar with Python
    and the LZMA2 compression algorithm.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，这段代码遵循了编写干净、可读且易于维护的 Python 代码的最佳实践。对于熟悉 Python 和 LZMA2 压缩算法的开发者来说，应该很容易理解。
- en: That was the end of the Claude 3 output and our discussion of what is good about
    its more readable version of the LZMA compression code in Python.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Claude 3 输出的结束以及我们讨论其更具可读性版本的 Python LZMA 压缩代码的优点。
- en: Now, let’s get to specific points that make code easy or hard to read and understand.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看一些具体的因素，这些因素使得代码容易或难以阅读和理解。
- en: What makes code hard or easy to read?
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么因素使得代码容易或难以阅读？
- en: Let’s look at some practices that might lead to poor readability, and then we’ll
    look at how to get the readability as good as possible.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些可能导致可读性差的实践，然后再看看如何使可读性尽可能好。
- en: Why is reading code hard?
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么阅读代码会很难？
- en: 'Reading code is much harder than writing code for at least three reasons:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读代码比写代码要困难得多，至少有三个原因：
- en: When writing code, you have to keep in mind the variables, algorithms, data,
    and structure of the feature you’re writing only. When reading code, you must
    keep in mind all the information about wider functionality and potential functionalities
    that you’ve guessed from your reading of the code so far.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写代码时，你只需要关注你正在编写的功能的变量、算法、数据和结构。而阅读代码时，你必须记住所有关于更广泛功能和潜在功能的信息，这是你从阅读代码中猜测出来的。
- en: Thinking is easier than understanding someone else’s thinking – vastly easier.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 思考比理解别人思考的过程要容易——要简单得多。
- en: It’s not your code – your baby, so it’s probably not as good as something you
    could write, or at least that’s the thinking of many programmers. That’s the emotional
    aspect. Alternatively, you might be thinking that the code is written by someone
    more intelligent and experienced, so you’ll not be able to understand it.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那不是你的代码——你的“孩子”，所以它可能不如你自己写的好，至少这是很多程序员的想法。这是情感方面的因素。或者，你可能会认为这段代码是由一个更聪明、更有经验的人编写的，所以你无法理解它。
- en: To understand someone else’s code, you need a working model of the code in your
    mind, as well as the aims of the project [ *GameDev_Dieterich* ].
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解别人的代码，你需要在脑中有一个代码的工作模型，并了解项目的目标 [ *GameDev_Dieterich* ]。
- en: Don’t be afraid to read other people’s code and get an understanding of it.
    You may well make good use of it and not have to re-write the code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 不要害怕阅读他人的代码并理解它。你可能会很好地利用它，而不必重新编写代码。
- en: This reminds me of the time I had to read and use code from colleagues in Czechia.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我想起了我曾经需要阅读并使用来自捷克同事的代码的时光。
- en: In addition to trying to understand the C code (when I would normally code in
    C#, R, or MATLAB) and learn some more physics, some of the variables were in Czech,
    which I don’t speak. So, I had to learn some Czech too. Fortunately, I enjoy learning
    languages and already know plenty about physics. Eventually, I understood the
    code and we worked together well, including visits to each other’s countries,
    UK and Czechia. We got some great products made.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 除了试图理解C代码（而我通常用C#、R或MATLAB编程）并学习一些物理知识外，其中一些变量是捷克语的，而我不懂捷克语。所以，我还得学一点捷克语。幸运的是，我喜欢学习语言，也已经对物理有一定了解。最终，我理解了代码，我们的合作也非常顺利，包括互访各自的国家，英国和捷克。我们做出了一些很棒的产品。
- en: Of course, if you can communicate with the original coder, you can ask them
    questions about it. Be polite – it’s their baby, which they might have taken a
    lot of time and energy to create.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你可以与原始编码者沟通，你可以向他们询问代码问题。要有礼貌——那是他们的心血结晶，他们可能花了很多时间和精力来创建它。
- en: Dos and don’ts of readable code – how to make readable code
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可读性代码的注意事项——如何编写可读的代码
- en: Looking at the opinions of coders, the following are factors that make code
    difficult or a joy to read.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 根据程序员的意见，以下是使代码难以或容易阅读的因素。
- en: Do not do these things
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要做这些事情
- en: Inconsistencies, such as multiple different tab/indentation styles in one file
    or group of files or checking for a null and later checking for a non-null pointer,
    can confuse the reader who is trying to understand the code and ensure it’s working
    properly. Keep naming conventions consistent too.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些不一致的地方，如在一个文件或一组文件中使用多种不同的制表符/缩进样式，或者先检查空指针后又检查非空指针，会让试图理解代码并确保其正常工作的读者感到困惑。命名规范也要保持一致。
- en: Use variable and function names that aren’t descriptive of what they are for,
    such as using celebrity names or movie titles even if the script has nothing to
    do with films!
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不具描述性的变量和函数名，比如使用名人名字或电影标题，即使脚本与电影毫无关系！
- en: Using very similar function names can make bugs extremely tough to track down,
    such as **functionl()** and **functionL()** . Make it easy enough for future coders
    (including yourself) to differentiate functions.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非常相似的函数名会让定位bug变得极其困难，例如**functionl()**和**functionL()**。使未来的程序员（包括你自己）能够轻松区分函数。
- en: '**switch** statement excess: when editing someone else’s code, don’t simply
    add a **switch** statement if your case is covered because that could lead to
    fall-through cases being dispersed randomly amongst the standard cases and make
    it a headache to read and understand [ *O’Reilly_Algo_Flow,* *Quora_Chen, StackOverflow_switch*
    ].'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**switch**语句的过度使用：当编辑他人的代码时，如果你的情况已经涵盖，不要仅仅添加一个**switch**语句，因为那可能导致穿透情况随机分布在标准情况之间，使代码难以阅读和理解
    [ *O’Reilly_Algo_Flow,* *Quora_Chen, StackOverflow_switch* ]。'
- en: 'Use too many nested statements/layers of **if** statements: If an **if** statement
    starts in the middle of the screen, there is probably too much nesting.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用过多嵌套语句/层级的**if**语句：如果一个**if**语句出现在屏幕的中间，可能说明嵌套层次太多。
- en: Do these things
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 做这些事情
- en: 'Code should contain different functions and functions should be simple:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码应该包含不同的函数，并且函数应该简洁：
- en: 'Function names should reflect what they do, and functions should be very simple:
    one task for one function, not multiple tasks in one function. Having such simple
    functions makes them easy to understand.'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数名应反映它们的功能，且函数应该非常简洁：每个函数只负责一个任务，而不是多个任务。拥有这样的简单函数能使它们更易理解。
- en: An alternative to overusing **if** statements is to use **switch** statements.
    **switch** statements are usually much faster than **if/else** statements too,
    especially when the number of conditions is large [ *O’Reilly_Algo_Flow,* *Quora_Chen,
    StackOverflow_switch* ].
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过度使用**if**语句的替代方案是使用**switch**语句。**switch**语句通常比**if/else**语句要快，特别是当条件较多时 [
    *O’Reilly_Algo_Flow,* *Quora_Chen, StackOverflow_switch* ]。
- en: Some strategies to effectively use LLMs for code generation
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些有效使用大语言模型（LLMs）进行代码生成的策略
- en: 'Provide clear and specific prompts:'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提供清晰具体的提示语：
- en: '*Be precise* : Clearly articulate the desired functionality or task.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*精确*：清晰地表达所需的功能或任务。'
- en: '*Give context* : Provide relevant information about the project or code base.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提供背景*：提供与项目或代码库相关的背景信息。'
- en: '*Specify language* : Indicate the programming language you want the code in
    and its version, such as Python 3.10.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定语言*：指明你希望代码使用的编程语言及其版本，如Python 3.10。'
- en: 'Iterate and refine:'
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 迭代与优化：
- en: '*Evaluate output* : Carefully review the generated code for correctness and
    readability.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*评估输出*：仔细审查生成的代码，检查其正确性和可读性。'
- en: '*Provide feedback* : If the code is incorrect or needs improvement, provide
    specific feedback to the LLM – for example, “This code works but please make it
    easier to read, especially in the **Xzy** function.”'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提供反馈*：如果代码有错误或需要改进，向LLM提供具体反馈——例如，“这段代码可以工作，但请使其更易读，尤其是在**Xzy**函数中。”'
- en: '*Iterate* : Continue refining the prompt and iterating until you get the desired
    outcome.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*迭代*：继续优化提示语并迭代，直到得到理想的结果。'
- en: 'Leverage LLM capabilities:'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 利用LLM的能力：
- en: '*Code completion* : Use LLMs to suggest code snippets or complete unfinished
    lines.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代码补全*：使用LLM建议代码片段或完成未完成的代码行。'
- en: '*Function generation* : Ask LLMs to generate entire functions based on a given
    description.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*函数生成*：要求LLM根据给定的描述生成完整的函数。'
- en: '*Code explanation* : Have LLMs explain existing code to better understand its
    functionality.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代码解释*：让LLM解释现有代码，以便更好地理解其功能。'
- en: 'Consider contextual information:'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 考虑上下文信息：
- en: '*Project structure* : Provide information about the project’s structure, dependencies,
    and conventions.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*项目结构*：提供关于项目结构、依赖关系和约定的信息。'
- en: '*Code style* : Specify preferred coding styles or guidelines.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代码风格*：指定首选的编码风格或指南。'
- en: '*Best practices* : Instruct the LLM to adhere to best practices and avoid common
    pitfalls.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最佳实践*：指示LLM遵循最佳实践，避免常见的陷阱。'
- en: 'Combine human expertise with LLM capabilities:'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将人类专业知识与LLM能力结合：
- en: '*Human oversight* : Always have a human developer review and validate the generated
    code.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*人工监督*：始终让人类开发者审查和验证生成的代码。'
- en: '*Domain knowledge* : Leverage human expertise to ensure the code aligns with
    specific domain requirements.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*领域知识*：利用人类专业知识，确保代码符合特定领域的要求。'
- en: 'Here is an example prompt:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例提示语：
- en: '[PRE4]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is the LLM response:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是LLM的回复：
- en: 'Python:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Python：
- en: '[PRE5]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Use code with caution.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代码时要小心。
- en: Note
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: While this code is correct, a human developer might suggest improvements, such
    as adding type hints or using a more efficient iterative approach for larger values
    of n .
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码是正确的，但人类开发者可能会建议改进，比如添加类型提示或对较大的n值使用更高效的迭代方法。
- en: Remember
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住
- en: LLMs are a valuable tool for code generation, but they should be used along
    with human expertise to ensure the highest quality and maintainability of the
    code. By following these guidelines and iteratively refining your prompts, you
    can effectively leverage LLMs to enhance your coding productivity.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: LLM是代码生成的有价值工具，但它们应与人类专业知识结合使用，以确保代码的最高质量和可维护性。通过遵循这些指南并迭代优化提示语，你可以有效地利用LLM来提高编程生产力。
- en: Learning to read code does take practice, so keep practicing, and you’ll find
    it easier and more productive with time and work. Collaboration is one of the
    most powerful tools we have to make amazing things!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 学习阅读代码确实需要练习，所以要不断练习，随着时间的推移，你会发现它变得更加容易和高效。协作是我们用来创造惊人成果的最强大工具之一！
- en: 'This section has been about bad and best practices when writing or generating
    code with LLMs: don’t use too many **if** statements, don’t make the code overly
    complex or with no comments, and don’t just add things randomly; do go back and
    forth with the LLM, provide the desired language version and context, such as
    the project structure, evaluate the code yourself, write simple functions, use
    descriptive names, document the code nicely, follow coding standards and conventions,
    handle errors, and so on. We looked at some code that’s hard to understand and
    some that is easier to read and understand, and where to get the code from the
    Packt GitHub repo. The next section is on how to summarize code you don’t understand.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了在使用LLM编写或生成代码时的坏习惯与最佳实践：不要使用太多**if**语句，不要让代码过于复杂或没有注释，也不要随便添加东西；要和LLM来回互动，提供所需的语言版本和上下文，如项目结构，自行评估代码，编写简单的函数，使用具有描述性的命名，良好地文档化代码，遵循编码标准和规范，处理错误等等。我们看了一些难以理解的代码和一些更容易阅读和理解的代码，以及如何从Packt
    GitHub仓库获取代码。下一节将讨论如何总结你不理解的代码。
- en: Summarizing code for understanding
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结代码以便理解
- en: This section is about how to summarize code you’re given or find that is opaque
    to you, the functioning of which you can’t quite figure out. Alternatively, maybe
    you just don’t want to spend the time wracking your brain to figure it out when
    you can automate that process and save energy and time.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讲述了如何总结你所给出的或找到的、你无法完全理解的代码，或者你不太清楚它的运行机制。或者，也许你只是觉得不想花时间脑力思考，反而希望通过自动化这一过程来节省精力和时间。
- en: 'Here, I asked Gemini, from Alphabet, to give me some code I don’t understand:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我请Alphabet的Gemini给我一些我不理解的代码：
- en: '[PRE6]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is the code from Gemini (+ Claude 3):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自Gemini（+ Claude 3）的代码：
- en: '[PRE7]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Important note
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: I got Claude 3 Sonnet to debug this code as it wouldn’t run – this is the final
    version (Gemini + Claude), but the explanation was done before the debugging.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我请Claude 3 Sonnet来调试这段代码，因为它无法运行——这是最终版本（Gemini + Claude），但解释是在调试之前完成的。
- en: In the code files, this is called **crypto_price_and_indicators.py** , which
    is what Claude called it, but that was extremely close to what I’d called it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码文件中，这个文件被命名为**crypto_price_and_indicators.py**，这是Claude所命名的，但与我曾给它起的名字非常接近。
- en: I don’t really want to run code that I don’t understand at all – it could be
    dangerous, theoretically, though I mostly trust Alphabet. So, let’s see what ChatGPT
    can tell us about this.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我其实不太想运行我完全不理解的代码——从理论上讲，这可能是危险的，尽管我大多数时候信任Alphabet。所以，让我们看看ChatGPT能告诉我们什么。
- en: 'This is the prompt to pass to ChatGPT:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是传递给ChatGPT的提示：
- en: '[PRE8]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is the response from ChatGPT:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是ChatGPT的回应：
- en: '[PRE9]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ChatGPT broke down the functions for us and gave us a general overview, including
    what the main function does and even why those code libraries were imported. ChatGPT
    even explained what RSI is. This makes the reader feel rather confident about
    what the script does and what every element does. That looks pretty good to me.
    If you’re unsure that this was done well, you could copy the code and explanation
    into Claude or back into Gemini or another chatbot to check whether the explanation
    was correct in all parts.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT为我们分解了函数，并给出了整体概述，包括主函数的作用，甚至解释了为什么要导入那些代码库。ChatGPT还解释了什么是RSI。这使得读者对脚本的功能和每个元素的作用充满信心。对我来说，这看起来相当不错。如果你不确定解释是否做得很好，可以将代码和解释复制到Claude或Gemini中，或者其他聊天机器人中，检查解释是否在各个部分都正确。
- en: Looking over the code myself, I think it is an accurate explanation from ChatGPT.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我自己检查代码后，认为这是ChatGPT给出的准确解释。
- en: The code worked and produced this plot of Bitcoin (BTC) prices in US Dollars
    Tether (USDT – a cryptocurrency tethered to the USD) and SMA indicator. See *Figure
    4* *.1* .
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码成功运行，并生成了比特币（BTC）价格与美元稳定币Tether（USDT）和SMA指标的图表。请参见*图 4.1*。
- en: '![Figure 4.1: Bitcoin historical price (wiggly blue line) versus USDT and SMA
    indicator in smooth green. The BTC price is on the left vertical axis [30000 to
    70000]. The SMA is on the right vertical axis [-0.04 to 0.04].](img/B21009_04_1.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1：比特币历史价格（波动的蓝色线）与USDT和SMA指标（平滑的绿色线）对比。比特币价格在左侧垂直轴上[30000到70000]，SMA在右侧垂直轴上[-0.04到0.04]。](img/B21009_04_1.jpg)'
- en: 'Figure 4.1: Bitcoin historical price (wiggly blue line) versus USDT and SMA
    indicator in smooth green. The BTC price is on the left vertical axis [30000 to
    70000]. The SMA is on the right vertical axis [-0.04 to 0.04].'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：比特币历史价格（波动的蓝色线）与USDT和SMA指标（平滑的绿色线）对比。比特币价格在左侧垂直轴上[30000到70000]，SMA在右侧垂直轴上[-0.04到0.04]。
- en: Now that you can have code explained to you, there’s probably only 1 more step
    up in complexity and explanation. Especially if you want to publish your code,
    you might well want to fully document it so other coders can really work well
    with it by reading the manual.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以让代码向你解释了，可能只有再复杂一点的解释步骤，尤其是当你想发布你的代码时，你很可能希望完全文档化它，这样其他程序员可以通过阅读手册，真正顺利地使用它。
- en: The next section is for when you need to document your code so others can know
    what it’s for, how to troubleshoot it, and the best ways to use your code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节是讲解如何为你的代码编写文档，让其他人了解它的用途、如何排除故障以及如何最好地使用你的代码。
- en: Generating documentation
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成文档
- en: Let’s see the difference between explaining the preceding code and the full
    documentation of the code here. Let’s get a direct comparison by using the preceding
    code for the documentation.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看解释前述代码与该代码完整文档之间的区别。通过使用前述代码来生成文档，我们来做一个直接的对比。
- en: I asked Claude (because I believe it’s currently the best-performing LLM chatbot
    for code) to give me full documentation for the preceding code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我请 Claude（因为我认为它目前是表现最好的用于代码的 LLM 聊天机器人）为我提供前述代码的完整文档。
- en: Documentation for crypto_price_and_indicators.py
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: crypto_price_and_indicators.py 的文档
- en: 'Claude 3 Sonnet responded with this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Claude 3 Sonnet 的回答如下：
- en: '[PRE10]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'That documentation was very structured and went into the library requirements;
    it detailed every function: the parameters, what is returned by each function,
    and of course, the overall summary of what it does (at the beginning). It even
    gave a note on how to improve the functionality.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 该文档结构非常清晰，详细介绍了库的要求；它列出了每个函数：参数、每个函数返回的内容，以及当然，函数所做的总体总结（在开头部分）。它甚至给出了如何改进功能的建议。
- en: Seriously, to say that this LLM technology is “revolutionary” would in no way
    be hyperbole! This technology makes coding and documenting amazingly easy and
    fast!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，说这项 LLM 技术是“革命性的”绝对不算夸张！这项技术让编程和文档编写变得异常简单和快速！
- en: This is so much easier than writing everything by hand! We are so lucky! Yes,
    the examples given in this book are short but there is so much heavy lifting done
    by LLMs, and it will improve too.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这比手工写一切轻松多了！我们真幸运！是的，这本书中的例子虽然简短，但 LLMs 已经做了大量的繁重工作，而且它会变得越来越好。
- en: Important note
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As mind-blowing as this technology is, this is early 2024 technology and much
    more powerful, adaptable, and intelligent technology is coming at an accelerating
    rate. So, this will be old very soon.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这项技术令人震撼，但这是2024年初的技术，而更强大、更具适应性和智能的技术正在以加速的速度涌现。所以，这项技术很快就会过时。
- en: '*Stay up to date! Keep looking for new* *coding tools.*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*保持最新！不断寻找新的* *编程工具。*'
- en: That’s it for [*Chapter 4*](B21009_04.xhtml#_idTextAnchor100) – summary inbound.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 [*第4章*](B21009_04.xhtml#_idTextAnchor100) – 概要即将呈现。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, we explored how to use LLMs to produce more readable code,
    summarize and explain existing code, and generate documentation for existing code.
    Frankly, it was mind-blowing! Coding is so easy with LLMs!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何使用 LLMs 生成更易读的代码，总结和解释现有代码，并为现有代码生成文档。坦白说，简直让人震惊！使用 LLMs 编程太简单了！
- en: In [*Chapter 5*](B21009_05.xhtml#_idTextAnchor115) , we will be addressing biases
    and ethical concerns in LLM-generated code. Gemini caused some problems in February
    2024, which were not popular with the public. This is always a learning process,
    and hopefully, humans and AI will get better at generating world-changing AI.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第5章*](B21009_05.xhtml#_idTextAnchor115) 中，我们将讨论 LLM 生成的代码中的偏见和伦理问题。Gemini
    在2024年2月引发了一些问题，公众对此并不买账。这始终是一个学习过程，希望人类和人工智能在生成改变世界的AI方面能越来越好。
- en: Bibliography
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: '*GameDev_Dieterich* : “Most Programmers Can’t Read Code,” Robert Dieterich,
    [https://www.gamedeveloper.com/programming/most-programmers-can-t-read-code#close-modal](https://www.gamedeveloper.com/programming/most-programmers-can-t-read-code#close-modal)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GameDev_Dieterich* ： “大多数程序员看不懂代码”，Robert Dieterich，[https://www.gamedeveloper.com/programming/most-programmers-can-t-read-code#close-modal](https://www.gamedeveloper.com/programming/most-programmers-can-t-read-code#close-modal)'
- en: '*Ioijilai* : “Neural/Learned Image Compression: An Overview,” Ioijilai, [https://medium.com/@loijilai_43024/learned-image-compression-an-overview-625f3ab709f2](mailto:https://medium.com/@loijilai_43024/learned-image-compression-an-overview-625f3ab709f2)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ioijilai* ： “神经/学习图像压缩：概述”，Ioijilai，[https://medium.com/@loijilai_43024/learned-image-compression-an-overview-625f3ab709f2](mailto:https://medium.com/@loijilai_43024/learned-image-compression-an-overview-625f3ab709f2)'
- en: '*O’Reilly_Algo_Flow* : “ChapterÂ 4.Â Algorithms and Flow Control,” Nicholas
    C. Zakas, [https://www.oreilly.com/library/view/high-performance-javascript/9781449382308/ch04.html#:~:text=As%20it%20turns%20out%2C%20the,than%20it%20is%20for%20switch%20](https://www.oreilly.com/library/view/high-performance-javascript/9781449382308/ch04.html#:~:text=As%20it%20turns%20out%2C%20the,than%20it%20is%20for%20switch%20)
    .'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*O’Reilly_Algo_Flow*：“第4章 算法与流程控制”，Nicholas C. Zakas, [https://www.oreilly.com/library/view/high-performance-javascript/9781449382308/ch04.html#:~:text=As%20it%20turns%20out%2C%20the,than%20it%20is%20for%20switch%20](https://www.oreilly.com/library/view/high-performance-javascript/9781449382308/ch04.html#:~:text=As%20it%20turns%20out%2C%20the,than%20it%20is%20for%20switch%20)'
- en: '*Quora_Chen* : “What makes some code hard to read and some code easy to read?”,
    Howard Chen, [https://www.quora.com/What-makes-some-code-hard-to-read-and-some-code-easy-to-read](https://www.quora.com/What-makes-some-code-hard-to-read-and-some-code-easy-to-read)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Quora_Chen*：“是什么让一些代码难以阅读，而另一些代码易于阅读？”，Howard Chen, [https://www.quora.com/What-makes-some-code-hard-to-read-and-some-code-easy-to-read](https://www.quora.com/What-makes-some-code-hard-to-read-and-some-code-easy-to-read)'
- en: '*StackOverflow_switch* : “When to use If-else if-else over switch statements
    and vice versa [duplicate]: concerning Readability:”, Sonu Oommen, [https://stackoverflow.com/questions/427760/when-to-use-if-else-if-else-over-switch-statements-and-vice-versa](https://stackoverflow.com/questions/427760/when-to-use-if-else-if-else-over-switch-statements-and-vice-versa)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*StackOverflow_switch*：“何时使用If-else if-else而非switch语句，反之亦然【重复问题】：关于可读性：”，Sonu
    Oommen, [https://stackoverflow.com/questions/427760/when-to-use-if-else-if-else-over-switch-statements-and-vice-versa](https://stackoverflow.com/questions/427760/when-to-use-if-else-if-else-over-switch-statements-and-vice-versa)'
- en: '*Taylor_2022* : Phillip Taylor, Nathan Griffiths, Vince Hall, Zhou Xu, Alex
    Mouzakitis, “Feature selection for supervised learning and compression,“ [https://www.tandfonline.com/doi/full/10.1080/08839514.2022.2034293](https://www.tandfonline.com/doi/full/10.1080/08839514.2022.2034293)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Taylor_2022*：Phillip Taylor, Nathan Griffiths, Vince Hall, Zhou Xu, Alex Mouzakitis，“监督学习与压缩的特征选择，”[https://www.tandfonline.com/doi/full/10.1080/08839514.2022.2034293](https://www.tandfonline.com/doi/full/10.1080/08839514.2022.2034293)'
- en: '*Wiki_Cosine* : “Discrete cosine transform,” Wikipedia, [https://en.wikipedia.org/wiki/Discrete_cosine_transform](https://en.wikipedia.org/wiki/Discrete_cosine_transform)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Wiki_Cosine*：“离散余弦变换”，Wikipedia, [https://en.wikipedia.org/wiki/Discrete_cosine_transform](https://en.wikipedia.org/wiki/Discrete_cosine_transform)'
- en: '*WikiDataComp* : “Data compression ratio,” [https://en.wikipedia.org/wiki/Data_compression_ratio#:~:text=Definition,-Data%20compression%20ratio&text=Thus%2C%20a%20representation%20that%20compresses,implicit%20ratio%2C%205%2F1](https://en.wikipedia.org/wiki/Data_compression_ratio#:~:text=Definition,-Data%20compression%20ratio&text=Thus%2C%20a%20representation%20that%20compresses,implicit%20ratio%2C%205%2F1)
    .'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*WikiDataComp*：“数据压缩比”，[https://en.wikipedia.org/wiki/Data_compression_ratio#:~:text=Definition,-Data%20compression%20ratio&text=Thus%2C%20a%20representation%20that%20compresses,implicit%20ratio%2C%205%2F1](https://en.wikipedia.org/wiki/Data_compression_ratio#:~:text=Definition,-Data%20compression%20ratio&text=Thus%2C%20a%20representation%20that%20compresses,implicit%20ratio%2C%205%2F1)'
- en: '*Wiki_LZMA2* : “Lempel–Ziv–Markov chain algorithm,” Wikipedia, [https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Markov_chain_algorithm](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Markov_chain_algorithm)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Wiki_LZMA2*：“Lempel–Ziv–Markov链算法”，Wikipedia, [https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Markov_chain_algorithm](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Markov_chain_algorithm)'
- en: '*Wiki_Wavelets* : “Wavelet transform,” [https://en.wikipedia.org/wiki/Wavelet_transform#Wavelet_compression](https://en.wikipedia.org/wiki/Wavelet_transform#Wavelet_compression)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Wiki_Wavelets*：“小波变换”，[https://en.wikipedia.org/wiki/Wavelet_transform#Wavelet_compression](https://en.wikipedia.org/wiki/Wavelet_transform#Wavelet_compression)'
