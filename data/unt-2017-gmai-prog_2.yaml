- en: Finite State Machines and You
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有限状态机与您
- en: 'In this chapter, we''ll expand our knowledge of the FSM pattern and its uses
    in games and learn how to implement it in a simple Unity game. We will create
    a tank game with the sample code that comes with this book. We''ll be dissecting
    the code and the components in this project. The topics we''ll cover are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将扩展我们对FSM模式和其在游戏中的应用的知识，并学习如何在简单的Unity游戏中实现它。我们将使用本书附带示例代码创建一个坦克游戏。我们将剖析这个项目中的代码和组件。我们将讨论的主题如下：
- en: Understanding Unity's state machine features
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Unity的状态机功能
- en: Creating our own states and transitions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们自己的状态和转换
- en: Creating a sample scene using examples
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用示例创建一个场景
- en: Unity 5 introduced state machine behaviors, which are a generic expansion of
    the Mecanim animation states that were introduced in the 4.x cycle. These new
    state machine behaviors, however, are independent of the animation system, and
    we will learn to leverage these new features to quickly implement a state-based
    AI system.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 5引入了状态机行为，这是对4.x周期中引入的Mecanim动画状态的通用扩展。然而，这些新的状态机行为与动画系统无关，我们将学习利用这些新功能快速实现基于状态的人工智能系统。
- en: In our game, the player will be able to control a tank. The enemy tanks will
    be moving around in the scene with reference to four waypoints. Once the player
    tank enters their visible range, they will start chasing us, and once they are
    close enough to attack, they'll start shooting at our tank agent. This simple
    example will be a fun way to get our feet wet in the world of AI and state FSMs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，玩家将能够控制一个坦克。敌方坦克将在场景中以四个航点为参考移动。一旦玩家坦克进入它们的可见范围内，它们将开始追逐我们，一旦它们足够接近可以攻击，它们就会开始向我们的坦克代理射击。这个简单的例子将是一个在人工智能和状态FSM世界中获得乐趣的好方法。
- en: Finding uses for FSMs
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找FSM的应用
- en: Although we will primarily focus on using FSMs to implement AI in our game to
    make it more fun and interesting, it is important to point out that FSMs are widely
    used throughout game and software design and programming. In fact, the system
    in Unity 2017 that we'll be using was first introduced in the Mecanim animation
    system.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将主要关注使用FSM来实现游戏中的AI，使其更加有趣和吸引人，但重要的是要指出，FSMs在游戏和软件设计和编程中被广泛使用。实际上，我们将使用的Unity
    2017系统最初是在Mecanim动画系统中引入的。
- en: 'We can categorize many things into states in our daily lives. The most effective
    patterns in programming are those that mimic the simplicity of real-life designs,
    and FSMs are no different. Take a look around and you''ll most likely notice a
    number of things in one of any number of possible states. For example, is there
    a light bulb nearby? A light bulb can be in one of two states—on or off (so long
    as we''re not talking about one of those fancy dimming lights). Let''s go back
    to grade school for a moment and think about the time when we were learning about
    the different states matter can be in. Water, for example, can be solid, liquid,
    or gas. Just as in the FSM pattern in programming where variables can trigger
    a state change, water''s transition from one state to another is caused by heat:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的日常生活中，我们可以将许多事物分类为状态。编程中最有效的模式是那些模仿现实生活设计的简单性，FSM也不例外。环顾四周，你很可能会注意到许多事物处于任何可能的多种状态之一。例如，附近有灯泡吗？灯泡可以处于两种状态之一——开或关（只要我们不谈论那些花哨的调光灯泡）。让我们暂时回到小学，回想一下我们学习物质不同状态的时间。例如，水可以是固体、液体或气体。就像在编程中的FSM模式中，变量可以触发状态变化一样，水的状态从一种到另一种的转变是由热量引起的：
- en: '![](img/615ef79f-2b49-427c-8116-66f966d3f081.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/615ef79f-2b49-427c-8116-66f966d3f081.png)'
- en: The three distinct states of water
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 水的三个不同状态
- en: Though there are no hard rules beyond those of our own implementation in programming
    design patterns, it is a characteristic of FSMs to be in one, and only one, state
    at any given time. With that said, transitions allow for a "hand-off", of sorts,
    between two states, just like ice slowly melts into water. Additionally, an agent
    can have multiple FSMs, driving any number of behaviors, and states can even contain
    state machines of their own—think Christopher Nolan's *Inception*, but with state
    machines instead of dreams.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编程设计模式中没有超出我们自身实现之外的硬性规则，但FSM的一个特点是任何给定时间都处于一个，并且只有一个状态。话虽如此，转换允许在两个状态之间进行“交接”，就像冰慢慢融化成水一样。此外，一个代理可以拥有多个FSM，驱动任何数量的行为，状态甚至可以包含它们自己的状态机——想想克里斯托弗·诺兰的*盗梦空间*，但用状态机代替梦境。
- en: 'There are many different implementations and variants of the FSM in C# and
    Unity, many of which can be found in the Unity Asset Store, but they share a few
    key features:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 和 Unity 中，有限状态机（FSM）有许多不同的实现和变体，其中许多可以在 Unity Asset Store 中找到，但它们有一些关键特性：
- en: They define the various states that an object can be in
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们定义了对象可能处于的各种状态
- en: They provide a mechanism for transitioning from one state to another
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供了一种从一种状态转换到另一种状态的机制
- en: They provide a way to define the rules that govern transitions
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供了一种定义控制转换规则的方式
- en: Unity's Mecanim system, though intended originally for driving animations in
    a state-based manner, fits the bill quite well as it provides a lesser-known,
    more generic set of FSM features.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 的 Mecanim 系统，虽然最初是为了以基于状态的方式驱动动画而设计的，但它非常适合提供更通用、更少为人所知的 FSM 功能。
- en: Creating state machine behaviors
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建状态机行为
- en: Now that we're familiar with the concept of a state machine, let's get our hands
    dirty and start implementing our very own.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经熟悉了状态机的概念，让我们动手实现我们自己的状态机。
- en: As of Unity 2017.1, state machines are still part of the animation system, but
    worry not, they are flexible and no animations are actually required to implement
    them. Don't be alarmed or confused if you see code referencing the `Animator`
    component or the `AnimationController` asset as it's merely a quirk of the current
    implementation. It's possible that Unity will address this in a later version,
    but the concepts will likely not change.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Unity 2017.1，状态机仍然是动画系统的一部分，但不用担心，它们是灵活的，实际上不需要动画来实现它们。如果你看到引用 `Animator`
    组件或 `AnimationController` 资产的代码，不要感到惊讶或困惑，因为这仅仅是当前实现的一个特性。Unity 可能会在以后的版本中解决这个问题，但概念可能不会改变。
- en: Let's fire up Unity, create a new project, and get to it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动 Unity，创建一个新的项目，并开始操作。
- en: Creating the AnimationController asset
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 AnimationController 资产
- en: 'The `AnimationController` asset is a type of asset within Unity that handles
    states and transitions. It is, in essence, an FSM, but it also does much more.
    We''ll focus on the FSM portion of its functionality. An animator controller can
    be created from the Assets menu, as shown in the following image:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnimationController` 资产是 Unity 中的一种资源类型，用于处理状态和转换。本质上，它是一个 FSM，但它还做了更多。我们将专注于其功能中的
    FSM 部分。动画控制器可以从资产菜单创建，如下面的图像所示：'
- en: '![](img/588bcc19-3075-49ba-abde-8a43e3bd051b.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/588bcc19-3075-49ba-abde-8a43e3bd051b.png)'
- en: 'Once you create the animator controller, it will pop up in your project assets
    folder, ready to be named. We''ll name it `TankFsm`. When you select the animator
    controller, unlike most other asset types, the hierarchy is blank. That is because
    animation controllers use their own window. You can simply click on Open in the
    hierarchy to open up the Animator window, or open it in the Window menu, as you
    can see in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建动画控制器，它就会出现在你的项目资源文件夹中，准备被命名。我们将命名为 `TankFsm`。当你选择动画控制器时，与大多数其他资源类型不同，层次结构是空的。这是因为动画控制器使用它们自己的窗口。你可以简单地点击层次结构中的“打开”来打开动画器窗口，或者像以下截图所示，在窗口菜单中打开：
- en: '![](img/5cb72492-d7de-491f-9468-8bb415e723f9.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5cb72492-d7de-491f-9468-8bb415e723f9.png)'
- en: Be sure to select Animator and not Animation as these are two different windows
    and features entirely.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 确保选择“Animator”而不是“Animation”，因为这两个窗口和功能完全不同。
- en: Let's familiarize ourselves with this window before moving forward.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们熟悉这个窗口。
- en: Layers and parameters
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 层和参数
- en: 'Layers, as the name implies, allow us to stack different state machine levels
    on top of each other. This panel allows us to organize the layers easily and have
    a visual representation. We will not be doing much in this panel for now as it
    primarily relates to animation, but it''s good to be familiar with it. Refer to
    the following screenshot of the window to find your way around the layers:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如同其名，层允许我们在彼此之上堆叠不同的状态机级别。这个面板允许我们轻松组织层，并有一个视觉表示。目前我们在这个面板上不会做太多，因为它主要与动画相关，但了解它是好的。参考以下窗口截图以了解如何在层中导航：
- en: '![](img/ba0ba33e-7b0d-4b0e-a987-305b7d91f85b.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba0ba33e-7b0d-4b0e-a987-305b7d91f85b.png)'
- en: 'Here is a summary of the items shown in the previous screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上一张截图中所显示的项目摘要：
- en: '**Add layer**: The + button creates a new layer at the bottom of the list.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加层**：+ 按钮在列表底部创建一个新的层。'
- en: '**Layer list**: These are the layers currently inside the animator controller.
    You can click to select a layer and drag and drop layers to rearrange them.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层列表**：这些是目前在动画控制器内部的层。你可以点击来选择一个层，并通过拖放来重新排列层。'
- en: '**Layer settings**: The gear icon brings up a menu to edit animation-specific
    settings for the layer.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层设置**：齿轮图标会弹出一个菜单，用于编辑层的特定动画设置。'
- en: Second, we have the Parameters panel, which is far more relevant to our use
    of the animator controller. Parameters are variables that determine when to transition
    between states, and we can access them via scripts to drive our states. There
    are four types of parameters—`float`, `int`, `bool`, and `trigger`. You should
    already be familiar with the first three as they are primitive types in C#, but
    `trigger` is specific to the animator controller, not to be confused with physics
    triggers, which do not apply here. Triggers are just a means to trigger a transition
    between states explicitly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们有参数面板，这与我们的动画控制器使用密切相关。参数是决定何时在状态之间转换的变量，我们可以通过脚本访问它们来驱动我们的状态。有四种类型的参数——`float`、`int`、`bool`和`trigger`。你应该已经熟悉前三种，因为它们是C#中的基本类型，但`trigger`是特定于动画控制器的，不要与物理触发器混淆，物理触发器在这里不适用。触发器只是显式触发状态之间转换的一种手段。
- en: 'The following screenshot shows the elements in the Parameters panel:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了参数面板中的元素：
- en: '![](img/4b09e53f-d7b2-4e72-ae7c-2cd1688a305d.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4b09e53f-d7b2-4e72-ae7c-2cd1688a305d.png)'
- en: 'Here is a summary of the items depicted in the previous screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是上一张截图中所展示的项目摘要：
- en: '**Search**: We can quickly search through our parameters here. Simply type
    in the name and the list will populate with the search results.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索**：我们可以在这里快速搜索我们的参数。只需输入名称，列表就会填充搜索结果。'
- en: '**Add parameter**: This button lets you add new parameters. When you click
    on it, you must select the parameter type.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加参数**：此按钮允许你添加新参数。当你点击它时，你必须选择参数类型。'
- en: '**Parameter list**: This is the list of parameters you''ve created. You can
    assign and view their values here. You can also reorder the parameters to your
    liking by dragging and dropping them in the correct order. This is merely for
    organization and does not affect functionality at all.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数列表**：这是你创建的参数列表。你可以在这里分配和查看它们的值。你也可以通过拖放来重新排列参数，以符合你的喜好。这只是为了组织，根本不影响功能。'
- en: 'Lastly, there is an eyeball icon, which you can click to hide the Layers and
    Parameters panels altogether. When the panels are closed, you can still create
    new layers by clicking on the Layers dropdown and selecting Create New Layer:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个眼球图标，你可以点击来完全隐藏层和参数面板。当面板关闭时，你仍然可以通过点击层下拉菜单并选择创建新层来创建新层：
- en: '![](img/00c538a4-b1c4-493e-9909-7c0d3eb58750.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00c538a4-b1c4-493e-9909-7c0d3eb58750.png)'
- en: The animation controller inspector
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画控制器检查器
- en: The animation controller inspector is slightly different from the regular inspector
    found throughout Unity. While the regular inspector allows you to add components
    to the game objects, the animation controller inspector has a button labeled Add
    Behaviour, which allows you to add a `StateMachineBehaviour` to it. This is the
    main distinction between the two types of inspectors, but apart from this, it
    will display the serialized information for any selected state, substate, transition,
    or blend tree, just as the regular inspector displays the data for the selected
    game object and its components.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 动画控制器检查器与Unity中找到的常规检查器略有不同。虽然常规检查器允许你向游戏对象添加组件，但动画控制器检查器有一个名为“添加行为”的按钮，允许你向其中添加`StateMachineBehaviour`。这是两种类型检查器之间的主要区别，但除此之外，它将显示任何选定状态、子状态、过渡或混合树的序列化信息，就像常规检查器显示选定游戏对象及其组件的数据一样。
- en: Bringing behaviors into the picture
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将行为引入画面
- en: State machine behaviors are a unique, new concept in Unity 5\. While states
    existed, conceptually, in the original implementation of Mecanim, transitions
    were handled behind the scenes and you did not have much control over what happened
    upon entering, transitioning, or exiting a state. Unity 5 addressed this issue
    by introducing behaviors; they provide the built-in functionality to handle typical
    FSM logic.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机行为是Unity 5中的一个独特、新的概念。虽然状态在Mecanim的原版实现中在概念上存在，但过渡是在幕后处理的，你无法对进入、转换或退出状态时发生的事情有太多控制。Unity
    5通过引入行为来解决这一问题；它们提供了处理典型有限状态机（FSM）逻辑的内置功能。
- en: Behaviors are sly and tricky. Though their name might lead you to believe they
    are related to `MonoBehaviour`, do not fall for it; if anything, these two are
    distant cousins at best. In fact, behaviors derive from `ScriptableObject`, not
    `MonoBehaviour`, so they exist only as assets, which cannot be placed in a scene
    or added as components to a `GameObject`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 行为（Behaviors）是狡猾且复杂的。尽管它们的名称可能让你认为它们与`MonoBehaviour`有关联，但不要上当；实际上，这两者最多只是远亲。实际上，行为是从`ScriptableObject`派生出来的，而不是从`MonoBehaviour`，因此它们仅作为资产存在，不能放置在场景中或作为组件添加到`GameObject`中。
- en: Creating our very first state
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个状态
- en: 'Okay, so the header is not entirely true since Unity creates a few default
    states for us in our animator controller—New State, Any State, Entry, and Exit—but
    let''s just agree that those don''t count for now, okay? Let''s take a look at
    some of the things we can do in our newly-created animation controller:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以这个标题并不完全准确，因为Unity在我们的动画控制器中为我们创建了一些默认状态——New State、Any State、Entry和Exit，但让我们先同意现在我们不考虑这些。让我们看看我们可以在新创建的动画控制器中做些什么：
- en: You can select states in this window by clicking on them, and you can move them
    by dragging and dropping them anywhere in the canvas.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过单击此窗口中的状态来选择它们，并且可以通过拖放它们到画布上的任何位置来移动它们。
- en: Select the state named New State and delete it by either right-clicking and
    then clicking on Delete or simply hitting the *Delete* key on your keyboard.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择名为“New State”的状态，并通过右键单击然后点击删除或简单地按键盘上的*Delete*键来删除它。
- en: 'If you select the Any State state, you''ll notice that you do not have the
    option to delete it. The same is true for the Entry state. These are required
    states in an animator controller and have unique uses, which we''ll cover up ahead:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您选择Any State状态，您会注意到您没有删除它的选项。Entry状态也是如此。这些是在动画控制器中必需的状态，并且有独特的用途，我们将在稍后讨论：
- en: '![](img/cf416931-af3a-43d0-baa3-d8aa4e90f39c.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cf416931-af3a-43d0-baa3-d8aa4e90f39c.png)'
- en: To create our (true) first state, right-click anywhere on the canvas and then
    select Create State, which opens up a few options, from which we'll select Empty.
    The other two options, From Selected Clip and From New Blend Tree, are not immediately
    applicable to our project, so we'll skip these. Now we've officially created our
    first state.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的（真正的）第一个状态，请在画布上的任何位置右键单击，然后选择创建状态，这将打开一些选项，我们将从中选择空状态。其他两个选项，从所选剪辑和从新混合树创建，对我们当前的项目并不立即适用，所以我们将跳过这些选项。现在我们已经正式创建了我们的第一个状态。
- en: Transitioning between states
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态之间的转换
- en: You'll notice that upon creating our state, an arrow is created connecting the
    Entry state to it, and that its node is orange. Unity will automatically set default
    states to look orange to differentiate them from other states. When you only have
    one state, it is automatically selected as the default state, and as such, it
    is automatically connected to the entry state. You can manually select which state
    is the default state by right-clicking on it and then clicking on Set as Layer
    Default State. It will then become orange, and the entry state will automatically
    connect itself to it. The connecting arrow is a **transition connector**. Transition
    connectors allow us some control over how and when the transition occurs, but
    the connector from the entry state to the default state is unique in that it does
    not provide us with any options, since this transition happens automatically.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，在创建我们的状态时，一个箭头被创建，连接到Entry状态，并且它的节点是橙色的。Unity会自动将默认状态设置为橙色，以区分其他状态。当您只有一个状态时，它将自动被选中为默认状态，并且因此，它将自动连接到入口状态。您可以通过右键单击它并点击设置为层默认状态来手动选择哪个状态是默认状态。它将变成橙色，入口状态将自动连接到它。连接的箭头是**转换连接器**。转换连接器允许我们控制转换如何以及何时发生，但从入口状态到默认状态的连接器是独特的，因为它不为我们提供任何选项，因为这个转换是自动发生的。
- en: You can manually assign transitions between states by right-clicking on a state
    node and then selecting Make Transition. This will create a transition arrow from
    the state you selected to your mouse cursor. To select the destination of the
    transition, simply click on the destination node and that's it. Note that you
    cannot redirect the transitions though. We can only hope that the kind folks behind
    Unity add that functionality at a later point, but for now, you must remove a
    transition by selecting it and deleting it, and then assigning an all-new transition
    manually.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过右键单击状态节点并选择创建转换来手动分配状态之间的转换。这将从您选择的状态创建一个转换箭头到鼠标光标。要选择转换的目标，只需单击目标节点即可。请注意，您不能重定向转换。我们只能希望Unity背后的好心人在以后添加该功能，但到目前为止，您必须通过选择它并删除它来删除转换，然后手动分配全新的转换。
- en: Setting up our player tank
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的玩家坦克
- en: Open up the sample project included with this book for this chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 打开本书附带的本章示例项目。
- en: It is a good idea to group similar assets together in your project folder to
    keep them organized. For example, you can group your state machines in a folder
    called `StateMachines`. The assets provided for this chapter are grouped for you
    already, so you can drop the assets and scripts you create during this chapter
    into the corresponding folder.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的项目文件夹中按组组织类似资产是一个好主意，以保持它们有序。例如，您可以将您的状态机放在名为`StateMachines`的文件夹中。本章提供的资产已经分组，因此您可以将本章创建的资产和脚本拖放到相应的文件夹中。
- en: Creating the enemy tank
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建敌人坦克
- en: Let's go ahead and create an animator controller in your assets folder. This
    will be your enemy tank's state machine. Call it `EnemyFsm`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在你的资产文件夹中创建一个动画控制器。这将是你敌人坦克的状态机。命名为`EnemyFsm`。
- en: This state machine will drive the tank's basic actions. As described earlier
    in our example, the enemy can patrol, chase, and shoot the player. Let's go ahead
    and set up our state machine. Select the `EnemyFsm` asset and open up the Animator
    window.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个状态机将驱动坦克的基本动作。正如之前在示例中所述，敌人可以巡逻、追逐并射击玩家。让我们继续设置我们的状态机。选择`EnemyFsm`资产并打开动画器窗口。
- en: Now, we'll go ahead and create three empty states that will conceptually and
    functionally represent our enemy tank's states. Name them `Patrol`, `Chase`, and
    `Shoot`. Once they are created and named, we'll want to make sure we have the
    correct default state assigned. At the moment, this will vary depending on the
    order in which you created and named the states, but we want the Patrol state
    to be the default state, so right-click on it and select Set as Layer Default
    State. Now it is colored orange and the Entry state is connected to it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续创建三个空状态，这些状态在概念上和功能上代表我们的敌人坦克的状态。命名为`Patrol`、`Chase`和`Shoot`。一旦创建并命名，我们就要确保我们分配了正确的默认状态。目前，这取决于你创建和命名状态的顺序，但我们希望巡逻状态是默认状态，所以右键单击它并选择设置为层默认状态。现在它被涂成橙色，入口状态连接到它。
- en: Choosing transitions
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择转换
- en: 'At this point, we have to make some design and logic decisions regarding the
    way our states will flow into each other. When we map out these transitions, we
    also want to keep in mind the conditions that trigger the transitions to make
    sure they are logical and work from a design-standpoint. Out in the wild, when
    you''re applying these techniques on your own, different factors will play into
    how these transitions are handled. In order to best illustrate the topic at hand,
    we''ll keep our transitions simple and logical:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们必须就我们的状态如何相互流动做出一些设计和逻辑决策。当我们规划这些转换时，我们还想记住触发转换的条件，以确保它们是逻辑的，并且从设计角度来说是可行的。在野外，当你自己应用这些技术时，不同的因素将影响这些转换的处理方式。为了最好地说明当前的主题，我们将保持我们的转换简单且逻辑清晰：
- en: '**Patrol**: From patrol, we can transition into chasing. We will use a chain
    of conditions to choose which state we''ll transition into, if any. Can the enemy
    tank see the player? If yes, we go to the next step; if not, we continue with
    patrolling.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**巡逻**：从巡逻状态，我们可以过渡到追逐状态。我们将使用一系列条件来选择我们将过渡到哪个状态，如果有的话。敌人坦克能看到玩家吗？如果是，我们进入下一步；如果不是，我们继续巡逻。'
- en: '**Chase**: From this state, we''ll want to continue to check whether the player
    is within sight to continue chasing, close enough to shoot, or completely out
    of sight—that would send us back into the Patrol state.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**追逐**：从这个状态开始，我们希望继续检查玩家是否在视线范围内以继续追逐，是否足够近可以射击，或者完全看不见——这将使我们回到巡逻状态。'
- en: '**Shoot**: As earlier, we''ll want to check our range for shooting and then
    the line of sight to determine whether or not we can chase to get within the range.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**射击**：和之前一样，我们想要检查射击范围，然后是视线，以确定我们是否可以追击进入射程。'
- en: 'This particular example has a simple and clean set of transition rules. If
    we connect our states accordingly, we''ll end up with a graph looking more or
    less similar to this one:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的例子有一组简单且清晰的转换规则。如果我们相应地连接我们的状态，最终得到的图将大致类似于这个：
- en: '![](img/b1f507f9-25d0-4546-85dc-51f7d35777c2.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b1f507f9-25d0-4546-85dc-51f7d35777c2.png)'
- en: Keep in mind that the placement of the nodes is entirely up to you, and it does
    not affect the functionality of the state machine in any way. You can try to place
    your nodes in a way that keeps them organized so that you can track your transitions
    visually.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，节点的放置完全取决于你，并且它不会以任何方式影响状态机的功能。你可以尝试以保持它们组织的方式放置节点，这样你就可以通过视觉跟踪你的转换。
- en: Now that we have our states mapped out, let's assign some behaviors to them.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经绘制了状态图，让我们给它们分配一些行为。
- en: Making the cogs turn
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让齿轮转动
- en: This is the part I'm sure you've been waiting for. I know, I've kept you waiting,
    but for good reason. As we now get ready to dive into the coding, we do so with
    a good understanding of the logical connection between the states in our FSM.
    Without further ado, select our Patrol state. In the hierarchy, you'll see a button
    labeled Add Behaviour. Clicking this gives you a context menu very similar to
    the Add Component button on regular game objects, but as we mentioned before,
    this button creates the oh-so-unique state machine behaviors.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是你一直等待的部分。我知道，我让你等了，但这是有原因的。现在我们准备开始编码，我们对FSM中状态之间的逻辑联系有了很好的理解。无需多言，选择我们的巡逻状态。在层次结构中，你会看到一个标有添加行为（Add
    Behaviour）的按钮。点击这个按钮会弹出一个上下文菜单，它与常规游戏对象上的添加组件（Add Component）按钮非常相似，但正如我们之前提到的，这个按钮创建的是独一无二的州机行为。
- en: 'Go ahead and name this behavior `TankPatrolState`. Doing so creates a script
    of the same name in your project and attaches it to the state we created it from.
    You can open this script via the project window, or by double-clicking on the
    name of the script in the inspector. What you''ll find inside will look similar
    to this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，给这个行为命名为`TankPatrolState`。这样做会在你的项目中创建一个同名的脚本，并将其附加到创建它的状态上。你可以通过项目窗口打开这个脚本，或者通过在检查器中双击脚本的名称。你将看到的内容将类似于这个：
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Downloading the example code
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下载示例代码
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你购买的所有Packt Publishing书籍的账户中下载示例代码文件。[http://www.packtpub.com](http://www.packtpub.com)。如果你在其他地方购买了这本书，你可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给你。
- en: Before we begin, uncomment each method. Let's break it down step by step. Unity
    creates this file for you, but all the methods are commented out. Essentially,
    the commented code acts as a guide. Much like the methods provided for you in
    a `MonoBehaviour`, these methods are called for you by the underlying logic. You
    don't need to know what's going on behind the scenes to use them; you simply have
    to know when they are called to leverage them. Luckily, the commented code provides
    a brief description of when each method is called, and the names are fairly descriptive
    themselves. There are two methods here we don't need to worry about, `OnStateIK`
    and `OnStateMove`, which are animation messages, so go ahead and delete them and
    save the file.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，取消注释每个方法。让我们一步一步来分析。Unity为你创建了此文件，但所有方法都被注释掉了。本质上，被注释的代码充当指南。就像为`MonoBehaviour`提供的那些方法一样，这些方法是由底层逻辑为你调用的。你不需要了解幕后发生了什么就可以使用它们；你只需要知道它们何时被调用，以便利用它们。幸运的是，被注释的代码提供了每个方法被调用时的简要描述，并且名称本身相当具有描述性。这里有两个我们不需要担心的方法，`OnStateIK`和`OnStateMove`，它们是动画消息，所以你可以直接删除它们并保存文件。
- en: 'To reiterate what''s stated in the code''s comments, the following things happen:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重申代码注释中所述的内容，以下事情会发生：
- en: '`OnStateEnter` is called when you enter the state, as soon as the'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnStateEnter`在进入状态时被调用，紧接着`MonoBehaviors`更新之后'
- en: transition starts
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 转换开始
- en: '`OnStateUpdate` is called on each frame, after the `MonoBehaviors` update'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnStateUpdate`在每一帧调用，在`MonoBehaviors`更新之后'
- en: '`OnStateExit` is called after the transition out of the state is finished'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnStateExit` 在离开状态完成后被调用'
- en: 'The following two states, as we mentioned, are animation-specific, so we do
    not use those for our purposes:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所述，以下两个状态是动画特定的，因此我们不会为我们的目的使用它们：
- en: '`OnStateIK` is called just before the IK system gets updated; this is an animation
    and rig-specific concept'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnStateIK` 在IK系统更新之前被调用；这是一个动画和绑定特定的概念'
- en: '`OnStateMove` is used on avatars that are set up to use root motion'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnStateMove` 用于设置了根运动的头像'
- en: 'Another important piece of information to note is the parameters passed into
    these methods:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的重要信息是传递给这些方法的参数：
- en: The `animator` parameter is a reference to the animator that contains this animator
    controller, and therefore this state machine. By extension, you can fetch a reference
    to the game object that the animator controller is on, and from there, you can
    grab any other components attached to it. Remember, the state machine behavior
    exists only as an asset, and does not exist in the class, meaning this is the
    best way to get references to runtime classes, such as mono behaviors.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`animator` 参数是对包含此动画控制器以及因此状态机的动画器的引用。通过扩展，你可以获取动画控制器所在的游戏对象的引用，然后你可以从中获取附加到它上的任何其他组件。记住，状态机行为仅作为一个资产存在，并不存在于类中，这意味着这是获取运行时类引用（如Mono行为）的最佳方式。'
- en: The animator state info provides information about the state you're currently
    in; however, the uses for this are primarily focused on animation state information,
    so it's not as useful for our application.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画器状态信息提供了关于你当前所在状态的信息；然而，这个用途主要集中在对动画状态信息的处理上，因此对我们应用程序来说并不那么有用。
- en: Lastly, we have the layer index, which is an integer telling us which layer
    within the state machine our state is in. The base layer is index zero, and each
    layer above that is a higher number.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有层索引，它是一个整数，告诉我们我们的状态在状态机中的哪一层。基本层索引为零，并且每个高于该层的层都有一个更高的数字。
- en: Now that we understand the basics of state machine behavior, let's get the rest
    of our components in order. Before we can actually see these behaviors in action,
    we have to go back to our state machine and add some parameters that will drive
    the states.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了状态机行为的基本原理，让我们整理好其余的组件。在我们真正看到这些行为发挥作用之前，我们必须回到我们的状态机并添加一些将驱动状态的参数。
- en: Setting conditions
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置条件
- en: We will need to provide our enemy tank with a few conditions to transitions
    states. These are the actual parameters that will drive the functionality.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为我们的敌人坦克提供一些条件以转换状态。这些是实际驱动功能的参数。
- en: Let's begin with the Patrol state. In order for our enemy tank to go from Patrol
    to Shoot, we need to be in range of the player; in other words, we'll be checking
    the distance between the enemy and the player, which is best represented by a
    float value. So, in your Parameters panel, add a float and name it `distanceFromPlayer`.
    We can also use this parameter to determine whether or not to go into the Chase
    state.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从巡逻状态开始。为了让我们的敌人坦克从巡逻状态切换到射击状态，我们需要在玩家的范围内；换句话说，我们将检查敌人和玩家之间的距离，这最好用浮点值表示。因此，在你的参数面板中添加一个浮点数，并将其命名为
    `distanceFromPlayer`。我们还可以使用此参数来确定是否进入追逐状态。
- en: The Shoot state and the Chase state will share a common condition, which is
    whether or not the player is visible. We'll determine this via a simple raycast,
    which will, in turn, tell us whether the player was in the line of sight or not.
    The best parameter for this is a Boolean, so create a Boolean and call it `isPlayerVisible`.
    Leave the parameter unchecked, which means false.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 射击状态和追逐状态将共享一个共同的条件，即玩家是否可见。我们将通过一个简单的射线投射来确定这一点，这将反过来告诉我们玩家是否在视线范围内。最适合这个的参数是布尔值，因此创建一个布尔值并将其命名为
    `isPlayerVisible`。保持参数未选中，这意味着false。
- en: 'Now we''ll assign the conditions via the transition connectors'' inspector.
    To do this, simply select a connector. When selected, the inspector will display
    some information about the current transition and, most importantly, the conditions,
    which show up as a list. To add a condition, simply click on the + (plus) sign:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过过渡连接器的检查器分配条件。为此，只需选择一个连接器。选择后，检查器将显示有关当前过渡的一些信息，最重要的是条件，它们将显示为一个列表。要添加条件，只需单击+（加号）符号：
- en: '![](img/0cfa3283-8ff5-4cf4-ac4b-27d90596b9ad.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0cfa3283-8ff5-4cf4-ac4b-27d90596b9ad.png)'
- en: 'Let''s tackle each transition one by one:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个解决每个过渡：
- en: Patrol to Chase
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 巡逻追击
- en: distanceFromPlayer < 5
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: distanceFromPlayer < 5
- en: isPlayerVisible == true
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: isPlayerVisible == true
- en: '![](img/8ba46922-e348-4820-8a22-9a4f0f194a5c.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8ba46922-e348-4820-8a22-9a4f0f194a5c.png)'
- en: The Patrol to Chase transition conditions
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 巡逻到追击的转换条件
- en: 'Chase to patrol gets a bit more interesting as we have two *separate* conditions
    that can trigger a transition. If we were to simply add two conditions to that
    transition, both would have to be evaluated to true in order for the transition
    to occur. But we want to check whether the player is out of range or out of sight.
    Luckily, we can have multiple transitions between the same two states. Simply
    add another transition connection as you normally would. Right-click on the Chase
    state and then make a transition to the Patrol state. You''ll notice that you
    now have two transitions listed at the top of the inspector. In addition, your
    transition connection indicator shows multiple arrows instead of just one to indicate
    that there are multiple transitions between these two states. Selecting each transition
    in the inspector will allow you to give each one separate conditions:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 追击巡逻变得更有趣，因为我们有两个**独立**的条件可以触发转换。如果我们简单地在那个转换中添加两个条件，两个条件都必须评估为真，转换才会发生。但我们要检查玩家是否超出范围或看不见。幸运的是，我们可以在相同两个状态之间有多个转换。就像通常那样添加另一个转换连接。在“追击”状态上右键单击，然后转换到“巡逻”状态。你会注意到现在在检查器顶部列出了两个转换。此外，你的转换连接指示器显示多个箭头而不是一个，以表示这两个状态之间存在多个转换。在检查器中选择每个转换，你可以为每个转换设置不同的条件：
- en: Chase to Patrol (A)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追击巡逻（A）
- en: distanceFromPlayer > 5
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: distanceFromPlayer > 5
- en: Chase to Patrol (B)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追击巡逻（B）
- en: isPlayerVisible == false
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: isPlayerVisible == false
- en: Chase to Shoot
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追击射击
- en: distanceFromPlayer < 3
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: distanceFromPlayer < 3
- en: isPlayerVisible == true
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: isPlayerVisible == true
- en: Shoot to Chase
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 射击追击
- en: distanceFromPlayer > 3
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: distanceFromPlayer > 3
- en: distanceFromPlayer < 5
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: distanceFromPlayer < 5
- en: isPlayerVisible == true
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: isPlayerVisible == true
- en: Shoot to Patrol (A)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 射击巡逻（A）
- en: distanceFromPlayer > 6
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: distanceFromPlayer > 6
- en: Shoot to Patrol (B)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 射击巡逻（B）
- en: isPlayerVisible == false
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: isPlayerVisible == false
- en: We now have our states and transitions set. Next, we need to create the script
    that will drive these values. All we need to do is set the values, and the state
    machine will handle the rest.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经设置了状态和转换。接下来，我们需要创建一个脚本，来驱动这些值。我们只需要设置这些值，状态机就会处理其余的部分。
- en: Driving parameters via code
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过代码驱动驾驶参数
- en: Before going any further, we'll need a few things from the assets we imported
    earlier in the chapter. For starters, go ahead and open the `DemoScene` for this
    chapter. You'll notice the scene is fairly stripped down and only contains an
    environment prefab and some waypoint transforms. Go ahead and drop the `EnemyTankPlaceholder`
    prefab into the scene.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要从本章早期导入的资产中获取一些东西。首先，打开本章的`DemoScene`。你会注意到场景相当简化，只包含一个环境预制体和一些航点变换。现在就放下`EnemyTankPlaceholder`预制体到场景中。
- en: You may notice a few components that you may or may not be familiar with on
    the `EnemyTank`. We'll get a chance to thoroughly explore `NavMesh` and `NavMeshAgent`
    in [Chapter 4](503803fe-f343-4a0c-835f-463c98005182.xhtml), *Finding Your Way*,
    but for now, these are necessary components to make the whole thing work. What
    you will want to focus on is the `Animator` component which will house the state
    machine (animator controller) we created earlier. Go ahead and drop the state
    machine into the empty slot before continuing.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到`EnemyTank`上的一些你可能熟悉或不熟悉的组件。我们将在[第4章](503803fe-f343-4a0c-835f-463c98005182.xhtml)“寻找你的路”中彻底探索`NavMesh`和`NavMeshAgent`，但到目前为止，这些是使整个系统工作所必需的组件。你将想要关注的是`Animator`组件，它将包含我们之前创建的状态机（动画控制器）。继续并放下状态机到空槽中，然后继续。
- en: We will also need a placeholder for the player. Go ahead and drop in the `PlayerTankPlaceholder`
    prefab as well. We won't be doing much with this for now. As with the enemy tank
    placeholder prefab, the player tank placeholder prefab has a few components that
    we can ignore for now. Simply place it in the scene and continue.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为玩家设置一个占位符。现在就放一个`PlayerTankPlaceholder`预制体进去。目前我们不会对它做太多操作。就像敌人坦克占位符预制体一样，玩家坦克占位符预制体有几个组件我们现在可以忽略。只需将其放置在场景中，然后继续。
- en: 'Next, you''ll want to add a new component to the `EnemyTankPlaceholder` game
    object—the `TankAi.cs` script, which is located in the `Chapter 2` scripts folder.
    If we open up the script, we''ll find this inside it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要在`EnemyTankPlaceholder`游戏对象上添加一个新的组件——位于`Chapter 2`脚本文件夹中的`TankAi.cs`脚本。如果我们打开脚本，我们会发现它里面是这样的：
- en: '[PRE1]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We have a series of variables that are required to run this script, so we''ll
    run through what they''re for in order:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一系列变量是运行此脚本所必需的，所以我们将逐一说明它们的作用：
- en: '`GameObject player`: This is a reference to the player placeholder prefab we
    dropped in earlier.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameObject player`：这是我们对之前放置的玩家占位符预制体的引用。'
- en: '`Animator animator`: This is the animator for our enemy tank, which contains
    the state machine we created.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Animator animator`：这是我们敌方坦克的动画控制器，其中包含我们创建的状态机。'
- en: '`Ray ray`: This is simply a declaration for a ray that we''ll use in a raycast
    test on our `FixedUpdate` loop.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ray ray`：这是一个用于在 `FixedUpdate` 循环中进行射线投射测试的射线声明。'
- en: '`RaycastHit hit`: This is a declaration for the hit information we''ll receive
    from our raycast test.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RaycastHit hit`：这是一个用于从我们的射线投射测试中接收到的碰撞信息的声明。'
- en: '`Float maxDistanceToCheck`: This number coincides with the value we set in
    our transitions inside the state machine earlier. Essentially, we are saying that
    we''re only checking as far as this distance for the player. Beyond that, we can
    assume that the player is out of range.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Float maxDistanceToCheck`：这个数字与我们之前在状态机中设置的值相匹配。本质上，我们是在说我们只检查玩家这个距离范围内的值。超出这个范围，我们可以假设玩家已经超出范围。'
- en: '`Float currentDistance`: This is the current distance between the player and
    the enemy tanks.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Float currentDistance`：这是玩家和敌方坦克之间的当前距离。'
- en: You'll notice we skipped a few variables. Don't worry, we'll come back to cover
    these later. These are the variables we'll be using for our Patrol state.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们跳过了一些变量。不用担心，我们稍后会回来覆盖这些。这些是我们将在巡逻状态中使用的变量。
- en: Our `Awake` method handles fetching the references to our player and animator
    variables. You can also declare the preceding variables as public or prefix them
    with the `[SerializeField]` attribute and set them via the inspector.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Awake` 方法处理获取玩家和动画控制器变量的引用。你还可以将前面的变量声明为公共的或使用 `[SerializeField]` 属性作为前缀，并通过检查器设置它们。
- en: The `FixedUpdate` method is fairly straightforward; the first part gets the
    distance between the position of the player and the enemy tank. The part to pay
    special attention to is `animator.SetFloat("distanceFromPlayer", currentDistance)`,
    which passes the information from this script into the parameter we defined earlier
    for our state machine. The same is true for the preceding section of the code,
    which passes in the hit result of the raycast as a Boolean. Lastly, it sets the
    `distanceFromTarget` variable, which we'll be using for the Patrol state in the
    next section.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`FixedUpdate` 方法相当直接；第一部分获取玩家位置和敌方坦克之间的距离。需要特别注意的部分是 `animator.SetFloat("distanceFromPlayer",
    currentDistance)`，它将此脚本中的信息传递到我们之前为状态机定义的参数。对于代码的前一部分也是如此，它将射线投射的结果作为布尔值传递。最后，它设置了
    `distanceFromTarget` 变量，我们将在下一节中使用它。'
- en: As you can see, none of the code concerns itself with how or why the state machine
    will handle transitions; it merely passes in the information the state machine
    needs, and the state machine handles the rest. Pretty cool, right?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，没有代码涉及状态机如何或为什么处理转换；它只是传递状态机所需的信息，状态机处理其余部分。很酷，对吧？
- en: Making our enemy tank move
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们的敌方坦克移动
- en: You may have noticed in addition to the variables we didn't cover yet, that
    our tank has no logic in place for moving. This can be easily handled with a substate
    machine, which is a state machine within a state. This may sound confusing at
    first, but we can easily break down the Patrol state into substates. In our example,
    the Patrol state will be in one of the two substates—moving to the current waypoint
    or finding the next waypoint. A waypoint is essentially a destination for our
    agent to move toward. In order to make these changes, we'll need to go into our
    state machine again.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，除了我们尚未覆盖的变量之外，我们的坦克还没有移动逻辑。这可以通过一个子状态机轻松处理，这是一个状态内的状态机。这听起来可能有些令人困惑，但我们可以轻松地将巡逻状态分解为子状态。在我们的例子中，巡逻状态将处于两个子状态之一——移动到当前航标或寻找下一个航标。航标本质上是我们智能体移动的目标。为了进行这些更改，我们需要再次进入我们的状态机。
- en: 'First, create a substate by clicking on an empty area on the canvas and then
    selecting Create Sub-State Machine. Since we already have our original Patrol
    state and all the connections that go with it, we can just drag and drop our Patrol
    state into our newly-created substate to merge the two. As you drag the Patrol
    state over the substate, you''ll notice a plus sign appears by your cursor; this
    means you''re adding one state to the other. When you drop the Patrol state in,
    the new substate will absorb it. Substates have a unique look: they are six-sided
    rather than rectangular. Go ahead and rename the substate to `Patrol`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过在画布上的空白区域单击并选择创建子状态机来创建一个子状态。由于我们已经有原始的Patrol状态及其所有相关连接，我们只需将Patrol状态拖放到新创建的子状态中即可合并这两个状态。当你将Patrol状态拖动到子状态上时，你会注意到光标旁边出现一个加号；这意味着你正在向另一个状态添加一个状态。当你放下Patrol状态时，新的子状态将吸收它。子状态有独特的外观：它们是六边形的而不是矩形的。继续将子状态重命名为`Patrol`：
- en: '![](img/2d2fd838-a0e7-48e1-93bc-17bf4dd0ba99.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2d2fd838-a0e7-48e1-93bc-17bf4dd0ba99.png)'
- en: To enter a substate, simply double-click on it. Think of it as going a level
    lower into the substate. The window will look fairly similar, but you will notice
    a few things—your Patrol state is connected to a node called (Up) Base Layer,
    which essentially is the connection from this level to the upper level that the
    substate machine sits on. The Entry state connects directly to the Patrol state.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入子状态，只需双击它。把它想象成进入子状态的一个层级。窗口看起来相当相似，但你将会注意到一些事情——你的Patrol状态连接到一个名为（Up）Base
    Layer的节点，这实际上是从这个层级到子状态机所在的上层级的连接。入口状态直接连接到Patrol状态。
- en: 'Unfortunately, this is not the functionality we want, as it''s a closed loop
    that doesn''t allow us to get in and out of the state into the individual waypoint
    states we need to create; so let''s make some changes. First, we''ll change the
    name of the substate to `PatrolEntry`. Next, we need to assign some transitions.
    When we enter this Entry state, we want to decide whether to continue moving to
    the current waypoint, or to find a new one. We''ll represent each of the outcomes
    as a state, so create two states, `MovingToTarget` and `FindingNewTarget`, then
    create transitions from the PatrolEntry state to each one of the new states. Likewise,
    you''ll want to create a transition between the two new states, meaning a transition
    from the `MovingToTarget` state to the `FindingNewTarget` state and vice versa.
    Now, add a new float parameter called `distanceFromWaypoint` and set up your conditions
    like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，这不是我们想要的功能，因为它是一个闭环，不允许我们进入和退出状态到我们需要创建的单独航点状态；所以让我们做一些修改。首先，我们将子状态的名字改为`PatrolEntry`。接下来，我们需要分配一些转换。当我们进入这个入口状态时，我们想要决定是继续移动到当前航点，还是找到一个新的航点。我们将每个结果表示为一个状态，因此创建两个状态，`MovingToTarget`和`FindingNewTarget`，然后从PatrolEntry状态到每个新状态创建转换。同样，你也会想要在这两个新状态之间创建一个转换，即从`MovingToTarget`状态到`FindingNewTarget`状态以及相反的转换。现在，添加一个新的浮点参数`distanceFromWaypoint`并设置如下条件：
- en: 'PatrolEntry to MovingToTarget:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从PatrolEntry到MovingToTarget：
- en: distanceFromWaypoint > 1
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: distanceFromWaypoint > 1
- en: 'PatrolEntry to FindingNewTarget:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从PatrolEntry到FindingNewTarget：
- en: distanceFromWaypoint < 1
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: distanceFromWaypoint < 1
- en: 'MovingToTarget to FindingNewTarget:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从MovingToTarget到FindingNewTarget：
- en: distanceFromWaypoint < 1
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: distanceFromWaypoint < 1
- en: You're probably wondering why we didn't assign the transition rule from the
    FindingNewTarget state to the MovingToTarget state. This is because we'll be executing
    some code via state machine behavior and then automatically going into the MovingToTarget
    state without requiring any conditions. Go ahead and select the FindingNewTarget
    state and add a behavior and call it `SelectWaypointState`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们没有将转换规则从FindingNewTarget状态分配到MovingToTarget状态。这是因为我们将通过状态机行为执行一些代码，然后自动进入MovingToTarget状态，而不需要任何条件。继续选择FindingNewTarget状态并添加一个行为，命名为`SelectWaypointState`。
- en: 'Open up the new script and remove all the methods, except for `OnStateEnter`.
    Add the following functionality to it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 打开新的脚本并删除所有方法，除了`OnStateEnter`。向其中添加以下功能：
- en: '[PRE2]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What we're doing here is getting a reference to our `TankAi` script and calling
    its `SetNextPoint()` method. Simple enough, right?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是获取我们的`TankAi`脚本的引用并调用其`SetNextPoint()`方法。很简单，对吧？
- en: Lastly, we need to redo our outgoing connections. Our new states don't have
    transitions out of this level, so we need to add one, using the exact same conditions
    that our PatrolEntry state has, to the (Up) Base Layer state. This is where Any
    State comes in handy—it allows us to transition from any state to another state,
    regardless of individual transition connections, so that we don't have to add
    transitions from each state to the (Up) Base Layer state; we simply add it once
    to the Any State, and we're set! Add a transition from the Any State to the PatrolEntry
    state and use the same conditions the Entry state has to the (Up) Base Layer state.
    This is a workaround for not being able to connect directly from the Any State
    to the (Up) Base Layer state.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要重新设计我们的输出连接。我们的新状态没有从这个级别退出的转换，因此我们需要添加一个，使用与巡逻进入状态相同的条件，到（向上）基本层状态。这就是Any
    State派上用场的地方——它允许我们从任何状态转换到另一个状态，无论是否存在单独的转换连接，这样我们就不必为每个状态添加到（向上）基本层状态的转换；我们只需将其添加一次到Any
    State，就设置好了！从Any State添加一个到巡逻进入状态的转换，并使用与进入状态相同的条件到（向上）基本层状态。这是解决无法直接从Any State连接到（向上）基本层状态的解决方案。
- en: 'When you''re done, your substate machine should look similar to this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，你的子状态机应该看起来类似于这样：
- en: '![](img/69745fef-cf8a-4666-af80-ad859db55fae.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69745fef-cf8a-4666-af80-ad859db55fae.png)'
- en: Testing
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Now, all we have to do is hit play and watch our enemy tank patrol back and forth
    between the two provided waypoints. If we place the player in the editor, in the
    enemy tank's path, we'll see the transition happen in the animator, out of the
    Patrol state and into the Chase state, and when we move the player out of range,
    back into the Patrol state. You'll notice our Chase and Shoot states are not fully
    fleshed out yet. This is because we'll be implementing these states via concepts
    we'll cover in [Chapter 3](25db39aa-6768-453c-855d-9f075da0e83e.xhtml), *Implementing
    Sensors*, and [Chapter 4](503803fe-f343-4a0c-835f-463c98005182.xhtml), *Finding
    Your Way*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需按下播放键，观察我们的敌方坦克在两个提供的航点之间来回巡逻。如果我们把玩家放置在编辑器中，在敌方坦克的路径上，我们会看到在动画器中发生转换，从巡逻状态退出并进入追逐状态，当我们把玩家移出范围时，又回到巡逻状态。你会注意到我们的追逐和射击状态还没有完全完善。这是因为我们将通过我们在[第3章](25db39aa-6768-453c-855d-9f075da0e83e.xhtml)，“实现传感器”，和[第4章](503803fe-f343-4a0c-835f-463c98005182.xhtml)，“找到你的路”中将要介绍的概念来实现这些状态。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to implement state machines in Unity 2017 using
    animator and controller-based state machines for what will be our tank game. We
    learned about state machine behaviors and transitions between states. With all
    of these concepts covered, we then applied the simple state machine to an agent,
    thus creating our first artificially intelligent entity!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在Unity 2017中实现状态机，使用基于动画器和控制器的状态机来构建我们的坦克游戏。我们了解了状态机行为以及状态之间的转换。在掌握了所有这些概念之后，我们将简单的状态机应用于一个智能体，从而创建了我们的第一个人工智能实体！
- en: In the next chapter, we'll continue to build our tank game and give our agent
    more complex methods for sensing the world around it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续构建我们的坦克游戏，并给我们的智能体提供更复杂的方法来感知周围的世界。
