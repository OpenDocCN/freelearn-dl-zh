- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Introducing the Neo4j Spring AI and LangChain4j Frameworks for Building Recommendation
    Systems
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍用于构建推荐系统的Neo4j Spring AI和LangChain4j框架
- en: We looked at Haystack and Python-based intelligent applications in the previous
    chapters. While Python is the favored language framework of data scientists, there
    are scenarios where we might need other frameworks to build solutions. One other
    popular language framework that comes to mind is Java. Java is faster than Python,
    provides integration to various data sources in a seamless manner, and is the
    most used language to build web-based applications along with the Spring Framework.
    For this purpose, we will look at how we can build intelligent applications based
    on **Large Language Models** (**LLMs**) and Neo4j in the next few chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了基于Haystack和Python的智能应用。虽然Python是数据科学家偏爱的语言框架，但在某些场景中，我们可能需要其他框架来构建解决方案。另一个值得考虑的流行语言框架是Java。Java比Python运行速度快，能够以无缝的方式集成到各种数据源中，并且是构建基于Web的应用程序以及Spring框架中最常用的语言。为此，在接下来的几章中，我们将探讨如何基于**大型语言模型**（**LLMs**）和Neo4j构建智能应用。
- en: Also, we have been concentrating on leveraging LLM capabilities to build intelligent
    search applications. This is just one aspect, though; LLMs can also be great tools
    in building and using knowledge graphs to power better recommendation systems.
    In this chapter, we will understand recommendation systems and why personalized
    recommendations are important. We will briefly touch upon the traditional rule-based
    approach for recommendation systems and also talk about some of their shortcomings.
    We will then introduce you to the LangChain4j and Spring AI frameworks and how
    they can support you in building intelligent recommendation systems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们一直专注于利用LLMs的能力来构建智能搜索应用。尽管这只是其中一个方面；LLMs在构建和使用知识图谱以增强推荐系统方面也可以是伟大的工具。在本章中，我们将了解推荐系统以及为什么个性化推荐很重要。我们将简要介绍推荐系统的传统基于规则的途径，并讨论其一些不足之处。然后，我们将向您介绍LangChain4j和Spring
    AI框架，以及它们如何支持您构建智能推荐系统。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding extended Neo4j capabilities to build intelligent applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解扩展的Neo4j能力以构建智能应用
- en: Personalizing recommendations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个性化推荐
- en: Introducing Neo4j’s LangChain4j and Spring AI frameworks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Neo4j的LangChain4j和Spring AI框架
- en: Overview of an intelligent recommendation system in Neo4j GenAI ecosystem
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Neo4j GenAI生态系统中智能推荐系统的概述
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: While this chapter focuses on personalized recommendations and introduces the
    LangChain4j and Spring AI frameworks, there are no specific technical requirements
    for this section.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章重点在于个性化推荐并介绍了LangChain4j和Spring AI框架，但本节没有特定的技术要求。
- en: However, if you are new to Spring applications, you can follow the documentation
    available at [https://spring.io/guides/gs/spring-boot](https://spring.io/guides/gs/spring-boot)
    to get yourself warmed up with Spring Boot. We will be using a Spring Boot application
    with a built-in web framework in the upcoming chapters. You also need Java installed
    on your system. Java 17 or 19 is recommended for the coming chapters.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您对Spring应用还不熟悉，可以参考[https://spring.io/guides/gs/spring-boot](https://spring.io/guides/gs/spring-boot)上的文档来熟悉Spring
    Boot。在接下来的章节中，我们将使用一个带有内置Web框架的Spring Boot应用程序。您还需要在系统上安装Java。推荐使用Java 17或19。
- en: Understanding extended Neo4j capabilities to build intelligent applications
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解扩展的Neo4j能力以构建智能应用
- en: In earlier chapters, we looked at using LLMs and Neo4j to build good search
    applications. While knowledge graphs provide great context for building intelligent
    search applications, they can also be a great foundation for building personalized
    recommendation applications.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了如何使用LLMs和Neo4j构建优秀的搜索应用。虽然知识图谱为构建智能搜索应用提供了很好的上下文，但它们也可以是构建个性化推荐应用的坚实基础。
- en: To extract intelligence from the data and build better, more intelligent applications
    that go beyond basic flow-based analytics, we would need more than graph database
    capabilities. This is where Neo4j’s capabilities as a database can help with building
    better applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从数据中提取智能并构建超越基本流程分析更好、更智能的应用，我们需要比图数据库功能更多的能力。这正是Neo4j作为数据库的能力可以帮助构建更好应用的地方。
- en: 'Some of these capabilities are listed here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些能力如下所示：
- en: '**Scalability**: Neo4j enables us to build large graphs, using sharding to
    build federated graphs to handle large datasets. It can scale to meet data growth
    and business needs while minimizing costs. You can read more about these capabilities
    at [https://neo4j.com/docs/operations-manual/current/database-administration/composite-databases/concepts/](https://neo4j.com/docs/operations-manual/current/database-administration/composite-databases/concepts/).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：Neo4j使我们能够构建大型图，使用分片构建联邦图以处理大型数据集。它能够扩展以满足数据增长和业务需求，同时最小化成本。您可以在[https://neo4j.com/docs/operations-manual/current/database-administration/composite-databases/concepts/](https://neo4j.com/docs/operations-manual/current/database-administration/composite-databases/concepts/)了解更多关于这些功能的信息。'
- en: '**Security**: Neo4j, by leveraging roles, enables data security. There are
    roles that enable security at a high level, such as who can read or write to the
    database. It also provides more granular security controls defining what data
    can be read based on the roles. Using this approach, one user might be looking
    at one part of the graph and another user looking at a different part of the graph
    based on the roles they are assigned. You can read more about these capabilities
    at [https://neo4j.com/docs/operations-manual/current/authentication-authorization/](https://neo4j.com/docs/operations-manual/current/authentication-authorization/).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：通过利用角色，Neo4j实现了数据安全。存在一些角色可以提供高级别的安全性，例如谁可以读取或写入数据库。它还提供了更细粒度的安全控制，根据角色定义可以读取哪些数据。采用这种方法，一个用户可能正在查看图的一部分，而另一个用户根据分配的角色查看图的不同部分。您可以在[https://neo4j.com/docs/operations-manual/current/authentication-authorization/](https://neo4j.com/docs/operations-manual/current/authentication-authorization/)了解更多关于这些功能的信息。'
- en: '**Flexible deployment architecture**: Neo4j’s clustering architecture provides
    multiple options that can be deployed to scale horizontally to handle a higher
    volume of reads and localize reads to different servers, to minimize the cost
    of ownership even as data grows. You can read more about Neo4j’s clustering capabilities
    at [https://neo4j.com/docs/operations-manual/current/clustering/introduction/](https://neo4j.com/docs/operations-manual/current/clustering/introduction/).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活的部署架构**：Neo4j的集群架构提供了多种部署选项，可以水平扩展以处理更高的读取量，并将读取本地化到不同的服务器，以最小化数据增长时的拥有成本。您可以在[https://neo4j.com/docs/operations-manual/current/clustering/introduction/](https://neo4j.com/docs/operations-manual/current/clustering/introduction/)了解更多关于Neo4j集群功能的信息。'
- en: '**Graph Data Science algorithms**: Neo4j Graph Data Science algorithms unlock
    hidden insights from the connected data. These algorithms range from pathfinding,
    node similarity, centrality, and community detection to machine learning aspects
    such as link prediction and node classifications. You can read more about Neo4j
    Graph Data Science’s capabilities at [https://neo4j.com/docs/graph-data-science/current/](https://neo4j.com/docs/graph-data-science/current/).'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图数据科学算法**：Neo4j图数据科学算法能够从连接数据中解锁隐藏的洞察。这些算法涵盖了路径查找、节点相似度、中心性和社区检测，以及机器学习方面的链接预测和节点分类。您可以在[https://neo4j.com/docs/graph-data-science/current/](https://neo4j.com/docs/graph-data-science/current/)了解更多关于Neo4j图数据科学功能的信息。'
- en: '**Vector indexes**: Neo4j provides vector index capabilities, to index embeddings
    to be able to look up similar nodes and then leverage graph traversal to provide
    more accurate results. You can read more about its vector index capabilities at
    [https://neo4j.com/docs/cypher-manual/current/indexes/semantic-indexes/vector-indexes/](https://neo4j.com/docs/cypher-manual/current/indexes/semantic-indexes/vector-indexes/).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向量索引**：Neo4j提供了向量索引功能，以索引嵌入，以便能够查找相似的节点，然后利用图遍历提供更准确的结果。您可以在[https://neo4j.com/docs/cypher-manual/current/indexes/semantic-indexes/vector-indexes/](https://neo4j.com/docs/cypher-manual/current/indexes/semantic-indexes/vector-indexes/)了解更多关于其向量索引功能的信息。'
- en: Neo4j as a graph database makes it easy to work with connected data easily,
    and the preceding capabilities go beyond connected data to help us build intelligent
    applications that are scalable and complex.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 作为图数据库的Neo4j使得轻松处理连接数据变得容易，上述功能超越了连接数据，帮助我们构建可扩展且复杂的智能应用。
- en: '**Note**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: If you want to read more about how search and recommendation systems
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于搜索和推荐系统
- en: 'differ, these articles may be helpful:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文章可能有所帮助：
- en: 'What’s the difference between search and recommendation: [https://medium.com/understanding-recommenders/whats-the-difference-between-search-and-recommendation-c32937506a29](https://medium.com/understanding-recommenders/whats-the-difference-between-search-and-recommendation-c32937506a29)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索和推荐有何区别：[https://medium.com/understanding-recommenders/whats-the-difference-between-search-and-recommendation-c32937506a29](https://medium.com/understanding-recommenders/whats-the-difference-between-search-and-recommendation-c32937506a29)
- en: How are search and recommendations the same, and how are they different?:[https://gist.github.com/veekaybee/2cf54ebcbd72aa73bfe482f20866c6ef](https://gist.github.com/veekaybee/2cf54ebcbd72aa73bfe482f20866c6ef)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索和推荐有何相同之处，有何不同之处？[https://gist.github.com/veekaybee/2cf54ebcbd72aa73bfe482f20866c6ef](https://gist.github.com/veekaybee/2cf54ebcbd72aa73bfe482f20866c6ef)
- en: We will utilize Neo4j capabilities to build an intelligent recommendation system
    in upcoming chapters. Before that, let’s discuss what a recommendation engine
    is and how personalization can help create intelligent recommendation systems.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中利用Neo4j的能力来构建智能推荐系统。在此之前，让我们讨论一下推荐引擎是什么，以及个性化如何帮助创建智能推荐系统。
- en: Personalizing recommendations
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个性化推荐
- en: A **recommendation system** is an application that recommends products to users
    based on their buying and search preferences. This aspect is not limited to just
    product placement but is also used in medical diagnostics and treatment. For example,
    recommendations may help with understanding how patients respond to medication
    and what kind of treatment sequence is more effective.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**推荐系统**是一个基于用户的购买和搜索偏好向用户推荐产品的应用程序。这一方面不仅限于产品定位，还用于医疗诊断和治疗。例如，推荐可以帮助理解患者对药物的反应以及哪种治疗顺序更有效。'
- en: As the data grows and the number of products available increases, the ability
    to understand user behavior and provide the most personal recommendations becomes
    more and more important.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数据的增长和可用产品的增加，理解用户行为并提供最个性化的推荐变得越来越重要。
- en: 'These strategies can be used to build personalized experiences. Some of these
    strategies are mentioned here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些策略可以用来构建个性化体验。以下是一些提到的策略：
- en: '**Building user profiles**: We can build custom user profiles by understanding
    user behavior. Behavior patterns can include the order of transactions made by
    users for a given time period or outcomes of events that occurred, along with
    other attributes such as age, race, and gender. We can use these aspects to segment
    users into various groups and create profiles for each of the groups.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建用户档案**：我们可以通过理解用户行为来构建自定义用户档案。行为模式可以包括用户在特定时间段内进行的交易顺序或事件的结果，以及其他属性，如年龄、种族和性别。我们可以使用这些方面将用户分成不同的组，并为每个组创建档案。'
- en: '**Provide contextual support**: Once the user profiles are available, we should
    be able to provide more meaningful and contextual support to users. This can be
    a recommendation to buy a product based on the last product bought or the next
    medication based on the current treatment level and current symptoms being experienced.
    These recommendations not only consider the last event that occurred but can also
    take other user attributes into account to provide more direct support.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供上下文支持**：一旦有了用户档案，我们就应该能够提供更有意义和上下文相关的支持给用户。这可能包括基于最后一次购买的产品推荐购买产品，或者基于当前治疗水平和当前症状的下一剂药物。这些推荐不仅考虑了最近发生的事件，还可以考虑其他用户属性，以提供更直接的支持。'
- en: '**Provide self-service experiences**: Along with contextual support as needed,
    it is also possible to use the recommendations to provide more satisfactory self-service
    experiences. Users should be able to change the characteristics to be considered
    for recommendations, thus providing a system that adjusts how it responds to events
    for the user.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供自助体验**：除了根据需要提供上下文支持外，还可以使用推荐来提供更令人满意的自我服务体验。用户应该能够更改用于推荐的特性，从而提供一个能够根据用户事件调整其响应方式的系统。'
- en: '**Incorporating feedback**: Using all the preceding strategies, it is possible
    to incorporate both positive and negative feedback so that the system can adapt
    to individual users’ requirements as needed.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整合反馈**：使用所有上述策略，可以整合正面和负面反馈，以便系统能够根据需要适应个别用户的要求。'
- en: Personalized recommendations offer numerous advantages, including suggesting
    the next products based on current views, providing incentives based on user behavior,
    enhancing brand reputation, optimizing treatment regimens for patients, marketing
    new drugs more efficiently, improving supply chain processes, and determining
    optimal delivery routes. These tailored suggestions enable businesses to deliver
    more relevant and impactful experiences to their customers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 个性化推荐提供了许多优势，包括基于当前视图建议下一个产品、根据用户行为提供激励、提升品牌声誉、优化患者治疗方案、更有效地推广新药、改进供应链流程以及确定最佳配送路线。这些定制化建议使企业能够向客户提供更相关和有影响力的体验。
- en: These are some of the ways the recommendations can be used. Some other interesting
    use cases of recommendation systems could be to boost sales ([https://neo4j.com/developer-blog/graphs-acceleration-frameworks-recommendations/](https://neo4j.com/developer-blog/graphs-acceleration-frameworks-recommendations/)),
    manage the supply chain ([https://neo4j.com/developer-blog/supply-chain-neo4j-gds-bloom/](https://neo4j.com/developer-blog/supply-chain-neo4j-gds-bloom/)),
    and carry out patient journey mapping ([https://www.graphable.ai/blog/patient-journey-mapping/](https://www.graphable.ai/blog/patient-journey-mapping/)).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些推荐可以使用的方法。推荐系统的一些其他有趣的用例可能包括提升销售额([https://neo4j.com/developer-blog/graphs-acceleration-frameworks-recommendations/](https://neo4j.com/developer-blog/graphs-acceleration-frameworks-recommendations/))、管理供应链([https://neo4j.com/developer-blog/supply-chain-neo4j-gds-bloom/](https://neo4j.com/developer-blog/supply-chain-neo4j-gds-bloom/))以及执行患者旅程映射([https://www.graphable.ai/blog/patient-journey-mapping/](https://www.graphable.ai/blog/patient-journey-mapping/))。
- en: Let’s take a look at the traditional rule-based approach for recommendation
    systems and why this approach is not sufficient for building intelligent and personalized
    recommendation systems.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看传统的基于规则的推荐系统方法以及为什么这种方法对于构建智能和个性化的推荐系统来说是不够的。
- en: Limitations of traditional approaches
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统方法的局限性
- en: Traditionally, recommendation systems used **rule-based systems**. A rule-based
    system is one where the decision is made by executing a set of rules based on
    the data input provided. The logic can be simple, or it can be very complex based
    on the need. For example, any credit card transaction that is more than $1,000
    in certain regions will be denied automatically. A slightly more complex rule
    can be to deny a transaction when a small transaction is successfully carried
    out and then a bigger transaction is attempted.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，推荐系统使用**基于规则的系统**。基于规则的系统是指决策是通过执行基于提供的数据输入的一组规则来做出的。逻辑可以是简单的，也可以根据需要非常复杂。例如，在特定地区，任何超过1000美元的信用卡交易都会自动拒绝。一个稍微复杂一些的规则可能是，当一个小交易成功执行后，然后尝试进行大交易时，会拒绝该交易。
- en: 'Rule-based systems usually apply two kinds of rules:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 基于规则的系统通常应用两种类型的规则：
- en: '**Static rules**: Here, rules are configured manually. Once these rules are
    in place, they work very efficiently and the system can execute them faithfully.
    They are good when you require fast responses with the least number of resources
    consumed. They can be as simple as case statements returning a value based on
    input.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态规则**：在这里，规则是手动配置的。一旦这些规则被设置好，它们可以非常高效地工作，系统可以忠实执行它们。当您需要快速响应且资源消耗最少时，它们是好的。它们可以像基于输入返回值的case语句一样简单。'
- en: '**Dynamic rules**: These are sophisticated rule engines. In these scenarios,
    the next decision made can be dependent on in which state the current decision
    tree lies and the next data input.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态规则**：这些是复杂的规则引擎。在这些情况下，下一个决策可以依赖于当前决策树所处的状态和下一个数据输入。'
- en: 'Some of the benefits of using rule-based systems are as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于规则的系统的一些好处如下：
- en: '**Consistency**: They are consistent in their behavior and guarantee that for
    a given input or set of inputs, the output is the same.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：它们的行为是一致的，并保证对于给定的输入或输入集，输出是相同的。'
- en: '**Scaling**: These systems can scale very well to handle data and complexity
    with ease.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：这些系统可以很好地扩展以轻松处理数据和复杂性。'
- en: '**Efficient**: These are very efficient in terms of resources consumed and
    the cost of the system.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高效**：在资源消耗和系统成本方面，它们非常高效。'
- en: '**Maintenance and management**: These are easier to build and maintain. This
    in turn makes it easy to manage these systems.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**维护和管理**：这些规则更容易构建和维护。这反过来使得管理这些系统变得容易。'
- en: 'Typically, use cases of these systems are fraud prevention and cybersecurity.
    While these systems are simple and easy to build, there are limitations to them.
    Some are listed here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些系统的用例是欺诈预防和网络安全。虽然这些系统简单且易于构建，但它们存在局限性。以下是一些例子：
- en: '**Complexity**: They can grow to be pretty complex as the business needs increase,
    if not handled correctly. With the added complexity, most of the benefits will
    slowly start to vanish.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性**：如果处理不当，随着业务需求的增加，它们可能会变得相当复杂。随着复杂性的增加，大多数好处将逐渐开始消失。'
- en: '**Rigidness**: The system is too rigid to adapt to new types of data and scenarios.
    Even when we identify new scenarios, coding and configuring them might take too
    long for them to be effective.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**僵化性**：系统过于僵化，难以适应新的数据类型和场景。即使我们识别出新的场景，编码和配置它们可能也需要太长时间才能有效。'
- en: '**Business needs adaptability**: It might take too much effort to adapt these
    systems to the growing business needs and requirements.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务需求适应性**：适应不断增长的业务需求和要求的这些系统可能需要太多的努力。'
- en: As we can see, as business needs evolve, we are stuck with limited options when
    relying on rule-based systems. It becomes more important to build an intelligent
    application that can adapt to the new data points as well as data complexity to
    provide better context to give good recommendations. These systems should be more
    adaptable to changing environments, data, as well as new requirements in a quick
    fashion.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，随着业务需求的发展，当我们依赖于基于规则的系统时，我们会陷入有限的选项。构建一个能够适应新的数据点和数据复杂性，以提供更好的上下文并给出良好建议的智能应用变得越来越重要。这些系统应该能够快速适应不断变化的环境、数据和新的要求。
- en: This is where Neo4j as a graph database and the surrounding technology stack
    help us to build intelligent recommendation systems. Let’s find out how.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这里，Neo4j 作为图数据库及其周围的技术堆栈帮助我们构建智能推荐系统。让我们来看看如何实现。
- en: Introducing Neo4j’s LangChain4j and Spring AI frameworks
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Neo4j 的 LangChain4j 和 Spring AI 框架
- en: To build intelligent applications, we can utilize multiple frameworks available
    around Neo4j. For the specific use case of intelligent recommendation systems,
    we will take a look at the Java frameworks Spring AI and LangChain4j.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建智能应用，我们可以利用围绕 Neo4j 可用的多个框架。对于智能推荐系统的特定用例，我们将探讨 Java 框架 Spring AI 和 LangChain4j。
- en: LangChain4j
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LangChain4j
- en: '**LangChain4j** ([https://github.com/langchain4j/](https://github.com/langchain4j/))
    is a Java framework inspired by the popular Python LangChain framework to build
    LLM applications in Java. Its goal is to simplify integrating LLM APIs into Java
    applications. Toward that, it builds an API that is a blend of LangChain, Haystack,
    LlamaIndex, and other concepts and adds its own flavor to build complex applications.
    This is how it achieves these objectives.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**LangChain4j** ([https://github.com/langchain4j/](https://github.com/langchain4j/))
    是一个受流行的 Python LangChain 框架启发的 Java 框架，用于在 Java 中构建 LLM 应用程序。其目标是简化将 LLM API 集成到
    Java 应用程序中。为此，它构建了一个结合了 LangChain、Haystack、LlamaIndex 和其他概念的 API，并为构建复杂应用增添了独特的风味。这就是它实现这些目标的方式。'
- en: 'The following list helps us understand how it achieves these objectives:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表帮助我们了解它是如何实现这些目标的：
- en: '**Unified APIs**: All the LLM providers, such as Open AI and Google Gemini,
    have their own proprietary APIs to build applications. Vector stores such as Neo4j,
    Pinecone, and Milvus also provide their own APIs to store and retrieve the embeddings.
    LangChain4j provides a unified API to hide the complexity of all these APIs to
    make development easier.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一API**：所有大型语言模型（LLM）提供商，如 Open AI 和 Google Gemini，都有自己的专有API来构建应用程序。像 Neo4j、Pinecone
    和 Milvus 这样的向量存储也提供自己的API来存储和检索嵌入。LangChain4j 提供了一个统一的API，以隐藏所有这些API的复杂性，使开发更加容易。'
- en: '**Comprehensive toolbox**: The LangChain community has identified various patterns,
    abstractions, and techniques to build numerous LLM applications and examples in
    ready-to-use packages to jumpstart development. Its toolbox includes examples
    of low-level prompt templates, chat memory management, AI services, and RAG. Most
    of these examples are ready for easy integration into other applications.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全面的工具箱**：LangChain 社区已经识别出各种模式、抽象和技术，以构建大量的 LLM 应用程序和示例，并提供现成的包以加速开发。其工具箱包括低级提示模板、聊天内存管理、AI
    服务和 RAG 的示例。其中大部分示例都易于集成到其他应用程序中。'
- en: 'LangChain4j provides the following features that help us in building intelligent
    applications:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: LangChain4j 提供以下功能，帮助我们构建智能应用：
- en: '**More than 15 LLM providers**: LangChain4j provides a simple API to integrate
    the LLM providers into an application and use them easily. You can read more about
    the language model integrations at [https://docs.langchain4j.dev/category/language-models](https://docs.langchain4j.dev/category/language-models).'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超过15个LLM提供商**：LangChain4j提供了一个简单的API，将LLM提供商集成到应用中并轻松使用。您可以在[https://docs.langchain4j.dev/category/language-models](https://docs.langchain4j.dev/category/language-models)上了解更多关于语言模型集成的内容。'
- en: '**More than 20 vector stores**: The vector store API allows storing the embeddings
    generated and querying them. Here is the vector store API for you to look at:
    [https://docs.langchain4j.dev/tutorials/embedding-stores](https://docs.langchain4j.dev/tutorials/embedding-stores).'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超过20个向量存储**：向量存储API允许存储生成的嵌入并查询它们。以下是您要查看的向量存储API：[https://docs.langchain4j.dev/tutorials/embedding-stores](https://docs.langchain4j.dev/tutorials/embedding-stores)。'
- en: '**AI services**: LangChain4j has low-level APIs, such as those that directly
    interact with LLM providers and vector stores. But that might be too low level
    for some scenarios. To make things simple, it also provides more high-level API
    flows to integrate LLMs, vector stores, embedding models, and RAG as a pipeline.
    These are called AI services ([https://docs.langchain4j.dev/tutorials/ai-services](https://docs.langchain4j.dev/tutorials/ai-services)).
    We will use AI Services in the upcoming chapters.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AI服务**：LangChain4j提供了低级API，例如直接与LLM提供商和向量存储交互的API。但对于某些场景来说，这可能太底层了。为了简化操作，它还提供了更高级的API流程来集成LLM、向量存储、嵌入模型和RAG作为管道。这些被称为AI服务([https://docs.langchain4j.dev/tutorials/ai-services](https://docs.langchain4j.dev/tutorials/ai-services))。我们将在接下来的章节中使用AI服务。'
- en: '**RAG**: LangChain4j provides support for the RAG indexing, as well as RAG
    retrieval, stage. It has a simple **Easy RAG** feature that makes it easy to get
    started with RAG features. You can read more about the RAG capabilities provided
    by LangChain4j at [https://docs.langchain4j.dev/tutorials/rag](https://docs.langchain4j.dev/tutorials/rag).'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RAG**：LangChain4j提供了对RAG索引和检索阶段的支持。它有一个简单的**Easy RAG**功能，使得开始使用RAG功能变得容易。您可以在[https://docs.langchain4j.dev/tutorials/rag](https://docs.langchain4j.dev/tutorials/rag)上了解更多关于LangChain4j提供的RAG能力。'
- en: LangChain4j has good integration with the Spring Framework. But the Apache Spring
    framework has also built a separate AI integration framework similar to LangChain4j,
    called Spring AI. We will take a look at this framework next.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: LangChain4j与Spring框架有良好的集成。但Apache Spring框架也构建了一个类似于LangChain4j的独立AI集成框架，称为Spring
    AI。我们将在下一节中查看这个框架。
- en: Spring AI
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring AI
- en: '**Spring AI** is inspired by LangChain4j and LlamaIndex. While LangChain4j
    supports simple Java applications as well as Spring applications, Spring AI is
    optimized to work with Spring Framework. This means those who are well versed
    in the Spring Framework can develop LLM applications faster and easier.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring AI**受到LangChain4j和LlamaIndex的启发。虽然LangChain4j支持简单的Java应用以及Spring应用，但Spring
    AI针对与Spring框架协同工作进行了优化。这意味着熟悉Spring框架的开发者可以更快、更轻松地开发LLM应用。'
- en: 'Since the Spring Framework provides multiple modules to connect to various
    databases and coding patterns that are well defined and used by a lot of developers,
    this new feature makes it very easy for developers to adopt and build AI applications
    quickly. Some of the Spring AI capabilities that can help us in building intelligent
    applications are as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Spring框架提供了多个模块来连接各种数据库和许多开发者定义和使用的良好编码模式，这个新特性使得开发者能够非常容易地采用并快速构建AI应用。以下是一些Spring
    AI能力，它们可以帮助我们构建智能应用：
- en: '**LLM prompt templates**: LLM prompt templates provide a simple API to integrate
    LLMs easily.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LLM提示模板**：LLM提示模板提供了一个简单的API，以便轻松集成LLM。'
- en: '**Embedding models**: Spring AI can integrate various embedding model engines
    using configuration to generate vector embeddings.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌入模型**：Spring AI可以通过配置集成各种嵌入模型引擎，以生成向量嵌入。'
- en: '**Vector stores**: Spring AI also provides simple APIs to store and query vector
    stores. It provides easy, configuration-based integration to connect to various
    vector stores, such as Neo4j, Pinecone, and Milvus.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向量存储**：Spring AI还提供了简单的API来存储和查询向量存储。它提供了基于配置的简单集成，以便连接到各种向量存储，如Neo4j、Pinecone和Milvus。'
- en: '**RAG**: You can also chain LLM prompt templates, embedding models, and vector
    stores to build effective RAG applications with Spring AI.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RAG**：您还可以使用Spring AI将LLM提示模板、嵌入模型和向量存储链接起来，构建有效的RAG应用。'
- en: Both the LangChain4j and Spring AI frameworks provide core APIs to integrate
    with LLM chat models, prompt templates, embedding models, and vector stores. Along
    with providing the low-level APIs to talk with those systems, they also make it
    easy to build more sophisticated applications using higher-level APIs, such as
    RAG framework APIs.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: LangChain4j和Spring AI框架都提供了核心API，用于与LLM聊天模型、提示模板、嵌入模型和向量存储集成。除了提供与这些系统通信的低级API外，它们还使使用高级API（如RAG框架API）构建更复杂的应用程序变得容易。
- en: Why Java-based frameworks?
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么选择基于Java的框架？
- en: There are a lot of frameworks in Python that can work with Neo4j. But there
    are a lot of applications that use Java frameworks. These frameworks provide a
    means to connect to various data sources, leveraging various packages available
    to build complex applications.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中有很多框架可以与Neo4j协同工作。但是，有很多应用程序使用Java框架。这些框架提供了一种连接到各种数据源的方式，利用各种可用的包来构建复杂的应用程序。
- en: These frameworks support various vector stores, such as Neo4j, and multiple
    LLM providers, such as Amazon Bedrock, Azure OpenAI, Google Gemini, Hugging Face,
    and OpenAI. They offer high-level AI capabilities, from simple tasks such as formatting
    inputs and parsing outputs for LLMs to more complex features such as chat memory,
    tools, and RAG.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些框架支持各种向量存储，如Neo4j，以及多个LLM提供商，如Amazon Bedrock、Azure OpenAI、Google Gemini、Hugging
    Face和OpenAI。它们提供高级AI功能，从简单的任务，如为LLM格式化输入和解析输出，到更复杂的功能，如聊天记忆、工具和RAG。
- en: By combining these capabilities with Neo4j, these frameworks make it easier
    to build more complex applications, such as generating embeddings for graph features
    (paths, etc.) using LLMs, which can form the basis for enhancing the graph using
    similarity and community detection algorithms to group nodes into segments. This
    segmentation can provide the basis for next-level recommendations and other aspects.
    You can read more about Neo4j’s GenAI ecosystem at [https://neo4j.com/labs/genai-ecosystem/](https://neo4j.com/labs/genai-ecosystem/).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这些能力与Neo4j结合，这些框架使构建更复杂的应用程序变得更容易，例如使用LLM生成图特征（路径等）的嵌入，这可以作为使用相似性和社区检测算法将节点分组到段的基础，以增强图谱。这种分段可以提供下一级推荐和其他方面的基础。您可以在[https://neo4j.com/labs/genai-ecosystem/](https://neo4j.com/labs/genai-ecosystem/)了解更多关于Neo4j的GenAI生态系统信息。
- en: Overview of an intelligent recommendation system in Neo4j GenAI ecosystem
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Neo4j GenAI生态系统中的智能推荐系统概述
- en: Let us look at how recommendation systems that are built on LLM/RAG principles
    would function in the Neo4j GenAI ecosystem (*Figure 7.1*).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看基于LLM/RAG原则构建的推荐系统在Neo4j GenAI生态系统中的运作方式（*图7.1*）。
- en: '![Figure 7.1 — Neo4j RAG recommendation architecture](img/B31107_07_1.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 — Neo4j RAG推荐架构](img/B31107_07_1.png)'
- en: Figure 7.1 — Neo4j RAG recommendation architecture
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 — Neo4j RAG推荐架构
- en: We can leverage the features of these frameworks to build RAG applications backed
    by knowledge graphs. In this architecture, we are leveraging the Spring AI app
    to augment the graph to be able to provide more personal recommendations.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这些框架的特性来构建基于知识图谱的RAG应用程序。在这个架构中，我们利用Spring AI应用程序来增强图谱，以便能够提供更多个性化的推荐。
- en: Also, for RAG, this architecture can leverage the vector indices as well as
    graph traversal to augment the response, to get the best of both worlds to get
    more accurate responses. This concept is called **G****raph RAG**. Knowledge graphs
    can bring more accurate responses, rich context, and explainability for AI model
    interactions. Neo4j can integrate into LangChain4j and Spring AI to act as a vector
    store as well as a graph database to augment the LLM responses.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于RAG，这个架构可以利用向量索引以及图遍历来增强响应，以获得两者的最佳效果，从而获得更准确的响应。这个概念被称为**G****raph RAG**。知识图谱可以为AI模型交互带来更准确的响应、丰富的上下文和可解释性。Neo4j可以集成到LangChain4j和Spring
    AI中，作为向量存储以及图数据库，以增强LLM的响应。
- en: Summary
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the capabilities of Neo4j that help us build intelligent
    applications, why the personalization that these applications can provide is useful,
    and how they are different from the existing rule-based applications. We looked
    at what Spring AI and LangChain4j are and their capabilities to build intelligent
    applications.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Neo4j帮助我们构建智能应用程序的能力，为什么这些应用程序可以提供的个性化是有用的，以及它们与现有的基于规则的应用程序有何不同。我们探讨了Spring
    AI和LangChain4j是什么，以及它们构建智能应用程序的能力。
- en: In the next chapter, [*Chapter 8*](Chapter_08.xhtml#_idTextAnchor058), we will
    build a graph data model to support intelligent and personalized recommendations
    with the H&M dataset and see how this data can be loaded into a graph data model
    with the aim of providing recommendations. [*Chapter 9*](Chapter_09.xhtml#_idTextAnchor059)
    of this book will enable you to integrate this intelligent recommendation system
    with the Spring AI and LangChain4j frameworks.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[*第8章*](Chapter_08.xhtml#_idTextAnchor058)，我们将使用H&M数据集构建一个图数据模型，以支持智能和个性化的推荐，并了解如何将此类数据加载到图数据模型中，目的是提供推荐。本书的[*第9章*](Chapter_09.xhtml#_idTextAnchor059)将使您能够将这个智能推荐系统集成到Spring
    AI和LangChain4j框架中。
