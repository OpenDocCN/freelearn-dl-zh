- en: Chapter 5. Finding Spans in Text – Chunking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：在文本中查找跨度—分块
- en: 'This chapter covers the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下内容：
- en: Sentence detection
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 句子检测
- en: Evaluation of sentence detection
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 句子检测的评估
- en: Tuning sentence detection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整句子检测
- en: Marking embedded chunks in a string – sentence chunk example
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在字符串中标记嵌套的分块—句子分块示例
- en: Paragraph detection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 段落检测
- en: Simple noun phrases and verb phrases
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的名词短语和动词短语
- en: Regular expression-based chunking for NER
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于正则表达式的命名实体识别（NER）分块
- en: Dictionary-based chunking for NER
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于词典的NER分块
- en: Translating between word tagging and chunks – BIO codec
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单词标注和分块之间转换—BIO编解码器
- en: HMM-based NER
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于隐马尔可夫模型（HMM）的NER
- en: Mixing the NER sources
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合NER数据源
- en: CRFs for chunking
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于分块的条件随机场（CRFs）
- en: NER using CRFs with better features
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更好的特征的条件随机场（CRFs）进行NER
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'This chapter will tell us how to work with spans of text that typically cover
    one or more words/tokens. The LingPipe API represents this unit of text as a chunk
    with corresponding chunkers that produce chunkings. The following is some text
    with character offsets indicated:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将告诉我们如何处理通常涵盖一个或多个单词/标记的文本跨度。LingPipe API将这种文本单元表示为分块，并使用相应的分块器生成分块。以下是一些带有字符偏移的文本：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Chunking the preceding text into sentences will give us the following output:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的文本分块成句子将会得到如下输出：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Adding in a chunking for named entities adds entities for LingPipe and Java:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为命名实体添加分块，增加了LingPipe和Java的实体：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can define the named-entity chunkings with respect to their offsets from
    the sentences that contain them; this will make no difference to LingPipe, but
    Java will be:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据命名实体的偏移量来定义命名实体分块；这对LingPipe没有影响，但对Java而言会有所不同：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is the basic idea of chunks. There are lots of ways to make them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是分块的基本思路。有很多方法可以构建它们。
- en: Sentence detection
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 句子检测
- en: Sentences in written text roughly correspond to a spoken utterance. They are
    the standard unit of processing words in industrial applications. In almost all
    mature NLP applications, sentence detection is a part of the processing pipeline
    even in the case of tweets, which can have more than one sentence in the allotted
    140 characters.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 书面文本中的句子大致对应于口头表达。它们是工业应用中处理单词的标准单元。在几乎所有成熟的NLP应用程序中，即使是推文（可能在限定的140字符内有多个句子），句子检测也是处理管道的一部分。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'As usual, we will play with some data first. Enter the following command in
    the console:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和往常一样，我们首先将玩一些数据。请在控制台输入以下命令：
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The program will provide a prompt for your sentence-detection experimentation.
    A new line / return terminates the text to be analyzed:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序将为您的句子检测实验提供提示。按下回车/换行键结束待分析的文本：
- en: '[PRE5]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It is worth playing around a bit with different inputs. The following are some
    examples that explore the properties of the sentence detector. Drop the capitalized
    beginning of a sentence; this will prevent the detection of the second sentence:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值得尝试不同的输入。以下是一些示例，用于探索句子检测器的特性。去掉句子开头的首字母大写；这样就能防止检测到第二个句子：
- en: '[PRE6]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The detector does not require a final period—this is configurable:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检测器不需要结束句号—这是可配置的：
- en: '[PRE7]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The detector balances parentheses, which will not allow sentences to break
    inside parentheses—this is also configurable:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检测器平衡括号，这样就不会让句子在括号内断开—这也是可配置的：
- en: '[PRE8]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This sentence detector is a heuristic-based or rule-based sentence detector.
    A statistical sentence detector would be a reasonable approach as well. We will
    get through the entire source to run the detector, and later, we will discuss
    the modifications:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个句子检测器是基于启发式或规则的句子检测器。统计句子检测器也是一个合理的方案。我们将遍历整个源代码来运行检测器，稍后我们会讨论修改：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Working from the top of the `main` class, the Boolean `endSent` parameter controls
    whether the string that is sentence detected is assumed to end with a sentence,
    no matter what—this means that the last character is a sentence boundary always—it
    does not need to be a period or other typical sentence-ending mark. Change it
    and try a sentence without a final period, and the result will be that no sentence
    is detected.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从`main`类的顶部开始，布尔类型的`endSent`参数控制是否假定被检测的句子字符串以句子结尾，无论如何—这意味着最后一个字符始终是句子边界—它不一定是句号或其他典型的句子结束符号。改变它，试试没有结束句号的句子，结果将是没有检测到句子。
- en: 'The next Boolean `parenS` declaration gives priority to parentheses over sentence
    makers when finding sentences. Next, the actual sentence chunker will be set up:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的布尔值`parenS`声明在寻找句子时优先考虑括号，而不是句子标记符。接下来，实际的句子分块器将被设置：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `tokFactory` should be familiar to you from [Chapter 2](ch02.html "Chapter 2. Finding
    and Working with Words"), *Finding and Working with Words*. The `sentenceChunker`
    then can be constructed. Following is the standard I/O code for command-line interaction:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`tokFactory`应该对你来说并不陌生，来自[第2章](ch02.html "第2章 查找和处理单词")，*查找和处理单词*。然后可以构建`sentenceChunker`。以下是标准的命令行交互输入/输出代码：'
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once we have the text, then the sentence detector is applied:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到了文本，句子检测器就会被应用：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The chunking provides a `Set<Chunk>` parameter, which will noncontractually
    provide an appropriate ordering of `Chunks`; they will be added as per the `ChunkingImpl`
    Javadoc. The truly paranoid programmer might impose the proper sort order, which
    we will cover later in the chapter when we have to handle overlapping chunks.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分块操作提供了一个`Set<Chunk>`参数，它非正式地提供了`Chunks`的适当排序；它们将根据`ChunkingImpl`的Javadoc进行添加。真正偏执的程序员可能会强制执行正确的排序，我们将在本章后面讨论如何处理重叠的分块。
- en: 'Next, we will check to see if any sentences were found, and if we don''t find
    them, we will report to the console:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查是否找到了任何句子，如果没有找到，我们将向控制台报告：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following is the first exposure to the `Chunker` interface in the book,
    and a few comments are in order. The `Chunker` interface generates the `Chunk`
    objects, which are typed and scored contiguous-character sequences over `CharSequence`—usually,
    `String`. `Chunks` can overlap. The `Chunk` objects are stored in `Chunking`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是书中首次介绍`Chunker`接口，并且有一些评论需要说明。`Chunker`接口生成`Chunk`对象，这些对象是通过`CharSequence`（通常是`String`）上的连续字符序列，带有类型和得分的。`Chunks`可以重叠。`Chunk`对象被存储在`Chunking`中：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we recovered the underlying text string `textStored` that the chunks
    are based on. It is the same string as `text`, but we wanted to illustrate this
    potentially useful method of the `Chunking` class, which can come up in recursive
    or other contexts when the chunking is far removed from where `CharSequence` that
    it uses is unavailable.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们恢复了基础文本字符串`textStored`，它是`Chunks`的基础。它与`text`相同，但我们希望说明`Chunking`类中这个可能有用的方法，这个方法在递归或其他上下文中可能会出现，其中`CharSequence`可能不可用。
- en: The remaining `for` loop iterates over the sentences and prints them out with
    the `substring()` method of `String`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的`for`循环遍历句子并使用`String`的`substring()`方法将其打印出来。
- en: There's more...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Before moving on to how to roll your own sentence detector, it is worth mentioning
    that LingPipe has `MedlineSentenceModel`, which is oriented towards the kind of
    sentences found in the medical research literature. It has seen a lot of data
    and should be a starting place for your own sentence-detection efforts over these
    kinds of data.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在讲解如何创建自己的句子检测器之前，值得一提的是LingPipe有一个`MedlineSentenceModel`，它专门处理医学研究文献中常见的句子类型。它已经处理了大量数据，应该是你在这类数据上进行句子检测的起点。
- en: Nested sentences
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套句子
- en: 'Sentences, particularly in literature, can contain nested sentences. Consider
    the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在文学作品中，句子可能包含嵌套的句子。考虑以下内容：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding sentence will be marked up properly as:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 前述句子将被正确标注为：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This sort of nesting is different from a linguist''s concept of a nested sentence,
    which is based on grammatical role. Consider the following example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种嵌套与语言学中嵌套句子的概念不同，后者是基于语法角色的。考虑以下例子：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This sentence consists of two linguistically complete sentences joined by `and`.
    The difference between the two is that the former is determined by punctuation
    and the latter by a grammatical function. Whether this distinction is significant
    or not can be debated. However, the former case is much easier to recognize programmatically.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个句子由两个在语言学上完整的句子通过`and`连接而成。两者的区别在于前者是由标点符号决定的，后者则由语法功能决定。这个区别是否重要可以讨论。然而，前者的情况在编程中更容易识别。
- en: However, we have rarely needed to model nested sentences in industrial contexts,
    but we took it on in our MUC-6 system and various coreference resolution systems
    in research contexts. This is beyond the scope of a recipe book, but be aware
    of the issue. LingPipe has no out-of-the-box capabilities for nested sentence
    detection.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在工业环境中我们很少需要建模嵌套句子，但在我们的MUC-6系统和各种共指解析研究系统中，我们已经涉及过此问题。这超出了食谱书的范围，但请注意这个问题。LingPipe没有开箱即用的嵌套句子检测功能。
- en: Evaluation of sentence detection
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 句子检测的评估
- en: Like most of the things we do, we want to be able to evaluate the performance
    of our components. Sentence detection is no different. Sentence detection is a
    span annotation that differs from our previous evaluations for classifiers and
    tokenization. As text can have characters that are not in any sentence, there
    is a notion of sentence start and sentence end. An example of characters that
    don't belong in a sentence will be JavaScript from an HTML page.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们做的大多数事情一样，我们希望能够评估组件的性能。句子检测也不例外。句子检测是一种跨度注释，区别于我们之前对分类器和分词的评估。由于文本中可能有不属于任何句子的字符，因此存在句子开始和句子结束的概念。一个不属于句子的字符示例是来自HTML页面的JavaScript。
- en: The following recipe will take you through the steps of creating evaluation
    data and running it past an evaluation class.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将引导你完成创建评估数据并通过评估类运行它的步骤。
- en: How to do it...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to evaluate sentence detection:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来评估句子检测：
- en: Open a text editor and copy and paste some literary gem that you want to evaluate
    sentence detection with, or you can go with our supplied default text, which is
    used if you don't provide your own data. It is easiest if you stick to plain text.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文本编辑器，复制并粘贴一些你想用来评估句子检测的文学作品，或者你可以使用我们提供的默认文本，如果没有提供自己的数据，则会使用此文本。最简单的方法是使用纯文本。
- en: 'Insert balanced `[` and `]` to indicate the beginnings and ends of sentences
    in the text. If the text already contains either `[` or `]`, pick another character
    that is not in the text as a sentence delimiter—curly brackets or slashes are
    a good choice. If you use different delimiters, you will have to modify the source
    appropriately and recreate the JAR file. The code assumes a single-character text
    delimiter. An example of a sentence-annotated text from *The Hitchhiker''s Guide
    to the Galaxy* is as follows—note that not every character is in a sentence; some
    whitespaces are between sentences:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入平衡的`[`和`]`来标识文本中句子的开始和结束。如果文本中已经包含`[`或`]`，请选择文本中没有的其他字符作为句子分隔符——大括号或斜杠是不错的选择。如果使用不同的分隔符，您需要相应地修改源代码并重新创建JAR文件。代码假设使用单字符文本分隔符。以下是来自《银河系漫游指南》的句子注释文本示例——注意并非每个字符都在句子中；一些空格位于句子之间：
- en: '[PRE18]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Get yourself a command line and run the following command:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行并运行以下命令：
- en: '[PRE19]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For this data, the code will display two sentences that match perfectly with
    the sentences annotated with `[]`, as indicated by the `TruePos` label.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这些数据，代码将显示两个完美匹配的句子，这些句子与用`[]`注释的句子一致，正如`TruePos`标签所示。
- en: 'A good exercise is to modify the annotation a bit to force errors. We will
    move the first sentence boundary one character in:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个好的练习是稍微修改注释以强制产生错误。我们将第一个句子边界向前移动一个字符：
- en: '[PRE20]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Rerunning the modified annotation file after saving it yields:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并重新运行修改后的注释文件后，结果如下：
- en: '[PRE21]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By changing the truth annotation, a false negative is produced, because the
    sentence span was missed by one character. In addition, a false positive is created
    by the sentence detector that recognizes the 0-83 character sequence.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过改变真值注释，会产生一个假阴性，因为句子跨度错过了一个字符。此外，由于句子检测器识别了0-83字符序列，产生了一个假阳性。
- en: It is a good idea to play around with the annotation and various kinds of data
    to get a feel of how evaluation works and the capabilities of the sentence detector.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过与注释和各种数据的交互，了解评估的工作原理以及句子检测器的能力是一个好主意。
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The class starts by digesting the annotated text and storing the sentence chunks
    in an evaluation object. Then, the sentence detector is created, just as we did
    in the previous recipe. The code finishes by applying the created sentence detector
    to the text, and the results are printed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该类从消化注释文本并将句子块存储到评估对象开始。然后，创建句子检测器，就像我们在前面的示例中所做的那样。代码最后通过将创建的句子检测器应用于文本，并打印结果。
- en: Parsing annotated data
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析注释数据
- en: 'Given text annotated with `[]` for sentence boundaries means that the correct
    offsets of the sentences have to be recovered, and the original unannotated text
    must be created, that is, without any `[]`. Span parsers can be a bit tricky to
    code, and the following is offered for simplicity rather than efficiency or proper
    coding technique:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 给定带有`[]`注释的文本表示句子边界，这意味着必须恢复句子的正确偏移量，并且必须创建原始的未注释文本，即没有任何`[]`。跨度解析器编写起来可能有些棘手，以下代码为了简化而不是为了效率或正确的编程技巧：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding code reads in the entire file as a single `char[]` array with
    an appropriate character encoding. Also, note that for large files, a streaming
    approach will be more memory friendly. Next, an accumulator for unannotated chars
    is setup as a `StringBuilder` object with the `rawChars` variable. All characters
    encountered that are not either a `[` or `]` will be appended to the object. The
    remaining code sets up counters for sentence starts and ends that are indexed
    into the unannotated character array and an accumulator for `Set<Chunk>` for annotated
    sentence segments.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将整个文件作为一个`char[]`数组读取，并使用适当的字符编码。此外，注意对于大文件，使用流式处理方法会更加节省内存。接下来，设置了一个未注释字符的累加器`StringBuilder`对象，并通过`rawChars`变量进行存储。所有遇到的不是`[`或`]`的字符都将被附加到该对象中。剩余的代码设置了用于句子开始和结束的计数器，这些计数器被索引到未注释的字符数组中，并设置了一个用于注释句子片段的`Set<Chunk>`累加器。
- en: 'The following `for` loop advances one character at a time over the annotated
    character sequence:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的`for`循环逐个字符遍历注释过的字符序列：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first `if (chars[i] == '[')` tests for starts of sentences in the annotation
    and sets the start variable to the length of `rawChars`. The iteration variable
    `i` includes the length added by the annotations. The corresponding `else if (chars[i]
    == ']')` statement handles the end of sentence case. Note that there are no error
    checks for this parser—this is a very bad idea because annotation errors are very
    likely if entered with a text editor. However, this is motivated by keeping the
    code as simple as possible. Later in the recipe, we will provide an example with
    some minimal error checking. Once the end of a sentence is found, a chunk is created
    for the sentence with `ChunkFactory.createChunk` with offsets and for the standard
    LingPipe sentence type `SentenceChunker.SENTENCE_CHUNK_TYPE`, which is required
    for the upcoming evaluation classes to work properly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`if (chars[i] == '[')`用于测试注释中句子的开始，并将`start`变量设置为`rawChars`的长度。迭代变量`i`包括由注释添加的长度。相应的`else
    if (chars[i] == ']')`语句处理句子结束的情况。请注意，这个解析器没有错误检查——这是一个非常糟糕的设计，因为如果使用文本编辑器输入，注释错误非常可能发生。然而，这样做是为了保持代码尽可能简洁。在接下来的章节中，我们将提供一个带有最小错误检查的示例。一旦找到句子的结束，就会使用`ChunkFactory.createChunk`根据偏移量为句子创建一个分块，并且使用标准的LingPipe句子类型`SentenceChunker.SENTENCE_CHUNK_TYPE`，这是接下来评估类正确工作的必需条件。
- en: 'The remaining `else` statement applies for all the characters that are not
    sentence boundaries, and it simply adds the character to the `rawChars` accumulator.
    The result of this accumulator can be seen outside the `for` loop when `String
    unannotatedText` is created. Now, we have sentence chunks indexed correctly into
    a text string. Next, we will create a proper `Chunking` object:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的`else`语句适用于所有非句子边界的字符，它仅仅将字符添加到`rawChars`累加器中。`for`循环外部创建`String unannotatedText`时，可以看到这个累加器的结果。现在，我们已经将句子分块正确地索引到文本字符串中。接下来，我们将创建一个合适的`Chunking`对象：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `ChunkingImpl` implementing class (`Chunking` is an interface) requires
    the underlying text on construction, which is why we didn't just populate it in
    the preceding loop. LingPipe generally tries to make object construction complete.
    If Chunkings can be created without the underlying `CharSequence` method, then
    what will be returned when the `charSequence()` method is called? An empty string
    is actively misleading. Alternatively, returning `null` needs to be caught and
    dealt with. Better to just force the object to make sense of construction.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 实现类`ChunkingImpl`（`Chunking`是接口）在构造时需要底层文本，这就是为什么我们没有在前面的循环中直接填充它。LingPipe通常会尝试使对象构造完整。如果可以不使用底层`CharSequence`方法创建`Chunking`，那么调用`charSequence()`方法时会返回什么呢？空字符串会误导用户。或者，返回`null`需要捕获并处理。最好直接强制对象构造以确保其合理性。
- en: 'Moving on, we will see the standard configuration of the sentence chunker from
    the previous recipe:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到上一节中句子分块器的标准配置：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The interesting stuff follows with an evaluator that takes `sentenceChunker`
    as being evaluated as a parameter:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的部分紧随其后，评估器将`sentenceChunker`作为待评估的参数：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next up, the `handle(sentChunking)` method will take the text we just parsed
    into `Chunking` and run the sentence detector on `CharSequence` supplied in `sentChunking`
    and set up the evaluation:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`handle(sentChunking)`方法将把我们刚刚解析的文本转化为`Chunking`，并在`sentChunking`中提供的`CharSequence`上运行句子检测器，并设置评估：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we will just get the evaluation data and work our way through the differences
    between the truth sentence detection and what the system did:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需要获取评估数据，并通过对比正确的句子检测与系统执行的结果，逐步分析差异：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This recipe does not cover all the evaluation methods—check out the Javadoc—but
    it does provide what a sentence detection tuner will likely be most in need of;
    this is a listing of what the sentence detector got right (true positives), sentences
    it found but were wrong (false positives), and sentences it missed (false negatives).
    Note that true negatives don't make much sense in span annotations, because they
    will be the set of all the possible spans that are not in the truth sentence detection.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱并没有涵盖所有评估方法——可以查看Javadoc——但它确实提供了句子检测调整器可能最需要的内容；这列出了句子检测器正确识别的内容（真阳性）、检测到但错误的句子（假阳性）以及漏掉的句子（假阴性）。注意，在跨度注解中，真阴性没有太大意义，因为它们将是所有可能的跨度集合，但不包含在正确的句子检测中。
- en: Tuning sentence detection
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整句子检测
- en: Lots of data will resist the charms of `IndoEuropeanSentenceModel`, so this
    recipe will provide a starting place to modify sentence detection to meet new
    kinds of sentences. Unfortunately, this is a very open-ended area of system building,
    so we will focus on techniques rather than likely formats for sentences.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 很多数据将抵抗`IndoEuropeanSentenceModel`的魅力，所以这个食谱将为修改句子检测以适应新类型的句子提供一个起点。不幸的是，这是一个非常开放的问题，所以我们将专注于技术，而不是句子格式的可能性。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'This recipe will follow a well-worn pattern: create evaluation data, set up
    evaluation, and start hacking. Here we go:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将遵循一个常见的模式：创建评估数据、设置评估并开始动手。我们开始吧：
- en: 'Haul out your favorite text editor and mark up some data—we will stick to the
    `[` and `]` markup approach. The following is an example that runs afoul of our
    standard `IndoEuropeanSentenceModel`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿出你最喜欢的文本编辑器并标记一些数据——我们将使用`[`和`]`标记法。以下是一个违反我们标准`IndoEuropeanSentenceModel`的示例：
- en: '[PRE29]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We will put the preceding sentence in `data/saki.sentDetected.txt` and run
    it:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把前面的句子放入`data/saki.sentDetected.txt`并运行它：
- en: '[PRE30]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: There's more...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: The single false positive corresponds to the one sentence found, and the two
    false negatives are the two sentences not found that we annotated here. What happened?
    The sentence model missed `people's.` as a sentence end. If the apostrophe is
    removed, the sentence is detected properly—what is going on?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的假阳性对应的是检测到的一个句子，两个假阴性是我们这里注释的两个未被检测到的句子。发生了什么？句子模型漏掉了`people's.`作为句子结尾。如果删除撇号，句子就能正确检测到——发生了什么？
- en: 'First, let''s look at the code running in the background. `IndoEuropeanSentenceModel`
    extends `HeuristicSentenceModel` by configuring several categories of tokens from
    the Javadoc for `HeuristicSentenceModel`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看一下后台运行的代码。`IndoEuropeanSentenceModel`通过配置来自`HeuristicSentenceModel`的Javadoc中的几类标记来扩展`HeuristicSentenceModel`：
- en: '**Possible stops**: These are tokens that are allowed to be the final ones
    in a sentence. This set typically includes sentence-final punctuation tokens,
    such as periods (.) and double quotes (").'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可能的停止符**：这些是可以作为句子结尾的标记。这个集合通常包括句尾标点符号标记，比如句号（.）和双引号（"）。'
- en: '**Impossible penultimates**: These are tokens that might not be the penultimate
    (second-to-last) token in a sentence. This set is typically made up of abbreviations
    or acronyms, such as `Mr`.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可能的倒数第二个**：这些是可能不是句子的倒数第二个（倒数第二）标记。这个集合通常由缩写或首字母缩写组成，例如`Mr`。'
- en: '**Impossible starts**: These are tokens that might not be the first ones in
    a sentence. This set typically includes punctuation characters that should be
    attached to the previous sentence, such as end quotes ('''').'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可能的开头**：这些是可能不是句子开头的标记。这个集合通常包括应该与前一句连接的标点符号字符，如结束引号（''''）。'
- en: '`IndoEuropeanSentenceModel` is not configurable, but from the Javadoc, it is
    clear that all single characters are considered impossible penultimates. The words
    `people''s` is tokenized into `people`, `''`, `s`, and `.`. The single character
    `s` is penultimate to the `.` and is thus blocked. How to fix this?'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`IndoEuropeanSentenceModel`不可配置，但从Javadoc中可以看出，所有单个字符都被视为不可能的倒数第二个字符。单词`people''s`被分词为`people`、`''`、`s`和`.`。单个字符`s`位于`.`的倒数第二位，因此会被阻止。如何修复这个问题？'
- en: 'A few options present themselves:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种选择呈现出来：
- en: Ignore the mistake assuming that it won't happen frequently
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略这个错误，假设它不会频繁发生
- en: Fix by creating a custom sentence model
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过创建自定义句子模型来修复
- en: Fix by modifying the tokenizer to not separate apostrophes
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过修改分词器以避免拆分撇号来修复
- en: Write a complete sentence-detection model for the interface
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为该接口编写一个完整的句子检测模型
- en: 'The second option, create a custom sentence model, is handled most easily by
    copying the source from `IndoEuropeanSentenceModel` into a new class and modifying
    it, as the relevant data structures are private. This is done to simplify the
    serialization of the class—very little configuration needs to be written to disk.
    In the example classes, there is a `MySentenceModel.java` file that differs by
    obvious changes in the package name and imports:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择，创建一个自定义句子模型，通过将`IndoEuropeanSentenceModel`的源代码复制到一个新类中并进行修改来处理，这是最简单的做法，因为相关的数据结构是私有的。这样做是为了简化类的序列化——几乎不需要将任何配置写入磁盘。在示例类中，有一个`MySentenceModel.java`文件，它通过明显的包名和导入语句的变化来区分：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding code just comments out two of the likely single-letter cases of
    penultimate tokens that are a single-word character. To see it at work, change
    the sentence model to `SentenceModel sentenceModel = new MySentenceModel();` in
    the `EvaluateAnnotatedSentences.java` class and recompile and run it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码只是注释掉了两种可能的单字母倒数第二个标记的情况，这些情况是单个字符的单词。要查看其效果，请将句子模型更改为`SentenceModel sentenceModel
    = new MySentenceModel();`，并在`EvaluateAnnotatedSentences.java`类中重新编译并运行。
- en: If you see the preceding code as a reasonable balancing of finding sentences
    that end in likely contractions versus non-sentence cases such as `[Hunter S.
    Thompson is a famous fellow.]`, which will detect `S.` as a sentence boundary.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将前面的代码视为一个合理的平衡，它可以找到以可能的缩写结尾的句子与非句子情况之间的平衡，例如`[Hunter S. Thompson is a famous
    fellow.]`，它会将`S.`识别为句子边界。
- en: Extending `HeuristicSentenceModel` can work well for many sorts of data. Mitzi
    Morris built `MedlineSentenceModel.java`, which is designed to work well with
    the abstracts provided in the MEDLINE research index.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展`HeuristicSentenceModel`对于多种类型的数据非常有效。Mitzi Morris构建了`MedlineSentenceModel.java`，它设计得很好，适用于MEDLINE研究索引中提供的摘要。
- en: One way to look at the preceding problem is that contractions should not be
    broken up into tokens for the purpose of sentence detection. `IndoEuropeanTokenizerFactory`
    should be tuned up to keep "people's" and other contractions together. While it
    initially seems slightly better that the first solution, it might well run afoul
    of the fact that `IndoEuropeanSentenceModel` was tuned with a particular tokenization
    in mind, and the consequences of the change are unknown in the absence of an evaluation
    corpus.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 看待前面问题的一种方式是，缩写不应被拆分为标记用于句子检测。`IndoEuropeanTokenizerFactory`应该进行调整，以将"people's"和其他缩写保持在一起。虽然这初看起来似乎稍微比第一个解决方案好，但它可能会遇到`IndoEuropeanSentenceModel`是针对特定的分词方式进行调整的问题，而在没有评估语料库的情况下，改变的后果是未知的。
- en: The other option is to write a completely novel sentence-detection class that
    supports the `SentenceModel` interface. Faced with a highly novel data collection
    such as Twitter feeds, we will consider using a machine-learning-driven span-annotation
    technique such as HMMs or CRFs covered in [Chapter 4](ch04.html "Chapter 4. Tagging
    Words and Tokens"), *Tagging Words and Tokens*, and at the end of this chapter.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是编写一个完全新的句子检测类，支持`SentenceModel`接口。面对像Twitter流这样的高度新颖的数据集，我们可以考虑使用基于机器学习的跨度注释技术，如HMMs或CRFs，这些内容在[第4章](ch04.html
    "第4章. 标注词汇和标记")，*标注词汇和标记*中以及本章末尾讨论过。
- en: Marking embedded chunks in a string – sentence chunk example
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记字符串中的嵌入块——句子块示例
- en: The method of displaying chunkings in the previous recipes is not well suited
    for applications that need to modify the underlying string. For example, a sentiment
    analyzer might want to highlight only sentences that are strongly positive and
    not mark up the remaining sentences while still displaying the entire text. The
    slight complication in producing the marked-up text is that adding markups changes
    the underlying string. This recipe provides working code to insert the chunking
    by adding chunks in reverse.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 先前食谱中展示块的方法不适用于需要修改底层字符串的应用程序。例如，一个情感分析器可能只想突出显示那些情感强烈的正面句子，而不标记其余句子，同时仍然显示整个文本。在生成标记化文本时的一个小难点是，添加标记会改变底层字符串。这个食谱提供了通过逆序添加块来插入块的工作代码。
- en: How to do it...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'While this recipe may not be technically complex it is useful to get span annotations
    into a text without out having to invent the code from whole cloth. The `src/com/lingpipe/coobook/chapter5/WriteSentDetectedChunks`
    class has the referenced code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个食谱在技术上可能不复杂，但它对于在文本中添加跨度注释非常有用，而无需从零开始编写代码。`src/com/lingpipe/coobook/chapter5/WriteSentDetectedChunks`类中包含了参考代码：
- en: 'The sentence chunking is created as per the first sentence-detection recipe.
    The following code extracts the chunks as `Set<Chunk>` and then sorts them by
    `Chunk.LONGEST_MATCH_ORDER_COMPARITOR`. In the Javadoc, the comparator is defined
    as:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 句子块是根据第一个句子检测食谱创建的。以下代码提取块作为`Set<Chunk>`，然后按照`Chunk.LONGEST_MATCH_ORDER_COMPARITOR`进行排序。在Javadoc中，该比较器被定义为：
- en: '*Compares two chunks based on their text position. A chunk is greater if it
    starts later than another chunk, or if it starts at the same position and ends
    earlier.*'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*根据文本位置比较两个块。如果一个块比另一个块晚开始，或者它们在相同位置开始但结束得更早，那么前者更大。*'
- en: 'There is also `TEXT_ORDER_COMPARITOR`, which is as follows:'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还有`TEXT_ORDER_COMPARITOR`，如下所示：
- en: '[PRE32]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we will iterate over the chunks in the reverse order, which eliminates
    having to keep an offset variable for the changing length of the `StringBuilder`
    object. Offset variables are a common source of bugs, so this recipe avoids them
    as much as possible but does non-standard reverse loop iteration, which might
    be worse:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将按逆序遍历块，这样可以避免为`StringBuilder`对象的变化长度保持偏移量变量。偏移量变量是一个常见的错误来源，因此这个食谱尽可能避免使用它们，但使用了非标准的逆序循环迭代，这可能更糟：
- en: '[PRE33]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding code does a very simple sentiment analysis by looking for the
    string `like` in the sentence and marking that sentence if `true`. Note that this
    code cannot handle overlapping chunks or nested chunks. It assumes a single, non-overlapping
    chunk set. Some example output is:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的代码通过查找字符串`like`来进行非常简单的情感分析，如果找到则标记该句子为`true`。请注意，这段代码无法处理重叠的块或嵌套的块。它假设一个单一的、不重叠的块集合。一些示例输出如下：
- en: '[PRE34]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To print nested chunks, look at the *Paragraph* *detection* recipe that follows.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要打印嵌套的块，请查看下面的*段落* *检测*食谱。
- en: Paragraph detection
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 段落检测
- en: The typical containing structure of a set of sentences is a paragraph. It can
    be set off explicitly in a markup language such as `<p>` in HTML or with two or
    more new lines, which is how paragraphs are usually rendered. We are in the part
    of NLP where no hard-and-fast rules apply, so we apologize for the hedging. We
    will handle some common examples in this chapter and leave it to you to generalize.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一组句子的典型包含结构是段落。它可以在标记语言中显式设置，例如HTML中的`<p>`，或者通过两个或更多的换行符来设置，这也是段落通常如何呈现的方式。我们处于自然语言处理的领域，这里没有硬性规定，所以我们为这种含糊其辞表示歉意。我们将在本章中处理一些常见的示例，并将推广的部分留给你来完成。
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We have never set up an evaluation harness for paragraph detection, but it
    can be done in ways similar to sentence detection. This recipe, instead, will
    illustrate a simple paragraph-detection routine that does something very important—maintain
    offsets into the original document with embedded sentence detection. This attention
    to detail will serve you well if you ever need to mark up the document in a way
    that is sensitive to sentences or other subspans of the document, such as named
    entities. Consider the following example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从未为段落检测设置过评估工具，但它可以通过类似句子检测的方式进行实现。这个食谱将演示一个简单的段落检测程序，它做了一件非常重要的事情——在进行嵌入句子检测的同时，保持原始文档的偏移量。细节上的关注会在你需要以对句子或文档的其他子跨度（例如命名实体）敏感的方式标记文档时帮助你。请考虑以下示例：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It gets transformed into the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 它被转化为以下内容：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding snippet, `[]`designates sentences, and `{}` designates paragraphs.
    We will jump right into the code on this recipe from `src/com/lingpipe/cookbook/chapter5/ParagraphSentenceDetection.java`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`[]` 表示句子，`{}` 表示段落。我们将直接跳入这个配方的代码，位于 `src/com/lingpipe/cookbook/chapter5/ParagraphSentenceDetection.java`：
- en: 'The example code has little to offer in paragraph-detection techniques. It
    is an open-ended problem, and you will have to use your wiles to solve it. Our
    paragraph detector is a pathetic `split("\n\n")` that, in a more sophisticated
    approach, will take into account context, characters, and other features that
    are far too idiosyncratic for us to cover. Here is the beginning of the code that
    reads the entire document as a string and splits it into an array. Note that `paraSeperatorLength`
    is the number of characters that form the basis of the paragraph split—if the
    length of the split varies, then that length will have to be associated with the
    corresponding paragraph:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 示例代码在段落检测技术方面几乎没有提供什么。它是一个开放性问题，你必须运用你的聪明才智来解决它。我们的段落检测器是一个可悲的 `split("\n\n")`，在更复杂的方法中，它会考虑上下文、字符和其他特征，这些特征过于独特，无法一一涵盖。以下是读取整个文档作为字符串并将其拆分为数组的代码开头。请注意，`paraSeperatorLength`
    是用于段落拆分的字符数——如果拆分长度有所变化，那么该长度将必须与对应段落相关联：
- en: '[PRE37]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The real point of the recipe is to help with the mechanics of maintaining character
    offsets into the original document and show embedded processing. This will be
    done by keeping two separate chunkings: one for paragraphs and one for sentences:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该配方的真正目的是帮助维护原始文档中字符偏移量的机制，并展示嵌入式处理。这将通过保持两个独立的块进行：一个用于段落，另一个用于句子：
- en: '[PRE38]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, the sentence detector will be set up in the same way as one in the previous
    recipe:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，句子检测器将以与上一配方中相同的方式进行设置：
- en: '[PRE39]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The chunking iterates over the array of paragraphs and builds a sentence chunking
    for each paragraph. The somewhat-complicated part of this approach is that the
    sentence chunk offsets are with respect to the paragraph string, not the entire
    document. So, the variables'' starts and ends are updated with document offsets
    in the code. Chunks have no methods to adjust starts and ends, so a new chunk
    must be created, `adjustedSentChunk`, with appropriate offsets into the paragraph
    start and must be added to `sentChunking`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 块处理会遍历段落数组，并为每个段落构建一个句子块。这个方法中稍显复杂的部分是，句子块的偏移量是相对于段落字符串的，而不是整个文档。因此，变量的开始和结束在代码中会通过文档偏移量进行更新。块本身没有调整开始和结束的方式，因此必须创建一个新的块
    `adjustedSentChunk`，并将适当的偏移量应用到段落的开始，并将其添加到 `sentChunking` 中：
- en: '[PRE40]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The rest of the loop adds the paragraph chunk and then updates the start of
    the paragraph with the length of the paragraph plus the length of the paragraph
    separator. This will complete the creation of correctly offset sentences and paragraphs
    into the original document string:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环的其余部分添加段落块，然后用段落的长度加上段落分隔符的长度更新段落的起始位置。这将完成将正确偏移的句子和段落插入到原始文档字符串中的过程：
- en: '[PRE41]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The rest of the program is concerned with printing out the paragraphs and sentences
    with some markup. First, we will create a chunking that has both sentence and
    paragraph chunks:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序的其余部分涉及打印出带有一些标记的段落和句子。首先，我们将创建一个同时包含句子和段落块的块：
- en: '[PRE42]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, `displayChunking` will be sorted by recovering `chunkSet`, converting
    it into an array of chunks and the application of the static comparator:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，`displayChunking` 将通过恢复 `chunkSet` 进行排序，转换为一个块数组，并应用静态比较器：
- en: '[PRE43]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We will use the same trick as we did in the *Marking embedded chunks in a string
    – sentence chunk example* recipe, which is to insert the markup backwards into
    the string. We will have to keep an offset counter, because nested sentences will
    extend the finishing paragraph mark placement. The approach assumes that no chunks
    overlap and that sentences are contained within paragraphs always:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用与 *在字符串中标记嵌入块 - 句子块示例* 配方中相同的技巧，即将标记反向插入字符串中。我们需要保持一个偏移量计数器，因为嵌套的句子会延长结束段落标记的位置。该方法假设没有块重叠，并且句子始终包含在段落内：
- en: '[PRE44]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: That's it for the recipe.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是该配方的全部内容。
- en: Simple noun phrases and verb phrases
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的名词短语和动词短语
- en: This recipe will show you how to find simple **noun phrases** (**NP**) and **verb
    phrases** (**VP**). By "simple", we mean that there is no complex structure within
    the phrases. For example, the complex NP "The rain in Spain" will be broken into
    two simple NP chunks "The rain" and "Spain". These phrases are also called "basal".
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方将展示如何查找简单的**名词短语**（**NP**）和**动词短语**（**VP**）。这里的“简单”是指短语内没有复杂结构。例如，复杂的NP "The
    rain in Spain" 将被分解成两个简单的NP块：“The rain”和“Spain”。这些短语也称为“基础短语”。
- en: This recipe will not go into the details of how the basal NPs/VPs are calculated
    but rather how to use the class—it can come in handy, and the source can be included
    if you want to sort out how it works.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方不会深入探讨如何计算基础NP/VP，而是介绍如何使用这个类——它非常实用，如果你想了解它如何工作，可以包括源代码。
- en: How to do it…
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'Like many of the recipes, we will provide a command-line-interactive interface
    here:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 和许多其他的配方一样，我们在这里提供一个命令行交互式界面：
- en: 'Haul up the command line and type:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行并输入：
- en: '[PRE45]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works…
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'The `main()` method starts by deserializing a part-of-speech tagger and then
    creating `tokenizerFactory`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`方法首先反序列化词性标注器，然后创建`tokenizerFactory`：'
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, `PhraseChunker` is constructed, which is a heuristic approach to the
    problem. Look at the source to see how it works—it scans the input left to right
    for NP/VP starts and attempts to add to the phrase incrementally:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，构造`PhraseChunker`，这是一种启发式的方法来解决该问题。查看源代码了解它是如何工作的——它从左到右扫描输入，查找NP/VP的开始，并尝试逐步添加到短语中：
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Our standard console I/O code is next:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的标准控制台输入/输出代码如下：
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, the input is tokenized, POS is tagged, and the tokens and tags are printed
    out:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，输入被分词，词性标注，并打印出标记和标签：
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The NP/VP chunkings are then calculated and printed out:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然后计算并打印NP/VP的分块结果：
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There is a more comprehensive tutorial at [http://alias-i.com/lingpipe/demos/tutorial/posTags/read-me.html](http://alias-i.com/lingpipe/demos/tutorial/posTags/read-me.html).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个更全面的教程，访问[http://alias-i.com/lingpipe/demos/tutorial/posTags/read-me.html](http://alias-i.com/lingpipe/demos/tutorial/posTags/read-me.html)。
- en: Regular expression-based chunking for NER
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于正则表达式的NER分块
- en: '**Named Entity Recognition** (**NER**) is the process of finding mentions of
    specific things in text. Consider a simple name; location-named entity recognizer
    might find `Ford Prefect` and `Guildford` as the name and location mentions, respectively,
    in the following text:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名实体识别**（**NER**）是识别文本中具体事物提及的过程。考虑一个简单的名称；位置命名实体识别器可能会在以下文本中分别找到`Ford Prefect`和`Guildford`作为人名和地名：'
- en: '[PRE51]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We will start by building rule-based NER systems and move up to machine-learning
    methods. Here, we'll take a look at building an NER system that can extract e-mail
    addresses from text.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从构建基于规则的NER系统开始，逐步过渡到机器学习方法。这里，我们将构建一个能够从文本中提取电子邮件地址的NER系统。
- en: How to do it…
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'Enter the following command into the command prompt:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符中输入以下命令：
- en: '[PRE52]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Interaction with the program proceeds as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与程序的交互如下进行：
- en: '[PRE53]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You can see that both `foo@bar.com` as well as `foo.bar@gmail.com` were returned
    as valid `e-mail` type chunks. Also, note that the final period in the sentence
    is not part of the second e-mail.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以看到`foo@bar.com`和`foo.bar@gmail.com`都被识别为有效的`e-mail`类型块。此外，请注意，句子末尾的句号不是第二个电子邮件地址的一部分。
- en: How it works…
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'A regular expression chunker finds chunks that match the given regular expression.
    Essentially, the `java.util.regex.Matcher.find()` method is used to iteratively
    find matching text segments, and these are then converted into the Chunk objects.
    The `RegExChunker` class wraps these steps. The code of `src/com/lingpipe/cookbook/chapter5/RegExNer.java`
    is described as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式分块器查找与给定正则表达式匹配的块。本质上，`java.util.regex.Matcher.find()`方法用于迭代地查找匹配的文本片段，然后将这些片段转换为Chunk对象。`RegExChunker`类包装了这些步骤。`src/com/lingpipe/cookbook/chapter5/RegExNer.java`的代码如下所述：
- en: '[PRE54]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: All the interesting work was done in the preceding lines of code. The `emailRegex`
    is pulled off of the Internet—see the following for the source, and the remaining
    bits are setting up `chunkType` and `score`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 所有有趣的工作都在前面的代码行中完成。`emailRegex`是从互联网上获取的——参见以下源代码，其余的部分是在设置`chunkType`和`score`。
- en: 'The rest of the code reads in the input and prints out the chunking:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 其余代码会读取输入并输出分块结果：
- en: '[PRE55]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: See also
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The regular expression for the e-mail address match is from [regexlib.com](http://regexlib.com)
    at [http://regexlib.com/DisplayPatterns.aspx?cattabindex=0&categoryId=1](http://regexlib.com/DisplayPatterns.aspx?cattabindex=0&categoryId=1)
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于匹配电子邮件地址的正则表达式来自[regexlib.com](http://regexlib.com)，网址为[http://regexlib.com/DisplayPatterns.aspx?cattabindex=0&categoryId=1](http://regexlib.com/DisplayPatterns.aspx?cattabindex=0&categoryId=1)。
- en: Dictionary-based chunking for NER
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于词典的命名实体识别（NER）分块
- en: In many websites and blogs and certainly on web forums, you might see keyword
    highlighting that links pages you can buy a product from. Similarly, news websites
    also provide topic pages for people, places, and trending events, such as the
    one at [http://www.nytimes.com/pages/topics/](http://www.nytimes.com/pages/topics/).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多网站和博客，特别是在网络论坛上，你可能会看到关键词高亮，这些关键词链接到你可以购买产品的页面。同样，新闻网站也提供关于人物、地点和流行事件的专题页面，例如[http://www.nytimes.com/pages/topics/](http://www.nytimes.com/pages/topics/)。
- en: A lot of this is fully automated and is easy to do with a dictionary-based `Chunker`.
    It is straightforward to compile lists of names for entities and their types.
    An exact dictionary chunker extracts chunks based on exact matches of tokenized
    dictionary entries.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 其中许多操作是完全自动化的，通过基于词典的`Chunker`很容易实现。编译实体名称及其类型的列表非常简单。精确的字典分块器根据分词后的字典条目的精确匹配来提取分块。
- en: The implementation of the dictionary-based chunker in LingPipe is based on the
    Aho-Corasick algorithm which finds all matches against a dictionary in linear
    time independent of the number of matches or size of the dictionary. This makes
    it much more efficient than the naïve approach of doing substring searches or
    using regular expressions.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: LingPipe中基于字典的分块器的实现基于Aho-Corasick算法，该算法在线性时间内找到所有与字典匹配的项，无论匹配数量或字典大小如何。这使得它比做子字符串搜索或使用正则表达式的天真方法更高效。
- en: How to do it…
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'In the IDE of your choice run the `DictionaryChunker` class in the `chapter5`
    package or type the following using the command line:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你选择的IDE中运行`chapter5`包中的`DictionaryChunker`类，或者在命令行中输入以下命令：
- en: '[PRE56]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Since this particular chunker example is biased (very heavily) towards the
    Hitchhikers Guide, let''s use a sentence that involves some of the characters:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这个特定的分块器示例强烈偏向于《银河系漫游指南》，我们使用一个涉及一些角色的句子：
- en: '[PRE57]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note that we have overlapping chunks from `Heart` and `Heart of Gold`. As we
    will see, this can be configured to behave differently.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，我们有来自`Heart`和`Heart of Gold`的重叠部分。正如我们将看到的，这可以配置为不同的行为方式。
- en: How it works…
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Dictionary-based NER drives a great deal of automatic linking against unstructured
    text data. We can build one using the following steps.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 基于字典的NER驱动了大量的自动链接，针对非结构化文本数据。我们可以使用以下步骤构建一个。
- en: 'The first step of the code will create `MapDictionary<String>` to store the
    dictionary entries:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一步将创建`MapDictionary<String>`来存储字典条目：
- en: '[PRE58]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, we will populate the dictionary with `DictionaryEntry<String>`, which
    includes type information and a score that will be used to create chunks:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将用`DictionaryEntry<String>`填充字典，其中包括类型信息和将用于创建分块的得分：
- en: '[PRE59]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In the `DictionaryEntry` constructor, the first argument is the phrase, the
    second string argument is the type, and the final double argument is the score
    for the chunk. Dictionary entries are always case sensitive. There is no limit
    to the number of different entity types in a dictionary. The scores will simply
    be passed along as chunk scores in the dictionary-based chunker.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DictionaryEntry`构造函数中，第一个参数是短语，第二个字符串参数是类型，最后一个双精度参数是分块的得分。字典条目始终区分大小写。字典中没有限制不同实体类型的数量。得分将作为分块得分传递到基于字典的分块器中。
- en: 'Next, we will build `Chunker`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建`Chunker`：
- en: '[PRE60]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: An exact dictionary chunker might be configured either to extract all the matching
    chunks to restrict the results to a consistent set of non-overlapping chunks via
    the `returnAllMatches` boolean. Look at the Javadoc to understand the exact criteria.
    There is also a `caseSensitive` boolean. The chunker requires a tokenizer, as
    it matches tokens as symbols, and whitespaces are ignored in the matching process.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 精确的字典分块器可以配置为提取所有匹配的分块，或者通过`returnAllMatches`布尔值将结果限制为一致的非重叠分块。查看Javadoc以了解精确的标准。还有一个`caseSensitive`布尔值。分块器需要一个分词器，因为它根据符号匹配分词，并且在匹配过程中会忽略空白字符。
- en: 'Next is our standard I/O code for console interaction:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们的标准输入/输出代码，用于控制台交互：
- en: '[PRE61]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The remaining code creates a chunking, goes through the chunks, and prints
    them out:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的代码创建了一个分块器，遍历分块，并将它们打印出来：
- en: '[PRE62]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Dictionary chunkers are very useful even in machine-learning-based systems.
    There tends to always be a class of entities that are best identified this way.
    The *Mixing the NER sources* recipe addresses how to work with multiple sources
    of named entities.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 字典块划分器在基于机器学习的系统中也非常有用。通常，总会有一些实体类别，使用这种方式最容易识别。*混合命名实体识别源*食谱介绍了如何处理多个命名实体来源。
- en: Translating between word tagging and chunks – BIO codec
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 词语标记与块之间的转换 – BIO编解码器
- en: In [Chapter 4](ch04.html "Chapter 4. Tagging Words and Tokens"), *Tagging Words
    and Tokens*, we used HMMs and CRFs to apply tags to words/tokens. This recipe
    addresses the case of creating chunks from taggings that use the **Begin, In,
    and Out** (**BIO**) tags to encode chunkings that can span multiple words/tokens.
    This, in turn, is the basis of modern named-entity detection systems.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章 标签词语与词元")中，*标签词语与词元*，我们使用了HMM和CRF来为词语/词元添加标签。本食谱讨论了如何通过使用**开始、内含和结束**（**BIO**）标签，从标记中创建块，进而编码可能跨越多个词语/词元的块。这也是现代命名实体识别系统的基础。
- en: Getting ready
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The standard BIO-tagging scheme has the first token in a chunk of type X tagged
    B-X (begin), with all the subsequent tokens in the same chunk tagged I-X (in).
    All the tokens that are not in chunks are tagged O (out). For example, the string
    with character counts:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的BIO标记方案中，块类型X的第一个词元被标记为B-X（开始），同一块中的所有后续词元被标记为I-X（内含）。所有不在块中的词元被标记为O（结束）。例如，具有字符计数的字符串：
- en: '[PRE63]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'It can be tagged as:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以被标记为：
- en: '[PRE64]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The corresponding chunks will be:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的块将是：
- en: '[PRE65]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: How to do it…
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The program will show the simplest mapping between taggings and chunkings and
    the other way around:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将展示标记和块的最简单映射关系，反之亦然：
- en: 'Run the following:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE66]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The program first prints out the string that will be tagged with a tagging:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序首先打印出将被标记的字符串：
- en: '[PRE67]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, the chunking is printed:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打印出块：
- en: '[PRE68]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, the tagging is created from the chunking just displayed:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从刚刚显示的块中创建标记：
- en: '[PRE69]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: How it works…
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The code starts by manually constructing `StringTagging`—we will see HMMs and
    CRFs do the same programmatically, but here it is explicit. It then prints out
    the created `StringTagging`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先手动构造`StringTagging`——我们将在HMM和CRF中看到同样的程序化操作，但这里是显式的。然后它会打印出创建的`StringTagging`：
- en: '[PRE70]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, it will construct `BioTagChunkCodec` and convert the tagging just printed
    out to a chunking followed by printing the chunking:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它将构造`BioTagChunkCodec`，并将刚刚打印出来的标记转换为块，然后打印出块：
- en: '[PRE71]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The remaining code reverses the process. First, a different `BioTagChunkCodec`
    is created with `boolean` `enforceConsistency`, which, if `true`, checks that
    the tokens created by the supplied tokenizer align exactly with the chunk begins
    and ends. Without the alignment we end up with a perhaps untenable relationship
    between chunks and tokens depending on the use case:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的代码反转了这一过程。首先，创建一个不同的`BioTagChunkCodec`，并使用`boolean`类型的`enforceConsistency`，如果为`true`，它会检查由提供的分词器创建的词元是否完全与块的开始和结束对齐。如果没有对齐，根据使用场景，我们可能会得到标记和块之间无法维持的关系：
- en: '[PRE72]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The last `for` loop simply prints out the tagging returned by the `codec2.toStringTagging()`
    method.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的`for`循环仅仅打印出由`codec2.toStringTagging()`方法返回的标记。
- en: There's more…
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The recipe works through the simplest example of mapping between taggings and
    chunkings. `BioTagChunkCodec` also takes the `TagLattice<String>` objects to produce
    n-best output, as will be shown in the HMM and CRF chunkers to follow.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱通过最简单的标记与块之间的映射示例进行讲解。`BioTagChunkCodec`还接受`TagLattice<String>`对象，生成n-best输出，正如后面将在HMM和CRF块器中展示的那样。
- en: HMM-based NER
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于HMM的命名实体识别（NER）
- en: '`HmmChunker` uses an HMM to perform chunking over tokenized character sequences.
    Instances contain an HMM decoder for the model and tokenizer factory. The chunker
    requires the states of the HMM to conform to a token-by-token encoding of a chunking.
    It uses the tokenizer factory to break the chunks down into sequences of tokens
    and tags. Refer to the *Hidden Markov Models (HMM) – part of speech* recipe in
    [Chapter 4](ch04.html "Chapter 4. Tagging Words and Tokens"), *Tagging Words and
    Tokens*.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`HmmChunker`使用HMM对标记化的字符序列进行块划分。实例包含用于该模型的HMM解码器和分词器工厂。块划分器要求HMM的状态符合块的逐个词元编码。它使用分词器工厂将块分解为词元和标签序列。请参考[第4章](ch04.html
    "第4章 标签词语与词元")中的*隐马尔可夫模型（HMM） – 词性*食谱，*标签词语与词元*。'
- en: We'll look at training `HmmChunker` and using it for the `CoNLL2002` Spanish
    task. You can and should use your own data, but this recipe assumes that training
    data will be in the `CoNLL2002` format.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论如何训练`HmmChunker`并将其用于`CoNLL2002`西班牙语任务。你可以并且应该使用自己的数据，但这个配方假设训练数据将采用`CoNLL2002`格式。
- en: Training is done using an `ObjectHandler` which supplies the training instances.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 训练是通过一个`ObjectHandler`完成的，`ObjectHandler`提供了训练实例。
- en: Getting ready
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As we want to train this chunker, we need to either label some data using the
    **Computational Natural Language Learning** (**CoNLL**) schema or use the one
    that's publicly available. For speed, we'll choose to get a corpus that is available
    in the CoNLL 2002 task.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望训练这个 chunker，我们需要使用**计算自然语言学习**（**CoNLL**）模式标注一些数据，或者使用公开的模式。为了提高速度，我们选择获取一个在
    CoNLL 2002 任务中可用的语料库。
- en: Note
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The ConNLL is an annual meeting that sponsors a bakeoff. In 2002, the bakeoff
    involved Spanish and Dutch NER.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ConNLL 是一个年度会议，赞助一个比赛。2002 年，这个比赛涉及了西班牙语和荷兰语的命名实体识别（NER）。
- en: The data can be downloaded from [http://www.cnts.ua.ac.be/conll2002/ner.tgz](http://www.cnts.ua.ac.be/conll2002/ner.tgz).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以从[http://www.cnts.ua.ac.be/conll2002/ner.tgz](http://www.cnts.ua.ac.be/conll2002/ner.tgz)下载。
- en: 'Similar to what we showed in the preceding recipe; let''s take a look at what
    this data looks like:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们在前一个配方中展示的内容；让我们来看一下这些数据的样子：
- en: '[PRE73]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: With this encoding scheme, the phrases *El Abogado General del Estado* and *Daryl
    Williams* are coded as persons, with their beginning and continuing tokens picked
    out with tags B-PER and I-PER, respectively.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种编码方式，短语*El Abogado General del Estado*和*Daryl Williams*被编码为人物（person），其开始和继续的标记分别为
    B-PER 和 I-PER。
- en: Note
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are a few formatting errors in the data that must be fixed before our
    parsers can handle them. After unpacking `ner.tgz` in the `data` directory you
    will have to go to `data/ner/data`, unzip the following files, and modify as indicated:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 数据中有一些格式错误，必须修复这些错误，才能让我们的解析器处理它们。在数据目录解压`ner.tgz`后，你需要进入`data/ner/data`，解压以下文件，并按照指示进行修改：
- en: '[PRE74]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: How to do it…
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Using the command line, type the following:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令行，输入以下命令：
- en: '[PRE75]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'It will run the training on the CoNLL training data if the model doesn''t exist.
    It might take a while, so be patient. The output of the training will be:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果模型不存在，它将对 CoNLL 训练数据进行训练。这可能需要一段时间，所以请耐心等待。训练的输出结果将是：
- en: '[PRE76]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Once the prompt to enter the text is presented, type in some Spanish text from
    the CoNLL test set:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦提示输入文本，输入来自 CoNLL 测试集的西班牙语文本：
- en: '[PRE77]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: What we will see is a number of entities, their confidence score, the span in
    the original sentence, the type of entity, and the phrase that represents this
    entity.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将看到一系列实体、它们的置信度分数、原始句子中的跨度、实体的类型和表示该实体的短语。
- en: 'To find out the correct tags, take a look at the annotated `esp.testa` file,
    which contains the following tags for this sentence:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要找出正确的标签，请查看标注过的`esp.testa`文件，该文件包含了以下标签：
- en: '[PRE78]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This can be read as follows:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这可以这样理解：
- en: '[PRE79]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: So, we got all the ones with 1.000 confidence correct and the rest wrong. This
    can help us set up a threshold in production.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，我们把所有置信度为 1.000 的实体识别正确，其他的都识别错了。这有助于我们在生产环境中设置阈值。
- en: How it works…
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The `CharLmRescoringChunker` provides a long-distance character language model-based
    chunker that operates by rescoring the output of a contained character language
    model HMM chunker. The underlying chunker is an instance of `CharLmHmmChunker`,
    which is configured with the specified tokenizer factory, n-gram length, number
    of characters, and interpolation ratio provided in the constructor.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`CharLmRescoringChunker`提供了一个基于长距离字符语言模型的 chunker，通过重新评分包含的字符语言模型 HMM chunker
    的输出结果来运行。底层的 chunker 是`CharLmHmmChunker`的一个实例，它根据构造函数中指定的分词器工厂、n-gram 长度、字符数和插值比率进行配置。'
- en: 'Let''s start with the `main()` method; here, we will set up the chunker, train
    it if it doesn''t exist, and then allow for some input to get the named entities
    out:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`main()`方法开始；在这里，我们将设置 chunker，如果模型不存在则进行训练，然后允许输入以提取命名实体：
- en: '[PRE80]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The training file will be in the correct place if you unpack the CoNLL data
    (`tar –xvzf ner.tgz`) in the data directory. Remember to correct the annotation
    on line 221619 of `esp.train`. If you use other data, then modify and recompile
    the class.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在数据目录中解压了 CoNLL 数据（`tar –xvzf ner.tgz`），训练文件将位于正确的位置。记得修正`esp.train`文件第 221619
    行的标注。如果你使用其他数据，请修改并重新编译类。
- en: 'The next bit of code trains the model if it doesn''t exist and then loads the
    serialized version of the chunker. If you have questions about deserialization,
    see the *Deserializing and running a classifier* recipe in [Chapter 1](ch01.html
    "Chapter 1. Simple Classifiers"), *Simple Classifiers*. Consider the following
    code snippet:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的代码段会训练模型（如果模型不存在），然后加载序列化版本的分块器。如果你对反序列化有疑问，请参见[第1章](ch01.html "第1章. 简单分类器")中的*反序列化和运行分类器*部分，了解更多内容。以下是代码片段：
- en: '[PRE81]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The `trainHMMChunker()` method starts with some `File` bookkeeping before setting
    up configuration parameters for `CharLmRescoringChunker`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`trainHMMChunker()`方法首先进行一些`File`文件管理，然后设置`CharLmRescoringChunker`的配置参数：'
- en: '[PRE82]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Starting with the first parameter, `numChunkingsRescored` sets the number of
    chunkings from the embedded `Chunker` that will be rescored in an effort to improve
    performance. The implementation of this rescoring can vary, but generally, less-localized
    information is used to improve on the basic HMM output, which is contextually
    limited. The `maxNgram` sets the maximum character size for the rescoring-bounded
    character language model per chunk type, and `lmInterpolation` dictates how the
    models are interpolated. A good value is the character n-gram size. Finally, a
    tokenizer factory is created. There is a lot going on in this class; consult Javadoc
    for more information.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一个参数开始，`numChunkingsRescored`设置来自嵌入式`Chunker`的分块数量，这些分块将重新评分以提高性能。此重新评分的实现可能有所不同，但通常会使用更少的局部信息来改进基本的HMM输出，因为它在上下文上有限。`maxNgram`设置每种分块类型的最大字符数，用于重新评分的字符语言模型，而`lmInterpolation`决定模型如何进行插值。一个好的值是字符n-gram的大小。最后，创建一个分词器工厂。在这个类中有很多内容，更多信息请查阅Javadoc。
- en: 'Next in the method, we will get a parser to be discussed in the following code
    snippet, that takes `chunkerEstimator` with the `setHandler()` method, and then,
    the `parser.parse()` method does the actual training. The last bit of code serializes
    the model to disk—see the *How to serialize a LingPipe object – classifier example*
    recipe in [Chapter 1](ch01.html "Chapter 1. Simple Classifiers"), *Simple Classifiers*,
    to read about what is going on:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 方法中的下一部分将获取一个解析器，我们将在接下来的代码片段中讨论，它接受`chunkerEstimator`和`setHandler()`方法，然后，`parser.parse()`方法进行实际训练。最后一段代码将模型序列化到磁盘——请参见[第1章](ch01.html
    "第1章. 简单分类器")中的*如何序列化LingPipe对象—分类器示例*部分，了解其中发生的情况：
- en: '[PRE83]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, let''s take a look at parsing the CoNLL data. The source for this class
    is `src/com/lingpipe/cookbook/chapter5/Conll2002ChunkTagParser`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看如何解析CoNLL数据。此类的源代码是`src/com/lingpipe/cookbook/chapter5/Conll2002ChunkTagParser`：
- en: '[PRE84]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The statics set up the configuration of the `com.aliasi.tag.LineTaggingParser`
    LingPipe class. CoNLL, like many available data sets, uses a token/tag per line
    format, which is meant to be very easy to parse:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法设置`com.aliasi.tag.LineTaggingParser` LingPipe类的配置。像许多可用的数据集一样，CoNLL使用每行一个标记/标签的格式，这种格式非常容易解析：
- en: '[PRE85]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The `LineTaggingParser` constructor requires a regular expression that identifies
    the token and tag strings via grouping. There is additionally a regular expression
    for lines to ignore and finally, a regular expression for sentence ends.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`LineTaggingParser`构造函数需要一个正则表达式，通过分组识别标记和标签字符串。此外，还有一个正则表达式用于忽略的行，最后一个正则表达式用于句子的结束。'
- en: 'Next, we set up `TagChunkCodec`; this will handle the mapping from tagged tokens
    in the BIO format to proper chunks. See the previous recipe, *Translating between
    word tagging and chunks – BIO codec*, for more about what is going on here. The
    remaining parameters customize the tags to match those of the CoNLL training data:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置`TagChunkCodec`；它将处理从BIO格式的标记令牌到正确分块的映射。关于这里发生的过程，请参见前一个食谱，*在词标记和分块之间转换—BIO编解码器*。剩余的参数将标签自定义为与CoNLL训练数据的标签相匹配：
- en: '[PRE86]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The rest of the class provides methods for `parseString()`, which is immediately
    sent to the `LineTaggingParser` class:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的其余部分提供`parseString()`方法，立即将其传递给`LineTaggingParser`类：
- en: '[PRE87]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Next, the `ObjectHandler` parser is properly configured with the codec and
    supplied handler:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`ObjectHandler`解析器与编解码器和提供的处理器一起正确配置：
- en: '[PRE88]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: It's a lot of odd-looking code, but all this does is set up a parser to read
    the lines from the input file and extract chunkings out of them.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码看起来很奇怪，但实际上它们的作用是设置一个解析器，从输入文件中读取行并从中提取分块。
- en: 'Finally, let''s go back to the `main` method and look at the output loop. We
    will set up the `MAX_NBEST` chunkings value as 10 and then invoke the `nBestChunkings`
    method on the chunker. This provides the top 10 chunks and their probabilistic
    scores. Based on an evaluation, we can choose to cut off at a particular score:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们回到`main`方法，看看输出循环。我们将把`MAX_NBEST`块值设置为10，然后调用块器的`nBestChunkings`方法。这将提供前10个块及其概率分数。根据评估结果，我们可以选择在某个特定分数处进行截断：
- en: '[PRE89]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: There's more…
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: For more details on running a complete evaluation, refer to the evaluation section
    of the tutorial at [http://alias-i.com/lingpipe/demos/tutorial/ne/read-me.html](http://alias-i.com/lingpipe/demos/tutorial/ne/read-me.html).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解如何运行完整评估的更多细节，请参见教程中的评估部分：[http://alias-i.com/lingpipe/demos/tutorial/ne/read-me.html](http://alias-i.com/lingpipe/demos/tutorial/ne/read-me.html)。
- en: See also
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'For more details on `CharLmRescoringChunker` and `HmmChunker`, refer to:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`CharLmRescoringChunker`和`HmmChunker`的更多详情，请参见：
- en: '[http://alias-i.com/lingpipe/docs/api/com/aliasi/chunk/AbstractCharLmRescoringChunker.html](http://alias-i.com/lingpipe/docs/api/com/aliasi/chunk/AbstractCharLmRescoringChunker.html)'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://alias-i.com/lingpipe/docs/api/com/aliasi/chunk/AbstractCharLmRescoringChunker.html](http://alias-i.com/lingpipe/docs/api/com/aliasi/chunk/AbstractCharLmRescoringChunker.html)'
- en: '[http://alias-i.com/lingpipe/docs/api/com/aliasi/chunk/HmmChunker.html](http://alias-i.com/lingpipe/docs/api/com/aliasi/chunk/HmmChunker.html)'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://alias-i.com/lingpipe/docs/api/com/aliasi/chunk/HmmChunker.html](http://alias-i.com/lingpipe/docs/api/com/aliasi/chunk/HmmChunker.html)'
- en: Mixing the NER sources
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合NER源
- en: Now that we've seen how to build a few different types of NERs, we can look
    at how to combine them. In this recipe, we will take a regular expression chunker,
    a dictionary-based chunker, and an HMM-based chunker and combine their outputs
    and look at overlaps.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过如何构建几种不同类型的命名实体识别（NER），接下来可以看看如何将它们组合起来。在本教程中，我们将结合正则表达式块器、基于词典的块器和基于HMM的块器，并将它们的输出合并，看看重叠情况。
- en: 'We will just initialize a few chunkers in the same way we did in the past few
    recipes and then pass the same text through these chunkers. The easiest possibility
    is that each chunker returns a unique output. For example, let''s consider a sentence
    such as "President Obama was scheduled to give a speech at the G-8 conference
    this evening". If we have a person chunker and an organization chunker, we might
    only get two unique chunks out. However, if we add a `Presidents of USA` chunker,
    we will get three chunks: `PERSON`, `ORGANIZATION`, and `PRESIDENT`. This very
    simple recipe will show us one way to handle these cases.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以与前几个食谱中相同的方式初始化一些块器，然后将相同的文本传递给这些块器。最简单的情况是每个块器返回唯一的输出。例如，我们考虑一个句子：“总统奥巴马原定于今晚在G-8会议上发表演讲”。如果我们有一个人名块器和一个组织块器，我们可能只会得到两个唯一的块。然而，如果我们再加入一个`美国总统`块器，我们将得到三个块：`PERSON`、`ORGANIZATION`和`PRESIDENT`。这个非常简单的食谱将展示一种处理这些情况的方法。
- en: How to do it…
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Using the command line or equivalent in your IDE, type the following:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令行或IDE中的等效命令，输入以下内容：
- en: '[PRE90]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The usual interactive prompt follows:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 常见的交互式提示如下：
- en: '[PRE91]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We see the output from the three chunkers: `neChunking` is the output of an
    HMM chunker that is trained to return the MUC-6 entities, `pChunking` is a simple
    regular expression that recognizes male pronouns, and `dChunking` is a dictionary
    chunker that recognizes US Presidents.'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们看到来自三个块器的输出：`neChunking`是经过训练返回MUC-6实体的HMM块器的输出，`pChunking`是一个简单的正则表达式，用于识别男性代词，`dChunking`是一个词典块器，用于识别美国总统。
- en: With overlaps allowed, we will see the chunks for `PRESIDENT` as well as `PERSON`
    in the merged output.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果允许重叠，我们将在合并的输出中看到`PRESIDENT`和`PERSON`的块。
- en: With overlaps disallowed, they will be added to the set overlapped chunks and
    removed from the unique chunks.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不允许重叠，它们将被添加到重叠块集合中，并从唯一块中移除。
- en: How it works…
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'We initialized three chunkers that should be familiar to you from the previous
    recipes in this chapter:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化了三个块器，这些块器应该是您从本章之前的食谱中熟悉的：
- en: '[PRE92]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Now, we will just chunk our input text via all three chunkers, combine the
    chunks into one set, and pass our `getCombinedChunks` method to it:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过所有三个块器对输入文本进行分块，将块合并为一个集合，并将`getCombinedChunks`方法传递给它：
- en: '[PRE93]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The meat of this recipe is in the `getCombinedChunks` method. We will just
    loop through all the chunks and check each pair if they overlap in their starts
    and ends. If they overlap and overlaps are not allowed, they are added to an overlapped
    set; otherwise, they are added to a combined set:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的核心在于`getCombinedChunks`方法。我们将遍历所有的块，检查每一对是否在开始和结束时有重叠。如果它们有重叠且不允许重叠，就将它们添加到重叠集；否则，添加到合并集：
- en: '[PRE94]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Here is the place to add more rules for overlapping chunks. For example, you
    can make it score based, so if the `PRESIDENT` chunk type has a higher score than
    the HMM-based one, you can choose it instead.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这是添加更多重叠块规则的地方。例如，你可以基于分数进行评分，如果`PRESIDENT`块类型的分数高于基于 HMM 的块类型，你可以选择它。
- en: CRFs for chunking
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于分块的 CRF
- en: CRFs are best known to provide close to state-of-the-art performance for named-entity
    tagging. This recipe will tell us how to build one of these systems. The recipe
    assumes that you have read, understood, and played with the *Conditional r* *andom
    fields – CRF for word/token tagging* recipe in [Chapter 4](ch04.html "Chapter 4. Tagging
    Words and Tokens"), *Tagging Words and Tokens*, which addresses the underlying
    technology. Like HMMs, CRFs treat named entity detection as a word-tagging problem,
    with an interpretation layer that provides chunkings. Unlike HMMs, CRFs use a
    logistic-regression-based classification approach, which, in turn, allows for
    random features to be included. Also, there is an excellent tutorial on CRFs that
    this recipe follows closely (but omits details) at [http://alias-i.com/lingpipe/demos/tutorial/crf/read-me.html](http://alias-i.com/lingpipe/demos/tutorial/crf/read-me.html).
    There is also a lot of information in the Javadoc.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: CRF 最著名的是在命名实体标注方面提供接近最先进的性能。本食谱将告诉我们如何构建这样的系统。该食谱假设你已经阅读、理解并尝试过*条件随机场 – 用于词汇/标记标注*的[第4章](ch04.html
    "第4章 标注词汇和标记")，该章节涉及了基础技术。与 HMM 类似，CRF 将命名实体识别视为一个词汇标注问题，具有一个解释层，提供分块信息。与 HMM
    不同，CRF 使用基于逻辑回归的分类方法，这使得可以包含随机特征。此外，本食谱遵循了一个优秀的 CRF 教程（但省略了细节），教程地址是[http://alias-i.com/lingpipe/demos/tutorial/crf/read-me.html](http://alias-i.com/lingpipe/demos/tutorial/crf/read-me.html)。Javadoc
    中也有很多信息。
- en: Getting ready
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Just as we did earlier, we will use a small hand-coded corpus to serve as training
    data. The corpus is in `src/com/lingpipe/cookbook/chapter5/TinyEntityCorpus.java`.
    It starts with:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前做的那样，我们将使用一个小型手动编码的语料库作为训练数据。该语料库位于`src/com/lingpipe/cookbook/chapter5/TinyEntityCorpus.java`，开始于：
- en: '[PRE95]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Since we are only using this corpus to train, the `visitTest()` method does
    nothing. However, the `visitTrain()` method exposes the handler to all the chunkings
    stored in the `CHUNKINGS` constant. This, in turn, looks like the following:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们仅使用此语料库进行训练，`visitTest()`方法没有任何作用。然而，`visitTrain()`方法将处理程序暴露给`CHUNKINGS`常量中存储的所有分块。这看起来像以下内容：
- en: '[PRE96]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We are still not done. Given that the creation of `Chunking` is fairly verbose,
    there are static methods to help dynamically create the requisite objects:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成。由于`Chunking`的创建相对冗长，存在静态方法来帮助动态创建所需的对象：
- en: '[PRE97]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This is all the setup; next, we will train and run a CRF on the preceding data.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所有的设置；接下来，我们将使用前面的数据训练并运行 CRF。
- en: How to do it...
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Type the `TrainAndRunSimplCrf` class in the command line or run the equivalent
    in your IDE:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中键入`TrainAndRunSimplCrf`类，或者在你的 IDE 中运行相应的命令：
- en: '[PRE98]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'This results in loads of screen output that report on the health and progress
    of the CRF, it is mostly information from the underlying logistic-regression classifier
    that drives the whole show. The fun bit is that we will get an invitation to play
    with the new CRF:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这会导致大量的屏幕输出，报告 CRF 的健康状态和进展，主要是来自底层的逻辑回归分类器，它驱动了整个过程。最有趣的部分是我们将收到一个邀请，去体验新的
    CRF：
- en: '[PRE99]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The chunker reports the first best output:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分块器报告了第一个最佳输出：
- en: '[PRE100]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The preceding output is the first best analysis by the CRF of what sorts of
    entities are in the sentence. It thinks that `John Smith` is `PER` with `the 0-10:PER@-Infinity`
    output. We know that it applies to the `John Smith` string by taking the substring
    from 0 to 10 in the input text. Ignore `–Infinity`, which is supplied for chunks
    that have no score. The first best chunking does not have scores. The other entity
    that it thinks is in the text is `New York` as an `LOC`.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前述输出是CRF的最优分析，展示了句子中有哪些实体。它认为`John Smith`是`PER`，其输出为`the 0-10:PER@-Infinity`。我们知道它通过从输入文本中提取从0到10的子字符串来应用于`John
    Smith`。忽略`–Infinity`，它是为没有分数的片段提供的。最优片段分析没有分数。它认为文本中的另一个实体是`New York`，其类型为`LOC`。
- en: 'Immediately, the conditional probabilities follow:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 紧接着，条件概率跟随其后：
- en: '[PRE101]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The preceding output provides the 10 best analyses of the whole phrase, along
    with their conditional (natural log) probabilities. In this case, we will see
    that the system isn't particularly confident of any of its analyses. For instance,
    the estimated probability of the first best analysis being correct is `exp(-1.66)=0.19`.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前述输出提供了整个短语的10个最佳分析结果及其条件（自然对数）概率。在这种情况下，我们会发现系统对任何分析结果都没有特别的信心。例如，最优分析被正确的估计概率为`exp(-1.66)=0.19`。
- en: 'Next, in the output, we see probabilities for individual chunks:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在输出中，我们看到个别片段的概率：
- en: '[PRE102]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: As with the previous conditional output, the probabilities are logs, so we can
    see that the `John Smith` chunk has estimated probability `exp(-0.49) = 0.61`,
    which makes sense because in training the CRF saw `John` at the beginning of `PER`
    and `Smith` at the end of another, but not `John Smith` directly.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前的条件输出一样，概率是对数，因此我们可以看到`John Smith`片段的估计概率为`exp(-0.49) = 0.61`，这很有道理，因为在训练时，CRF看到`John`出现在`PER`的开始位置，`Smith`出现在另一个`PER`的结束位置，而不是直接看到`John
    Smith`。
- en: The preceding kind of probability distributions can really improve systems if
    there are sufficient resources to consider a broad range of analyses and ways
    of combining evidence to allow for improbable outcomes to be selected. First best
    analyses tend to be over committed to conservative outcomes that fit what training
    data looks like.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前述类型的概率分布如果有足够的资源去考虑广泛的分析范围以及结合证据的方式，以允许选择不太可能的结果，确实能改善系统。最优分析往往会过于保守，适应训练数据的外观。
- en: How it works…
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The code in `src/com/lingpipe/cookbook/chapter5/TrainAndRunSimpleCRF.java`
    resembles our classifier and HMM recipes with a few differences. These differences
    are addressed as follows:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/com/lingpipe/cookbook/chapter5/TrainAndRunSimpleCRF.java`中的代码与我们的分类器和HMM配方类似，但有一些不同之处。这些不同之处如下所示：'
- en: '[PRE103]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: When we previously played with CRFs, the inputs were of the `Tagging<String>`
    type. Looking back at `TinyEntityCorpus.java`, the types are of the `Chunking`
    type. The preceding `BioTagChunkCodec` facilitates the translation of `Chunking`
    into `Tagging` via the efforts of a supplied `TokenizerFactory` and `boolean`
    that raise an exception if `TokenizerFactory` does not exactly agree with the
    `Chunk` starts and ends. Look back to the *Translating between word tagging and
    chunks–BIO codec* recipe better understand the role of this class.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们之前使用CRF时，输入数据是`Tagging<String>`类型。回顾`TinyEntityCorpus.java`，数据类型是`Chunking`类型。前述的`BioTagChunkCodec`通过提供的`TokenizerFactory`和`boolean`来帮助将`Chunking`转换为`Tagging`，如果`TokenizerFactory`与`Chunk`的开始和结束不完全匹配，则会引发异常。回顾*在词语标注和片段之间的转换–BIO编解码器*配方，以更好理解这个类的作用。
- en: 'Let''s take a look at the following:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下内容：
- en: '[PRE104]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This codec will translate into a tagging:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这个编解码器将转化为一个标注：
- en: '[PRE105]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The codec will do the reverse operation as well. The Javadoc is worth a visit.
    Once this mapping is established, the rest of the CRF is the same as the word
    tagging case behind the scenes, as shown by the fact that we use the same feature
    extractor in the *Conditional random fields – CRF for word/token tagging* recipe,
    in [Chapter 4](ch04.html "Chapter 4. Tagging Words and Tokens"), *Tagging Words
    and Tokens*. Consider the following code snippet:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 编解码器也将执行相反的操作。Javadoc值得一看。一旦建立了这种映射，剩下的CRF与背后的词性标注案例是相同的，正如我们在*条件随机场 – 用于词语/标记标注*的配方中所展示的那样，参见[第4章](ch04.html
    "第4章. 标注词语和标记")，*标注词语和标记*。考虑以下代码片段：
- en: '[PRE106]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'All the mechanics are hidden inside a new `ChainCrfChunker` class, and it is
    initialized in a manner similar to logistic regression, which is the underlying
    technology. Refer to the *Logistic regression* recipe of [Chapter 3](ch03.html
    "Chapter 3. Advanced Classifiers"), *Advanced Classifiers*, for more information
    on the configuration:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的机制都隐藏在一个新的 `ChainCrfChunker` 类中，它的初始化方式类似于逻辑回归，这是其底层技术。如需了解更多配置信息，请参阅 [第3章](ch03.html
    "第3章 高级分类器")中的 *逻辑回归* 示例，*高级分类器*：
- en: '[PRE107]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The only new thing here is the `tagChunkCodec` parameter, which we just described.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的新内容是我们刚刚描述的 `tagChunkCodec` 参数。
- en: 'Once the training is over, we will access the chunker for first best with the
    following code:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦训练完成，我们将通过以下代码访问分块器的最佳结果：
- en: '[PRE108]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Conditional chunkings are delivered by:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 条件分块由以下内容提供：
- en: '[PRE109]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The individual chunks are accessed with:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下方式访问各个块：
- en: '[PRE110]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: That's it. You have access to one of the world's finest chunking technologies.
    Next, we will show you how to make it better.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些。你已经访问了世界上最优秀的分块技术之一。接下来，我们将向你展示如何改进它。
- en: NER using CRFs with better features
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用更好特征的 CRFs 进行命名实体识别（NER）
- en: In this recipe, we'll show you how to create a realistic, though not quite state-of-the-art,
    set of features for CRFs. The features will include normalized tokens, part-of-speech
    tags, word-shape features, position features, and token prefixes and suffixes.
    Substitute it for the `SimpleCrfFeatureExtractor` in the *CRFs for chunking* recipe
    to use it.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将展示如何为 CRF 创建一个逼真的、尽管不是最先进的、特征集。这些特征将包括标准化的标记、词性标签、词形特征、位置特征以及标记的前后缀。将其替换为
    *CRFs for chunking* 示例中的 `SimpleCrfFeatureExtractor` 进行使用。
- en: How to do it…
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到……
- en: 'The source for this recipe is in `src/com/lingpipe/cookbook/chapter5/FancyCrfFeatureExtractor.java`:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例的源代码位于 `src/com/lingpipe/cookbook/chapter5/FancyCrfFeatureExtractor.java`：
- en: 'Open up your IDE or command prompt and type:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的 IDE 或命令提示符，输入：
- en: '[PRE111]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Brace yourself for an explosion of features from the console. The data being
    used for feature extraction is `TinyEntityCorpus` of the previous recipe. Luckily,
    the first bit of data is just the node features for the "John" in the sentence
    `John ran.`:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备好迎接控制台中爆炸性的特征输出。用于特征提取的数据是上一个示例中的 `TinyEntityCorpus`。幸运的是，第一部分数据仅仅是句子 `John
    ran.` 中 "John" 的节点特征：
- en: '[PRE112]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The next word in the sequence adds edge features—we won''t bother showing you
    the node features:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 序列中的下一个词汇添加了边缘特征——我们不会展示节点特征：
- en: '[PRE113]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: How it works…
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: As with other recipes, we won't bother discussing parts that are very similar
    to previous recipes—the relevant previous recipe here is the *Modifying CRFs*
    recipe in [Chapter 4](ch04.html "Chapter 4. Tagging Words and Tokens"), *Tagging
    Words and Tokens*. This is exactly the same, except for the fact that we will
    add in a lot more features—perhaps, from unexpected sources.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他示例一样，我们不会讨论那些与之前示例非常相似的部分——这里相关的前一个示例是 [第4章](ch04.html "第4章 标记单词和标记")中的 *Modifying
    CRFs*，*标记单词和标记*。这完全相同，唯一不同的是我们将添加更多特征——可能来自意想不到的来源。
- en: Note
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The tutorial for CRFs covers how to serialize/deserialize this class. This implementation
    does not cover it.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: CRFs 的教程涵盖了如何序列化/反序列化这个类。该实现并未覆盖这部分内容。
- en: 'Object construction is similar to the `Modifying CRFs` recipe in [Chapter 4](ch04.html
    "Chapter 4. Tagging Words and Tokens"), *Tagging Words and Tokens*:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 对象构造方式类似于 [第4章](ch04.html "第4章 标记单词和标记")中的 `Modifying CRFs` 示例，*标记单词和标记*：
- en: '[PRE114]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The constructor sets up a part-of-speech tagger with a cache and shoves it into
    the `mPosTagger` member variable.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数设置了一个带有缓存的词性标注器，并将其传递给 `mPosTagger` 成员变量。
- en: 'The following method does very little, except supplying an inner `ChunkerFeatures`
    class:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法几乎不做任何事，只是提供了一个内部的 `ChunkerFeatures` 类：
- en: '[PRE115]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The `ChunkerFeatures` class is where things get more interesting:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChunkerFeatures` 类是更有趣的部分：'
- en: '[PRE116]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The `mPosTagger` function is used to set up `Tagging<String>` for the tokens
    presented on class creation. This will be aligned with the `tag()` and `token()`
    superclass methods and be the source of part-of-speech tags as a node feature.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`mPosTagger` 函数用于为类创建时呈现的标记设置 `Tagging<String>`。这将与 `tag()` 和 `token()` 超类方法对齐，并作为节点特征的来源提供词性标签。'
- en: 'Now, we can get on with the feature extraction. We will start with edge features,
    as they are the simplest:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始特征提取了。我们将从边缘特征开始，因为它们是最简单的：
- en: '[PRE117]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The new feature is prefixed with `PREV_TAG_TOKEN_CAT_`, and the example is `PREV_TAG_TOKEN_CAT_PN_LET-CAP=1.0`.
    The `tokenCat()` method looks at the word shape feature for the previous token
    and returns it as a string. Look at the Javadoc for `IndoEuropeanTokenCategorizer`
    to see what is going on.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 新的特征以 `PREV_TAG_TOKEN_CAT_` 为前缀，示例如 `PREV_TAG_TOKEN_CAT_PN_LET-CAP=1.0`。`tokenCat()`
    方法查看前一个标记的单词形状特征，并将其作为字符串返回。查看 `IndoEuropeanTokenCategorizer` 的 Javadoc 以了解其具体内容。
- en: 'Next comes the node features. There are many of these; each will be presented
    in turn:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是节点特征。这里有许多特征；每个特征将依次呈现：
- en: '[PRE118]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The preceding code sets up the method with the appropriate return type. The
    next two lines set up some state to know where the feature extractor is in the
    string:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码设置了带有适当返回类型的方法。接下来的两行设置了一些状态，以便知道特征提取器在字符串中的位置：
- en: '[PRE119]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Next, we will compute the token categories, tokens, and part-of-speech tags
    for the current position, previous position, and the next position of the input:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将计算当前、前一个和下一个位置的标记类别、标记和词性标注：
- en: '[PRE120]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The previous and next methods check if we're at the begin or end of the sentence
    and return `null` accordingly. The part-of-speech tagging is taken from the saved
    part-of-speech taggings computed in the constructor.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个和下一个方法检查我们是否处于句子的开始或结束，并相应地返回`null`。词性标注来自构造函数中计算并保存的词性标注。
- en: 'The token methods provide some normalization of tokens to compress all numbers
    to the same kind of value. This method is as follows:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 标记方法提供了一些标记规范化，将所有数字压缩为相同类型的值。此方法如下：
- en: '[PRE121]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: This just takes every sequence of numbers and replaces it with `*D...D*`. For
    instance, `12/3/08` is converted to `*DD*/*D*/*DD*`.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是将每个数字序列替换为`*D...D*`。例如，`12/3/08`被转换为`*DD*/*D*/*DD*`。
- en: 'We will then set feature values for the preceding, current, and following tokens.
    First, a flag indicates whether it begins or ends a sentence or an internal node:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将为前一个、当前和后一个标记设置特征值。首先，一个标志表示它是否开始或结束一个句子或内部节点：
- en: '[PRE122]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Next, we will include the tokens, token categories, and their parts of speech:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将包括标记、标记类别及其词性：
- en: '[PRE123]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Finally, we will add the prefix and suffix features, which add features for
    each suffix and prefix (up to a prespecified length):'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加前缀和后缀特征，这些特征为每个后缀和前缀（最多指定长度）添加特征：
- en: '[PRE124]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: After this, we will just return the feature mapping generated.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将返回生成的特征映射。
- en: 'The `prefix` or `suffix` function is simply implemented with a list:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`prefix` 或 `suffix` 函数简单地用一个列表实现：'
- en: '[PRE125]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: That's a nice feature set for your named-entity detector.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的特征集，适合你的命名实体检测器。
