- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Learning Jina’s Basics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 Jina 基础
- en: In the previous chapter, we learned about neural search, and now we can start
    thinking about how to work with it and the steps we’ll need to take to implement
    our own search engine. However, as we saw in previous chapters, in order to implement
    an end-to-end search solution, time and effort will be needed to gather all of
    the resources required. This is where Jina can help as it will take care of many
    of the necessary tasks, letting you focus on the design of your implementation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了神经搜索，现在我们可以开始思考如何使用它，以及我们需要采取的步骤来实现自己的搜索引擎。然而，正如我们在之前的章节中看到的，为了实现一个端到端的搜索解决方案，需要花费时间和精力收集所有必要的资源。Jina
    在这方面可以提供帮助，因为它会处理许多必要的任务，让你可以专注于实现的设计。
- en: 'In this chapter, you will understand the core concepts of Jina: **Documents**,
    **DocumentArrays**, **Executors**, and **Flow**. You will see each of them in
    detail and understand their overall design and how they connect.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将理解 Jina 的核心概念：**文档**、**文档数组**、**执行器**和 **流程**。你将详细了解它们，并理解它们的整体设计及其如何相互连接。
- en: 'We’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主要主题：
- en: Exploring Jina
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Jina
- en: Documents
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档
- en: DocumentArrays
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档数组
- en: Executors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行器
- en: Flow
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程
- en: By the end of this chapter, you will have a solid understanding of idioms in
    Jina, what they are, and how to use them. You will use this knowledge later to
    build your own search engine for any type of modality.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将对 Jina 中的惯用法有一个扎实的理解，了解它们是什么，以及如何使用它们。你将利用这些知识，稍后构建适用于任何类型模态的搜索引擎。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter has the following technical requirements:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有以下技术要求：
- en: A laptop with a minimum of 4 GB of RAM, ideally 8 GB
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台至少拥有 4 GB RAM 的笔记本电脑，理想情况下是 8 GB
- en: Python 3.7, 3.8, or 3.9 installed on a Unix-like operating system, such as macOS
    or Ubuntu
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类似 Unix 的操作系统上安装 Python 3.7、3.8 或 3.9，例如 macOS 或 Ubuntu
- en: Exploring Jina
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Jina
- en: '**Jina** is a framework that helps you build deep learning search systems on
    the cloud using state-of-the-art models. Jina is an infrastructure that allows
    you to focus only on the areas that you are interested in. In this way, you don’t
    need to be involved in every aspect of building a search engine. This involves
    everything from pre-processing your data to spinning up microservices if needed.
    Another good thing about neural search is that you can search for any kind of
    data regardless of type. Here are some examples of how you can search using different
    data types:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jina** 是一个框架，帮助你在云端使用最先进的模型构建深度学习搜索系统。Jina 是一种基础设施，让你可以仅专注于你感兴趣的领域。这样，你就不需要参与构建搜索引擎的每一个方面。这包括从预处理数据到在需要时启动微服务等。神经搜索的另一个好处是你可以搜索任何类型的数据。以下是一些使用不同数据类型进行搜索的示例：'
- en: Image-to-image search
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像到图像搜索
- en: Text-to-image search
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本到图像搜索
- en: Question answering search
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问答搜索
- en: Audio search
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频搜索
- en: Building your own search engine can be very time-consuming, so one of the core
    goals of Jina is reducing the time you would need if you were going to build one
    from scratch. Jina is designed in a layered way that lets you focus only on the
    specific parts that you need, letting the rest of the infrastructure be handled
    in the background. So, for example, you could use pre-trained **Machine Learning**
    (**ML**) models directly instead of building them yourself.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 构建你自己的搜索引擎可能非常耗时，因此 Jina 的核心目标之一是减少从零开始构建一个搜索引擎所需的时间。Jina 采用分层设计，让你只专注于你需要的特定部分，其余的基础设施会在后台处理。例如，你可以直接使用预训练的
    **机器学习**（**ML**）模型，而不必自己构建它们。
- en: Since we live in the era of cloud computing, it makes sense to leverage the
    power that decentralized work can offer, so it is useful to design your solution
    to be distributed on the cloud, and features such as **sharding**, **asynchronizing**,
    and **REST** are fully integrated and work out of the box.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们生活在云计算时代，利用去中心化工作所能提供的力量是有意义的，因此将你的解决方案设计为在云上分布式运行是非常有用的，**分片**、**异步化**和
    **REST** 等功能已经完全集成并可以开箱即用。
- en: 'As we have already said, another way that Jina helps you reduce the time and
    effort needed while building a search engine is by using the latest state-of-the-art
    ML models. You take advantage of this in one of two ways:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，Jina 帮助你减少构建搜索引擎所需时间和精力的另一种方式是使用最新的最先进的 ML 模型。你可以通过以下两种方式之一来利用这一点：
- en: Using one of Jina’s plug-and-play models
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jina 的即插即用模型之一
- en: Developing your own model from scratch for when you have a specialized use case
    or if there is still no model available on Jina Hub
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在有特定应用场景时，从头开始开发你自己的模型，或者如果 Jina Hub 上还没有合适的模型可用。
- en: With these options, you can choose between having a pre-defined model or implementing
    your own if your needs are not covered.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些选项，你可以选择使用预定义模型，或者如果你的需求没有被涵盖，可以实现你自己的模型。
- en: 'As you can imagine, all of this means that there are a lot of components working
    in the background. The more you learn, the more power you will have over your
    application, but to start, you will need to understand the basic components of
    Jina, which we will discuss in the following sections:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想，这意味着后台有很多组件在工作。你学得越多，掌握应用程序的能力就越强，但首先，你需要理解 Jina 的基本组件，我们将在接下来的章节中讨论这些组件：
- en: Documents
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档
- en: DocumentArrays
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档数组
- en: Executors
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行器
- en: Flows
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程
- en: Documents
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档
- en: In Jina, **Documents** are the most basic data type you can work with. They
    are the data you want to use and can be used for indexing and/or querying. They
    can be made with whatever data type you require, such as text, gifs, PDF files,
    3D meshes, and so on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jina 中，**文档**是你可以使用的最基本的数据类型。它们是你希望使用的数据，并且可以用于索引和/或查询。你可以用任何你需要的数据类型来创建文档，例如文本、GIF、PDF
    文件、3D 网格等等。
- en: We will use Documents to index and query, but since Documents can be of any
    type and size, it’s likely that we will need to divide them before use.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用文档来进行索引和查询，但由于文档可以是任何类型和大小，因此我们可能需要在使用之前将其拆分。
- en: 'As an analogy, think of a Document as a chocolate bar. There are several types
    of chocolate: white, dark, milk, and so on. Likewise, a Document can be of several
    types, such as audio, text, video, a 3D mesh, and so on. Also, if we have a big
    chocolate bar, we will probably divide it into smaller pieces before eating it.
    Accordingly, if we have a big Document, we should divide it into smaller pieces
    before indexing.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 作为类比，想象一个文档就像一块巧克力。巧克力有几种类型：白巧克力、黑巧克力、牛奶巧克力等等。同样，文档也可以有多种类型，例如音频、文本、视频、3D 网格等等。另外，如果我们有一块大巧克力，可能会在吃之前把它分成小块。类似地，如果我们有一个大的文档，在建立索引之前，应该把它分成小块。
- en: 'This is how a Document looks in Python code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是文档在 Python 代码中的表现形式：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, all you need to create a Document is to import it from Jina
    and create it as you would any other object in Python. This is a very basic example,
    but in real life, you will have more complex cases, so we will need to add some
    attributes, which we will see next.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，创建文档所需要做的就是从 Jina 导入它，并像处理任何其他 Python 对象一样创建它。这是一个非常基础的示例，但在实际应用中，你会遇到更复杂的情况，因此我们需要添加一些属性，接下来我们将看到这些属性。
- en: Document attributes
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档属性
- en: 'Each Document can have different attributes that belong to four main categories:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文档可以有不同的属性，这些属性属于四个主要类别：
- en: '**Content**: This refers to the actual content of your Document. For example,
    the text or its embedded vector.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容**：这是指文档的实际内容。例如，文本或其嵌入向量。'
- en: '**Meta**: This is information about the Document itself. For example, its ID
    and whether it has any tags.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元数据**：这是关于文档本身的信息。例如，它的ID以及是否有标签。'
- en: '**Recursive**: This tells us how the Document is divided. For example, its
    matches or if it was divided into any chunks.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**递归**：这告诉我们文档是如何被分割的。例如，它的匹配项，或是否被分成了若干块。'
- en: '**Relevance**: This refers to the relevance of the Document, such as its score.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相关性**：这是指文档的相关性，例如其分数。'
- en: 'These categories consist of various attributes, which are listed in the following
    table:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类别由各种属性组成，具体列在下面的表格中：
- en: '| **Category** | **Attributes** |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **类别** | **属性** |'
- en: '| Content attributes | `.buffer`, `.blob`, `.text`, `.uri`, `.content`, `.embedding`
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 内容属性 | `.buffer`, `.blob`, `.text`, `.uri`, `.content`, `.embedding` |'
- en: '| Meta attributes | `.id`, `.parent_id`, `.weight`, .`mime_type`, `.content_type`,
    `.tags`, `.modality` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 元数据属性 | `.id`, `.parent_id`, `.weight`, `.mime_type`, `.content_type`, `.tags`,
    `.modality` |'
- en: '| Recursive attributes | `.chunks`, `.matches`, `.granularity`, `.adjacency`
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 递归属性 | `.chunks`, `.matches`, `.granularity`, `.adjacency` |'
- en: '| Relevance attributes | `.score`, `.evaluations` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 相关性属性 | `.score`, `.evaluations` |'
- en: Table 4.1 – Document categories and their attributes
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 – 文档类别及其属性
- en: We will see later in more detail what each of those attributes are, but first,
    let’s see how to set them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会更详细地了解这些属性，但首先，先来看看如何设置它们。
- en: Setting and unsetting attributes
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置和取消设置属性
- en: 'The attributes in *Table 4.1* are the possible attributes we can use with our
    Document. Let’s say we want our Document to have the text `hello world`. We can
    do this by setting its `text` attribute like so:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 4.1* 中的属性是我们可以与文档一起使用的可能属性。假设我们希望文档包含文本 `hello world`。我们可以通过设置其 `text` 属性来做到这一点：'
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And if we want to unset it, we can do so as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想取消设置它，可以如下操作：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In plenty of real-world cases, we will need to work with multiple attributes,
    and it is also possible to unset several of these at once:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多实际场景中，我们需要处理多个属性，且也可以同时取消设置其中的多个属性：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Accessing nested attributes from tags
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问标签中的嵌套属性
- en: 'In Jina, each Document contains tags that hold a map-like structure that can
    map arbitrary values:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jina 中，每个文档包含标签，这些标签持有类似映射的结构，可以映射任意值：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you want to access the nested fields, you can do so by using the attribute
    name with the symbol `__` interlaced. For example, if you would like to access
    the `weight` tag, you should do the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想访问嵌套字段，可以使用属性名，并用符号 `__` 连接。例如，如果你想访问 `weight` 标签，可以这样做：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Constructing a Document
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建文档
- en: To construct a Document, you need to fill it with attributes, so let’s take
    a look at them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个文档，你需要为其填充属性，让我们来看看这些属性。
- en: Content attributes
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内容属性
- en: 'Each Document needs to contain some information about itself, ranging from
    raw binary content to text info. We can see the details that a Document can have
    in the following table:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文档都需要包含一些关于它自身的信息，从原始二进制内容到文本信息。我们可以在下表中看到文档可以包含的详细信息：
- en: '| **Attribute** | **Description** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| `doc.buffer` | The raw binary content of the Document |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `doc.buffer` | 文档的原始二进制内容 |'
- en: '| `doc.blob` | The ndarray of the image/audio/video Document |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `doc.blob` | 图像/音频/视频文档的 ndarray |'
- en: '| `doc.text` | The text info of the Document |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `doc.text` | 文档的文本信息 |'
- en: '| `doc.uri` | A Document URI could be a local file path, a remote URL that
    starts with http or https, or a data URI scheme |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `doc.uri` | 文档 URI 可以是本地文件路径、以 http 或 https 开头的远程 URL，或者是数据 URI 方案 |'
- en: '| `doc.content` | This can be any of the previous attributes (buffer, blob,
    text, uri) |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `doc.content` | 这可以是之前提到的任何属性（buffer、blob、text、uri） |'
- en: '| `doc.embedding` | The embedding ndarray of the Document |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `doc.embedding` | 文档的嵌入 ndarray |'
- en: Table 4.2 - Content attributes
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.2 - 内容属性
- en: 'There are two ways you can assign a *content* type to your Document. If you
    know exactly what type it is, you can assign it explicitly with the `text`, `blob`,
    `buffer`, or `uri` attributes. If you don’t know the type, you can use `.content`,
    which will automatically assign a type to your Document based on what it’s most
    likely to be. See this, for example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以为文档分配 *内容* 类型。如果你确切知道内容类型，可以明确地使用 `text`、`blob`、`buffer` 或 `uri` 属性进行分配。如果你不知道类型，可以使用
    `.content`，它将根据内容的类型自动为文档分配一个类型。例如，请看以下示例：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this example, the following applies:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，以下内容适用：
- en: '`document1` will have a field of `text`.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`document1` 将有一个 `text` 字段。'
- en: '`document2` will have a field of `buffer`.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`document2` 将有一个 `buffer` 字段。'
- en: '`document3` will have a field of `blob`.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`document3` 将有一个 `blob` 字段。'
- en: '`document4` will have a field of `uri`.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`document4` 将有一个 `uri` 字段。'
- en: The content will be automatically assigned to any one of the `text`, `buffer`,
    `blob`, or `uri` fields. The `id` and `mime_type` attributes are auto-generated
    when not set explicitly. This means that you can specify explicitly the ID and
    type (`mime_type`) of your document, otherwise it will be autogenerated.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 内容将自动分配给 `text`、`buffer`、`blob` 或 `uri` 其中之一。当未显式设置时，`id` 和 `mime_type` 属性会自动生成。这意味着你可以显式指定文档的
    ID 和类型（`mime_type`），否则它们将自动生成。
- en: Exclusivity of doc.content
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: doc.content 的独占性
- en: 'In Jina, each Document can only contain one type of content: `text`, `buffer`,
    `blob`, or `uri`. Setting `text` first and then setting `uri` will clear the `text`
    field.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jina 中，每个文档只能包含一种类型的内容：`text`、`buffer`、`blob` 或 `uri`。如果先设置 `text`，再设置 `uri`，则会清空
    `text` 字段。
- en: In the following figure, you can see the different types that content can have,
    as well as the fact that each Document can only have one type.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，你可以看到内容可能具有的不同类型，以及每个文档只能有一种类型。
- en: '![Figure 4.1 – Possible content types in a Document ](img/Figure_4.1_B17488.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 文档中的可能内容类型](img/Figure_4.1_B17488.jpg)'
- en: Figure 4.1 – Possible content types in a Document
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 文档中的可能内容类型
- en: 'Let’s see how we would set the `content` attribute of a Document in code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在代码中设置文档的 `content` 属性：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can see how you can set every type of attribute in a Document, but if you
    assign different values to a single Document, only the last attribute will be
    valid.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到如何在文档中设置每种类型的属性，但如果你为一个文档分配不同的值，只有最后一个属性会有效。
- en: Conversion of doc.content
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: doc.content 的转换
- en: 'Now that you’ve seen the different possible attributes in Jina, you might be
    thinking that sometimes it’d be useful to convert one type of `doc.content` to
    another. For example, if you had a Document and its path (`uri`), but you needed
    it in a text format, you could use one of these pre-made conversion functions
    to easily switch the content type:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了 Jina 中不同的可能属性，你可能会想，有时将一种类型的 `doc.content` 转换为另一种类型会很有用。例如，如果你有一个文档及其路径（`uri`），但你需要它是文本格式的，你可以使用这些预制的转换函数轻松地切换内容类型：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, all of these methods will help you transform your data from
    one type to another, but all of these types will need to be transformed into vector
    embeddings . Let’s see what exactly an embedding is and why we use them in neural
    search.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，所有这些方法都将帮助你将数据从一种类型转换为另一种类型，但所有这些类型都需要转换为向量嵌入。让我们来看看嵌入到底是什么，以及为什么我们在神经搜索中使用它们。
- en: Setting an embedding attribute
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置嵌入属性
- en: An embedding is a high-dimensional representation of a Document, and it’s a
    key element in neural search. Embeddings are representations of your data in a
    vector format. This is why neural search can be used for any kind of data regardless
    of its type (image, audio, text, and so on). The data will be transformed into
    vectors (embeddings), and those vectors are the ones that will be used in neural
    search. Therefore, the type doesn’t matter as neural search ends up working only
    with vectors.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入是文档的高维表示，是神经搜索中的关键元素。嵌入是数据的向量格式表示。这就是为什么神经搜索可以用于任何类型的数据，无论是图像、音频、文本等等。数据将被转换为向量（嵌入），而这些向量将被用于神经搜索。因此，类型并不重要，因为神经搜索最终只处理向量。
- en: 'Since we are working with vectors, it is useful to work with already-established
    libraries that have extensive support for embeddings, such as NumPy, so you can,
    for example, assign any NumPy `ndarray` as a Document’s embedding and then use
    the flexibility that those libraries provide:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在处理向量，因此使用已经建立的支持嵌入的库（如 NumPy）非常有用，这样你就可以例如将任何 NumPy `ndarray` 作为文档的嵌入，然后使用这些库提供的灵活性：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Meta attributes
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元数据属性
- en: 'Apart from content attributes, you can also have meta attributes:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内容属性外，你还可以有元数据属性：
- en: '| **Attribute** | **Description** |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| `doc.tags` | Used to store the meta-information of the Document |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `doc.tags` | 用于存储文档的元信息 |'
- en: '| `doc.id` | A hexdigest that represents a unique Document ID |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `doc.id` | 表示唯一文档 ID 的十六进制摘要 |'
- en: '| `doc.parent_id` | A hexdigest that represents the Document’s parent ID |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `doc.parent_id` | 表示文档父级 ID 的十六进制摘要 |'
- en: '| `doc.weight` | The weight of the Document |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `doc.weight` | 文档的权重 |'
- en: '| `doc.mime_type` | The mime type of the Document |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `doc.mime_type` | 文档的 MIME 类型 |'
- en: '| `doc.content_type` | The content type of the Document |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `doc.content_type` | 文档的内容类型 |'
- en: '| `doc.modality` | An identifier of the modality of the Document such as an
    image, text, and so on |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `doc.modality` | 文档的模态标识符，例如图像、文本等 |'
- en: Table 4.3 – Meta attributes
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.3 – 元数据属性
- en: 'To create your Document, you can assign multiple attributes in its constructor
    as shown here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建文档，你可以在构造函数中分配多个属性，如下所示：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Constructing a Document from dictionary or a JSON string
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从字典或 JSON 字符串构建文档
- en: 'There’s also the option to construct your Document directly from a Python dictionary
    or JSON string. If you have the information of your Document already stored in
    those formats, you can conveniently create the Document using the following example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种选择是直接从 Python 字典或 JSON 字符串构建文档。如果你已经将文档信息存储在这些格式中，你可以方便地使用以下示例创建文档：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Parsing unrecognized fields
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解析未识别的字段
- en: 'If the fields in dictionary/a JSON string are not recognized, they are automatically
    put into the `document.tags` field. As shown in the following example, `foo` is
    not a defined attribute (*Table 4.3*), so it will be automatically parsed into
    the `tags` field:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字典/JSON 字符串中的字段无法识别，它们将自动放入`document.tags`字段。如下面的示例所示，`foo` 不是一个已定义的属性（*表
    4.3*），因此它将被自动解析到 `tags` 字段中：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can use `field_resolver` to map external field names to Document attributes:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`field_resolver`将外部字段名映射到文档属性：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Constructing a Document from other Documents
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从其他 Documents 构建 Document
- en: 'In case you want to duplicate a Document, the following are ways to do so:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想复制一个 Document，以下是几种方法：
- en: '**Shallow copy**: Assigning a Document object to another Document object will
    make a shallow copy:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浅拷贝**：将一个 Document 对象赋值给另一个 Document 对象将创建一个浅拷贝：'
- en: '[PRE14]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`copy=True`:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy=True`：'
- en: '[PRE15]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Partial copy**: You can partially update a Document according to another
    source Document:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分拷贝**：你可以根据另一个源 Document 部分更新一个 Document：'
- en: '![](img/Figure_4.2_B17488.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_4.2_B17488.jpg)'
- en: You can use any of the three preceding methods to copy a Document.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用前三种方法中的任何一种来复制一个 Document。
- en: Constructing a Document from file types such as JSON, CSV, ndarray, and others
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JSON、CSV、ndarray 等文件类型构建 Document
- en: The `jina.types.document.generators` module lets you construct Documents from
    common file types such as `JSON`, `CSV`, `ndarray`, and text files.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`jina.types.document.generators` 模块允许你从常见的文件类型（如 `JSON`、`CSV`、`ndarray` 和文本文件）构建
    Document。'
- en: 'The following functions will create a generator of Documents, where each `Document`
    object corresponds to a line/row in the original format:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数将创建一个 Document 的生成器，每个 `Document` 对象对应原始格式中的一行/一列：
- en: '| **Import Method** | **Description** |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **导入方法** | **描述** |'
- en: '| `from_ndjson()` | This function yields a Document from a line-based JSON
    file. Each line is a Document object. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `from_ndjson()` | 该函数从基于行的 JSON 文件中生成一个 Document。每一行是一个 Document 对象。 |'
- en: '| `from_csv()` | This function yields a Document from a .csv file. Each line
    is a Document object. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `from_csv()` | 该函数从 .csv 文件中生成一个 Document。每一行是一个 Document 对象。 |'
- en: '| `from_files()` | This function yields a Document from a glob file. Each file
    is a Document object. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `from_files()` | 该函数从 glob 文件中生成一个 Document。每个文件都是一个 Document 对象。 |'
- en: '| `from_ndarray()` | This function yields a Document from an ndarray. Each
    row (depending on the axis) is a Document object. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `from_ndarray()` | 该函数从 ndarray 中生成一个 Document。每一行（根据轴的不同）是一个 Document 对象。
    |'
- en: '| `from_lines()` | This function yields a Document from lines, of JSON, and
    CSV. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `from_lines()` | 该函数从 JSON 和 CSV 的行中生成一个 Document。 |'
- en: Table 4.4 – Python methods for constructing Documents
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.4 – 构建 Document 的 Python 方法
- en: Using a generator is sometimes less memory-intensive, as it does not load/build
    all Document objects in one go.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生成器有时能节省内存，因为它不会一次性加载/构建所有 Document 对象。
- en: Now you have learned what a Document is and how to create one. You can create
    it either by filling it with individual bits of content, or by copying from a
    JSON file if you already have one.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了什么是 Document，以及如何创建一个 Document。你可以通过填充个别内容来创建它，或者如果你已有 JSON 文件，也可以通过复制来创建。
- en: DocumentArray
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DocumentArray
- en: Another powerful concept in Jina is the `insert`, `delete`, `construct`, `traverse`,
    and `sort`. The DocumentArray is a first-class citizen to an Executor, serving
    as its input and output. We will talk about Executors in the next section, but
    for now, think of them as the way Jina processes Documents.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Jina 中的另一个强大概念是 `insert`、`delete`、`construct`、`traverse` 和 `sort`。DocumentArray
    是 Executor 的一等公民，作为其输入和输出。我们将在下一节讨论 Executors，但现在，你可以将它们看作 Jina 处理文档的方式。
- en: Constructing a DocumentArray
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个 DocumentArray
- en: 'You can construct, delete, insert, sort, and traverse a `DocumentArray` like
    a Python list. You can create these in different ways:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像使用 Python 列表一样构建、删除、插入、排序和遍历 `DocumentArray`。你可以通过不同的方式来创建这些：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Just like a normal Document, the DocumentArray also supports different methods
    as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 就像普通的 Document 一样，DocumentArray 也支持以下不同的方法：
- en: '| **Category** | **Attributes** |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **类别** | **属性** |'
- en: '| Python list-like interface | `__getitem__`, `__setitem__`, `__delitem__`,
    `__len__`, `insert`, `append`, `reverse`, `extend`, `__iadd__`, `__add__`, `__iter__`,
    `clear`, `sort, shuffle`, `sample` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 类似 Python 列表的接口 | `__getitem__`、`__setitem__`、`__delitem__`、`__len__`、`insert`、`append`、`reverse`、`extend`、`__iadd__`、`__add__`、`__iter__`、`clear`、`sort,
    shuffle`、`sample` |'
- en: '| Persistence   | `save`, `load` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 持久化 | `save`、`load` |'
- en: '| Neural search operations | `match`, `visualize` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 神经搜索操作 | `match`、`visualize` |'
- en: '| Advanced getters   | `get_attributes`, `get_attributes_with_docs`, `traverse_flat`,
    `traverse` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 高级获取器 | `get_attributes`、`get_attributes_with_docs`、`traverse_flat`、`traverse`
    |'
- en: Table 4.5 – DocumentArray attributes
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.5 – DocumentArray 属性
- en: Persistence via save()/load()
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 save()/load() 实现持久化
- en: 'Of course, there will be cases where you want to save the elements of your
    DocumentArray for further processing, and you can save all elements in a DocumentArray
    in two ways:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也会有一些情况，你希望将 DocumentArray 中的元素保存以便进一步处理，你可以通过两种方式将所有元素保存到 DocumentArray
    中：
- en: In JSON line format
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 JSON 行格式
- en: In binary format
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以二进制格式
- en: 'To save it in JSON line format, you can do the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 若要以JSON行格式保存，你可以执行以下操作：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And to store it in binary format, which is much faster and yields smaller files,
    you can do the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 若要以二进制格式存储，它会更快且生成更小的文件，你可以执行以下操作：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Basic operations
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本操作
- en: 'Like with any other object, you can perform basic operations on a DocumentArray.
    This includes the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 和任何其他对象一样，你可以对DocumentArray执行基本操作，包括以下内容：
- en: Accessing elements
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问元素
- en: Sorting elements
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序元素
- en: Filtering elements
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤元素
- en: Let’s learn about these in detail.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解这些。
- en: Accessing elements
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 访问元素
- en: 'You can access a Document in the DocumentArray via an index, ID, or slice indices,
    as shown here:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过索引、ID或切片索引来访问DocumentArray中的Document，如下所示：
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Feel free to use to any variation of these options depending on your use case
    scenario.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的使用场景，可以随意使用这些选项的任意变体。
- en: Sorting elements
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 排序元素
- en: 'Because `DocumentArray` is a subclass of `MutableSequence`, you can use the
    built-in Python function `sort` to sort elements in a DocumentArray. For example,
    if you want to sort elements in-place (without making copies), and use the `tags[id]`
    value in a descending manner, you can do the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`DocumentArray`是`MutableSequence`的子类，你可以使用内置的Python函数`sort`来对DocumentArray中的元素进行排序。例如，如果你想就地排序元素（不进行复制），并按降序使用`tags[id]`值，可以执行以下操作：
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code would print the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将输出以下内容：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Filtering elements
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 过滤元素
- en: 'You can use Python’s built-in `filter` function to filter elements in a `DocumentArray`
    object:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Python的内置`filter`函数来过滤`DocumentArray`对象中的元素：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This would print the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can also build a `DocumentArray` object from the filtered results as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过以下方式，从过滤结果中构建一个`DocumentArray`对象：
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This would print the following result:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下结果：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: At this point, you have learned how to create Documents and DocumentArrays that
    store multiple Documents as a list. But what can you actually do with these? How
    can you process them for use in neural search? This is where Executors come into
    the picture. Let’s talk about them in the following section.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你已经学习了如何创建存储多个文档的Documents和DocumentArrays（作为一个列表）。但是，你实际上能用这些做什么呢？如何将它们用于神经网络搜索？这时，Executor就发挥作用了。接下来的部分我们将讨论Executor。
- en: Executors
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Executors
- en: The **Executor** represents the processing component in a Jina Flow. It performs
    a single task on a Document or DocumentArray. You can think of an Executor as
    the logical part of Jina. Executors are the ones that will perform tasks of all
    kinds on a Document. For example, you could have an Executor for extracting text
    from a PDF file, or for encoding audio for your Document. They handle all of the
    algorithmic tasks in Jina.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**Executor**代表Jina Flow中的处理组件。它对Document或DocumentArray执行单个任务。你可以将Executor看作Jina的逻辑部分。Executors是执行各种任务的主体。例如，你可以有一个用于从PDF文件中提取文本的Executor，或者为Document编码音频的Executor。它们处理Jina中的所有算法任务。'
- en: Since Executors are one of the main parts of Jina, and they are the ones that
    perform all the algorithmic tasks, it would be very useful for you to make them
    in a way that means they could be easily shared with other people, so that others
    can re-use your work. Similarly, you could use prebuilt Executors made by someone
    else in your own code. This is in fact possible because Executors are easily available
    in a marketplace, which in Jina is called Jina Hub ([https://hub.jina.ai/](https://hub.jina.ai/)). There
    you can browse between various Executors that solve different tasks, and you can
    just select the one that is useful to you and use it in your code. Of course,
    it’s possible that the Executor for the task you need to do has not already been
    built in Jina Hub, in which case you’ll need to create your own Executor. You
    can do this easily in Jina Hub. Let’s take a deep dive into how to do that.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Executor是Jina的主要组成部分，它们执行所有算法任务，因此你创建Executor时，可以使其更易于与他人共享，这样他人就可以重用你的工作。同样，你也可以在自己的代码中使用别人预构建的Executor。事实上，这完全可行，因为Executor在市场中是可以轻松获得的，在Jina中这个市场叫做Jina
    Hub ([https://hub.jina.ai/](https://hub.jina.ai/))。你可以浏览各种解决不同任务的Executor，只需选择对你有用的Executor并在代码中使用它。当然，可能你需要的任务Executor还没有在Jina
    Hub中构建好，在这种情况下，你将需要创建自己的Executor。这在Jina Hub中很容易实现。让我们深入了解如何做到这一点。
- en: Creating an Executor
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Executor
- en: 'To create an Executor, it’s best to use Jina Hub, which will generate a wizard
    to guide you through the process. To start this process, open a console and write
    the following command:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Executor 最好使用 Jina Hub，它将生成一个向导，指导你完成整个过程。要启动此过程，请打开控制台并输入以下命令：
- en: '[PRE26]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will trigger a wizard that will guide you through the creation of the
    Executor and ask you for some details about it:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这将触发一个向导，指导你完成 Executor 的创建并要求你提供一些关于它的细节：
- en: '![Figure 4.3 – Creating an Executor via the CLI ](img/Figure_4.3_B17488.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 通过 CLI 创建 Executor ](img/Figure_4.3_B17488.jpg)'
- en: Figure 4.3 – Creating an Executor via the CLI
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 通过 CLI 创建 Executor
- en: After going through the wizard, your Executor will be ready. Now, let’s learn
    about Executors in more detail.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 经过向导后，你的 Executor 就准备好了。现在，让我们更详细地了解 Executors。
- en: 'Executors process DocumentArrays in-place via functions decorated with `@requests`.
    We add this decorator to whatever functions we want in our Executors. When creating
    an Executor, three principles should be kept in mind:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Executors 通过带有 `@requests` 装饰器的函数就地处理 DocumentArrays。我们将此装饰器添加到我们希望在 Executors
    中使用的任何函数。当创建 Executor 时，应牢记三个原则：
- en: It should be a subclass of the `jina.Executor` class.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该是 `jina.Executor` 类的子类。
- en: It must be a bag-of-functions with the state `shared`. It can contain an arbitrary
    number of functions with arbitrary names.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须是一个带有 `shared` 状态的函数集合。它可以包含任意数量的函数，函数名也可以任意。
- en: Functions decorated by `@requests` will be invoked according to their `on= endpoint`.
    We will see different cases of what those endpoints could be in the following
    example.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被 `@requests` 装饰的函数将根据它们的 `on=端点` 被调用。我们将在以下示例中看到这些端点可能是什么。
- en: 'Here is a very basic Executor in Python to help you understand this last concept
    better:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常基本的 Python Executor，帮助你更好地理解最后这个概念：
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The name of your Executor can be whatever you wish, but the important thing
    to remember is that every new Executor should be a subclass of `jina.Executor`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Executor 名称可以是你想要的任何名称，但需要记住的重要一点是，每个新的 Executor 应该是 `jina.Executor` 的子类。
- en: Constructor
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'You don’t need to implement the constructor (`__init__`) if your Executor does
    not contain initial states, but if your Executor has `__init__`, it needs to carry
    `**kwargs` in the signature and call `super().__init__(**kwargs)` into the body:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 Executor 不包含初始状态，则不需要实现构造函数（`__init__`）。但如果你的 Executor 有 `__init__`，它需要在函数签名中携带
    `**kwargs`，并在函数体内调用 `super().__init__(**kwargs)`：
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Method decorator
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法装饰器
- en: The `@requests` decorator defines when a function will be invoked. It has the
    `on=` keyword, which defines the endpoint. We haven’t talked about Flow yet. We
    will do so in the next section, but for now, think of Flow as a manager. The `@requests`
    decorator sends information to Flow whenever our Executor needs to be called.
    This is to communicate to Flow when the function will be called and at which endpoint.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`@requests` 装饰器定义了何时调用一个函数。它有一个 `on=` 关键字，用于定义端点。我们还没有谈到 Flow。我们将在下一节中讲解它，但现在，可以将
    Flow 想象成一个管理器。每当我们的 Executor 需要被调用时，`@requests` 装饰器会将信息发送到 Flow。这是为了向 Flow 通信何时以及在什么端点调用该函数。'
- en: 'You can use the decorator like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样使用装饰器：
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this example, we have three endpoints:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们有三个端点：
- en: '`on=''/index''`: This endpoint will trigger the `MyExecutor.foo` method.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on=''/index''`：此端点将触发 `MyExecutor.foo` 方法。'
- en: '`on=''/random_work''`: This endpoint will trigger the `MyExecutor.bar` method.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on=''/random_work''`：此端点将触发 `MyExecutor.bar` 方法。'
- en: '`on=''/blah'':` This endpoint will not trigger any methods, as no function
    is bound to `MyExecutor.blah`.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on=''/blah''`：此端点不会触发任何方法，因为没有函数绑定到 `MyExecutor.blah`。'
- en: Executor binding
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Executor 绑定
- en: Now that we have seen how to create Executors and learned about the `@requests`
    decorator, you might be wondering what types of binding you can use with `@requests`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何创建 Executors，并了解了 `@requests` 装饰器，你可能会想知道可以使用哪些类型的绑定与 `@requests`。
- en: Default binding
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 默认绑定
- en: 'A class method decorated with plain `@requests` is the default handler for
    all endpoints. This means that it is the fallback handler for endpoints that are
    not found. Let’s see one example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用普通的 `@requests` 装饰器装饰的类方法是所有端点的默认处理程序。这意味着它是未找到的端点的回退处理程序。让我们来看一个例子：
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this example, two functions were defined:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，定义了两个函数：
- en: '`foo`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foo`'
- en: '`bar`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bar`'
- en: Here the `foo` function becomes the default method since it has no `on=` keyword.
    If we were now to use an unknown endpoint, such as `f.post(on='/blah', ...)`,
    it would invoke `MyExecutor.foo` since there is no `on='/blah'` endpoint.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `foo` 函数成为默认方法，因为它没有 `on=` 关键字。如果我们现在使用一个未知的端点，例如 `f.post(on='/blah', ...)`，它会调用
    `MyExecutor.foo`，因为没有 `on='/blah'` 端点。
- en: Multiple bindings
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多重绑定
- en: To bind a method with multiple endpoints, you can use `@requests(on=['/foo',
    '/bar'])`. This allows either `f.post(on='/foo', ...)` or `f.post(on='/bar', ...)`
    to invoke the function.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要将方法绑定到多个端点，你可以使用 `@requests(on=['/foo', '/bar'])`。这样，`f.post(on='/foo', ...)`
    或 `f.post(on='/bar', ...)` 都可以调用这个函数。
- en: No binding
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无绑定
- en: A class with no `@requests` binding plays no part in the a Flow. The request
    will simply pass through without any processing.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 没有 `@requests` 绑定的类在 Flow 中不起作用。请求会直接通过而不进行任何处理。
- en: Now you know what an Executor is and why it is useful to share them with other
    developers. You have also learned where to find already-published Executors and
    how to publish your own. Let’s see now how to put together the concepts you’ve
    learned so far.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了执行器是什么，并且知道为什么与其他开发人员共享它们是有用的。你还学会了如何查找已发布的执行器以及如何发布自己的执行器。现在让我们看看如何将你迄今为止学到的概念结合起来。
- en: Flow
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flow
- en: Now that you know what Documents and Executors are and how to work with them,
    we can start to talk about **Flow**, one of the most important concepts in Jina.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了文档（Documents）和执行器（Executors）是什么，以及如何使用它们，我们可以开始讨论 **Flow**，这是 Jina 中最重要的概念之一。
- en: Think of Flow as a manager in Jina; it takes care of all the tasks that will
    run on your application and will use Documents as its input and output.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 可以把 Flow 看作 Jina 中的一个管理器；它负责处理应用程序中所有要运行的任务，并以文档（Documents）作为输入和输出。
- en: Creating a Flow
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Flow
- en: 'The creation of a Flow in Jina is very easy and works just like any other object
    in Python. For example, this is how you would create an empty Flow:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jina 中创建 Flow 非常简单，和在 Python 中创建任何其他对象一样。比如，这就是如何创建一个空的 Flow：
- en: '[PRE31]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In order to use a Flow, it’s best to always open it as a context manager, just
    like you would open a file in Python, by using the `with` function:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Flow，最好始终将其作为上下文管理器打开，就像在 Python 中打开文件一样，可以使用 `with` 函数：
- en: '[PRE32]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Flow follows a lazy construction pattern: it won’t actually run unless you
    use the `with` function to open it.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Flow 遵循懒加载模式：除非你使用 `with` 函数打开它，否则它不会实际运行。
- en: Adding Executors to a Flow
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向流程中添加执行器
- en: To add elements to your Flow, all you need to do is use the `.add()` method.
    You can add as many elements as you wish.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要向你的 Flow 添加元素，只需要使用 `.add()` 方法。你可以根据需要添加任意数量的元素。
- en: 'The `.add()` method is used to add an Executor to a Flow object. Each `.add()`
    instance adds a new Executor, and these Executors can be run as a local thread,
    local process, remote process, inside a Docker container, or even inside a remote
    Docker container. You can add as many as you need like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`.add()` 方法用于向 Flow 对象中添加执行器。每个 `.add()` 实例会添加一个新的执行器，这些执行器可以作为本地线程、本地进程、远程进程、Docker
    容器内甚至远程 Docker 容器中的进程运行。你可以像这样添加任意数量的执行器：'
- en: '[PRE33]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Defining an Executor via uses
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 uses 定义执行器
- en: 'You can use the `uses` parameter to specify the Executor that you are using.
    The `uses` parameter accepts multiple value types including class names, Docker
    images, and (inline) YAML. Therefore, you can add an Executor via this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `uses` 参数来指定你正在使用的执行器。`uses` 参数支持多种类型的值，包括类名、Docker 镜像和（内联）YAML。因此，你可以通过以下方式添加执行器：
- en: '[PRE34]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Visualizing a Flow
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可视化 Flow
- en: 'If you want to visualize your Flow, you can do so with the`.plot()` function.
    This will create a `.svg` file with the visualized Flow. To do this, add the `.plot()`
    function at the end of your Flow and use the intended title of your `.svg` file:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想可视化你的 Flow，可以使用 `.plot()` 函数。这将生成一个包含可视化流程的 `.svg` 文件。为此，只需在 Flow 末尾添加 `.plot()`
    函数，并使用你希望的 `.svg` 文件标题：
- en: '[PRE35]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding snippet will produce the following figure with the corresponding
    Flow:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段将生成如下图形和相应的 Flow：
- en: '![Figure 4.4 – Example of a Flow ](img/Figure_4.4_B17488.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 流程示例](img/Figure_4.4_B17488.jpg)'
- en: Figure 4.4 – Example of a Flow
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 流程示例
- en: Note
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In Jupyter Lab/Notebook, the Flow object is rendered automatically without needing
    to call `.plot()`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jupyter Lab/Notebook 中，Flow 对象会自动渲染，无需调用 `.plot()`。
- en: 'You can also use CRUD methods (index, search, update, delete), which are just
    sugary syntax forms of post with `on=''/index'', on=''/search''`. These are laid
    out in the following list:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 CRUD 方法（index, search, update, delete），这些只是带有`on='/index', on='/search'`的糖语法形式的
    post。它们列在以下清单中：
- en: '`index = partialmethod(post, ''/index'')`'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index = partialmethod(post, ''/index'')`'
- en: '`search = partialmethod(post, ''/search'')`'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search = partialmethod(post, ''/search'')`'
- en: '`update = partialmethod(post, ''/update'')`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update = partialmethod(post, ''/update'')`'
- en: '`delete = partialmethod(post, ''/delete'')`'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete = partialmethod(post, ''/delete'')`'
- en: 'So, taking the previous concepts together, a minimal working example requires
    the creation of an Executor that extends from the base Executor class and can
    be used together with your Flow:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，综合前述概念，一个最小的工作示例需要创建一个从基本 Executor 类扩展出来的 Executor，并且可以与你的 Flow 一起使用：
- en: '[PRE36]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: That’s it! You now have a minimal working example and have covered the basics
    of Jina. We’ll see more advanced uses in the next chapters, but if you’ve learned
    the Document, DocumentArray, Executor, and Flow concepts, you are good to go.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在你有一个最小的工作示例，并且已经掌握了 Jina 的基础知识。在接下来的章节中，我们将看到更多高级用法，但如果你已经学会了 Document、DocumentArray、Executor
    和 Flow 的概念，那么你已经准备好了。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'This chapter introduced the main concepts in Jina: Document, DocumentArray,
    Flow, and Executor. You should now have an overview of what each of those concepts
    are, why they are important, and how they relate to each other.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 Jina 中的主要概念：Document、DocumentArray、Flow 和 Executor。现在，你应该对这些概念是什么、它们为什么重要以及它们如何相互关联有一个概览。
- en: Besides understanding the theory of why Document, DocumentArray, Flow, and Executor
    are important while building your search engine, you should also be able to create
    a simple Document and assign its corresponding attributes.  As you are done with
    this chapter, you should also be able to create your own Executor and spin up
    a basic Flow.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 除了理解构建搜索引擎时 Document、DocumentArray、Flow 和 Executor 的重要性理论之外，你还应该能够创建一个简单的 Document
    并分配其对应的属性。完成本章后，你还应该能够创建自己的 Executor 并启动一个基本的 Flow。
- en: You will use all of this knowledge in the next chapter, where you will learn
    how to integrate these concepts together.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在下一章节中使用所有这些知识，学习如何将这些概念整合在一起。
