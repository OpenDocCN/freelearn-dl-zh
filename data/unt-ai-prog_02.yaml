- en: '*Chapter 1*: Introduction to AI'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*: 人工智能简介'
- en: 'This book aims to teach you the basics of **artificial intelligence** (**AI**)
    programming for video games using one of the most popular commercial game engines
    available: Unity3D. In the upcoming chapters, you will learn how to implement
    many of the foundational techniques of any modern game, such as behavior trees
    and finite state machines.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书旨在教你使用最流行的商业游戏引擎之一：Unity3D，进行游戏人工智能编程的基础知识。在接下来的章节中，你将学习如何实现任何现代游戏的基础技术，例如行为树和有限状态机。
- en: Before that, though, you must have a little background on AI in terms of its
    broader, academic, traditional domain, which we will provide in this introductory
    chapter. Then, we'll learn how the applications and implementations of AI in games
    are different from other domains and the essential and unique requirements for
    AI in games. Finally, we'll explore the basic techniques of AI that are used in
    games.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，尽管如此，你必须对人工智能有一个基本的了解，尤其是在其更广泛的、学术的、传统的领域。我们将在这个介绍性章节中提供这些信息。然后，我们将学习人工智能在游戏中的应用和实现与其他领域有何不同，以及游戏人工智能的基本和独特需求。最后，我们将探讨游戏中使用的AI的基本技术。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding AI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解人工智能
- en: AI in video games
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏中的AI
- en: AI techniques for video games
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏人工智能技术
- en: Understanding AI
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解人工智能
- en: Intelligence is a natural and necessary aspect of life for all living organisms,
    such as animals and humans. Without intelligence – mentioned in the broadest way
    possible here – animals would not be able to look for food, bees would not be
    able to find flowers, and we humans would have never been able to craft objects
    or light fires, let alone develop games in Unity! On the contrary, computers are
    just electronic devices that can accept data, perform logical and mathematical
    operations at high speeds, and output the results. They lack any kind of intelligence.
    Computers would stay still and lifeless forever like rocks without someone telling
    them what to do and how to do it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 智力是所有生物体，如动物和人类，生活中自然且必要的方面。没有智力——在这里以最广泛的方式提及——动物将无法寻找食物，蜜蜂将无法找到花朵，而我们人类将永远无法制造物体或点燃火焰，更不用说在Unity中开发游戏了！相反，计算机只是可以接受数据、以高速执行逻辑和数学运算并输出结果的电子设备。它们缺乏任何形式的智力。如果没有人的指示和指导，计算机将永远像石头一样静止不动，毫无生气。
- en: From this point of view, AI is essentially the field that studies how to give
    machines the spark of natural intelligence. It's a discipline that teaches computers
    how to think and decide like living organisms to achieve any goal without human
    intervention.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，人工智能本质上是研究如何赋予机器自然智能火花的一个领域。这是一门教授计算机如何像生物体一样思考和决策，以实现任何目标而不需要人类干预的学科。
- en: As you can imagine, this is a vast subject. There's no way that such a small
    book will be able to cover everything related to AI. Fortunately, for the goal
    of game AI, we do not need a comprehensive knowledge of AI. We only need to grasp
    the basic concepts and master the basic techniques. And this is what we will do
    in this book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，这是一个庞大的主题。这样一本小书不可能涵盖与人工智能相关的所有内容。幸运的是，为了游戏人工智能的目标，我们不需要对人工智能有全面的知识。我们只需要掌握基本概念并精通基本技术。这正是本书要做的。
- en: 'But before we move on to game-specific techniques, let''s look at some of the
    main research areas for AI:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们继续探讨特定游戏的技术之前，让我们先看看人工智能的一些主要研究领域：
- en: '**Computer vision**: This is the ability to take visual input from visual sources
    – such as videos and photos – and analyze them to identify objects (object recognition),
    faces (face recognition), text in handwritten documents (optical character recognition),
    or even to reconstruct 3D models from stereoscopic images.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算机视觉**：这是从视觉源——如视频和照片——获取视觉输入并分析它们以识别对象（对象识别）、面孔（面部识别）、手写文档中的文本（光学字符识别），甚至从立体图像中重建3D模型的能力。'
- en: '**Natural Language Processing** (**NLP**): This allows a machine to read and
    understand human languages – that is, how we write and speak. The problem is that
    human languages are difficult for machines to understand. Language ambiguity is
    the main problem: there are many ways to say the same thing, and the same sentence
    can have different meanings based on the context. NLP is a significant cognitive
    step for machines since they need to understand the languages and expressions
    we use before processing them and responding accordingly. Fortunately, many datasets
    are available on the web to help researchers train machines for this complex task.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自然语言处理**（**NLP**）：这允许机器阅读和理解人类语言——也就是说，我们如何书写和说话。问题是人类语言对机器来说很难理解。语言歧义是主要问题：有很多种说法可以表达相同的意思，同一个句子可以根据上下文有不同的含义。NLP是机器的一个重大认知步骤，因为它们在处理和相应地做出反应之前需要理解我们使用的语言和表达方式。幸运的是，网络上有很多数据集可以帮助研究人员训练机器完成这个复杂任务。'
- en: '**Machine learning**: This branch of AI studies how machines can learn how
    to perform a task using only raw data and experience, with or without human intervention.
    Such tasks span from identifying if a picture contains the image of a cat, to
    playing board games (such as the AlphaGo software, which, in 2017, was able to
    beat the number one ranked player of the world in the game of Go), to perfectly
    interpolating the faces of famous actors in our homemade videos (so-called **deepfakes**).
    Machine learning is a vast field that spans all other AI fields. We will talk
    more about it in [*Chapter 11*](B17984_11_Epub.xhtml#_idTextAnchor587), *Machine
    Learning in Unity*.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机器学习**：这一分支的AI研究机器如何仅使用原始数据和经验来学习执行任务，无论是否有人类的干预。这些任务包括从识别一张图片是否包含猫的图像，到玩棋类游戏（例如AlphaGo软件，在2017年能够击败围棋世界排名第一的选手），再到完美地在我们自制的视频中插值著名演员的面部（所谓的**深度伪造**）。机器学习是一个涵盖所有其他AI领域的广阔领域。我们将在[*第11章*](B17984_11_Epub.xhtml#_idTextAnchor587)，*Unity中的机器学习*中更多地讨论它。'
- en: '**Common sense reasoning**: There is a type of knowledge that is almost innate
    in human beings. For instance, we trivially know that *things fall on the ground
    if they''re not supported* or that *we cannot put a big thing into a smaller one*.
    However, this kind of knowledge and reasoning (also called **common sense knowledge**)
    is entirely undecipherable for computers. At the time of writing, nobody knows
    how to teach machines such trivial – for us – things. Nevertheless, it is a very
    active (and frustrating) research direction.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常识推理**：有一种知识几乎是人类与生俱来的。例如，我们轻易地知道*如果没有支撑，东西会掉在地上*或者*我们不能把一个大东西放进一个小东西里*。然而，这种知识和推理（也称为**常识知识**）对计算机来说是完全无法理解的。在撰写本文时，没有人知道如何教会机器这些对我们来说微不足道的事情。尽管如此，这仍然是一个非常活跃（且令人沮丧）的研究方向。'
- en: 'Fortunately for us, game AI has a much narrower scope. Instead, as we will
    see in the next section, game AI has a single but essential goal: to make the
    game fun to play.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，对于游戏AI来说，其范围要窄得多。相反，正如我们将在下一节中看到的，游戏AI有一个但却是至关重要的目标：让游戏变得有趣。
- en: AI in video games
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏中的AI
- en: Different from general AI, game AI only needs to provide the *illusion of intelligence*.
    Its goal is not to offer human-like intelligent agents but characters that are
    smart enough to make a game fun to play.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与通用AI不同，游戏AI只需要提供**智能的错觉**。它的目标不是提供类似人类的智能代理，而是足够聪明，能让游戏变得有趣的角色。
- en: Of course, making a game *fun to play* is no trivial matter, and to be fair,
    a good AI is just one part of the problem. Nevertheless, if a good AI is not enough
    to make a game *fun*, a bad AI can undermine even the most well-designed game.
    If you are interested in the problem of *what makes a game fun*, I suggest that
    you read a good book on game design, such as *The Art of Game Design*, by Jesse
    Schell.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，让游戏*变得有趣*并非易事，而且公平地说，一个好的AI只是问题的一部分。尽管如此，如果一个好的AI不足以让游戏*变得有趣*，一个差的AI甚至可能破坏最精心设计的游戏。如果你对*什么让游戏变得有趣*这个问题感兴趣，我建议你阅读一本关于游戏设计的优秀书籍，例如Jesse
    Schell的*游戏设计艺术*。
- en: However, for what concerns us, it is sufficient to say that it's essential to
    provide an adequate level of challenge to the player. A fair challenge, in this
    case, means the game should not be so difficult that the player can't beat the
    opponent, nor too easy that winning becomes a tedious task. Thus, finding the
    right challenge level is the key to making a game fun to play.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于我们来说，重要的是要说明，提供足够的挑战水平给玩家是至关重要的。在这种情况下，公平的挑战意味着游戏不应该太难以至于玩家无法击败对手，也不应该太容易以至于胜利变得乏味。因此，找到正确的挑战水平是使游戏有趣的关键。
- en: And that's where AI kicks in. The role of AI in games is to make it fun by providing
    challenging opponents and interesting **Non-Player Characters** (**NPCs**) that
    behave appropriately in the game world. So, the objective here is not to replicate
    the whole thought process of humans or animals but to make the NPCs seem intelligent
    by reacting to the changing situations in the game world so that they make sense
    to the player. This, as we mentioned previously, provides the illusion of intelligence.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正是在这里，AI开始发挥作用。游戏中的AI角色是通过提供具有挑战性的对手和在游戏世界中表现适当的**非玩家角色**（NPCs）来使游戏变得有趣。因此，这里的目的是不是复制人类或动物的全部思维过程，而是通过让NPC在游戏世界中的变化情况下的反应显得智能，从而使它们对玩家有意义。正如我们之前提到的，这提供了智能的错觉。
- en: Information
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: It is essential to mention that AI in games is not limited to modeling NPC's
    behaviors. AI is also used to generate game content (as we will see in [*Chapter
    10*](B17984_10_Epub.xhtml#_idTextAnchor527), *Procedural Content Generation*)
    to control the story events and the narrative pace (a notable example is given
    by the AI director in the *Left 4 Dead* series) or even to invent entire narrative
    arcs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 必须提到的是，游戏中的AI不仅限于模拟NPC的行为。AI还用于生成游戏内容（正如我们将在[*第10章*](B17984_10_Epub.xhtml#_idTextAnchor527)，*程序内容生成*)，控制故事事件和叙事节奏（一个显著的例子来自《求生之路》系列的AI导演）或甚至创造整个叙事弧线。
- en: 'Note that a good game AI doesn''t need to be a complex AI. A recurring example
    is the AI of the original *Pac-Man* arcade game. By any modern standard, the algorithm
    that governs the behavior of the four ghosts chasing Pac-Man can barely be considered
    AI. Each ghost uses a really simple rule to decide where to move next: measure
    the distance between the ghost and a *target tile* and choose the direction to
    minimize the distance.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一个好的游戏AI不需要是复杂的AI。一个反复出现的例子是原始《吃豆人》街机游戏的AI。按照任何现代标准，控制四个鬼魂追逐吃豆人的算法几乎不能被认为是AI。每个鬼魂都使用一个非常简单的规则来决定下一步移动的方向：测量鬼魂和目标方块之间的距离，并选择最小化距离的方向。
- en: The *target tile* might be the location of Pac-Man itself (as in the case of
    the Red Ghost), but it can also be something in front of Pac-Man (such as the
    Pink Ghost) or some other tile. By simply changing the target tile's position,
    the Pac-Man arcade game can give each ghost a distinctive personality and an AI
    that challenges us even after 40 years!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 目标方块可能是吃豆人的位置（如红色鬼魂的情况），也可能是吃豆人前方的东西（如粉色鬼魂），或者是一些其他的方块。通过简单地改变目标方块的位置，吃豆人街机游戏可以为每个鬼魂赋予独特的个性和AI，即使经过40年后，它仍然能挑战我们！
- en: The golden rule is to use the smallest amount of AI necessary to achieve the
    game's design goal. Of course, we may take this rule to the extreme and use no
    AI if we find out that it is unnecessary. For instance, in *Portal* and *Portal
    2*, all the characters are completely scripted and there is no AI involved, yet
    nobody complained about the lack of AI.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 金科玉律是使用最少的AI来实现游戏的设计目标。当然，如果我们发现AI是不必要的，我们可以将这一规则推向极致，不使用任何AI。例如，在《传送门》和《传送门2》中，所有角色都是完全脚本化的，没有涉及AI，但没有人对AI的缺失表示不满。
- en: Information
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: 'If you are interested in diving deeper into the Pac-Man AI, I suggest that
    you watch this very detailed video from the *Retro Game Mechanics Explained* YouTube
    channel: [https://www.youtube.com/watch?v=ataGotQ7ir8](https://www.youtube.com/watch?v=ataGotQ7ir8).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要深入了解《吃豆人》AI，我建议你观看来自*Retro Game Mechanics Explained* YouTube频道的这个非常详细的视频：[https://www.youtube.com/watch?v=ataGotQ7ir8](https://www.youtube.com/watch?v=ataGotQ7ir8)。
- en: 'Alternatively, if you prefer to read, you can go to this very informative web
    page: [https://gameinternals.com/understanding-pac-man-ghost-behavior](https://gameinternals.com/understanding-pac-man-ghost-behavior).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你更喜欢阅读，你可以访问这个非常有信息量的网页：[https://gameinternals.com/understanding-pac-man-ghost-behavior](https://gameinternals.com/understanding-pac-man-ghost-behavior)。
- en: Another challenge for game AI is that other operations, such as graphics rendering
    and physics simulation, need to share the processing power that's required for
    AI. And don't forget that they are all happening in real time, so it's critical
    to achieve a steady frame rate throughout the game. This means that game AI needs
    to be designed to not overtake the computational resources. This is usually done
    by designing an algorithm that can be interrupted and spread over multiple frames.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏 AI 另一个挑战是，其他操作，如图形渲染和物理模拟，需要与 AI 所需的计算能力共享。别忘了，这一切都是在实时发生的，所以在整个游戏中保持稳定的帧率至关重要。这意味着游戏
    AI 需要设计得不会耗尽计算资源。这通常是通过设计一个可以中断并在多个帧上扩展的算法来实现的。
- en: In general AI, many companies invest in a dedicated processor for AI calculations
    called an AI accelerator (such as Google's Tensor Processing Unit). However, until
    games have widespread access to such dedicated AI processors, we game AI developers
    still need to pay attention to our algorithms' performance.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般 AI 领域，许多公司投资于一个专门的 AI 计算处理器，称为 AI 加速器（例如谷歌的 Tensor Processing Unit）。然而，直到游戏广泛地访问这样的专用
    AI 处理器之前，我们游戏 AI 开发者仍然需要关注我们算法的性能。
- en: The next section will provide a general introduction to the most popular AI
    techniques that are used in video games.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将提供对在视频游戏中使用最广泛的 AI 技术的一般介绍。
- en: AI techniques for video games
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视频游戏 AI 技术
- en: In this section, we will look at some of the AI techniques that are commonly
    used in different types of games. We'll learn how to implement each of these features
    in Unity in the upcoming chapters. Since this book does not focus on AI techniques
    themselves but on implementing these techniques inside Unity, we won't look at
    them in too much detail here. So, let's just take this as a crash course before
    diving into the implementation details.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些在不同类型游戏中常用的 AI 技术。我们将在接下来的章节中学习如何在 Unity 中实现这些功能。由于本书的重点不是 AI 技术本身，而是在
    Unity 中实现这些技术，因此我们不会在这里过多地详细讨论它们。所以，让我们将其视为在深入了解实现细节之前的一个快速课程。
- en: If you want to learn more about AI for games, there are some great books, such
    as *Programming Game AI by Example*, by Mat Buckland, and *Artificial Intelligence
    for Games*, by Ian Millington and John Funge. In addition, the *AI Game Programming
    Wisdom and Game AI Pro* series also contain a lot of valuable resources and articles
    on the latest AI techniques.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于游戏 AI 的信息，有一些很好的书籍，例如 Mat Buckland 的《通过实例编程游戏 AI》和 Ian Millington
    与 John Funge 的《游戏人工智能》。此外，*AI 游戏编程智慧* 和 *游戏 AI 专业人士* 系列也包含大量关于最新 AI 技术的有价值资源和文章。
- en: Finite state machines
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有限状态机
- en: '**Finite State Machines** (**FSMs**) are probably one of the simplest, most
    used, and most discussed AI models and, for most games, they represent the only
    AI technique. A state machine consists of a finite number of **states** that are
    connected by one or more **transitions**, resulting in a data structure known
    as a **graph**. Each game entity starts with an initial state. Then, environment
    events trigger specific rules that will make the entity move into another state.
    Such triggering rules are called **transitions**. A game entity can only be in
    one state at any given time.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**有限状态机**（**FSM**）可能是最简单、最常用、最常讨论的 AI 模型之一，对于大多数游戏来说，它们代表了唯一的 AI 技术。状态机由有限数量的
    **状态** 组成，这些状态通过一个或多个 **转换** 相连，形成一个称为 **图** 的数据结构。每个游戏实体都从一个初始状态开始。然后，环境事件触发特定的规则，使实体移动到另一个状态。这种触发规则称为
    **转换**。游戏实体在任何给定时间只能处于一个状态。'
- en: 'For example, let''s consider an AI guard character in a typical shooting game.
    Its states could be as simple as *patrolling*, *chasing*, and *shooting*:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑一个典型射击游戏中的 AI 守卫角色。其状态可能像 *巡逻*、*追逐* 和 *射击* 这样简单：
- en: '![Figure 1.1 – A simple FSM for an AI guard character'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.1 – 一个简单的用于 AI 守卫角色的有限状态机'
- en: '](img/B17984_01_01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17984_01_01.jpg)'
- en: Figure 1.1 – A simple FSM for an AI guard character
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 一个简单的用于 AI 守卫角色的有限状态机 (FSM)
- en: 'There are four components in a simple FSM:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 简单 FSM 有四个组成部分：
- en: '**States**: This component defines a set of states that a game entity or an
    NPC can choose from (**Patrol**, **Chase**, and **Shoot**).'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：此组件定义了游戏实体或 NPC 可以选择的一组状态（**巡逻**、**追逐** 和 **射击**）。'
- en: '**Transitions**: This component defines the relationships between different
    states.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换**：此组件定义了不同状态之间的关系。'
- en: '**Rules**: This component defines when to perform a state transition (**Player
    in sight**, **Close enough to attack**, and **Lost/killed player**).'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则**：此组件定义了何时执行状态转换（**玩家在视野中**、**足够近可以攻击**和**失去/杀死玩家**）。'
- en: '**Events**: This is the component that will trigger to check the rules (the
    guard''s visible area, distance to the player, and so on).'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**：这是将触发以检查规则（守卫的可见区域、与玩家的距离等）的组件。'
- en: 'So, a monster in *Quake 2* may have the following states: standing, walking,
    running, dodging, attacking, idle, and searching.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在《Quake 2》中的怪物可能具有以下状态：站立、行走、奔跑、躲避、攻击、空闲和搜索。
- en: FSMs are widely used in games because they are simple to implement using only
    a bunch of *if* or *switch* statements, but they are still powerful enough for
    simple and somewhat complex games. On the other hand, they can get messy when
    we need a lot of states and transitions. We'll learn how to manage a simple FSM
    in the next chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机（FSMs）在游戏中被广泛使用，因为它们仅使用一些*if*或*switch*语句就很容易实现，但它们仍然足够强大，可以用于简单和相对复杂的游戏。另一方面，当我们需要大量状态和转换时，它们可能会变得混乱。我们将在下一章学习如何管理一个简单的状态机。
- en: Randomness and probability in AI
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AI中的随机性和概率
- en: Imagine an enemy bot in a **First-Person Shooter** (**FPS**) game that can always
    kill the player with a headshot or an opponent in a racing game who always chooses
    the best route and never collides with any obstacle. Such a level of *intelligence*
    will make the game so hard that it will become almost impossible to win and, as
    a consequence, it will be frustrating to play. On the opposite side of the spectrum,
    imagine an enemy that chooses the same predictable route whenever it tries to
    escape from the player. After a couple of games, the player will learn the enemy's
    pattern, and the game will feel boring. AI-controlled entities that behave the
    same way every time the player encounters them make the game predictable, easy
    to win, and therefore dull.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下在一个**第一人称射击游戏**（**FPS**）中，一个敌人机器人总是可以用头槌或对手在赛车游戏中总是选择最佳路线且从不与任何障碍物碰撞。这种程度的**智能**会使游戏变得非常困难，几乎不可能获胜，因此游戏体验会变得令人沮丧。在光谱的另一端，想象一下，当敌人试图从玩家那里逃脱时，总是选择相同的可预测路线。经过几场比赛后，玩家会学会敌人的模式，游戏会变得乏味。当玩家每次遇到都表现出相同行为的AI控制实体，会使游戏变得可预测、容易获胜，因此变得乏味。
- en: Of course, there are some cases in which *intentional predictability* is a desired
    feature. In stealth games, for instance, we want the players to be able to predict
    the path of the enemies so that the players can plan a sneaking route. But in
    other cases, *unintentional predictability* can interfere with the game's engagement
    and make the player feel like the game is not challenging or fair enough. One
    way to fix these *too-perfect* or *too-stupid* AIs is to introduce intentional
    mistakes in their behavior. In games, we introduce randomness and probability
    in the decision-making process of AI calculations.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有些情况下，*有意可预测性*是一个期望的特性。例如，在潜行游戏中，我们希望玩家能够预测敌人的路径，以便玩家可以计划潜行路线。但在其他情况下，*无意可预测性*可能会干扰游戏的参与度，使玩家感觉游戏不够具有挑战性或公平性。修复这些**过于完美**或**过于愚蠢**的AI的一种方法是在它们的行为中引入有意错误。在游戏中，我们在AI计算的决策过程中引入随机性和概率。
- en: There are multiple scenarios where we may want to introduce a bit of randomness.
    The most straightforward case is when the NPC has no information and/or it doesn't
    matter what decision it makes. For instance, in a shooting game, an enemy under
    fire may want to decide where to cover. So, instead of always moving it to the
    closest cover, we may wish to instruct the NPCs to sometimes choose a slightly
    far-away cover.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种场景，我们可能希望引入一些随机性。最直接的情况是当NPC没有信息，或者它所做的决定无关紧要时。例如，在射击游戏中，一个被攻击的敌人可能想要决定在哪里躲避。因此，我们可能希望指示NPC有时选择一个稍微远一点的躲避点。
- en: In other cases, we can use randomness for the outcomes of a decision. For example,
    we can use randomness for hit probabilities, add or subtract random bits of damage
    to/from base damage, or make an NPC hesitate before they start shooting.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，我们可以使用随机性来决定结果。例如，我们可以使用随机性来决定命中率，对基础伤害进行随机增减，或者在NPC开始射击前让他们犹豫。
- en: The sensor system
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传感器系统
- en: 'Our AI characters need to know their surroundings and the world they interact
    with to make a particular decision. Such information includes the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的人工智能角色需要了解他们的周围环境和他们与之交互的世界，以便做出特定的决定。此类信息包括以下内容：
- en: '**The position of the player**: This is used to decide whether to attack or
    chase or keep patrolling.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家的位置**：这用于决定是攻击、追击还是继续巡逻。'
- en: '**Buildings and nearby objects**: This is used to hide or take cover.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**建筑和附近物体**：这用于隐藏或掩护。'
- en: '**The player''s health and the AI''s health**: This is used to decide whether
    to retreat or advance.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家的健康和AI的健康**：这用于决定是撤退还是前进。'
- en: '**Location of resources on the map in a Real-Time Strategy (RTS) game**: This
    is used to occupy and collect resources that are required to update and/or produce
    other units.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时策略（RTS）游戏中地图上资源的位置**：这用于占领和收集更新和/或生产其他单位所需的资源。'
- en: 'As you can imagine, choosing the correct method to collect game information
    can vary a lot, depending on the type of game we are trying to build. In the next
    few sections, we''ll look at two basic strategies: **polling** and **message (event)
    systems**.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想，选择正确的方法来收集游戏信息可能会因我们试图构建的游戏类型而大相径庭。在接下来的几节中，我们将探讨两种基本策略：**轮询**和**消息（事件）系统**。
- en: Polling
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 投票
- en: One method to collect such information is `FixedUpdate` method of our AI character.
    In this way, AI characters can just poll the information they are interested in
    from the game world, do the checks, and take action accordingly. Polling works
    great if there aren't too many things to check.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 收集此类信息的一种方法是我们AI角色的`FixedUpdate`方法。这样，AI角色可以从游戏世界中轮询它们感兴趣的信息，进行检查，并据此采取行动。如果需要检查的项目不多，轮询效果很好。
- en: To make this method more efficient, we may want to program the characters to
    poll the world states at different rates so that we do not have all the characters
    checking everything at once. For instance, we may divide the polling agents into
    10 groups (G1, G2, G3, and so on) and assign the polling for each group at different
    frames (for example, G1 will poll at frame 0, 60, 120, and so on; G2 will poll
    at frame 10, 70, 130, and so on).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这种方法更高效，我们可能想要编程角色以不同的速率轮询世界状态，这样我们就不需要所有角色同时检查一切。例如，我们可以将轮询代理分成10组（G1、G2、G3等），并为每组分配不同的帧进行轮询（例如，G1将在帧0、60、120等轮询；G2将在帧10、70、130等轮询）。
- en: As another example, we may decide to change the polling frequency based on the
    enemy's type or state. For instance, enemies that are disengaged and far away
    may poll every 3-4 seconds, while enemies closer to the player and under attack
    may want to poll every 0.5 seconds.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，我们可能会决定根据敌人的类型或状态来改变轮询频率。例如，未参与战斗且远离的敌人可能每3-4秒轮询一次，而接近玩家且正在受到攻击的敌人可能希望每0.5秒轮询一次。
- en: However, polling is no longer enough as soon as the game gets bigger. Therefore,
    in more massive games with more complex AI systems, we need to implement an event-driven
    method using a global messaging system.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着游戏的扩大，轮询就不再足够了。因此，在更大型、更复杂的AI系统中，我们需要实现一个使用全局消息系统的基于事件的驱动方法。
- en: Messaging systems
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消息系统
- en: In a messaging system, the game communicates events between the AI entity and
    the player, the world, or the other AI entities through asynchronous messages.
    For example, when the player attacks an enemy unit inside a group of patrol guards,
    the other AI units need to know about this incident so that they can start searching
    for and attacking the player.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在消息系统中，游戏通过异步消息在AI实体、玩家、世界或其他AI实体之间传递事件。例如，当玩家攻击一群巡逻守卫中的敌方单位时，其他AI单位需要了解这一事件，以便它们可以开始搜索并攻击玩家。
- en: 'If we were using the polling method, our AI entities would need to check the
    state of all of the other AI entities to find out if one of them has been attacked.
    However, we can implement this in a more manageable and scalable fashion: we can
    register the AI characters that are interested in a particular event as listeners
    of that event; then, if that event occurs, our messaging system will broadcast
    this information to all listeners. The AI entities can then take the appropriate
    actions or perform further checks.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用轮询方法，我们的AI实体需要检查所有其他AI实体的状态，以确定是否有实体被攻击。然而，我们可以以更易于管理和可扩展的方式实现这一点：我们可以将感兴趣特定事件的AI角色注册为该事件的监听器；然后，如果该事件发生，我们的消息系统将向所有监听器广播此信息。AI实体可以据此采取适当的行动或进行进一步的检查。
- en: This event-driven system does not necessarily provide a faster mechanism than
    polling. Still, it provides a convenient, central checking system that senses
    the world and informs the interested AI agents, rather than having each agent
    check the same event in every frame. In reality, both polling and messaging systems
    are used together most of the time. For example, the AI may poll for more detailed
    information when it receives an event from the messaging system.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事件驱动系统并不一定比轮询机制更快。然而，它提供了一个方便的、集中的检查系统，它感知世界并向感兴趣的AI代理报告，而不是让每个代理在每一帧检查相同的事件。在现实中，轮询和消息系统通常一起使用。例如，当AI从消息系统中收到事件时，它可能会轮询更详细的信息。
- en: Flocking, swarming, and herding
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 群聚、盘旋和放牧
- en: Many living beings such as birds, fish, insects, and land animals perform specific
    operations such as moving, hunting, and foraging in groups. They stay and hunt
    in groups because it makes them stronger and safer from predators than pursuing
    goals individually. So, let's say you want a group of birds flocking, swarming
    around in the sky; it'll cost too much time and effort for animators to design
    the movement and animations of each bird. However, if we apply some simple rules
    for each bird to follow, we can achieve an emergent intelligence for the whole
    group with complex, global behavior.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 许多生物，如鸟类、鱼类、昆虫和陆地动物，在群体中进行特定的操作，如移动、狩猎和觅食。它们以群体形式停留和狩猎，因为这样比单独追求目标更强大、更安全。所以，假设你想要一群鸟在空中群聚、盘旋；对于动画师来说，为每只鸟设计运动和动画将花费太多时间和精力。然而，如果我们为每只鸟应用一些简单的规则，我们就可以通过复杂的全局行为实现整个群体的涌现智能。
- en: 'One pioneer of this concept is Craig Reynolds, who presented such a flocking
    algorithm in his 1987 SIGGRAPH paper, *Flocks, Herds, and Schools – A Distributed
    Behavioral Model*. He coined the term **boid**, which sounds like "bird" but refers
    to a bird-like object. He proposed three simple rules to apply to each unit:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念的先驱是Craig Reynolds，他在1987年的SIGGRAPH论文《Flocks, Herds, and Schools – A Distributed
    Behavioral Model》中提出了这样的群聚算法。他创造了**boid**这个术语，听起来像“bird”（鸟），但实际上指的是类似鸟的对象。他提出了三个简单的规则应用于每个单元：
- en: '**Separation**: Each boid needs to maintain a minimum distance from neighboring
    boids to avoid hitting them (short-range repulsion).'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分离**：每个boid需要与邻近的boid保持最小距离，以避免碰撞（短程排斥）。'
- en: '**Alignment**: Each boid needs to align itself with the average direction of
    its neighbors and then move in the same velocity with them as a flock.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对齐**：每个boid需要与邻居的平均方向对齐，然后以相同的速度与它们一起移动，作为一个群体。'
- en: '**Cohesion**: Each boid is attracted to the group''s center of mass (long-range
    attraction).'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**凝聚力**：每个boid被吸引到群体的质心（长程吸引）。'
- en: These three simple rules are all we need to implement a realistic and reasonably
    complex flocking behavior for birds. This doesn't only work with birds. Flocking
    behaviors are useful for modeling a crowd or even a couple of NPCs that will follow
    the player during the game.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个简单的规则就足以实现一个逼真且相对复杂的鸟类群聚行为。这不仅适用于鸟类。群聚行为对于模拟人群或甚至在游戏中跟随玩家的几个NPC都很有用。
- en: We'll learn how to implement such a flocking system in Unity in [*Chapter 5*](B17984_05_Epub.xhtml#_idTextAnchor332),
    *Flocking*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第五章*](B17984_05_Epub.xhtml#_idTextAnchor332)“群聚”中学习如何在Unity中实现这样一个群聚系统。
- en: Path following and steering
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟随路径和转向
- en: Sometimes, we want our AI characters to roam the game world and follow a roughly
    guided or thoroughly defined path. For example, in a racing game, the AI opponents
    need to navigate a road. In that case, simple reactive algorithms, such as our
    flocking boid algorithm, are not powerful enough to solve this problem. Still,
    in the end, it all comes down to dealing with actual movements and steering behaviors.
    Steering behaviors for AI characters has been a research topic for a couple of
    decades now.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们希望我们的AI角色在游戏世界中漫游并跟随一个大致引导或详细定义的路径。例如，在赛车游戏中，AI对手需要导航道路。在这种情况下，像我们的群聚boid算法这样的简单反应算法不足以解决这个问题。然而，最终，这都归结于处理实际的运动和转向行为。AI角色的转向行为已经成为几十年的研究课题。
- en: 'One notable paper in this field is *Steering Behaviors for Autonomous Characters*,
    again by Craig Reynolds, presented in 1999 at the **Game Developers Conference**
    (**GDC**). He categorized steering behaviors into the following three layers:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个领域，一篇值得注意的论文是Craig Reynolds在1999年游戏开发者大会（**GDC**）上提出的**《自主角色的转向行为**》，他再次提出了以下三个层次的转向行为：
- en: '![Figure 1.2 – Hierarchy of motion behaviors'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.2 – 运动行为层次结构'
- en: '](img/B17984_01_02.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17984_01_02.jpg]'
- en: Figure 1.2 – Hierarchy of motion behaviors
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 运动行为层次结构
- en: 'To understand these layers, let''s look at an example. Imagine that you are
    working at your desk on a hot summer afternoon. You are thirsty, and you want
    a cold glass of iced tea. So, we start from the first layer: we want a cold glass
    of iced tea (setting the goal), and we plan out what we need to do to get it.
    We probably need to go to the kitchen (unless you have a mini-fridge under your
    desk), fetch an empty glass, and then move to the fridge, open it, and get the
    iced tea (we have made a high-level plan).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这些层次，让我们来看一个例子。想象一下，在一个炎热的夏日午后，你坐在办公桌前工作。你感到口渴，想要一杯冰茶。因此，我们从第一层开始：我们想要一杯冰茶（设定目标），并规划出我们为了得到它需要做什么。我们可能需要去厨房（除非你的桌子下有一个迷你冰箱），拿一个空杯子，然后移动到冰箱，打开它，拿冰茶（我们已经制定了一个高级计划）。
- en: 'Now, we move to the second layer. Unless your kitchen is a direct straight
    line from your desk, you need to determine a path: go around the desk, move through
    a corridor, navigate around the kitchen furniture until you reach the cabinet
    with the glasses, and so on. Now that you have a path, it is time to move to the
    third layer: walking the path. In this example, the third layer is represented
    by your body, skeleton, and muscles moving you along the path.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们转到第二层。除非你的厨房是从你的桌子直接延伸的直线，否则你需要确定一条路径：绕过桌子，穿过走廊，绕过厨房家具，直到你到达放玻璃杯的橱柜，等等。现在你已经有了路径，是时候移动到第三层：沿着路径行走。在这个例子中，第三层由你的身体、骨骼和肌肉沿着路径移动来表示。
- en: Information
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Don't worry – you don't need to master all three layers. As an AI programmer,
    you only need to focus on the first two. The third layer is usually handled by
    graphic programmers – in particular, animators.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心——你不需要掌握所有三层。作为一个 AI 程序员，你只需要专注于前两层。第三层通常由图形程序员处理——特别是动画师。
- en: After describing these three layers, Craig Reynolds explains how to design and
    implement standard steering behaviors for individual AI characters. Such behaviors
    include *seek* and *flee*, *pursue* and *evade*, *wander*, *arrival*, *obstacle
    avoidance*, *wall following*, and *path following*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述了这三层之后，克雷格·雷诺兹解释了如何为单个 AI 角色设计和实现标准的转向行为。这些行为包括 *寻找* 和 *逃离*，*追逐* 和 *躲避*，*徘徊*，*到达*，*避障*，*沿墙行走*
    和 *路径跟随*。
- en: We'll implement some of these behaviors in Unity in [*Chapter 6*](B17984_06_Epub.xhtml#_idTextAnchor375),
    *Path Following and Steering Behaviors*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第 6 章*](B17984_06_Epub.xhtml#_idTextAnchor375) 中实现这些行为中的一些，*路径跟随和转向行为*。
- en: A* pathfinding
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A* 路径查找
- en: There are many games where you can find monsters or enemies that follow the
    player or move to a particular point while avoiding obstacles. For example, let's
    take a look at a typical RTS game. You can select a group of units and click a
    location where you want them to move or click on the enemy units to attack them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多游戏中，你可以找到跟随玩家或避开障碍物移动到特定点的怪物或敌人。例如，让我们看看一个典型的实时战略游戏。你可以选择一组单位并点击你想要它们移动的位置，或者点击敌方单位进行攻击。
- en: Then, your units need to find a way to reach the goal without colliding with
    the obstacles. Of course, the enemy units also need to be able to do the same.
    The barriers could be different for different units. For example, an airforce
    unit may pass over a mountain, while the ground or artillery units need to find
    a way around it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你的单位需要找到一种方法在不与障碍物碰撞的情况下达到目标。当然，敌方单位也需要能够做到同样的事情。不同的单位可能有不同的障碍物。例如，空军单位可以飞越山脉，而地面或炮兵单位则需要找到绕过它的方法。
- en: '**A*** (pronounced *A-star*) is a pathfinding algorithm that''s widely used
    in games because of its performance, accuracy, and ease of implementation. Let''s
    look at an example to see how it works. Let''s say we want our unit to move from
    point **A** to point **B**, but there''s a wall in the way, and it can''t go straight
    toward the target. So, it needs to find a way to point **B** while avoiding the
    wall:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**A***（发音为“A-star”）是一种路径查找算法，由于其性能、准确性和易于实现，在游戏中被广泛使用。让我们通过一个例子来看看它是如何工作的。假设我们想让我们的单位从点
    **A** 移动到点 **B**，但中间有一堵墙，它不能直接朝目标前进。因此，它需要找到一种方法到达点 **B** 同时避开墙壁：'
- en: '![Figure 1.3 – Top-down view of our map'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.3 – 我们地图的俯视图'
- en: '](img/B17984_01_03.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17984_01_03.jpg]'
- en: Figure 1.3 – Top-down view of our map
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 我们地图的俯视图
- en: 'This is a simple 2D example, but we can apply the same idea to 3D environments.
    To find the path from point **A** to point **B**, we need to know more about the
    map, such as the position of obstacles. For that, we can split our whole map into
    small tiles that represent the entire map in a grid format, as shown in the following
    diagram:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的 2D 示例，但我们可以将同样的想法应用到 3D 环境中。为了从点 **A** 到点 **B** 寻找路径，我们需要了解更多关于地图的信息，例如障碍物的位置。为此，我们可以将整个地图分成代表整个地图的小瓷砖，以网格格式表示，如图所示：
- en: '![Figure 1.4 – Map represented in a 2D grid'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4 – 以 2D 网格表示的地图'
- en: '](img/B17984_01_04.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_01_04.jpg)'
- en: Figure 1.4 – Map represented in a 2D grid
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 以 2D 网格表示的地图
- en: The tiles can also be of other shapes, such as hexagons or triangles. Each shape
    comes with its advantages. For instance, hexagonal tiles are convenient because
    they do not have the problem of *diagonal moves* (all the hexagons surrounding
    a target hexagon are at the same distance). In this example, though, we have used
    square tiles because they are the more intuitive shape that comes to mind when
    we think about **grids**.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 瓷砖也可以是其他形状，例如六边形或三角形。每种形状都有其优点。例如，六边形瓷砖很方便，因为它们没有 **对角线移动** 的问题（围绕目标六边形的所有六边形都在相同的距离上）。然而，在这个例子中，我们使用了正方形瓷砖，因为当我们想到
    **网格** 时，它们是更直观的形状。
- en: Now, we can reference our map in a small 2D array.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在一个小的 2D 数组中引用我们的地图。
- en: We can represent our map with a 5x5 grid of square tiles for a total of 25 tiles.
    Now, we can start searching for the best path to reach the target. How do we do
    this? By calculating the movement score of each tile that's adjacent to the starting
    tile that is not occupied by an obstacle, and then choosing the tile with the
    lowest cost.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一个 5x5 的正方形瓷砖网格来表示我们的地图，总共 25 个瓷砖。现在，我们可以开始寻找到达目标的最佳路径。我们如何做？通过计算与起始瓷砖相邻且未被障碍物占据的每个瓷砖的移动得分，然后选择成本最低的瓷砖。
- en: If we don't consider the diagonal movements, there are four possible adjacent
    tiles to the player. Now, we need to use two numbers to calculate the movement
    score for each of those tiles. Let's call them *G* and *H*, where *G* is the cost
    to move from the starting tile to the current tile, and *H* is the estimated cost
    to reach the target tile from the current tile.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不考虑对角线移动，玩家周围有四个可能的相邻瓷砖。现在，我们需要使用两个数字来计算每个这些瓷砖的移动得分。让我们称它们为 *G* 和 *H*，其中
    *G* 是从起始瓷砖移动到当前瓷砖的成本，而 *H* 是从当前瓷砖到达目标瓷砖的估计成本。
- en: 'Let''s call *F* the sum of *G* and *H*, (*F = G + H*) – that is, the final
    score of that tile:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称 *F* 为 *G* 和 *H* 的和 (*F = G + H*) – 即该瓷砖的最终得分：
- en: '![Figure 1.5 – Valid adjacent tiles'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.5 – 有效的相邻瓷砖'
- en: '](img/B17984_01_05.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_01_05.jpg)'
- en: Figure 1.5 – Valid adjacent tiles
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 有效的相邻瓷砖
- en: 'In our example, to estimate *H*, we''ll use a simple method called **Manhattan
    length** (also known as **taxicab geometry**). According to this method, the distance
    (cost) between **A** and **B** is the number of horizontal tiles, **A** and **B**,
    plus the number of vertical tiles between **A** and **B**:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，为了估算 *H*，我们将使用一种称为 **曼哈顿距离**（也称为 **出租车几何**）的简单方法。根据这种方法，点 **A** 和 **B**
    之间的距离（成本）是 **A** 和 **B** 之间的水平瓷砖数量，加上 **A** 和 **B** 之间的垂直瓷砖数量：
- en: '![Figure 1.6 – Calculating G'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.6 – 计算 G'
- en: '](img/B17984_01_06.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_01_06.jpg)'
- en: Figure 1.6 – Calculating G
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – 计算 G
- en: The *G* value, on the other hand, represents the *cost so far* during the search.
    The preceding diagram shows the calculations of *G* with two different paths.
    To compute the current *G*, we must add `1` (the cost of moving one tile) to the
    previous tile's *G* score. However, we can give different costs to different tiles.
    For example, we may want to set a higher movement cost for diagonal movements
    (if we are considering them) or, for instance, to tiles occupied by a pond or
    a muddy road.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，*G* 值代表搜索过程中的 **当前成本**。前面的图示显示了使用两条不同路径计算 *G* 的过程。为了计算当前的 *G*，我们必须将 `1`（移动一个瓷砖的成本）加到前一个瓷砖的
    *G* 分数上。然而，我们可以给不同的瓷砖分配不同的成本。例如，我们可能希望为对角线移动设置更高的移动成本（如果我们正在考虑它们），或者，例如，为池塘或泥泞的道路上的瓷砖。
- en: 'Now that we know how to get *G*, let''s learn how to calculate *H*. The following
    diagram shows the *H* value for different starting tiles. Even in this case, we
    use the Manhattan distance:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何得到 *G*，让我们学习如何计算 *H*。以下图示显示了不同起始瓷砖的 *H* 值。即使在这种情况下，我们也使用曼哈顿距离：
- en: '![Figure 1.7 – Calculating H'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.7 – 计算 H'
- en: '](img/B17984_01_07.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_01_07.jpg)'
- en: Figure 1.7 – Calculating H
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – 计算 H
- en: So, now that we know how to get *G* and *H*, let's go back to our original example
    to figure out the shortest path from **A** to **B**. First, we must choose the
    starting tile and collect all its adjacent tiles, as shown in the following diagram.
    Then, we must calculate each tile's *G* and *H* scores, as shown in the tile's
    lower left and right corners. Finally, we must get the final score, *F*, by adding
    *G* and *H* together. You can see the *F* score in the tile's top-left corner.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经知道了如何获取 *G* 和 *H*，让我们回到我们的原始例子，找出从 **A** 到 **B** 的最短路径。首先，我们必须选择起始瓷砖，并收集所有相邻的瓷砖，如图所示。然后，我们必须计算每个瓷砖的
    *G* 和 *H* 分数，如图中瓷砖的左下角和右下角所示。最后，我们必须通过将 *G* 和 *H* 相加来获取最终分数 *F*。您可以在瓷砖的左上角看到 *F*
    分数。
- en: 'Now, we must choose the tile with the lowest *F* score as our next tile and
    store the previous tile as its parent. Note that keeping records of each tile''s
    parents is crucial because we will use this backlink later to trace the sequence
    of nodes from the end to the start to obtain the final path. In this example,
    we must choose the tile to the right of the starting position and consider it
    the current tile:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须选择具有最低 *F* 分数的瓷砖作为我们的下一个瓷砖，并将前一个瓷砖作为其父瓷砖存储。请注意，记录每个瓷砖的父瓷砖是至关重要的，因为我们稍后会使用这个回链来从终点到起点追踪节点序列以获得最终路径。在这个例子中，我们必须选择起始位置右侧的瓷砖，并将其视为当前瓷砖：
- en: '![Figure 1.8 – Starting position'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.8 – 起始位置'
- en: '](img/B17984_01_08.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_01_08.jpg)'
- en: Figure 1.8 – Starting position
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – 起始位置
- en: 'From the current tile, we repeat this process, starting with collecting the
    valid adjacent tiles. There are only two free adjacent tiles this time: the one
    above the current tile and the one at the bottom (in fact, the left tile is the
    starting tile – which we''ve already examined – and the obstacle occupies the
    right tile). We calculate *G* and *H*, and then the *F* score of those new adjacent
    tiles.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从当前瓷砖开始，我们重复这个过程，首先收集有效的相邻瓷砖。这次只有两个空闲的相邻瓷砖：当前瓷砖上方的那个和底部的那个（实际上，左边的瓷砖是起始瓷砖——我们已经检查过——障碍物占据了右边的瓷砖）。我们计算
    *G* 和 *H*，然后计算这些新相邻瓷砖的 *F* 分数。
- en: 'This time, we have four tiles on our map, all with the same score: six. Therefore,
    we can choose any of them. In fact, in the end, we will find the shortest path
    independently of which tile we explore first (proving the math behind this statement
    is outside the scope of this book):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们在地图上有四个瓷砖，它们的分数都相同：六。因此，我们可以选择其中的任何一个。实际上，最终我们会发现，无论我们首先探索哪个瓷砖，我们都会找到最短路径（证明这个陈述背后的数学原理超出了本书的范围）：
- en: '![Figure 1.9 – Second step'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.9 – 第二步'
- en: '](img/B17984_01_09.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_01_09.jpg)'
- en: Figure 1.9 – Second step
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 – 第二步
- en: 'In this example, from the group of tiles with a cost of `6`, we chose the tile
    at the top left as the starting position. Again, we must examine the adjacent
    tiles. In this step, there''s only one new adjacent tile with a calculated *F*
    score of `8`. Because the lowest score is still `6` right now, we can choose any
    tile with a score of `6`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们从成本为 `6` 的瓷砖组中选择了左上角的瓷砖作为起始位置。同样，我们必须检查相邻的瓷砖。在这一步中，只有一个新的相邻瓷砖，其计算出的
    *F* 分数为 `8`。因为目前最低的分数仍然是 `6`，所以我们可以选择任何分数为 `6` 的瓷砖：
- en: '![Figure 1.10 – Third step'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.10 – 第三步'
- en: '](img/B17984_01_10.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_01_10.jpg)'
- en: Figure 1.10 – Third step
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 – 第三步
- en: 'If we repeat this process until we reach our target tile, we''ll end up with
    a board that shows all the scores for each free tile:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重复这个过程，直到我们到达目标瓷砖，我们最终会得到一个显示每个空闲瓷砖分数的板：
- en: '![Figure 1.11 – Reach target'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.11 – 达到目标'
- en: '](img/B17984_01_11.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_01_11.jpg)'
- en: Figure 1.11 – Reach target
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11 – 达到目标
- en: 'There is only one step left. Do you remember the parent links that we stored
    in each node? Now, starting from the target tile, we must use the stored parent
    tile to trace back a list of tiles. The resulting list will be a path that looks
    something like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下只有一步了。你还记得我们存储在每个节点中的父链接吗？现在，从目标瓷砖开始，我们必须使用存储的父瓷砖来追踪一个瓷砖列表。结果列表将是一条看起来像这样的路径：
- en: '![Figure 1.12 – Path traced back'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.12 – 追踪回溯路径'
- en: '](img/B17984_01_12.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_01_12.jpg)'
- en: Figure 1.12 – Path traced back
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 – 追踪回溯路径
- en: What we explained here is the essence of the A* pathfinding algorithm, which
    is the basic founding block of any pathfinding algorithm. Fortunately, since Unity
    3.5, a couple of new features such as automatic navigation mesh generation and
    the NavMesh Agent make implementing pathfinding in your games much more accessible.
    As a result, you may not even need to know anything about A* to implement pathfinding
    for your AI characters. Nonetheless, knowing how the system works behind the scenes
    is essential to becoming a solid AI programmer.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里解释的是A*路径查找算法的精髓，这是任何路径查找算法的基本基石。幸运的是，自从Unity 3.5以来，一些新功能，如自动导航网格生成和NavMesh代理，使得在游戏中实现路径查找变得更加容易。因此，你可能甚至不需要了解A*就能为你的AI角色实现路径查找。然而，了解幕后系统的工作原理对于成为一名优秀的AI程序员至关重要。
- en: We'll talk about NavMesh in the next section and then in more detail in [*Chapter
    8*](B17984_08_Epub.xhtml#_idTextAnchor447), *Navigation Mesh*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中讨论导航网格，然后在[*第8章*](B17984_08_Epub.xhtml#_idTextAnchor447)，*导航网格*中更详细地讨论。
- en: Navigation meshes
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航网格
- en: Now that you know the basics of the A* pathfinding algorithm, you may notice
    that using a grid in A* requires many steps to get the shortest path between the
    start and target position. It may not seem notable but searching for a path tile-by-tile
    for huge maps with thousands of mostly empty tiles is a severe waste of computational
    power. So, games often use waypoints as a guide to move the AI characters as a
    simple and effective way to use fewer computation resources.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了A*路径查找算法的基础知识，你可能注意到在A*中使用网格需要许多步骤才能在起始位置和目标位置之间找到最短路径。这可能看起来并不显著，但搜索巨大地图上的路径，其中大多数是空格，并且逐个搜索路径方块是一种严重的计算资源浪费。因此，游戏通常使用航点作为指南，以简单有效的方式移动AI角色，从而减少计算资源的使用。
- en: 'Let''s say we want to move our AI character from point **A** to point **B**,
    and we''ve set up three waypoints, as shown in the following diagram:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想将我们的AI角色从点**A**移动到点**B**，并且我们已经设置了三个航点，如下面的图所示：
- en: '![Figure 1.13 – Waypoints'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.13 – 航点'
- en: '](img/B17984_01_13.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17984_01_13](img/B17984_01_13.jpg)'
- en: Figure 1.13 – Waypoints
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13 – 航点
- en: All we have to do now is apply the A* algorithm to the waypoints (there are
    fewer of these compared to the number of tiles) and then simply move the character
    in a straight line from waypoint to waypoint.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要将A*算法应用于航点（这些航点的数量比方块的数量少），然后简单地从航点到航点直线移动角色。
- en: 'However, waypoints are not without issues. What if we want to update the obstacles
    in our map? We''ll have to place the waypoints again for the updated map, as shown
    in the following diagram:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，航点并非没有问题。如果我们想更新地图中的障碍物怎么办？我们将不得不为更新的地图重新放置航点，如下面的图所示：
- en: '![Figure 1.14 – New waypoints'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.14 – 新航点'
- en: '](img/B17984_01_14.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17984_01_14](img/B17984_01_14.jpg)'
- en: Figure 1.14 – New waypoints
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14 – 新航点
- en: Moreover, following each node to the target produces characters that look unrealistic.
    For instance, they move in straight lines, followed by an abrupt change of direction,
    much like the mechanical puppets in a theme park's attraction. Or the path that
    connects two waypoints may be too close to the obstacles. For example, look at
    the preceding diagrams; the AI character will likely collide with the wall where
    the path is close to the wall.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，跟随每个节点到目标会产生看起来不真实的角色。例如，它们直线移动，然后突然改变方向，就像主题公园的景点中的机械木偶一样。或者连接两个航点的路径可能太靠近障碍物。例如，看看前面的图；AI角色可能会在路径靠近墙壁的地方撞到墙上。
- en: If that happens, our AI will keep trying to go through the wall to reach the
    next target, but it won't be able to, and it will get stuck there. Sure, we could
    make the path more realistic by smoothing out the zigzag path using splines, or
    we could manually check each path to avoid grazing the edges of obstacles. However,
    the problem is that the waypoints don't contain any information about the environment
    other than the trajectory that's connecting two nodes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生这种情况，我们的AI将继续尝试穿过墙壁以到达下一个目标，但它将无法做到，并且会卡在那里。当然，我们可以通过使用样条曲线平滑地调整路径来使路径更真实，或者我们可以手动检查每条路径以避免擦过障碍物的边缘。然而，问题在于航点不包含任何关于环境的信息，除了连接两个节点的轨迹。
- en: To address such situations, we're going to need a tremendous number of waypoints,
    which are very hard to manage. So, for everything other than straightforward games,
    we must exchange the computational cost of a grid with the mental and design cost
    of managing hundreds of waypoints.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这种情况，我们需要大量的航点，这非常难以管理。因此，对于除了简单游戏之外的所有事情，我们必须用管理数百个航点的心理和设计成本来交换网格的计算成本。
- en: 'Fortunately, there is a better solution: using a navigation mesh. A **navigation
    mesh** (often called **NavMesh**) is another graph structure that we can use to
    represent our world, similar to square tile-based grids and waypoint graphs:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个更好的解决方案：使用导航网格。**导航网格**（通常称为**NavMesh**）是我们可以用来说明我们世界的另一种图结构，类似于基于方块的网格和航点图：
- en: '![Figure 1.15 – Navigation mesh'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.15 – 导航网格]'
- en: '](img/B17984_01_15.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17984_01_15.jpg]'
- en: Figure 1.15 – Navigation mesh
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.15 – 导航网格]'
- en: A NavMesh uses convex polygons to represent the areas in the map where an AI
    entity can travel. The most crucial benefit of using a NavMesh is that it contains
    much more information about the environment than a waypoint system. With a NavMesh,
    we can automatically adjust our path safely because we know that our AI entities
    can move freely inside a region. Another advantage of using a NavMesh is that
    we can use the same mesh for different types of AI entities. Different AI entities
    can have different properties such as size, speed, and movement abilities. For
    instance, a set of waypoints may be suitable for human characters, but they may
    not work nicely for flying creatures or AI-controlled vehicles. Those may need
    different sets of waypoints (with all the problems that this adds).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: NavMesh使用凸多边形来表示地图中AI实体可以行走的区域。使用NavMesh的最关键好处是它比航点系统包含更多关于环境的信息。有了NavMesh，我们可以自动调整我们的路径，因为我们知道我们的AI实体可以在一个区域内自由移动。使用NavMesh的另一个优点是我们可以为不同类型的AI实体使用相同的网格。不同的AI实体可以有不同的属性，例如大小、速度和移动能力。例如，一组航点可能适合人类角色，但可能不适合飞行生物或AI控制的车辆。这些可能需要不同的航点集（这会带来所有这些问题）。
- en: However, programmatically generating a NavMesh based on a scene is a somewhat
    complicated process. Fortunately, Unity includes a built-in NavMesh generator.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，根据场景程序生成NavMesh是一个相对复杂的过程。幸运的是，Unity包含一个内置的NavMesh生成器。
- en: Since this is not a book on core AI techniques, we won't go into how to generate
    such NavMeshes. Instead, we'll learn how to efficiently use Unity's NavMesh to
    implement pathfinding for our AI characters.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这不是一本关于核心AI技术的书，我们不会深入探讨如何生成这样的NavMesh。相反，我们将学习如何有效地使用Unity的NavMesh来实现AI角色的路径查找。
- en: Behavior trees
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为树
- en: '**Behavior trees** are another technique that''s used to represent and control
    the logic behind AI characters'' decisions. They have become popular for their
    applications in AAA games such as *Halo* and *Spore*. We briefly covered FSMs
    earlier in this chapter, which is a straightforward way to define the logic of
    AI characters based on the transition between different states in reaction to
    game events. However, FSMs have two main issues: they are challenging to scale
    and reuse.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为树**是另一种用于表示和控制AI角色决策背后逻辑的技术。由于其在AAA游戏如*光环*和*孢子*中的应用而变得流行。我们在本章前面简要介绍了FSM，这是一种基于游戏事件反应中不同状态之间转换来定义AI角色逻辑的简单方法。然而，FSM有两个主要问题：它们难以扩展和重用。'
- en: To support all the scenarios where we want our characters to be, we need to
    add a lot of states and hardwire many transitions. So, we need something that
    scales better with more extensive problems. Behavior trees represent a sensible
    step in the right direction.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持我们希望角色存在的所有场景，我们需要添加很多状态并硬编码许多转换。因此，我们需要某种可以更好地与更广泛的问题缩放的东西。行为树代表了正确方向上的一个合理步骤。
- en: As its name suggests, the essence of a behavior tree is a tree-like data structure.
    The leaves of such trees are called **tasks**, and they represent our character's
    actions (for instance, *attack*, *chase*, *patrol*, *hide*, and so on) or sensory
    input (for example, *Is the player near?* or *Am I close enough to attack?*).
    Instead, the internal nodes of the trees are represented by control flow nodes,
    which guide the execution of the tree. **Sequence**, **Selector**, and **Parallel
    Decorator** are commonly used control flow nodes.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，行为树的本质是一种树状的数据结构。这种树的叶子被称为**任务**，它们代表我们角色的动作（例如，*攻击*、*追逐*、*巡逻*、*隐藏*等）或感官输入（例如，*玩家是否靠近？*或*我是否足够接近可以攻击？*）。相反，树的内节点由控制流节点表示，它们指导树的执行。**序列**、**选择器**和**并行装饰器**是常用的控制流节点。
- en: 'Now, let''s try to reimplement the example from the *Finite state machines*
    section using a behavior tree. First, we can break all the transitions and states
    into basic tasks:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用行为树重新实现“有限状态机”部分中的示例。首先，我们可以将所有转换和状态分解成基本任务：
- en: '![Figure 1.16 – Tasks'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.16 – 任务'
- en: '](img/B17984_01_16.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17984_01_16.jpg](img/B17984_01_16.jpg)'
- en: Figure 1.16 – Tasks
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.16 – 任务
- en: Now, let's look at a Selector node. We represent a Selector with a circle with
    a question mark inside it. When executed, a Selector node tries to execute all
    the child tasks/sub-trees in sequential order until the first one that returns
    with success. In other words, if we have a Selector with four children (for example,
    A, B, C, and D), the Selector node executes A first. If A fails, then the Selector
    executes B. If B fails, then it executes C, and so on. If *any* of the tasks return
    a Success, then the Sequence returns a Success as soon as that task completes.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看选择器节点。我们用一个带有问号的圆圈来表示选择器。当执行时，选择器节点会按顺序尝试执行所有子任务/子树，直到第一个返回成功的任务。换句话说，如果我们有一个有四个子节点（例如，A、B、C和D）的选择器，选择器节点会首先执行A。如果A失败，那么选择器会执行B。如果B失败，那么它会执行C，依此类推。如果*任何*任务返回成功，那么序列在完成那个任务后立即返回成功。
- en: 'In the following example, the Selector node first chooses to attack the player.
    If the **Attack** task returns a Success (that is, if the player is in attack
    range), the Selector node stops the execution and returns with a Success to its
    parent node – if there is one. Instead, if the **Attack** task returns with a
    failure, the Selector node moves to the **Chase** task. Here, we repeat what we
    did previously: if the **Chase** task succeeds, the Selector node succeeds; if
    the **Chase** task fails, it tries the **Patrol** task, and so on:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，选择器节点首先选择攻击玩家。如果**攻击**任务返回成功（即玩家在攻击范围内），选择器节点停止执行并返回成功给其父节点（如果有的话）。相反，如果**攻击**任务返回失败，选择器节点会移动到**追逐**任务。在这里，我们重复之前所做的事情：如果**追逐**任务成功，选择器节点成功；如果**追逐**任务失败，它会尝试**巡逻**任务，依此类推：
- en: '![Figure 1.17 – Selector node'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.17 – 选择器节点'
- en: '](img/B17984_01_17.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17984_01_17.jpg](img/B17984_01_17.jpg)'
- en: Figure 1.17 – Selector node
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.17 – 选择器节点
- en: 'What about the other kind of tasks – the ones that check the game state? We
    use them with Sequence nodes, which are usually represented with a rectangle with
    an arrow inside them. A Sequence node is similar to a Selector node with a crucial
    difference: it only returns a Success message if every sub-tree returns with a
    Success. In other words, if we have a Sequence with four children (for example,
    A, B, C, and D), the Sequence node will execute A, then B, then C, and finally
    D. If *all* the tasks return a Success, then the Sequence returns a Success.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，其他类型的任务——检查游戏状态的任务怎么办？我们与序列节点一起使用它们，通常用带有箭头的矩形表示。序列节点类似于选择器节点，但有一个关键的区别：只有当每个子树都返回成功时，它才返回成功消息。换句话说，如果我们有一个有四个子节点（例如，A、B、C和D）的序列，序列节点将执行A，然后是B，然后是C，最后是D。如果*所有*任务都返回成功，那么序列返回成功。
- en: 'In the following example, the first Sequence node checks whether the player
    character is close enough to attack. If this task succeeds, it will proceed to
    the next task: attacking the player. If the **Attack** task also returns with
    a Success message, the whole Sequence terminates with success. Instead, if the
    **Close Enough to Attack?** task fails, then the Sequence node does not proceed
    to the **Attack** task and returns a failed status to the parent Selector node.
    Then, the Selector chooses the next task in the Sequence, **Lost or Killed Player**,
    and the execution continues:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，第一个序列节点检查玩家角色是否足够接近以进行攻击。如果这个任务成功，它将进入下一个任务：攻击玩家。如果**攻击**任务也返回成功消息，整个序列将成功结束。相反，如果**足够接近以攻击？**任务失败，那么序列节点将不会进入**攻击**任务，并将失败状态返回给父选择器节点。然后，选择器选择序列中的下一个任务，**玩家失去或被杀**，执行继续：
- en: '![Figure 1.18 – Sequence tasks'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.18 – 序列任务'
- en: '](img/B17984_01_18.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_01_18.jpg)'
- en: Figure 1.18 – Sequence tasks
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.18 – 序列任务
- en: The other two common nodes are **Parallel** and **Decorator**. A Parallel node
    executes all of its child tasks simultaneously (while the Sequence and Selector
    nodes only execute their child trees one by one). A Decorator is another type
    of node that has only one child. It is used to change the behavior of its own
    single child's sub-tree, for instance, to run it multiple times or invert the
    subtree's result (if the subtree returns a Success message, the decorator returns
    a failure, and vice versa).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个常见的节点是**并行**和**装饰器**。并行节点同时执行其所有子任务（而序列和选择器节点只依次执行其子树）。装饰器是另一种只有单个子节点的节点。它用于改变其单个子树的行为，例如，运行它多次或反转子树的结果（如果子树返回成功消息，装饰器返回失败，反之亦然）。
- en: We'll learn how to implement a basic behavior tree system in Unity in [*Chapter
    9*](B17984_09_Epub.xhtml#_idTextAnchor487), *Behavior Trees*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第 9 章*](B17984_09_Epub.xhtml#_idTextAnchor487) *行为树*中学习如何在 Unity 中实现基本的行为树系统。
- en: Locomotion
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运动方式
- en: Animals (including humans) have a very complex musculoskeletal system that allows
    them to move around their environment. Animals also have sophisticated brains
    that tell them how to use such a system. For instance, we instinctively know where
    to put our steps when climbing a ladder, stairs, or uneven terrain, and we also
    know how to balance our bodies to stabilize all the fancy poses we want to make.
    We can do all this using a brain that controls our bones, muscles, joints, and
    other tissues, collectively described as our locomotor system.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 动物（包括人类）拥有一个非常复杂的肌肉骨骼系统，使它们能够在环境中移动。动物还拥有复杂的头脑，告诉它们如何使用这样的系统。例如，我们本能地知道在攀爬梯子、楼梯或不平地形时应该把脚放在哪里，我们还知道如何平衡身体以稳定我们想要做出的所有复杂姿势。我们可以通过控制我们的骨骼、肌肉、关节和其他组织的头脑来完成所有这些，这些被统称为我们的运动系统。
- en: 'Now, let''s put this in a game development perspective. Let''s say we have
    a human character who needs to walk on uneven surfaces or small slopes, and we
    have only one animation for a walk cycle. With the lack of a locomotor system
    in our virtual character, this is what it would look like:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从游戏开发的角度来看这个问题。假设我们有一个人类角色，他需要在不平坦的表面或小斜坡上行走，而我们只有一个行走循环的动画。由于我们的虚拟角色缺少运动系统，这将是以下样子：
- en: '![Figure 1.19 – Climbing stairs without locomotion'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.19 – 无运动方式爬楼梯'
- en: '](img/B17984_01_19.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_01_19.jpg)'
- en: Figure 1.19 – Climbing stairs without locomotion
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.19 – 无运动方式爬楼梯
- en: First, we play the walk animation and move the player forward. But now, the
    character is penetrating the surface. So, the collision detection system pulls
    the character above the surface to stop this impossible configuration.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们播放行走动画并将玩家向前移动。但现在，角色正在穿透表面。因此，碰撞检测系统将角色拉到表面以上以停止这种不可能的配置。
- en: 'Now, let''s look at how we walk upstairs in reality. We put our foot firmly
    on the staircase and, using force, we pull the rest of our body onto the next
    step. However, it''s not simple to implement this level of realism in games. We''ll
    need many animations for different scenarios, including climbing ladders, walking/running
    upstairs, and so on. So, in the past, only the large studios with many animators
    could pull this off. Nowadays, however, we have automated systems for this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们在现实中如何上楼。我们坚定地将脚放在楼梯上，并使用力量将身体的其他部分拉到下一个台阶上。然而，在游戏中实现这种级别的现实感并不简单。我们需要为不同的场景准备许多动画，包括攀爬梯子、上楼行走/跑步等。因此，在过去，只有拥有许多动画师的大型工作室才能做到这一点。然而，如今，我们有了自动化的系统来完成这项工作：
- en: '![Figure 1.20 – Unity extension for inverse kinematics'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.20 – Unity 逆运动学扩展'
- en: '](img/B17984_01_20.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_01_20.jpg)'
- en: Figure 1.20 – Unity extension for inverse kinematics
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.20 – Unity 逆运动学扩展
- en: This system can automatically blend our animated walk/run cycles and adjust
    the movements of the bones in the player's legs to ensure that the player's feet
    step on the ground correctly (in literature, this is called **inverse kinematics**).
    It can also adjust the animations that were initially designed for a specific
    speed and direction, to any speed and direction on any surface, such as steps
    and slopes. In [*Chapter 6*](B17984_06_Epub.xhtml#_idTextAnchor375), *Path Following
    and Steering Behaviors*, we'll learn how to use this locomotion system to apply
    realistic movement to our AI characters.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统可以自动混合我们的动画行走/跑步周期，并调整玩家腿部骨骼的运动，以确保玩家的脚正确地踩在地面上（在文献中，这被称为**逆运动学**）。它还可以调整最初为特定速度和方向设计的动画，以适应任何表面上的任何速度和方向，例如台阶和斜坡。在[*第
    6 章*](B17984_06_Epub.xhtml#_idTextAnchor375)，“路径跟随和转向行为”中，我们将学习如何使用这个运动系统为我们的
    AI 角色应用逼真的动作。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned that game AI and academic AI have different objectives.
    Academic AI researchers try to solve real-world problems and develop AI algorithms
    that compete with human intelligence, with the ultimate goal of replacing humans
    in complex situations. On the other hand, game AI focuses on building NPCs with
    limited resources that seem to be intelligent to the player, with the ultimate
    goal of entertaining them. The objective of AI in games is to provide a challenging
    opponent that makes the game more fun to play.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到游戏人工智能和学术人工智能有不同的目标。学术人工智能研究人员试图解决现实世界的问题，并开发与人类智能竞争的人工智能算法，其最终目标是取代人类在复杂情况下的工作。另一方面，游戏人工智能侧重于使用有限资源构建看起来对玩家来说很智能的非玩家角色（NPC），其最终目标是娱乐他们。游戏人工智能的目标是提供一个具有挑战性的对手，使游戏更具趣味性。
- en: We also learned about the different AI techniques that are used in games, such
    as FSMs, randomness and probability, sensors, input systems, flocking and group
    behaviors, path following and steering behaviors, AI pathfinding, navigation mesh
    generation, and behavior trees.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了在游戏中使用的不同人工智能技术，例如有限状态机（FSMs）、随机性和概率、传感器、输入系统、群体行为和群体行为、路径跟随和转向行为、人工智能路径查找、导航网格生成和行为树。
- en: 'We''ll learn how to implement these techniques inside the Unity engine in the
    following chapters. In the next chapter, we will start with the basics: FSMs.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中学习如何在 Unity 引擎中实现这些技术。在下一章中，我们将从基础知识开始：有限状态机（FSMs）。
