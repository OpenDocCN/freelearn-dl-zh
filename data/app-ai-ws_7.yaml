- en: Appendix
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: 1\. Introduction to Artificial Intelligence
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 人工智能简介
- en: 'Activity 1.01: Generating All Possible Sequences of Steps in a Tic-Tac-Toe
    Game'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 1.01：生成井字棋游戏中的所有可能步骤序列
- en: '**Solution**:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: 'The following steps will help you to complete this activity:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成此活动：
- en: Open a new Jupyter Notebook file.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Jupyter Notebook文件。
- en: Reuse the function codes of *Steps 2–9* from the previous, *Exercise 1.02*,
    *Creating an AI with Random Behavior for the Tic-Tac-Toe Game*.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重用先前步骤*步骤 2–9*中的函数代码，*练习 1.02*，*为井字棋游戏创建具有随机行为的AI*。
- en: 'Create a function that maps the `all_moves_from_board_list` function to each
    element of a list of boards. This way, we will have all of the nodes of a decision
    tree in each depth:'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，将`all_moves_from_board_list`函数映射到棋盘列表的每个元素。这样，我们将在每个深度获得决策树的所有节点：
- en: '[PRE0]'
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code snippet, we have defined the `all_moves_from_board` function,
    which will enumerate all the possible moves from the board and add the move to
    a list called `move_list`.
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了`all_moves_from_board`函数，它将列举所有棋盘上的可能移动，并将这些动作添加到一个名为`move_list`的列表中。
- en: 'Create a variable called board that contains the `EMPTY_SIGN * 9` decision
    tree and calls the `all_moves_from_board_list` function with the board and `AI_SIGN`.
    Save its output in a variable called `all_moves` and print its content:'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为board的变量，包含`EMPTY_SIGN * 9`的决策树，并使用`all_moves_from_board_list`函数对该棋盘和`AI_SIGN`进行调用。将其输出保存到一个名为`all_moves`的变量中，并打印其内容：
- en: '[PRE1]'
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The expected output is this:'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '[PRE2]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a `filter_wins` function that takes the ended games out from the list
    of moves and appends them in an array containing the board states won by the AI
    player and the opponent player:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`filter_wins`函数，将结束的游戏从动作列表中提取，并将它们追加到一个包含AI玩家和对手玩家获胜棋盘状态的数组中：
- en: '[PRE3]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code snippet, we have defined a `filter_wins` function, which
    will add the winning state of the board for each player to a list.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了一个`filter_wins`函数，它将每个玩家的获胜状态添加到棋盘的列表中。
- en: 'Use the `count_possibilities` function, which prints and returns the number
    of decision tree leaves that ended with a draw, that were won by the first player,
    and that were won by the second player, as shown in the following code snippet:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`count_possibilities`函数，该函数打印并返回决策树叶子节点的数量，分别为平局、第一玩家获胜和第二玩家获胜，如下方代码片段所示：
- en: '[PRE4]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have up to `9` steps in each state. In the 0th, 2nd, 4th, 6th, and 8th iterations,
    the AI player moves. In all the other iterations, the opponent moves. We create
    all possible moves in all steps and take out the completed games from the move list.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在每个状态中最多有`9`个步骤。在第0、2、4、6和8次迭代中，AI玩家进行移动。在所有其他迭代中，对手进行移动。我们在所有步骤中创建所有可能的动作，并从动作列表中提取完成的游戏。
- en: 'Execute the number of possibilities to experience the combinatorial explosion
    and save the results in four variables called `first_player`, `second_player`,
    `draw`, and `total`:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行可能性数量以体验组合爆炸，并将结果保存在四个变量中，分别为`first_player`、`second_player`、`draw`和`total`：
- en: '[PRE5]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The expected output is this:'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '[PRE6]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the tree of the board states consists of a total of `266073`
    leaves. The `count_possibilities` function essentially implements a BFS algorithm
    to traverse all the possible states of the game. Notice that we count these states
    multiple times because placing an `X` in the top-right corner in *Step 1* and
    placing an `X` in the top-left corner in *Step 3* leads to similar possible states
    as starting with the top-left corner and then placing an `X` in the top-right
    corner. If we implemented the detection of duplicate states, we would have to
    check fewer nodes. However, at this stage, due to the limited depth of the game,
    we will omit this step.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，棋盘状态的树由总共`266073`个叶子节点组成。`count_possibilities`函数本质上实现了一个BFS算法，用于遍历游戏的所有可能状态。请注意，我们会多次计算这些状态，因为在*步骤
    1*中将`X`放置在右上角与在*步骤 3*中将`X`放置在左上角会导致与从左上角开始再将`X`放置在右上角类似的状态。如果我们实现了重复状态的检测，我们需要检查的节点会更少。然而，在此阶段，由于游戏深度有限，我们将省略此步骤。
- en: A decision tree, however, is identical to the data structure examined by `count_possibilities`.
    In a decision tree, we explore the utility of each move by investigating all possible
    future steps up to a certain extent. In our example, we could calculate the utility
    of the initial moves by observing the number of wins and losses after fixing the
    first few moves.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，决策树与 `count_possibilities` 检查的数据结构是相同的。在决策树中，我们通过探索所有可能的未来步骤来评估每个行动的效用。在我们的示例中，我们可以通过观察固定前几步后的胜负情况来计算初始步骤的效用。
- en: Note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The root of the tree is the initial state. An internal state of the tree is
    a state in which a game has not been ended and moves are still possible. A leaf
    of the tree contains a state where a game has ended.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 树的根节点是初始状态。树的内部状态是游戏尚未结束并且仍有可能进行移动的状态。树的叶子节点包含一个游戏已结束的状态。
- en: To access the source code for this specific section, please refer to [https://packt.live/3doxPog](https://packt.live/3doxPog).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问这一特定部分的源代码，请参考 [https://packt.live/3doxPog](https://packt.live/3doxPog)。
- en: You can also run this example online at [https://packt.live/3dpnuIz](https://packt.live/3dpnuIz).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在网上运行此示例，访问 [https://packt.live/3dpnuIz](https://packt.live/3dpnuIz)。
- en: You must execute the entire Notebook in order to get the desired result.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须执行整个 Notebook 才能得到期望的结果。
- en: 'Activity 1.02: Teaching the Agent to Realize Situations When It Defends Against
    Losses'
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 1.02：教授代理人认识到它何时防止失败
- en: '**Solution**:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: 'The following steps will help you to complete this activity:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成此活动：
- en: Open a new Jupyter Notebook file.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Jupyter Notebook 文件。
- en: Reuse all the code from *Steps 2–6* from the previous, *Exercise 1.03*, *Teaching
    the Agent to Win*.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重用之前 *步骤 2–6* 中的所有代码，来自 *练习 1.03*，*教授代理人获胜*。
- en: Create a function called `player_can_win` that takes all the moves from the
    board using the `all_moves_from_board` function and iterates over them using the
    `next_move` variable.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `player_can_win` 的函数，该函数使用 `all_moves_from_board` 函数获取所有棋盘上的移动，并通过 `next_move`
    变量进行迭代。
- en: In each iteration, it checks whether the game can be won by the player.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在每次迭代中，它检查玩家是否可以获胜。
- en: '[PRE7]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Extend the AI move so that it prefers making safe moves. A move is safe if
    the opponent cannot win the game in the next step:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展 AI 移动，使其更倾向于进行安全移动。如果一个移动是安全的，即对手无法在下一步获胜，那么该移动就被视为安全的：
- en: '[PRE8]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code snippet, we have defined the `ai_move` function, which
    tells the AI how to move by looking at the list of all the possibilities and choosing
    one where the player cannot win in the next move. If you test our new application,
    you will find that the AI has made the correct move.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了 `ai_move` 函数，该函数通过查看所有可能的列表并选择一个玩家无法在下一步获胜的选项来告诉 AI 如何行动。如果你测试我们的新应用，你会发现
    AI 已经做出了正确的决定。
- en: 'Now, place this logic in the state space generator and check how well the computer
    player is doing by generating all the possible games:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将此逻辑放入状态空间生成器中，并通过生成所有可能的游戏来检查电脑玩家的表现：
- en: '[PRE9]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code snippet, we have defined a function that generates all
    possible moves. As soon as we find the next move that can make the player win,
    we return a move to counter it. We do not care whether the player has multiple
    options to win the game in one move – we just return the first possibility. If
    the AI cannot stop the player from winning, we return all possible moves.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了一个生成所有可能移动的函数。一旦我们找到了能够让玩家获胜的下一步，我们就返回一个反制的移动。我们不关心玩家是否有多个获胜选项——我们只返回第一个可能性。如果
    AI 无法阻止玩家获胜，我们就返回所有可能的移动。
- en: Let's see what this means in terms of counting all of the possibilities at each
    step.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看这在每一步计数所有可能性时意味着什么。
- en: 'Count the options that are possible:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算所有可能的选项：
- en: '[PRE10]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The expected output is this:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出是这样的：
- en: '[PRE11]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We are doing better than before. We not only got rid of almost 2/3 of possible
    games again, but, most of the time, the AI player either wins or settles for a
    draw.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在做得比之前更好了。我们不仅再次去除了几乎 2/3 的可能游戏，而且，大多数时候，AI 玩家要么获胜，要么以平局收场。
- en: Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2B0G9xf](https://packt.live/2B0G9xf).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问这一特定部分的源代码，请参考 [https://packt.live/2B0G9xf](https://packt.live/2B0G9xf)。
- en: You can also run this example online at [https://packt.live/2V7qLpO](https://packt.live/2V7qLpO).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在网上运行此示例，访问 [https://packt.live/2V7qLpO](https://packt.live/2V7qLpO)。
- en: You must execute the entire Notebook in order to get the desired result.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须执行整个 Notebook 才能得到期望的结果。
- en: 'Activity 1.03: Fixing the First and Second Moves of the AI to Make It Invincible'
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动1.03：修复AI的第一步和第二步，使其无敌
- en: '**Solution**:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: 'The following steps will help you to complete this activity:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成此活动：
- en: Open a new Jupyter Notebook file.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Jupyter Notebook文件。
- en: Reuse the code from *Steps 2–4* of the previous, *Activity 1.02*, *Teaching
    the Agent to Realize Situations When It Defends Against Losses*.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重用前面的*步骤2–4*中的代码，*活动1.02*，*教会代理在防止输局时识别局势*。
- en: 'Now, count the number of empty fields on the board and make a hardcoded move
    in case there are 9 or 7 empty fields. You can experiment with different hardcoded
    moves. We found that occupying any corner, and then occupying the opposite corner,
    leads to no loss. If the opponent occupies the opposite corner, making a move
    in the middle results in no losses:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，计算棋盘上空白格子的数量，并在空白格子有9个或7个时做出硬编码的移动。你可以尝试不同的硬编码移动。我们发现，占据任意一个角落，然后占据对角的角落，能够保证不输。如果对手占据了对角的角落，那么在中间位置做出移动也不会失败：
- en: '[PRE12]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, verify the state space:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，验证状态空间：
- en: '[PRE13]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The expected output is this:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出是这样的：
- en: '[PRE14]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After fixing the first two steps, we only need to deal with 8 possibilities
    instead of 504\. We also guided the AI into a state where the hardcoded rules
    were sufficient enough for it to never lose a game. Fixing the steps is not important
    because we would give the AI hardcoded steps to start with, but it is important
    because it is a tool that is used to evaluate and compare each step. After fixing
    the first two steps, we only need to deal with 8 possibilities instead of 504\.
    We also guided the AI into a state, where the hardcoded rules were sufficient
    for never losing a game. As you can see, the AI is now nearly invincible and will
    only win or make a draw.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 修正前两个步骤后，我们只需要处理8种可能，而不是504种。我们还引导AI进入了一个状态，在这个状态下，硬编码规则足够使它永远不会输掉游戏。修正步骤并不重要，因为我们会给AI提供硬编码的步骤，但它很重要，因为它是用来评估和比较每一步的工具。修正前两个步骤后，我们只需要处理8种可能，而不是504种。我们还引导AI进入了一个状态，在这个状态下，硬编码规则足以让它永不输掉游戏。正如你所见，AI现在几乎是无敌的，它只会获胜或平局。
- en: The best that a player can hope to get against this AI is a draw.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家对抗这个AI时，最好的结果是平局。
- en: Note
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2YnUcpA](https://packt.live/2YnUcpA).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 若要访问此部分的源代码，请参考[https://packt.live/2YnUcpA](https://packt.live/2YnUcpA)。
- en: You can also run this example online at [https://packt.live/318TBtq](https://packt.live/318TBtq).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/318TBtq](https://packt.live/318TBtq)上在线运行此示例。
- en: You must execute the entire Notebook in order to get the desired result.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须执行整个Notebook，以获得预期的结果。
- en: 'Activity 1.04: Connect Four'
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动1.04：四子棋
- en: '**Solution**:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: Open a new Jupyter Notebook file.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Jupyter Notebook文件。
- en: Let's set up the `TwoPlayersGame` framework by writing the `init` method.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们通过编写`init`方法来设置`TwoPlayersGame`框架。
- en: 'Define the board as a one-dimensional list, like the tic-tac-toe example. We
    could use a two-dimensional list, too, but modeling will not get much easier or
    harder. Beyond making initialization like we did in the tic-tac-toe game, we will
    work a bit further ahead. We will generate all of the possible winning combinations
    in the game and save them for future use, as shown in the following code snippet:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将棋盘定义为一维列表，就像井字游戏的示例一样。我们也可以使用二维列表，但建模的难度不会有太大变化。除了像井字游戏那样进行初始化外，我们还将进一步操作。我们将生成游戏中所有可能的胜利组合，并将其保存以供以后使用，代码如下所示：
- en: '[PRE15]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, handle the `possible_moves` function, which is a simple enumeration.
    Notice that we are using column indices from `1` to `7` in the move names because
    it is more convenient to start a column indexing with `1` in the human player
    interface than with zero. For each column, we check whether there is an unoccupied
    field. If there is one, we will make the column a possible move:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，处理`possible_moves`函数，这是一个简单的枚举。请注意，我们在移动名称中使用从`1`到`7`的列索引，因为在玩家界面中，从`1`开始列索引比从零开始更为方便。对于每一列，我们检查是否有空闲格子。如果有空位，我们就将该列设为一个可能的移动：
- en: '[PRE16]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Making a move is like the `possible_moves` function. We check the column of
    the move and find the first empty cell starting from the bottom. Once we find
    it, we occupy it. You can also read the implementation of the both the `make_move`
    function: `unmake_move`. In the `unmake_move` function, we check the column from
    top to down, and we remove the move at the first non-empty cell. Notice that we
    rely on the internal representation of `easyAI` so that it does not undo moves
    that it hasn''t made. Otherwise, this function would remove a token of the other
    player without checking whose token was removed:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一次移动就像`possible_moves`函数一样。我们检查该移动的列，并从底部开始找到第一个空单元格。一旦找到，就占据它。你也可以阅读`make_move`和`unmake_move`两个函数的实现。在`unmake_move`函数中，我们从上到下检查列，并在第一个非空单元格处移除移动。请注意，我们依赖于`easyAI`的内部表示，以确保它不会撤销自己没有做的移动。否则，这个函数会在不检查的情况下删除对方玩家的棋子：
- en: '[PRE17]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since we already have the tuples that we must check, we can mostly reuse the
    `lose` function from the tic-tac-toe example:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经有了必须检查的元组，我们可以大部分复用来自井字游戏示例的`lose`函数：
- en: '[PRE18]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Our final task is to implement the `show` method, which prints the board. We
    will reuse the tic-tac-toe implementation and just change the `show` and `scoring` variables:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的最终任务是实现`show`方法，该方法打印棋盘。我们将重用井字游戏的实现，只需更改`show`和`scoring`变量：
- en: '[PRE19]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that all the functions are complete, you can try out the example. Feel free
    to play a round or two against your opponent.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在所有函数都已完成，你可以尝试示例。随时和对手玩一两局。
- en: 'The expected output is this:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出是这样的：
- en: '![Figure 1.30: Expected output for the Connect Four game'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图1.30：连接四子游戏的预期输出'
- en: '](img/B16060_01_30.jpg)'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_01_30.jpg)'
- en: 'Figure 1.30: Expected output for the Connect Four game'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.30：连接四子游戏的预期输出
- en: By completing this activity, you have seen that the opponent is not perfect,
    but that it plays reasonably well. If you have a strong computer, you can increase
    the parameter of the `Negamax` algorithm. We encourage you to come up with a better
    heuristic.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此活动后，你会发现对手并不完美，但它的表现相当不错。如果你有一台强大的计算机，你可以增加`Negamax`算法的参数。我们鼓励你提出更好的启发式方法。
- en: Note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3esk2hI](https://packt.live/3esk2hI).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考[https://packt.live/3esk2hI](https://packt.live/3esk2hI)。
- en: You can also run this example online at [https://packt.live/3dnkfS5](https://packt.live/3dnkfS5).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/3dnkfS5](https://packt.live/3dnkfS5)上在线运行此示例。
- en: You must execute the entire Notebook in order to get the desired result.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须执行整个Notebook，才能获得期望的结果。
- en: 2\. An Introduction to Regression
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 回归介绍
- en: 'Activity 2.01: Boston House Price Prediction with Polynomial Regression of
    Degrees 1, 2, and 3 on Multiple Variables'
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动2.01：使用1、2和3度多变量的多项式回归进行波士顿房价预测
- en: '**Solution**:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: Open a Jupyter Notebook.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个Jupyter Notebook。
- en: 'Import the required packages and load the Boston House Prices data from `sklearn`
    into a DataFrame:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的包并从`sklearn`加载波士顿房价数据到DataFrame中：
- en: '[PRE20]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output of `df` is as follows:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`df`的输出如下：'
- en: '![Figure 2.28: Output displaying the dataset'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图2.28：显示数据集的输出'
- en: '](img/B16060_02_28.jpg)'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_02_28.jpg)'
- en: 'Figure 2.28: Output displaying the dataset'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.28：显示数据集的输出
- en: Earlier in this chapter, you learned that most of the required packages to perform
    linear regression come from `sklearn`. We need to import the `preprocessing` module
    to scale the data, the `linear_model` module to train linear regression, the `PolynomialFeatures`
    module to transform the inputs for the polynomial regression, and the `model_selection`
    module to evaluate the performance of each model.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本章前面，你学习了执行线性回归所需的大部分包都来自`sklearn`。我们需要导入`preprocessing`模块来缩放数据，`linear_model`模块来训练线性回归，`PolynomialFeatures`模块来转换多项式回归的输入，以及`model_selection`模块来评估每个模型的性能。
- en: 'Prepare the dataset for prediction by converting the label and features into
    NumPy arrays and scaling the features:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将标签和特征转换为NumPy数组并缩放特征，准备预测数据集：
- en: '[PRE21]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output for `features` is as follows:'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`features`的输出如下：'
- en: '![Figure 2.29: Labels and features converted to NumPy arrays'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图2.29：标签和特征转换为NumPy数组'
- en: '](img/B16060_02_29.jpg)'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_02_29.jpg)'
- en: '[PRE22]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, our features have been properly scaled.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，我们的特征已经被正确缩放。
- en: As we don't have any missing values and we are not trying to predict a future
    value as we did in *Exercise 2.03*, *Preparing the Quandl Data for Prediction*,
    we can directly convert the label (`'MEDV'`) and features into NumPy arrays. Then,
    we can scale the arrays of features using the `preprocessing.scale()` function.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们没有缺失值，并且不像在*练习 2.03*中那样试图预测未来值（*准备 Quandl 数据进行预测*），我们可以直接将标签（`'MEDV'`）和特征转换为
    NumPy 数组。然后，我们可以使用 `preprocessing.scale()` 函数对特征数组进行缩放。
- en: 'Create three different set of features by transforming the scaled features
    into a suitable format for each of the polynomial regressions:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将缩放特征转换为适合每个多项式回归的格式，创建三组不同的特征集：
- en: '[PRE23]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output for `poly_1_scaled_features` is as follows:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`poly_1_scaled_features` 的输出如下：'
- en: '[PRE24]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Our `scaled_features` variable has been properly transformed for the polynomial
    regression of degree `1`.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的 `scaled_features` 变量已正确转换，用于度数为 `1` 的多项式回归。
- en: 'The output for `poly_2_scaled_features` is as follows:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`poly_2_scaled_features` 的输出如下：'
- en: '![Figure 2.31: Output showing poly_2_scaled_features'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.31：显示 poly_2_scaled_features 输出的图像]'
- en: '](img/B16060_02_31.jpg)'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_02_31.jpg)'
- en: '[PRE25]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Our `scaled_features` variable has been properly transformed for the polynomial
    regression of degree `3`.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的 `scaled_features` 变量已正确转换，用于度数为 `3` 的多项式回归。
- en: We had to transform the scaled features in three different ways as each degree
    of polynomial regression required a different input transformation.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们必须以三种不同的方式转换缩放特征，因为每个多项式回归度数需要不同的输入转换。
- en: 'Split the data into a training set and a testing set with `random state = 8`:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据分为训练集和测试集，`random state = 8`：
- en: '[PRE26]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we have three different sets of scaled transformed features but the same
    set of labels, we had to perform three different splits. By using the same set
    of labels and `random_state` in each splitting, we ensure that we obtain the same
    `poly_label_train` and `poly_label_test` for every split.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们有三组不同的缩放转换特征，但相同的标签集，我们必须执行三次不同的拆分。通过在每次拆分中使用相同的标签集和 `random_state`，我们确保每次拆分都获得相同的
    `poly_label_train` 和 `poly_label_test`。
- en: 'Perform a polynomial regression of degree 1 and evaluate whether the model
    is overfitting:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行度数为 1 的多项式回归，并评估模型是否存在过拟合：
- en: '[PRE27]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output for `model_1_score_train` is as follows:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`model_1_score_train` 的输出如下：'
- en: '[PRE28]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output for `model_1_score_test` is as follows:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`model_1_score_test` 的输出如下：'
- en: '[PRE29]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To estimate whether a model is overfitting or not, we need to compare the scores
    of the model applied to the training set and testing set. If the score for the
    training set is much higher than the test set, we are overfitting. This is the
    case here where the polynomial regression of degree 1 achieved a score of `0.74`
    for the training set compared to `0.68` for the testing set.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了估计模型是否过拟合，我们需要比较应用于训练集和测试集的模型得分。如果训练集的得分远高于测试集，则表示过拟合。在此案例中，度数为 1 的多项式回归在训练集上的得分为
    `0.74`，而测试集上的得分为 `0.68`。
- en: 'Perform a polynomial regression of degree 2 and evaluate whether the model
    is overfitting:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行度数为 2 的多项式回归，并评估模型是否存在过拟合：
- en: '[PRE30]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output for `model_2_score_train` is as follows:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`model_2_score_train` 的输出如下：'
- en: '[PRE31]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output for `model_2_score_test` is as follows:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`model_2_score_test` 的输出如下：'
- en: '[PRE32]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Like with the polynomial regression of degree 1, our polynomial regression of
    degree 2 is overfitting even more than degree 1, but has managed to achieve better
    results at the end.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就像一次多项式回归度数为 1 的情况，我们的多项式回归度数为 2 时过拟合的情况更加严重，但最终却取得了更好的结果。
- en: 'Perform a polynomial regression of degree 3 and evaluate whether the model
    is overfitting:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行度数为 3 的多项式回归，并评估模型是否存在过拟合：
- en: '[PRE33]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output for `model_3_score_train` is as follows:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`model_3_score_train` 的输出如下：'
- en: '[PRE34]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output for `model_3_score_test` is as follows:'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`model_3_score_test` 的输出如下：'
- en: '[PRE35]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: These results are very interesting because the polynomial regression of degree
    3 managed to achieve a near-perfect score with `0.99` (1 is the maximum). This
    is a warning sign that our model is overfitting too much. We have the confirmation
    of this warning when the model is applied to the testing set and achieves a very
    low negative score of `-8430`. As a reminder, a score of 0 can be achieved by
    using the mean of the data as a prediction. This means that our third model managed
    to make worse predictions than just using the mean.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些结果非常有趣，因为三次多项式回归成功地达到了接近完美的分数`0.99`（1是最高分）。这给出了一个警告信号，表明我们的模型过度拟合了训练数据。当模型应用于测试集时，我们得到了一个非常低的负分数`-8430`，这进一步确认了过拟合问题。提醒一下，0分是通过将数据的均值作为预测值得到的。这意味着我们的第三个模型的预测结果比单纯使用均值还要差。
- en: 'Compare the predictions of the 3 models against the label on the testing set:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较3个模型在测试集上的预测结果与标签：
- en: '[PRE36]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output of `df_prediction` is as follows:'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`df_prediction`的输出如下：'
- en: '![Figure 2.32: Output showing the expected predicted values'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图2.32：显示期望预测值的输出'
- en: '](img/B16060_02_32.jpg)'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_02_32.jpg)'
- en: 'Figure 2.32: Output showing the expected predicted values'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.32：显示期望预测值的输出
- en: After applying the `predict` function for each model on their respective testing
    set, in order to get the predicted values, we convert them into a single `df_prediction`
    DataFrame with the label values. Increasing the number of degrees in polynomial
    regressions does not necessarily mean that the model will perform better compared
    to one with a lower degree. In fact, increasing the degree will lead to more overfitting
    on the training data.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在对每个模型应用`predict`函数，得到它们各自测试集的预测值之后，我们将它们与标签值一起转换成一个单独的`df_prediction`数据框。增加多项式回归的次数并不意味着模型的表现一定会比低次模型更好。实际上，增加次数会导致模型在训练数据上的过拟合。
- en: Note
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3eD8gAY](https://packt.live/3eD8gAY).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考[https://packt.live/3eD8gAY](https://packt.live/3eD8gAY)。
- en: You can also run this example online at [https://packt.live/3etadjp](https://packt.live/3etadjp).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/3etadjp](https://packt.live/3etadjp)上在线运行此示例。
- en: You must execute the entire Notebook in order to get the desired result.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须执行整个Notebook才能得到期望的结果。
- en: In this activity, we learned how to perform polynomial regressions of degrees
    1 to 3 with multiple variables on the Boston House Price dataset and saw how increasing
    the degrees led to overfitted models.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们学习了如何对波士顿房价数据集进行1到3度的多项式回归，并看到增加度数会导致模型过拟合。
- en: 3\. An Introduction to Classification
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. 分类简介
- en: 'Activity 3.01: Increasing the Accuracy of Credit Scoring'
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动3.01：提高信用评分的准确度
- en: '**Solution**:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: Open a new Jupyter Notebook file and execute all the steps from the previous
    exercise, *Exercise 3.04*, *K-Nearest Neighbors Classification in Scikit-Learn*.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Jupyter Notebook文件，执行上一个练习*Exercise 3.04*中的所有步骤，*Scikit-Learn中的K-最近邻分类*。
- en: 'Import `neighbors` from `sklearn`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`sklearn`导入`neighbors`：
- en: '[PRE37]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create a function called `fit_knn` that takes the following parameters: `k`,
    `p`, `features_train`, `label_train`, `features_test`, and `label_test`. This
    function will fit `KNeighborsClassifier` with the training set and print the accuracy
    score for the training and testing sets, as shown in the following code snippet:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`fit_knn`的函数，该函数接受以下参数：`k`、`p`、`features_train`、`label_train`、`features_test`和`label_test`。这个函数将使用训练集拟合`KNeighborsClassifier`，并打印训练集和测试集的准确度评分，如下代码片段所示：
- en: '[PRE38]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Call the `fit_knn()` function with `k=5` and `p=2`, save the results in `2`
    variables, and print them. These variables are `acc_train_1` and `acc_test_1`:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`fit_knn()`函数，设置`k=5`和`p=2`，将结果保存到`2`个变量中并打印。这些变量是`acc_train_1`和`acc_test_1`：
- en: '[PRE39]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The expected output is this:'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 期望的输出是这样的：
- en: '[PRE40]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With `k=5` and `p=2`, KNN achieved a good accuracy score close to `0.78`. But
    the score is quite different from the training and testing sets, which means the
    model is overfitting.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`k=5`和`p=2`时，KNN取得了接近`0.78`的不错的准确率。但训练集和测试集的分数差异较大，这意味着模型存在过拟合问题。
- en: 'Call the `fit_knn()` function with `k=10` and `p=2`, save the results in `2`
    variables, and print them. These variables are `acc_train_2` and `acc_test_2`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`fit_knn()`函数，设置`k=10`和`p=2`，将结果保存到`2`个变量中并打印。这些变量是`acc_train_2`和`acc_test_2`：
- en: '[PRE41]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The expected output is this:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 期望的输出是这样的：
- en: '[PRE42]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Increasing the number of neighbors to 10 has decreased the accuracy score of
    the training set, but now it is very close to the testing set.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将邻居数量增加到10降低了训练集的准确性，但现在它与测试集的准确性非常接近。
- en: 'Call the `fit_knn()` function with `k=15` and `p=2`, save the results in `2`
    variables, and print them. These variables are `acc_train_3` and `acc_test_3`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`k=15`和`p=2`调用`fit_knn()`函数，将结果保存在`2`个变量中，并打印它们。这些变量是`acc_train_3`和`acc_test_3`：
- en: '[PRE43]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The expected output is this:'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出是这样的：
- en: '[PRE44]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: With `k=15` and `p=2`, the difference between the training and testing sets
    has  increased.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`k=15`和`p=2`时，训练集和测试集之间的差异增加了。
- en: 'Call the `fit_knn()` function with `k=25` and `p=2`, save the results in `2`
    variables, and print them. These variables are `acc_train_4` and `acc_test_4`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`k=25`和`p=2`调用`fit_knn()`函数，将结果保存在`2`个变量中，并打印它们。这些变量是`acc_train_4`和`acc_test_4`：
- en: '[PRE45]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The expected output is this:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出是这样的：
- en: '[PRE46]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Increasing the number of neighbors to `25` has a significant impact on the training
    set. However, the model is still overfitting.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将邻居数量增加到`25`对训练集产生了显著影响，但模型仍然存在过拟合。
- en: 'Call the `fit_knn()` function with `k=50` and `p=2`, save the results in `2`
    variables, and print them. These variables are `acc_train_5` and `acc_test_5`:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`k=50`和`p=2`调用`fit_knn()`函数，将结果保存在`2`个变量中，并打印它们。这些变量是`acc_train_5`和`acc_test_5`：
- en: '[PRE47]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The expected output is this:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出是这样的：
- en: '[PRE48]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Bringing the number of neighbors to `50` neither improved the model's performance
    or the overfitting issue.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将邻居数量增加到`50`既没有改善模型性能，也没有解决过拟合问题。
- en: 'Call the `fit_knn()` function with `k=5` and `p=1`, save the results in `2`
    variables, and print them. These variables are `acc_train_6` and `acc_test_6`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`k=5`和`p=1`调用`fit_knn()`函数，将结果保存在`2`个变量中，并打印它们。这些变量是`acc_train_6`和`acc_test_6`：
- en: '[PRE49]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The expected output is this:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出是这样的：
- en: '[PRE50]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Changing to the Manhattan distance has helped increase the accuracy of the training
    set, but the model is still overfitting.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更改为曼哈顿距离有助于提高训练集的准确性，但模型仍然存在过拟合。
- en: 'Call the `fit_knn()` function with `k=10` and `p=1`, save the results in `2`
    variables, and print them. These variables are `acc_train_7` and `acc_test_7`:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`k=10`和`p=1`调用`fit_knn()`函数，将结果保存在`2`个变量中，并打印它们。这些变量是`acc_train_7`和`acc_test_7`：
- en: '[PRE51]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The expected output is this:'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出是这样的：
- en: '[PRE52]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'With `k=10`, the accuracy score for the training and testing sets are quite
    close to each other: around `0.78`.'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`k=10`时，训练集和测试集的准确性相差无几：大约为`0.78`。
- en: 'Call the `fit_knn()` function with `k=15` and `p=1`, save the results in `2`
    variables, and print them. These variables are `acc_train_8` and `acc_test_8`:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`k=15`和`p=1`调用`fit_knn()`函数，将结果保存在`2`个变量中，并打印它们。这些变量是`acc_train_8`和`acc_test_8`：
- en: '[PRE53]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The expected output is this:'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出是这样的：
- en: '[PRE54]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Bumping `k` to `15`, the model achieved a better accuracy score and is not overfitting
    very much.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将`k`增加到`15`时，模型的准确性有所提高，且过拟合情况不再那么严重。
- en: 'Call the `fit_knn()` function with `k=25` and `p=1`, save the results in `2`
    variables, and print them. These variables are `acc_train_9` and `acc_test_9`:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`k=25`和`p=1`调用`fit_knn()`函数，将结果保存在`2`个变量中，并打印它们。这些变量是`acc_train_9`和`acc_test_9`：
- en: '[PRE55]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The expected output is this:'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出是这样的：
- en: '[PRE56]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: With `k=25`, the difference between the training and testing sets' accuracy
    is increasing, so the model is overfitting.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`k=25`时，训练集和测试集准确性之间的差异在增加，因此模型存在过拟合。
- en: 'Call the `fit_knn()` function with `k=50` and `p=1`, save the results in `2`
    variables, and print them. These variables are `acc_train_10` and `acc_test_10`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`k=50`和`p=1`调用`fit_knn()`函数，将结果保存在`2`个变量中，并打印它们。这些变量是`acc_train_10`和`acc_test_10`：
- en: '[PRE57]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The expected output is this:'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出是这样的：
- en: '[PRE58]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: With `k=50`, the model's performance on the training set dropped significantly
    and the model is definitely overfitting.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`k=50`时，模型在训练集上的表现显著下降，且模型显然出现了过拟合。
- en: In this activity, we tried multiple combinations of hyperparameters for `n_neighbors`
    and `p`. The best one we found was for `n_neighbors=10` and `p=2`. With these
    hyperparameters, the model is not overfitting much and it achieved an accuracy
    score of around `78%` for both the training and testing sets.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，我们尝试了多个`n_neighbors`和`p`的超参数组合。我们发现的最佳组合是`n_neighbors=10`和`p=2`。使用这些超参数，模型几乎没有过拟合，并且在训练集和测试集上都达到了大约`78%`的准确性。
- en: Note
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2V5TOtG](https://packt.live/2V5TOtG).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 若要访问此特定部分的源代码，请参考[https://packt.live/2V5TOtG](https://packt.live/2V5TOtG)。
- en: You can also run this example online at [https://packt.live/2Bx0yd8](https://packt.live/2Bx0yd8).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在网上运行这个例子，链接：[https://packt.live/2Bx0yd8](https://packt.live/2Bx0yd8)。
- en: You must execute the entire Notebook in order to get the desired result.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须执行整个Notebook才能获得期望的结果。
- en: 'Activity 3.02: Support Vector Machine Optimization in scikit-learn'
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动3.02：在scikit-learn中进行支持向量机优化
- en: '**Solution**:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: Open a new Jupyter Notebook file and execute all the steps mentioned in the
    previous, *Exercise 3.04*, *K-Nearest Neighbor Classification in scikit-learn*.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Jupyter Notebook文件并执行之前提到的所有步骤，*练习3.04*，*scikit-learn中的K最近邻分类*。
- en: 'Import `svm` from `sklearn`:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`sklearn`导入`svm`：
- en: '[PRE59]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create a function called `fit_knn` that takes the following parameters: `features_train`,
    `label_train`, `features_test`, `label_test`, `kernel="linear"`, `C=1`, `degree=3`,
    and `gamma=''scale''`. This function will fit an SVC with the training set and
    print the accuracy score for both the training and testing sets:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`fit_knn`的函数，接受以下参数：`features_train`、`label_train`、`features_test`、`label_test`、`kernel="linear"`、`C=1`、`degree=3`和`gamma='scale'`。该函数将使用训练集拟合SVC，并打印训练集和测试集的准确度得分：
- en: '[PRE60]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Call the `fit_knn()` function with the default hyperparameter values, save
    the results in `2` variables, and print them. These variables are `acc_train_1`
    and `acc_test_1`:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`fit_knn()`函数，使用默认的超参数值，将结果保存在`2`个变量中并打印。这些变量是`acc_train_1`和`acc_test_1`：
- en: '[PRE61]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The expected output is this:'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 期望的输出是这样的：
- en: '[PRE62]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: With the default hyperparameter values (linear model), the performance of the
    model is quite different between the training and the testing set.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用默认的超参数值（线性模型），模型在训练集和测试集上的表现差异较大。
- en: 'Call the `fit_knn()` function with `kernel="poly"`, `C=1`, `degree=4`, and
    `gamma=0.05`, save the results in `2` variables, and print them. These variables
    are `acc_train_2` and `acc_test_2`:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`fit_knn()`函数，设置`kernel="poly"`、`C=1`、`degree=4`和`gamma=0.05`，将结果保存在`2`个变量中并打印。这些变量是`acc_train_2`和`acc_test_2`：
- en: '[PRE63]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The expected output is this:'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 期望的输出是这样的：
- en: '[PRE64]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: With a fourth-degree polynomial, the model is not performing well on the training
    set.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用四次多项式时，模型在训练集上的表现不佳。
- en: 'Call the `fit_knn()` function with `kernel="poly"`, `C=2`, `degree=4`, and
    `gamma=0.05`, save the results in `2` variables, and print them. These variables
    are `acc_train_3` and `acc_test_3`:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`fit_knn()`函数，设置`kernel="poly"`、`C=2`、`degree=4`和`gamma=0.05`，将结果保存在`2`个变量中并打印。这些变量是`acc_train_3`和`acc_test_3`：
- en: '[PRE65]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The expected output is this:'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 期望的输出是这样的：
- en: '[PRE66]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Increasing the regularization parameter, `C`, didn't impact the model's performance
    at all.
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 增加正则化参数`C`对模型的表现没有任何影响。
- en: 'Call the `fit_knn()` function with `kernel="poly"`, `C=1`, `degree=4`, and
    `gamma=0.25`, save the results in `2` variables, and print them. These variables
    are `acc_train_4` and `acc_test_4`:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`fit_knn()`函数，设置`kernel="poly"`、`C=1`、`degree=4`和`gamma=0.25`，将结果保存在`2`个变量中并打印。这些变量是`acc_train_4`和`acc_test_4`：
- en: '[PRE67]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The expected output is this:'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 期望的输出是这样的：
- en: '[PRE68]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Increasing the value of gamma to `0.25` has significantly improved the model's
    performance on the training set. However, the accuracy on the testing set is much
    lower, so the model is overfitting.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将gamma值增加到`0.25`显著提高了模型在训练集上的表现。然而，测试集的准确度较低，因此模型存在过拟合现象。
- en: 'Call the `fit_knn()` function with `kernel="poly"`, `C=1`, `degree=4`, and
    `gamma=0.5`, save the results in `2` variables, and print them. These variables
    are `acc_train_5` and `acc_test_5`:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`fit_knn()`函数，设置`kernel="poly"`、`C=1`、`degree=4`和`gamma=0.5`，将结果保存在`2`个变量中并打印。这些变量是`acc_train_5`和`acc_test_5`：
- en: '[PRE69]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The expected output is this:'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 期望的输出是这样的：
- en: '[PRE70]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Increasing the value of gamma to `0.5` has drastically improved the model's
    performance on the training set, but it is definitely overfitting as the accuracy
    score on the testing set is much lower.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将gamma值增加到`0.5`极大地改善了模型在训练集上的表现，但它明显出现了过拟合，因为测试集上的准确度得分明显降低。
- en: 'Call the `fit_knn()` function with `kernel="poly"`, `C=1`, `degree=4`, and
    `gamma=0.16`, save the results in `2` variables, and print them. These variables
    are `acc_train_6` and `acc_test_6`:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`fit_knn()`函数，设置`kernel="poly"`、`C=1`、`degree=4`和`gamma=0.16`，将结果保存在`2`个变量中并打印。这些变量是`acc_train_6`和`acc_test_6`：
- en: '[PRE71]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The expected output is this:'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 期望的输出是这样的：
- en: '[PRE72]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: With `gamma=0.16`, the model achieved a better accuracy score than it did for
    the best KNN model. Both the training and testing sets have a score of around `0.77`.
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`gamma=0.16`时，模型的准确度得分比最佳的KNN模型更高。训练集和测试集的得分都接近`0.77`。
- en: 'Call the `fit_knn()` function with `kernel="sigmoid"`, save the results in
    `2` variables, and print them. These variables are `acc_train_7` and `acc_test_7`:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`fit_knn()`函数，使用`kernel="sigmoid"`，将结果保存在`2`个变量中并打印出来。这些变量是`acc_train_7`和`acc_test_7`：
- en: '[PRE73]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The expected output is this:'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '[PRE74]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The sigmoid kernel achieved a low accuracy score.
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Sigmoid核的准确率得分较低。
- en: 'Call the `fit_knn()` function with `kernel="rbf"` and `gamma=0.15`, save the
    results in `2` variables, and print them. These variables are `acc_train_8` and
    `acc_test_8`:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`fit_knn()`函数，使用`kernel="rbf"`和`gamma=0.15`，将结果保存在`2`个变量中并打印出来。这些变量是`acc_train_8`和`acc_test_8`：
- en: '[PRE75]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The expected output is this:'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '[PRE76]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `rbf` kernel achieved a good score with `gamma=0.15`. The model is overfitting
    a bit, though.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`rbf`核在`gamma=0.15`时获得了较好的分数。尽管如此，模型仍然有些过拟合。'
- en: 'Call the `fit_knn()` function with `kernel="rbf"` and `gamma=0.25`, save the
    results in `2` variables, and print them. These variables are `acc_train_9` and
    `acc_test_9`:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`fit_knn()`函数，使用`kernel="rbf"`和`gamma=0.25`，将结果保存在`2`个变量中并打印出来。这些变量是`acc_train_9`和`acc_test_9`：
- en: '[PRE77]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The expected output is this:'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '[PRE78]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The model performance got better with `gamma=0.25`, but it is still overfitting.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模型性能在`gamma=0.25`时有所提升，但仍然存在过拟合。
- en: 'Call the `fit_knn()` function with `kernel="rbf"` and `gamma=0.35`, save the
    results in `2` variables, and print them. These variables are `acc_train_10` and
    `acc_test_10`:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`fit_knn()`函数，使用`kernel="rbf"`和`gamma=0.35`，将结果保存在`2`个变量中并打印出来。这些变量是`acc_train_10`和`acc_test_10`：
- en: '[PRE79]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The expected output is this:'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '[PRE80]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: With the `rbf` kernel and `gamma=0.35`, we got very similar results for the
    training and testing sets and the model's performance is higher than the best
    KNN we trained in the previous activity. This is our best model for the German
    credit dataset.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`rbf`核和`gamma=0.35`时，我们在训练集和测试集上获得了非常相似的结果，模型的性能高于我们在前一个活动中训练的最佳KNN模型。这是我们在德国信用数据集上的最佳模型。
- en: Note
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3fPZlMQ](https://packt.live/3fPZlMQ).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 若要访问此特定部分的源代码，请参考[https://packt.live/3fPZlMQ](https://packt.live/3fPZlMQ)。
- en: You can also run this example online at [https://packt.live/3hVlEm3](https://packt.live/3hVlEm3).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/3hVlEm3](https://packt.live/3hVlEm3)在线运行此示例。
- en: You must execute the entire Notebook in order to get the desired result.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 必须执行整个Notebook才能得到期望的结果。
- en: 'In this activity, we tried different values for the main hyperparameters of
    the SVM classifier: `kernel`, `gamma`, `C`, and `degrees`. We saw how they affected
    the model''s performance and their tendency to overfit. With trial and error,
    we finally found the best hyperparameter combination and achieved an accuracy
    score close to 0.78\. This process is called **hyperparameter tuning** and is
    an important step for any data science project.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本次活动中，我们尝试了SVM分类器的不同主超参数值：`kernel`、`gamma`、`C`和`degrees`。我们观察了这些超参数如何影响模型的表现以及它们过拟合的趋势。经过反复试验，我们最终找到了最佳的超参数组合，并获得了接近0.78的准确率。这个过程被称为**超参数调优**，是任何数据科学项目的重要步骤。
- en: 4\. An Introduction to Decision Trees
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. 决策树简介
- en: 'Activity 4.01: Car Data Classification'
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 4.01：汽车数据分类
- en: '**Solution**:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: Open a new Jupyter Notebook file.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Jupyter Notebook文件。
- en: 'Import the `pandas` package as `pd`:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`pandas`包并命名为`pd`：
- en: '[PRE81]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Create a new variable called `file_url` that will contain the URL to the raw dataset:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`file_url`的新变量，该变量将包含原始数据集的URL：
- en: '[PRE82]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Load the data using the `pd.read_csv()` method.:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pd.read_csv()`方法加载数据：
- en: '[PRE83]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Print the first five rows of `df`:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印`df`的前五行：
- en: '[PRE84]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The output will be as follows:'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![Figure 4.13: The first five rows of the dataset'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.13：数据集的前五行'
- en: '](img/B16060_04_13.jpg)'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_04_13.jpg)'
- en: 'Figure 4.13: The first five rows of the dataset'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.13：数据集的前五行
- en: 'Import the `preprocessing` module from `sklearn`:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`preprocessing`模块，来自`sklearn`：
- en: '[PRE85]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Create a function called `encode()` that takes a DataFrame and column name
    as parameters. This function will instantiate `LabelEncoder()`, fit it with the
    unique value of the column, and transform its data. It will return the transformed column:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`encode()`的函数，该函数接受一个DataFrame和列名作为参数。该函数将实例化`LabelEncoder()`，用列的唯一值进行拟合，并转化其数据。它将返回转换后的列：
- en: '[PRE86]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Create a `for` loop that will iterate through each column of `df` and will
    encode them with the `encode()` function:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`for`循环，该循环将遍历`df`的每一列，并使用`encode()`函数对它们进行编码：
- en: '[PRE87]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now, print the first five rows of `df`:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打印`df`的前五行：
- en: '[PRE88]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The output will be as follows:'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![Figure 4.14: The updated first five rows of the dataset'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.14：数据集的前五行已更新](img/B16060_04_17.jpg)'
- en: '](img/B16060_04_14.jpg)'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_04_14.jpg)'
- en: 'Figure 4.14: The updated first five rows of the dataset'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.14：数据集的前五行已更新
- en: 'Extract the class column using `.pop()` from pandas and save it in a variable
    called `label`:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`.pop()`从pandas中提取类别列，并将其保存到名为`label`的变量中：
- en: '[PRE89]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Import `model_selection` from `sklearn`:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`sklearn`导入`model_selection`：
- en: '[PRE90]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Split the dataset into training and testing sets with `test_size=0.1` and `random_state=88`:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`test_size=0.1`和`random_state=88`将数据集划分为训练集和测试集：
- en: '[PRE91]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Import `DecisionTreeClassifier` from `sklearn`:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`sklearn`导入`DecisionTreeClassifier`：
- en: '[PRE92]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Instantiate `DecisionTreeClassifier()` and save it in a variable called `decision_tree`:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化`DecisionTreeClassifier()`并将其保存到名为`decision_tree`的变量中：
- en: '[PRE93]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Fit the decision tree with the training set:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用训练集拟合决策树：
- en: '[PRE94]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The output will be as follows:'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![Figure 4.15: Decision tree fit with the training set'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.15：决策树在训练集上的拟合](img/B16060_04_14.jpg)'
- en: '](img/B16060_04_15.jpg)'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_04_15.jpg)'
- en: 'Figure 4.15: Decision tree fit with the training set'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.15：决策树在训练集上的拟合
- en: 'Print the score of the decision tree on the testing set:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印决策树在测试集上的得分：
- en: '[PRE95]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The output will be as follows:'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE96]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The decision tree is achieving an accuracy score of `0.95` for our first try.
    This is remarkable.
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 决策树在我们第一次尝试时的准确率为`0.95`，这非常值得注意。
- en: 'Import `classification_report` from `sklearn.metrics`:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`sklearn.metrics`导入`classification_report`：
- en: '[PRE97]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Print the classification report of the test labels and predictions:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印测试标签和预测的分类报告：
- en: '[PRE98]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The output will be as follows:'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![Figure 4.16: Output showing the expected classification report'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.16：展示预期的分类报告的输出](img/B16060_04_16.jpg)'
- en: '](img/B16060_04_16.jpg)'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_04_16.jpg)'
- en: 'Figure 4.16: Output showing the expected classification report'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16：展示预期的分类报告的输出
- en: From this classification report, we can see that our model is performing quite
    well for the precision scores for all four classes. Regarding the recall score,
    we can see that it didn't perform as well for the last class.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个分类报告中，我们可以看到模型在四个类别的精确度得分上表现得相当好。至于召回率，我们可以看到它在最后一个类别上的表现较差。
- en: Note
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3hQDLtr](https://packt.live/3hQDLtr).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 若要访问此部分的源代码，请参阅[https://packt.live/3hQDLtr](https://packt.live/3hQDLtr)。
- en: You can also run this example online at [https://packt.live/2NkEEML](https://packt.live/2NkEEML).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在线运行此示例，[https://packt.live/2NkEEML](https://packt.live/2NkEEML)。
- en: You must execute the entire Notebook in order to get the desired result.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须执行整个Notebook才能获得预期的结果。
- en: By completing this activity, you have prepared the car dataset and trained a
    decision tree model. You have learned how to get its accuracy score and a classification
    report so that you can analyze its precision and recall scores.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此活动后，你已准备好汽车数据集并训练了决策树模型。你已学会如何获取其准确率和分类报告，从而分析其精确度和召回率得分。
- en: 'Activity 4.02: Random Forest Classification for Your Car Rental Company'
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 4.02：为你的租车公司进行随机森林分类
- en: '**Solution**:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: Open a Jupyter Notebook.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个Jupyter Notebook。
- en: Reuse the code mentioned in *Steps 1 - 4* of *Activity 1*, *Car Data Classification*.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重用*活动 1*中*步骤 1 - 4*的代码，*汽车数据分类*。
- en: 'Import `RandomForestClassifier` from `sklearn.ensemble`:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`sklearn.ensemble`导入`RandomForestClassifier`：
- en: '[PRE99]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Instantiate a random forest classifier with `n_estimators=100`, `max_depth=6`,
    and `random_state=168`. Save it to a variable called `random_forest_classifier`:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个随机森林分类器，设置`n_estimators=100`，`max_depth=6`，并设置`random_state=168`。将其保存到一个名为`random_forest_classifier`的变量中：
- en: '[PRE100]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Fit the random forest classifier with the training set:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用训练集拟合随机森林分类器：
- en: '[PRE101]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The output will be as follows:'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![Figure 4.17: Logs of the RandomForest classifier with its hyperparameter
    values'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.17：展示随机森林分类器及其超参数值的日志](img/B16060_04_17.jpg)'
- en: '](img/B16060_04_17.jpg)'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_04_17.jpg)'
- en: 'Figure 4.17: Logs of the RandomForest classifier with its hyperparameter values'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.17：展示随机森林分类器及其超参数值的日志
- en: These are the logs of the `RandomForest` classifier with its hyperparameter values.
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些是`RandomForest`分类器及其超参数值的日志。
- en: 'Make predictions on the testing set using the random forest classifier and
    save them in a variable called `rf_preds_test`. Print its content:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用随机森林分类器对测试集进行预测，并将其保存到名为`rf_preds_test`的变量中。打印其内容：
- en: '[PRE102]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The output will be as follows:'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![Figure 4.18: Output showing the predictions on the testing set'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.18：展示测试集上预测结果的输出](img/B16060_04_15.jpg)'
- en: '](img/B16060_04_18.jpg)'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_04_18.jpg)'
- en: 'Figure 4.18: Output showing the predictions on the testing set'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.18：显示测试集预测的输出
- en: 'Import `classification_report` from `sklearn.metrics`:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`sklearn.metrics`导入`classification_report`：
- en: '[PRE103]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Print the classification report with the labels and predictions from the test
    set:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印带有标签和测试集预测的分类报告：
- en: '[PRE104]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The output will be as follows:'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 4.19: Output showing the classification report with the labels and
    predictions from the test set'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.19：显示带有标签和测试集预测的分类报告的输出'
- en: '](img/B16060_04_19.jpg)'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_04_19.jpg)'
- en: 'Figure 4.19: Output showing the classification report with the labels and predictions
    from the test set'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.19：显示带有标签和测试集预测的分类报告的输出
- en: The F1 score in the preceding report shows us that the random forest is performing
    well on class `2` but not as good for classes `0` and `3`. The model is unable
    to predict accurately for class `1`, but there were only 9 observations in the
    testing set. The accuracy score is `0.84`, while the F1 score is `0.82`.
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前述报告中的F1得分告诉我们，随机森林在类`2`上的表现良好，但在类`0`和`3`上表现不佳。模型无法准确预测类`1`，但测试集中只有9个观测值。准确率为`0.84`，而F1得分为`0.82`。
- en: 'Import `confusion_matrix` from `sklearn.metrics`:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`sklearn.metrics`导入`confusion_matrix`：
- en: '[PRE105]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Display the confusion matrix on the true and predicted labels of the testing
    set:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示测试集的真实标签和预测标签的混淆矩阵：
- en: '[PRE106]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The output will be as follows:'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE107]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: From this confusion matrix, we can see that the `RandomForest` model is having
    difficulties accurately predicting the first class. It incorrectly predicted 16
    cases (8 + 5 + 3) for this class.
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从这个混淆矩阵中，我们可以看出，`RandomForest`模型在准确预测第一类时遇到困难。它错误地预测了16个案例（8 + 5 + 3）为这一类。
- en: 'Print the feature importance score of the test set using `.feature_importance_`
    and save the results in a variable called `rf_varimp`. Print its contents:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`.feature_importance_`打印测试集的特征重要性得分，并将结果保存在名为`rf_varimp`的变量中。打印其内容：
- en: '[PRE108]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The output will be as follows:'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE109]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The preceding output shows us that the most important features are the fourth
    and sixth ones, which correspond to `persons` and `safety`, respectively.
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前述输出显示最重要的特征是第四个和第六个，分别对应`persons`和`safety`。
- en: 'Import `ExtraTreesClassifier` from `sklearn.ensemble`:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`sklearn.ensemble`导入`ExtraTreesClassifier`：
- en: '[PRE110]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Instantiate `ExtraTreestClassifier` with `n_estimators=100`, `max_depth=6`,
    and `random_state=168`. Save it to a variable called `random_forest_classifier`:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化`ExtraTreesClassifier`，设置`n_estimators=100`、`max_depth=6`、`random_state=168`，并将其保存在名为`random_forest_classifier`的变量中：
- en: '[PRE111]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Fit the `extratrees` classifier with the training set:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用训练集拟合`extratrees`分类器：
- en: '[PRE112]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The output will be as follows:'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 4.20: Output with the extratrees classifier with the training set'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.20：使用训练集的extratrees分类器的输出'
- en: '](img/B16060_04_20.jpg)'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_04_20.jpg)'
- en: 'Figure 4.20: Output with the extratrees classifier with the training set'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.20：使用训练集的extratrees分类器的输出
- en: These are the logs of the `extratrees` classifier with its hyperparameter values.
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些是`extratrees`分类器及其超参数值的日志。
- en: 'Make predictions on the testing set using the `extratrees` classifier and save
    them in a variable called `et_preds_test`. Print its content:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`extratrees`分类器对测试集进行预测，并将结果保存在名为`et_preds_test`的变量中。打印其内容：
- en: '[PRE113]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The output will be as follows:'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 4.21: Predictions on the testing set using extratrees'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.21：使用extratrees对测试集进行预测'
- en: '](img/B16060_04_21.jpg)'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_04_21.jpg)'
- en: 'Figure 4.21: Predictions on the testing set using extratrees'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.21：使用extratrees对测试集进行预测
- en: 'Print the classification report with the labels and predictions from the test
    set:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印带有标签和测试集预测的分类报告：
- en: '[PRE114]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The output will be as follows:'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 4.22: Classification report with the labels and predictions from the
    test set'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.22：带有标签和测试集预测的分类报告'
- en: '](img/B16060_04_22.jpg)'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_04_22.jpg)'
- en: 'Figure 4.22: Classification report with the labels and predictions from the
    test set'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.22：带有标签和测试集预测的分类报告
- en: The F1 score shown in the preceding report shows us that the random forest is
    performing well on class `2` but not as good for class `0`. The model is unable
    to predict accurately for classes `1` and `3`, but there were only `9` and `8`
    observations in the testing set, respectively. The accuracy score is `0.82`, while
    the F1 score is `0.78`. So, our `RandomForest` classifier performed better with
    `extratrees`.
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面报告中的F1得分显示，随机森林在类别`2`上的表现良好，但在类别`0`上的表现较差。模型无法准确预测类别`1`和`3`，但测试集中只有分别为`9`和`8`的观测值。准确率为`0.82`，F1得分为`0.78`。因此，我们的`RandomForest`分类器在`extratrees`上表现得更好。
- en: 'Display the confusion matrix of the true and predicted labels of the testing
    set:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示测试集的真实标签与预测标签的混淆矩阵：
- en: '[PRE115]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The output will be as follows:'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE116]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: From this confusion matrix, we can see that the `extratrees` model is having
    difficulties accurately predicting the first and third classes.
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从这个混淆矩阵中，我们可以看出，`extratrees`模型在准确预测第一和第三类别时遇到了困难。
- en: 'Print the feature importance score on the test set using `.feature_importance_`
    and save the results in a variable called `et_varimp`. Print its content:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`.feature_importance_`打印测试集上的特征重要性分数，并将结果保存在一个名为`et_varimp`的变量中。打印其内容：
- en: '[PRE117]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The output will be as follows:'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE118]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The preceding output shows us that the most important features are the sixth
    and fourth ones, which correspond to `safety` and `persons`, respectively. It
    is interesting to see that `RandomForest` has the same two most important features
    but in a different order.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出向我们展示了最重要的特征是第六个和第四个特征，分别对应`safety`和`persons`。有趣的是，`RandomForest`也有相同的两个最重要特征，但顺序不同。
- en: Note
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2YoUY5t](https://packt.live/2YoUY5t).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考[https://packt.live/2YoUY5t](https://packt.live/2YoUY5t)。
- en: You can also run this example online at [https://packt.live/3eswBcW](https://packt.live/3eswBcW).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/3eswBcW](https://packt.live/3eswBcW)上在线运行这个示例。
- en: You must execute the entire Notebook in order to get the desired result.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 必须执行整个Notebook才能获得所需的结果。
- en: '5\. Artificial Intelligence: Clustering'
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 人工智能：聚类
- en: 'Activity 5.01: Clustering Sales Data Using K-Means'
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 5.01：使用K-Means聚类销售数据
- en: '**Solution**:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: Open a new Jupyter Notebook file.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Jupyter Notebook文件。
- en: 'Load the dataset as a DataFrame and inspect the data:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据集加载为DataFrame并检查数据：
- en: '[PRE119]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The output of `df` is as follows:'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`df`的输出如下所示：'
- en: '![Figure 5.18: Output showing the contents of the dataset'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.18：显示数据集内容的输出](img/B16060_05_18.jpg)'
- en: '](img/B16060_05_18.jpg)'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_05_18.jpg)'
- en: 'Figure 5.18: Output showing the contents of the dataset'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.18：显示数据集内容的输出
- en: If you look at the output, you will notice that our dataset contains `811` rows,
    with each row representing a product. It also contains `107` columns, with the
    first column being the product code, then `52` columns starting with `W` representing
    the sale quantity for each week, and finally, the normalized version of the `52`
    columns, starting with the `Normalized` columns. The normalized columns will be
    a better choice to work with rather than the absolute sales columns, `W`, as they
    will help our k-means algorithms to find the center of each cluster faster. Since
    we are going to work on the normalized columns, we can remove every `W` column
    plus the `Product_Code` column. We can also remove the `MIN` and `MAX` columns
    as they do not bring any value to our clustering. Also notice that the weeks run
    from `0` to `51` and not `1` to `52`.
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你查看输出，你会注意到我们的数据集包含`811`行，每一行代表一个产品。它还包含`107`列，第一列是产品代码，然后是`52`列以`W`开头，表示每周的销售数量，最后是`52`列的归一化版本，以`Normalized`开头。归一化列比绝对销售列`W`更适合用于k-means算法，它将帮助我们的算法更快地找到每个聚类的中心。由于我们将处理归一化列，因此可以删除每个`W`列和`Product_Code`列。我们还可以删除`MIN`和`MAX`列，因为它们对我们的聚类没有任何帮助。还要注意，周数从`0`到`51`而不是从`1`到`52`。
- en: 'Next, create a new DataFrame without the unnecessary columns, as shown in the
    following code snippet (the first `55` columns of the dataset). You should use
    the `inplace` parameter to help you:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个没有不必要列的新DataFrame，如以下代码片段所示（数据集的前`55`列）。你应该使用`inplace`参数来帮助你：
- en: '[PRE120]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The output of `df2` is as follows:'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`df2`的输出如下所示：'
- en: '![Figure 5.19: Modified DataFrame'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.19：修改后的DataFrame](img/B16060_05_19.jpg)'
- en: '](img/B16060_05_19.jpg)'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_05_19.jpg)'
- en: '[PRE121]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Create a k-means clustering model with `8` clusters and with `random state
    = 8`:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有`8`个聚类和`random state = 8`的k-means聚类模型：
- en: '[PRE122]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: We build a k-means model with the default value for every parameter except for
    `n_clusters=8` with `random_state=8` in order to obtain `8` clusters and reproducible
    results.
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们构建了一个k-means模型，除了`n_clusters=8`和`random_state=8`之外，其他参数都使用默认值，以获得`8`个聚类并实现可重复的结果。
- en: 'Retrieve the labels from the clustering algorithm:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从聚类算法中提取标签：
- en: '[PRE123]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The output of `labels` will be as follows:'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`labels`的输出将如下所示：'
- en: '![Figure 5.20: Output array of labels'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图5.20：标签输出数组'
- en: '](img/B16060_05_20.jpg)'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_05_20.jpg)'
- en: 'Figure 5.20: Output array of labels'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.20：标签输出数组
- en: It is very hard to make sense out of this output, but each index of `labels`
    represents the cluster that the product has been assigned, based on similar weekly
    sales trends. We can now use these cluster labels to group products together.
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从这个输出中很难看出任何意义，但`labels`的每个索引代表基于相似的周销售趋势，产品被分配到的聚类。现在，我们可以使用这些聚类标签将产品聚集在一起。
- en: 'Now, from the first DataFrame, `df`, keep only the `W` columns and add the
    labels as a new column, as shown in the following code snippet:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从第一个DataFrame `df`中，仅保留`W`列，并将标签作为新列添加，如以下代码片段所示：
- en: '[PRE124]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: In the preceding code snippet, we removed all the unneeded columns and added
    `labels` as a new column in the DataFrame.
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们删除了所有不需要的列，并将`labels`作为新列添加到了DataFrame中。
- en: 'The output of `df` will be as follows:'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`df`的输出将如下所示：'
- en: '![Figure 5.21: Updated DataFrame with the new labels as a new column'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图5.21：包含新标签作为新列的更新DataFrame'
- en: '](img/B16060_05_21.jpg)'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_05_21.jpg)'
- en: 'Figure 5.21: Updated DataFrame with the new labels as a new column'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.21：包含新标签作为新列的更新DataFrame
- en: Now that we have the label, we can perform aggregation on the `label` column
    in order to calculate the yearly average sales of each cluster.
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经有了标签，可以对`label`列进行聚合，计算每个聚类的年销售平均值。
- en: 'Perform the aggregation (use the `groupby` function from pandas) in order to
    obtain the yearly average sale of each cluster, as shown in the following code snippet:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行聚合（使用pandas中的`groupby`函数），以便获得每个聚类的年销售平均值，如以下代码片段所示：
- en: '[PRE125]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: In the preceding code snippet, we first used the `groupby` function with the
    `sum()` method of the DataFrame to calculate the sum of every product's sales
    for each `W` column and cluster, and stored the results in `df_agg`. We then used
    the `groupby` function with the `count()` method on a single column (an arbitrary
    choice) of `df` to obtain the total number of products per cluster (note that
    we also had to rename the `W0` column after the aggregation). The next step was
    to sum all the sales columns of `df_agg` in order to obtain the total sales for
    each cluster. Finally, we calculated the `yearly_average_sales` for each cluster
    by dividing `total_sales` by `count_product`. We also included a final step to
    sort out the cluster by the highest `yearly_average_sales`.
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们首先使用`groupby`函数和DataFrame的`sum()`方法，计算每个`W`列和聚类的每个产品的销售总和，并将结果存储在`df_agg`中。然后，我们在`df`的单个列（任意选择）上使用`groupby`函数和`count()`方法，计算每个聚类的产品总数（注意我们还必须在聚合后重命名`W0`列）。接下来的步骤是对`df_agg`中的所有销售列求和，以获得每个聚类的总销售额。最后，我们通过将`total_sales`除以`count_product`计算每个聚类的`yearly_average_sales`。我们还加入了最后一步，通过`yearly_average_sales`对聚类进行排序。
- en: 'The output of `df_final` will be as follows:'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`df_final`的输出将如下所示：'
- en: '![Figure 5.22: Expected output on the sales transaction dataset'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图5.22：销售交易数据集的预期输出'
- en: '](img/B16060_05_22.jpg)'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_05_22.jpg)'
- en: 'Figure 5.22: Expected output on the sales transaction dataset'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.22：销售交易数据集的预期输出
- en: Now, with this output, we see that our k-means model has managed to put similarly
    performing products together. We can easily see that the `115` products in cluster
    `3` are the best-selling products, whereas the `123` products of cluster `1` are
    performing very badly. This is very valuable for any business, as it helps them
    automatically identify and group together a number of similarly performing products
    without having any bias in the product name or description.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过这个输出，我们可以看到我们的k-means模型成功地将表现相似的产品聚集在一起。我们可以清楚地看到，`3`号聚类中的`115`个产品是最畅销的产品，而`1`号聚类中的`123`个产品表现非常差。这对于任何企业都是非常有价值的，因为它帮助企业自动识别并将表现相似的产品聚集在一起，而不受产品名称或描述的偏见影响。
- en: Note
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 注：
- en: To access the source code for this specific section, please refer to [https://packt.live/3fVpSbT](https://packt.live/3fVpSbT).
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 若要访问此特定部分的源代码，请参阅[https://packt.live/3fVpSbT](https://packt.live/3fVpSbT)。
- en: You can also run this example online at [https://packt.live/3hW24Gk](https://packt.live/3hW24Gk).
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在网上运行此示例：[https://packt.live/3hW24Gk](https://packt.live/3hW24Gk)。
- en: You must execute the entire Notebook in order to get the desired result.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须执行整个 Notebook 才能获得期望的结果。
- en: By completing this activity, you have learned how to perform k-means clustering
    on multiple columns for many products. You have also learned how useful clustering
    can be for a business, even without label data.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个活动后，你已经学会了如何对多个列进行 k-means 聚类，适用于多个产品。你还学会了聚类在没有标签数据的情况下对企业有多么有用。
- en: 'Activity 5.02: Clustering Red Wine Data Using the Mean Shift Algorithm and
    Agglomerative Hierarchical Clustering'
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '活动 5.02: 使用均值迁移算法和凝聚层次聚类对红酒数据进行聚类'
- en: '**Solution**:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: Open a new Jupyter Notebook file.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Jupyter Notebook 文件。
- en: 'Load the dataset as a DataFrame with `sep = ";"` and inspect the data:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sep = ";"`加载数据集为DataFrame，并检查数据：
- en: '[PRE126]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The output of `df` is as follows:'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`df`的输出如下：'
- en: '![Figure 5.23: df showing the dataset as the output'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.23: df 显示数据集作为输出'
- en: '](img/B16060_05_23.jpg)'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_05_23.jpg)'
- en: 'Figure 5.23: df showing the dataset as the output'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '图 5.23: df 显示数据集作为输出'
- en: Note
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The output from the preceding screenshot is truncated.
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面截图中的输出被截断了。
- en: Our dataset contains `1599` rows, with each row representing a red wine. It
    also contains `12` columns, with the last column being the quality of the wine.
    We can see that the remaining 11 columns will be our features, and we need to
    scale them in order to help the accuracy and speed of our models.
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的数据集包含`1599`行，每一行代表一瓶红酒。它还包含`12`列，最后一列是葡萄酒的质量。我们可以看到其余的 11 列将是我们的特征，我们需要对它们进行缩放，以帮助提高我们模型的准确性和速度。
- en: 'Create `features`, `label`, and `scaled_features` variables from the initial
    DataFrame, `df`:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从初始的 DataFrame `df` 创建 `features`、`label` 和 `scaled_features` 变量：
- en: '[PRE127]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: In the preceding code snippet, we separated the label (`quality`) from the features.
    Then we used `preprocessing.scale` function from `sklearn` in order to scale our
    features, as this will improve our models.
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将标签（`quality`）与特征分开。然后，我们使用来自`sklearn`的`preprocessing.scale`函数对特征进行缩放，因为这将提高我们的模型性能。
- en: 'Next, create a mean shift clustering model, then retrieve the model''s predicted
    labels and the number of clusters created:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个均值迁移聚类模型，然后获取该模型预测的标签和创建的聚类数量：
- en: '[PRE128]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The output of `n_cluster_mean_shift` will be as follows:'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`n_cluster_mean_shift`的输出如下：'
- en: '[PRE129]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Our mean shift model has created `10` clusters, which is already more than the
    number of groups that we have in our `quality` label. This will probably affect
    our extrinsic scores and might be an early indicator that wines sharing similar
    physicochemical properties don't belong in the same quality group.
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的均值迁移模型已经创建了`10`个聚类，这已经超过了我们在`quality`标签中所拥有的组数。这可能会影响我们的外部评分，并可能是一个早期的指标，表明具有相似物理化学性质的葡萄酒不应该属于同一质量组。
- en: 'The output of `label_mean_shift` will be as follows:'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`label_mean_shift`的输出如下：'
- en: '![Figure 5.24: Output array of label_mean_shift'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.24: label_mean_shift 的输出数组'
- en: '](img/B16060_05_24.jpg)'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_05_24.jpg)'
- en: 'Figure 5.24: Output array of label_mean_shift'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '图 5.24: label_mean_shift 的输出数组'
- en: This is a very interesting output because it clearly shows that most wines in
    our dataset are very similar; there are a lot more wines in cluster `0` than in
    the other clusters.
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个非常有趣的输出，因为它清楚地显示出我们数据集中大多数葡萄酒非常相似；聚类`0`中的葡萄酒数量远多于其他聚类。
- en: 'Now create an agglomerative hierarchical clustering model after creating a
    dendrogram and selecting the optimal number of clusters for it:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在创建树状图并为其选择最佳聚类数量后，创建一个凝聚层次聚类模型：
- en: '[PRE130]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The output of `dendrogram` will be as follows:'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`dendrogram`的输出如下：'
- en: '![Figure 5.25: Output showing the dendrogram for the clusters'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.25: 显示聚类树状图的输出'
- en: '](img/B16060_05_25.jpg)'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_05_25.jpg)'
- en: 'Figure 5.25: Output showing the dendrogram for the clusters'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '图 5.25: 显示聚类树状图的输出'
- en: From this output, we can see that seven clusters seems to be the optimal number
    for our model. We get this number by searching for the highest difference on the
    *y* axis between the lowest branch and the highest branch. In our case, for seven
    clusters, the lowest branch has a value of `29` and the highest branch has a value
    of `41`.
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从这个输出中，我们可以看到七个聚类似乎是我们模型的最佳数量。我们通过在*y*轴上寻找最低分支和最高分支之间的最大差异来得到这个数字。在我们的案例中，对于七个聚类，最低分支的值为`29`，而最高分支的值为`41`。
- en: 'The output of `label_agglomerative` will be as follows:'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`label_agglomerative`的输出如下：'
- en: '![Figure 5.26: Array showing label_agglomerative'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.26: 显示label_agglomerative的数组'
- en: '](img/B16060_05_26.jpg)'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_05_26.jpg)'
- en: 'Figure 5.26: Array showing label_agglomerative'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '图 5.26: 显示label_agglomerative的数组'
- en: We can see that we have a predominant cluster, `1`, but not as much as was the
    case in the mean shift model.
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到我们有一个主要的聚类，`1`，但不像均值漂移模型中那样显著。
- en: 'Now, compute the following extrinsic approach scores for both models:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，计算以下两种模型的外部方法得分：
- en: 'a. Begin with the adjusted Rand index:'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 从调整后的Rand指数开始：
- en: '[PRE131]'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The output of `ARI_mean` will be as follows:'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ARI_mean`的输出将如下所示：'
- en: '[PRE132]'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Next, enter `ARI_agg` to get the expected values:'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，输入`ARI_agg`以获取预期值：
- en: '[PRE133]'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The output of `ARI_agg` will be as follows:'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ARI_agg`的输出将如下所示：'
- en: '[PRE134]'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Our agglomerative model has a much higher `adjusted_rand_score` than the mean
    shift model, but both scores are very close to `0`, which means that neither model
    is performing very well with regard to the true labels.
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的聚合模型的`adjusted_rand_score`比均值漂移模型高得多，但两个得分都非常接近`0`，这意味着两个模型在真实标签的表现上都不太理想。
- en: 'b. Next, calculate the adjusted mutual information:'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 接下来，计算调整后的互信息：
- en: '[PRE135]'
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The output of `AMI_mean` will be as follows:'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`AMI_mean`的输出将如下所示：'
- en: '[PRE136]'
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Next, enter `AMI_agg` to get the expected values:'
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，输入`AMI_agg`以获取预期值：
- en: '[PRE137]'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The output of `AMI_agg` will be as follows:'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`AMI_agg`的输出将如下所示：'
- en: '[PRE138]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Our agglomerative model has a much higher `adjusted_mutual_info_score` than
    the mean shift model, but both scores are very close to `V_mean` will be as follows:'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的聚合模型的`adjusted_mutual_info_score`比均值漂移模型高得多，但两个得分都非常接近，`V_mean`将如下所示：
- en: '[PRE139]'
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Next, enter `V_agg` to get the expected values:'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，输入`V_agg`以获取预期值：
- en: '[PRE140]'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The output of `V_agg` will be as follows:'
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`V_agg`的输出将如下所示：'
- en: '[PRE141]'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Our agglomerative model has a higher V-Measure than the mean shift model, but
    both scores are very close to `FM_mean` will be as follows:'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的聚合模型的V-Measure比均值漂移模型高，但两个得分都非常接近，`FM_mean`将如下所示：
- en: '[PRE142]'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Next, enter `FM_agg` to get the expected values:'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，输入`FM_agg`以获取预期值：
- en: '[PRE143]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'The output of `FM_agg` will be as follows:'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`FM_agg`的输出将如下所示：'
- en: '[PRE144]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: This time, our mean shift model has a higher Fowlkes-Mallows score than the
    agglomerative model, but both scores are still on the lower range of the score,
    which means that neither model is performing very well with regard to the true labels.
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这一次，我们的均值漂移模型的Fowlkes-Mallows得分高于聚合模型，但两个模型的得分仍然处于得分范围的较低位置，这意味着两个模型在真实标签的表现上都不太理想。
- en: In conclusion, with the extrinsic approach evaluation, neither of our models
    were able to find clusters containing wines of a similar quality based on their
    physicochemical properties. We will confirm this by using the intrinsic approach
    evaluation to ensure that our models' clusters are well defined and are properly
    grouping similar wines together.
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总结而言，通过外部方法评估，我们的两个模型都未能根据葡萄酒的物理化学特性找到包含相似质量的聚类。我们将通过使用内部方法评估来确认这一点，以确保我们的模型聚类已被良好定义，并且能正确地将相似的葡萄酒分组在一起。
- en: 'Now, compute the following intrinsic approach scores for both models:'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，计算以下两种模型的内部方法得分：
- en: 'a. Begin with the Silhouette Coefficient:'
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 从轮廓系数开始：
- en: '[PRE145]'
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'The output of `Sil_mean` will be as follows:'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Sil_mean`的输出将如下所示：'
- en: '[PRE146]'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Next, enter `Sil_agg` to get the expected values:'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，输入`Sil_agg`以获取预期值：
- en: '[PRE147]'
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'The output of `Sil_agg` will be as follows:'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Sil_agg`的输出将如下所示：'
- en: '[PRE148]'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Our mean shift model has a higher Silhouette Coefficient than the agglomerative
    model, but both scores are very close to `CH_mean` will be as follows:'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的均值漂移模型的轮廓系数（Silhouette Coefficient）高于聚合模型，但两个得分都非常接近，`CH_mean`将如下所示：
- en: '[PRE149]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Next, enter `CH_agg` to get the expected values:'
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，输入`CH_agg`以获取预期值：
- en: '[PRE150]'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'The output of `CH_agg` will be as follows:'
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CH_agg`的输出将如下所示：'
- en: '[PRE151]'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Our agglomerative model has a much higher Calinski-Harabasz index than the mean
    shift model, which means that the agglomerative model has much more dense and
    well-defined clusters than the mean shift model.
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的聚合模型的Calinski-Harabasz指数比均值漂移模型高得多，这意味着聚合模型的聚类更加密集且界限更加明确。
- en: 'c. Finally, find the Davies-Bouldin index:'
  id: totrans-563
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 最后，计算Davies-Bouldin指数：
- en: '[PRE152]'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The output of `DB_mean` will be as follows:'
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DB_mean`的输出将如下所示：'
- en: '[PRE153]'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Next, enter `DB_agg` to get the expected values:'
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，输入`DB_agg`以获取预期值：
- en: '[PRE154]'
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'The output of `DB_agg` will be as follows:'
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DB_agg`的输出将如下所示：'
- en: '[PRE155]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Our agglomerative model has a higher David-Bouldin index than the mean shift
    model, but both scores are close to **0**, which means that both models are performing
    well with regard to the definition of their clusters.
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的凝聚模型的David-Bouldin指数高于均值迁移模型，但两者的分数都接近**0**，这意味着两者在定义其聚类方面表现良好。
- en: Note
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：
- en: To access the source code for this specific section, please refer to [https://packt.live/2YXMl0U](https://packt.live/2YXMl0U).
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 若要访问此特定部分的源代码，请参考[https://packt.live/2YXMl0U](https://packt.live/2YXMl0U)。
- en: You can also run this example online at [https://packt.live/2Bs7sAp](https://packt.live/2Bs7sAp).
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以在线运行这个示例，链接：[https://packt.live/2Bs7sAp](https://packt.live/2Bs7sAp)。
- en: You must execute the entire Notebook in order to get the desired result.
  id: totrans-575
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你必须执行整个Notebook才能得到期望的结果。
- en: In conclusion, with the intrinsic approach evaluation, both our models were
    well defined and confirm our intuition on the red wine dataset, that is, similar
    physicochemical properties are not associated with similar quality. We were also
    able to see that in most of our scores, the agglomerative hierarchical model performs
    better than the mean shift model.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，通过内在方法评估，我们的两个模型都得到了很好的定义，并且验证了我们对红酒数据集的直觉，即相似的物理化学属性与相似的质量无关。我们还看到，在大多数评分中，凝聚层次模型的表现优于均值迁移模型。
- en: 6\. Neural Networks and Deep Learning
  id: totrans-577
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 神经网络与深度学习
- en: 'Activity 6.01: Finding the Best Accuracy Score for the Digits Dataset'
  id: totrans-578
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动6.01：为数字数据集找到最佳准确度评分
- en: '**Solution**:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: Open a new Jupyter Notebook file.
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Jupyter Notebook文件。
- en: 'Import `tensorflow.keras.datasets.mnist` as `mnist`:'
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`tensorflow.keras.datasets.mnist`为`mnist`：
- en: '[PRE156]'
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Load the `mnist` dataset using `mnist.load_data()` and save the results into
    `(features_train, label_train), (features_test, label_test)`:'
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`mnist.load_data()`加载`mnist`数据集，并将结果保存到`(features_train, label_train), (features_test,
    label_test)`：
- en: '[PRE157]'
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Print the content of `label_train`:'
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印`label_train`的内容：
- en: '[PRE158]'
  id: totrans-586
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'The expected output is this:'
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出是这样的：
- en: '[PRE159]'
  id: totrans-588
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'The `label` column contains numeric values that correspond to the `10` handwritten
    digits: `0` to `9`.'
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`label`列包含与`0`到`9`这`10`个手写数字对应的数值：'
- en: 'Print the shape of the training set:'
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印训练集的形状：
- en: '[PRE160]'
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'The expected output is this:'
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出是这样的：
- en: '[PRE161]'
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: The training set is composed of `60,000` observations of shape `28` by `28`.
    We will need to flatten the input for our neural network.
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 训练集由`60,000`个形状为`28` x `28`的观察值组成。我们需要将输入展平以适应神经网络。
- en: 'Print the shape of the testing set:'
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印测试集的形状：
- en: '[PRE162]'
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'The expected output is this:'
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出是这样的：
- en: '[PRE163]'
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: The testing set is composed of `10,000` observations of shape `28` by `28`.
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试集由`10,000`个形状为`28` x `28`的观察值组成。
- en: 'Standardize `features_train` and `features_test` by dividing them by `255`:'
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将`features_train`和`features_test`除以`255`来进行标准化：
- en: '[PRE164]'
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Import `numpy` as `np`, `tensorflow` as `tf`, and `layers` from `tensorflow.keras`:'
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`numpy`为`np`，`tensorflow`为`tf`，以及从`tensorflow.keras`导入`layers`：
- en: '[PRE165]'
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Set `8` as the seed for NumPy and TensorFlow using `np.random_seed()` and `tf.random.set_seed()`:'
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`np.random_seed()`和`tf.random.set_seed()`分别设置NumPy和TensorFlow的种子为`8`：
- en: '[PRE166]'
  id: totrans-605
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Instantiate a `tf.keras.Sequential()` class and save it into a variable called
    `model`:'
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个`tf.keras.Sequential()`类并将其保存到一个名为`model`的变量中：
- en: '[PRE167]'
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Instantiate `layers.Flatten()` with `input_shape=(28,28)` and save it into
    a variable called `input_layer`:'
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化`layers.Flatten()`，并设置`input_shape=(28,28)`，然后将其保存到名为`input_layer`的变量中：
- en: '[PRE168]'
  id: totrans-609
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Instantiate a `layers.Dense()` class with `128` neurons and `activation=''relu''`,
    then save it into a variable called `layer1`:'
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个`layers.Dense()`类，设置`128`个神经元并使用`activation='relu'`，然后将其保存到名为`layer1`的变量中：
- en: '[PRE169]'
  id: totrans-611
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Instantiate a second `layers.Dense()` class with `1` neuron and `activation=''softmax''`,
    then save it into a variable called `final_layer`:'
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化第二个`layers.Dense()`类，设置`1`个神经元并使用`activation='softmax'`，然后将其保存到名为`final_layer`的变量中：
- en: '[PRE170]'
  id: totrans-613
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Add the three layers you just defined to the model using `.add()` and add a
    `layers.Dropout(0.25)` layer in between each of them (except for the flatten layer):'
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`.add()`将刚刚定义的三层添加到模型中，并在每一层之间（展平层除外）添加一个`layers.Dropout(0.25)`层：
- en: '[PRE171]'
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Instantiate a `tf.keras.optimizers.Adam()` class with `0.001` as learning rate
    and save it into a variable called `optimizer`:'
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个`tf.keras.optimizers.Adam()`类，学习率为`0.001`，并将其保存到名为`optimizer`的变量中：
- en: '[PRE172]'
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Compile the neural network using `.compile()` with `loss=''sparse_categorical_crossentropy'',
    optimizer=optimizer, metrics=[''accuracy'']`:'
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`.compile()`编译神经网络，参数为`loss='sparse_categorical_crossentropy', optimizer=optimizer,
    metrics=['accuracy']`：
- en: '[PRE173]'
  id: totrans-619
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Print a summary of the model using `.summary()`:'
  id: totrans-620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`.summary()`打印模型的概述：
- en: '[PRE174]'
  id: totrans-621
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'The expected output is this:'
  id: totrans-622
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出是这样的：
- en: '![Figure 6.29: Summary of the model'
  id: totrans-623
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.29：模型概述'
- en: '](img/B16060_06_29.jpg)'
  id: totrans-624
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_06_29.jpg)'
- en: 'Figure 6.29: Summary of the model'
  id: totrans-625
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.29：模型总结
- en: This output summarizes the architecture of our neural networks. We can see it
    is composed of four layers with one flatten layer, two dense layers, and one dropout
    layer.
  id: totrans-626
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该输出总结了我们神经网络的架构。我们可以看到它由四层组成，包括一层展平层，两层密集层和一层Dropout层。
- en: 'Instantiate the `tf.keras.callbacks.EarlyStopping()` class with `monitor=''val_loss''`
    and `patience=5` as the learning rate and save it into a variable called `callback`:'
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化`tf.keras.callbacks.EarlyStopping()`类，使用`monitor='val_loss'`和`patience=5`作为学习率，并将其保存为名为`callback`的变量：
- en: '[PRE175]'
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Fit the neural networks with the training set and specify `epochs=10`, `validation_split=0.2`,
    `callbacks=[callback]`, and `verbose=2`:'
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用训练集拟合神经网络，并指定`epochs=10`，`validation_split=0.2`，`callbacks=[callback]`和`verbose=2`：
- en: '[PRE176]'
  id: totrans-630
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'The expected output is this:'
  id: totrans-631
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 期望的输出是这样的：
- en: '![Figure 6.30: Fitting the neural network with the training set'
  id: totrans-632
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.30：使用训练集拟合神经网络'
- en: '](img/B16060_06_30.jpg)'
  id: totrans-633
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_06_30.jpg)'
- en: 'Figure 6.30: Fitting the neural network with the training set'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.30：使用训练集拟合神经网络
- en: We achieved an accuracy score of `0.9825` for the training set and `0.9779`
    for the validation set for recognizing hand-written digits after just `10` epochs.
    These are amazing results. In this section, you learned how to build and train
    a neural network from scratch using TensorFlow to classify digits.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 在仅经过`10`个epochs后，我们在训练集上的准确率为`0.9825`，在验证集上的准确率为`0.9779`，这些结果非常惊人。在本节中，您学习了如何使用TensorFlow从头开始构建并训练神经网络以进行数字分类。
- en: Note
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/37UWf7E](https://packt.live/37UWf7E).
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考 [https://packt.live/37UWf7E](https://packt.live/37UWf7E)。
- en: You can also run this example online at [https://packt.live/317R2b3](https://packt.live/317R2b3).
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在线运行此示例，网址是 [https://packt.live/317R2b3](https://packt.live/317R2b3)。
- en: You must execute the entire Notebook in order to get the desired result.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须执行整个Notebook才能得到预期的结果。
- en: 'Activity 6.02: Evaluating a Fashion Image Recognition Model Using CNNs'
  id: totrans-640
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 6.02：使用CNN评估Fashion图像识别模型
- en: '**Solution**:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: Open a new Jupyter Notebook.
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Jupyter Notebook。
- en: 'Import `tensorflow.keras.datasets.fashion_mnist` as `fashion_mnist`:'
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`tensorflow.keras.datasets.fashion_mnist`为`fashion_mnist`：
- en: '[PRE177]'
  id: totrans-644
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Load the Fashion MNIST dataset using `fashion_mnist.load_data()` and save the
    results into `(features_train, label_train), (features_test, label_test)`:'
  id: totrans-645
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`fashion_mnist.load_data()`加载Fashion MNIST数据集，并将结果保存到`(features_train, label_train),
    (features_test, label_test)`中：
- en: '[PRE178]'
  id: totrans-646
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Print the shape of the training set:'
  id: totrans-647
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印训练集的形状：
- en: '[PRE179]'
  id: totrans-648
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'The expected output is this:'
  id: totrans-649
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 期望的输出是这样的：
- en: '[PRE180]'
  id: totrans-650
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: The training set is composed of `60,000` images of size `28`*`28`.
  id: totrans-651
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 训练集由`60,000`张大小为`28`*`28`的图像组成。
- en: 'Print the shape of the testing set:'
  id: totrans-652
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印测试集的形状：
- en: '[PRE181]'
  id: totrans-653
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'The expected output is this:'
  id: totrans-654
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 期望的输出是这样的：
- en: '[PRE182]'
  id: totrans-655
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: The testing set is composed of `10,000` images of size `28`*`28`.
  id: totrans-656
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试集由`10,000`张大小为`28`*`28`的图像组成。
- en: 'Reshape the training and testing sets with the dimensions (`number_rows`, `28`,
    `28`, `1`), as shown in the following code snippet:'
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码片段的方式，重塑训练集和测试集的维度为(`number_rows`, `28`, `28`, `1`)：
- en: '[PRE183]'
  id: totrans-658
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Standardize `features_train` and `features_test` by dividing them by `255`:'
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将`features_train`和`features_test`除以`255`来标准化它们：
- en: '[PRE184]'
  id: totrans-660
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Import `numpy` as `np`, `tensorflow` as `tf`, and `layers` from `tensorflow.keras`:'
  id: totrans-661
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`numpy`为`np`，`tensorflow`为`tf`，并从`tensorflow.keras`导入`layers`：
- en: '[PRE185]'
  id: totrans-662
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Set `8` as the seed for `numpy` and `tensorflow` using `np.random_seed()` and
    `tf.random.set_seed()`:'
  id: totrans-663
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`np.random_seed()`和`tf.random.set_seed()`将`8`设置为`numpy`和`tensorflow`的种子：
- en: '[PRE186]'
  id: totrans-664
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Instantiate a `tf.keras.Sequential()` class and save it into a variable called
    `model`:'
  id: totrans-665
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个`tf.keras.Sequential()`类，并将其保存为名为`model`的变量：
- en: '[PRE187]'
  id: totrans-666
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'Instantiate `layers.Conv2D()` with `64` kernels of shape `(3,3), activation=''relu''
    and input_shape=(28,28)` and save it into a variable called `conv_layer1`:'
  id: totrans-667
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`64`个形状为`(3,3)`的卷积核和`activation='relu'`，以及`input_shape=(28,28)`，实例化`layers.Conv2D()`并将其保存为名为`conv_layer1`的变量：
- en: '[PRE188]'
  id: totrans-668
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Instantiate `layers.Conv2D()` with `64` kernels of shape `(3,3), activation=''relu''`
    and save it into a variable called `conv_layer2`:'
  id: totrans-669
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`64`个形状为`(3,3)`的卷积核和`activation='relu'`，实例化`layers.Conv2D()`并将其保存为名为`conv_layer2`的变量：
- en: '[PRE189]'
  id: totrans-670
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Instantiate `layers.Flatten()` with `128` neurons and `activation=''relu''`,
    then save it into a variable called `fc_layer1`:'
  id: totrans-671
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`128`个神经元和`activation='relu'`，实例化`layers.Flatten()`，然后将其保存为名为`fc_layer1`的变量：
- en: '[PRE190]'
  id: totrans-672
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Instantiate `layers.Flatten()` with `10` neurons and `activation=''softmax''`,
    then save it into a variable called `fc_layer2`:'
  id: totrans-673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`10`个神经元和`activation='softmax'`，实例化`layers.Flatten()`，然后将其保存为名为`fc_layer2`的变量：
- en: '[PRE191]'
  id: totrans-674
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Add the four layers you just defined to the model using `.add()` and add a
    `MaxPooling2D()` layer of size `(2,2)` in between each of the convolutional layers:'
  id: totrans-675
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `.add()` 方法将刚才定义的四个层添加到模型中，并在每个卷积层之间添加一个大小为 `(2,2)` 的 `MaxPooling2D()` 层：
- en: '[PRE192]'
  id: totrans-676
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'Instantiate a `tf.keras.optimizers.Adam()` class with `0.001` as the learning
    rate and save it into a variable called `optimizer`:'
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个 `tf.keras.optimizers.Adam()` 类，学习率为 `0.001`，并将其保存到名为 `optimizer` 的变量中：
- en: '[PRE193]'
  id: totrans-678
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'Compile the neural network using `.compile()` with `loss=''sparse_categorical_crossentropy'',
    optimizer=optimizer, metrics=[''accuracy'']`:'
  id: totrans-679
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `.compile()` 编译神经网络，设置 `loss='sparse_categorical_crossentropy'`，`optimizer=optimizer`，`metrics=['accuracy']`：
- en: '[PRE194]'
  id: totrans-680
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Print a summary of the model using `.summary()`:'
  id: totrans-681
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `.summary()` 打印模型概述：
- en: '[PRE195]'
  id: totrans-682
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'The expected output is this:'
  id: totrans-683
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出是这样的：
- en: '![Figure 6.31: Summary of the model'
  id: totrans-684
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.31：模型概述'
- en: '](img/B16060_06_31.jpg)'
  id: totrans-685
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_06_31.jpg)'
- en: 'Figure 6.31: Summary of the model'
  id: totrans-686
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.31：模型概述
- en: The summary shows us that there are more than `240,000` parameters to be optimized
    with this model.
  id: totrans-687
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 概述显示该模型需要优化超过 `240,000` 个参数。
- en: 'Fit the neural network with the training set and specify `epochs=5`, `validation_split=0.2`,
    and `verbose=2`:'
  id: totrans-688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用训练集拟合神经网络，并指定 `epochs=5`、`validation_split=0.2` 和 `verbose=2`：
- en: '[PRE196]'
  id: totrans-689
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'The expected output is this:'
  id: totrans-690
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出是这样的：
- en: '![Figure 6.32: Fitting the neural network with the training set'
  id: totrans-691
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.32：使用训练集拟合神经网络'
- en: '](img/B16060_06_32.jpg)'
  id: totrans-692
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_06_32.jpg)'
- en: 'Figure 6.32: Fitting the neural network with the training set'
  id: totrans-693
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.32：使用训练集拟合神经网络
- en: After training for `5` epochs, we achieved an accuracy score of `0.925` for
    the training set and `0.9042` for the validation set. Our model is overfitting
    a bit.
  id: totrans-694
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 经过 `5` 个训练周期后，我们在训练集上达到了 `0.925` 的准确率，在验证集上达到了 `0.9042` 的准确率。我们的模型有些过拟合。
- en: 'Evaluate the performance of the model on the testing set:'
  id: totrans-695
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估模型在测试集上的表现：
- en: '[PRE197]'
  id: totrans-696
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'The expected output is this:'
  id: totrans-697
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出是这样的：
- en: '[PRE198]'
  id: totrans-698
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: We achieved an accuracy score of `0.8976` on the testing set for predicting
    images of clothing from the Fashion MNIST dataset. You can try on your own to
    improve this score and reduce the overfitting.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在测试集上预测来自 Fashion MNIST 数据集的服装图像时，达到了 `0.8976` 的准确率。你可以尝试自己提高这个得分并减少过拟合。
- en: Note
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2Nzt6pn](https://packt.live/2Nzt6pn).
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问该特定部分的源代码，请参考 [https://packt.live/2Nzt6pn](https://packt.live/2Nzt6pn)。
- en: You can also run this example online at [https://packt.live/2NlM5nd](https://packt.live/2NlM5nd).
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在网上运行这个示例，访问 [https://packt.live/2NlM5nd](https://packt.live/2NlM5nd)。
- en: You must execute the entire Notebook in order to get the desired result.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 必须执行整个 Notebook 才能获得预期的结果。
- en: In this activity, we designed and trained a CNN architecture for recognizing
    images of clothing from the Fashion MNIST dataset.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 在本次活动中，我们设计并训练了一个用于识别来自 Fashion MNIST 数据集服装图像的 CNN 架构。
- en: 'Activity 6.03: Evaluating a Yahoo Stock Model with an RNN'
  id: totrans-705
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 6.03：使用 RNN 评估雅虎股票模型
- en: '**Solution**:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: Open a Jupyter Notebook.
  id: totrans-707
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个 Jupyter Notebook。
- en: 'Import `pandas` as `pd` and `numpy` as `np`:'
  id: totrans-708
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `pandas` 作为 `pd` 和 `numpy` 作为 `np`：
- en: '[PRE199]'
  id: totrans-709
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'Create a variable called `file_url` containing a link to the raw dataset:'
  id: totrans-710
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `file_url` 的变量，包含指向原始数据集的链接：
- en: '[PRE200]'
  id: totrans-711
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'Load the dataset using `pd.read_csv()` into a new variable called `df`:'
  id: totrans-712
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `pd.read_csv()` 加载数据集，并将其保存到名为 `df` 的新变量中：
- en: '[PRE201]'
  id: totrans-713
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'Extract the values of the second column using `.iloc` and `.values` and save
    the results in a variable called `stock_data`:'
  id: totrans-714
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `.iloc` 和 `.values` 提取第二列的值，并将结果保存到名为 `stock_data` 的变量中：
- en: '[PRE202]'
  id: totrans-715
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Import `MinMaxScaler` from `sklearn.preprocessing`:'
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `sklearn.preprocessing` 导入 `MinMaxScaler`：
- en: '[PRE203]'
  id: totrans-717
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Instantiate `MinMaxScaler()` and save it to a variable called `sc`:'
  id: totrans-718
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化 `MinMaxScaler()` 并将其保存到名为 `sc` 的变量中：
- en: '[PRE204]'
  id: totrans-719
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'Standardize the data with `.fit_transform()` and save the results in a variable
    called `stock_data_scaled`:'
  id: totrans-720
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `.fit_transform()` 标准化数据，并将结果保存到名为 `stock_data_scaled` 的变量中：
- en: '[PRE205]'
  id: totrans-721
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'Create two empty arrays called `X_data` and `y_data`:'
  id: totrans-722
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个空数组，命名为 `X_data` 和 `y_data`：
- en: '[PRE206]'
  id: totrans-723
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'Create a variable called `window` that will contain the value `30`:'
  id: totrans-724
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `window` 的变量，它将包含值 `30`：
- en: '[PRE207]'
  id: totrans-725
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'Create a `for` loop starting from the `window` value and iterate through the
    length of the dataset. For each iteration, append to `X_data` the previous rows
    of `stock_data_scaled` using `window` and append the current value of `stock_data_scaled`:'
  id: totrans-726
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从 `window` 值开始的 `for` 循环，遍历数据集的长度。在每次迭代中，使用 `window` 将 `stock_data_scaled`
    的前几行添加到 `X_data` 中，并将当前的 `stock_data_scaled` 值添加到其中：
- en: '[PRE208]'
  id: totrans-727
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '`y_data` will contain the opening stock price for each day and `X_data` will
    contain the last 30 days'' stock prices.'
  id: totrans-728
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`y_data` 将包含每天的开盘股票价格，`X_data` 将包含过去 30 天的股票价格。'
- en: 'Convert `X_data` and `y_data` into NumPy arrays:'
  id: totrans-729
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`X_data`和`y_data`转换为NumPy数组：
- en: '[PRE209]'
  id: totrans-730
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'Reshape `X_data` as (number of rows, number of columns, 1):'
  id: totrans-731
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`X_data`调整形状为（行数，列数，1）：
- en: '[PRE210]'
  id: totrans-732
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'Use the first `1,000` rows as the training data and save them into two variables
    called `features_train` and `label_train`:'
  id: totrans-733
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前`1,000`行作为训练数据，并将它们保存到两个变量中，分别叫做`features_train`和`label_train`：
- en: '[PRE211]'
  id: totrans-734
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'Use the rows after row `1,000` as the testing data and save them into two variables
    called `features_test` and `label_test`:'
  id: totrans-735
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用第`1,000`行之后的行作为测试数据，并将它们保存到两个变量中，分别叫做`features_test`和`label_test`：
- en: '[PRE212]'
  id: totrans-736
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'Import `numpy` as `np`, `tensorflow` as `tf`, and `layers` from `tensorflow.keras`:'
  id: totrans-737
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`numpy`为`np`，`tensorflow`为`tf`，并从`tensorflow.keras`导入`layers`：
- en: '[PRE213]'
  id: totrans-738
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'Set `8` as `seed` for NumPy and TensorFlow using `np.random_seed()` and `tf.random.set_seed()`:'
  id: totrans-739
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`8`为NumPy和TensorFlow的`seed`，使用`np.random_seed()`和`tf.random.set_seed()`：
- en: '[PRE214]'
  id: totrans-740
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'Instantiate a `tf.keras.Sequential()` class and save it into a variable called
    `model`:'
  id: totrans-741
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个`tf.keras.Sequential()`类，并将其保存到一个变量中，名为`model`：
- en: '[PRE215]'
  id: totrans-742
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'Instantiate `layers.LSTM()` with `50` units, `return_sequences=''True''`, and
    `input_shape=(X_train.shape[1], 1)`, then save it into a variable called `lstm_layer1`:'
  id: totrans-743
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化`layers.LSTM()`，使用`50`个单元，`return_sequences='True'`，并且`input_shape=(X_train.shape[1],
    1)`，然后将其保存到一个变量中，名为`lstm_layer1`：
- en: '[PRE216]'
  id: totrans-744
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'Instantiate `layers.LSTM()` with `50` units and `return_sequences=''True''`,
    then save it into a variable called `lstm_layer2`:'
  id: totrans-745
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化`layers.LSTM()`，使用`50`个单元和`return_sequences='True'`，然后将其保存到一个变量中，名为`lstm_layer2`：
- en: '[PRE217]'
  id: totrans-746
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'Instantiate `layers.LSTM()` with `50` units and `return_sequences=''True''`,
    then save it into a variable called `lstm_layer3`:'
  id: totrans-747
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化`layers.LSTM()`，使用`50`个单元和`return_sequences='True'`，然后将其保存到一个变量中，名为`lstm_layer3`：
- en: '[PRE218]'
  id: totrans-748
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'Instantiate `layers.LSTM()` with `50` units and save it into a variable called
    `lstm_layer4`:'
  id: totrans-749
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化`layers.LSTM()`，使用`50`个单元，并将其保存到一个变量中，名为`lstm_layer4`：
- en: '[PRE219]'
  id: totrans-750
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'Instantiate `layers.Dense()` with `1` neuron and save it into a variable called `fc_layer`:'
  id: totrans-751
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化`layers.Dense()`，使用`1`个神经元，并将其保存到一个变量中，名为`fc_layer`：
- en: '[PRE220]'
  id: totrans-752
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'Add the five layers you just defined to the model using `.add()` and add a
    `Dropout(0.2)` layer in between each of the LSTM layers:'
  id: totrans-753
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`.add()`方法将你刚才定义的五个层添加到模型中，并在每个LSTM层之间添加一个`Dropout(0.2)`层：
- en: '[PRE221]'
  id: totrans-754
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'Instantiate a `tf.keras.optimizers.Adam()` class with `0.001` as the learning
    rate and save it into a variable called `optimizer`:'
  id: totrans-755
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个`tf.keras.optimizers.Adam()`类，学习率为`0.001`，并将其保存到一个变量中，名为`optimizer`：
- en: '[PRE222]'
  id: totrans-756
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'Compile the neural network using `.compile()` with `loss=''mean_squared_error'',
    optimizer=optimizer, metrics=[mse]`:'
  id: totrans-757
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`.compile()`编译神经网络，参数为`loss='mean_squared_error', optimizer=optimizer, metrics=[mse]`：
- en: '[PRE223]'
  id: totrans-758
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'Print a summary of the model using `.summary()`:'
  id: totrans-759
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`.summary()`打印模型的摘要：
- en: '[PRE224]'
  id: totrans-760
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'The expected output is this:'
  id: totrans-761
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出是这样的：
- en: '![Figure 6.33: Summary of the model'
  id: totrans-762
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.33：模型摘要'
- en: '](img/B16060_06_33.jpg)'
  id: totrans-763
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_06_33.jpg)'
- en: 'Figure 6.33: Summary of the model'
  id: totrans-764
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.33：模型摘要
- en: The summary shows us that there are more than `71,051` parameters to be optimized
    with this model.
  id: totrans-765
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 汇总显示我们有超过`71,051`个参数需要优化。
- en: 'Fit the neural network with the training set and specify `epochs=10, validation_split=0.2,
    verbose=2`:'
  id: totrans-766
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用训练集拟合神经网络，并指定`epochs=10, validation_split=0.2, verbose=2`：
- en: '[PRE225]'
  id: totrans-767
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'The expected output is this:'
  id: totrans-768
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出是这样的：
- en: '![Figure 6.34: Fitting the neural network with the training set'
  id: totrans-769
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.34：使用训练集拟合神经网络'
- en: '](img/B16060_06_34.jpg)'
  id: totrans-770
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_06_34.jpg)'
- en: 'Figure 6.34: Fitting the neural network with the training set'
  id: totrans-771
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.34：使用训练集拟合神经网络
- en: After training for `10` epochs, we achieved a mean squared error score of `0.0025`
    for the training set and `0.0033` for the validation set. Our model is overfitting
    a little bit.
  id: totrans-772
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 经过`10`个训练周期后，我们在训练集上获得了`0.0025`的均方误差分数，在验证集上获得了`0.0033`，说明我们的模型有些过拟合。
- en: 'Finally, evaluate the performance of the model on the testing set:'
  id: totrans-773
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，评估模型在测试集上的表现：
- en: '[PRE226]'
  id: totrans-774
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'The expected output is this:'
  id: totrans-775
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出是这样的：
- en: '[PRE227]'
  id: totrans-776
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE227]'
- en: We achieved a mean squared error score of `0.0017` on the testing set, which
    means we can quite accurately predict the stock price of Yahoo using the last
    30 days' stock price data as features.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在测试集上获得了`0.0017`的均方误差分数，这意味着我们可以相当准确地使用过去30天的股价数据作为特征来预测雅虎的股价。
- en: Note
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3804U8P](https://packt.live/3804U8P).
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问该特定部分的源代码，请参考[https://packt.live/3804U8P](https://packt.live/3804U8P)。
- en: You can also run this example online at [https://packt.live/3hWtU5l](https://packt.live/3hWtU5l).
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在线运行此示例，访问[https://packt.live/3hWtU5l](https://packt.live/3hWtU5l)。
- en: You must execute the entire Notebook in order to get the desired result.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须执行整个Notebook才能获得期望的结果。
- en: In this activity, we designed and trained an RNN model to predict the Yahoo
    stock price from the previous 30 days of data.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 在这项活动中，我们设计并训练了一个RNN模型，用于预测基于过去30天数据的Yahoo股票价格。
