- en: ES-HyperNEAT and the Retina Problem
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES-HyperNEAT与视网膜问题
- en: In this chapter, you will learn about the ES-HyperNEAT extension of the HyperNEAT
    method, which we discussed in the previous chapter. As you learned in the previous
    chapter, the HyperNEAT method allows the encoding of larger-scale **artificial
    neural network** (**ANN**) topologies, which is essential for working in areas
    where the input data has a large number of dimensions, such as computer vision.
    However, despite all its power, the HyperNEAT method has a significant drawback—the
    configuration of the ANN substrate should be designed beforehand by a human architect.
    The ES-HyperNEAT method was invented to address this issue by introducing the
    concept of evolvable-substrate, which allows us to produce the appropriate configuration
    of the substrate automatically during evolution.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解HyperNEAT方法的ES-HyperNEAT扩展，这是我们上章讨论过的。正如你在上章所学，HyperNEAT方法允许编码更大规模的**人工神经网络**（**ANN**）拓扑结构，这对于在输入数据具有大量维度的领域工作至关重要，例如计算机视觉。然而，尽管HyperNEAT方法功能强大，但它有一个显著的缺点——ANN基底的配置应该由人类建筑师事先设计。ES-HyperNEAT方法通过引入可进化基底的观念来解决这一问题，这使得我们能够在进化过程中自动产生适当的基底配置。
- en: After familiarizing yourself with the basics of the ES-HyperNEAT method, you
    will have a chance to apply this knowledge to solve the modular retina problem.
    During this task, we will show you how to choose an appropriate initial substrate
    configuration that helps the evolutionary process to discover the modular structures.
    Also, we will discuss the source code of the modular retina problem solver along
    with the test environment, which can be used to evaluate the fitness of each detector
    ANN.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在熟悉ES-HyperNEAT方法的基础知识之后，你将有机会将此知识应用于解决模块化视网膜问题。在此任务中，我们将向你展示如何选择一个合适的初始基底配置，以帮助进化过程发现模块化结构。此外，我们还将讨论模块化视网膜问题求解器的源代码以及测试环境，这些可以用来评估每个检测ANN的适应性。
- en: Through this chapter, you will gain hands-on experience with applying the ES-HyperNEAT
    method using the MultiNEAT Python library.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，你将获得使用MultiNEAT Python库应用ES-HyperNEAT方法的实践经验。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将涵盖以下主题：
- en: Manual versus evolution-based configuration of the topography of neural nodes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 神经节点拓扑的手动配置与基于进化的配置
- en: Quadtree information extraction and ES-HyperNEAT basics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四叉树信息提取和ES-HyperNEAT基础知识
- en: The modular left and right retina experiment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化左右视网膜实验
- en: Discussion of the experiment results
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实验结果讨论
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following technical requirements should be met to execute the experiments
    described in this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行本章中描述的实验，应满足以下技术要求：
- en: Windows 8/10, macOS 10.13 or newer, or modern Linux
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 8/10, macOS 10.13或更新的版本，或现代Linux
- en: Anaconda Distribution version 2019.03 or newer
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Anaconda Distribution版本2019.03或更新的版本
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/tree/master/Chapter8](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/tree/master/Chapter8)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/tree/master/Chapter8](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/tree/master/Chapter8)找到
- en: Manual versus evolution-based configuration of the topography of neural nodes
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 神经节点拓扑的手动配置与基于进化的配置
- en: The HyperNEAT method, which we discussed in [Chapter 7](21fb699f-605d-4156-aa5c-5ba501dc09cf.xhtml),
    *Hypercube-Based NEAT for Visual Discrimination*, allows us to use neuroevolution
    methods for a broad class of problems that require the use of large-scale ANN
    structures to find a solution. This class of problem spreads across multiple practical
    domains, including visual pattern recognition. The main distinguishing feature
    of all these problems is the high dimensionality of the input/output data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第7章](21fb699f-605d-4156-aa5c-5ba501dc09cf.xhtml)“基于超立方体的NEAT进行视觉区分”中讨论的HyperNEAT方法，允许我们使用神经进化方法解决需要使用大规模ANN结构来找到解决方案的广泛类别的难题。这类问题跨越多个实际领域，包括视觉模式识别。所有这些问题的主要区别特征是输入/输出数据的高度维度。
- en: In the previous chapter, you learned how to define the configuration of the
    substrate of the discriminator ANN to solve a visual discrimination task. You
    also learned that it is crucial to use an appropriate substrate configuration
    that is aligned with the geometric features of the search space of the target
    problem. With the HyperNEAT method, you, as an architect, need to define the substrate
    configuration beforehand, using only your understanding of the spatial geometry
    of the problem. However, it is not always possible to learn about all the geometric
    regularities hidden behind a specific problem space.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何定义判别器人工神经网络（ANN）的基底的配置来解决视觉判别任务。你也了解到，使用与目标问题搜索空间几何特征相匹配的适当基底配置至关重要。使用HyperNEAT方法，作为架构师的你需要事先定义基底配置，仅使用你对问题空间空间几何的理解。然而，并不总是可能了解特定问题空间背后隐藏的所有几何规律。
- en: If you design the substrate manually, you create an unintentional constraint
    on the pattern of weights drawn over it by the connective**Compositional Pattern
    Producing Networks** (**CPPNs**). By placing nodes at specific locations in the
    substrate, you interfere with the ability of the CPPN to discover the geometric
    regularities of the natural world. The CPPN should produce a connectivity pattern
    that is perfectly aligned with the structure of the substrate that you provided,
    and connections are only possible between the nodes of this structure. This limitation
    leads to unnecessary approximation errors, which taints the results when you use
    an evolved CPPN to create the topology of the solution-solver ANN (the phenotype).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你手动设计基底，你会在其上绘制的权重模式上创建一个无意中的约束，这种模式是由连接**组合模式生成网络**（**CPPNs**）产生的。通过在基底中特定位置放置节点，你干扰了CPPN发现自然世界几何规律的能力。CPPN应该产生一个与提供的基底结构完美对齐的连接模式，并且只有该结构中的节点之间才能建立连接。这种限制导致了不必要的近似误差，当你使用演化的CPPN创建解决方案求解器ANN（表型）的拓扑结构时，这些误差会污染结果。
- en: 'However, why are the limitations that are introduced with manual substrate
    configuration inflicted in the first place? Would it be better if the CPPN could
    elaborate on the connectivity patterns between the nodes of the substrate that
    are automatically positioned in the right locations in the substrate? It seems
    that evolving connectivity patterns in the substrate provides valuable implicit
    hints that help us to estimate the nodes'' positions for the next epoch of the
    evolution. The method of substrate configuration evolution during the CPPN training
    got a name: **Evolvable-Substrate**.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为什么手动配置基底时引入的限制一开始就产生了？如果CPPN能够详细阐述基底中自动定位在正确位置的节点之间的连接模式会更好吗？似乎在基底中演化的连接模式提供了有价值的隐含提示，帮助我们估计下一轮演化的节点位置。在CPPN训练期间基底配置演化的方法得到了一个名字：**可演化基底**。
- en: The implicit data allowing us to estimate the position of the next node is the
    amount of the information encoded by the connectivity pattern in the specific
    substrate area. The areas with a uniform distribution of connection weights encode
    a small amount of information, thereby requiring only a few substrate nodes in
    those areas. At the same time, substrate areas with large gradients of connection
    weights are informationally intensive and can benefit from additional nodes placed
    within those areas. When you place an additional node in such areas of the substrate,
    you allow the CPPN to represent the much more granular encoding of the natural
    world. Thus, the placement of the nodes and the connectivity pattern can be mandated
    by the distribution of the connection weights while the CPPN produces the connection
    weights during the evolution.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 允许我们估计下一个节点位置的隐含数据是特定基底区域中连接模式编码的信息量。连接权重均匀分布的区域编码的信息量较小，因此在这些区域只需要少量基底节点。同时，连接权重梯度大的基底区域信息密集，可以从放置在这些区域内的额外节点中受益。当你将额外的节点放置在基底这样的区域时，你允许CPPN表示自然世界的更细粒度的编码。因此，节点的放置和连接模式可以由连接权重的分布来规定，而CPPN在进化过程中产生连接权重。
- en: HyperNEAT represents each connection between two nodes of the substrate as a
    point in the four-dimensional hypercube. The evolvable-substrate HyperNEAT algorithm
    extends HyperNEAT by automatically placing fewer hyperpoints in the areas of the
    hypercube with lower variation in the connection weights. Thus, ES-HyperNEAT uses
    information density as the primary guiding principle when determining the topology
    of the substrate during the evolution.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: HyperNEAT将基底中两个节点之间的每个连接表示为四维超立方体中的一个点。可进化基底HyperNEAT算法通过自动在连接权重变化较小的超立方体区域放置较少的超点来扩展HyperNEAT。因此，ES-HyperNEAT在进化过程中确定基底拓扑时，将信息密度作为主要的指导原则。
- en: In the next section, we discuss the particulars of the ES-HyperNEAT algorithm.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论ES-HyperNEAT算法的细节。
- en: Quadtree information extraction and ES-HyperNEAT basics
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 四叉树信息提取和ES-HyperNEAT基础知识
- en: For the effective calculation of the information density within the connectivity
    patterns of the substrate, we need to use an appropriate data structure. We need
    to employ a data structure that allows an effective search through the two-dimensional
    substrate space at different levels of granularity. In computer science, there
    is a data structure that perfectly fits these requirements. This structure is
    the **quadtree**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效计算基底的连接模式中的信息密度，我们需要使用适当的数据结构。我们需要使用一种数据结构，允许在不同粒度级别上有效地搜索二维基底空间。在计算机科学中，存在一种数据结构完美符合这些要求。这种结构就是**四叉树**。
- en: The quadtree is a data structure that allows us to organize an effective search
    through two-dimensional space by splitting any area of interest into four subareas.
    Each of these subareas consequently becomes a leaf of a tree, with the root node
    representing the initial region.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 四叉树是一种数据结构，允许我们通过将任何感兴趣的区域分割成四个子区域来有效地在二维空间中进行搜索。每个子区域随后成为树的叶子，根节点代表初始区域。
- en: ES-HyperNEAT employs the quadtree data structure to iteratively look for the
    new connections and nodes in the substrate, starting from the input and the output
    nodes predefined by the data scientist. Using a quadtree to search for new connections
    and nodes is much more computationally effective than searching in the four-dimensional
    space of the hypercube.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ES-HyperNEAT使用四叉树数据结构，从数据科学家预定义的输入和输出节点开始，迭代地寻找基底中的新连接和节点。使用四叉树搜索新连接和节点比在超立方体的四维空间中搜索要计算效率高得多。
- en: 'The scheme of information extraction using the quadtree structure is shown
    in the following diagram:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了使用四叉树结构的信息提取方案：
- en: '![](img/e7cca6a3-0382-4424-b28f-3b759c53f33e.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e7cca6a3-0382-4424-b28f-3b759c53f33e.png)'
- en: The scheme of information extraction
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 信息提取方案
- en: 'The information extraction method depicted in the diagram has two major parts:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图中所示的信息提取方法有两个主要部分：
- en: 'The **division and initialization** stage is presented in the top part of the
    diagram. At this stage, the quadtree is created by recursively dividing the initial
    substrate area, which spans from (*-1*, *-1*) to (*1, 1*). The division stops
    when the desired depth of the quadtree is reached. Now we have several subspaces
    that are fitted into the substrate, determining the initial substrate resolution
    (*r*). Next, for every node of the quadtree with a center at (![](img/7b9cf86d-a9b4-429d-bc7e-faa039aa599c.png),![](img/058e9c7f-9dc4-42db-9c59-311c42c52554.png)),
    we query the CPPN to find a connection weight (*w*) between this node and a specific
    input or output neuron at coordinates (*a, b*). When we have calculated the connection
    weights for the* k* leaf nodes in the subtree of the quadtree, *p*, we are ready
    to calculate the information variance of the node, *p*, in the quadtree as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**划分和初始化**阶段在图表的上部部分展示。在这个阶段，通过递归划分初始基底区域（从(*-1*, *-1*）到(*1, 1*)），创建四叉树。当达到所需的四叉树深度时，划分停止。现在我们有几个子空间被拟合到基底中，确定初始基底分辨率(*r*)。接下来，对于四叉树中中心在(![](img/7b9cf86d-a9b4-429d-bc7e-faa039aa599c.png),![](img/058e9c7f-9dc4-42db-9c59-311c42c52554.png))的每个节点，我们查询CPPN以找到该节点与特定输入或输出神经元在坐标(*a,
    b*)之间的连接权重(*w*)。当我们计算出四叉树子树中*k*个叶子节点的连接权重后，我们就可以计算四叉树中节点*p*的信息方差，如下所示：'
- en: '![](img/4c372061-3f19-40ba-90fe-8c7d3773a415.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4c372061-3f19-40ba-90fe-8c7d3773a415.png)'
- en: '![](img/806e14e4-960c-4327-bd4c-d6c048112dd3.png) is the mean connection weight
    among *k* leaf nodes and ![](img/7567b3d8-2e17-4436-9d1b-8bc18199c6ee.png) is
    a connection weight to each leaf node.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/806e14e4-960c-4327-bd4c-d6c048112dd3.png)是*k*个叶节点之间的平均连接权重，![](img/7567b3d8-2e17-4436-9d1b-8bc18199c6ee.png)是每个叶节点的连接权重。'
- en: We can use this estimated variance value as a heuristic indicator of the information
    density in the specific subarea of the substrate. The higher this value, the higher
    the information density. The variance can be used to manage the information density
    in the specific subarea of the substrate by introducing the **division threshold** constant.
    If the variance is greater than the division threshold, then the division stage
    is repeated until the desired information density is reached.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个估计的方差值作为信息密度在基质特定子区域中的启发式指标。这个值越高，信息密度就越高。可以通过引入**分割阈值**常量来使用方差来管理基质特定子区域的信息密度。如果方差大于分割阈值，则重复分割阶段，直到达到所需的信息密度。
- en: At this stage, we create an indicative structure that allows the CPPN to decide
    where to make connections within the given substrate. The next stage of the processing
    places all necessary connections using the created quadtree structure.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们创建一个指示性结构，使CPPN能够决定在给定的基质中连接的位置。处理阶段的下一阶段使用创建的四叉树结构放置所有必要的连接。
- en: The** pruning and extraction** stage is represented in the bottom part of the
    diagram. In this stage, we use the populated quadtree structure from the previous
    stage to find the regions with high variance and make sure that more connections
    are expressed among the nodes of these regions. We traverse the quadtree depth-first
    and stop the traversal at the node that has a variance value that's smaller than
    the given** variance threshold **(![](img/00f974a1-7ad2-4378-a76b-079f334dc42b.png))
    or when the current node has no children (that is, has zero variance). For every
    quadtree node found by the depth-first search, we express the connection between
    the center of the node (*x*, *y*) and each parent node that is already determined.
    The parent node can either be determined by an architect (input/output nodes)
    or be found in the previous runs of the information extraction method, that is,
    from hidden nodes already created by the ES-HyperNEAT method. When this stage
    completes, the substrate configuration will have more nodes in the informationally
    intensive substrate regions and fewer nodes in the regions encoding a small amount
    of information.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**修剪和提取**阶段在图的下部表示。在这个阶段，我们使用前一阶段创建的填充四叉树结构来找到高方差区域，并确保这些区域的节点之间有更多的连接。我们以深度优先的方式遍历四叉树，并在具有小于给定**方差阈值**的方差值的节点处停止遍历（![](img/00f974a1-7ad2-4378-a76b-079f334dc42b.png))或当当前节点没有子节点（即，方差为零）时。对于通过深度优先搜索找到的每个四叉树节点，我们表达节点中心(*x*,
    *y*)与每个已确定的父节点之间的连接。父节点可以是建筑师（输入/输出节点）确定的，也可以在信息提取方法的前一轮次中找到，即从ES-HyperNEAT方法已创建的隐藏节点中找到。当这个阶段完成时，基质配置将在信息密集的基质区域有更多的节点，而在编码少量信息的区域有较少的节点。'
- en: In the following section, we will discuss how to use the ES-HyperNEAT algorithm
    we've just described to find a solution for the modular retina problem.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何使用我们刚刚描述的ES-HyperNEAT算法来解决模块化视网膜问题。
- en: For more details about the ES-HyperNEAT algorithm, refer to [Chapter 1](f59c6396-55e5-4495-95c0-7af9a42c2f20.xhtml),
    *Overview of Neuroevolution Methods*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 关于ES-HyperNEAT算法的更多详细信息，请参阅[第1章](f59c6396-55e5-4495-95c0-7af9a42c2f20.xhtml)，*神经进化方法概述*。
- en: Modular retina problem basics
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化视网膜问题基础知识
- en: The hierarchical modular structures are an essential part of the complex biological
    organisms and play an indispensable role in their evolution. The modularity enhances
    the evolvability, allowing the recombination of various modules during the evolution
    process. The evolved hierarchy of modular components bootstraps the evolution
    process, allowing operations over a collection of complex structures rather than
    basic genes. After that, the neuroevolutionary process does not need to spend
    time to evolve similar functionality from scratch again. Instead, the ready-to-use
    modular components can be used as building blocks to produce very complex neural
    networks.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 层次模块结构是复杂生物体的基本组成部分，在它们的进化中起着不可或缺的作用。模块化增强了可进化性，允许在进化过程中重组各种模块。模块组件的进化层次启动了进化过程，允许对一组复杂结构进行操作，而不是基本基因。之后，神经进化过程不需要再次从头开始进化类似的功能。相反，现成的模块组件可以作为构建块来构建非常复杂的神经网络。
- en: In this chapter, we will implement a solution to the retina problem using the
    ES-HyperNEAT algorithm. The retina problem is about the simultaneous identification
    of valid 2x2 patterns on the left and the right side of an artificial retina that
    has a resolution of 4x2\. Thus, the detector ANN must decide if the patterns presented
    on the left and the right side of the retina are valid for the corresponding side
    of the retina (left or right).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用ES-HyperNEAT算法实现视网膜问题的解决方案。视网膜问题涉及同时识别人工视网膜左侧和右侧的有效的2x2模式，该人工视网膜的分辨率为4x2。因此，检测器ANN必须决定视网膜左侧和右侧呈现的模式是否对应视网膜的相应侧（左侧或右侧）。
- en: In the retina problem, the left and the right problem components are perfectly
    separated into different functional units. At the same time, some components can
    be present on each side of the retina, while others are unique to a specific part
    of the retina. Thus, to produce a successful detector ANN, the neuroevolution
    process needs to discover the modular structures separately for the left and the
    right detection zones.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在视网膜问题中，左右问题组件被完美地分离到不同的功能单元中。同时，一些组件可以出现在视网膜的每一侧，而其他组件则仅限于视网膜的特定部分。因此，为了产生一个成功的检测器ANN，神经进化过程需要分别发现左右检测区域的模块结构。
- en: 'The retina problem scheme is shown in the following diagram:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 视网膜问题方案如下所示：
- en: '![](img/6015ae45-08dd-4dcd-afcf-3af1767e3ab2.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6015ae45-08dd-4dcd-afcf-3af1767e3ab2.png)'
- en: The retina problem scheme
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 视网膜问题方案
- en: As you can see in the preceding diagram, the artificial retina is represented
    as a 2D grid with a resolution of 4x2 pixels. The values of the two-dimensional
    array representing the patterns drawn on the retina constitute the inputs of the
    detector ANN. The filled pixels in the array have a value of `1.0` and the empty
    pixels have a value of `0.0`. With the given resolution, it is possible to draw
    16 different 2x2 patterns for the left and the right parts of the retina. Thus,
    we have eight valid patterns for the left side and eight valid patterns for the
    right side of the retina. Some of the patterns mentioned are valid for both sides
    of the retina.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，人工视网膜被表示为一个分辨率为4x2像素的2D网格。表示视网膜上绘制的模式的二维数组的值构成了检测器ANN的输入。数组中的填充像素的值为`1.0`，空像素的值为`0.0`。在给定的分辨率下，可以为视网膜的左右两侧绘制16种不同的2x2模式。因此，视网膜的左侧有八个有效模式，右侧也有八个有效模式。所提到的某些模式对视网膜的两侧都有效。
- en: 'The scheme of decision-making by the detector ANN in the retina problem domain
    is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在视网膜问题领域中，检测器ANN的决策方案如下：
- en: '![](img/4a0213e3-11fc-47ec-a951-e49296ae65fc.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4a0213e3-11fc-47ec-a951-e49296ae65fc.png)'
- en: The scheme of decision making by the detector ANN
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 检测器ANN的决策方案
- en: The detector ANN has eight inputs to accept input data patterns from both sides
    of the retina and two output nodes. Each of the output nodes produces a value
    that can be used to classify the pattern's validity at each side of the retina.
    The first output node is assigned to the left and the second node to the right
    side of the retina correspondingly. The activation value of the output node that
    is greater than or equal to `0.5` classifies the pattern for the related side
    of the retina as valid. If the activation value is less than `0.5`, the pattern
    is considered not valid. To even further simplify the detection, we apply rounding
    to the values of the output nodes according to the rounding scheme shown in the
    diagram. Thus, each output node of the detector ANN serves as a binary classifier
    for the related part of the retina that produces a value of `0.0` or `1.0` to
    mark the input pattern as invalid or valid correspondingly.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 检测器人工神经网络（ANN）有八个输入来接受视网膜两边的输入数据模式，并且有两个输出节点。每个输出节点产生一个值，可以用来分类视网膜每边的模式的有效性。第一个输出节点分配给左侧，第二个节点分配给视网膜的右侧。输出节点的激活值大于或等于`0.5`时，将视网膜相关侧的模式分类为有效。如果激活值小于`0.5`，则模式被认为无效。为了进一步简化检测，我们根据图中的舍入方案对输出节点的值进行舍入。因此，检测器ANN的每个输出节点作为相关视网膜部分的二元分类器，产生`0.0`或`1.0`的值来相应地标记输入模式为无效或有效。
- en: Objective function definition
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标函数定义
- en: The task of the detector ANN is to correctly classify the inputs from the left
    and right sides of the retina as valid or not by producing a vector of the binary
    outputs with values of `0.0` or `1.0`. The output vector has a length of 2, which
    is equal to number of the output nodes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 检测器ANN的任务是通过产生具有`0.0`或`1.0`值的二元输出向量，正确地将视网膜左右两侧的输入分类为有效或无效。输出向量的长度为2，等于输出节点的数量。
- en: 'We can define the detection error as the Euclidean distance between the vector
    with ground truth values and the vector with ANN output values, as given by the
    following formula:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将检测误差定义为真实值向量与ANN输出值向量之间的欧几里得距离，如下公式所示：
- en: '![](img/264a3ace-8838-4bf8-a668-371867d9bc28.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/264a3ace-8838-4bf8-a668-371867d9bc28.png)'
- en: '![](img/9132f8c9-c333-422f-a337-a3652a762eae.png) is the squared detection
    error for one trial, ![](img/75051026-cfcc-4719-9751-778e01da36aa.png) is the
    vector with detector ANN outputs, and ![](img/a1fbc606-d1ef-4b6e-9a30-29a33ff88b84.png)
    is the vector with the ground truth values.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/9132f8c9-c333-422f-a337-a3652a762eae.png)是单个试验的平方检测误差，![图片](img/75051026-cfcc-4719-9751-778e01da36aa.png)是检测器ANN的输出向量，而![图片](img/a1fbc606-d1ef-4b6e-9a30-29a33ff88b84.png)是真实值向量。'
- en: 'At each generation of the evolution, we evaluate each detector ANN (phenotype)
    against all 256 possible combinations of 4x4 retina patterns, which are produced
    by combining 16 different 2x2 patterns for each side of the retina. Thus, to get
    a final detection error value for the particular detector ANN, we calculate the
    sum of 256 error values obtained for each configuration of the retina patterns,
    as indicated by the following formula:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在进化的每一代中，我们评估每个检测器ANN（表型）对所有256种可能的4x4视网膜模式组合，这些模式是通过将每侧视网膜的16个不同的2x2模式组合而产生的。因此，为了得到特定检测器ANN的最终检测误差值，我们计算视网膜模式配置获得的256个误差值的总和，如下公式所示：
- en: '![](img/4c0370c0-7e99-48b6-a17e-607e740979a1.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4c0370c0-7e99-48b6-a17e-607e740979a1.png)'
- en: '![](img/653fbe3d-5f27-475f-b9c4-f46b68d9ce66.png) is the sum of all errors
    obtained during 256 trials and ![](img/debe4e93-4cab-486d-bc3e-8161c06bf4af.png) is
    the squared detection error for a particular trial.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/653fbe3d-5f27-475f-b9c4-f46b68d9ce66.png)是256次试验期间获得的所有误差的总和，而![图片](img/debe4e93-4cab-486d-bc3e-8161c06bf4af.png)是特定试验的平方检测误差。'
- en: 'The fitness function can be defined as the inverse of the sum of the errors
    obtained from all 256 trials against all possible retina patterns, as shown in
    the following formula:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 适应度函数可以被定义为从所有256次试验中获取的所有可能的视网膜模式误差之和的倒数，如下公式所示：
- en: '![](img/da755433-17e7-417d-8e5d-0cb93ed122fe.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/da755433-17e7-417d-8e5d-0cb93ed122fe.png)'
- en: We add `1.0` to the sum of errors (![](img/bd661974-d4b9-45c8-b734-3585e3f849ef.png))
    in the denominator to avoid dividing by 0 in cases when all trials produce no
    error. Thus, according to the fitness function formula, the maximum value of the
    fitness score in our experiment is `1000.0`, which we will use as a fitness threshold
    value later.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`1.0`加到分母中错误的和（![图片](img/bd661974-d4b9-45c8-b734-3585e3f849ef.png)）以避免在所有试验均无错误的情况下除以0。因此，根据适应度函数公式，我们实验中适应度分数的最大值为`1000.0`，我们将在稍后将其用作适应度阈值值。
- en: Modular retina experiment setup
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化视网膜实验设置
- en: In this section, we discuss the details of an experiment aimed at creating a
    successful solver of the modular retina problem. In our experiment, we use this
    problem as a benchmark to test the ability of the ES-HyperNEAT method to discover
    modular topologies in the phenotype ANN.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了旨在创建模块化视网膜问题成功求解器的实验的细节。在我们的实验中，我们将此问题作为基准来测试ES-HyperNEAT方法在表型ANN中发现模块化拓扑结构的能力。
- en: The initial substrate configuration
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始基底配置
- en: 'As described earlier in the chapter, the retina has dimensions of 4x2, with
    two 2x2 areas, one on the left side and one on the right side. The particulars
    of the retina geometry must be represented in the geometry of the initial substrate
    configuration. In our experiment, we use a three-dimensional substrate, as shown
    in the following diagram:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，视网膜的尺寸为4x2，有两个2x2区域，一个在左侧，一个在右侧。视网膜几何的细节必须在初始基底配置的几何中表示。在我们的实验中，我们使用三维基底，如下所示：
- en: '![](img/8a75c354-2a52-42a3-ba74-c43d033e7e8f.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8a75c354-2a52-42a3-ba74-c43d033e7e8f.png)'
- en: The initial substrate configuration
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 初始基底配置
- en: As you can see in the diagram, the input nodes are placed within the XZ plane,
    which is orthogonal to the XY plane. They are presented in two groups, with four
    nodes to describe the left and right sides of the retina. The two output and bias
    nodes are located within the XY plane, which divides the Z-plane in half with
    the input nodes. The evolution of the substrate creates new hidden nodes in the
    same XY plane where the output nodes are located. The evolved connective CPPN
    draws the connectivity patterns between all nodes within the substrate. Our ultimate
    goal is to evolve the CPPN and the substrate configuration, which produces an
    appropriate modular graph of the detector ANN. This graph should include two modules,
    each representing an appropriate configuration for the binary classifier, which
    we discussed earlier. Let's now look at the test environment for the modular retina
    problem.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，输入节点位于XZ平面内，该平面垂直于XY平面。它们分为两组，每组四个节点用于描述视网膜的左右两侧。两个输出和偏置节点位于XY平面内，该平面将Z平面一分为二，与输入节点相邻。基底的演变在输出节点所在的同一XY平面中创建了新的隐藏节点。演化的连接性CPPN绘制了基底内所有节点之间的连接模式。我们的最终目标是演化CPPN和基底配置，从而产生检测器ANN的适当模块化图。此图应包括两个模块，每个模块代表二进制分类器的适当配置，这是我们之前讨论过的。现在让我们看看模块化视网膜问题的测试环境。
- en: Test environment for the modular retina problem
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化视网膜问题的测试环境
- en: 'First, we need to create a test environment that can be used to evaluate the
    results of the neuroevolution process that aims to create a successful detector
    ANN. The test environment should create a dataset that consists of all possible
    patterns of pixels on the retina. Also, it should provide functions to evaluate
    the detector ANN against each pattern in the dataset. Thus, the test environment
    can be divided into two main parts:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个测试环境，用于评估旨在创建成功的检测器ANN的神经进化过程的成果。测试环境应创建一个数据集，包括视网膜上所有可能的像素模式。此外，它还应提供评估检测器ANN与数据集中每个模式的功能。因此，测试环境可以分为两个主要部分：
- en: The data structure to hold visual patterns for the left-hand, the right-hand,
    or both sides of the retina
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储视网膜左侧、右侧或两侧视觉模式的数结构
- en: The test environment storing the dataset and providing functions for detector
    ANN evaluation
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储数据集并提供检测器ANN评估功能的测试环境
- en: In the following sections, we provide a detailed description of each part.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们提供了每个部分的详细描述。
- en: The visual object definition
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视觉对象定义
- en: 'Each of the allowed configurations of pixels in the specific part of the retina
    space can be represented as a separate visual object. The Python class encapsulating
    the related functionality is named `VisualObject` and is defined in the `retina_experiment.py`
    file. It has the following constructor:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 视网膜空间特定部分的像素允许配置的每种配置都可以表示为一个单独的视觉对象。封装相关功能的Python类命名为`VisualObject`，并在`retina_experiment.py`文件中定义。它具有以下构造函数：
- en: '[PRE0]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The constructor receives the configuration of a particular visual object as
    a string, along with a valid location for this object in the retina space. After
    that, it assigns received parameters to the internal fields and creates a two-dimensional
    data array holding the states of the pixels in the visual object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接收一个特定视觉对象的配置字符串，以及该对象在视网膜空间中的有效位置。之后，它将接收到的参数分配给内部字段，并创建一个二维数据数组，用于存储视觉对象中像素的状态。
- en: 'The pixels'' states are obtained by parsing the visual object configuration
    string as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下方式解析视觉对象配置字符串以获取像素的状态：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The visual object configuration string has four characters, excluding the line
    break, which define the state of the corresponding pixel in the visual object.
    If the symbol at a specific position in the configuration line is `o`, then the
    pixel at the corresponding position of the visual object is set to the ON state,
    and the value `1.0` is saved to the data array at this position.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉对象配置字符串由四个字符组成，不包括换行符，这些字符定义了视觉对象中相应像素的状态。如果配置行中特定位置的符号是`o`，则将视觉对象中相应位置的像素设置为开启状态，并将值`1.0`保存到数据数组中的该位置。
- en: The retina environment definition
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视网膜环境定义。
- en: The retina environment creates and stores the dataset consisting of all possible
    visual objects and provides functions for evaluating the fitness of the detector
    ANN. It has the following main implementation parts.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 视网膜环境创建并存储由所有可能的视觉对象组成的数据集，并提供评估检测器ANN适应度的函数。它具有以下主要实现部分。
- en: The function to create a dataset with all the possible visual objects
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建包含所有可能视觉对象的数据集的功能。
- en: 'In this function, we create the visual objects for the dataset as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数中，我们按照以下方式创建数据集的视觉对象：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code creates visual objects for the left side of the retina.
    The visual objects for the right side can be created in a similar way:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了视网膜左侧的视觉对象。右侧的视觉对象可以以类似的方式创建：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The created objects appended to the list of the visual objects are defined as
    a dataset for evaluating the fitness of the detector ANN produced by the neuroevolution
    process from the substrate.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的对象被添加到视觉对象列表中，定义为评估从基底产生的神经进化过程中检测器ANN适应度的数据集。
- en: The function to evaluate the detector ANN against two specific visual objects
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估检测器ANN针对两个特定视觉对象的功能。
- en: This function evaluates the performance of the detector ANN against two given
    visual objects—one for each side of the retina space. For the complete source
    code, please refer to the `def _evaluate(self, net, left, right, depth, debug=False)` function
    defined at [https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter8/retina_environment.py](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter8/retina_environment.py).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能评估检测器ANN针对两个给定的视觉对象（每个视觉对象对应视网膜空间的一侧）的性能。对于完整的源代码，请参阅在[https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter8/retina_environment.py](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter8/retina_environment.py)中定义的`def
    _evaluate(self, net, left, right, depth, debug=False)`函数。
- en: 'The source code of the function has the following essential parts:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的源代码具有以下基本部分：
- en: 'First, we prepare the inputs for the detector ANN in the order that they are
    defined in for the substrate configuration:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们按照在基底配置中定义的顺序准备检测器人工神经网络（ANN）的输入。
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `inputs` array starts with the left-side data and continues with the right-side
    data. After that, the bias value is appended to the end of the `inputs` array
    and the array data is supplied as input to the detector ANN.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`inputs`数组以左侧数据开始，然后继续添加右侧数据。之后，将偏差值附加到`inputs`数组的末尾，并将数组数据作为输入提供给检测器ANN。'
- en: 'After a specific number of activations of the detector ANN, the outputs are
    obtained and rounded:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检测器ANN激活特定次数之后，获得输出并四舍五入。
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we need to calculate squared detection error, which is the Euclidean
    distance between the outputs vector and the vector with the ground-truth values.
    Thus, we first create the vector with ground-truth values as follows:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要计算平方检测错误，这是输出向量与真实值向量之间的欧几里得距离。因此，我们首先创建以下具有真实值的向量：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The corresponding ground-truth value is set to `1.0` if the visual object is
    valid for a given side of the retina, or both sides. Otherwise, it is set to `0.0`
    to indicate an incorrect visual object position.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果视觉对象对于视网膜的给定侧面或两侧都是有效的，则将相应的真实值设置为`1.0`。否则，将其设置为`0.0`以指示视觉对象位置不正确。
- en: 'Finally, the squared detection error is calculated as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，计算平方检测错误如下：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The function returns the detection error and the outputs from the detector ANN.
    In the next section, we will discuss the retina experiment runner implementation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回检测错误和检测器ANN的输出。在下一节中，我们将讨论视网膜实验运行器的实现。
- en: For complete implementation details, refer to the `retina_environment.py` file
    at [https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter8/retina_environment.py](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter8/retina_environment.py).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整的实现细节，请参阅[https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter8/retina_environment.py](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter8/retina_environment.py)中的`retina_environment.py`文件。
- en: Experiment runner
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验运行器
- en: To solve the modular retina problem, we need to use a Python library that provides
    an implementation of the ES-HyperNEAT algorithm. If you've read the previous chapter,
    you are already familiar with the MultiNEAT Python library, which also has an
    implementation of the ES-HyperNEAT algorithm. Thus, we can use this library to
    create a retina experiment runner implementation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决模块化视网膜问题，我们需要使用一个提供ES-HyperNEAT算法实现的Python库。如果你已经阅读了上一章，你应该已经熟悉了MultiNEAT
    Python库，它也实现了ES-HyperNEAT算法。因此，我们可以使用这个库来创建视网膜实验运行器的实现。
- en: Let's discuss the essential components of the implementation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论实现中的基本组件。
- en: For full implementation details, refer to the `retina_experiment.py` file at
    [https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter8/retina_experiment.py](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter8/retina_experiment.py).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整的实现细节，请参阅[https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter8/retina_experiment.py](https://github.com/PacktPublishing/Hands-on-Neuroevolution-with-Python/blob/master/Chapter8/retina_experiment.py)中的`retina_experiment.py`文件。
- en: The experiment runner function
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验运行器函数
- en: 'The `run_experiment` function runs the experiment using the provided hyperparameters
    and an initialized test environment to evaluate the discovered detector ANNs against
    the possible retina configurations. The function implementation has the following
    significant parts:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`run_experiment`函数使用提供的超参数和一个初始化的测试环境来运行实验，评估发现的检测器ANN相对于可能的视网膜配置。函数实现具有以下显著部分：'
- en: 'First is the initialization of the population of the initial CPPN genomes:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先是初始化初始CPPN基因组的种群：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At first, the preceding code sets the random seed value to the one that we found
    to be useful for generating successful solutions by sequentially running many
    experiment trials. After that, we create the substrate configuration that is suitable
    for the retina experiment, taking into account the geometry of the retina space.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，前面的代码将随机种子值设置为我们在通过顺序运行许多实验试验以生成成功解决方案时发现的有用值。之后，我们创建适合视网膜实验的底物配置，考虑到视网膜空间的几何形状。
- en: Next, we create the initial CPPN genome using the substrate configuration we
    already have. The CPPN genome needs to have a number of input and output nodes
    that is compatible with the substrate configuration. Also, we seed the initial
    CPPN genome with two hidden nodes with a Gaussian activation function to boost
    the neuroevolution process in the right direction. The Gaussian hidden nodes start
    the neuroevolution search with a bias toward producing particular detector ANN
    topologies. With these hidden nodes, we introduce to the connectivity patterns
    of the substrate the principle of symmetry, which is precisely what we are expecting
    to achieve in the topology of the successful detector ANN. For the retina problem,
    we need to discover a symmetrical detector ANN configuration incorporating the
    two symmetrical classifier modules.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用已有的底物配置创建初始CPPN基因组。CPPN基因组需要具有与底物配置兼容的输入和输出节点数。此外，我们使用具有高斯激活函数的两个隐藏节点初始化初始CPPN基因组，以正确方向促进神经进化过程。高斯隐藏节点以偏向产生特定检测器ANN拓扑结构的方式开始神经进化搜索。通过这些隐藏节点，我们将对称性原则引入底物的连接模式中，这正是我们期望在成功检测器ANN拓扑结构中实现的。对于视网膜问题，我们需要发现一个包含两个对称分类模块的对称检测器ANN配置。
- en: 'Next, we prepare the intermediary variables to hold the experiment execution
    results, along with the statistics collector. After that, we run the evolution
    loop for a set number of generations:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们准备中间变量来保存实验执行结果以及统计收集器。之后，我们运行进化循环，进行一定数量的代数：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Inside the evolution loop, we get the list of genomes belonging to the current
    population and evaluate it against the test environment as follows:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进化循环内部，我们获取当前种群中属于当前种群的基因组列表，并按照以下方式对其进行测试环境评估：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `eval_genomes` function returns a tuple that has the following components:
    the best-fit genome, the highest fitness score among all evaluated genomes, and
    the list of detection errors for each evaluated genome. We save the appropriate
    parameters into a statistics collector and evaluate the obtained fitness score
    against the search termination criterion, which is defined as a `FITNESS_THRESHOLD`
    constant with a value of `1000.0`. The evolutionary search terminates successfully
    if the best fitness score in population is greater than or equal to the `FITNESS_THRESHOLD`
    value.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval_genomes`函数返回一个元组，包含以下组件：最佳拟合基因组、所有评估基因组的最高适应度分数以及每个评估基因组的检测错误列表。我们将适当的参数保存到统计收集器中，并将获得的适应度分数与搜索终止标准进行比较，该标准定义为`FITNESS_THRESHOLD`常量，其值为`1000.0`。如果种群中的最佳适应度分数大于或等于`FITNESS_THRESHOLD`值，进化搜索将成功终止。'
- en: 'If the successful solution was found, or the current best fitness score of
    the population is higher than the maximum fitness score ever achieved, we save
    the best CPPN genome and current fitness score as follows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到了成功的解决方案，或者当前种群的最佳适应度分数高于之前达到的最高适应度分数，我们将按照以下方式保存最佳CPPN基因组和当前适应度分数：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After that, if the value of the `solution_found` variable was set to `True`,
    we terminate the evolution loop:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，如果`solution_found`变量的值被设置为`True`，我们将终止进化循环：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the evolution failed to produce a successful solution, we print the statistics
    for the current generation and move to the next epoch:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果进化未能产生成功的解决方案，我们将打印当前代的统计数据，并移动到下一个时代：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The rest of the experiment runner code reports the results of the experiment
    in different formats.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 实验运行器代码的其余部分以不同的格式报告实验结果。
- en: 'We report the experiment results in textual and visual formats using the statistics
    collected in the evolution loop. Furthermore, visualizations are also saved into
    the local filesystem in the SVG vector format:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用进化循环中收集的统计数据，以文本和视觉格式报告实验结果。此外，可视化结果也以SVG矢量格式保存到本地文件系统中：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first three lines of the code print general statistics about experiment
    execution, such as the highest fitness score achieved, the time elapsed for experiment
    execution, and the random generator seed value.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的前三行打印了关于实验执行的通用统计数据，例如达到的最高适应度分数、实验执行所花费的时间以及随机生成器的种子值。
- en: 'The next part of the code is about visualizing the experiment results, which
    is the most informative part, and you should pay great attention to it. We start
    with visualizing the CPPN network that we create from the best genome found during
    the evolution:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的下一部分是关于可视化实验结果，这是最有信息量的部分，你应该特别注意。我们从可视化在进化过程中找到的最佳基因组创建的CPPN网络开始：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After that, we visualize the detector ANN topology that is created using the
    best CPPN genome and the retina substrate:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可视化使用最佳CPPN基因组和视网膜基板创建的检测器ANN拓扑结构：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Also, we print the results of the evaluation of the detector ANN created by
    the preceding code against a full dataset and two randomly selected visual objects:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还打印了前述代码创建的检测器ANN对完整数据集和两个随机选择的视觉对象的评估结果：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we render the statistics data collected during the experiment as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将实验期间收集的统计数据以如下方式呈现：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: All visualization plots mentioned here can be found after execution of the experiment
    in the `trial_out_dir` directory of the local filesystem. Now, let's discuss how
    the substrate builder function is implemented.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提到的所有可视化图表都可以在本地文件系统的 `trial_out_dir` 目录中实验执行后找到。现在，让我们讨论基板构建函数的实现。
- en: The substrate builder function
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基板构建函数
- en: The ES-HyperNEAT method runs the neuroevolution process, which includes the
    evolution of the CPPN genomes along with the evolution of the substrate configuration.
    However, even though the substrate is evolving during evolution, it is incredibly
    beneficial to start with an appropriate initial substrate configuration. This
    configuration should correspond to the geometry of the problem space.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ES-HyperNEAT方法运行神经进化过程，这包括CPPN基因组的进化以及基板配置的进化。然而，尽管基板在进化过程中也在进化，但从一个适当的初始基板配置开始是非常有益的。这个配置应该对应于问题空间的几何形状。
- en: 'For the retina experiment, the appropriate substrate configuration is created
    as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于视网膜实验，适当的基板配置创建如下：
- en: 'First, we create the configuration of the input layer of the substrate. As
    you may remember from the *The initial substrate configuration* section, the eight
    nodes of the input layer are placed within the XZ plane, which is orthogonal to
    the XY plane. Furthermore, to reflect the geometry of the retina space, the left
    object''s nodes need to be placed on the left side, and the right object''s nodes
    on the right side of the plane correspondingly. The bias node should be located
    at the center of the input nodes plane. Thus, the input layer is created as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建基板输入层的配置。如您在“*初始基板配置*”部分所记得，输入层的八个节点放置在XZ平面内，该平面垂直于XY平面。此外，为了反映视网膜空间的几何形状，左侧对象的节点需要放置在平面的左侧，右侧对象的节点相应地放置在平面的右侧。偏置节点应位于输入节点平面的中心。因此，输入层创建如下：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The two output nodes are located within the XY plane, which is orthogonal to
    the inputs plane. This substrate configuration allows natural substrate evolution
    by placing the discovered hidden nodes within the XY plane.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 两个输出节点位于XY平面内，该平面垂直于输入平面。这种基板配置通过将发现的隐藏节点放置在XY平面内，允许基板自然进化。
- en: 'The output layer is created as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出层创建如下：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we define the general substrate configuration parameters as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义基板的一般配置参数如下：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We allow the substrate to have connections from input-to-hidden, hidden-to-hidden,
    and hidden-to-output nodes. We specify that hidden nodes should use the signed
    sigmoid activation function, while output nodes should use the unsigned sigmoid
    activation function. We choose the unsigned sigmoid activation for the output
    nodes in order to have detector ANN output values in the range `[0,1]`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们允许基板从输入到隐藏层、隐藏层到隐藏层以及隐藏层到输出节点之间有连接。我们指定隐藏节点应使用带符号的Sigmoid激活函数，而输出节点应使用无符号的Sigmoid激活函数。我们选择无符号的Sigmoid激活函数用于输出节点，以便检测器ANN的输出值在范围
    `[0,1]` 内。
- en: In the next section, we discuss the implementation of the functions to evaluate
    the fitness of the solutions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论评估解决方案适应性的函数实现。
- en: Fitness evaluation
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适应性评估
- en: The neuroevolution process requires a means to evaluate the fitness of the genome
    population at each generation of evolution. The fitness evaluation in our experiment
    consists of two parts, which we discuss here.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 神经进化过程需要一种方法来评估每一代进化中基因组群体的适应性。在我们的实验中，适应性评估包括两个部分，我们在这里进行讨论。
- en: The eval_genomes function
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`eval_genomes` 函数'
- en: 'This function evaluates the fitness of the overall population. It has the following
    definition:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数评估整体群体的适应性。它具有以下定义：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `eval_genomes` function takes the list of CPPN genomes from the current
    population, the substrate configuration, the initialized test environment, and
    the ES-HyperNEAT hyperparameters as parameters.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval_genomes`函数接受当前种群中的CPPN基因组列表、底物配置、初始化的测试环境和ES-HyperNEAT超参数作为参数。'
- en: 'At the beginning of the code, we create an intermediary object to collect the
    evaluation results of each specific genome:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的开始部分，我们创建一个中间对象来收集每个特定基因组的评估结果：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After that, we start the loop that iterates over all genomes and evaluates
    each genome against a given test environment:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们开始循环遍历所有基因组，并对每个基因组进行给定测试环境的评估：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Finally, the function returns the evaluation results as a tuple that includes
    the best genome, the highest fitness score, and the list of all detection errors
    for each evaluated genome.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，函数返回一个元组，其中包含最佳基因组、最高适应度分数以及每个评估基因组的所有检测错误列表。
- en: The eval_individual function
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`eval_individual`函数'
- en: 'This function evaluates the fitness of each individual genome and has the following
    definition:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数评估每个个体的适应度，其定义如下：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It takes the CPPN genome to be evaluated, the substrate configuration, the test
    environment, and the ES-HyperNEAT hyperparameters as parameters. Using the provided
    parameters, we create the neural network configuration of the detector ANN and
    evaluate it against the given test environment. The function then returns the
    evaluation result.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受要评估的CPPN基因组、底物配置、测试环境和ES-HyperNEAT超参数作为参数。使用提供的参数，我们创建检测器ANN的神经网络配置，并对其在给定的测试环境中进行评估。然后，该函数返回评估结果。
- en: Modular retina experiment
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化视网膜实验
- en: Now we are ready to start experimenting against the test environment that simulates
    the modular retina problem space. In the next subsections, you will learn how
    to select appropriate hyperparameters and how to set up the environment and run
    the experiment. After that, we discuss the experiment results.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备开始针对模拟模块化视网膜问题空间的测试环境进行实验。在接下来的小节中，你将了解如何选择合适的超参数以及如何设置环境和运行实验。之后，我们将讨论实验结果。
- en: Hyperparameter selection
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超参数选择
- en: 'The hyperparameters are defined as a `Parameters` Python class, and the MultiNEAT
    library refers to it for the necessary configuration options. In the source code
    of the experiment runner script, we define a specialized function called `create_hyperparameters`,
    which encapsulates the logic of the hyperparameter initialization. Hereafter,
    we describe the most critical hyperparameters and the reasons for choosing these
    specific values:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 超参数定义为`Parameters` Python类，MultiNEAT库引用它以获取必要的配置选项。在实验运行脚本源代码中，我们定义了一个名为`create_hyperparameters`的专用函数，它封装了超参数初始化的逻辑。以下，我们将描述最关键的超参数以及选择这些特定值的原因：
- en: 'We decided to use a medium size for the CPPN genome population. This is done
    to intensify the evolution by providing a large space of options for the solution
    search from the beginning. The size of the population is defined as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们决定使用中等大小的CPPN基因组种群。这样做是为了通过从一开始就提供大量解决方案搜索选项来增强进化。种群的大小定义如下：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we define the number of species to be kept during evolution in the range`[5,15]`and
    set the species stagnation to `100` generations. This configuration allows us
    to have healthy diversity among species and keep them alive for long enough to
    produce the solution we are looking for:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在`[5,15]`范围内定义在进化过程中要保留的物种数量，并将物种停滞设置为`100`代。这种配置使我们能够在物种之间保持健康的多样性，并让它们存活足够长的时间，以产生我们正在寻找的解决方案：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We are interested in producing an extra-compact configuration of CPPN genomes.
    Thus, we have very small values of probabilities that control how often new nodes
    and connections will be introduced into the genome:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对生成一个非常紧凑的CPPN基因组配置感兴趣。因此，我们为控制新节点和连接在基因组中引入的频率设置了非常小的概率值：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The ES-HyperNEAT method is an extension of the HyperNEAT method. Thus, during
    the evolution, it changes the types of activation functions in the hidden and
    output nodes. In this experiment, to produce appropriate substrate configurations,
    we are interested in the following activation types, selected with equal probability:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ES-HyperNEAT方法是HyperNEAT方法的一个扩展。因此，在进化过程中，它会改变隐藏和输出节点中激活函数的类型。在这个实验中，为了产生适当的底物配置，我们对以下激活类型感兴趣，这些类型以相等的概率被选中：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we define the ES-HyperNEAT specific hyperparameters, which control
    how the substrate evolves. The following hyperparameters control the dynamics
    of the creation of nodes and connections within the substrate during evolution:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义了 ES-HyperNEAT 特定的超参数，这些参数控制着基质的进化方式。以下超参数控制着在进化过程中，基质内节点和连接创建的动态：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`params.DivisionThreshold` controls how many new nodes and connections are
    introduced into the substrate at each generation of evolution. `params.VarianceThreshold` determines
    how many nodes and connections are allowed to remain in the substrate after the
    pruning and extraction phase. See the *Quadtree information extraction and ES-HyperNEAT
    basics* section for more details about these thresholds.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`params.DivisionThreshold` 控制在每一代进化中引入基质的新节点和连接的数量。`params.VarianceThreshold`
    确定在修剪和提取阶段后允许保留在基质中的节点和连接的数量。有关这些阈值的更多详细信息，请参阅 *Quadtree 信息提取和 ES-HyperNEAT 基础*
    部分。'
- en: Working environment setup
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作环境设置
- en: 'In this experiment, we use the MultiNEAT Python library, which provides the
    implementation of the ES-HyperNEAT algorithm. Thus, we need to create an appropriate
    Python environment, which includes the MultiNEAT Python library and all necessary
    dependencies. This can be done using Anaconda by executing the following commands
    on the command line:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们使用提供 ES-HyperNEAT 算法实现的 MultiNEAT Python 库。因此，我们需要创建一个适当的 Python 环境，其中包括
    MultiNEAT Python 库和所有必要的依赖项。这可以通过在命令行中执行以下命令来完成：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: These commands create and activate the `rt_multineat` virtual environment with
    Python 3.5\. After that, they install the MultiNEAT Python library with the latest
    version, along with dependencies that are used by our code for result visualization.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令创建并激活了 Python 3.5 的 `rt_multineat` 虚拟环境。之后，它们安装了最新版本的 MultiNEAT Python 库，以及我们代码用于结果可视化的依赖项。
- en: Running the modular retina experiment
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行模块化视网膜实验
- en: 'At this stage, we already have the experiment runner script fully defined in
    the `retina_experiment.py` Python script. You can start the experiment by cloning
    the corresponding Git repository and running the script with the following commands:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经在 `retina_experiment.py` Python 脚本中完全定义了实验运行脚本。你可以通过克隆相应的 Git 仓库并运行以下命令来开始实验：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Do not forget to activate the appropriate virtual environment with the following
    command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记使用以下命令激活适当的虚拟环境：
- en: '**`conda activate rt_multineat`**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**`conda activate rt_multineat`**'
- en: 'The preceding command starts one trial of the experiment for 1,000 generations
    of evolution. After a particular number of generations, the successful solution
    should be found, and you will see the following output in the console:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令开始了一个实验，该实验进行了 1,000 代进化的试验。在特定的代数之后，应该找到成功的解决方案，你将在控制台看到以下输出：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see in the output, the successful solution was found in generation
    `949`. It was produced by a CPPN genome with 21 nodes and 22 connections among
    them. At the same time, the substrate that determines the topology of the detector
    ANN has 15 nodes and 28 connections between them. The successful solution was
    produced using random seed value `1569777981`. Using other random seed values
    may fail to produce successful solutions, or it will require many more generations
    of evolution.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在输出中看到的那样，成功的解决方案是在第 `949` 代找到的。它是由一个具有 21 个节点和 22 个节点之间连接的 CPPN 基因组产生的。同时，确定检测器
    ANN 拓扑结构的基质有 15 个节点和它们之间的 28 个连接。成功的解决方案是使用随机种子值 `1569777981` 产生的。使用其他随机种子值可能无法产生成功的解决方案，或者它将需要更多代的进化。
- en: 'Next, it is interesting to look at the plot of the average fitness and error
    during the evolution:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，观察进化过程中的平均适应度和误差的图表是很有趣的：
- en: '![](img/cbf8d9e1-8200-4f88-816c-a7fa49166931.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbf8d9e1-8200-4f88-816c-a7fa49166931.png)'
- en: The average fitness and error per generation
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 每代的平均适应度和误差
- en: You can see in the preceding plot that, during most of the evolution generations,
    the fitness score was very small (about 20), but suddenly, the successful CPPN
    genome was found, which produced an immediate evolutionary leap just in one generation.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前面的图表中看到，在大多数进化代数中，适应度得分非常小（大约为 20），但突然，找到了成功的 CPPN 基因组，它仅在一代内产生了立即的进化飞跃。
- en: 'The configuration of the successful CPPN genome is shown in the following diagram:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的 CPPN 基因组的配置如下所示：
- en: '![](img/3f032f44-2073-4c2d-b375-9b60f090b918.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f032f44-2073-4c2d-b375-9b60f090b918.png)'
- en: The CPPN phenotype graph of the successful genome
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 成功基因的CPPN表型图
- en: 'The diagram is extremely interesting because, as you can see, the configuration
    of the successful CPPN genome does not use all the available inputs (the gray
    squares) to produce outputs. Moreover, even more confounding is that it uses only
    the *x* coordinate of the input (node #0) and the *y* coordinate of the hidden
    (node #3) substrate nodes when deciding about exposing a connection between these
    substrate nodes. At the same time, both the *x* and *y* coordinates of the substrate
    output nodes are involved in the decision-making process (nodes #4 and #5).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 该图非常有趣，因为，正如你所看到的，成功的CPPN基因配置没有使用所有可用的输入（灰色方块）来产生输出。更重要的是，它甚至更加令人困惑，因为它在决定是否在这些基底层节点之间暴露连接时，只使用了输入（节点#0）的*x*坐标和隐藏（节点#3）基底层节点的*y*坐标。同时，基底层输出节点的*x*和*y*坐标都参与了决策过程（节点#4和#5）。
- en: When you look at the initial substrate configuration, which we presented earlier,
    you will see that the peculiarities we've mentioned are fully substantiated by
    the substrate topology. We placed the input nodes within the XZ plane. Thus, the
    *y* coordinate is not critical for them at all. At the same time, the hidden nodes
    located within the XY plane, with the *y* coordinate determining the distance
    from the inputs plane. Finally, the output nodes are also located within the XY
    plane. Their *x* coordinate determines the side of the retina to which each output
    node relates. Thus, for the output nodes, it is natural that both the *x* and
    *y* coordinates are included.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看我们之前提出的初始基底层配置时，你会发现我们提到的特性完全由基底层拓扑结构证实。我们将输入节点放置在XZ平面内。因此，对于它们来说，*y*坐标根本不重要。同时，位于XY平面内的隐藏节点，*y*坐标决定了从输入平面到节点的距离。最后，输出节点也位于XY平面内。它们的*x*坐标决定了每个输出节点相关的视网膜侧面。因此，对于输出节点来说，自然地，*x*和*y*坐标都包含在内。
- en: In the CPPN phenotype plot, the input nodes are marked with squares, the output
    nodes are filled circles, the bias node is a diamond, and the hidden nodes are
    empty circles.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在CPPN表型图中，输入节点用方块标记，输出节点用实心圆圈标记，偏置节点用菱形标记，隐藏节点用空心圆圈标记。
- en: 'Two output nodes in the CPPN diagram has the following meaning:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: CPPN图中两个输出节点有以下含义：
- en: The first node (8) provides the weight of the connection.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个节点（8）提供了连接的权重。
- en: The second node (9) determines whether the connection is expressed or not.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个节点（9）确定连接是否表达。
- en: 'The CPPN''s input nodes are defined as the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: CPPN的输入节点定义为以下：
- en: The first two nodes (0 and 1) set the point coordinates (*x*, *z*) in the input
    layer of the substrate.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前两个节点（0和1）设置了基底层输入层中的点坐标（*x*，*z*）。
- en: The next two nodes (2 and 3) set the point coordinates (*x*, *y*) in the hidden
    layer of the substrate.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的两个节点（2和3）设置了基底层隐藏层中的点坐标（*x*，*y*）。
- en: The next two nodes (4 and 5) set the point coordinates (*x*, *y*) in the output
    layer of the substrate.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的两个节点（4和5）设置了基底层输出层中的点坐标（*x*，*y*）。
- en: The last node (6) sets the Euclidean distance of the point in the input layer
    from the origin of the coordinates.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个节点（6）设置了输入层中点与坐标原点的欧几里得距离。
- en: 'However, you can see the most exciting part of the experiment results in the
    following diagram. It represents the configuration of the successful detector
    ANN:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以在下面的图中看到实验结果中最激动人心的部分。它代表了成功检测器ANN的配置：
- en: '![](img/ed3cd3e3-ba05-4ea1-9434-257132dfc46b.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ed3cd3e3-ba05-4ea1-9434-257132dfc46b.png)'
- en: The configuration of the detector ANN
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 检测器ANN的配置
- en: As in the previous plot, we mark the input nodes with squares, the output nodes
    with filled circles, the bias node as a diamond, and the hidden nodes as empty
    circles.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的图表一样，我们用方块标记输入节点，用实心圆圈标记输出节点，用菱形标记偏置节点，用空心圆圈标记隐藏节点。
- en: 'As you can see, we have two clearly separated modular structures on the left
    and right sides of the graph. Each module is connected to the corresponding inputs
    from the left (nodes #0, #1, #2, and #3) and the right (nodes #4, #5, #6, and
    #7) sides of the retina. Both modules have the same number of hidden nodes, which
    are connected to the corresponding output nodes: node #9 for the left side and
    node #10 for the right side of the retina. Also, you can see that connectivity
    patterns in the left and right modules are similar. The hidden node, #11, on the
    left has similar connection patterns to node #14 on the right, and the same can
    be said for nodes #12 and #13.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们在图的左右两侧有两个明显分离的模块化结构。每个模块都与视网膜左侧（节点#0、#1、#2和#3）和右侧（节点#4、#5、#6和#7）的相应输入相连。两个模块具有相同数量的隐藏节点，这些节点连接到相应的输出节点：视网膜左侧的节点#9和右侧的节点#10。你还可以看到左右模块的连接模式相似。左侧的隐藏节点#11具有与右侧节点#14相似的连接模式，同样，节点#12和#13也是如此。
- en: It is just amazing how the stochastic evolutionary process was able to discover
    such a simple and elegant solution. With the results of this experiment, we fully
    confirmed our hypothesis that the retina problem can be solved by the creation
    of modular detector ANN topologies.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 真是令人惊叹，随机进化过程能够发现如此简单而优雅的解决方案。通过这个实验的结果，我们完全证实了我们的假设，即视网膜问题可以通过创建模块化检测ANN拓扑结构来解决。
- en: More details about modular retina problem can be found in the original paper
    at [http://eplex.cs.ucf.edu/papers/risi_alife12.pdf](http://eplex.cs.ucf.edu/papers/risi_alife12.pdf).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于模块化视网膜问题的详细信息可以在原始论文[http://eplex.cs.ucf.edu/papers/risi_alife12.pdf](http://eplex.cs.ucf.edu/papers/risi_alife12.pdf)中找到。
- en: Exercises
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Try to run an experiment with different values of the random seed generator
    that can be changed in line 101 of the `retina_experiment.py` script. See if you
    can find successful solutions with other values.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试运行一个实验，改变`retina_experiment.py`脚本中第101行可以更改的随机种子生成器的不同值。看看你是否可以用其他值找到成功的解决方案。
- en: Try to increase the initial population size to 1,000 by adjusting the value
    of the `params.PopulationSize` hyperparameter. How did this affect the performance
    of the algorithm?
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试通过调整`params.PopulationSize`超参数的值将初始种群大小增加到1,000。这如何影响了算法的性能？
- en: Try to change the number of activation function types used during the evolution
    by setting the probability of its selection to 0\. It's especially interesting
    to see what happens when you exclude the `ActivationFunction_SignedGauss_Prob`
    and `ActivationFunction_SignedStep_Prob` activation types from selection.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试通过将选择概率设置为0来改变在进化过程中使用的激活函数类型的数量。当排除`ActivationFunction_SignedGauss_Prob`和`ActivationFunction_SignedStep_Prob`激活类型时，观察会发生什么特别有趣。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the neuroevolution method that allows the
    substrate configuration to evolve during the process of finding the solution to
    the problem. This approach frees the human designer from the burden of creating
    a suitable substrate configuration to the smallest details, allowing us to define
    only the primary outlines. The algorithm will automatically learn the remaining
    details of the substrate configuration during the evolution.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了神经进化方法，该方法允许在寻找问题解决方案的过程中使底物配置进化。这种方法使人类设计师从创建适合的最小细节的底物配置的负担中解放出来，使我们能够仅定义主要轮廓。算法将在进化过程中自动学习底物配置的剩余细节。
- en: Also, you learned about the modular ANN structures that can be used to solve
    various problems, including the modular retina problem. Modular ANN topologies
    are a very powerful concept that allows the reuse of the successful phenotype
    ANN module multiple times to build a complex hierarchical topology. Furthermore,
    you have had the chance to hone your skills with the Python programming language
    by implementing the corresponding solution using the MultiNEAT Python library.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你学习了可以使用模块化人工神经网络结构来解决各种问题，包括模块化视网膜问题。模块化ANN拓扑结构是一个非常强大的概念，它允许多次重用成功的表型ANN模块来构建复杂的分层拓扑。此外，你还有机会通过使用MultiNEAT
    Python库实现相应的解决方案来磨练你的Python编程技能。
- en: In the next chapter, we will discuss the fascinating concept of coevolution
    and how it can be used to simultaneously coevolve the solver and the objective
    function that is used for optimization. We will discuss the method of solution
    and fitness evolution, and you will learn how to apply it to the modified maze-solving
    experiment.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论协同进化的迷人概念以及如何将其用于同时协同进化用于优化的求解器和目标函数。我们将讨论解决方案和适应度演化的方法，并教会你如何将其应用于修改后的迷宫求解实验。
