- en: '*Chapter 17*: Controlling the Robot with a Phone and Python'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第17章*：使用手机和Python控制机器人'
- en: The robot we've been programming has many behaviors, but when you run some of
    them, they result in the robot stopping on the other side of the room. You could
    try to write code to return it back to you, but this may be complicated. We've
    also got a neat camera with some visual feedback available on what the robot is
    doing. Wouldn't it be neat to take control and drive the robot sometimes?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在编程的机器人有许多行为，但当你运行其中一些时，它们会导致机器人在房间的另一边停止。你可以尝试编写代码将其送回，但这可能很复杂。我们还有一个很棒的摄像头，可以提供一些视觉反馈，显示机器人正在做什么。难道不是很好奇有时可以控制并驾驶机器人吗？
- en: We've been launching commands to drive our robot from a **Secure Shell** (**SSH**)
    terminal, but the robot will be more exciting and more comfortable to demonstrate
    if you could start the commands via a menu. We can build upon the web **application
    programming interface** (**API**) code you made in [*Chapter 15*](B15660_15_Final_ASB_ePub.xhtml#_idTextAnchor344),
    *Voice Communication with a Robot Using Mycroft*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在通过**Secure Shell**（**SSH**）终端发送命令来驾驶我们的机器人，但如果可以通过菜单启动命令，这将使机器人更加有趣和舒适地进行演示。我们可以在[*第15章*](B15660_15_Final_ASB_ePub.xhtml#_idTextAnchor344)，“使用Mycroft与机器人进行语音通信”中制作的Web**应用程序编程接口**（**API**）代码的基础上进行构建。
- en: In this chapter, we will see how to create a menu system to choose behaviors
    designed for a phone. We will then use the touch surface to build a control system,
    with the camera in view. You will learn about phone-ready web apps and get control
    of the robot.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解如何创建一个菜单系统来选择为手机设计的操作。然后我们将使用触摸表面构建一个控制系统，摄像头在视野中。你将了解为手机准备的Web应用程序，并控制机器人。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: When speech control won't work—why we need to drive
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当语音控制不起作用时——为什么我们需要驾驶
- en: Menu modes—choosing your robot's behavior
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 菜单模式——选择你的机器人行为
- en: Choosing a controller—how are going to drive the robot, and why
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择控制器——我们将如何驾驶机器人，以及为什么
- en: Preparing the Raspberry Pi for remote driving—get the basic driving system going
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为远程驾驶准备Raspberry Pi——启动基本驾驶系统
- en: Making the robot fully phone-operable
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使机器人完全可通过手机操作
- en: Making the menu start when the Pi starts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使菜单在Pi启动时启动
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following items:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要以下物品：
- en: Your Raspberry Pi robot with the camera set up and the code from previous chapters
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置好摄像头并从上一章获取代码的Raspberry Pi机器人
- en: A touchscreen device such as a phone with Wi-Fi
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种带Wi-Fi的手机等触摸屏设备
- en: A wireless network
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无线网络
- en: The GitHub code for this chapter is at [https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter17](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter17).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的GitHub代码位于[https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter17](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter17)。
- en: Use the `0_starting_point` folder to find the complete code from the previous
    chapters and the `full_system` folder on GitHub for this chapter's full code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`0_starting_point`文件夹查找上一章的完整代码，以及GitHub上的`full_system`文件夹以获取本章的完整代码。
- en: 'Check out the following video to see the code in action: [https://bit.ly/2Kb7rp8](https://bit.ly/2Kb7rp8)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：[https://bit.ly/2Kb7rp8](https://bit.ly/2Kb7rp8)
- en: When speech control won't work – why we need to drive
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当语音控制不起作用时 – 为什么我们需要驾驶
- en: In [*Chapter 15*](B15660_15_Final_ASB_ePub.xhtml#_idTextAnchor344), *Voice Communication
    with a Robot Using Mycroft*, we built a Mycroft system to launch behaviors. If
    you have tried to build intents to make the robot stop in time or drive left or
    right, you will have probably noticed that it takes some time to respond even
    with the clearest speaking.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第15章*](B15660_15_Final_ASB_ePub.xhtml#_idTextAnchor344)，“使用Mycroft与机器人进行语音通信”，我们构建了一个Mycroft系统来启动行为。如果你尝试构建意图让机器人及时停止或向左或向右行驶，你可能已经注意到，即使是最清晰的说话也需要一些时间来响应。
- en: Speech control also only really works in a quiet room. If your robot is outside
    (you would like to drive it somewhere), this is not useful.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 语音控制也仅在安静的环境中真正有效。如果你的机器人在外面（你希望将其驶往某处），这就不太有用。
- en: Mycroft is also utterly dependent on having access to the internet. It is one
    thing to have a small shared network for a robot and a controller; it's another
    to always require internet access, which can become tricky when not at your home,
    school, or lab.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Mycroft完全依赖于能够访问互联网。对于机器人和控制器来说，有一个小型的共享网络是一回事；但总是需要互联网访问则是另一回事，当你不在家、学校或实验室时，这可能会变得很棘手。
- en: Using an SSH session to log in to a robot, then typing commands to start and
    stop behaviors works well during testing stages, but it can be slow and cumbersome.
    In demonstration conditions, mistyping a command or just restarting the SSH session
    is time-consuming.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SSH会话登录到机器人，然后输入命令来启动和停止行为，在测试阶段效果良好，但可能会很慢且繁琐。在演示条件下，误输入命令或只是重新启动SSH会话都会很耗时。
- en: A phone-targeted browser app can be responsive, giving you tight control over
    the robot's movements. With a local network, it won't need external internet access.
    You can use this to drive a robot back to you after a behavior has run and you've
    stopped it, and it can be used to halt errant behavior. And with a bit of thought,
    it can be used to deliver useful—or plain interesting—feedback on what your robot
    is doing.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 针对手机的目标浏览器应用可以响应，让你能够紧密控制机器人的动作。在有本地网络的情况下，它不需要外部互联网访问。你可以使用它来在行为运行后停止机器人并将其开回你身边，也可以用来停止错误的行为。经过一些思考，它还可以用来提供有用的——或者仅仅是有趣的——关于你的机器人正在做什么的反馈。
- en: Menu modes – choosing your robot's behavior
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 菜单模式 - 选择你的机器人行为
- en: Our book has introduced quite a collection of robot behaviors and invited you
    to create more. We've talked about how SSH can be cumbersome to start robot programs—even
    just remembering the options you have or pressing the *Ctrl* + *C* combination
    to stop can be frustrating.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的书介绍了一系列机器人行为，并邀请你创建更多。我们讨论了SSH启动机器人程序可能会很繁琐——甚至只是记住你有的选项或按下*Ctrl* + *C*组合来停止都可能会让人沮丧。
- en: In this section, we are going to create a menu system to select them. A convenient
    and phone-friendly way to do this is to serve it to the phone's browser, so we
    take that approach with our robot. We will also use a desktop browser to test
    this code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个菜单系统来选择它们。一种方便且适合手机的方式是将它提供给手机的浏览器，因此我们采用了这种方法来处理我们的机器人。我们还将使用桌面浏览器来测试此代码。
- en: We can extend the system we built in the *Starting a behavior remotely* section
    of [*Chapter 15*](B15660_15_Final_ASB_ePub.xhtml#_idTextAnchor344), *Voice Communication
    with a Robot Using Mycroft*, adding a **user interface** (**UI**). We'll make
    this UI as templates, with some placeholders replaced by code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在[*第15章*](B15660_15_Final_ASB_ePub.xhtml#_idTextAnchor344)中“远程启动行为”部分的系统中扩展，添加**用户界面**（**UI**）。我们将使用模板制作此UI，其中一些占位符将由代码替换。
- en: 'Let''s take a look in the following diagram at how this system will work:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下图表，看看这个系统将如何工作：
- en: '![](img/B15660_17_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_17_01.jpg)'
- en: Figure 17.1 – How the control server and menu system will work
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.1 – 控制服务器和菜单系统的工作方式
- en: '*Figure 17.1* shows an overview of the system. Here''s how it works:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17.1*显示了系统的概述。以下是它是如何工作的：'
- en: The **client browser** (a phone or computer) makes a page request via **Wi-Fi**
    to the **web server** on the robot for a page to display.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**客户端浏览器**（手机或电脑）通过**Wi-Fi**向机器人上的**网络服务器**发送页面请求以显示页面。'
- en: 'The **web server** uses **robot modes** to get the mode list: a list of scripts
    it can start.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**网络服务器**使用**机器人模式**来获取模式列表：它可以启动的脚本列表。'
- en: The **web server** sends this mode list to a **template** to render it into
    the menu page and send that rendered menu page to the user.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**网络服务器**将此模式列表发送到**模板**以将其渲染成菜单页面，并将渲染后的菜单页面发送给用户。'
- en: In the browser, when you touch or click the menu item links in the page, they
    make control requests to the **web server**.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中，当你触摸或点击页面中的菜单项链接时，它们会向**网络服务器**发送控制请求。
- en: The `run` and `stop` to the **robot modes** system.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向**机器人模式**系统发送`run`和`stop`命令。
- en: The **robot modes** system starts/stops the behavior scripts.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**机器人模式**系统启动/停止行为脚本。'
- en: The **control server** sends a status back to the **client browser** to say
    it's been handled.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**控制服务器**向**客户端浏览器**发送状态信息，表示它已被处理。'
- en: Let's start by extending the list of scripts (modes) and how the system handles
    them.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先扩展脚本（模式）列表以及系统如何处理它们。
- en: Managing robot modes
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理机器人模式
- en: We will revisit the code made in [*Chapter 15*](B15660_15_Final_ASB_ePub.xhtml#_idTextAnchor344),
    *Voice Communication with a Robot Using Mycroft*, extend the list of modes to
    run, and add a menu configuration.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新审视在[*第15章*](B15660_15_Final_ASB_ePub.xhtml#_idTextAnchor344)，“使用Mycroft与机器人进行语音通信”中编写的代码，扩展要运行的模式列表，并添加菜单配置。
- en: 'Let''s expand the number of items our mode system knows about, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展我们的模式系统所知道的项目数量，如下所示：
- en: Open the file called `robot_modes.py`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开名为`robot_modes.py`的文件。
- en: 'Find the `mode_config` variable in this file. We can extend it with a few more
    behaviors, as illustrated in the following code snippet:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件中找到`mode_config`变量。我们可以通过以下代码片段扩展它，添加更多行为：
- en: '[PRE0]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After the `mode_config` variable, we add a list configuring the menu. The order
    will match menu items on a screen. Each item has a `mode_name` setting`—`matching
    the short slug in the `mode_config` variable, and `text`—the human-readable label
    for the menu option, as illustrated in the following code snippet:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mode_config`变量之后，我们添加一个配置菜单的列表。顺序将与屏幕上的菜单项匹配。每个项目都有一个`mode_name`设置——与`mode_config`变量中的简短缩略名匹配，以及`text`——菜单选项的易读标签，如下面的代码片段所示：
- en: '[PRE1]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we want to add a behavior to the menu, we must add it to both the `menu_config`
    and the `mode_config` variables.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们想在菜单中添加一个行为，我们必须将其添加到`menu_config`和`mode_config`变量中。
- en: 'To allow a menu user to choose a new mode without pressing a `run` method cope
    with this by stopping any existing process, as follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了允许菜单用户在不按下`run`方法的情况下选择新的模式，我们可以通过停止任何现有进程来处理这个问题，如下所示：
- en: '[PRE2]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This file will act as a configuration, and you can expand it to run other code.
    We can test this now.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此文件将作为配置文件使用，你可以扩展它来运行其他代码。我们现在可以测试一下。
- en: Upload `robot_modes.py` to the robot. You should already have the [*Chapter
    15*](B15660_15_Final_ASB_ePub.xhtml#_idTextAnchor344), *Voice Communication with
    a Robot Using Mycroft*, `control_server.py` file uploaded.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`robot_modes.py`上传到机器人。你应该已经上传了[*第15章*](B15660_15_Final_ASB_ePub.xhtml#_idTextAnchor344)，“使用Mycroft与机器人进行语音通信”的`control_server.py`文件。
- en: Run this on the Pi with `python3 control_server.py`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Pi上使用`python3 control_server.py`运行此代码。
- en: 'As we saw in [*Chapter 15*](B15660_15_Final_ASB_ePub.xhtml#_idTextAnchor344),
    *Voice Communication with a Robot Using Mycroft*, we will use the `curl` command
    to make a request, like this:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们在[*第15章*](B15660_15_Final_ASB_ePub.xhtml#_idTextAnchor344)，“使用Mycroft与机器人进行语音通信”中看到的，我们将使用`curl`命令来发送请求，如下所示：
- en: '[PRE3]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This should start the **light-emitting diodes** (**LEDs**) flashing on the robot.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会启动机器人上的**发光二极管**（**LEDs**）闪烁。
- en: 'Let''s change behavior—this should stop the current behavior and start a new
    one. Run the following code:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们改变行为——这将停止当前行为并启动一个新的行为。运行以下代码：
- en: '[PRE4]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The LEDs should stop, and assuming the motors are turned on, the head should
    start moving.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: LED应该停止闪烁，假设电机已经打开，头部应该开始移动。
- en: 'Let''s stop the robot by running the following code:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过运行以下代码来停止机器人：
- en: '[PRE5]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have added some further modes and configuration to `robot_modes.py` to describe
    those modes, and tested them. Let's check for any problems.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`robot_modes.py`中添加了一些额外的模式和配置来描述这些模式，并进行了测试。让我们检查是否有任何问题。
- en: Troubleshooting
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'When requests to the menu sever fail, it can output error codes in the response.
    There are only three error codes we make use of in our system, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当对菜单服务器的请求失败时，它可以在响应中输出错误代码。在我们的系统中，我们只使用了以下三个错误代码：
- en: '`200`—This means that the server thinks everything is OK. There may still be
    a logic problem, but it''s not caused a failure.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200`——这意味着服务器认为一切正常。可能仍然存在逻辑问题，但并未导致失败。'
- en: '`404`—This is shown when the server couldn''t find a route. This means you
    may have a typo either in the request you made or in the routers on the server
    code. Check that they match and try again.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`404`——当服务器找不到路由时显示。这意味着你可能在你发出的请求或服务器代码中的路由器中有一个拼写错误。检查它们是否匹配并再次尝试。'
- en: '`500`—This means that the server failed in some way. It is usually accompanied
    by a traceback/exception on the server. This can then be treated as a normal Python
    error.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`500`——这意味着服务器以某种方式失败了。这通常伴随着服务器上的回溯/异常。这可以被视为一个正常的Python错误。'
- en: Now that we have the mode configuration lists ready, we need the web service
    to display it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了模式配置列表，我们需要网络服务来显示它。
- en: The web service
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络服务
- en: In [*Chapter 15*](B15660_15_Final_ASB_ePub.xhtml#_idTextAnchor344), *Voice Communication
    with a Robot Using Mycroft*, we'd already wired `robot_modes.py` into the `control_server.py`
    Flask web server. We have used Flask in [*Chapter 13*](B15660_13_Final_ASB_ePub.xhtml#_idTextAnchor283),
    *Robot Vision – Using a Pi Camera and OpenCV*, to render templates with a video
    box. In this section, we will make a menu template to show the user their options.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第15章*](B15660_15_Final_ASB_ePub.xhtml#_idTextAnchor344)，“使用 Mycroft 与机器人进行语音通信”，我们已经在
    `control_server.py` Flask 网络服务器中连接了 `robot_modes.py`。我们在 [*第13章*](B15660_13_Final_ASB_ePub.xhtml#_idTextAnchor283)，“机器人视觉——使用
    Pi 摄像头和 OpenCV”，使用了 Flask 来渲染带有视频框的模板。在本节中，我们将创建一个菜单模板以显示用户的选项。
- en: 'Let''s make the necessary changes to render the template first, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先进行必要的更改以渲染模板，如下所示：
- en: Open `control_server.py`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `control_server.py`。
- en: 'Extend the imports of Flask to include `render_template`, as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Flask 的导入扩展到包括 `render_template`，如下所示：
- en: '[PRE6]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we will have a style sheet we are changing, we need to stop devices holding
    a stale, cached copy of the sheet. We can do this by adding a header to all responses,
    like this:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将更改样式表，我们需要停止持有过时缓存的表单的设备。我们可以通过向所有响应添加标题来实现这一点，如下所示：
- en: '[PRE7]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We now need to add the route that shows our menu. We will make a template called
    `menu.html`, which uses the `menu_config` variable to display. Most of our modes
    need this. Let''s add the code to render the template, as follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要添加显示我们菜单的路由。我们将创建一个名为 `menu.html` 的模板，它使用 `menu_config` 变量来显示。我们的大部分模式都需要这个。让我们添加渲染模板的代码，如下所示：
- en: '[PRE8]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We now have code to render the template building on code we already had to handle
    `run` and `stop` requests. However, before we can run this service, we need to
    provide the template, `menu.html`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了渲染模板的代码，它是基于我们已有的处理 `run` 和 `stop` 请求的代码。然而，在我们能够运行此服务之前，我们需要提供模板，即
    `menu.html`。
- en: The template
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板
- en: Our HTML template defines our display and lets us separate how the robot menu
    looks from how to handle the control system. This template combines HTML (seen
    in [*Chapter 13*](B15660_13_Final_ASB_ePub.xhtml#_idTextAnchor283), *Robot Vision
    – Using a Pi Camera and OpenCV*, and [*Chapter 14*](B15660_14_Final_ASB_ePub.xhtml#_idTextAnchor315),
    *Line-Following with a Camera in Python*) and the `templates` folder from [*Chapter
    15*](B15660_15_Final_ASB_ePub.xhtml#_idTextAnchor344), *Voice Communication with
    a Robot Using Mycroft*—we will add our menu template here. We could add further
    styling to this template; for now, we'll keep it simple.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 HTML 模板定义了我们的显示，并让我们将机器人菜单的外观与处理控制系统的方法分开。此模板结合了 [*第13章*](B15660_13_Final_ASB_ePub.xhtml#_idTextAnchor283)，“机器人视觉——使用
    Pi 摄像头和 OpenCV” 和 [*第14章*](B15660_14_Final_ASB_ePub.xhtml#_idTextAnchor315)，“Python
    中的摄像头跟随线” 中看到的 HTML，以及 [*第15章*](B15660_15_Final_ASB_ePub.xhtml#_idTextAnchor344)，“使用
    Mycroft 与机器人进行语音通信” 中的 `templates` 文件夹——我们将在这里添加我们的菜单模板。我们可以进一步美化此模板；现在，我们将保持其简单性。
- en: 'Make a file called `templates`/`menu.html` and then proceed as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `templates`/`menu.html` 的文件，然后按照以下步骤进行：
- en: 'Our template starts with a header that sets the page title and uses the same
    jQuery tool we saw before, as illustrated in the following code snippet:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的模板从设置页面标题的标题开始，并使用我们之前看到的相同的 jQuery 工具，如下面的代码片段所示：
- en: '[PRE9]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The body of our template has the `My Robot Menu` heading. Feel free to change
    this to your robot''s name. The code is shown in the following snippet:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们模板的主体有 `My Robot Menu` 标题。你可以随意将其更改为你的机器人名称。代码如下所示：
- en: '[PRE10]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we have a space for a message; it''s empty now though, as you can see
    here:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，有一个用于消息的空间；现在它是空的，正如你在这里可以看到的：
- en: '[PRE11]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The next section is a list—that is the menu itself. We use the `<ul>` tag and
    then a `for` loop, which creates a list item with a link for each menu item. The
    double brackets `{{ }}` are used to surround a placeholder, that will be replaced
    when run. It uses the `mode_name` setting and `text` to make that link, combining
    `/run` with the mode name, as illustrated in the following code snippet:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个部分是一个列表——即菜单本身。我们使用 `<ul>` 标签然后是一个 `for` 循环，它为每个菜单项创建一个带有链接的列表项。双大括号 `{{
    }}` 用于包围一个占位符，当运行时将被替换。它使用 `mode_name` 设置和 `text` 来创建该链接，将 `/run` 与模式名称结合，如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Before closing our list, we need to add one more menu item—the **Stop** button,
    as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关闭我们的列表之前，我们需要添加一个额外的菜单项——**停止**按钮，如下所示：
- en: '[PRE13]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We talked about handling the `run` action in some JavaScript code. The following
    code makes POST requests sending data to the web server, and then updates the
    message from the response. We need to put it in `<script>` tags, as follows:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 JavaScript 代码中讨论了处理 `run` 动作。以下代码发送数据到 Web 服务器并从响应中更新消息的 POST 请求。我们需要将其放在
    `<script>` 标签中，如下所示：
- en: '[PRE14]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we can close our HTML document, like this:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以像这样关闭我们的 HTML 文档：
- en: '[PRE15]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The nice thing with a template such as this is that you can preview this code
    in a browser without the server and make sense of how it should look. The following
    screenshot shows it in preview mode:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 模板如这样的好处是，您可以在浏览器中预览此代码，而无需服务器，并理解它应该如何看起来。以下截图显示了它在预览模式下的样子：
- en: '![](img/B15660_17_02.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_17_02.jpg)'
- en: Figure 17.2 – Previewing the template
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.2 – 预览模板
- en: When you view the preview, as shown in *Figure 17.2*, the template placeholders
    are showing as the browser doesn't know how to render them.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当您查看预览，如图 *图 17.2* 所示，模板占位符会显示，因为浏览器不知道如何渲染它们。
- en: You need to run the app to see it properly rendered.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要运行应用才能正确渲染。
- en: Running it
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行它
- en: 'Upload the `robot_modes.py` and `control_server.py` files to the robot, and
    then the `templates` folder. On the Raspberry Pi, via SSH, you can start it with
    the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `robot_modes.py` 和 `control_server.py` 文件上传到机器人，然后是 `templates` 文件夹。在 Raspberry
    Pi 上，通过 SSH，您可以使用以下命令启动它：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can now point your browser at your robot (`http://myrobot.local:5000/`)
    to see the menu. The following screenshot shows how it should look:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以将浏览器指向您的机器人（`http://myrobot.local:5000/`）以查看菜单。以下截图显示了它应该看起来是什么样子：
- en: '![](img/B15660_17_03.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_17_03.jpg)'
- en: Figure 17.3 – My Robot Menu in a browser
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.3 – 浏览器中的我的机器人菜单
- en: '*Figure 17.3* now shows the list rendered. We now see all the menu items instead
    of the template placeholders. You should be able to click a mode and see the robot
    start that behavior. Clicking `robot_modes.py` code to send the equivalent of
    a *Ctrl* + *C* action to the running behavior script, making it stop.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17.3* 现在显示了渲染的列表。我们现在看到所有菜单项而不是模板占位符。您应该能够点击一个模式并看到机器人启动该行为。点击 `robot_modes.py`
    代码将发送相当于 *Ctrl* + *C* 动作到运行的行为脚本，使其停止。'
- en: 'When you click a behavior or stop, it shows the output in the message area,
    as shown in the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击一个行为或停止时，它会在消息区域显示输出，如图下所示截图：
- en: '![](img/B15660_17_04.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_17_04.jpg)'
- en: Figure 17.4 – The stopped message
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.4 – 停止消息
- en: '*Figure 17.4* shows the menu again. I''ve clicked the **Stop** button, so the
    menu shows the **Stopped** response message.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17.4* 再次显示了菜单。我已经点击了**停止**按钮，因此菜单显示了**停止**响应消息。'
- en: 'Notice in the following code snippet that the behavior''s outputs—its `print`
    statements—are coming out in the web server console:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下代码片段中行为输出的 `print` 语句出现在 Web 服务器控制台中：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You need to press *Ctrl* + *C* on the Pi to exit this menu server app.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在 Pi 上按下 *Ctrl* + *C* 来退出此菜单服务器应用。
- en: Important note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This tiny robot web app has no security mechanism, authentication, or passwords.
    It is beyond this book's scope but is a serious consideration worth further research
    if you plan to use this on shared Wi-Fi.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '这个微型的机器人 Web 应用没有安全机制、身份验证或密码。这超出了本书的范围，但如果您计划在共享 Wi-Fi 上使用它，这是一个值得进一步研究的严肃考虑。 '
- en: There are ways to get the console output from a script onto the page. I recommend
    looking at the additional reading recommendations in the *Further reading* section
    for Flask.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有方法可以将脚本的控制台输出放到页面上。我建议查看 *进一步阅读* 部分的附加阅读推荐，以了解 Flask。
- en: Troubleshooting
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'Hopefully, this all works, but if you have any problems try the following steps:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这一切都能正常工作，但如果您有任何问题，请尝试以下步骤：
- en: The output log shows the return codes from the web system. You can use these
    status codes—as you've seen before—to troubleshoot.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出日志显示了来自 Web 系统的返回代码。您可以使用这些状态代码——如您之前所见——来排除故障。
- en: '`200`—The system thinks everything is OK. If it failed to run something, check
    the `run` function.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200`—系统认为一切正常。如果它未能运行某些内容，请检查 `run` 函数。'
- en: '`404`—Not found. Have you matched the routes?'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`404`—未找到。您是否匹配了路由？'
- en: '`500`—You should see a Python error with this too.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`500`—您也应该看到与此相关的 Python 错误。'
- en: If the render shows the display `{ item.text }`, this needs double curly brackets
    for the template system to work.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果渲染显示 `{ item.text }`，则需要使用双大括号，以便模板系统正常工作。
- en: 'If you see an error such as `jinja2.exceptions.TemplateSyntaxError: unexpected
    ''<''`, then you''ll need to verify you have typed out the preceding template—you
    are likely to have missed a closing curly bracket ( `}`).'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果你看到像`jinja2.exceptions.TemplateSyntaxError: unexpected ''<''`这样的错误，那么你需要验证你是否正确地输出了前面的模板——你很可能会遗漏了一个闭合的大括号（`}`）。'
- en: You now have a menu system to start different robot behaviors and stop them.
    You can point your phone at it—although it's not particularly phone-friendly yet.
    We have only scratched the surface of this, and this system is quite rudimentary.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在有一个菜单系统来启动不同的机器人行为并停止它们。你可以将手机指向它——尽管它目前还不是特别适合手机。我们只是刚刚触及了这一点，这个系统相当基础。
- en: We'll start looking at a more interesting phone interface for driving the robot,
    but we can first look at options other than smartphones.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始查看一个更有趣的手机界面来控制机器人，但我们可以先看看除了智能手机之外的其他选项。
- en: Choosing a controller — how we are going to drive the robot, and why
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择控制器——我们将如何驾驶机器人，以及为什么
- en: We want to be able to control our robot with something that is handheld and
    wireless. Trailing a wire to our robot would make little sense. Having seen how
    our robot drives in [*Chapter 7*](B15660_07_Final_ASB_ePub.xhtml#_idTextAnchor131),
    *Drive and Turn – Moving Motors with Python*, we will want a control system that
    directly affects the wheels.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够用手持无线设备来控制我们的机器人。给机器人拖一根线没什么意义。在看过我们的机器人在[*第 7 章*](B15660_07_Final_ASB_ePub.xhtml#_idTextAnchor131)，“使用
    Python 驱动和转向 – 移动电机”中的驾驶方式后，我们将需要一个直接影响轮子的控制系统。
- en: One way to do this would be to use a Bluetooth joypad. There are a large number
    of these on the market, which may require specialist drivers to read. Bluetooth
    has a habit of dropping pairings at inopportune times.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的办法之一是使用蓝牙手柄。市场上有很多这样的手柄，可能需要专业的驱动程序来读取。蓝牙有时会在不合适的时候断开配对。
- en: Some joypads use a custom wireless dongle; these are far more reliable than
    Bluetooth but have a dongle that doesn't fit very nicely on the robot.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一些手柄使用定制的无线扩展器；这些比蓝牙更可靠，但扩展器在机器人上不太合适。
- en: 'However, you already have a handheld device in your pocket: your phone. It
    has a touchscreen, capable of reading finger movements. With a bit of the right
    code, you can display the video between controller bars, creating a kind of robotic
    *periscope* you can drive around and see (it''s quite tricky to drive on camera—harder
    than overhead). We''ve already been building web applications for our robot to
    access via Wi-Fi, and most phones can connect to that. So, instead of going out
    and buying a new joypad, we will make a web app that your phone can access to
    drive the robot and see a robot''s-eye view of the world.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你口袋里已经有一个手持设备了：你的手机。它有一个触摸屏，能够读取手指动作。通过一些正确的代码，你可以在控制器条之间显示视频，创建一种可以驾驶并观察的机器人*潜望镜*（在相机上驾驶相当困难——比从上方驾驶更难）。我们已经为机器人构建了可以通过
    Wi-Fi 访问的网页应用，而大多数手机都可以连接到那个应用。因此，我们不会出去买一个新的手柄，而是将制作一个手机可以访问的网页应用来驾驶机器人并看到机器人的视角。
- en: Design and overview
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计和概述
- en: 'To make a phone web app, a little bit of design on how we would expect this
    to work is needed. This design could be as simple as a pen drawing on a scrap
    of paper or using a drawing tool to get professional-looking results. The next
    screenshot shows a screen mockup of this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要制作一个手机网页应用，我们需要对如何期望它工作有一些设计。这个设计可能只是一个在纸条上用笔画的草图，或者使用绘图工具来获得专业的外观。下一张截图显示了这个的原型：
- en: '![](img/B15660_17_05.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_17_05.jpg)'
- en: Figure 17.5 – Screen mockup of driving web app
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.5 – 驾驶网页应用的屏幕截图
- en: The mockup in *Figure 17.5* shows a mobile phone screen in landscape mode. The
    top of the screen has an **Exit** button, and we can set this up to go to our
    menu after instructing the app to exit.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17.5* 中的原型显示了横幅模式下的手机屏幕。屏幕顶部有一个**退出**按钮，我们可以将其设置为在指示应用退出后转到我们的菜单。'
- en: 'The middle of the screen has a video feed from the robot, using the mechanism
    from the *Building a Raspberry Pi camera stream app* in [*Chapter 13*](B15660_13_Final_ASB_ePub.xhtml#_idTextAnchor283),
    *Robot Vision – Using a Pi Camera and OpenCV*. The left and right have sliders.
    The next screenshot shows how this works:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕中间有一个来自机器人的视频流，使用了[*第 13 章*](B15660_13_Final_ASB_ePub.xhtml#_idTextAnchor283)，“机器人视觉
    – 使用 Pi 相机和 OpenCV”中“构建 Raspberry Pi 相机流应用”的机制。左右两侧有滑块。下一张截图显示了它是如何工作的：
- en: '![](img/B15660_17_06.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_17_06.jpg)'
- en: Figure 17.6 – Slider return to middle behavior
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.6 – 滑块返回中间行为
- en: '*Figure 17.6* shows the slider mechanism. As with an analog joystick, you can
    drag the sliders to any position on their track with touches, and when let go,
    they will spring back to the middle.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17.6* 展示了滑动机制。与模拟摇杆类似，您可以通过触摸将滑块拖动到其轨道上的任何位置，并且当松开时，它们会弹回到中间。'
- en: Note that they don't immediately drop to the middle when let go but animate
    back to this over a few frames. We'll need a little math to make that happen in
    our code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它们不会立即回到中间，而是在几帧内动画回到这个位置。我们需要一点数学知识来在我们的代码中实现这一点。
- en: These sliders let you drive the robot tank-style (with a joypad, you could use
    two analog sticks for this). Each slider controls the speed of a motor. While
    this sounds tricky (not like driving a car), it is an elegant way to drive a two-wheeled
    robot with a little practice. The further away from the middle you slide a slider,
    the faster the associated motor will go. We will also ensure that the robot motors
    will stop after a second if communication is lost.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这些滑块让您能够以坦克式（使用摇杆，您可以使用两个模拟摇杆进行此操作）驾驶机器人。每个滑块控制一个电机的速度。虽然这听起来很复杂（不像开车），但通过一点练习，这是一种优雅地驾驶两轮机器人的方式。滑块离中间越远，相关的电机速度越快。我们还将确保如果通信丢失，机器人电机将在一秒后停止。
- en: 'This control of left speed and right speed is the same control system your
    behaviors have been using throughout the book, but has been made interactive.
    The next diagram shows some of the motions needed for typical moves:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种左右速度的控制与您在整本书中一直在使用的相同控制系统，但已经变得交互式。下一张图显示了典型移动所需的一些动作：
- en: '![](img/B15660_17_07.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15660_17_07.jpg)'
- en: Figure 17.7 – Common moves on two sliders
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.7 – 两个滑块上的常见动作
- en: The red dots in *Figure 17.7* represent where your thumb is touching the screen.
    By sliding both forward the robot will drive forward, and the further you slide
    them, the faster it will go. A backward action slides them both back. To spin
    the robot, slide them in opposite directions. To drive forward and a little left
    or right, you slide both forward but bring the right slider a little higher than
    the left. You are also able to compensate for veer this way.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17.7* 中的红色点代表您的拇指触摸屏幕的位置。通过同时向前滑动，机器人将向前行驶，而且您滑得越远，它行驶得越快。向后动作将它们都向后滑动。要旋转机器人，将它们向相反方向滑动。要向前行驶并稍微向左或向右，同时向前滑动，但将右侧滑块稍微抬得比左侧高。您还可以为此方向进行补偿。'
- en: We have a nice user interface design. To start building this, we will plan the
    code blocks we will need, and write the code to make them work in the real world.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个很好的用户界面设计。为了开始构建这个，我们将规划所需的代码块，并编写使它们在现实世界中工作的代码。
- en: Preparing the Raspberry Pi for remote driving—get the basic driving system going
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为远程驾驶准备Raspberry Pi——启动基本驾驶系统
- en: 'Our Raspberry Pi has already been able to run web services, using Flask to
    create a menu server and video servers. We can use image and control queues to
    make a behavior interact with a web server. We are going to reuse these capabilities.
    In the phone app, the slider controls will need to be smart. The next diagram
    shows the parts of our manual drive system:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Raspberry Pi已经能够运行网络服务，使用Flask创建菜单服务器和视频服务器。我们可以使用图像和控制队列使行为与网络服务器交互。我们将重用这些功能。在手机应用中，滑块控制需要智能。下一张图显示了我们的手动驱动系统的各个部分：
- en: '![](img/B15660_17_08.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15660_17_08.jpg)'
- en: Figure 17.8 – The system overview of a manual drive app
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.8 – 手动驱动应用系统概述
- en: The dashed boxes in *Figure 17.8* show where the code is running, with the top
    dashed box being code running on the phone, and the lower box being code running
    on the Raspberry Pi in the robot. Inside the dashed boxes, the boxes with solid
    outlines are blocks of code or systems our code will need. At the bottom layer
    of *Figure 17.8*, the **Robot** box accepts the **stop motors** and **set motor
    speed** calls. These are from the **Behavior** box based on timeouts or the **control
    message queue** from the **Flask Web Server**. Meanwhile, the **Behavior** loop
    will also be taking **image frames** from the **camera**, encoding them and pushing
    them onto the **display frame queue**.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17.8* 中的虚线框显示了代码的运行位置，顶部的虚线框是手机上运行的代码，下方的框是机器人在Raspberry Pi上运行的代码。在虚线框内部，带有实线轮廓的框是代码块或系统，我们的代码将需要它们。在*图17.8*
    的底层，**机器人**框接受**停止电机**和**设置电机速度**的调用。这些来自**行为**框，基于超时或来自**Flask Web服务器**的**控制消息队列**。同时，**行为**循环也将从**摄像头**获取**图像帧**，对它们进行编码并将它们推送到**显示帧队列**。'
- en: The next layer up is the **Flask Web Server**. This server consumes the **display
    frame queue** supplying frames to the multi-part **image feed**. The Flask server
    will handle **control requests** and push them onto the **control message queue**.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个层次是**Flask Web服务器**。该服务器消耗**显示帧队列**，为多部分的**图像流**提供帧。Flask服务器将处理**控制请求**并将它们推送到**控制消息队列**。
- en: A **Page Script** handles **slider updates** and turns them into **control requests**
    using the jQuery library. The **Slider Gadget** turns **touches** into **slider
    updates** (it will be doing animation and converting for this).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**页面脚本**处理**滑块更新**，并使用jQuery库将它们转换为**控制请求**。**滑块小部件**将**触摸**转换为**滑块更新**（它将进行动画转换）。'
- en: The page itself uses an `img` tag to display the **video** feed, as before,
    and places the slider widgets. The **Exit** button makes a control request.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 页面本身使用`img`标签来显示**视频**流，就像之前一样，并放置滑块小部件。**退出**按钮会发出控制请求。
- en: The **Page Script** and **Slider Gadget** will require JavaScript and **Cascading
    Style Sheets** (**CSS**) programming. Before we start that, we need to take the
    image core from [*Chapter 14*](B15660_14_Final_ASB_ePub.xhtml#_idTextAnchor315),
    *Line-Following with a Camera in Python*, and build more features to deliver the
    code to the browser.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**页面脚本**和**滑块小部件**将需要JavaScript和**层叠样式表**（**CSS**）编程。在我们开始之前，我们需要从[*第14章*](B15660_14_Final_ASB_ePub.xhtml#_idTextAnchor315)，*Python中的摄像头跟随线*中获取图像核心，并添加更多功能以将代码发送到浏览器。'
- en: Enhancing the image app core
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强图像应用核心
- en: To build this, we will start by adding some static file links and reusing the
    image app core we last used in [*Chapter 14*](B15660_14_Final_ASB_ePub.xhtml#_idTextAnchor315),
    *Line-Following with a Camera in Python*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建这个，我们将首先添加一些静态文件链接，并重用我们在[*第14章*](B15660_14_Final_ASB_ePub.xhtml#_idTextAnchor315)，*Python中的摄像头跟随线*中使用的图像应用核心。
- en: Static files do not cause the robot to do something; the system passively serves
    them. We will be serving JavaScript and CSS, along with a local copy of the jQuery
    library. Flask does this automatically.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 静态文件不会让机器人做任何事情；系统被动地提供服务。我们将提供JavaScript和CSS，以及jQuery库的本地副本。Flask会自动完成这项工作。
- en: 'Let''s set up the static files folder, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式设置静态文件文件夹：
- en: Create a `static` folder. We will put JavaScript and CSS code in this `static`
    folder.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`static`文件夹。我们将把JavaScript和CSS代码放在这个`static`文件夹中。
- en: We will make a local copy of the jQuery library. Make a `lib` directory under
    `static`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将制作jQuery库的本地副本。在`static`下创建一个`lib`目录。
- en: Download jQuery from [https://code.jquery.com/jquery-3.5.1.min.js](https://code.jquery.com/jquery-3.5.1.min.js),
    press the browser `lib` folder. You should have a `static/lib/jquery-3.5.1.min.js`
    file.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://code.jquery.com/jquery-3.5.1.min.js](https://code.jquery.com/jquery-3.5.1.min.js)下载jQuery，按浏览器`lib`文件夹。你应该有一个`static/lib/jquery-3.5.1.min.js`文件。
- en: 'In the `image_app_core.py` file, we also need to stop it using cached files
    so that it reloads our CSS and JavaScript files, as follows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`image_app_core.py`文件中，我们还需要使用缓存文件来停止它，以便它重新加载我们的CSS和JavaScript文件，如下所示：
- en: '[PRE18]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The app core now has a static copy of jQuery we can use offline, so our phone
    doesn't have to rely on a good signal to talk to the robot.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 应用核心现在有一个可以离线使用的jQuery静态副本，所以我们的手机不需要依赖良好的信号与机器人通信。
- en: Writing the manual drive behavior
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写手动驾驶行为
- en: The next part we will need is the behavior. It builds on concepts from the code
    seen before in [*Chapter 14*](B15660_14_Final_ASB_ePub.xhtml#_idTextAnchor315),
    *Line-Following with a Camera in Python*, with control messages changing motor
    speeds and a plain video output.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要的是行为。它基于之前代码中看到的[*第14章*](B15660_14_Final_ASB_ePub.xhtml#_idTextAnchor315)，*Python中的摄像头跟随线*的概念，通过控制消息改变电机速度和纯视频输出。
- en: This system will have a timeout—if no control messages arrive for 1 second,
    it will stop driving. It can be quite frustrating to watch a robot drive off into
    the distance or off a desk, so it will revert to stopping if nothing is making
    sense.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统将有一个超时——如果1秒内没有控制消息到达，它将停止驾驶。看到机器人开到远处或桌子上是很令人沮丧的，所以如果没有任何有意义的事情发生，它将恢复停止。
- en: 'Let''s build it, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式构建它：
- en: 'Start a file called `manual_drive.py` with imports for the camera and control,
    like this:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以类似以下方式开始一个名为`manual_drive.py`的文件，导入摄像头和控制：
- en: '[PRE19]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can declare what we want the timeout threshold to be in seconds, as illustrated
    in the following code snippet:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以声明我们想要的超时阈值是多少秒，如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We''ll make a `ManualDriveBehavior` class. In this, we''ll store a `robot`
    object and track time, as illustrated in the following code snippet:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个`ManualDriveBehavior`类。在这个类中，我们将存储一个`robot`对象并跟踪时间，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, build the control section of this behavior. It resets the last time for
    every instruction. The code can be seen in the following snippet:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，构建这个行为的控制部分。它为每个指令重置最后时间。代码可以在下面的代码片段中看到：
- en: '[PRE22]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Our code processes the instruction in `handle_instruction`. This instruction
    is a dictionary, with an instruction name and parameters as its members. We can
    check if this command is `set_left` or `set_right`, as illustrated in the following
    code snippet:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的代码在`handle_instruction`中处理指令。这个指令是一个字典，其中指令名称和参数是其成员。我们可以检查这个命令是否是`set_left`或`set_right`，如下面的代码片段所示：
- en: '[PRE23]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We also need to handle the `exit` command, as follows:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要处理`exit`命令，如下所示：
- en: '[PRE24]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It would be useful, at least when testing, to know whether we have an unknown
    instruction. Let''s handle that case by raising an exception, as follows:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少在测试时，知道我们是否有未知的指令会有用。让我们通过抛出异常来处理这种情况，如下所示：
- en: '[PRE25]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Our app also needs to make a display, putting the frame on the server image
    queue, as follows:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的应用程序还需要创建一个显示，将帧放在服务器图像队列中，如下所示：
- en: '[PRE26]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The behavior then has a `run` method to perform the setup and the main loop.
    We start by setting the pan and tilt to look straight ahead, warm up the camera,
    and stop the servos, as follows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该行为有一个`run`方法来执行设置和主循环。我们首先将俯仰设置成直视前方，预热相机，并停止伺服电机，如下所示：
- en: '[PRE27]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We then loop over frames from the camera and process control instructions,
    as follows:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们遍历来自相机的帧并处理控制指令，如下所示：
- en: '[PRE28]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We finally make it auto stop based on the timeout, as follows:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们根据超时自动停止，如下所示：
- en: '[PRE29]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We add the top-level code to create and start the components, as follows:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加顶层代码来创建和启动组件，如下所示：
- en: '[PRE30]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We still want to ensure we stop the server when we exit or hit an error, so
    we run the following code:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们仍然想确保在退出或遇到错误时停止服务器，所以我们运行以下代码：
- en: '[PRE31]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The behavior backend is complete but it needs a template to see it, along with
    style and code to run on the phone.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 行为后端已完成，但需要一个模板来查看它，以及运行在手机上的样式和代码。
- en: The template (web page)
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板（网页）
- en: The template is where we will place our sliders and some of the code to handle
    them.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是我们放置滑块和部分处理它们的代码的地方。
- en: 'Let''s get into it, as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始，如下所示：
- en: 'Create a `templates/manual_drive.html` file. Start with the HTML preamble,
    as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`templates/manual_drive.html`文件。从HTML前缀开始，如下所示：
- en: '[PRE32]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We want the display to fit on a phone, adapting to the display size. We also
    don''t want the user''s touch interactions to accidentally scale the display.
    This line of code tells the browser that this is our intention:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望显示适应手机屏幕，根据显示大小调整。我们也不希望用户的触摸交互意外地缩放显示。这一行代码告诉浏览器这是我们的意图：
- en: '[PRE33]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We want to style this (and potentially our other interfaces). For this, we
    use a `display.css` style sheet, as illustrated in the following code snippet:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望对这个（以及可能的其他界面）进行样式设计。为此，我们使用一个`display.css`样式表，如下面的代码片段所示：
- en: '[PRE34]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We are going to use the jQuery library to make things interactive, and we''ll
    build a touch-slider system. These are the HTML equivalent of imports:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用jQuery库来使事物交互，并构建一个触摸滑块系统。这些是HTML的导入等效：
- en: '[PRE35]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We are going to place a very specific bit of style here in this file. The rest
    comes from the style sheet. We want this behavior''s view to take up the whole
    screen and not scroll. The code can be seen here:'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在这个文件中放置一个非常具体的样式。其余的来自样式表。我们希望这个行为的视图占据整个屏幕，并且不滚动。代码如下所示：
- en: '[PRE36]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The head ends with a title to go on the top of the tab, as follows:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 头部以一个标题结束，该标题将显示在标签页的顶部，如下所示：
- en: '[PRE37]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We now start the body with the first slider; we define this with `svg` tag,
    which we''ll use to make the slider track, as illustrated in the following code
    snippet:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在从第一个滑块开始构建主体；我们使用`svg`标签来定义它，我们将用它来制作滑块轨迹，如下面的代码片段所示：
- en: '[PRE38]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Inside the container, we will draw a circle. The circle needs a radius `r`,
    which we can give in view box units. The center will be 0 in both directions.
    The code for this is shown here:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器内部，我们将画一个圆。这个圆需要一个半径`r`，我们可以用视图框单位给出。中心在两个方向上都是0。这个代码如下所示：
- en: '[PRE39]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The circle's color will come from the style sheet.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 圆的颜色将来自样式表。
- en: 'Next, we need an `Exit` link to finish the behavior. It has a class and ID
    to style it, as illustrated in the following code snippet:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个`退出`链接来完成行为。它有一个类和ID来定义其样式，如下面的代码片段所示：
- en: '[PRE40]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we have our video block. The `img` tag for the video is contained inside
    a `div` tag to preserve our video ratio on any size screen while letting it resize
    to fit the space, as illustrated in the following code snippet:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有我们的视频块。视频的`img`标签包含在一个`div`标签内，以保持我们的视频在任何尺寸屏幕上的比例，同时允许它调整大小以适应空间，如下面的代码片段所示：
- en: '[PRE41]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The right slider is a repeat of the left, with only the ID being different.
    You could copy and paste the left code, changing the ID. The code can be seen
    here:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右侧的滑块是左侧的重复，只是ID不同。你可以复制并粘贴左侧的代码，更改ID。代码可以在这里看到：
- en: '[PRE42]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We will need some JavaScript code in our HTML for the sliders. The code on
    the page will link slider code to the graphics we have and to the motors. First,
    we declare the JavaScript block, as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在我们的HTML中添加一些JavaScript代码来处理滑块。页面上的代码将滑块代码与我们的图形和电机链接起来。首先，我们声明JavaScript块，如下所示：
- en: '[PRE43]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add a function to send motor controls to the robot. It takes a name (left or
    right) and a speed, as illustrated in the following code snippet:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个函数来发送电机控制到机器人。它接受一个名称（左或右）和一个速度，如下面的代码片段所示：
- en: '[PRE44]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We POST this control instruction to the server.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将这个控制指令POST到服务器。
- en: 'The next bit of code must only run after the page has completed loading; we
    want to ensure the preceding JavaScript libraries are fully loaded. jQuery has
    a special function, `$()`, which will run any function passed to it when the page
    has completed loading, as illustrated in the following code snippet:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的代码必须在页面完成加载后运行；我们想确保前面的JavaScript库已经完全加载。jQuery有一个特殊函数`$()`，当页面完成加载时，它会运行传递给它的任何函数，如下面的代码片段所示：
- en: '[PRE45]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We need to link the exit button to a POST request, which forwards to the menu
    when done, as illustrated in the following code snippet:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将退出按钮链接到一个POST请求，完成后将转发到菜单，如下面的代码片段所示：
- en: '[PRE46]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We set up the sliders and link them with their `svg` element IDs and `set_motor`
    so that they will update this every time they change, as illustrated in the following
    code snippet:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置了滑块并将它们与它们的`svg`元素ID和`set_motor`链接起来，以便每次它们改变时都会更新，如下面的代码片段所示：
- en: '[PRE47]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We now end our page by closing all the tags, as follows:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们通过关闭所有标签来结束我们的页面，如下所示：
- en: '[PRE48]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This page has no style; by default, the video and sliders have no shape, size,
    or color—so, if you try to load this, it will show a blank page. We've yet to
    tell the browser where we want things on the page or which colors to make them.
    We also don't have the slider code yet.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面没有样式；默认情况下，视频和滑块没有形状、大小或颜色——所以，如果你尝试加载这个，它将显示一个空白页面。我们还没有告诉浏览器我们想在页面上放置什么或使用什么颜色。我们还没有滑块的代码。
- en: We've made the code to send the exit button and link sliders with tags. In the
    next section, we'll add a style sheet to make things visible.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了发送退出按钮并将滑块与标签链接的代码。在下一节中，我们将添加一个样式表来使事物可见。
- en: The style sheet
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样式表
- en: We can now give our app some style. Style sheets take time to tune and get just
    right, so this is just a taste of what it can do. If you think my color choices
    are terrible, please feel free to substitute your own; I suggest using w3c colors
    at [https://www.w3schools.com/colors/default.asp](https://www.w3schools.com/colors/default.asp).
    You can use named or hex (`#1ab3c5`) colors.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以给我们的应用添加一些样式。样式表需要时间来调整和精确设置，所以这只是一个展示它能做什么的例子。如果你认为我的颜色选择很糟糕，请随意替换你自己的；我建议使用w3c颜色，在[https://www.w3schools.com/colors/default.asp](https://www.w3schools.com/colors/default.asp)。你可以使用命名或十六进制（`#1ab3c5`）颜色。
- en: The essence of CSS is to select elements on the page and associate style attributes
    with them. CSS style sections start with a `#` mark. For a comprehensive look
    at CSS selectors, see the *Further reading* section. Each section uses braces
    `{}` to delimit a section of style. A section's styles consist of a property name,
    a colon `:`, and a setting. A semicolon `;` follows these to end each setting.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: CSS的本质是在页面上选择元素并将样式属性与它们关联。CSS样式部分以一个`#`标记开始。要全面了解CSS选择器，请参阅*进一步阅读*部分。每个部分使用花括号`{}`来界定一个样式部分。一个部分的样式由属性名、一个冒号`:`和一个设置组成。一个分号`;`跟在这些设置之后，以结束每个设置。
- en: 'Let''s make the style, as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义样式，如下所示：
- en: Create a `static/display.css` file to hold this style information.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`static/display.css`文件来保存这些样式信息。
- en: 'We can set our slider track to 10% of the viewport width—that is, 10% as big
    as the screen. CSS has a special unit, `vw`, for this, along with `vh` for percentage
    of the viewport height. See the *Further reading* section for notes on CSS units.
    This code uses the `.slider_track` CSS selector, which applies to all objects
    with that class. Both sliders have this class, so changes here affect both of
    them. The code can be seen here:'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以将我们的滑块轨道设置为视口宽度的10%——即屏幕大小的10%。CSS有一个特殊的单位`vw`用于此，还有`vh`用于视口高度的百分比。在*进一步阅读*部分查看关于CSS单位的说明。此代码使用`.slider_track`
    CSS选择器，它适用于具有该类的所有对象。两个滑块都有这个类，所以这里的更改会影响它们两个。代码如下所示：
- en: '[PRE49]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We''ll give the slider track a solid blue border and a light blue background
    to match our mockups, as follows:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将给滑块轨道添加一个实心蓝色边框和浅蓝色背景，以匹配我们的原型，如下所示：
- en: '[PRE50]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To style the tick, the circle we see on the sliders, we can add a light pinkish
    fill color, like our mockups, as follows:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了样式化勾选标记，即我们在滑块上看到的圆圈，我们可以添加一个淡粉色填充色，就像我们的原型一样，如下所示：
- en: '[PRE51]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, we want to position the sliders (by their IDs) to the left and right.
    When making a display match closely to the screen mockup, we can use **absolute
    positioning** with viewport percentages to say exactly where things should be,
    as follows:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想要将滑块（通过它们的ID）定位在左侧和右侧。当制作一个与屏幕原型非常接近的显示时，我们可以使用**绝对定位**和视口百分比来确切地说明事物应该在哪里，如下所示：
- en: '[PRE52]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You can try this now by uploading it, stopping the running behavior, starting
    it again, and then reloading. The sliders look better, but the exit button and
    video are in the wrong place.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以通过上传它，停止运行行为，再次启动，然后重新加载来尝试这个。滑块看起来更好，但退出按钮和视频位置不正确。
- en: 'Let''s make the exit button more like a button. Styles under `.button` will
    apply to all buttons with the same class. We will make it a block—an element that
    uses width and height properties. This block is 10% of the viewport height. The
    code can be seen here:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使退出按钮更像一个按钮。`.button`下的样式将应用于具有相同类的所有按钮。我们将使其成为一个块——一个使用宽度和高度属性的元素。这个块是视口高度的10%。代码如下所示：
- en: '[PRE53]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, we align the text in the middle with `line-height` and `text-align`,
    then use `2em` to mean twice normal text size, as follows:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`line-height`和`text-align`将文本居中，然后使用`2em`表示正常文本大小的两倍，如下所示：
- en: '[PRE54]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We want to take the underline off the button text, which you normally get with
    a link. We''ll also give it some color, a blue background with white text, as
    follows:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要移除按钮文本的下划线，这通常是链接中出现的样式。我们还会给它添加一些颜色，一个蓝色背景和白色文本，如下所示：
- en: '[PRE55]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We specify more about the exit button using its ID. We will set its width and
    the top but use `auto` margins to center it, as follows:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用退出按钮的ID来指定更多关于它的样式。我们将设置其宽度和顶部位置，但使用`auto`边距来居中它，如下所示：
- en: '[PRE56]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Trying this out, you should now see the exit button in the right place.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尝试这个，你现在应该能看到退出按钮在正确的位置。
- en: 'Next, we style the video. We want to center the video on the screen. The outer
    video element can do that for us, like this:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们样式化视频。我们希望将视频居中在屏幕上。外部视频元素可以为我们做到这一点，如下所示：
- en: '[PRE57]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We can then specify the position and size of the inner image block. We want
    it to be 20% from the top of the screen using a `vh` measurement. The `vmin` unit
    is a percentage of the screen''s minimum dimension; it ensures that this block
    is never so large that it would obscure the two slider bars. We make the height
    automatically scale. We select `#video img` to apply this style to the `img` object
    contained in the `video` object, as illustrated in the following code snippet:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以指定内部图像块的定位和大小。我们希望它从屏幕顶部20%的位置开始，使用`vh`单位。`vmin`单位是屏幕最小维度的百分比；它确保这个块永远不会太大，以至于会遮挡两个滑块条。我们使高度自动缩放。我们选择`#video
    img`来将此样式应用于`video`对象中包含的`img`对象，如下面的代码片段所示：
- en: '[PRE58]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Our page is fully styled. You can try this now to see how it looks. Upload
    the whole folder (including templates) to the robot, and then run `python3 manual_drive.py`.
    Point a desktop browser at `http://myrobot.local:5001/`, substituting your robot''s
    hostname or address to see it. A desktop browser is good to discover errors in
    the HTML or JavaScript code. At the time of writing, Firefox and Chrome support
    emulating mobile devices in the browser and touch events. It should look like
    the mockup with real video, as illustrated in the following screenshot:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的页面已经完全样式化。你现在可以尝试一下，看看它看起来如何。将整个文件夹（包括模板）上传到机器人，然后运行`python3 manual_drive.py`。将桌面浏览器指向`http://myrobot.local:5001/`，用你的机器人的主机名或地址替换，以查看它。桌面浏览器非常适合发现HTML或JavaScript代码中的错误。在撰写本文时，Firefox和Chrome支持在浏览器中模拟移动设备和触摸事件。它应该看起来像以下截图所示的带有真实视频的模拟：
- en: '![](img/B15660_17_09.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_17_09.jpg)'
- en: Figure 17.9 – Screenshot of app running on the phone
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.9 – 手机上运行的应用程序截图
- en: '*Figure 17.9* shows the app running on a real phone. The slider bars still
    don''t do anything yet. Note that you may need to force your browser to reload
    the style sheet.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17.9*展示了在真实手机上运行的应用程序。滑块栏目前还没有任何功能。请注意，你可能需要强制浏览器重新加载样式表。'
- en: We now need to add the slider code.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要添加滑块代码。
- en: Creating the code for the sliders
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建滑块的代码
- en: The sliders need to respond to touch events, moving the circle to match the
    touch location and sending an update message to show how far this movement is
    from the middle. The sliders will automatically return to the center when the
    touch events stop. JavaScript lets us run code in the browser, so we'll create
    a JavaScript `makeSlider` function.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 滑块需要响应用户的触摸事件，将圆圈移动到触摸位置，并发送一个更新消息来显示这次移动距离中间有多远。当触摸事件停止时，滑块将自动返回中心。JavaScript允许我们在浏览器中运行代码，因此我们将创建一个名为`makeSlider`的JavaScript函数。
- en: 'First, we want to see how touches translate to slider positions and motor speeds.
    This is illustrated in the following diagram:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想看看触摸如何转换为滑块位置和电机速度。以下图表展示了这一点：
- en: '![](img/B15660_17_10.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_17_10.jpg)'
- en: Figure 17.10 – Going from touch events to motor positions
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.10 – 从触摸事件到电机位置
- en: Our sliders have some complexity in their positions, shown in *Figure 17.10*.
    When a user touches a screen, the position arrives in terms of screen coordinates.
    We first need to find where it is in the slider by taking away the slider's top
    coordinates. We will need to divide that result by the slider height, multiply
    by 200, and then subtract 100 to give us the viewbox position (the same system
    used to draw the SVG). In viewbox coordinates, the top is -100, but for our motors
    to go forward we need +100, so we must negate the viewbox position to get the
    motor speed.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的滑块在位置上有些复杂性，如图17.10所示。当用户触摸屏幕时，位置以屏幕坐标的形式到达。我们首先需要通过减去滑块的上边坐标来找到它在滑块中的位置。我们需要将这个结果除以滑块的高度，乘以200，然后减去100，以得到视图框位置（与绘制SVG使用的相同系统）。在视图框坐标中，顶部是-100，但为了我们的电机向前移动，我们需要+100，因此我们必须取视图框位置的负值以获得电机速度。
- en: 'Our script will set up the data needed to move the slider and internal functions
    to map to the slider events, manage the slider''s movement, and call back the
    `manual_drive.html` code (or any other code) when we move the sliders. Let''s
    make the slider code, as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本将设置移动滑块所需的数据，以及将内部函数映射到滑块事件、管理滑块的运动，并在我们移动滑块时调用`manual_drive.html`代码（或任何其他代码）。让我们编写滑块代码，如下所示：
- en: We will put this in `static/touch-slider.js`. As we are in a `.js` file, the
    `<script>` tags are not needed.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把这个放在`static/touch-slider.js`中。由于我们处于一个`.js`文件中，不需要`<script>`标签。
- en: 'We create the `makeSlider`, function, a factory function to make everything
    the sliders need, as follows:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个`makeSlider`函数，这是一个工厂函数，用于创建滑块所需的一切，如下所示：
- en: '[PRE59]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The first thing we need is some internal data. The code needs to know if we
    are touching the slider so that it won''t try to move back while we''re still
    touching it. We need to know if the touch position has changed and keep track
    of its position. Finally, we''ll find our slider by its ID and keep the found
    object to use, as follows:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要一些内部数据。代码需要知道我们是否在触摸滑块，这样它就不会在我们仍然触摸时尝试移动回去。我们需要知道触摸位置是否已改变，并跟踪其位置。最后，我们将通过其ID找到我们的滑块，并保留找到的对象以供使用，如下所示：
- en: '[PRE60]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We then need some functions to deal with the slider. We''ll start with a function
    to update the position, ensuring the tick is updated, that we only use whole numbers
    (because the browser won''t accept decimal points here), and that we update the
    `changed` flag, as illustrated in the following code snippet:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要一些函数来处理滑块。我们将从一个更新位置的函数开始，确保刻度被更新，我们只使用整数（因为浏览器在这里不接受小数点），并且更新`changed`标志，如下面的代码片段所示：
- en: '[PRE61]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The next thing is handling touch events. Event handlers are functions that
    get called when something happens (such as the exit button handler). Touch events
    have three events: `touchstart`—when someone starts touching a screen, `touchmove`—when
    a touch moves to another area, and `touchend`—when the touch stops. We won''t
    use `touchstart`, so we''ll start with making an anonymous `touchmove` function,
    as follows:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是处理触摸事件。事件处理器是在发生某些事情时被调用的函数（例如退出按钮处理器）。触摸事件有三个事件：`touchstart`——当有人开始触摸屏幕时，`touchmove`——当触摸移动到另一个区域时，和`touchend`——当触摸停止时。我们不会使用`touchstart`，所以我们将从一个匿名的`touchmove`函数开始，如下所示：
- en: '[PRE62]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We then get the relative position of this touch from the top of the slider,
    as follows:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们从这个触摸从滑块顶部的相对位置获取，如下所示：
- en: '[PRE63]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We can use this with the height to convert the touch position into a number
    from -100 to +100, matching the SVG viewbox coordinates, as follows:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以用这个高度将触摸位置转换为从-100到+100的数字，匹配SVG视图框坐标，如下所示：
- en: '[PRE64]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Since the code has received a touch event, we should set the `touched` flag
    to `true`. We must also prevent the touch event from having any other effects,
    as illustrated in the following code snippet:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于代码已经接收到触摸事件，我们应该将`touched`标志设置为`true`。我们还必须防止触摸事件产生任何其他效果，如下面的代码片段所示：
- en: '[PRE65]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Since we''ve set a flag to say that the touch event is occurring, we should
    also clear it (set it to `false`) when the touch event ends, as follows:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们设置了一个标志来表示触摸事件正在发生，因此当触摸事件结束时，我们也应该清除它（将其设置为`false`），如下所示：
- en: '[PRE66]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Our system is animated, so it needs to have an update cycle to return to the
    middle. The update should only move the tick if we are not touching the slider,
    so it stays where you keep your thumb. When the touch has stopped and it''s still
    not at the zero position, we should update the position, as follows:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的系统是动态的，因此它需要一个更新周期来返回中间位置。更新应该只在没有触摸滑块时移动刻度，这样它就会停留在你放置拇指的位置。当触摸停止且它仍然不在零位置时，我们应该更新位置，如下所示：
- en: '[PRE67]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This next part looks a bit like the **Proportional-Integral-Derivative** (**PID**)
    controller code in that there''s an error multiplied by a proportional component.
    We scale the error by a factor of 0.3 and add/subtract an extra 0.5 to get it
    closer to a 1% minimum. Every time this is updated, it moves the slider closer
    to the middle. The code can be seen here:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个部分看起来有点像**比例-积分-微分**（**PID**）控制器的代码，因为这里有一个乘以比例组件的错误。我们将错误乘以0.3，并额外加/减0.5以使其接近1%的最小值。每次更新时，它都会将滑块移动到中间位置。代码可以在以下位置查看：
- en: '[PRE68]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This code is also a great place to log the position—something we can use when
    it goes wrong.
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码也是一个很好的记录位置的地方——当它出错时我们可以使用。
- en: 'To run this `update` function frequently, we can use the `setInterval` built-in
    function, which runs a function repeatedly on every interval. This display update
    should be short to keep it responsive. The timings are in milliseconds. The code
    can be seen here:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了频繁运行这个`update`函数，我们可以使用`setInterval`内置函数，它在每个间隔内重复运行一个函数。这个显示更新应该很短，以保持其响应性。时间以毫秒为单位。代码可以在以下位置查看：
- en: '[PRE69]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Besides updating the image, we also need to call the `when_changed` function.
    We only want to do so when something has changed and then reset the `changed`
    flag, so we don''t call it when idle. We''ll call this `update_when_changed`.
    This checks for changes and runs less frequently than the display update, so it
    doesn''t flood the `when_changed` handler and the queue on the robot. The code
    can be seen here:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了更新图像外，我们还需要调用`when_changed`函数。我们只想在发生变化时这样做，然后重置`changed`标志，这样我们就不在空闲时调用它。我们将调用这个`update_when_changed`。它检查变化，并且比显示更新运行得更频繁，因此不会淹没`when_changed`处理器和机器人上的队列。代码可以在以下位置查看：
- en: '[PRE70]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: You should now be ready to run the whole system.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该准备好运行整个系统了。
- en: Running this
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行这个
- en: You can now upload the entire set of files to a folder on your robot. As before,
    you can use `python3 manual_drive.py` to run this.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以将整个文件集上传到你的机器人上的一个文件夹中。和之前一样，你可以使用`python3 manual_drive.py`来运行它。
- en: 'You can use developer mode on a browser to view the web page before trying
    it on a phone, as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试在手机上使用之前，你可以在浏览器中使用开发者模式查看网页，如下所示：
- en: Point your browser (Chrome or Firefox) at `http://myrobot.local:5001` (using
    your robot's hostname or address).
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的浏览器（Chrome或Firefox）指向`http://myrobot.local:5001`（使用你的机器人的主机名或地址）。
- en: Right-click on your page and click the menu item labeled **Inspect or Inspect
    Element**.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击你的页面，然后点击标有**检查或检查元素**的菜单项。
- en: In the developer tools, there will be buttons for emulating phone devices and
    touch events. Enable the phone emulation.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开发者工具中，将有模拟手机设备和触摸事件的按钮。启用手机模拟。
- en: Try to shake out any problems in a desktop browser first. Check that dragging
    the sliders has the desired results and click on the **Console** button to see
    if there are errors from the JavaScript.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先尝试在桌面浏览器中排除任何问题。检查拖动滑块是否得到期望的结果，并点击**控制台**按钮查看是否有JavaScript错误。
- en: Common problems in JavaScript and CSS are missing punctuation such as semicolons,
    commas, or brackets. Having class or ID selectors that do not match (or are missing
    the required dot/hash mark syntax) will make styles fail to apply or element lookups
    in JavaScript produce no results.
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: JavaScript和CSS中常见的常见问题是缺少标点符号，如分号、逗号或括号。如果类或ID选择器不匹配（或缺少所需的点/井号语法），将导致样式无法应用或JavaScript中的元素查找没有结果。
- en: 'To use on the phone, you will need to use your robot''s IP address, as major
    smartphone brands do not support `.local` addresses. You can find this from your
    desktop with `ping myrobot.local`, as illustrated in the following code snippet:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在手机上使用，你需要使用你的机器人的IP地址，因为主要的智能手机品牌不支持`.local`地址。你可以通过桌面上的`ping myrobot.local`找到它，如下面的代码片段所示：
- en: '[PRE71]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: With the phone, you should be able to use your thumbs to drive the robot.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用手机，你应该能够用你的拇指来驾驶机器人。
- en: It will take some practice to drive the robot manually. I suggest practicing
    overhead driving first, and when you have got the hang of that, try navigating
    through the camera. The camera frame rate is not very high, and this frame rate
    currently constrains the driving loop.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 驾驶机器人需要一些练习。我建议先练习从上往下驾驶，当你熟悉了这一点后，再尝试通过摄像头导航。摄像头的帧率不是很高，这个帧率目前限制了驾驶循环。
- en: Troubleshooting
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'This is a fairly complex combination of Python, HTML, JavaScript, and CSS.
    Try these if you''ve run into trouble:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当复杂的Python、HTML、JavaScript和CSS的组合。如果你遇到麻烦，可以尝试以下方法：
- en: If you see errors from Python, verify the line of code against the preceding
    code.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果看到Python的错误，请对照前面的代码验证代码行。
- en: If things are not working on the web page, try out the phone emulation in browser
    mode, as suggested previously, then select the inspector **Console** tab and try
    the operation again. This will show JavaScript errors.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果网页上的事情不起作用，尝试在浏览器模式中运行手机模拟，如之前建议的，然后选择检查器**控制台**选项卡并再次尝试操作。这将显示JavaScript错误。
- en: If the display appears wrong, with parts out of place or in the wrong color,
    verify that the CSS/style sheet sections and the HTML are correct.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果显示出现错误，部分内容位置不正确或颜色错误，请验证CSS/样式表部分和HTML是否正确。
- en: If you receive `404` errors, ensure that the URLs in the HTML match the routes
    in the Flask/Python code.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你收到`404`错误，请确保HTML中的URL与Flask/Python代码中的路由相匹配。
- en: If your robot seems to be pausing and then spending a while catching up with
    your events, you could adjust the `update_if_changed` interval time to something
    longer.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的机器人似乎在暂停，然后花一段时间赶上你的事件，你可以将`update_if_changed`间隔时间调整得更长一些。
- en: You now have a robot you can drive remotely with the phone while seeing through
    its camera. You've seen how to handle touch events and use style sheets with SVG
    to make custom widgets. You've used JavaScript to bring the widget to life with
    animation and send control messages back to the robot.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你有一个可以通过手机远程驾驶的机器人，同时通过其摄像头看到。你已经看到了如何处理触摸事件和使用SVG样式表来创建自定义小部件。你已经使用JavaScript通过动画使小部件生动起来，并发送控制消息回机器人。
- en: In our next section, we'll make the menu more touch-friendly so that we can
    control the robot mostly from the phone.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使菜单更易于触摸操作，这样我们就可以主要通过手机来控制机器人。
- en: Making the robot fully phone-operable
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使机器人完全手机可操作
- en: The goal here is to make it so that we can drive the robot completely from the
    phone. We need to ensure that the robot is ready to run when we turn it on, and
    make sure that the menu is usable from a phone. The menu we made earlier doesn't
    seem very touch-friendly. It also will not successfully run any of the behaviors
    with displays using Flask. We will make the menu buttons bigger and more touch-friendly,
    using styles similar to our manual drive behavior. The menu will also load our
    server page after clicking a behavior with a server such as this one or the last
    chapter's visual tracking behaviors.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的目标是实现我们可以完全通过手机来控制机器人。我们需要确保在开启机器人时，机器人已经准备好运行，并确保菜单可以从手机上使用。我们之前制作的菜单看起来不太适合触摸操作。它也无法成功运行使用
    Flask 的任何带有显示的行为。我们将使菜单按钮更大，并使其更易于触摸操作，使用与我们手动驾驶行为相似的样式。点击具有服务器（如本例或上一章的视觉跟踪行为）的行为后，菜单还将加载我们的服务器页面。
- en: Let's fix the Flask behaviors first.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先修复 Flask 行为。
- en: Making menu modes compatible with Flask behaviors
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使菜单模式与 Flask 行为兼容
- en: If you've already tried running Flask-based behaviors (such as those with a
    camera) in the control server, you will have noticed some very odd behavior. Your
    behavior will appear to do the right thing with sensors on the robot, but the
    web service fails to do anything useful on port `5001`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经在控制服务器中尝试运行基于 Flask 的行为（如带有摄像头的那些），您将注意到一些非常奇怪的行为。您的行为似乎在机器人的传感器上做了正确的事情，但
    Web 服务在 `5001` 端口上无法执行任何有用的操作。
- en: 'Flask uses subprocesses to manage its debug mode, which interferes with our
    use of them. We don''t need debug mode, so the fix is to remove debug mode by
    doing the following:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 使用子进程来管理其调试模式，这干扰了我们对它们的用法。我们不需要调试模式，所以修复方法是删除调试模式，如下所示：
- en: Open `control_server.py` and jump to the last few lines.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `control_server.py` 并跳转到最后几行。
- en: 'Remove `debug=True` from the `app.run` line by running the following code:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下代码从 `app.run` 行中移除 `debug=True`：
- en: '[PRE72]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: You can now add the manual drive and color-tracking and face-tracking behaviors
    to the control server, and they will start properly.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以向控制服务器添加手动驾驶、颜色跟踪和面部跟踪行为，并且它们将正常启动。
- en: Loading video services
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载视频服务
- en: When we click on a menu option for a video server-based behavior, after it starts
    we need to send our browser to port `5001` on our robot to see its output.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击基于视频服务器的行为菜单选项后，在它启动后，我们需要将我们的浏览器发送到机器人的 `5001` 端口以查看其输出。
- en: Our `menu.html` file currently takes the response from the `control_server`
    process and puts this into the message box. We can upgrade this to instruct the
    code to do something else. We can start by configuring the items that need to
    show a server page in `mode_config` variable.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的 `menu.html` 文件从 `control_server` 进程获取响应并将其放入消息框中。我们可以升级它，让代码执行其他操作。我们可以从配置
    `mode_config` 变量中需要显示服务器页面的项目开始。
- en: 'Each item in the `mode_config` variable holds only the mode script; we can
    update this to have both a script and whether it needs to show a server, as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`mode_config` 变量中的每个条目只包含模式脚本；我们可以将其更新为包含脚本以及是否需要显示服务器，如下所示：'
- en: Open `robot_modes.py`.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `robot_modes.py`。
- en: 'In `mode_config`, we will take the simple text naming the script (such as `"avoid_behavior.py"`)
    and replace it with a dictionary, allowing a simple case (`{"script": "avoid_behavior.py}`)
    or a more complex case (`{"script": "manual_drive.py", "server": True}`). You''ll
    need to change that on all items throughout the `mode_config`. The code is shown
    in the following snippet:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在 `mode_config` 中，我们将用字典替换简单的脚本命名文本（例如 `"avoid_behavior.py"`），允许简单的案例（`{"script":
    "avoid_behavior.py"}`）或更复杂的案例（`{"script": "manual_drive.py", "server": True}`）。您需要在整个
    `mode_config` 中的所有条目上更改这一点。代码如下面的代码片段所示：'
- en: '[PRE73]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We then need to update the server-type scripts in `mode_config` variable using
    the more complex case, as follows:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要使用更复杂的案例更新 `mode_config` 变量中的服务器类型脚本，如下所示：
- en: '[PRE74]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We need to modify the `run` method to pick the script from this changed structure,
    as follows:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要修改 `run` 方法以从这种更改后的结构中选择脚本，如下所示：
- en: '[PRE75]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Next, we need to check if we should redirect if the mode is a server and the
    current process is alive. I''ve added the explicit `is True`, to make it clearer
    that the value is a `True`/`False` flag, as illustrated in the following code
    snippet:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要检查如果模式是服务器并且当前进程处于活动状态，我们是否应该进行重定向。我在以下代码片段中添加了明确的 `is True`，以使其更清晰，表明该值是一个
    `True`/`False` 标志。
- en: '[PRE76]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We''ve prepared `robot_modes.py`. The `control_server.py` file sends responses
    to the web page. Let''s use the same trick we did with the `mode_config` and return
    a dictionary with data instead of just a string, as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备了`robot_modes.py`。`control_server.py`文件向网页发送响应。让我们使用与`mode_config`相同的技巧，返回一个包含数据的字典而不是只是一个字符串，如下所示：
- en: 'We will use `control_server.py` and add `jsonify` to the Flask imports, as
    illustrated in the following code snippet:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`control_server.py`并在Flask导入中添加`jsonify`，如下面的代码片段所示：
- en: '[PRE77]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Next, we replace the `run` method so that it creates the `response` dictionary,
    as follows:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们替换`run`方法，使其创建`response`字典，如下所示：
- en: '[PRE78]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This response is the basic message.
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个响应是基本消息。
- en: 'If we intend to redirect, we should send the `redirect` setting with our response,
    as follows:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们打算重定向，我们应该在我们的响应中发送`redirect`设置，如下所示：
- en: '[PRE79]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We need to send the response, encoded as JSON. JSON is an easy way to get data
    to JavaScript from Python—it is especially good with dictionary data. Run the
    following code:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要发送编码为JSON的响应。JSON是将数据从Python发送到JavaScript的一种简单方式——它与字典数据特别好。运行以下代码：
- en: '[PRE80]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Since we also sent a message back in the `stop` command, we should wrap it
    in the same way, like this:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们在`stop`命令中也发送了消息，我们应该以相同的方式将其包装起来，如下所示：
- en: '[PRE81]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The control server is able to send the `response` dictionary, and redirect
    if needed. The other side of this, now receiving the JSON object, requires changes
    in the page scripts to handle the new response. Proceed as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 控制服务器能够发送`response`字典，并在需要时进行重定向。现在，接收JSON对象的那一侧，需要在页面脚本中进行更改以处理新的响应。按照以下步骤进行：
- en: 'Open `templates/menu.html` and find the `run` function, as illustrated in the
    following code snippet:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`templates/menu.html`，找到`run`函数，如下面的代码片段所示：
- en: '[PRE82]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The message handling here needs to change. We need to set the message element
    HTML using the message element from our response, as follows:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里消息处理需要更改。我们需要使用响应中的消息元素设置消息元素的HTML，如下所示：
- en: '[PRE83]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'However, we can also check if we need to redirect. If so, we use the same trick
    we did in the previous *The template* section for the exit button in the manual
    drive behavior, but in a timeout, as follows:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，我们也可以检查是否需要重定向。如果是这样，我们使用与之前*模板*部分中手动驾驶行为中的退出按钮相同的技巧，但在超时中进行，如下所示：
- en: '[PRE84]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: If you upload this and run `python3 control_server.py`, you'll see the menu
    is now more functional but looks quite plain. You should be able to click on the
    tracking or driving behaviors and, after 3 seconds, be redirected to their page.
    Clicking the exit buttons should take you back to the menu.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你上传这个并运行`python3 control_server.py`，你会看到菜单现在功能更强大，但看起来相当简单。你应该能够点击跟踪或驾驶行为，3秒后重定向到它们的页面。点击退出按钮应该会带你回到菜单。
- en: Time to give it some style.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候给它一些样式了。
- en: Styling the menu
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 菜单样式
- en: We've already used a style sheet in the manual drive demo to make the exit button
    look better. This menu is a set of buttons too. We can build on that style and
    make the menu more phone-friendly.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在手动驾驶演示中使用了样式表来使退出按钮看起来更好。这个菜单也是一组按钮。我们可以在此基础上构建样式，使菜单更适用于手机。
- en: Making the menu template into buttons
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将菜单模板转换为按钮
- en: 'We have an existing style sheet in `static/display.css`. We can make further
    use of this in the menu, perhaps with a few tweaks. Our menu template can be optimized
    to make the most of that style sheet too. Proceed as follows:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`static/display.css`中有一个现有的样式表。我们可以在菜单中进一步使用这个样式表，也许需要一些调整。我们的菜单模板也可以优化以充分利用这个样式表。按照以下步骤进行：
- en: 'Open `templates/menu.html`. We will add a link to the style sheet. We can add
    a `charset` definition too, as follows:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`templates/menu.html`。我们将添加一个链接到样式表。我们还可以添加一个`charset`定义，如下所示：
- en: '[PRE85]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The menu template uses a list of items for the menu. Adding a `menu` class
    to that list and a `button` class to the links lets us use the existing style
    for them, as illustrated in the following code snippet:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 菜单模板使用一个项目列表。给这个列表添加一个`menu`类，给链接添加一个`button`类，这样我们就可以使用它们现有的样式，如下面的代码片段所示：
- en: '[PRE86]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, open up `static/display.css`, where we will define the style for the `menu`
    class, as follows:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`static/display.css`，我们将在这里定义`menu`类的样式，如下所示：
- en: '[PRE87]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: We make the list container fill the screen width without any extra margins (space
    around the outside of the item) or padding (space between the inside of the item
    and its child list items).
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使列表容器填充屏幕宽度，没有任何额外的边距（项目外部的空间）或填充（项目内部和其子列表项之间的空间）。
- en: 'The menu consists of list items. By default, these get a dot: a bullet point.
    We want to set this to `none` (no shape) to remove the bullet point. We can use
    CSS `list-style` properties to change that. The selector here applies to list
    items (`li`) that are children of a `.menu` class object. The code can be seen
    in the following snippet:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 菜单由列表项组成。默认情况下，这些项会带有一个点：一个项目符号。我们希望将其设置为`none`（无形状）以移除项目符号。我们可以使用CSS的`list-style`属性来更改它。这里的选择器适用于`.menu`类对象的子列表项（`li`）。代码可以在下面的代码片段中看到：
- en: '[PRE88]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'To make this touch-friendly, we make the buttons the same width. `60vw` (60%
    of the viewport width) should be wide enough. We use the margin `auto` trick to
    center this. We can also add a 1-pixel light blue border to them, as illustrated
    in the following code snippet:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使其触控友好，我们使按钮宽度相同。`60vw`（视口宽度的60%）应该足够宽。我们使用`auto`边距技巧来居中。我们还可以在它们上添加一个1像素的浅蓝色边框，如下面的代码片段所示：
- en: '[PRE89]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Upload the whole directory and start the menu server with `python3 control_server.py`.
    This menu should now look more phone-friendly.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 上传整个目录并使用`python3 control_server.py`启动菜单服务器。现在这个菜单应该看起来更符合手机。
- en: You've now seen how to make our control server work nicely on a smartphone,
    and you should be getting a little more comfortable with the interactions of JavaScript,
    HTML, and CSS with Python. However, this system has a flaw—we are still starting
    it from an SSH terminal. Let's see how to fix this.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了如何使我们的控制服务器在智能手机上运行良好，你应该对JavaScript、HTML和CSS与Python的交互更加熟悉。然而，这个系统有一个缺陷——我们仍然是从SSH终端启动它的。让我们看看如何解决这个问题。
- en: Making the menu start when the Pi starts
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让菜单在Pi启动时启动
- en: You now have a menu system launching robot behaviors. Using SSH to log in is
    great to debug, see problems, and fix them. However, when you want to demonstrate
    your robot, a SSH session will become inconvenient.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在有一个菜单系统可以启动机器人行为。使用SSH登录是很好的调试方式，可以看到问题并修复它们。然而，当你想展示你的机器人时，SSH会话会变得不方便。
- en: The ideal is to turn on the robot, wait for a light to come on, then point your
    phone browser at it to control it.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的情况是打开机器人，等待灯光亮起，然后将你的手机浏览器指向它来控制它。
- en: 'We are going to do two things to make this useful, as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将做两件事来使这个功能变得有用，如下所示：
- en: Use an LED to indicate that it's ready (in menu mode) to allow the robot to
    tell us before our phone has linked to the page
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LED指示它已准备好（在菜单模式下），以便在手机连接到页面之前机器人能告诉我们
- en: Use `systemd` to automatically start the menu Flask server when we turn on the
    robot
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`systemd`在机器人开启时自动启动菜单Flask服务器
- en: Let's get stuck in with the lights.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用灯光。
- en: Adding lights to the menu server
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向菜单服务器添加灯光
- en: 'We won''t want the whole robot class loaded in our menu, but it can use the
    lights to indicate our robot is now ready. We will import the LED system, turn
    it on as the server starts, and then turn it off/release it when the first `/run`
    request arrives. Proceed as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望整个机器人类加载到我们的菜单中，但它可以使用灯光来指示我们的机器人现在已准备好。我们将导入LED系统，在服务器启动时将其打开，然后在第一个`/run`请求到达时关闭/释放它。按照以下步骤操作：
- en: 'Open the `control_server.py` file and import the LEDs, like this:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`control_server.py`文件并导入LED，如下所示：
- en: '[PRE90]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We need to set up our LEDs and turn one LED green by running the following
    code:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要设置我们的LED并运行以下代码来使一个LED变绿：
- en: '[PRE91]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'When we run something, we know that someone''s used the menu. In our `run`
    method, we can clear the LED. Since we only want to do it once, we can set the
    global LEDs to `None` and then check this next time. Note in the following code
    snippet that we are inserting the highlighted code into the existing `run` function:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们运行某些内容时，我们知道有人使用了菜单。在我们的`run`方法中，我们可以清除LED。由于我们只想做一次，我们可以将全局LED设置为`None`，然后在下次检查。注意以下代码片段中我们正在将高亮代码插入到现有的`run`函数中：
- en: '[PRE92]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: You can test this by uploading the menu server code and rerunning it. The LED
    should light when it starts, and then when you select another behavior, it will
    go out. It should work correctly to move from the menu to the LED test behavior.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过上传菜单服务器代码并重新运行它来测试这一点。LED应该在启动时亮起，然后当你选择另一个行为时，它会熄灭。它应该能够正确地从菜单移动到LED测试行为。
- en: Using systemd to automatically start the robot
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`systemd`自动启动机器人
- en: The `systemd` in Raspberry Pi.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派中的`systemd`。
- en: 'Registering a service is done by creating a unit file and copying it into the
    right folder on the Pi. Proceed as follows:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个单元文件并将其复制到Pi的正确文件夹中来注册一个服务。按照以下步骤操作：
- en: 'Make a `menu_server.service` file. Start this with a description, and tell
    `systemd` to start our service after we have networking on our Raspberry Pi, as
    illustrated in the following code snippet:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `menu_server.service` 文件。用描述来启动它，并告诉 `systemd` 在我们的 Raspberry Pi 上建立网络后启动我们的服务，如下面的代码片段所示：
- en: '[PRE93]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now, we tell `systemd` we want this to start as the Pi is ready for users to
    log in, as illustrated in the following code snippet:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们告诉 `systemd` 我们希望在 Pi 准备好用户登录时启动它，如下面的代码片段所示：
- en: '[PRE94]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The `Service` section shown in the following snippet configures how to run
    our code:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段中显示的 `Service` 部分配置了如何运行我们的代码：
- en: '[PRE95]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The working directory is where you have copied your robot files to—for example,
    `/home/pi`. We can also set the `pi` user we''ve been using the whole time. The
    working directory is how your code finds its other components. Have a look at
    the following code snippet:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作目录是你将机器人文件复制到的位置——例如，`/home/pi`。我们还可以设置我们一直在使用的 `pi` 用户。工作目录是代码找到其其他组件的方式。请查看以下代码片段：
- en: '[PRE96]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The `ExecStart` statement tells `systemd` the command to run the service. However,
    it does not assume a path the way a shell would, so prefix the `python3` command
    with `/usr/bin/env`, as follows:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ExecStart` 语句告诉 `systemd` 运行服务的命令。然而，它并不像 shell 那样假设路径，所以请在 `python3` 命令前加上
    `/usr/bin/env`，如下所示：'
- en: '[PRE97]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: You now need to set this up on the Raspberry Pi. Upload this file to your Raspberry
    Pi home directory.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在需要在 Raspberry Pi 上设置这个。将此文件上传到你的 Raspberry Pi 主目录。
- en: 'You''ll need `sudo` to copy it into the system configuration. Type this via
    SSH on the Pi. Note you will see permission errors if you miss the `sudo` command.
    The code can be seen here:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要 `sudo` 权限将其复制到系统配置中。请在 Pi 上通过 SSH 输入此命令。注意，如果你遗漏了 `sudo` 命令，你会看到权限错误。代码可以在以下位置查看：
- en: '[PRE98]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We should now ask `systemd` to load our configuration and then enable our service,
    as follows:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在应该要求 `systemd` 加载我们的配置，然后启用我们的服务，如下所示：
- en: '[PRE99]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The system will confirm you''ve enabled it with this message:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统将确认你已经启用它，如下所示的消息：
- en: '[PRE100]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'You can then try starting your service with this command:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以使用以下命令尝试启动你的服务：
- en: '[PRE101]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: If starting this server is successful, you will see a green light go on, showing
    it is ready. You will then be able to point your browser at the robot and control
    it.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启动此服务器成功，你会看到一个绿灯亮起，表示它已准备好。然后你将能够将浏览器指向机器人并控制它。
- en: Let's just check that this has worked.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下这是否已经成功。
- en: Troubleshooting
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'Things can go wrong here—if so, try these steps to fix it or find out more:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能会出错——如果发生这种情况，请尝试以下步骤来修复它或了解更多信息：
- en: 'Starting/enabling the menu server with `systemd` may fail, and you will see
    `Unit menu_server.service is not loaded properly: Invalid argument` if there are
    problems with the `menu_server.service` file. Please verify its content, copy
    it back over, and rerun the `sudo` commands to install the new file.'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用 `systemd` 启动/启用菜单服务器可能会失败，如果你发现 `menu_server.service` 文件有问题，你会看到 `Unit menu_server.service
    is not loaded properly: Invalid argument`。请验证其内容，将其复制回来，然后重新运行 `sudo` 命令来安装新文件。'
- en: 'If you want to see more of what the server is doing, you can use this command:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想要看到服务器正在做什么的更多信息，你可以使用以下命令：
- en: '[PRE102]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The Pi will then respond with something like this:'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Pi 将会响应如下：
- en: '[PRE103]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '`systemctl` can show some recent activity, but you may want to follow the output
    of behaviors as they run. To do this, you will need to use the `journalctl` command.
    Use `-u` to specify the service we created, and then `-f` to follow the log, as
    illustrated in the following code snippet:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`systemctl` 可以显示一些最近的活动，但你可能想跟踪运行中的行为输出。为此，你需要使用 `journalctl` 命令。使用 `-u` 来指定我们创建的服务，然后使用
    `-f` 来跟踪日志，如下面的代码片段所示：'
- en: '[PRE104]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: We will then be able to see servers as they run—perhaps not as convenient for
    debugging, but handy for launching services. Use *Ctrl* + *C* to stop seeing the
    log.
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将能够看到服务器在运行时的状态——这可能不是调试中最方便的，但对于启动服务来说很方便。使用 *Ctrl* + *C* 来停止查看日志。
- en: You can now reboot the robot, wait for the green light, and start driving it.
    The green light will also mean that your Mycroft voice assistant can send requests
    to the robot too.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以重新启动机器人，等待绿灯亮起，然后开始驾驶它。绿灯也会意味着你的 Mycroft 语音助手可以向机器人发送请求。
- en: 'If you upload new code, you will need to restart the service. You can use the
    following command to do so:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你上传了新的代码，你需要重新启动服务。你可以使用以下命令来这样做：
- en: '[PRE105]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Congratulations—your robot is now truly headless! It doesn't even need a PC
    or laptop to start doing things.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜——你的机器人现在真正无头了！它甚至不需要 PC 或笔记本电脑来开始做事。
- en: Summary
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter added a small menu system to our robot to start different modes
    from a connected web browser.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为我们的机器人添加了一个小型菜单系统，可以从连接的网页浏览器中启动不同的模式。
- en: You've seen how to drive a robot from a mobile phone and how to create interesting-looking
    animated widgets with SVG and JavaScript.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何从手机驾驶机器人，以及如何使用 SVG 和 JavaScript 创建有趣的动画小部件。
- en: Your robot has now gained the ability to be driven manually. It may take you
    a while to get used to handling it, and manually correcting for veer (motors behaving
    slightly differently) is more challenging than when the PID systems correct themselves.
    Still, you will gain skills in driving it with your phone. You can use the camera
    on the front of the robot to get a robot's-eye view of the world.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 你的机器人现在已经获得了手动驾驶的能力。你可能需要一段时间来习惯操作它，手动纠正偏航（电机行为略有不同）比 PID 系统自行纠正更具挑战性。尽管如此，你将学会用手机驾驶它。你可以使用机器人前部的摄像头来获得机器人视角的世界。
- en: You've turned the control server into a menu server and then made that start
    automatically when you turn on the robot. You've also seen how to connect your
    menu server to the video-server apps such as manual driving, color-tracking, or
    face-tracking apps. By making the buttons more touch-friendly on the menu server,
    you can use a phone to launch most behaviors.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经将控制服务器变成了菜单服务器，并在打开机器人时自动启动它。你还看到了如何将你的菜单服务器连接到视频服务器应用程序，如手动驾驶、颜色追踪或人脸追踪应用程序。通过使菜单服务器上的按钮更易于触摸，你可以使用手机启动大多数行为。
- en: Finally, we gave the menu server a way to indicate being ready on the robot
    with a LED and then set it up to automatically start when you turn on the robot.
    If your robot and phone can connect to the same network (perhaps you can set up
    your phone hotspot in a `wpa_supplicant.conf` file), you will be able to launch
    the behaviors from places outside your lab and demonstrate them to people. You've
    made the robot fully controllable with your phone!
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为菜单服务器提供了一个用 LED 指示机器人在机器人上就绪的方法，并将其设置为在打开机器人时自动启动。如果你的机器人和手机可以连接到同一网络（也许你可以在
    `wpa_supplicant.conf` 文件中设置你的手机热点），你将能够从实验室外的地方启动行为并向人们展示它们。你已经用手机完全控制了机器人！
- en: In the next chapter, we will look at meeting the robot-making community and
    finding further robot building and programming skills to continue building.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何加入机器人制作社区，并寻找更多的机器人构建和编程技能，以继续构建。
- en: Exercises
  id: totrans-451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'You could enhance the system in many ways. Here are some suggestions for building
    further:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过许多方式增强系统。以下是一些进一步构建的建议：
- en: In the `manual_drive.py` file, the `handle_instruction` function uses a bunch
    of `if` statements to handle the instruction. If this list of command handlers
    exceeds five, you could improve it by using a dictionary (such as `menu_modes`)
    and then calling different handler methods.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `manual_drive.py` 文件中，`handle_instruction` 函数使用一系列 `if` 语句来处理指令。如果这个命令处理器的列表超过五个，你可以通过使用字典（例如
    `menu_modes`）并调用不同的处理方法来改进它。
- en: Could you change the touch interface into two circular pads—perhaps so the left
    controls motor movement and the right changes the camera position?
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能否将触摸界面改为两个圆形垫片——也许这样左边的可以控制电机移动，右边的可以改变相机位置？
- en: What about creating phone-friendly interfaces for other behaviors to control
    their parameters?
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于为其他行为创建手机友好的界面来控制它们的参数，你怎么看？
- en: You could embellish the CSS by adding round buttons or putting spacing between
    the buttons.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过添加圆形按钮或按钮之间的间距来装饰 CSS。
- en: The menu still uses text buttons. Could you find a way to associate an image
    with each behavior and make a button grid?
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 菜单仍然使用文本按钮。你能找到一种方法将每个行为与一个图像关联，并制作一个按钮网格？
- en: Adding a `sudo poweroff` command.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `sudo poweroff` 命令。
- en: For desktop compatibility, the manual driving system could be enhanced with
    keyboard interactions to drive the robot, which is not quite as fun as the phone
    but is a handy fallback.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了桌面兼容性，手动驾驶系统可以通过键盘交互来增强，以驾驶机器人，这不如手机有趣，但是一个方便的备用方案。
- en: A seriously advanced improvement to the driving system would be to control motors
    in terms of counts per second, with a PID per wheel, matching the number of pulse
    counts we get with those we expect from the encoders. This improvement would make
    the robot drive straighter and be therefore easier to drive.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对驾驶系统进行一个严重的改进，将电机控制改为每秒计数，每个轮子一个 PID，匹配我们从编码器得到的脉冲计数与我们预期的脉冲计数。这个改进会使机器人直线行驶更直，因此更容易驾驶。
- en: Further reading
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To find out more about the topics covered in this chapter, here are some suggestions:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章涵盖的主题，以下是一些建议：
- en: I highly recommend the Flask API documentation ([http://flask.pocoo.org/docs/1.0/api/](http://flask.pocoo.org/docs/1.0/api/)),
    both to help understand the Flask functions we've used and to learn other ways
    to use this flexible web server library.
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我强烈推荐Flask API文档（[http://flask.pocoo.org/docs/1.0/api/](http://flask.pocoo.org/docs/1.0/api/)），它不仅可以帮助理解我们使用的Flask函数，还可以学习其他使用这个灵活的网络服务器库的方法。
- en: For a more guided look at the Flask web server, I suggest reading *Flask By
    Example*, *Gareth Dwyer*, *Packt Publishing* ([https://www.packtpub.com/product/flask-by-example/9781785286933](https://www.packtpub.com/product/flask-by-example/9781785286933)),
    showing you how to build more involved web applications using Flask.
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了更深入地了解Flask网络服务器，我建议阅读*Flask By Example*，作者*加雷思·德耶尔*，*Packt Publishing* ([https://www.packtpub.com/product/flask-by-example/9781785286933](https://www.packtpub.com/product/flask-by-example/9781785286933))，它展示了如何使用Flask构建更复杂的网络应用程序。
- en: I also recommend the book *Mastering Flask*, *Jack Stouffer*, *Packt Publishing*
    ([https://www.packtpub.com/web-development/mastering-flask](https://www.packtpub.com/web-development/mastering-flask)).
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我还推荐书籍*精通Flask*，作者*杰克·斯托弗*，*Packt Publishing* ([https://www.packtpub.com/web-development/mastering-flask](https://www.packtpub.com/web-development/mastering-flask))。
- en: The HTML used in this chapter is elementary. To get a more in-depth look into
    how you could enhance the simple menu system, I recommend the e-learning video
    guide *Beginning Responsive Web Development with HTML and CSS [eLearning]*, *Ben
    Frain*, *Cord Slatton-Valle*, *Joshua Miller*, *Packt Publishing* ([https://www.packtpub.com/web-development/beginning-responsive-web-development-html-and-css-elearning-video](https://www.packtpub.com/web-development/beginning-responsive-web-development-html-and-css-elearning-video)).
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章使用的HTML是基础的。为了更深入地了解如何增强简单的菜单系统，我推荐观看e-learning视频指南*使用HTML和CSS开始响应式网络开发 [eLearning]*，作者*本·弗莱恩*，*科德·斯莱顿-瓦莱*，*约书亚·米勒*，*Packt
    Publishing* ([https://www.packtpub.com/web-development/beginning-responsive-web-development-html-and-css-elearning-video](https://www.packtpub.com/web-development/beginning-responsive-web-development-html-and-css-elearning-video))。
- en: We use CSS selectors throughout HTML, CSS, and JavaScript applications. You
    can find a good combination of reference and tutorials at the *W3C Schools CSS
    Selectors* website ([https://www.w3schools.com/cssref/css_selectors.asp](https://www.w3schools.com/cssref/css_selectors.asp)).
    I would recommend exploring the site for its information on most web application
    technologies. For CSS units, see *W3C Schools CSS Units* ([https://www.w3schools.com/cssref/css_units.asp](https://www.w3schools.com/cssref/css_units.asp))
    to practice and find more types of units to use. *W3C Schools* provides in general
    great reference and learning material for these web technologies.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在HTML、CSS和JavaScript应用程序中使用了CSS选择器。你可以在*W3C Schools CSS选择器*网站上找到一个很好的参考和教程的组合（[https://www.w3schools.com/cssref/css_selectors.asp](https://www.w3schools.com/cssref/css_selectors.asp)）。我建议探索该网站，了解大多数网络应用技术的信息。对于CSS单位，请参阅*W3C
    Schools CSS单位*（[https://www.w3schools.com/cssref/css_units.asp](https://www.w3schools.com/cssref/css_units.asp)）以练习并找到更多可用的单位类型。*W3C
    Schools*通常为这些网络技术提供优秀的参考和学习材料。
- en: For getting more familiar with the JavaScript, CSS, and HTML technologies used
    here, *freeCodeCamp* ([https://www.freecodecamp.org/](https://www.freecodecamp.org/))
    is a valuable resource with self-learning modules.
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了更熟悉这里使用的JavaScript、CSS和HTML技术，*freeCodeCamp* ([https://www.freecodecamp.org/](https://www.freecodecamp.org/))是一个有价值的资源，提供了自学模块。
- en: Raspberry Pi has handy documentation on user `systemd` files at [https://www.raspberrypi.org/documentation/linux/usage/systemd.md](https://www.raspberrypi.org/documentation/linux/usage/systemd.md).
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi在其[https://www.raspberrypi.org/documentation/linux/usage/systemd.md](https://www.raspberrypi.org/documentation/linux/usage/systemd.md)上提供了关于用户`systemd`文件的便捷文档。
- en: There is a chapter on understanding `systemd` in *Mastering Linux Network Administration*,
    *Jay LaCroix*, *Packt Publishing* ([https://www.packtpub.com/product/mastering-linux-network-administration/9781784399597](https://www.packtpub.com/product/mastering-linux-network-administration/9781784399597)),
    published in 2015\.
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*精通Linux网络管理*（*Jay LaCroix*，*Packt Publishing*）[https://www.packtpub.com/product/mastering-linux-network-administration/9781784399597](https://www.packtpub.com/product/mastering-linux-network-administration/9781784399597)中有一章关于理解`systemd`，该书于2015年出版。
- en: A full reference for `systemd` services can be found on the *freedesktop* manuals
    at [https://www.freedesktop.org/software/systemd/man/systemd.service.html](https://www.freedesktop.org/software/systemd/man/systemd.service.html).
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemd`服务的完整参考可以在[freedesktop](https://www.freedesktop.org/software/systemd/man/systemd.service.html)手册中找到。'
