- en: Performing Speech-to-Text and Vice Versa with Amazon Transcribe and Polly
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Amazon Transcribe 和 Polly 执行语音转文本及反向操作
- en: In this chapter, we will continue to develop the skills and intuition required
    for real-world artificial intelligence applications. We will build an application
    that can translate spoken speech from one language to another. We will leverage
    Amazon Transcribe and Amazon Polly to perform speech-to-text and text-to-speech
    tasks. We will also demonstrate how our reference architecture allows us to reuse
    the service implementations we implemented in the previous chapter projects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续发展实现现实世界人工智能应用所需的技能和直觉。我们将构建一个能够将口语从一种语言翻译成另一种语言的应用程序。我们将利用 Amazon
    Transcribe 和 Amazon Polly 来执行语音转文本和文本转语音任务。我们还将展示我们的参考架构如何让我们重用在前一章项目中实现的服务。
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论以下主题：
- en: Performing speech-to-text with Amazon Transcribe
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Amazon Transcribe 执行语音转文本
- en: Performing text-to-speech with Amazon Polly
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Amazon Polly 进行文本转语音
- en: Building serverless AI applications with AWS services, RESTful APIs, and web
    user interface
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AWS 服务、RESTful API 和网页用户界面构建无服务器 AI 应用程序
- en: Reusing existing AI service implementations within the reference architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在参考架构中重用现有的 AI 服务实现
- en: Discussing user experience and product design decisions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论用户体验和产品设计决策
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This book's GitHub repository, which contains the source code for this chapter,
    can be found at [https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-on-Amazon-Web-Services](https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-on-Amazon-Web-Services).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的 GitHub 仓库，包含本章的源代码，可以在 [https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-on-Amazon-Web-Services](https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-on-Amazon-Web-Services)
    找到。
- en: Technologies from science fiction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 科幻中的技术
- en: Google's recent entry into the headphone market, called the Pixel Buds, had
    a unique feature that wowed the reviewers. These headphones can translate conversations
    in real time for dozens of languages. This sounds like science fiction. What comes
    to mind is Star Trek's universal translator that allows Starfleet crews to communicate
    with almost any alien race. Even though the Pixel Buds are not as powerful as
    their science fiction counterpart, they are packed with some amazing **Artificial
    Intelligence** (**AI**) technologies. This product showcases what we can expect
    from AI capabilities to help us communicate with more people in more places.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌最近进入耳机市场，推出了 Pixel Buds，这款耳机有一个独特的功能让评论员们惊艳。这些耳机能够实时翻译多种语言的对话。这听起来像科幻小说中的情节。让人想到的是《星际迷航》中的通用翻译器，它可以让星际舰队成员与几乎所有外星种族交流。尽管
    Pixel Buds 没有科幻作品中的那种强大功能，但它们集成了一些令人惊叹的 **人工智能** (**AI**) 技术。这款产品展示了我们可以期待的 AI
    能力，它能够帮助我们与更多地方的更多人沟通。
- en: We will be implementing a similar conversation translation feature using AWS
    AI services. Our application, modestly named the Universal Translator, will provide
    voice-to-voice translation between dozens of languages. However, our Universal
    Translator is not exactly real time and it only supports dozens of human languages.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 AWS AI 服务实现类似的对话翻译功能。我们的应用程序，谦虚地命名为通用翻译器，将提供多种语言之间的语音对语音翻译。然而，我们的通用翻译器并不是实时的，它仅支持几十种人类语言。
- en: Understanding the architecture of Universal Translator
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解通用翻译器的架构
- en: 'Our Universal Translator application will provide a web user interface for
    the users to record a phrase in one language and then translate that phrase to
    another language. Here is the architecture design highlighting the layers and
    services of our application. The organization of the layers and components should
    be familiar to you from our previous projects:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的通用翻译器应用程序将为用户提供一个网页用户界面，让他们可以录制一句话，并将该句子翻译成另一种语言。以下是我们应用程序架构设计，突出了各个层级和服务。我们之前项目中的层级和组件组织应该对你来说并不陌生：
- en: '![](img/ebd4b401-085c-4255-885a-53ab98fce7f0.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ebd4b401-085c-4255-885a-53ab98fce7f0.png)'
- en: 'In this application, the web user interface will interact with three RESTful
    endpoints in the orchestration layer:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，网页用户界面将与编排层中的三个 RESTful 端点进行交互：
- en: '**Upload Recording Endpoint** will delegate the audio recording upload to our
    Storage Service, which provides an abstraction layer to AWS S3.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上传录音端点** 将把音频录制上传委托给我们的存储服务，该服务为 AWS S3 提供了一个抽象层。'
- en: '**Translate Recording Endpoint** will use both the Amazon Transcription Service
    and the Amazon Translation Service. It first gets the transcription of the audio
    recording, and then translates the transcription text to the target language.
    The transcription service and the translation service abstract the Amazon Transcribe
    and Amazon Translate services respectively.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**录音翻译端点**将使用Amazon转录服务和Amazon翻译服务。它首先获取音频录音的转录内容，然后将转录文本翻译成目标语言。转录服务和翻译服务分别抽象了Amazon
    Transcribe和Amazon Translate服务。'
- en: '**Synthesize Speech Endpoint** will delegate the speech synthesis of the translated
    text to the Speech Service, which is backed by the Amazon Polly service.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语音合成端点**将把翻译后的文本的语音合成任务委托给语音服务，而该服务由Amazon Polly支持。'
- en: As we will soon see in the project implementation, the Translation Service is
    reused from the Pictorial Translator project, without any modification. In addition,
    the upload file method in the Storage Service implementation is also reused from
    the previous projects. One of the benefits of separating the orchestration layer
    and the service implementations should be clear here. We can reuse and recombine
    various service implementations, without modification, by stitching them together
    in the orchestration layer. Each application's unique business logics are implemented
    in the orchestration layer while the capabilities are implemented without the
    knowledge of the application-specific business logic.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在项目实现中看到的，翻译服务是从图像翻译项目中复用的，未做任何修改。此外，存储服务实现中的文件上传方法也复用了先前项目中的方法。分离编排层和服务实现的一个好处应该很明显：我们可以在编排层中将不同的服务实现拼接在一起，复用并重新组合，而无需修改。每个应用程序特有的业务逻辑在编排层中实现，而功能实现则不依赖于特定应用程序的业务逻辑。
- en: Component interactions of Universal Translator
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用翻译器的组件交互
- en: 'The following diagram walks through how the different components will interact
    with each other to form the business logic workflow of the Universal Translator
    application:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了不同组件如何相互作用，以形成通用翻译应用的业务逻辑工作流：
- en: '![](img/ee07ad0e-99d3-4c4a-89a0-34ae8e71593b.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee07ad0e-99d3-4c4a-89a0-34ae8e71593b.png)'
- en: 'The following is from the user''s perspective:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容是从用户的角度来看：
- en: The user first selects the source and target languages of the speech translation
    in the web user interface.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户首先在网页用户界面中选择语音翻译的源语言和目标语言。
- en: The user then records a short audio speech with the on-screen controls.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，用户使用屏幕上的控制录制一段简短的音频语音。
- en: This recording can be played back from the web user interface. The user can
    use the playback feature to check the quality of the speech recording.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该录音可以从网页用户界面播放。用户可以使用播放功能检查语音录音的质量。
- en: When the user is satisfied with the recording, it can be uploaded for translation.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户对录音满意时，可以上传以进行翻译。
- en: Some time later, the web user interface will display both the transcription
    and translation texts in the web user interface.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一段时间后，网页用户界面将同时显示转录文本和翻译文本。
- en: Finally, a synthesized speech of the translated text will be available for audio
    playback from the web user interface.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，翻译文本的合成语音将通过网页用户界面提供音频播放。
- en: 'We decided to break the end-to-end translation process into three major steps:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定将端到端的翻译过程分为三个主要步骤：
- en: Upload the audio recording.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传音频录音。
- en: Get the translation text.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取翻译文本。
- en: Synthesize the speech.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合成语音。
- en: This design decision allows the Universal Translator to display the translation
    text in the web user interface while the translation audio is being synthesized.
    This way, not only does the application appear more responsive to the user, but
    the user can also make use of the translation text in certain situations without
    waiting for the audio synthesis.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这一设计决策使得通用翻译器能够在翻译音频合成时，在网页用户界面中显示翻译文本。这样，应用不仅显得更为响应用户需求，而且用户在某些情况下也可以利用翻译文本，而无需等待音频合成完成。
- en: Setting up the project structure
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目结构
- en: 'Let''s create a similar base project structure with the steps outlined in [Chapter
    2](042787e6-6f54-4728-8354-e22d87be0460.xhtml), *Anatomy of a Modern AI Application*,
    including `pipenv`, `chalice`, and the web files:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照[第2章](042787e6-6f54-4728-8354-e22d87be0460.xhtml)《现代AI应用的结构》中的步骤创建一个类似的基础项目结构，包括`pipenv`、`chalice`和网页文件：
- en: 'In the terminal, we will create the root project directory, and enter it with
    the following commands:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，我们将创建根项目目录，并使用以下命令进入该目录：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will create placeholders for the web frontend by creating a directory named
    `Website`, and, within this directory, we will create the `index.html` and `scripts.js`
    files, as shown as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过创建一个名为 `Website` 的目录来为 Web 前端创建占位符，在该目录内创建 `index.html` 和 `scripts.js`
    文件，如下所示：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will create a Python 3 virtual environment with `pipenv` in the project''s
    `root` directory. Our Python portion of the project needs two packages, `boto3`
    and `chalice`. We can install them with the following commands:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在项目的 `root` 目录中使用 `pipenv` 创建一个 Python 3 虚拟环境。项目的 Python 部分需要两个包，`boto3`
    和 `chalice`。我们可以使用以下命令安装它们：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Remember that the Python packages installed via `pipenv` are only available
    if we activate the virtual environment. One way to do this is with the following
    command:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请记住，通过 `pipenv` 安装的 Python 包仅在我们激活虚拟环境时可用。我们可以通过以下命令来激活虚拟环境：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, while still in the virtual environment, we will create the orchestration
    layer as an AWS `chalice` project named `Capabilities`, with the following commands:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在仍处于虚拟环境中时，我们将创建一个名为 `Capabilities` 的 AWS `chalice` 项目作为编排层，使用以下命令：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To create the `chalicelib` Python package, issue the following commands:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建 `chalicelib` Python 包，请执行以下命令：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The initial project structure for Universal Translator should look like the
    following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通用翻译器的初始项目结构应如下所示：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is the project structure for the Universal Translator; it contains a user
    interface, orchestration, and the service implementation layers of the AI application
    architecture that we defined in [Chapter 2](042787e6-6f54-4728-8354-e22d87be0460.xhtml),
    *Anatomy of a Modern AI Application*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通用翻译器的项目结构；它包含了用户界面、编排和服务实现层，这是我们在[第 2 章](042787e6-6f54-4728-8354-e22d87be0460.xhtml)《现代
    AI 应用程序的结构》中定义的 AI 应用程序架构的一部分，*现代 AI 应用程序的解剖*。
- en: Implementing services
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现服务
- en: Let's implement this application layer by layer, starting with the service implementations
    that contain the crucial AI capabilities that make the Universal Translator tick.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分层实现这个应用程序，从包含通用翻译器核心 AI 功能的服务实现开始。
- en: Transcription service – speech-to-text
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转录服务 – 语音转文本
- en: In the Universal Translator, we are going to translate spoken words from one
    language to another. The first step of this translation process is to know which
    words were spoken. For this, we are going to use the Amazon Transcribe service.
    Amazon Transcribe uses deep learning based **Automatic Speech Recognition** (**ASR**)
    algorithms to generate text from speech.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在通用翻译器中，我们将把一种语言的口语翻译成另一种语言。翻译过程的第一步是知道哪些单词被说了。为此，我们将使用 Amazon Transcribe 服务。Amazon
    Transcribe 使用基于深度学习的**自动语音识别**（**ASR**）算法将语音转换为文本。
- en: 'Let''s use the AWS CLI to understand how the Transcribe service works. Issue
    the following command to start a transcription:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 AWS CLI 来理解 Transcribe 服务是如何工作的。输入以下命令以启动转录：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s understand the parameters passed in the preceding command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解前面命令中传递的参数：
- en: The job name must be a unique ID for each transcription job.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作业名称必须是每个转录作业的唯一标识符。
- en: The language code tells the service which language the audio speech is in. Supported
    languages, at the time of this writing, are `"en-US"`, `"es-US"`, `"en-AU"`, `"fr-CA"`,
    `"en-GB"`, `"de-DE"`, `"pt-BR"`, `"fr-FR"`, and `"it-IT"`.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言代码告诉服务音频语言是什么。撰写本文时，支持的语言包括`"en-US"`、`"es-US"`、`"en-AU"`、`"fr-CA"`、`"en-GB"`、`"de-DE"`、`"pt-BR"`、`"fr-FR"`
    和`"it-IT"`。
- en: The media format specifies the audio format of the speech; possible values are
    `"mp3"`, `"mp4"`, `"wav"`, and `"flac"`.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 媒体格式指定了语音的音频格式；可能的值为 `"mp3"`、`"mp4"`、`"wav"` 和 `"flac"`。
- en: The media parameter takes a URI to the audio recording, for example, an S3 URL.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 媒体参数接受音频录音的 URI，例如，S3 URL。
- en: The output bucket name specifies in which S3 bucket the transcription output
    should be stored.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出存储桶名称指定了转录输出应存储在哪个 S3 存储桶中。
- en: You will need to upload an audio recording to an S3 bucket for this command
    to work. You can use any available software tool to record an audio clip, or you
    can skip ahead to the *Speech Service* section of this chapter to learn how to
    generate speech audio with the Amazon Polly service.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将音频录音上传到 S3 存储桶中，以便该命令能够工作。你可以使用任何可用的软件工具录制音频片段，或者跳到本章的*语音服务*部分，了解如何使用 Amazon
    Polly 服务生成语音音频。
- en: Interestingly, we don't get the transcript in the output of this command. In
    fact, we can see that the transcription job we just started hasn't finished yet.
    In the output, `TranscriptionJobStatus` is still `IN_PROGRESS`. The Amazon Transcribe
    service follows an asynchronous pattern, which is commonly use for longer running
    tasks.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们在此命令的输出中不会得到转录文本。实际上，我们可以看到我们刚启动的转录任务尚未完成。在输出中，`TranscriptionJobStatus`仍然是`IN_PROGRESS`。Amazon
    Transcribe服务遵循异步模式，这通常用于长时间运行的任务。
- en: 'So how do we know the job has finished? There is another command as the following
    shows. We can issue this command to check the status of the job we just started:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何知道任务是否完成呢？有另一个命令，如下所示。我们可以执行此命令来检查刚刚启动的任务的状态：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的命令中：
- en: The `get-transcription-job` command takes in one parameter here, which is the
    unique job name that we specified when we started the job.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get-transcription-job`命令在这里接受一个参数，即我们启动任务时指定的唯一作业名称。'
- en: When the job status becomes `"COMPLETED"`, `"TranscriptFileUri"` will point
    to the JSON output file sitting in the output bucket we specified earlier.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当任务状态变为`"COMPLETED"`时，`"TranscriptFileUri"`将指向我们之前指定的输出桶中的JSON输出文件。
- en: 'This JSON file contains the actual transcription; here''s an excerpt:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JSON文件包含了实际的转录内容；下面是一个摘录：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is the JSON output we need to parse in our service implementation to extract
    the transcription text.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在服务实现中需要解析的JSON输出，用于提取转录文本。
- en: 'The Transcription Service is implemented as a Python class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 转录服务被实现为一个Python类：
- en: The constructor, `__init__()`, creates a `boto3` client to the Transcribe service.
    The constructor also takes in the Storage Service as a dependency for later use.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数`__init__()`创建了一个`boto3`客户端，用于连接转录服务。构造函数还接受存储服务作为依赖，以便后续使用。
- en: The `transcribe_audio()` method contains the logic to work with the Amazon Transcribe
    service.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transcribe_audio()`方法包含了与Amazon Transcribe服务交互的逻辑。'
- en: The `extract_transcript()` method is a helper method that contains the logic
    to parse the transcription JSON output from the Transcribe service.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extract_transcript()`方法是一个辅助方法，包含了解析来自转录服务的转录JSON输出的逻辑。'
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Before we dive deeper into the implementation of the `"transcribe_audio()"`
    and `"extract_transcript()"` methods, let's first take a look at the APIs available
    for Transcribe in the `boto3` SDK.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨`"transcribe_audio()"`和`"extract_transcript()"`方法的实现之前，首先让我们来看一下`boto3`
    SDK中与转录相关的API。
- en: As with the AWS CLI commands, the Amazon Transcribe APIs follow the same asynchronous
    pattern. We can call `"start_transcription_job()"` with `"TranscriptionJobName"`,
    which is the unique identifier for the transcription job. This method invokes
    the transcription process; however, it does not return the transcription text
    when the API call finishes. The `"start_transcription_job()"` API call also returns
    a `"TranscriptionJobStatus"` field within its response, which can be one of three
    values, `"IN_PROGRESS"`, `"COMPLETED"`, or `"FAILED"`. We can check on the transcription
    process with the API call to `"get_transcritpion_job()"` with the previously specified
    `"TranscriptionJobName"` to check on the job status.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与AWS CLI命令一样，Amazon Transcribe的API遵循相同的异步模式。我们可以通过`"TranscriptionJobName"`调用`"start_transcription_job()"`，这是转录任务的唯一标识符。此方法会启动转录过程；然而，当API调用完成时，它不会返回转录文本。`"start_transcription_job()"`
    API调用的响应中还会返回一个`"TranscriptionJobStatus"`字段，其值可以是`"IN_PROGRESS"`、`"COMPLETED"`或`"FAILED"`中的一个。我们可以通过API调用`"get_transcritpion_job()"`并指定先前的`"TranscriptionJobName"`来检查任务的状态。
- en: When the job is completed, the transcription text is placed in an S3 bucket.
    We can either specify an S3 bucket with `"OutputBucketName"` when calling `"start_transcription_job()"`
    or Amazon Transcribe will place the transcription output in a default S3 bucket
    with a presigned URL to access the transcription text. If the job failed, another
    `"FailureReason"` field in the response of `"start_transcription_job()"` or `"get_transcription_job()"`
    will provide the information about why the job failed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当任务完成时，转录文本会被放置在S3桶中。我们可以在调用`"start_transcription_job()"`时通过`"OutputBucketName"`指定一个S3桶，或者Amazon
    Transcribe会将转录输出放入一个默认的S3桶，并提供一个预签名的URL来访问转录文本。如果任务失败，`"start_transcription_job()"`或`"get_transcription_job()"`的响应中会有另一个`"FailureReason"`字段，提供任务失败的原因。
- en: This asynchronous pattern is commonly used for longer running processes. Instead
    of blocking the API caller until the process is completed, it allows the caller
    to perform other tasks and check back on the process later. Think about the customer
    experience of ordering an item on Amazon.com. Instead of making the customer wait
    on the website for the item to be packaged, shipped, and delivered, the customer
    is immediately shown the confirmation message that the order has been placed,
    and the customer can check on the order status (with a unique order ID) at a later
    time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种异步模式通常用于较长时间运行的过程。它允许调用者在等待过程完成的同时进行其他任务，之后再检查进度。可以类比在 Amazon.com 上订购商品的客户体验。客户不需要一直在网站上等待商品包装、发货和配送完成，而是会立即看到订单已成功下单的确认信息，并且可以稍后通过唯一的订单
    ID 查询订单状态。
- en: 'The `"transcribe_audio()"` method in the `TranscriptionService` class works
    around this asynchronous pattern of the Amazon Transcribe APIs:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`TranscriptionService` 类中的 `"transcribe_audio()"` 方法解决了 Amazon Transcribe API
    的异步模式：'
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following is an overview of the preceding `"transcribe_audio()"` implementation:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面 `"transcribe_audio()"` 实现的概述：
- en: We used a simple Python dictionary to store three pairs of language codes. The
    abbreviations "en", "es", and "fr" are the language codes used by our Universal
    Translator, and they are mapped to the language codes used by Amazon Transcribe,
    "en-US", "es-US", and "fr-CA" respectively.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用一个简单的 Python 字典来存储三对语言代码。"en"、"es" 和 "fr" 是我们通用翻译器使用的语言代码，它们分别映射到 Amazon
    Transcribe 使用的语言代码 "en-US"、"es-US" 和 "fr-CA"。
- en: This particular mapping is limited to only three languages to simplify our project.
    However, it does demonstrate the technique for abstracting the language codes,
    an implementation detail used by third-party services from our application. This
    way, regardless of the underlying third-party services, we can always standardize
    the language codes used by our application.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种映射仅限于三种语言，以简化我们的项目。然而，它展示了抽象语言代码的技术，这是我们的应用程序中第三方服务的实现细节。通过这种方式，无论底层的第三方服务如何，我们都可以始终标准化应用程序使用的语言代码。
- en: We generated a unique name for each transcription job, called `"job_name"`.
    This name combines the audio filename and a string representation of the current
    time. This way, even if the method is called on the same file multiple times,
    the job name still remains unique.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为每个转录任务生成了一个独特的名称，叫做`"job_name"`。这个名称结合了音频文件名和当前时间的字符串表示。通过这种方式，即使在同一个文件上多次调用该方法，任务名称仍然保持唯一。
- en: This method then calls `"start_transcription_job()"` with the unique `"job_name"`,
    language code, media format, the S3 URI where the recording is located, and finally
    the output bucket name.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，方法调用 `"start_transcription_job()"`，传入唯一的 `"job_name"`、语言代码、媒体格式、录音所在的 S3
    URI，最后是输出桶的名称。
- en: Even though the Transcribe API is asynchronous, we designed our `"transcribe_audio()"`
    method to be synchronous. To make our synchronous method work with Transcribe's
    asynchronous APIs, we added a wait loop. This loop waits for the `POLL_DELAY`
    seconds (set at 5 seconds) and then calls the `"get_transcription_job()"` method
    repeatedly to check on the job status. The loop runs while the job status is still
    `"IN_PROGRESS"`.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即便 Transcribe API 是异步的，我们仍然设计了 `"transcribe_audio()"` 方法为同步方式。为了让我们的同步方法能够与
    Transcribe 的异步 API 配合使用，我们添加了一个等待循环。该循环等待 `POLL_DELAY` 秒（设置为 5 秒），然后重复调用 `"get_transcription_job()"`
    方法检查任务状态。当任务状态仍为 `"IN_PROGRESS"` 时，循环会继续运行。
- en: Finally, when the job completes or fails, we grab the contents of the JSON output
    file from the specified S3 bucket via the Storage Service. This is why we needed
    the Storage Service as a dependency in the constructor. We then parse the transcription
    output with an `"extract_transcript()"` helper method.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，当任务完成或失败时，我们通过存储服务从指定的 S3 存储桶中获取 JSON 输出文件的内容。这也是我们在构造函数中需要将存储服务作为依赖的原因。接着，我们使用
    `"extract_transcript()"` 辅助方法解析转录输出。
- en: 'Next, we implement the `"extract_transcript()"` helper method, previously used
    by the `"transcribe_audio()"` method to parse the Amazon Transcribe output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实现了之前由 `"transcribe_audio()"` 方法使用的 `"extract_transcript()"` 辅助方法来解析 Amazon
    Transcribe 的输出：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have seen the JSON output format earlier with the transcription job we issued
    with the AWS CLI. This helper method encapsulates the logic to parse this JSON
    output. It first checks if the job completed successfully, and, if not, the method
    returns an error message as the transcription text; otherwise, it returns the
    actual transcription text.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经见过使用 AWS CLI 发出的转录任务的 JSON 输出格式。这个辅助方法封装了解析该 JSON 输出的逻辑。它首先检查任务是否成功完成，如果没有，则方法返回一个错误信息作为转录文本；如果成功完成，则返回实际的转录文本。
- en: Translation Service – translating text
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 翻译服务 – 翻译文本
- en: 'Just like in [Chapter 3](504c5915-cf10-4cd0-8f5c-3c75466f7dc6.xhtml), *Detecting
    and Translating Text with Amazon Rekognition and Translat*e, the Pictorial Translator
    application, we are going to leverage the Amazon Translate service to provide
    the language translation capability. As stated earlier, we can reuse the same
    implementation of the translation service that we used in the Pictorial Translator
    project:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在[第 3 章](504c5915-cf10-4cd0-8f5c-3c75466f7dc6.xhtml)，*使用 Amazon Rekognition
    和 Translate 检测和翻译文本* 中的图像翻译应用程序一样，我们将利用 Amazon Translate 服务提供语言翻译功能。如前所述，我们可以重复使用在图像翻译项目中使用的相同翻译服务实现：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding code is the exact same implementation of `TranslationService`
    from the previous project. For completion, we include this code here. For more
    details on its implementation and design choices, refer to [Chapter 3](https://cdp.packtpub.com/hands_on_artificial_intelligence_on_amazon_web_services/wp-admin/post.php?post=300&action=edit#post_298),
    *Detecting and Translating Text with Amazon Rekognition and Translat*e.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码与之前项目中的 `TranslationService` 实现完全相同。为了完整起见，我们在此包括此代码。如需更多关于其实现和设计选择的详细信息，请参考[第
    3 章](https://cdp.packtpub.com/hands_on_artificial_intelligence_on_amazon_web_services/wp-admin/post.php?post=300&action=edit#post_298)，*使用
    Amazon Rekognition 和 Translate 检测和翻译文本*。
- en: Speech Service – text-to-speech
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语音服务 – 文本到语音
- en: Once we have the translation text, we are going to leverage the Amazon Polly
    service to generate a spoken version of the translation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得翻译文本，就将利用 Amazon Polly 服务生成翻译的语音版本。
- en: 'Before we dive into the implementation, let''s generate a short audio speech
    using this service with the following AWS CLI command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入实现之前，让我们使用以下 AWS CLI 命令生成一个简短的音频语音：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This command has four mandatory parameters:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令有四个必填参数：
- en: 'The output format is the audio format:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出格式是音频格式：
- en: For audio stream, this can be `"mp3"`, `"ogg_vorbis"`, or `"pcm"`.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于音频流，可以是 `"mp3"`、`"ogg_vorbis"` 或 `"pcm"`。
- en: For speech marks, this will be `"json"`.
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于语音标记，这将是 `"json"`。
- en: The output S3 bucket name is where the generated audio file will be placed.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出 S3 存储桶名称是生成的音频文件将被放置的地方。
- en: The text is the text to be used for the text-to-speech synthesis.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该文本是用于文本到语音合成的文本。
- en: The voice ID specifies one of many voices available in Amazon Polly. The voice
    ID indirectly specifies the language, as well as a female or male voice. We used
    Ivy, which is one of the female voices for US English.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语音 ID 指定了 Amazon Polly 提供的多种语音之一。语音 ID 间接指定了语言以及男女声。我们使用了 Ivy，这是美国英语的女性语音之一。
- en: 'The Amazon Polly service follows a similar asynchronous pattern we saw earlier
    with Amazon Transcribe. To check on the status of the task we just started, we
    issue the following AWS CLI command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon Polly 服务遵循与之前 Amazon Transcribe 相似的异步模式。要检查我们刚刚启动的任务状态，我们发出以下 AWS CLI
    命令：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding command, we have the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述命令中，我们有以下内容：
- en: The `"get-speech-synthesis-task"` command takes in just one parameter, the task
    ID that was passed back in the output of the `"start-speech-synthesis-task"` command.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"get-speech-synthesis-task"` 命令只接受一个参数，即在 `"start-speech-synthesis-task"`
    命令输出中返回的任务 ID。'
- en: When the job status becomes `"completed"`, the `"OutputUri"` will point to the
    audio file generated in the S3 bucket we specified earlier.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当任务状态变为 `"completed"` 时，`"OutputUri"` 将指向我们之前指定的 S3 存储桶中生成的音频文件。
- en: The audio filename is the task ID with the specified audio format file extension,
    for example,`"e68d1b6a-4b7f-4c79-9483-2b5a5932e3d1.mp3"` for the MP3 format.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频文件名是任务 ID 和指定音频格式文件扩展名的组合，例如，`"e68d1b6a-4b7f-4c79-9483-2b5a5932e3d1.mp3"`
    表示 MP3 格式。
- en: 'Our Speech Service implementation is a Python class with a constructor, `"__init__()"`,
    and a method named `synthesize_speech()`. Here is its implementation as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的语音服务实现是一个 Python 类，包含一个构造函数 `"__init__()"` 和一个名为 `synthesize_speech()` 的方法。其实现如下：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The constructor creates a `boto3` client for the Amazon Polly service, and takes
    in `StorageService` as a dependency for later use.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数创建了一个 Amazon Polly 服务的 `boto3` 客户端，并将 `StorageService` 作为依赖传入，以便后续使用。
- en: 'In the `synthesize_speech()` method, we used the Python `voice_map` dictionary
    to store five pairs of language codes. The language codes used by our Universal
    Translator application are `"en"`, `"de"`, `"fr"`, `"it"`, and `"es"`. Instead
    of language codes, Amazon Polly uses voice ids which are associated with languages
    as well as female/male voices. The following is an excerpt of Polly voice mappings:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在`synthesize_speech()`方法中，我们使用了 Python 的 `voice_map` 字典来存储五对语言代码。我们的通用翻译器应用支持的语言代码有`"en"`、`"de"`、`"fr"`、`"it"`和`"es"`。与语言代码不同，Amazon
    Polly 使用的是与语言及男女语音相关联的语音 ID。以下是 Polly 语音映射的一个摘录：
- en: '| **Language** | **Female ID(s)** | **Male ID(s)** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **语言** | **女性 ID(s)** | **男性 ID(s)** |'
- en: '| English, British (en-GB) | Amy, Emma | Brian |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 英语（英国）(en-GB) | Amy, Emma | Brian |'
- en: '| German (de-DE) | Marlene, Vicki | Hans |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 德语 (de-DE) | Marlene, Vicki | Hans |'
- en: '| French (fr-FR) | Celine, Lea | Mathieu |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 法语 (fr-FR) | Celine, Lea | Mathieu |'
- en: '| Italian (it-IT) | Carla, Bianca | Giorgio |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 意大利语 (it-IT) | Carla, Bianca | Giorgio |'
- en: '| Spanish, European (es-ES) | Conchita, Lucia | Enrique |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 西班牙语（欧洲）(es-ES) | Conchita, Lucia | Enrique |'
- en: The `voice_map` dictionary in this method stored the first female voice ID of
    each language that the Universal Translator supports. This design choice is to
    simplify our project implementation. For a more polished voice-to-voice translation
    application, the developer can choose to support more languages and to provide
    customizations on the different voices. Again, `"voice_map"` abstracts third party
    service implementation details, the Amazon Polly voice ids, from our application.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法中的 `voice_map` 字典存储了通用翻译器所支持的每种语言的第一个女性语音 ID。这个设计选择是为了简化我们的项目实现。对于更精致的语音对语音翻译应用，开发者可以选择支持更多语言，并提供对不同语音的自定义。再次强调，`"voice_map"`
    抽象了第三方服务的实现细节，即 Amazon Polly 的语音 ID，隔离了应用层的实现。
- en: Our choices of supported languages are not completely arbitrary here. We specifically
    picked US English, US Spanish, and Canadian French for the input voices of Amazon
    Transcribe, and a European variant of the output voices of Amazon Polly. We are
    targeting customers from North America who are traveling to Europe with our Universal
    Translator, at least for this **MVP** (**minimal viable product**) version.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择支持的语言并非完全随意。在这里，我们特意选择了美国英语、美国西班牙语和加拿大法语作为 Amazon Transcribe 的输入语音，并选择了
    Amazon Polly 的欧洲变种作为输出语音。我们面向的客户群体是来自北美的游客，他们计划前往欧洲使用我们的通用翻译器，至少对于这个**最小可行产品**（**MVP**）版本而言。
- en: The Amazon Polly service APIs follow the same asynchronous pattern as its AWS
    CLI commands, with the `"start_speech_synthesis_task()"` and `"get_speech_synthesis_task()"`
    API calls. The implementation to synthesize speech looks very similar to the transcription
    implementation. Once again, we call the `"start_speech_synthesis_task()"` method
    to start the long-running process, and then use a while loop to make our method
    implementation synchronous. This loop waits for the `POLL_DELAY` seconds (set
    at 5 seconds) and then calls the `"get_speech_synthesis_task()"` method to check
    on the job status, which can be `"scheduled"`, `"inProgress"`, `"completed"`,
    and `"failed"`. The loop runs while the status is still `"scheduled"` or `"inProgress"`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon Polly 服务的 API 遵循与其 AWS CLI 命令相同的异步模式，分别为 `"start_speech_synthesis_task()"`
    和 `"get_speech_synthesis_task()"` API 调用。语音合成的实现与转录实现非常相似。我们再次调用 `"start_speech_synthesis_task()"`
    方法来启动长时间运行的过程，然后使用 while 循环使我们的实现变得同步。这个循环等待 `POLL_DELAY` 秒（设置为 5 秒），然后调用 `"get_speech_synthesis_task()"`
    方法来检查作业状态，状态可能为 `"scheduled"`、`"inProgress"`、`"completed"` 或 `"failed"`。当状态为 `"scheduled"`
    或 `"inProgress"` 时，循环会继续运行。
- en: Notice that, even amongst AWS APIs, the status values are not consistent from
    service to service. Our speech and transcription services shielded all these implementation
    details from the rest of our application. In the event that we want to swap in
    a different speech or transcription service implementation, the changes are isolated
    in the service implementation layer.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使在 AWS API 中，状态值在不同服务之间也不一致。我们的语音和转录服务将所有这些实现细节屏蔽在服务层之外。如果我们想要更换不同的语音或转录服务实现，相关更改将仅局限于服务实现层。
- en: Finally, when the task has the status of `"completed"`, we grab the S3 URI of
    the synthesized audio translation. By default, the file in the S3 bucket will
    not be publicly accessible, and our web user interface will not be able to play
    the audio translation. Therefore, before we return the S3 URI, we used our Storage
    Service `"make_file_public()"` method to make the audio translation public. We
    will take a look at how that's done in the Storage Service implementation next.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当任务状态为 `"completed"` 时，我们会获取合成音频翻译的 S3 URI。默认情况下，S3 桶中的文件不会公开访问，我们的 Web 用户界面也无法播放音频翻译。因此，在返回
    S3 URI 之前，我们使用了我们的存储服务方法 `"make_file_public()"` 将音频翻译设为公开。接下来，我们将查看在存储服务实现中是如何完成这一操作的。
- en: Storage Service – uploading and retrieving a file
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储服务 – 上传和检索文件
- en: Most of the Storage Service implementation should look familiar from the previous
    chapter. The `__init__()`, constructor, the `"get_storage_location()"` method,
    and the `"upload_file()"` method are all exactly the same as in our previous implementations.
    We added two new methods to extend the functionalities of `StorageService`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 存储服务的实现大部分应与上一章中相似。`__init__()` 构造函数、`"get_storage_location()"` 方法和 `"upload_file()"`
    方法与我们之前的实现完全相同。我们添加了两个新方法来扩展 `StorageService` 的功能。
- en: 'Here is the complete implementation:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的实现：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s have a look at the two new class methods:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这两个新类方法：
- en: The `get_file()` method takes a filename and returns that file's content as
    a string. We accomplish this by using the `boto3` S3 client to get the object
    by key (filename) from the bucket name (Storage Service's storage location), and
    then decode the file content as a UTF-8 string.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_file()` 方法接受文件名并返回该文件的内容作为字符串。我们通过使用 `boto3` S3 客户端，通过密钥（文件名）从桶名称（存储服务的存储位置）获取对象，并将文件内容解码为
    UTF-8 字符串来实现这一点。'
- en: The `make_file_public()` method takes a file URI and changes the **Access Control
    List** (**ACL**) of the target file to allow public access. Since our Storage
    Service is backed by AWS S3, the method assumes the URI is an S3 URI and parses
    it accordingly to extract the bucket name and key. With the bucket name and key,
    it then changes the object's ACL to `'public-read'`.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make_file_public()` 方法接受一个文件 URI，并更改目标文件的**访问控制列表**（**ACL**），以允许公开访问。由于我们的存储服务是由
    AWS S3 支持的，该方法假设 URI 是 S3 URI，并相应地解析它以提取桶名称和密钥。通过桶名称和密钥，它将对象的 ACL 更改为 `''public-read''`。'
- en: All of the methods within the Storage Service are designed to be generic, so
    that they are more likely to be reused by different applications.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 存储服务中的所有方法都设计得足够通用，以便它们更容易被不同的应用程序重用。
- en: Implementing RESTful endpoints
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 RESTful 端点
- en: Now that the services are implemented, let's move on to the orchestration layer
    with the RESTful endpoints. Since all of the real work is done by the service
    implementations, the endpoints are used to stitch the capabilities together and
    to provide HTTP access for the user interface layer to use these capabilities.
    The implementation code, therefore, is concise and easy to understand.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务已经实现，让我们继续探讨具有 RESTful 接口的编排层。由于所有实际工作都由服务实现完成，因此这些端点用于将功能拼接在一起，并为用户界面层提供
    HTTP 访问以使用这些功能。因此，实施代码简洁且易于理解。
- en: 'The `app.py` file contains the RESTful endpoint implementations. Here''s a
    snippet from `app.py` that includes the imports, configuration, and initialization
    code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.py` 文件包含了 RESTful 端点的实现。以下是 `app.py` 中的一个代码片段，包含了导入、配置和初始化代码：'
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will discuss each endpoint implementation in `app.py` in detail in the next
    few sections.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的几节中详细讨论 `app.py` 中每个端点的实现。
- en: Translate recording endpoint
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 翻译录音端点
- en: 'The Translate Recording endpoint is an HTTP POST endpoint that takes JSON parameters
    in the request''s body. This endpoint takes the recording ID as a parameter, and
    uses a JSON body to pass in the source and target languages of the translation:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译录音端点是一个 HTTP POST 端点，接收请求正文中的 JSON 参数。此端点接受录音 ID 作为参数，并通过 JSON 正文传递翻译的源语言和目标语言：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The annotation right above this function describes the HTTP request that can
    access the endpoint:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数之上的注释描述了可以访问该端点的 HTTP 请求：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s look at the preceding code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下之前的代码：
- en: The annotation right above the `"transcribe_recording()"` describes the HTTP
    POST request that can access the endpoint.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"transcribe_recording()"` 之上的注释描述了可以访问该端点的 HTTP POST 请求。'
- en: The function first gets the request data that contains the source language,
    `"fromLang",` and target language, `"toLang"`, for the translation.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数首先获取包含源语言（`"fromLang"`）和目标语言（`"toLang"`）的请求数据，用于翻译。
- en: The `"transcribe_recording()"` function calls to the Transcription Service to
    transcribe the audio recording.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"transcribe_recording()"`函数调用转录服务转录音频录音。'
- en: Next, this function calls the Translation Service to translate the transcription
    text.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，该函数调用翻译服务翻译转录文本。
- en: Finally, this function returns a JSON object containing both the transcription
    text and the translation information.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，这个函数返回一个包含转录文本和翻译信息的JSON对象。
- en: 'Let''s test this endpoint out by running `chalice local` in the Python virtual
    environment, and then issue the following `curl` command that specifies an audio
    clip that has already been uploaded to our S3 bucket:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在Python虚拟环境中运行`chalice local`来测试这个端点，然后发出以下`curl`命令，指定已经上传到我们的S3桶中的音频片段：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `<recording id>` identifies the filename of the audio file in our S3 bucket.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`<recording id>`标识我们S3桶中音频文件的文件名。'
- en: This is the JSON that our web user interface will receive and use to display
    the translation to the user.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的网页用户界面将接收并用来显示翻译结果的JSON数据。
- en: Synthesize speech endpoint
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合成语音端点
- en: 'The Synthesize Speech endpoint is an HTTP POST endpoint that takes JSON parameters
    in the request''s body. This endpoint uses JSON to pass in the target language
    and the text to be converted into speech. Even though Universal Translator is
    designed to translate short phrases, the text used to perform text-to-speech on
    can potentially be long, depending on the application. We are using a JSON payload
    here, as opposed to the URL parameters, because there''s a limit to the length
    of URLs. This design decision makes the endpoint more reusable for other applications
    in the future. It is also a good practice to keep the URLs of your application
    short and clean:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 合成语音端点是一个HTTP POST端点，接受请求体中的JSON参数。这个端点使用JSON传入目标语言和要转换为语音的文本。尽管Universal Translator设计用于翻译简短的短语，但用于执行文本到语音的文本可能会很长，这取决于应用程序。我们在这里使用JSON负载，而不是URL参数，因为URL的长度是有限制的。这个设计决策使得该端点将来可以更方便地用于其他应用程序。保持应用程序的URL简短清晰也是一个好习惯：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The annotation right above this function describes the HTTP request that can
    access this endpoint:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数上方的注释描述了可以访问此端点的HTTP请求：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding code, we have the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有以下内容：
- en: The `synthesize_speech()` function parses the request body as JSON data to get
    the text and the language for the speech synthesis.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`synthesize_speech()`函数将请求体解析为JSON数据，以获取语音合成的文本和语言。'
- en: The function then calls the Speech Service's `synthesize_speech()` method.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数随后调用语音服务的`synthesize_speech()`方法。
- en: The function then returns the URL to the audio file. Remember that we already
    made this audio file publicly accessible before `synthesize_speech()` returned.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后该函数返回音频文件的URL。请记住，在` synthesize_speech()`返回之前，我们已经使这个音频文件对外公开可访问。
- en: 'Let''s test this endpoint out by running `chalice local` in the Python virtual
    environment, and then issue the following `curl` command to pass in the JSON payload:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在Python虚拟环境中运行`chalice local`来测试这个端点，然后发出以下`curl`命令来传递JSON负载：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is the JSON that our web user interface will receive and use to update
    the audio player for the translation speech.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的网页用户界面将接收并用来更新翻译语音的音频播放器的JSON数据。
- en: Upload recording Endpoint
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传录音端点
- en: 'This endpoint is essentially the same as the Upload Image Endpoint from [Chapter
    3](https://cdp.packtpub.com/hands_on_artificial_intelligence_on_amazon_web_services/wp-admin/post.php?post=300&action=edit#post_298),
    *Detecting and Translating Text with Amazon Rekognition and Translat*e*,* Pictorial
    Translator application. It uses the same two functions that we implemented in
    the project without modification. The only change is the `@app.route` annotation,
    where we created a different HTTP POST endpoint, `/recordings`, that takes uploads
    via Base64 encoding:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个端点本质上与[第三章](https://cdp.packtpub.com/hands_on_artificial_intelligence_on_amazon_web_services/wp-admin/post.php?post=300&action=edit#post_298)中的上传图像端点相同，*使用Amazon
    Rekognition和翻译检测和翻译文本*，*图像翻译器应用程序。它使用我们在项目中实现的两个相同的函数，没有修改。唯一的变化是`@app.route`注释，在那里我们创建了一个不同的HTTP
    POST端点`/recordings`，通过Base64编码进行上传：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For completion, we include the code for both the endpoint and its helper function
    here. For more details on their implementations, refer to [Chapter 3](504c5915-cf10-4cd0-8f5c-3c75466f7dc6.xhtml),
    *Detecting and Translating Text with Amazon Rekognition and Translate*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，我们在这里包含了端点及其辅助函数的代码。有关它们实现的更多细节，请参考[第3章](504c5915-cf10-4cd0-8f5c-3c75466f7dc6.xhtml)，*使用Amazon
    Rekognition和Translate检测和翻译文本*。
- en: Implementing the Web User Interface
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现网页用户界面
- en: Next, let's create a simple web user interface with HTML and JavaScript in the
    `index.html` and `scripts.js` files in the `Website` directory.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在`Website`目录下的`index.html`和`scripts.js`文件中创建一个简单的网页用户界面。
- en: 'This is what the final web interface looks like:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是最终的网页界面样式：
- en: '![](img/ec702afc-5450-4647-9fcf-4e26e20704ba.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec702afc-5450-4647-9fcf-4e26e20704ba.png)'
- en: In this application, the user first selects the languages to translate from
    and to in the Select Languages section. The user then records a short speech in
    the Record Audio section. In this section, the user can also playback the recording
    to check for quality. Then the translation process kicks off. When the translation
    text becomes available, it is displayed to the user in the Translation Text section.
    Then the text-to-speech generation process is started. When the generated audio
    translation becomes available, the audio player controls are enabled to allow
    playback of the translation.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在此应用程序中，用户首先在选择语言部分选择翻译的源语言和目标语言。然后，用户在录音部分录制简短的语音。在此部分，用户还可以播放录音以检查其质量。然后，翻译过程开始。当翻译文本可用时，它将在翻译文本部分显示给用户。接着，开始文本转语音生成过程。当生成的音频翻译可用时，音频播放器控制被启用，以允许播放翻译内容。
- en: 'We made the design decision to treat the steps of every translation as sequential,
    meaning only one translation can be performed at a time. There is a certain amount
    of wait time for each end-to-end translation, mostly due to the speed of Amazon
    Transcribe and Amazon Polly services. There are a few techniques to improve the
    user experience during the wait time:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做出的设计决策是将每次翻译的步骤视为顺序执行，意味着一次只能执行一个翻译。每次端到端的翻译都会有一定的等待时间，主要是由于Amazon Transcribe和Amazon
    Polly服务的速度。我们有一些技术可以改善用户在等待期间的体验：
- en: A most important technique is actually letting the user know that the application
    is processing. We employed spinners in the Translation Text and Translation Audio
    sections while the application is processing. The fact that we are displaying
    spinners gives the clue to the user that these steps are not instantaneous.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个最重要的技术实际上是让用户知道应用程序正在处理。我们在翻译文本和翻译音频部分使用了加载指示器，表示应用程序正在处理。我们展示加载指示器的事实向用户暗示这些步骤不是即时完成的。
- en: Another technique we employed is breaking up the text translation and audio
    translation steps. Even though the total amount of processing time stays about
    the same, the user sees progress and intermediate results. Psychologically, this
    significantly reduces the perception of the wait time for the user.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们采用的另一种技术是将文本翻译和音频翻译步骤分开。尽管总的处理时间大致相同，用户可以看到进度和中间结果。从心理学角度看，这大大减少了用户对等待时间的感知。
- en: 'We could also reduce the `POLL_DELAY` in our Transcription Service and Speech
    Service implementations. Currently, the `POLL_DELAY` is set to 5 seconds in both.
    This results in some delay after the processing is completed, on average 2.5 seconds
    of delay in each step and on average 5 seconds in total. We can certainly reduce
    the delay. However, there is a tradeoff here: shorter `POLL_DELAY` will result
    in more AWS API calls to `"get_transcription_job()"` and `"get_speech_synthesis_task()"`
    functions.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以减少在转录服务和语音服务实现中的`POLL_DELAY`。目前，`POLL_DELAY`在两者中都设置为5秒。这会导致在处理完成后存在一些延迟，平均每步延迟2.5秒，总共约5秒的延迟。我们当然可以减少延迟。然而，这里存在一个权衡：较短的`POLL_DELAY`将导致更多的AWS
    API调用，分别是`"get_transcription_job()"`和`"get_speech_synthesis_task()"`函数。
- en: Finally, we could use real-time services for faster processing if they are available.
    For example, Amazon Transcribe now supports real-time transcription with a feature
    called Streaming Transcription. This feature enables applications to pass in live
    audio streams and receive text transcripts in real time. Unfortunately, at the
    time of this writing, this feature is not available in the Python AWS SDK. A flexible
    architecture will allow future service implementations, AWS-based or otherwise,
    to be more easily swapped in for long term evolution of the application.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果有可用的实时服务，我们可以使用它们来加速处理。例如，亚马逊的 Transcribe 现在支持名为流式转录（Streaming Transcription）的实时转录功能。此功能使得应用程序能够传入实时音频流并实时接收文本转录。不幸的是，在本文撰写时，该功能尚未在
    Python AWS SDK 中提供。一个灵活的架构将使未来的服务实现（无论是基于 AWS 还是其他）能够更轻松地替换，从而推动应用程序的长期发展。
- en: index.html
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: index.html
- en: 'Following is the `index.html` file. We are using standard HTML tags here, so
    the code of the web page should be easy to follow:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`index.html`文件。我们在这里使用了标准的 HTML 标签，因此网页的代码应该很容易理解：
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This code snippet shows the frame and the title of the web user interface:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段显示了网页用户界面的框架和标题：
- en: In addition to the W3 stylesheets we have used in previous projects, we also
    included the Font-Awesome CSS for the spinners.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了在之前的项目中使用的 W3 样式表外，我们还包含了用于旋转图标的 Font-Awesome CSS。
- en: At the bottom of `index.html`, we have included `MediaStreamRecorder.js` for
    the audio recording functionality in the web user interface.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`index.html`的底部，我们包含了`MediaStreamRecorder.js`，用于实现网页用户界面的音频录制功能。
- en: The rest of the `index.html` code snippet goes inside the top level `<div>`
    tag within the `<body>`
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其余的`index.html`代码片段位于`<body>`内的顶级`<div>`标签中。
- en: '[PRE27]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In this code snippet, we have the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们有以下内容：
- en: We created the `Select Languages` and Record Audio sections of the web user
    interface.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了网页用户界面的“选择语言”和“录制音频”部分。
- en: In the Select Languages section, we hardcoded the supported `fromLang` and `toLang`
    in `dropdown` lists.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“选择语言”部分，我们将支持的`fromLang`和`toLang`硬编码在`dropdown`列表中。
- en: In the Record Audio section, we used the `<audio>` tag to create an audio player
    with a couple of input buttons to control the recording and translation functions.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“录制音频”部分，我们使用了`<audio>`标签来创建一个音频播放器，并添加了几个输入按钮以控制录音和翻译功能。
- en: Most of the dynamic behaviors are implemented in `scripts.js`.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数动态行为是在`scripts.js`中实现的。
- en: 'To continue with the `index.html` code, execute the following command:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续编辑`index.html`代码，请执行以下命令：
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this code snippet, we have the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们有以下内容：
- en: We created the `Translation Text` and Translation Audio sections of the web
    user interface.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了网页用户界面的“翻译文本”和“翻译音频”部分。
- en: In the Translation Text section, we placed a spinner that's initially hidden
    from view and a couple of `<div>` that will be used to display the translation
    results.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“翻译文本”部分，我们放置了一个初始时隐藏的旋转图标，并且有几个`<div>`将用来显示翻译结果。
- en: In the Translation Audio section, we placed another spinner that's also initially
    hidden from view, along with an audio player that will be used to play back the
    translation audio.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“翻译音频”部分，我们放置了另一个初始时隐藏的旋转图标，以及一个音频播放器，用于播放翻译后的音频。
- en: scripts.js
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: scripts.js
- en: 'The following is the `scripts.js` file. Much of the Universal Translator''s
    dynamic behaviors are implemented in JavaScript. `scripts.js` is interacting with
    the endpoints and stitching together the overall user experience of the application:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`scripts.js`文件。许多“通用翻译器”的动态行为是通过 JavaScript 实现的。`scripts.js`与端点进行交互，构建应用程序的整体用户体验：
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This snippet defines the `serverUrl` as the address of `chalice local`. It
    also defines the `HttpError` to handle the exceptions that might occur during
    the HTTP requests:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段将`serverUrl`定义为`chalice local`的地址，并定义了`HttpError`来处理可能在 HTTP 请求中发生的异常：
- en: '[PRE30]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This code snippet follows the recommended audio recording implementation from
    [https://github.com/intercom/MediaStreamRecorder](https://github.com/intercom/MediaStreamRecorder)
    which we will not cover. There are a few details to point out:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段遵循了[https://github.com/intercom/MediaStreamRecorder](https://github.com/intercom/MediaStreamRecorder)中推荐的音频录制实现，我们将不在此详细介绍。这里有一些细节需要注意：
- en: Universal Translator supports upto 30 seconds of audio recording, defined in
    the `maxAudioLength` constant. This length should be sufficient for translation
    of short phrases.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Universal Translator支持最多30秒的音频录制，长度由`maxAudioLength`常量定义。这个时长足以翻译简短的短语。
- en: The audio recording format is set to `audio/wav`, which is one of the formats
    supported by Amazon Transcribe.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频录制格式被设置为`audio/wav`，这是Amazon Transcribe支持的格式之一。
- en: 'When the audio recording is completed, we perform two tasks:'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当音频录制完成后，我们执行两个任务：
- en: We place the recorded bits in a JavaScript File object with the filename `recorded_audio.wav`;
    this will be the filename of the uploaded recording to S3\. Since the recordings
    all have the same filename, a previously uploaded recording will be replaced when
    a new recording is uploaded.
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将录制的音频数据放入一个JavaScript文件对象中，文件名为`recorded_audio.wav`；这将是上传到S3的录音文件名。由于所有录音的文件名相同，因此上传新的录音时会替换掉之前上传的录音。
- en: We update the audio player in the Record Audio section with an Object URL to
    the recorded audio for playback.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在录音音频部分更新音频播放器，使用录音音频的Object URL进行播放。
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `toggleRecording` function in `scripts.js` makes the first input button
    beneath the audio player a toggle button. This toggle button starts or stops the
    audio recording with the `MediaStreamRecorder` implementation preceding.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`scripts.js`中的`toggleRecording`函数使音频播放器下方的第一个输入按钮成为一个切换按钮。此切换按钮通过前面的`MediaStreamRecorder`实现开始或停止音频录制。'
- en: 'Next, we define five functions:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义五个函数：
- en: '`uploadRecording()`: Uploads the audio recording via Base64 encoding to our
    Upload Recording Endpoint'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uploadRecording()`：通过Base64编码将音频录音上传到我们的上传录音端点。'
- en: '`translateRecording()`: Calls our Translate Recording Endpoint to translate
    the audio recording'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`translateRecording()`：调用我们的翻译录音端点来翻译音频录音。'
- en: '`updateTranslation()`: Updates the Translation Text section with the returned
    transcription and translation texts'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateTranslation()`：更新翻译文本部分，显示返回的转录和翻译文本。'
- en: '`synthesizeTranslation()`: Calls our Synthesize Speech Endpoint to generate
    audio speech of the translation text'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`synthesizeTranslation()`：调用我们的语音合成端点生成翻译文本的音频语音。'
- en: '`updateTranslationAudio()`: Updates the audio player in the Translation Audio
    section with the audio speech URL to enable playback'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateTranslationAudio()`：更新翻译音频部分的音频播放器，将音频语音的URL加载进去以启用播放。'
- en: These functions correspond to the sequential steps of the translation user experience.
    We broke them into individual functions to make the JavaScript code more modular
    and readable; each function performs a specific task. Let's go through the implementation
    details of these functions.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数对应于翻译用户体验的顺序步骤。我们将它们拆分为单独的函数，使JavaScript代码更加模块化和可读；每个函数执行一个特定的任务。让我们逐个了解这些函数的实现细节。
- en: 'Let''s have a look at the `uploadRecording()` function as shown in the following
    code block:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`uploadRecording()`函数，如下所示的代码块所示：
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding code, we have the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有以下内容：
- en: The `uploadRecording()` function creates a Base64 encoded string from the File
    object that's holding the audio recording.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uploadRecording()`函数通过将文件对象中的音频录音转换为Base64编码的字符串来创建上传数据。'
- en: This function formats the JSON payload to include the `filename` and `filebytes`
    that our endpoint is expecting.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数格式化JSON负载，以包括我们端点所期望的`filename`和`filebytes`。
- en: It then sends the HTTP POST request with the JSON payload to our Upload Recording
    Endpoint URL and returns the response JSON.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它向我们的上传录音端点URL发送HTTP POST请求，并返回JSON响应。
- en: This is almost the same code as the `uploadImage()` function in the Pictorial
    Translator application; the only difference is the File is coming from the audio
    recorder.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这与Pictorial Translator应用中的`uploadImage()`函数几乎相同，唯一的区别是文件来自音频录制器。
- en: 'Let''s have a look at the `translateRecording()` function as shown in the following
    code block:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`translateRecording()`函数，如下所示的代码块所示：
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the preceding code, we have the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有以下内容：
- en: The `translateRecording()` function first grabs the values of the languages
    from the `fromLang` and `toLang` dropdowns in the web user interface.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`translateRecording()`函数首先从网页用户界面的`fromLang`和`toLang`下拉菜单中获取语言的值。'
- en: The function then starts the spinner, signaling the start of the translation
    process to the user. It then calls our Translate Recording Endpoint and waits
    for the response.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数启动旋转器，向用户发出开始翻译过程的信号。然后它调用我们的翻译录音端点，并等待响应。
- en: 'Let''s have a look at the `updateTranslation()` function as shown in the following
    code block:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`updateTranslation()`函数，如下代码块所示：
- en: '[PRE34]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the preceding code, the following applies:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下内容适用：
- en: When the Translate Recording Endpoint responds, the `updateTranslation()` function
    hides the spinner.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当翻译录音端点响应时，`updateTranslation()`函数会隐藏旋转指示器。
- en: The function then updates the `Translation Text` section with the transcription
    and translation texts.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数随后会更新`Translation Text`部分，包含转录和翻译文本。
- en: 'Let''s have a look at the `synthesizeTranslation()` function as shown in the
    following code block:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`synthesizeTranslation()`函数，如下代码块所示：
- en: '[PRE35]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding code, we have the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有如下内容：
- en: The `synthesizeTranslation()` function starts the spinner to signal the start
    of the speech synthesis process to the user.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`synthesizeTranslation()`函数启动旋转指示器，以通知用户开始进行语音合成过程。'
- en: This function then calls the Synthesize Speech Endpoint and waits for the response.
    Remember this endpoint is expecting JSON parameters, which it is setting in the
    `fetch()` call.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数随后会调用语音合成端点并等待响应。请记住，该端点期望的是JSON参数，而这些参数在`fetch()`调用中设置。
- en: 'Let''s have a look at the `updateTranslationAudio()` function as shown in the
    following code block:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`updateTranslationAudio()`函数，如下代码块所示：
- en: '[PRE36]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding code, we have the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有如下内容：
- en: When the Synthesize Speech Endpoint responds, the `updateTranslationAudio()`
    function stops the audio synthesis spinner.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当语音合成端点响应时，`updateTranslationAudio()`函数会停止语音合成的旋转指示器。
- en: This function then updates the audio player with the URL of the synthesized
    translation audio.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数随后会使用合成的翻译音频的URL更新音频播放器。
- en: 'All preceding five functions are stitched together by the `uploadAndTranslate()`
    function as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前面提到的五个函数都通过`uploadAndTranslate()`函数将其串联在一起，如下所示：
- en: '[PRE37]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice how clear the sequence of events are in the `uploadAndTranslate()` function.
    By way of a final step in this function, we enable the record toggle button so
    that the user can start the next translation.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`uploadAndTranslate()`函数中的事件顺序是多么清晰。作为该函数的最终步骤，我们启用了记录切换按钮，以便用户可以开始下一次翻译。
- en: 'The final project structure for the Universal Translator application should
    be as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 通用翻译器应用程序的最终项目结构应如下所示：
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, we have completed the implementation of the Universal Translator application.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了通用翻译器应用程序的实现。
- en: Deploying the Universal Translator to AWS
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将通用翻译器部署到AWS
- en: The deployment steps for the Universal Translator application is the same as
    the deployment steps of the projects in the previous chapters. We include them
    here for completion.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 通用翻译器应用程序的部署步骤与前几章项目的部署步骤相同。我们在此包含它们以便完整性。
- en: 'First, let''s tell Chalice to perform policy analysis for us by setting `"autogen_policy"`
    to `false` in the `config.json` file in the `.chalice` directory of the project
    structure:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们通过在项目结构的`.chalice`目录中的`config.json`文件中将`"autogen_policy"`设置为`false`来告诉Chalice为我们执行策略分析：
- en: '[PRE39]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we create a new file `policy-dev.json` in the `chalice` directory to
    manually specify the AWS services the project needs:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在`chalice`目录中创建一个新的文件`policy-dev.json`，手动指定项目需要的AWS服务：
- en: '[PRE40]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we deploy the Chalice backend to AWS by running the following command
    within the `Capabilities` directory:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们通过在`Capabilities`目录中运行以下命令将Chalice后端部署到AWS：
- en: '[PRE41]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When the deployment is complete, Chalice will output a RESTful API URL that
    looks similar to `https://<UID>.execute-api.us-east-1.amazonaws.com/api/` where
    the `<UID>` is a unique identifier string. This is the server URL your frontend
    app should hit to access the application backend running on AWS.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 部署完成后，Chalice会输出一个类似于`https://<UID>.execute-api.us-east-1.amazonaws.com/api/`的RESTful
    API URL，其中`<UID>`是一个唯一的标识符字符串。这就是前端应用程序应该访问的服务器URL，用于连接在AWS上运行的应用程序后端。
- en: 'Next we will upload the `index.html` and `scripts.js` files to this S3 bucket,
    and then set the permissions to publicly readable. Before we do that, we need
    to make a change in `scripts.js` as shown in the following. Remember, the website
    will be running in the cloud now, and won''t have access to our local HTTP server.
    Replace the local server URL with the one from our backend deployment:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将`index.html`和`scripts.js`文件上传到这个S3桶中，并设置权限为公开可读。在此之前，我们需要在`scripts.js`中做如下更改。请记住，网站现在将在云端运行，并且无法访问我们的本地HTTP服务器。将本地服务器的URL替换为来自后端部署的URL：
- en: '[PRE42]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now the Universal Translator application is accessible to everyone on the Internet!
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通用翻译器应用程序可以通过互联网让每个人都能访问！
- en: Discussing the project enhancement ideas
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论项目增强想法
- en: 'At the end of each hands-on project in Part 2, we provide you with a few ideas
    to extend the intelligence-enabled application. Here are a couple of ideas to
    enhance the Universal Translator:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分的每个动手项目结束时，我们都会提供一些想法，以扩展智能启用应用程序。以下是增强通用翻译器的一些想法：
- en: Allow users to save default source language and output voice preferences within
    the application. The user is likely to use his or her native language as the source
    language and may prefer the translated speech to match the his or her gender and
    voice.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户在应用程序中保存默认的源语言和输出语音偏好设置。用户可能会将母语作为源语言，并可能希望翻译后的语音与其性别和声音相匹配。
- en: Add real-time transcription with Amazon Transcribe's Streaming Transcription
    feature. This feature can greatly reduce the user's wait time for the voice translation.
    At the time of this writing, the Python SDK does not support this feature, so
    your implementation will need a different SDK. Our architecture does support a
    polyglot system, a system written in multiple languages.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Amazon Transcribe 的流式转录功能添加实时转录。此功能可以大大减少用户等待语音翻译的时间。在撰写本文时，Python SDK 尚不支持此功能，因此您的实现将需要使用其他
    SDK。我们的架构确实支持多语言系统，即用多种语言编写的系统。
- en: The Universal Translator and the Pictorial Translator both provide translation
    capabilities. These two forms of translation capability can be combined into a
    single application for travelers and students, especially a mobile app that's
    always with the user in the real-world.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用翻译器和图像翻译器都提供翻译功能。这两种翻译功能可以结合成一个单一的应用程序，供旅行者和学生使用，尤其是一个在现实世界中始终伴随用户的移动应用。
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we built a Universal Translator application to translate spoken
    speech from one language to another. We combined speech-to-text, language translation,
    and text-to-speech capabilities from AWS AI services, including Amazon Transcribe,
    Amazon Translate, and Amazon Polly. This hands-on project continued our journey
    as AI practitioners to develop the skills and intuition for real-world AI applications.
    Along the way, we also discussed user experience and product design decisions
    of our Universal Translator application. Additionally, we demonstrated clean code
    reuse of Translation Service and Storage Service in the reference architecture
    defined in [Chapter 2](042787e6-6f54-4728-8354-e22d87be0460.xhtml), *Anatomy of
    a Modern AI Application*.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个通用翻译器应用程序，用于将口语从一种语言翻译成另一种语言。我们结合了来自 AWS AI 服务的语音转文本、语言翻译和文本转语音能力，包括
    Amazon Transcribe、Amazon Translate 和 Amazon Polly。这个动手项目继续了我们作为 AI 从业者的旅程，培养了我们开发实际
    AI 应用程序所需的技能和直觉。在这个过程中，我们还讨论了通用翻译器应用程序的用户体验和产品设计决策。此外，我们展示了在 [第 2 章](042787e6-6f54-4728-8354-e22d87be0460.xhtml)《现代
    AI 应用程序的构成》定义的参考架构中，翻译服务和存储服务的干净代码重用，*现代 AI 应用程序的架构*。
- en: In the next chapter, we will leverage more AWS AI services to create solutions
    that can simplify our lives. Being an AI practitioner is not just about knowing
    which services or APIs to use, but is also about being skilled in fusing good
    product and architecture designs with AI capabilities.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将利用更多的 AWS AI 服务来创建能够简化我们生活的解决方案。成为一名 AI 从业者不仅仅是了解使用哪些服务或 API，还需要具备将优秀的产品和架构设计与
    AI 能力融合的技能。
- en: References
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'For more information on Performing Speech-to-Text and Vice-versa with Amazon
    Transcribe and Amazon Polly, please refer to the following links:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用 Amazon Transcribe 和 Amazon Polly 进行语音转文本及反向操作的更多信息，请参考以下链接：
- en: '[https://www.verizonwireless.com/wireless-devices/accessories/google-pixel-buds/](https://www.verizonwireless.com/wireless-devices/accessories/google-pixel-buds/)'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.verizonwireless.com/wireless-devices/accessories/google-pixel-buds/](https://www.verizonwireless.com/wireless-devices/accessories/google-pixel-buds/)'
- en: '[https://www.washingtonpost.com/news/the-switch/wp/2017/11/15/i-tried-out-googles-translating-headphones-heres-what-i-found/?utm_term=.1cef17d669e2](https://www.washingtonpost.com/news/the-switch/wp/2017/11/15/i-tried-out-googles-translating-headphones-heres-what-i-found/?utm_term=.1cef17d669e2)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.washingtonpost.com/news/the-switch/wp/2017/11/15/i-tried-out-googles-translating-headphones-heres-what-i-found/?utm_term=.1cef17d669e2](https://www.washingtonpost.com/news/the-switch/wp/2017/11/15/i-tried-out-googles-translating-headphones-heres-what-i-found/?utm_term=.1cef17d669e2)'
- en: '[https://github.com/intercom/MediaStreamRecorder](https://github.com/intercom/MediaStreamRecorder)'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/intercom/MediaStreamRecorder](https://github.com/intercom/MediaStreamRecorder)'
