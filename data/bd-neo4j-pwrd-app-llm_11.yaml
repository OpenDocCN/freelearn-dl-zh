- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Integrating LangChain4j and Spring AI with Neo4j
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将LangChain4j和Spring AI与Neo4j集成
- en: Now that we have loaded the data into a graph, in this chapter, we will look
    at how we can use LangChain4j or Spring AI to augment the graph to enhance its
    capabilities and build a knowledge graph. We will look into integrating the graph
    with LLMs to generate a summary of customer purchases and create an embedding
    of that summary to represent the customer purchase history. These embeddings are
    crucial for enabling machine learning and graph algorithms to understand and process
    graph data. These embeddings can help us build a knowledge graph to provide more
    personal recommendations for customers by understanding purchase behaviors. We
    will also look at how to create embeddings of the detailed description of each
    article present in the dataset.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将数据加载到图中，在本章中，我们将探讨如何使用LangChain4j或Spring AI来增强图的功能并构建一个知识图谱。我们将研究如何将图与LLMs集成以生成客户购买的摘要，并创建该摘要的嵌入来表示客户购买历史。这些嵌入对于使机器学习和图算法能够理解和处理图数据至关重要。这些嵌入可以帮助我们构建知识图谱，通过理解购买行为为客户提供更个性化的推荐。我们还将探讨如何创建数据集中每个文章详细描述的嵌入。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Setting up LangChain4j and Spring AI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置LangChain4j和Spring AI
- en: Building your recommendation engine with LangChain4j
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LangChain4j构建你的推荐引擎
- en: Building your recommendation engine with Spring AI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring AI构建你的推荐引擎
- en: Fine-tuning your recommendation system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微调你的推荐系统
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will be using a Java IDE environment to work with the LangChain4j and Spring
    AI projects. You need to have these installed and know how to work with them.
    You will need the following to get started:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Java IDE环境来处理LangChain4j和Spring AI项目。你需要安装这些并了解如何使用它们。开始之前，你需要以下内容：
- en: Maven will be used to build a project and manage dependencies. If you are going
    to use the IntelliJ IDE (or IntelliJ IDEA), then Maven will be installed along
    with it, and you need not install it separately. If you are new to Maven, you
    can read more about it at [https://maven.apache.org/](https://maven.apache.org/).
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将使用Maven来构建项目和管理工作依赖。如果你打算使用IntelliJ IDE（或IntelliJ IDEA），那么Maven将与其一起安装，你无需单独安装。如果你是Maven的新手，你可以在[https://maven.apache.org/](https://maven.apache.org/)了解更多相关信息。
- en: Java 17.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 17。
- en: IntelliJ – These examples are built and tested with the IntelliJ IDE. You can
    use your preferred IDE, however. We will be using the IntelliJ IDEA tool to build
    and run our projects. You can download the tool from [https://www.jetbrains.com/idea/](https://www.jetbrains.com/idea/).
    You can download the Community Edition to run the examples in this chapter. You
    can read more about using this IDE to build Spring applications at [https://www.jetbrains.com/idea/spring/](https://www.jetbrains.com/idea/spring/).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntelliJ – 这些示例是用IntelliJ IDE构建和测试的。你可以使用你喜欢的IDE，但我们将使用IntelliJ IDEA工具来构建和运行我们的项目。你可以从[https://www.jetbrains.com/idea/](https://www.jetbrains.com/idea/)下载该工具。你可以下载社区版本来运行本章的示例。你可以在[https://www.jetbrains.com/idea/spring/](https://www.jetbrains.com/idea/spring/)了解更多关于如何使用此IDE构建Spring应用程序的信息。
- en: Spring Boot – If you are new to Spring Boot, you can go to [https://spring.io/projects/spring-boot](https://spring.io/projects/spring-boot)
    to learn more about it.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot – 如果你是对Spring Boot新手，你可以访问[https://spring.io/projects/spring-boot](https://spring.io/projects/spring-boot)来了解更多。
- en: 'Neo4j Desktop with the following plugins installed. We will be starting from
    the graph database we built in the last chapter. You can download Neo4j Desktop
    from [https://neo4j.com/download/](https://neo4j.com/download/). If you are new
    to Neo4j Desktop, you can learn more about it at [https://neo4j.com/docs/desktop-manual/current/](https://neo4j.com/docs/desktop-manual/current/).
    The code is tested with the 5.21.2 version of the database. The following are
    the plugins required:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了以下插件的Neo4j Desktop。我们将从上一章构建的图数据库开始。你可以从[https://neo4j.com/download/](https://neo4j.com/download/)下载Neo4j
    Desktop。如果你是Neo4j Desktop的新手，你可以在[https://neo4j.com/docs/desktop-manual/current/](https://neo4j.com/docs/desktop-manual/current/)了解更多。代码与数据库的5.21.2版本进行了测试。以下是需要安装的插件：
- en: APOC plugin – 5.21.2
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: APOC插件 – 5.21.2
- en: Graph Data Science library – 2.9.0
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形数据科学库 – 2.9.0
- en: The following figure shows how to install these plugins for a DBMS.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了如何为数据库管理系统安装这些插件。
- en: '![Figure 9.1 — Install plugins on Neo4j Desktop](img/B31107_09_01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 — 在Neo4j Desktop上安装插件](img/B31107_09_01.png)'
- en: Figure 9.1 — Install plugins on Neo4j Desktop
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 — 在Neo4j Desktop上安装插件
- en: When you select the DBMS on Neo4j Desktop, on the right side, it shows its details.
    Click on the **Plugins** tab and select the plugins you require. On the details
    pane, click on the **Install and Restart** button.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Neo4j Desktop中选择DBMS时，在右侧会显示其详细信息。点击**插件**选项卡并选择所需的插件。在详细信息面板中，点击**安装并重启**按钮。
- en: '**Note**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can find all the code you need at [https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch9](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch9).
    These are complete projects and ready to run in an IDE. We will only show snippets
    of the code in this chapter to showcase the usage. So, it might be a good idea
    to download the code to follow the steps in this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch9](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch9)找到您需要的所有代码。这些是完整的项目，可以在IDE中运行。在本章中，我们只展示代码片段以展示其用法。因此，下载代码以遵循本章中的步骤可能是个好主意。
- en: We will start with setting up the LangChain4j and Spring AI projects.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从设置LangChain4j和Spring AI项目开始。
- en: Setting up LangChain4j and Spring AI
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置LangChain4j和Spring AI
- en: We will take a look at setting up the Spring AI and LangChain4j projects using
    the **spring initializr** website ([https://start.spring.io/](https://start.spring.io/)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看如何使用**spring initializr**网站([https://start.spring.io/](https://start.spring.io/))设置Spring
    AI和LangChain4j项目。
- en: We will look at each of these technologies independently. LangChain4j and Spring
    AI are both options to perform the same tasks. We need only one of these frameworks
    to build GenAI projects. LangChain4j has been available for a bit longer than
    Spring AI. Both of them work pretty similarly in terms of the API and integrations.
    We will build the same application with both frameworks and see how similar they
    are. We will also identify the differences.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将独立查看这些技术。LangChain4j和Spring AI都是执行相同任务的选项。我们只需要其中一个框架来构建GenAI项目。LangChain4j比Spring
    AI更早一些时间可用。在API和集成方面，它们的工作方式相当相似。我们将使用这两个框架构建相同的应用程序，并查看它们有多么相似。我们还将确定它们之间的差异。
- en: 'The following are the steps we need to follow to create the starter projects:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要遵循以下步骤来创建启动项目：
- en: 'Setting up the LangChain4j project:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置LangChain4j项目：
- en: Go to the website, [https://start.spring.io/](https://start.spring.io/).
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问网站，[https://start.spring.io/](https://start.spring.io/)。
- en: Select **Maven** under the **Project** section.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**部分下选择**Maven**。
- en: Select **Java** under the **Language** section.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**语言**部分下选择**Java**。
- en: 'In the **Project Metadata** section, fill in the following values:'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目元数据**部分，填写以下值：
- en: '**Group**: `com.packt.genai.hnm.springai`'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组**: `com.packt.genai.hnm.springai`'
- en: '**Artifact**: `springai _graphaugment`'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工件**: `springai_graphaugment`'
- en: '**Name**: `springai _graphaugment`'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**: `springai_graphaugment`'
- en: '**Description**: `Graph Augmenting with Spring AI`'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**: `使用Spring AI进行图增强`'
- en: '**Package Name**: `com.packt.genai.hnm.springai.graphaugment`'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包名**: `com.packt.genai.hnm.springai.graphaugment`'
- en: '**Packaging**: `Jar`'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打包**: `Jar`'
- en: '**Java**: `17`'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java**: `17`'
- en: In the **Dependencies** section, click on the **Add Dependencies** button and
    select the **Spring Web** dependency.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**依赖项**部分，点击**添加依赖项**按钮并选择**Spring Web**依赖项。
- en: There are no other dependencies that are currently listed by the initializer
    to add to the project. We will add LangChain4j dependencies manually to the project.
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前初始化器没有列出其他依赖项需要添加到项目中。我们将手动将LangChain4j依赖项添加到项目中。
- en: Download and save the ZIP file that is generated.
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并保存生成的ZIP文件。
- en: 'Setting up the Spring AI project:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置Spring AI项目：
- en: Go to the website, [https://start.spring.io/](https://start.spring.io/).
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问网站，[https://start.spring.io/](https://start.spring.io/)。
- en: Select **Maven** under the **Project** section.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**部分下选择**Maven**。
- en: Select **Java** under the **Language** section.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**语言**部分下选择**Java**。
- en: 'In the **Project Metadata** section, fill in the following values:'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目元数据**部分，填写以下值：
- en: '**Group**: `com.packt.genai.hnm.langchain`'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组**: `com.packt.genai.hnm.langchain`'
- en: '**Artifact**: `langchain_graphaugment`'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工件**: `langchain_graphaugment`'
- en: '**Name**: `langchain_graphaugment`'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**: `langchain_graphaugment`'
- en: '**Description**: `Graph Augmenting with Langchain4J`'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**: `使用Langchain4J进行图增强`'
- en: '**Package Name**: `com.packt.genai.hnm.langchain.graphaugment`'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包名**: `com.packt.genai.hnm.langchain.graphaugment`'
- en: '**Packaging**: `Jar`'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打包**: `Jar`'
- en: '**Java**: `17`'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java**: `17`'
- en: 'In the **Dependencies** section, click on the **Add Dependencies** button to
    select the following dependencies:'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**依赖项**部分，点击**添加依赖项**按钮以选择以下依赖项：
- en: '**Spring Web**'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Web**'
- en: '**OpenAI**'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenAI**'
- en: '**Neo4j Vector Database**'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Neo4j向量数据库**'
- en: Download and save the ZIP file that is generated.
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并保存生成的ZIP文件。
- en: This will only give us a skeleton project with which we will build the application.
    The skeleton project gives us a basic structure upon which we can add more logic.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这只会给我们一个基本的项目框架，我们将在此基础上添加更多逻辑来构建应用程序。
- en: 'Let us look at what we want out of our application before we go ahead and build
    it. We loaded the H&M transaction data into the graph database in the previous
    chapter. Currently, it holds the customers, articles, and transactions along with
    some helper relationships that mark the first transaction in a given season and
    year. As we want to build a personal recommendation system, we want to enhance
    the graph to understand customer behavior and provide recommendations. For this
    purpose, we will be taking the following approach:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续构建应用程序之前，让我们看看我们希望从应用程序中得到什么。在前一章中，我们将H&M的交易数据加载到了图数据库中。目前，它包含了客户、商品和交易，以及一些辅助关系，这些关系标记了给定季节和年份中的第一次交易。由于我们想要构建一个个性化推荐系统，我们希望增强图数据库以理解客户行为并提供推荐。为此，我们将采取以下方法：
- en: Select a season for which to understand the purchase behavior. For example,
    say we want to find the customers who made purchases in summer 2019 and fall 2019
    and use the transactions between those seasons to understand customer behavior.
    Note that there might be some customers who did not make any transactions in the
    fall of 2019, even though they might have made transactions in the summer of 2019\.
    We are ignoring those customers for this exercise, to make things a bit simpler.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个季节来了解购买行为。例如，假设我们想要找到在2019年夏天和秋天进行购买的客户，并使用这些季节之间的交易来理解客户行为。请注意，可能有一些客户在2019年的秋天没有进行任何交易，尽管他们可能在夏天进行了交易。为了使事情更简单，我们将忽略这些客户。
- en: Retrieve the articles purchased during these transactions. The articles should
    match the condition (purchases made in the summer and fall of 2019) in the order
    they are purchased. We will then use an LLM to summarize these purchases. This
    summarization preserves the order of the articles purchased.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取这些交易中购买的商品。这些商品应满足条件（在2019年的夏天和秋天购买），并按照购买顺序排列。然后我们将使用LLM来总结这些购买。这种总结保留了购买商品的顺序。
- en: Use the LLM to generate embedding for this summary text. We will be leveraging
    an OpenAI LLM for this part.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用LLM为这篇总结文本生成嵌入。我们将利用OpenAI的LLM来完成这一部分。
- en: Store these embeddings. We will be storing them on the season relationship for
    which these embeddings are generated. For example, if we are generating a summary
    for the summer of 2019, we will store the resulting embeddings on the `SUMMER_2019`
    relationship. An OpenAI LLM is used to generate the embeddings.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储这些嵌入。我们将将这些嵌入存储在生成这些嵌入的季节关系上。例如，如果我们正在为2019年的夏天生成总结，我们将把生成的嵌入存储在`SUMMER_2019`关系上。我们将使用OpenAI的LLM来生成嵌入。
- en: In the next section, we will take a look at building an application that performs
    the functions we described previously using LangChain4j.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用LangChain4j构建一个执行我们之前描述的功能的应用程序。
- en: Building your recommendation engine with LangChain4j
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LangChain4j构建你的推荐引擎
- en: 'In this section, we will look at building a graph augmentation application
    that leverages LangChain4j. In this project, we will be using the GraphRAG approach
    to generate embeddings for a transaction chain that meets our requirements. We
    will be using the Neo4j graph retriever to retrieve the transaction chain that
    meets our requirements, as well as an LLM to generate a summary of those transactions
    to describe the customer purchase behavior and generate an embedding. The embedding
    generated will be a vector representation that describes the text summary in a
    manner that can be leveraged by machine learning or Graph Data Science algorithms.
    It can also be leveraged for vector search purposes. This article explains embeddings
    in the context of LLMs well: [https://ml-digest.com/architecture-training-of-the-embedding-layer-of-llms/](https://ml-digest.com/architecture-training-of-the-embedding-layer-of-llms/).
    We will start with the ZIP file downloaded in the last section. We need to unzip
    the file we have downloaded. Once it is unzipped, we will load the project into
    the IntelliJ platform using these steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨构建一个利用 LangChain4j 的图增强应用程序。在这个项目中，我们将使用 GraphRAG 方法为满足我们要求的交易链生成嵌入。我们将使用
    Neo4j 图检索器检索满足我们要求的交易链，以及一个 LLM 生成这些交易的摘要以描述客户购买行为并生成嵌入。生成的嵌入将是一个向量表示，以机器学习或图数据科学算法可以利用的方式描述文本摘要。它也可以用于向量搜索。这篇文章很好地解释了
    LLM 上下文中的嵌入：[https://ml-digest.com/architecture-training-of-the-embedding-layer-of-llms/](https://ml-digest.com/architecture-training-of-the-embedding-layer-of-llms/)。我们将从上一节下载的
    ZIP 文件开始。我们需要解压我们下载的文件。一旦解压，我们将使用以下步骤将这些项目加载到 IntelliJ 平台：
- en: Launch the IntelliJ IDE.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 IntelliJ IDE。
- en: Click on **File** | **New** | **Project from Existing Sources…**.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **文件** | **新建** | **从现有源创建项目…**。
- en: '![Figure 9.2 — Create a new project](img/B31107_09_02.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 — 创建新项目](img/B31107_09_02.png)'
- en: Figure 9.2 — Create a new project
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 — 创建新项目
- en: 3\. Select the `pom.xml` file from the directory we unzipped.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 从我们解压的目录中选择 `pom.xml` 文件。
- en: '![Figure 9.3 — Select pom.xml](img/B31107_09_03.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 — 选择 pom.xml](img/B31107_09_03.png)'
- en: Figure 9.3 — Select pom.xml
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 — 选择 pom.xml
- en: 4\. Click on **Trust Project** to load the project.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 点击 **信任项目** 以加载项目。
- en: '![Figure 9.4 — Trust Project](img/B31107_09_04.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 —信任项目](img/B31107_09_04.png)'
- en: Figure 9.4 — Trust Project
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 — 信任项目
- en: 5\. Select **New Window** when prompted.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 当提示时，选择 **新窗口**。
- en: '![Figure 9.5 — Select New Window](img/B31107_09_05.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 — 选择新窗口](img/B31107_09_05.png)'
- en: Figure 9.5 — Select New Window
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 — 选择新窗口
- en: 6\. Once the project is loaded, you can continue to the next section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 一旦项目加载完成，您可以继续到下一节。
- en: In the next section, we will update the project dependencies.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更新项目依赖项。
- en: 'LangChain4j: updating the project dependencies'
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LangChain4j：更新项目依赖项
- en: When we used the Spring starter to prepare the starter project, we could only
    add the dependencies identified by that tool. We need to edit the `pom.xml` file
    to add the dependencies.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Spring 启动器准备启动项目时，我们只能添加由该工具识别的依赖项。我们需要编辑 `pom.xml` 文件来添加依赖项。
- en: 'The following are the dependencies we need to add to the project:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们需要添加到项目中的依赖项：
- en: 'LangChain4j Spring Boot starter – This dependency provides the Spring Boot
    integration of LangChain4j:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LangChain4j Spring Boot 启动器 – 这个依赖提供了 LangChain4j 的 Spring Boot 集成：
- en: '[PRE0]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'LangChain4j OpenAI integration – This dependency provides the OpenAI integration:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LangChain4j OpenAI 集成 – 这个依赖提供了 OpenAI 集成：
- en: '[PRE1]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'LangChain4j Neo4j integration – This dependency provides the Neo4j integration:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LangChain4j Neo4j 集成 – 这个依赖提供了 Neo4j 集成：
- en: '[PRE2]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'LangChain4j LLM embeddings integration – This dependency provides the LLM embeddings
    API:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LangChain4j LLM 嵌入集成 – 这个依赖提供了 LLM 嵌入 API：
- en: '[PRE3]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The latest integration options and details can be found at [https://docs.langchain4j.dev/category/integrations](https://docs.langchain4j.dev/category/integrations).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最新集成选项和详细信息可以在 [https://docs.langchain4j.dev/category/integrations](https://docs.langchain4j.dev/category/integrations)
    找到。
- en: Now that we have added the project dependencies, we need to update the configuration
    properties that are required for the application. In the next section, we will
    be looking at updating the application properties.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了项目依赖项，我们需要更新应用程序所需的配置属性。在下一节中，我们将探讨更新应用程序属性。
- en: '**Note**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: When you have made changes to the `pom.xml` file, you might have to reload the
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当您对 `pom.xml` 文件进行了更改，可能需要重新加载
- en: project for the IDE to update all the dependencies correctly. You can learn
    more about how to work with Maven projects with IntelliJ IDEA at [https://www.jetbrains.com/help/idea/delegate-build-and-run-actions-to-maven.html#maven_reimport](https://www.jetbrains.com/help/idea/delegate-build-and-run-actions-to-maven.html#maven_reimport).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为IDE更新所有依赖项的项目。您可以在[https://www.jetbrains.com/help/idea/delegate-build-and-run-actions-to-maven.html#maven_reimport](https://www.jetbrains.com/help/idea/delegate-build-and-run-actions-to-maven.html#maven_reimport)了解更多关于如何在IntelliJ
    IDEA中与Maven项目一起工作的信息。
- en: 'LangChain4j: updating the application properties'
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LangChain4j：更新应用程序属性
- en: 'In this section, we need to update the application properties for the dependencies
    we added in the last section to be able to leverage the APIs. We need to add this
    configuration to the `application.properties` file in the project. Since we will
    be using the OpenAI LLM for the chat model and embeddings, we need to acquire
    an API key for this purpose. We need to visit the following website to acquire
    an API key for this purpose: [https://platform.openai.com/docs/overview](https://platform.openai.com/docs/overview).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们需要更新应用程序属性，以便利用我们上一节中添加的依赖项的API。我们需要将此配置添加到项目的`application.properties`文件中。由于我们将使用OpenAI
    LLM作为聊天模型和嵌入，因此我们需要为此目的获取一个API密钥。我们需要访问以下网站以获取此目的的API密钥：[https://platform.openai.com/docs/overview](https://platform.openai.com/docs/overview)。
- en: 'These are the configuration properties we need to add:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们需要添加的配置属性：
- en: 'OpenAI chat model integration – We need to add this configuration to `application.properties`:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenAI聊天模型集成 – 我们需要将此配置添加到`application.properties`：
- en: '[PRE4]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'OpenAI embeddings integration – We need to add this configuration to `application.properties`:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenAI嵌入集成 – 我们需要将此配置添加到`application.properties`：
- en: '[PRE5]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Neo4j integration – We will add basic Neo4j integration this time, not the
    Neo4j vector database-related integration:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Neo4j集成 – 这次我们将添加基本的Neo4j集成，而不是与Neo4j向量数据库相关的集成：
- en: '[PRE6]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that we have looked at the configuration properties, let us start building
    the application. We will start with Neo4j database integration, and then add chat
    model integration to summarize the transactions and generate embeddings for the
    summary. Finally, we will take a look at building a REST endpoint to invoke those
    requests as needed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看完配置属性，让我们开始构建应用程序。我们将从Neo4j数据库集成开始，然后添加聊天模型集成来总结交易并生成摘要的嵌入。最后，我们将查看如何构建一个REST端点以按需调用这些请求。
- en: 'LangChain4j: Neo4j integration'
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LangChain4j：Neo4j集成
- en: 'We will take a look at Neo4j integration first. We will look at this first
    as we need a means to integrate with the database to perform these tasks:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将查看Neo4j集成。我们将首先查看这一点，因为我们需要一种与数据库集成的手段来执行这些任务：
- en: Set up connectivity to be able to perform read and write transactions.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置连接以能够执行读取和写入事务。
- en: Read the articles for the transactions that occurred for the specified season.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取指定季节发生的交易的文章。
- en: Persist (save) the embeddings once they are generated.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦生成嵌入，就将其持久化（保存）。
- en: 'Before we can build this logic, we need to create a **configuration bean**
    for Neo4j connectivity. We can define that bean like this to read from `application.properties`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建这个逻辑之前，我们需要为Neo4j连接创建一个**配置Bean**。我们可以这样定义这个Bean来从`application.properties`中读取：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `ConfigurationProperties` annotation on top of the class definition will
    read `application.properties` and initialize the properties in the bean. The `prefix`
    option tells us to read only the properties that start with that prefix. For example,
    if we want the `uri` field to be populated, then we need to add the `neo4j.uri`
    property to the configuration. We have not included all the getter and setter
    code that is required to read the properties from this bean here.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义上方的`ConfigurationProperties`注解将读取`application.properties`并初始化Bean中的属性。`prefix`选项告诉我们只读取以该前缀开始的属性。例如，如果我们想填充`uri`字段，那么我们需要将`neo4j.uri`属性添加到配置中。我们没有在这里包含从该Bean读取属性所需的所有getter和setter代码。
- en: 'Now, we will define a service to provide integration with the Neo4j database
    to read the articles and customer transactions data and update the embeddings
    as needed:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将定义一个服务，以提供与Neo4j数据库的集成，读取文章和客户交易数据，并根据需要更新嵌入：
- en: 'Define the service class using `@Service` annotation. We also need to inject
    `Neo4JConfiguration` here:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`@Service`注解定义服务类。我们还需要在这里注入`Neo4JConfiguration`：
- en: '[PRE8]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the `setup` method to initialize the connection to the Neo4j database:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`setup`方法添加到初始化与Neo4j数据库的连接：
- en: '[PRE9]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the method to get the customer transactions data for given start- and end-of-season
    values. Based on the start- and end-of-season values provided, it retrieves the
    `elementId` value of the start-of-season value and the article description in
    the sequence they are purchased. We need this `elementId` value to save the embeddings
    later. We can see that we are trying to get more related data from the article
    attributes instead of just the description. This way, we can include more attributes,
    such as color, as part of the summary, so that we can represent them as embeddings
    more accurately:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个方法来获取给定季节开始和结束值客户交易数据。根据提供的季节开始和结束值，它检索开始季节值的`elementId`值和购买顺序中的文章描述。我们需要这个`elementId`值来稍后保存嵌入。我们可以看到，我们正在尝试从文章属性中获取更多相关数据，而不仅仅是描述。这样，我们可以包括更多属性，如颜色，作为摘要的一部分，以便我们可以更准确地表示它们作为嵌入：
- en: '[PRE10]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the method to get the articles from the database:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将获取数据库中文章的方法添加：
- en: '[PRE11]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add a method to save the embeddings for the selected season of a customer.
    We are keeping the summary in the graph to understand what the embedding represents.
    Once we understand this aspect, we don’t need to store the summary in the database:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个方法来保存客户选定季节的嵌入。我们将摘要保留在图中，以了解嵌入表示什么。一旦我们理解了这个方面，我们就不需要将摘要存储在数据库中：
- en: '[PRE12]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add a method to save the embeddings for the `Article` text on an `Article`
    node:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个方法来保存`Article`节点上`Article`文本的嵌入：
- en: '[PRE13]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: From the code, we can see that this service depends on `Neo4jConfiguration`
    and provides these methods.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码中我们可以看到，这个服务依赖于`Neo4jConfiguration`并提供了这些方法。
- en: The code flow here is simple and provides utility methods to interact with a
    Neo4j database. The methods to get and save data have Cypher queries embedded
    into the code here.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码流程简单，提供了与Neo4j数据库交互的实用方法。获取和保存数据的方法在这里嵌入Cypher查询。
- en: Next, we will take a look at an OpenAI chat model integration that can generate
    a summary for the list of articles.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看一个OpenAI聊天模型集成，它可以生成文章列表的摘要。
- en: 'LangChain4j: OpenAI chat integration'
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LangChain4j：OpenAI聊天集成
- en: To integrate the chat, we need to define `AiService`. This is the API exposed
    by Langchain4J to build Java applications.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要集成聊天，我们需要定义`AiService`。这是Langchain4J暴露的API，用于构建Java应用程序。
- en: 'Let’s see how we can do this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何做到这一点：
- en: 'When we define `AiService`, the LangChain4j Spring Framework provides the implementation
    under the covers to make it very easy to invoke the chat service. Let’s look at
    how this can be defined:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们定义`AiService`时，LangChain4j Spring框架在幕后提供了实现，使得调用聊天服务变得非常简单。让我们看看如何定义它：
- en: '[PRE14]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We set a role for the LLM chat engine. This sets the context for the engine
    on what guidelines to use to handle the data:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为LLM聊天引擎设置了一个角色。这为引擎设置了处理数据的上下文，即使用什么指南来处理数据：
- en: '[PRE15]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We set a goal for the LLM engine here on how it should process the data. This
    describes what the input data is and how it is structured:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里为LLM引擎设置了一个目标，说明它应该如何处理数据。这描述了输入数据是什么以及它的结构：
- en: '[PRE16]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The response directive for the LLM gives directions on how the response should
    be structured:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LLM的响应指令规定了响应应该如何结构化：
- en: '[PRE17]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `Data` section has the `{text}` variable defined, which is substituted
    with the input the method receives:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Data`部分定义了`{text}`变量，该变量用方法接收到的输入进行替换：'
- en: '[PRE18]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we are defining an interface with an `@AiService` annotation. In this
    service, we need to define a chat method. We will be using a simple AI chat service
    with a `System Message` option here. To read about the common operations and advanced
    operations that `AIServices` offers, please read the documentation at [https://docs.langchain4j.dev/tutorials/ai-services/](https://docs.langchain4j.dev/tutorials/ai-services/).
    Here, we are asking the LLM to act like a fashion expert and give us a summary
    of customer fashion preferences and highlight the top purchases, keeping the order
    of purchases in mind. The `input` parameter from the text is used as input data
    to the chat assistant.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个带有`@AiService`注解的接口。在这个服务中，我们需要定义一个聊天方法。在这里，我们将使用一个简单的带有`System Message`选项的AI聊天服务。要了解`AIServices`提供的常见操作和高级操作，请阅读[https://docs.langchain4j.dev/tutorials/ai-services/](https://docs.langchain4j.dev/tutorials/ai-services/)中的文档。在这里，我们要求LLM扮演时尚专家的角色，并给出客户时尚偏好的摘要，并突出显示顶级购买，同时考虑到购买顺序。文本中的`input`参数被用作聊天助手的输入数据。
- en: 'Now we will take a look at how we can invoke this chat request:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看看如何调用这个聊天请求：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We will take a look at embedding model integration next.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将接下来看看嵌入模型集成。
- en: 'LangChain4j: OpenAI embedding model integration'
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LangChain4j：OpenAI 嵌入模型集成
- en: 'Embedding model integration is pretty simple since we have already enabled
    `AiService` for the chat service. The embedding model usage looks as shown in
    the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入模型集成相当简单，因为我们已经为聊天服务启用了 `AiService`。嵌入模型的使用方式如下所示：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can see from the code that it is as simple as adding `EmbeddingModel` to
    the class and initializing it using a constructor. When the Spring Boot application
    starts, the appropriate embedding model implementation based on properties is
    instantiated and assigned to this variable. This service provides a method to
    generate the embedding for a given text.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码中我们可以看到，这就像是将 `EmbeddingModel` 添加到类中并使用构造函数初始化它一样简单。当 Spring Boot 应用程序启动时，根据属性实例化并分配给这个变量的适当嵌入模型实现。此服务提供了一个为给定文本生成嵌入的方法。
- en: Now that we have looked at all the services defined, let us look at how we can
    use all of these to build the application to augment a customer transactions graph.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看所有定义的服务，让我们看看我们如何使用所有这些来构建增强客户交易图的程序。
- en: 'LangChain4j: final application'
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LangChain4j：最终应用
- en: 'For the final application, we will build a REST endpoint to issue the request
    to perform the augmentation. Since the process itself can take time, it is split
    into two parts:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最终应用，我们将构建一个 REST 端点以发出执行增强的请求。由于该过程本身可能需要时间，它被分为两部分：
- en: Issue a request to start the augmentation process. This returns a request ID.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发出请求以启动增强过程。这将返回一个请求 ID。
- en: We can use the request ID returned in step 1 to check the progress of the request.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用步骤 1 中返回的请求 ID 来检查请求的进度。
- en: 'Let us look at the REST controller first to issue requests:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看 REST 控制器以发出请求：
- en: 'We need to create a REST controller to handle the HTTP requests:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一个 REST 控制器来处理 HTTP 请求：
- en: '[PRE22]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Inject the individual services defined using the `Autowired` directive:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Autowired` 指令注入定义的各个服务：
- en: '[PRE23]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Define the global variable to hold the current processing requests:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义全局变量以保存当前处理请求：
- en: '[PRE24]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the method to start the customer transactions augmenting process. This
    method takes the start- and end-of-season values and creates a `ProcessRequest`
    object. It starts a process thread that requests and returns a `UUID` for this
    request. We keep the `UUID` and `ProcessRequest` mapping so that we can provide
    the status when requested:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加启动客户交易增强过程的方法。此方法接受季节的开始和结束值，并创建一个 `ProcessRequest` 对象。它启动一个请求并返回此请求的 `UUID`
    的进程线程。我们保留 `UUID` 和 `ProcessRequest` 映射，以便在请求时提供状态：
- en: '[PRE25]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the method to start the article text augmentation process:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加启动文章文本增强过程的方法：
- en: '[PRE26]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add a method to get the status of the specified request ID:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个获取指定请求 ID 状态的方法：
- en: '[PRE27]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Note**'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The graph augmenting process can take a lot of time. In particular, the summary
    generation part using the LLM chat API can be time-consuming and it can take quite
    a lot of time to augment all the customers that match the requirements, say, the
    summer of 2019 purchases. For that reason, the database dump that has the complete
    augmentation only covers around 10,000 customers.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图增强过程可能需要很长时间。特别是，使用 LLM 聊天 API 生成的摘要部分可能很耗时，并且增强所有符合要求的客户，比如 2019 年夏天的购买，可能需要相当多的时间。因此，包含完整增强的数据库转储仅覆盖大约
    10,000 名客户。
- en: 'Now, let us look at the process request implementation. This is where we tie
    in all the various APIs to perform the required process:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看处理请求的实现。这是我们将所有各种 API 绑定在一起以执行所需过程的地方：
- en: 'We need to define a class `ProcessRequest` that implements the `Runnable` interface.
    We will start a thread as these requests are long-running ones. The chat service,
    embedding model service, Neo4j service, and other parameters are passed as input
    when we create this request. This class keeps track of the current processing
    status:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要定义一个实现 `Runnable` 接口的 `ProcessRequest` 类。由于这些请求是长时间运行的，我们将启动一个线程。当创建此请求时，聊天服务、嵌入模型服务、Neo4j
    服务和其他参数作为输入传递。此类跟踪当前处理状态：
- en: '[PRE28]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `run` method implements the actual process:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`run` 方法实现了实际过程：'
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Retrieve the customer transactions data from the Neo4j database. The output
    is a list, where each record contains the relationship ID for the start season
    as the context and the description of the articles in the order in which they
    were purchased:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Neo4j数据库中检索客户交易数据。输出是一个列表，其中每个记录包含起始季度的关系ID作为上下文，以及按购买顺序排列的文章描述：
- en: '[PRE30]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once you reach the required batch size of results collected, save the data
    to the Neo4j database:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收集到所需的结果批次大小，将数据保存到Neo4j数据库中：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Retrieve the customer purchase summary from the LLM chat service by passing
    the list of transactions retrieved from the graph:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过传递从图中检索到的交易列表，从LLM聊天服务中检索客户购买摘要：
- en: '[PRE32]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For the summary we get from the LLM chat service, create an embedding by leveraging
    the embedding service:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于从LLM聊天服务获得的摘要，利用嵌入服务创建嵌入：
- en: '[PRE33]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Save the summary and embedding along with the relationship context ID into
    a record and then save it into a batch:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将摘要和嵌入以及关系上下文ID保存到记录中，然后将其保存到批次中：
- en: '[PRE34]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If any data is left in the batch, save that data to the Neo4j database:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果批次中还有任何数据，将其保存到Neo4j数据库中：
- en: '[PRE35]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With this approach, we can augment the graph to perform the next steps to understand
    customer purchase behavior to be able to provide them with better recommendations.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以增强图以执行理解客户购买行为的下一步，以便为他们提供更好的推荐。
- en: 'The following code can process the article augmentation. The code is pretty
    much similar to the `ProcessRequest` class. We will look at only the differences
    here:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以处理文章增强。代码与`ProcessRequest`类非常相似。我们在这里只看差异：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `run` method reads the data from Neo4j and splits it into batches before
    invoking the batch embedding request:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`run`方法从Neo4j读取数据，并在调用批嵌入请求之前将其分割成批次：'
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once the batch of article texts is collected, we will pass that batch to the
    embedding service to get the embeddings. We will save the embeddings generated
    to the Neo4j database:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收集到文章文本的批次，我们将将其传递给嵌入服务以获取嵌入。我们将生成的嵌入保存到Neo4j数据库中：
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Generate the embeddings for any of the remaining article texts and save them
    to the Neo4j database:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为任何剩余的文章文本生成嵌入，并将其保存到Neo4j数据库中：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The flow of the operation is similar to the one in the `ProcessRequest` class.
    While we used a single request mode for season purchase embeddings, for article
    embeddings, we are using the *batch mode*. With the single request mode (using
    the API), we could generate only one summary at a time. However, with the batch
    mode, it is much faster to generate embeddings.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 操作流程与`ProcessRequest`类中的类似。虽然我们使用了单一请求模式进行季节购买嵌入，但对于文章嵌入，我们使用的是*批处理模式*。使用单一请求模式（使用API），我们一次只能生成一个摘要。然而，使用批处理模式，生成嵌入要快得多。
- en: You can download the latest project from [https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch9/langchain_graphaugment](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch9/langchain_graphaugment)
    instead of building it from scratch if you would like to play with it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要尝试该项目，可以从[https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch9/langchain_graphaugment](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch9/langchain_graphaugment)下载最新项目，而不是从头开始构建。
- en: To run the project, you can right-click on the `LangchainGraphaugmentApplication.java`
    file and select the **Run** menu option.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行项目，你可以右键单击`LangchainGraphaugmentApplication.java`文件，并选择**Run**菜单选项。
- en: '**Note**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: If you are interested in customizing the run options and other aspects, then
    you can use the **Run**/**Debug** configurations provided by the IDE. To learn
    more about these aspects, please visit [https://www.jetbrains.com/help/idea/run-debug-configuration-java-application.html](https://www.jetbrains.com/help/idea/run-debug-configuration-java-application.html).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对自定义运行选项和其他方面感兴趣，则可以使用IDE提供的**Run**/**Debug**配置。要了解更多关于这些方面的信息，请访问[https://www.jetbrains.com/help/idea/run-debug-configuration-java-application.html](https://www.jetbrains.com/help/idea/run-debug-configuration-java-application.html)。
- en: In the next section, we will take a look at how we can build the same recommendation
    engine using Spring AI.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用Spring AI构建相同的推荐引擎。
- en: Building your recommendation engine with Spring AI
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring AI构建你的推荐引擎
- en: In this section, we will look at building the graph augmentation application
    leveraging Spring AI. This project approach is similar to what we built using
    LangChain4j. We will be leveraging the GraphRAG approach to generate embeddings
    for a transaction chain that meets our requirements. We will start with the ZIP
    file downloaded in the last section. We need to unzip the file we have downloaded.
    Once it is unzipped, we will load the project into the IntelliJ platform using
    these steps. This is similar to what we did in the previous section. Please follow
    the steps listed at the start of the *Building your recommendation engine with
    LangChain4j* section to import the project.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨利用Spring AI构建图增强应用程序。这种方法与我们使用LangChain4j构建的项目方法类似。我们将利用GraphRAG方法为满足我们要求的交易链生成嵌入。我们将从上一节下载的ZIP文件开始。我们需要解压我们下载的文件。一旦解压，我们将使用以下步骤将项目加载到IntelliJ平台。这与我们在上一节中做的是一样的。请按照*使用LangChain4j构建推荐引擎*部分开头列出的步骤导入项目。
- en: In contrast to LangChain4j, there are no significant steps to update Spring
    AI project dependencies. Let’s see why.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与LangChain4j相比，更新Spring AI项目依赖项没有显著的步骤。让我们看看原因。
- en: 'Spring AI: updating the project dependencies'
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring AI：更新项目依赖项
- en: Unlike the LangChain4j project, we don’t need to update any dependencies. We
    were able to add all the required dependencies from the Spring starter project.
    We will take a look next at updating the application properties.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 与LangChain4j项目不同，我们不需要更新任何依赖项。我们能够从Spring启动器项目中添加所有必需的依赖项。接下来，我们将查看更新应用程序属性。
- en: 'Spring AI: updating the application properties'
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring AI：更新应用程序属性
- en: In this section, we need to update the application properties to be able to
    leverage the APIs. We need to add this configuration to the `application.properties`
    file in the project. Since we will be using an OpenAI LLM for the chat model and
    embeddings, we need to acquire an API key for this purpose, which we can do by
    visiting [https://platform.openai.com/docs/overview](https://platform.openai.com/docs/overview).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们需要更新应用程序属性以利用API。我们需要将此配置添加到项目中的`application.properties`文件。由于我们将使用OpenAI
    LLM作为聊天模型和嵌入，我们需要为此目的获取一个API密钥，这可以通过访问[https://platform.openai.com/docs/overview](https://platform.openai.com/docs/overview)来完成。
- en: 'These are the configuration properties we need to add:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们需要添加的配置属性：
- en: 'OpenAI chat model integration – We need to add this configuration to `application.properties`.
    We only need to add the OpenAI API key:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenAI聊天模型集成 – 我们需要将此配置添加到`application.properties`。我们只需要添加OpenAI API密钥：
- en: '[PRE40]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'OpenAI embeddings integration – We need to add this configuration to `application.properties`.
    We don’t need to add the OpenAI API key again, as it uses the same configuration
    as the LLM chat configuration:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenAI嵌入集成 – 我们需要将此配置添加到`application.properties`。我们不需要再次添加OpenAI API密钥，因为它使用与LLM聊天配置相同的配置：
- en: '[PRE41]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Neo4j integration – We will add basic Neo4j integration, not the Neo4j vector
    database-related integration:'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Neo4j集成 – 我们将添加基本的Neo4j集成，而不是与Neo4j向量数据库相关的集成：
- en: '[PRE42]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now that we have looked at the configuration properties, let us start building
    the application. We will start with Neo4j database integration first, then add
    chat model integration for summarizing the transactions and generating embeddings
    for the summary. Finally, we will take a look at building a REST endpoint to invoke
    those requests as needed.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看配置属性，让我们开始构建应用程序。我们将首先进行Neo4j数据库集成，然后添加聊天模型集成以总结交易并生成摘要的嵌入。最后，我们将查看构建REST端点以按需调用这些请求。
- en: 'Spring AI: Neo4j integration'
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring AI：Neo4j集成
- en: 'We are looking at Neo4j integration first as we need a means to integrate with
    the database to perform the following tasks:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先考虑Neo4j集成，因为我们需要一种与数据库集成的手段来执行以下任务：
- en: Set up connectivity to be able to perform read and write transactions.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置连接以能够执行读取和写入事务。
- en: See the articles for the transactions that occurred for the specified period.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看指定期间发生的交易文章。
- en: Persist the embeddings once they are generated.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦生成嵌入，就将其持久化。
- en: The implementation here is exactly the same as the LangChain4j project discussed
    in the *Langchain4J – Neo4j integration* part of the previous section. We will
    take a look at an OpenAI chat model integration that can generate a summary for
    the list of articles.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的实现与上一节*Langchain4J – Neo4j集成*部分中讨论的LangChain4j项目完全相同。我们将查看一个OpenAI聊天模型集成，可以为文章列表生成摘要。
- en: 'Spring AI: OpenAI chat integration'
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring AI：OpenAI聊天集成
- en: 'To integrate the chat, it is a bit different from LangChain4j. We need to define
    `Service` and initialize `ChatClient`. We need to leverage this client and use
    chat APIs to make the request. It is not abstracted as it is with LangChain4j.
    Let us take a look at this service:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要集成聊天功能，与LangChain4j略有不同。我们需要定义`Service`并初始化`ChatClient`。我们需要利用这个客户端并使用聊天API来发送请求。它没有像LangChain4j那样抽象。让我们看看这个服务：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let’s now look at the steps to integrate OpenAI chat:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看集成OpenAI聊天步骤：
- en: 'We have to provide the prompts for the LLM slightly differently in the Spring
    AI framework. In the LangChain4j framework, we had a single system message that
    defined the role the LLM is playing, the goal for the response, and data as a
    parameter in a single message. Here, we have to split the role and goal into a
    system prompt template, while the `data` parameter is passed into the user message.
    The outcome is the same in both cases:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Spring AI框架中，我们必须以不同的方式为LLM提供提示。在LangChain4j框架中，我们有一个单一的系统消息，定义了LLM扮演的角色、响应的目标以及作为消息参数的数据。在这里，我们必须将角色和目标拆分为系统提示模板，而`data`参数则传递到用户消息中。两种情况下结果相同：
- en: '[PRE44]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We are setting a role for the LLM chat engine. This sets the context for the
    engine on what guidelines to use to handle the data:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在为LLM聊天引擎设置一个角色。这为引擎设置了处理数据的指导方针：
- en: '[PRE45]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We are setting a goal for the LLM engine here on how it should process the
    data. This describes what the input data is and how it is structured:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里为LLM引擎设置一个目标，说明它应该如何处理数据。这描述了输入数据是什么以及它的结构：
- en: '[PRE46]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The response directive for the LLM gives directions on how the response should
    be structured:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LLM的响应指令给出了关于响应应该如何构建的指导：
- en: '[PRE47]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The data is passed as a user message here. It has the `{text}` variable defined,
    which is the property that is substituted with the input the method receives:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据作为用户消息传递。它定义了`{text}`变量，这是用方法接收的输入替换的属性：
- en: '[PRE48]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We need to initialize the chat client using `ChatClient.Builder`, which is
    injected by the Spring Framework into the constructor:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要使用`ChatClient.Builder`初始化聊天客户端，该客户端由Spring框架注入到构造函数中：
- en: '[PRE49]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can see that the usage is different from the LangChain4j framework. Here,
    we need to create a prompt with a system template, pass the user message with
    data replacement, and invoke the `chatResponse` method:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看到，使用方法与LangChain4j框架不同。在这里，我们需要使用系统模板创建一个提示，用数据替换传递用户消息，并调用`chatResponse`方法：
- en: '[PRE50]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We will take a look at embedding model integration next.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将接下来看看嵌入模型集成。
- en: 'Spring AI: OpenAI embedding model integration'
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring AI：OpenAI嵌入模型集成
- en: 'Embedding model integration is pretty simple. We can use `Autowired` to initialize
    the embedding model instance. The embedding model usage looks as shown in the
    following code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入模型集成相当简单。我们可以使用`Autowired`来初始化嵌入模型实例。嵌入模型的使用方法如下所示：
- en: '[PRE51]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: From the code, we can see it is as simple as adding `EmbeddingModel` to the
    class and initializing it using a constructor. When the Spring Boot application
    starts, the appropriate embedding model implementation based on properties is
    instantiated and assigned to this variable. This service provides a method to
    generate the embedding for a given text.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码中我们可以看到，它就像将`EmbeddingModel`添加到类中并使用构造函数初始化它一样简单。当Spring Boot应用启动时，根据属性实例化并分配给这个变量的适当的嵌入模型实现。此服务提供了一个方法来为给定的文本生成嵌入。
- en: Now that we have looked at all the services defined, let us look at how we can
    use all of these to build a graph augment application.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看所有定义的服务，让我们看看如何使用所有这些来构建一个图增强应用。
- en: 'Spring AI: final application'
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring AI：最终应用
- en: The application flow is pretty much the same as the LangChain4j application
    we discussed in the *LangChain4j – final application* section. The code is similar,
    so we will not be adding that code here. The only difference would be the Java
    package names. For posterity, let us take a look at the application flow.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 应用流程基本上与我们在*LangChain4j – 最终应用*部分讨论的LangChain4j应用相同。代码相似，所以我们不会在这里添加代码。唯一的区别将是Java包名。为了未来的参考，让我们看看应用流程。
- en: 'The REST endpoint is built to issue the request to perform the augmentation.
    Since the process itself can take time, this process is split into two parts:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 构建的REST端点用于发出执行增强的请求。由于这个过程本身可能需要时间，这个过程被分为两部分：
- en: Issue a request to start the augmentation process. This returns a request ID.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发起一个请求以启动增强过程。这将返回一个请求ID。
- en: Use the request ID returned in step 1 to check the progress of the request.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用步骤1中返回的请求ID来检查请求的进度。
- en: 'The first step starts a thread and initiates processing the whole data. The
    request process follows these steps:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步启动一个线程并开始处理整个数据。请求过程遵循以下步骤：
- en: Retrieve the relationship ID for the start season as the context, and the description
    of the articles in the order in which they were purchased. We return a list of
    records as a response.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以起始季度的关系ID作为上下文，按购买顺序检索文章的描述。我们以记录列表的形式返回响应。
- en: 'For each record we retrieved from Neo4j, we perform the following steps:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们从Neo4j检索的每个记录，我们执行以下步骤：
- en: Execute the chat request to generate the summary.
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行聊天请求以生成摘要。
- en: For the summary returned from the chat request, generate an embedding using
    an LLM embedding API.
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于聊天请求返回的摘要，使用LLM嵌入API生成嵌入。
- en: Save the relationship ID, summary, and embedding to a map to build a batch.
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将关系ID、摘要和嵌入保存到映射中，以构建一个批次。
- en: Once the batch size reaches the size specified in the configuration, write the
    summary and embedding to the relationship identified by the relationship ID.
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦批次大小达到配置中指定的尺寸，就将摘要和嵌入写入由关系ID标识的关系中。
- en: With this approach, we can augment the graph to perform the next steps to understand
    customer purchase behavior to be able to provide customers with better recommendations.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以增强图以执行下一步来理解客户购买行为，以便为客户提供更好的推荐。
- en: You can download the latest project from [https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch9/springai_graphaugment](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch9/springai_graphaugment)
    instead of building it from scratch if you would like to play with it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想玩这个项目，你可以从[https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch9/springai_graphaugment](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch9/springai_graphaugment)下载最新项目，而不是从头开始构建。
- en: To run the project, you can right-click on the `SpringaiGraphAugmentApplication.java`
    file and select the **Run** menu option.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行项目，你可以右键单击`SpringaiGraphAugmentApplication.java`文件，并选择**运行**菜单选项。
- en: '**Note**'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: If you are interested in customizing the run options and other aspects, then
    you can use the **Run**/**Debug** configurations provided by the IDE. To learn
    more about these aspects, please visit [https://www.jetbrains.com/help/idea/run-debug-configuration-java-application.html](https://www.jetbrains.com/help/idea/run-debug-configuration-java-application.html).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣于自定义运行选项和其他方面，那么你可以使用IDE提供的**运行**/**调试**配置。要了解更多关于这些方面的信息，请访问[https://www.jetbrains.com/help/idea/run-debug-configuration-java-application.html](https://www.jetbrains.com/help/idea/run-debug-configuration-java-application.html)。
- en: Let’s now see how we can use this application we built to augment the graph
    and take a look at how we can provide recommendations from this.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们如何使用我们构建的这个应用程序来增强图，并看看我们如何从中提供推荐。
- en: Fine-tuning your recommendation system
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微调你的推荐系统
- en: Now that the project is ready, we can either run the application in the IDE
    or build a runnable JAR file. Here, we will run it from the IDE directly. We will
    be using a LangChain4j application for testing here. A Spring AI application would
    follow the same principles. We will be starting from the database we created in
    the previous chapter. If you do not want to start from scratch, you can download
    the database dump from [https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/Building+Neo4j-Powered+Applications+with+LLMs+Database+Dump+files.zip](https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/Building+Neo4j-Powered+Applications+with+LLMs+Database+Dump+files.zip)
    and create a database from it.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在项目已经准备好了，我们既可以直接在IDE中运行应用程序，也可以构建一个可运行的JAR文件。在这里，我们将直接从IDE运行它。我们将使用LangChain4j应用程序进行测试。Spring
    AI应用程序将遵循相同的原则。我们将从上一章创建的数据库开始。如果你不想从头开始，你可以从[https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/Building+Neo4j-Powered+Applications+with+LLMs+Database+Dump+files.zip](https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/Building+Neo4j-Powered+Applications+with+LLMs+Database+Dump+files.zip)下载数据库转储文件，并从中创建一个数据库。
- en: You can double-click on the `LangchainGraphaugmentApplication`.`j``ava` file
    to load it into the IDE. Once it is loaded, you can right-click on the class name
    to run the application. *Figure 9.6* shows how we can do this.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以双击 `LangchainGraphaugmentApplication`.`j``ava` 文件将其加载到IDE中。一旦加载，你可以在类名上右键单击以运行应用程序。*图9.6*
    展示了如何进行此操作。
- en: '![Figure 9.6 — Run the application from the IDE](img/B31107_09_06.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 — 从IDE运行应用程序](img/B31107_09_06.png)'
- en: Figure 9.6 — Run the application from the IDE
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 — 从IDE运行应用程序
- en: 'Once you’ve right-clicked on the class name, click on the **Run** menu item
    to start the application. Once the application is ready, you should see this in
    the IDE console:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你右键单击了类名，点击 **运行** 菜单项以启动应用程序。一旦应用程序准备就绪，你应该在IDE控制台中看到以下内容：
- en: '[PRE52]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Once the application is up and running, we can open a browser and enter the
    URL `http://localhost:8080/augment/SUMMER_2019/FALL_2019` to start the augmentation
    process for the `SUMMER_2019` purchases of customers. When we issue this request,
    we get a UUID such as `aff867bd-08fb-42fb-8a27-3917e0ce83d1` as a response. While
    the process is running, we can inquire about the current completion percentage
    by entering the URL `http://localhost:8080/augment/status/aff867bd-08fb-42fb-8a27-3917e0ce83d1`
    in the browser.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序启动并运行，我们就可以打开浏览器并输入URL `http://localhost:8080/augment/SUMMER_2019/FALL_2019`
    以开始对客户的 `SUMMER_2019` 购买进行增强过程。当我们发出此请求时，我们会得到一个UUID，例如 `aff867bd-08fb-42fb-8a27-3917e0ce83d1`
    作为响应。在过程运行期间，我们可以在浏览器中输入URL `http://localhost:8080/augment/status/aff867bd-08fb-42fb-8a27-3917e0ce83d1`
    来查询当前的完成百分比。
- en: '**Note**'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Note that the `UUID` value of  `aff867bd-08fb-42fb-8a27-3917e0ce83d1` mentioned
    previously is a dynamic one. It is not guaranteed that you will get the same UUID
    as shown in the preceding text. This `UUID` is specific to the run in this example.
    You would need to take a look at the `UUID` returned by the request for your run
    and use it to check the status.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，之前提到的 `aff867bd-08fb-42fb-8a27-3917e0ce83d1` 的 `UUID` 值是动态的。不能保证你会得到与前面文本中显示的相同的UUID。这个
    `UUID` 是针对本例中的运行特定的。你需要查看你运行请求返回的 `UUID` 并使用它来检查状态。
- en: Generating a summary and embedding will take time. Once this process is complete,
    we should create embeddings on articles next. The process is similar to the previous
    step. We need to enter the URL `http://localhost:8080/augmentArticles` in the
    browser. It will also provide us with a `UUID` as a response. We need to keep
    checking the completion percentage until it is complete.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 生成摘要和嵌入将需要时间。一旦这个过程完成，我们应该在文章上创建嵌入。过程与上一步类似。我们需要在浏览器中输入 `http://localhost:8080/augmentArticles`。它也会提供一个
    `UUID` 作为响应。我们需要持续检查完成百分比，直到完成。
- en: If you do not want to wait for this whole process to complete, you can download
    the database from [https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/Building+Neo4j-Powered+Applications+with+LLMs+Database+Dump+files.zip](https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/Building+Neo4j-Powered+Applications+with+LLMs+Database+Dump+files.zip).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想等待整个过程的完成，你可以从 [https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/Building+Neo4j-Powered+Applications+with+LLMs+Database+Dump+files.zip](https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/Building+Neo4j-Powered+Applications+with+LLMs+Database+Dump+files.zip)
    下载数据库。
- en: Now, that we have performed the augmentation, let us take a look at how good
    these embeddings are and how they can help us provide recommendations. For this
    purpose, we can further enhance the graph by creating vector indexes for the embeddings
    we created.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了增强，让我们看看这些嵌入的效果以及它们如何帮助我们提供推荐。为此，我们可以通过为创建的嵌入创建向量索引来进一步增强图。
- en: 'You can execute this Cypher query to create a vector index for embeddings on
    articles:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以执行这个Cypher查询来为文章上的嵌入创建向量索引：
- en: '[PRE53]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This creates a vector index on `Article` nodes named `article-embeddings`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 `Article` 节点上创建一个名为 `article-embeddings` 的向量索引。
- en: 'The following Cypher code can be used to create a vector index on the summer
    2019 purchases embedding:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Cypher代码可以用来在2019年夏季购买的嵌入上创建向量索引：
- en: '[PRE54]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This creates a vector index on the `SUMMER_2019` relationship named `summer-2019-embeddings`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 `SUMMER_2019` 关系上创建一个名为 `summer-2019-embeddings` 的向量索引。
- en: 'Let us take a look at using the `Article` vector index first. This Cypher tries
    to find the top five matches for an article with an ID of `0748579001`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何使用 `Article` 向量索引。这个Cypher试图找到ID为 `0748579001` 的文章的前五条匹配项：
- en: '[PRE55]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'From the results (*Figure 9.7*), we can see that the first match is the best
    match and it is the `Article` node we looked for:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果（图9.7）中，我们可以看到第一个匹配项是最好的匹配，正是我们寻找的`Article`节点：
- en: '| **Score** | **Id** | **Desc** |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| **评分** | **ID** | **描述** |'
- en: '| 1.0 | “0748579001” | “Ankle-length, A-line beach dress in an airy, patterned
    weave with a deep V-neck with gold-coloured studs, and long dolman sleeves with
    elastication and a decorative drawstring at the cuffs. Unlined.” |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| 1.0 | “0748579001” | “踝部长款A字沙滩裙，采用轻盈的图案编织，深V领，金色珠片装饰，长灯笼袖，袖口有弹性装饰和装饰性的抽绳。无衬里。”
    |'
- en: '| 0.882 | “0748033001” | “Long beach dress in airy, crinkled chiffon with narrow,
    tie-top shoulder straps and an opening at the back of the neck. Unlined.” |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| 0.882 | “0748033001” | “长款沙滩裙，采用轻盈的皱褶雪纺，窄肩带，颈部后面有开口。无衬里。” |'
- en: '| 0.873 | “0748582008” | “Short beach dress in an airy cotton weave with broderie
    anglaise. V-neck front and back with a crocheted lace trim, horizontal, tasselled
    straps at the back of the neck, dropped shoulders and short sleeves. Seam at the
    waist and a gently flared skirt. Unlined.” |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| 0.873 | “0748582008” | “短款沙滩裙，采用轻盈的棉质编织，带有法式刺绣。前后V领，带有钩针蕾丝装饰，水平，颈部后面有流苏带，落肩，短袖。腰部有缝线，裙摆微微张开。无衬里。”
    |'
- en: '| 0.866 | “0748025004” | “Kaftan in an airy weave with buttons down the front
    and high slits in the sides.” |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| 0.866 | “0748025004” | “前襟有纽扣，侧面有高开叉的沙笼。” |'
- en: '| 0.866 | “0747737004” | “Sarong in an airy weave. Size 130x150 cm.” |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| 0.866 | “0747737004” | “轻盈编织的沙笼，尺寸130x150厘米。” |'
- en: Figure 9.7 — Similar articles for a given article
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 — 给定文章的相似文章
- en: 'Also, we can see that the articles that are less similar to each other have
    lower score values. From this result, let us take `Article` with an ID of `0748582008`
    and see what we can find:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以看到彼此不太相似的物品具有较低的评分值。从这个结果来看，让我们选取ID为`0748582008`的`Article`，看看我们能找到什么：
- en: '[PRE56]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'When we run the Cypher, we can see these results:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行Cypher查询时，我们可以看到以下结果：
- en: '| **Score** | **Id** | **Desc** |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| **评分** | **ID** | **描述** |'
- en: '| 1.0 | “0748582008” | “Short beach dress in an airy cotton weave with broderie
    anglaise. V-neck front and back with a crocheted lace trim, horizontal, tasselled
    straps at the back of the neck, dropped shoulders and short sleeves. Seam at the
    waist and a gently flared skirt. Unlined.” |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 1.0 | “0748582008” | “短款沙滩裙，采用轻盈的棉质编织，带有法式刺绣。前后V领，带有钩针蕾丝装饰，水平，颈部后面有流苏带，落肩，短袖。腰部有缝线，裙摆微微张开。无衬里。”
    |'
- en: '| 0.969 | “0748582001” | “Short beach dress in an airy cotton weave with broderie
    anglaise. V-neck front and back with a crocheted lace trim, horizontal, tasselled
    straps at the back of the neck, dropped shoulders and short sleeves. Seam at the
    waist and a gently flared skirt. Unlined.” |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 0.969 | “0748582001” | “短款沙滩裙，采用轻盈的棉质编织，带有法式刺绣。前后V领，带有钩针蕾丝装饰，水平，颈部后面有流苏带，落肩，短袖。腰部有缝线，裙摆微微张开。无衬里。”
    |'
- en: '| 0.893 | “0848082001” | “Short beach kaftan in an airy weave with lace trims.
    Short, wide sleeves, and a drawstring at the waist.” |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 0.893 | “0848082001” | “短款沙滩开衫，采用轻盈的蕾丝装饰编织。短袖，宽袖，腰部有抽绳。” |'
- en: '| 0.884 | “0854784001” | “Short beach dress in an airy cotton weave containing
    glittery threads. Round neckline with a V-neck opening and narrow ties at the
    front, dropped shoulders and long balloon sleeves with narrow, buttoned cuffs.
    Gathered tiers at the hem for added width.” |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 0.884 | “0854784001” | “短款沙滩裙，采用轻盈的棉质编织，含有闪亮线。圆领，V领开口，前面有窄带，落肩，长灯笼袖，袖口有窄扣。下摆有褶皱层，增加宽度。”
    |'
- en: '| 0.884 | “0850893001” | “Calf-length lace kaftan with a crocheted trim around
    the opening, a drawstring and twisted ties at the waist, and long sleeves. Scalloped
    trim around the cuffs and hem.” |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 0.884 | “0850893001” | “开襟长款蕾丝开衫，开口处有钩针装饰，腰部有抽绳和扭曲的腰带，长袖。袖口和下摆有波浪形装饰。” |'
- en: Figure 9.8 — Similar articles for a given article
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 — 给定文章的相似文章
- en: From the results, we can see that when the score is closer to `0.9`, the articles
    are pretty similar. We can use this information to provide similar articles as
    recommendations, based on the articles customers have already purchased.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果来看，当评分接近`0.9`时，文章非常相似。我们可以利用这些信息，根据客户已购买的物品提供相似文章作为推荐。
- en: 'Now, let us look at the customer summer purchase behaviors for a customer whose
    ID ends in `92f0`. Let’s call this customer, A:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看ID以`92f0`结尾的客户的夏季购买行为。我们可以称这位客户为A：
- en: '[PRE57]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'When we run this Cypher, we can see these results:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个Cypher查询时，我们可以看到以下结果：
- en: '| **Score** | **Id** | **Desc** |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| **Score** | **Id** | **Desc** |'
- en: '| 1.0 | “0002..92f0” | “The customer exhibits a strong preference for vibrant
    colors and comfortable, casual styles, particularly in swimwear and denim. Their
    purchases suggest a love for playful yet practical clothing, suitable for both
    beach outings and everyday wear. The mix of swimwear, shorts, and casual tops
    indicates a versatile wardrobe focused on both style and comfort.” |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| 1.0 | “0002..92f0” | “客户表现出对鲜艳色彩和舒适休闲风格的强烈偏好，尤其是在泳装和牛仔布方面。他们的购买表明对既有趣又实用的服装的喜爱，适合海滩出行和日常穿着。泳装、短裤和休闲上衣的混合表明一个注重风格和舒适的多功能衣橱。”
    |'
- en: '| 0.968 | “044d..d47e” | “The customer exhibits a strong preference for swimwear,
    particularly in vibrant colors like light orange and dark red, indicating a fun
    and playful style. Their choices also reflect an inclination towards high-waisted
    designs and supportive tops, suggesting a desire for both comfort and fashion.
    Additionally, the purchase of a versatile playsuit and tailored jacket indicates
    an appreciation for stylish yet practical everyday wear.” |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 0.968 | “044d..d47e” | “客户表现出对泳装的强烈偏好，尤其是在浅橙色和深红色等鲜艳色彩中，表明一种有趣且活泼的风格。他们的选择也反映了倾向于高腰设计和支撑性上衣，表明对舒适和时尚的渴望。此外，购买多功能连衣裙和定制夹克表明对时尚且实用的日常穿着的欣赏。”
    |'
- en: '| 0.967 | “07fe..a87f” | “The customer exhibits a strong preference for swimwear,
    particularly in vibrant colors like orange and black, indicating a love for beach
    and poolside activities. There is also a notable inclination towards basic wardrobe
    staples, such as tank tops and shorts, suggesting a desire for comfortable yet
    stylish casual wear. The blend of swimwear and basic clothing reflects a versatile
    fashion sense suitable for both leisure and everyday wear.” |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 0.967 | “07fe..a87f” | “客户表现出对泳装的强烈偏好，尤其是在橙色和黑色等鲜艳色彩中，表明对海滩和泳池边活动的喜爱。同时，对基本服装必备品，如无袖上衣和短裤的明显倾向，表明对舒适且时尚休闲装的渴望。泳装和基本服装的混合反映了适合休闲和日常穿着的多功能时尚感。”
    |'
- en: '| 0.966 | “0247..74b3” | “The customer demonstrates a preference for vibrant
    colors and versatile clothing items suitable for various occasions, including
    casual wear and swimwear. The repeated purchases of swimwear suggest a keen interest
    in beach or poolside activities. Additionally, the inclusion of dresses and accessories
    indicates a desire for stylish yet comfortable outfits.” |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| 0.966 | “0247..74b3” | “客户表现出对鲜艳色彩和适合各种场合的服装的偏好，包括休闲装和泳装。泳装的重复购买表明对海滩或泳池边活动的浓厚兴趣。此外，包括连衣裙和配饰表明对时尚且舒适的服装组合的渴望。”
    |'
- en: '| 0.965 | “0686..5220” | “The customer displays a strong preference for vibrant
    colors, particularly orange and white, as seen in their selection of swimwear
    and casual attire. Their purchases indicate a blend of comfort and style, with
    a focus on versatile pieces that can be worn for various occasions. The inclusion
    of both swimwear and everyday clothing suggests a lifestyle that appreciates both
    leisure and fashion.” |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| 0.965 | “0686..5220” | “客户表现出对鲜艳色彩的强烈偏好，尤其是橙色和白色，这在他们的泳装和休闲装选择中可见。他们的购买表明舒适和风格的结合，注重适合各种场合的多功能单品。包括泳装和日常服装表明一种既欣赏休闲又欣赏时尚的生活方式。”
    |'
- en: Figure 9.9 — Purchase summaries for other customers similar to the given customer
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 — 与给定客户相似的客户的购买摘要
- en: 'From the basic summary, we can see that the customer purchase behaviors are
    pretty similar. Let us pick another customer (say, customer B) from this list
    to see whether the same customers are returned when we run the same query. We
    will pick the customer ID ending in `74b3`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 从基本总结中，我们可以看到客户的购买行为相当相似。让我们从这个列表中挑选另一个客户（比如客户B）来查看当我们运行相同的查询时是否返回了相同的客户。我们将选择以`74b3`结尾的客户ID：
- en: '[PRE58]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let us look at the results when we run this query:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看运行此查询的结果：
- en: '| **Score** | **Id** | **Desc** |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| **Score** | **Id** | **Desc** |'
- en: '| 1.0 | “0247..74b3” | “The customer demonstrates a preference for vibrant
    colors and versatile clothing items suitable for various occasions, including
    casual wear and swimwear. The repeated purchases of swimwear suggest a keen interest
    in beach or poolside activities. Additionally, the inclusion of dresses and accessories
    indicates a desire for stylish yet comfortable outfits.” |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| 1.0 | “0247..74b3” | “客户表现出对鲜艳色彩和适合各种场合的服装的偏好，包括休闲装和泳装。泳装的重复购买表明对海滩或泳池边活动的浓厚兴趣。此外，包括连衣裙和配饰表明对时尚且舒适的服装组合的渴望。”
    |'
- en: '| 0.968 | “05de..29df” | “The customer’s fashion preferences indicate a strong
    inclination towards swimwear and dresses, particularly in vibrant and playful
    colors such as pink, orange, and blue. The selection of both swimwear and dresses
    suggests a versatile style that embraces both casual beachwear and stylish everyday
    attire. Additionally, the repeated purchases of high-waisted bikini bottoms showcase
    a preference for flattering and functional swimwear options.” |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| 0.968 | “05de..29df” | “客户的时尚偏好表明他们强烈倾向于泳装和连衣裙，尤其是在鲜艳且活泼的颜色如粉色、橙色和蓝色。泳装和连衣裙的选择暗示了一种多变的风格，既包括休闲沙滩装也包括时尚的日常装。此外，反复购买高腰比基尼短裤展示了他们对于既美观又实用的泳装选择的偏好。”
    |'
- en: '| 0.967 | “0322..3e92” | “The customer exhibits a strong preference for swimwear,
    as evidenced by multiple purchases of bikini tops and bottoms, showcasing a desire
    for stylish beach attire. Additionally, the selection of dresses and blouses reflects
    an inclination towards fashionable yet comfortable everyday wear. The use of vibrant
    colors and unique design elements indicates a taste for contemporary and eye-catching
    pieces.” |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| 0.967 | “0322..3e92” | “客户对泳装表现出强烈的偏好，这从他们多次购买比基尼上衣和短裤中可以看出，展示了他们对于时尚沙滩装的渴望。此外，连衣裙和衬衫的选择反映了他们倾向于时尚且舒适的日常装。鲜艳的颜色和独特的设计元素表明他们喜欢现代且引人注目的单品。”
    |'
- en: '| 0.966 | “0002..92f0” | “The customer exhibits a strong preference for vibrant
    colors and comfortable, casual styles, particularly in swimwear and denim. Their
    purchases suggest a love for playful yet practical clothing, suitable for both
    beach outings and everyday wear. The mix of swimwear, shorts, and casual tops
    indicates a versatile wardrobe focused on both style and comfort.” |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| 0.966 | “0002..92f0” | “客户对鲜艳的颜色和舒适、休闲的风格表现出强烈的偏好，尤其是在泳装和牛仔装上。他们的购买表明他们喜欢既有趣又实用的服装，适合海滩出行和日常穿着。泳装、短裤和休闲上衣的混合选择表明他们有一个注重风格和舒适的多变衣橱。”
    |'
- en: '| 0.965 | “0863..c454” | “The customer displays a strong preference for swimwear,
    particularly in vibrant colors like dark red and orange, indicating a fondness
    for beachwear and summer styles. Additionally, their choices in everyday clothing,
    such as airy dresses and denim skirts, suggest an inclination towards comfortable
    yet stylish casual wear. The repetition of specific items also reflects a desire
    for consistency and reliability in their fashion selections.” |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| 0.965 | “0863..c454” | “客户对泳装表现出强烈的偏好，尤其是在鲜艳的颜色如深红和橙色，这表明他们喜欢沙滩装和夏季风格。此外，他们在日常服装，如宽松连衣裙和牛仔裙的选择，表明他们倾向于舒适且时尚的休闲装。重复购买特定商品也反映了他们在时尚选择上对一致性和可靠性的渴望。”
    |'
- en: Figure 9.10 — Purchase summaries for other customers similar to the given customer
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 — 与给定客户相似的其它客户的购买摘要
- en: We can see that the top five matches for customer B are very different from
    those of customer A, even though customer B’s purchase summary was in the top
    five similar customer purchases of customer A.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，客户B的前五名匹配与客户A的非常不同，尽管客户B的购买摘要出现在客户A的前五名相似客户购买中。
- en: 'We can use this approach to recommend articles to purchase based on customer
    purchase behavior. We are capturing the order of the purchases, but how the summary
    of these purchases is captured by an embedding defines who will be considered
    a similar customer. Let us see what this query would look like:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这种方法根据客户购买行为推荐商品。我们正在捕捉购买顺序，但如何通过嵌入来捕捉这些购买的摘要定义了谁将被视为相似客户。让我们看看这个查询会是什么样子：
- en: '[PRE59]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We want to find other customers similar to this customer based on purchases.
    We will use the vector index to get the top five similar customers:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望根据购买行为找到与这位客户相似的其它客户。我们将使用向量索引来获取前五名相似客户：
- en: '[PRE60]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Collect the articles purchased by the customer:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 收集客户的购买商品：
- en: '[PRE61]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Collect the articles purchased by the other customers who are similar to the
    first customer:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 收集与第一位客户相似的其它客户的购买商品：
- en: '[PRE62]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Remove the articles purchased by the original customer from the articles purchased
    by similar customers:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 从相似客户的购买商品中移除原始客户的购买商品：
- en: '[PRE63]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This Cypher first collects the purchases made by the customer, finds other
    customers who have similar purchase behavior, retrieves the purchases made by
    those customers, and recommends 10 articles to the original customer that they
    haven’t previously purchased. The output of this query looks like this:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 此Cypher首先收集客户的购买，找到具有相似购买行为的其他客户，检索那些客户的购买，并向原始客户推荐10件他们之前未购买的商品。此查询的输出如下：
- en: '| **Id** | **Desc** |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| **Id** | **Desc** |'
- en: '| “0471714036” | “Knee-length shorts in a cotton weave with a button fly, side
    pockets and a welt back pocket with a button.” |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| “0471714036” | “棉质编织的膝盖长度短裤，有纽扣飞翼，侧口袋和带纽扣的翻盖后口袋。” |'
- en: '| “0699923078” | “T-shirt in soft, printed cotton jersey.” |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| “0699923078” | “柔软的印花棉质T恤。” |'
- en: '| “0786663001” | “Short, off-the-shoulder dress in an airy, plumeti weave with
    elastication and a small frill trim at the top. Long sleeves with elastication
    at the cuffs, an elasticated seam at the waist and a flounce at the hem. Jersey
    lining.” |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| “0786663001” | “短款无肩带连衣裙，采用轻盈的缎子编织，顶部有弹性和小褶边装饰。长袖，袖口有弹性，腰部有弹性接缝，下摆有荷叶边。 jersey衬里。”
    |'
- en: '| “0728473001” | “Triangle bikini top with laser-cut scalloped edges and lightly
    padded cups with removable inserts. Narrow, adjustable shoulder straps that can
    be fastened in different ways and an adjustable metal hook fastening at the back.”
    |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| “0728473001” | “三角形比基尼上衣，有激光切割的波浪边缘和轻微填充的罩杯，可拆卸的填充物。窄的可调节肩带，可以以不同的方式固定，背部有可调节的金属钩扣。”
    |'
- en: '| “0689040001” | “Fully lined bikini bottoms with a mid waist, wide sides,
    a wide tie at one side and medium coverage at the back.” |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| “0689040001” | “全内衬比基尼下装，中腰，两侧宽，一侧宽腰带，后部中等覆盖。” |'
- en: '| “0736046001” | “Metal hoop earrings in different sizes, three with charms
    in various designs. Diameter 1-2 cm.” |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| “0736046001” | “不同尺寸的金属圈耳环，三个带有各种设计的吊坠。直径1-2厘米。” |'
- en: '| “0713200006” | “Fully lined, waist-high bikini bottoms with wide sides and
    medium coverage at the back.” |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| “0713200006” | “全内衬，腰高比基尼下装，两侧宽，后部中等覆盖。” |'
- en: '| “0674606026” | “Short, A-line skirt with a high waist and buttons down the
    front.” |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| “0674606026” | “短款A字裙，高腰，前面有纽扣。” |'
- en: '| “0562245064” | “5-pocket jeans in washed, superstretch denim with a regular
    waist, zip fly and button, and skinny legs.” |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| “0562245064” | “五口袋牛仔裤，采用水洗超弹牛仔布，常规腰围，拉链和纽扣，细腿。” |'
- en: '| “0557247005” | “Oversized top in sturdy sweatshirt fabric with dropped shoulders
    and ribbing around the neckline, cuffs and hem. Soft brushed inside.” |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| “0557247005” | “宽松的上衣，采用耐用的运动衫面料，肩部下坠，领口、袖口和下摆有罗纹。内部柔软刷毛。” |'
- en: Figure 9.11 — Recommendations for a customer based on purchases made by similar
    customers
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11 — 基于相似客户购买行为推荐的客户推荐
- en: By following the steps explained to fine-tune your graph, we can now provide
    recommendations based on customer purchase behavior by finding similar customers
    and their purchases or similar articles based on what customers bought. This approach
    is simple and works well. But we are determining who similar customers are, and
    so on. We might want to use **Graph Data Science** algorithms or machine learning
    to group customers better so that we can provide better recommendations. We will
    take a look at that aspect in the next chapter.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循解释的步骤微调您的图，我们现在可以通过找到相似客户及其购买或基于客户购买的商品的相似文章来根据客户购买行为提供推荐。这种方法简单且效果良好。但我们在确定相似客户是谁等问题上。我们可能想使用**图数据科学**算法或机器学习来更好地分组客户，以便我们可以提供更好的推荐。我们将在下一章中探讨这一方面。
- en: Summary
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how to build intelligent applications by leveraging
    LangChain4j and Spring AI. We used these applications to augment the H&M transactions
    graph we loaded in the previous chapter, by leveraging LLM chat and embedding
    capabilities. Once the graph was augmented, we further enhanced the graph by leveraging
    vector indexes and saw how these indexes help us find similar articles or customers
    based on their purchases.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何通过利用LangChain4j和Spring AI构建智能应用。我们使用这些应用来增强上一章中加载的H&M交易图，通过利用LLM聊天和嵌入功能。一旦图被增强，我们进一步通过利用向量索引增强了图，并看到了这些索引如何帮助我们根据客户的购买行为找到相似的文章或客户。
- en: In the next chapter, we will step into **Graph Data Science** algorithms to
    see how we can further enhance these recommendations.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将步入**图数据科学**算法，看看我们如何进一步优化这些推荐。
