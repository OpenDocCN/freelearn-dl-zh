- en: Understanding the Heuristic Search Algorithm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解启发式搜索算法
- en: Heuristic searching is an AI search technique that utilizes a heuristic for
    its functionality. A **heuristic** is a general guideline that most likely prompts
    an answer. Heuristics assume a noteworthy role in searching strategies, in view
    of the exponential nature of most problems. Heuristics help to decrease a high
    quantity of options from an exponential number to a polynomial number. In **artificial
    intelligence** (**AI**), heuristic searching is of general significance, and also
    has specific importance. In a general sense, the term heuristic is utilized for
    any exercise that is regularly successful, but isn't certain to work in every
    situation. In heuristic search design, the term heuristic often alludes to the
    extraordinary instance of a heuristic evaluation function.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 启发式搜索是一种利用启发式方法来实现功能的人工智能搜索技术。**启发式**是一个通常能引导出答案的一般性指导原则。启发式在搜索策略中扮演着重要角色，因为大多数问题的规模是指数级的。启发式帮助减少从指数级选项中筛选出多项可能性，从而减少搜索空间。
    在**人工智能**（**AI**）中，启发式搜索具有普遍重要性，同时也有其特定的重要性。一般而言，启发式一词用于指代任何通常有效，但在每种情况下并不保证成功的做法。在启发式搜索设计中，启发式通常指的是启发式评估函数的特殊实例。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Revisiting the navigation application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重访导航应用
- en: The priority queue data structure
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先队列数据结构
- en: Visualizing search trees
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化搜索树
- en: Greedy **Best-First Search** (**BFS**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贪心**最佳优先搜索**（**BFS**）
- en: The A* Search
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A* 搜索
- en: Features of a good heuristic
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优秀启发式的特征
- en: Revisiting the navigation application
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重访导航应用
- en: 'In [Chapter 2](31a5d361-a5f4-45f2-b6f3-e28c01f85971.xhtml), *Understanding
    the Breadth-First Search Algorithm*, we saw the university navigation application,
    with which we wanted to find our way from the Bus Stop to the AI Lab. In the BFS
    method, we assume that the distance between connected places is one (that is,
    the same). However, in reality, that is not the case. Now, let''s assume that
    the university is designed as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](31a5d361-a5f4-45f2-b6f3-e28c01f85971.xhtml)《理解广度优先搜索算法》中，我们看到了大学导航应用程序，其中我们想要从公交车站找到到达人工智能实验室的路径。在
    BFS 方法中，我们假设连接地点之间的距离是 1（即相同）。然而，实际情况并非如此。现在，让我们假设大学是按如下方式设计的：
- en: '![](img/a26e2598-6f09-4e7d-b7ab-ba4655e0fdac.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a26e2598-6f09-4e7d-b7ab-ba4655e0fdac.png)'
- en: Figure 1
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1
- en: 'The values in green are the actual distances between the connected places.
    Let''s go ahead and create a dictionary, storing the locations of these places:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 绿色值表示连接地点之间的实际距离。接下来，我们创建一个字典，用于存储这些地点的位置：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the Python `NavigationData.py` module, we have created a dictionary called
    `connections`; this dictionary stores the connections between places. They are
    similar to the connections between people that we saw in the LinkedIn connection
    feature application in [Chapter 2](31a5d361-a5f4-45f2-b6f3-e28c01f85971.xhtml),
    *Understanding the Breadth-First Search Algorithm*:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python `NavigationData.py` 模块中，我们创建了一个名为 `connections` 的字典；该字典存储了地点之间的连接。这些连接与我们在[第二章](31a5d361-a5f4-45f2-b6f3-e28c01f85971.xhtml)《理解广度优先搜索算法》中看到的
    LinkedIn 连接功能应用中的人际连接类似：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We also have the `location` dictionary for storing the locations of places.
    The keys of the `location` dictionary are the places, and the values are the *x*
    and *y* coordinates of those places.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还拥有 `location` 字典，用于存储地点的位置。`location` 字典的键是地点，值是这些地点的 *x* 和 *y* 坐标。
- en: In DFS, preference was given to the child nodes while exploring the search tree; in
    BFS, preference was given to the sibling nodes. In heuristic searching, preference
    is given to nodes with lower heuristic values.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DFS 中，搜索树的探索优先考虑子节点；在 BFS 中，优先考虑兄弟节点。在启发式搜索中，优先考虑启发式值较低的节点。
- en: 'Now, let''s look at the term *heuristic*. A heuristic is a property of the
    class node. It is a guess, or estimate, of which node will lead to the goal state
    faster than others. This is a strategy used to reduce the nodes explored and reach
    the goal state quicker:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下术语*启发式*。启发式是节点类别的一个属性。它是对哪个节点能比其他节点更快到达目标状态的猜测或估计。这是一种用于减少探索节点数量并更快到达目标状态的策略：
- en: '![](img/b339d2d2-5292-4573-ae7a-b29176fa319b.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b339d2d2-5292-4573-ae7a-b29176fa319b.png)'
- en: Figure 2
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2
- en: For example, suppose that we're at the red node in the preceding diagram, and
    it has two child nodes—the yellow node and the green node. The green node seems
    to be much closer to the goal state, so we would select that node for further
    exploration.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们位于前面图示中的红色节点，它有两个子节点——黄色节点和绿色节点。绿色节点似乎离目标状态更近，因此我们会选择这个节点进行进一步探索。
- en: 'We''ll see the following two heuristic search algorithms as we proceed with
    this chapter:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章接下来的内容中，我们将看到以下两种启发式搜索算法：
- en: The greedy BFS algorithm
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贪心广度优先搜索算法
- en: The A* Search algorithm
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A* 搜索算法
- en: The priority queue data structure
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先队列数据结构
- en: A **priority queue** is a queue in which each element has a priority. For example,
    when passengers are waiting in a queue to board a flight, families with young
    children and business class passengers usually take priority and board first;
    then, the economy class passengers board. Let's look at another example. Suppose
    that three people are waiting in a queue to be attended to at a service counter,
    and an old man steps in at the end of the queue. Considering his age, the people
    in the queue might give him a higher priority and allow him to go first. Through
    these two examples, we can see that the elements in a priority queue have priorities,
    and they are processed in order of those priorities.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**优先队列**是一种队列，其中每个元素都有一个优先级。例如，当乘客排队等候登机时，带有小孩的家庭和商务舱乘客通常优先登机；然后，经济舱乘客登机。我们来看另一个例子。假设有三个人在服务台排队等候，而一位老人走到了队伍的最后面。考虑到他的年龄，队中的人可能会给他更高的优先级，让他先走。通过这两个例子，我们可以看到优先队列中的元素具有优先级，它们按优先级顺序处理。'
- en: 'Just like in queuing, we have operations to insert elements into a priority
    queue. The **insert** operation inserts an element with a specific priority. Consider
    the following diagram, illustrating the insert operation:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在排队中一样，我们有操作可以将元素插入到优先队列中。**插入**操作会以特定优先级插入一个元素。考虑下图，说明插入操作：
- en: '![](img/18952aac-49f7-4c9c-9436-4c913e245f46.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18952aac-49f7-4c9c-9436-4c913e245f46.png)'
- en: Figure 3
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3
- en: In the preceding diagram, element **A** is inserted with priority **5**; since
    the priority queue is empty, the element is kept at the front. In Python, elements
    with low priorities are arranged toward the front of the queue, and elements with
    high priority values are arranged toward the end of the priority queue. This means
    that elements with low priority values are processed first, since they're at the
    front of the priority queue. Now, suppose that element **B** needs to be inserted
    with priority **10**. As **10** is greater than **5**, element **B** is kept after
    element **A**. Now, suppose that element **C** is to be inserted with priority
    **1**. Because **1** is less than **5, **it is arranged in front of element **A**.
    Next, element **D** is to be inserted with priority **5**; here, both elements
    **A** and **D** have priority **5**, but, since **A** was inserted first, it has
    a higher priority. This means that **D** is placed after **A** and before **B**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图示中，元素**A**的优先级是**5**，因为优先队列为空，元素保持在前端。在 Python 中，优先级较低的元素排列在队列的前面，而优先级较高的元素排列在优先队列的后面。这意味着优先级较低的元素先被处理，因为它们位于优先队列的前面。现在，假设元素**B**需要以优先级**10**插入。由于**10**大于**5**，元素**B**被插入到元素**A**之后。现在，假设元素**C**需要以优先级**1**插入。因为**1**小于**5**，它被排在元素**A**前面。接下来，元素**D**需要以优先级**5**插入；这里，元素**A**和**D**的优先级都是**5**，但由于**A**先插入，它具有更高的优先级。这意味着**D**被插入在**A**之后，**B**之前。
- en: In a queue, we have an operation called **dequeue**, which removes an element
    from the front. Similarly, in a priority queue, we have an operation called **get
    front element**, which removes an element from the front of the priority queue.
    So, calling this operation four times should first remove **C**, then **A**, then
    **D**, and finally **B**.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在队列中，我们有一个操作叫做**出队**，它从队列前端移除一个元素。同样地，在优先队列中，我们有一个操作叫做**获取前端元素**，它从优先队列的前端移除一个元素。因此，调用这个操作四次，应该首先移除**C**，然后是**A**，接着是**D**，最后是**B**。
- en: 'In Python, we have the `Queue` class for the priority queue data structure.
    It has the `PriorityQueue` method, which takes `maxsize` as an argument for creating
    a priority queue. If `maxsize` is less than `0` or equal to `0`, the queue size
    is infinite. In our case, we''ll call this method with no arguments, because the
    default argument is `0`. In `PriorityQueue`, the elements of the tuple are `priority_number`
    and `data`. The `Queue` class has the `empty()` method, which returns `True` if
    it''s empty and `False` otherwise. It has the `put()` method, used for inserting
    an item that is in the form of a tuple: `(priority_number, data)`. Finally, we
    have the `get()` method, which returns the front element. Let''s go ahead and
    try out these methods, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们有 `Queue` 类用于优先队列数据结构。它有一个 `PriorityQueue` 方法，该方法以 `maxsize` 作为参数来创建优先队列。如果
    `maxsize` 小于 `0` 或等于 `0`，则队列的大小是无限的。在我们的案例中，我们将不带参数地调用该方法，因为默认参数是 `0`。在 `PriorityQueue`
    中，元组的元素是 `priority_number` 和 `data`。`Queue` 类有一个 `empty()` 方法，如果队列为空，则返回 `True`，否则返回
    `False`。它还有一个 `put()` 方法，用于插入一个元组形式的项：`(priority_number, data)`。最后，我们有一个 `get()`
    方法，用于返回队列前端的元素。接下来，让我们尝试这些方法，如下所示：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have created a Python module called `PriorityQueue.py`, and we are importing
    the `Queue` class. We have also created a priority queue and, one by one, we are
    inserting elements with specific priorities.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `PriorityQueue.py` 的 Python 模块，并且导入了 `Queue` 类。我们还创建了一个优先队列，并逐个插入具有特定优先级的元素。
- en: 'As can be seen in the preceding code, we are inserting a tuple where the priority
    number is `5` and the data is `A`; then, we are inserting element `B` with priority
    `10`, `C` with priority `1`, and `D` with priority `5`. We are also checking whether
    the priority queue is empty and when it is not empty, we are printing all of the
    elements one by one, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们插入了一个元组，其中优先级数字为 `5`，数据为 `A`；然后，我们插入了优先级为 `10` 的元素 `B`，优先级为 `1` 的元素
    `C`，以及优先级为 `5` 的元素 `D`。我们还检查了优先队列是否为空，当队列不为空时，我们逐一打印出所有元素，如下所示：
- en: '![](img/e754937d-60ce-4cd6-a732-cbad40d452ed.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e754937d-60ce-4cd6-a732-cbad40d452ed.png)'
- en: Figure 4
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4
- en: As you can see, in the preceding output, the priority queue is initially empty.
    After inserting the four elements, the length becomes `4`; when we get the front
    elements, the first element is `C`, the next is `A`, the next is `D`, and the
    last element is `B`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在前面的输出中，优先队列最初是空的。插入四个元素后，队列的长度变为 `4`；当我们获取前端元素时，第一个元素是 `C`，接下来是 `A`，然后是
    `D`，最后是 `B`。
- en: Visualizing a search tree
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化搜索树
- en: In the previous chapter, you learned that a **graph** is a structure in which
    nodes are connected by edges. A **tree** is a special type of graph, in which
    there are no cycles and two nodes are connected by one path. For visualizing trees,
    we'll use the `pydot` Python library, which is a Python interface to Graphviz's
    DOT language. In [Chapter 1](50419d40-ab0f-4d63-9447-295dc802574c.xhtml), *Understanding
    the Depth-First Search Algorithm*, we learned that **Graphviz** is open source
    graph visualization software, and it provides the DOT language for creating layered
    drawings of directed graphs. In addition, we'll be using the `matplotlib` library
    for displaying the final rendered image.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了 **图** 是一个节点通过边连接的结构。**树** 是一种特殊类型的图，其中没有循环，并且两个节点通过一条路径连接。为了可视化树，我们将使用
    `pydot` Python 库，这是 Graphviz 的 DOT 语言的 Python 接口。在 [第 1 章](50419d40-ab0f-4d63-9447-295dc802574c.xhtml)《理解深度优先搜索算法》中，我们了解到
    **Graphviz** 是开源的图形可视化软件，它提供了 DOT 语言用于创建有向图的分层图形。此外，我们还将使用 `matplotlib` 库来显示最终渲染的图像。
- en: 'Now, let''s use these libraries to visualize the following simple tree. It
    has a root node, and three children under the root node:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用这些库来可视化以下简单的树。它有一个根节点，并且根节点下有三个子节点：
- en: '![](img/bf4c49d1-8891-41d5-80ec-cf3d0d38ebd5.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf4c49d1-8891-41d5-80ec-cf3d0d38ebd5.png)'
- en: Figure 5
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5
- en: 'Consider the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下代码：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have created a Python module called `TreePlotTest.py`, and have imported
    the `pydot` library and the required classes from `matplotlib`. Using the `Dot()`
    method of `pydot`, we can create a `graph` object that will hold the nodes and
    edges of the graph. We have also specified the `dpi` for the image as `300` in
    this case. We can use the `Node()` method of `pydot` to create a node. We are
    creating the `rootNode` by passing the label as `0 Root`, and using the `style`
    argument `filled` and the `fillcolor` argument `#00ee11`; the `xlabel` is `0`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`TreePlotTest.py`的Python模块，并导入了`pydot`库和`matplotlib`中所需的类。使用`pydot`的`Dot()`方法，我们可以创建一个`graph`对象，该对象将容纳图形的节点和边。我们还在此情况下指定了图像的`dpi`为`300`。我们可以使用`pydot`的`Node()`方法来创建一个节点。我们通过传递标签为`0
    Root`，并使用`style`参数`filled`和`fillcolor`参数`#00ee11`来创建`rootNode`；`xlabel`为`0`。
- en: 'The `fillcolor` argument is specified in hexadecimal format. Browse to [https://www.w3schools.com/colors/colors_picker.asp](https://www.w3schools.com/colors/colors_picker.asp) to
    select a color and see its hexadecimal code; later, you''ll understand why the
    `xlabel` is used:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`fillcolor`参数以十六进制格式指定。浏览到[https://www.w3schools.com/colors/colors_picker.asp](https://www.w3schools.com/colors/colors_picker.asp)选择颜色并查看其十六进制代码；稍后，你将了解为什么使用`xlabel`：'
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After we have created this `rootNode`, it will be added to the `graph` object,
    and we will create the `childNode` three times with appropriate names. The `style`
    argument will be `filled` with another color, and the `xlabel` will be `1`. We
    will also add this node to the graph. Then, we will create an edge between the
    `rootNode` and the newly created `childNode`, and add this edge to the `graph`
    object. The snippet of code at the end of the following block is used to display
    the graph in full screen:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 创建好`rootNode`后，它将被添加到`graph`对象中，我们将三次创建`childNode`并为其指定适当的名称。`style`参数将为`filled`并使用另一种颜色，`xlabel`为`1`。我们还将此节点添加到图中。接着，我们将创建一个从`rootNode`到新创建的`childNode`的边，并将这条边添加到`graph`对象中。以下代码块末尾的代码片段用于全屏显示图形：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s run the preceding code, and see what happens:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行前面的代码，看看会发生什么：
- en: '![](img/1fab482f-6d53-4e51-a9a4-ff88ef87ac4f.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fab482f-6d53-4e51-a9a4-ff88ef87ac4f.png)'
- en: Figure 6
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图6
- en: 'Upon successful execution of the code, we will see the four nodes: the root
    node, and then the three child nodes beneath it. We can see the xlabel values
    `0` and `1`, which are extra annotations for the node.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功执行代码后，我们将看到四个节点：根节点，然后是它下面的三个子节点。我们可以看到`0`和`1`的xlabel值，它们是节点的附加注释。
- en: 'Now, let''s try modifying the name of the `childNode`. We will remove the numerical
    value from the child node''s name, so that all three of the nodes have the same
    name:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试修改`childNode`的名称。我们将从子节点的名称中删除数字值，使得这三个节点具有相同的名称：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Having made these changes to the names of the `childNode`, we will see the
    following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改了`childNode`的名称后，我们将看到如下所示：
- en: '![](img/344f283c-e2c3-4067-a2cd-37fa12a2de95.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/344f283c-e2c3-4067-a2cd-37fa12a2de95.png)'
- en: Figure 7
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图7
- en: 'Since the three nodes have the same name, `pydot` treats them as the same node.
    Hence, we should try to use unique names in the nodes for the search tree. The
    following diagram shows an example of a search tree:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这三个节点具有相同的名称，`pydot`将它们视为同一个节点。因此，我们应该尽量在搜索树中的节点使用唯一的名称。下面的图示显示了一个搜索树的示例：
- en: '![](img/ab3f5865-8444-4e9c-b5dd-dbfd88322ac8.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab3f5865-8444-4e9c-b5dd-dbfd88322ac8.png)'
- en: Figure 8
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图8
- en: In the preceding diagram, we want to visualize a heuristic search. Each node
    has a heuristic value. In this example, **Bus Stop** appears twice, so we use
    index values to differentiate multiple instances. Each node also has a color code.
    Green nodes have already been explored; in this case, **Bus Stop** and **Library**
    will be explored. The red node has been selected for exploration; in this case, **Car
    Park** has been selected for exploration. The blue nodes are unexplored, forming
    a fringe, and they are arranged in a priority queue in descending order of heuristic
    values. A **fringe** is a priority queue of unexplored nodes, ordered by heuristic
    value.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图示中，我们希望可视化一个启发式搜索。每个节点都有一个启发式值。在这个例子中，**公交车站**出现了两次，因此我们使用索引值来区分多个实例。每个节点还有一个颜色编码。绿色节点已经被探索过；在这种情况下，**公交车站**和**图书馆**将被探索。红色节点已经被选择进行探索；在这种情况下，**停车场**被选择进行探索。蓝色节点是未探索的，形成了一个边缘，它们按启发式值的降序排列在优先队列中。**边缘**是一个按启发式值排序的未探索节点的优先队列。
- en: In our case, the **Maths Building** comes first, because it has the lowest heuristic
    value (**2.2**), followed by **Store,** which has a heuristic value of **4**;
    **Student Center,** with a value of **8**; **Library,** with a value of **8.2**;
    and **Bus Stop,** with a value of **8.9**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，**数学大楼**排在第一位，因为它的启发式值最小（**2.2**），接下来是**商店**，它的启发式值为**4**；然后是**学生中心**，启发式值为**8**；**图书馆**，启发式值为**8.2**；最后是**公交站**，启发式值为**8.9**。
- en: 'In DFS, we use the stack data structure, giving preference to the child nodes.
    In BFS, we use the queue data structure, giving preference to siblings. In a heuristic
    search, we will use the priority queue; this will give preference to the unexplored
    node that is closest to the goal, which is the first node in the priority queue:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在深度优先搜索（DFS）中，我们使用栈数据结构，优先考虑子节点。在广度优先搜索（BFS）中，我们使用队列数据结构，优先考虑兄弟节点。在启发式搜索中，我们将使用优先队列；这将优先选择距离目标最近的未探索节点，该节点是优先队列中的第一个节点：
- en: '![](img/7c1c7267-fc3b-4a5f-a974-58d3cc9da800.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c1c7267-fc3b-4a5f-a974-58d3cc9da800.png)'
- en: Figure 9
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9
- en: 'A few changes need to be made to the `Node` class in order to accommodate the
    heuristic search and visualization process. A new property called `fringe` is
    introduced, to indicate whether the node is a part of the fringe. A new property
    called `heuristic` is introduced, the constructor has changed, and an additional
    argument, `parentNode`, is introduced. The `addChild` method is changed to the `setParent`
    method, and we have a new method, called `computeHeuristic`. Now, let''s take
    a look at the code for the `Node` class, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 需要对`Node`类做一些修改，以适应启发式搜索和可视化过程。引入了一个新的属性`fringe`，用于指示节点是否是边缘的一部分。引入了一个新的属性`heuristic`，构造函数也发生了变化，新增了一个参数`parentNode`。`addChild`方法被修改为`setParent`方法，我们还新增了一个名为`computeHeuristic`的方法。现在，让我们来看一下`Node`类的代码，如下所示：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we have commented out the code for setting the parent as `None`. Instead,
    we have the `setParent` method, which takes the parent node as an argument and
    sets the property. We have a property called `fringe`, which is set as `True`
    by default, and there is a new property, `heuristic`, which is set by the `computeHeuristic`
    function . As mentioned previously, `addChild` has been set to `setParent`, which
    takes `parentNode` as an argument. We check whether the parent node is not `None`;
    if it is not `None`, then the node is added to the `children` property of the
    parent node, and the `parent` property of the current node is set as `parentNode`;
    the current node depth is equal to `parentNode.depth + 1`. If `parentNode` is
    `None`, then the `parent` property is set to `None`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经注释掉了将父节点设置为`None`的代码。取而代之的是`setParent`方法，它将父节点作为参数并设置该属性。我们有一个名为`fringe`的属性，默认为`True`，还有一个新属性`heuristic`，它由`computeHeuristic`函数设置。如前所述，`addChild`已被设置为`setParent`，它接受`parentNode`作为参数。我们检查父节点是否不是`None`；如果不是`None`，则将节点添加到父节点的`children`属性中，并将当前节点的`parent`属性设置为`parentNode`；当前节点的深度等于`parentNode.depth
    + 1`。如果`parentNode`是`None`，则`parent`属性设置为`None`：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There is also a new method called `computeHeuristic`. This function sets the
    `heuristic` property to a value. We will see how this function actually works,
    and what it computes, in the *Greedy* *BFS* and *A* Search* sections:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个新方法叫做`computeHeuristic`。这个函数将`heuristic`属性设置为一个值。我们将在*贪心* *广度优先搜索*和*A* 搜索*部分中看到这个函数如何实际工作，以及它计算的内容：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the Python `TreePlot.py` module, we created a class called `TreePlot`, which
    is used to create a tree visualization of the `Node` class. This class has two
    properties: the first one is a `graph` object, and the other one is the `index`
    of the node. It has a method called `createGraph`, which adds nodes and edges
    to the `graph` object. The flow of this method is similar to `printTree`, as it
    is recursively called on its child nodes. This method takes the current node being
    processed and `currentNode` as an argument. `currentNode` is the node that is
    shown in red in *Figure 8,* **Car Park**. The `createGraph` method checks whether
    the node that we are processing has the same state as that of the `currentNode`,
    and, if it does, it assigns color red to it. If it is a part of the fringe, the
    color blue is assigned. If the node has been explored, the color green is assigned:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python的`TreePlot.py`模块中，我们创建了一个名为`TreePlot`的类，用于创建`Node`类的树形可视化。这个类有两个属性：一个是`graph`对象，另一个是节点的`index`。它有一个名为`createGraph`的方法，用于将节点和边添加到`graph`对象中。这个方法的流程类似于`printTree`，因为它会递归地在子节点上调用。这个方法接收当前正在处理的节点和`currentNode`作为参数。`currentNode`是图中*图8*中红色显示的节点，**停车场**。`createGraph`方法检查我们正在处理的节点是否与`currentNode`的状态相同，如果相同，则将其颜色设置为红色。如果它是边缘的一部分，则设置为蓝色。如果该节点已被探索，则将其颜色设置为绿色：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After assigning the hexadecimal color of the node, we will create the node
    and call it `parentGraphNode`. The label of the node is a combination of the index
    value and the state of the node, and the `xlabel` is the heuristic value of the
    node. After we have created this node, the value of the index will be incremented,
    and the node will be added to the graph:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在为节点分配了十六进制颜色后，我们将创建该节点并将其命名为`parentGraphNode`。该节点的标签是索引值和节点状态的组合，`xlabel`是节点的启发式值。在创建完这个节点后，索引值将递增，节点将被添加到图中：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For each of the `childNode` objects, we call the `self.createGraph` method
    and pass `childNode` and `currentNode`. So, when we call this on `childNode`,
    it should return the corresponding `pydot` node. Then, we can create an edge between `parentGraphNode` and
    `childGraphNode`. After creating this edge, we can add it to our `graph` object:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个`childNode`对象，我们调用`self.createGraph`方法并传入`childNode`和`currentNode`。所以，当我们在`childNode`上调用时，它应该返回相应的`pydot`节点。然后，我们可以在`parentGraphNode`和`childGraphNode`之间创建一条边。创建完这条边后，我们可以将其添加到我们的`graph`对象中：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This class has another method, called `generateDiagram`, and it takes `rootNode`
    and `currentNode` as arguments. First, it generates the `graph` object containing
    all of the nodes and edges by calling the `createGraph` method, with `rootNode`
    as the first argument and `currentNode` as the second argument. Then, we have
    the same snippet that we earlier used to show the diagram. So, if you want to
    visualize a search tree, you have to instantiate an object of `TreePlot` and call
    the `generateDiagram` method:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类还有一个方法，叫做`generateDiagram`，它接收`rootNode`和`currentNode`作为参数。首先，通过调用`createGraph`方法生成包含所有节点和边的`graph`对象，`rootNode`作为第一个参数，`currentNode`作为第二个参数。然后，我们会看到与之前展示图形时相同的代码片段。所以，如果你想可视化一个搜索树，你需要实例化一个`TreePlot`对象，并调用`generateDiagram`方法：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the Python `TreePlotTest2.py` module, we imported the necessary classes—`Node`,
    `State`, and `TreePlot`, and we are creating a sample tree with the root node
    and child nodes of the first level. We also created a `TreePlot` object and called
    the `generateDiagram` method, with the arguments `root` and `root`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python的`TreePlotTest2.py`模块中，我们导入了必要的类——`Node`、`State`和`TreePlot`，并且正在创建一个包含根节点和第一层子节点的示例树。我们还创建了一个`TreePlot`对象，并调用了`generateDiagram`方法，参数是`root`和`root`：
- en: '![](img/804707a2-219a-445c-acad-6d494516b024.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/804707a2-219a-445c-acad-6d494516b024.png)'
- en: Figure 10
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图10
- en: In the preceding diagram, we can see the root node and the first-level child
    node.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到根节点和第一层的子节点。
- en: Now that you have learned how to visualize a tree, in the next section you will
    learn about greedy best-first search.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何可视化树结构，在接下来的部分，你将学习贪心最佳优先搜索。
- en: Greedy BFS
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 贪心BFS
- en: 'In the *Revisiting the navigation application* section, you learned that a
    heuristic value is a property of the node, and it is a guess, or estimate, of
    which node will lead to the goal state quicker than others. It is a strategy used
    to reduce the nodes explored and reach the goal state quicker. In **greedy BFS**,
    the heuristic function computes an estimated cost to reach the goal state. For
    our application, the heuristic function can compute the straight-line distance
    to the goal state, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在*重新审视导航应用*部分，你已经学到启发式值是节点的一个属性，它是一个猜测或估计，表示哪个节点能比其他节点更快地到达目标状态。这是一种用来减少探索节点数量并更快达到目标状态的策略。在**贪心BFS**中，启发式函数计算到达目标状态的估计代价。对于我们的应用，启发式函数可以计算到目标状态的直线距离，如下所示：
- en: '![](img/0585470f-f65a-413e-a10a-31d1e3744ee2.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0585470f-f65a-413e-a10a-31d1e3744ee2.png)'
- en: Figure 11
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11
- en: 'As you can see, in the preceding diagram the initial state is the **Bus Stop**.
    From the **Bus Stop** node, we have one channel, which is the **Library** node.
    Let''s suppose that we''re at the **Library** now; from the **Library** node,
    there are three child nodes: the **Car Park**, the **Bus Stop**, and the **Student
    Center**. In real life, we''d prefer to go to the **Car Park**, because it seems
    closer to the goal state, and the chances that we will reach the **AI Lab** faster
    are much higher:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在上面的图中，初始状态是**Bus Stop**。从**Bus Stop**节点出发，我们有一个通道，即**Library**节点。假设我们现在在**Library**，从**Library**节点出发，有三个子节点：**Car
    Park**、**Bus Stop**和**Student Center**。在现实生活中，我们更倾向于去**Car Park**，因为它似乎离目标状态更近，且到达**AI
    Lab**的几率也更高：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s use the location data of these four places (`Library`, `Car Park`, `Bus
    Stop`, and `Student Center`) to compute the heuristic functions for the three
    nodes. When you compute the heuristic functions for these three nodes, you will
    find that the value for `Car Park` is `6.4`, `Bus Stop` is `8.9`, and `Student
    Center` is `8.0`. According to these heuristic values, we will select the first
    value in the fringe, which is the node with the lowest heuristic value (`Car Park`):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这四个地点（`Library`、`Car Park`、`Bus Stop` 和 `Student Center`）的位置信息来计算这三个节点的启发式值。当你计算这三个节点的启发式值时，你会发现`Car
    Park`的值是`6.4`，`Bus Stop`的值是`8.9`，`Student Center`的值是`8.0`。根据这些启发式值，我们将选择边界中的第一个值，也就是启发式值最小的节点（`Car
    Park`）：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s take a look at the preceding `computeHeuristic` function. The `Node`
    class has a method called `computeHeuristic`. This function computes the heuristic
    value of the node by finding the distance from this state to the goal state. You
    can find the goal location by using the `location` dictionary of the navigation
    data and using the AI Lab as the key. You can find the current location by using
    the `location` dictionary, with the current place as the key. We find the difference
    in the `x` coordinates as follows: `dx = goalLocation[0] - currentLocation[0]`.
    We find the difference in the `y` coordinates as follows: `dy = goalLocation[1]
    - currentLocation[1]`. Finally, we compute the distance as the square root of
    `dx` square plus `dy` square, and we assign this distance to the `heuristic` property
    of the `Node` class:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下前面的`computeHeuristic`函数。`Node`类有一个名为`computeHeuristic`的方法。该函数通过计算从当前状态到目标状态的距离来计算节点的启发式值。你可以通过使用导航数据中的`location`字典，并以AI实验室作为键，来找到目标位置。你可以通过使用`location`字典，并以当前位置作为键，来找到当前地点。我们通过以下方式计算`x`坐标的差值：`dx
    = goalLocation[0] - currentLocation[0]`。我们通过以下方式计算`y`坐标的差值：`dy = goalLocation[1]
    - currentLocation[1]`。最后，我们通过计算`dx`的平方加`dy`的平方的平方根来得到距离，并将这个距离赋值给`Node`类的`heuristic`属性：
- en: '![](img/57a8639d-f5b3-4c6f-a5cb-88bf3335dcb6.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57a8639d-f5b3-4c6f-a5cb-88bf3335dcb6.png)'
- en: Figure 12
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12
- en: 'Now that you understand this heuristic function, let''s look at the flow of
    the greedy BFS algorithm. The flow of this algorithm is similar to BFS. Instead
    of using a queue, we are going to use a priority queue, and we are going to compute
    the heuristic of the node and add the node, along with the heuristic value, to
    the priority queue:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了这个启发式函数，我们来看看贪心BFS算法的流程。该算法的流程类似于BFS，不同的是它使用的是优先队列而不是队列，我们将计算节点的启发式值，并将节点和启发式值一起加入优先队列中：
- en: We initially create the root node and add it to the tree, and then add this
    node, along with its heuristic value, to the priority queue.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建根节点并将其添加到树中，然后将该节点及其启发式值一起添加到优先队列中。
- en: We get the front node from the priority queue, and we check if it has goal state.
    If it does, we end our search here, and if it doesn't have the goal state, then
    we find its child nodes, add them to the tree, and then add them to the priority
    queue, along with a heuristic value.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从优先队列中获取前一个节点，并检查它是否有目标状态。如果有，我们就结束搜索；如果没有目标状态，我们就找到它的子节点，添加它们到树中，然后将它们连同启发式值一起添加到优先队列中。
- en: We carry on with this process until we find the goal state or we've exhausted
    all of the nodes in our search stream.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续这个过程，直到找到目标状态或搜索流中的所有节点都已被遍历完。
- en: 'Let''s try to code the greedy BFS algorithm as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试按以下方式编写贪婪BFS算法：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the Python `GreedySearch.py` module, we have created a `performGreedySearch()`
    method, which will perform the greedy BFS. In this method, we have created an
    empty priority queue for holding the nodes. With `initialState`, we are creating
    a root node, and, as mentioned earlier, the constructive node has changed; there
    is an additional argument in the parent node. For the root node, the parent node
    is `None`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python `GreedySearch.py`模块中，我们创建了一个`performGreedySearch()`方法，该方法将执行贪婪BFS。在这个方法中，我们创建了一个空的优先队列来存储节点。通过`initialState`，我们创建了一个根节点，正如之前提到的，构造性节点已经改变；父节点中多了一个额外的参数。对于根节点，父节点是`None`。
- en: 'We are creating a `TreePlot` object and calling its `generateDiagram()` method
    to visualize the current search tree. In this case, the search tree will only
    contain the root node. We''re adding the root node, along with its heuristic value,
    to the priority queue. We check whether the priority queue is not empty; if it
    is not empty, we get the front element and call it `currentNode`. As mentioned
    earlier, the format of the priority queue is a tuple containing the heuristic
    value and the node. Since we only want the node, we''ll ignore the heuristic value.
    We will set the `fringe` property of `currentNode` to `False`, because it''s currently
    selected for exploration:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个`TreePlot`对象并调用其`generateDiagram()`方法来可视化当前的搜索树。在这种情况下，搜索树将只包含根节点。我们将根节点及其启发式值添加到优先队列中。我们检查优先队列是否为空；如果不为空，我们获取队列的前一个元素并将其命名为`currentNode`。如前所述，优先队列的格式是一个包含启发式值和节点的元组。由于我们只关心节点，因此会忽略启发式值。我们将`currentNode`的`fringe`属性设置为`False`，因为它当前已被选中进行探索：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We check whether the current node has the goal state; if it has the goal state,
    we print the path from the initial state to the goal state. We show the current
    search tree by calling the `treeplot.generateDiagram` method. If it doesn't have
    the goal state, we find the child states of the current node, and for each `childState`,
    we create the `childNode` by using the new constructor. In this new constructor,
    we pass the parent node as the `currentNode`, and we add the child node, along
    with its heuristic value, to the priority queue; we then display the current search
    tree.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查当前节点是否具有目标状态；如果它有目标状态，我们将打印从初始状态到目标状态的路径。我们通过调用`treeplot.generateDiagram`方法来显示当前的搜索树。如果没有目标状态，我们会找到当前节点的子状态，并为每个`childState`使用新的构造函数创建`childNode`。在这个新的构造函数中，我们将父节点作为`currentNode`传递，并将子节点及其启发式值添加到优先队列中；然后我们显示当前的搜索树。
- en: 'So, we actually display the search tree at each step, whenever one level of
    the search tree is added. In this case, the search tree contains the root node.
    When one level of the search tree is added, we display the search tree; finally,
    when we reach the goal state, we prepare and then display the search tree that
    has been explored:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们实际上在每一步都显示搜索树，每当搜索树的一层被添加时。在这种情况下，搜索树只包含根节点。当添加一层搜索树时，我们会显示搜索树；最后，当我们到达目标状态时，我们会准备并显示已经探索过的搜索树：
- en: '![](img/c69db465-7111-4fed-b84a-0b7327faca8b.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c69db465-7111-4fed-b84a-0b7327faca8b.png)'
- en: Figure 13
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13
- en: 'As you can see in the preceding output, we have a root node with the heuristic
    value `8.9` in our search tree. The `Bus Stop` node has been selected for exploration,
    and its child node library has been added to the search tree. The heuristic value
    of `Library` is `8.2`, which is lower than the heuristic value of `Bus Stop`,
    which is `8.9`. Since this is the only node in the fringe, it will be selected
    for exploration later:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的输出中看到的，我们的搜索树中有一个启发式值为`8.9`的根节点。`Bus Stop`节点已被选中进行探索，它的子节点`Library`已经被添加到搜索树中。`Library`的启发式值是`8.2`，低于`Bus
    Stop`的启发式值`8.9`。由于这是唯一的“fringe”节点，它将在稍后被选中进行探索：
- en: '![](img/451b7fe9-89f5-47bd-898f-06ec082cd05f.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/451b7fe9-89f5-47bd-898f-06ec082cd05f.png)'
- en: Figure 14
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14
- en: 'As shown in the preceding diagram, `Library` has been selected for exploration,
    and the child nodes of the `Library` node are added. We can see that for the three
    child nodes in the fringe, `Bus Stop` has a heuristic value of `8.9`, `Car Park`
    has a heuristic value of `6.4`, and `Student Center` has a heuristic value of
    `8.0`. Out of the three nodes, `Car Park` has the lowest heuristic value, so this
    will be selected for exploration:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，`Library`已被选中进行探索，并且`Library`节点的子节点已被添加。我们可以看到，对于边缘上的三个子节点，`Bus Stop`的启发式值为`8.9`，`Car
    Park`的启发式值为`6.4`，而`Student Center`的启发式值为`8.0`。在这三个节点中，`Car Park`的启发式值最低，因此它将被选中进行探索：
- en: '![](img/c9ef7ed8-df5c-4c40-9bbc-34f81b4b6e17.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9ef7ed8-df5c-4c40-9bbc-34f81b4b6e17.png)'
- en: Figure 15
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图15
- en: 'Now, `Car Park` has been selected for exploration, and its child nodes are
    added to the priority queue. Here, we have five nodes in the fringe. `Bus Stop`
    has a heuristic value of `8.9`, the `Maths Building` has a heuristic value of `2.2`,
    `Library` has a value of `8.2`, `Store` has a value of `4`, and `Student Center`
    has a value of `8.0`. Of these five nodes, `Maths Building` has the lowest heuristic
    value (`2.2`), so it will be selected for exploration:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Car Park`已被选中进行探索，并且其子节点已被添加到优先队列中。此时，边缘中有五个节点。`Bus Stop`的启发式值为`8.9`，`Maths
    Building`的启发式值为`2.2`，`Library`的值为`8.2`，`Store`的值为`4`，`Student Center`的值为`8.0`。这五个节点中，`Maths
    Building`的启发式值最低（`2.2`），因此它将被选中进行探索：
- en: '![](img/ba05d135-960f-4cdd-b4fa-f500362731ea.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba05d135-960f-4cdd-b4fa-f500362731ea.png)'
- en: Figure 16
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图16
- en: 'Now, `Maths Building` has been selected for exploration, and its child nodes
    are added to the search tree. Of the nodes in the fringe, `Canteen` has the lowest
    heuristic value (`1.0`), so it will be selected for exploration:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Maths Building`已被选中进行探索，并且其子节点已被添加到搜索树中。在边缘中的节点中，`Canteen`的启发式值最低（`1.0`），因此它将被选中进行探索：
- en: '![](img/7ac994e1-0402-4919-9414-06bb3adb5e5b.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ac994e1-0402-4919-9414-06bb3adb5e5b.png)'
- en: Figure 17
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图17
- en: 'Now, the `Canteen` node has been selected for exploration, and its child nodes
    are added to the search tree and to the fringe. Out of all of the blue nodes,
    `AI Lab` has the lowest heuristic value (`0.0`), so it will be selected for exploration:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Canteen`节点已被选中进行探索，并且其子节点已被添加到搜索树和边缘。所有蓝色节点中，`AI Lab`的启发式值最低（`0.0`），因此它将被选中进行探索：
- en: '![](img/8665302a-ad86-43f4-8b96-9542f4543467.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8665302a-ad86-43f4-8b96-9542f4543467.png)'
- en: Figure 18
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图18
- en: Finally, the `AI Lab` is selected for processing, and we find that we've reached
    the goal state, so we end our search here. The optimal path is shown by the green
    nodes and by the red node. The optimal path is `Bus Stop`, `Library`, `Car Park`,
    `Maths Building`, `Canteen`, and `AI Lab`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，`AI Lab`被选中进行处理，我们发现我们已经达到了目标状态，因此我们在这里结束搜索。最优路径由绿色节点和红色节点表示。最优路径是`Bus Stop`、`Library`、`Car
    Park`、`Maths Building`、`Canteen`和`AI Lab`。
- en: As we go from the initial state to the goal state, we can observe that the heuristic
    values reduce. `Bus Stop` has the value `8.9`, `Library` has the value `8.2`,
    `Car Park` has the value `6.4`, `Maths Building` has the value `2.2`, `Canteen`
    has the value `1`, and `AI Lab` has the value `0`. This means that as we traverse
    the search tree, we are getting closer to the goal state. In the greedy BFS algorithm,
    the heuristic value reduces as we progress toward the goal state.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从初始状态到达目标状态时，我们可以观察到启发式值在减少。`Bus Stop`的值为`8.9`，`Library`的值为`8.2`，`Car Park`的值为`6.4`，`Maths
    Building`的值为`2.2`，`Canteen`的值为`1`，`AI Lab`的值为`0`。这意味着，当我们遍历搜索树时，我们正逐渐接近目标状态。在贪心BFS算法中，启发式值随着我们朝目标状态前进而减少。
- en: Now that you have learned the heuristic function for the greedy BFS algorithm,
    in the next section you will learn the problems with the greedy BFS algorithm,
    and you will see how A* Search solves those problems.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了贪心BFS算法的启发式函数，在接下来的部分，你将学习贪心BFS算法的问题，并且你将看到A*搜索如何解决这些问题。
- en: A* Search
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: A* 搜索
- en: 'In the preceding section, you learned that the path found by a greedy BFS is
    as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，你学到了贪心BFS找到的路径如下：
- en: '![](img/0c1ae32b-611b-4bae-bed8-6eb9c62ac70e.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c1ae32b-611b-4bae-bed8-6eb9c62ac70e.png)'
- en: Figure 19
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图19
- en: 'The total distance covered is **14.24**. However, the actual optimal solution
    is shown in the following diagram:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 总覆盖距离为**14.24**。然而，实际的最优解如下图所示：
- en: '![](img/03899d33-7b12-4e27-88ea-9915b9ee0b9c.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03899d33-7b12-4e27-88ea-9915b9ee0b9c.png)'
- en: Figure 20
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图20
- en: The total distance covered is **12**. This means that the greedy BFS algorithm
    is not optimal. The problem is that the heuristic function doesn't consider the
    costs already incurred. A* Search proposes a new heuristic function, which computes
    the sum of the cost incurred and the estimated cost to reach the goal state.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 总行驶距离是**12**。这意味着贪心BFS算法并非最优。问题在于，启发式函数没有考虑到已经发生的成本。A*搜索提出了一种新的启发式函数，它计算了已经发生的成本与到目标状态的预计成本之和。
- en: 'For our application, the heuristic function can compute the sum of the distance
    traveled from the root node to the current node, and the straight line distance
    to the goal state. Let''s look at the example that we saw in the previous section
    and compute this new heuristic function for the three nodes **Car Park**, **Bus
    Stop**, and **Student Center**:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用，启发式函数可以计算从根节点到当前节点的已行驶距离与到目标状态的直线距离之和。让我们看一下我们在上一节中看到的例子，并为三个节点**停车场**、**公交车站**和**学生中心**计算这个新的启发式函数：
- en: '![](img/64fceb91-d333-4164-81b4-fd4a5ed47f0e.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64fceb91-d333-4164-81b4-fd4a5ed47f0e.png)'
- en: Figure 21
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21
- en: 'For the **Car Park**, the distance traveled is **2** + **5**, and the distance
    to the goal state is **6**, so the value of the new heuristic is **13.4**. For
    the **Bus Stop**, the distance traveled is **2** + **2**, which is **4**, and
    the distance to the goal state is **8.9**, so the value of the new heuristic function
    for the **Bus Stop** is **4** + **8.9**, which is **12.9**. For the **Student
    Center**, the distance traveled is **2** + **2**, which is **4**, and the distance
    to the goal state is **8**, so the value of the new heuristic function for the **Student
    Center** is **4** + **8**,which is **12**. Based on these new heuristic values,
    we will select **Student Center** for further exploration:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**停车场**，已经行进的距离是**2** + **5**，到目标状态的距离是**6**，所以新的启发式值为**13.4**。对于**公交车站**，已经行进的距离是**2**
    + **2**，即**4**，到目标状态的距离是**8.9**，因此**公交车站**的新的启发式函数值为**4** + **8.9**，即**12.9**。对于**学生中心**，已经行进的距离是**2**
    + **2**，即**4**，到目标状态的距离是**8**，所以**学生中心**的新的启发式函数值为**4** + **8**，即**12**。根据这些新的启发式值，我们将选择**学生中心**进行进一步探索：
- en: '![](img/de48865f-8fb7-4173-85e2-31db9084d0d9.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de48865f-8fb7-4173-85e2-31db9084d0d9.png)'
- en: Figure 22
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 22
- en: 'In addition to the changes to the `Node` class, which we saw in the *Visualizing
    a search tree* section, we will introduce a property called `costFromRoot` and
    a method called `computeCost`. The `costFromRoot` property is the distance incurred
    while traveling from the root node to the current node, and this value will be
    computed by the `computeCost` function:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在*可视化搜索树*部分看到的对`Node`类的更改外，我们将引入一个名为`costFromRoot`的属性和一个名为`computeCost`的方法。`costFromRoot`属性表示从根节点到当前节点的行驶距离，这个值将通过`computeCost`函数计算得出：
- en: '![](img/678db639-178b-4aac-b2dd-c99a0ab34de3.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/678db639-178b-4aac-b2dd-c99a0ab34de3.png)'
- en: Figure 23
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 23
- en: 'Let''s look at how the `computeCost` method works. As indicated by the preceding
    diagram, we have three nodes: **Bus Stop**, **Library**, and **Car Park**. The
    distance between **Bus Stop** and **Library** is **2**, and the distance between
    **Library** and **Car Park** is **5**. Since **Bus Stop** is the initial state,
    the cost for that node is **0**. For **Library**, the cost from the root is **2**,
    and for **Car Park**, the `costFromRoot` is **2** + **5**, which is **7**. This
    is also the cost of its parent node plus the distance between the parent node
    and the current node. So, we can write the formula as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`computeCost`方法是如何工作的。如前面的图所示，我们有三个节点：**公交车站**、**图书馆**和**停车场**。**公交车站**到**图书馆**的距离是**2**，**图书馆**到**停车场**的距离是**5**。由于**公交车站**是初始状态，该节点的成本是**0**。对于**图书馆**，根节点到它的成本是**2**，对于**停车场**，`costFromRoot`是**2**
    + **5**，即**7**。这也是它的父节点的成本加上父节点与当前节点之间的距离。所以，我们可以写出如下公式：
- en: '*costFromRoot = parent''s costFromRoot + distance of parent node to current
    node*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*costFromRoot = 父节点的 costFromRoot + 父节点到当前节点的距离*'
- en: 'Let''s look at the code for this method. Before we look at the `computeCost`
    method, let''s look at the `computeDistance` method:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下这个方法的代码。在查看`computeCost`方法之前，我们先看一下`computeDistance`方法：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This method computes the distance between two locations, and it takes `location1`
    and `location2` as arguments. It finds the difference in the *x* coordinates as
    `dx` is equal to `location1[0] - location2[0]`, and it finds the difference in
    the *y* coordinates as `dy` is equal to `location1[1] - location2[1]`. It finds
    the distance as the square root of `dx` square plus `dy` square, and it returns
    this distance:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法计算两个位置之间的距离，它将`location1`和`location2`作为参数。它通过计算 *x* 坐标的差值得到 `dx`，即 `dx =
    location1[0] - location2[0]`，并通过计算 *y* 坐标的差值得到 `dy`，即 `dy = location1[1] - location2[1]`。然后它通过计算
    `dx` 的平方加 `dy` 的平方的平方根来得到距离，并返回这个距离：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `computeCost` method computes the distance of the current node from the
    root node. So, we check whether the `parent` property is `None`. Then, we find
    the distance from the current location to the parent location, and we compute
    the `costFromRoot` as the parent''s `costFromRoot` plus the distance that we''ve
    just computed; if the parent is `None`, then `costFromRoot` is `0`, because this
    is the root node:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`computeCost` 方法计算当前节点到根节点的距离。所以，我们检查 `parent` 属性是否为 `None`。然后，我们计算从当前节点到父节点的距离，并计算
    `costFromRoot` 为父节点的 `costFromRoot` 加上我们刚刚计算的距离；如果父节点是 `None`，则 `costFromRoot`
    为 `0`，因为这是根节点：'
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s look at the `computerHeuristic` method. Just like in a greedy BFS,
    we find the goal location as the location of the `AI Lab` and the current location,
    and we find the distance from the goal as the distance between the goal location
    and the current location. Then, we compute the heuristic as a sum of `costFromRoot`
    and `distanceFromGoal`, and we assign the `heuristic` property as this heuristic
    value:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来看一下`computerHeuristic`方法。就像在贪心 BFS 中一样，我们找出目标位置为`AI实验室`的地点，并且找出当前地点与目标地点之间的距离。接着，我们计算启发式值，将`costFromRoot`和`distanceFromGoal`相加，并将`heuristic`属性赋值为这个启发式值：
- en: '![](img/7d797ac3-2a07-42f5-bd98-43483d590660.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d797ac3-2a07-42f5-bd98-43483d590660.png)'
- en: Figure 24
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 24
- en: 'As shown in the preceding diagram, the flow of A* Search is actually the same
    as that of greedy BFS. So, let''s look at the code for A* Search, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的图所示，A* 搜索的流程实际上与贪心 BFS 相同。那么，我们来看一下 A* 搜索的代码，如下所示：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the Python `AStar.py` module, we have created a method called `performAStarSearch`,
    which has the code for A* Search; this code is exactly the same as that of greedy
    BFS:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 的 `AStar.py` 模块中，我们创建了一个名为 `performAStarSearch` 的方法，它包含了 A* 搜索的代码；这段代码与贪心
    BFS 的代码完全相同：
- en: '![](img/b1c984d4-a44e-4ef2-86ca-4477f12a5ab4.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1c984d4-a44e-4ef2-86ca-4477f12a5ab4.png)'
- en: Figure 25
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 25
- en: 'Initially, we have our root node with a heuristic value of `8.9`, and the `Bus
    Stop` node is selected for expansion; its `Library` child is added, and that has
    a heuristic value of `10.2`. Since this is the only node in the fringe, it will
    be selected for exploration:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们有一个启发式值为`8.9`的根节点，并选择`公交车站`节点进行扩展；它的`图书馆`子节点被添加，并且该节点的启发式值为`10.2`。由于这是唯一在边界的节点，它将被选中进行探索：
- en: '![](img/56bc4f05-5ff5-45ea-841e-c8d4e70be756.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56bc4f05-5ff5-45ea-841e-c8d4e70be756.png)'
- en: Figure 26
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 26
- en: 'Now the `Library` node is selected for exploration, and its three child nodes
    are added. `Bus Stop` has a heuristic value of `12.9`, `Car Park` has a heuristic
    value of `13.4`, and `Student Center` has a heuristic value of `12`. Out of these
    three, `Student Center` has the lowest heuristic value, so it will be selected
    for exploration:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`图书馆`节点被选中进行探索，它的三个子节点被添加。`公交车站`的启发式值为`12.9`，`停车场`的启发式值为`13.4`，`学生中心`的启发式值为`12`。在这三者中，`学生中心`的启发式值最低，因此它将被选中进行探索：
- en: '![](img/0d541455-a2cc-416d-a857-310c55ef0260.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d541455-a2cc-416d-a857-310c55ef0260.png)'
- en: Figure 27
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 27
- en: 'Now `Student Center` is selected for exploration, and its three child nodes
    are added to the fringe. Out of the five nodes in the fringe, `Store` has the
    lowest heuristic value, so it will be selected for exploration:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`学生中心`被选中进行探索，它的三个子节点被添加到边界。在边界的五个节点中，`商店`的启发式值最低，因此它将被选中进行探索：
- en: '![](img/b6298ea6-736a-4242-82f4-4554dca2c633.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6298ea6-736a-4242-82f4-4554dca2c633.png)'
- en: Figure 28
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 28
- en: 'Now `Store` is selected for exploration, and its four child nodes are added.
    Out of the eight nodes in the fringe, `Canteen` has the lowest heuristic value,
    so it will be selected for exploration:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`商店`被选中进行探索，它的四个子节点被添加。在边界的八个节点中，`食堂`的启发式值最低，因此它将被选中进行探索：
- en: '![](img/d4cdfedd-0900-409e-980b-4f4747cb0fee.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4cdfedd-0900-409e-980b-4f4747cb0fee.png)'
- en: Figure 29
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 29
- en: 'Now `Canteen` has been selected for exploration, and its child nodes are added
    to the search tree and to the fringe. Out of all of the nodes in the fringe, `AI
    Lab` has the lowest heuristic value, so this node will be selected for exploration:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Canteen`已被选中进行探索，其子节点被添加到搜索树和边界中。在所有边界中的节点中，`AI Lab`具有最低的启发式值，因此该节点将被选中进行探索：
- en: '![](img/e88755c5-2299-4da6-a0e3-24a115425706.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e88755c5-2299-4da6-a0e3-24a115425706.png)'
- en: Figure 30
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图30
- en: When `AI Lab` is select for exploration, we find that we've encountered the
    goal state, and we stop our search.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当`AI Lab`被选中进行探索时，我们发现已经遇到了目标状态，因此停止搜索。
- en: The optimal path is indicated by the green nodes and the red node. The optimal
    path is from `Bus Stop` to `Library` to `Student Center` to `Store` to `Canteen`,
    and finally to `AI Lab`. As we traverse from the root node to the goal node, we
    find that the heuristic function value either remains the same or increases. So, `Bus
    Stop` has the value `9`, `Library` has the value `10.2`, `Student Center` has
    the value `12.0`, `Store` has the value `12.0`, `Canteen` has the value `12.0`,
    and finally `AI Lab` has the value `12.0`. So, in this example, we learned that
    the heuristic function increases or remains the same as we progress from the initial
    state to the goal state, and we also observed that A* Search is optimal. We saw
    that greedy BFS is not optimal, and we can now understand why. We saw a new heuristic
    function, which makes A* optimal. In the next section, we will look at what a
    good heuristic function entails.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最优路径由绿色节点和红色节点表示。最优路径是从`Bus Stop`到`Library`，再到`Student Center`，然后到`Store`，最后到`Canteen`，最终到`AI
    Lab`。当我们从根节点遍历到目标节点时，我们发现启发式函数的值要么保持不变，要么增加。因此，`Bus Stop`的值为`9`，`Library`的值为`10.2`，`Student
    Center`的值为`12.0`，`Store`的值为`12.0`，`Canteen`的值为`12.0`，最后`AI Lab`的值为`12.0`。因此，在这个例子中，我们了解到启发式函数在从初始状态到目标状态的过程中是增加或保持不变的，并且我们还观察到
    A* 搜索是最优的。我们看到贪婪的 BFS 不是最优的，现在我们能理解为什么。我们看到了一种新的启发式函数，这使得 A* 是最优的。在下一节中，我们将探讨一个好的启发式函数应该具备哪些特点。
- en: What is a good heuristic function?
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是好的启发式函数？
- en: To answer the question, *why is a good heuristic function required?* We will
    compare the DFS and BFS methods to the heuristic search approach. In DFS and BFS,
    the costs of all of the edges are equal to **1**, and DFS explores all of the
    child nodes, whereas BFS explores all of the sibling nodes. In a heuristic search,
    the costs of the edges are different, and the heuristic search selects the nodes
    to explore based on heuristic functions.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这个问题，*为什么需要一个好的启发式函数？* 我们将把深度优先搜索（DFS）和广度优先搜索（BFS）方法与启发式搜索方法进行比较。在 DFS 和
    BFS 中，所有边的成本都等于**1**，DFS会探索所有子节点，而BFS会探索所有兄弟节点。在启发式搜索中，边的成本是不同的，启发式搜索根据启发式函数选择要探索的节点。
- en: By using a heuristic function, we can reduce the memory that is used, and we
    can reach the solution in less time. The next question to be answered is, *why
    is a good heuristic function required?* The answer is in order to find the **optimal
    solution**. In our A* Search example, we illustrated that by using a better heuristic
    function, we can find the optimal solution; it is clear that A* explores the least
    number of nodes. Now, let's look at the properties of a good heuristic function.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用启发式函数，我们可以减少所使用的内存，并且可以在更短的时间内达到解决方案。接下来需要回答的问题是，*为什么需要一个好的启发式函数？* 答案是为了找到**最优解**。在我们的
    A* 搜索示例中，我们通过使用更好的启发式函数，说明了我们能够找到最优解；很明显，A* 探索的节点数量最少。现在，让我们来看看一个好的启发式函数的属性。
- en: Properties of a good heuristic function
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 好的启发式函数的属性
- en: The properties of a good heuristic functions are detailed in the following sections.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的启发式函数的属性将在接下来的章节中详细说明。
- en: Admissible
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可接受性
- en: 'A good heuristic function should be admissible, which means that the heuristic
    function should have a value that is less than (or equal to) the true cost to
    reach the goal:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的启发式函数应该是可接受的，这意味着启发式函数的值应该小于或等于到达目标的真实成本：
- en: '![](img/3ab2b1e9-ea0b-4bc6-86e7-cae780e77d24.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ab2b1e9-ea0b-4bc6-86e7-cae780e77d24.png)'
- en: Figure 31
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图31
- en: 'Let''s suppose that node **1** is the root node and node **5** has the goal
    state, and we are currently computing the heuristic function for node **2**; the
    following applies:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 假设节点**1**是根节点，节点**5**是目标状态，而我们正在为节点**2**计算启发式函数；以下内容适用：
- en: '**d12** is the cost of the path from **1** to **2**'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**d12**是从**1**到**2**的路径成本'
- en: '**d24** is the cost of the path from node **2** to **4**'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**d24**是从节点**2**到**4**的路径成本'
- en: '**d45** is the cost from node **4** to **5**'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**d45**是从节点**4**到节点**5**的代价'
- en: '**d23** is the cost from node **2** to **3**'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**d23**是从节点**2**到节点**3**的代价'
- en: '**d35** is the cost from node **3** to **5**'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**d35**是从节点**3**到节点**5**的代价'
- en: 'Then, in order for our function to be admissible, the following must be true:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了使我们的函数是可接受的，必须满足以下条件：
- en: The heuristic function for node **2** should have a value less than or equal
    to **d24** + **d45**
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点**2**的启发式函数值应该小于或等于**d24** + **d45**
- en: The heuristic function for node **2** should have a value less than or equal
    to **d23** + **d35**
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点**2**的启发式函数值应该小于或等于**d23** + **d35**
- en: '![](img/84009382-23c5-4abe-a45f-e1918b1f2f83.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84009382-23c5-4abe-a45f-e1918b1f2f83.png)'
- en: Figure 32
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 32
- en: 'In the preceding example, node **1** is the root node and node **5** has the
    goal state. The red values are the estimated cost to the goal state, and the green
    values are the true cost of the edge:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，节点**1**是根节点，节点**5**是目标状态。红色值表示估计到目标状态的代价，绿色值表示边的真实代价：
- en: Let's suppose that we have explored node **1**, and have added nodes **2** and
    **3** to the fringe. So, we will compute the heuristic values for nodes **2**
    and **3**.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们已经探索过节点**1**，并将节点**2**和**3**添加到了边缘。接下来，我们将计算节点**2**和**3**的启发式函数值。
- en: The heuristic value for node **2** is **3** + **9***,* which is **12**, and
    the heuristic value for node **3** is **10** + **1***,* which is **11**; based
    on these values, we select node **3** for further exploration.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 节点**2**的启发式值为**3** + **9**，即**12**，节点**3**的启发式值为**10** + **1**，即**11**；基于这些值，我们选择节点**3**进行进一步探索。
- en: We add the child of node **3**, which is node **5**, to the fringe. The fringe
    contains nodes **2** and **5**. We had previously computed the heuristic function
    for node **2** as **12**, and the heuristic function for node **5** as **10**
    + **10** + **0**, which is **20**. So, based on these values, we will select node
    **2** for exploration.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将节点**3**的子节点，即节点**5**，添加到边缘。边缘包含节点**2**和节点**5**。我们之前已经计算了节点**2**的启发式函数值为**12**，节点**5**的启发式函数值为**10**
    + **10** + **0**，即**20**。所以，基于这些值，我们将选择节点**2**进行探索。
- en: We add the child of node **2**, which is node **4**, to the fringe. Now, the
    fringe contains **4** and **5**. We had previously computed the heuristic function
    for node **5** as **20**, and we will compute the heuristic function for node
    **4** as **3** + **3** + **1**, which is **7**. Based on these values, we will
    select node **4** for further exploration.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将节点**2**的子节点，即节点**4**，添加到边缘。现在，边缘包含节点**4**和节点**5**。我们之前已经计算了节点**5**的启发式函数值为**20**，并将计算节点**4**的启发式函数值为**3**
    + **3** + **1**，即**7**。基于这些值，我们将选择节点**4**进行进一步探索。
- en: We add the child of node **4**, which is node **5**, to the fringe. The fringe
    contains node **5** through path [1-3-5], and node **5** through path [1-2-4-5].
    We had previously computed the heuristic function for node **5** through path
    [1-3-5] as **20**. So, we compute the heuristic function of node **5** through
    path [1-2-4-5] as **3** + **3** + **3** + **0**, which is **9**. Based on these
    values, we select node **5** with path [1-2-4-5]; when we process this node, we
    see that we've reached the goal state and end our search here.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将节点**4**的子节点，即节点**5**，添加到边缘。边缘通过路径[1-3-5]包含节点**5**，并且通过路径[1-2-4-5]也包含节点**5**。我们之前已经计算了节点**5**通过路径[1-3-5]的启发式函数值为**20**。所以，我们计算节点**5**通过路径[1-2-4-5]的启发式函数值为**3**
    + **3** + **3** + **0**，即**9**。基于这些值，我们选择路径[1-2-4-5]上的节点**5**；当我们处理这个节点时，我们看到已经到达了目标状态，并在此结束搜索。
- en: In this example, you saw that during the search process, we side-tracked to
    node **3**. Later, we found the optimal solution to be [1-2-4-5]. So, an admissible
    heuristic guaranteed finding the optimal solution.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你看到在搜索过程中，我们偏离了路径来探索节点**3**。后来，我们发现最优解是[1-2-4-5]。因此，一个可接受的启发式函数确保找到了最优解。
- en: Consistent
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一致性
- en: 'The second property a good heuristic function should have is that it should
    be consistent, which means that it should be non-decreasing:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的启发式函数应具备的第二个属性是它应该是一致的，这意味着它应该是非递减的：
- en: '![](img/463fdd3f-c3f9-4bd7-a2ac-f4024fcf46d2.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/463fdd3f-c3f9-4bd7-a2ac-f4024fcf46d2.png)'
- en: Figure 33
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 33
- en: 'For example, the heuristic function for node **3** should be greater than (or
    equal to) the heuristic function for node **2**, and the value of the heuristic
    function for node **4 **should be greater than (or equal to) the value of the
    heuristic function for node **2**. Let''s look at why this is so, through the
    following diagram:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，节点**3**的启发式函数应该大于（或等于）节点**2**的启发式函数，而节点**4**的启发式函数值应该大于（或等于）节点**2**的启发式函数值。让我们通过以下图示来看看为什么会这样：
- en: '![](img/dd95ca51-d5da-41a4-9596-f5ba4a05a8e5.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dd95ca51-d5da-41a4-9596-f5ba4a05a8e5.png)'
- en: Figure 34
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图34
- en: Let's suppose that nodes **1** and **2** are intermediate nodes, and node **5**
    has the goal state. First, **x1** is the estimated cost of node **1** to node
    **5**, and **x2** is the estimated cost of reaching the goal state from node **2**;
    **d12** is the cost of going from node **1** to node **2**.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 假设节点**1**和**2**是中间节点，节点**5**是目标状态。首先，**x1**是从节点**1**到节点**5**的估计成本，**x2**是从节点**2**到目标状态的估计成本；**d12**是从节点**1**到节点**2**的成本。
- en: 'Let''s suppose that node **2** is closer to the goal state than node **1**;
    this means that the following statement applies:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 假设节点**2**离目标状态比节点**1**更近；这意味着以下陈述适用：
- en: '[PRE22]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Suppose that the following statement is true:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 假设以下陈述为真：
- en: '[PRE23]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding code means that `x1 <= d12 + x2`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码意味着`x1 <= d12 + x2`。
- en: 'Suppose that `TC1` is the true cost of reaching node **1** from the root node;
    then, the heuristic function for node 1 will be as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`TC1`是从根节点到节点**1**的真实成本；那么，节点**1**的启发式函数如下：
- en: '[PRE24]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The heuristic function for node **2** will be as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 节点**2**的启发式函数如下：
- en: '[PRE25]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is because `d12 + x2 >= x1`; the heuristic value of **2** is greater than
    or equal to the value of the heuristic function for node **1** (that is, `h(2)>=h(1)`).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`d12 + x2 >= x1`；节点**2**的启发式值大于或等于节点**1**的启发式函数值（即，`h(2)>=h(1)`）。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: You should now understand what a heuristic function is, and also the priority
    queue data structure. In this chapter, you learned how to visualize search trees.
    You learned the heuristic function for a greedy best-first search and the steps
    involved in this algorithm. We also covered problems related to the greedy best-first
    algorithm, and how an A* Search solves them. Finally, you learned the properties
    required for a good heuristic function.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该理解什么是启发式函数，以及优先队列数据结构。在本章中，你学会了如何可视化搜索树。你了解了贪心最佳优先搜索的启发式函数和该算法的步骤。我们还讨论了与贪心最佳优先算法相关的问题，以及A*搜索是如何解决这些问题的。最后，你了解了一个好的启发式函数所需的属性。
- en: Please refer to the link [https://www.packtpub.com/sites/default/files/downloads/HandsOnArtificialIntelligenceforSearch_ColorImages.pdf](https://www.packtpub.com/sites/default/files/downloads/HandsOnArtificialIntelligenceforSearch_ColorImages.pdf) for
    the colored images of this chapter.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅链接[https://www.packtpub.com/sites/default/files/downloads/HandsOnArtificialIntelligenceforSearch_ColorImages.pdf](https://www.packtpub.com/sites/default/files/downloads/HandsOnArtificialIntelligenceforSearch_ColorImages.pdf)以获取本章的彩色图像。
