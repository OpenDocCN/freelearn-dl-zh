- en: Deep Learning on Microsoft Azure Using Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python在微软Azure上进行深度学习
- en: We are going to end our cloud API exploration journey with this chapter. So
    far, we have gently introduced ourselves to the wonderful world of APIs, specifically
    the APIs that let us carry out deep learning with ease. We have seen how to consume
    REST APIs and use them programmatically. Like **Google Cloud Platform** (**GCP**)
    and **Amazon Web Services** (**AWS**), Microsoft also offers its own cloud service
    platform, which is called Azure. As in previous chapters, we will only be focusing
    on the deep learning-based solutions that Azure has to offer. We will be shifting
    gears a bit and will also take a look at Microsoft's **Cognitive Toolkit** (**CNTK**),
    which is a deep learning framework like Keras.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将结束我们的云API探索之旅。到目前为止，我们已经轻松地了解了API的精彩世界，特别是那些让我们轻松进行深度学习的API。我们已经看到了如何使用REST
    API并通过编程方式使用它们。像**谷歌云平台**（**GCP**）和**亚马逊云服务**（**AWS**）一样，微软也提供了自己的云服务平台，称为Azure。与前几章一样，我们将重点介绍Azure提供的基于深度学习的解决方案。我们将稍微调整一下方向，还将介绍微软的**认知工具包**（**CNTK**），它是一个类似于Keras的深度学习框架。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Setting up your account in Azure
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Azure中设置你的账户
- en: A quick walk-through of the deep learning solutions offered by Azure
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速了解Azure提供的深度学习解决方案
- en: Using the Face API in Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中使用人脸API
- en: Using the Text Analytics API in Python
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中使用文本分析API
- en: An introduction to CNTK
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CNTK简介
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can access the code for this chapter from [https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/tree/master/Chapter8](https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/tree/master/Chapter8).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/tree/master/Chapter8](https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/tree/master/Chapter8)访问本章的代码。
- en: 'To run the code used in this chapter, you''ll need the following software:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行本章使用的代码，你需要以下软件：
- en: Python 3.6+
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.6+
- en: The Python PIL library
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python PIL库
- en: The Matplotlib library
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Matplotlib库
- en: All other installations, such as CNTK and Django, will be described during the
    course of this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他安装步骤，如CNTK和Django，将在本章中进一步介绍。
- en: Setting up your account in Azure
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Azure中设置你的账户
- en: 'From your previous cloud platform usage experience, you may have realized that
    it all starts with setting up your account and billing in a cloud provider. This
    is a pretty standard workflow and Azure is no exception. So, let''s head over
    to [https://azure.microsoft.com](https://azure.microsoft.com/) and follow these
    steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你之前使用云平台的经验，你可能已经意识到，所有一切都始于在云服务提供商处设置账户和账单。这是一个相当标准的工作流程，Azure也不例外。因此，让我们前往[https://azure.microsoft.com](https://azure.microsoft.com/)，并按照以下步骤操作：
- en: 'Click on the Start free button, as shown:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“开始免费试用”按钮，如下所示：
- en: '![](img/01908bbd-6abc-4f1b-8b26-2d05cab0472d.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01908bbd-6abc-4f1b-8b26-2d05cab0472d.png)'
- en: Note that you will need a Microsoft account to proceed with the following steps.
    So, if you do not have one, create one at [https://account.microsoft.com/account](https://account.microsoft.com/account).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你需要一个微软账户才能继续进行以下步骤。如果你没有账户，可以在[https://account.microsoft.com/account](https://account.microsoft.com/account)创建一个。
- en: You will be redirected to another page, where you will again see another Start
    free button. Click on it.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将被重定向到另一个页面，页面中会再次显示一个“开始免费试用”按钮。点击它。
- en: '![](img/e67d8ec9-75a8-48a3-aa96-a76668954eb7.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e67d8ec9-75a8-48a3-aa96-a76668954eb7.png)'
- en: 'You will be asked to log in to your Microsoft account to proceed. Give the
    credentials accordingly and you should land on a page as in the following screenshot:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将被要求登录微软账户才能继续。根据提示输入账户信息，应该能看到如下截图的页面：
- en: '![](img/89e7d103-9c26-4a97-aaa8-78989fd0b407.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89e7d103-9c26-4a97-aaa8-78989fd0b407.png)'
- en: If you are a first-time user, you will get $200 of credit (depending on your
    currency) for free for 30 days to explore different services offered by Azure.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是首次使用，你将获得价值200美元的信用额度（根据你的货币不同），可以免费使用30天，探索Azure提供的不同服务。
- en: Fill in your details, which will also include verification of your identity
    by card.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写你的详细信息，包括通过银行卡验证身份。
- en: You might be charged a very nominal fee for this. Be sure to review the terms
    and conditions of the Azure free tier, which you will find at [https://azure.microsoft.com/en-in/offers/ms-azr-0003p/](https://azure.microsoft.com/en-in/offers/ms-azr-0003p/).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要支付一笔非常小的费用。务必查看 Azure 免费套餐的条款和条件，详情请见 [https://azure.microsoft.com/en-in/offers/ms-azr-0003p/](https://azure.microsoft.com/en-in/offers/ms-azr-0003p/)。
- en: Once this process is complete, you are all set up and ready to move to your
    Azure portal ([https://portal.azure.com](https://portal.azure.com/#home)), which
    acts in the same way as the GCP and AWS consoles that you have seen in previous
    chapters.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个过程完成，你就已经设置好了，可以进入你的 Azure 门户 ([https://portal.azure.com](https://portal.azure.com/#home))，它的功能与前几章中提到的
    GCP 和 AWS 控制台类似。
- en: 'The Azure portal looks like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 门户界面如下所示：
- en: '![](img/be9a0fa6-08a0-474a-8d62-b28113ea7fcf.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be9a0fa6-08a0-474a-8d62-b28113ea7fcf.png)'
- en: Now that you have set up your Azure account, let's explore the deep learning-based
    offerings of Azure in the next section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置好了 Azure 账户，让我们在下一节中探索 Azure 基于深度学习的服务。
- en: A walk-through of the deep learning services provided by Azure
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对 Azure 提供的深度学习服务的逐步讲解
- en: 'Azure''s deep learning- (and general machine learning-) based offerings are
    broadly divided into three parts:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 的深度学习（以及一般的机器学习）服务大致分为三大部分：
- en: '**The Azure Machine Learning service** ([https://azure.microsoft.com/en-in/services/machine-learning-service/](https://azure.microsoft.com/en-in/services/machine-learning-service/)),
    which provides an end-to-end machine learning life cycle, including model building,
    training, and deployment:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure 机器学习服务** ([https://azure.microsoft.com/en-in/services/machine-learning-service/](https://azure.microsoft.com/en-in/services/machine-learning-service/))，提供完整的机器学习生命周期，包括模型构建、训练和部署：'
- en: '![](img/5e49fe53-bc9e-41e1-b544-97bdfb6d9e0a.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5e49fe53-bc9e-41e1-b544-97bdfb6d9e0a.png)'
- en: '**Machine Learning APIs** ([https://gallery.azure.ai/machineLearningAPIs](https://gallery.azure.ai/machineLearningAPIs)),
    which provide APIs for a wide range of learning tasks, such as content moderation,
    translation, anomaly detection, and so on:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机器学习 API** ([https://gallery.azure.ai/machineLearningAPIs](https://gallery.azure.ai/machineLearningAPIs))，提供广泛的学习任务
    API，例如内容审核、翻译、异常检测等：'
- en: '![](img/3172ed87-5c07-4de6-bcb3-8a1c49c9ac02.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3172ed87-5c07-4de6-bcb3-8a1c49c9ac02.png)'
- en: '**Azure AI** ([https://azure.microsoft.com/en-in/overview/ai-platform/](https://azure.microsoft.com/en-in/overview/ai-platform/)),
    which focuses on topics such as **knowledge mining**, **decision mining**, and
    many other similar machine learning capabilities in the domains of computer vision
    and language modeling:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure AI** ([https://azure.microsoft.com/en-in/overview/ai-platform/](https://azure.microsoft.com/en-in/overview/ai-platform/))，专注于**知识挖掘**、**决策挖掘**以及计算机视觉和语言建模领域的其他许多类似机器学习能力：'
- en: '![](img/a33df20e-bf48-44a2-b065-44b02e2bf715.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a33df20e-bf48-44a2-b065-44b02e2bf715.png)'
- en: We will now study two APIs for a computer vision task and a natural language
    understanding task, respectively. We will also look at how to use these APIs from
    Python. Let's dive in.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将分别研究两个 API，一个用于计算机视觉任务，一个用于自然语言理解任务。我们还将学习如何从 Python 中使用这些 API。让我们深入了解。
- en: Object detection using the Face API and Python
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Face API 和 Python 进行物体检测
- en: Object detection is a classic use case of computer vision and is widely applied
    to a number of real-world problems, such as video surveillance systems. In this
    section, we will be using the Face API to detect faces from a given image. This
    has direct use when designing video surveillance systems. You can learn more about
    the Face API from its official page at [https://azure.microsoft.com/en-us/services/cognitive-services/face/](https://azure.microsoft.com/en-us/services/cognitive-services/face/).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 物体检测是计算机视觉的经典应用，广泛应用于许多现实世界问题中，如视频监控系统。在本节中，我们将使用 Face API 从给定图像中检测面孔。这在设计视频监控系统时有直接应用。你可以通过
    [https://azure.microsoft.com/en-us/services/cognitive-services/face/](https://azure.microsoft.com/en-us/services/cognitive-services/face/)
    了解更多关于 Face API 的信息。
- en: The initial setup
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始设置
- en: 'Azure lets you try this API for free for a duration of 7 days, as well. But
    since you already have an Azure account (with free credit, I am assuming), we
    can do it another way, as shown:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 还允许你在 7 天内免费试用该 API。但是，由于你已经拥有 Azure 账户（假设你有免费的信用额度），我们可以采用另一种方式，如下所示：
- en: Sign in to your Azure account.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录你的 Azure 账户。
- en: Go to [https://azure.microsoft.com/en-us/services/cognitive-services/face/](https://azure.microsoft.com/en-us/services/cognitive-services/face/).
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 [https://azure.microsoft.com/en-us/services/cognitive-services/face/](https://azure.microsoft.com/en-us/services/cognitive-services/face/)。
- en: Click on Already using Azure? Try this service for free now.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“已经在使用 Azure？现在免费试用此服务”。
- en: 'You should now have a window as in the following screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该看到如下截图的窗口：
- en: '![](img/f1b88b0e-e960-4830-9440-3e4ffa4ab083.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1b88b0e-e960-4830-9440-3e4ffa4ab083.png)'
- en: Fill in the details accordingly and hit Create once you are done. You will get
    a popup that reads Submitting deployment.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写相关信息并点击“创建”完成。您将看到一个弹出窗口，显示“正在提交部署”。
- en: 'Once the deployment is completed, you should land on a page as in the following
    screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 部署完成后，您应该看到如下截图的页面：
- en: '![](img/8d44a941-a39a-4c25-8b07-1457bef65c63.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d44a941-a39a-4c25-8b07-1457bef65c63.png)'
- en: 'Click on Go to resource and you should be redirected to the resources page,
    which contains a bunch of details on it:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“前往资源”，您将被重定向到资源页面，其中包含许多详细信息：
- en: '![](img/08af55b4-5b80-44b4-9943-282a9618ff8d.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08af55b4-5b80-44b4-9943-282a9618ff8d.png)'
- en: Just scroll down a bit and you will be able to see the endpoint of the Face
    API. Note that it will vary depending on the configuration details you entered
    while creating the deployment. The endpoint looks like [https://eastus.api.cognitive.microsoft.com/face/v1.0](https://eastus.api.cognitive.microsoft.com/face/v1.0).
    Note this down.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 只需稍微向下滚动，您就可以看到 Face API 的端点。请注意，它会根据您在创建部署时输入的配置细节而有所不同。该端点看起来像这样：[https://eastus.api.cognitive.microsoft.com/face/v1.0](https://eastus.api.cognitive.microsoft.com/face/v1.0)。请记下它。
- en: 'Now, to be able to use the Face API programmatically, you need to create the
    respective API keys. On that same page, there is a section at the top that says
    **Grab your keys**:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了能够通过编程使用 Face API，您需要创建相应的 API 密钥。在同一页面的顶部，有一个部分写着**获取您的密钥**：
- en: '![](img/15e48360-dd9c-48f2-b123-c6e1680e2514.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15e48360-dd9c-48f2-b123-c6e1680e2514.png)'
- en: 'Under that section, click Keys and you will see something as in the following
    screenshot:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该部分下，点击“密钥”，您将看到类似如下截图的内容：
- en: '![](img/6166e10e-a211-4053-9236-f678e04822cc.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6166e10e-a211-4053-9236-f678e04822cc.png)'
- en: Now that you have the API keys for the Face API, you are ready to use it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经拥有了 Face API 的 API 密钥，准备好使用它了。
- en: Consuming the Face API from Python code
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Python 代码中调用 Face API
- en: When your program includes security credentials such as API keys, it is often
    a good practice to define those keys as environmental variables and then call
    them in your program. So, go ahead and create an environment variable to store
    one of the API keys of the Face API.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的程序包含诸如 API 密钥之类的安全凭证时，通常的最佳做法是将这些密钥定义为环境变量，并在程序中调用它们。因此，创建一个环境变量来存储 Face
    API 的一个 API 密钥。
- en: To add an environment variable to your computer, you can follow this article
    at [https://www.twilio.com/blog/2017/01/how-to-set-environment-variables.html](https://www.twilio.com/blog/2017/01/how-to-set-environment-variables.html).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要将环境变量添加到计算机中，可以参考这篇文章：[https://www.twilio.com/blog/2017/01/how-to-set-environment-variables.html](https://www.twilio.com/blog/2017/01/how-to-set-environment-variables.html)。
- en: 'In my case, I have named the environment variable `face_api_key`. You can put
    any image that contains faces in it. For this example, I will be using this image:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 就我而言，我将环境变量命名为 `face_api_key`。您可以上传任何包含面孔的图像。对于这个示例，我将使用此图像：
- en: '![](img/5429ceba-947a-43c2-abbe-7e92043a3fdf.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5429ceba-947a-43c2-abbe-7e92043a3fdf.jpg)'
- en: 'Create a new Jupyter notebook and follow these steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 Jupyter Notebook 并按照以下步骤操作：
- en: 'Let''s now load up the environment variable using Python, as shown:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 Python 加载环境变量，如下所示：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, assign your Face API endpoint (for object detection) to a variable.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将您的 Face API 端点（用于物体检测）分配给一个变量。
- en: Also, upload the image you want to test to an online file server, such as Imgur,
    and retrieve the URL that allows fetching the raw image from Imgur.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，将您想要测试的图像上传到一个在线文件服务器，如 Imgur，并获取允许从 Imgur 提取原始图像的 URL。
- en: 'In my case, I have uploaded the image to a GitHub repository and used the respective
    URL:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 就我而言，我已将图像上传到 GitHub 仓库，并使用相应的 URL：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that in the preceding API, only the endpoint name at the end of the URL
    changes. In most cases, the part before the endpoint name will remain constant
    throughout your use of Cognitive Services, unless a change is required by the
    Azure platform itself.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的 API 中，URL 末尾的端点名称会发生变化。在大多数情况下，端点名称前面的部分在您使用认知服务时会保持不变，除非 Azure 平台本身要求进行更改。
- en: 'Now, import the `requests` module and set up the API payload as shown:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，导入 `requests` 模块，并按如下所示设置 API 负载：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, we are in a position to make a request to the Face API.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好向 Face API 发出请求。
- en: 'The following lines of code do this for you:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行将为您执行此操作：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can now display the response received from the API:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以显示从 API 接收到的响应：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this case, the code returned is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，返回的代码如下：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Pay attention to the `returnFaceAttributes` body parameter, which lets you specify
    several attributes of faces and the Face API will analyze the given faces with
    respect to those attributes. To find out more about these attributes, check out
    the documentation at [http://bit.ly/2J3j6nM](http://bit.ly/2J3j6nM).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 `returnFaceAttributes` 这个请求体参数，它让你可以指定面部的多个属性，Face API 将根据这些属性分析给定的人脸。欲了解更多关于这些属性的信息，请查看文档：[http://bit.ly/2J3j6nM](http://bit.ly/2J3j6nM)。
- en: 'Let''s embed the response we got from the API in the image in a presentable
    manner. We will show the probable gender and probable age of the detected faces
    in the image. We will do this using the `matplotlib`, `PIL`, and `io` libraries
    and we''ll be using a Jupyter notebook to work on the following segments of code
    in this section. We will start by importing the libraries:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一种可展示的方式将从 API 获得的响应嵌入图像中。我们将显示检测到的人脸的可能性别和可能年龄。我们将使用 `matplotlib`、`PIL`
    和 `io` 库，并将在 Jupyter notebook 中进行以下代码段的工作。我们将首先导入这些库：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To display overlays on the image with the response received from the API, we
    use the following method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要在图像上显示 API 返回的叠加信息，我们使用以下方法：
- en: 'Store the API response:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储 API 响应：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create an image from the response content:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从响应内容创建图像：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create an empty figure:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空白的图形：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Show the image created with the response:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示使用响应创建的图像：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Iterate over the faces specified in the earlier section and extract the necessary
    information:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历前面部分指定的人脸并提取必要的信息：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should have an image like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该有一张这样的图片：
- en: '![](img/6602861e-76f7-4378-afcc-db74b1161cf8.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6602861e-76f7-4378-afcc-db74b1161cf8.png)'
- en: You are encouraged to play around with the different parameters that the API
    provides. We will now study a **Natural Language Understanding** (**NLU**) API.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励你尝试 API 提供的不同参数。接下来，我们将研究 **自然语言理解**（**NLU**）API。
- en: Extracting text information using the Text Analytics API and Python
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用文本分析 API 和 Python 提取文本信息
- en: Whether knowingly or unknowingly, we must all have encountered some of the astonishing
    use cases of natural language processing. Be it autocorrect, the next word suggestion,
    or language translation, these use cases are too important to neglect. In this
    section, we are going to use the Text Analytics API ([https://azure.microsoft.com/en-us/services/cognitive-services/text-analytics/](https://azure.microsoft.com/en-us/services/cognitive-services/text-analytics/))
    to extract meaningful information from a given piece of text.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是有意还是无意，我们都一定遇到过一些令人惊叹的自然语言处理应用案例。无论是自动更正、下一个单词的建议，还是语言翻译，这些应用案例都非常重要，不容忽视。在本节中，我们将使用文本分析
    API（[https://azure.microsoft.com/en-us/services/cognitive-services/text-analytics/](https://azure.microsoft.com/en-us/services/cognitive-services/text-analytics/)）从给定的文本中提取有意义的信息。
- en: 'You can try the API for free using the previously mentioned link and see its
    power. In the following example, I entered the phrase `I want to attend NeurIPS
    someday and present a paper there` and the Text Analytics API extracted four meaningful
    pieces of information from it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过之前提到的链接免费试用 API，看看它的强大功能。在以下示例中，我输入了短语 `I want to attend NeurIPS someday
    and present a paper there`，Text Analytics API 从中提取了四个有意义的信息：
- en: '![](img/e67aa8f4-cd9d-4d88-922a-4c94bd55d0b0.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e67aa8f4-cd9d-4d88-922a-4c94bd55d0b0.png)'
- en: Observe how gracefully the API was able to extract all the key pieces of information
    from the phrase.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 观察 API 如何优雅地提取出短语中的所有关键信息。
- en: We will now see how to do this programmatically using Python. The setup steps
    are going to be exactly the same as the preceding ones. Just go to [https://portal.azure.com/#create/Microsoft.CognitiveServicesTextAnalytics](https://portal.azure.com/#create/Microsoft.CognitiveServicesTextAnalytics)
    and follow the steps there. Once you have the respective API keys to consume the
    Text Analytics API, move on to the following subsection. Do not forget to note
    down the respective endpoint, as well. The endpoint should start with [https://eastus.api.cognitive.microsoft.com/text/analytics/v2.0](https://eastus.api.cognitive.microsoft.com/text/analytics/v2.0).
    This URL will not work alone; it needs to have a suffix pointing to the right
    method to be invoked.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看到如何使用 Python 进行编程操作。设置步骤与之前完全相同。只需访问 [https://portal.azure.com/#create/Microsoft.CognitiveServicesTextAnalytics](https://portal.azure.com/#create/Microsoft.CognitiveServicesTextAnalytics)，并按照那里的步骤操作。一旦获得了用于访问
    Text Analytics API 的 API 密钥，就可以进入下一个子部分。别忘了记下相应的端点。该端点应以 [https://eastus.api.cognitive.microsoft.com/text/analytics/v2.0](https://eastus.api.cognitive.microsoft.com/text/analytics/v2.0)
    开头。这个 URL 单独使用时无法正常工作，它需要一个后缀指向需要调用的方法。
- en: Using the Text Analytics API from Python code
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Python 代码中使用 Text Analytics API
- en: 'This section will show you how to use the Text Analytics API in your own Python
    code. The following are the steps for using it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将展示如何在您自己的 Python 代码中使用 Text Analytics API。以下是使用它的步骤：
- en: 'We will begin this section by importing the libraries we need:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过导入所需的库来开始本节内容：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will then load the API key for the Text Analytics API from the environment
    variable:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将从环境变量中加载 Text Analytics API 的 API 密钥：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s now specify a few URLs to store the API endpoints:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们指定一些 URL 来存储 API 端点：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s now define the `headers` parameter by supplying the API key:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们通过提供 API 密钥来定义 `headers` 参数：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s also define the body parameter. In my case, I will keep the same phrase
    I showed earlier in the GUI-based demo:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将定义 body 参数。在我的示例中，我将保持与之前在基于 GUI 的演示中展示的相同的短语：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can now make calls to the respective APIs of Text Analytics. Let''s start
    by detecting the language:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以调用 Text Analytics 的相应 API。首先让我们开始检测语言：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We get the response accordingly, as shown:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据此得到相应的响应，如下所示：
- en: '![](img/16b55881-1edf-4f83-9814-5cd3c785a8da.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16b55881-1edf-4f83-9814-5cd3c785a8da.png)'
- en: 'Note that I have highlighted the language. Now, let''s move on to the sentiment
    analysis part:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我已经突出显示了语言部分。现在，让我们继续进行情感分析：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The sentiment displayed is as shown:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的情感如下所示：
- en: '![](img/37049f4f-493f-4703-a41c-52f3a69aeb73.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37049f4f-493f-4703-a41c-52f3a69aeb73.png)'
- en: 'Note that the phrase used here contains neither a positive sentiment nor a
    negative sentiment, hence the score. We will now extract the key phrases from
    the given text:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里使用的短语既不包含正面情感也不包含负面情感，因此得出了这样的评分。现在我们将从给定的文本中提取关键短语：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The key phrases are as shown:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 关键短语如下所示：
- en: '![](img/6e957a31-82f6-4670-8ad7-eaded45163f1.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e957a31-82f6-4670-8ad7-eaded45163f1.png)'
- en: Notice how the endpoints have changed with respect to the tasks. You can explore
    more about the different parameters of the endpoints we used in the preceding
    example at [http://bit.ly/2JjLRfi](http://bit.ly/2JjLRfi).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到端点根据任务的不同发生了变化。您可以在 [http://bit.ly/2JjLRfi](http://bit.ly/2JjLRfi) 了解更多关于我们在前面示例中使用的端点参数。
- en: An introduction to CNTK
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CNTK 简介
- en: CNTK is an offering by Microsoft. The framework is a part of the ONNX format
    initiative, which allows easy conversion of models between different neural toolkit
    frameworks. The framework is responsible for a huge portion of the deep learning
    production workload on Microsoft software and platforms. Launched in 2016, the
    framework has been a contender to popular frameworks such as TensorFlow, PyTorch,
    and so on. The framework is completely open source and can be found at [https://github.com/microsoft/CNTK](http://github.com/microsoft/CNTK).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: CNTK 是 Microsoft 提供的一个框架。该框架是 ONNX 格式计划的一部分，允许在不同的神经网络工具包框架之间轻松转换模型。该框架负责微软软件和平台上深度学习生产工作负载的很大一部分。该框架于
    2016 年推出，并且是 TensorFlow、PyTorch 等流行框架的竞争者。该框架完全开源，您可以在 [https://github.com/microsoft/CNTK](http://github.com/microsoft/CNTK)
    上找到它。
- en: CNTK powers enterprise services, such as Cortana and Bing, and advertisements,
    such as Skype Translate, Microsoft Cognitive Services, and several others. It
    has been proven to work faster than competitors such as TensorFlow and PyTorch
    on several applications.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: CNTK 驱动了企业服务，如 Cortana 和 Bing，以及广告服务，如 Skype 翻译、Microsoft Cognitive Services
    等。已证明它在多个应用中比 TensorFlow 和 PyTorch 等竞争者运行得更快。
- en: In this section, we will study some fundamentals of CNTK and then proceed to
    create a Django application to carry over the CNTK-based model to the web.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习一些 CNTK 的基础知识，然后继续创建一个 Django 应用程序，将基于 CNTK 的模型迁移到网页上。
- en: Getting started with CNTK
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 CNTK
- en: CNTK is one of the easiest frameworks to get started with, thanks to its simple
    syntax and ability to work without the concept of sessions, as is the case in
    TensorFlow, which is confusing to most learners. Let's see how we can set up CNTK
    on our local machines or on Google Colaboratory.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 CNTK 的语法简单，并且能够无需像 TensorFlow 中的会话（session）概念就能工作，因此它是最容易入门的框架之一。大多数学习者对
    TensorFlow 中的会话概念感到困惑。让我们看看如何在本地机器或 Google Colaboratory 上设置 CNTK。
- en: Installation on a local machine
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地机器上安装
- en: The CNTK framework supports both 64-bit and 32-bit architecture machines. However,
    it only supports Python versions up to version 3.6, at the time of writing this
    book. You can verify the latest supported versions at [https://pypi.org/project/cntk/](https://pypi.org/project/cntk/).
    Furthermore, CNTK is not available as a built binary on macOS, currently.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: CNTK 框架支持 64 位和 32 位架构的机器。然而，目前它仅支持 Python 版本最高到 3.6。您可以在 [https://pypi.org/project/cntk/](https://pypi.org/project/cntk/)
    验证最新的支持版本。此外，CNTK 目前不提供 macOS 的已编译二进制版本。
- en: 'To install the framework, you can either use the `pip` package manager or install
    it using compiled binaries on Anaconda. Assuming a Python environment is set up,
    you can use the following commands to install CNTK on both Windows and Linux:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装该框架，您可以使用 `pip` 包管理器，或者通过 Anaconda 使用已编译的二进制文件进行安装。假设已设置 Python 环境，您可以使用以下命令在
    Windows 和 Linux 上安装 CNTK：
- en: 'Without Anaconda, use the following for the CPU version:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有 Anaconda，请使用以下命令安装 CPU 版本：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Use the following for the GPU-enabled version:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下命令安装 GPU 支持版本：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'On Anaconda-enabled machines, the CNTK framework can be installed using `pip`
    with the following command:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在启用 Anaconda 的机器上，可以使用 `pip` 和以下命令安装 CNTK 框架：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`<url>` can be obtained from the CNTK website at [http://tiny.cc/cntk](http://tiny.cc/cntk).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`<url>` 可从 CNTK 网站 [http://tiny.cc/cntk](http://tiny.cc/cntk) 获取。'
- en: 'The command will resemble the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将类似于以下内容：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can now begin with its installation on Google Colaboratory.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始在 Google Colaboratory 上进行安装了。
- en: Installation on Google Colaboratory
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Google Colaboratory 上安装
- en: 'The CNTK framework is not available on the Google Colaboratory platform by
    default and so must be installed along with other requisite modules. To install
    CNTK on a Google Colaboratory runtime, use the following command at the top of
    the script:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: CNTK 框架在 Google Colaboratory 平台上默认不可用，因此必须与其他必要的模块一起安装。要在 Google Colaboratory
    运行时安装 CNTK，请在脚本顶部使用以下命令：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that the preceding command is a single-line command. If you break it up
    into multiple lines, you should make sure you add the required changes to the
    command.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的命令是单行命令。如果将其拆分成多行，您应该确保对命令进行必要的修改。
- en: Once the preceding step runs successfully, you will not need to use this command
    again in that runtime. So, the command can be commented out in future runs of
    the program.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦前面的步骤成功执行，在该运行时中您将不再需要使用此命令。因此，未来运行程序时，可以注释掉该命令。
- en: 'It is conventional to import CNTK to Python projects by the `C` alias. We use
    the following code to import the library to the project:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，通过 `C` 别名将 CNTK 导入 Python 项目。我们使用以下代码将库导入到项目中：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can check the version of CNTK installed using the following line:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令检查安装的 CNTK 版本：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With CNTK imported to the project, we're ready to proceed with the precursory
    requirements of creating a deep learning model.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 将 CNTK 导入项目后，我们可以继续进行创建深度学习模型的前期要求。
- en: Creating a CNTK neural network model
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 CNTK 神经网络模型
- en: 'In this section, we''ll complete the steps required before creating a predictive
    neural network and then we will create the neural network itself:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将完成创建预测神经网络之前所需的步骤，然后我们将创建神经网络本身：
- en: 'We begin by importing the necessary modules to the project:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将必要的模块导入到项目中：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `fetch_openml()` method of the `sklearn` modules helps us directly download
    the dataset used in this example to the project—the MNIST Handwritten Digits dataset.
    The `OneHotEncoder` method is used for the one-hot encoding of the labels.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`sklearn` 模块的 `fetch_openml()` 方法帮助我们直接下载本示例中使用的数据集——MNIST 手写数字数据集。`OneHotEncoder`
    方法用于标签的独热编码。'
- en: 'Next, the few constants that are required during the program execution are
    set up:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，设置程序执行期间需要的几个常量：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We will perform the training on 60,000 samples with an initial learning rate
    of `0.1`. This rate can be dynamically updated during the training.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在60,000个样本上进行训练，初始学习率为`0.1`。在训练过程中，这个学习率可以动态更新。
- en: 'We then need to create a method for generating random mini-batches for the
    training:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来需要创建一个生成随机小批量数据的训练方法：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding method on each call generates batches equal to the size set in
    the previous step—for example, 64 samples in each batch. These samples are taken
    randomly from the dataset.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用前述方法时，会生成与先前步骤中设置的大小相等的批量数据——例如，每个批次包含64个样本。这些样本会从数据集中随机抽取。
- en: 'The dataset now needs to be fetched; to do so, we use the following line of
    code:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在需要获取数据集；为此，我们使用以下代码行：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once the data has been fetched, it can be separated into training and test
    datasets, as shown:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 数据获取完成后，可以将其分为训练集和测试集，如下所示：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Labels in the datasets need to be one-hot encoded before being fed into the
    training model. To do so, we use the following code:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据集中的标签在输入训练模型之前需要进行one-hot编码。为此，我们使用以下代码：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can now create a generator object for the training batches generator, as
    shown:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以为训练批量生成器创建一个生成器对象，如下所示：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s quickly carry out the preceding steps for the `test` dataset, too:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们快速地对`test`数据集执行上述步骤：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let''s create a CNTK neural network model. We first begin by defining
    some constants:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个CNTK神经网络模型。我们首先定义一些常量：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We define the dimensions of the input data as `784`. Recall our example from
    [Chapter 3](a33bccdc-8664-4ae7-be82-b066e5b64850.xhtml), *Creating Your First
    Deep Learning Web Application*, where we used the MNIST dataset. The images in
    the MNIST dataset are stored in the format of single-dimension arrays containing
    28 x 28 values in the range of `0` to `255`. The images belong to 10 different
    classes, corresponding to each digit in the Arabic numeral system. We keep a provision
    of 3 hidden layers, each with 400 neurons in them.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将输入数据的维度定义为`784`。回想一下我们在[第3章](a33bccdc-8664-4ae7-be82-b066e5b64850.xhtml)《创建你的第一个深度学习Web应用》中使用的MNIST数据集。MNIST数据集中的图像以单维数组格式存储，包含28
    x 28个值，范围从`0`到`255`。这些图像属于10个不同的类别，对应阿拉伯数字系统中的每个数字。我们保留了3个隐藏层，每个隐藏层有400个神经元。
- en: We then create two CNTK `input` variables to use while creating the model. This
    is one of the most important concepts of CNTK.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建两个CNTK的`input`变量，用于在创建模型时使用。这是CNTK中最重要的概念之一。
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'An `input` variable in CNTK is essentially a placeholder that we use to fill
    samples during model training and evaluation or testing. The shape of the input
    from the dataset must exactly match the dimensions declared in the `input` variables
    declaration in this step. It is important to mention here that a lot of people
    confuse the dimensions of input with the number of features a dataset has. A dataset
    that has *N* number of features and *M* number of samples has an (*M*, *N*) shape
    and so the dimensions of this dataset is simply `2`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在CNTK中，`input`变量本质上是一个占位符，我们在模型训练、评估或测试时用来填充样本。从数据集中获取的输入形状必须与此步骤中声明的`input`变量的维度完全匹配。这里需要特别提到的是，很多人将输入的维度与数据集的特征数混淆。一个具有*N*个特征和*M*个样本的数据集，其形状为(*M*,
    *N*)，因此该数据集的维度仅为`2`：
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We create the `create_model()` method, which takes the input of the features
    as the argument.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了`create_model()`方法，它以特征作为输入参数。
- en: First, the defaults are set for the model to use the uniform distribution of
    the initialization of weights and other values. The default activation function
    is set to `ReLU`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为模型设置默认值，使用均匀分布来初始化权重和其他值。默认的激活函数设置为`ReLU`。
- en: 'The first layer contains the features themselves and the final layer contains
    a vector with a dimension equal to the number of classes. All the layers in between
    contain a completely connected network of 3 hidden layers with 400 neurons each
    and ReLU activation:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第一层包含特征本身，最终层包含一个维度等于类别数的向量。中间的所有层包含一个完全连接的网络，拥有3个隐藏层，每个隐藏层有400个神经元，并使用ReLU激活：
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Finally, we create the model using the previous function. Dividing by `255`
    provides normalization to the dataset, rendering the values in the image arrays
    between `0` and `1`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用前面的函数创建模型。通过`255`进行除法运算，实现数据集的归一化，将图像数组中的值限制在`0`和`1`之间。
- en: Training the CNTK model
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练CNTK模型
- en: 'With the model created, we can now move on to training the model and making
    it learn to predict. To do so, we need to use the CNTK model object and fit the
    samples in the dataset to it. We can, at the same time, log `loss` and other evaluation
    metrics. We need to carry out the following steps to train our model:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 模型创建完成后，我们现在可以进行模型训练并让其学习预测。为此，我们需要使用 CNTK 模型对象，并将数据集中的样本拟合到它。与此同时，我们还需要记录 `loss`
    和其他评估指标。我们需要执行以下步骤来训练模型：
- en: 'Create placeholders for `loss` and the classification error:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `loss` 和分类误差的占位符：
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we can set up a `trainer` object for the CNTK framework, which is used
    to perform the actual training:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以为 CNTK 框架设置一个 `trainer` 对象，用于执行实际的训练：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s perform the training now:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们进行训练：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We set the number of epochs for training as `10` to allow quick training and
    evaluations. You can set it to a higher value for more accuracy in training; however,
    this may lead to no better training or overfitting, in some cases. At every 1,000th
    iteration, we display the loss and evaluation error obtained up to then. The general
    trend for these should be toward decline.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将训练的 epoch 数设置为 `10`，以便进行快速训练和评估。你可以将其设置为更高的值以提高训练的准确性；然而，这可能在某些情况下导致没有更好的训练效果或过拟合。在每次达到
    1,000 次迭代时，我们都会显示到目前为止的损失和评估误差。这些值的整体趋势应该是下降的。
- en: Testing and saving the CNTK model
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试并保存 CNTK 模型
- en: 'Before continuing with turning this project into a web application using the
    Django framework, let''s quickly test the accuracy obtained in this training of
    the model. We will carry out the following to make predictions from the model:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续使用 Django 框架将此项目转换为 Web 应用程序之前，让我们快速测试一下模型在此训练中的准确性。我们将执行以下操作，从模型中进行预测：
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This creates a NumPy array of probabilities for each label in the dataset.
    This has to be converted into indices and compared to the labels of the test data.
    We do this as shown:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为数据集中的每个标签创建一个 NumPy 概率数组。必须将其转换为索引并与测试数据的标签进行比较。我们按如下方式进行操作：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We find around 98% accuracy in the prediction. This is a very good value and
    we will move on to saving the model and using it through Django. To save the CNTK
    model, we do the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现预测准确率约为 98%。这是一个非常好的值，我们将继续保存模型并通过 Django 使用它。保存 CNTK 模型的方法如下：
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: With the model saved successfully, you will have to download the `model` file
    to your local system if you've used Colaboratory to build the model. Next, we
    can move on to deploying the model on a Django-based server.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 成功保存模型后，如果你使用了 Colaboratory 来构建模型，你需要将 `model` 文件下载到本地系统。接下来，我们可以继续将模型部署到基于
    Django 的服务器上。
- en: A brief introduction to Django web development
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Django Web 开发简介
- en: Django is one of the most popular frameworks for web development using Python.
    The framework is lightweight, robust, and actively maintained by the community,
    which quickly patches security holes and adds new features. In this book, we've
    covered the Flask framework, which is essentially a bare-bones framework for Python
    web development. However, Django comes with a lot of built-in features that implement
    state-of-the-art methods and practices.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Django 是使用 Python 进行 Web 开发的最流行框架之一。该框架轻量、健壮，并且得到社区的积极维护，社区会迅速修补安全漏洞并添加新特性。本书中我们介绍了
    Flask 框架，它本质上是一个用于 Python Web 开发的简单框架。然而，Django 提供了许多内建功能，实施了最先进的方法和实践。
- en: 'A Django project is initially structured in the following manner:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Django 项目的初始结构如下所示：
- en: '![](img/220c2b95-9ed4-4521-9ee1-9937f6e28fec.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/220c2b95-9ed4-4521-9ee1-9937f6e28fec.png)'
- en: These files are auto-generated when you create a new Django project using the
    `django-admin` tool. The top-level directory, `mysite`, represents the name of
    the Django project. Each Django project contains apps. Apps are similar to the
    concept of modules in software development. They are usually independent pieces
    of the complete project and are put together by the `mysite` master app within
    the project directory. Each project can have several apps inside it.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件是在使用 `django-admin` 工具创建新 Django 项目时自动生成的。顶级目录 `mysite` 表示 Django 项目的名称。每个
    Django 项目包含多个应用程序。应用程序类似于软件开发中的模块概念。它们通常是完整项目中的独立部分，并通过项目目录中的 `mysite` 主应用程序组合在一起。每个项目内部可以有多个应用程序。
- en: Let's learn how to get started with Django and create a new project!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何开始使用 Django 并创建一个新项目！
- en: Getting started with Django
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门 Django
- en: 'The foremost step before using Django is to install it. Fortunately, the framework
    is easily installable as a module from the Python PIP repository. It is also available
    on the Conda repository. To install Django, open a new terminal window and use
    the following command:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Django之前的首要步骤是安装它。幸运的是，这个框架可以轻松地作为一个模块从Python PIP仓库安装。它也可以在Conda仓库中找到。要安装Django，打开一个新的终端窗口并使用以下命令：
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Alternatively, if you prefer PIP, use the following command:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你更喜欢使用PIP，可以使用以下命令：
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This will install the Django module to your Python environment.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把Django模块安装到你的Python环境中。
- en: 'To check whether it has been successfully installed, use the following command
    in the terminal:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查是否已成功安装，请在终端中使用以下命令：
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This should produce an output of a version number—for example, `- 2.0.8`. If
    not, check your installation of Django.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会输出一个版本号，例如`- 2.0.8`。如果没有，请检查你的Django安装。
- en: Creating a new Django project
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的Django项目
- en: 'Django provides a handy utility named the `django-admin` tool, which can be
    used to generate the boilerplate code required for a Django project. To create
    a new project named, say, `cntkdemo`, use the following code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了一个名为`django-admin`的便捷工具，可以用来生成Django项目所需的模板代码。要创建一个名为`cntkdemo`的新项目，请使用以下代码：
- en: '[PRE48]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This will create all the boilerplate folders and files. However, we must create
    at least one app within the project. Change your active working directory to the
    `cntkdemo` folder using the terminal. Use the following command to create an app
    inside this project:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建所有的模板文件和文件夹。但是，我们必须在项目中创建至少一个应用。通过终端将当前工作目录更改为`cntkdemo`文件夹。使用以下命令在此项目中创建一个应用：
- en: '[PRE49]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'So, we have created a folder named `api` with the following folders inside
    it; all the files are auto-generated with placeholder code and documentation:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们创建了一个名为`api`的文件夹，其中包含以下文件夹；所有文件都带有自动生成的占位符代码和文档：
- en: '![](img/3d297b46-da99-422e-aab5-4dfb5cbc90e6.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d297b46-da99-422e-aab5-4dfb5cbc90e6.png)'
- en: We can now proceed with the coding of the initial UI.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续进行初步UI的编码了。
- en: Setting up the home page template
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置首页模板
- en: Let's now create a web page that loads when the `/` route is accessed. Remember
    the `api` app that we created in the project? Let's make the index page a part
    of this app for the sake of simplicity. While it is possible to create this route
    in the `urls.py` file of the `mysite` app, we will provide the `api` app with
    its own route handling file.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个当访问`/`路由时加载的网页。还记得我们在项目中创建的`api`应用吗？为了简化起见，我们将把首页作为这个应用的一部分。虽然可以在`mysite`应用的`urls.py`文件中创建这个路由，但我们会为`api`应用提供一个独立的路由处理文件。
- en: 'Let''s begin with the steps for setting up the home page template:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设置首页模板的步骤开始：
- en: 'Create a file, `urls.py`, inside the `api` folder. The complete path of this
    file relative to the project directory would be `mysite/api/urls.py`. Inside this
    file, let''s add the `/` route, using the following code:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`api`文件夹中创建一个文件`urls.py`。这个文件相对于项目目录的完整路径是`mysite/api/urls.py`。在这个文件中，让我们使用以下代码添加`/`路由：
- en: '[PRE50]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Save this file. The preceding code essentially adds a new path, `/`, to the
    `api` app (note, not to the project!). It imports all the views available in the
    `views.py` file of the `api` app. Note that `indexView` still does not exist.
    We will create this view after the next step.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存此文件。前面的代码本质上为`api`应用添加了一个新路径`/`（注意，这不是项目的路径！）。它导入了`api`应用中的所有视图（`views.py`文件）。请注意，`indexView`仍然不存在。我们将在下一步后创建这个视图。
- en: 'The `api` app is not linked to the main project app. We need to add the following
    lines to the `mysite/mysite/urls.py` file to enable the route handling by the
    `api` app''s route handler:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`api`应用没有链接到主项目应用。我们需要在`mysite/mysite/urls.py`文件中添加以下几行，以便启用`api`应用的路由处理：'
- en: '[PRE51]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The first line imports a utility for including app-specific routing settings
    to the project app. We use this to include the `urls.py` file inside the `api`
    app using the `api.urls` string. This automatically converts the strings to lines
    of code that try to find and include the correct file.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行导入了一个工具，用于将特定于应用的路由设置包含到项目应用中。我们通过使用`api.urls`字符串，将`urls.py`文件包含到`api`应用中。这会自动将字符串转换为代码行，试图找到并包含正确的文件。
- en: 'In the `views.py` file inside the `api` app directory, add the following lines:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`api`应用目录中的`views.py`文件中，添加以下几行代码：
- en: '[PRE52]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `HttpResponse` method allows the `view` method to return an HTML response.
    The `loader` class provides us with methods to load HTML templates from the disk.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpResponse`方法允许`view`方法返回一个 HTML 响应。`loader`类提供了从磁盘加载 HTML 模板的方法。'
- en: 'Let''s now create the `indexView` method:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建`indexView`方法：
- en: '[PRE53]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `indexView` method loads the `api/index.html` template file and renders
    it with the variables provided in the `context` dictionary, along with the `request`
    parameters available to the template. Currently, we pass a blank context because
    we do not have any values to send to the template. But again, the `api/index.html`
    file defined previously does not exist.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexView`方法加载`api/index.html`模板文件，并使用`context`字典中提供的变量以及可用于模板的`request`参数进行渲染。目前，我们传递一个空的上下文，因为我们没有任何值要发送到模板。但如前所述，之前定义的`api/index.html`文件并不存在。'
- en: 'Let''s create the folder for holding templates and link it to the project settings.
    To do so, go to the root directory of the project and create a folder named `templates`.
    We need the project to be able to recognize this folder as the directory for the
    templates. To do so, we need to modify the `TEMPLATES` settings in the `mysite/mysite/settings.py`
    file:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个用于存放模板的文件夹，并将其链接到项目设置中。为此，进入项目的根目录并创建一个名为`templates`的文件夹。我们需要让项目能够识别该文件夹作为模板的目录。为此，我们需要修改`mysite/mysite/settings.py`文件中的`TEMPLATES`设置：
- en: '[PRE54]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Upon adding the preceding line, the project will look for the templates inside
    the `mysite/templates/` folder.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 添加前述行后，项目将会在`mysite/templates/`文件夹中查找模板。
- en: Create the `index.html` template file.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`index.html`模板文件。
- en: 'Notice that our template file route in step 4 exists within an `api` directory.
    Create a folder named `api` inside the `templates` directory. Inside this, create
    the `index.html` file with the following code:'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，我们在第 4 步中提到的模板文件路径存在于`api`目录中。在`templates`目录下创建一个名为`api`的文件夹。在这个文件夹中，创建`index.html`文件，并添加以下代码：
- en: '[PRE55]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We've included some required scripts at the end of the preceding code block,
    including a script to fetch the CSRF token from the backend.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的代码块的末尾包含了一些必需的脚本，其中包括从后端获取 CSRF token 的脚本。
- en: 'Now, let''s add a `canvas` element to `div` with the `jumbotron` class in the
    previous code block, where we will draw the digits. We''ll also add a slider for
    selecting the width of the drawing pen, as shown:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在前面的代码块中，向具有`jumbotron`类的`div`元素中添加一个`canvas`元素，我们将在该元素上绘制数字。我们还将添加一个滑动条，用于选择绘图笔的宽度，如下所示：
- en: '[PRE56]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `template` file also includes two static files—`style.css` and `script.js`.
    We will be creating these files in the upcoming section. We have not yet created
    the script for sending the data to the server and rendering the response received.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`template`文件还包含了两个静态文件——`style.css` 和 `script.js`。我们将在接下来的部分中创建这些文件。目前我们还没有创建用于将数据发送到服务器并呈现收到的响应的脚本。'
- en: 'Now, we will begin adding the JavaScript code required to communicate with
    the backend APIs. First, we create a method to check whether we need a CSRF token
    to communicate with the backend. This is only a utility function and is not related
    to calling the backend APIs, which may, at times, be designed to accept requests
    without CSRF tokens. We create this function as shown:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将开始添加与后端 API 通信所需的 JavaScript 代码。首先，我们创建一个方法来检查是否需要 CSRF token 来与后端通信。这只是一个工具函数，与调用后端
    API 无关，因为有时后端 API 会被设计为接受没有 CSRF token 的请求。我们创建这个函数，如下所示：
- en: '[PRE57]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then, we create a `click` handler for the `Predict` button. This handler function
    first sets up the proper headers required to make the call to the backend APIs
    and then converts the drawing present on the canvas into a data URL string:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们为`Predict`按钮创建一个`click`处理程序。这个处理程序函数首先设置所需的正确头信息以便与后端 API 通信，然后将画布上的绘图转换为数据
    URL 字符串：
- en: '[PRE58]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, we add the code to the `click` handler function of the `Predict` button
    to make the Ajax call to the backend with the data from the canvas, as shown:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将代码添加到`Predict`按钮的`click`处理函数中，以便通过 Ajax 调用后端，将画布中的数据发送出去，如下所示：
- en: '[PRE59]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Before we can create the static files, we need to create a folder for them
    and link it to the project. This is similar to how we created the `templates`
    folder. First, create a folder, `static`, in the project directory with a `mysite/static/`
    path. Then, modify the `STATIC` configuration in the `mysite/mysite/settings.py`
    file, as shown:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们创建静态文件之前，我们需要为它们创建一个文件夹并将其链接到项目中。这与我们创建`templates`文件夹的方式类似。首先，在项目目录中创建一个名为`static`的文件夹，路径为`mysite/static/`。然后，修改`mysite/mysite/settings.py`文件中的`STATIC`配置，如下所示：
- en: '[PRE60]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We can now create and load static files into the project templates using the
    `{% load static %}` directive at the top of the template files, as we did in the
    `index.html` file.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以像在`index.html`文件中一样，使用模板文件顶部的`{% load static %}`指令将静态文件加载到项目模板中。
- en: Create `style.css` and `script.js`—since these files are not explicitly relevant
    to the context of this book, you can download them directly from [http://tiny.cc/cntk-demo](http://tiny.cc/cntk-demo).
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`style.css`和`script.js`文件—由于这些文件与本书的上下文没有直接关系，你可以直接从[http://tiny.cc/cntk-demo](http://tiny.cc/cntk-demo)下载它们。
- en: Please note here that without the `script.js` file, the project will not run.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果没有`script.js`文件，项目将无法运行。
- en: We have created the setup for the prediction of the images drawn on a canvas
    present in the `index.html` template file. However, the `/predict` route is yet
    to be created. Let's see how CNTK models can be loaded and used in Django in the
    next section.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为在`index.html`模板文件中绘制的图像预测创建了设置。然而，`/predict`路由尚未创建。接下来的部分我们将看到如何在Django中加载并使用CNTK模型。
- en: Making predictions using CNTK from the Django project
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Django项目中的CNTK进行预测
- en: In this section, we'll first set the required route, the view, and the imports
    for the CNTK model to work with Django. We will then load the CNTK model from
    the saved file and make predictions using it.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们将首先设置所需的路由、视图和CNTK模型的导入，以便与Django一起使用。然后，我们将从保存的文件中加载CNTK模型，并使用它进行预测。
- en: Setting up the predict route and view
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置预测路由和视图
- en: 'Recall how we created the `/` route and its corresponding view in the `api`
    app:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们如何在`api`应用中创建`/`路由及其对应的视图：
- en: 'First, add the following line to `mysite/api/urls.py`:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下行添加到`mysite/api/urls.py`中：
- en: '[PRE61]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This creates the `/predict` route. However, the view, `predictView`, is not
    yet created.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了`/predict`路由。然而，视图`predictView`尚未创建。
- en: 'Add the following lines to the `views.py` file in the `api` app:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下行添加到`api`应用的`views.py`文件中：
- en: '[PRE62]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Notice the placeholders in the preceding lines. We'll add more here in the next
    steps.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意前面代码行中的占位符。我们将在接下来的步骤中在这里添加更多内容。
- en: Making the necessary module imports
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入必要的模块
- en: 'Now, let''s load all the modules required to make predictions with the CNTK
    model, as in the following steps:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们加载所有必要的模块，以便按照以下步骤使用CNTK模型进行预测：
- en: 'Add the following lines of imports to the `views.py` file of the `api` app:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下导入语句添加到`api`应用的`views.py`文件中：
- en: '[PRE63]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We''ll need the preceding imports to load the model from the disk:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要前面的导入语句来从磁盘加载模型：
- en: '[PRE64]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The preceding lines import the CNTK module to the Django project. The `load_model`
    method will help us load the saved CNTK model file.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码行将CNTK模块导入Django项目。`load_model`方法将帮助我们加载保存的CNTK模型文件。
- en: 'The following modules are used to manipulate the images that the predictions
    will be made on:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 以下模块用于处理进行预测时使用的图像：
- en: '[PRE65]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The following modules provide utility for handling Base64-encoded strings,
    which is the format that the `index.html` page sends the canvas data in the request:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下模块提供了处理Base64编码字符串的实用功能，这是`index.html`页面在请求中发送画布数据的格式：
- en: '[PRE66]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The other libraries will be explained when they are used in the upcoming sections.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 其他库将在它们在接下来的部分中使用时进行解释。
- en: Loading and predicting using the CNTK model
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CNTK模型进行加载和预测
- en: 'We will now further edit the `predictView` view by following these steps:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过以下步骤进一步编辑`predictView`视图：
- en: 'First, read the Base64-encoded image string data to a variable using the following
    code:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下代码将Base64编码的图像字符串数据读取到变量中：
- en: '[PRE67]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The Base64-decoded string does not have proper padding and contains spaces that
    need to be converted into `+`. The last two lines in the previous code block perform
    the same manipulations on the string.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Base64解码后的字符串没有适当的填充，并且包含需要转换为`+`的空格。前面代码块中的最后两行对字符串进行了相同的操作。
- en: 'Next, we will convert this Base64-encoded string into a PNG image and save
    it to disk with the following lines:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将把这个Base64编码的字符串转换为PNG图像，并使用以下代码保存到磁盘：
- en: '[PRE68]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The first line creates a 32-character-long random string for the filename. The
    next line calls the `convertImage` method, which stored the `base64` string as
    the filename provided.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个32字符长的随机字符串作为文件名。下一行调用了`convertImage`方法，将`base64`字符串存储为提供的文件名。
- en: 'However, the `convertImage` method has not yet been defined. Outside of the
    `predictView` method, add the definition for the function, as shown:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，`convertImage`方法尚未定义。在`predictView`方法外部，按如下方式添加该函数的定义：
- en: '[PRE69]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The method strips out the extra metadata from the string. It then decodes the
    string and saves it as a PNG file.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法会从字符串中去除多余的元数据，然后解码该字符串并将其保存为 PNG 文件。
- en: 'Let''s return back to the `predictView` method. We will first load the saved
    `image` file:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到 `predictView` 方法。我们将首先加载保存的 `image` 文件：
- en: '[PRE70]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We will also convert the image into a black and white channel only. This reduces
    the number of channels in the image from 3 to 1.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将把图像转换为仅黑白通道。这将图像中的通道数从 3 降至 1。
- en: 'Recall that all images in the MNIST dataset have dimensions of 28 x 28\. We
    must resize our current image to the same dimensions. We do so with the following
    line:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回想一下，MNIST 数据集中的所有图像的尺寸都是 28 x 28。我们必须将当前图像调整为相同的尺寸。我们通过以下代码来实现：
- en: '[PRE71]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, we convert the image into a NumPy array with the following lines:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用以下代码将图像转换为 NumPy 数组：
- en: '[PRE72]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`np.expanded_dims` is a simple utility in NumPy used to add an extra dimension
    to the array for proper compatibility with most machine learning libraries.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.expanded_dims` 是 NumPy 中的一个简单工具，用于为数组添加额外的维度，以便与大多数机器学习库兼容。'
- en: Load the CNTK model. First, create a folder named `data` in the root directory
    of the project and copy the saved `model` file there in `mysite/data/cntk.model`.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载 CNTK 模型。首先，在项目的根目录创建一个名为 `data` 的文件夹，并将保存的 `model` 文件复制到 `mysite/data/cntk.model`
    中。
- en: 'We now load the CNTK model in the `predictView` method, as shown:'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在在 `predictView` 方法中加载 CNTK 模型，如下所示：
- en: '[PRE73]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Finally, we can predict the label of the image, as shown:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以预测图像的标签，如下所示：
- en: '[PRE74]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The `eval` method, in its first argument, expects the NumPy array of the image
    and returns a list of probabilities of each output class. The `np.argmax` method
    is used to find the index of the class with the highest probability.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval` 方法的第一个参数期望传入图像的 NumPy 数组，并返回每个输出类别的概率列表。`np.argmax` 方法用于找到具有最高概率的类别的索引。'
- en: 'To return the output, modify the `return` part of the `predictView` method,
    as shown:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要返回输出，请修改 `predictView` 方法中的 `return` 部分，如下所示：
- en: '[PRE75]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The predicted label for the image is sent as a digit contained in the `data`
    variable of the JSON response, which is displayed on the page.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的预测标签作为包含在 `data` 变量中的数字发送，响应的 JSON 数据会在页面上显示。
- en: Testing the web app
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试网页应用程序
- en: Finally, we can test the CNTK + Django app we have developed. To do so, open
    the terminal and direct it to the root directory of the project.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以测试我们开发的 CNTK + Django 应用程序。为此，打开终端并将其切换到项目的根目录。
- en: 'Use the following command to start the Django server:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令启动 Django 服务器：
- en: '[PRE76]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The server starts at [http://localhost:8000](http://localhost:8000) if the
    port is free. Open the page in a web browser. Draw your digit on the canvas provided
    and click on the Predict button. You will be able to see the result from the model
    at the bottom of the page, as shown:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果端口空闲，服务器会在 [http://localhost:8000](http://localhost:8000) 启动。打开网页浏览器，点击提供的画布上绘制数字并点击预测按钮。你可以在页面底部看到模型的预测结果，如下所示：
- en: '![](img/b717132a-d629-41e8-b622-7424137ccf76.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b717132a-d629-41e8-b622-7424137ccf76.png)'
- en: Notice that the model returns the correct output in the preceding screenshot,
    which is 2\. Hence, we conclude the deployment of CNTK models using Django.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，模型在前面的屏幕截图中返回了正确的输出，即 2。因此，我们得出结论，CNTK 模型通过 Django 部署已完成。
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the offerings from Microsoft AI and the Azure cloud
    for performing deep learning on websites. We saw how the Face API can be used
    to predict the gender and age of people in images, as well as how the Text Analytics
    API can be used to predict the language of a given text and the key phrases in
    the provided text or the sentiment of any sentence. Finally, we created a deep
    learning model using CNTK on the MNIST dataset. We saw how the model can be saved
    and then deployed via a Django-based web application in the form of an API. This
    deployment of the saved model via Django can be easily adapted for other deep
    learning frameworks, such as TensorFlow or PyTorch.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章，我们介绍了 Microsoft AI 和 Azure 云服务在网站上执行深度学习的相关功能。我们看到了如何使用面部 API 来预测图像中人物的性别和年龄，以及如何使用文本分析
    API 来预测给定文本的语言、关键短语或任何句子的情感。最后，我们使用 CNTK 在 MNIST 数据集上创建了一个深度学习模型。我们展示了如何保存模型，并通过基于
    Django 的 Web 应用程序将其作为 API 部署。通过 Django 部署保存的模型可以轻松适配其他深度学习框架，如 TensorFlow 或 PyTorch。
- en: In the next chapter, we will discuss a generalized framework for building production-grade
    deep learning applications using Python.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将讨论一个通用框架，用于使用 Python 构建生产级深度学习应用程序。
