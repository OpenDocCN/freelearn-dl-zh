- en: Information Extraction and Text Classification
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信息提取与文本分类
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下几种方法：
- en: Using inbuilt NERs
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置的命名实体识别（NER）
- en: Creating, inversing, and using dictionaries
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、反向构建和使用字典
- en: Creating your own NEs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你自己的命名实体（NE）
- en: Choosing the feature set
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择特征集
- en: Segmenting sentences using classification
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分类方法分割句子
- en: Classifying documents
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档分类
- en: Writing a POS tagger with context
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写带有上下文的词性标注器
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Information retrieval is a vast area and has many challenges. In previous chapters,
    we understood regular expressions, grammars, **Parts-of-Speech** (**POS**) tagging,
    and chunking. The natural step after this process is to identify the Interested
    Entities in a given piece of text. To be clear, when we are processing large amounts
    of data, we are really interested in finding out whether any famous personalities,
    places, products, and so on are mentioned. These things are called **named entitie****s**
    in NLP. We will understand more about these with examples in the following recipes.
    Also, we will see how we can leverage the clues that are present in the input
    text to categorize large amounts of text, and many more examples will be explained.
    Stay tuned!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 信息检索是一个庞大的领域，并且面临许多挑战。在前面的章节中，我们了解了正则表达式、语法、**词性**（**POS**）标注和短语块分析。紧接着的自然步骤是识别给定文本中的感兴趣实体。明确来说，当我们处理大量数据时，我们最关心的是查找是否提到任何著名的人物、地点、产品等。这些被称为**命名实体**，在自然语言处理（NLP）中占有重要地位。我们将在接下来的例子中进一步了解这些概念。此外，我们还将探讨如何利用输入文本中的线索来对大量文本进行分类，并解释更多示例，敬请期待！
- en: Understanding named entities
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解命名实体
- en: So far, we have seen how to parse the text, identify parts of speech, and extract
    chunks from the text. The next thing that we need to look into is finding **proper
    nouns**, which are also called named entities.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何解析文本、识别词性并提取短语块。接下来我们需要关注的是如何识别**专有名词**，也就是命名实体。
- en: Named entities help us understand more about what is being referred to in a
    given text so that we can further classify the data. Since named entities comprise
    more than one word, it is sometimes difficult to find these from the text.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 命名实体帮助我们理解文本中所指的内容，以便进一步对数据进行分类。由于命名实体通常包含多个词，因此有时很难从文本中识别出这些实体。
- en: 'Let''s take up the following examples to understand what named entities are:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来理解什么是命名实体：
- en: '| **Sentence** | **Named entities** |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **句子** | **命名实体** |'
- en: '| Hampi is on the South Bank of Tungabhadra river | Hampi, Tungabhadra River
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 汉皮位于通加布赫德拉河的南岸 | 汉皮，通加布赫德拉河 |'
- en: '| Paris is famous for Fashion | Paris |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 巴黎因时尚而闻名 | 巴黎 |'
- en: '| Burj Khalifa is one of the Skyscrapers in Dubai | Burj Khalifa , Dubai |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 哈利法塔是迪拜的摩天大楼之一 | 哈利法塔，迪拜 |'
- en: '| Jeff Weiner is the CEO of LinkedIn | Jeff Weiner, LinkedIn |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 杰夫·维纳是领英的首席执行官 | 杰夫·维纳，领英 |'
- en: 'Let''s take a closer look at these and try to understand:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这些内容，并尝试理解：
- en: Even though *South Bank* refers to a direction, it does not qualify as a named
    entity because we cannot uniquely identify the object from that.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使*南岸*是指一个方向，但它不能算作命名实体，因为我们无法仅凭此唯一确定对象。
- en: Even though *Fashion* is a noun, we cannot completely qualify it as named entity.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使*时尚*是一个名词，我们也不能完全将其视为命名实体。
- en: '*Skyscraper* is a noun, but there can be many possibilities for Skyscrapers.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*摩天大楼*是一个名词，但摩天大楼有许多可能的含义。'
- en: '*CEO* is a role here; there are many possible persons who can hold this title.
    So, this also cannot be a named entity.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*首席执行官*是一个职务，可能由许多人担任。因此，这也不能算作命名实体。'
- en: 'To further understand, let''s just look at these NEs from a categories perspective:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，让我们从类别的角度来看这些命名实体：
- en: '| **Category** | **Examples of named entities** |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| **类别** | **命名实体示例** |'
- en: '| `TIMEZONE` | Asia/Kolkata, IST, UTC |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `TIMEZONE` | 亚洲/加尔各答，印度标准时间，协调世界时 |'
- en: '| `LOCATION` | Mumbai, Kolkata, Egypt |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `LOCATION` | 孟买，加尔各答，埃及 |'
- en: '| `RIVERS` | Ganga, Yamuna, Nile |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `RIVERS` | 恒河，雅穆纳河，尼罗河 |'
- en: '| `COSMETICS` | Maybelline Deep Coral Lipstick, LOreal Excellence Creme Hair
    Color |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `COSMETICS` | 美宝莲深珊瑚口红，欧莱雅卓越发色染发膏 |'
- en: '| `CURRENCY` | 100 bitcoins, 1.25 INR |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `CURRENCY` | 100比特币，1.25印度卢比 |'
- en: '| `DATE` | 17-Aug-2017, 19-Feb-2016 |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `DATE` | 2017年8月17日，2016年2月19日 |'
- en: '| `TIME` | 10:10 AM |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `TIME` | 上午10:10 |'
- en: '| `PERSON` | Satya Nadella, Jeff Weiner, Bill Gates |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `PERSON` | 萨蒂亚·纳德拉，杰夫·维纳，比尔·盖茨 |'
- en: Using inbuilt NERs
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内置的命名实体识别（NER）
- en: 'Python NLTK has built-in support for **Named Entity Recognition** (**NER**).
    In order to use this feature, first we need to recollect what we have done so
    far:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Python NLTK内置了对**命名实体识别**（**NER**）的支持。为了使用此功能，首先我们需要回顾一下到目前为止我们做了什么：
- en: Break a large document into sentences.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将大文档拆分成句子。
- en: Break the sentence into words (or tokens).
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将句子拆分成单词（或标记）。
- en: Identify the parts of speech in the sentence.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定句子中的词性。
- en: Extract chunks of consecutive words (non-overlapping) from the sentence.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从句子中提取连续的单词块（不重叠）。
- en: Assign IOB tags to these words based on the chunking patterns.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据分块模式为这些单词分配IOB标签。
- en: The next logical step would be to further extend the algorithms to find out
    the named entities as a sixth step. So, we will basically be using data that is
    preprocessed until step 5 as part of this example.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个逻辑步骤是进一步扩展算法，以便作为第六步找出命名实体。因此，我们将在这个示例中使用直到第五步的预处理数据。
- en: We will be using `treebank` data to understand the NER process. Remember, the
    data is already pre-tagged in IOB format. Without the training process, none of
    the algorithms that we are seeing here are going to work. (So, there is no magic!)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`treebank`数据来理解命名实体识别（NER）过程。记住，数据已经预先按照IOB格式标记。没有训练过程，任何我们在这里看到的算法都无法工作。（所以，这里没有什么魔法！）
- en: In order to understand the importance of the training process, let's take up
    an example. Say, there is a need for the Archaeological department to figure out
    which of the famous places in India are being tweeted and mentioned in social
    networking websites in the Kannada Language.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解训练过程的重要性，假设我们有这样一个例子：考古部门需要找出哪些印度著名地点在社交网络网站上被提到并被推文，且这些信息使用的是卡纳达语。
- en: Assuming that they have already got the data somewhere and it is in terabytes 
    or even in petabytes, how do they find out all these names? This is where we need
    to take a sample dataset from the original input and do the  training process
    to further use this trained data set to extract the named entities in Kannada.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 假设他们已经在某处获得了数据，并且数据的规模是TB甚至PB级，如何找出所有这些名字呢？这时我们需要从原始输入中获取一个示例数据集，并进行训练过程，进一步使用这个训练过的数据集来提取卡纳达语中的命名实体。
- en: Getting ready
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have Python installed, along with the `nltk` library.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经安装了Python，并且安装了`nltk`库。
- en: How to do it...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何进行...
- en: Open Atom editor (or you favorite programming editor).
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Atom编辑器（或你喜欢的编程编辑器）。
- en: Create a new file called `NER.py`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`NER.py`的新文件。
- en: 'Type the following source code:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下源代码：
- en: '![](img/0abb176a-d572-4e81-aa7d-8c8dd2d9fa5d.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0abb176a-d572-4e81-aa7d-8c8dd2d9fa5d.png)'
- en: Save the file.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Run the program using the Python interpreter.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Python解释器运行程序。
- en: 'You will see the following output:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '![](img/6018fa18-cf7f-452b-8d0a-e3612aa361cd.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6018fa18-cf7f-452b-8d0a-e3612aa361cd.png)'
- en: How it works...
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The code looks so simple, right? However, all the algorithms are implemented
    in the `nltk` library. So, let''s dig into how this simple program gives what
    we are looking for. This instruction imports the `nltk` library into the program:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来很简单，对吧？然而，所有的算法都在`nltk`库中实现。那么，让我们深入了解这个简单的程序是如何提供我们所需结果的。这个指令将`nltk`库导入到程序中：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'These three instructions define a new function called `sampleNE()`. We are
    importing the first tagged sentence from the `treebank` corpus and then passing
    it to the `nltk.ne_chunk()` function to extract the named entities. The output
    from this program includes all the named entities with their proper category:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个指令定义了一个名为`sampleNE()`的新函数。我们从`treebank`语料库中导入第一个已标记的句子，然后将其传递给`nltk.ne_chunk()`函数以提取命名实体。此程序的输出包括所有命名实体及其正确的类别：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These three instructions define a new function called `sampleNE2()`. We are
    importing the first tagged sentence from the `treebank` corpus and then passing
    it to the `nltk.ne_chunk()` function to extract the named entities. The output
    from this program includes all the named entities without any proper category.
    This is helpful if the training dataset is not accurate enough to tag the named
    entities with the proper category such as person, organization, location, and
    so on:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个指令定义了一个名为`sampleNE2()`的新函数。我们从`treebank`语料库中导入第一个已标记的句子，然后将其传递给`nltk.ne_chunk()`函数以提取命名实体。此程序的输出包括所有命名实体，但没有正确的类别。如果训练数据集不够准确，无法为命名实体分配正确的类别（如人名、组织、地点等），这非常有帮助：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These three instructions will call the two sample functions that we have defined
    before and print the results on the screen.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这三条指令将调用之前定义的两个示例函数，并在屏幕上打印结果。
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating, inversing, and using dictionaries
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建、反转和使用字典
- en: Python, as a general-purpose programming language, has support for many built-in
    data structures. Of those, one of the most powerful data structures are dictionaries.
    Before we jump into what dictionaries are, let's try to understand what these
    data structures are used for. Data structures, in short, help programmers to store,
    retrieve, and traverse through data that is stored in these structures. Each data
    structure has its own sets of behaviors and performance benefits that programmers
    should understand before selecting them for a given task at hand.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种通用编程语言，Python支持许多内置的数据结构。其中，最强大的数据结构之一就是字典。在我们深入了解字典之前，先来看看这些数据结构的用途。简而言之，数据结构帮助程序员存储、检索和遍历存储在这些结构中的数据。每种数据结构都有自己的一组行为和性能优势，程序员应在为特定任务选择数据结构之前理解这些特点。
- en: 'Let''s get back to dictionaries. The basic use case of dictionaries can be
    explained with a simple example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到字典。字典的基本用例可以通过一个简单的例子来解释：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can use POS identification on the preceding sentence. But if someone were
    to ask what POS `flights` is in this sentence, we should have an efficient way
    to look for this word. This is where dictionaries come into play. They can be
    thought of as **one-to-one** mappings between data of interest. Again this one-to-one
    is at the highest level of abstraction of the data unit that we are talking about.
    If you are an expert programmer in Python, you know how to do **many-to-many**
    also. In this simple example, we need something like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对前面的句子使用词性识别。但是，如果有人问在这个句子中`flights`的词性是什么，我们应该有一个高效的方式来查找这个词。这就是字典的作用。字典可以看作是**一对一**的数据映射关系。同样，这个一对一映射是在我们讨论的数据单元的最高抽象层次。如果你是Python专家，你也知道如何实现**多对多**映射。在这个简单的例子中，我们需要像这样的东西：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now let's answer a different question. Is it possible to print the list of all
    the words in the sentence that are nouns? Yes, for this too, we will learn how
    to use a Python dictionary.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回答一个不同的问题。是否可以打印句子中所有名词的单词列表？是的，对于这个问题，我们也将学习如何使用Python字典。
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have Python installed, along with the `nltk` library, in order to
    run this example.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要安装Python和`nltk`库，才能运行这个示例。
- en: How to do it...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做……
- en: Open Atom editor (or your favorite programming editor).
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Atom编辑器（或你喜欢的编程编辑器）。
- en: Create a new file called `Dictionary.py`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Dictionary.py`的新文件。
- en: 'Type the following source code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下源代码：
- en: '![](img/48346cdf-5656-4b23-bacc-c095c5296b82.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48346cdf-5656-4b23-bacc-c095c5296b82.png)'
- en: Save the file.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Run the program using the Python interpreter.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Python解释器运行程序。
- en: 'You will see the following output:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '![](img/8633a272-e323-4220-ae47-b90ccb3e4f2a.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8633a272-e323-4220-ae47-b90ccb3e4f2a.png)'
- en: How it works...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'Now, let''s understand more about dictionaries by going through the instructions
    we have written so far. We are importing the `nltk` library into the program:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过回顾我们迄今为止写的指令，更深入地理解字典。我们正在将`nltk`库导入程序：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We are defining a new class called `LearningDictionary`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在定义一个名为`LearningDictionary`的新类：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We are creating a constructor for `LearningDictionary` that takes `sentence` text
    as an argument:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在为`LearningDictionary`创建一个构造函数，该函数接受`sentence`文本作为参数：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This instruction breaks the sentence into words using the `nltk.word_tokenize()` function
    and saves the result in the class member `words`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令使用`nltk.word_tokenize()`函数将句子分解为单词，并将结果保存在类成员`words`中：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This instruction identifies the POS for `words` and saves the result in the
    class member tagged:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令识别`words`的词性并将结果保存在标记的类成员中：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This instruction invokes the `buildDictionary()` function that is defined in
    the class:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令调用了在类中定义的`buildDictionary()`函数：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This instruction invokes the `buildReverseDictionary()` function that is defined
    in the class:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令调用了在类中定义的`buildReverseDictionary()`函数：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This instruction defines a new class member function called `buildDictionary()`*:*
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令定义了一个新的类成员函数，名为`buildDictionary()`*：*
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This instruction initializes a empty `dictionary` variable in the class. These
    two instructions iterate over all the tagged `pos` list elements and then assign
    each `word` to the `dictionary` as key and the POS as value of the key:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令在类中初始化一个空的`dictionary`变量。这两条指令遍历所有的标记过的`pos`列表元素，然后将每个`word`作为键，词性（POS）作为值，赋值给`dictionary`：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This instruction defines another class member function called `buildReverseDictionary()`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令定义了另一个类成员函数，名为`buildReverseDictionary()`：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This instruction initializes an empty `dictionary` to a class member, `rdictionary`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令将一个空的`dictionary`初始化为类成员`rdictionary`：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This instruction iterates over all the `dictionary` keys and puts the key of `dictionary` into
    a local variable called `key`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令遍历所有的`dictionary`键，并将`dictionary`中的键放入一个名为`key`的局部变量中：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This instruction extracts the `value` (POS) of the given `key` (word) and stores
    it in a local variable called `value`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令提取给定`key`（词）对应的`value`（词性），并将其存储在名为`value`的局部变量中：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'These four instructions check whether a given `key` (word) is already in the
    reverse dictionary variable (`rdictionary`). If it is, then we append the currently
    found word to the list. If the word is not found, then we create a new list of
    size one with the current word as the member:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这四条指令检查给定的`key`（词）是否已存在于反向字典变量（`rdictionary`）中。如果存在，那么我们将当前找到的词添加到列表中。如果没有找到该词，我们会创建一个大小为1的新列表，将当前词作为成员：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This function returns `Yes` or `No` depending on whether a given word is found
    in the `dictionary`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回`Yes`或`No`，取决于给定的词是否在`dictionary`中找到：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This function returns the POS for the given word by looking into `dictionary`.
    If the value is not found, a special value of `None` is returned:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数通过查阅`dictionary`返回给定词的词性。如果未找到该词性，则返回一个特殊值`None`。
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These two instructions define a function that returns all the words in the
    sentence with a given POS by looking into `rdictionary` (reverse dictionary).
    If the POS is not found, a special value of `None` is returned:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这两条指令定义了一个函数，该函数通过查阅`rdictionary`（反向字典）返回给定词性（POS）下的所有词。如果未找到该词性，则返回一个特殊值`None`：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We define a variable called `sentence`, which stores the string that we are
    interested in parsing:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`sentence`的变量，用来存储我们感兴趣的待解析字符串：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Initialize the `LearningDictionary()` class with `sentence` as a parameter.
    Once the class object is created, it is assigned to the learning variable:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sentence`作为参数初始化`LearningDictionary()`类。一旦类对象创建，它会被赋值给学习变量：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We create a list of `words` that we are interested in knowing the POS of. If
    you see carefully, we have included a few words that are not in the sentence:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`words`列表，用来查看我们感兴趣的词的词性。如果你仔细观察，我们已经包括了一些不在句子中的词：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We create a list of `pos` for which we are interested in seeing the words that
    belong to these POS classifications:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`pos`列表，用来查看属于这些词性分类的词：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'These instructions iterate over all the `words`, take one `word` at a time,
    check whether the `word` is in the dictionary by calling the `isWordPresent()` function
    of the object, and then print its status. If the `word` is present in the dictionary,
    then we print the POS for the word:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令遍历所有的`words`，一次处理一个`word`，通过调用对象的`isWordPresent()`函数检查该`word`是否在字典中，然后打印其状态。如果该`word`在字典中存在，那么我们会打印该词的词性（POS）：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In these instructions, we iterate over all the `pos`. We take one word at a
    time and then print the words that are in this POS using the `getWordsForPOS()` function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些指令中，我们遍历所有的`pos`。我们一次处理一个词，然后使用`getWordsForPOS()`函数打印出属于该词性（POS）的所有词：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Choosing the feature set
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择特征集
- en: Features are one of the most powerful components of `nltk` library. They represent
    clues within the language for easy tagging of the data that we are dealing with.
    In Python terminology, features are expressed as dictionaries, where the keys
    are the labels and the values are the clues extracted from input data.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 特征是`nltk`库中最强大的组件之一。它们代表了语言中的线索，有助于我们轻松标记正在处理的数据。在Python术语中，特征表现为字典，字典中的键是标签，值是从输入数据中提取的线索。
- en: Let's say we are dealing with some transport department data and we are interested
    in finding out whether a given vehicle number belongs to the Government of Karnataka
    or not. Right now we have no clue about the data we are dealing with. So how can
    we tag the given numbers accurately?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在处理一些交通部门的数据，并且我们想知道某个给定的车辆号是否属于卡纳塔克邦政府。现在我们对正在处理的数据毫无头绪。那么我们该如何准确地标记这些号码呢？
- en: 'Let''s try to learn how the vehicle numbers give some clues about what they
    mean:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试学习车辆编号如何提供一些线索来帮助理解它们的含义：
- en: '| **Vehicle number** | **Clues about the pattern** |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| **车辆编号** | **关于模式的线索** |'
- en: '| **KA-[0-9]{2} [0-9]{2}** | Normal vechicle number |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| **KA-[0-9]{2} [0-9]{2}** | 普通车辆编号 |'
- en: '| **KA-[0-9]{2}-F** | KSRTC, BMTC vehicles |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| **KA-[0-9]{2}-F** | KSRTC, BMTC车辆 |'
- en: '| **KA-[0-9]{2}-G** | Government vehicles |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **KA-[0-9]{2}-G** | 政府车辆 |'
- en: Using these clues (features), let's try to come up with a simple program that
    can tell us the classification of a given input number.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些线索（特征），让我们尝试编写一个简单的程序，告诉我们给定输入编号的分类。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You should have Python installed, along with the `nltk` library.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经安装了Python，并且安装了`nltk`库。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open Atom editor (or your favorite programming editor).
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Atom编辑器（或你喜欢的编程编辑器）。
- en: Create a new file called `Features.py`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Features.py`的新文件。
- en: 'Type the following source code:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下源代码：
- en: '![](img/045dfc44-f4cf-45eb-a7d2-69fc0792a43c.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/045dfc44-f4cf-45eb-a7d2-69fc0792a43c.png)'
- en: Save the file.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Run the program using the Python interpreter.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Python解释器运行程序。
- en: 'You will see the following output:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '![](img/cb969140-d0cc-4018-9883-f9a2aaf9c635.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb969140-d0cc-4018-9883-f9a2aaf9c635.png)'
- en: How it works...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Now, let''s see what our program does. These two instructions import the `nltk` and `random` libraries
    into the current program:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看程序的表现。这两条指令将`nltk`和`random`库导入当前程序：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We are defining a list of Python tuples, where the first element in the tuple
    is the vehicle number and the second element is the predefined label that is applied
    to the number.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在定义一个Python元组的列表，其中元组的第一个元素是车辆编号，第二个元素是预定义的标签，应用于该编号。
- en: 'These instructions define that all the numbers are classified into three labels—`rtc`, `gov`,
    and `oth`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令定义了所有编号被分类为三种标签——`rtc`，`gov`，和`oth`：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This instruction shuffles all of the data in the `sampledata` list to make
    sure that the algorithm is not biased by the order of elements in the input sequence:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令将`sampledata`列表中的所有数据打乱，以确保算法不会因为输入序列中元素的顺序而产生偏差：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'These are the test vehicle numbers for which we are interested in finding the
    category:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们感兴趣的测试车辆编号，目的是查找其类别：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This instruction defines a new function called `learnSimpleFeatures`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令定义了一个名为`learnSimpleFeatures`的新函数：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'These instructions define a new function, `vehicleNumberFeature()`, which takes
    the vehicle number and returns the seventh character in the that number. The return
    type is `dictionary`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令定义了一个新函数`vehicleNumberFeature()`，它接受车辆编号并返回该编号中的第七个字符。返回类型为`dictionary`：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This instruction creates a list of feature tuples, where the first member in
    the tuple is feature dictionary and the second member in tuple is the label of
    the data. After this instruction, the input vehicle numbers in `sampledata` are
    no longer visible. This is one of the key things to remember:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令创建了一个特征元组的列表，其中元组的第一个成员是特征字典，第二个成员是数据的标签。执行此指令后，`sampledata`中的输入车辆编号将不再可见。这是需要记住的关键点之一：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This instruction trains `NaiveBayesClassifier` with the feature dictionary
    and the labels that are applied to `featuresets`. The result is available in the
    classifier object, which we will use further:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令使用特征字典和应用于`featuresets`的标签来训练`NaiveBayesClassifier`。结果保存在分类器对象中，我们将进一步使用它：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'These instructions iterate over the test data and then print the label of the
    data from the classification done using `vehicleNumberFeature`. Observe the output
    carefully. You will see that the feature extraction function that we have written
    does not perform well in labeling the numbers correctly:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令遍历测试数据，然后打印通过`vehicleNumberFeature`分类得到的标签。仔细观察输出，你会看到我们编写的特征提取函数在正确标记数字方面表现不佳：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This instruction defines a new function called `learnFeatures`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令定义了一个名为`learnFeatures`的新函数：
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'These instructions define a new function called `vehicleNumberFeature` that
    returns the feature dictionary with two keys. One key, `vehicle_class`, returns
    the character at position `6` in the string, and `vehicle_prev` has the character
    at position `5`. These kinds of clues are very important to make sure we eliminate
    bad labeling of data:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令定义了一个新函数`vehicleNumberFeature`，它返回包含两个键的特征字典。一个键`vehicle_class`返回字符串中位置为`6`的字符，`vehicle_prev`返回位置为`5`的字符。这些线索对于确保我们消除数据错误标签非常重要：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This instruction creates a list of `featuresets` and input labels by iterating
    over of all the input trained data. As before, the original input vehicle numbers
    are no longer present here:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令通过迭代所有输入的训练数据，创建一个`featuresets`列表和输入标签。和之前一样，原始输入的车辆编号在这里已经不再出现：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This instruction creates a `NaiveBayesClassifier.train()` function on `featuresets` and
    returns the object for future use:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令在`featuresets`上创建了一个`NaiveBayesClassifier.train()`函数，并返回该对象供将来使用：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'These instructions loop through the `testdata` and print the classification
    of the input vehicle number based on the trained dataset. Here, if you observe
    carefully, the false-positive is not there:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令遍历`testdata`并根据训练好的数据集打印输入的车辆号码的分类情况。在这里，如果仔细观察，你会发现假阳性已经没有了：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Invoke both the functions and print the results on the screen.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这两个函数并打印结果到屏幕上。
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If we observe carefully, we realize that the first function's results have one
    false positive, where it cannot identify the `gov` vehicle. This is where the
    second function performs well, as it has more features that improve accuracy.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细观察，会发现第一个函数的结果有一个假阳性，无法识别`gov`车辆。这就是第二个函数表现良好的地方，因为它有更多特征来提高准确性。
- en: Segmenting sentences using classification
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用分类进行句子分割
- en: A natural language that supports question marks (?), full stops (.), and exclamations
    (!) poses a challenge to us in identifying whether a statement has ended or it
    still continues after the punctuation characters.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 支持问号（?）、句号（.）和感叹号（!）的自然语言在识别一个陈述是否已经结束，或在标点符号后是否还会继续时给我们带来了挑战。
- en: This is one of the classic problems to solve.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个经典的待解决问题。
- en: In order to solve this problem, let's find out the features (or clues) that
    we can leverage to come up with a classifier and then use the classifier to extract
    sentences in large text.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，让我们找出可以利用的特征（或线索），以便创建一个分类器，然后使用该分类器在大文本中提取句子。
- en: If we encounter a punctuation mark like `.` then it ends a sentence If we encounter
    a punctuation mark like `.` and the next word's first letter is a capital letter,
    then it ends a sentence.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遇到像`.`这样的标点符号，则表示句子结束。如果我们遇到像`.`这样的标点符号，并且下一个单词的首字母是大写字母，那么它也表示句子结束。
- en: Let's try to write a simple classifier using these two features to mark sentences.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用这两个特征编写一个简单的分类器来标记句子。
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You should have Python installed along with `nltk` library.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经安装了 Python，并且安装了`nltk`库。
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open Atom editor (or your favorite programming editor).
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Atom 编辑器（或你喜欢的编程编辑器）。
- en: Create a new File called `Segmentation.py`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Segmentation.py`的新文件。
- en: 'Type the following source code:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下源代码：
- en: '![](img/f6c31463-5cf4-4682-8e0f-18aa270db410.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6c31463-5cf4-4682-8e0f-18aa270db410.png)'
- en: Save the file.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Run the program using the Python interpreter.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Python 解释器运行程序。
- en: 'You will see the following output:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '![](img/c170092c-1016-4885-bd4f-f386b152bf19.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c170092c-1016-4885-bd4f-f386b152bf19.png)'
- en: How it works...
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This instruction imports the `nltk` library into the program:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令将`nltk`库导入到程序中：
- en: '[PRE44]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This function defines a modified feature extractor that returns a tuple containing
    the dictionary of the features and `True` or `False` to tell whether this feature
    indicates a sentence boundary or not:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数定义了一个修改过的特征提取器，它返回一个包含特征字典的元组，并通过`True`或`False`来告诉我们该特征是否表示句子边界：
- en: '[PRE45]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This function takes a `sentence` as input and returns a list of `featuresets` that
    is a list of tuples, with the feature dictionary and `True` or `False`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数以`sentence`作为输入，并返回一个`featuresets`列表，`featuresets`是一个包含特征字典和`True`或`False`的元组列表：
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This function takes the input text, breaks it into words, and then traverses
    through each word in the list. Once it encounters a full stop, it calls `classifier`
    to conclude whether it has encountered a sentence end. If the `classifier` returns
    `True`, then the sentence is found and we move on to the next word in the input.
    The process is repeated for all words in the input:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接收输入文本，将其拆分为单词，然后遍历列表中的每个单词。一旦遇到句号，它会调用`classifier`来判断是否遇到了句子结束。如果`classifier`返回`True`，则表示句子结束，我们继续处理输入中的下一个单词。这个过程会对输入中的所有单词重复：
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'These instructions define a few variables for training and evaluation of our
    classifier:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令定义了一些变量，用于训练和评估我们的分类器：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Extract all the features from the `traindata` variable and store it in `traindataset`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 提取所有来自`traindata`变量的特征并存储到`traindataset`中：
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Train the `NaiveBayesClassifier` on `traindataset` to get  `classifier` as
    object:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `traindataset` 上训练 `NaiveBayesClassifier`，以获得作为对象的 `classifier`：
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Invoke the function on `testdata` and print all the found sentences as output
    on the screen:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `testdata` 调用该函数，并将所有找到的句子作为输出显示在屏幕上：
- en: '[PRE51]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Classifying documents
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分类文档
- en: In this recipe, we will learn how to write a classifier that can be used to
    classify documents. In our case, we will classify **rich site summary** (**RSS**) feeds.
    The list of categories is known ahead of time, which is important for the classification
    task.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习如何编写一个分类器，用于对文档进行分类。在我们的案例中，我们将分类**丰富站点摘要**（**RSS**）订阅源。类别列表是预先确定的，这对分类任务非常重要。
- en: In this information age, there are vast amounts of text available. Its humanly
    impossible for us to properly categorize all information for further consumption.
    This is where categorization algorithms help us to properly categorize the newer
    sets of documents that are being produced based on the training given on sample
    data.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个信息时代，有大量的文本数据。对于我们人类来说，正确分类所有信息以供进一步使用几乎是不可能的。这时，分类算法帮助我们根据在示例数据上的训练，正确地分类新产生的文档。
- en: Getting ready
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备开始
- en: You should have Python installed, along with the `nltk` and `feedparser` libraries.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要安装 Python，并且安装 `nltk` 和 `feedparser` 库。
- en: How to do it...
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open Atom editor (or your favorite programming editor).
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Atom 编辑器（或你喜欢的编程编辑器）。
- en: Create a new file called `DocumentClassify.py`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `DocumentClassify.py` 的新文件。
- en: 'Type the following source code:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下源代码：
- en: '![](img/8df78831-67d3-4c71-bb2e-22278a21cc58.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8df78831-67d3-4c71-bb2e-22278a21cc58.png)'
- en: Save the file.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Run the program using the Python interpreter.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Python 解释器运行程序。
- en: 'You will see this output:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到如下输出：
- en: '![](img/1cb21192-bb6d-41d2-be3d-7391822aac2e.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1cb21192-bb6d-41d2-be3d-7391822aac2e.png)'
- en: How it works...
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s see how this document classification works. Importing three libraries
    into the program:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看文档分类是如何工作的。将三个库导入程序：
- en: '[PRE52]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This instruction defines a new dictionary with two RSS feeds pointing to Yahoo!
    sports. They are pre-categorized. The reason we have selected these RSS feeds
    is that data is readily available and categorized for our example:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令定义了一个新字典，包含指向 Yahoo! 体育的两个 RSS 订阅源。它们是预分类的。我们选择这些 RSS 订阅源的原因是数据易于获取，并且已经为我们的示例进行分类：
- en: '[PRE53]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Initializing the empty dictionary variable `feedmap` to keep the list of RSS
    feeds in memory until the program terminates:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化空字典变量 `feedmap`，以便在程序终止之前将 RSS 订阅源列表保存在内存中：
- en: '[PRE54]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Getting the list of `stopwords` in English and storing it in the `stopwords` variable:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 获取英文的 `stopwords` 列表并将其存储在 `stopwords` 变量中：
- en: '[PRE55]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This function, `featureExtractor()`, takes list of words and then adds them
    to the dictionary, where each key is the word and the value is `True`. The dictionary
    is returned, which are the features for the given input `words`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数 `featureExtractor()` 接收一个单词列表，然后将它们添加到字典中，其中每个键是单词，值为 `True`。返回的字典即为给定输入
    `words` 的特征：
- en: '[PRE56]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Empty list to store all the correctly labeled `sentences`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个空列表，用于存储所有正确标记的 `sentences`：
- en: '[PRE57]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Iterate over all the `keys()` of the dictionary called `urls` and store the
    key in a variable called `category`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历字典 `urls` 的所有 `keys()`，并将每个键存储在名为 `category` 的变量中：
- en: '[PRE58]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Download one feed and store the result in the `feedmap[category]` variable
    using the `parse()` function from the `feedparser` module:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 下载一个订阅源，并使用 `feedparser` 模块的 `parse()` 函数将结果存储在 `feedmap[category]` 变量中：
- en: '[PRE59]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Display the `url` that is being downloaded on the screen, using Python''s built-in
    the `print` function:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 内置的 `print` 函数在屏幕上显示正在下载的 `url`：
- en: '[PRE60]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Iterate over all the RSS entries and store the current entry in a variable
    called `entry` variable:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历所有的 RSS 条目，并将当前条目存储在一个名为 `entry` 的变量中：
- en: '[PRE61]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Take the `summary` (news text) of the RSS feed item into the `data` variable:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 将 RSS 订阅源项目的 `summary`（新闻文本）存入 `data` 变量：
- en: '[PRE62]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We brea `summary` into `words` based on space so that we can pass these to
    `nltk` for feature extraction:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据空格将 `summary` 分解成 `words`，以便可以将它们传递给 `nltk` 进行特征提取：
- en: '[PRE63]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Store all `words` in the current RSS feed item, along with `category` it belongs
    to, in a tuple:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 将当前 RSS 订阅源条目中的所有 `words` 以及它所属的 `category` 存储在一个元组中：
- en: '[PRE64]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Extract all the features of  `sentences` and store them in the variable `featuresets`.
    Later, do `shuffle()` on this array so that all the elements in the list are randomized
    for the algorithm:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 提取所有 `sentences` 的特征并将其存储在 `featuresets` 变量中。然后，对该数组进行 `shuffle()` 操作，使列表中的所有元素都被随机化，以便算法使用：
- en: '[PRE65]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Create two datasets, one `trainset` and the other `testset`, for our analysis:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个数据集，一个是`trainset`，另一个是`testset`，用于我们的分析：
- en: '[PRE66]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Create a `classifier` using the `trainset` data by using the `NaiveBayesClassifier` module''s `train()` function:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`NaiveBayesClassifier`模块的`train()`函数，通过`trainset`数据创建一个`classifier`：
- en: '[PRE67]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Print the accuracy of  `classifier` using `testset`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`testset`打印`classifier`的准确度：
- en: '[PRE68]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Print the informative features about this data using the built-in function
    of `classifier`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`classifier`的内置函数打印此数据的有用特征：
- en: '[PRE69]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Take four sample entries from the `nfl` RSS item. Try to tag the document based
    on `title` (remember, we have classified them based on `summary`):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 从`nfl` RSS项中取四个样本条目。尝试根据`title`标记文档（记住，我们是基于`summary`进行分类的）：
- en: '[PRE70]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Writing a POS tagger with context
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个带有上下文的词性标注器
- en: In previous recipes, we have written regular-expression-based POS taggers that
    leverage word suffixes such as *ed*, *ing*, and so on to check whether the word
    is of a given POS or not. In the English language, the same word can play a dual
    role depending on the context in which it is used.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们已经编写了基于正则表达式的词性标注器，利用单词后缀如*ed*、*ing*等检查单词是否属于给定的词性。在英语中，同一个单词可以根据上下文扮演不同的角色。
- en: 'For example, the word `address` can be both noun and verb depending on the
    context:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，单词`address`可以根据上下文既是名词，也可以是动词：
- en: '[PRE71]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Let's try to write a program that leverages the feature extraction concept to
    find the POS of the words in the sentence.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试编写一个利用特征提取概念来找出句子中单词词性的程序。
- en: Getting ready
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have Python installed, along with `nltk`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经安装了Python，并且安装了`nltk`。
- en: How to do it...
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: Open Atom editor (or your favorite programming editor).
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Atom编辑器（或你喜欢的编程编辑器）。
- en: Create a new file called `ContextTagger.py`.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ContextTagger.py`的新文件。
- en: 'Type the following source code:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下源代码：
- en: '![](img/1e05adaf-bf14-4c51-b890-3dfd893cf92f.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e05adaf-bf14-4c51-b890-3dfd893cf92f.png)'
- en: Save the file.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Run the program using the Python interpreter.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Python解释器运行程序。
- en: 'You will see the following output:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '![](img/8fe4c10f-51e2-4850-8334-c218929e0b99.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8fe4c10f-51e2-4850-8334-c218929e0b99.png)'
- en: How it works...
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Let''s see how the current program works. This instruction imports the `nltk` libarary
    into the program:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当前程序是如何工作的。这个指令将`nltk`库导入到程序中：
- en: '[PRE72]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Some sample strings that indicate the dual behavior of the words, `address`,
    `laugh`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 一些样本字符串，表示单词`address`、`laugh`的双重行为：
- en: '[PRE73]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This function takes `sentence` strings and returns a list of lists, where the
    inner lists contain the words along with their POS tags:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受`sentence`字符串并返回一个包含词汇及其词性标签的列表的列表：
- en: '[PRE74]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In order to set up a baseline and see how bad the tagging can be, this function
    explains how  `UnigramTagger` can be used to print the POS of the words just by
    looking at the current word. We are feeding the sample text to it as learning.
    This `tagger` performs very badly when compared to the built-in tagger that `nltk`
    comes with. But this is just for our understanding:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设立基准并看看标签的准确度有多差，这个函数解释了如何使用`UnigramTagger`仅通过查看当前单词来打印单词的词性。我们将样本文本输入作为学习。与`nltk`自带的内置标注器相比，这个`tagger`的表现非常差。但这只是为了帮助我们理解：
- en: '[PRE75]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Defining a new function called `withContextTagger()`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个名为`withContextTagger()`的新函数：
- en: '[PRE76]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This function does feature extraction on a given set of words and returns a
    dictionary of the last three characters of the current word and previous word
    information:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数对给定的一组单词进行特征提取，并返回一个字典，包含当前单词和前一个单词的最后三个字符信息：
- en: '[PRE77]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We are building a `featuredata` list. It contains tuples of `featurelist` and
    `tag` members, which we will use to classify using `NaiveBayesClassifier`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建一个`featuredata`列表。它包含`featurelist`和`tag`成员的元组，我们将使用它们通过`NaiveBayesClassifier`进行分类：
- en: '[PRE78]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We take 50% for training and 50% of the feature extracted data to test our
    classifier:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将50%的数据用于训练，另外50%的特征提取数据用于测试分类器：
- en: '[PRE79]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This instruction creates `classifier` using the training data:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令使用训练数据创建`classifier`：
- en: '[PRE80]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This instruction prints the accuracy of the classifier using `testdata`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令使用`testdata`打印分类器的准确度：
- en: '[PRE81]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: These two functions print the results of two preceding functions' computations.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数打印前面两个函数计算的结果。
- en: '[PRE82]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
