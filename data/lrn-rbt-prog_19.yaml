- en: '*Chapter 16*: Diving Deeper with the IMU'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第16章*: 使用IMU深入探索'
- en: In [*Chapter 12*](B15660_12_Final_ASB_ePub.xhtml#_idTextAnchor251), *IMU Programming
    with Python*, we read data from an **inertial measurement unit** (**IMU**). We've
    now learned a bit more about processing sensor data, using math and pipelines
    to make decisions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第12章*](B15660_12_Final_ASB_ePub.xhtml#_idTextAnchor251)的*使用Python进行IMU编程*中，我们读取了来自**惯性测量单元**（**IMU**）的数据。我们现在对处理传感器数据、使用数学和管道进行决策有了更多的了解。
- en: In this chapter, we will learn how to get calibrated data from the IMU, combine
    data from the sensors, and use this to make a robot have absolute orientation-based
    behavior. On the way, we'll see algorithms for better precision/speed or accuracy.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何从IMU获取校准数据，结合传感器数据，并使用这些数据使机器人具有基于绝对方向的行性行为。在这个过程中，我们将看到用于提高精度/速度或准确性的算法。
- en: By the end of the chapter, you will be able to detect a robot's absolute orientation,
    display it on a screen, and incorporate this with the **Proportional-Integral-Derivative**
    (**PID**) behaviors.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够检测机器人的绝对方向，并在屏幕上显示，并将其与**比例-积分-微分**（**PID**）行为相结合。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主要内容：
- en: Programming a virtual robot
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程虚拟机器人
- en: Detecting rotation with the gyroscope
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用陀螺仪检测旋转
- en: Detecting pitch and roll with the accelerometer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加速度计检测俯仰和滚转
- en: Detecting a heading with the magnetometer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用磁力计检测航向
- en: Getting a rough heading from the magnetometer
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从磁力计获取大致航向
- en: Combining sensors for orientation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合传感器进行方向检测
- en: Driving a robot from IMU data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用IMU数据驱动机器人
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following items:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要以下物品：
- en: The robot from at least [*Chapter 14*](B15660_14_Final_ASB_ePub.xhtml#_idTextAnchor315),
    *Line-Following with a Camera in Python*
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自至少[*第14章*](B15660_14_Final_ASB_ePub.xhtml#_idTextAnchor315)的机器人代码，*使用Python进行基于摄像头的循线*
- en: The robot code from [*Chapter 14*](B15660_14_Final_ASB_ePub.xhtml#_idTextAnchor315),
    *Line-Following with a Camera in Python*, at [https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter14](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter14)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[*第14章*](B15660_14_Final_ASB_ePub.xhtml#_idTextAnchor315)的机器人代码，*使用Python进行基于摄像头的循线*，在[https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter14](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter14)
- en: The IMU code from [*Chapter 12*](B15660_12_Final_ASB_ePub.xhtml#_idTextAnchor251),
    *IMU Programming with Python*, at [https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter12](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter12)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[*第12章*](B15660_12_Final_ASB_ePub.xhtml#_idTextAnchor251)的IMU代码，*使用Python进行IMU编程*，在[https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter12](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter12)
- en: A wide driving space without many magnets
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在没有许多磁铁的广阔驾驶空间
- en: A magnetic compass
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁罗盘
- en: For the complete code for this chapter, go to [https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter16](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter16).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码请访问[https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter16](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter16)。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2LztwOO](https://bit.ly/2LztwOO)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://bit.ly/2LztwOO](https://bit.ly/2LztwOO)
- en: Programming a virtual robot
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程虚拟机器人
- en: We will first detect our robot's orientation; it would be useful to show this
    as a 3D robot model. This part builds upon the *Representing coordinate and rotation
    systems* section in [*Chapter 12*](B15660_12_Final_ASB_ePub.xhtml#_idTextAnchor251),
    *IMU Programming with Python*. In this section, we will construct a simple model
    of our robot in VPython.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将检测我们的机器人方向；将其显示为3D机器人模型将很有用。这部分基于[*第12章*](B15660_12_Final_ASB_ePub.xhtml#_idTextAnchor251)中的*表示坐标和旋转系统*部分，*使用Python进行IMU编程*。在本节中，我们将使用VPython构建我们机器人的简单模型。
- en: Modeling the robot in VPython
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在VPython中建模机器人
- en: We'll use shapes, known as **primitives**, to model the robot. They have a position,
    rotation, size, and color. The height-and-width parameters match the VPython-world
    coordinate system (see *Figure 12.14 – The robot body coordinate system* in [*Chapter
    12*](B15660_12_Final_ASB_ePub.xhtml#_idTextAnchor251), *IMU Programming with Python*),
    so we must rotate things to match the robot body coordinate system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用称为 **原语** 的形状来模拟机器人。它们具有位置、旋转、大小和颜色。高度和宽度参数与 VPython 世界坐标系匹配（参见 [*第 12
    章*](B15660_12_Final_ASB_ePub.xhtml#_idTextAnchor251) 中的 *图 12.14 – 机器人身体坐标系*，*使用
    Python 进行 IMU 编程*），因此我们必须旋转物体以匹配机器人身体坐标系。
- en: 'First, we need to collect some robot measurements. The following diagram shows
    where they are. Once the major measurements are made, estimates can be used for
    smaller measurements:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要收集一些机器人测量值。以下图表显示了它们的位置。一旦完成主要测量，可以使用估计值进行较小测量：
- en: '![](img/B15660_16_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_16_01.jpg)'
- en: Figure 16.1 – Measurements for the virtual robot
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.1 – 虚拟机器人的测量值
- en: '*Figure 16.1* shows the measurements across the robot. A top view and a left
    view show to cover the different aspects. This includes the width and height of
    the base—note that we are treating it as a rectangle for this purpose. The wheels''
    size and position, along with the castor-wheel size and position, are needed.
    Measure or guess these for your robot. For our purposes, guesses are good enough.
    Positions come from the middle of the chassis.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16.1* 展示了机器人的测量值。俯视图和左视图展示了覆盖不同方面的内容。这包括底座的宽度和高度——注意，我们在此目的将其视为矩形。需要测量或猜测车轮的大小和位置，以及万向轮的大小和位置。为你的机器人测量或猜测这些值。对我们来说，猜测就足够了。位置来自底盘的中间。'
- en: 'Let''s write the code to make the basic shape, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写代码来创建基本形状，如下所示：
- en: 'Create a file called `virtual_robot.py` and start it by adding in the `vpython`
    import and our robot view, as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `virtual_robot.py` 的文件，并添加 `vpython` 导入和我们的机器人视图来启动它，如下所示：
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We''ll put the virtual bot in a function ready to use in a few different behaviors,
    like this:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将虚拟机器人放入一个函数中，以便在几种不同的行为中使用，如下所示：
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We put the robot''s measurements from *Figure 16.1* in variables. I''ve used
    **millimeters** (**mm**) for all of them. The code is shown in the following snippet:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 *图 16.1* 中的机器人测量值放入变量中。我使用了 **毫米**（**mm**）来表示所有这些值。代码如下所示：
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The base is a box with the position defaulting to (`0`, `0`, `0`). The code
    is shown in the following snippet:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 底座是一个默认位置为 (`0`, `0`, `0`) 的盒子。代码如下所示：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Rotate this box to match the body coordinate system by 90 degrees around the
    *x* axis, putting the *z* axis up, as follows:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此盒子绕 `x` 轴旋转 90 度以匹配身体坐标系，将 `z` 轴向上，如下所示：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We''ll use two cylinders for the wheels. The distance from each wheel to the
    middle is roughly half the chassis width. Let''s use it to create the wheels''
    *y* positions, as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用两个圆柱体作为车轮。每个车轮到中间的距离大约是底盘宽度的一半。让我们用它来创建车轮的 `y` 位置，如下所示：
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We set wheel positions to line up with the ends of the motor axles. The left
    wheel has a *y* coordinate; `-wheel_dist` moves it left of the platform, as illustrated
    in the following code snippet:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置车轮位置以与电机轴的末端对齐。左轮有一个 `y` 坐标；`-wheel_dist` 将其移动到平台左侧，如下代码片段所示：
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we set the right wheel, with a positive `wheel_dist` and *y* as *1* for
    the axis so that it points to the right, as illustrated in the following code
    snippet:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们设置右轮，`wheel_dist` 为正值，`y` 轴为 `1`，以便它指向右侧，如下代码片段所示：
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'I''ve used a cylinder for the rear castor wheel, as illustrated in the following
    code snippet:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我已经使用了一个圆柱体作为后轮的万向轮，如下代码片段所示：
- en: '[PRE8]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we join all of these parts into a compound object—a single 3D object,
    like this:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将所有这些部分组合成一个复合对象——一个单一的 3D 对象，如下所示：
- en: '[PRE9]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For testing it, let''s make a tiny `main` section. This code checks if you''ve
    launched it directly, so the following code won''t run when we import the virtual
    robot as a library:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试它，让我们创建一个微小的 `main` 部分。此代码检查你是否直接启动了它，因此以下代码在将虚拟机器人作为库导入时不会运行：
- en: '[PRE10]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Set the view, putting the camera just in front of the robot, as follows:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置视图，将摄像机放置在机器人前方，如下所示：
- en: '[PRE11]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We''ll add axes to show where things are, like this:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加轴来显示物品的位置，如下所示：
- en: '[PRE12]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And then, we''ll draw the robot, as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将绘制机器人，如下所示：
- en: '[PRE13]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Upload and test this code with `vpython virtual_robot.py`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `vpython virtual_robot.py` 上传并测试此代码。
- en: Open up a browser to port `9020` on your robot to see your virtual robot. You
    should see a figure like the following:![](img/B15660_16_02.jpg)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器，查看您机器人上的端口 `9020` 以查看您的虚拟机器人。您应该看到以下类似的图像！![图片](img/B15660_16_02.jpg)
- en: Figure 16.2 – Screenshot of the 3D virtual robot from VPython
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图16.2 – VPython 3D虚拟机器人的截图
- en: In *Figure 16.2*, we can see the *x* axis facing forward in red, the *y* axis
    going right in green, and the *z* axis going up in blue. This follows a right-hand-rule
    coordinate system. It shows the virtual robot viewed from the front, with a wheel
    on either side. It's gray, boxy, and basic, but it will do for our remaining experiments.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 *图16.2* 中，我们可以看到红色表示的 *x* 轴向前，绿色表示的 *y* 轴向右，蓝色表示的 *z* 轴向上。这遵循右手定则坐标系。它显示了从前方看到的虚拟机器人，两侧各有一个轮子。它是灰色、方形的，但对我们剩余的实验来说足够了。
- en: 'You can right-click and drag this around to get another view. The mouse wheel
    will also zoom in or out. The following screenshot shows the rear castor:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以右键单击并拖动它以获得另一个视角。鼠标滚轮也可以放大或缩小。以下截图显示了后轮：
- en: '![](img/B15660_16_03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15660_16_03.jpg)'
- en: Figure 16.3 – A different view of the virtual robot
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3 – 虚拟机器人的不同视角
- en: '*Figure 16.3* shows a left-hand view of this virtual robot.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16.3* 展示了该虚拟机器人的左侧视角。'
- en: Close the browser tab, then press *Ctrl* + *C* to finish this program when done.
    Let's just check you've been able to follow along.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭浏览器标签页，然后按 *Ctrl* + *C* 完成此程序。让我们检查一下你是否能跟上。
- en: Troubleshooting
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'If you haven''t got this to work, let''s check a few things, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有让这个工作，让我们检查以下几点：
- en: If you receive errors saying **no such module vpython**, ensure that VPython
    is installed. Follow the steps in [*Chapter 12*](B15660_12_Final_ASB_ePub.xhtml#_idTextAnchor251),
    *IMU Programming with Python*, in the *Reading the temperature* section. You need
    the code from the whole of [*Chapter 12*](B15660_12_Final_ASB_ePub.xhtml#_idTextAnchor251),
    *IMU Programming with Python*, for this chapter to work.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您收到显示 **没有这样的模块 vpython** 的错误，请确保您已遵循 [*第12章*](B15660_12_Final_ASB_ePub.xhtml#_idTextAnchor251)
    中的 *简化 VPython 命令行* 部分，*使用 Python 进行 IMU 编程*，在 *读取温度* 部分。您需要 [*第12章*](B15660_12_Final_ASB_ePub.xhtml#_idTextAnchor251)
    中的整个代码，*使用 Python 进行 IMU 编程*，以便本章工作。
- en: If you receive errors saying **no such command vpython**, ensure you have followed
    the *Simplifying the VPython command line* section from [*Chapter 12*](B15660_12_Final_ASB_ePub.xhtml#_idTextAnchor251),
    *IMU Programming with Python*. The alias for VPython is necessary to be able to
    see a display.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您收到显示 **没有这样的命令 vpython** 的错误，请确保您已遵循 [*第12章*](B15660_12_Final_ASB_ePub.xhtml#_idTextAnchor251)
    中的 *简化 VPython 命令行* 部分。VPython 的别名对于能够看到显示是必要的。
- en: If you see syntax errors, please check your code for typos.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您看到语法错误，请检查您的代码是否有误。
- en: If you cannot reach the display (and have checked *Step 1*), ensure you use
    port `9020` on your robot (mine is [http://myrobot.local:9020](http://myrobot.local:9020)).
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您无法到达显示屏（并且已经检查了 *步骤1*），请确保您在机器人上使用端口 `9020`（我的机器人是 [http://myrobot.local:9020](http://myrobot.local:9020)）。
- en: Be patient—VPython can take a minute or two to start up.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请耐心等待——VPython 启动可能需要一分钟或两分钟。
- en: Now that we have a visual robot to play with, we can revisit the gyroscope and
    try to make the onscreen robot move like our real robot.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以玩耍的视觉机器人，我们可以重新审视陀螺仪，并尝试让屏幕上的机器人像我们的真实机器人一样移动。
- en: Detecting rotation with the gyroscope
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用陀螺仪检测旋转
- en: 'We''ve had some raw data from the gyroscope, but to use it more effectively,
    we''ll need to perform two operations, calibrating the gyroscope, and then integrating
    it, as shown in the following diagram:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从陀螺仪获得了一些原始数据，但为了更有效地使用它，我们需要执行两个操作，校准陀螺仪，然后将其积分，如下图中所示：
- en: '![](img/B15660_16_04.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15660_16_04.jpg)'
- en: Figure 16.4 – The gyroscope data flow
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4 – 陀螺仪数据流
- en: '*Figure 16.4* shows the data flow, and we will look closer at the concepts
    later in this section. The first operation is shown at the top, which shows the
    gyroscope data going through an offset calibration to take out errors. This gives
    us a calibrated gyroscope, with a rate of change in degrees per second (per axis)—shown
    by the arrow around the circle. The gyroscope makes a relative measurement.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16.4* 展示了数据流，我们将在本节稍后更详细地探讨这些概念。第一个操作显示在顶部，显示了陀螺仪数据经过偏移校准以去除误差。这给我们一个校准后的陀螺仪，以每秒度数的变化率（每轴）显示——由圆圈周围的箭头表示。陀螺仪进行相对测量。'
- en: The lower part of the diagram is the second operation, combining delta time
    with the calibrated gyroscope (gyro). We need to **integrate** that to find an
    absolute measurement. An integrator multiplies an input value by delta time and
    adds this to a previous result. In this case, we multiply the gyroscope rate by
    delta time to produce a movement for that period (shown by the multiplication
    symbol in a box). The circle above it has a small slither of pie with dashed lines,
    denoting the amount moved.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图表的下半部分是第二个操作，将时间差与校准后的陀螺仪（gyro）结合。我们需要**积分**这个值以找到绝对测量值。积分器将输入值乘以时间差并添加到先前结果中。在这种情况下，我们将陀螺仪速率乘以时间差以产生该期间的移动（由框中的乘法符号表示）。上面的圆圈有一个小扇形，用虚线表示移动的量。
- en: We add the movement to the last value for that axis, shown by the plus symbol
    box. The circle above it shows a solid gray pie segment for the existing position
    and a new segment with dashed lines. When added, they make the total value for
    that axis—shown by the circle with a large, solid gray pie segment representing
    the addition's result. The system feeds the pitch, roll, or yaw result back into
    the next cycle.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将移动量加到该轴的最后一个值上，由加号符号框表示。上面的圆圈显示了一个实心灰色扇形表示现有位置，以及一个带有虚线的新的扇形段。当它们相加时，它们构成了该轴的总值——由一个带有大实心灰色扇形的圆圈表示，表示加法的结果。系统将俯仰、滚转或偏航结果反馈到下一个循环。
- en: Before we do this, we need to correct the errors in the gyroscope.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这样做之前，我们需要纠正陀螺仪的错误。
- en: Calibrating the gyroscope
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 校准陀螺仪
- en: As they come from the factory, **microelectromechanical systems** (**MEMS**)
    gyroscopes usually have minor flaws that cause them to give slightly off readings.
    These flaws will cause drift in our integration.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们是从工厂出来的，**微机电系统**（**MEMS**）陀螺仪通常有一些微小的缺陷，导致它们给出略微不准确的读数。这些缺陷将导致我们的积分出现漂移。
- en: 'We can make code to detect these and compensate; we call this **calibration**.
    Proceed as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写代码来检测这些并补偿；我们称之为**校准**。按照以下步骤进行：
- en: Create a file named `calibrate_gyro.py`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`calibrate_gyro.py`的文件。
- en: 'We need VPython for vectors, time for a little sleep, and to set up the IMU,
    as illustrated in the following code snippet:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要VPython来处理向量，time来稍微休息一下，以及设置IMU，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We need vectors to hold the minimum and maximum values of the gyroscope, as
    illustrated in the following code snippet:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要向量来保存陀螺仪的最小和最大值，如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, for the loop, we''ll do a bunch of readings over time, as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，对于循环，我们将在一段时间内进行多次读数，如下所示：
- en: '[PRE16]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To calibrate, we measure for a while to get the minimum and maximum values
    for each axis. The Python `min` function returns the lower of the two values given
    to it, as follows:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了校准，我们需要测量一段时间以获取每个轴的最小和最大值。Python的`min`函数返回它给出的两个值中的较小值，如下所示：
- en: '[PRE17]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We do the same for the maximum values, using the Python `max` function, as
    follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对最大值也做同样的处理，使用Python的`max`函数，如下所示：
- en: '[PRE18]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The middle of these is an estimate of how far we are from zero. We can calculate
    this by adding the vectors and dividing by 2, as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些中间部分是我们距离零的估计值。我们可以通过将向量相加然后除以2来计算这个值，如下所示：
- en: '[PRE19]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Sleep a little before the next loop, as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个循环之前稍微休息一下，如下所示：
- en: '[PRE20]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We print the values so we can use them, as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们打印这些值以便使用，如下所示：
- en: '[PRE21]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code is ready to run. Upload and run this with Python 3, leaving the robot
    still on a flat, stable surface until the program exits.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此代码已准备好运行。使用Python 3上传并运行此代码，直到程序退出之前，请确保机器人仍然位于平坦、稳定的表面上。
- en: 'You should see console output ending with something like this:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到控制台输出以类似以下内容结束：
- en: '[PRE22]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'What we''ve measured here is how much the gyroscope changes, on average, when
    stationary. This is calculated as an offset for each axis. By subtracting this
    from the measurements, we will mostly offset any continuous errors from the gyroscope.
    Let''s put this somewhere we can use it, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里测量的是当静止时陀螺仪平均变化了多少。这被计算为每个轴的偏移量。通过从测量值中减去这个值，我们将主要抵消陀螺仪的连续误差。让我们把它放在我们可以使用的地方，如下所示：
- en: Create a file called `imu_settings.py`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`imu_settings.py`的文件。
- en: 'We''ll import the `vector` type, and then set our calibration readings. You
    probably only need to run this once, or if you change IMU device. Please use the
    readings you got from your robot. Run the following code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将导入`vector`类型，然后设置我们的校准读数。你可能只需要运行一次，或者如果你更换了IMU设备。请使用从你的机器人获得的读数。运行以下代码：
- en: '[PRE23]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Next, we upgrade our `RobotImu` class to handle these offsets—open `robot_imu.py`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将我们的`RobotImu`类升级以处理这些偏移量——打开`robot_imu.py`。
- en: 'We will make our class accept offsets if we pass them, or use zero if we leave
    them. Make the highlighted changes to the `__init__` method of `RobotImu`, as
    follows:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们传递偏移量，我们的类将接受它们，或者如果我们不传递它们，则使用零。对`RobotImu`的`__init__`方法进行以下突出显示的更改：
- en: '[PRE24]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We need to modify the `read_gyroscope` method to account for these too, as
    follows:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要修改`read_gyroscope`方法来考虑这些偏移量，如下所示：
- en: '[PRE25]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, to see if this works, let's use it to move a virtual robot.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了看看这行不行，让我们用它来移动一个虚拟机器人。
- en: Rotating the virtual robot with the gyroscope
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用陀螺仪旋转虚拟机器人
- en: 'We''ve mentioned how we will integrate the gyroscope measurements. Take a look
    at the following diagram to see how this will work for a single axis:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到了如何将陀螺仪测量值进行积分。看看以下图表，看看这是如何对单个轴起作用的：
- en: '![](img/B15660_16_05.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15660_16_05.jpg)'
- en: Figure 16.5 – Integrating a gyroscope axis
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5 – 整合陀螺仪轴
- en: '*Figure 16.5* shows a dashed circle, indicating a turning circle of an axis.
    The crosshair through the circle shows its center. A thick arrow above and to
    the left of the circle indicates the current heading. A shaded area shows the
    change in rotation in degrees over some time, which we add to the current heading
    to get to the new heading estimate—another thick arrow.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16.5*显示了一个虚线圆圈，表示轴的旋转圆。穿过圆的十字线表示其中心。圆圈上方和左边的粗箭头表示当前的航向。阴影区域表示一段时间内旋转的变化（以度为单位），我们将这些变化加到当前航向上，以得到新的航向估计——另一个粗箭头。'
- en: We multiply the turning rate by time to get a movement; it is an estimate since
    we don't have intermediate values.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将旋转速率乘以时间以获得移动；这是一个估计，因为我们没有中间值。
- en: The concept of time-since-last-measurement is an important one, seen in the
    PID in [*Chapter 14*](B15660_14_Final_ASB_ePub.xhtml#_idTextAnchor315), *Line-Following
    with a Camera in Python*. It's more commonly known as the delta time.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 时间自上次测量以来的概念是一个重要的概念，在[*第14章*](B15660_14_Final_ASB_ePub.xhtml#_idTextAnchor315)中可以看到，即“Python中用摄像头进行路径跟踪”。它更常被称为时间差。
- en: 'We can combine what we know about the gyroscope with the virtual robot and
    make it rotate on the screen. Let''s use this to rotate our virtual robot, as
    follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们对陀螺仪的了解与虚拟机器人结合起来，使其在屏幕上旋转。让我们用这个来旋转我们的虚拟机器人，如下所示：
- en: 'Create a new file named `visual_gyroscope.py`. We have many imports here to
    bring the components together, as can be seen in the following code snippet:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`visual_gyroscope.py`的新文件。我们在这里有很多导入，以便将组件组合在一起，如下面的代码片段所示：
- en: '[PRE26]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This time, when we set up the `RobotImu`, we will do so with the settings we
    made, as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，当我们设置`RobotImu`时，我们将使用我们设置的设置，如下所示：
- en: '[PRE27]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We are going to integrate three axes: `pitch`, `roll`, and `yaw`. Let''s start
    them at zero, like this:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要整合三个轴：`俯仰角`、`横滚角`和`偏航角`。让我们从零开始，如下所示：
- en: '[PRE28]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We should now set up the virtual robot and the view for it, as follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在应该设置虚拟机器人和它的视图，如下所示：
- en: '[PRE29]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We are going to be tracking delta time, so we start by taking the latest time,
    like this:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要跟踪时间差，所以我们首先获取最新的时间，如下所示：
- en: '[PRE30]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We then start the main loop for this behavior. Since this is animating in VPython,
    we need to set the loop rate and tell it to update, as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们开始这个行为的主体循环。由于这是在VPython中动画化，我们需要设置循环速率并告诉它更新，如下所示：
- en: '[PRE31]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We now calculate the delta time (`dt`), storing a new latest time, as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在计算时间差（`dt`），存储最新的时间，如下所示：
- en: '[PRE32]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The code reads the gyroscope in the `gyro` vector, as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码读取`gyro`向量中的陀螺仪，如下所示：
- en: '[PRE33]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We integrate the current rate (in degrees per second) multiplied by `dt` (in
    seconds), as illustrated in the following code snippet:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将当前速率（每秒度数）乘以`dt`（秒）进行积分，如下面的代码片段所示：
- en: '[PRE34]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We reset the model''s orientation to prepare it for rotation, like this:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将模型的朝向重置为准备旋转，如下所示：
- en: '[PRE35]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We perform the rotations by each axis. We must convert these into radians,
    as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过每个轴进行旋转。我们必须将这些转换为弧度，如下所示：
- en: '[PRE36]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This code is now ready to run; this will make the virtual robot change position
    when we rotate the robot in the real world! Upload the files and run with `vpython
    visual_gyroscope.py`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码现在可以运行了；这将使虚拟机器人在现实世界中旋转时改变位置！上传文件并使用`vpython visual_gyroscope.py`运行。
- en: As before, wait a minute or so, and point your browser to `myrobot.local:9020`.
    You should see the following display:![](img/B15660_16_06.jpg)
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，等待一分钟或更长时间，并将您的浏览器指向`myrobot.local:9020`。您应该看到以下显示：![图片](img/B15660_16_06.jpg)
- en: Figure 16.6 – The robot rotated
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图16.6 – 旋转的机器人
- en: '*Figure 16.6* shows the virtual robot rotated to an angle by having moved the
    real robot. Move your robot around a bit—try to approximate what you see here.'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图16.6*显示了通过移动真实机器人使虚拟机器人旋转到一定角度。移动一下你的机器人——尽量接近你在这里看到的样子。'
- en: You'll notice that as you move the robot and return it, it won't line up correctly
    anymore—this is the accumulating errors or drift that gyroscope integration causes.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会注意到，当你移动机器人并将其放回原位时，它将不再正确对齐——这是陀螺仪积分造成的累积误差或漂移。
- en: From this experiment, while seeing some great movement you've also noticed that
    a gyroscope alone can't accurately track rotations. We are going to need to leverage
    the other sensors in the IMU device to improve this.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，虽然看到了一些很好的运动，但你同时也注意到仅使用陀螺仪无法准确跟踪旋转。我们将需要利用IMU设备中的其他传感器来提高这一点。
- en: Let's check it is working before proceeding.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们检查它是否正常工作。
- en: Troubleshooting
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'If it is not quite working, try some of these steps:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它还没有完全工作，尝试以下步骤：
- en: This code requires the use of the `vpython` command and a browser to see the
    results.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此代码需要使用`vpython`命令和浏览器来查看结果。
- en: If the robot is still moving when held still, retry the calibration and offsets.
    The gyroscope's nature is that this won't be perfect—we'll fix that further on.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果机器人静止时仍在移动，请重试校准和偏移。陀螺仪的特性是这不会完美——我们将在后面修复它。
- en: If the robot appears to spin uncontrollably or jump around, ensure you've remembered
    to convert to radians.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果机器人看起来无法控制地旋转或跳跃，请确保你已经记得将其转换为弧度。
- en: If the robot is rotating the wrong way (left/right instead of up/down), check
    the rotations' axis parameters.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果机器人旋转的方向不正确（左右而不是上下），请检查旋转轴的参数。
- en: Now that you have this working, let's move on to the accelerometer so that we
    can see forces acting on our robot!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经使它工作，让我们继续到加速度计，这样我们就可以看到作用在我们机器人上的力了！
- en: Detecting pitch and roll with the accelerometer
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用加速度计检测俯仰和滚转
- en: In [*Chapter 12*](B15660_12_Final_ASB_ePub.xhtml#_idTextAnchor251), *IMU Programming
    with Python*, we were getting a vector from the accelerometer, but we need to
    calculate angles to consider using it alongside the gyroscope and magnetometer.
    To use this to rotate things, we need to turn this vector into pitch-and-roll
    angles.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第12章*](B15660_12_Final_ASB_ePub.xhtml#_idTextAnchor251)，“使用Python进行IMU编程”中，我们得到了加速度计的矢量，但我们需要计算角度以考虑与陀螺仪和磁力计一起使用。为了使用这个来旋转物体，我们需要将这个矢量转换为俯仰和滚转角度。
- en: Getting pitch and roll from the accelerometer vector
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从加速度计矢量获取俯仰和滚转
- en: The accelerometer describes what is going on in **Cartesian coordinates**. We
    need to convert these into a pair of pitch-and-roll angles perpendicular to each
    other. In [*Chapter 12*](B15660_12_Final_ASB_ePub.xhtml#_idTextAnchor251), *IMU
    Programming with Python*, the *Coordinate and rotation systems* section shows
    roll as taking place around the *x* axis, and pitch as taking place around the
    *y* axis.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度计描述了在**笛卡尔坐标系**中发生的事情。我们需要将这些转换为相互垂直的一对俯仰和滚转角度。在[*第12章*](B15660_12_Final_ASB_ePub.xhtml#_idTextAnchor251)，“使用Python进行IMU编程”中，*坐标和旋转系统*部分显示滚转发生在*x*轴周围，俯仰发生在*y*轴周围。
- en: 'A crude but effective way to consider this is as two planes. When rotating
    around the *x* axis, you can take a vector in the *yz* plane and find its angle.
    When turning around the *y* axis, then you consider the *xz* plane instead. Take
    a look at the next diagram:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这种方法的粗略但有效的方式是将其视为两个平面。当围绕*x*轴旋转时，你可以在*yz*平面取一个矢量并找到其角度。当围绕*y*轴旋转时，则考虑*xz*平面。看看下一个图：
- en: '![](img/B15660_16_07.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_16_07.jpg)'
- en: Figure 16.7 – The accelerometer vector and angles
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7 – 加速度计矢量和角度
- en: In *Figure 16.7*, the background has *x*, *y*, and *z* axes and a sphere, with
    circles around the *xz* and *yz* planes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图16.7*中，背景有*x*、*y*和*z*轴以及一个球体，周围有围绕*xz*和*yz*平面的圆圈。
- en: The accelerometer vector is shown as vector **A**. By using only the *xz* components,
    we project this vector onto an *xz* circle at point **C**; so, the angle from
    the *z* axis to **C** is the pitch. We project **A** again onto a *yz* circle
    at point **B**; this angle from the *z* axis to **B** is the roll.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度计矢量为**A**。仅使用*xz*分量，我们将此矢量投影到点**C**处的*xz*圆上；因此，从*z*轴到**C**的角度是俯仰。我们再次将**A**投影到点**B**处的*yz*圆上；从*z*轴到**B**的角度是滚转。
- en: 'When we have two components (*x* and *z*, for example) on a plane, they can
    be used in the `atan2` function (present in most programming languages) to get
    an angle from them. A slight quirk here is that the orientation of the different
    sensor components means we must negate the pitch. The following diagram shows
    the process:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在一个平面上有两个组件（例如 *x* 和 *z*）时，它们可以用在 `atan2` 函数（存在于大多数编程语言中）中以获取一个角度。这里的一个小问题是不同传感器组件的朝向意味着我们必须取俯仰的相反数。以下图表显示了这个过程：
- en: '![](img/B15660_16_08.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_16_08.jpg)'
- en: Figure 16.8 – Accelerometer data flow
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8 – 加速度计数据流
- en: '*Figure 16.8* shows the raw accelerometer data going into the arctangent to
    get the angles and outputting the accelerometer pitch/roll values.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16.8* 显示了原始加速度计数据进入反正切函数以获取角度，并输出加速度计俯仰/滚转值。'
- en: 'Let''s turn the accelerometer readings into pitch and roll, and then put them
    into a graph, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把加速度计读数转换成俯仰和滚转，然后放入图表中，如下所示：
- en: First, open up `robot_imu.py`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开 `robot_imu.py`。
- en: 'Extend the imports to include the trigonometric functions, as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将导入扩展到包括三角函数，如下所示：
- en: '[PRE37]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After the `read_accelerometer` method, add the following code to perform the
    required math:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `read_accelerometer` 方法之后，添加以下代码以执行所需的数学运算：
- en: '[PRE38]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Let's show these angles on a graph, which will also reveal a major flaw with
    using the accelerometer on its own. Create a `plot_pitch_and_roll.py` file.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在图表上显示这些角度，这将同时揭示使用加速度计时存在的重大缺陷。创建一个 `plot_pitch_and_roll.py` 文件。
- en: 'Start with imports, as follows:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从导入开始，如下所示：
- en: '[PRE39]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We create the graphs, like this:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建图表，如下所示：
- en: '[PRE40]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, we set up a start time so that we can make a time-based graph, as follows:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们设置一个起始时间，以便我们可以创建一个基于时间的图表，如下所示：
- en: '[PRE41]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can now get our new pitch-and-roll values, as follows:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以获取新的俯仰和滚转值，如下所示：
- en: '[PRE42]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And then, we can put both sets into graphs, like this:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以将这两组数据放入图表中，如下所示：
- en: '[PRE43]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Upload both the `robot_imu.py` and `plot_pitch_and_roll.py` files. Run this
    with `vpython plot_accel_pitch_and_roll.py`, and point your browser at port `9020`
    on the robot. This should result in the following:![](img/B15660_16_09.jpg)
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传 `robot_imu.py` 和 `plot_pitch_and_roll.py` 文件。使用 `vpython plot_accel_pitch_and_roll.py`
    运行，并将浏览器指向机器人的端口 `9020`。这应该会产生以下结果：![](img/B15660_16_09.jpg)
- en: Figure 16.9 – Accelerometer pitch-and-roll graph
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.9 – 加速度计俯仰和滚转图
- en: '*Figure 16.9* shows a screenshot of the graph. The red curve in the graph represents
    pitch, around the *y* axis, while the green curve represents roll, around the
    *x* axis. Although it shows swings between +90 and -90 degrees, what is also clear
    is that the graph has a lot of noise, so much so that movements of less than a
    second are blotted out by it.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16.9* 显示了图表的截图。图表中的红色曲线代表俯仰，围绕 *y* 轴，而绿色曲线代表滚转，围绕 *x* 轴。虽然它显示了+90和-90度之间的摆动，但也很明显的是，图表有很多噪声，以至于不到一秒的移动都被它抹去了。'
- en: We need to clean this up. A common way to do so is through a complementary filter,
    combining a new value with a previous value to filter out fast vibration noise.
    We will create such a filter, but it makes sampling slower.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要清理一下。一个常见的做法是通过互补滤波器，将新值与旧值结合以过滤掉快速振动噪声。我们将创建这样的滤波器，但这会使采样变慢。
- en: Let's check that this is working.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下这是否有效。
- en: Troubleshooting
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'If it''s not quite working, let''s try a few fixes, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它还没有完全工作，让我们尝试一些修复方法，如下所示：
- en: If it's very noisy, try a more severe turn, and try keeping your hands steady.
    This graph will be noisy due to the nature of the accelerometer alone.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果非常嘈杂，尝试更剧烈的转弯，并尽量保持双手稳定。这张图会因为加速度计本身的特性而嘈杂。
- en: If you see the graph break up or misbehave outside of the 0-90-degree range,
    ensure you are using the `atan2` function—this mathematically performs the trigonometric
    CAST rule.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你看到图表在0-90度范围外断裂或行为异常，请确保你正在使用 `atan2` 函数——这个函数在大多数编程语言中执行三角函数的 CAST 规则。
- en: Notice that the `read_accelerometer_pitch_and_roll` method has a negative sign
    in front of the `atan2` function.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，`read_accelerometer_pitch_and_roll` 方法在 `atan2` 函数前有一个负号。
- en: If things misbehave at 180 degrees—this is a known and expected problem with
    this system—try to avoid hitting this yet.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在180度处出现问题——这是这个系统已知且预期的问题——尽量避免触及这一点。
- en: 'Now, we have the pitch and roll, but it''s quite rough—a suitable way to fix
    this is to combine sensors through a filter. We have another sensor that is giving
    us an integrated pitch-and-roll value: the gyroscope.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了俯仰和滚转，但它们相当粗糙——一个合适的修复方法是结合传感器通过滤波器。我们还有一个传感器，它给我们一个综合的俯仰和滚转值：陀螺仪。
- en: Smoothing the accelerometer
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平滑加速度计
- en: We can combine what we know about integrating the gyroscope with the accelerometer
    to make a smooth combination.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们对积分陀螺仪和加速度计的知识结合起来，以实现平滑的组合。
- en: Since we will use the delta-time concept more, a class to help will save us
    some work later.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将更多地使用时间差概念，一个帮助的类将节省我们以后的工作。
- en: Delta time
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间差
- en: 'We saw before how we tracked the elapsed time for graphing and the delta time
    between updates for integrating. Let''s create the code to help, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到如何跟踪绘图所需的时间差和更新之间的时间差以进行积分。让我们创建以下代码来帮助：
- en: 'Make a `delta_timer.py` file and start by importing `time`, as follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `delta_timer.py` 文件，并首先导入 `time`，如下所示：
- en: '[PRE44]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We''ll make a `DeltaTimer` class that will keep track of things, as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个 `DeltaTimer` 类来跟踪事物，如下所示：
- en: '[PRE45]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The central part of this is an `update` method. Every loop calls this; let''s
    start by getting the current time, as follows:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里的核心是一个 `update` 方法。每个循环都会调用这个方法；让我们先获取当前时间，如下所示：
- en: '[PRE46]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The delta time will be the difference between the current time and last time,
    as illustrated in the following code snippet:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 时间差将是当前时间和上次时间之间的差值，如下面的代码片段所示：
- en: '[PRE47]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The elapsed time is the difference between the current time and the start time,
    as illustrated in the following code snippet:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经过的时间是当前时间和开始时间之间的差值，如下面的代码片段所示：
- en: '[PRE48]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We now need to update the last time for the delta time and return the parts,
    as follows:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要更新最后的时间以获取时间差并返回这些部分，如下所示：
- en: '[PRE49]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can use this class whenever we need a delta time and an elapsed time for
    graphing. Let's start by using it to combine the accelerometer and gyroscope.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在需要用于绘图的时间差和经过的时间时使用这个类。让我们先使用它来组合加速度计和陀螺仪。
- en: Fusing accelerometer and gyroscope data
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 融合加速度计和陀螺仪数据
- en: 'By combining the sensors, we can let each of them complement the other''s weaknesses.
    The accelerometer acts as an absolute measurement for pitch and roll to counteract
    the drift seen by the gyroscope. The gyroscope does not experience the same noise
    as the accelerometer but can make fast measurements. Let''s see how to combine
    them in the following diagram:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组合传感器，我们可以让每个传感器补充对方的弱点。加速度计作为俯仰角和横滚角的绝对测量值，以抵消陀螺仪看到的漂移。陀螺仪不像加速度计那样经历相同的噪声，但可以进行快速测量。让我们看看如何在以下图中将它们组合起来：
- en: '![](img/B15660_16_10.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_16_10.jpg)'
- en: Figure 16.10 – Gyroscope and accelerometer fusion data flow
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10 – 陀螺仪和加速度计融合数据流
- en: '*Figure 16.10* shows the data flow diagram, using a complementary filter to
    fuse gyroscope and accelerometer data. We''ll take pitch as an example. First,
    the system feeds gyroscope data and delta time into an integrator. The integrator
    adds this to a previous position. We can then use 95% of this term to account
    for larger movement changes. The filter''s other 5% is the accelerometer measurement.
    This 5% will drag the measurement to the average accelerometer reading while filtering
    out the chaotic noise element. The output is a filtered pitch or roll, fed back
    into the integrator for the next cycle.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16.10* 展示了数据流图，使用互补滤波器融合陀螺仪和加速度计数据。以俯仰角为例。首先，系统将陀螺仪数据和时间差输入到积分器中。积分器将这个值加到之前的位置上。然后我们可以用这个值的95%来解释较大的运动变化。滤波器的其他5%是加速度计的测量值。这5%将在滤波过程中将测量值拖到平均加速度计读数，同时滤除混沌噪声元素。输出是一个滤波后的俯仰角或横滚角，然后反馈到积分器进行下一周期。'
- en: 'Let''s put this into code, starting with the filter, as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些放入代码中，从滤波器开始，如下所示：
- en: Open up `robot_imu.py`.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `robot_imu.py`。
- en: 'Add the `ComplementaryFilter` class, as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ComplementaryFilter` 类，如下所示：
- en: '[PRE50]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can construct this filter with the left side''s value, storing this and
    calculating the complement (one minus the left side) to make the right side, as
    follows:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用左侧的值构建这个滤波器，存储这个值并计算其补数（左侧减一）来形成右侧，如下所示：
- en: '[PRE51]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This class has a `filter` method that takes the two sides and combines them
    using the filter values, as follows:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类有一个 `filter` 方法，它接受两个值并使用滤波器值将它们结合起来，如下所示：
- en: '[PRE52]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: That finishes the filter.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样就完成了滤波器。
- en: 'The next thing we''ll want is code to combine the IMU sensors via filters –
    to fuse them. We''ll add a class for this to `robot_imu.py`, as follows:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步，我们想要的是通过滤波器组合IMU传感器的代码 – 将它们融合在一起。我们将在 `robot_imu.py` 中添加一个类来实现这一点，如下所示：
- en: '[PRE53]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the constructor, we will store the `RobotImu` instance, create a filter,
    and seed the pitch-and-roll values, as follows:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，我们将存储 `RobotImu` 实例，创建一个滤波器，并初始化俯仰角和横滚值，如下所示：
- en: '[PRE54]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The core part of this code is an `update` function. The function takes a `dt`
    (delta time) parameter. It will not return anything and just updates the pitch/roll
    members, as follows:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的核心部分是一个`update`函数。该函数接受一个`dt`（时间差）参数。它不会返回任何内容，只是更新俯仰/滚转成员，如下所示：
- en: '[PRE55]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We start by taking the pitch-and-roll values from the accelerometer, as follows:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先从加速度计获取俯仰和滚转值，如下所示：
- en: '[PRE56]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We also want the gyroscope values, so we run the following command:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还想要陀螺仪的值，所以我们运行以下命令：
- en: '[PRE57]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, we combine the gyroscope *y* reading and accelerometer pitch to get the
    pitch value, as follows:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将陀螺仪的*y*读数和加速度计的俯仰值结合起来得到俯仰值，如下所示：
- en: '[PRE58]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Notice here the multiply and addition operations from the preceding data flow.
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意这里来自先前数据流的乘法和加法操作。
- en: 'We do the same for the roll, as follows:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对滚转也做同样的处理，如下：
- en: '[PRE59]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, we have prepared the `RobotImu` class with filters and fused the sensors.
    Let''s give this code a test drive with a graph, as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好了带有滤波器的`RobotImu`类，并融合了传感器。让我们用以下代码进行一次图形测试：
- en: 'In the `plot_pitch_and_roll.py` file, we''ll add the `DeltaTimer`, `ImuFusion`,
    and gyroscope calibration imports. Note in the following code snippet that `import
    time` has been removed:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`plot_pitch_and_roll.py`文件中，我们将添加`DeltaTimer`、`ImuFusion`和陀螺仪校准导入。注意以下代码片段中已经移除了`import
    time`：
- en: '[PRE60]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Next, we set up the `RobotImu` with the gyroscope settings, and then create
    the `fusion` instance, as illustrated in the following code snippet:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用陀螺仪设置设置`RobotImu`，然后创建`fusion`实例，如下代码片段所示：
- en: '[PRE61]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We need a `dt` (delta time) for the fusion calculations and an elapsed time
    for the graph. The `DeltaTimer` class provides these. We put this close before
    the loop starts, replacing the assignment of `start`, as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个`dt`（时间差）用于融合计算和一个用于图形的已过时间。`DeltaTimer`类提供了这些。我们在循环开始前将其放在这里，替换了`start`的赋值，如下所示：
- en: '[PRE62]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, in the loop where we calculate `elapsed`, we use the delta timer, as follows:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在计算`elapsed`的循环中，我们使用delta定时器，如下所示：
- en: '[PRE63]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, replace the reading of the accelerometer with code to update the fusion
    with the delta time so that it makes its calculations, as follows:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，用代码替换加速度计的读数，以更新融合的delta时间，使其进行计算，如下所示：
- en: '[PRE64]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can now fetch pitch-and-roll values from the `fusion` object, as follows:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以从`fusion`对象中获取俯仰和滚转值，如下所示：
- en: '[PRE65]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Upload `robot_imu.py`, `delta_timer.py` and `plot_pitch_and_roll.py` to the
    robot.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`robot_imu.py`、`delta_timer.py`和`plot_pitch_and_roll.py`上传到机器人。
- en: Run `vpython plot_pitch_and_roll.py`, again and point your browser at port `9020`
    on the robot.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行`vpython plot_pitch_and_roll.py`，并将你的浏览器指向机器人的`9020`端口。
- en: Superficially, it should look similar to the accelerometer pitch-and-roll graph
    in *Figure 16.9*. However, as you move the robot around, you should notice that
    there is far less noise—the graph is smoother—and that when you place the robot
    down or hold it still, it levels off. It should quickly account for rapid turns.
    The system is smooth and accurate!
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上，它应该看起来与*图16.9*中的加速度计俯仰和滚转图相似。然而，当你移动机器人时，你应该注意到噪声少得多——图形更平滑——并且当你放下机器人或保持它静止时，它会水平。它应该能够快速处理快速转弯。系统平稳且准确！
- en: Troubleshooting
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'If you have issues, try these troubleshooting checks:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有问题，尝试以下故障排除检查：
- en: As always, if you see syntax errors or strange behavior, check the code carefully.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总是如此，如果你看到语法错误或异常行为，请仔细检查代码。
- en: If things move strangely, ensure you are using `0.95` (and not `95`) for the
    filter value.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果出现异常移动，确保你使用的是`0.95`（而不是`95`）作为滤波器值。
- en: Ensure you've uploaded all the files.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你已经上传了所有文件。
- en: This system will need a second or two after the graph starts to settle.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个系统在图形开始后需要一两秒钟才能稳定下来。
- en: You've now seen how to get an accurate and smooth pitch and roll from these
    sensors. A robot on wheels may not encounter many reasons to use pitch and roll,
    but one of them will be to make a compass work. Let's dig further into the magnetometer.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了如何从这些传感器获取准确和平滑的俯仰和滚转。一个轮式机器人可能不会遇到很多需要使用俯仰和滚转的原因，但其中之一将是使指南针工作。让我们进一步探讨磁力计。
- en: Detecting a heading with the magnetometer
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用磁力计检测航向
- en: We saw in [*Chapter 12*](B15660_12_Final_ASB_ePub.xhtml#_idTextAnchor251), *IMU
    Programming with Python*, how to plot a vector from the magnetometer, and how
    magnetic metal (such as bits of steel and iron) will interfere with it. Even the
    pin headers on the IMU board interfere. We can calibrate to compensate for this.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [*第12章*](B15660_12_Final_ASB_ePub.xhtml#_idTextAnchor251)，*使用Python进行IMU编程*中看到了如何从磁力计绘制向量，以及磁性金属（如钢和铁的碎片）如何干扰它。甚至IMU板上的引脚头也会干扰。我们可以校准以补偿这一点。
- en: Getting *X*, *Y*, and *Z* components aren't that useful; we want a heading relative
    to a magnetic North. We can see how to use this for precise turns.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 *X*，*Y* 和 *Z* 分量并不那么有用；我们想要一个相对于磁北的航向。我们可以看到如何使用这个来进行精确的转向。
- en: This section needs a space, with very few magnets present. Laptops, phones,
    speakers, and disk drives interfere with this sensor. Use a map compass to reveal
    magnetic fields in your space. I recommend making the standoff *stalk* on the
    robot as long as the cable allows, putting more standoffs in; the robot's motors
    have a strong magnetic field of their own.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分需要留出空间，因为磁铁非常少。笔记本电脑、手机、扬声器和磁盘驱动器会干扰这个传感器。使用指南针来揭示你空间中的磁场。我建议将机器人的支架*茎*尽可能长，允许的话多放一些支架；机器人的电机本身就有很强的磁场。
- en: Please avoid starting with the robot facing South—this will cause some odd results,
    which we will investigate and fix later. Starting with the robot roughly North
    is a good idea.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 请避免以机器人面向南方开始——这会导致一些奇怪的结果，我们将在以后进行调查和修复。以机器人大致面向北方开始是个好主意。
- en: Calibrating the magnetometer
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 校准磁力计
- en: We are going to perform a calibration known as the **hard iron offset calculation**.
    Hard iron refers to any magnetic things near the magnetometer that move with it.
    We move the robot around to sample the field strength in each axis. We will use
    the middle of all readings for an axis to compensate, and add this to the IMU
    settings; this will seem similar to the gyroscope calibration but requires you
    to move the robot around.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将执行一个称为**硬铁偏移计算**的校准。硬铁指的是任何与磁力计一起移动的磁性物体。我们将机器人移动到各个轴上来采样场强。我们将使用轴上所有读数的中间值来进行补偿，并将其添加到IMU设置中；这看起来与陀螺仪校准相似，但需要你移动机器人。
- en: 'Let''s write the code, as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写代码，如下所示：
- en: 'Create a file named `magnetometer_calibration.py`, starting with imports and
    the `RobotImu` setup, as follows:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `magnetometer_calibration.py` 的文件，从导入和 `RobotImu` 设置开始，如下所示：
- en: '[PRE66]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We will find minimum and maximum vectors, as we did for the gyroscope, as illustrated
    in the following code snippet:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将找到最小和最大向量，就像我们在陀螺仪中做的那样，如下面的代码片段所示：
- en: '[PRE67]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We are going to show the system as a set of three scatter charts with colored-dot
    clusters. Each of the three clusters is a plot combining two axes: *xy*, *yz*,
    and *xz*. Our goal is to make the sets line up by calibrating the device, as follows:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将展示系统作为一组带有彩色点集群的三维散点图。这三个集群中的每一个都是一个结合了两个轴的图表：*xy*，*yz*和*zx*。我们的目标是通过对设备进行校准使这些集合对齐，如下所示：
- en: '[PRE68]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We start the main loop and read the magnetometer, as follows:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们开始主循环并读取磁力计，如下所示：
- en: '[PRE69]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, we update the minimums, in the same way we did for the gyroscope, as follows:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们以与陀螺仪相同的方式更新最小值，如下所示：
- en: '[PRE70]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'And then, we update the maximums, as follows:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们以同样的方式更新最大值，如下所示：
- en: '[PRE71]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We then calculate the offset in the same way as we did for the gyroscope, as
    follows:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后以与陀螺仪相同的方式计算偏移量，如下所示：
- en: '[PRE72]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This `print` statement shows the current values and offsets:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个 `print` 语句显示了当前值和偏移量：
- en: '[PRE73]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, we create the plots. They will guide you in getting enough calibration
    data and show where the axes do not line up. The code is shown in the following
    snippet:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建图表。它们将指导你获取足够的校准数据，并显示轴不对齐的地方。代码如下所示：
- en: '[PRE74]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Upload this and run it with VPython. You should see the following screen:![](img/B15660_16_11.jpg)
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传此文件并使用VPython运行它。你应该看到以下屏幕：![图片](img/B15660_16_11.jpg)
- en: Figure 16.11 – Initial magnetometer calibration screen
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图16.11 – 初始磁力计校准屏幕
- en: '*Figure 16.11* shows the clusters as three colored blobs—the bottom right is
    red, (for *xy*), the top is blue (for *yz*), and on the right is green (for *zx*).
    These clusters will start in a different position for you, depending on the orientation
    of your robot.'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图16.11* 展示了集群作为三个彩色块——右下角是红色（代表 *xy*），顶部是蓝色（代表 *yz*），右边是绿色（代表 *zx*）。这些集群在你这里将从一个不同的位置开始，这取决于你机器人的方向。'
- en: You need to move the robot around, rotating it slowly around the whole *y* axis
    (around the wheels). The green graph should be more like an ellipse, as illustrated
    in the following screenshot:![](img/B15660_16_12.jpg)
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要移动机器人，慢慢地围绕整个 *y* 轴（围绕轮子）旋转。绿色图表应该更像一个椭圆，如下面的截图所示！[](img/B15660_16_12.jpg)
- en: Figure 16.12 – The magnetometer partially calibrated
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图16.12 – 磁力计部分校准
- en: '*Figure 16.12* shows the ellipse for the green values, and more data for the
    red and blue scatter plots. The slower you are, the better the data is.'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图16.12* 展示了绿色值的椭圆，以及红色和蓝色散点图的更多数据。你越慢，数据越好。'
- en: Rotate the robot around the *x* axis (the length of the robot), and then around
    the *z* axis (around its height). The more angles you move it through, the better.
    Fill in the gaps by making 3D figures of 8\. Eventually, it should look like the
    graph in the following screenshot:![](img/B15660_16_13.jpg)
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将机器人绕 *x* 轴（机器人的长度）旋转，然后绕 *z* 轴（其高度）旋转。你移动的角度越多，越好。通过制作 8 的三维图形来填补空白。最终，它应该看起来像以下截图中的图形！[](img/B15660_16_13.jpg)
- en: 'Figure 16.13 – Magnetometer calibration: a good combination'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图16.13 – 磁力计校准：良好的组合
- en: '*Figure 16.13* shows how a good collection of data should look, with circles
    of red, green, and blue. Note that there are outliers due to waving the robot
    too close to other magnets—beware of these!'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图16.13* 展示了良好的数据集合应该看起来像什么，有红色、绿色和蓝色的圆圈。注意，由于机器人太靠近其他磁铁而摆动，存在异常值——小心这些！'
- en: You can close the browser now, having collected a load of calibration data.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以关闭浏览器了，因为你已经收集了大量校准数据。
- en: 'The console will show the calibration offsets, as follows:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制台将显示校准偏移量，如下所示：
- en: '[PRE75]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: At the start, those offsets change a lot; however, as you collect more data,
    they will settle and stabilize, even when the magnetometer readings are changing.
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 开始时，这些偏移量变化很大；然而，随着你收集更多数据，它们将稳定下来，即使磁力计读数在变化。
- en: We now have some calibration numbers; my example gave `21.15, 3.15, 0.225`.
    Let's make sure that everyone has some values.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一些校准数字；我的例子给出了 `21.15, 3.15, 0.225`。让我们确保每个人都有一组值。
- en: Troubleshooting
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'This calibration may not have worked—let''s see why, as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这种校准可能不起作用——让我们看看原因如下：
- en: If the numbers don't appear to be settling, continue moving the robot. You must
    try to do full 360-degree movements with it to get a full range.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数字看起来没有稳定下来，继续移动机器人。你必须尝试用它进行完整的 360 度运动以获得完整的范围。
- en: If strange dots appear outside of the circle, move somewhere else and restart
    the calibration—this is likely to be a magnetic field where you are testing, and
    will throw your results off.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果奇怪的点出现在圆圈之外，请移动到其他地方并重新开始校准——这很可能是你测试时的磁场，并会影响你的结果。
- en: There is a possibility your browser will get slow or run out of memory trying
    to do this—while I say move slowly, you cannot put this aside while running as
    it will continue adding dots.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有可能你的浏览器在尝试这样做时会变慢或耗尽内存——虽然我说要慢慢来，但你不能在运行时将其搁置一边，因为它会继续添加点。
- en: If you don't get circles at all—lines or small patches—double-check that you
    have the right plot combinations of *xy*, *yz*, and *zx*.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你完全没有得到圆圈——线条或小块——请确保你有正确的 *xy*、*yz* 和 *zx* 绘图组合。
- en: You should now be getting calibration offsets. Let's use these values to line
    up the scatter plots.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该正在获取校准偏移量。让我们使用这些值来对齐散点图。
- en: Testing the calibration values
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试校准值
- en: 'To see if these are effective we''ll put them back into the code, and the same
    operation should show the dot clusters lining up. It starts by allowing us to
    set offsets in the `RobotImu` interface. Proceed as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看看这些是否有效，我们将它们放回代码中，并且相同的操作应该显示点簇对齐。它首先允许我们在 `RobotImu` 接口中设置偏移量。按照以下步骤进行：
- en: Open up the `robot_imu.py` file.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `robot_imu.py` 文件。
- en: 'In the `__init__` method, we need to store the offsets. I''ve highlighted the
    new code, as follows:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `__init__` 方法中，我们需要存储偏移量。我已经突出显示了新的代码，如下所示：
- en: '[PRE76]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `read_magnetometer` method needs to subtract the magnetometer offsets,
    like this:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`read_magnetometer` 方法需要减去磁力计偏移量，如下所示：'
- en: '[PRE77]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Our scripts can now include an offset for the magnetometer. We''ll put these
    in the same settings file we used for the gyroscope calibrations. Proceed as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将磁力计的偏移量包含在我们的脚本中。我们将把这些放在我们用于陀螺仪校准的相同设置文件中。按照以下步骤进行：
- en: Open `imu_settings.py`.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `imu_settings.py`。
- en: 'Add the magnetometer calibration readings from your robot, as follows:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式添加你的机器人上的磁力计校准读数：
- en: '[PRE78]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now, we can use them in our scatter plot. Open up `magnetometer_calibration.py`
    and add our settings to the imports, as follows:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在散点图中使用它们。打开`magnetometer_calibration.py`，并将我们的设置添加到导入中，如下所示：
- en: '[PRE79]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'When we have created our `RobotImu` we can apply the offset, like this:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们创建了我们的`RobotImu`后，我们可以应用偏移量，如下所示：
- en: '[PRE80]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Send the files to the robot, and rerun `magnetometer_calibration.py`. You''ll
    need to make rotations and figures of 8 again to get many sample points at different
    orientations. When you have collected the data you should have overlapping circles,
    as depicted in the following screenshot:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件发送到机器人，并重新运行`magnetometer_calibration.py`。你需要再次进行旋转和8字形图样，以在不同方向上获得许多样本点。当你收集了数据后，你应该有重叠的圆圈，如下面的截图所示：
- en: '![](img/B15660_16_14.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_16_14.jpg)'
- en: Figure 16.14 – Calibrated magnetometer
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.14 – 校准磁力计
- en: '*Figure 16.14* shows the red, blue, and green circles superimposed. Congratulations—you
    have calibrated your magnetometer!'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16.14*显示了叠加的红色、蓝色和绿色圆圈。恭喜你——你已经校准了你的磁力计！'
- en: With your calibrated magnetometer, we can try further experiments with more
    useful values. But first, let's troubleshoot any problems.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的校准磁力计，我们可以尝试进行更多有用值的进一步实验。但首先，让我们排除任何问题。
- en: What to do if the circles aren't together
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果圆圈没有在一起，应该怎么做
- en: 'You may have reached this point, and the circles are not converging. Try these
    troubleshooting steps if this is the case:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经到达了这个点，但圆圈没有收敛。如果出现这种情况，请尝试以下故障排除步骤：
- en: You will need to rerun the calibration code. Before you do so, comment out the
    line that applies (sets) the offsets on the `RobotImu` class. Running the calibration
    code when you have offsets active will cause it to offset incorrectly.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要重新运行校准代码。在这样做之前，请注释掉应用于`RobotImu`类的偏移量应用（设置）行。在偏移量激活时运行校准代码会导致它偏移错误。
- en: Check your calibration and IMU code carefully for errors.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仔细检查你的校准和IMU代码，确保没有错误。
- en: Ensure there are no strong magnets or big chunks of metal near the robot—speakers
    or hard disks, for example. Try to do this about a meter away from such things.
    Even your laptop or mobile phone can interfere.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在机器人附近没有强磁铁或大块金属——例如扬声器或硬盘。尽量在离这些物体大约一米的地方做这个。甚至你的笔记本电脑或手机也可能产生干扰。
- en: Ensure you go through each axis slowly and try the figure of 8\. Keep going
    until you can see three ellipses.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你缓慢地通过每个轴，并尝试8字形图样。继续这样做，直到你能看到三个椭圆。
- en: You can use the console output, rotating the robot and moving around in every
    orientation, and then seeing if the offset values output here settle.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用控制台输出，旋转机器人，并在每个方向上移动，然后看看这里输出的偏移值是否稳定。
- en: When the outputs settle, try applying the offset again, and run the calibration
    to see if the circles converge.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当输出稳定后，再次尝试应用偏移量，并运行校准以查看圆圈是否收敛。
- en: After going through these, you should have the calibration values you need to
    continue. Let's put this back into the vector output we had and determine a heading.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些步骤后，你应该有了继续所需的校准值。让我们将其放回我们已有的矢量输出中，并确定航向。
- en: Getting a rough heading from the magnetometer
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从磁力计获取粗略航向
- en: 'Now that we''ve got calibration settings, we can start using magnetometer readings
    to estimate where North is, like a compass. The words *heading* and *yaw* mean
    the same thing —which way we face relative to a reference point—in this case,
    magnetic North. Let''s see how we can do this. Have a look at the following screenshot:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经获得了校准设置，我们可以开始使用磁力计读数来估计北方在哪里，就像指南针一样。*航向*和*yaw*意味着同一件事——相对于参考点的方向——在这种情况下，是磁北。让我们看看我们如何做到这一点。看看下面的截图：
- en: '![](img/B15660_16_15.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_16_15.jpg)'
- en: Figure 16.15 – Getting an approximate heading from the magnetometer
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.15 – 从磁力计获取近似航向
- en: '*Figure 16.15* shows a method we will build. It takes the magnetometer with
    calibration data applied and uses `atan2`, as we did with the gyroscope to approximate
    the heading. We can also add a rough compass with it too.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16.15*显示了我们将构建的方法。它使用校准数据应用了磁力计，并使用`atan2`，就像我们使用陀螺仪来近似航向一样。我们也可以添加一个粗略的指南针。'
- en: 'Let''s make this, as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这样做：
- en: 'Create a `plot_mag_heading.py` file. Start with the imports, as follows:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`plot_mag_heading.py`文件。从导入开始，如下所示：
- en: '[PRE81]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We can initialize the `RobotImu` with the settings, like this:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以用设置初始化`RobotImu`，如下所示：
- en: '[PRE82]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'To make a compass display, we need a dial (cylinder) and needle (arrow) in
    red, as follows:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要制作指南针显示，我们需要一个红色刻度盘（圆柱体）和指针（箭头），如下所示：
- en: '[PRE83]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Next, let''s make a graph to show the heading, and a delta timer for elapsed
    time, as follows:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们制作一个图表来显示航向，以及一个用于显示经过时间的delta计时器，如下所示：
- en: '[PRE84]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We start the main loop with a rate and fetch the elapsed time, as follows:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们以速率启动主循环并获取经过时间，如下所示：
- en: '[PRE85]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now, we read the magnetometer by running the following command:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们通过运行以下命令来读取磁力计：
- en: '[PRE86]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We can take the *xy* plane and find the `atan2` function of these values of
    this to get a heading, as follows:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以取*xy*平面，并找到这些值的`atan2`函数以获得航向，如下所示：
- en: '[PRE87]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Then, we plot this on the graph in degrees, like this:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们以度为单位在图表上绘制这个，如下所示：
- en: '[PRE88]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We can also set the needle axis to our direction, using `sin`/`cos` to convert
    it back into a unit direction, as follows:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用`sin`/`cos`将针轴设置为我们的方向，将其转换回一个单位方向，如下所示：
- en: '[PRE89]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Save, upload, and run this in VPython. Send your browser to port `9020` on the
    robot.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存，上传并在VPython中运行此代码。将你的浏览器发送到机器人的`9020`端口。
- en: 'If you rotate the robot around, you will see a display like this:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你围绕机器人旋转，你会看到如下显示：
- en: '![](img/B15660_16_16.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_16_16.jpg)'
- en: Figure 16.16 – Magnetometer heading estimate
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.16 – 磁力计航向估计
- en: '*Figure 16.16* shows a compass, with the top being what the robot perceives
    as North, and a red arrow. Below this is a blue graph, ranging between + and –180
    degrees. As you move the robot, you will see this move, with 0 degrees being North.
    You will need the robot to be on a flat surface, though.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16.16*显示了一个指南针，顶部是机器人感知的北方，以及一个红色箭头。下面是一个蓝色图表，范围在+和-180度之间。当你移动机器人时，你会看到这个移动，0度是北方。不过，你需要确保机器人位于一个平坦的表面上。'
- en: Note that the compass is reading where North is relative to the robot—not where
    the robot is relative to North!
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，指南针是读取相对于机器人的北方，而不是机器人相对于北方的位置！
- en: This output is starting to appear reasonable. It can point North and make some
    compass measurements, and we have a heading.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出开始看起来合理。它可以指向北方并进行一些指南针测量，我们有一个航向。
- en: It is a little chaotic, and you can make it incorrect by any pitch or roll.
    Again, by fusing this data with data from the other sensors, we can improve this.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点混乱，任何俯仰或横滚都可能使其错误。再次，通过将此数据与其他传感器的数据融合，我们可以改进这一点。
- en: Combining sensors for orientation
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合传感器进行定位
- en: We've seen how we combined the accelerometer and gyroscope to get smooth readings
    for pitch and roll. We can combine the sensors again to correctly orient and smooth
    the magnetometer readings too. This system allows us to approximate the absolute
    orientation of the robot.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何将加速度计和陀螺仪结合起来，以获得平稳的俯仰和横滚读数。我们还可以再次结合这些传感器，以正确地定位并平滑磁力计的读数。这个系统使我们能够近似机器人的绝对方向。
- en: 'Take a look at the following data flow to see what we are doing—it builds on
    the previous stages:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下数据流以了解我们在做什么——它是基于之前阶段的：
- en: '![](img/B15660_16_17.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_16_17.jpg)'
- en: Figure 16.17 – Fusing all three sensors
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.17 – 融合所有三个传感器
- en: '*Figure 16.17* starts on the left with data from our previous stages. We have
    the filtered pitch and roll in gray because it''s also an output. There''s the
    calibrated gyroscope yaw, delta time, and also the calibrated magnetometer as
    inputs. The filtered pitch and roll go through the tilt-compensate box, where
    we rotate the magnetometer vector. The magnetometer data then goes through an
    *xy*-to-polar box, using the `atan2` function to get a heading.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16.17*从左侧开始，显示我们之前阶段的数据。我们有灰色的滤波俯仰和横滚，因为它也是一个输出。有校准后的陀螺仪偏航、delta时间和校准后的磁力计作为输入。滤波后的俯仰和横滚通过倾斜补偿框，在那里我们旋转磁力计向量。磁力计数据然后通过一个*xy*-到极坐标框，使用`atan2`函数来获得航向。'
- en: Above this, the calibrated gyroscope yaw and delta time go into an integrator,
    which adds to a previous yaw reading. The integrator and magnetometer heading
    output go into a complementary filter, with the integrator output being dominant.
    This filter output is then a heading/yaw output, which will be stable and quick
    to respond, and will return to the absolute heading. We now have three angles—pitch,
    roll, and yaw!
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之上，校准后的陀螺仪偏航和delta时间进入一个积分器，它将添加到之前的偏航读数。积分器和磁力计航向输出进入一个互补滤波器，其中积分器的输出占主导地位。这个滤波器的输出是一个航向/偏航输出，它将稳定且快速响应，并返回到绝对航向。我们现在有三个角度——俯仰、横滚和偏航！
- en: Let's modify the code to do this, as follows;
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改代码来实现这一点，如下所示；
- en: Open up `robot_imu.py` and head to the `ImuFusion` class.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`robot_imu.py`并转到`ImuFusion`类。
- en: 'We will need to convert back to radians, so we need to add this to the imports
    from VPython, as follows:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将其转换回弧度，因此我们需要将此添加到从VPython导入的内容中，如下所示：
- en: '[PRE90]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In the `__init__` method, we should add a variable to store the yaw in, as
    follows:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`__init__`方法中，我们应该添加一个变量来存储偏航，如下所示：
- en: '[PRE91]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: We are going to use the same filter for now.
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在将使用相同的滤波器。
- en: 'In the `update` method, after calculating the pitch and roll, add the following
    line to get the magnetometer reading:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法中，在计算俯仰和滚转之后，添加以下行以获取磁力计读数：
- en: '[PRE92]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The `mag` variable is a vector. We rotate this using pitch and tilt to level
    the *xy* components, as follows:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mag`变量是一个向量。我们使用俯仰和倾斜来旋转这个向量，以使*xy*分量水平，如下所示：'
- en: '[PRE93]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We can now calculate the magnetometer yaw from this, as follows:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以从这个计算磁力计偏航，如下所示：
- en: '[PRE94]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'To stabilize this, we can now use the complementary filter with the gyroscope,
    as follows:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了稳定它，我们现在可以使用互补滤波器与陀螺仪，如下所示：
- en: '[PRE95]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The `self.yaw` value will now have the compensated yaw (or heading) value,
    allowing this IMU to act as a compass. To make use of it, let''s visualize it
    in three ways—as a graph, a compass, and the movement of the robot. Proceed as
    follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.yaw`值现在将具有补偿后的偏航（或航向）值，使这个IMU可以作为指南针使用。为了使用它，让我们以三种方式可视化它——作为图形、指南针和机器人的运动。按照以下步骤进行：'
- en: 'Put this in a new file called `visual_fusion.py`. The code will be very familiar.
    Only the magnetometer offsets and yaw values are new. The imports are shown in
    the following code snippet:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此代码放入一个名为`visual_fusion.py`的新文件中。代码将非常熟悉。只有磁力计偏移量和偏航值是新的。导入如下代码片段所示：
- en: '[PRE96]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Prepare the `RobotImu` with magnetometer offsets, and initialize `fusion`,
    as follows:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备带有磁力计偏移量的`RobotImu`，并初始化`fusion`，如下所示：
- en: '[PRE97]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We are going to use a VPython canvas for the virtual robot, and a separate
    one for the compass. Each canvas lets us contain a 3D scene. Let''s make the current
    canvas a robot view and put it on the left. The robot model will be associated
    with this. The code is shown in the following snippet:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用一个VPython画布来表示虚拟机器人，并为指南针使用一个单独的画布。每个画布让我们包含一个3D场景。让我们将当前画布设置为机器人视图并将其放在左侧。机器人模型将与这个视图相关联。代码如下所示：
- en: '[PRE98]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'To accompany the robot view, we''ll create a `compass` canvas, using the same
    cylinder and arrow as previously. Note that the most recent canvas is associated
    with the shapes created after it. The code is shown in the following snippet:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了配合机器人视图，我们将创建一个`指南针`画布，使用与之前相同的圆柱和箭头。请注意，最新的画布与之后创建的形状相关联。代码如下所示：
- en: '[PRE99]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Set up graphs for pitch, roll, and yaw, as follows:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下设置俯仰、滚动和偏航的图形：
- en: '[PRE100]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Create a delta timer, start the loop, and fetch the time update, as follows:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个delta计时器，启动循环，并获取时间更新，如下所示：
- en: '[PRE101]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'We now update `fusion` with the time (it will read the IMU and perform calculations),
    as follows:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用时间更新`fusion`（它将读取IMU并执行计算），如下所示：
- en: '[PRE102]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Now, we need to reset the virtual robot model before we rotate it, as follows:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们旋转它之前，我们需要重置虚拟机器人模型，如下所示：
- en: '[PRE103]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'And then, we need to perform three rotations—roll, pitch, and yaw, as follows:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要执行三个旋转——滚动、俯仰和偏航，如下所示：
- en: '[PRE104]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'We position the compass needle—note that our yaw is in degrees, so we convert
    it, as follows:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定位指南针针——注意我们的偏航是以度为单位，因此我们需要将其转换，如下所示：
- en: '[PRE105]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Then, we plot the three-graph axes, as follows:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们绘制三个图形轴，如下所示：
- en: '[PRE106]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Upload `robot_imu.py` and `visual_fusion.py` to the robot. Start with `vpython
    visual_fusion.py` and point your browser at port `9020` on the robot.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`robot_imu.py`和`visual_fusion.py`上传到机器人。首先使用`vpython visual_fusion.py`，并将你的浏览器指向机器人的`9020`端口。
- en: 'You should see the visual robot, compass, and a graph for all three axes displayed,
    and each should be both relatively stable and responsive, as depicted in the following
    screenshot:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到可视化的机器人、指南针以及所有三个轴的图形显示，每个都应该既相对稳定又响应迅速，如以下截图所示：
- en: '![](img/B15660_16_18.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_16_18.jpg)'
- en: Figure 16.18 – Pitch, roll, and yaw graph
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.18 – 俯仰、滚动和偏航图形
- en: The graph in *Figure 16.18* is a screenshot of the display. In the top left
    is the virtual robot—you can change its view by right-clicking. The top left shows
    the compass. Below that is a scrolling pitch, yaw, and roll graph. The roll is
    in red, pitch is in green, and yaw is in blue. The graphs will initially settle
    and then match your robot movements. When moving in one axis there is a small
    effect on the others, but they can move independently.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16.18*中的图形是显示的截图。左上角是虚拟机器人——你可以通过右键点击来更改其视图。左上角显示指南针。下面是滚转、俯仰和偏航的滚动图形。滚转用红色表示，俯仰用绿色表示，偏航用蓝色表示。图形最初会稳定，然后匹配你的机器人运动。当在一个轴上移动时，对其他轴有轻微的影响，但它们可以独立移动。'
- en: At +/-180 degrees, the graph will misbehave though. Let's see how to fix that.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在±180度时，图表会表现不佳。让我们看看如何解决这个问题。
- en: Fixing the 180-degree problem
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决180度问题
- en: The fundamental thing to realize is that angles on a circle are cyclical; 200
    degrees and -160 degrees are equivalent, and -180 degrees and 180 degrees are
    also equal. We've not made the filter or code aware of this, so when we reach
    the 180-degree point and the `atan2` function is flipping between -179.988 and
    179.991 (or some similar very close mark), the graph becomes chaotic, treating
    the difference of less than 1 degree as 360 degrees, and then trying to filter
    between them.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 需要认识到的是，圆上的角度是循环的；200度和-160度是等效的，-180度和180度也是相等的。我们没有让过滤器或代码意识到这一点，所以当我们达到180度点，`atan2`函数在-179.988和179.991（或一些非常接近的标记）之间翻转时，图表变得混乱，将小于1度的差异视为360度，然后尝试在这两者之间进行过滤。
- en: 'This problem needs some changes to fix it. First, we can state that we intend
    angles to be numerically below 180 and above -180 and constrain them this way.
    Since we intend to use the complementary filter with angles, we can specialize
    it, as follows:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要进行一些更改。首先，我们可以声明我们希望角度数值在-180度以下和180度以上，并以这种方式约束它们。由于我们打算使用角度的互补滤波器，我们可以对其进行特殊化，如下所示：
- en: 'At the top of `robot_imu.py`, inside the `ComplementaryFilter` class, let''s
    add a method to format the angle, like this:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`robot_imu.py`的顶部，在`ComplementaryFilter`类内部，让我们添加一个格式化角度的方法，如下所示：
- en: '[PRE107]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'If the angle is below -180, we want to wrap it around by adding `360`, as follows:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果角度低于-180度，我们希望通过加上`360`将其绕回，如下所示：
- en: '[PRE108]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'If the angle is above 180, we wrap it around by subtracting `360`, as follows:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果角度大于180度，我们将通过减去`360`将其绕回，如下所示：
- en: '[PRE109]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'We will replace the inside of the `filter` function with something to constrain
    these angles more intelligently. When we filter, we start by formatting the incoming
    angles, as follows:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将用某种更智能地约束这些角度的方法来替换`filter`函数的内部。当我们进行过滤时，我们首先按照以下方式格式化传入的角度：
- en: '[PRE110]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'We also want to put the filtered angles in the same range. If there is a difference
    of more than 350 degrees, we can assume that something has wrapped around; so,
    we add 360 to the lowest one to filter them together, as follows:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望将过滤后的角度放在相同的范围内。如果差异超过350度，我们可以假设某些东西已经绕回；因此，我们将最低的一个加上360度来过滤它们，如下所示：
- en: '[PRE111]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'This operation could leave an answer outside of the range. So, we format it
    back, like this:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个操作可能会得到一个超出范围的答案。因此，我们将其格式化回，如下所示：
- en: '[PRE112]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: This filter is in use already, so we can rerun `visual_fusion.py` and try turning
    back through 180 degrees again. When you point your browser at the port, after
    settling, the robot there should be rotating with yours—and settling, not drifting!
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个过滤器已经在使用中，所以我们可以重新运行`visual_fusion.py`并尝试再次通过180度。当你将浏览器指向端口时，在稳定后，那里的机器人应该会随着你的旋转而旋转——并且稳定，不会漂移！
- en: Note that this system still doesn't deal well with facing South when it starts.
    We've solved at least one problem with the system and smoothed out its flaws.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个系统在启动时处理面向南方的情况仍然不太好。我们已经至少解决了系统的一个问题，并平滑了其缺陷。
- en: 'This behavior is exciting: you can now get a robot on screen to mirror how
    you rotate it. However, while moving on the screen is fun, we''d like to see this
    used in the real world. Let''s engage some motors!'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为很令人兴奋：你现在可以在屏幕上得到一个机器人来镜像你的旋转。然而，尽管在屏幕上移动很有趣，但我们希望看到它在现实世界中得到应用。让我们启动一些电机！
- en: Driving a robot from IMU data
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从IMU数据驱动机器人
- en: In previous chapters, we saw how to use the PID algorithm, and in this chapter,
    how to detect a pitch, roll, and yaw from a magnetometer. Our robot can't move
    its pitch or roll, but it can change its heading.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何使用PID算法，在本章中，我们将学习如何从磁力计检测俯仰、滚转和偏航。我们的机器人不能改变其俯仰或滚转，但它可以改变其航向。
- en: 'In this demonstration, we''ll get the robot to stay on course—to try to track
    North regardless of where we turn it. Let''s see how. Have a look at the following
    diagram:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中，我们将让机器人保持在航向上——尝试无论我们将其转向何方都能追踪北方。让我们看看如何。看一下以下图表：
- en: '![](img/B15660_16_19.jpg)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15660_16_19.jpg)'
- en: Figure 16.19 – Drive to heading behavior
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.19 – 航向驱动行为
- en: '*Figure 16.19* shows the flow of data. The left of the diagram starts with
    a measured heading, and a heading setpoint going into a PID—the error value will
    be the difference between the two. The measured heading has come from the **IMU
    + Fusion** algorithm. We use the PID output to drive the motors so that they move
    at a fixed speed plus or minus the value, so the robot will turn to reduce the
    error. The robot moving will feed back into the **IMU + Fusion** algorithm, looping
    through the PID.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16.19*显示了数据流。图的左侧从测量的航向开始，航向设定点进入PID——误差值将是两者的差值。测量的航向来自**IMU + 融合**算法。我们使用PID输出来驱动电机，使它们以固定速度加减该值移动，这样机器人就会转向以减少误差。机器人的移动将反馈到**IMU
    + 融合**算法中，通过PID循环。'
- en: 'Let''s take the preceding flow and use it to build the code, as follows:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用前面的流程来构建代码，如下所示：
- en: 'Start a `drive_north_behavior.py` file with the following imports:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以以下导入开始`drive_north_behavior.py`文件：
- en: '[PRE113]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'We now initialize the `RobotImu`, `fusion`, and the `DeltaTimer`, as follows:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在初始化`RobotImu`、`fusion`和`DeltaTimer`，如下所示：
- en: '[PRE114]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'We can then set up a PID (or PI) controller and the robot, as follows:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以设置PID（或PI）控制器和机器人，如下所示：
- en: '[PRE115]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'And then, a couple of constants—the robot''s base speed, and the heading setpoint
    in degrees from North, as illustrated in the following code snippet:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，几个常数——机器人的基本速度，以及从北方起度的航向设定点，如下面的代码片段所示：
- en: '[PRE116]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The main loop here updates the timer and IMU fusion. Note in the following
    code snippet that there''s not a visual rate here:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里的主要循环更新计时器和IMU融合。注意在下面的代码片段中，这里没有视觉速率：
- en: '[PRE117]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'We now calculate the error, and feed the PID with that and the delta time,
    as follows:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在计算误差，并将该误差和delta时间输入PID，如下所示：
- en: '[PRE118]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'We print the values to debug, and set our motor speeds, as follows:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们打印值以进行调试，并设置电机速度，如下所示：
- en: '[PRE119]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Upload this to the robot, turn on the motors, and run with regular Python 3\.
    The robot will try to drive North. If you turn it off course it will correct back
    to North, and the more you turn it, the faster the motors will try to turn back.
    Playing with this behavior is quite fun!
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 将此上传到机器人，打开电机，用常规Python 3运行。机器人将尝试向北行驶。如果你偏离航线，它将纠正回北方，而你转得越多，电机尝试转回的速度就越快。玩这个行为相当有趣！
- en: Press *Ctrl* + *C* to stop this when you are done, and play with different heading
    set points.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后按 *Ctrl* + *C* 停止，并尝试不同的航向设定点。
- en: In this section, you've reinforced building data flow diagrams and writing code
    from them. You've further demonstrated that by converting sensor data to a number
    like this, you can build a PID-based behavior with it. You've then taken the heading
    that we've calculated and used it with the PID to create compass-based movement
    from your robot.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你通过构建数据流图和从它们编写代码来巩固了这些技能。你通过将传感器数据转换为这样的数字，展示了如何使用它构建基于PID的行为。然后你使用了我们计算出的航向，并用它和PID一起创建从你的机器人来的基于指南针的运动。
- en: Summary
  id: totrans-473
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you've seen how to combine the IMU sensors to approximate an
    absolute orientation in space. You've seen how to render these in graphs and how
    to display them onscreen with a virtual robot. You've then seen how to hook this
    sensor system up to a PID controller and motor to get the robot to drive.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你看到了如何将IMU传感器组合起来以近似空间中的绝对方向。你看到了如何在图表中呈现这些信息，以及如何使用虚拟机器人将它们显示在屏幕上。然后你看到了如何将这个传感器系统连接到PID控制器和电机，以使机器人行驶。
- en: You've learned a little of the math needed to convert between vector components
    and angles, in 3D, along with how to use complementary filters to compensate for
    noise in one system and drift in another. You've started to see multiple sensors
    fused together to make inferences about the world. Your block diagram and data
    flow skills have been exercised, and you have had more practice with the PID algorithm.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学到了一些必要的数学知识，用于在3D空间中转换向量分量和角度，以及如何使用互补滤波器来补偿一个系统中的噪声和另一个系统中的漂移。你已经开始看到多个传感器融合在一起，以对世界做出推断。你的框图和数据流技能得到了锻炼，你在PID算法方面也有了更多的实践。
- en: In the next chapter, we will look at how you can control your robot and choose
    behaviors from a menu with a smartphone.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用智能手机控制你的机器人，并从菜单中选择行为。
- en: Exercises
  id: totrans-477
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Here are some ideas to further your understanding, and give you some ideas
    for more interesting things to do with the concepts from this chapter:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些想法可以帮助你进一步理解，并给你一些关于如何使用本章概念做更有趣的事情的想法：
- en: A reader can use more colors and complicated shapes to make a better robot model.
    It's not the purpose of this chapter, but it is a fun and rewarding way to get
    more familiar with VPython.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读者可以使用更多颜色和复杂的形状来制作更好的机器人模型。这并非本章的目的，但这是一个有趣且有益的方法，可以让你更熟悉VPython。
- en: Our magnetometer settings were hardcoded, going into a Python file. It is good
    practice to load settings from a data file. A good starting point can be found
    at [http://zetcode.com/python/yaml/](http://zetcode.com/python/yaml/).
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的磁力计设置是硬编码的，直接写入Python文件中。从数据文件中加载设置是一种良好的实践。一个良好的起点可以在[http://zetcode.com/python/yaml/](http://zetcode.com/python/yaml/)找到。
- en: Could the visual robot be used to display or debug the other sensors and integrations?
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能否使用视觉机器人来显示或调试其他传感器和集成？
- en: Could you combine the absolute positioning here with the encoders to make a
    square with very accurate turns?
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能否将这里的绝对定位与编码器结合起来，以实现非常精确的转弯的方形？
- en: Further reading
  id: totrans-483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information on the topics covered in this chapter, refer to the following:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章涵盖的主题的更多信息，请参考以下内容：
- en: 'The **World Wide Web Consortium** (**W3C**) has a guide on magnetometer devices
    in browsers, which makes for interesting reading on techniques, but also on how
    code on a smartphone might be able to perform these same algorithms to get the
    phone orientation: [https://www.w3.org/TR/magnetometer](https://www.w3.org/TR/magnetometer).'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**万维网联盟**（**W3C**）有一份关于浏览器中磁力计设备的指南，它不仅对技术进行了有趣的阅读，还介绍了智能手机上的代码可能如何执行这些相同的算法以获取手机方向：[https://www.w3.org/TR/magnetometer](https://www.w3.org/TR/magnetometer).'
- en: 'I''ve mentioned the `atan2` function a lot; this page has further information
    on it: [https://en.wikipedia.org/wiki/Atan2](https://en.wikipedia.org/wiki/Atan2).'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我多次提到了`atan2`函数；这个页面有关于它的更多信息：[https://en.wikipedia.org/wiki/Atan2](https://en.wikipedia.org/wiki/Atan2).
- en: 'I recommend Paul McWhorter''s Arduino experiments with an IMU, and his introduction
    to VPython—his guide was an instrumental part in the research for this book: [https://toptechboy.com/arduino-based-9-axis-inertial-measurement-unit-imu-based-on-bno055-sensor/](https://toptechboy.com/arduino-based-9-axis-inertial-measurement-unit-imu-based-on-bno055-sensor/).'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我推荐保罗·麦克沃特（Paul McWhorter）的基于IMU的Arduino实验，以及他对VPython的介绍——他的指南是本书研究过程中的一个关键部分：[https://toptechboy.com/arduino-based-9-axis-inertial-measurement-unit-imu-based-on-bno055-sensor/](https://toptechboy.com/arduino-based-9-axis-inertial-measurement-unit-imu-based-on-bno055-sensor/).
- en: 'This paper takes things a bit further and introduces a **Global Positioning
    System** (**GPS**) for further sensor fusion: [https://www.researchgate.net/publication/51873462_Data_Fusion_Algorithms_for_Multiple_Inertial_Measurement_Units](https://www.researchgate.net/publication/51873462_Data_Fusion_Algorithms_for_Multiple_Inertial_Measurement_Units).'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本文将内容进一步拓展，引入了一个**全球定位系统**（**GPS**）以实现更进一步的传感器融合：[https://www.researchgate.net/publication/51873462_Data_Fusion_Algorithms_for_Multiple_Inertial_Measurement_Units](https://www.researchgate.net/publication/51873462_Data_Fusion_Algorithms_for_Multiple_Inertial_Measurement_Units).
- en: 'If you wish to dig deeper into sensor fusion, and algorithms to combine them
    while filtering errors, Kalman filters are the way to go. This article is a starting
    point: [https://towardsdatascience.com/sensor-fusion-part-1-kalman-filter-basics-4692a653a74c](https://towardsdatascience.com/sensor-fusion-part-1-kalman-filter-basics-4692a653a74c).'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想深入了解传感器融合，以及如何在滤波误差的同时将它们结合起来的算法，卡尔曼滤波器是最佳选择。这篇文章是一个起点：[https://towardsdatascience.com/sensor-fusion-part-1-kalman-filter-basics-4692a653a74c](https://towardsdatascience.com/sensor-fusion-part-1-kalman-filter-basics-4692a653a74c).
