- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Creating End-to-End spaCy Workflows with Weasel
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Weasel创建端到端spaCy工作流程
- en: In this chapter, we will explore how to create end-to-end NLP workflows using
    spaCy and its companion tool, **Weasel** . Originally a part of spaCy, Weasel
    has now become a standalone library, meaning you can also use it for other projects
    that are not created with spaCy.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何使用spaCy及其配套工具**Weasel**创建端到端NLP工作流程。最初是spaCy的一部分，Weasel现在已成为一个独立的库，这意味着您也可以将其用于不是用spaCy创建的其他项目。
- en: '**Data Version Control** ( **DVC** ) has an ecosystem of solutions for data/model
    versioning and experiment tracking, enhancing collaboration and experiment management.
    By integrating Weasel with DVC, we ensure our projects are efficiently versioned
    and tracked, improving organization and reliability.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据版本控制**（**DVC**）提供了一套针对数据/模型版本控制和实验跟踪的解决方案，增强了协作和实验管理。通过将Weasel与DVC集成，我们确保我们的项目能够高效地进行版本控制和跟踪，提高组织和可靠性。'
- en: In this chapter, we will start by cloning and running a project template with
    Weasel, following the best software engineering practices to ensure a reproducible
    and well-structured workflow. We will then adapt this template for a different
    use case and, finally, we will explore how to use DVC to track and manage trained
    models, enabling efficient collaboration. This approach will allow us to create
    robust NLP pipelines, ready for production and teamwork.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先使用Weasel克隆和运行项目模板，遵循最佳软件工程实践以确保可重复和结构良好的工作流程。然后我们将为此模板适应不同的用例，最后我们将探讨如何使用DVC跟踪和管理训练好的模型，从而实现高效的协作。这种方法将使我们能够创建健壮的NLP管道，为生产和工作团队做好准备。
- en: 'We’re going to cover these main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主要主题：
- en: Cloning and running a project template with Weasel
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Weasel克隆和运行项目模板
- en: Modifying a project template for a different use case
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为不同用例修改项目模板
- en: Managing models with the DVC Studio model registry
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DVC Studio模型注册管理模型
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will be using the spaCy, Weasel, and DVC libraries. The
    chapter code can be found at [https://github.com/PacktPublishing/Mastering-spaCy-Second-Edition](https://github.com/PacktPublishing/Mastering-spaCy-Second-Edition)
    .
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用spaCy、Weasel和DVC库。本章代码可以在[https://github.com/PacktPublishing/Mastering-spaCy-Second-Edition](https://github.com/PacktPublishing/Mastering-spaCy-Second-Edition)找到。
- en: Cloning and running a project template with Weasel
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Weasel克隆和运行项目模板
- en: The **spacy weasel clone** command clones a project template from a Git repository.
    It uses spaCy’s project template repo ( [https://github.com/explosion/projects](https://github.com/explosion/projects)
    ) by default, but you can provide any other repo you have access to (public or
    private) using the **--** **repo** option.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**spacy weasel clone**命令从Git仓库克隆一个项目模板。默认情况下，它使用spaCy的项目模板仓库（[https://github.com/explosion/projects](https://github.com/explosion/projects)），但您可以使用**--repo**选项提供您有权访问的任何其他仓库（公开或私有）。'
- en: 'In this chapter, we will use the **categorization of emotions in Reddit posts**
    (also referred to as **text classification** ) project as our project template.
    Let’s go ahead and clone the project:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用**Reddit帖子情感分类**（也称为**文本分类**）项目作为我们的项目模板。让我们继续并克隆项目：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command creates a **textcat_goemotions** folder in the current directory.
    The **project.yml** file defines everything related to the project. This includes
    assets and custom commands. The main sections of the **project.yml** files are
    as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在当前目录中创建一个**textcat_goemotions**文件夹。**project.yml**文件定义了与项目相关的所有内容。这包括资产和自定义命令。**project.yml**文件的主要部分如下：
- en: '**title** : You guessed right, this defines the title of the project.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**title**：没错，这定义了项目的标题。'
- en: '**description** : An optional project description.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**description**：可选的项目描述。'
- en: '**vars** : A dictionary of variables for paths, URLs, and scripts, which can
    be overridden via the CLI.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vars**：一个包含路径、URL和脚本的变量字典，可以通过CLI进行覆盖。'
- en: '**env** : A dictionary mapping variables to environment names, allowing project
    scripts to use values such as **${env.name}** from environment variables.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**env**：一个将变量映射到环境名称的字典，允许项目脚本使用环境变量中的值，例如**${env.name}**。'
- en: '**directories** : A list of directories to be created within the project, automatically
    generated by spaCy if they don’t exist.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**directories**：要在项目中创建的目录列表，如果不存在，则由spaCy自动生成。'
- en: '**assets** : A list of assets to be fetched, each defined by a URL or local
    path, a destination within the project, and an optional checksum for verification.
    You can also specify a Git repository with **repo** , **branch** , and **path**
    to download assets directly from Git.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资产**：要获取的资产列表，每个资产由一个URL或本地路径、项目内的目标位置以及可选的校验和定义。您还可以通过指定**repo**、**branch**和**path**来指定Git仓库，直接从Git下载资产。'
- en: '**commands** : A command specifies how to run the project steps. It usually
    specifies how to run a Python script. Each command is specified with **script**
    , **deps** , and **outputs** . **deps** define the files the command depends on,
    and **outputs** define the files the command produces. This lets spaCy determine
    when to re-run a command if a dependency changed.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令**：命令指定了如何运行项目步骤。它通常指定如何运行Python脚本。每个命令都使用**script**、**deps**和**outputs**指定。**deps**定义了命令所依赖的文件，而**outputs**定义了命令生成的文件。这允许spaCy确定何时重新运行命令，如果依赖项已更改。'
- en: '**workflows** : Workflows define a list of commands that should be executed
    in order.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作流程**：工作流程定义了一个应该按顺序执行的命令列表。'
- en: 'Now that we have cloned the template, the next step is to fetch the assets.
    The **spacy weasel assets** command downloads all the assets defined in the **assets**
    section of **project.yml** . Let’s download the assets:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经克隆了模板，下一步是获取资产。**spacy weasel assets**命令下载**project.yml**中**assets**部分定义的所有资产。让我们下载这些资产：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This project has four assets: a file with the categories to train and three
    files with data, one for training, one for development, and one for testing. The
    data is in **.tsv** format, so we need to convert it into **.spacy** binary format.
    The **scripts/convert_corpus.py** script does that. The **project.yml** file has
    a command named **preprocess** that we can use to run this script. Let’s see how
    this command is defined:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目有四个资产：一个包含训练类别的文件和三个数据文件，一个用于训练，一个用于开发，一个用于测试。数据是**.tsv**格式，因此我们需要将其转换为**.spacy**二进制格式。**scripts/convert_corpus.py**脚本执行这个操作。**project.yml**文件中有一个名为**preprocess**的命令，我们可以使用它来运行这个脚本。让我们看看这个命令是如何定义的：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The command specifies the assets in the **deps** keys (because we need them
    to run the code) and the outputs the code generates. To run this command, we can
    use **spacy project run** and the name of the command, like this: **spacy project
    run preprocess** . This command creates **train.spacy** , **dev.spacy** , and
    **test.spacy** inside the **/** **corpus** folder.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 命令指定了**deps**键中的资产（因为我们需要它们来运行代码）以及代码生成的输出。要运行此命令，我们可以使用**spacy project run**和命令名称，例如：**spacy
    project run preprocess**。此命令在**corpus**文件夹内创建**train.spacy**、**dev.spacy**和**test.spacy**。
- en: 'The **all** workflow calls the **preprocess** , **train** , **evaluate** ,
    and **package** commands in order. This is useful so we don’t have to call each
    command manually. Let’s try running this workflow:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**all**工作流程按顺序调用**preprocess**、**train**、**evaluate**和**package**命令。这样很有用，因为我们不需要手动调用每个命令。让我们尝试运行这个工作流程：'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Figure 9* *.1* displays the command outputs. Weasel verified that **deps**
    of the **preprocess** command didn’t change, so it skipped this step.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9* *.1*显示了命令输出。Weasel验证了**preprocess**命令的**deps**没有更改，因此跳过了这一步。'
- en: '![Figure 9.1 – Outputs after running the all workflow](img/B22441_09_1.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 运行所有工作流程后的输出](img/B22441_09_1.jpg)'
- en: Figure 9.1 – Outputs after running the all workflow
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 运行所有工作流程后的输出
- en: The **visualize** command uses **Streamlit** and **spacy-streamlit** to serve
    a web app to interact with the model. We can run this command with **weasel run
    visualize** . *Figure 9* *.2* shows the web app interface. We will learn how to
    use spaCy with Streamlit in [*Chapter 11*](B22441_11.xhtml#_idTextAnchor143) .
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**visualize**命令使用**Streamlit**和**spacy-streamlit**来提供用于与模型交互的Web应用程序。我们可以使用**weasel
    run visualize**运行此命令。*图9* *.2*显示了Web应用程序界面。我们将在[*第11章*](B22441_11.xhtml#_idTextAnchor143)中学习如何使用spaCy与Streamlit一起使用。'
- en: '![Figure 9.2 – Streamlit interface to interact with the model](img/B22441_09_2.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 与模型交互的Streamlit界面](img/B22441_09_2.jpg)'
- en: Figure 9.2 – Streamlit interface to interact with the model
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 与模型交互的Streamlit界面
- en: With all that, we have successfully used the project template to recreate this
    text classification pipeline. What if we have another dataset and need to execute
    these same project steps? We can simply reuse the template and adapt it to our
    needs. Let’s learn how to do it in the next section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些，我们已经成功使用项目模板来重新创建这个文本分类流程。如果我们有另一个数据集并且需要执行这些相同的项目步骤怎么办？我们可以简单地重用模板并调整以满足我们的需求。让我们在下一节中学习如何做到这一点。
- en: Modifying a project template for a different use case
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改项目模板以适应不同的用例
- en: 'To reuse the project template for a different use case, the first thing we’ll
    do is clone the project, specifying a different **dest** folder. Let’s do that:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要为不同的用例重用项目模板，我们首先会克隆项目，指定一个不同的**dest**文件夹。让我们这样做：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will create a **textcat_github_issues** folder. The new use case uses
    annotated data from **Prodigy** and we should predict whether a GitHub issue title
    is about documentation or not. The original project is available here: [https://github.com/explosion/projects/tree/v3/tutorials/textcat_docs_issues](https://github.com/explosion/projects/tree/v3/tutorials/textcat_docs_issues)
    . The goal of this section is to learn how to reuse a project template, so we
    will modify the **textcat_goemotions** project to this domain.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个**textcat_github_issues**文件夹。新的用例使用来自**Prodigy**的标注数据，我们应该预测GitHub问题标题是否关于文档。原始项目在此处可用：[https://github.com/explosion/projects/tree/v3/tutorials/textcat_docs_issues](https://github.com/explosion/projects/tree/v3/tutorials/textcat_docs_issues)。本节的目标是学习如何重用项目模板，因此我们将修改**textcat_goemotions**项目以适应这个领域。
- en: 'First, we should update **title** , **description** , and **vars** with the
    information for this new GitHub issues project. The assets of the GitHub issues
    are in the **.jsonl** format, so we will need to modify the command to convert
    the data to **.spacy** format. We have three files: **train.jsonl** , **dev.jsonl**
    , and **eval.jsonl** . Let’s first modify the assets key of **project.yml** to
    point to these files:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该使用这个新GitHub问题项目的信息更新**title**、**description**和**vars**。GitHub问题的资产以**.jsonl**格式存在，因此我们需要修改命令以将数据转换为**.spacy**格式。我们有三个文件：**train.jsonl**、**dev.jsonl**和**eval.jsonl**。让我们首先修改**project.yml**中的assets键，使其指向这些文件：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we can download the assets using the **assets** command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用**assets**命令下载资产：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s see a snippet of the training data:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看训练数据的一个片段：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This format is different from **textcat_goemotions** , so we will need to create
    a different **convert_corpus.py** script. We will use **srsly** (a package that
    bundles some of the best Python serialization libraries) to read the **.jsonl**
    data and **typer** (a library for building CLI applications) to specify the arguments
    of the script. Let’s write the script to do that:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种格式与**textcat_goemotions**不同，因此我们需要创建一个不同的**convert_corpus.py**脚本。我们将使用**srsly**（一个捆绑了一些最好的Python序列化库的包）来读取**.jsonl**数据，并使用**typer**（一个用于构建CLI应用程序的库）来指定脚本的参数。让我们编写一个脚本来完成这个任务：
- en: 'First, we import the libraries and define the variables for the directories:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入库并定义目录的变量：
- en: '[PRE8]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To run the script, we should specify the directory to read the assets, the
    directory to save the corpus, and the language of the model we’ll use to create
    the **Doc** objects. With **typer** , we can do this by creating a function with
    these arguments:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行脚本，我们应该指定读取资产的目录、保存语料的目录以及我们将用于创建**Doc**对象的模型的语言。使用**typer**，我们可以通过创建一个具有这些参数的函数来完成此操作：
- en: '[PRE9]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The script should convert all the **train.jsonl** , **dev.json** , and **eval.jsonl**
    files, so we will need to loop through each file in **assets_dir** , and if it’s
    a **.jsonl** file, we will create a **DocBin** object:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本应该转换所有的**train.jsonl**、**dev.json**和**eval.jsonl**文件，因此我们需要遍历**assets_dir**中的每个文件，如果它是一个**.jsonl**文件，我们将创建一个**DocBin**对象：
- en: '[PRE10]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For each **jsonl_file** , we will build the **Doc** object, set the **cats**
    parameter, and add it to the **DocBin** object. Finally, we save this **DocBin**
    object to disk:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个**jsonl_file**，我们将构建**Doc**对象，设置**cats**参数，并将其添加到**DocBin**对象中。最后，我们将此**DocBin**对象保存到磁盘：
- en: '[PRE11]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The last step is to tie this script with Typer. We do that with **typer.run(main)**
    :'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是将此脚本与Typer绑定。我们通过**typer.run(main)**来完成：
- en: '[PRE12]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we can save this new **convert_corpus.py** script and run the following
    command:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以保存这个新的**convert_corpus.py**脚本并运行以下命令：
- en: '[PRE13]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Figure 9* *.3* shows the output of this command.'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图9* *.3*显示了此命令的输出。'
- en: '![Figure 9.3 – Weasel output after running the preprocess command](img/B22441_09_3.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 运行preprocess命令后的Weasel输出](img/B22441_09_3.jpg)'
- en: Figure 9.3 – Weasel output after running the preprocess command
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 运行preprocess命令后的Weasel输出
- en: 'Weasel is saying that we’re missing an **assets/train.tsv** dependency. That’s
    because we didn’t update **deps** and **outputs** of the **preprocess** command
    to work with this new use case. Let’s do it now:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Weasel表示我们缺少**assets/train.tsv**依赖项。这是因为我们没有更新**preprocess**命令的**deps**和**outputs**以适应这个新用例。让我们现在做这件事：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now you can save these changes and try running the **preprocess** command again.
    The script creates the **.spacy** files in the **/corpus** directory. Alright,
    let’s also update the dependencies of the **evaluate** command and run the **all**
    workflow to train, evaluate, and create a package for this GitHub issues project:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您可以保存这些更改并再次尝试运行**preprocess**命令。该脚本在**/corpus**目录中创建**.spacy**文件。好的，让我们也更新**evaluate**命令的依赖项并运行**all**工作流程来训练、评估并为这个GitHub问题项目创建一个包：
- en: '[PRE15]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Figure 9* *.4* displays the evaluation results for this pipeline.'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 9* *.4* 显示了此管道的评估结果。'
- en: '![Figure 9.4 – Evaluation results](img/B22441_09_4.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 评估结果](img/B22441_09_4.jpg)'
- en: Figure 9.4 – Evaluation results
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 评估结果
- en: 'Could we get better results using BERT? Let’s change this in the **vars** section
    of **project.yml** :'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否使用BERT获得更好的结果？让我们在**project.yml**的**vars**部分中更改这一点：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'I had trouble running the training with the batch configuration defined on
    the **configs/bert.cfg** file, so let’s change it to **spacy.batch_by_padded.v1**
    :'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我在**configs/bert.cfg**文件上定义的批处理配置运行训练时遇到了麻烦，所以让我们将其更改为**spacy.batch_by_padded.v1**：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we can run the workflow again:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以再次运行工作流程：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Figure 9* *.5* displays the evaluation results of this model, which performs
    better than the first one.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9* *.5* 显示了此模型的评估结果，其性能优于第一个。'
- en: '![Figure 9.5 – Results using BERT](img/B22441_09_5.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 使用 BERT 的结果](img/B22441_09_5.jpg)'
- en: Figure 9.5 – Results using BERT
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 使用 BERT 的结果
- en: Now that we have the trained models, we can use Weasel to upload them to remote
    storage. Let’s do that in the next section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了训练好的模型，我们可以使用Weasel将它们上传到远程存储。让我们在下一节中这样做。
- en: Uploading and downloading project outputs to remote storage
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上传和下载项目输出到远程存储
- en: You can use the **spacy project push** command to store project outputs in remote
    storage, enabling you to share pipeline packages, collaborate with your team,
    or cache results to avoid redundant tasks. The **spacy project pull** command
    retrieves any missing outputs from remote storage. Remotes are specified in the
    **remotes** section of **project.yml** . To configure the remote storage, you
    can list one or more destinations in the **remotes** section of the **project.yml**
    file, mapping a string name to the storage URL. spaCy uses **cloudpathlib** to
    communicate with remote storage, allowing the use of any protocol supported by
    **cloudpathlib** , including S3, Google Cloud Storage, Azure Blob Storage, and
    the local filesystem.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用**spacy project push**命令将项目输出存储在远程存储中，这样您就可以共享管道包、与团队协作或缓存结果以避免重复任务。**spacy
    project pull**命令从远程存储检索任何缺失的输出。远程存储在**project.yml**的**remotes**部分中指定。要配置远程存储，您可以在**project.yml**文件的**remotes**部分中列出一个或多个目的地，将字符串名称映射到存储URL。spaCy使用**cloudpathlib**与远程存储通信，允许使用**cloudpathlib**支持的任何协议，包括S3、Google
    Cloud Storage、Azure Blob Storage和本地文件系统。
- en: The **push** command uploads all files or directories listed in **outputs**
    section of commands to remote storage. Outputs are archived and compressed before
    upload. Weasel uses a hash of the command string and dependencies and a hash of
    the file contents. This means **push** should never overwrite a file in your remote
    storage. If all hashes match, the contents are the same and nothing happens. If
    the contents differ, the new version of the file is uploaded.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**push**命令将命令中**outputs**部分列出的所有文件或目录上传到远程存储。上传前，输出会被归档和压缩。Weasel使用命令字符串和依赖项的哈希以及文件内容的哈希。这意味着**push**永远不会覆盖远程存储中的文件。如果所有哈希匹配，内容相同，则不会发生任何操作。如果内容不同，则上传新版本的文件。'
- en: The **pull** command downloads all files or directories listed as outputs for
    commands unless they are already present locally. When searching for files in
    the remote storage, **pull** will consider not only the output path but also the
    command string and dependency hashes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**pull**命令下载命令中列出的所有文件或目录，除非它们已经存在于本地。在远程存储中搜索文件时，**pull**将考虑输出路径、命令字符串和依赖项哈希。'
- en: We’ve trained two models for the GitHub issues use case. If we were in a production
    setting, we would need to manage these trained models. The straightforward use
    case would be to change between them in production. DVC is a library that helps
    us connect to versioned data sources and code with pipelines, track experiments,
    and register models. Weasel was inspired by DVC and we can use the **spacy weasel
    dvc** command to auto-generate a DVC configuration file. With this file, we can
    manage the spaCy project like any other DVC project. In the next section, we will
    use the DVC Studio model registry to catalog our **Machine Learning** ( **ML**
    ) models and manage them in production.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为GitHub问题用例训练了两个模型。如果我们处于生产环境中，我们需要管理这些训练好的模型。最直接的应用场景是在生产环境中在这两个模型之间切换。DVC是一个库，它帮助我们通过管道连接到版本化的数据源和代码，跟踪实验，并注册模型。Weasel受到了DVC的启发，我们可以使用**spacy
    weasel dvc**命令来自动生成一个DVC配置文件。有了这个文件，我们可以像管理其他DVC项目一样管理spaCy项目。在下一节中，我们将使用DVC Studio模型注册表来编目我们的**机器学习**（**ML**）模型，并在生产环境中管理它们。
- en: Managing models with the DVC model registry
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用DVC模型注册表管理模型
- en: DVC is an open source command-line tool that helps us develop reproducible ML
    projects. Weasel itself was inspired by DVC ( [https://x.com/honnibal/status/1316792615996592133](https://x.com/honnibal/status/1316792615996592133)
    ). It comes with tools to version data and models, track experiments, compare
    data, and share experiments. In this section, we’re going to use the model registry
    in **DVC Studio** , a web application that enables teams to run and track experiments
    and manage the model life cycle.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: DVC是一个开源的命令行工具，帮助我们开发可重复的机器学习项目。Weasel本身受到了DVC的启发（[https://x.com/honnibal/status/1316792615996592133](https://x.com/honnibal/status/1316792615996592133)）。它包含版本化数据和模型、跟踪实验、比较数据和共享实验的工具。在本节中，我们将使用DVC
    Studio中的模型注册表，这是一个网络应用程序，它使团队能够运行和跟踪实验，并管理模型的生命周期。
- en: Under the hood, DVC Studio uses a command line called **Git Tag Ops** ( **GTO**
    ) for model registry actions. To work with DVC, it’s useful to learn more about
    **GitOps** . Let’s do this in the next section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，DVC Studio使用一个名为**Git Tag Ops**（**GTO**）的命令行来进行模型注册操作。要使用DVC，了解更多的**GitOps**很有用。让我们在下一节中这样做。
- en: What is GitOps?
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是GitOps？
- en: '**GitOps** is a set of practices that emphasizes the use of the Git version
    control system as the source of truth for declarative infrastructure and applications.
    It draws ideas from DevOps and infrastructure as code practices. The *GitOps WG*
    ( [https://opengitops.dev/](https://opengitops.dev/) ) defines four GitOps principles
    (v1.0.0):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**GitOps**是一组强调使用Git版本控制系统作为声明性基础设施和应用程序的真相来源的实践。它借鉴了DevOps和基础设施即代码实践的思想。*GitOps
    WG*（[https://opengitops.dev/](https://opengitops.dev/)）定义了四个GitOps原则（v1.0.0）：'
- en: '**Declarative** : In a GitOps-managed system, the desired state must be defined
    declaratively'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明式**：在GitOps管理的系统中，所需状态必须以声明性方式定义'
- en: '**Versioned and immutable** : The desired state is stored in a way that enforces
    immutability and versioning and retains a complete version history'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本化和不可变**：所需状态以强制不可变和版本化的方式存储，并保留完整的版本历史'
- en: '**Pulled automatically** : Software agents automatically pull the desired state
    declarations from the source'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动拉取**：软件代理自动从源拉取所需状态声明'
- en: '**Continuously reconciled** : Software agents constantly monitor the system
    and work to align it with the desired state'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续协调**：软件代理持续监控系统，并努力使其与所需状态保持一致'
- en: 'Let’s delve deeper into each principle in the following list:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地探讨以下列表中的每个原则：
- en: '**Principle 1 – declarative** : In practical terms, this means that all the
    configurations and settings for your infrastructure and applications are described
    in a declarative format, such as YAML or JSON files. Rather than writing scripts
    that perform a series of steps to reach the desired state, you define what the
    final state should look like. This is also the principle of **Weasel** for the
    **project.yml** file – it ensures that we have no hidden defaults. The configuration
    files serve as a blueprint for how your system should be configured.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原则1 – 声明式**：在实践中，这意味着你的基础设施和应用程序的所有配置和设置都描述在声明性格式中，例如YAML或JSON文件。而不是编写执行一系列步骤以达到所需状态的脚本，你定义最终状态应该是什么样子。这也是**Weasel**对**project.yml**文件的原则——它确保我们没有隐藏的默认值。配置文件充当了如何配置你的系统的蓝图。'
- en: '**Principle 2 – versioned and immutable** : This principle emphasizes that
    all configuration files (the declarative descriptions) should be stored in a Git
    repository. Git naturally supports versioning, allowing you to track changes over
    time. Immutability means that once a particular state is defined and committed,
    it shouldn’t be altered. If changes are necessary, a new version should be created.
    This practice ensures that you have a complete history of every change made to
    your configurations, making it easier to understand the evolution of your code
    and infrastructure and roll back to previous states if necessary. For example,
    if a new configuration breaks your application, you can quickly revert to the
    last known good configuration using Git’s version history.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原则 2 – 版本化和不可变**：这一原则强调所有配置文件（声明性描述）应存储在 Git 仓库中。Git 本身支持版本控制，允许您跟踪随时间的变化。不可变性意味着一旦定义并提交了特定状态，就不应对其进行更改。如果需要更改，应创建一个新的版本。这种做法确保您有配置所做每个更改的完整历史记录，使得理解代码和基础设施的演变以及必要时回滚到先前状态变得更容易。例如，如果新的配置破坏了您的应用程序，您可以使用
    Git 的版本历史快速回滚到最后已知的好配置。'
- en: '**Principle 3 – pulled automatically** : In a GitOps setup, when a new commit
    is detected, the GitOps agent should automatically pull the updated configuration
    files and apply the changes to the infrastructure or applications. This automation
    ensures that any updates made in the Git repository are promptly reflected in
    the actual running environment without manual intervention.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原则 3 – 自动拉取**：在 GitOps 设置中，当检测到新的提交时，GitOps 代理应自动拉取更新的配置文件并将更改应用到基础设施或应用程序。这种自动化确保了
    Git 仓库中进行的任何更新都能及时反映在实际运行环境中，无需人工干预。'
- en: '**Principle 4 – continuously reconciled** : The GitOps agents should continuously
    compare the actual state of your infrastructure and applications with the desired
    state defined in your Git repository. If there is a discrepancy between the two,
    the agents will try to reconcile them by making the necessary adjustments to bring
    the actual state in line with the desired state. This continuous reconciliation
    ensures that your system is always aligned with the configurations in Git. This
    principle ensures consistency and reliability, preventing drift between what is
    declared in Git and what is actually running in your environment.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原则 4 – 持续协调**：GitOps 代理应持续比较您基础设施和应用程序的实际状态与 Git 仓库中定义的期望状态。如果两者之间存在差异，代理将尝试通过进行必要的调整来使实际状态与期望状态一致。这种持续协调确保您的系统始终与
    Git 中的配置保持一致。这一原则确保了一致性和可靠性，防止了 Git 中声明的内容与您环境中实际运行的内容之间的偏差。'
- en: Let’s move on to DVC, addressing common data science and ML challenges next.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论 DVC，接下来将解决常见的数据科学和机器学习挑战。
- en: How DVC addresses common data science and ML challenges
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DVC 如何解决常见的数据科学和机器学习挑战
- en: 'Data science and ML projects often face challenges that can be effectively
    addressed using DVC and GitOps principles. Here are some common challenges and
    how these tools and principles can help solve them:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学和机器学习项目经常面临可以使用 DVC 和 GitOps 原则有效解决的问题。以下是一些常见挑战以及这些工具和原则如何帮助解决它们：
- en: '**Difficult sharing and collaboration** : Sharing datasets, models, and experiments
    among team members can be complicated, especially when dealing with large files
    or multiple versions, leading to duplicated work and errors. With DVC, we can
    use remote storage to track datasets and models just like we track code with Git.
    This allows team members to pull and push assets to make sure everyone is working
    with the same state.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**困难的数据共享和协作**：在团队成员之间共享数据集、模型和实验可能很复杂，尤其是在处理大文件或多个版本时，会导致重复工作和错误。使用 DVC，我们可以使用远程存储来跟踪数据集和模型，就像我们使用
    Git 跟踪代码一样。这允许团队成员拉取和推送资产，以确保每个人都在使用相同的状态。'
- en: '**Pipelines not reliable or not reproducible** : We usually start our project
    experiments in a Jupyter notebook. This is completely fine for data analysis and
    prototypes, but when the project grows (as we hope so), structure and automation
    become beneficial. Some requirements for structured pipelines include units of
    code as **.py** modules and managing configuration in dedicated files (to track
    parameters, file paths, etc.). DVC (and Weasel) perfectly creates a structure
    for us to create these reusable pipelines.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管道不可靠或不可重复**：我们通常在Jupyter笔记本中开始我们的项目实验。这对于数据分析和原型设计是完全可行的，但当项目增长（我们希望如此）时，结构和自动化变得有益。结构化管道的一些要求包括将代码单元作为**.py**模块，并在专用文件中管理配置（以跟踪参数、文件路径等）。DVC（和Weasel）为我们完美地创建了一个结构，以便我们可以创建这些可重用的管道。'
- en: '**Model metrics tracking** : Keeping a history of model performance metrics
    is crucial for understanding the evolution and effectiveness of models over time.
    DVC allows the storing and versioning of performance metrics along with models,
    facilitating the comparison of different versions and the analysis of improvements.
    With GitOps, these metrics can be integrated into CI/CD pipelines, ensuring that
    new model versions are always validated against previous versions before deployment.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型指标跟踪**：保留模型性能指标的历史记录对于理解模型随时间演化和有效性至关重要。DVC允许存储和版本控制性能指标，与模型一起，便于比较不同版本和分析改进。通过GitOps，这些指标可以集成到CI/CD管道中，确保在部署之前，新模型版本始终与旧版本进行验证。'
- en: 'By addressing these challenges with DVC and GitOps principles, data science
    and ML teams can achieve more reliable, reproducible, and scalable workflows.
    The benefits of implementing GitOps principles include the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用DVC和GitOps原则解决这些挑战，数据科学和机器学习团队可以实现更可靠、可重复和可扩展的工作流程。实施GitOps原则的好处包括以下内容：
- en: Increased developer and operational productivity
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高开发人员和运营效率
- en: Enhanced developer experience
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高开发者体验
- en: Improved stability
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高稳定性
- en: Consistency and standardization
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致性和标准化
- en: DVC integrates seamlessly with GitOps practices, so by using the tool, we get
    all these benefits. Now that we know what GitOps is and the challenges it addresses,
    let’s go ahead and convert our Weasel project to DVC and add our models to the
    model registry so we can share them.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: DVC与GitOps实践无缝集成，因此通过使用此工具，我们可以获得所有这些好处。既然我们已经了解了GitOps是什么以及它所解决的挑战，那么我们就继续将我们的Weasel项目转换为DVC，并将我们的模型添加到模型注册表中，以便我们可以共享它们。
- en: From Weasel to DVC
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Weasel到DVC
- en: 'The first step is to install DVC. DVC is a Python library, so we can carry
    out the installation using **pip** or **conda** :'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是安装DVC。DVC是一个Python库，因此我们可以使用**pip**或**conda**进行安装：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, inside the project directory, we can run **dvc init** to initialize a
    DVC project. There has to be a Git repository initialized in this directory. Let’s
    initialize the project:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在项目目录内，我们可以运行**dvc init**来初始化一个DVC项目。在这个目录中必须初始化一个Git仓库。让我们初始化项目：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The **dvc init** command creates three files: **.dvc/config** , **.dvc/.gitignore**
    , and **.dvcignore** . DVC provides access to external storage locations, allowing
    us to manage and share our data and ML models. It supports cloud providers such
    as Amazon S3, Microsoft Azure Blob Storage, and Google Cloud Storage, and self-hosted/on-premises
    options such as SSH and HDFS. In this chapter, we will use Google Drive as remote
    storage. For that, we need the folder ID of the Google Drive folder. The **dvc
    remote add** command adds the remote configuration to the **.dvc/config** file.
    Let’s do it:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**dvc init**命令创建三个文件：**.dvc/config**，**.dvc/.gitignore**，和**.dvcignore**。DVC提供了对外部存储位置的访问，使我们能够管理和共享我们的数据和机器学习模型。它支持云提供商，如Amazon
    S3、Microsoft Azure Blob Storage和Google Cloud Storage，以及自托管/本地选项，如SSH和HDFS。在本章中，我们将使用Google
    Drive作为远程存储。为此，我们需要Google Drive文件夹的文件夹ID。**dvc remote add**命令将远程配置添加到**.dvc/config**文件。让我们来做这件事：'
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The **gdrive_acknowledge_abuse** flag allows the download of files flagged as
    potentially abusive, such as containing malware or personal information, but only
    by the file’s owner when this parameter is enabled. Now, when we run **dvc pull**
    or **dvc push** to store or retrieve model artifacts using Google Drive as the
    remote storage, the browser will open a new window for authentication.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**gdrive_acknowledge_abuse**标志允许下载被标记为可能具有滥用行为的文件，例如包含恶意软件或个人信息，但只有当此参数启用时，文件的所有者才能下载。现在，当我们运行**dvc
    pull**或**dvc push**以使用Google Drive作为远程存储来存储或检索模型工件时，浏览器将打开一个新窗口进行身份验证。'
- en: Once DVC is configured, the **spacy project dvc** command auto-generates a **dvc.yaml**
    file from your **project.yml** . This lets you manage your spaCy project as a
    DVC repository, using the workflow defined in **project.yml** . In this chapter,
    we’re just going to use the model registry functionality, so let’s go ahead and
    see how to do that in the next section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了 DVC，**spacy project dvc** 命令会自动从你的 **project.yml** 文件中生成一个 **dvc.yaml**
    文件。这让你可以使用在 **project.yml** 中定义的工作流程来管理你的 spaCy 项目，因此在本章中，我们只是将要使用模型注册功能，让我们继续看看下一节如何操作。
- en: Creating a command to add the model to the model registry
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个将模型添加到模型注册表的命令
- en: 'To add the model to the model registry, we need to install the **DVCLive**
    Python package. DVCLive is a Python library for logging ML metrics and other metadata:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要将模型添加到模型注册表，我们需要安装 **DVCLive** Python 包。DVCLive 是一个用于记录机器学习指标和其他元数据的 Python
    库：
- en: 'Let’s install it:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们安装它：
- en: '[PRE22]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let’s revisit our **project.yml** Weasel file. We have the **all** workflow
    defined there with these commands:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下我们的 **project.yml** Weasel 文件。我们在那里定义了 **all** 工作流程，并包含以下命令：
- en: '[PRE23]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: What we’ll do is create three new commands, one to track the model with DVC,
    one to push the model to the remote storage, and one to add the model to the model
    registry.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要创建三个新的命令，一个用于使用 DVC 跟踪模型，一个用于将模型推送到远程存储，还有一个用于将模型添加到模型注册表中。
- en: 'To push the model to the remote storage, first we need to track it with DVC.
    We do this with **dvc add** . Let’s create the command inside **project.yml**
    :'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模型推送到远程存储，首先我们需要使用 DVC 来跟踪它。我们通过 **dvc add** 命令来完成这个操作。让我们在 **project.yml**
    文件中创建这个命令：
- en: '[PRE24]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let’s run this command with Weasel:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用 Weasel 运行这个命令：
- en: '[PRE25]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You should remove the **packages** folder from the root **.gitignore** file
    created by Weasel to add the model package to DVC (DVC will create a new **.gitignore**
    file inside the **model** folder).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从 Weasel 创建的根 **.gitignore** 文件中删除 **packages** 文件夹，以便将模型包添加到 DVC（DVC 将在
    **model** 文件夹内创建一个新的 **.gitignore** 文件）。
- en: The **dvc add** command creates a **.dvc** file for the artifact, and this artifact
    is then tracked with Git.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**dvc add** 命令为该工件创建一个 **.dvc** 文件，然后使用 Git 来跟踪这个工件。'
- en: 'Now we can create the command to add this model to Google Drive:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个将此模型添加到 Google Drive 的命令：
- en: '[PRE26]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can also run it with Weasel:'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们也可以使用 Weasel 运行它：
- en: '[PRE27]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The command will open the browser so we can authenticate with Google Drive.
    Now we are finally ready to create the command that adds the model to the DVC
    Studio model registry. To do that, we will create a new Python script. Let’s do
    it:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令会打开浏览器，以便我们可以使用 Google Drive 进行身份验证。现在，我们终于准备好创建一个将模型添加到 DVC Studio 模型注册表的命令。为此，我们将创建一个新的
    Python 脚本。让我们开始吧：
- en: 'First, we import the libraries:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入库：
- en: '[PRE28]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we create a **main()** function with the context manager block for the
    DVCLive logger and use the **log_artifact()** method to add the model:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个带有 DVCLive 日志记录器上下文管理器块的 **main()** 函数，并使用 **log_artifact()** 方法来添加模型：
- en: '[PRE29]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we add **typer.run(main)** to handle the command-line arguments:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将 **typer.run(main)** 添加来处理命令行参数：
- en: '[PRE30]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can save this script as **scripts/add_model_registry.py** . Now, we can
    create the command to run this script:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将这个脚本保存为 **scripts/add_model_registry.py**。现在，我们可以创建一个命令来运行这个脚本：
- en: '[PRE31]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We should now commit the **dvc.yaml** file that was created:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在应该提交创建的 **dvc.yaml** 文件：
- en: '[PRE32]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now you should go to [https://studio.iterative.ai/](https://studio.iterative.ai/)
    , connect with GitHub/GitLab/Bitbucket and import your Git repo. After doing that,
    you can click on the **Models** menu and see the model there. *Figure 9* *.6*
    shows this interface.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，你应该前往 [https://studio.iterative.ai/](https://studio.iterative.ai/)，使用 GitHub/GitLab/Bitbucket
    连接，并导入你的 Git 仓库。完成之后，你可以点击 **模型** 菜单，在那里可以看到模型。*图 9.6* 显示了这个界面。
- en: '![Figure 9.6 – DVC Studio Models](img/B22441_09_6.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – DVC Studio 模型](img/B22441_09_6.jpg)'
- en: Figure 9.6 – DVC Studio Models
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – DVC Studio 模型
- en: The next step is to register the model. Click on the model’s name to see the
    options displayed in *Figure 9* *.7* .
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是注册模型。点击模型名称，可以看到在 *图 9.7* 中显示的选项。
- en: '![Figure 9.7 – DVC Studio model options](img/B22441_09_7.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – DVC Studio 模型选项](img/B22441_09_7.jpg)'
- en: Figure 9.7 – DVC Studio model options
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – DVC Studio 模型选项
- en: Now, click on the blue **Register first version** button to choose a specific
    commit in our model development history and attach a version to it to make it
    easier to keep track of it. *Figure 9* *.8* shows the register model popup.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击蓝色的 **注册第一个版本** 按钮，选择我们模型开发历史中的一个特定提交，并将其附加到一个版本上，以便更容易跟踪它。*图 9.8* 显示了注册模型弹出窗口。
- en: '![Figure 9.8 – The DVC Studio register model options](img/B22441_09_8.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图9.8 – DVC Studio注册模型选项](img/B22441_09_8.jpg)'
- en: Figure 9.8 – The DVC Studio register model options
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – DVC Studio注册模型选项
- en: The model is now registered, and we can download it or assign it to life cycle
    stages. *Figure 9* *.9* shows those options.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 模型现在已注册，我们可以下载它或将它分配到生命周期阶段。*图9.9*显示了这些选项。
- en: '![Figure 9.9 – Ways to access the model with DVC Studio](img/B22441_09_9.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9 – 使用DVC Studio访问模型的方法](img/B22441_09_9.jpg)'
- en: Figure 9.9 – Ways to access the model with DVC Studio
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – 使用DVC Studio访问模型的方法
- en: 'When the model is assigned to a stage, it can automatically trigger actions
    in your CI/CD workflows, such as deploying the model to a new environment. You
    can learn more about that in the DVC documentation: [https://dvc.org/doc/start/model-registry/model-cicd](https://dvc.org/doc/start/model-registry/model-cicd)
    .'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当模型被分配到某个阶段时，它可以自动触发CI/CD工作流程中的操作，例如将模型部署到新的环境。你可以在DVC文档中了解更多信息：[https://dvc.org/doc/start/model-registry/model-cicd](https://dvc.org/doc/start/model-registry/model-cicd)。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to manage spaCy projects with Weasel. First,
    you cloned a project template from spaCy’s repository and ran it on your machine.
    Then, you used this same project structure to train a model for a dataset. After
    that, you saw how GitOps can address some data science and ML challenges and used
    DVC to register the model we’ve trained to share it with teammates or add a deploy
    setting to it. The goal of this chapter was to teach you how to manage NLP projects
    in a production setting.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用Weasel管理spaCy项目。首先，你从spaCy的仓库克隆了一个项目模板并在你的机器上运行它。然后，你使用相同的项目结构对一个数据集进行模型训练。之后，你看到了GitOps如何解决一些数据科学和机器学习挑战，并使用DVC注册了我们训练的模型以与队友分享，或者添加部署设置。本章的目标是教你如何在生产环境中管理NLP项目。
- en: In the next chapter, we will explore how to train a model for coreference resolution.
    This will involve understanding what coreference resolution is, why it is important
    in NLP, and how to implement it using spaCy.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何训练用于指代消解的模型。这包括理解什么是指代消解，为什么它在NLP中很重要，以及如何使用spaCy来实现它。
