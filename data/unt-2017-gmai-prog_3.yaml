- en: Implementing Sensors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现传感器
- en: In this chapter, we'll learn to implement AI behavior using the concept of a
    sensory system similar to what living entities have. As we discussed earlier,
    a character AI system needs to have awareness of its environment such as where
    the obstacles are, where the enemy it is looking for is, whether the enemy is
    visible in the player's sight, and so on. The quality of our NPC's AI completely
    depends on the information it can get from the environment. Nothing breaks the
    level of immersion in a game like an NPC getting stuck behind a wall. Based on
    the information the NPC can collect, the AI system can decide which logic to execute
    in response to that data. If the sensory systems do not provide enough data, or
    the AI system is unable to properly take action on that data, the agent can begin
    to glitch, or behave in a way contrary to what the developer, or more importantly
    the player, would expect. Some games have become infamous for their comically
    bad AI glitches, and it's worth a quick internet search to find some videos of
    AI glitches for a good laugh.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用类似于生物体所具有的感官系统概念来实现人工智能行为。正如我们之前讨论的，一个角色人工智能系统需要对其环境有所了解，例如障碍物的位置、正在寻找的敌人的位置、敌人是否在玩家的视野中，等等。我们NPC的人工智能质量完全取决于它从环境中获取的信息。没有任何事情能像NPC卡在墙后那样打破游戏的沉浸感。基于NPC可以收集的信息，人工智能系统可以决定对那些数据执行哪种逻辑。如果感官系统没有提供足够的数据，或者人工智能系统无法对那些数据采取适当的行动，代理可能会开始出现故障，或者以与开发者或更重要的是玩家期望相反的方式行事。有些游戏因其滑稽的糟糕人工智能故障而臭名昭著，快速进行一次网络搜索就能找到一些人工智能故障的视频，让人忍俊不禁。
- en: 'We can detect all the environment parameters and check them against our predetermined
    values if we want. But using a proper design pattern will help us maintain code
    and thus will be easy to extend. This chapter will introduce a design pattern
    that we can use to implement sensory systems. We will be covering:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想检测所有环境参数并检查它们是否与我们的预定值相符，我们可以做到。但是，使用适当的设计模式将帮助我们维护代码，从而更容易扩展。本章将介绍我们可以用来实现感官系统的一个设计模式。我们将涵盖：
- en: What sensory systems are
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 感官系统是什么
- en: Some of the different sensory systems that exist
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在的一些不同的感官系统
- en: How to set up a sample tank with sensing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置带有传感器的样本罐
- en: Basic sensory systems
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本感官系统
- en: Our agent's sensory systems should believably emulate real-world senses such
    as vision, sound, and so on, to build a model of its environment, much like we
    do as humans. Have you ever tried to navigate a room in the dark after shutting
    off the lights? It gets more and more difficult as you move from your initial
    position when you turned the lights off because your perspective shifts and you
    have to rely more and more on your fuzzy memory of the room's layout. While our
    senses rely on and take in a constant stream of data to navigate their environment,
    our agent's AI is a lot more forgiving, giving us the freedom to examine the environment
    at predetermined intervals. This allows us to build a more efficient system in
    which we can focus only on the parts of the environment that are relevant to the
    agent.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代理的感官系统应该能够逼真地模拟现实世界的感官，如视觉、听觉等，以构建其环境模型，就像我们作为人类所做的那样。你在关掉灯后尝试在黑暗中导航房间吗？当你从关灯时的初始位置移动时，这变得越来越困难，因为你的视角发生了变化，你必须越来越多地依赖对房间布局的模糊记忆。虽然我们的感官依赖于并吸收一个不断的数据流来导航它们的环境，但我们的代理的AI要宽容得多，它给了我们自由，可以在预定的间隔内检查环境。这使得我们能够构建一个更高效的系统，我们可以只关注对代理相关的环境部分。
- en: The concept of a basic sensory system is that there will be two components, `Aspect`
    and `Sense`. Our AI characters will have senses, such as perception, smell, and
    touch. These senses will look out for specific aspects such as enemies and bandits.
    For example, you could have a patrol guard AI with a perception sense that's looking
    for other game objects with an enemy aspect, or it could be a zombie entity with
    a smell sense looking for other entities with an aspect defined as a brain.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 基本感官系统的概念是它将包含两个组件，`Aspect`和`Sense`。我们的AI角色将具有感官，例如感知、嗅觉和触觉。这些感官将寻找特定的方面，如敌人和强盗。例如，你可以有一个具有感知感官的巡逻守卫AI，它在寻找具有敌人方面的其他游戏对象，或者它可能是一个具有嗅觉感官的僵尸实体，它在寻找被定义为大脑方面的其他实体。
- en: For our demo, this is basically what we are going to implement—a base interface
    called `Sense` that will be implemented by other custom senses. In this chapter,
    we'll implement perspective and touch senses. Perspective is what animals use
    to see the world around them. If our AI character sees an enemy, we want to be
    notified so that we can take some action. Likewise with touch, when an enemy gets
    too close, we want to be able to sense that, almost as if our AI character can
    hear that the enemy is nearby. Then we'll write a minimal `Aspect` class that
    our senses will be looking for.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的演示，这基本上是我们将要实现的内容——一个基础接口称为`Sense`，它将由其他自定义感官实现。在本章中，我们将实现视角和触觉感官。视角是动物用来观察周围世界的方式。如果我们的AI角色看到敌人，我们希望得到通知，以便我们可以采取一些行动。同样，对于触觉，当敌人过于接近时，我们希望能够感知到这一点，几乎就像我们的AI角色能听到敌人就在附近一样。然后我们将编写一个最小的`Aspect`类，我们的感官将寻找这个类。
- en: Cone of sight
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视野锥
- en: 'In the example provided in [Chapter 2](9e338555-162c-4ed0-a519-035cfcea94ce.xhtml)*,*
    *Finite State Machines and You*, we set up our agent to detect the player tank
    using line of sight, which is literally a line in the form of a raycast. A **raycast**
    is a feature in Unity that allows you to determine which objects are intersected
    by a line cast from a point toward a given direction. While this is a fairly efficient
    way to handle visual detection in a simple way, it doesn''t accurately model the
    way vision works for most entities. An alternative to using line of sight is using
    a cone-shaped field of vision. As the following figure illustrates, the field
    of vision is literally modeled using a cone shape. This can be in 2D or 3D, as
    appropriate for your type of game:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](9e338555-162c-4ed0-a519-035cfcea94ce.xhtml)*，*《有限状态机与您*，我们设置了我们的智能体，使用视线来检测玩家坦克，这实际上是一个以射线形式存在的线。**射线**是Unity中的一个功能，允许你确定哪些对象被从一点向给定方向发射的线投射所交叉。虽然这是一种以简单方式处理视觉检测的相当有效的方法，但它并不能准确模拟大多数实体视觉工作的方式。使用视线的替代方案是使用锥形视野。如图所示，视野实际上是用锥形形状来模拟的。这可以是2D或3D，根据你的游戏类型而定：
- en: '![](img/db1843c4-9f08-43a7-bb52-1b9718725497.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/db1843c4-9f08-43a7-bb52-1b9718725497.png)'
- en: The preceding figure illustrates the concept of a cone of sight. In this case,
    beginning with the source, that is, the agent's eyes, the cone grows, but becomes
    less accurate with distance, as represented by the fading color of the cone.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示说明了视野锥的概念。在这种情况下，从源开始，即智能体的眼睛，锥体逐渐增长，但随着距离的增加，其准确性降低，如锥体颜色逐渐变淡所示。
- en: The actual implementation of the cone can vary from a basic overlap test to
    a more complex realistic model, mimicking eyesight. In a simple implementation,
    it is only necessary to test whether an object overlaps with the cone of sight,
    ignoring distance or periphery. A complex implementation mimics eyesight more
    closely; as the cone widens away from the source, the field of vision grows, but
    the chance of getting to see things toward the edges of the cone diminishes compared
    to those near the center of the source.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 锥形的实际实现可以从基本的重叠测试到更复杂的现实模型，模仿视觉。在简单实现中，只需要测试一个对象是否与视野锥重叠，忽略距离或边缘。复杂实现更接近地模仿视觉；随着锥体从源向外扩展，视野增长，但看到锥体边缘事物的机会与源中心附近的事物相比减少。
- en: Hearing, feeling, and smelling using spheres
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用球体进行听觉、触觉和嗅觉
- en: One very simple yet effective way of modeling sounds, touch, and smell is via
    the use of spheres. For sounds, for example, we can imagine the center as being
    the source and the loudness dissipating the farther from the center the listener
    is. Inversely, the listener can be modeled instead of, or in addition to, the
    source of the sound. The listener's hearing is represented by a sphere, and the
    sounds closest to the listener are more likely to be "heard." We can modify the
    size and position of the sphere relative to our agent to accommodate feeling and
    smelling.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一种非常简单而有效的方式来模拟声音、触觉和嗅觉，就是通过使用球体。例如，对于声音，我们可以想象中心是声源，而响度随着听众离中心越远而逐渐消散。相反，听众可以被模拟，代替或补充声音源。听众的听觉通过一个球体来表示，离听众最近的声源更有可能被“听到”。我们可以修改球体的大小和位置相对于我们的智能体，以适应感觉和嗅觉。
- en: 'The following figure represents our sphere and how our agent fits into the
    setup:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了我们的球体以及我们的智能体如何适应这个设置：
- en: '![](img/ec1eded7-23cd-4bfd-94ba-cc68c8fc5769.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ec1eded7-23cd-4bfd-94ba-cc68c8fc5769.png)'
- en: As with sight, the probability of an agent registering the sensory event can
    be modified, based on the distance from the sensor or as a simple overlap event,
    where the sensory event is always detected as long as the source overlaps the
    sphere.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 就像视觉一样，根据传感器距离或简单的重叠事件（即只要源重叠球体，感官事件总是被检测到），可以修改代理注册感官事件的可能性。
- en: Expanding AI through omniscience
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过全知全能扩展人工智能
- en: In a nutshell, omniscience is really just a way to make your AI cheat. While
    your agent doesn't necessarily know everything, it simply means that they *can*
    know anything. In some ways, this can seem like the antithesis to realism, but
    often the simplest solution is the best solution. Allowing our agent access to
    seemingly hidden information about its surroundings or other entities in the game
    world can be a powerful tool to provide an extra layer of complexity.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，全知全能实际上只是让你的AI作弊的一种方式。虽然你的代理不一定知道一切，但这仅仅意味着他们*可以*知道任何事情。在某种程度上，这似乎与现实主义相反，但通常最简单的解决方案是最好的解决方案。让我们的代理访问其周围环境或游戏世界中看似隐藏的信息，可以是一个强大的工具，为游戏提供额外的复杂性。
- en: In games, we tend to model abstract concepts using concrete values. For example,
    we may represent a player's health with a numeric value ranging from 0 to 100\.
    Giving our agent access to this type of information allows it to make realistic
    decisions, even though having access to that information is not realistic. You
    can also think of omniscience as your agent being able to *use the force* or sense
    events in your game world without having to *physically* experience them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，我们倾向于使用具体值来建模抽象概念。例如，我们可能用一个从0到100的数值来表示玩家的健康。让我们的代理访问这类信息允许它做出现实的决定，即使获取这类信息在现实中并不现实。你也可以将全知全能视为你的代理能够*使用原力*或感知游戏世界中的事件，而无需*物理上*体验它们。
- en: While omniscience is not necessarily a specific pattern or technique, it's another
    tool in your toolbox as a game developer to cheat a bit and make your game more
    interesting by, in essence, bending the rules of AI, and giving your agent data
    that they may not otherwise have had access to through *physical* means.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然全知全能不一定是一个特定的模式或技术，但它作为游戏开发者工具箱中的另一个工具，可以稍微作弊一下，通过在本质上弯曲人工智能的规则，并给你的代理提供他们可能无法通过*物理*手段获得的数据，从而使你的游戏更有趣。
- en: Getting creative with sensing
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在感知方面发挥创意
- en: While cones, spheres, and lines are among the most basic ways an agent can see,
    hear, and perceive their environment, they are by no means the only ways to implement
    these senses. If your game calls for other types of sensing, feel free to combine
    these patterns. Want to use a cylinder or a sphere to represent a field of vision?
    Go for it. Want to use boxes to represent the sense of smell? Sniff away!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管锥形、球体和线条是代理可以看到、听到和感知其环境的最基本方式，但它们绝不是实现这些感官的唯一方式。如果你的游戏需要其他类型的感知，请随意组合这些模式。想要用圆柱体或球体来表示视野范围？那就这么做吧。想要用盒子来表示嗅觉？那就嗅吧！
- en: Using the tools at your disposal, come up with creative ways to model sensing
    in terms relative to your player. Combine different approaches to create unique
    gameplay mechanics for your games by mixing and matching these concepts. For example,
    a magic-sensitive but blind creature could completely ignore a character right
    in front of them until they cast or receive the effect of a magic spell. Maybe
    certain NPCs can track the player using smell, and walking through a collider
    marked *water* can clear the scent from the player so that the NPC can no longer
    track him. As you progress through the book, you'll be given all the tools to
    pull these and many other mechanics off—sensing, decision-making, pathfinding,
    and so on. As we cover some of these techniques, start thinking about creative
    twists for your game.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 利用你手中的工具，想出创造性的方法来根据你的玩家建模感知。通过混合和匹配这些概念，结合不同的方法为你的游戏创建独特的游戏机制。例如，一个对魔法敏感但失明的生物可以完全忽略他们面前的人物，直到他们施展或接收到魔法咒语的效果。也许某些NPC可以通过气味追踪玩家，而穿过标记为*水*的碰撞体可以清除玩家的气味，这样NPC就再也无法追踪他。随着你阅读本书的进展，你将获得所有实现这些和其他许多机制的工具——感知、决策、路径查找等等。在我们介绍这些技术的同时，开始思考你游戏中创意的变体。
- en: Setting up the scene
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置场景
- en: 'In order to get started with implementing the sensing system, you can jump
    right into the example provided for this chapter, or set up the scene yourself,
    by following these steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始实现感知系统，你可以直接跳到本章提供的示例，或者按照以下步骤自己设置场景：
- en: Let's create a few barriers to block the line of sight from our AI character
    to the tank. These will be short but wide cubes grouped under an empty game object
    called `Obstacles`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一些障碍物来阻挡AI角色到坦克的视线。这些障碍物将是短而宽的立方体，它们位于一个名为 `Obstacles` 的空游戏对象下。
- en: Add a plane to be used as a floor.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个用作地面的平面。
- en: Then, we add a directional light so that we can see what is going on in our
    scene.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加一个方向光，以便我们可以看到场景中正在发生的事情。
- en: As you can see in the example, there is a target 3D model, which we use for
    our player, and we represent our AI agent using a simple cube. We will also have
    a `Target` object to show us where the tank will move to in our scene.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，有一个目标3D模型，我们用它作为玩家，我们用一个简单的立方体来表示我们的AI代理。我们还将有一个 `Target` 对象来显示我们的坦克在场景中将移动到何处。
- en: 'For simplicity, our example provides a point light as a child of the `Target`
    so that we can easily see our target destination in the game view. Our scene hierarchy
    will look similar to the following screenshot after you''ve set everything up
    correctly:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们的示例提供了一个点光作为 `Target` 的子对象，这样我们就可以在游戏视图中轻松地看到我们的目标目的地。设置正确后，我们的场景层次结构将类似于以下截图：
- en: '![](img/ec3ecb5f-098e-4579-ac8e-10722262f860.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec3ecb5f-098e-4579-ac8e-10722262f860.png)'
- en: The scene hierarchy
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 场景层次结构
- en: 'Now we will position the tank, the AI character, and walls randomly in our
    scene. Increase the size of the plane to something that looks good. Fortunately,
    in this demo, our objects float, so nothing will fall off the plane. Also, be
    sure to adjust the camera so that we can have a clear view of the following scene:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将坦克、AI角色和墙壁随机地放置在我们的场景中。增加平面的尺寸，使其看起来更美观。幸运的是，在这个演示中，我们的对象可以漂浮，所以没有什么会从平面上掉下来。同时，确保调整相机，以便我们可以清楚地看到以下场景：
- en: '![](img/58a5d229-ccbe-48d9-b22a-5d1f383dddf2.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58a5d229-ccbe-48d9-b22a-5d1f383dddf2.png)'
- en: Our game scene
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏场景
- en: With the essential setup out of the way, we can begin tackling the code for
    driving the various systems.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成基本设置后，我们可以开始处理驱动各种系统的代码。
- en: Setting up the player tank and aspect
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置玩家坦克和视角
- en: Our `Target` object is a simple sphere game object with the mesh render removed,
    so that we end up with only the **Sphere Collider**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Target` 对象是一个简单的球体游戏对象，移除了网格渲染，因此我们最终只有 **Sphere Collider**。
- en: 'Look at the following code in the `Target.cs` file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下位于 `Target.cs` 文件中的代码：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You'll notice we left in an empty `Start` method in the code. While there is
    a cost in having empty `Start`, `Update`, and other `MonoBehaviour` events that
    don't do anything, we can sometimes choose to leave the `Start` method in during
    development, so that the component shows an enable/disable toggle in the inspector.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们在代码中留下了一个空的 `Start` 方法。虽然留下空的 `Start`、`Update` 和其他不执行任何操作的 `MonoBehaviour`
    事件会有一定的成本，但我们有时可以选择在开发过程中留下 `Start` 方法，以便在检查器中显示组件的启用/禁用切换。
- en: Attach this script to our `Target` object, which is what we assigned in the
    inspector to the `targetMarker` variable. The script detects the mouse click event
    and then, using a raycast, it detects the mouse click point on the plane in the
    3D space. After that, it updates the `Target` object to that position in the world
    space in the scene.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将此脚本附加到我们的 `Target` 对象上，这是我们分配给检查器中的 `targetMarker` 变量的对象。该脚本检测鼠标点击事件，然后使用射线投射，检测3D空间中的鼠标点击点。之后，它将
    `Target` 对象更新到场景中的世界空间中的该位置。
- en: A raycast is a feature of the Unity Physics API that shoots a virtual ray from
    a given origin towards a given direction, and returns data on any colliders hit
    along the way.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 射线投射是Unity物理API的一个功能，它从给定的起点向给定的方向发射一个虚拟射线，并返回沿途遇到的任何碰撞器的数据。
- en: Implementing the player tank
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现玩家坦克
- en: Our player tank is the simple tank model we used in [Chapter 2](9e338555-162c-4ed0-a519-035cfcea94ce.xhtml),
    *Finite State Machines and You*, with a kinematic rigid body component attached.
    The rigid body component is needed in order to generate trigger events whenever
    we do collision detection with any AI characters. The first thing we need to do
    is to assign the tag `Player` to our tank.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的玩家坦克是我们在 [第2章](9e338555-162c-4ed0-a519-035cfcea94ce.xhtml) 中使用的简单坦克模型，*有限状态机与您*，并附加了一个刚体组件。刚体组件是必需的，以便在与其他任何AI角色进行碰撞检测时生成触发事件。我们需要做的第一件事是将标签
    `Player` 分配给我们的坦克。
- en: The `isKinematic` flag in Unity's Rigidbody component makes it so that external
    forces are ignored, so that you can control the Rigidbody entirely from code or
    from an animation, while still having access to the Rigidbody API.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的Rigidbody组件中的`isKinematic`标志使得外部力被忽略，这样您就可以完全从代码或从动画中控制Rigidbody，同时仍然可以访问Rigidbody
    API。
- en: The tank is controlled by the `PlayerTank` script, which we will create in a
    moment. This script retrieves the target position on the map and updates its destination
    point and the direction accordingly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 坦克由`PlayerTank`脚本控制，我们将在稍后创建此脚本。此脚本检索地图上的目标位置，并相应地更新其目的地点和方向。
- en: 'The code in the `PlayerTank.cs` file is as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerTank.cs`文件中的代码如下：'
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](img/9d470de6-cccd-4cb1-b95d-38034bd5bff7.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9d470de6-cccd-4cb1-b95d-38034bd5bff7.png)'
- en: Properties of our tank object
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们坦克对象的属性
- en: The preceding screenshot shows us a snapshot of our script in the inspector
    once applied to our tank.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了我们的脚本在应用至坦克后的检查器快照。
- en: This script queries the position of the `Target` object on the map and updates
    its destination point and the direction accordingly. After we assign this script
    to our tank, be sure to assign our `Target` object to the `targetTransform` variable.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本查询地图上`目标`对象的位置，并相应地更新其目的地点和方向。在我们将此脚本分配给我们的坦克后，务必将我们的`目标`对象分配给`targetTransform`变量。
- en: Implementing the Aspect class
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Aspect类
- en: Next, let's take a look at the `Aspect.cs` class. `Aspect` is a very simple
    class with just one public enum of type `AspectTypes` called `aspectType`. That's
    all of the variables we need in this component. Whenever our AI character senses
    something, we'll check the  `aspectType` to see whether it's the aspect that the
    AI has been looking for.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下`Aspect.cs`类。`Aspect`是一个非常简单的类，只有一个名为`aspectType`的公共枚举类型属性。这就是我们在这个组件中需要的所有变量。每当我们的AI角色感知到某物时，我们将检查`aspectType`以确定它是否是AI正在寻找的属性。
- en: 'The code in the `Aspect.cs` file looks like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Aspect.cs`文件中的代码如下：'
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Attach this aspect script to our player tank and set the `aspectType` to `PLAYER`,
    as shown in the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将此属性脚本附加到我们的玩家坦克上，并将`aspectType`设置为`PLAYER`，如下面的截图所示：
- en: '![](img/4b549b44-5340-4e0b-8e0a-770184fa4f69.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4b549b44-5340-4e0b-8e0a-770184fa4f69.png)'
- en: Setting the Aspect Type of the tank
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 设置坦克的属性类型
- en: Creating an AI character
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建AI角色
- en: 'Our NPC will be roaming around the scene in a random direction. It''ll have
    the following two senses:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的NPC将在场景中以随机方向漫游。它将具有以下两种感官：
- en: The perspective sense will check whether the tank aspect is within a set visible
    range and distance
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视角感官将检查坦克属性是否在设定的可见范围和距离内
- en: The touch sense will detect if the enemy aspect has collided with its box collider,
    which we'll be adding to the tank in a later step
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触摸感官将检测敌人属性是否与其将要添加到坦克中的盒子碰撞器发生碰撞
- en: Because our player tank will have the `PLAYER` aspect type, the NPC will be
    looking for any `aspectType` not equal to its own.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的玩家坦克将具有`PLAYER`属性类型，NPC将寻找任何与其自身属性类型不相同的`aspectType`。
- en: 'The code in the `Wander.cs` file is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wander.cs`文件中的代码如下：'
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Wander` script generates a new random position in a specified range whenever
    the AI character reaches its current destination point. The `Update` method will
    then rotate our enemy and move it toward this new destination. Attach this script
    to our AI character so that it can move around in the scene. The `Wander` script
    is rather simplistic, but we will cover more advanced locomotion approaches in
    later chapters.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当AI角色达到其当前目的地点时，`Wander`脚本会在指定范围内生成一个新的随机位置。然后，`Update`方法将旋转我们的敌人并将其移动到这个新目的地。将此脚本附加到我们的AI角色上，以便它可以在场景中移动。`Wander`脚本相当简单，但我们在后面的章节中会介绍更高级的运动方法。
- en: Using the Sense class
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Sense类
- en: The `Sense` class is the interface of our sensory system that the other custom
    senses can implement. It defines two virtual methods, `Initialize` and `UpdateSense`,
    which will be implemented in custom senses, and are executed from the `Start`
    and `Update` methods, respectively.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sense`类是我们感官系统的接口，其他自定义感官可以实现它。它定义了两个虚拟方法，`Initialize`和`UpdateSense`，这些方法将在自定义感官中实现，并分别从`Start`和`Update`方法中执行。'
- en: Virtual methods are methods that can be overridden using the `override` modifier
    in derived classes. Unlike `abstract` classes, virtual classes do not require
    that you override them.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟方法是可以使用派生类中的`override`修饰符重写的方法。与`abstract`类不同，虚拟类不需要您重写它们。
- en: 'The code in the `Sense.cs` file looks like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sense.cs`文件中的代码如下所示：'
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The basic properties include its detection rate to execute the sensing operation,
    as well as the name of the aspect it should look for. This script will not be
    attached to any of our objects since we'll be deriving from it for our actual
    senses.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 基本属性包括执行感知操作的检测率以及它应该寻找的方面的名称。由于我们将从它派生我们的实际感知，因此此脚本将不会附加到我们的任何对象上。
- en: Giving a little perspective
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给予一点视角
- en: The perspective sense will detect whether a specific aspect is within its field
    of view and visible distance. If it sees anything, it will take the specified
    action, which in this case is to print a message to the console.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 视角感知将检测特定方面是否在其视野和可见距离内。如果它看到任何东西，它将执行指定的操作，在这种情况下是将消息打印到控制台。
- en: 'The code in the `Perspective.cs` file looks like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Perspective.cs` 文件中的代码如下所示：'
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We need to implement the `Initialize` and `UpdateSense` methods that will be
    called from the `Start` and `Update` methods of the parent `Sense` class, respectively.
    In the `DetectAspect` method, we first check the angle between the player and
    the AI's current direction. If it's in the field of view range, we shoot a ray
    in the direction that the player tank is located. The ray length is the value
    of the visible distance property.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现`Initialize`和`UpdateSense`方法，这些方法将分别从父`Sense`类的`Start`和`Update`方法中调用。在`DetectAspect`方法中，我们首先检查玩家和AI当前方向之间的角度。如果它在视野范围内，我们将向玩家坦克所在的方向发射一条射线。射线长度是可见距离属性的值。
- en: The `Raycast` method will return when it first hits another object. This way,
    even if the player is in the visible range, the AI character will not be able
    to see if it's hidden behind the wall. We then check for an `Aspect` component,
    and it will return true only if the object that was hit has an `Aspect` component
    and its `aspectType` is different from its own.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Raycast`方法将在第一次击中另一个对象时返回。这样，即使玩家在可见范围内，AI角色也无法看到它是否隐藏在墙壁后面。然后我们检查`Aspect`组件，并且只有当被击中的对象具有`Aspect`组件且其`aspectType`与其自身不同时，它才会返回true。'
- en: The `OnDrawGizmos` method draws lines based on the perspective field of view
    angle and viewing distance so that we can see the AI character's line of sight
    in the editor window during play testing. Attach this script to our AI character
    and be sure that the aspect type is set to `ENEMY`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnDrawGizmos`方法根据视角视野角度和观看距离绘制线条，这样我们就可以在游戏测试期间在编辑器窗口中看到AI角色的视线。将此脚本附加到我们的AI角色上，并确保方面类型设置为`ENEMY`。'
- en: 'This method can be illustrated as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法可以表示如下：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Touching is believing
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触手可及即为信
- en: The next sense we'll be implementing is `Touch.cs`, which triggers when the
    player tank entity is within a certain area near the AI entity. Our AI character
    has a box collider component and its `IsTrigger` flag is on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要实现的是`Touch.cs`，它在玩家坦克实体在AI实体附近的一定区域内时触发。我们的AI角色具有一个盒子碰撞体组件，并且其`IsTrigger`标志处于开启状态。
- en: We need to implement the `OnTriggerEnter` event, which will be called whenever
    another collider enters the collision area of this game object's collider. Since
    our tank entity also has a collider and rigid body components, collision events
    will be raised as soon as the colliders of the AI character and player tank collide.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现`OnTriggerEnter`事件，该事件将在另一个碰撞体进入此游戏对象碰撞体的碰撞区域时被调用。由于我们的坦克实体也有碰撞体和刚体组件，因此当AI角色的碰撞体和玩家坦克的碰撞体碰撞时，将立即引发碰撞事件。
- en: 'Unity provides two other trigger events besides `OnTriggerEnter`: `OnTriggerExit`
    and `OnTriggerStay`. Use these to detect when a collider leaves a trigger, and
    to fire off every frame that a collider is inside the trigger, respectively.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了两个其他触发事件，除了`OnTriggerEnter`之外：`OnTriggerExit`和`OnTriggerStay`。使用这些事件来检测碰撞体何时离开触发器，以及在每个帧中触发器内的碰撞体何时被触发。
- en: 'The code in the `Touch.cs` file is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Touch.cs`文件中的代码如下所示：'
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our sample NPC and tank have  `BoxCollider` components on them already. The
    NPC has its sensor collider set to `IsTrigger = true` . If you''re setting up
    the scene on your own, make sure you add the `BoxCollider` component yourself,
    and that it covers a wide enough area to trigger easily for testing purposes.
    Our trigger can be seen in the following screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例NPC和坦克已经具有`BoxCollider`组件。NPC的传感器碰撞体设置为`IsTrigger = true`。如果您自己设置场景，请确保您自己添加`BoxCollider`组件，并且它覆盖足够大的区域以便于测试。我们的触发器可以在以下屏幕截图中看到：
- en: '![](img/79522f53-2057-45db-a581-acae504d9d2f.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79522f53-2057-45db-a581-acae504d9d2f.png)'
- en: The collider around our player
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们玩家周围的碰撞器
- en: 'The previous screenshot shows the box collider on our enemy AI that we''ll
    use to trigger the touch sense event. In the following screenshot, we can see
    how our AI character is set up:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了我们的敌人 AI 上的盒子碰撞器，我们将使用它来触发触摸感应事件。在下一张截图中，我们可以看到我们的 AI 角色是如何设置的：
- en: '![](img/dbb978b2-789e-49da-b789-ab409d25467b.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dbb978b2-789e-49da-b789-ab409d25467b.png)'
- en: The properties of our NPC
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 NPC 的属性
- en: For demo purposes, we just print out that the enemy aspect has been detected
    by the touch sense, but in your own games, you can implement any events and logic
    that you want. This system ties in really nicely with other concepts covered in
    this book, such as states, which we learned about in [Chapter 2](9e338555-162c-4ed0-a519-035cfcea94ce.xhtml)*,
    Finite State Machines and You*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们只是打印出敌人方面已被触摸感应检测到，但在你自己的游戏中，你可以实现任何你想要的事件和逻辑。这个系统与本书中涵盖的其他概念结合得非常好，例如状态，我们在第
    2 章“有限状态机与您”中学习了这些内容。
- en: Testing the results
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试结果
- en: 'Hit play in the Unity editor and move the player tank near the wandering AI
    NPC by clicking on the ground to direct the tank to move to the clicked location.
    You should see the Enemy touch detected message in the console log window whenever
    our AI character gets close to our player tank:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器中点击播放，并通过点击地面将玩家坦克移动到附近的游荡 AI NPC 附近。你应该在控制台日志窗口中看到“敌人触摸检测”消息，每当我们的
    AI 角色靠近我们的玩家坦克时：
- en: '![](img/888ce9b1-b216-4115-9ede-f83fbdcdf7a2.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/888ce9b1-b216-4115-9ede-f83fbdcdf7a2.png)'
- en: Our NPC and tank in action
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在行动中的 NPC 和坦克
- en: The previous screenshot shows an AI agent with touch and perspective senses
    looking for another aspect. Move the player tank in front of the NPC, and you'll
    get the Enemy detected message. If you go to the editor view while running the
    game, you should see the debug lines being rendered. This is because of the `OnDrawGizmos`
    method implemented in the perspective `Sense` class.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了一个具有触摸和视角感应的 AI 代理正在寻找另一个方面。将玩家坦克移至 NPC 前面，你会收到“敌人检测”消息。如果你在运行游戏的同时进入编辑器视图，你应该会看到正在渲染的调试线条。这是因为我们在视角“感应”类中实现了
    `OnDrawGizmos` 方法。
- en: Summary
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduced the concept of using sensors and implemented two distinct
    senses—perspective and touch—for our AI character. The sensory system is one component
    of the whole decision-making system. We can use the sensory system in combination
    with a behavior system to execute certain behaviors for certain senses. For example,
    we can use an FSM to change to Chase and Attack states from the Patrol state once
    we have detected that there's an enemy within line of sight. We'll also cover
    how to apply behavior tree systems in [Chapter 6](8db41b31-be4b-432f-a68e-ef13e1f7e03b.xhtml),
    *Behavior Trees*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了使用传感器的概念，并为我们的 AI 角色实现了两种不同的感应——视角和触摸。感官系统是整个决策系统的一个组成部分。我们可以将感官系统与行为系统结合使用，以执行某些感官的特定行为。例如，一旦我们检测到视线范围内有敌人，我们可以使用有限状态机（FSM）从巡逻状态切换到追逐和攻击状态。我们还将介绍如何在第
    6 章“行为树”中应用行为树系统。
- en: In the next chapter, we'll be looking at popular pathfinding algorithms. We'll
    learn how to make our AI agent navigate complex environments using the ever-popular
    A* pathfinding algorithm, and even Unity's own `NavMesh` system.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨流行的路径查找算法。我们将学习如何使用流行的 A* 路径查找算法，以及 Unity 自身的 `NavMesh` 系统来让我们的 AI
    代理在复杂环境中导航。
