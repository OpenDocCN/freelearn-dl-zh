- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: The Foundation of Robotics and Artificial Intelligence
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器人和人工智能的基础
- en: In this book, I invite you to go on a journey with me to discover how to add
    **Artificial Intelligence** (**AI**) to a mobile robot. The basic difference between
    what I will call an **AI robot** and a more **regular robot** is the ability of
    the robot and its software to make decisions and to learn and adapt to its environment
    based on data from its sensors. To be a bit more specific, we are leaving the
    world of pre-coded robot design behind. Instead of programming all of the robot’s
    behaviors in advance, the robot, or more correctly, the robot software, will learn
    from examples we provide, or from interacting with the outside world. The robot
    software will not control its behavior as much as the data that we use to train
    the AI system will.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我邀请你和我一起踏上旅程，发现如何将**人工智能**（**AI**）添加到移动机器人中。我所说的**AI机器人**和更**常规机器人**之间的基本区别是机器人和其软件根据传感器提供的数据做出决策、学习和适应其环境的能力。更具体地说，我们正在告别预先编码的机器人设计的世界。我们不是预先编程所有机器人的行为，而是机器人（更准确地说，是机器人软件）将从我们提供的示例或与外部世界的交互中学习。机器人软件不会像我们用来训练人工智能系统的数据那样控制其行为。
- en: The AI robot will use its learning process to make predictions about the environment
    and how to achieve goals, and then use those predictions to create behavior. We
    will be trying out several forms of AI on our journey, including supervised and
    unsupervised learning, reinforcement learning, neural networks, and genetic algorithms.
    We will create a digital robot assistant that can talk and understand commands
    (and tell jokes), and we will create an **Artificial Personality** (**AP**) for
    our robot. We will learn how to teach our robot to navigate without a map, grasp
    objects by trial and error, and see in three dimensions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能机器人将利用其学习过程对环境以及如何实现目标进行预测，然后利用这些预测来创建行为。在我们的旅途中，我们将尝试几种人工智能的形式，包括监督学习和无监督学习、强化学习、神经网络和遗传算法。我们将创建一个能够交谈并理解命令（以及讲笑话）的数字机器人助手，并为我们的机器人创建一个**人工个性**（**AP**）。我们将学习如何教会我们的机器人无地图导航、通过试错法抓取物体，以及三维视觉。
- en: 'In this chapter, we will cover the following key topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下关键主题：
- en: The basic principles of robotics and AI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人和人工智能的基本原理
- en: What is AI and autonomy (and what is it not)?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是人工智能和自主性（以及它不是什么）？
- en: Are recent developments in AI anything new?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人工智能的近期发展有什么新内容吗？
- en: What is a robot?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是机器人？
- en: Introducing our sample problem
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍我们的示例问题
- en: When do you need AI for your robot?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时需要为你的机器人使用人工智能？
- en: Introducing the robot and our development environment
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍机器人和我们的开发环境
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The technical requirements for completing the tasks in this chapter are described
    in the *Preface* at the beginning of this book.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章任务的技术要求在本书的**前言**中有描述。
- en: All of the code for this book is available on the GitHub repository, available
    at [https://github.com/PacktPublishing/Artificial-Intelligence-for-Robotics-2e/](https://github.com/PacktPublishing/Artificial-Intelligence-for-Robotics-2e/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的所有代码都可在GitHub仓库中找到，网址为[https://github.com/PacktPublishing/Artificial-Intelligence-for-Robotics-2e/](https://github.com/PacktPublishing/Artificial-Intelligence-for-Robotics-2e/)。
- en: The basic principle of robotics and AI
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器人和人工智能的基本原理
- en: AI applied to **robotics development** requires a different set of skills from
    you, the robot designer or developer. You may have made robots before. You probably
    have a quadcopter or a 3D printer (which is, in fact, a robot). The familiar world
    of **Proportional-Integral-Derivative** (**PID**) controllers, sensor loops, and
    state machines is augmented by **Artificial Neural Networks** (**ANNs**), expert
    systems, genetic algorithms, and searching path planners. We want a robot that
    does not just react to its environment as a reflex action but has goals and intent
    – and can learn and adapt to the environment and is taught or trained rather than
    programmed. Some of the problems we can solve this way would be difficult, intractable,
    or impossible otherwise.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 将人工智能应用于**机器人开发**需要你，即机器人设计师或开发者，具备不同的技能。你可能之前制作过机器人。你可能有一个四旋翼无人机或3D打印机（实际上，它也是一个机器人）。熟悉的**比例-积分-微分**（**PID**）控制器、传感器循环和状态机的世界被**人工神经网络**（**ANNs**）、专家系统、遗传算法和搜索路径规划器所增强。我们希望机器人不仅仅是对其环境做出反射性反应，而是有目标和意图——并且能够学习和适应环境，并且是被教导或训练而不是被编程的。通过这种方式我们可以解决的问题可能在其他情况下是困难的、难以处理的或不可能的。
- en: What we are going to do in this book is introduce a problem – picking up toys
    in a playroom – that we will use as our example throughout the book as we learn
    a series of techniques for applying AI to our robot. It is important to understand
    that, in this book, the journey is far more important than the destination. At
    the end of the book, you should have gained some important skills with broad applicability,
    not just learned how to pick up toys.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们要介绍一个问题——在游戏室里捡起玩具——我们将用它作为全书的例子，当我们学习一系列将人工智能应用于我们机器人的技术时。重要的是要理解，在这本书中，过程远比目的地更重要。在书的结尾，你应该获得一些具有广泛适用性的重要技能，而不仅仅是学会如何捡起玩具。
- en: What we are going to do is first provide some tools and background to match
    the infrastructure that was used to develop the examples in the book. This is
    both to provide an even playing field and to not assume any practical knowledge
    on your part. To execute some of the advanced neural networks that we are going
    to build, we will use the GPUs in the Jetson.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是提供一些工具和背景，以匹配书中开发例子所使用的基础设施。这是为了提供一个公平的竞争环境，并且不假设你具备任何实际知识。为了执行我们将要构建的一些高级神经网络，我们将使用Jetson中的GPU。
- en: In the rest of this chapter, we will discuss some basics about robotics and
    AI, and then proceed to develop two important tools that we will use in all of
    the examples in the rest of the book. We will introduce the concept of soft real-time
    control, and then provide a framework, or model, for creating autonomy for our
    robot called the **Observe-Orient-Decide-Act** (**OODA**) loop.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将讨论一些关于机器人和人工智能的基础知识，然后继续开发我们将用于本书其余部分所有例子的两个重要工具。我们将介绍软实时控制的概念，然后提供一个框架或模型，称为**观察-定位-决策-行动**（**OODA**）循环，以为我们机器人创建自主性。
- en: What is AI and autonomy (and what is it not)?
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工智能和自主性（以及它不是什么）是什么？
- en: 'What would be the definition of AI? In general, it means a machine that exhibits
    some characteristics of intelligence – thinking, reasoning, planning, learning,
    and adapting. It can also mean a software program that can simulate thinking or
    reasoning. Let’s try some examples: a robot that avoids obstacles by simple rules
    (if the obstacle is to the right, go left) is not AI. A program that learns, by
    example, to recognize a cat in a video is AI. A robot arm that is operated by
    a joystick does not use AI, but a robot arm that adapts to different objects in
    order to pick them up is an application of AI.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能的定义是什么？一般来说，它意味着一种表现出某些智能特征的机器——思考、推理、规划、学习和适应。它也可以指一种可以模拟思考或推理的软件程序。让我们尝试一些例子：一个通过简单规则（如果障碍物在右边，就向左走）避开障碍物的机器人不是人工智能。一个通过示例学习在视频中识别猫的程序是人工智能。一个由操纵杆操作的机器人手臂不使用人工智能，但一个能够适应不同物体以便捡起它们的机器人手臂是人工智能的应用。
- en: There are two defining characteristics of AI robots that you must be aware of.
    First of all, AI robots are primarily **trained** to perform tasks, by providing
    examples, rather than being programmed step by step. For example, we will teach
    the robot’s software to recognize toys – things we want it to pick up – by training
    a neural network with examples of what toys look like. We will provide a training
    set of pictures with the toys in the images. We will specifically annotate what
    parts of the images are toys, and the robot will learn from that. Then we will
    test the robot to see that it learned what we wanted it to, somewhat like a teacher
    would test a student. The second characteristic is **emergent behavior**, in which
    the robot exhibits evolving actions that were not explicitly programmed into it.
    We provide the robot with controlling software that is inherently non-linear and
    self-organizing. The robot may suddenly exhibit some bizarre or unusual reaction
    to an event or situation that might appear to be odd, quirky, or even emotional.
    I worked with a self-driving car that we swore had delicate sensibilities and
    moved very daintily, earning it the nickname *Ferdinand*, after the sensitive,
    flower-loving bull from a cartoon, which was strange in a nine-ton truck that
    appeared to like plants. These behaviors are just caused by interactions of the
    various software components and control algorithms and do not represent anything
    more than that.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须了解人工智能机器人的两个定义特征。首先，人工智能机器人主要是**训练**来完成任务的，通过提供示例，而不是一步一步地进行编程。例如，我们将通过用玩具的外观示例训练神经网络来教机器人的软件识别玩具——我们希望它捡起的东西。我们将提供一组包含玩具的图片的训练集。我们将特别标注图像中哪些部分是玩具，机器人将从中学习。然后我们将测试机器人，看看它是否学到了我们希望它学到的，这有点像老师测试学生。第二个特征是**涌现行为**，其中机器人表现出没有明确编程进它的演变行为。我们为机器人提供了一种本质上非线性且自组织的控制软件。机器人可能会突然对某个事件或情况表现出一些奇怪或异常的反应，这可能会显得奇怪、古怪，甚至带有情感。我曾与一辆自动驾驶汽车合作，我们确信它有细腻的情感，移动得非常优雅，因此给它起了昵称“费迪南德”，这个名字来自一部卡通片中敏感、爱花的公牛，这在九吨重的卡车上显得很奇怪，因为卡车似乎喜欢植物。这些行为只是各种软件组件和控制算法的交互作用的结果，并不代表任何更多的事情。
- en: One concept you will hear in AI circles is the **Turing test**. The Turing test
    was proposed by Alan Turing in 1950, in a paper entitled *Computing Machinery
    and Intelligence*. He postulated that a human interrogator would question a hidden,
    unseen AI system, along with another human. If the human posing the questions
    was unable to tell which person was the computer and which was the human, then
    that AI computer would pass the test. This test supposes that the AI would be
    fully capable of listening to a conversation, understanding the content, and giving
    the same sort of answers a person would. Current **AI chatbots** can easily pass
    the Turing test and you may have interacted several times this week with AI on
    the phone without realizing it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你在人工智能领域会听到的一个概念是**图灵测试**。图灵测试是由艾伦·图灵在1950年提出的，在一篇题为《计算机与智能》的论文中。他假设一个人类审问者会询问一个隐藏的、看不见的人工智能系统，以及另一个人类。如果提出问题的人类无法分辨出哪个人是计算机，哪个人是人类，那么那个人工智能计算机就通过了测试。这个测试假设人工智能将能够完全具备倾听对话、理解内容并给出与人类相同类型答案的能力。当前的**人工智能聊天机器人**可以轻松通过图灵测试，你可能在本周已经与人工智能在电话中互动了几次，而自己却没有意识到。
- en: One group from the **Association for the Advancement of Artificial Intelligence**
    (**AAAI**) proposed that a more suitable test for AI might be the assembly of
    flatpack furniture – using the supplied instructions. However, to date, no robot
    has passed this test.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 来自**人工智能协会**（**AAAI**）的一个小组提出，对于人工智能来说，可能一个更合适的测试是组装平板家具——使用提供的说明书。然而，到目前为止，还没有任何机器人通过这个测试。
- en: Our objective in this book is not to pass the Turing test, but rather to take
    some novel approaches to solving problems using techniques in machine learning,
    planning, goal seeking, pattern recognition, grouping, and clustering. Many of
    these problems would be very difficult to solve any other way. AI software that
    could pass the Turing test would be an example of **general AI**, or a full, working
    intelligent artificial brain, and, just like you, general AI does not need to
    be specifically trained to solve any particular problem. To date, general AI has
    not been created, but what we do have is **narrow AI** or software that simulates
    thinking in a very narrow application, such as recognizing objects, or picking
    good stocks to buy.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目标不是通过图灵测试，而是采用一些新颖的方法，利用机器学习、规划、目标寻求、模式识别、分组和聚类等技术来解决问题。许多这些问题用其他方法解决起来都非常困难。能够通过图灵测试的人工智能软件将是一个**通用人工智能**的例子，或者是一个完整、工作的人工智能大脑，就像你一样，通用人工智能不需要专门训练来解决任何特定问题。到目前为止，通用人工智能尚未被创造出来，但我们所拥有的只是**窄人工智能**或模拟在非常狭窄的应用中思考的软件，例如识别物体，或者挑选购买的好股票。
- en: While we are *not* building general AI in this book, that means we are not going
    to be worried about our creations developing a mind of their own or getting out
    of control. That comes from the realm of science fiction and bad movies, rather
    than the reality of computers today. I am firmly of the mind that anyone preaching
    about the *evils* of AI or predicting that robots will take over the world has
    likely not seen the dismal state of AI research in terms of solving general problems
    or creating something resembling actual intelligence.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在本书中**不是**构建通用人工智能，这意味着我们不会担心我们的创造物会发展出自己的思维或失去控制。这来自科幻小说和糟糕电影的领域，而不是今天计算机的现实。我坚信，任何宣扬人工智能**弊端**或预测机器人将统治世界的人可能都没有看到人工智能研究在解决一般问题或创造类似实际智能的东西方面的悲观状态。
- en: Are recent developments in AI anything new?
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工智能最近的发展有什么新意吗？
- en: '*What has been is what will be, and what has been done is what will be done,
    and there is nothing new under the sun – Ecclesiastes 1:9, King* *James Bible*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: “过去的事必将重演，做过的事必将再做，太阳之下并无新事”——《传道书》1:9，《詹姆斯国王圣经》
- en: The modern practice of AI is not new. Most of these techniques were developed
    in the 1960s and 1970s and fell out of favor because the computing machinery of
    the day was insufficient for the complexity of software or the number of calculations
    required. They only waited for computers to get bigger and for another very significant
    event – the invention of the **internet**. In previous decades, if you needed
    10,000 digitized pictures of cats to compile a database to train a neural network,
    the task would be almost impossible – you could take a lot of cat pictures, or
    scan images from books. Today, a Google search for cat pictures returns 126,000,000
    results in 0.44 seconds. Finding cat pictures, or anything else, is just a search
    away, and you have your training set for your neural network – unless you need
    to train on a very specific set of objects that don’t happen to be on the internet,
    as we will see in this book, in which case we will once again be taking a lot
    of pictures with another modern aid not found in the sixties, a digital camera.
    The happy combination of very fast computers, cheap, plentiful storage, and access
    to almost unlimited data of every sort has produced a renaissance in AI.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能的现代实践并非新鲜事物。其中大部分技术都是在20世纪60年代和70年代开发的，但由于当时的计算设备不足以处理软件的复杂性或所需的计算量，这些技术逐渐失去了人们的青睐。它们只等待计算机变得更强大，以及另一个非常重大的事件——**互联网**的发明。在之前的几十年里，如果你需要10,000张猫的数字化图片来编译一个数据库以训练神经网络，这项任务几乎是不可能的——你可以拍摄很多猫的照片，或者从书中扫描图像。今天，通过谷歌搜索猫的图片，0.44秒内就能返回1亿2600万个结果。找到猫的图片，或者任何其他东西，只需搜索一下，你就有了一个用于训练神经网络的训练集——除非你需要训练一个非常特定的对象集合，而这些对象恰好不在互联网上，正如我们将在本书中看到的，在这种情况下，我们又将使用另一种现代工具，而不是60年代就能找到的工具，那就是数码相机。非常快速的计算机、廉价的、丰富的存储以及几乎无限的数据访问的结合，催生了人工智能的复兴。
- en: Another modern development has occurred on the other end of the computer spectrum.
    While anyone can now have what we would have called a supercomputer back in 2000
    on their desk at home, the development of the smartphone has driven a whole series
    of innovations that are just being felt in technology. Your wonder of a smartphone
    has accelerometers and gyroscopes made of tiny silicon chips called **Micro-Electromechanical
    Systems** (**MEMS**). It also has a high-resolution but very small digital camera
    and a multi-core computer processor that takes very little power to run. It also
    contains (probably) three radios – a Wi-Fi wireless network, a cellular phone,
    and a Bluetooth transceiver. As good as these parts are at making your iPhone
    fun to use, they have also found their way into parts available for robots. That
    is fun for us because what used to be only available for research labs and universities
    is now for sale to individual users. If you happen to have a university or research
    lab or work for a technology company with multi-million-dollar development budgets,
    you will also learn something from this book, and find tools and ideas that hopefully
    will inspire your robotics creations or power new products with exciting capabilities.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一项现代发展发生在计算机光谱的另一端。虽然现在任何人都可以在家中的桌子上拥有我们过去称之为超级计算机的东西，但智能手机的发展推动了一系列创新，这些创新正在技术领域感受到。你可能会对智能手机的加速度计和陀螺仪感到惊奇，这些是由称为**微机电系统**（**MEMS**）的微小硅芯片制成的。它还配备了一个高分辨率但非常小的数码相机和一个多核计算机处理器，运行时所需的电量很少。它还包含（可能）三个无线电——一个Wi-Fi无线网络、一部移动电话和一个蓝牙发射接收器。尽管这些部件在使你的iPhone变得有趣使用方面做得很好，但它们也进入了为机器人提供的部件中。这对我们来说很有趣，因为过去只有研究实验室和大学才能使用的东西，现在可以出售给个人用户。如果你恰好有一个大学或研究实验室，或者为拥有数百万美元开发预算的技术公司工作，你也会从这本书中学到一些东西，并找到希望激发你的机器人创作或为新产品带来令人兴奋功能的有用工具和想法。
- en: Now that you’re familiar with the concept of AI for robotics, let’s look at
    what a robot actually is.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了机器人AI的概念，让我们看看机器人实际上是什么。
- en: What is a robot?
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器人是什么？
- en: The word **robot** entered the modern language from the play *R.U.R* by the
    Czech author Karel Capek, which was published back in 1920\. *Roboti* is a Czech
    word meaning *forced servitude*. In the play, an industrialist learns how to build
    artificial people – not mechanical, metal men, but made of flesh and blood, and
    coming from a factory fully grown. The English translation of the name *R.U.R*
    as *Rossum’s Universal Robots* introduced the word *robot* to the world.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 词语**机器人**是从捷克作家卡雷尔·恰佩克的戏剧《R.U.R*》中进入现代语言的，这部戏剧于1920年出版。“Roboti”是捷克语，意为“强制劳动”。在这部戏剧中，一个工业家学会了如何制造人造人——不是机械的、金属的人，而是由肉体和血液构成，并且是从工厂中完全成长起来的。将名称*R.U.R*翻译成“罗素通用机器人”（Rossum’s
    Universal Robots）将词语**机器人**介绍给了世界。
- en: For the purposes of this book, a robot is a machine that is capable of sensing
    and reacting to its environment, and that has some human- or animal-like function.
    We generally think of a robot as an automated, self-directing mobile machine that
    can interact with the environment. That is to say, a robot has a **physical form**
    and exhibits some form of **autonomy**, or the ability to make decisions for itself
    based on observation of the external environment.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这本书的目的，机器人是一种能够感知和对其环境做出反应的机器，并且具有某些人类或动物般的职能。我们通常认为机器人是一种自动的、自我指导的移动机器，能够与环境互动。也就是说，机器人具有**物理形态**并表现出某种形式的**自主性**，即根据对外部环境的观察做出自己决策的能力。
- en: Next, let’s discuss the problem we will be trying to solve in this book.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论这本书中我们将试图解决的问题。
- en: Our sample problem – clean up this room!
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的示例问题——清理这个房间！
- en: In the course of this book, we will be using a single problem set that I feel
    most people can relate to easily, while still representing a real challenge for
    the most seasoned roboticist. We will be using AI and robotics techniques to pick
    up toys in my house after my grandchildren have visited. That sound you just heard
    was the gasp from the professional robotics engineers and researchers in the audience
    – this is a tough problem. Why is this a tough problem, and why is it ideal for
    this book?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的过程中，我们将使用一个我认为大多数人都能轻松相关联的问题集，同时仍然代表了对经验丰富的机器人学家的真正挑战。我们将使用人工智能和机器人技术来在我孙子辈访问后清理我家的玩具。你刚才听到的那个声音是观众中专业机器人工程师和研究人员的惊呼声——这是一个难题。为什么这是一个难题，为什么它适合这本书？
- en: Let’s discuss the problem and break it down a bit. Later, in [*Chapter 2*](B19846_02.xhtml#_idTextAnchor032),
    we will do a full task analysis, learn how to write use cases, and create storyboards
    to develop our approach, but we can start here with some general observations.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论这个问题，并对其进行一些分解。稍后，在[*第二章*](B19846_02.xhtml#_idTextAnchor032)中，我们将进行完整任务分析，学习如何编写用例，并创建故事板来开发我们的方法，但我们可以从这里开始，做一些一般性的观察。
- en: 'Robotics designers first start with the environment – where does the robot
    work? We divide environments into two categories: structured and unstructured.
    A structured environment, like the playing field for a FIRST robotics competition
    (a contest for robots built by high school students in the US, where all of the
    playing field is known in advance), an assembly line, or a lab bench, has everything
    in an organized space. You might have heard the saying *“A place for everything
    and everything in its place”* – that is a **structured environment**. Another
    way to think about it is that we know in advance where everything is or is going
    to be. We know what color things are, where they are placed in space, and what
    shape they are. A name for this type of information is *a priori* knowledge –
    things we know in advance. Having advanced knowledge of the environment in robotics
    is sometimes absolutely essential. Assembly line robots expect parts to arrive
    in an exact position and orientation to be grasped and placed into position. In
    other words, we have arranged the world to suit the robot.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人设计师首先从环境开始考虑——机器人将在哪里工作？我们将环境分为两类：结构化和非结构化。一个结构化环境，比如FIRST机器人竞赛的赛场（这是美国高中生建造的机器人竞赛，所有赛场在比赛前都是已知的），装配线或实验室工作台，都有一个有组织的空间。你可能听说过这样的话：“物有所归，物归其位”——这就是**结构化环境**。另一种思考方式是，我们事先知道一切的位置或去向。我们知道物体的颜色、它们在空间中的位置以及它们的形状。这种类型的信息被称为**先验知识**——我们事先知道的事情。在机器人领域，对环境的先验知识有时是绝对必要的。装配线机器人期望零件以精确的位置和方向到达，以便抓取并放置到正确的位置。换句话说，我们已经安排好世界以适应机器人。
- en: In the world of my house, this is simply not an option. If I could get my grandchildren
    to put their toys in exactly the same spot each time, then we would not need a
    robot for this task. We have a set of objects that are fairly fixed – we only
    have so many toys for them to play with. We occasionally add things or lose toys,
    or something falls down the stairs, but the toys are elements of a set of fixed
    objects. What they are not is positioned or oriented in any particular manner
    – they are just where they were left when the kids finished playing with them
    and went home. We also have a fixed set of furniture, but some parts move – the
    footstool or chairs can be moved around. This is an **unstructured environment**,
    where the robot and the software have to adapt, not the toys or furniture.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的房子这个世界上，这根本不是一种选择。如果我能让我的孙子孙女每次都把玩具放在完全相同的地方，那么我们就不需要机器人来完成这个任务。我们有一套相对固定的物体——他们只有这么多玩具可以玩。我们偶尔会添加一些东西或丢失玩具，或者有些东西从楼梯上掉下来，但玩具是固定物体集合的一部分。它们不是以任何特定的方式定位或定向的——它们只是孩子们玩完回家后留下的地方。我们还有一套固定的家具，但有些部分会移动——脚凳或椅子可以移动。这是一个**非结构化环境**，在这个环境中，机器人和软件需要适应，而不是玩具或家具。
- en: 'The problem is to have the robot drive around the room and pick up toys. Here
    are some objectives for this task:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是要让机器人绕着房间行驶并拿起玩具。以下是这个任务的一些目标：
- en: We want the user to **interact** with the robot by **talking** to it. We want
    the robot to understand what we want it to do, which is to say, what our intent
    is for the commands we are giving it.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望用户通过**与机器人交谈**来与机器人**互动**。我们希望机器人能够理解我们希望它做什么，也就是说，我们给出的命令的意图是什么。
- en: Once commanded to start, the robot will have to **identify an object** as being
    a toy or not being a toy. We only want to pick up toys.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦被命令开始，机器人将必须**识别一个物体**是玩具还是不是玩具。我们只想拿起玩具。
- en: The robot must **avoid hazards**, the most important being the stairs going
    down to the first floor. Robots have a particular problem with negative obstacles
    (dropoffs, curbs, cliffs, stairs, etc.), and that is exactly what we have here.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人必须**避免危险**，最重要的是一楼下去的楼梯。机器人特别容易遇到负面障碍（悬崖、台阶、悬崖、楼梯等），这正是我们这里的情况。
- en: Once the robot finds a toy, it has to determine how to **pick the toy up** with
    its robot arm. Can it grasp the object directly, or must it scoop the item up,
    or push it along? We expect that the robot will try different ways to pick up
    toys and may need several trial-and-error attempts.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦机器人找到玩具，它必须确定如何用其机器人手臂**拿起**玩具。它可以直接抓住物体，还是必须用勺子挖起，或者推它？我们预计机器人会尝试不同的方法来拿起玩具，并且可能需要多次尝试和错误。
- en: Once the toy is picked up by the robot arm, the robot needs to **carry the toy**
    to a toy box. The robot must recognize the toy box in the room, remember where
    it is for repeat trips, and then position itself to place the toy in the box.
    Again, more than one attempt may be required.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦玩具被机器人手臂拿起，机器人需要将玩具**携带**到玩具箱。机器人必须识别房间中的玩具箱，记住它的位置以便于重复行程，然后定位自己将玩具放入箱子。再次强调，可能需要多次尝试。
- en: After the toy is dropped off, the robot returns to **patrolling the room** looking
    for more toys. At some point, hopefully, all of the toys will be retrieved. It
    may have to ask us, the human, whether the room is acceptable, or whether it needs
    to continue cleaning.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在玩具被放下后，机器人将返回到**巡逻房间**寻找更多的玩具。希望最终能够找回所有的玩具。它可能需要询问我们，人类，房间是否可以接受，或者是否需要继续清洁。
- en: What will we learn from this problem? We will be using this backdrop to examine
    a variety of AI techniques and tools. The purpose of the book is to teach you
    how to develop AI solutions with robots. It is the process and the approach that
    is the critical information here, not the problem and not the robot I developed
    for the book. We will be demonstrating techniques for making a moving machine
    that can learn and adapt to its environment. I would expect that you will pick
    and choose which chapters to read and in which order, according to your interests
    and your needs, and as such, each of the chapters will be standalone lessons.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个问题中学到什么？我们将利用这个背景来检验各种人工智能技术和工具。本书的目的是教会你如何使用机器人开发人工智能解决方案。这里的关键信息是过程和方法，而不是问题，也不是我为本书开发的机器人。我们将展示如何制作一个能够学习和适应其环境的移动机器。我预计你们会根据自己的兴趣和需求挑选和阅读章节，并且按照自己的顺序，因此每一章都将是一个独立的课程。
- en: The first three chapters are foundation material that supports the rest of the
    book by setting up the problem and providing a firm framework to attach the rest
    of the material.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前三章是基础材料，通过建立问题和提供坚实的框架来支持本书的其余部分。
- en: The basics of robotics
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机器人学基础
- en: 'Not all of the chapters or topics in this book are considered *classical* AI
    approaches, but they do represent different ways of approaching machine learning
    and decision-making problems. We will be exploring together the following topics:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有章节或主题并不都被认为是*经典*的人工智能方法，但它们确实代表了处理机器学习和决策问题的不同方式。我们将一起探讨以下主题：
- en: '**Control theory and timing**: We will build a firm foundation for robot control
    by understanding control theory and timing. We will be using a soft real-time
    control scheme with what I call a **frame-based control loop**. This technique
    has a fancy technical name – **rate monotonic scheduling** – but I think you will
    find the concept intuitive and easy to understand.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制理论和时间管理**：我们将通过理解控制理论和时间管理来为机器人控制建立一个坚实的基础。我们将使用一种软实时控制方案，我称之为**基于帧的控制循环**。这项技术有一个复杂的名字——**速率单调调度**——但我认为你会发现这个概念直观且易于理解。'
- en: '**OODA loop**: At the most basic level, AI is a way for the robot to make decisions
    about its actions. We will introduce a model for decision-making that comes from
    the US Air Force, called the **OODA loop**. This describes how a robot (or a person)
    makes decisions. Our robot will have two of these loops, an inner loop or **introspective
    loop**, and an outward-looking **environment sensor loop**. The lower, inner loop
    takes priority over the slower, outer loop, just as the autonomic parts of your
    body (such as the heartbeat, breathing, and eating) take precedence over your
    task functions (such as going to work, paying bills, and mowing the yard). This
    makes our system a type of **subsumption architecture**, a biologically inspired
    control paradigm named by Rodney Brooks of MIT, one of the founders of iRobot
    and Rethink Robotics, and the designer of a robot named Baxter.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OODA循环**：在最基本层面上，人工智能是机器人做出行动决策的一种方式。我们将介绍一个来自美国空军的决策模型，称为**OODA循环**。它描述了机器人（或人）是如何做出决策的。我们的机器人将有两个这样的循环，一个是内部循环或**内省循环**，另一个是向外看的**环境传感器循环**。较低的内部循环比较慢的外部循环优先级更高，就像你身体自主的部分（如心跳、呼吸和进食）比你的任务功能（如去上班、付账单和修剪草坪）优先级更高一样。这使得我们的系统成为一种**吸收架构**，这是一种由麻省理工学院的罗德尼·布鲁克斯（Rodney
    Brooks）命名的生物启发式控制范式，他是iRobot和Rethink Robotics的创始人之一，也是Baxter机器人的设计者。'
- en: '![Figure 1.1 – My version of the OODA loop](img/B19846_01_1.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – 我版本的OODA循环](img/B19846_01_1.jpg)'
- en: Figure 1.1 – My version of the OODA loop
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 我版本的OODA循环
- en: Note
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The OODA loop was invented by Col. John Boyd, a man also called *The Father
    of the F-16*. Col. Boyd’s ideas are still widely quoted today, and his OODA loop
    is used to describe robot AI, military planning, or marketing strategies with
    equal utility. OODA provides a model for how a thinking machine that interacts
    with its environment might work.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: OODA循环是由约翰·博伊德上校（Col. John Boyd）发明的，他也被称作*F-16之父*。博伊德上校的思想至今仍被广泛引用，他的OODA循环被用来描述机器人人工智能、军事规划和营销策略，具有同等效用。OODA提供了一个模型，说明了与环境互动的思考机器可能的工作方式。
- en: Our robot works not by simply following commands or instructions step by step
    but by setting goals and then working to achieve those goals. The robot is free
    to set its own path or determine how to get to its goal. We will tell the robot
    *pick up that toy* and the robot will decide which toy, how to get in range, and
    how to pick up the toy. If we, the human robot owner, instead tried to treat the
    robot as a teleoperated hand, we would have to give the robot many individual
    instructions, such as *move forward*, *move right*, *extend arm*, *and open hand*,
    each individually, and without giving the robot any idea why we were making those
    motions. In a goal-oriented structure, the robot will be aware of which objects
    are toys and which are not and it will know how to find the toy box and how to
    put toys in the box. This is the difference between an autonomous robot and a
    radio-controlled teleoperated device.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们机器人工作的方式不是简单地按步骤执行命令或指令，而是通过设定目标然后努力实现这些目标。机器人可以自由地设定自己的路径或决定如何到达目标。我们会告诉机器人*拿起那个玩具*，然后机器人会决定是哪个玩具，如何进入范围，以及如何拿起玩具。如果我们，作为人类机器人拥有者，试图将机器人当作遥控手来对待，我们就必须给机器人提供许多单独的指令，例如*向前移动*、*向右移动*、*伸出手臂*、*张开手*，每个动作都要单独给出，而且不向机器人说明我们为什么要做出这些动作。在以目标为导向的结构中，机器人会知道哪些物体是玩具，哪些不是，并且它会知道如何找到玩具箱以及如何把玩具放入箱中。这就是自主机器人和遥控无线电操作设备之间的区别。
- en: Before designing the specifics of our robot and its software, we have to match
    its capabilities to the environment and the problem it must solve. The book will
    introduce some tools for designing the robot and managing the development of the
    software. We will use two tools from the discipline of systems engineering to
    accomplish this – **use cases** and **storyboards**. I will make this process
    as streamlined as possible. More advanced types of systems engineering are used
    by NASA, aerospace, and automobile companies to design rockets, cars, and aircraft
    – this gives you a taste of those types of structured processes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计我们机器人和其软件的具体细节之前，我们必须将其能力与环境以及它必须解决的问题相匹配。本书将介绍一些设计机器人和管理软件开发的工具。我们将使用系统工程领域的两个工具来完成这项任务——**用例**和**故事板**。我会尽可能使这个过程简化。更高级的系统工程类型被NASA、航空航天公司和汽车公司用于设计火箭、汽车和飞机——这让你尝到了那些类型结构化过程的味道。
- en: The techniques used in this book
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本书使用的技术
- en: 'The following sections will each detail step-by-step examples of applying AI
    techniques to a robotics problem:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节将逐步详细说明将人工智能技术应用于机器人问题的示例：
- en: We start with **object recognition**. We need our robot to recognize objects,
    and then classify them as either *toys* to be picked up or *not toys* to be left
    alone. We will use a trained **ANN** to recognize objects from a video camera
    from various angles and lighting conditions. We will be using the process of **transfer
    learning** to extend an existing object recognition system, **YOLOv8**, to recognize
    our toys quickly and reliably.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从**物体识别**开始。我们需要我们的机器人能够识别物体，并将它们分类为*玩具*（需要拾起）或*非玩具*（需要留下）。我们将使用经过训练的**人工神经网络（ANN**）从不同角度和光照条件下识别来自视频摄像头的物体。我们将使用**迁移学习**的过程来扩展现有的物体识别系统，**YOLOv8**，以便快速且可靠地识别我们的玩具。
- en: The next task, once a toy is identified, is to pick it up. Writing a general-purpose
    *pick up anything* program for a robot arm is a difficult task involving a lot
    of higher mathematics (use the internet to look up *inverse kinematics* to see
    what I mean). What if we let the robot sort this out for itself? We use **genetic
    algorithms** that permit the robot to invent its own behaviors and learn to use
    its arm on its own. Then we will employ **deep reinforcement learning** (**DRL**)
    to let the robot teach itself how to grasp various objects using an **end effector**
    (robot speak for a hand).
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个任务，一旦识别出玩具，就是将其拾起。为机器人手臂编写一个通用的*拾起任何东西*程序是一个困难的任务，涉及大量的高等数学（使用互联网查找*逆运动学*来了解我的意思）。如果我们让机器人自己解决这个问题会怎样呢？我们使用**遗传算法**，允许机器人发明自己的行为，并学会自己使用手臂。然后我们将使用**深度强化学习（DRL**）让机器人自己学习如何使用末端执行器（机器人的手）抓取各种物体。
- en: Our robot needs to understand commands and instructions from its owner (us).
    We use **natural language processing** (**NLP**) to not just recognize speech
    but to understand our intent for the robot to create goals consistent with what
    we want it to do. We use a neat technique that I call the *fill in the blank*
    method to allow the robot to reason from the context of a command. This process
    is useful for a lot of robot planning tasks.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的机器人需要理解其所有者（我们）的命令和指示。我们使用**自然语言处理（NLP**）不仅是为了识别语音，而且是为了理解我们的意图，以便让机器人创建符合我们期望的目标。我们使用一种我称之为*填空法*的巧妙技术，允许机器人从命令的上下文中进行推理。这个过程对于许多机器人规划任务都很有用。
- en: The robot’s next problem is navigating rooms while avoiding the stairs and other
    hazards. We will use a combination of a unique, mapless navigation technique with
    3D vision provided by a special stereo camera to see and avoid obstacles.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人的下一个问题是导航房间，同时避开楼梯和其他危险。我们将结合一种独特的、无地图的导航技术与由特殊立体相机提供的3D视觉，以看到并避开障碍物。
- en: The robot will need to be able to find the toy box to put items away, as well
    as have a general framework for planning moves in the future. We will use **decision
    trees** for path planning, as well as discussing **pruning** or quickly rejecting
    bad plans. If you imagine what a computer chess program algorithm must do, looking
    several moves ahead and scoring good moves versus bad moves before selecting a
    strategy, that will give you an idea of the power of this technique. This type
    of decision tree has many uses and can handle many dimensions of strategies. We’ll
    be using it as one of two ways to find a path to our toy box to put toys away.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人需要能够找到玩具箱来存放物品，以及拥有一个用于未来移动规划的一般框架。我们将使用**决策树**进行路径规划，并讨论**剪枝**或快速拒绝不良计划。如果你想象一下计算机国际象棋程序算法必须做什么，提前几步考虑，并在选择策略之前对好走和坏走的步骤进行评分，这将给你一个关于这种技术力量的概念。这种类型的决策树有许多用途，可以处理许多策略维度。我们将将其用作找到放置玩具的路径的两种方法之一。
- en: Our final task brings a different set of tools not normally used in robotics,
    or at least not the way we are going to employ them.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的最后任务需要使用一套在机器人技术中不常用，或者至少不是以我们即将使用的方式使用的工具。
- en: I have five wonderful, talented, and delightful grandchildren who love to come
    and visit. You’ll be hearing a lot about them throughout the book. The oldest
    grandson is 10 years old, and autistic, as is my granddaughter, the third child,
    who is 8, as well as the youngest boy, who is 6 as I write this. I introduced
    my eldest grandson, William, to the robot – and he immediately wanted to have
    a conversation with it. He asked, *“What’s your name?”* and *“What do you do?”*
    He was disappointed when the robot made no reply. So for the grandkids, we will
    be developing an engine for the robot to carry out a short conversation – we will
    be creating a robot personality to interact with children. William had one more
    request for this robot – he wants it to tell and respond to *knock, knock* jokes,
    so we will use that as a prototype of special dialog.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我有五个可爱、有才华、令人愉快的孙子孙女，他们喜欢来拜访。在整个书中，你将听到很多关于他们的故事。最大的孙子今年10岁，患有自闭症，我的孙女，第三个孩子，8岁，以及最小的男孩，6岁，也是我写这篇文章的时候。我向我的大孙子威廉介绍了这个机器人——他立刻想和它交谈。他问，“你叫什么名字？”和“你做什么？”当机器人没有回应时，他感到失望。所以对于孙子孙女们，我们将为机器人开发一个执行简短对话的引擎——我们将创建一个与孩子互动的机器人个性。威廉对这个机器人还有一个要求——他希望它能讲并回应“敲门”笑话，所以我们将使用这个作为特殊对话的原型。
- en: While developing a robot with actual feelings is far beyond the state of the
    art in robotics or AI today, we can simulate having a personality with a finite
    state machine and some Monte Carlo modeling. We will also give the robot a model
    for human interaction so that the robot will take into account the child’s mood
    as well. I like to call this type of software an **AP** to distinguish it from
    our AI. AI builds a model of thinking, and an AP builds a model of emotion for
    our robot.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在机器人或AI领域，开发具有真实情感的机器人远远超出了当前的技术水平，但我们可以通过有限状态机和一些蒙特卡洛建模来模拟拥有个性。我们还将为机器人提供一个人类交互的模型，这样机器人就会考虑到孩子的情绪。我喜欢将这种类型的软件称为**AP**，以区别于我们的AI。AI构建思考模型，而AP为我们的机器人构建情感模型。
- en: Now that you’re familiar with the problem we will be addressing in this book,
    let’s briefly discuss when and why you might need AI for your robot.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了我们将在本书中解决的问题，让我们简要讨论一下你何时以及为什么可能需要为你的机器人使用AI。
- en: When do you need AI for your robot?
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你什么时候需要为你的机器人使用AI？
- en: We generally describe AI as a technique for modeling or simulating processes
    that emulate how our brains make decisions. Let’s discuss how AI can be used in
    robotics to provide capabilities that may be difficult for *traditional* programming
    techniques to achieve. One of those is identifying objects in images or pictures.
    If you connect a camera to a computer, the computer receives not an image, but
    an array of numbers that represent pixels (picture elements). If we are trying
    to determine whether a certain object, say a toy, is located in the image, then
    this can be quite tricky. You can find shapes, such as circles or squares, but
    a teddy bear? Moreover, what if the teddy bear is upside down, or lying flat on
    a surface? This is the sort of problem that an AI program can solve when nothing
    else can.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常将AI描述为一种模拟或模拟过程的技术，它模仿我们的大脑如何做出决策。让我们讨论AI如何在机器人中应用，以提供可能难以通过**传统**编程技术实现的能力。其中之一是识别图像或图片中的对象。如果你将相机连接到计算机，计算机接收到的不是图像，而是一系列代表像素（图像元素）的数字。如果我们试图确定某个特定对象，比如玩具，是否位于图像中，那么这可能相当棘手。你可以找到形状，比如圆形或正方形，但熊玩具呢？此外，如果熊玩具是倒置的，或者平躺在表面上呢？这是AI程序可以解决的问题，而其他任何方法都无法解决。
- en: Our traditional approach for creating robot behaviors is to figure out what
    function we want and to write code to make that happen. When we have a simple
    function, such as driving around an obstacle, then this approach works well, and
    we can get results with a little tuning.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建机器人行为传统的方法是确定我们想要的函数，并编写代码来实现它。当我们有一个简单的函数，比如绕过障碍物时，这种方法效果很好，我们只需稍作调整就能得到结果。
- en: 'Some examples of AI and **ML** for robotics include:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能和机器学习在机器人领域的例子包括：
- en: '**NLP**: Using AI/ML to allow the robot to understand and respond to natural
    human speech and commands. This makes interacting with the robot much more intuitive.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NLP**：使用AI/ML让机器人理解和回应自然的人类语言和命令。这使得与机器人的交互更加直观。'
- en: '**Computer vision**: Using AI to let the robot see and recognize objects or
    people’s faces, read text, and so on. This helps the robot operate in real-world
    environments.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算机视觉**：使用AI让机器人看到并识别物体或人脸，读取文本等。这有助于机器人在现实世界环境中运行。'
- en: '**Motion planning**: AI can help the robot plan optimal paths and motions to
    navigate around obstacles and people. This makes the robot’s movements more efficient
    and human-like.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运动规划**：AI可以帮助机器人规划最优路径和动作，以避开障碍物和人群。这使得机器人的动作更加高效和类似人类。'
- en: '**Reinforcement learning**: The robot can learn how to do, and improve at doing,
    tasks through trial and error using AI reinforcement learning algorithms. This
    means less explicit programming is needed.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强化学习**：机器人可以通过使用AI强化学习算法通过试错来学习如何完成任务，并提高完成任务的能力。这意味着需要的显式编程更少。'
- en: The main rule of thumb is to use AI/ML whenever you want the robot to perform
    robustly in a complex, dynamic real-world environment. The AI gives it more perceptual
    and decision-making capabilities.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的指导原则是在你想要机器人在一个复杂、动态的真实世界环境中稳健地执行任务时使用AI/ML。AI赋予它更多的感知和决策能力。
- en: Now let’s look at one function we need for this robot – recognizing that an
    object is either a toy (and needs to be picked up) or is not. Creating a standard
    function for this via programming is quite difficult. Regular computer vision
    processes separate an image into shapes, colors, or areas. Our problem is the
    toys don’t have predictable shapes (circles, squares, or triangles), they don’t
    have consistent colors, and they are not all the same size. What we would rather
    do is to teach the robot what is a toy and what is not. That is what we would
    do with a person. We just need a process for teaching the robot how to use a camera
    to recognize a particular object. Fortunately, this is an area of AI that has
    been deeply studied, and there are already techniques to accomplish this, which
    we will use in [*Chapter 4*](B19846_04.xhtml#_idTextAnchor126). We will use a
    **convolutional neural network** (**CNN**) to recognize toys from camera images.
    This is a type of **supervised learning**, where we use examples to show the software
    what type of object we want to recognize, and then create a customized function
    that *predicts* the class (or type) of object based on the pixels that represent
    it in an image. One of the principles of AI that we will be applying is **gradual
    learning** using **gradient descent**. This means that instead of trying to make
    the computer learn a skill all in one go, we will train it a little bit at a time,
    gently training a function to output what we want by looking at errors (or loss)
    and making small changes. We use the principle of gradient descent – looking at
    the slope of the change in errors – to determine which way to adjust the training.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下这个机器人需要的一个功能——识别一个物体是玩具（需要被拿起）还是不是。通过编程创建这样一个标准功能相当困难。常规的计算机视觉过程将图像分离成形状、颜色或区域。我们的问题是玩具没有可预测的形状（圆形、方形或三角形），它们没有一致的颜色，而且大小也不一样。我们更愿意教机器人什么是玩具，什么不是。这就是我们如何对待人的。我们只需要一个过程来教机器人如何使用相机来识别特定的物体。幸运的是，这是AI领域已经深入研究的一个领域，已经有技术可以完成这项任务，我们将在[*第4章*](B19846_04.xhtml#_idTextAnchor126)中使用这些技术。我们将使用**卷积神经网络**（**CNN**）从相机图像中识别玩具。这是一种**监督学习**，我们使用示例向软件展示我们想要识别的对象类型，然后创建一个定制的函数，根据图像中代表它的像素来**预测**对象的类别（或类型）。我们将应用的一个AI原则是**逐步学习**，使用**梯度下降**。这意味着我们不会试图一次性让计算机学习一项技能，而是逐步训练它，通过观察错误（或损失）并做出小的调整，温和地训练一个函数输出我们想要的结果。我们使用梯度下降的原则——观察错误变化的斜率——来确定调整训练的方向。
- en: You may be thinking at this point, *“If that works for learning to classify
    pictures, then maybe it can be used to classify other things,"* and you would
    be right. We’ll use a similar approach – with somewhat different neural networks
    – to teach the robot to answer to its name, by recognizing the sound.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，到这个时候，“如果那适用于学习分类图片，那么也许它可以用来分类其他事物”，你会是对的。我们将使用类似的方法——使用略有不同的神经网络——来教机器人通过识别声音来回应它的名字。
- en: So, in general, when do we need to use AI in a robot? When we need to emulate
    some sort of decision-making process that would be difficult or impossible to
    create with procedural steps (i.e., programming). It’s easy to see that neural
    networks are emulations of animal thought processes since they are a (greatly)
    simplified model of how neurons interact. Other AI techniques can be more difficult
    to understand.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，总的来说，我们什么时候需要在机器人中使用AI呢？当我们需要模拟某种难以或无法通过程序步骤（即编程）创建的决策过程时。很容易看出，神经网络是动物思维过程的模拟，因为它们是神经元交互的（大大）简化模型。其他AI技术可能更难以理解。
- en: One common theme could be that AI consistently uses *programming by example*
    as a technique to replace code with a common framework and variables with data.
    Instead of *programming by process*, we are programming by showing the software
    what result we want and having the software come up with how to get to that result.
    So for **object recognition** using pictures, we provide pictures of objects *and*
    the answer to what kind of object is represented by the picture. We repeat this
    over and over and train the software – by modifying the parameters in the code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的主题是，人工智能始终使用**示例编程**作为技术，用通用框架替换代码，用数据替换变量。我们不再使用**过程编程**，而是通过展示软件我们想要的结果，让软件想出如何达到那个结果。因此，对于使用图片进行**物体识别**，我们提供物体的图片以及图片所代表的物体类型的答案。我们反复这样做，并通过修改代码中的参数来训练软件。
- en: Another type of behavior we can create with AI has to do with behaviors. There
    are a lot of tasks that can be thought of as games. We can easily imagine how
    this works. Let’s say you want your children to pick up the toys in their room.
    You could command them to do it – which may or may not work. Or, you could make
    it a game by awarding points for each toy picked up, and giving a reward (such
    as giving a dollar) based on the number of points scored. What did we add by doing
    this? We added a **metric**, or measurement tool, to let the children know how
    well they are doing – a point system. And, more critically, we added a reward
    for specific behaviors. This can be a process we can use to modify or create behaviors
    in a robot. This is formally called **reinforcement learning**. While we can’t
    give a robot an emotional reward (as robots don’t have wants or needs), we can
    program the robot to seek to maximize a reward function. Then we can use the same
    process of making a small adjustment in parameters that change the reward, see
    whether that improves the score, and then either keep that change (when learning
    results in more reward, our reinforcement) or discard it if the score goes down.
    This type of process works well for robot motion, and for controlling robot arms.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用人工智能创造的另一种行为类型与行为有关。有很多任务可以被视为游戏。我们可以轻松想象它是如何工作的。假设你希望你的孩子们捡起他们房间里的玩具。你可以命令他们这样做——这可能有效也可能无效。或者，你可以通过为每个捡起的玩具奖励积分，并根据得分多少给予奖励（比如给一美元）来将其变成一个游戏。我们通过这样做增加了什么？我们增加了一个**指标**，或测量工具，让孩子们知道他们做得怎么样——一个积分系统。更重要的是，我们为特定的行为增加了奖励。这可以是一个我们可以用来修改或创建机器人行为的流程。这正式称为**强化学习**。虽然我们不能给机器人一个情感上的奖励（因为机器人没有欲望或需求），但我们可以编程让机器人寻求最大化奖励函数。然后我们可以使用调整参数以改变奖励的相同流程，看看这是否会提高得分，然后要么保留这个变化（当学习导致更多奖励时，我们的强化），要么如果得分下降就放弃它。这种类型的流程对机器人运动和机器人手臂的控制非常有效。
- en: I must tell you that the task set out in this book – to pick up toys in an unstructured
    environment – is nearly impossible to perform without AI techniques. It could
    be done by modifying the environment – say, by putting RFID tags in the toys –
    but not otherwise. That, then, is the purpose of this book – to show how certain
    tasks, which are difficult or impossible to solve otherwise, can be completed
    using the combination of AI and robotics.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须告诉你，这本书中提出的任务——在非结构化环境中捡起玩具——没有人工智能技术几乎是不可能完成的。可以通过修改环境来完成，比如在玩具上放置RFID标签，但除此之外不行。那么，这本书的目的就是——展示某些任务，这些任务在没有人工智能和机器人技术的情况下难以或无法解决，如何通过人工智能和机器人的结合来完成。
- en: Next, let’s discuss our robot and the development environment that we’ll be
    using in this book.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论本书中我们将使用的机器人和开发环境。
- en: Introducing the robot and our development environment
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍机器人和我们的开发环境
- en: This is a book about robots and AI, so we really need to have a robot to use
    for all of our practical examples. As we will discuss in [*Chapter 2*](B19846_02.xhtml#_idTextAnchor032)
    at some length, I have selected robot hardware and software that will be accessible
    to the average reader. The particular brand and type are not important, and I’ve
    upgraded Albert considerably since the first edition was published some five years
    ago. In the interest of keeping things up to date, we are putting all of the hardware
    details in the GitHub repository for this book.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一本关于机器人和人工智能的书，所以我们真的需要一台机器人来用于所有的实际示例。正如我们将在[*第二章*](B19846_02.xhtml#_idTextAnchor032)中详细讨论的那样，我选择了普通读者可以接触到的机器人硬件和软件。具体品牌和类型并不重要，自从五年前第一版出版以来，我已经对阿尔伯特进行了相当大的升级。为了保持内容的时效性，我们将所有硬件细节都放在了这本书的GitHub仓库中。
- en: 'As shown in the following photographs taken from two different perspectives,
    my robot has new omnidirectional wheels, a mechanical six-degree-of-freedom arm,
    and a computer brain:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如下两张不同角度拍摄的照片所示，我的机器人配备了新的全向轮、一个六自由度的机械臂和一台电脑大脑：
- en: '![Figure 1.2 – Albert the robot has wheels and a mechanical arm](img/B19846_01_2.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2 – 阿尔伯特机器人有轮子和机械臂](img/B19846_01_2.jpg)'
- en: Figure 1.2 – Albert the robot has wheels and a mechanical arm
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – 阿尔伯特机器人有轮子和机械臂
- en: I’ll call it *Albert*, since it needs some sort of name, and I like the reference
    to Prince Albert, consort of Queen Victoria, who was famous for taking marvelous
    care of their nine children. All nine of his children survived to adulthood, which
    was a rarity in the Victorian age, and he had 42 grandchildren. He went by his
    middle name; his actual first name was Francis.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我会称它为*阿尔伯特*，因为它需要某种名称，而且我喜欢它对维多利亚女王丈夫阿尔伯特亲王的引用，他因对他们的九个孩子照顾得非常好而闻名。他的九个孩子都长大成人，这在维多利亚时代是罕见的，他还有42个孙子孙女。他以他的中间名为人所知；他的真实名字是弗朗西斯。
- en: Our tasks in this book center around picking up toys in an interior space, so
    our robot has a solid base with four motors and omni wheels for driving over carpet.
    Our steering method is the tank type, or differential drive, where we steer by
    sending different commands to the wheel motors. If we want to go straight ahead,
    we set all four motors to the same forward speed. If we want to travel backward,
    we reverse both motors the same amount. Turns are accomplished by moving one side
    forward and the other backward (which makes the robot turn in place) or by giving
    one side more forward drive than the other. We can make any sort of turn this
    way. The omni wheels allow us to do some other tricks as well – we can turn the
    wheels toward each other and translate directly sideways, and even turn in a circle
    while pointing at the same spot on the ground. We will mostly drive like a truck
    or car but will use the *y*-axis motion occasionally to line things up. Speaking
    of axes, I’ll use the *x* axis to mean that the robot will move straight ahead,
    the *y* axis refers to horizontal movement from side to side, and the *z* axis
    is up and down, which we need for the robot’s arm.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的任务主要集中在室内空间捡起玩具，因此我们的机器人有一个坚固的底盘，配备四个电机和全向轮，以便在地毯上行驶。我们的转向方法是坦克式，或差速驱动，通过向轮电机发送不同的命令来进行转向。如果我们想直行，我们将所有四个电机设置为相同的向前速度。如果我们想倒退，我们将两个电机以相同的量反转。转向是通过将一侧向前移动而另一侧向后移动（这使得机器人原地转向）或通过给一侧比另一侧更多的向前驱动来实现。我们可以用这种方式进行任何类型的转向。全向轮还允许我们做一些其他的技巧——我们可以将车轮转向彼此并直接向侧面移动，甚至可以在指向地面上同一位置的同时旋转。我们主要会像卡车或汽车一样驾驶，但偶尔会使用*Y*轴运动来对齐。说到轴，我会用*x*轴表示机器人将直线前进，*y*轴指的是从一侧到另一侧的水平移动，而*z*轴是上下移动，这是我们机器人手臂所需要的。
- en: In order to pick up toys, we need some sort of manipulator, so I’ve included
    a six-axis robot arm that imitates a shoulder–elbow–wrist–hand combination that
    is quite dexterous and, since it is made out of standard digital servos, quite
    easy to wire and program.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捡起玩具，我们需要某种机械臂，所以我包括了一个六轴机器人臂，它模仿了肩部-肘部-腕部-手部的组合，非常灵巧，而且由于它是由标准数字伺服电机制成的，所以连接和编程都非常简单。
- en: 'The main control of the Albert robot is the Nvidia Nano **single-board computer**
    (**SBC**), which talks to the operator via a USB Wi-Fi dongle. The Nvidia talks
    to an Arduino Mega 2560 microcontroller and motor controller that we will use
    to control motors via **Pulse Width Modulation** (**PWM**) pulses. The following
    figure depicts the internal components of the robot:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Albert机器人的主要控制器是英伟达Nano**单板计算机（SBC**），它通过USB Wi-Fi闪存盘与操作员通信。Nvidia与Arduino Mega
    2560微控制器和电机控制器通信，我们将使用它通过**脉冲宽度调制（PWM**）脉冲来控制电机。以下图显示了机器人的内部组件：
- en: '![Figure 1.3 – Block diagram of the robot](img/B19846_01_3.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – 机器人框图](img/B19846_01_3.jpg)'
- en: Figure 1.3 – Block diagram of the robot
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 机器人框图
- en: We will be primarily concerned with the Nvidia Nano SBC, which is the brains
    of our robot. We will set up the rest of the components once and not change them
    for the entire book.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将主要关注英伟达Nano单板计算机，它是我们机器人的大脑。我们将一次性设置其余组件，并在整本书中不会更改它们。
- en: The Nvidia Nano acts as the main interface between our control station, which
    is a PC running Windows, and the robot itself via a Wi-Fi network. Just about
    any low-power, Linux-based SBC can perform this job, such as a BeagleBone Black,
    Odroid XU4, or an Intel Edison. One of the advantages of the Nano is that it can
    use its **Graphics Processing Units** (**GPUs**) to speed up the processing of
    neural networks.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 英伟达Nano作为我们控制站（运行Windows的PC）和机器人本身通过Wi-Fi网络之间的主要接口。几乎任何基于Linux的低功耗单板计算机（SBC）都可以执行这项任务，例如BeagleBone
    Black、Odroid XU4或英特尔爱迪生。Nano的一个优点是它可以使用其**图形处理单元（GPU**）来加速神经网络的处理。
- en: Connected to the SBC is an Arduino with a motor controller. The Nano talks through
    a USB port addressed as a serial port. We also need a 5V regulator to provide
    the proper power from the 11.1V rechargeable lithium battery power pack into the
    robot. My power pack is a rechargeable 3S1P (three cells in series and one in
    parallel) 2700 Ah battery (normally used for quadcopter drones) and came with
    the appropriate charger. As with any lithium battery, follow all of the directions
    that come with the battery pack and recharge it in a metal box or container in
    case of fire.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到SBC的是带有电机控制器的Arduino。Nano通过一个被指定为串行端口的USB端口进行通信。我们还需要一个5V稳压器，将从11.1V可充电锂离子电池组提供适当的电源到机器人。我的电源包是一个可充电的3S1P（三节串联，一节并联）2700Ah电池（通常用于四旋翼无人机），并附带适当的充电器。与任何锂离子电池一样，遵循电池组附带的所有说明，并在发生火灾时在金属箱或容器中充电。
- en: Software components (ROS, Python, and Linux)
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件组件（ROS、Python和Linux）
- en: I am going to direct you once again to the Git repository to see all of the
    software that runs the robot, but I’ll cover the basics here to remind you. The
    base operating system for the robot is Linux running on an Nvidia Nano SBC, as
    we said. We are using the ROS 2 to connect all of our various software components
    together, and it also does a wonderful job of taking care of all of the finicky
    networking tasks such as setting up sockets and establishing connections. It also
    comes with a great library of already prepared functions that we can just take
    advantage of, such as a joystick interface. ROS 2 is not a true operating system
    that controls the whole computer like Linux or Windows does, but rather is a backbone
    of communications and interface standards and utilities that make putting together
    a robot a lot simpler. The name I like to use for this type of system is **Modular
    Open System Architecture** (**MOSA**). ROS 2 uses a *publish/subscribe* technique
    to move data from one place to another that truly decouples the programs that
    produce data (such as sensors and cameras) from those programs that use data,
    such as controls and displays. We’ll be making a lot of our own stuff and only
    using a few ROS functions. Packt has several great books for learning ROS; my
    favorite is *Effective Robotics Programming* *with ROS*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我将再次指导您查看Git仓库，以查看运行机器人的所有软件，但我会在这里介绍基础知识以提醒您。正如我们所说，机器人的基础操作系统是运行在Nvidia Nano
    SBC上的Linux。我们使用ROS 2将所有各种软件组件连接在一起，并且它还出色地处理了所有那些棘手的网络任务，例如设置套接字和建立连接。它还附带了一个功能强大的库，我们可以直接利用，例如操纵杆接口。ROS
    2不是一个像Linux或Windows那样控制整个计算机的真正操作系统，而是一个通信、接口标准和实用程序的骨干，这使得组装机器人变得更加简单。我喜欢为这种类型的系统起名为**模块化开放式系统架构**（**MOSA**）。ROS
    2使用**发布/订阅**技术将数据从一个地方移动到另一个地方，这真正地将产生数据（如传感器和摄像头）的程序与使用数据（如控制和显示）的程序解耦。我们将制作很多自己的东西，并且只使用少数ROS函数。Packt有几本关于学习ROS的出色书籍；我最喜欢的是《*有效的ROS机器人编程*》。
- en: 'The programming language we will use throughout this book, with a couple of
    minor exceptions, will be **Python**. Python is a great language for this purpose
    for two great reasons: it is widely used in the robotics community in conjunction
    with ROS, and it is also widely accepted in the machine learning and AI community.
    This double whammy makes using Python irresistible. Python is an interpreted language,
    which has three amazing advantages for us:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用一种编程语言，除了少数几个小例外，那就是**Python**。Python是这种用途的绝佳语言，原因有两个：它在与ROS结合使用时在机器人社区中得到了广泛的应用，同时也在机器学习和人工智能社区中得到了广泛的认可。这种双重优势使得使用Python变得无法抗拒。Python是一种解释型语言，它对我们来说有三个惊人的优势：
- en: '**Portability**: Python is very portable between Windows, Mac, and Linux. Usually,
    you can get by with just a line or two of changes if you use a function out of
    the operating system, such as opening a file. Python has access to a huge collection
    of C/C++ libraries that also add to its utility.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植性**：Python在Windows、Mac和Linux之间非常便携。通常，如果你使用操作系统中的函数，如打开文件，只需进行一行或两行的更改即可。Python可以访问大量的C/C++库，这也增加了它的实用性。'
- en: '**No compilation**: As an interpreted language, Python does not require a compile
    step. Some of the programs we are developing in this book are pretty involved,
    and if we wrote them in C or C++, it would take 10 or 20 minutes of build time
    each time we made a change. You can do a lot with that much time, which you can
    spend getting your program to run and not waiting for the *make* process to finish.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无需编译**：作为解释型语言，Python不需要编译步骤。我们在这本书中开发的一些程序相当复杂，如果我们用C或C++编写，每次我们做出更改时都需要10或20分钟的构建时间。你可以用那么多时间做很多事情，你可以用这些时间让你的程序运行，而不是等待*make*过程完成。'
- en: '**Isolation**: This is a benefit that does not get talked about much but having
    had a lot of experience with crashing operating systems with robots, I can tell
    you that the fact that Python’s interpreter is isolated from the core operating
    system means that having one of your Python ROS programs crash the computer is
    very rare. A computer crash means rebooting the computer and also probably losing
    all of the data you need to diagnose the crash. I had a professional robot project
    that we moved from Python to C++, and immediately the operating system crashes
    began, which shot the reliability of our robot. If a Python program crashes, another
    program can monitor that and restart it. If the operating system has crashed,
    there is not much you can do without some extra hardware that can push the *Reset*
    button for you.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离**：这是一个很少被提及的好处，但鉴于我有很多与机器人相关的操作系统崩溃的经验，我可以告诉你，Python解释器与核心操作系统隔离的事实意味着你的Python
    ROS程序崩溃计算机是非常罕见的。计算机崩溃意味着需要重新启动计算机，也可能丢失所有用于诊断崩溃所需的数据。我有一个从Python迁移到C++的专业机器人项目，结果操作系统崩溃开始发生，这大大降低了我们机器人的可靠性。如果一个Python程序崩溃，另一个程序可以监控它并重新启动它。如果操作系统崩溃，没有额外的硬件帮助你按下*重置*按钮，你几乎无能为力。'
- en: Before we dive into the coding of our base control system, let’s talk about
    the theory we will use to create a robust, modular, and flexible control system
    for robotics.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入到基础控制系统的编码之前，让我们谈谈我们将用于创建一个健壮、模块化和灵活的机器人控制系统的理论。
- en: Robot control systems and a decision-making framework
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机器人控制系统和决策框架
- en: 'As I mentioned earlier in this chapter, we are going to use two sets of tools
    in the sections: **soft real-time control** and the **OODA loop**. One gives us
    a base for controlling the robot easily and consistently, and the other provides
    a basis for the robot’s autonomy.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如我在这章前面提到的，我们在接下来的几节中将要使用两组工具：**软实时控制**和**OODA循环**。前者为我们提供了一个基础，使我们能够轻松且一致地控制机器人，而后者为机器人的自主性提供了基础。
- en: How to control your robot
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何控制你的机器人
- en: The basic concept of how a robot works, especially one that drives, is simple.
    There is a master control loop that does the same thing over and over – reads
    data from the sensors and motor controller, looks for commands from the operator
    (or the robot’s autonomy functions), makes any changes to the state of the robot
    based on those commands, and then sends instructions to the motors or effectors
    to make the robot move.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人工作的基本概念，尤其是那些用于驱动的机器人，是简单的。存在一个主控制循环，它反复执行相同的事情——从传感器和电机控制器读取数据，寻找操作员（或机器人的自主功能）的指令，根据这些指令对机器人的状态进行任何更改，然后向电机或执行器发送指令以使机器人移动。
- en: '![Figure 1.4 – Robot control loop](img/B19846_01_4.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – 机器人控制循环](img/B19846_01_4.jpg)'
- en: Figure 1.4 – Robot control loop
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 机器人控制循环
- en: The preceding diagram illustrates how we have instantiated the OODA loop in
    the software and hardware of our robot. The robot can either act autonomously
    or accept commands from a control station connected via a wireless network.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表说明了我们如何在机器人的软件和硬件中实现OODA循环。机器人可以自主行动，或者通过无线网络接受连接的控制站的指令。
- en: What we need to do is perform this control loop in a consistent manner all of
    the time. We need to set a base frame rate or basic update frequency that sets
    the timing of our control loop. This makes all the systems of the robot perform
    together. Without some sort of time manager, each control cycle of the robot takes
    a different amount of time to complete, and any sort of path planning, position
    estimate, or arm movement becomes very complicated. ROS does not provide a time
    manager as it is inherently non-synchronous; if required, we have to create one
    ourselves.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要始终以一致的方式执行这个控制循环。我们需要设置一个基本帧率或基本更新频率，以设定控制循环的时间。这使得机器人的所有系统一起工作。如果没有某种形式的时间管理器，机器人的每个控制周期完成所需的时间都不同，任何路径规划、位置估计或手臂运动都会变得非常复杂。ROS本身是非同步的，因此不提供时间管理器；如果需要，我们必须自己创建一个。
- en: Using control loops
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用控制循环
- en: 'In order to have control of our robot, we have to establish some sort of control
    or feedback loop. Let’s say that we tell the robot to move 12 inches (30 cm) forward.
    The robot must send a command to the motors to start moving forward, and then
    have some sort of mechanism to measure 12 inches of travel. We can use several
    means, but let’s just use a clock. The robot moves 3 inches (7.5 cm) per second.
    We need the control loop to start the movement, and then each update cycle, or
    time through the loop, check the time and see whether four seconds have elapsed.
    If they have, then it sends a *stop* command to the motors. The timer is the *control*,
    four seconds is the *set point*, and the motor is the *system* that is controlled.
    The process also generates an error signal that tells us what control to apply
    (in this case, to stop). Let’s look at a simple control loop:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制我们的机器人，我们必须建立某种控制或反馈回路。假设我们告诉机器人向前移动12英寸（30厘米）。机器人必须向电机发送命令以开始前进，然后有一种机制来测量12英寸的行程。我们可以使用多种方法，但让我们只使用一个时钟。机器人每秒移动3英寸（7.5厘米）。我们需要控制回路开始移动，然后在每个更新周期，或通过回路的每次时间，检查时间并查看是否已经过去了四秒钟。如果已经过去了，那么它就向电机发送一个**停止**命令。计时器是**控制**，四秒钟是**设定点**，电机是受控的**系统**。这个过程还生成一个误差信号，告诉我们应用什么控制（在这种情况下，停止）。让我们看看一个简单的控制回路：
- en: '![Figure 1.5 – Sample control loop – maintaining the temperature of a pot of
    water](img/B19846_01_5.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5 – 样本控制回路 – 维持水壶的温度](img/B19846_01_5.jpg)'
- en: Figure 1.5 – Sample control loop – maintaining the temperature of a pot of water
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – 样本控制回路 – 维持水壶的温度
- en: Based on the preceding figure, what we want is a constant temperature in the
    **pot of water**. The **valve** controls the heat produced by the **fire**, which
    warms the **pot of water**. The **temperature sensor** detects whether the water
    is too cold, too hot, or just right. The controller uses this information to control
    the valve for more heat. This type of schema is called a **closed loop** **control
    system**.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的图示，我们希望**水壶**中的温度保持恒定。**阀门**控制由**火焰**产生的热量，从而加热**水壶**。**温度传感器**检测水是否过冷、过热或恰到好处。控制器使用这些信息来控制阀门以产生更多热量。这种类型的方案被称为**闭环****控制系统**。
- en: You can think of this also in terms of a process. We start the process, and
    then get feedback to show our progress so that we know when to stop or modify
    the process. We could be doing speed control, where we need the robot to move
    at a specific speed, or pointing control, where the robot aims or turns in a specific
    direction.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将这个过程视为一个过程。我们开始这个过程，然后获取反馈来显示我们的进度，以便我们知道何时停止或修改过程。我们可能在进行速度控制，需要机器人以特定的速度移动，或者进行指向控制，机器人指向或转向特定的方向。
- en: 'Let’s look at another example. We have a robot with a self-charging docking
    station, with a set of **light-emitting diodes** (**LEDs**) on the top as an optical
    target. We want the robot to drive straight into the docking station. We use the
    camera to see the target LEDs on the docking station. The camera generates an
    error signal, which is used to guide the robot toward the LEDs. The distance between
    the LEDs also gives us a rough range to the dock. This process is illustrated
    in the following figure:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子。我们有一个带有自充电对接站的机器人，顶部有一组**发光二极管**（**LEDs**）作为光学目标。我们希望机器人直接驶入对接站。我们使用摄像头来观察对接站上的目标LED灯。摄像头生成一个误差信号，用于引导机器人向LED灯移动。LED灯之间的距离也给我们提供了到对接站的大致距离。这个过程在下图中展示：
- en: '![Figure 1.6 – Target tracking for a self-docking charging station](img/B19846_01_6.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6 – 自停靠充电站的目标跟踪](img/B19846_01_6.jpg)'
- en: Figure 1.6 – Target tracking for a self-docking charging station
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – 自停靠充电站的目标跟踪
- en: 'Let’s understand this in some more detail:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解一下：
- en: Let’s say that the LEDs in the figure are off to the left of the center 50%
    and the distance from the robot to the target is 3 feet (1 m). We send that information
    through a control loop to the motors – turn left a bit and drive forward a bit.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设图中的LED灯在中心左侧的50%处关闭，并且机器人到目标物的距离是3英尺（1米）。我们将这个信息通过控制回路发送到电机——稍微向左转并向前行驶一点。
- en: We then check again, and the LEDs are closer to the center (40%) and the distance
    to the target is 2.9 feet or 90 cm. Our error signal is a bit less, and the distance
    is a bit less. We’ll have to develop a **scaling factor** to determine how many
    pixels equate to how much **turn rate**, which is measured as a percentage of
    full power. Since we are using a fixed camera and lens, this will be a constant.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们再次检查，LED灯更接近中心（40%），到目标物的距离是2.9英尺或90厘米。我们的误差信号略小，距离也略小。我们将不得不开发一个**缩放因子**来确定多少像素等于多少**转速**，这以全功率的百分比来衡量。由于我们使用的是固定的摄像头和镜头，这将是一个常数。
- en: Now we send a slower turn and a slower movement to the motors this update cycle.
    We end up exactly in the center and come to zero speed just as we touch the docking
    station.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们在这个更新周期中给电机发送一个更慢的转动和移动。我们最终正好在中心，当我们接触到对接站时，速度变为零。
- en: For those people currently saying, *“But if you use a PID controller …”*, yes,
    you are correct – you also know that I’ve just described a *P* or *proportional*
    control scheme. We can add more bells and whistles to help prevent the robot from
    overshooting or undershooting the target due to its own weight and inertia and
    to damp out oscillations caused by those overshoots.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些正在说“但是如果你使用PID控制器……”的人，是的，你是对的——你也知道我刚刚描述了一个*P*或**比例**控制方案。我们可以添加更多的功能来帮助防止机器人由于自身的重量和惯性而超出或低于目标，以及抑制由这些超出引起的振荡。
- en: A **PID controller** is a type of control system that uses three types of inputs
    to manage a closed-loop control system. A **proportional control** uses a multiple
    of the detected error to drive a control.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**PID控制器**是一种使用三种类型输入来管理闭环控制系统的控制系统。**比例控制**使用检测到的误差的倍数来驱动控制。'
- en: For example, in our pot of water, we measure the error in the temperature. If
    the desired temperature is 100°C and we measure 90°C with our thermometer, then
    the error in the temperature is 10 °C. We need to add more heat by opening the
    valve in proportion to the temperature error. If the error is 0, the change in
    the value is 0\. Let’s say that we try changing the value of the valve by 10%
    for a 10°C error. So we multiply 10°C by 0.01 to set our valve position to +0.1\.
    This 0.01 value is our *P* term or **proportional constant**.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的水壶中，我们测量温度的误差。如果期望的温度是100°C，而我们用温度计测量到90°C，那么温度误差就是10°C。我们需要通过打开阀门按比例增加热量。如果误差是0，那么值的改变也是0。假设我们尝试通过将阀门值改变10%来应对10°C的误差。因此，我们将10°C乘以0.01来设置我们的阀门位置为+0.1。这个0.01值是我们的*P*项或**比例常数**。
- en: In our next sample, we see that the temperature of our pot is now 93°C and our
    error is 7°C. We change our valve position to +0.07, slightly less than before.
    We will probably find that by using this method, we will overshoot the desired
    temperature due to the hysteresis of the water – it takes a while for the water
    to heat up, creating a delay in the response. We will end up overheating the water
    and overshooting our desired temperature. One way to help prevent that is with
    the **D** term of the PID controller, that is, a **derivative** term. You remember
    that a derivative describes the slope of the line of a function – in this case,
    the temperature curve we measure. The *y* axis of our temperature graph is time,
    so we have *delta temperature/delta time*. To add a *D* term to our controller,
    we also add in the difference between the error of the last sample and the error
    of this sample (*-10 – (-7) = -3*). We add this to our control by multiplying
    this value times a constant, *D*. The integral term is just the cumulative sum
    of the error multiplied by a constant we’ll call *I*. We can modify the *P*, *I*,
    and *D* constants to adjust (tune) our PID controller to provide the proper response
    for our control loop – with no overshoots, undershoots, or drifts. More explanation
    is available at [https://jjrobots.com/pid/](https://jjrobots.com/pid/). The point
    of these examples is to point out the concept of control in a machine – we have
    to take measurements, compare them to our desired result, compute the error signal,
    and then make any corrections to the controls over and over many times a second,
    and doing that consistently is the concept of real-time control.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个示例中，我们看到我们的锅温现在是93°C，我们的误差是7°C。我们将阀门位置更改为+0.07，略低于之前。我们可能会发现，由于水的滞后性，使用这种方法，我们可能会超过期望的温度——因为水加热需要一段时间，这会在响应中造成延迟。最终，我们可能会过度加热水并超过期望的温度。防止这种情况的一种方法是在PID控制器的**D**项，即**导数**项。你还记得导数描述的是函数线的斜率——在这种情况下，我们测量的温度曲线。我们温度图的*Y*轴是时间，所以我们有*温度变化/时间变化*。为了在我们的控制器中添加一个*D*项，我们还添加了上一次样本误差和这次样本误差之间的差异（-10
    – (-7) = -3）。我们通过将这个值乘以一个常数*D*来添加到我们的控制中。积分项只是误差乘以一个常数的累积总和，我们可以称之为*I*。我们可以修改*P*、*I*和*D*常数来调整（调谐）我们的PID控制器，以提供适当的响应，以控制回路——没有超调、欠调或漂移。更多解释请参阅[https://jjrobots.com/pid/](https://jjrobots.com/pid/)。这些示例的目的是指出机器控制的概念——我们必须进行测量，将它们与我们的期望结果进行比较，计算误差信号，然后多次每秒进行任何控制修正，并且持续这样做是实时控制的概念。
- en: Types of control loops
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 控制回路类型
- en: 'In order to perform our control loop at a consistent time interval (or to use
    the proper term, deterministically), we have two ways of controlling our program
    execution: **soft real time** and **hard real time**. Hard real-time control systems
    require assistance from the hardware of the computer – that is where the *hard*
    part of the title comes from. Hard real time generally requires a **real-time
    operating system** (**RTOS**) or complete control over all of the computer cycles
    in the processor. The problem we are faced with is that a computer running an
    operating system is constantly getting interrupted by other processes, chaining
    threads, switching contexts, and performing tasks. Your experience with desktop
    computers, or even smartphones, is that the same process, such as starting up
    a word processor program, always seems to take a different amount of time whenever
    you start it up.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以一致的时间间隔执行我们的控制回路（或者使用正确的术语，确定性地），我们有两种控制程序执行的方法：**软实时**和**硬实时**。硬实时控制系统需要计算机硬件的帮助——这就是标题中“硬”的部分的由来。硬实时通常需要一个**实时操作系统**（**RTOS**）或对处理器中所有计算机周期的完全控制。我们面临的问题是，运行操作系统的计算机始终被其他进程、线程链、上下文切换和执行任务所中断。你在桌面计算机或甚至智能手机上的经验是，启动相同的过程，如启动文字处理程序，每次启动时似乎总是需要不同的时间。
- en: This sort of behavior is intolerable in a real-time system where we need to
    know in advance exactly how long a process will take down to the microsecond.
    You can easily imagine the problems if we created an autopilot for an airliner
    that, instead of managing the aircraft’s direction and altitude, was constantly
    getting interrupted by disk drive access or network calls that played havoc with
    the control loops giving you a smooth ride or making a touchdown on the runway.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在实时系统中，我们需要提前确切知道一个进程将花费多长时间，甚至到微秒级别，这种行为是无法容忍的。你可以很容易地想象，如果我们为飞机创建了一个自动驾驶仪，它不是管理飞机的方向和高度，而是不断地被磁盘驱动器访问或网络调用中断，这些调用会破坏控制循环，导致平稳的飞行或跑道上的着陆，会出现什么问题。
- en: An RTOS system allows the programmers and developers to have complete control
    over when and how the processes execute and which routines are allowed to interrupt
    and for how long. Control loops in RTOS systems always take the exact same number
    of computer cycles (and thus time) every loop, which makes them reliable and dependable
    when the output is critical. It is important to know that in a hard real-time
    system, the hardware enforces timing constraints and makes sure that the computer
    resources are available when they are needed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 实时操作系统（RTOS）系统允许程序员和开发者完全控制进程何时以及如何执行，以及哪些例程可以中断以及中断多长时间。RTOS系统中的控制循环在每次循环中总是消耗相同数量的计算机周期（因此是时间），这使得当输出至关重要时，它们既可靠又可信赖。重要的是要知道，在硬实时系统中，硬件强制执行时间约束，并确保计算机资源在需要时可用。
- en: We can actually do hard real time in an Arduino microcontroller because it has
    no operating system and can only do one task at a time or run only one program
    at a time. Our robot will also have a more capable processor in the form of an
    Nvidia Nano running Linux. This computer, which has some real power, does a number
    of tasks simultaneously to support the operating system, run the network interface,
    send graphics to the output HDMI port, provide a user interface, and even support
    multiple users.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以在Arduino微控制器中实现硬实时，因为它没有操作系统，一次只能执行一个任务或运行一个程序。我们的机器人也将拥有一个更强大的处理器，即运行Linux的Nvidia
    Nano。这台计算机拥有一些真正的实力，可以同时执行多项任务以支持操作系统，运行网络接口，将图形发送到输出HDMI端口，提供用户界面，甚至支持多个用户。
- en: Soft real time is a bit more of a relaxed approach, and is more appropriate
    to our playroom-cleaning robot than a safety-critical hard real-time system –
    plus, RTOSs can be expensive (there are open source versions) and require special
    training for you. What we are going to do is treat our control loop as a feedback
    system. We will leave some extra room – say about 10% – at the end of each cycle
    to allow the operating system to do its work, which should leave us with a consistent
    control loop that executes at a constant time interval. Just like our control
    loop example that we just discussed, we will take a measurement, determine the
    error, and apply a correction to each cycle.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 软实时是一种更为宽松的方法，更适合我们的游戏室清洁机器人，而不是一个安全关键的硬实时系统——此外，RTOS可能很昂贵（有开源版本）并且需要特殊培训。我们将要做的是将我们的控制循环视为一个反馈系统。我们将在每个循环的末尾留出一些额外的空间——比如说大约10%——以便操作系统完成其工作，这应该会给我们留下一个执行在恒定时间间隔上的一致控制循环。就像我们刚才讨论的控制循环示例一样，我们将进行测量，确定误差，并对每个循环应用校正。
- en: We are not just worried about our update rate. We also must worry about **jitter**,
    or random variability in the timing loop caused by the operating system getting
    interrupted and doing other things. An interrupt will cause our timing loop to
    take longer, causing a random jump in our cycle time. We have to design our control
    loops to handle a certain amount of jitter for soft real time, but these are comparatively
    infrequent events.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅担心我们的更新速率。我们还必须担心**抖动**，即由于操作系统被中断并执行其他操作而引起的定时循环中的随机变化。中断会导致我们的定时循环变长，导致周期时间的随机跳跃。我们必须设计我们的控制循环来处理软实时中一定量的抖动，但这些事件相对较少。
- en: Running a control loop
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行控制循环
- en: The process of running a control loop is fairly simple in practice. We start
    by initializing our timer, which needs to be the high-resolution clock. We are
    writing our control loop in Python, so we will use the `time.time()` function,
    which is specifically designed to measure our internal program timing performance
    (set frame rate, do loop, measure time, generate error, sleep for error, loop).
    Each time we call `time.time()`, we get a floating-point number, which is the
    number of seconds from the Unix clock and has microsecond resolution on the Nvidia
    Nano.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上运行控制循环的过程相当简单。我们首先初始化计时器，它需要是高分辨率时钟。我们用Python编写控制循环，所以我们将使用`time.time()`函数，该函数专门设计用来测量我们内部程序的时间性能（设置帧率，执行循环，测量时间，生成错误，睡眠以纠正错误，循环）。每次我们调用`time.time()`，我们都会得到一个浮点数，这是从Unix时钟以来的秒数，并且具有Nvidia
    Nano上的微秒级分辨率。
- en: The concept for this process is to divide our processing into a set of fixed
    time intervals we will call **frames**. Everything we do will fit within an integral
    number of frames. Our basic running speed will process 30 **frames per second**
    (**fps**). That is how fast we will be updating the robot’s position estimate,
    reading sensors, and sending commands to motors. We have other functions that
    run slower than the 30 frames, so we can divide them between frames in even multiples.
    Some functions run every frame (30 fps) and are called and executed every frame.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的理念是将我们的处理分成一组固定的时间间隔，我们称之为**帧**。我们做的所有事情都将适合在整数的帧数内。我们的基本运行速度将以每秒30 **帧**（**fps**）的速度处理。这就是我们将更新机器人的位置估计、读取传感器和向电机发送命令的速度。我们还有运行速度低于30
    fps的其他函数，因此我们可以将它们均匀地分配到帧之间。一些函数每帧运行一次（30 fps）并且每帧被调用和执行。
- en: Let’s say that we have a sonar sensor that can only update 10 times a second.
    We call the *read sonar* function every third frame. We assign all our functions
    to be some multiple of our basic 30 fps frame rate, so we have 30, 15, 10, 7.5,
    6, 5, 4.28, 2, and 1 fps if we call the functions every frame, every second frame,
    every third frame, and so on. We can even do less than 1 fps – a function called
    every 60 frames executes once every 2 seconds.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个只能每秒更新10次的声纳传感器。我们每隔三帧调用一次**读取声纳**函数。我们将所有函数分配为基本30 fps帧率的倍数，因此如果我们每帧调用函数，我们将有30
    fps、15 fps、10 fps、7.5 fps、6 fps、5 fps、4.28 fps、2 fps和1 fps。我们甚至可以做到小于1 fps – 每隔60帧调用一次的函数每2秒执行一次。
- en: 'The tricky bit is we need to make sure that each process fits into one frame
    time – which is 1/30 of a second or 0.033 seconds or 33 milliseconds. If the process
    takes longer than that, we have to either divide it up into parts or run it in
    a separate thread or program where we can start the process in one frame and get
    the result in another. It is also important to try and balance the frames so that
    not all processing lands in the same frame. The following figure shows a task
    scheduling system based on a 30 fps basic rate. Here, we have four tasks to take
    care of: task *A* runs at 15 fps, task *B* runs at 6 fps (every five frames),
    task *C* runs at 10 fps (every three frames), and task *D* runs at 30 fps (every
    frame):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 困难之处在于我们需要确保每个过程都适合在一个帧时间内完成 – 这相当于1/30秒或0.033秒或33毫秒。如果过程需要更长的时间，我们必须将其分成几个部分，或者在一个单独的线程或程序中运行，这样我们可以在一个帧中开始过程，并在另一个帧中得到结果。尝试平衡帧也很重要，以便不是所有的处理都落在同一个帧上。以下图显示了基于30
    fps基本速率的任务调度系统。在这里，我们有四个任务需要处理：任务*A*以15 fps运行，任务*B*以6 fps运行（每五帧一次），任务*C*以10 fps运行（每三帧一次），任务*D*以30
    fps运行（每帧一次）：
- en: '![Figure 1.7 – Frame-based task schedule](img/B19846_01_7.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7 – 基于帧的任务调度](img/B19846_01_7.jpg)'
- en: Figure 1.7 – Frame-based task schedule
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 基于帧的任务调度
- en: Our first pass (the top of the figure) at the schedule has all four tasks landing
    on the same frame at frames 1, 13, and 25\. We can improve the balance of the
    load on the control program if we delay the start of task *B* on the second frame
    as shown in the bottom half of the diagram.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对调度表的第一遍（图的最上方）显示所有四个任务在帧1、13和25上落在同一个帧上。如果我们像图的下半部分所示的那样在第二帧延迟任务*B*的开始，我们可以改善控制程序负载的平衡。
- en: This is akin to how measures in music work, where a measure is a certain amount
    of time, and different notes have different intervals – one whole note can only
    appear once per measure, a half note can appear twice, all the way down to 64th
    notes. Just like a composer makes sure that each measure has the right number
    of beats, we can make sure that our control loop has a balanced measure of processes
    to execute each frame.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于音乐中的度量方式，其中度量是一定的时间，不同的音符有不同的间隔——一个全音符每度量只能出现一次，一个二分音符可以出现两次，一直到最后是64分音符。就像作曲家确保每个度量有正确数量的拍子一样，我们也可以确保我们的控制循环在每个帧中执行平衡的度量过程。
- en: Let’s start by writing a little program to control our timing loop and to let
    you play with these principles.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先写一个小程序来控制我们的定时循环，并让你玩这些原则。
- en: 'This is exciting – our first bit of coding together. This program just demonstrates
    the timing control loop we are going to use in the main robot control program
    and is here to let you play around with some parameters and see the results. This
    is the simplest version I think is possible of a soft time-controlled loop, so
    feel free to improve and embellish it. I’ve made you a flowchart to help you understand
    this a little better:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这很令人兴奋——我们第一次一起编写代码。这个程序只是演示了我们将在主机器人控制程序中使用的定时控制循环，并且在这里让你可以玩一些参数并查看结果。这是我认为可能的最简单的软时间控制循环版本，所以请随意改进和装饰它。我已经为你制作了一个流程图，以帮助你更好地理解：
- en: '![Figure 1.8 – Flowchart of soft real-time controller](img/B19846_01_8.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.8 – 软实时控制器流程图](img/B19846_01_8.jpg)'
- en: Figure 1.8 – Flowchart of soft real-time controller
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – 软实时控制器流程图
- en: 'Let’s look more closely at the terms used in the preceding diagram:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看前面图中使用的术语：
- en: '**FrameTime**: The time we have allocated to execute one iteration of the loop'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**帧时间**：我们分配给执行循环一次迭代的时间'
- en: '**StartTime**: When the loop/frame begins'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始时间**：循环/帧开始时'
- en: '**Do a Bunch of Math**: The program that you are managing'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进行大量数学运算**：你正在管理的程序'
- en: '**StopTime**: When the frame completes'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止时间**：帧完成时'
- en: '**Remaining Time**: The difference between the elapsed time and the desired
    frame time'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**剩余时间**：已过时间与期望帧时间的差'
- en: '**Elapsed Time**: The time it takes to actually run through the loop once'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已过时间**：实际运行一次循环所需的时间'
- en: '**Frame Sleep Time**: We use **Remaining Time** to tell the computer to sleep
    so that the frame takes exactly the amount of time we want.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**帧睡眠时间**：我们使用**剩余时间**来告诉计算机睡眠，以便帧正好花费我们想要的时间。'
- en: 'Now we’ll begin with coding. This is pretty straightforward Python code – we
    won’t get fancy until later:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将开始编码。这是一段相当直接的Python代码——我们不会在后面变得复杂：
- en: 'We start by importing our libraries. It is not surprising that we start with
    the `time` module. We also will use the `mean` function from `numpy` (Python numerical
    analysis) and `matplotlib` to draw our graph at the end. We will also be doing
    some math calculations to simulate our processing and create a load on the frame
    rate:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先导入我们的库。我们首先从`time`模块开始并不奇怪。我们还将使用`numpy`（Python数值分析）中的`mean`函数和`matplotlib`来在最后绘制我们的图表。我们还将进行一些数学计算来模拟我们的处理并创建对帧率的负载：
- en: '[PRE0]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we have some parameters to control our test. This is where you can experiment
    with different timings. Our basic control is `FRAMERATE` – how many updates per
    second do we want to try? Let’s start with `30`, as we did in the example we discussed
    earlier:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一些参数来控制我们的测试。这是你可以尝试不同定时的地方。我们的基本控制是`FRAMERATE`——我们想要尝试每秒更新多少次？让我们从`30`开始，就像我们在之前讨论的例子中做的那样：
- en: '[PRE1]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The duration of the test is set by the `counter` variable. The time the test
    will take is the `FRAME` time times the number of cycles in `counter`. In our
    example, 2,000 frames divided by 30 fps is 66.6 seconds, or a bit over a minute
    to run the test:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试的持续时间由`counter`变量设置。测试将花费的时间是`FRAME`时间乘以`counter`中的循环次数。在我们的例子中，2,000帧除以30
    fps等于66.6秒，或者略超过一分钟来运行测试：
- en: '[PRE2]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will be controlling our timing loop in two ways:'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将以两种方式控制我们的定时循环：
- en: We will first measure the amount of time it takes to perform the calculations
    for this frame. We have a stub of a program with some trigonometry functions we
    will call to put a load on the computer. Robot control functions, such as computing
    the angles needed in a robot arm, need lots of trig to work. This is available
    from `import math` in the header of the program.
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将首先测量执行此帧计算所需的时间。我们有一个带有一些我们将调用的三角函数的示例程序，以向计算机添加负载。例如，机器人控制函数，如计算机器人臂所需的角，需要大量的三角运算。这可以从程序头部的`import
    math`中获取。
- en: Note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will measure the time for our control function to run, which will take some
    part of our frame. We then compute how much of our frame remains, and tell the
    computer to sleep this process for the rest of the time. Using the `sleep` function
    releases the computer to go and take care of other business in the operating system,
    and is a better way to mark time rather than running a tight loop of some sort
    to waste the rest of our frame time.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将测量控制函数运行的时间，这将占用我们帧的一部分。然后我们计算我们帧剩余的部分，并告诉计算机在这段时间内睡眠此进程。使用`sleep`函数释放计算机去处理操作系统中的其他事务，这是一种比运行某种紧密循环来浪费我们帧剩余时间更好的标记时间的方法。
- en: 'The second way we control our loop is by measuring the complete frame – compute
    time plus rest time – and looking to see whether we are over or under our frame
    time. We use `TIME_CORRECTION` for this function to trim our sleep time to account
    for variability in the sleep function and any delays getting back from the operating
    system:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们控制循环的第二种方式是通过测量整个帧的时间——计算时间加上休息时间——并查看我们是否超出了或低于帧时间。我们使用`TIME_CORRECTION`为此功能调整睡眠时间，以考虑睡眠函数的变异性以及从操作系统返回的任何延迟：
- en: '[PRE3]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will collect some data to draw a jitter graph at the end of the program.
    We use the `dataStore` structure for this. Let’s put a header on the screen to
    tell you the program has begun, since it takes a while to finish:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在程序结束时收集一些数据来绘制一个抖动图。我们使用`dataStore`结构来完成这项工作。让我们在屏幕上放一个标题来告诉您程序已经开始，因为完成它需要一段时间：
- en: '[PRE4]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this step, we are going to set up some variables to measure our timing.
    As we mentioned, the objective is to have a bunch of compute frames, each the
    same length. Each frame has two parts: a `myTime` is the *top of frame* time,
    when the frame begins. `newTime` is the end of the work period timer. We use `masterTime`
    to compute the total time the program is running:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步，我们将设置一些变量来测量我们的时间。正如我们提到的，目标是有一系列计算帧，每个帧的长度都相同。每个帧有两个部分：`myTime`是帧的*顶部时间*，即帧开始时的时间。`newTime`是工作周期计时器的结束。我们使用`masterTime`来计算程序运行的总时间：
- en: '[PRE5]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This section is our **payload** – the section of the code doing the work. This
    might be an arm angle calculation, a state estimate, or a command interpreter.
    We’ll stick in some trig functions and some math to get the CPU to do some work
    for us. Normally, this *working* section is the majority of our frame, so let’s
    repeat these math terms 1,000 times:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个部分是我们的**有效载荷**——执行工作的代码部分。这可能是臂角计算、状态估计或命令解释器。我们将插入一些三角函数和一些数学运算，让CPU为我们做一些工作。通常，这个*工作*部分是我们帧的大部分，所以让我们重复这些数学术语1,000次：
- en: '[PRE6]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we read the clock to find the working time. We can now compute how long
    we need to sleep the process before the next frame. The important part is that
    *working time + sleep time = frame time*. I’ll call this `timeError`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们读取时钟以找到工作时间。我们现在可以计算出在下一个帧之前需要睡眠进程多长时间。重要的是*工作时间 + 睡眠时间 = 帧时间*。我将称这个为`timeError`：
- en: '[PRE7]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We carry forward some information from the previous frame here. `TIME_CORRECTION`
    is our adjustment for any timing errors in the previous frame time. We initialized
    it earlier to zero before we started our loop so we don’t get an undefined variable
    error here. We also do some range checking because we can get some large jitters
    in our timing caused by the operating system that can cause our sleep timer to
    crash if we try to sleep a negative amount of time:'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里向前传递一些来自前一帧的信息。`TIME_CORRECTION`是我们对前一帧时间中任何时间错误的调整。我们在开始循环之前将其初始化为零，以避免在这里出现未定义变量错误。我们还进行了一些范围检查，因为我们可能会因为操作系统而得到一些大的抖动，这可能导致如果我们尝试睡眠负时间，我们的睡眠计时器会崩溃：
- en: Note
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We use the Python `max` function as a quick way to clamp the value of sleep
    time to be zero or greater. It returns the greater of two arguments. The alternative
    is something like *if a< 0 :* *a=0*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '我们使用Python的`max`函数作为快速将睡眠时间限制为零或更大的方法。它返回两个参数中较大的一个。另一种方法是类似这样的代码：`if a < 0
    : a = 0`。'
- en: '[PRE8]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So, here is our actual sleep command. The `sleep` command does not always provide
    a precise time interval, so we will be checking for errors:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，这是我们实际的睡眠命令。`sleep`命令并不总是提供精确的时间间隔，因此我们将检查错误：
- en: '[PRE9]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is the time correction section. We figure out how long our frame time
    was in total (working and sleeping) and subtract it from what we want the frame
    time to be (`FrameTime`). Then we set our time correction to that value. I’m also
    going to save the measured frame time into a data store so we can graph how we
    did later using `matplotlib`. This technique is one of Python’s more useful features:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是时间校正部分。我们计算出我们的帧时间总共有多长（工作和睡眠时间）并从我们希望帧时间达到的值（`FrameTime`）中减去。然后我们将时间校正设置为该值。我还会将测量的帧时间保存到数据存储中，这样我们就可以使用`matplotlib`来绘制我们之后的图表。这种技术是Python更有用的特性之一：
- en: '[PRE10]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This completes the looping section of the program. This example does 2,000 cycles
    of 30 frames a second and finishes in 66.6 seconds. You can experiment with different
    cycle times and frame rates.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这完成了程序的循环部分。这个例子做了每秒30帧的2000个周期，并在66.6秒内完成。你可以尝试不同的周期时间和帧率。
- en: 'Now that we have completed the program, we can make a little report and a graph.
    We print out the frame time and total runtime, compute the average frame time
    (total time/counter), and display the average error we encountered, which we can
    get by averaging the data in `dataStore`:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了程序，我们可以制作一个小报告和图表。我们打印出帧时间和总运行时间，计算平均帧时间（总时间/计数器），并显示我们遇到的平均误差，这可以通过平均`dataStore`中的数据来获得：
- en: '[PRE11]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The results from our program are shown in the following code block. Note that
    the average error is just 0.00018 of a second, or 0.18 milliseconds out of a frame
    of 33 milliseconds:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们程序的结果在下面的代码块中显示。请注意，平均误差仅为0.00018秒，或者说在33毫秒的帧中只有0.18毫秒：
- en: '[PRE12]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following figure shows the timing graph of our program:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了我们的程序计时图：
- en: '![Figure 1.9 – Timing graph of our program](img/B19846_01_10.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图1.9 – 我们程序的计时图](img/B19846_01_10.jpg)'
- en: Figure 1.9 – Timing graph of our program
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 – 我们程序的计时图
- en: The *spikes* in the image are jitter caused by operating system interrupts.
    You can see the program controls the frame time in a fairly narrow range. If we
    did not provide control, the frame time would get greater and greater as the program
    executed. The graph shows that the frame time stays in a narrow range that keeps
    returning to the correct value.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图像中的*尖峰*是由操作系统中断引起的抖动。你可以看到程序在相当狭窄的范围内控制帧时间。如果我们不提供控制，随着程序的执行，帧时间会越来越大。图表显示帧时间保持在狭窄的范围内，并不断回到正确的值。
- en: 'Now that we have exercised our programming muscles, we can apply this knowledge
    to the main control loop for our robot with soft real-time control. This control
    loop has two primary functions:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经锻炼了我们的编程肌肉，我们可以将这种知识应用到我们的机器人主控制循环中，实现软实时控制。这个控制循环有两个主要功能：
- en: Respond to commands from the control station
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应来自控制站的命令
- en: Interface to the robot’s motors and sensors in the Arduino Mega
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino Mega中与机器人电机和传感器的接口
- en: We will discuss this in detail in [*Chapter 7*](B19846_07.xhtml#_idTextAnchor221).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第7章*](B19846_07.xhtml#_idTextAnchor221)中详细讨论。
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we introduced the subject of AI, which will be emphasized
    throughout this book. We identified the main difference between an AI robot and
    a *regular* robot, which is that an AI robot may be nondeterministic. This is
    to say it may have a different response to the same stimulus, due to learning.
    We introduced the problem we will use throughout the book, which is picking up
    toys in a playroom and putting them into a toy box. Next, we discussed two critical
    tools for AI robotics: the OODA loop, which provides a model for how our robot
    makes decisions, and the soft real-time control loop, which manages and controls
    the speed of execution of our program. We applied these techniques in a timing
    loop demonstration and began to develop our main robot control program.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了人工智能的主题，这一主题将在整本书中得到强调。我们确定了人工智能机器人和*普通*机器人之间的主要区别，即人工智能机器人可能是非确定性的。这意味着它可能对相同的刺激有不同的反应，这是由于学习造成的。我们介绍了本书将使用的主题，即在一个游戏室里捡起玩具并将它们放入玩具箱。接下来，我们讨论了人工智能机器人两个关键工具：OODA循环，它为我们机器人如何做出决策提供了一个模型，以及软实时控制循环，它管理和控制我们程序执行的速率。我们在计时循环演示中应用了这些技术，并开始开发我们的主要机器人控制程序。
- en: In the next chapter, we will teach the robot to recognize toys – the objects
    we want the robot to pick up and put away. We will use computer vision with a
    video camera to find and recognize the toys left on the floor.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将教机器人识别玩具——我们希望机器人捡起并放回的对象。我们将使用带有视频摄像头的计算机视觉来寻找和识别地板上留下的玩具。
- en: Questions
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What does the acronym *PID* stand for? Is this considered an AI software method?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缩写*PID*代表什么？这被认为是人工智能软件方法吗？
- en: What is the Turing test? Do you feel this is a valid method of assessing AI?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图灵测试是什么？您觉得这是评估AI的有效方法吗？
- en: Why do you think robots have a problem with negative obstacles such as stairs
    and potholes?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您认为为什么机器人会与负向障碍物（如楼梯和坑洼）有问题？
- en: In the OODA loop, what does the *Orient* step do?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在OODA循环中，*Orient*步骤做什么？
- en: From the discussion of Python and its advantages, compute the following. Your
    program needs 50 changes tested. Assuming each change requires a recompile step
    and one run to test, a C Make compile takes 450 seconds and a Python `run` command
    takes 3 seconds. How much time do you sit idle waiting on the compiler?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Python及其优势的讨论中，计算以下内容。您的程序需要测试50次更改。假设每次更改都需要重新编译步骤和一个运行步骤来测试，C Make编译需要450秒，Python
    `run`命令需要3秒。您在等待编译器时空闲了多少时间？
- en: What does RTOS stand for?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RTOS代表什么？
- en: 'Your robot has the following scheduled tasks: telemetry at 10 Hz, GPS at 5
    Hz, inertial measurements at 50 Hz, and motor control at 20 Hz. At what frequency
    would you schedule the base task, and what intervals would you use for the slower
    tasks (i.e., 10 Hz base, motors every three frames, telemetry every two frames,
    etc.)?'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的机器人有以下预定任务：遥测频率为10 Hz，GPS频率为5 Hz，惯性测量频率为50 Hz，电机控制频率为20 Hz。您将如何安排基础任务的频率，以及您将使用什么间隔来安排较慢的任务（例如，10
    Hz的基础频率，每三帧一次电机控制，每两帧一次遥测等）？
- en: Given that a frame rate scheduler has the fastest task at 20 fps, how would
    you schedule a task that needs to run at 7 fps? How about one that runs at 3.5
    fps?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设一个帧率调度器最快的任务频率为20 fps，您会如何安排需要以7 fps运行的任务？对于以3.5 fps运行的任务呢？
- en: What is a blocking call function? Why is it bad to use blocking calls in a real-time
    system like a robot?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是阻塞调用函数？为什么在像机器人这样的实时系统中使用阻塞调用是不好的？
- en: Further reading
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can refer to the following resources for further details:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下资源以获取更多详细信息：
- en: '*Effective Robotics Programming with ROS – Third Edition*, by Anil Mahtani,
    Luis Sanchez, and Enreque Fernandez Perdomo, Packt Publishing, 2016'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《ROS高效机器人编程 - 第三版》*，作者Anil Mahtani，Luis Sanchez，Enreque Fernandez Perdomo，Packt
    Publishing，2016'
- en: '*Introduction to AI Robotics – Second Edition* by Robin R. Murphy, Bradford
    Books, 2019'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《人工智能机器人导论 - 第二版》*，作者Robin R. Murphy，Bradford Books，2019'
- en: '*Real-Time scheduling: from hard to soft real-time systems*, a whitepaper by
    Palopoli Lipari, 2015 ([https://arxiv.org/pdf/1512.01978.pdf](https://arxiv.org/pdf/1512.01978.pdf))'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《实时调度：从硬实时到软实时系统》*，Palopoli Lipari撰写的一份白皮书，2015 ([https://arxiv.org/pdf/1512.01978.pdf](https://arxiv.org/pdf/1512.01978.pdf))'
- en: '*Boyd: The Fighter Pilot Who Changed the Art of War*, by Robert Coram, Little,
    Brown and Company, 2002'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《改变战争艺术的飞行员：博伊德》*，作者Robert Coram，Little, Brown and Company，2002'
