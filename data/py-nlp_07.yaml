- en: Rule-Based System for NLP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于规则的自然语言处理系统
- en: 'We learned to derive various features by using the concepts of linguistics
    and statistics in [Chapter 5](07f71ca1-6c8a-492d-beb3-a47996e93f04.xhtml), *Feature
    Engineering and NLP Algorithms* and [Chapter 6](c4861b9e-2bcf-4fce-94d4-f1e2010831de.xhtml),
    *Advanced Feature Engineering and NLP Algorithms*. For developing an NLP application,
    these features are going to be fed into the algorithms. These algorithms take
    features as input. As you know, we are referring to algorithms as black boxes
    that perform some kind of magic and gives us the appropriate output. Refer to
    *Figure 7.1*, which demonstrates our journey so far:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 5 章](07f71ca1-6c8a-492d-beb3-a47996e93f04.xhtml)，*特征工程与自然语言处理算法*，以及[第
    6 章](c4861b9e-2bcf-4fce-94d4-f1e2010831de.xhtml)，*高级特征工程与自然语言处理算法*中，学习了如何利用语言学和统计学的概念来推导各种特征。为了开发一个自然语言处理应用，这些特征将作为输入传递给算法。这些算法将特征作为输入。正如你所知道的，我们将算法称为黑盒，它们执行某种魔法并给我们相应的输出。参考*图
    7.1*，展示了我们至今为止的学习过程：
- en: '![](img/177ea531-388f-40dd-aaf5-590ead0a3f4e.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/177ea531-388f-40dd-aaf5-590ead0a3f4e.png)'
- en: 'Figure 7.1: Stages we have learned so far'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：我们迄今为止学习的阶段
- en: Congratulations, you have learned a lot about NLP, and specifically about the
    NLU!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经学到了很多关于自然语言处理的知识，特别是关于自然语言理解（NLU）的知识！
- en: Now, it is high time for us to explore the algorithms which we use to develop
    NLP applications. We refer to these algorithms, techniques, or approaches as our
    black boxes and their logic is works as some magic for us. Now, it's time to dive
    deep into these black boxes and understand the magic.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候探索我们用来开发自然语言处理应用的算法了。我们将这些算法、技术或方法称为我们的黑盒，它们的逻辑就像是某种魔法一样。现在，是时候深入了解这些黑盒并理解其中的奥秘了。
- en: 'Algorithms (implementation techniques or approaches) for NLP applications can
    be divided into two parts. Refer to *Figure 7.2*:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 自然语言处理应用的算法（实现技术或方法）可以分为两部分。参考*图 7.2*：
- en: '![](img/6ac4fc1a-6734-4476-bf61-e64c3b495e59.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ac4fc1a-6734-4476-bf61-e64c3b495e59.png)'
- en: 'Figure 7.2: Algorithms or approaches or implementation techniques for black
    boxes'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：黑盒的算法、方法或实现技术
- en: We will look at the **rule-based** (**RB**) system in this chapter and machine
    learning approaches in [Chapter 8](97808151-90d2-4034-8d53-b94123154265.xhtml),
    *Machine Learning for NLP Problems* and [Chapter 9](f414d38e-b88e-4239-88bd-2d90e5ce67ab.xhtml),
    *Deep Learning for NLP and NLG Problems*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论**基于规则的**（**RB**）系统，以及[第 8 章](97808151-90d2-4034-8d53-b94123154265.xhtml)，*自然语言处理问题的机器学习*，和[第
    9 章](f414d38e-b88e-4239-88bd-2d90e5ce67ab.xhtml)，*自然语言处理和自然语言生成问题的深度学习*中的机器学习方法。
- en: 'In this chapter, we are going to focus on the rule-based system. We are going
    to touch upon the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点介绍基于规则的系统。我们将讨论以下主题：
- en: Understanding of the RB system
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 RB 系统
- en: Purpose of having the RB system
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于规则的系统的目的
- en: Architecture of the RB system
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RB 系统架构
- en: Understanding the RB system development life cycle
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 RB 系统开发生命周期
- en: Applications
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用
- en: Developing NLP applications using the RB system
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 RB 系统开发自然语言处理应用
- en: Comparing the RB approach with other approaches
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 RB 方法与其他方法进行比较
- en: Advantages
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优势
- en: Disadvantages
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺点
- en: Challenges
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挑战
- en: Recent trends for the RB system
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RB 系统的最新趋势
- en: So, let's get started!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: Understanding of the rule-based system
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解基于规则的系统
- en: RB systems are also known as **knowledge-based systems**. But first, we will
    see what the RB system means and what it does for us? What kind of NLP applications
    can be implemented by using this approach? For a better understanding, I will
    explain the concepts with the help of the applications.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: RB 系统也被称为**知识基础系统**。但首先，我们将了解 RB 系统的含义以及它为我们做了什么？通过这种方法可以实现哪些类型的自然语言处理应用？为了更好地理解，我将通过应用实例来解释这些概念。
- en: What does the RB system mean?
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RB 系统是什么意思？
- en: 'The rule-based system is defined as by using available knowledge or rules,
    we develop such a system which uses the rules, apply the available system rules
    on a corpus and try to generate or inference the results. Refer *Figure 7.3*,
    which will give you an idea about the RB system:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 基于规则的系统是通过使用现有的知识或规则，我们开发出这样一个系统，利用规则将现有的系统规则应用于语料库，并尝试生成或推理结果。参考*图 7.3*，这将为你提供关于
    RB 系统的概念：
- en: '![](img/d8a699c8-d489-42d4-9204-daaa0baff37c.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8a699c8-d489-42d4-9204-daaa0baff37c.png)'
- en: 'Figure 7.3: Rule based system input/output flow'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：基于规则的系统输入/输出流程
- en: In short, you can say that the RB system is all about applying real-life rules
    or experiences to a available corpus, manipulating information as per the rules,
    and deriving certain decisions or results. Here, rules are generated or created
    by humans.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，你可以说，RB系统就是将现实生活中的规则或经验应用于可用语料库，按照规则操作信息，并得出某些决策或结果。在这里，规则是由人类生成或创建的。
- en: The RB system is used for interpreting available corpus (information) in a useful
    manner. Here, rules act as core logic for the RB system. The corpus is interpreted
    based on rules or knowledge, so our end result is dependent on these two factors,
    one is rules and the second is our corpus.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: RB系统用于以有用的方式解释现有语料库（信息）。在这里，规则作为RB系统的核心逻辑。语料库是基于规则或知识进行解释的，因此我们的最终结果取决于这两个因素，一个是规则，另一个是我们的语料库。
- en: Now I will explain one of the **AI** (**Artificial Intelligence**) applications
    for getting the core essence of the RB system.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将解释一种**AI**（**人工智能**）应用程序，以便理解RB系统的核心本质。
- en: As humans, we all do very complicated work every day to perform some tasks.
    To perform tasks, we use our prior experiences or follow rules to successfully
    complete the task.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作为人类，我们每天都做非常复杂的工作以完成某些任务。为了完成任务，我们使用先前的经验或遵循规则来成功地完成任务。
- en: 'Take an example: If you are driving a car, you are following some rules. You
    have prior knowledge of these rules. Now, if you think about the self-driving
    car, then that car should react or perform the entire task that a human was doing
    previously. But cars don''t understand how to drive automatically without a driver.
    To develop this kind of driver less car is quite complicated, as well as challenging.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子：如果你在开车，你会遵循一些规则。你对这些规则有先前的了解。现在，如果你考虑自动驾驶汽车，那么这辆车应该反应并执行人类之前所做的整个任务。但汽车不能理解如何在没有驾驶员的情况下自动驾驶。开发这种无人驾驶汽车是相当复杂且具有挑战性的。
- en: 'Anyhow, you want to create a self-driving car. You know there are so many rules
    that the car needs to learn in order to perform as well as a human driver. Here
    you have a few major challenges:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，你想要创造一辆无人驾驶汽车。你知道汽车需要学习很多规则才能像人类驾驶员一样表现得那么好。在这里，你面临一些主要挑战：
- en: This is a kind of complicated application
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一种复杂的应用
- en: Lots of rules as well as situations need to be learned by the car
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汽车需要学习大量的规则和情况。
- en: The accuracy of the self-driving car should be high enough to launch it on the
    market for the consumer
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无人驾驶汽车的准确度应足够高，才能将其推向市场供消费者使用。
- en: 'So, to solve the challenges, we follow various steps:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了解决这些挑战，我们遵循以下几个步骤：
- en: We first try to reduce the problem statement to small chunks of a problem which
    is a subset of our original problem statement.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先尝试将问题陈述分解为问题的小块，这些小块是原始问题陈述的一个子集。
- en: We try to solve small chunks of the problem first.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先尝试解决问题的小块部分。
- en: To solve it, we are trying to come up with generalized rules that help us to
    solve our problem as well as help us to achieve our end goal.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们正在尝试提出一些通用规则，这些规则帮助我们解决问题，并帮助我们实现最终目标。
- en: For our version of the driver less (self-driving) car, we need to think from
    the software perspective. So, what is the first step the car should learn? Think!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们版本的无人驾驶汽车，我们需要从软件的角度来思考。那么，汽车应该首先学习的步骤是什么？想一想！
- en: The car should learn to see and identify objects on the road. This is the first
    step for our car and we define some generalized rules which the car will use to
    learn and decide whether there is any object on the road?, then drive based on
    that. What should the speed of the car when it sees road conditions? And so on,
    (think right now using the rule-based system, and for some time don't think about
    the deep learning aspect to solve this step).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这辆车应该学会看到并识别道路上的物体。这是我们汽车的第一步，我们定义了一些通用规则，汽车将使用这些规则来学习并决定道路上是否有物体？然后根据这个来行驶。当汽车看到路况时，应该保持什么速度？等等，（现在请使用基于规则的系统思考一会儿，不要考虑深度学习方面来解决这个步骤）。
- en: For every small part of our task, we try to define rules and feed that rule
    logic into the RB system. Then, we check whether that rule worked out properly
    on the given input data. We will also measure the performance of the system after
    getting the output.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任务的每一个小部分，我们尝试定义规则并将规则逻辑输入到RB系统中。然后，我们检查该规则是否在给定的输入数据上正确工作。我们还会在得到输出后衡量系统的性能。
- en: Now, you must be thinking this is a book about NLP, so why am I giving an example
    of a generalized AI application? The reason behind it is that the self-driving
    car example is easy to relate to and can be understood by everyone. I want to
    highlight some of the points that also help us to understand the purpose of having
    a rule-based system.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你一定在想这是一本关于NLP的书，为什么我要举一个通用AI应用的例子？原因在于，自动驾驶汽车的例子容易理解，大家都能理解。我想强调一些有助于我们理解拥有基于规则系统目的的观点。
- en: 'Let''s take one general example and understand the purpose:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个通用的例子来理解其目的：
- en: This self-driving car example helps you in identifying that sometimes a task
    that is very easy for a human to perform is so much more complicated for machines
    to do by themselves
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个自动驾驶汽车的例子帮助你识别出，有时一个人类很容易完成的任务，对于机器而言却是极其复杂的。
- en: These kinds of complicated tasks need high accuracy! I mean very high!
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这类复杂任务需要非常高的准确性！我的意思是，非常高！
- en: We don't expect our system to cover and learn about all situations, but whatever
    rules we feed into the system, it should learn about those situations in the best
    manner
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们并不指望系统覆盖和学习所有的情况，但无论我们输入什么规则到系统中，它应该以最佳的方式学习这些情况。
- en: In the RB system, the coverage of various scenarios is less but accuracy of
    the system should be high. That is what we need
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在RB系统中，覆盖的场景较少，但系统的准确性应当很高。这正是我们所需要的。
- en: Our rules are derived from real-life human experience or by using knowledge
    of humans.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的规则来源于现实生活中的人类经验或通过使用人类知识。
- en: Development and implementation of rules is done by humans
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则的开发和实施是由人类完成的。
- en: All these points help us to decide when and where to use a rule-based system.
    This leads us to define our purpose of having a rule-based system. So let's jump
    into the next section where we define a rule of thumb for using the rule-based
    approach for any NLP or AI-related application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些要点帮助我们决定何时何地使用基于规则的系统。这引导我们定义拥有基于规则系统的目的。那么让我们进入下一部分，定义一个使用基于规则方法的经验法则，适用于任何NLP或AI相关的应用。
- en: Purpose of having the rule-based system
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拥有基于规则系统的目的。
- en: Generally, the rule-based system is used for developing NLP applications and
    generalized AI applications. There are bunch of questions that we need to answer
    to generate a clear picture about the rule-based system.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，基于规则的系统用于开发NLP应用和通用AI应用。我们需要回答一系列问题，以便清晰地了解基于规则的系统。
- en: Why do we need the rule-based system?
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么需要基于规则的系统？
- en: 'The rule-based system tries to mimic human expert knowledge for the NLP applications.
    Here, we are going to address the factors that will help you to understand the
    purpose of the RB system:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 基于规则的系统尝试模仿人类专家的知识，用于NLP应用。这里，我们将讨论一些有助于你理解RB系统目的的因素：
- en: Available corpus size is small
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的语料库规模较小。
- en: Output is too subjective
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出过于主观。
- en: Easy for humans of a specific domain to generate some specialized rules
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专门领域的专家容易为特定领域生成一些专业规则。
- en: Difficult for machines to generate specialized rules by just observing small
    amounts of data
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器仅通过观察少量数据很难生成专门的规则。
- en: System output should be highly accurate
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统输出应当具有很高的准确性。
- en: All the preceding factors are very much critical if you want to develop NLP
    application using the RB system. How do the preceding factors help you to decide
    whether you should choose the RB approach or not?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用RB系统开发NLP应用，所有前述因素都非常关键。这些因素如何帮助你决定是否选择RB方法？
- en: 'You need to ask the following questions:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要问以下问题：
- en: Do you have a large amount of data or a small amount of data?
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是拥有大量数据还是少量数据？
- en: If you have a small amount of data, then ask the next question and if you have
    a large amount of data, then you have many other options
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你拥有少量数据，那么可以问下一个问题；如果你有大量数据，那么你有更多其他选择。
- en: Regarding the NLP application that you want to develop, is its output subjective
    or generalized?
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于你要开发的NLP应用，它的输出是主观的还是通用的？
- en: If you have a small amount of data and the output of the application which you
    want to develop is too subjective and you know, with a small amount of data, the
    machine cannot generalize the patterns, then choose the RB system
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你拥有少量数据，并且你要开发的应用输出过于主观，而且你知道用少量数据，机器无法概括出模式，那么选择RB系统。
- en: 'The NLP application that you want to develop should have very high accuracy:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你要开发的NLP应用应该具有非常高的准确性：
- en: If the application that you want to develop should have high accuracy, almost
    the same as a human by using a small dataset, then choose the RB system
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想开发的应用程序应该具有高精度，几乎与人类一样，且使用的是小数据集，那么请选择RB系统。
- en: Here, you should also keep in mind that human experts create rules for the system.
    According to that system, generate the output, so the RB system is highly accurate
    but does not cover all scenarios
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，你还应该记住，RB系统中的规则是由人类专家创建的。根据该系统生成输出，因此RB系统具有很高的准确性，但并不能涵盖所有情境。
- en: 'The preceding questions define why and in what kind of situations we can use
    the RB system. If I needed to summarize the preceding questions, I would describe
    it like this: If you have small amount of data and you know you need a highly
    accurate system where it is easy for a human expert to identify various scenarios
    for making rules and its output but it is very difficult for machines to identify
    generalized rules by themselves accurately, then the RB system is for you! The
    output of the RB system should mimic the experiences of the human expert. This
    is the thumb rule for choosing the RB system.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上述问题定义了我们可以在什么样的情况下使用RB系统。如果我要总结之前的问题，我会这样描述：如果你有少量数据，并且知道你需要一个高精度的系统，其中人类专家能够轻松识别出各种情境来制定规则并预测其输出，而机器则很难自己准确地识别出通用规则，那么RB系统就是适合你的选择！RB系统的输出应该模仿人类专家的经验。这就是选择RB系统的经验法则。
- en: We will see in [Chapter 9](f414d38e-b88e-4239-88bd-2d90e5ce67ab.xhtml), *Deep
    Learning for NLP and NLG Problems*, that there is a better approach when you have
    very large amount of data. For this chapter, the RB approach helps us to generate
    very accurate NLP applications.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第9章](f414d38e-b88e-4239-88bd-2d90e5ce67ab.xhtml)，“*自然语言处理和自然语言生成中的深度学习*”中看到，当你有大量数据时，存在更好的方法。在本章中，RB方法帮助我们生成非常准确的NLP应用。
- en: Which kind of applications can use the RB approach over the other approaches?
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哪种类型的应用程序可以使用RB方法，而不是其他方法？
- en: 'As we defined earlier, the RB system is developed with the help of human domain
    experts. Let''s take some examples in this section which can help to prove our
    rule of thumb:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前定义的，RB系统是在人工领域专家的帮助下开发的。在本节中，我们将举几个例子，帮助证明我们的经验法则：
- en: Say, we want to build the machine translation system from English to available
    Indian corpora and they are too small. The translation system should be accurate
    enough in order to develop it. We need human experts who know English as well
    as Gujarati. We don't want to address all the different levels of translation
    at a time, so we need to cover small chunks of the problem first and then on top
    of the developed prototype, we will build other chunks. So, here also, I would
    like to choose the RB system. What do you think?
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们想构建一个从英语到印度语料库的机器翻译系统，但这些语料库太小。翻译系统必须足够准确才能开发。我们需要同时掌握英语和古吉拉特语的人工专家。我们不想一次性解决所有翻译层次的问题，因此需要先解决小块问题，然后在开发的原型上构建其他部分。因此，在这里，我也会选择RB系统。你怎么看？
- en: Say we want to develop a grammar correction system for the English language.
    Suppose we have a small amount of parallel corpora (documents with grammatical
    mistakes and the same documents without grammatical mistakes), and by using the
    available corpus we need to make an accurate grammar correction application which
    identifies, as well as corrects, the grammatical mistakes. So, in this kind of
    application, which approach would you take? Think for a minute and then come up
    with your answers! Here, I would like to go with the RB system as per our rule
    of thumb.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们想开发一个英语语法纠错系统。假设我们有一小部分平行语料库（包含语法错误的文档和没有语法错误的相同文档），通过现有的语料库，我们需要制作一个准确的语法纠错应用，能够识别并纠正语法错误。那么，在这种应用场景下，你会选择哪种方法？想一想，然后给出你的答案！在这里，根据我们的经验法则，我会选择RB系统。
- en: Exercise
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: If you wanted to develop a basic chatbot system, which approach would you take?
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想开发一个基本的聊天机器人系统，你会选择哪种方法？
- en: RB approach
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: RB方法
- en: ML approach
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习方法
- en: If you want to predict the sentiment of given sentences, which approach would
    you take?
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想预测给定句子的情感，您会选择哪种方法？
- en: RB approach
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: RB方法
- en: ML approach
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习方法
- en: Hybrid approach
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合方法
- en: None of them
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 都不适用
- en: What kind of resources do you need if you want to develop a rule-based system?
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果你想开发一个基于规则的系统，需要什么资源？
- en: Now you have understood why we are using the RB system and for which kinds of
    application we use it. The third important aspect is what do we need if we want
    to develop the RB system for any NLP or AI applications?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了为什么我们使用 RB 系统以及我们将其应用于哪些类型的应用程序。第三个重要方面是，如果我们想要为任何 NLP 或 AI 应用程序开发 RB
    系统，我们需要什么？
- en: 'There are three main resources that we need to consider at this point. Refer
    to *Figure 7.4*:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要考虑三个主要资源。请参见 *图 7.4*：
- en: '![](img/af4d10b2-7aee-473c-8aff-783a8f11ab28.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af4d10b2-7aee-473c-8aff-783a8f11ab28.png)'
- en: 'Figure 7.4: Resources for implementing RB system'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：实现 RB 系统的资源
- en: 'Now, let''s see the details of each resource that helps us to define RB system
    components:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细了解每个有助于定义 RB 系统组件的资源：
- en: 'Domain expert (human expert/knowledge expert): For developing applications
    using the RB system, first and foremost, we need a domain expert, a person who
    knows almost everything about the domain.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域专家（人类专家/知识专家）：为了使用 RB 系统开发应用程序，首先我们需要一位领域专家，一个几乎了解该领域所有知识的人。
- en: Suppose you want to build a machine translation system, then your domain expert
    could be a person who has deep knowledge of linguistics for the source and target
    languages. He can come up with rules by using his expertise and experience.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设你想建立一个机器翻译系统，那么你的领域专家可能是对源语言和目标语言的语言学有深入了解的人。他可以利用自己的专业知识和经验提出规则。
- en: 'System architect (system engineer) of RB system: For defining the architecture
    of the RB system, you need a team or person who has the following expertise:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RB 系统的系统架构师（系统工程师）：为了定义 RB 系统的架构，你需要一个团队或个人，具备以下专长：
- en: Basic knowledge of the domain
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域的基本知识
- en: Deep knowledge or high experience in designing system architectures
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计系统架构的深厚知识或高水平经验
- en: Architecture is the most important part of the RB system because your architecture
    is one of the components which decide how efficient your whole system will be.
    Good architecture design for the RB system will provide good user experience,
    accurate and efficient output, and apart from that, it will make life easy for
    coders and other technical teams such as support or testing teams who will be
    able to work on the system easily. The system architecture is the responsibility
    of the system engineer or system architect.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 架构是 RB 系统中最重要的部分，因为架构是决定整个系统效率的关键组件之一。良好的 RB 系统架构设计将提供良好的用户体验、准确高效的输出，除此之外，它还将使得程序员和其他技术团队（如支持团队或测试团队）能够轻松工作。系统架构由系统工程师或系统架构师负责。
- en: 'Coders (developers or knowledge engineers) for implementing rules: Once rules
    are developed by domain experts and the system architecture has been designed
    properly, then coders or developers come into the picture. Coders are our real
    ninjas! They implement the rules by using programming languages and help to complete
    the application. Their coding skills are a much needed part of the RB system.
    Programming can be done using any of the programming or scripting languages such
    as C, C++, Java, Python, Perl, shell scripts, and so on. You can use any of them
    as per the architecture, but not all of them in a single system without a streamlined
    architecture.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码人员（开发人员或知识工程师）实现规则：一旦领域专家开发出规则并且系统架构已经设计好，那么编码人员或开发人员便会介入。编码人员就是我们的真正的忍者！他们使用编程语言实现规则并帮助完成应用程序。他们的编程技能是
    RB 系统中不可或缺的一部分。编程可以使用任何编程语言或脚本语言，如 C、C++、Java、Python、Perl、Shell 脚本等。根据架构的不同，你可以选择其中任何一种语言，但不能在单一系统中使用多种语言，除非有精心设计的架构。
- en: We will look at more technical stuff regarding the architecture part a little
    later in this chapter.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后在本章中，我们将深入了解架构部分的更多技术内容。
- en: Architecture of the RB system
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RB 系统架构
- en: 'I will explain the architecture of the RB system by segregating it into three
    sections:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过将其分为三个部分来解释 RB 系统的架构：
- en: General architecture of RB system as an expert system
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RB 系统作为专家系统的一般架构
- en: Practical architecture of the RB system for NLP applications
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于 NLP 应用的 RB 系统的实际架构
- en: Custom architecture - RB system for NLP applications
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义架构 - NLP 应用的 RB 系统
- en: Apache **UIMA** (**Unstructured Information Management Architecture**) the RB
    system for NLP applications
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache **UIMA**（**非结构化信息管理架构**）为 NLP 应用提供的 RB 系统
- en: General architecture of the rule-based system as an expert system
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为专家系统的规则基础系统的一般架构
- en: 'If we described our rule-based system as an expert system, then the architecture
    of this kind of rule-based system would be the same as in *Figure 7.5*:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将我们的基于规则的系统描述为专家系统，那么这种基于规则的系统的架构将与*图 7.5*中的架构相同：
- en: '![](img/cdb9c8a5-c956-4910-b2fe-21e5bfe8a59c.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cdb9c8a5-c956-4910-b2fe-21e5bfe8a59c.png)'
- en: 'Figure 7.5: Architecture of the RB system, considering it as an expert system'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5：将RB系统视为专家系统时的架构
- en: 'Let''s look at each of the components of the architecture in detail:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看架构中的每个组件：
- en: '**Domain expert**:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域专家：**'
- en: As we saw in the previous section, domain experts are the ones who have expertise
    for a specific domain and they can help us to generate the rules to solve our
    problems
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如我们在前一节中所见，领域专家是那些对特定领域有专长的人，他们可以帮助我们生成规则来解决问题
- en: '**Developers or knowledge engineer:**'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发者或知识工程师：**'
- en: Developers use the rules which are created by the domain expert and convert
    them into a machine-understandable format using their coding skills
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者使用由领域专家创建的规则，并通过编程技能将其转换为机器可理解的格式
- en: Developers encode the rules created by experts
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者对专家创建的规则进行编码
- en: Mostly, this encoding is in the form of pseudo codes
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，这种编码以伪代码的形式呈现
- en: '**Knowledge base:**'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**知识库：**'
- en: The knowledge base is where all the rules can be put by experts
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知识库是专家可以放置所有规则的地方
- en: The domain expert can add, update, or delete the rules
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域专家可以添加、更新或删除规则
- en: '**Database or working storage:**'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库或工作存储：**'
- en: All meta information-related rules can be put in the working storage
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有与元信息相关的规则可以放在工作存储中
- en: Here, we can store rules as well as special scenarios, some lists if available,
    examples, and so on
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，我们可以存储规则、特殊场景、可用的列表、示例等
- en: We also save data on which we want to apply rules
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还会保存要应用规则的数据
- en: '**Inference engine:**'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推理引擎：**'
- en: The inference engine is the core part of the system
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推理引擎是系统的核心部分
- en: Here, we put in actual codes for our rules
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，我们为规则编写实际的代码
- en: Rules will be triggered when predefined rules and conditions meet with a user
    query or on a dataset which we have given to the system as input
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当预定义的规则和条件与用户查询或我们给系统输入的数据集匹配时，规则会被触发
- en: '**User inference:**'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户推理：**'
- en: Sometimes, our end users also provide some conditions to narrow down their results,
    so all these user inference will also be considered when our system generates
    the output
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时候，我们的最终用户也会提供一些条件来缩小结果范围，因此当我们的系统生成输出时，这些用户推理也会被考虑在内。
- en: '**User interface:**'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户界面：**'
- en: The user interface helps our user to submit their input and in return they will
    get the output
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面帮助用户提交输入，作为回报，他们会得到输出结果
- en: This provides an interactive environment for our end users
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这为我们的最终用户提供了一个互动环境
- en: '**System architect:**'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统架构师：**'
- en: The system architect takes care of the whole architecture of the system
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统架构师负责整个系统架构
- en: The system architect also decides what is the most efficient architecture for
    the RB system
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统架构师还决定什么是RB系统的最有效架构
- en: We have seen the traditional architecture of the RB system. Now it is time to
    see what will be the real-life practical architecture of the RB system for NLP
    applications.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到传统的RB系统架构，现在是时候看到NLP应用的RB系统的实际架构了。
- en: Practical architecture of the rule-based system for NLP applications
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于规则的系统在自然语言处理（NLP）应用中的实际架构
- en: 'I have already described the general architecture, now we will see the practical
    architecture of the RB system for NLP applications. Refer to *Figure 7.6*:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经描述了整体架构，现在我们将看到RB系统在NLP应用中的实际架构。参考*图 7.6*：
- en: '![](img/21152cfe-294d-4141-be51-0056e8931963.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21152cfe-294d-4141-be51-0056e8931963.png)'
- en: 'Figure 7.6: Real life architecture of RB system for NLP application'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6：用于NLP应用的RB系统的实际架构
- en: Let's look at each of the components of the architecture in detail.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看架构中的每个组件。
- en: 'Some of the parts, such as domain experts, user interfaces, and system engineer,
    we have seen in the previous section. So, here, we are focusing on new components:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一节中已经看到了一些部分，如领域专家、用户界面和系统工程师。所以，在这里，我们专注于新的组件：
- en: '**Knowledge-based editor:**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于知识的编辑器：**'
- en: The domain experts may not know how to code
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域专家可能不知道如何编码
- en: So we are providing them a knowledge-based editor where they can write or create
    the rules by using human language
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所以我们为他们提供了一个基于知识的编辑器，他们可以使用自然语言编写或创建规则
- en: Suppose we are developing a grammar correction system for the English language
    and we have a linguist who knows how to create rules but doesn't know how to code
    them
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们正在开发一个英语语法纠错系统，并且我们有一个语言学家，他知道如何创建规则，但不知道如何将规则编码。
- en: In this case, they can add, update, or delete rules by using the knowledge-based
    editor
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，他们可以使用知识库编辑器来添加、更新或删除规则。
- en: All the created rules are specified in the form of normal human language
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有创建的规则都以普通人类语言的形式进行说明。
- en: '**Rule translator:**'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则翻译器：**'
- en: As we know, all rules are in the form of the human language, so we need to translate
    or convert them into machine-understandable form
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们所知，所有规则都是以人类语言的形式表示的，因此我们需要将它们翻译或转换成机器可以理解的形式。
- en: So, the rule translator is the section where pseudo logic for the rules has
    been defined with examples
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，规则翻译器就是定义规则伪逻辑并给出示例的部分。
- en: Let's consider our grammar correction system example. Here our expert defines
    a rule if there is a singular subject and plural verb in the sentence, and then
    changes the verb to the singular verb format
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们考虑我们的语法纠错系统例子。在这里，我们的专家定义了一条规则：如果句子中有单数主语和复数动词，那么就将动词改为单数形式。
- en: In the rule translator, the defined rule has been converted as if there is a
    sentence **S** which has a singular subject with the POS tag **PRP$**, **NP**
    with POS tag of verbs **VBP,** then change the verb to the **VBZ** format. Some
    examples have also been specified to understand the rules
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在规则翻译器中，已定义的规则被转换成这样的格式：如果句子**S**有一个单数主语，词性标签为**PRP$**，而动词词性标签为**VBP**，则将动词更改为**VBZ**格式。为了理解规则，也给出了一些示例。
- en: '**Rule object classes:**'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则对象类：**'
- en: This rule object class act, as the container for supporting libraries
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个规则对象类充当支持库的容器。
- en: It contains various prerequisite libraries
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含各种先决条件库。
- en: It also sometimes contains an optional object class for libraries to optimize
    the entire system
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有时还包含一个可选的对象类，用于库的优化，进而优化整个系统。
- en: For the grammar correction system, we can put tools such as parsers, POS taggers,
    **named entity recognition** (**NER**), and so on in the container to be used
    by the rule engine
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于语法纠错系统，我们可以将解析器、词性标注器、**命名实体识别**（**NER**）等工具放入容器中，供规则引擎使用。
- en: '**Database or knowledge base:** A database has metadata for rules, such as:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库或知识库：** 一个数据库包含规则的元数据，例如：'
- en: Which supporting libraries have been used from the rule object classes?
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经使用了哪些支持库来自规则对象类？
- en: What is the category of the rule?
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则的类别是什么？
- en: What is priority of the rule?
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则的优先级是什么？
- en: '**Rule engine:**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则引擎：**'
- en: This is the core part, which is the brain of the RB system
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是核心部分，是RB系统的大脑。
- en: By using the rule translator, rule object classes, and knowledge base we need
    to develop the core code which actually runs on the user query or on the input
    dataset and generates the output
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用规则翻译器、规则对象类和知识库，我们需要开发核心代码，该代码实际运行在用户查询或输入数据集上，并生成输出。
- en: You can code by using any programming language which is the best fit for your
    application and its architectures
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用任何适合你的应用程序及其架构的编程语言来编写代码。
- en: For our grammar correction system, we will code the rule in this stage and the
    final code will be put into the rule engine repository
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于我们的语法纠错系统，我们将在此阶段编写规则，最终代码将被放入规则引擎的代码库中。
- en: These are all the components that are useful if you are developing an RB system
    for NLP. Now you must have questions. Can we change the architecture of the system
    as per our needs? Is it fine? To get answers to these questions, you need to follow
    the next section.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是开发NLP的RB系统时有用的所有组件。现在你一定会有一些问题。我们可以根据需要改变系统的架构吗？这样可以吗？要回答这些问题，你需要参考下一部分内容。
- en: Custom architecture - the RB system for NLP applications
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制架构 - 用于NLP应用的RB系统
- en: 'According to the needs of different NLP applications, you can change the architecture
    or components. Customization is possible in this approach. There are some points
    that need to be taken care of if you are designing a customized RB system architecture.
    Ask the following questions:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 根据不同NLP应用的需求，你可以更改架构或组件。在这种方法中，可以进行定制。如果你正在设计一个定制的RB系统架构，有一些需要注意的点。请问以下问题：
- en: Did you analyze and study the problem and the already existing architectures?
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你分析和研究过这个问题以及已有的架构吗？
- en: Before doing customization, you need to do analysis of your application. If
    any existing system is there, then study its architecture and take the bad and
    good out of it
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进行定制之前，你需要对应用进行分析。如果存在现有系统，那么需要研究其架构，并从中提取优缺点。
- en: Take enough time for analysis
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花足够的时间进行分析。
- en: Do you really need custom architecture?
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你真的需要定制架构吗？
- en: If after the study, you feel that your application architecture needs to be
    customized, then write down the reasons why you you really need it
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果经过研究后，你觉得应用架构需要定制，那么写下你为什么真的需要它的原因。
- en: State the reasons that you have listed down and can help your system to make
    it better by asking a series of questions. If yes, then you are on the right track
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出你所列出的理由，并通过一系列问题帮助你的系统变得更好。如果答案是肯定的，那么你已经走在正确的轨道上。
- en: Does it help to streamline the development process?
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否有助于简化开发流程？
- en: Does the new architecture actually help your development process better? If
    it does, then you can consider that architecture
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新架构是否真的能帮助你的开发过程更好？如果是，那么你可以考虑使用该架构。
- en: Most of the time, defining a streamline process for developing the RB system
    is challenging but if your new customized architecture can help you, then it is
    really a good thing
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数时候，定义一个流畅的RB系统开发流程是具有挑战性的，但如果你新的定制架构能够帮助你，那将是非常好的事情。
- en: Does this streamline process actually stabilize your RB system?
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个流畅的过程是否真的稳定了你的RB系统？
- en: Is it maintainable?
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否易于维护？
- en: A customized architecture can help you to maintain the system easily as well
    as efficiently
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制化架构可以帮助你更轻松、高效地维护系统。
- en: If you can add this feature to your customized architecture, then thumbs up!
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你能将这个功能添加到定制架构中，那就太棒了！
- en: Is it modular?
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否具有模块化？
- en: If it will provide modularity in the RB system then it will be useful because
    then you can add, remove, or update certain modules easily
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它能提供RB系统的模块化，那么它将非常有用，因为你可以轻松添加、删除或更新某些模块。
- en: Is it scalable?
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否具有可扩展性？
- en: With the help of the new architecture, you can scale up the system. You should
    also consider this
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 借助新架构，你可以扩展系统。你也应该考虑到这一点。
- en: Is it easy to migrate?
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否易于迁移？
- en: If it is with the defined architecture, it should be easy for the team to migrate
    the system from one platform to another
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有了定义的架构，团队应该能够轻松地将系统从一个平台迁移到另一个平台。
- en: If we want to migrate a module from one system to another, it should be easy
    for the technical as well the infrastructure team
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想将一个模块从一个系统迁移到另一个系统，那么技术团队和基础设施团队都应该能够轻松完成。
- en: Is it secure?
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否安全？
- en: System security is a major concern. New architecture should definitely have
    this feature of security and user privacy if needed
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统安全是一个主要问题。新的架构如果需要的话，应该具备安全性和用户隐私保护功能。
- en: Is it easy to deploy?
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否易于部署？
- en: If you want to deploy some changes in the future, then deployment should be
    easy
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你未来想要部署一些变更，那么部署过程应该足够简便。
- en: If you want to sell your end product, then the deployment process should be
    easy enough, which will reduce your efforts and time
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想销售最终产品，那么部署过程应该足够简便，以减少你的工作量和时间。
- en: Is it time saving in terms of development time?
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从开发时间的角度来看，它是否节省时间？
- en: Implementation as well as the development of the RB system by using the architecture
    should be time saving
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用该架构开发和实现RB系统应该是节省时间的。
- en: The architecture itself should not take too much time to implement
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构本身不应占用太多的实现时间。
- en: Is it easy for our users to use?
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对我们的用户来说，它是否易于使用？
- en: The architecture can be complex but for end users it must be user-friendly and
    easy to use
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构可能很复杂，但对于最终用户来说，它必须是用户友好且易于使用的。
- en: If you can take all of the preceding points or most of them, then try to implement
    a small set of problems using the architecture that you think best for the system,
    then, at the end, ask all the previous questions again and evaluate the output.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能采纳上述所有或大部分要点，那么尝试使用你认为最适合系统的架构，解决一小部分问题，然后最后再一次提出所有之前的问题，评估输出结果。
- en: If you still get positive answers, then you are good to go! Here, the design
    is neither right nor wrong; it's all about the best fit for your NLP application.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然得到正面的答案，那么你可以放心了！在这里，设计没有绝对的对错；关键是找到最适合你的NLP应用的架构。
- en: 'A **Question-Answering** (**Q/A**) system can use the architecture which is
    shown in the *Figure 7.7*:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**问答**（**Q/A**）系统可以使用在*图7.7*中展示的架构：
- en: '![](img/7441eed7-ab5b-4689-a454-cf5953e265a3.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7441eed7-ab5b-4689-a454-cf5953e265a3.png)'
- en: 'Figure 7.7: Architecture for Question-Answering RB system'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：问答RB系统架构
- en: You can see a very different kind of architecture. The approach of the Q/A system
    is an ontology based RB system. Question processing and document processing is
    the main rule engine for us. Here, we are not thinking of a high-level question
    answering system. We want to develop a Q/A system for small children who can ask
    questions about stories and the system will send back the answers as per the rules
    and available story data.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到一种非常不同的架构。这个问答系统的方法是基于本体的RB系统。问题处理和文档处理是我们主要的规则引擎。在这里，我们并不考虑开发一个高级的问答系统。我们希望开发一个适合小孩子的问答系统，孩子们可以提问关于故事的问题，系统会根据规则和现有的故事数据返回答案。
- en: 'Let''s see each of the components in details:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看每个组件：
- en: When the user submits the question, the parser parses the question.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户提交问题时，解析器会解析问题。
- en: Parse the question matching the parsing result with the knowledge base, ontology,
    and keywords thesaurus using the interpreter.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用解释器解析问题，将解析结果与知识库、本体和关键词词典进行匹配。
- en: Here, we apply the reasoning and facts as well.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，我们也应用了推理和事实。
- en: We derive some facts from the questions and categorized user questions using
    query classification and reformulation.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从问题中提取一些事实，并通过查询分类和重构对用户问题进行分类。
- en: After, the already-generated facts and categorized queries are sent to the document
    processing part where the facts are given to the search engine.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，已经生成的事实和分类过的问题会被发送到文档处理部分，在那里事实会传递给搜索引擎。
- en: Answer extraction is the core RB engine for the Q/A system because it uses facts
    and applies reasoning techniques such as forward chaining or backward chaining
    to extract all possible answers. Now you will want to know about backward chaining
    and forward chaining. So, here, I'm giving you just a brief overview. In forward
    chaining, we start with available data and use inference rules to extract more
    facts from data until a goal is achieved. This technique is used in expert system
    to understand what can happen next. And in backward chaining, we start with a
    list of goals and work backwards to find out which conditions could have happened
    in the past for the current result. These techniques help us to understand why
    this happened.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 答案提取是问答系统的核心RB引擎，因为它利用事实并应用推理技术，如前向链推理或后向链推理，来提取所有可能的答案。现在你可能想了解一下后向链推理和前向链推理。那么，在这里，我将为你提供一个简要的概述。在前向链推理中，我们从可用数据开始，使用推理规则从数据中提取更多事实，直到达成目标。该技术被用于专家系统中，以了解接下来可能发生的事情。而在后向链推理中，我们从一系列目标开始，倒推以找出哪些条件可能在过去发生，从而导致当前结果的产生。这些技术帮助我们理解为什么会发生这种情况。
- en: Once all possible answers have been generated, then it will be sent back to
    the user.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦所有可能的答案生成完毕，它们将会返回给用户。
- en: I have one question in my mind that I would like to ask you.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我心中有一个问题，想问你。
- en: What kind of database do you want to select if you develop a Q/A system? Think
    before you go ahead!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你开发一个问答系统，想选择什么类型的数据库？在继续之前，先思考一下！
- en: 'I would like to choose the NoSQL database over the SQL DBs, and there are a
    couple of reasons behind it. The system should be available for the user 24\7\.
    Here, we care about our user. The user can access the system anytime, and availability
    is a critical part. So, I would like to choose the NoSQL database.If, in the future,
    we want to perform some analytics on the users'' questions and answers, then we
    need to save the users'' questions and the system''s answers in the database .
    Read further to understand them:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我倾向于选择NoSQL数据库，而不是SQL数据库，背后有几个原因。系统应该24小时全天候对用户开放。在这里，我们非常关心我们的用户。用户可以随时访问系统，系统的可用性至关重要。因此，我希望选择NoSQL数据库。如果将来我们需要对用户的问题和答案进行一些分析，那么我们需要将用户的问题和系统的答案保存在数据库中。继续阅读以了解更多信息：
- en: 'You can choose your data warehouse or NoSQL DB. If you are new to NoSQL, then
    you can refer to NoSQL using this link: [https://en.wikipedia.org/wiki/NoSQL,](https://en.wikipedia.org/wiki/NoSQL)
    and if you are new to the word data warehouse, then you can refer to this link:
    [https://en.wikipedia.org/wiki/Data_warehouse.](https://en.wikipedia.org/wiki/Data_warehouse)
    This will help us categorize our users, and we can make some creative changes
    that really matter to the user. We can also provide customized feed or suggestions
    to each of the users.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择自己的数据仓库或 NoSQL 数据库。如果你是 NoSQL 新手，可以通过这个链接了解 NoSQL：[https://en.wikipedia.org/wiki/NoSQL](https://en.wikipedia.org/wiki/NoSQL)；如果你对数据仓库这个词不熟悉，可以参考这个链接：[https://en.wikipedia.org/wiki/Data_warehouse](https://en.wikipedia.org/wiki/Data_warehouse)。这将帮助我们对用户进行分类，并能够做出真正对用户有意义的创意性改变。我们还可以为每个用户提供定制化的反馈或建议。
- en: Exercise
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习。
- en: Suppose you are developing a grammar correction system, what kind of system
    architecture do you design? Try to design it on paper! Let your thoughts come
    out.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在开发一个语法纠正系统，你会设计什么样的系统架构？尝试在纸上设计它！让你的思路流露出来。
- en: Apache UIMA - the RB system for NLP applications
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apache UIMA - 用于 NLP 应用程序的规则引擎系统。
- en: In this section, we will look at one of the famous frameworks for the RB system
    for NLP applications.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究用于 NLP 应用程序的规则引擎系统中的一个著名框架。
- en: 'Apache UIMA is basically developed by IBM to process unstructured data. You
    can explore more details by clicking on this link: [https://uima.apache.org/index.html](https://uima.apache.org/index.html)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Apache UIMA 最初是由 IBM 开发的，用于处理非结构化数据。你可以通过点击此链接查看更多详细信息：[https://uima.apache.org/index.html](https://uima.apache.org/index.html)
- en: Here, I want to highlight some points from this framework, which will help you
    to make your own NLP application using the RB approach.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我想强调这个框架中的一些要点，它们将帮助你使用规则引擎方法构建自己的自然语言处理（NLP）应用程序。
- en: 'The following are the features of UIMA:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 UIMA 的一些特性：
- en: UIMA will provide us with the infrastructure, components, and framework
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UIMA 将为我们提供基础设施、组件和框架。
- en: UMIA has an inbuilt RB engine and GATE library for performing preprocessing
    of text data
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UIMA 内建了规则引擎（RB 引擎）和 GATE 库，用于对文本数据进行预处理。
- en: 'The following tools are available as part of the components. I have listed
    down a few of them:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下工具作为组件的一部分可用，我列举了一些：
- en: Language identification tool
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言识别工具。
- en: Sentence segmentation tool
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 句子分割工具。
- en: NER tool
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: NER 工具
- en: We can code in Java, Ruta, and C++
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 Java、Ruta 和 C++ 编写代码。
- en: It is a flexible, modular, and easy-to-use framework
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个灵活、模块化、易于使用的框架。
- en: C/C++ annotators also supports Python and Perl
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C/C++ 注释器还支持 Python 和 Perl。
- en: 'Applications/uses of UIMA include:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: UIMA 的应用/用途包括：
- en: IBM Watson uses UIMA to analyze unstructured data
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IBM Watson 使用 UIMA 来分析非结构化数据。
- en: The **clinical Text Analysis and Knowledge Extraction System** (**Apache cTAKES**)
    uses the UIMA-based system for information extraction from medical records
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**临床文本分析与知识提取系统**（**Apache cTAKES**）使用基于 UIMA 的系统从医疗记录中提取信息。'
- en: 'The challenges of using UIMA include:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 UIMA 的挑战包括：
- en: You need to code rules in either Java, Ruta, or C++. Although, for optimization,
    many RB systems use C++; getting the best human resources for Ruta is a challenging
    task
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要使用 Java、Ruta 或 C++ 编写规则。尽管为了优化，许多规则引擎（RB）系统使用 C++，但为 Ruta 招募到优秀的人才是一项具有挑战性的任务。
- en: If you are new to UIMA, you need some time to become familiar with it
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你是 UIMA 的新手，你需要一些时间来熟悉它。
- en: Understanding the RB system development life cycle
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解规则引擎系统开发生命周期。
- en: In this section, we will look at the development life cycle for the RB system,
    which will help you in the future if you want to develop your own. *Figure 7.8*
    describes the development life cycle of the RB system. This figure is quite self-explanatory,
    so there is no need for an extra description.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论规则引擎系统的开发生命周期。如果你以后想要开发自己的系统，这将对你有所帮助。*图 7.8* 描述了规则引擎系统的开发生命周期。这个图表非常直观，所以不需要额外的说明。
- en: 'If we follow the stages of the RB development life cycle, then life will be
    easy for us:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遵循规则引擎开发生命周期的各个阶段，那么生活将变得更轻松：
- en: '![](img/ac7a6883-ee3f-41db-9ee5-29a1d3f222de.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac7a6883-ee3f-41db-9ee5-29a1d3f222de.png)'
- en: 'Figure 7.8: RB system development life cycle'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8：规则引擎系统开发生命周期。
- en: Applications
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序。
- en: In this section, I have divided the applications into two sections; one is the
    NLP application and the other one is the generalized AI application.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将应用程序分为两个部分：一个是 NLP 应用程序，另一个是通用的 AI 应用程序。
- en: NLP applications using the rule-based system
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用规则引擎系统的 NLP 应用程序。
- en: 'Here, we mention some of the NLP applications that use the RB system:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们列出了一些使用基于规则系统的NLP应用：
- en: 'Sentence boundary detection:'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 句子边界检测：
- en: Sentence boundary detection is easy for general English writing but it will
    be complicated when you are dealing with research papers or other scientific documents
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对一般的英语写作来说，句子边界检测比较容易，但当你处理研究论文或其他科学文档时，它会变得更加复杂。
- en: So, handcrafted post-processing rules will help us to identify the sentence
    boundary accurately
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所以，手工制作的后处理规则将帮助我们准确识别句子边界。
- en: This approach has been used by Grammarly Inc. for the grammar correction system
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grammarly公司也使用这种方法用于语法纠错系统。
- en: 'Machine translation:'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器翻译：
- en: When we think of a machine translation system, in our mind, we think of the
    **Google Neural Machine Translation** (**GNMT**) system
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想到机器翻译系统时，我们脑海中会想到**谷歌神经机器翻译**（**GNMT**）系统。
- en: For many Indian languages, Google used to use a complex rule-based system with
    a statistical prediction system, so they have an hybrid system
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于许多印度语言，谷歌曾经使用一个复杂的基于规则的系统与统计预测系统，因此他们有一个混合系统。
- en: In 2016, Google launched the neural network based MT system
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2016年，谷歌推出了基于神经网络的机器翻译系统。
- en: Many research projects still use the RB system for MT and the majority of them
    try tapping out the languages which are untapped
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多研究项目仍然使用基于规则的系统进行机器翻译，并且他们中的大多数都在尝试开发那些尚未开发的语言。
- en: 'Template based chatbots:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于模板的聊天机器人：
- en: Nowadays, chatbots are the new trend and craze in the market
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如今，聊天机器人是市场上的新趋势和热潮。
- en: A basic version of them is a template-based approach where we have a defined
    set of questions or keywords and we have mapped the answers to each of the keywords
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的基本版本是一种基于模板的方法，在这种方法中，我们有一套已定义的问题或关键词，并将每个关键词的答案进行了映射。
- en: The good part of this system is matching the keywords. So if you are using any
    other language but if your chat messages contain keywords which we have defined,
    then the system is able to send you a proper message as a response
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个系统的好处是匹配关键词。因此，如果你使用的是其他语言，但你的聊天信息中包含我们已定义的关键词，那么系统能够为你发送正确的响应信息。
- en: The bad part is, if you make any spelling mistakes then the system will not
    be able to respond in a proper manner
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坏的一面是，如果你犯了拼写错误，系统将无法以正确的方式做出响应。
- en: We will develop this application from scratch. I will explain the coding part
    in the next section, so keep reading and start your computer!
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从零开始开发这个应用程序。我将在下一节中解释编码部分，所以请继续阅读并启动你的计算机！
- en: 'Grammar correction system:'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法纠错系统：
- en: A grammar correction system is also implemented by using rules
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法纠错系统也是通过使用规则来实现的。
- en: In this application, we can define some of the simple rules to very complicated
    rules as well
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们可以定义一些简单的规则，也可以定义一些非常复杂的规则。
- en: In the next section, we will see some of the basic grammar correction rules
    which we are going to implement using Python
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到一些基本的语法纠错规则，我们将使用Python来实现这些规则。
- en: 'Question answering systems:'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问答系统：
- en: A question answering system also uses the RB system, but here, there is one
    different thing going on
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问答系统也使用基于规则的系统，但这里有一个不同之处。
- en: The Q/A system uses semantics to get the answer of the submitted question
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问答系统通过语义学来获取提交问题的答案。
- en: For putting semantics into the picture, we are using the ontology-based RB approach
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了将语义学融入其中，我们使用了基于本体的基于规则方法。
- en: Generalized AI applications using the rule-based system
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基于规则的系统的通用AI应用：
- en: 'You have seen the NLP applications which use the RB approach. Now, move into
    the generalized AI applications, which use the RB approach along with other techniques:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了使用基于规则方法的NLP应用。现在，我们来看一下使用基于规则方法与其他技术结合的通用AI应用：
- en: 'Self-driving cars or driver less cars:'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动驾驶汽车或无人驾驶汽车：
- en: At the start of the chapter, I gave the example of the self-driving car to highlight
    the purpose of having the RB system
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章开始时，我举了自动驾驶汽车的例子来突出基于规则系统的目的。
- en: The self-driving car also uses a hybrid approach. Many of the big companies,
    from Google to Tesla, are trying to build self-driving cars, and their experiments
    are in order to develop the most trustworthy self-driving cars
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动驾驶汽车也使用了混合方法。许多大公司，从谷歌到特斯拉，都在尝试制造自动驾驶汽车，他们的实验旨在开发最值得信赖的自动驾驶汽车。
- en: This application has been developed by using complex RB systems during its initial
    days
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个应用程序在初期是通过使用复杂的基于规则（RB）系统开发的。
- en: Then, the experiment turned into the direction of ML techniques
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，实验转向了机器学习技术的方向。
- en: Nowadays, companies are implementing deep learning techniques to make the system
    better
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如今，许多公司正在应用深度学习技术以使系统变得更好。
- en: 'Robotics applications:'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人应用：
- en: It has been a long-term goal of the AI community to develop robots which complement
    human skills
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发展能够补充人类技能的机器人一直是人工智能社区的长期目标。
- en: We have a goal where we want to develop robots which help humans to do their
    work, tasks which are basically time consuming
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的目标是开发能够帮助人类完成工作、处理耗时任务的机器人。
- en: Suppose there is a robot that helps you with household work. This kind of task
    can be performed by the robot with the help of defined rules for all possible
    situations
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设有一个帮助你做家务的机器人。通过为所有可能的情况定义规则，机器人可以完成这种任务。
- en: 'Expert system of NASA:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NASA的专家系统：
- en: NASA made the expert system by using the general purpose programming language,
    **CLIPS** (**C Language Integrated Production System**)
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: NASA通过使用通用编程语言**CLIPS**（**C语言集成生产系统**）开发了专家系统。
- en: Now, I think that's enough of theories. Now we should try to develop some of
    the RB applications from scratch. Get ready for coding. We will begin our coding
    journey in the next section.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我想理论部分已经足够了。现在我们应该尝试从零开始开发一些RB应用程序。准备好开始编码吧，我们将在下一节开始我们的编程之旅。
- en: Developing NLP applications using the RB system
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RB系统开发自然语言处理（NLP）应用程序。
- en: In this section, we will see how to develop NLP applications using the RB system.
    We are developing applications from the beginning. So, first you need the following
    dependencies.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何使用RB系统开发NLP应用程序。我们将从头开始开发应用程序。因此，首先你需要以下依赖项。
- en: 'You can run the following command to install all the dependencies:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行以下命令来安装所有的依赖项：
- en: '[PRE0]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The list of dependencies can be found by clicking on this link: [https://github.com/jalajthanaki/NLPython/blob/master/pip-requirements.txt](https://github.com/jalajthanaki/NLPython/blob/master/pip-requirements.txt)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项的列表可以通过点击此链接找到：[https://github.com/jalajthanaki/NLPython/blob/master/pip-requirements.txt](https://github.com/jalajthanaki/NLPython/blob/master/pip-requirements.txt)
- en: Thinking process for making rules
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制定规则的思维过程：
- en: We are talking a lot about rules, but how can these rules actually can be derived?
    What is the thinking process of a linguist when they are deriving rules for an
    NLP application? Then, let's begin with this thinking process.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们谈论了很多关于规则的内容，但这些规则到底是如何推导出来的呢？当语言学家为NLP应用程序推导规则时，他们的思维过程是什么样的？那么，让我们从这个思维过程开始。
- en: You need to think like a linguist for a while. Remember all the concepts that
    you have learned so far in this book and be a linguist.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要像语言学家一样思考一段时间。记住你至今在本书中学到的所有概念，成为一名语言学家。
- en: 'Suppose you are developing rules for a grammar correction system, especially
    for the English language. So, I''m describing the thought process of a linguist
    and this thought process helps you when you are developing rules:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在为语法修正系统开发规则，特别是针对英语语言。因此，我将描述语言学家的思维过程，而这个思维过程将帮助你在开发规则时：
- en: What should I need to know?
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我需要知道什么？
- en: You should know about grammatical rules of the language for which you are creating
    rules, here that language is English
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该了解你所创建规则的语言的语法规则，这里的语言是英语。
- en: You should know the structure, word order, and other language related concepts
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该了解语言的结构、词序和其他语言相关的概念。
- en: The preceding two points are prerequisites
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面的两点是先决条件。
- en: From where should I start?
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我应该从哪里开始？
- en: If you know all the language-related things, then you need to observe and study
    incorrect sentences
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你了解所有与语言相关的内容，那么你就需要观察和研究不正确的句子。
- en: Now, when you study incorrect sentences, you need to know what mistakes there
    are in the sentences
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，当你学习不正确的句子时，你需要知道这些句子中有哪些错误。
- en: After that you need to think about the categories of the mistakes, whether the
    mistakes are syntax related, or whether they are because of semantic ambiguity
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，你需要思考错误的分类，错误是与语法相关，还是由于语义歧义引起的。
- en: After all this, you can map your language-related knowledge to the mistakes
    in the sentences
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经过这一切后，你可以将你与语言相关的知识映射到句子中的错误上。
- en: How can rules be derived?
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则是如何推导的？
- en: Once you find the mistakes in the sentence, then at that moment focus on your
    thinking process. What does your brain think when you're capturing the mistakes?
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦你发现了句子中的错误，那么此时就要专注于你的思维过程。当你捕捉到错误时，你的大脑是如何反应的？
- en: Think about how your brain reacts to each of the mistakes that you have identified
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想一想你的大脑是如何对你已识别的每个错误作出反应的。
- en: You can capture the mistake because you know the grammatical facts of the language
    or other language related technical stuff (sentence syntax structures, semantics
    knowledge, and so on). Your brain actually helps you
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能够捕捉到错误，因为你了解语言的语法事实或其他与语言相关的技术内容（句子语法结构、语义知识等）。你的大脑实际上在帮助你。
- en: Your brain knows the right way to interpret the given text using the given language
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的大脑知道如何使用给定的语言正确解读给定的文本。
- en: That is the reason you are able to catch the mistakes. At the same time, you
    have some solid reason; based on that, you have identified the mistakes
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这就是你能够发现错误的原因。与此同时，你有了一些坚实的理由；基于这些理由，你已经识别出错误。
- en: Once you have identified the mistakes, as per the different categories of the
    mistakes, you can correct the mistakes by changing some parts of the sentences
    using certain logical rules
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦识别出错误，根据错误的不同类别，你可以通过使用某些逻辑规则来修改句子的部分内容，从而纠正错误。
- en: You can change the word order, or you can change the subject verb agreement,
    or you can change some phrases or all of them together
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以改变词序，或者你可以改变主谓一致，或者你可以改变一些短语，或者所有这些都一起改变。
- en: Bingo! At this point, you will get your rule. You know what the mistakes are
    and you also know what are these steps are for converting incorrect sentences
    to correct sentences
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bingo！到此为止，你会得到你的规则。你知道错误是什么，你也知道这些步骤是用来将错误句子转化为正确句子的。
- en: Your rule logic is nothing but the steps of converting incorrect sentences into
    correct sentences
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的规则逻辑不过就是将错误句子转换成正确句子的步骤。
- en: What elements do I need to take care of?
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我需要注意哪些元素？
- en: First, you need to think about a very simple way of correcting the mistakes
    or incorrect sentences
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，你需要考虑一种非常简单的方式来修正错误或不正确的句子。
- en: Try to make pattern-based rules
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试制定基于模式的规则。
- en: If pattern-based rule are not possible to derive then check if you can use parsing
    and/or morphological analyzer results and then check other tools and libraries
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果无法推导出基于模式的规则，那么检查你是否可以使用解析和/或形态分析器的结果，然后检查其他工具和库。
- en: By the way, there is one catch here. When you defining rules, you also need
    to think about how feasible the rule logic is for implementation
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺便说一下，这里有一个要点。当你定义规则时，还需要考虑规则逻辑在实现上的可行性。
- en: Are the tools available or not? If the tools are available then you can code
    your rules or the developer can code the rules
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有可用的工具？如果工具可用，你可以编写规则，或者开发者可以编写规则。
- en: If the tools aren't available then you need to discard your rules
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果工具不可用，那么你需要放弃你的规则。
- en: Research is involved when you define a rule and then check whether there are
    any tools available which coders can use for coding up the defined rule logic
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你定义规则并检查是否有可供编码人员使用的工具时，研究就涉及其中。
- en: The selected tools should be capable of coding the exceptional scenarios for
    rules
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选定的工具应该能够编码规则的特殊情况。
- en: Defining rules and researching on tools can be basic tasks for linguists if
    you have some linguists in your team. If not, then you as coders need to search
    tools which you can use for coding the rule logic
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的团队中有语言学家，定义规则和研究工具可能是语言学家的基本任务。如果没有，那么作为编码人员，你需要搜索可以用来编写规则逻辑的工具。
- en: Without any delay, we will start coding.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将毫不拖延地开始编码。
- en: Start with simple rules
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从简单的规则开始。
- en: I have written a script which scrapes the Wikipedia page entitled Programming
    language.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我编写了一个脚本，用于抓取标题为“编程语言”的维基百科页面。
- en: 'Click here to open that page: [https://en.wikipedia.org/wiki/Programming_language](https://en.wikipedia.org/wiki/Programming_language)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 点击这里打开该页面：[https://en.wikipedia.org/wiki/Programming_language](https://en.wikipedia.org/wiki/Programming_language)
- en: 'Extracting the name of the programming languages from the text of the given
    page is our goal. Take an example: The page has C, C++, Java, JavaScript, and
    so on, programming languages. I want to extract them. These words can be a part
    of sentences or have occurred standalone in the text data content.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 从给定页面的文本中提取编程语言的名称是我们的目标。举个例子：该页面有 C、C++、Java、JavaScript 等编程语言。我想提取它们。这些词可能是句子的一部分，也可能独立出现在文本数据内容中。
- en: 'Now, see how we can solve this problem by defining a simple rule. The GitHub
    link for the script is: [https://github.com/jalajthanaki/NLPython/blob/master/ch7/7_1_simplerule.py](https://github.com/jalajthanaki/NLPython/blob/master/ch7/7_1_simplerule.py)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看我们如何通过定义一个简单的规则来解决这个问题。脚本的 GitHub 链接是：[https://github.com/jalajthanaki/NLPython/blob/master/ch7/7_1_simplerule.py](https://github.com/jalajthanaki/NLPython/blob/master/ch7/7_1_simplerule.py)
- en: 'The data file link on GitHub is: [https://github.com/jalajthanaki/NLPython/blob/master/data/simpleruledata.txt](https://github.com/jalajthanaki/NLPython/blob/master/data/simpleruledata.txt)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 上的数据文件链接是：[https://github.com/jalajthanaki/NLPython/blob/master/data/simpleruledata.txt](https://github.com/jalajthanaki/NLPython/blob/master/data/simpleruledata.txt)
- en: 'Here our task can be divided into three parts:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的任务可以分为三个部分：
- en: Scraping the text data
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抓取文本数据
- en: Defining the rule for our goal
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义我们的目标规则
- en: Coding our rule and generating the prototype and result
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写规则并生成原型和结果
- en: Scraping the text data
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抓取文本数据
- en: 'In this stage, we are going to scrape the text from the programming language
    wiki page and export the content into a text file. You can see the code snippet
    in *Figure 7.9*:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们将从编程语言的维基页面抓取文本，并将内容导出到文本文件中。你可以在*图 7.9*中看到代码片段：
- en: '![](img/7862c8ec-1953-4c0e-91ea-8c1fd703632e.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7862c8ec-1953-4c0e-91ea-8c1fd703632e.png)'
- en: 'Figure 7.9: Code snippets for scraping text data'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9：用于抓取文本数据的代码片段
- en: 'The output of the scraping data is shown in *Figure 7.10*:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 抓取数据的输出结果如*图 7.10*所示：
- en: '![](img/b0c90cf2-7310-4035-872c-47f7f48fe65e.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0c90cf2-7310-4035-872c-47f7f48fe65e.png)'
- en: 'Figure 7.10: Output of scraping script'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10：抓取脚本的输出结果
- en: Defining the rule for our goal
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义我们的目标规则
- en: Now, if you look at our scraped data, you can find the sentences. Now after
    analyzing the text, you need to define a rule for extracting only programming
    language names such as Java, JavaScript, MATLAB, and so on. Then, think for a
    while about what kind of simple rule or logic can help you to achieve your goal.
    Think hard and take your time! Try to focus on your thinking process and try to
    find out the patterns.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你查看我们抓取的数据，你可以找到这些句子。经过分析文本后，你需要定义一个规则，用来提取编程语言名称，如 Java、JavaScript、MATLAB
    等。然后，想一想，什么样的简单规则或逻辑可以帮助你实现目标。仔细思考，给自己一些时间！集中精力在思考过程中，并尽力找出模式。
- en: If I wanted to define a rule, then I would generalize my problem in the context
    of the data given to me. During my analysis, I have noticed that the majority
    of the programming language keywords come with the word language. I have noticed
    that when language as a word appears in the sentences, then there is a high chance
    that the actual programming language name also appears in that sentence. For example,
    the C programming language is specified by an ISO standard. In the given example,
    the C programming language appears and the word language also appears in the sentence.
    So, I will perform the following process.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我要定义一个规则，那么我会在给定数据的上下文中概括我的问题。在分析过程中，我发现大多数编程语言的关键字都会带有单词“language”。我注意到，当句子中出现“language”这个单词时，实际的编程语言名称也很有可能出现在该句子中。例如，C
    编程语言是由 ISO 标准指定的。在这个例子中，C 编程语言和单词“language”都出现在句子中。所以，我将执行以下过程。
- en: 'First, I need to extract the sentences which contain language as a word. Now
    as a second step, I will start to process the extracted sentences and check any
    capitalized words or camel case words there are in the sentence. Then, if I find
    any capitalized words or camel case words, I need to extract them and I will put
    them into the list because most of the programming languages appear as capitalized
    words or in camel case word format. See the examples: C, C++, Java, JavaScript,
    and so on. There will be cases where a single sentence contains the name of more
    than one programming language.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我需要提取包含单词“language”的句子。接下来，作为第二步，我将开始处理提取的句子，检查句子中是否有任何大写单词或驼峰式大小写单词。然后，如果我发现有任何大写单词或驼峰式大小写单词，我需要将它们提取出来，并把它们放入列表中，因为大多数编程语言都以大写单词或驼峰式大小写格式出现。比如，C、C++、Java、JavaScript
    等等。也会有情况，一句话中包含多个编程语言名称。
- en: 'The preceding process is our rule and the logical form of the rule is given
    here:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 上述过程就是我们的规则，规则的逻辑形式如下所示：
- en: Extract sentences with language as a word
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取包含单词“language”的句子
- en: Then try to find out words in the sentence which are in camel case or capitalized
    form
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后尝试找出句子中使用驼峰式大小写或大写形式的单词
- en: Put all these words in a list
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有这些单词放入列表中
- en: Print the list
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印列表
- en: Coding our rule and generating a prototype and result
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写规则并生成原型和结果
- en: This example gives you the practical essence of the rule making process. This
    is our first step so we are not focusing on accuracy very much. I know, this is
    not the only way of solving this problem and this is not the most efficient way.
    There are also other efficient ways to implement the same problem, but I'm using
    this one because I felt this solution is the simplest one and easiest to understand.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例给你提供了规则制定过程的实际精髓。这是我们的第一步，因此我们并不太关注准确性。我知道，这不是解决这个问题的唯一方法，也不是最有效的方法。还有其他更有效的方式可以实现同样的功能，但我使用这个方法是因为我觉得这是最简单且最易理解的解决方案。
- en: This example can help you to understand how rules can be coded and, after getting
    the result of the first prototype, what next steps you can take to improve your
    output.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例可以帮助你理解规则如何编码，并在得到第一个原型的结果后，你可以采取什么步骤来改进输出。
- en: 'See the code snippet in *Figure 7.11*:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见*图 7.11*中的代码片段：
- en: '![](img/b7e81518-af58-4790-8404-d4ab270cdd14.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b7e81518-af58-4790-8404-d4ab270cdd14.png)'
- en: 'Figure 7.11: Code for implementation of rule logic for extracting programming
    language'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11：提取编程语言规则逻辑的实现代码
- en: 'The output for the preceding code snippet is as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码片段的输出如下：
- en: '[PRE1]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now as you have seen, our basic rule extracted programming languages but it
    has also extracted junk data. Now think how you can restrict the rule or how you
    can put in some constraints so it will give us an accurate output. That will be
    your assignment.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的基本规则提取了编程语言，但也提取了无关数据。现在，思考如何限制规则或添加一些约束，使其能够给出准确的输出。这将是你的任务。
- en: Exercise
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Please improvise the preceding output by putting in some constraints (Hint:
    You can apply some preprocessing and regex can also help you.)'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 请通过添加一些约束来改进前面的输出（提示：你可以应用一些预处理，正则表达式也可以帮助你。）
- en: Python for pattern-matching rules for a proofreading application
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于校对应用程序的 Python 模式匹配规则
- en: Now, suppose you want to make a proofreading tool. So, here I will provide you
    with one very simple mistake that you can find easily in any business mail or
    in any letter. Then we will try to correct the errors with high accuracy.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你想制作一个校对工具。那么，在这里我将为你提供一个非常简单的错误，这个错误你可以在任何商务邮件或信件中轻松找到。然后我们将尝试以高准确率修正这些错误。
- en: The mistake is when people specify a meeting timing in their mail, they may
    have specified the time as 2pm, or as 2PM, or as 2P.M., or other variations, but
    the correct format is 2 p.m. or 9 a.m.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是，当人们在邮件中指定会议时间时，他们可能会指定为 2pm、2PM、2P.M. 或其他变体，但正确的格式应该是 2 p.m. 或 9 a.m.
- en: This mistake can be fixed by the pattern-based rule. The following is the rule
    logic.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误可以通过基于模式的规则来修复。以下是规则逻辑。
- en: Suppose the numeric digit of length two starts from 1 to 12\. After this numeric
    digit, if `am` and `pm` occurred without a space or without a period, then add
    the space and the proper period symbol.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 假设长度为两位的数字从1到12开始。此数字后，如果出现`am`和`pm`且没有空格或没有句点，请添加空格和正确的句点符号。
- en: I will implement it by using a regular expression.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用正则表达式来实现它。
- en: 'Source pattern:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 源模式：
- en: '[PRE2]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Target pattern:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 目标模式：
- en: '[PRE3]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can find the code on the GitHub URL at: [https://github.com/jalajthanaki/NLPython/blob/master/ch7/7_2_basicpythonrule.py](https://github.com/jalajthanaki/NLPython/blob/master/ch7/7_2_basicpythonrule.py)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub URL 上找到代码：[https://github.com/jalajthanaki/NLPython/blob/master/ch7/7_2_basicpythonrule.py](https://github.com/jalajthanaki/NLPython/blob/master/ch7/7_2_basicpythonrule.py)
- en: 'The code snippet is given in *Figure 7.12*:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段见*图 7.12*：
- en: '![](img/3f42586d-dc3e-4282-a65c-ebba44d8f8e4.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f42586d-dc3e-4282-a65c-ebba44d8f8e4.png)'
- en: 'Figure 7.12: Code snippet for pattern-based rule'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12：基于模式的规则代码片段
- en: 'The output of the preceding code snippet is:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码片段的输出是：
- en: '![](img/90ee2ddc-9ba7-454a-8597-7a7f5b171005.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90ee2ddc-9ba7-454a-8597-7a7f5b171005.png)'
- en: 'Figure 7.13: Output of pattern-based rule'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13：基于模式的规则输出
- en: The given example is a basic one, but it helps you to think about how proofreading
    can be done. Many simple sets of rules can be applied on the data and, according
    to the pattern, you will get the corrected result.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 给出的示例是一个基础示例，但它帮助你思考如何进行校对。许多简单的规则集合可以应用到数据上，并根据模式，你将获得修正后的结果。
- en: Exercise
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Write a similar kind of rule which helps in correcting the timing pattern 11:30am
    or 5:45pm to 11:30 a.m. or 5:45 p.m.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 编写类似的规则，帮助修正时间格式 11:30am 或 5:45pm 为 11:30 a.m. 或 5:45 p.m.
- en: Grammar correction
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法修正
- en: We will make a simple rule about a subject verb agreement rule for simple present
    tense.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为简单现在时的主谓一致规则做一个简单的定义。
- en: We know that in simple present tense the third-person singular subjects always
    takes a singular verb with either s/es as the suffix of the verb.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道在简单现在时中，第三人称单数主语总是使用单数动词，动词后缀为s/es。
- en: 'Here are some examples of incorrect sentences:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些不正确句子的示例：
- en: He drink tomato soup in the morning
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他早晨喝番茄汤
- en: She know cooking
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 她会做饭
- en: We plays game online
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在线玩游戏
- en: 'We cannot perform a pattern-based correction for these kinds of incorrect sentences.
    Here, to make a rule, we will parse each sentence and try to check by using the
    parser result. Can we make any rules? I have parsed sentences to generate the
    parse result so you can see the parse tree in *Figure 7.14*. This result has been
    generated by using the Stanford parser:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能对这些不正确的句子执行基于模式的修正。在这里，为了制定规则，我们将解析每个句子并尝试通过解析结果进行检查。我们能制定任何规则吗？我已经解析了句子并生成了解析结果，你可以在*图
    7.14*中看到解析树。这个结果是使用Stanford解析器生成的：
- en: '![](img/864c3aeb-7b89-473a-bad5-cf19fa6b45e7.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![](img/864c3aeb-7b89-473a-bad5-cf19fa6b45e7.png)'
- en: 'Figure 7.14: Parsing result for example sentences'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14：示例句子的解析结果
- en: We need to first extract the **NP**, which either takes the pronouns **PRP**/**NNP**
    or **NN**. This rule can be restricted to **PRP** only. We can extract the **PRP**
    tags from the sentence. After that we need to extract the **VP**. By using the
    type of pronoun and **VP**, we can suggest the change to the user. I guess you
    guys remember **NP**, **PRP**, **NNP**, and so on. As we have already shown, these
    are all kinds of POS tags, in [Chapter 5](07f71ca1-6c8a-492d-beb3-a47996e93f04.xhtml),
    *Feature Engineering and NLP Algorithm*.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要首先提取**NP**，它通常带有代词**PRP**/**NNP**或名词**NN**。这个规则可以限制为仅提取**PRP**。我们可以从句子中提取**PRP**标签。之后，我们需要提取**VP**。通过使用代词类型和**VP**，我们可以向用户建议更改。我猜你们应该记得**NP**、**PRP**、**NNP**等。这些都是词性标记（POS标签），如我们在[第5章](07f71ca1-6c8a-492d-beb3-a47996e93f04.xhtml)中所展示的，*特征工程与NLP算法*。
- en: 'Rule logic:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 规则逻辑：
- en: Extract the **NP** with the **PRP** tag
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取带有**PRP**标签的**NP**
- en: Extract the **VP**
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取**VP**
- en: As per the **PRP**, perform the correction in ****VP****
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据**PRP**，在****VP****中进行修正
- en: 'Let''s do the coding for this:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为此编写代码：
- en: 'I have installed the Stanford-`corenlp` and `pycornlp` libraries. You have
    already learned the steps for installing the Stanford parser in [Chapter 5](07f71ca1-6c8a-492d-beb3-a47996e93f04.xhtml),
    *Feature Engineering and NLP Algorithm.*You guys are going to code this. So, it''s
    a complete code challenge. I have a code in which I have extracted the pattern
    for you for **PRP** and **VBZ**/**VBP**. Your task is to check whether the combination
    of **PRP** and **VBP**/**VBZ** is right or wrong. If it is wrong, then raise an
    alert. You can find the code at: [https://github.com/jalajthanaki/NLPython/blob/master/ch7/7_3_SVArule.py](https://github.com/jalajthanaki/NLPython/blob/master/ch7/7_3_SVArule.py)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经安装了Stanford-`corenlp`和`pycornlp`库。你们已经在[第5章](07f71ca1-6c8a-492d-beb3-a47996e93f04.xhtml)中学习了如何安装Stanford解析器的步骤，*特征工程与NLP算法*。你们将编写代码。所以，这是一个完整的代码挑战。我提供了一段代码，其中为你提取了**PRP**和**VBZ**/**VBP**的模式。你的任务是检查**PRP**与**VBP**/**VBZ**的组合是否正确。如果不正确，则发出警报。你可以在此处找到代码：[https://github.com/jalajthanaki/NLPython/blob/master/ch7/7_3_SVArule.py](https://github.com/jalajthanaki/NLPython/blob/master/ch7/7_3_SVArule.py)
- en: 'You can see the code snippet in *Figure 7.15* and *Figure 7.16*:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*图 7.15*和*图 7.16*中看到代码片段：
- en: '![](img/bf229a86-fb2e-48e6-9fb4-efd8833a65c0.png)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf229a86-fb2e-48e6-9fb4-efd8833a65c0.png)'
- en: 'Figure 7.15: Stated Stanford corenlp server'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15：声明的Stanford corenlp服务器
- en: 'I have given you the code but you need to complete it:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经给你提供了代码，但你需要完成它：
- en: '![](img/a88b6724-67f7-4890-a3fa-59d1c7ac34b5.png)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a88b6724-67f7-4890-a3fa-59d1c7ac34b5.png)'
- en: 'Figure 7.16: Code which I have given to you but you need to complete'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16：我已经给你提供的代码，但你需要完成它
- en: 'You can see the output of my incomplete code in *Figure 7.17*:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*图 7.17*中看到我未完成的代码输出：
- en: '![](img/1083e9d0-41b5-4bb3-be1a-424cfc7d9d37.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1083e9d0-41b5-4bb3-be1a-424cfc7d9d37.png)'
- en: 'Figure 7.17: Output of my incomplete code'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17：我未完成的代码输出
- en: Template-based chatbot application
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于模板的聊天机器人应用
- en: Here, we will see how we can build a core engine for a chatbot application which
    can help a loan applicant to apply for the same. We are generating output in JSON
    format, so any front-end developer can integrate this output on a website.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看到如何为一个聊天机器人应用构建核心引擎，该应用可以帮助贷款申请人申请贷款。我们生成JSON格式的输出，因此任何前端开发人员都可以将这个输出集成到网站中。
- en: Here, I'm using the flask web framework and making web services for each question
    that our chatbot asks.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用了Flask Web框架，并为我们的聊天机器人每个问题创建了Web服务。
- en: 'You need to install MongoDB if you want to save the user data. The installation
    steps of MongoDB are in this link: [https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/)'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想保存用户数据，你需要安装MongoDB。MongoDB的安装步骤在这个链接中：[https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/)
- en: 'I have defined functions in the `conversationengine.py` file. The path of this
    file on GitHub is: [https://github.com/jalajthanaki/NLPython/blob/master/ch7/chatbot/customscripts/conversationengine.py](https://github.com/jalajthanaki/NLPython/blob/master/ch7/chatbot/customscripts/conversationengine.py)'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`conversationengine.py`文件中定义了函数。该文件在GitHub上的路径是：[https://github.com/jalajthanaki/NLPython/blob/master/ch7/chatbot/customscripts/conversationengine.py](https://github.com/jalajthanaki/NLPython/blob/master/ch7/chatbot/customscripts/conversationengine.py)
- en: 'You can see the flask web engine code in the `flaskengin.py` file. The GitHub
    link is: [https://github.com/jalajthanaki/NLPython/blob/master/ch7/chatbot/customscripts/conversationengine.py](https://github.com/jalajthanaki/NLPython/blob/master/ch7/chatbot/customscripts/conversationengine.py)'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`flaskengin.py`文件中看到Flask Web引擎的代码。GitHub链接是：[https://github.com/jalajthanaki/NLPython/blob/master/ch7/chatbot/customscripts/conversationengine.py](https://github.com/jalajthanaki/NLPython/blob/master/ch7/chatbot/customscripts/conversationengine.py)
- en: 'The whole folder and package file path is at: [https://github.com/jalajthanaki/NLPython/tree/master/ch7/chatbot](https://github.com/jalajthanaki/NLPython/tree/master/ch7/chatbot)'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 整个文件夹和包的路径是：[https://github.com/jalajthanaki/NLPython/tree/master/ch7/chatbot](https://github.com/jalajthanaki/NLPython/tree/master/ch7/chatbot)
- en: Flow of code
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码流程
- en: So, I have written functions in `conversationengine.py` which generate a JSON
    response according to the questions you have asked and this JSON response can
    be used by the frontend developer team to display messages on the chatbot UI.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我在`conversationengine.py`中编写了函数，根据你所提的问题生成JSON响应，这个JSON响应可以被前端开发团队用来在聊天机器人UI上显示消息。
- en: Then, I have written a web service using flask so you can see the JSON response
    on the web URL specified in JSON itself.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我使用Flask编写了一个Web服务，因此你可以在JSON中指定的Web URL上看到JSON响应。
- en: 'The `conversationengine.py` is the core rule engine with handcrafted rules
    and codes. See the code snippet in *Figure 7.18*:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`conversationengine.py`是核心规则引擎，包含手工编写的规则和代码。请参见*图7.18*中的代码片段：'
- en: '![](img/a0fd264e-9b32-44b0-bde0-cfd089c3c676.png)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0fd264e-9b32-44b0-bde0-cfd089c3c676.png)'
- en: 'Figure 7.18: Code snippet of conversationengine.py'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.18：`conversationengine.py`的代码片段
- en: Here, we have used a keywords list and, responses list to implement chatbot.
    I have also made customized JSON schema to export the conversation and, if you
    are from a web development background then you can write JavaScript which will
    help you to display this JSON on the front end with GUI.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了一个关键字列表和一个响应列表来实现聊天机器人。我还创建了自定义的JSON架构来导出对话。如果你来自Web开发背景，你可以编写JavaScript，它将帮助你在前端显示这个JSON，并展示图形用户界面。
- en: 'Now, let''s look at the web services part in *Figure 7.19*:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看*图7.19*中的Web服务部分：
- en: '![](img/a0ad22d9-1614-4e27-a5e0-8c4bfc45dde6.png)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0ad22d9-1614-4e27-a5e0-8c4bfc45dde6.png)'
- en: 'Figure 7.19: Flask web service URLs defined in flaskengin.py'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19：Flask Web服务URL在`flaskengin.py`中定义
- en: 'Now, to run the scripts and see the output follow these steps:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要运行脚本并查看输出，按照以下步骤操作：
- en: First run `flaskengin.py`
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先运行`flaskengin.py`
- en: 'Go to the URL: `http://0.0.0.0:5002/`, where you can see `Hello from chatbot
    Flask!`'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问这个URL：`http://0.0.0.0:5002/`，你将看到`Hello from chatbot Flask!`
- en: 'You can see the chatbot JSON response by using this URL: `http://0.0.0.0:5002/welcomemsg_chat`'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过使用这个URL查看聊天机器人的JSON响应：`http://0.0.0.0:5002/welcomemsg_chat`
- en: You can see the JSON response in *Figure 7.20*:![](img/266f8f6f-8f8d-4be6-af88-f0d1492a702e.png)
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在*图7.20*中看到JSON响应：![](img/266f8f6f-8f8d-4be6-af88-f0d1492a702e.png)
- en: 'Figure 7.20: JSON response of chatbot'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.20：聊天机器人的JSON响应
- en: 'Now, we are providing suggestions to our human user which will help them analyze
    what the expected input from them is. So, here, you can see the JSON attribute
    `suggestion_message: ["Hi"]`. So, the user will see the button with the `Hi` label.'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，我们正在向我们的用户提供建议，帮助他们分析他们期望的输入是什么。所以，在这里，你可以看到JSON属性`suggestion_message: ["Hi"]`。因此，用户将看到一个标签为`Hi`的按钮。'
- en: If you want to redirect to the next page or next question, then use `next_form_action`
    URL and put the user argument after `msg = USER ARGUMENT`
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想跳转到下一页或下一个问题，可以使用`next_form_action` URL，并将用户参数放在`msg = USER ARGUMENT`之后。
- en: For example, I am at the `http://0.0.0.0:5002/welcomemsg_chat` page. Now, you
    can read the `message_bot`. It says you need to say `Hi to bot`
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，我正在 `http://0.0.0.0:5002/welcomemsg_chat` 页面。现在，你可以阅读 `message_bot`。它告诉你需要对机器人说
    `Hi`
- en: 'You can give your `Hi` response like this: `http://0.0.0.0:5002/hi_chat?msg=Hi`'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以像这样发送你的 `Hi` 响应：`http://0.0.0.0:5002/hi_chat?msg=Hi`
- en: 'When you are on this URL: `http://0.0.0.0:5002/hi_chat?msg=Hi` you can see
    the bot will ask for your name now you need to enter your name.'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在这个 URL 上时：`http://0.0.0.0:5002/hi_chat?msg=Hi`，你可以看到聊天机器人会询问你的名字，现在你需要输入你的名字。
- en: To enter your name and be redirected to the next question, you need to again
    check what is the value of the URL for the `next_form_action` attribute
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要输入你的名字并跳转到下一个问题，你需要再次检查 URL 中 `next_form_action` 属性的值
- en: Here the value is `/asking_borowers_email_id?msg=`
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里的值是 `/asking_borowers_email_id?msg=`
- en: You need to put your name after the `=` sign so the URL becomes `/asking_borowers_email_id?msg=Jalaj
    Thanaki`
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要在 `=` 符号后面输入你的名字，这样 URL 就变成 `/asking_borowers_email_id?msg=Jalaj Thanaki`
- en: When you use `http://0.0.0.0:5002/asking_borowers_full_name?msg=Jalaj%20Thanaki`,
    you can see next question from the bot.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你使用 `http://0.0.0.0:5002/asking_borowers_full_name?msg=Jalaj%20Thanaki` 时，你可以看到聊天机器人提出下一个问题。
- en: 'First you need to run the script: [https://github.com/jalajthanaki/NLPython/blob/master/ch7/chatbot/flaskengin.py](https://github.com/jalajthanaki/NLPython/blob/master/ch7/chatbot/flaskengin.py)
    and then you can check the following URLs:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先你需要运行脚本：[https://github.com/jalajthanaki/NLPython/blob/master/ch7/chatbot/flaskengin.py](https://github.com/jalajthanaki/NLPython/blob/master/ch7/chatbot/flaskengin.py)，然后你可以查看以下
    URL：
- en: '`http://0.0.0.0:5002/welcomemsg_chat`'
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://0.0.0.0:5002/welcomemsg_chat`'
- en: '`http://0.0.0.0:5002/hi_chat?msg=Hi`'
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://0.0.0.0:5002/hi_chat?msg=Hi`'
- en: '`http://0.0.0.0:5002/asking_borowers_full_name msg=Jalaj%20Thanaki`'
  id: totrans-446
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://0.0.0.0:5002/asking_borowers_full_name msg=Jalaj%20Thanaki`'
- en: '`http://0.0.0.0:5002/asking_borowers_email_id?msg=jalaj@gmail.com`'
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://0.0.0.0:5002/asking_borowers_email_id?msg=jalaj@gmail.com`'
- en: '`http://0.0.0.0:5002/mobilenumber_asking?msg=9425897412`'
  id: totrans-448
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://0.0.0.0:5002/mobilenumber_asking?msg=9425897412`'
- en: '`http://0.0.0.0:5002/loan_chat?msg=100000`'
  id: totrans-449
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://0.0.0.0:5002/loan_chat?msg=100000`'
- en: '`http://0.0.0.0:5002/end_chat?msg=Bye`'
  id: totrans-450
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://0.0.0.0:5002/end_chat?msg=Bye`'
- en: If you want to insert user data in the MongoDB database, then this is possible
    and is included in the code but commented.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在 MongoDB 数据库中插入用户数据，这是可能的，代码中有相关内容，但已被注释掉。
- en: Advantages of template-based chatbot
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于模板的聊天机器人优点
- en: Easy to implement.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现容易。
- en: Time and cost efficient.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间和成本高效。
- en: Use cases are understood prior to development so user experience will also be
    good.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用案例在开发之前就已经确定，因此用户体验也会很好。
- en: This is a pattern-matching approach, so if users use English and other languages
    in their conversation then users also get answers because chatbot identifies keywords
    which he provides in English, and if English keywords match with the chatbot vocabulary,
    then chatbot can give you answer.
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一种模式匹配方法，所以如果用户在对话中使用英语和其他语言，聊天机器人也能提供回答，因为它识别出用户提供的英语关键词，并且如果这些英语关键词与聊天机器人的词汇表匹配，聊天机器人就能给出回答。
- en: Disadvantages of template-based chatbot
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于模板的聊天机器人缺点
- en: It cannot work for unseen use cases
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能处理未见过的使用案例
- en: User should process a rigid flow of conversation
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户需要处理一个严格的对话流程
- en: Spelling mistakes by users create a problem for chatbot. In this case, we will
    use deep learning
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的拼写错误会给聊天机器人带来问题。在这种情况下，我们将使用深度学习
- en: Exercise
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Develop a template-based chatbot application for a hotel room booking customer
    support service. Develop some questions and answers and develop the application.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 为酒店房间预订客户支持服务开发一个基于模板的聊天机器人应用程序。开发一些问题和答案，并开发应用程序。
- en: Comparing the rule-based approach with other approaches
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将基于规则的方法与其他方法进行比较
- en: 'The rule-based approach is a very reliable engine which provides your application
    with high accuracy. When you compare the RB approach with ML approaches or deep
    learning approaches, you will find the following points:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 基于规则的方法是一种非常可靠的引擎，它为你的应用程序提供高准确性。当你将 RB 方法与 ML 方法或深度学习方法进行比较时，你会发现以下几点：
- en: For the RB approach, you need a domain expert, while for the ML approach, or
    for the deep learning approach, you don't need a domain expert
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 RB 方法，你需要一个领域专家，而对于 ML 方法或深度学习方法，你不需要领域专家
- en: The RB system doesn't need a large amount of data, whereas ML and deep learning
    need a very large amount of data
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RB 系统不需要大量数据，而 ML 和深度学习需要非常大量的数据
- en: For the RB system, you need to find patterns manually, whereas ML and deep learning
    techniques find patterns on your behalf as per the data and input features
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于RB系统，你需要手动寻找模式，而机器学习（ML）和深度学习技术则会根据数据和输入特征为你自动寻找模式。
- en: The RB system is often a good approach for developing the first cut of your
    end product, which is still popular in practice
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RB系统通常是开发最终产品初步版本的一个不错方法，在实践中仍然广受欢迎。
- en: Advantages of the rule-based system
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于规则系统的优点
- en: 'There are very good advantages to using RB system. The advantages are mentioned
    as follows:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RB系统有很多优点。优点如下：
- en: 'Availability: Availability of the system for the user is not an issue'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性：系统对用户的可用性不是问题。
- en: 'Cost efficient: This system is cost efficient and accurate in terms of its
    end result'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成本效益：该系统在最终结果方面具有成本效益且准确。
- en: 'Speed: You can optimize the system as you know all the parts of the system.
    So to provide output in a few seconds is not a big issue'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速度：你可以优化系统，因为你了解系统的所有部分。因此，在几秒钟内提供输出不是一个大问题。
- en: 'Accuracy and less error rate: Although coverage for different scenarios is
    less, whatever scenarios are covered by the RB system will provide high accuracy.
    Because of these predefined rules, the error rate is also less'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准确性和较低的错误率：尽管不同场景的覆盖面较少，但RB系统涵盖的所有场景都能提供高准确性。由于这些预定义规则，错误率也较低。
- en: 'Reducing risk: We are reducing the amount of risk in terms of system accuracy'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降低风险：我们在系统准确性方面降低了风险。
- en: 'Steady response: Output which has been generated by the system is dependent
    on rules so the output responses are stable, which means it cannot be vague'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稳定响应：系统生成的输出依赖于规则，因此输出响应是稳定的，这意味着它不能模糊不清。
- en: 'The same cognitive process as a human: This system provides you with the same
    result as a human, as it has been handcrafted by humans'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与人类相同的认知过程：该系统为你提供与人类相同的结果，因为它是由人类手工制作的。
- en: 'Modularity: The modularity and good architecture of the RB system can help
    the technical team to maintain it easily. This decreases human efforts and time'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化：RB系统的模块化和良好的架构可以帮助技术团队轻松维护。这减少了人工工作和时间。
- en: 'Uniformity: The RB system is much uniformed in its implementation and its output.
    This makes life easy for the end user because the output of the system can be
    easily understood by humans'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致性：RB系统在其实现和输出方面非常一致。这使得最终用户的生活更轻松，因为系统的输出容易被人类理解。
- en: 'Easy to implement: This approach mimics the human thought process, so the implementation
    of rules is comparatively easy for developers'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于实现：该方法模仿了人类的思维过程，因此规则的实施对开发人员来说相对容易。
- en: Disadvantages of the rule-based system
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于规则系统的缺点
- en: 'The disadvantages of the RB system are as follows:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: RB系统的缺点如下：
- en: 'Lot of manual work: The RB system demands deep knowledge of the domain as well
    as a lot of manual work'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大量手工工作：RB系统要求对领域有深刻的了解，同时需要大量的手工工作。
- en: 'Time consuming: Generating rules for a complex system is quite challenging
    and time consuming'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 耗时：为一个复杂系统生成规则是一个相当具有挑战性且耗时的过程。
- en: 'Less learning capacity: Here, the system will generate the result as per the
    rules so the learning capacity of the system by itself is much less'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习能力较弱：在这里，系统将根据规则生成结果，因此系统本身的学习能力较差。
- en: 'Complex domains: If an application that you want to build is too complex, building
    the RB system can take lot of time and analysis. Complex pattern identification
    is a challenging task in the RB approach'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂领域：如果你要构建的应用程序过于复杂，构建RB系统可能会耗费大量时间和分析。复杂模式识别是RB方法中的一项挑战性任务。
- en: Challenges for the rule-based system
  id: totrans-487
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于规则系统的挑战
- en: 'Let''s look at some of the challenges in the RB approach:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下RB方法中的一些挑战：
- en: It is not easy to mimic the behavior of a human.
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模仿人类行为并不容易。
- en: Selecting or designing architecture is the critical part of the RB system.
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择或设计架构是RB系统的关键部分。
- en: In order to develop the RB system, you need to be an expert of the specific
    domain which generates rules for us. For NLP we need linguists who know how to
    analyze language.
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了开发RB系统，你需要是特定领域的专家，能够为我们生成规则。对于自然语言处理（NLP），我们需要了解如何分析语言的语言学家。
- en: Natural language is itself a challenging domain because it has so many exception
    cases and covering those exceptions using rules is also a challenging task, especially
    when you have a large amount of rules.
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自然语言本身就是一个具有挑战性的领域，因为它有许多例外情况，而使用规则覆盖这些例外情况也是一个具有挑战性的任务，尤其当你有大量规则时。
- en: Arabic, Gujarati, Hindi, and Urdu are difficult to implement in the RB system
    because finding a domain expert for these languages is a difficult task. There
    are also less tools available for the described languages to implement the rules.
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阿拉伯语、古吉拉特语、印地语和乌尔都语在RB系统中难以实现，因为为这些语言寻找领域专家是一项艰巨的任务。对于这些语言，实施规则的工具也较少。
- en: Time consumption of human effort is too high.
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人类努力的时间消耗太大。
- en: Understanding word-sense disambiguation basics
  id: totrans-495
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解词义消歧的基础知识。
- en: '**Word-sense disambiguation** (**WSD**) is a well-known problem in NLP. First
    of all, let''s understand what WSD is. WSD is used in identifying what the sense
    of a word means in a sentence when the word has multiple meanings. When a single
    word has multiple meaning, then for the machine it is difficult to identify the
    correct meaning and to solve this challenging issue we can use the rule-based
    system or machine learning techniques.'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '**词义消歧** (**WSD**) 是自然语言处理中的一个著名问题。首先，让我们了解一下什么是WSD。WSD用于在一个单词有多重含义的情况下，确定该单词在句子中的具体意义。当一个单词有多个含义时，机器很难识别正确的意义，解决这个挑战性问题的方法包括使用基于规则的系统或机器学习技术。'
- en: 'In this chapter, our focus area is the RB system. So, we will see the flow
    of how WSD is solved. In order to solve this complex problem using the RB system,
    you can take the following steps:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是RB系统。因此，我们将了解WSD是如何被解决的。为了使用RB系统解决这个复杂问题，您可以采取以下步骤：
- en: When you are trying to solve WSD for any language you need to have a lot of
    data where you can find the various instances of words whose meaning can be different
    from sentence to sentence
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你尝试解决任何语言的WSD时，你需要大量数据，其中包含多种不同情境下，单词含义会随句子变化的实例。
- en: Once you have this kind of dataset available, then human experts come into the
    picture
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦你有了这种数据集，接下来就需要人类专家介入。
- en: 'Human experts are used to tag the meaning of a word or words and usually the
    tags have some predefined IDs. Now, let''s take an example: I have the sentences:
    I went to river bank, and I went to bank to deposit my money.'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人类专家用于标注一个单词或多个单词的意义，通常这些标签都有一些预定义的ID。现在，让我们举个例子：我有这样的句子：I went to river bank（我去了河岸），和I
    went to bank to deposit my money（我去银行存钱）。
- en: In the preceding sentences, the word bank has multiple meanings and the meaning
    changes as per the overall sentence. So, the human expert is used to tag these
    kinds of words. Here, our word is bank
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的句子中，单词“bank”有多重含义，且其含义随着整体句子而变化。因此，需要人类专家来标注这些类型的单词。这里的单词是“bank”。
- en: So, the human expert tags the word bank in the river bank sense by using a predefined
    ID. Assume for now that the ID is 100
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，人类专家使用预定义的ID标注“bank”在“river bank”（河岸）中的意义。假设此时的ID是100。
- en: In the second sentence, the word bank is tagged as a financial institution by
    using the predefined ID. Assume for now that ID is 101
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二个句子中，单词“bank”通过使用预定义的ID被标注为金融机构。假设目前该ID是101。
- en: Once this tag has been given then the next stage has been started, which is
    either to choose rule-based engine or supervised machine learning techniques
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦这个标签被赋予，下一阶段就开始了，即选择基于规则的引擎或监督机器学习技术。
- en: If we decide to go with the rule-based system then human experts need to come
    up with a certain pattern or rules which help us to disambiguate the sense of
    the words. Sometimes, for some words, the expert can find the rule by using a
    parsing result or by using POS tags, but in most case they can't
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们决定使用基于规则的系统，那么人类专家需要提出一定的模式或规则，帮助我们消除词义歧义。有时候，对于某些单词，专家可以通过使用解析结果或POS标签找到规则，但在大多数情况下，他们做不到。
- en: So nowadays, once tagging has been done, the tagged data is used as input to
    develop a supervised machine learning model which helps humans to identify the
    senses of the words
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如今，一旦标注完成，标注数据就作为输入，用于开发一个监督学习模型，帮助人类识别单词的词义。
- en: Sometimes only the rule-based system cannot work in the same way only the machine
    learning approach alone sometimes can't help you. Here is the same kind of case
    according to my experience. I think the hybrid approach will give you a better
    result
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时候，仅靠基于规则的系统无法工作，单独的机器学习方法有时也无法帮你解决问题。根据我的经验，这是同样的情况。我认为混合方法会给你带来更好的结果。
- en: After tagging the data, we should build the RB system which handles known situations
    very well and we also have a situation where we can't define rules. To solve that
    situation, we need to build a machine learning model.
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在标注数据之后，我们应当构建一个规则库（RB）系统，它能够很好地处理已知的情况，同时也有一些情况我们无法定义规则。为了解决这些情况，我们需要构建一个机器学习模型。
- en: You can also use the vectorization concept and deep learning model to solve
    WSD problems. Your findings on WSD by using deep learning can be a research topic
    as well.
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还可以使用向量化概念和深度学习模型来解决词义消歧（WSD）问题。通过使用深度学习来研究词义消歧，你的发现也可以作为一个研究课题。
- en: Discussing recent trends for the rule-based system
  id: totrans-510
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论规则库系统的最新趋势
- en: This section is a discussion about how the current market is using the RB system.
    So many people are asking many questions on different forums and they want to
    know about the future of the RB system, so I want to discuss with you one important
    question which will help you to learn the future trends of the NLP market and
    RB system. I have some of the questions that we will look at.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论的是当前市场如何使用规则库系统。许多人在不同的论坛上提出了许多问题，他们想了解规则库系统的未来。我想和你讨论一个重要问题，这个问题将帮助你了解NLP市场和规则库系统的未来趋势。我们将探讨一些问题。
- en: Are RB systems outdated in the NLP domain? I would like to answer this with
    NO. The RB system has been used majorly in all NLP applications, grammar correction,
    speech recognition, machine translation, and so on! This approach is the first
    step when you start making any new NLP application. If you want to experiment
    on your idea, then prototypes can be easily developed with the help of the RB
    approach. For prototyping, you need domain knowledge and basic coding skills.
    You don't need to know high-level mathematics or ML techniques. For basic prototyping,
    you should go with the RB system.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 规则库系统在自然语言处理（NLP）领域是否过时了？我想回答这个问题的答案是“没有”。规则库系统在所有NLP应用中得到了广泛应用，包括语法纠正、语音识别、机器翻译等！当你开始制作任何新的NLP应用时，这种方法是第一步。如果你想对你的想法进行实验，那么可以通过规则库方法轻松开发原型。进行原型开发时，你需要领域知识和基本的编码技能。你不需要了解高阶数学或机器学习技术。对于基础原型开发，你应该选择规则库系统。
- en: Can deep learning and ML-based approaches replace the RB based system? This
    question is quite an open-ended question. I would like to present some facts at
    this point which will help you to derive your question. Nowadays, we are flooded
    with data and we have cheap computation power available to us. The AI industry
    and AI-based projects are creating a lot of buzz. The preceding two points help
    deep learning and ML approaches to derive accurate results for NLP as well as
    other AI applications. These approaches need less human effort compared to the
    RB system. This is the reason why so many people think that the RB system will
    not be replaced by the deep learning and ML-based systems. I would argue that
    the RB system is not going to be replaced totally, but it will complement these
    approaches. Now you ask, how? So, the answer is, I think I would like to go with
    hybrid approaches which are much more beneficial for us. We can find patterns
    or predictions with the help of the ML system and then give those predictions
    to the RB system, and the RB system can validate the prediction and choose the
    best one for the users. This will actually help us to overcome one major challenge
    of the RB system, which is the reduction of human effort and time.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 深度学习和基于机器学习（ML）的方法能否取代基于规则库的系统？这个问题是一个相当开放性的问题。我希望在此提供一些事实，帮助你思考这个问题。如今，我们被大量数据淹没，并且拥有廉价的计算能力。人工智能行业及其基于人工智能的项目正在引起广泛关注。前面提到的两点使得深度学习和机器学习方法能够为自然语言处理（NLP）以及其他人工智能应用提供准确的结果。这些方法相比规则库系统需要更少的人工干预。这也是为什么许多人认为规则库系统不会被深度学习和基于机器学习的方法所取代。我认为规则库系统不会完全被取代，但它会与这些方法互为补充。那么，你可能会问，如何做到呢？我的答案是，我认为我们应该采用混合方法，这对我们更为有利。我们可以借助机器学习系统来发现模式或做出预测，然后将这些预测交给规则库系统，规则库系统可以验证这些预测，并为用户选择最佳方案。这实际上帮助我们解决了规则库系统的一个主要挑战——减少人工干预和时间。
- en: For the preceding questions, there is not any right or wrong answers. It is
    all about how you can see the questions and NLP domain. I just want to leave a
    thought for you. Think by yourself and try to come up with your own answer.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的问题，没有绝对的对错答案。这完全取决于你如何看待这些问题和自然语言处理领域。我只是想给你留下一些思考，自己思考一下，尽量得出你自己的答案。
- en: Summary
  id: totrans-515
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen all the details related to the rule-based system
    and how the rule-based approach helps us to develop rapid prototypes for complex
    problems with high accuracy. We have seen the architecture of the rule-based system.
    We have learned about the advantages, disadvantages, and challenges for the rule-based
    system. We have seen how this system is helpful to us for developing NLP applications
    such as grammar correction systems, chatbots, and so on. We have also discussed
    the recent trends for the rule-based system.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们已经了解了与基于规则的系统相关的所有细节，以及基于规则的方法如何帮助我们为复杂问题开发具有高精度的快速原型。我们已经了解了基于规则的系统架构，学习了基于规则系统的优缺点和挑战。我们还看到，这个系统如何帮助我们开发自然语言处理（NLP）应用程序，例如语法纠错系统、聊天机器人等。我们还讨论了基于规则系统的最新趋势。
- en: In the next chapter, we will learn the other main approaches called machine
    learning, to solve NLP applications. The upcoming chapter will give you all the
    details about which machine learning algorithms you need to use for developing
    NLP applications. We will see supervised ML, semi-supervised ML, and unsupervised
    ML techniques. We will also develop some of the applications from scratch. So
    keep reading!
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习另一种主要方法——机器学习，用来解决NLP应用问题。接下来的章节将向你详细介绍开发NLP应用时需要使用哪些机器学习算法。我们将探讨监督学习、半监督学习和无监督学习技术，并从零开始开发一些应用。所以，继续阅读！
- en: This self-driving car exam
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 这次自动驾驶汽车考试
