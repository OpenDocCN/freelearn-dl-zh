- en: 2\. An Introduction to Regression
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 回归简介
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will be introduced to regression. Regression comes in handy
    when you are trying to predict future variables using historical data. You will
    learn various regression techniques such as linear regression with single and
    multiple variables, along with polynomial and Support Vector Regression (SVR).
    You will use these techniques to predict future stock prices from a stock price
    data. By the end of this chapter, you will be comfortable using regression techniques
    to solve practical problems in a variety of fields.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习回归技术。回归在尝试使用历史数据预测未来变量时非常有用。您将学习各种回归技术，如单变量和多变量线性回归，以及多项式回归和支持向量回归（SVR）。您将使用这些技术预测未来的股价。到本章结束时，您将能够熟练地运用回归技术解决各个领域的实际问题。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, you were introduced to the fundamentals of **Artificial
    Intelligence** (**AI**), which helped you create the game Tic-Tac-Toe. In this
    chapter, we will be looking at regression, which is a machine learning algorithm
    that can be used to measure how closely related independent variable(s), called
    **features**, relate to a dependent variable called a **label**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您已经了解了**人工智能**（**AI**）的基本知识，并使用它创建了井字游戏。在本章中，我们将讨论回归，它是一种机器学习算法，可用于衡量独立变量（称为**特征**）与依赖变量（称为**标签**）之间的关系。
- en: Linear regression is a concept with many applications a variety of fields, ranging
    from finance (predicting the price of an asset) to business (predicting the sales
    of a product) and even the economy (predicting economy growth).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归是一个广泛应用于各个领域的概念，从金融（预测资产价格）到商业（预测产品销量），甚至到经济学（预测经济增长）。
- en: Most of this chapter will deal with different forms of linear regression, including
    linear regression with one variable, linear regression with multiple variables,
    polynomial regression with one variable, and polynomial regression with multiple
    variables. Python provides lots of forms of support for performing regression
    operations and we will also be looking at these later on in this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章大部分内容将讨论不同形式的线性回归，包括单变量线性回归、多变量线性回归、单变量多项式回归和多变量多项式回归。Python 提供了许多回归操作的支持，我们也将在本章稍后介绍这些内容。
- en: We will also use an alternative regression model, called **Support Vector Regression**
    (**SVR**), with different forms of linear regression. Throughout this chapter,
    we will be using a few sample datasets along with the stock price data loaded
    from the **Quandl** Python library to predict future prices using different types
    of regression.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用一种替代回归模型，称为**支持向量回归**（**SVR**），以及不同形式的线性回归。在本章中，我们将使用一些样本数据集，以及从**Quandl**
    Python 库加载的股价数据，利用不同类型的回归来预测未来价格。
- en: Note
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Although it is not recommended that you use the models in this chapter to provide
    trading or investment advice, this is a very exciting and interesting journey
    that explains the fundamentals of regression.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不建议您使用本章中的模型来提供交易或投资建议，但这是一次非常激动人心且有趣的旅程，它解释了回归的基本原理。
- en: Linear Regression with One Variable
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单变量线性回归
- en: A general regression problem can be defined with the following example. Suppose
    we have a set of data points and we need to figure out the best fit curve to approximately
    fit the given data points. This curve will describe the relationship between our
    input variable, `x`, which is the data point, and the output variable, `y`, which
    is the curve.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一个通用的回归问题可以通过以下示例定义。假设我们有一组数据点，需要找出最佳拟合曲线来大致拟合给定的数据点。这条曲线将描述输入变量`x`（即数据点）和输出变量`y`（即曲线）之间的关系。
- en: Remember, in real life, we often have more than one input variable determining
    the output variable. However, linear regression with one variable will help us
    to understand how the input variable impacts the output variable.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在现实生活中，我们通常有多个输入变量决定输出变量。然而，使用单变量的线性回归有助于我们理解输入变量如何影响输出变量。
- en: Types of Regression
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回归的类型
- en: In this chapter, we will work with regression on the two-dimensional plane.
    This means that our data points are two-dimensional, and we are looking for a
    curve to approximate how to calculate one variable from another.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将处理二维平面上的回归问题。这意味着我们的数据点是二维的，我们正在寻找一条曲线来近似如何从一个变量计算另一个变量。
- en: 'We will come across the following types of regression in this chapter:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将遇到以下几种回归类型：
- en: '**Linear regression with one variable using a polynomial of degree 1**: This
    is the most basic form of regression, where a straight line approximates the trajectory
    of future data.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用一次多项式的单变量线性回归**：这是最基本的回归形式，其中一条直线近似未来数据的轨迹。'
- en: '**Linear regression with multiple variables using a polynomial of degree 1**:
    We will be using equations of degree 1, but we will also allow multiple input
    variables, called features.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用一次多项式的多变量线性回归**：我们将使用一次方程，但也允许多个输入变量，称为特征。'
- en: '**Polynomial regression with one variable**: This is a generic form of the
    linear regression of one variable. As the polynomial used to approximate the relationship
    between the input and the output is of an arbitrary degree, we can create curves
    that fit the data points better than a straight line. The regression is still
    linear – not because the polynomial is linear, but because the regression problem
    can be modeled using linear algebra.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单变量的多项式回归**：这是单变量线性回归的通用形式。由于用来近似输入与输出之间关系的多项式可以是任意的次数，因此我们可以创建比直线更适合数据点的曲线。回归依然是线性的——不是因为多项式是线性的，而是因为回归问题可以通过线性代数来建模。'
- en: '**Polynomial regression with multiple variables**: This is the most generic
    regression problem, using higher degree polynomials and multiple features to predict
    the future.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多变量的多项式回归**：这是最通用的回归问题，使用高次多项式和多个特征来预测未来。'
- en: '**SVR**: This form of regression uses **Support Vector Machines** (**SVMs**)
    to predict data points. This type of regression is included to explain SVR''s
    usage compared to the other four regression types.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SVR**：这种回归形式使用**支持向量机**（**SVMs**）来预测数据点。包括这种回归类型是为了说明SVR与其他四种回归类型的区别。'
- en: 'Now we will deal with the first type of linear regression: we will use one
    variable, and the polynomial of the regression will describe a straight line.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将处理第一种类型的线性回归：我们将使用一个变量，并且回归的多项式将描述一条直线。
- en: On the two-dimensional plane, we will use the Déscartes coordinate system, more
    commonly known as the *Cartesian coordinate system*. We have an *x* and a *y*-axis,
    and the intersection of these two axes is the origin. We denote points by their
    *x* and *y* coordinates.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在二维平面上，我们将使用笛卡尔坐标系，也被称为*笛卡尔坐标系*。我们有一个*x*轴和一个*y*轴，这两条轴的交点是原点。我们用*x*和*y*坐标来表示点的位置。
- en: 'For instance, point *(2, 1)* corresponds to the black point on the following
    coordinate system:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，点*(2, 1)*对应于下列坐标系中的黑色点：
- en: '![Figure 2.1: Representation of point (2,1) on the coordinate system'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.1：点(2, 1)在坐标系中的表示'
- en: '](img/B16060_02_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_02_01.jpg)'
- en: 'Figure 2.1: Representation of point (2,1) on the coordinate system'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：点(2, 1)在坐标系中的表示
- en: A straight line can be described with the equation *y = a*x + b*, where *a*
    is the slope of the equation, determining how steeply the equation climbs up,
    and *b* is a constant determining where the line intersects the *y*-axis.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一条直线可以用方程*y = a*x + b*来描述，其中*a*是方程的斜率，决定了方程上升的陡峭度，*b*是常数，决定了直线与*y*轴的交点。
- en: 'In *Figure 2.2*, you can see three equations:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 2.2*中，您可以看到三个方程：
- en: The straight line is described with the equation *y = 2*x + 1*.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这条直线的方程是*y = 2*x + 1*。
- en: The dashed line is described with the equation *y = x + 1*.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚线的方程是*y = x + 1*。
- en: The dotted line is described with the equation *y = 0.5*x + 1*.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚线的方程是*y = 0.5*x + 1*。
- en: You can see that all three equations intersect the *y*-axis at *1*, and their
    slope is determined by the factor by which we multiply *x*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，所有三个方程都在*y*轴上交于*1*，它们的斜率由我们乘以*x*的因子来决定。
- en: 'If you know *x*, you can solve *y*. Similarly, if you know *y*, you can solve
    *x*. This equation is a polynomial equation of degree *1*, which is the base of
    linear regression with one variable:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道*x*，你就可以求解*y*。类似地，如果你知道*y*，你也可以求解*x*。这个方程是一个一次多项式方程，它是单变量线性回归的基础：
- en: '![Figure 2.2: Representation of the equations y = 2*x + 1, y = x + 1, and y
    = 0.5*x + 1 on the coordinate system'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.2：y = 2*x + 1、y = x + 1 和 y = 0.5*x + 1 在坐标系中的表示'
- en: '](img/B16060_02_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_02_02.jpg)'
- en: 'Figure 2.2: Representation of the equations y = 2*x + 1, y = x + 1, and y =
    0.5*x + 1 on the coordinate system'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：y = 2*x + 1、y = x + 1 和 y = 0.5*x + 1 在坐标系中的表示
- en: 'We can describe curves instead of straight lines using polynomial equations;
    for example, the polynomial equation *4x*4*-3x*3*-x*2*-3x+3* will result in *Figure
    2.3*. This type of equation is the base of polynomial regression with one variable:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用多项式方程来描述曲线而非直线；例如，多项式方程 *4x*4*-3x*3*-x*2*-3x+3* 将生成 *图 2.3*。这种类型的方程是具有一个变量的多项式回归的基础：
- en: '![Figure 2.3: Representation of the polynomial equation'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.3：多项式方程的表示'
- en: '](img/B16060_02_03.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_02_03.jpg)'
- en: 'Figure 2.3: Representation of the polynomial equation'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3：多项式方程的表示
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you would like to experiment further with the Cartesian coordinate system,
    you can use the following plotter: [https://s3-us-west-2.amazonaws.com/oerfiles/College+Algebra/calculator.html](https://s3-us-west-2.amazonaws.com/oerfiles/College+Algebra/calculator.html).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想进一步实验笛卡尔坐标系，可以使用以下绘图工具：[https://s3-us-west-2.amazonaws.com/oerfiles/College+Algebra/calculator.html](https://s3-us-west-2.amazonaws.com/oerfiles/College+Algebra/calculator.html)。
- en: Features and Labels
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特征和标签
- en: In machine learning, we differentiate between features and labels. Features
    are considered our **input** variables, and labels are our **output** variables.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中，我们区分特征和标签。特征被视为我们的**输入**变量，而标签则是我们的**输出**变量。
- en: When talking about regression, the possible value of the labels is a continuous
    set of rational numbers. Think of features as the values on the *x*-axis and labels
    as the values on the *y*-axis.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈到回归时，标签的可能值是一个连续的有理数集合。可以将特征看作是 *x* 轴上的值，而标签则是 *y* 轴上的值。
- en: The task of regression is to predict label values based on feature values.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 回归任务是基于特征值预测标签值。
- en: We often create a label by projecting the values of a feature in the future.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常通过将特征的值投影到未来来创建标签。
- en: 'For instance, if we would like to predict the price of a stock for next month
    using historical monthly data, we would create the label by shifting the stock
    price feature one month into the future:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想通过历史月度数据来预测下个月的股票价格，我们将通过将股票价格特征向未来移动一个月来创建标签：
- en: For each stock price feature, the label would be the stock price feature of
    the next month.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个股票价格特征，标签将是下个月的股票价格特征。
- en: For the last month, prediction data would not be available, so these values
    are all `NaN` (Not a Number).
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于最后一个月，预测数据将无法获得，因此这些值都是 `NaN`（不是一个数字）。
- en: Let's say we have data for the months of `January`, `February`, and `March`,
    and we want to predict the price for `April`. Our feature for each month will
    be the current monthly price and the label will be the price of the next month.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有 `1月`、`2月` 和 `3月` 的数据，并且我们想要预测 `4月` 的价格。我们每个月的特征将是当前月的价格，标签将是下一个月的价格。
- en: 'For instance, take a look at the following table:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看以下表格：
- en: '![Figure 2.4: Example of a feature and a label'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.4：特征和标签的示例'
- en: '](img/B16060_02_04.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_02_04.jpg)'
- en: 'Figure 2.4: Example of a feature and a label'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4：特征和标签的示例
- en: This means that the label for `January` is the price of `February` and that
    the label for `February` is actually the price of `March`. The label for `March`
    is unknown (`NaN`) as this is the value we are trying to predict.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `1月` 的标签是 `2月` 的价格，`2月` 的标签实际上是 `3月` 的价格。`3月` 的标签是未知的（`NaN`），因为这是我们要预测的值。
- en: Feature Scaling
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特征缩放
- en: At times, we have multiple features (inputs) that may have values within completely
    different ranges. Imagine comparing micrometers on a map to kilometers in the
    real world. They won't be easy to handle because of the difference in magnitude
    of nine zeros.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们会有多个特征（输入），它们可能具有完全不同范围的值。想象一下将地图上的微米与现实世界中的千米进行比较。由于数量级差异有九个零，这些值处理起来会非常困难。
- en: A less dramatic difference is the difference between imperial and metric data.
    For instance, pounds and kilograms, and centimeters and inches, do not compare
    that well.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个较小的差异是英制和公制数据之间的差异。例如，磅和千克，厘米和英寸，它们的比较并不好。
- en: Therefore, we often scale our features to normalized values that are easier
    to handle, as we can compare the values of these ranges more easily.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们通常将特征缩放到更容易处理的归一化值，因为我们可以更轻松地比较这些范围的值。
- en: 'We will demonstrate two types of scaling:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将演示两种类型的缩放：
- en: Min-max normalization
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Min-max 归一化
- en: Mean normalization
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 均值归一化
- en: 'Min-max normalization is calculated as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Min-max 归一化的计算方法如下：
- en: '![1](img/B16060_02_4a.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![1](img/B16060_02_4a.png)'
- en: Here, *X*MIN is the minimum value of the feature and *X*MAX is the maximum value.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*X*MIN 是特征的最小值，*X*MAX 是最大值。
- en: The feature-scaled values will be within the range of `[0;1]`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 特征缩放后的值将在 `[0;1]` 的范围内。
- en: 'Mean normalization is calculated as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 均值归一化的计算方法如下：
- en: '![2](img/B16060_02_4b.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![2](img/B16060_02_4b.png)'
- en: Here, `AVG` is the average.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`AVG` 是平均值。
- en: The feature-scaled values will be within the range of `[-1;1]`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 特征缩放后的值将在 `[-1;1]` 的范围内。
- en: Here's an example of both normalizations applied on the first 13 numbers of
    the Fibonacci sequence.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在斐波那契数列的前 13 个数字上应用两种归一化的例子。
- en: 'We begin with finding the min-max normalization:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先找到 min-max 归一化：
- en: '[PRE0]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The expected output is this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出是这样的：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, take a look at the following code snippet to find the mean normalization:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，查看以下代码片段以找到均值归一化：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The expected output is this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出是这样的：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Scaling could add to the processing time, but, often, it is an important step
    to add.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放可能会增加处理时间，但通常它是一个需要执行的重要步骤。
- en: 'In the scikit-learn library, we have access to the `preprocessing.scale` function,
    which scales NumPy arrays:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 scikit-learn 库中，我们可以使用 `preprocessing.scale` 函数，它可以对 NumPy 数组进行缩放：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The expected output is this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出是这样的：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `scale` method performs a standardization, which is another type of normalization.
    Notice that the result is a NumPy array.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`scale` 方法执行标准化，这是一种归一化方式。注意，结果是一个 NumPy 数组。'
- en: Splitting Data into Training and Testing
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据分为训练集和测试集
- en: Now that we have learned how to normalize our dataset, we need to learn about
    the training-testing split. In order to measure how well our model can generalize
    its predictive performance, we need to split our dataset into a training set and
    a testing set. The training set is used by the model to learn from so that it
    can build predictions. Then, the model will use the testing set to evaluate the
    performance of its prediction.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何对数据集进行归一化，我们还需要学习训练-测试拆分。为了衡量我们的模型能否很好地概括其预测性能，我们需要将数据集分为训练集和测试集。训练集供模型学习以构建预测，然后，模型将使用测试集来评估其预测的性能。
- en: When we split the dataset, we first need to shuffle it to ensure that our testing
    set will be a generic representation of our dataset. The split is usually 90%
    for the training set and 10% for the testing set.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们分割数据集时，我们首先需要对其进行洗牌，以确保我们的测试集能够代表整个数据集。通常，拆分比例为 90% 用于训练集，10% 用于测试集。
- en: With training and testing, we can measure whether our model is overfitting or
    underfitting.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过训练和测试，我们可以衡量模型是否发生了过拟合或欠拟合。
- en: '**Overfitting** occurs when the trained model fits the training dataset too
    well. The model will be very accurate on the training data, but it will not be
    usable in real life, as its accuracy will decrease when used on any other data.
    The model adjusts to the random noise in the training data and assumes patterns
    on this noise that yield false predictions.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**过拟合**发生在训练好的模型对训练数据拟合得过于完美时。模型在训练数据上表现得非常准确，但在实际应用中无法使用，因为它在其他数据上的准确度会降低。模型会对训练数据中的随机噪声进行调整，并假设这些噪声中存在的模式，从而得出错误的预测。'
- en: '**Underfitting** occurs when the trained model does not fit the training data
    well enough to recognize important patterns in the data. As a result, it cannot
    make accurate predictions on new data. One example of this is when we attempt
    to do linear regression on a dataset that is not linear. For example, the Fibonacci
    sequence is not linear; therefore, a model on a Fibonacci-like sequence cannot
    be linear either.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**欠拟合**发生在训练好的模型无法充分拟合训练数据，导致无法识别数据中的重要模式。因此，它无法对新数据做出准确的预测。一个例子是当我们尝试对一个非线性数据集进行线性回归时。例如，斐波那契数列是非线性的；因此，基于类似斐波那契数列的数据建模也不可能是线性的。'
- en: We can do the training-testing split using the `model_selection` library of
    scikit- learn.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 scikit-learn 的 `model_selection` 库来进行训练-测试拆分。
- en: 'Suppose, in our example, that we have scaled the Fibonacci data and defined
    its indices as labels:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，在我们的例子中，我们已经对斐波那契数据进行了缩放，并将其索引定义为标签：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let''s use 10% of the data as test data, `test_size=0.1`, and specify
    `random_state` parameter in order to get the exact same split every time we run
    the code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将数据的10%用作测试数据，`test_size=0.1`，并指定`random_state`参数，以便每次运行代码时都能得到完全相同的分割：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our dataset has been split into test and training sets for our features (`x_train`
    and `x_test`) and for our labels (`y_train` and `y_test`).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据集已被划分为特征（`x_train`和`x_test`）和标签（`y_train`和`y_test`）的测试集和训练集。
- en: 'Finally, let''s check each set, beginning with the `x_train` feature:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们检查每个数据集，从`x_train`特征开始：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The expected output is this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出为：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we check for `x_test`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查`x_test`：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The expected output is this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出为：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we check for `y_train`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查`y_train`：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The expected output is this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出为：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we check for `y_test`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查`y_test`：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The expected output is this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出为：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding output, we can see that our split has been properly executed;
    for instance, our label has been split into `y_test`, which contains the `7` and
    `10` indexes, and `y_train` which contains the remaining `11` indexes. The same
    logic has been applied to our features and we have `2` values in `x_test` and
    `11` values in `x_train`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到我们的数据分割已正确执行；例如，我们的标签已被分割为`y_test`，其中包含`7`和`10`索引，`y_train`包含其余的`11`个索引。相同的逻辑已应用于我们的特征，`x_test`中有`2`个值，`x_train`中有`11`个值。
- en: Note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: If you remember the Cartesian coordinate system, you know that the horizontal
    axis is the *x*-axis and that the vertical axis is the *y*-axis. Our features
    are on the *x*-axis, while our labels are on the *y*-axis. Therefore, we use features
    and *x* as synonyms, while labels are often denoted by *y*. Therefore, `x_test`
    denotes feature test data, `x_train` denotes feature training data, `y_test` denotes
    label test data, and `y_train` denotes label training data.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得笛卡尔坐标系，你会知道水平轴是*x*轴，垂直轴是*y*轴。我们的特征位于*x*轴上，而我们的标签位于*y*轴上。因此，我们将特征和*x*视为同义词，而标签通常用*y*表示。因此，`x_test`表示特征测试数据，`x_train`表示特征训练数据，`y_test`表示标签测试数据，`y_train`表示标签训练数据。
- en: Fitting a Model on Data with scikit-learn
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用scikit-learn在数据上拟合模型
- en: We are now going to illustrate the process of regression on an example where
    we only have one feature and minimal data.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过一个只有一个特征且数据最小的例子来说明回归过程。
- en: As we only have one feature, we have to format `x_train` by reshaping it with
    `x_train.reshape (-1,1)` to a NumPy array containing one feature.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只有一个特征，我们必须通过`x_train.reshape (-1,1)`将`x_train`格式化为包含一个特征的NumPy数组。
- en: 'Therefore, before executing the code on fitting the best line, execute the
    following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在执行拟合最佳直线的代码之前，先执行以下代码：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can fit a linear regression model on our data with the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下代码在数据上拟合一个线性回归模型：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The expected output is this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出为：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can also calculate the score associated with the model:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以计算与模型相关的得分：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The expected output is this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出为：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This score represents the accuracy of the model and is defined as the R2 or
    **coefficient of determination**. It represents how well we can predict the features
    from the labels.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个得分表示模型的准确性，定义为R2或**决定系数**。它表示我们可以从标签中预测特征的程度。
- en: In our example, an R2 of `-1.8268` indicates a very bad model as the best possible
    score is **1**. A score of **0** can be achieved if we constantly predict the
    labels by using the average value of the features.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`-1.8268`的R2表示一个非常糟糕的模型，因为最佳得分为**1**。如果我们始终使用特征的平均值来预测标签，则可以获得**0**的得分。
- en: Note
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: We will omit the mathematical background of this score in this book.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将省略此得分的数学背景。
- en: 'Our model does not perform well for two reasons:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模型表现不佳有两个原因：
- en: If we check our previous Fibonacci sequence, 11 training data points and 2 testing
    data points are simply not enough to perform a proper predictive analysis.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们检查之前的斐波那契数列，11个训练数据点和2个测试数据点显然不足以进行适当的预测分析。
- en: Even if we ignore the number of points, the Fibonacci sequence does not describe
    a linear relationship between *x* and *y*. Approximating a nonlinear function
    with a line is only useful if we are looking at two very close data points.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使我们忽略数据点的数量，斐波那契数列并没有描述*x*和*y*之间的线性关系。用直线近似非线性函数仅在我们观察到两个非常接近的数据点时才有用。
- en: Linear Regression Using NumPy Arrays
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用NumPy数组进行线性回归
- en: One reason why NumPy arrays are handier than Python lists is that they can be
    treated as vectors. There are a few operations defined on vectors that can simplify
    our calculations. We can perform operations on vectors of similar lengths.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组比 Python 列表更方便的一个原因是它们可以被视为向量。向量上定义了一些操作，可以简化我们的计算。我们可以对长度相同的向量执行操作。
- en: 'Let''s take, for example, two vectors, V1 and V2, with three coordinates each:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以两个向量 V1 和 V2 为例，每个向量有三个坐标：
- en: V1 = (a, b, c) with a=1, b=2, and c=3
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: V1 = (a, b, c)，其中 a=1，b=2，c=3
- en: V2 = (d, e, f) with d=2, e=0, and f=2
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: V2 = (d, e, f)，其中 d=2，e=0，f=2
- en: 'The addition of these two vectors will be this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个向量的加法将是：
- en: V1 + V2 = (a+d, b+e, c+f) = (1+2, 2+0, 3+2) = (3,2,5)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: V1 + V2 = (a+d, b+e, c+f) = (1+2, 2+0, 3+2) = (3,2,5)
- en: 'The product of these two vectors will be this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个向量的乘积将是：
- en: V1 + V2 = (a*d, b*e, c*f) = (1*2, 2*0, 3*2) = (2,0,6)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: V1 + V2 = (a*d, b*e, c*f) = (1*2, 2*0, 3*2) = (2,0,6)
- en: You can think of each vector as our datasets with, for example, the first vector
    as our **features set** and the second vector as our **labels set**. With Python
    being able to do vector calculations, this will greatly simplify the calculations
    required for our linear regression models.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将每个向量看作我们的数据集，例如，第一个向量是我们的**特征集**，第二个向量是我们的**标签集**。因为 Python 能够进行向量计算，这将大大简化我们线性回归模型所需的计算。
- en: Now, let's build a linear regression using NumPy in the following example.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过以下示例使用 NumPy 构建线性回归。
- en: Suppose we have two sets of data with 13 data points each; we want to build
    a linear regression that best fits all the data points for each set.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个数据集，每个数据集有 13 个数据点；我们想要构建一条最佳拟合所有数据点的线性回归线。
- en: 'Our first set is defined as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一组数据定义如下：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we plot this dataset with the values (`2,8,8,18,25,21,32,44,32,48,61,45,62`)
    as the *y*-axis, and the index of each value (`1,2,3,4,5,6,7,8,9,10,11,12,13`)
    as the *x*-axis, we will get the following plot:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个数据集的值（`2,8,8,18,25,21,32,44,32,48,61,45,62`）绘制为*y*轴，而每个值的索引（`1,2,3,4,5,6,7,8,9,10,11,12,13`）绘制为*x*轴，我们将得到如下图表：
- en: '![Figure 2.5: Plotted graph of the first dataset'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.5：第一个数据集的绘制图]'
- en: '](img/B16060_02_05.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_02_05.jpg)'
- en: 'Figure 2.5: Plotted graph of the first dataset'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5：第一个数据集的绘制图
- en: We can see that this dataset's distribution seems linear in nature, and if we
    wanted to draw a line that was as close as possible to each dot, it wouldn't be
    too hard. A simple linear regression appears appropriate in this case.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这个数据集的分布似乎呈线性，如果我们想画一条尽可能靠近每个点的直线，这并不难。在这种情况下，简单的线性回归看起来是合适的。
- en: 'Our second set is the first 13 values scaled in the Fibonacci sequence that
    we saw earlier in the *Feature Scaling* section:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二组数据是前 13 个值，按照我们在*特征缩放*部分中看到的斐波那契数列进行缩放：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we plot this dataset with the values as the *y*-axis and the index of each
    value as the *x*-axis, we will get the following plot:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个数据集的值作为 *y* 轴，每个值的索引作为 *x* 轴，我们将得到如下图表：
- en: '![Figure 2.6: Plotted graph of the second dataset'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.6：第二个数据集的绘制图]'
- en: '](img/B16060_02_06.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_02_06.jpg)'
- en: 'Figure 2.6: Plotted graph of the second dataset'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6：第二个数据集的绘制图
- en: We can see that this dataset's distribution doesn't appear to be linear, and
    if we wanted to draw a line that was as close as possible to each dot, our line
    would miss quite a lot of dots. A simple linear regression will probably struggle
    in this situation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这个数据集的分布似乎不是线性的，如果我们想画一条尽可能靠近每个点的直线，线可能会错过很多点。在这种情况下，简单的线性回归可能会遇到困难。
- en: We know that the equation of a straight line is ![3](img/B16060_02_6a.png).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，直线的方程是![3](img/B16060_02_6a.png)。
- en: In this equation, ![4](img/B16060_02_6b.png) is the slope, and ![5](img/B16060_02_6c.png)
    is the *y* intercept. To find the line of best fit, we must find the coefficients
    of ![6](img/B16060_02_6b.png) and ![7](img/B16060_02_6c.png).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方程中，![4](img/B16060_02_6b.png) 是斜率，而![5](img/B16060_02_6c.png) 是 *y* 截距。为了找到最佳拟合线，我们必须找到![6](img/B16060_02_6b.png)
    和![7](img/B16060_02_6c.png) 的系数。
- en: 'In order to do this, we will use the least-squares method, which can be achieved
    by completing the following steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将使用最小二乘法，通过完成以下步骤来实现：
- en: For each data point, calculate *x*2 and *xy*.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个数据点，计算 *x*² 和 *xy*。
- en: Sum all of *x*, *y*, *x*2, and *x * y*, which gives us ![8](img/B16060_02_6f.png)
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 求所有 *x*、*y*、*x*² 和 *x * y* 的和，得出![8](img/B16060_02_6f.png)。
- en: Calculate the slope, ![9](img/B16060_02_6b.png), as ![10](img/B16060_02_6h.png)
    with *N* as the total number of data points.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算斜率，![9](img/B16060_02_6b.png)，作为 ![10](img/B16060_02_6h.png)，其中 *N* 是数据点的总数。
- en: Calculate the *y* intercept, ![11](img/B16060_02_6c.png), as ![12](img/B16060_02_6j.png).
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 *y* 截距，![11](img/B16060_02_6c.png)，作为 ![12](img/B16060_02_6j.png)。
- en: Now, let's apply these steps using NumPy as an example for the first dataset
    in the following code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们以 NumPy 为例，使用以下代码应用这些步骤来处理第一个数据集。
- en: 'Let''s take a look at the first step:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下第一步：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For `x_2`, the output will be this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `x_2`，输出将是：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For `xy`, the output will be this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `xy`，输出将是：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let''s move on to the next step:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一步：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For `sum_x`, the output will be this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `sum_x`，输出将是：
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For `sum_y`, the output will be this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `sum_y`，输出将是：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For `sum_x_2`, the output will be this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `sum_x_2`，输出将是：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For `sum_xy`, the output will be this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `sum_xy`，输出将是：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s move on to the next step:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一步：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For `N`, the output will be this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `N`，输出将是：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For `a`, the output will be this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `a`，输出将是：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let''s move on to the final step:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续到最后一步：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'For `b`, the output will be this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `b`，输出将是：
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once we plot the line ![13](img/B16060_02_6l.png) with the preceding coefficients,
    we get the following graph:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们用前述系数绘制出线 ![13](img/B16060_02_6l.png)，我们将得到以下图形：
- en: '![Figure 2.7: Plotted graph of the linear regression for the first dataset'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.7：第一数据集的线性回归绘制图'
- en: '](img/B16060_02_07.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_02_07.jpg)'
- en: 'Figure 2.7: Plotted graph of the linear regression for the first dataset'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7：第一数据集的线性回归绘制图
- en: As you can see, our linear regression model works quite well on this dataset,
    which has a linear distribution.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的线性回归模型在这个具有线性分布的数据集上表现得非常好。
- en: Note
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find a linear regression calculator at [http://www.endmemo.com/statistics/lr.php](http://www.endmemo.com/statistics/lr.php).
    You can also check the calculator to get an idea of what lines of best fit look
    like on a given dataset.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [http://www.endmemo.com/statistics/lr.php](http://www.endmemo.com/statistics/lr.php)
    找到线性回归计算器。你还可以查看该计算器，以了解在给定数据集上最优拟合线的形态。
- en: 'We will now repeat the exact same steps for the second dataset:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对第二数据集重复相同的步骤：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'For `a`, the output will be this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `a`，输出将是：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For `b`, the output will be this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `b`，输出将是：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Once we plot the line ![14](img/B16060_02_6l1.png) with the preceding coefficients,
    we get the following graph:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们用前述系数绘制出线 ![14](img/B16060_02_6l1.png)，我们将得到以下图形：
- en: '![Figure 2.8: Plotted graph of the linear regression for the second dataset'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.8：第二数据集的线性回归绘制图'
- en: '](img/B16060_02_08.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_02_08.jpg)'
- en: 'Figure 2.8: Plotted graph of the linear regression for the second dataset'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8：第二数据集的线性回归绘制图
- en: Clearly, with a nonlinear distribution, our linear regression model struggles
    to fit the data.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在线性分布下，我们的线性回归模型能够很好地拟合数据。
- en: Note
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We don't have to use this method to perform linear regression. Many libraries,
    including scikit-learn, will help us to automate this process. Once we perform
    linear regression with multiple variables, we are better off using a library to
    perform the regression for us.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必使用这种方法来进行线性回归。许多库，包括 scikit-learn，可以帮助我们自动化这一过程。一旦我们进行多个变量的线性回归，最好使用库来为我们执行回归。
- en: Fitting a Model Using NumPy Polyfit
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 NumPy Polyfit 拟合模型
- en: NumPy Polyfit can also be used to create a line of best fit for linear regression
    with one variable.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy Polyfit 还可以用于创建具有一个变量的最佳拟合线进行线性回归。
- en: 'Recall the calculation for the line of best fit:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 回忆一下最优拟合线的计算：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The equation for finding the coefficients ![15](img/B16060_02_6b.png) and ![16](img/B16060_02_6c.png)
    is quite long. Fortunately, `numpy.polyfit` in Python performs these calculations
    to find the coefficients of the line of best fit. The `polyfit` function accepts
    three arguments: the array of `x` values, the array of `y` values, and the degree
    of polynomial to look for. As we are looking for a straight line, the highest
    power of `x` is `1` in the polynomial:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 求解系数的方程式 ![15](img/B16060_02_6b.png) 和 ![16](img/B16060_02_6c.png) 相当复杂。幸运的是，Python
    中的 `numpy.polyfit` 函数可以执行这些计算，找出最优拟合线的系数。`polyfit` 函数接受三个参数：`x` 值的数组、`y` 值的数组，以及要查找的多项式的次数。由于我们要查找的是一条直线，因此多项式中
    `x` 的最高次方为 `1`：
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'For `[a,b]`, the output will be this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `[a,b]`，输出将是：
- en: '[PRE41]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Plotting the Results in Python
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Python 中绘制结果
- en: Suppose you have a set of data points and a regression line; our task is to
    plot the points and the line together so that we can see the results with our
    eyes.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一组数据点和一条回归线，我们的任务是将这些点和回归线一起绘制，以便我们能直观地看到结果。
- en: 'We will use the `matplotlib.pyplot` library for this. This library has two
    important functions:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `matplotlib.pyplot` 库来实现这一点。这个库有两个重要的函数：
- en: '`scatter`: This displays scattered points on the plane, defined by a list of
    *x* coordinates and a list of *y* coordinates.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scatter`：此函数显示在平面上分布的散点，由一组 *x* 坐标和一组 *y* 坐标定义。'
- en: '`plot`: Along with two arguments, this function plots a segment defined by
    two points or a sequence of segments defined by multiple points. A plot is like
    a scatter, except that instead of displaying the points, they are connected by
    lines.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plot`：此函数接受两个参数，绘制由两个点定义的线段或由多个点定义的一系列线段。与散点图类似，区别在于它不是显示单独的点，而是通过线条将它们连接起来。'
- en: A plot with three arguments plots a segment and/or two points formatted according
    to the third argument.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三个参数的绘图函数绘制一个线段和/或根据第三个参数格式化的两个点。
- en: 'A segment is defined by two points. As *x* ranges between 1 and 13 (remember
    the dataset contains 13 data points), it makes sense to display a segment between
    0 and 15\. We must substitute the value of *x* in the equation ![17](img/B16060_02_8c.png)
    to get the corresponding *y* values:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一条线段由两个点定义。当 *x* 在 1 和 13 之间变化时（请记住数据集包含 13 个数据点），在 0 和 15 之间显示一条线段是合理的。我们必须将
    *x* 的值代入方程式 ![17](img/B16060_02_8c.png) 以获得相应的 *y* 值：
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output is as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![Figure 2.9: Plotted graph of the linear regression for the first dataset
    using matplotlib'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.9：使用 matplotlib 绘制的第一个数据集线性回归图'
- en: '](img/B16060_02_09.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_02_09.jpg)'
- en: 'Figure 2.9: Plotted graph of the linear regression for the first dataset using
    matplotlib'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9：使用 matplotlib 绘制的第一个数据集线性回归图
- en: The regression line and the scattered data points are displayed as expected.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 回归线和散布的数据点如预期显示。
- en: 'However, the plot has an advanced signature. You can use `plot` to draw scattered
    dots, lines, and any curves on this figure. These variables are interpreted in
    groups of three:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，绘图函数有一个更复杂的签名。你可以使用 `plot` 在图形上绘制散点、线条或任何曲线。这些变量按三元组进行解析：
- en: '`x` values'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x` 值'
- en: '`y` values'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y` 值'
- en: Formatting options in the form of a string
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以字符串形式的格式化选项
- en: 'Let''s create a function for deriving an array of approximated `y` values from
    an array of approximated `x` values:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个函数，从一组近似的 `x` 值数组推导出一组近似的 `y` 值数组：
- en: '[PRE43]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We will use the `fit` function to plot the values:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `fit` 函数绘制这些值：
- en: '[PRE44]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Every third argument handles formatting. The letter `g` stands for green, while
    the letter `r` stands for red. You could have used `b` for blue and `y` for yellow,
    among other examples. In the absence of a color, each triple value will be displayed
    using a different color. The `o` character symbolizes that we want to display
    a dot where each data point lies. Therefore, `go` has nothing to do with movement
    – it requests the plotter to plot green dots. The `-` characters are responsible
    for displaying a dashed line. If you just use -1, a straight line appears instead
    of the dashed line.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 每个第三个参数处理格式化。字母 `g` 代表绿色，而字母 `r` 代表红色。你也可以使用 `b` 来表示蓝色，`y` 来表示黄色，等等。在没有指定颜色的情况下，每个三元组将以不同的颜色显示。`o`
    字符表示我们希望在每个数据点的位置显示一个点。因此，`go` 与移动无关——它请求绘图工具绘制绿色的点。`-` 字符负责绘制虚线。如果只使用 -1，将会显示一条直线而不是虚线。
- en: 'The output is as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![Figure 2.10: Graph for the plot function using the fit function'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.10：使用拟合函数的绘图函数图'
- en: '](img/B16060_02_10.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_02_10.jpg)'
- en: 'Figure 2.10: Graph for the plot function using the fit function'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10：使用拟合函数的绘图函数图
- en: The Python plotter library offers a simple solution for most of your graphing
    problems. You can draw as many lines, dots, and curves as you want on this graph.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的绘图库为你解决大多数图形问题提供了简单的解决方案。你可以在图形上绘制任意数量的线条、点和曲线。
- en: 'When displaying curves, the plotter connects the dots with segments. Also,
    bear in mind that even a complex sequence of curves is an approximation that connects
    the dots. For instance, if you execute the code from [https://gist.github.com/traeblain/1487795](https://gist.github.com/traeblain/1487795),
    you will recognize the segments of the `batman` function as connected lines:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示曲线时，绘图工具将点连接起来形成线段。还要记住，即使是复杂的曲线序列，也只是将点连接起来的近似值。例如，如果你执行来自 [https://gist.github.com/traeblain/1487795](https://gist.github.com/traeblain/1487795)
    的代码，你将看到 `batman` 函数的线段被连接成了直线：
- en: '![Figure 2.11: Graph for the batman function'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.11：蝙蝠侠函数的图表](img/B16060_02_11.jpg)'
- en: '](img/B16060_02_11.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_02_11.jpg)'
- en: 'Figure 2.11: Graph for the batman function'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11：蝙蝠侠函数的图表
- en: 'There is a large variety of ways to plot curves. We have seen that the `polyfit`
    method of the NumPy library returns an array of coefficients to describe a linear equation:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的方法可以绘制曲线。我们已经看到，NumPy 库的 `polyfit` 方法返回一个系数数组来描述线性方程：
- en: '[PRE45]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here the output is as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的输出如下：
- en: '[PRE46]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This array describes the equation *4.85714286 * x - 2.76923077*.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组描述了方程 *4.85714286 * x - 2.76923077*。
- en: 'Suppose we now want to plot a curve, ![18](img/B16060_02_11a.png). This quadratic
    equation is described by the coefficient array `[-1, 3, -2]` as ![19](img/B16060_02_11b.png).
    We could write our own function to calculate the `y` values belonging to `x` values.
    However, the NumPy library already has a feature that can do this work for us
    – `np.poly1d`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们现在想绘制一条曲线，![18](img/B16060_02_11a.png)。这个二次方程由系数数组 `[-1, 3, -2]` 描述，如![19](img/B16060_02_11b.png)。我们可以自己编写一个函数来计算属于
    `x` 值的 `y` 值。然而，NumPy 库已经有一个功能可以为我们完成这项工作——`np.poly1d`：
- en: '[PRE47]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `f` function that''s created by the `poly1d` call not only works with single
    values but also with lists or NumPy arrays:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`poly1d` 调用创建的 `f` 函数不仅适用于单一值，还适用于列表或 NumPy 数组：'
- en: '[PRE48]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The expected output is this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '[PRE49]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Similarly, for `f(x)`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于 `f(x)`：
- en: '[PRE50]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output will be:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是：
- en: '[PRE51]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can now use these values to plot a nonlinear curve:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这些值来绘制非线性曲线：
- en: '[PRE52]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output is as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 2.12: Graph for a nonlinear curve'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.12：非线性曲线的图表](img/B16060_02_12.jpg)'
- en: '](img/B16060_02_12.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_02_12.jpg)'
- en: 'Figure 2.12: Graph for a nonlinear curve'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12：非线性曲线的图表
- en: As you can see, we can use the `pyplot` library to easily create the plot of
    a nonlinear curve.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们可以使用 `pyplot` 库轻松创建非线性曲线的图表。
- en: Predicting Values with Linear Regression
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用线性回归预测值
- en: 'Suppose we are interested in the `y` value belonging to the `x` coordinate
    `20`. Based on the linear regression model, all we need to do is substitute the
    value of `20` in the place of `x` on the previously used code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们对属于 `x` 坐标 `20` 的 `y` 值感兴趣。根据线性回归模型，我们需要做的就是将 `20` 的值代入之前使用的代码中的 `x`：
- en: '[PRE53]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The output is as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 2.13: Graph showing the predicted value using linear regression'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.13：显示使用线性回归预测值的图表](img/B16060_02_14.jpg)'
- en: '](img/B16060_02_13.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_02_13.jpg)'
- en: 'Figure 2.13: Graph showing the predicted value using linear regression'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13：显示使用线性回归预测值的图表
- en: Here, we denoted the predicted value with red. This red point is on the best
    line of fit.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们用红色表示了预测值。这个红点位于最优拟合直线的上方。
- en: Let's look at next exercise where we will be predicting populations based on
    linear regression.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下一个练习，在这个练习中，我们将根据线性回归预测人口。
- en: 'Exercise 2.01: Predicting the Student Capacity of an Elementary School'
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.01：预测小学的学生容量
- en: In this exercise, you will be trying to forecast the need for elementary school
    capacity. Your task is to figure out 2025 and 2030 predictions for the number
    of children starting elementary school.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将尝试预测小学容量的需求。你的任务是预测 2025 年和 2030 年入学儿童的数量。
- en: Note
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The data is contained inside the `population.csv` file, which you can find
    on our GitHub repository: [https://packt.live/2YYlPoj](https://packt.live/2YYlPoj).'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包含在 `population.csv` 文件中，你可以在我们的 GitHub 仓库中找到它：[https://packt.live/2YYlPoj](https://packt.live/2YYlPoj)。
- en: 'The following steps will help you to complete this exercise:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成此练习：
- en: Open a new Jupyter Notebook file.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Jupyter Notebook 文件。
- en: 'Import `pandas` and `numpy`:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `pandas` 和 `numpy`：
- en: '[PRE54]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, load the CSV file as a DataFrame on the Notebook and read the CSV file:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将 CSV 文件作为 DataFrame 加载到 Notebook 中并读取 CSV 文件：
- en: '[PRE55]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The expected output is this:'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 2.14: Reading the CSV file'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.14：读取 CSV 文件](img/B16060_02_14.jpg)'
- en: '](img/B16060_02_14.jpg)'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_02_14.jpg)'
- en: 'Figure 2.14: Reading the CSV file'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.14：读取 CSV 文件
- en: 'Now, convert the DataFrame into two NumPy arrays. For simplicity, we can indicate
    that the `year` feature, which is from `2001` to `2018`, is the same as `1` to `18`:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 DataFrame 转换为两个 NumPy 数组。为了简便起见，我们可以假设 `year` 特征从 `2001` 到 `2018`，对应的值为
    `1` 到 `18`：
- en: '[PRE56]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `x` output will be:'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`x` 的输出将是：'
- en: '[PRE57]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `y` output will be:'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`y` 输出将是：'
- en: '[PRE58]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, with the two NumPy arrays, use the `polyfit` method (with a degree of
    `1` as we only have one feature) to determine the coefficients of the regression
    line:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用两个 NumPy 数组，使用 `polyfit` 方法（由于我们只有一个特征，设置多项式的次数为 `1`）来确定回归线的系数：
- en: '[PRE59]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The output for `[a, b]` will be:'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`[a, b]` 的输出将是：'
- en: '[PRE60]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, plot the results using `matplotlib.pyplot` and predict the future until `2030`:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 `matplotlib.pyplot` 绘制结果，并预测未来至 `2030` 年：
- en: '[PRE61]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The expected output is this:'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出是：
- en: '![Figure 2.15: Plot showing the future for 2030'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.15：显示 2030 年未来情况的图'
- en: '](img/B16060_02_15.jpg)'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_02_15.jpg)'
- en: 'Figure 2.15: Plot showing the future for 2030'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.15：显示 2030 年未来情况的图
- en: As you can see, the data appears linear and our model seems to be a good fit.
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，数据呈线性关系，我们的模型似乎拟合得很好。
- en: 'Finally, predict the population for `2025` and `2030`:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，预测 `2025` 年和 `2030` 年的人口：
- en: '[PRE62]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The output for `population_2025` will be:'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`population_2025` 的输出将是：'
- en: '[PRE63]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The output for `population_2030` will be:'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`population_2030` 的输出将是：'
- en: '[PRE64]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/31dvuKt](https://packt.live/31dvuKt).
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考[https://packt.live/31dvuKt](https://packt.live/31dvuKt)。
- en: You can also run this example online at [https://packt.live/317qeIc](https://packt.live/317qeIc).
    You must execute the entire Notebook in order to get the desired result.
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以在线运行此示例，网址为[https://packt.live/317qeIc](https://packt.live/317qeIc)。你必须执行整个
    Notebook 才能得到期望的结果。
- en: By completing this exercise, we can now conclude that the population of children
    starting elementary school is going to decrease in the future and that there is
    no need to increase the elementary school capacity if we are currently meeting
    the needs.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，我们现在可以得出结论：未来开始上小学的儿童人口将减少，因此，如果我们当前已经满足需求，就不需要增加小学的容量。
- en: Linear Regression with Multiple Variables
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多元线性回归
- en: In the previous section, we dealt with linear regression with one variable.
    Now we will learn an extended version of linear regression, where we will use
    multiple input variables to predict the output.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们处理了一个变量的线性回归。现在我们将学习线性回归的扩展版本，在该版本中，我们将使用多个输入变量来预测输出。
- en: Multiple Linear Regression
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多元线性回归
- en: If you recall the formula for the line of best fit in linear regression, it
    was defined as ![20](img/B16060_02_15a.png), where ![21](img/B16060_02_6b.png)
    is the slope of the line, ![22](img/B16060_02_6c.png) is the *y* intercept of
    the line, *x* is the feature value, and *y* is the calculated label value.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回想一下线性回归中最佳拟合线的公式，它被定义为 ![20](img/B16060_02_15a.png)，其中 ![21](img/B16060_02_6b.png)
    是线的斜率，![22](img/B16060_02_6c.png) 是线的 *y* 截距，*x* 是特征值，*y* 是计算出的标签值。
- en: In multiple regression, we have multiple features and one label. If we have
    three features, *x*1, *x*2, and *x*3, our model changes to ![23](img/B16060_02_15d.png).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在多元回归中，我们有多个特征和一个标签。如果我们有三个特征，*x*1、*x*2 和 *x*3，我们的模型将变成 ![23](img/B16060_02_15d.png)。
- en: 'In NumPy array format, we can write this equation as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NumPy 数组格式中，我们可以将这个方程写成如下形式：
- en: '[PRE65]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'For convenience, it makes sense to define the whole equation in a vector multiplication
    format. The coefficient of ![24](img/B16060_02_6c.png) is going to be `1`:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，最好将整个方程定义为向量乘法形式。系数 ![24](img/B16060_02_6c.png) 将是 `1`：
- en: '[PRE66]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Multiple linear regression is a simple scalar product of two vectors, where
    the coefficients ![25](img/B16060_02_6c.png), ![26](img/B16060_02_15g.png), ![27](img/B16060_02_15h.png),
    and ![28](img/B16060_02_15i.png) determine the best fit equation in a four-dimensional space.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 多元线性回归是两个向量的简单标量积，其中系数 ![25](img/B16060_02_6c.png)、![26](img/B16060_02_15g.png)、![27](img/B16060_02_15h.png)
    和 ![28](img/B16060_02_15i.png) 决定了四维空间中最优拟合方程。
- en: 'To understand the formula of multiple linear regression, you will need the
    scalar product of two vectors. As the other name for a scalar product is a dot
    product, the NumPy function performing this operation is called `dot`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解多元线性回归的公式，你需要计算两个向量的标量积。由于标量积的另一个名称是点积，因此执行此操作的 NumPy 函数称为 `dot`：
- en: '[PRE67]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The output will be `32` as `np.dot(v1, v2)= 1 * 4 + 2 * 5 + 3 * 6 = 32`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是 `32`，因为 `np.dot(v1, v2) = 1 * 4 + 2 * 5 + 3 * 6 = 32`。
- en: We simply sum the product of each respective coordinate.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅需将每个坐标的乘积相加。
- en: We can determine these coefficients by minimizing the error between the data
    points and the nearest points described by the equation. For simplicity, we will
    omit the mathematical solution of the best-fit equation and use scikit-learn instead.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过最小化数据点与由方程描述的最接近点之间的误差来确定这些系数。为了简单起见，我们将省略最佳拟合方程的数学解法，而改用scikit-learn。
- en: Note
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In *n*-dimensional spaces, where *n* is greater than 3, the number of dimensions
    determines the different variables that are in our model. In the preceding example,
    we have three features (*x*1, *x*2, and *x*3) and one label, *y*. This yields
    four dimensions. If you want to imagine a four-dimensional space, you can imagine
    a three-dimensional space with a fourth dimension of time. A five-dimensional
    space can be imagined as a four-dimensional space, where each point in time has
    a temperature. Dimensions are just features (and labels); they do not necessarily
    correlate with our concept of three-dimensional space.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在*n*维空间中，其中*n*大于3，维度的数量决定了我们模型中不同的变量。在前面的例子中，我们有三个特征（*x*1、*x*2和*x*3）和一个标签*y*。这就得到了四个维度。如果你想象四维空间，你可以将其视为一个有时间维度的三维空间。五维空间可以想象成四维空间，其中每个时间点都有一个温度。维度只是特征（和标签）；它们不一定与我们对三维空间的概念相关。
- en: The Process of Linear Regression
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性回归的过程
- en: 'We will follow the following simple steps to solve linear regression problems:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下简单步骤解决线性回归问题：
- en: Load data from the data sources.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据源加载数据。
- en: Prepare data for prediction. Data is prepared in this (`normalize`, `format`,
    and `filter`) format.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备预测数据。数据以（`normalize`、`format`和`filter`）格式准备。
- en: Compute the parameters of the regression line. Regardless of whether we use
    linear regression with one variable or with multiple variables, we will follow
    these steps.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算回归线的参数。无论我们使用单变量还是多变量线性回归，都将遵循以下步骤。
- en: Importing Data from Data Sources
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从数据源导入数据
- en: 'There are multiple libraries that can provide us with access to data sources.
    As we will be working with stock data, let''s cover two examples that are geared
    toward retrieving financial data: Quandl and Yahoo Finance. Take a look at these
    important points before moving ahead:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个库可以为我们提供数据源访问。由于我们将处理股票数据，让我们先看两个专门用于获取财务数据的例子：Quandl和Yahoo Finance。在继续之前，请先查看以下几个重要点：
- en: Scikit-learn comes with a few datasets that can be used for practicing your
    skills.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scikit-learn提供了一些数据集，可以用于练习你的技能。
- en: '[https://www.quandl.com](https://www.quandl.com) provides you with free and
    paid financial datasets.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.quandl.com](https://www.quandl.com)为你提供免费的和付费的财务数据集。'
- en: '[https://pandas.pydata.org/](https://pandas.pydata.org/) helps you load any
    CSV, Excel, JSON, or SQL data.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://pandas.pydata.org/](https://pandas.pydata.org/)帮助你加载任何CSV、Excel、JSON或SQL数据。'
- en: Yahoo Finance provides you with financial datasets.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yahoo Finance为你提供财务数据集。
- en: Loading Stock Prices with Yahoo Finance
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Yahoo Finance加载股票价格
- en: 'The process of loading stock data with Yahoo Finance is straightforward. All
    you need to do is install the `yfinance` package using the following command in
    Jupyter Notebook:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Yahoo Finance加载股票数据的过程非常简单。你只需在Jupyter Notebook中使用以下命令安装`yfinance`包：
- en: '[PRE68]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We will download a dataset that has an open price, high price, low price, close
    price, adjusted close price, and volume values of the S&P 500 index starting from
    2015 to January 1, 2020\. The S&P 500 index is the stock market index that measures
    the stock performance of 500 large companies listed in the United States:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将下载一个数据集，其中包含从2015年到2020年1月1日的标准普尔500指数的开盘价、最高价、最低价、收盘价、调整后收盘价和成交量值。标准普尔500指数是衡量美国500家大型上市公司股票表现的股市指数：
- en: '[PRE69]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Note
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The dataset file can also be found in our GitHub repository: [https://packt.live/3fRI5Hk](https://packt.live/3fRI5Hk).'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集文件也可以在我们的GitHub仓库找到：[https://packt.live/3fRI5Hk](https://packt.live/3fRI5Hk)。
- en: 'The original dataset can be found here: [https://github.com/ranaroussi/yfinance](https://github.com/ranaroussi/yfinance).'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据集可以在这里找到：[https://github.com/ranaroussi/yfinance](https://github.com/ranaroussi/yfinance)。
- en: That's all you need to do. The DataFrame containing the S&P 500 index is ready.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要做的。包含标准普尔500指数的数据框已经准备好了。
- en: 'You can plot the index closing prices using the `plot` method:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`plot`方法绘制指数收盘价：
- en: '[PRE70]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The output is as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 2.16: Graph showing the S&P 500 index closing price since 2015'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.16：显示自 2015 年以来 S&P 500 指数收盘价的图表'
- en: '](img/B16060_02_16.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_02_16.jpg)'
- en: 'Figure 2.16: Graph showing the S&P 500 index closing price since 2015'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16：显示自 2015 年以来 S&P 500 指数收盘价的图表
- en: The data does not appear to be linear; a polynomial regression might be a better
    model for this dataset.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 数据似乎不是线性的；多项式回归可能是该数据集更合适的模型。
- en: 'It is also possible to save data to a CSV file using the following code:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用以下代码将数据保存为 CSV 文件：
- en: '[PRE71]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '[https://www.quandl.com](https://www.quandl.com) is a reliable source of financial
    and economic datasets that we will be using in this chapter.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.quandl.com](https://www.quandl.com) 是我们在本章中将使用的可靠的金融和经济数据集来源。'
- en: 'Exercise 2.02: Using Quandl to Load Stock Prices'
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.02：使用 Quandl 加载股票价格
- en: The goal of this exercise is to download data from the Quandl package and load
    it into a DataFrame like we previously did with Yahoo Finance.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目标是从 Quandl 包下载数据，并将其加载到一个 DataFrame 中，类似于我们之前在 Yahoo Finance 上所做的操作。
- en: 'The following steps will help you to complete the exercise:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成练习：
- en: Open a new Jupyter Notebook file.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Jupyter Notebook 文件。
- en: 'Install `Quandl` using the following command:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装 `Quandl`：
- en: '[PRE72]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Download the data into a DataFrame using Quandl for the S&P 500\. Its ticker
    is `“YALE/SPCOMP”`:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Quandl 下载 S&P 500 的数据到 DataFrame 中。其代码为 `“YALE/SPCOMP”`：
- en: '[PRE73]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Use the DataFrame `head()` method to inspect the first five rows of data in
    your DataFrame:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 DataFrame 的 `head()` 方法检查 DataFrame 中前五行数据：
- en: '[PRE74]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The output is as follows:'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 2.17: Dataset displayed as the output'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.17：数据集作为输出显示'
- en: '](img/B16060_02_17.jpg)'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_02_17.jpg)'
- en: 'Figure 2.17: Dataset displayed as the output'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17：数据集作为输出显示
- en: Note
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3dwDUz6](https://packt.live/3dwDUz6).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的源代码，请参考 [https://packt.live/3dwDUz6](https://packt.live/3dwDUz6)。
- en: You can also run this example online at [https://packt.live/31812B6](https://packt.live/31812B6).
    You must execute the entire Notebook in order to get the desired result.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过 [https://packt.live/31812B6](https://packt.live/31812B6) 在线运行此示例。您必须执行整个
    Notebook 才能获得预期的结果。
- en: By completing this exercise, we have learned how to download an external dataset
    in `CSV` format and import it as a DataFrame. We also learned about the `.head()`
    method, which provides a quick view of the first five rows of your DataFrame.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本练习后，我们学会了如何下载外部数据集（CSV 格式）并将其导入为 DataFrame。我们还学习了 `.head()` 方法，它可以快速查看 DataFrame
    中的前五行数据。
- en: In the next section, we will be moving on to prepare the dataset to perform
    multiple linear regression.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将继续准备数据集以执行多元线性回归。
- en: Preparing Data for Prediction
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为预测准备数据
- en: Before we perform multiple linear regression on our dataset, we must choose
    the relevant features and the data range on which we will perform the regression.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在对数据集执行多元线性回归之前，我们必须选择相关的特征和回归所用的数据范围。
- en: Preparing the data for prediction is the second step in the regression process.
    This step also has several sub-steps. We will go through these sub-steps in the
    following exercise.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 准备数据以进行预测是回归过程中的第二步。此步骤还包含几个子步骤。我们将在接下来的练习中逐步讲解这些子步骤。
- en: 'Exercise 2.03: Preparing the Quandl Data for Prediction'
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.03：为预测准备 Quandl 数据
- en: The goal of this exercise is to download an external dataset from the Quandl
    library and then prepare it so that it is ready for use in our linear regression
    models.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目标是从 Quandl 库下载外部数据集，并将其准备好以便在我们的线性回归模型中使用。
- en: 'The following steps will help you to complete this exercise:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成本练习：
- en: Open a new Jupyter Notebook file.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Jupyter Notebook 文件。
- en: Note
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: If the Qaundl library is not installed on your system, remember to run the command
    `!pip install quandl`.
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您的系统未安装 Quandl 库，请记得运行命令 `!pip install quandl`。
- en: 'Next, download the data into a DataFrame using Quandl for the S&P 500 between
    1950 and 2019\. Its ticker is `“YALE/SPCOMP”`:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用 Quandl 下载 S&P 500 从 1950 年到 2019 年的数据到 DataFrame 中。其代码为 `“YALE/SPCOMP”`：
- en: '[PRE75]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Use the `head()` method to visualize the columns inside the `data_frame.head()`
    DataFrame:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `head()` 方法来查看 `data_frame.head()` DataFrame 中的列：
- en: '[PRE76]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The output is as follows:'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 2.18: Dataset displayed as the output'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.18：数据集作为输出显示'
- en: '](img/B16060_02_18.jpg)'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_02_18.jpg)'
- en: 'Figure 2.18: Dataset displayed as the output'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.18：数据集作为输出显示
- en: A few features seem to highly correlate with each other. For instance, the `Real
    Dividend` column grows proportionally with `Real Price`. The ratio between them
    is not always similar, but they do correlate.
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有些特征似乎高度相关。例如，`Real Dividend`列与`Real Price`按比例增长。它们之间的比率并不总是相似，但它们确实存在相关性。
- en: As regression is not about detecting the correlation between features, we would
    rather get rid of the features that we know are correlated and perform regression
    on the features that are non-correlated. In this case, we will keep the `Long
    Interest Rate`, `Real Price`, and `Real Dividend` columns.
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于回归并不是为了检测特征之间的相关性，我们宁愿去除那些我们知道是相关的特征，并对那些没有相关性的特征进行回归。在这种情况下，我们将保留`Long Interest
    Rate`、`Real Price`和`Real Dividend`列。
- en: 'Keep only the relevant columns in the `Long Interest Rate`, `Real Price`, and
    `Real Dividend` DataFrames:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅保留`Long Interest Rate`、`Real Price`和`Real Dividend`数据框中相关的列：
- en: '[PRE77]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The output is as follows:'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Figure 2.19: Dataset showing only the relevant columns'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.19：仅显示相关列的数据集'
- en: '](img/B16060_02_19.jpg)'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_02_19.jpg)'
- en: 'Figure 2.19: Dataset showing only the relevant columns'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.19：仅显示相关列的数据集
- en: You can see that the DataFrame contains a few missing values `NaN`. As regression
    doesn't work with missing values, we need to either replace them or delete them.
    In the real world, we will usually choose to replace them. In this case, we will
    replace the missing values by the preceding values using a method called **forward
    filling**.
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以看到数据框中有一些缺失值`NaN`。由于回归无法处理缺失值，我们需要将它们替换或删除。在实际情况中，我们通常选择替换它们。在这种情况下，我们将使用一种叫做**前向填充**的方法，用前一个值来替换缺失值。
- en: 'We can replace the missing values with a forward filling as shown in the following
    code snippet:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码片段通过前向填充来替换缺失值：
- en: '[PRE78]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The output is as follows:'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Figure 2.20: Missing values have been replaced'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.20：缺失值已被替换'
- en: '](img/B16060_02_20.jpg)'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_02_20.jpg)'
- en: 'Figure 2.20: Missing values have been replaced'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.20：缺失值已被替换
- en: Now that we have cleaned the missing data, we need to create our label. We want
    to predict the `Real Price` column 3 months in advance using the current `Real
    Price`, `Long Interest Rate`, and `Real Dividend` columns. In order to create
    our label, we need to shift the `Real Price` values up by three units and call
    it `Real Price Label`.
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经清理了缺失数据，需要创建我们的标签。我们希望使用当前的`Real Price`、`Long Interest Rate`和`Real Dividend`列预测`Real
    Price`列的未来3个月数据。为了创建标签，我们需要将`Real Price`的值向上移动三个单位，并将其命名为`Real Price Label`。
- en: 'Create the `Real Price Label` label by shifting `Real Price` by 3 months as
    shown in the following code:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码通过将`Real Price`移位3个月来创建`Real Price Label`标签：
- en: '[PRE79]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The output is as follows:'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Figure 2.21: New labels have been created'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.21：新标签已创建'
- en: '](img/B16060_02_21.jpg)'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_02_21.jpg)'
- en: 'Figure 2.21: New labels have been created'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.21：新标签已创建
- en: The side effect of shifting these values is that missing values will appear
    in the last three rows for `Real Price Label`, so we need to remove the last three
    rows of data. However, before that, we need to convert the features into a NumPy
    array and scale it. We can use the `drop` method of the DataFrame to remove the
    label column and the preprocessing function from `sklearn` to scale the features.
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将这些值移位的副作用是，`Real Price Label`的最后三行将出现缺失值，因此我们需要移除最后三行数据。然而，在此之前，我们需要将特征转换为NumPy数组并进行缩放。我们可以使用数据框的`drop`方法删除标签列，并使用`sklearn`中的预处理函数来缩放特征。
- en: 'Create a NumPy array for the features and scale it in the following code:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码创建一个NumPy数组来表示特征并进行缩放：
- en: '[PRE80]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The output is as follows:'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE81]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `1` in the second argument specifies that we are dropping columns. As the
    original DataFrame was not modified, the label can be directly extracted from
    it. Now that the features are scaled, we need to remove the last three values
    of the features as they are the features of the missing values in the label column.
    We will save them for later in the prediction part.
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二个参数中的`1`指定我们要删除列。由于原始数据框未被修改，因此可以直接从中提取标签。现在，特征已经被缩放，我们需要删除特征中的最后三个值，因为它们是标签列中缺失值的特征。我们将它们保存以供稍后在预测部分使用。
- en: 'Remove the last three values of the `features` array and save them into another
    array using the following code:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码移除`features`数组中的最后三个值，并将它们保存到另一个数组中：
- en: '[PRE82]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The output for `scaled_features` is as follows:'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`scaled_features`的输出如下所示：'
- en: '[PRE83]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `scaled_features` variable doesn't contain the three data points anymore
    as they are now in `scaled_features_latest_3`. Now we can remove the last three
    rows with missing data from the DataFrame, then convert the label into a NumPy
    array using `sklearn`.
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`scaled_features`变量不再包含三个数据点，因为它们现在位于`scaled_features_latest_3`中。现在我们可以从DataFrame中删除最后三行缺失数据，然后使用`sklearn`将标签转换为NumPy数组。'
- en: 'Remove the rows with missing data in the following code:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中删除缺失数据的行：
- en: '[PRE84]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The output for `data_frame` is as follows:'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`data_frame`的输出如下：'
- en: '![Figure 2.22: Dataset updated with the removal of missing values'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.22：更新后的数据集，删除了缺失值'
- en: '](img/B16060_02_22.jpg)'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_02_22.jpg)'
- en: 'Figure 2.22: Dataset updated with the removal of missing values'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.22：更新后的数据集，删除了缺失值
- en: As you can see, the last three rows were also removed from the DataFrame.
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如您所见，DataFrame中的最后三行也被删除了。
- en: 'Now let''s see if we have accurately created our label. Go ahead and run the
    following code:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们看看我们是否准确地创建了我们的标签。继续运行以下代码：
- en: '[PRE85]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The output for the `label` is as follows:'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`label`的输出如下：'
- en: '![Figure 2.23: Output showing the expected labels'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.23：显示预期标签的输出'
- en: '](img/B16060_02_23.jpg)'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_02_23.jpg)'
- en: 'Figure 2.23: Output showing the expected labels'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.23：显示预期标签的输出
- en: Our variable contains all the labels and is exactly the same as the `Real Price
    Label` column in the DataFrame.
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的变量包含所有标签，与DataFrame中的`Real Price Label`列完全相同。
- en: Our next task is to separate the training and testing data from each other.
    As we saw in the *Splitting Data into Training and Testing* section, we will use
    90% of the data as the training data and the remaining 10% as the test data.
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的下一个任务是将训练数据和测试数据分开。正如我们在*将数据分割为训练和测试*部分中看到的，我们将使用数据的90%作为训练数据，剩下的10%作为测试数据。
- en: 'Split the `features` data into training and test sets using `sklearn` with
    the following code:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sklearn`中的以下代码将`features`数据分为训练集和测试集：
- en: '[PRE86]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `train_test_split` function shuffles the lines of our data, keeps the correspondence,
    and puts approximately 10% of all data in the test variables, keeping 90% for
    the training variables. We also use `random_state=8` in order to reproduce the
    results. Our data is now ready to be used for the multiple linear regression model.
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`train_test_split`函数对我们数据的行进行了洗牌，保持了对应关系，并将约10%的所有数据放入测试变量中，保留了90%用于训练变量。我们还使用`random_state=8`来复制结果。我们的数据现在可以用于多元线性回归模型。'
- en: Note
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2zZssOG](https://packt.live/2zZssOG).
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2zZssOG](https://packt.live/2zZssOG)。
- en: You can also run this example online at [https://packt.live/2zW8WCH](https://packt.live/2zW8WCH).
    You must execute the entire Notebook in order to get the desired result.
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/2zW8WCH](https://packt.live/2zW8WCH)上在线运行此示例。必须执行整个Notebook才能获得所需的结果。
- en: By completing this exercise, we have learned all the required steps for data
    preparation before performing a regression.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成此练习，我们已经学会了在执行回归之前进行数据准备的所有必要步骤。
- en: Performing and Validating Linear Regression
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行和验证线性回归
- en: Now that our data has been prepared, we can perform our linear regression. After
    that, we will measure our model performance and see how well it performs.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的数据已准备好，我们可以执行线性回归。之后，我们将测量我们的模型性能，看看它的表现如何。
- en: 'We can now create the linear regression model based on the training data:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以基于训练数据创建线性回归模型：
- en: '[PRE87]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Once the model is ready, we can use it to predict the labels belonging to the
    test feature values and use the `score` method from the model to see how accurate
    it is:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模型准备好，我们可以使用它来预测属于测试特征值的标签，并使用模型的`score`方法查看其准确性：
- en: '[PRE88]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The output is as follows:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE89]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: With a score or R2 of `0.985`, we can conclude that the model is very accurate.
    This is not a surprise since the financial market grows at around 6-7% a year.
    This is linear growth, and the model essentially predicts that the markets will
    continue growing at a linear rate. Concluding that markets tend to increase in
    the long run is not rocket science.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 通过得分或R2为`0.985`，我们可以得出结论，该模型非常准确。这并不令人意外，因为金融市场的增长约为每年6-7%。这是线性增长，模型基本上预测市场将以线性速度继续增长。得出市场
    tend to increase in the long run 的结论并不是火箭科学。
- en: Predicting the Future
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预测未来
- en: 'Now that our model has been trained, we can use it to predict future values.
    We will use the `scaled_features_latest_3` variable that we created by taking
    the last three values of the features NumPy array and using it to predict the
    index price of the next three months in the following code:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的模型已经训练完成，我们可以用它来预测未来的值。我们将使用`scaled_features_latest_3`变量，它是通过取特征NumPy数组中的最后三个值来创建的，并使用它来预测接下来三个月的指数价格，代码如下：
- en: '[PRE90]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The output is as follows:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE91]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: By looking at the output, you might think it seems easy to forecast the value
    of the S&P 500 and use it to earn money by investing in it. Unfortunately, in
    practice, using this model for making money by betting on the forecast is by no
    means better than gambling in a casino. This is just an example to illustrate
    prediction; it is not enough to be used for short-term or long-term speculation
    on market prices. In addition to this, stock prices are sensitive to many external
    factors, such as economic recession and government policy. This means that past
    patterns do not necessarily reflect any patterns in the future.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察输出，你可能会觉得预测标普500指数的值似乎很容易，并用它来通过投资赚钱。不幸的是，在实践中，使用这个模型来通过预测赚钱并不比在赌场赌博更好。这只是一个用来说明预测的例子，并不足以用于市场价格的短期或长期投机。除此之外，股价对许多外部因素敏感，如经济衰退和政府政策。这意味着过去的模式不一定能反映未来的模式。
- en: Polynomial and Support Vector Regression
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多项式与支持向量回归
- en: When performing a polynomial regression, the relationship between *x* and *y*,
    or using their other names, features, and labels, is not a linear equation, but
    a polynomial equation. This means that instead of the ![29](img/B16060_02_6l.png)
    equation, we can have multiple coefficients and multiple powers of *x* in the
    equation.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行多项式回归时，*x*与*y*之间的关系，或者使用它们的其他名称，特征和标签，并不是线性方程，而是多项式方程。这意味着我们可以在方程中使用多个系数和多个*x*的幂，而不是![29](img/B16060_02_6l.png)方程。
- en: To make matters even more complicated, we can perform polynomial regression
    using multiple variables, where each feature may have coefficients multiplying
    different powers of the feature.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的是，我们可以使用多个变量进行多项式回归，其中每个特征可能有不同的系数，分别乘以特征的不同幂。
- en: Our task is to find a curve that best fits our dataset. Once polynomial regression
    is extended to multiple variables, we will learn the SVM model to perform polynomial regression.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是找到一条最能拟合我们数据集的曲线。一旦将多项式回归扩展到多个变量，我们将学习支持向量机（SVM）模型来执行多项式回归。
- en: Polynomial Regression with One Variable
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一维多项式回归
- en: 'As a recap, we have performed two types of regression so far:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，到目前为止我们已经执行了两种回归：
- en: 'Simple linear regression: ![30](img/B16060_02_6l.png)'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单线性回归：![30](img/B16060_02_6l.png)
- en: 'Multiple linear regression: ![31](img/B16060_02_23c_New.png)'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多元线性回归：![31](img/B16060_02_23c_New.png)
- en: We will now learn how to do polynomial linear regression with one variable.
    The equation for polynomial linear regression is ![33](img/B16060_02_23d.png).
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将学习如何进行一维多项式线性回归。多项式线性回归的方程是![33](img/B16060_02_23d.png)。
- en: Polynomial linear regression has a vector of coefficients, ![34](img/B16060_02_23e.png),
    multiplying a vector of degrees of *x* in the polynomial, ![35](img/B16060_02_23f.png).
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式线性回归具有一个系数向量![34](img/B16060_02_23e.png)，乘以一个多项式中*x*的幂次向量![35](img/B16060_02_23f.png)。
- en: At times, polynomial regression works better than linear regression. If the
    relationship between labels and features can be described using a linear equation,
    then using a linear equation makes perfect sense. If we have a nonlinear growth,
    polynomial regression tends to approximate the relationship between features and
    labels better.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，多项式回归比线性回归效果更好。如果标签与特征之间的关系可以用线性方程描述，那么使用线性方程是非常合适的。如果我们有非线性增长的情况，多项式回归往往能更好地逼近特征与标签之间的关系。
- en: The simplest implementation of linear regression with one variable was the `polyfit`
    method of the NumPy library. In the next exercise, we will perform multiple polynomial
    linear regression with degrees of 2 and 3.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的一维线性回归实现是NumPy库中的`polyfit`方法。在接下来的练习中，我们将执行二次和三次的多项式线性回归。
- en: Note
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Even though our polynomial regression has an equation containing coefficients
    of *x*n, this equation is still referred to as polynomial linear regression in
    literature. Regression is made linear not because we restrict the usage of higher
    powers of *x* in the equation, but because the coefficients *a*1,*a*2 … and so
    on are linear in the equation. This means that we use the toolset of linear algebra
    and work with matrices and vectors to find the missing coefficients that minimize
    the error of the approximation.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的多项式回归方程包含*x*的高阶系数，文献中仍将此方程称为多项式线性回归。回归之所以是线性的，并不是因为我们限制了方程中*x*的更高次幂的使用，而是因为方程中的系数*a*1、*a*2等是线性的。这意味着我们使用线性代数的工具集，通过矩阵和向量来找到最小化逼近误差的缺失系数。
- en: 'Exercise 2.04: First-, Second-, and Third-Degree Polynomial Regression'
  id: totrans-498
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.04：一次、二次和三次多项式回归
- en: The goal of this exercise is to perform first-, second-, and third-degree polynomial
    regression on the two sample datasets that we used earlier in this chapter. The
    first dataset has a linear distribution and the second one is the Fibonacci sequence
    and has a nonlinear distribution.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的目标是在本章早些时候使用的两个样本数据集上执行一次、二次和三次多项式回归。第一个数据集具有线性分布，第二个是斐波那契序列，具有非线性分布。
- en: 'The following steps will help you to complete the exercise:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: Open a new Jupyter Notebook file.
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Jupyter Notebook文件。
- en: 'Import the `numpy` and `matplotlib` packages:'
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`numpy`和`matplotlib`包：
- en: '[PRE92]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Define the first dataset:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义第一个数据集：
- en: '[PRE93]'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Define the second dataset:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义第二个数据集：
- en: '[PRE94]'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Perform a polynomial regression of degrees `1`, `2`, and `3` on the first dataset
    using the `polyfit` method from `numpy` in the following code:'
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码在第一个数据集上进行一次、二次和三次多项式回归，使用`numpy`中的`polyfit`方法：
- en: '[PRE95]'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The output for `f1` is as follows:'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数`f1`的输出如下：
- en: '[PRE96]'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: As you can see, a polynomial regression of degree `1` has two coefficients.
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，一次多项式回归具有两个系数。
- en: 'The output for `f2` is as follows:'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数`f2`的输出如下：
- en: '[PRE97]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: As you can see, a polynomial regression of degree `2` has three coefficients.
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，二次多项式回归具有三个系数。
- en: 'The output for `f3` is as follows:'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数`f3`的输出如下：
- en: '[PRE98]'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: As you can see, a polynomial regression of degree `3` has four coefficients.
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，三次多项式回归具有四个系数。
- en: Now that we have calculated the three polynomial regressions, we can plot them
    together with the data on a graph to see how they behave.
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经计算了三次多项式回归，可以将它们与数据一起绘制在图表上，观察它们的行为。
- en: 'Plot the three polynomial regressions and the data on a graph in the following code:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中将三个多项式回归和数据绘制在图表上：
- en: '[PRE99]'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The output is as follows:'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 2.24: Graph showing the polynomial regressions for the first dataset'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图2.24：显示第一个数据集多项式回归的图表'
- en: '](img/B16060_02_24.jpg)'
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_02_24.jpg)'
- en: 'Figure 2.24: Graph showing the polynomial regressions for the first dataset'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.24：显示第一个数据集多项式回归的图表
- en: As the coefficients are enumerated from left to right in order of decreasing
    degree, we can see that the higher-degree coefficients stay close to negligible.
    In other words, the three curves are almost on top of each other, and we can only
    detect a divergence near the right edge. This is because we are working on a dataset
    that can be very well approximated with a linear model.
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当系数按从左到右的降阶顺序枚举时，我们可以看到更高阶的系数保持接近可忽略的状态。换句话说，三条曲线几乎重合，我们只能在右边缘附近检测到分歧。这是因为我们处理的数据集可以用线性模型非常好地逼近。
- en: In fact, the first dataset was created out of a linear function. Any non-zero
    coefficients for *x*2 and *x*3 are the result of overfitting the model based on
    the available data. The linear model is better for predicting values outside the
    range of the training data than any higher-degree polynomial.
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上，第一个数据集是基于线性函数创建的。任何非零的*x*2和*x*3系数都是基于可用数据过拟合模型的结果。与任何更高阶多项式相比，线性模型更适合预测训练数据范围之外的值。
- en: Let's contrast this behavior with the second example. We know that the Fibonacci
    sequence is nonlinear. So, using a linear equation to approximate it is a clear
    case for underfitting. Here, we expect a higher polynomial degree to perform better.
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们将这种行为与第二个例子进行对比。我们知道斐波那契序列是非线性的。因此，使用线性方程来近似它是欠拟合的明显情况。在这里，我们期望更高的多项式次数能够表现更好。
- en: 'Perform a polynomial regression of degrees `1`, `2`, and `3` on the second
    dataset using the `polyfit` method from `numpy` with the following code:'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码，使用`numpy`中的`polyfit`方法在第二组数据集上执行1次、2次和3次的多项式回归：
- en: '[PRE100]'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The output for `g1` is as follows:'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`g1`的输出如下：'
- en: '[PRE101]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: As you can see, a polynomial regression of degree `1` has `2` coefficients.
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，1次多项式回归有2个系数。
- en: 'The output for `g2` is as follows:'
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`g2`的输出如下：'
- en: '[PRE102]'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: As you can see, a polynomial regression of degree `2` has `3` coefficients.
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，2次多项式回归有3个系数。
- en: 'The output for `g3` is as follows:'
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`g3`的输出如下：'
- en: '[PRE103]'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: As you can see, a polynomial regression of degree `3` has `4` coefficients.
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，3次多项式回归有4个系数。
- en: 'Plot the three polynomial regressions and the data on a graph in the following code:'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中绘制三条多项式回归曲线和数据点：
- en: '[PRE104]'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The output is as follows:'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 2.25: Graph showing the second dataset points and three polynomial
    curves'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.25：展示第二组数据点和三条多项式曲线](img/B16060_02_25.jpg)'
- en: '](img/B16060_02_25.jpg)'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_02_25.jpg)'
- en: 'Figure 2.25: Graph showing the second dataset points and three polynomial curves'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.25：展示第二组数据点和三条多项式曲线
- en: The difference is clear. The quadratic curve fits the points a lot better than
    the linear one. The cubic curve is even better.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 差异很明显。二次曲线比线性曲线更好地拟合数据点。三次曲线更好。
- en: Note
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3dpCgyY](https://packt.live/3dpCgyY).
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3dpCgyY](https://packt.live/3dpCgyY)。
- en: You can also run this example online at [https://packt.live/2B09xDN](https://packt.live/2B09xDN).
    You must execute the entire Notebook in order to get the desired result.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/2B09xDN](https://packt.live/2B09xDN)上在线运行这个示例。你必须执行整个笔记本才能获得期望的结果。
- en: If you research Binet's formula, you will find out that the Fibonacci function
    is an exponential function, as the *n*th Fibonacci number is calculated as the
    *n*th power of a constant. Therefore, the higher the polynomial degree we use,
    the more accurate our approximation will be.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你研究比内特公式，你会发现斐波那契函数是一个指数函数，因为第*n*个斐波那契数是常数的*n*次幂。因此，使用的多项式次数越高，我们的近似值就会越精确。
- en: Polynomial Regression with Multiple Variables
  id: totrans-551
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多变量的多项式回归
- en: When we have one variable of degree *n*, we have *n+1* coefficients in the equation
    as ![36](img/B16060_02_23d.png).
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个次数为*n*的变量时，方程中有*n+1*个系数，如![36](img/B16060_02_23d.png)所示。
- en: Once we deal with multiple features, *x*1, *x*2, …, *x*m, and their powers of
    up to the *n*th degree, we get an *m * (n+1)* matrix of coefficients. The math
    will become quite lengthy when we start exploring the details and prove how a
    polynomial model works. We will also lose the nice visualizations of two-dimensional
    curves.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们处理了多个特征，*x*1, *x*2, …, *x*m，以及它们的最高次幂为*n*时，我们将得到一个*m * (n+1)*的系数矩阵。当我们开始探索细节并证明多项式模型如何工作时，数学推导会变得相当冗长。我们还会失去二维曲线的美观可视化。
- en: Therefore, we will apply the concepts learned in the previous section on polynomial
    regression with one variable and omit the math. When training and testing a linear
    regression model, we can calculate the mean square error to see how good an approximation
    a model is.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将应用在前一节中学习的单变量多项式回归的概念，并省略数学推导。当训练和测试一个线性回归模型时，我们可以计算均方误差来衡量模型的拟合效果。
- en: In scikit-learn, the degree of the polynomials used in the approximation is
    a simple parameter in the model.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在scikit-learn中，用于近似的多项式次数是模型中的一个简单参数。
- en: As polynomial regression is a form of linear regression, we can perform polynomial
    regression without changing the regression model. All we need to do is to transform
    the input and keep the linear regression model. The transformation of the input
    is performed by the `fit_transform` method of the `PolynomialFeatures` package.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 由于多项式回归是一种线性回归形式，我们可以在不改变回归模型的情况下执行多项式回归。我们需要做的只是转换输入并保持线性回归模型。输入的转换通过`PolynomialFeatures`包的`fit_transform`方法完成。
- en: 'First, we can reuse the code from *Exercise 2.03*, *Preparing the Quandl Data
    for Prediction*, up to *Step 9* and import `PolynomialFeatures` from the `preprocessing`
    module of `sklearn`:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以重用*练习 2.03*中的代码，*为预测准备Quandl数据*，直到*步骤9*，并从`sklearn`的`preprocessing`模块中导入`PolynomialFeatures`：
- en: '[PRE105]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Now, we can create a polynomial regression of degree `3` using the `fit_transform`
    method of `PolynomialFeatures`:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`PolynomialFeatures`的`fit_transform`方法创建一个三次多项式回归：
- en: '[PRE106]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The output of `poly_scaled_features` is as follows:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '`poly_scaled_features` 的输出如下：'
- en: '[PRE107]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Then, we need to split the data into testing and training sets:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将数据分为测试集和训练集：
- en: '[PRE108]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The `train_test_split` function shuffles the lines of our data, keeps the correspondence,
    and puts approximately 10% of all data in the test variables, keeping 90% for
    the training variables. We also use `random_state=8` in order to reproduce the
    results.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '`train_test_split` 函数会打乱数据行，保持其对应关系，并将大约 10% 的数据放入测试变量，剩下的 90% 用于训练变量。我们还使用
    `random_state=8` 来重现结果。'
- en: 'Our data is now ready to be used for the multiple polynomial regression model;
    we will also measure its performance with the `score` function:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据现在已准备好用于多项式回归模型；我们还将使用 `score` 函数来衡量其性能：
- en: '[PRE109]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The output is as follows:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE110]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: With a score or R2 of `0.988`, our multiple polynomial regression model is slightly
    better than our multiple linear regression model (`0.985`), which we built in
    *Exercise 2.03*, *Preparing the Quandl Data for Prediction*. It might be possible
    that both models are overfitting the dataset.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在得分或 R2 为 `0.988` 的情况下，我们的多项式回归模型略优于我们在*练习 2.03*，*为预测准备 Quandl 数据*中构建的多元线性回归模型（`0.985`）。可能两者模型都存在过拟合数据集的情况。
- en: There is another model in scikit-learn that performs polynomial regression,
    called the SVM model.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: scikit-learn 中还有另一个执行多项式回归的模型，称为 SVM 模型。
- en: Support Vector Regression
  id: totrans-572
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持向量回归
- en: SVMs are binary classifiers and are usually used in classification problems
    (you will learn more about this in *Chapter 3*, *An Introduction to Classification*).
    An SVM classifier takes data and tries to predict which class it belongs to. Once
    the classification of a data point is determined, it gets labeled. But SVMs can
    also be used for regression; that is, instead of labeling data, it can predict
    future values in a series.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: SVM 是二分类器，通常用于分类问题（你将在*第 3 章*，*分类简介*中学到更多）。SVM 分类器接收数据并尝试预测数据属于哪个类别。一旦确定了数据点的分类，它就会被标记。但
    SVM 也可以用于回归；也就是说，除了标记数据，它还可以预测序列中的未来值。
- en: The SVR model uses the space between our data as a margin of error. Based on
    the margin of error, it makes predictions regarding future values.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: SVR 模型使用我们数据之间的空间作为误差范围。基于误差范围，它对未来值进行预测。
- en: If the margin of error is too small, we risk overfitting the existing dataset.
    If the margin of error is too big, we risk underfitting the existing dataset.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 如果误差范围过小，我们可能会导致模型过拟合现有数据集。如果误差范围过大，我们可能会导致模型欠拟合现有数据集。
- en: In the case of a classifier, the kernel describes the surface dividing the state
    space, whereas, in a regression, the kernel measures the margin of error. This
    kernel can use a linear model, a polynomial model, or many other possible models.
    The default kernel is **RBF**, which stands for **Radial Basis Function**.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 对于分类器，核函数描述了划分状态空间的曲面，而在回归中，核函数衡量误差范围。这个核可以使用线性模型、多项式模型或许多其他可能的模型。默认的核函数是 **RBF**，即
    **径向基函数**。
- en: SVR is an advanced topic that is outside the scope of this book. Therefore,
    we will only stick to an easy walk-through as an opportunity to try out another
    regression model on our data.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: SVR 是一个高级话题，超出了本书的范围。因此，我们只会坚持一个简单的演示，作为在数据上尝试另一个回归模型的机会。
- en: 'We can reuse the code from *Exercise 2.03*, *Preparing the Quandl Data for
    Prediction*, up to *Step 11*:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重复使用*练习 2.03*，*为预测准备 Quandl 数据*中的代码，直到*步骤 11*：
- en: '[PRE111]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Then, we can perform a regression with `svm` by simply changing the linear
    model to a support vector model by using the `svm` method from `sklearn`:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过简单地将线性模型改为支持向量模型，使用 `sklearn` 中的 `svm` 方法来执行回归：
- en: '[PRE112]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: As you can see, performing an SVR is exactly the same as performing a linear
    regression, with the exception of defining the model as `svm.SVR()`.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，执行 SVR 与执行线性回归完全相同，唯一的区别是将模型定义为 `svm.SVR()`。
- en: 'Finally, we can predict and measure the performance of our model:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以预测并衡量模型的性能：
- en: '[PRE113]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The output is as follows:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE114]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: As you can see, the score or R2 is quite low, our SVR's parameters need to be
    optimized in order to increase the accuracy of the model.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，得分或 R2 值相当低，我们的 SVR 参数需要优化，以提高模型的准确性。
- en: Support Vector Machines with a 3-Degree Polynomial Kernel
  id: totrans-588
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具有 3 次多项式核的支持向量机
- en: 'Let''s switch the kernel of the SVM to a polynomial function (the default degree
    is `3`) and measure the performance of the new model:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将SVM的核函数切换为多项式函数（默认度数为`3`），并测量新模型的性能：
- en: '[PRE115]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The output is as follows:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE116]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: We managed to increase the performance of the SVM by simply changing the kernel
    function to a polynomial function; however, the model still needs a lot of tuning
    to reach the same performance as the linear regression models.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将SVM的核函数更改为多项式函数，成功提高了模型的性能；然而，模型仍然需要大量的调优，才能达到线性回归模型的相同性能。
- en: 'Activity 2.01: Boston House Price Prediction with Polynomial Regression of
    Degrees 1, 2, and 3 on Multiple Variables'
  id: totrans-594
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 2.01：使用多项式回归（1、2、3次）和多个变量预测波士顿房价
- en: In this activity, you will need to perform linear polynomial regression of degrees
    1, 2, and 3 with scikit-learn and find the best model. You will work on the Boston
    House Prices dataset. The Boston House Price dataset is very famous and has been
    used as an example for research on regression models.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你需要使用scikit-learn进行1、2、3次线性多项式回归，并找到最优模型。你将使用波士顿房价数据集。波士顿房价数据集非常著名，并已作为回归模型研究的示例。
- en: Note
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: More details about the Boston House Prices dataset can be found at [https://archive.ics.uci.edu/ml/machine-learning-databases/housing/](https://archive.ics.uci.edu/ml/machine-learning-databases/housing/).
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 关于波士顿房价数据集的更多详情，请访问[https://archive.ics.uci.edu/ml/machine-learning-databases/housing/](https://archive.ics.uci.edu/ml/machine-learning-databases/housing/)。
- en: 'The dataset file can also be found in our GitHub repository: [https://packt.live/2V9kRUU](https://packt.live/2V9kRUU).'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集文件也可以在我们的GitHub仓库中找到：[https://packt.live/2V9kRUU](https://packt.live/2V9kRUU)。
- en: 'You will need to predict the prices of houses in Boston (label) based on their
    characteristics (features). Your main goal will be to build 3 linear models using
    polynomial regressions of degrees `1`, `2`, and `3` with all the features of the
    dataset. You can find the following dataset description:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要根据波士顿房屋的特征（特征）预测房价（标签）。你的主要目标是使用数据集中的所有特征，构建3个线性模型，分别是1次、2次和3次多项式回归。你可以找到以下数据集描述：
- en: '![Figure 2.26: Boston housing dataset description'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.26：波士顿房价数据集描述'
- en: '](img/B16060_02_26.jpg)'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_02_26.jpg)'
- en: 'Figure 2.26: Boston housing dataset description'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.26：波士顿房价数据集描述
- en: We will define our label as the `MEDV` field, which is the median value of the
    house in $1,000s. All of the other fields will be used as our features for our
    models. As this dataset does not contain any missing values, we won't have to
    replace missing values as we did in the previous exercises.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义`MEDV`字段作为标签，它是房屋的中位数价格（单位：千美元）。所有其他字段将作为我们模型的特征。由于这个数据集没有缺失值，我们不需要像之前的练习那样填补缺失值。
- en: 'The following steps will help you to complete the activity:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成该活动：
- en: Open a Jupyter Notebook.
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个Jupyter Notebook。
- en: Import the required packages and load the Boston House Prices data into a DataFrame.
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的包并将波士顿房价数据加载到一个DataFrame中。
- en: Prepare the dataset for prediction by converting the label and features into
    NumPy arrays and scaling the features.
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备数据集进行预测，将标签和特征转换为NumPy数组，并对特征进行缩放。
- en: Create three different sets of features by transforming the scaled features
    into suitable formats for each of the polynomial regressions.
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将缩放后的特征转换为适合每个多项式回归的格式，创建三组不同的特征。
- en: Split the data into training and testing sets with `random state = 8`.
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据集拆分为训练集和测试集，`random state = 8`。
- en: Perform a polynomial regression of degree `1` and evaluate whether the model
    is overfitting.
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一个一次多项式回归，并评估模型是否存在过拟合现象。
- en: Perform a polynomial regression of degree `2` and evaluate whether the model
    is overfitting.
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一个二次多项式回归，并评估模型是否存在过拟合现象。
- en: Perform a polynomial regression of degree `3` and evaluate whether the model
    is overfitting.
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一个三次多项式回归，并评估模型是否存在过拟合现象。
- en: Compare the predictions of the three models against the label on the testing
    set.
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较三种模型在测试集上预测的结果与标签的差异。
- en: 'The expected output is this:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 2.27: Expected output based on the predictions'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.27：基于预测的预期输出'
- en: '](img/B16060_02_27.jpg)'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_02_27.jpg)'
- en: 'Figure 2.27: Expected output based on the predictions'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.27：基于预测的预期输出
- en: Note
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity is available on page 334.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第334页找到。
- en: Summary
  id: totrans-620
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned the fundamentals of linear regression. After
    going through some basic mathematics, we looked at the mathematics of linear regression
    using one variable and multiple variables.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经学习了线性回归的基础知识。在了解了一些基础数学知识后，我们研究了使用单个变量和多个变量的线性回归数学原理。
- en: Then, we learned how to load external data from sources such as a CSV file,
    Yahoo Finance, and Quandl. After loading the data, we learned how to identify
    features and labels, how to scale data, and how to format data to perform regression.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了如何从外部数据源加载数据，如CSV文件、Yahoo Finance和Quandl。在加载数据后，我们学习了如何识别特征和标签，如何对数据进行缩放，以及如何格式化数据以执行回归。
- en: We learned how to train and test a linear regression model, and how to predict
    the future. Our results were visualized by an easy-to-use Python graph plotting
    library called `pyplot`.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何训练和测试线性回归模型，以及如何预测未来。我们的结果通过一个易于使用的Python图形绘图库`pyplot`进行了可视化。
- en: 'We also learned about a more complex form of linear regression: linear polynomial
    regression using arbitrary degrees. We learned how to define these regression
    problems on multiple variables and compare their performance on the Boston House
    Price dataset. As an alternative to polynomial regression, we also introduced
    SVMs as a regression model and experimented with two kernels.'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了更复杂的线性回归形式：使用任意次数的线性多项式回归。我们学习了如何在多个变量上定义这些回归问题，并比较它们在波士顿房价数据集上的表现。作为多项式回归的替代方法，我们还介绍了支持向量机（SVM）作为回归模型，并试验了两种核函数。
- en: In the next chapter, you will learn about classification and its models.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习分类及其模型。
