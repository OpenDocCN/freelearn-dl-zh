- en: Dynamic Programming for Optimal Policies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: åŠ¨æ€è§„åˆ’ä¸æœ€ä¼˜ç­–ç•¥
- en: '**Dynamic programming** (**DP**) represents a set of algorithms that can be
    used to calculate an optimal policy given a perfect model of the environment in
    the form of a **Markov decision process** (**MDP**). DP methods update the estimates
    of the state values on the basis of the estimates made in the previous steps.Â In
    DP, an optimization problem is decomposed into simpler subproblems and the solution
    for each subproblem is stored so that each subproblem is solved only once. In
    this chapter, we will learn how to select the optimal portfolio using DP through
    an R code implementation.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**åŠ¨æ€è§„åˆ’**ï¼ˆ**DP**ï¼‰ä»£è¡¨äº†ä¸€ç»„å¯ä»¥ç”¨æ¥è®¡ç®—æœ€ä¼˜ç­–ç•¥çš„ç®—æ³•ï¼Œå‰ææ˜¯æœ‰ä¸€ä¸ªå®Œç¾çš„ç¯å¢ƒæ¨¡å‹ï¼Œä»¥**é©¬å°”å¯å¤«å†³ç­–è¿‡ç¨‹**ï¼ˆ**MDP**ï¼‰çš„å½¢å¼ç»™å‡ºã€‚DPæ–¹æ³•æ ¹æ®ä¹‹å‰æ­¥éª¤ä¸­çš„ä¼°è®¡å€¼æ¥æ›´æ–°çŠ¶æ€å€¼çš„ä¼°è®¡ã€‚åœ¨DPä¸­ï¼Œä¼˜åŒ–é—®é¢˜è¢«åˆ†è§£ä¸ºæ›´ç®€å•çš„å­é—®é¢˜ï¼Œæ¯ä¸ªå­é—®é¢˜çš„è§£è¢«å­˜å‚¨ï¼Œä»¥ä¾¿æ¯ä¸ªå­é—®é¢˜åªè¢«è§£å†³ä¸€æ¬¡ã€‚åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•é€šè¿‡Rä»£ç å®ç°DPæ¥é€‰æ‹©æœ€ä¼˜çš„æŠ•èµ„ç»„åˆã€‚'
- en: 'The following topics are covered in the chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ç« æ¶µç›–ä»¥ä¸‹ä¸»é¢˜ï¼š
- en: Understanding DP
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç†è§£DP
- en: Learning the top-downÂ DP approach
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å­¦ä¹ è‡ªé¡¶å‘ä¸‹çš„DPæ–¹æ³•
- en: Analyzing the difference between recursion and memoization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åˆ†æé€’å½’ä¸å¤‡å¿˜å½•åŒ–çš„åŒºåˆ«
- en: Learning the optimization techniques
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å­¦ä¹ ä¼˜åŒ–æŠ€æœ¯
- en: Implementing DP in reinforcement learning applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨å¼ºåŒ–å­¦ä¹ åº”ç”¨ä¸­å®ç°DP
- en: Solving the knapsack problem
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è§£å†³èƒŒåŒ…é—®é¢˜
- en: Optimization of a robot navigation system
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æœºå™¨äººå¯¼èˆªç³»ç»Ÿçš„ä¼˜åŒ–
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æŠ€æœ¯è¦æ±‚
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: æŸ¥çœ‹ä»¥ä¸‹è§†é¢‘ï¼Œäº†è§£ä»£ç å¦‚ä½•è¿è¡Œï¼š
- en: '[http://bit.ly/2RPIFfB](http://bit.ly/2RPIFfB)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2RPIFfB](http://bit.ly/2RPIFfB)'
- en: Understanding DP
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç†è§£DP
- en: DP is a mathematical methodology developed by Richard Bellman in the 1950s.
    It is used to solve problems in which a series of interdependent decisions must
    be addressed in sequence. The underlying principle behind this methodology is
    that of Bellman's optimalityâ€”whatever the initial status and the initial decision,
    subsequent decisions must provide an optimal policy with respect to the status
    resulting from the previous decision. This is the essential feature of an optimal
    policy.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: DPï¼ˆåŠ¨æ€è§„åˆ’ï¼‰æ˜¯ç†æŸ¥å¾·Â·è´å°”æ›¼ï¼ˆRichard Bellmanï¼‰åœ¨1950å¹´ä»£å¼€å‘çš„æ•°å­¦æ–¹æ³•è®ºã€‚å®ƒç”¨äºè§£å†³éœ€è¦æŒ‰é¡ºåºå¤„ç†ä¸€ç³»åˆ—ç›¸äº’ä¾èµ–çš„å†³ç­–é—®é¢˜ã€‚è¯¥æ–¹æ³•è®ºèƒŒåçš„åŸºæœ¬åŸåˆ™æ˜¯è´å°”æ›¼çš„æœ€ä¼˜æ€§â€”â€”æ— è®ºåˆå§‹çŠ¶æ€å’Œåˆå§‹å†³ç­–å¦‚ä½•ï¼Œåç»­çš„å†³ç­–å¿…é¡»ç›¸å¯¹äºå‰ä¸€ä¸ªå†³ç­–æ‰€å¯¼è‡´çš„çŠ¶æ€æä¾›æœ€ä¼˜çš„ç­–ç•¥ã€‚è¿™æ˜¯æœ€ä¼˜ç­–ç•¥çš„æœ¬è´¨ç‰¹å¾ã€‚
- en: Consider an example of finding the best path that joins two positions. The optimality
    principle states that every sub-path included in it, between any intermediate
    and final position, must in turn be optimal. Based on this principle, DP solves
    a problem by making one decision at a time. At each step, the best policy for
    the future is determined, regardless of past choices (it is a Markov process),
    if these are also optimal.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: è®¾æƒ³ä¸€ä¸ªå¯»æ‰¾è¿æ¥ä¸¤ä¸ªä½ç½®çš„æœ€ä½³è·¯å¾„çš„ä¾‹å­ã€‚æœ€ä¼˜æ€§åŸåˆ™æŒ‡å‡ºï¼Œè·¯å¾„ä¸­æ¯ä¸€ä¸ªå­è·¯å¾„ï¼Œæ— è®ºæ˜¯ä»ä¸­é—´ä½ç½®åˆ°æœ€ç»ˆä½ç½®ï¼Œéƒ½å¿…é¡»æ˜¯æœ€ä¼˜çš„ã€‚åŸºäºè¿™ä¸€åŸåˆ™ï¼ŒDPé€šè¿‡ä¸€æ¬¡ä½œå‡ºä¸€ä¸ªå†³ç­–æ¥è§£å†³é—®é¢˜ã€‚åœ¨æ¯ä¸€æ­¥ï¼Œéƒ½ä¼šç¡®å®šæœªæ¥çš„æœ€ä½³ç­–ç•¥ï¼Œè€Œä¸è€ƒè™‘è¿‡å»çš„é€‰æ‹©ï¼ˆå®ƒæ˜¯ä¸€ä¸ªé©¬å°”å¯å¤«è¿‡ç¨‹ï¼‰ï¼Œå‰ææ˜¯è¿™äº›é€‰æ‹©ä¹Ÿæ˜¯æœ€ä¼˜çš„ã€‚
- en: DP is therefore effectively applicable whenever the original problem can be
    broken down into a series of minor subproblems, or when the cost paid or the profit
    obtained are expressed as the sum of the elementary costs associated with each
    individual decision. More generally, the cost must be expressed through some operators
    as a composition of elementary costsÂ that are individually dependent on a single
    decision.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼ŒDPåœ¨åŸé—®é¢˜å¯ä»¥åˆ†è§£ä¸ºä¸€ç³»åˆ—è¾ƒå°çš„å­é—®é¢˜ï¼Œæˆ–å½“æ”¯ä»˜çš„æˆæœ¬æˆ–è·å¾—çš„åˆ©æ¶¦å¯ä»¥è¡¨ç¤ºä¸ºä¸æ¯ä¸ªå•ç‹¬å†³ç­–ç›¸å…³çš„åŸºæœ¬æˆæœ¬ä¹‹å’Œæ—¶ï¼ŒDPæ˜¯æœ‰æ•ˆçš„ã€‚æ›´ä¸€èˆ¬åœ°ï¼Œæˆæœ¬å¿…é¡»é€šè¿‡æŸäº›è¿ç®—ç¬¦è¡¨ç¤ºä¸ºåŸºæœ¬æˆæœ¬çš„ç»„åˆï¼Œè¿™äº›åŸºæœ¬æˆæœ¬å„è‡ªä¾èµ–äºå•ä¸ªå†³ç­–ã€‚
- en: 'The following diagram shows the best route between two nodes of a network (the
    red path) among all those available (and by "best" I mean "shortest"):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹å›¾ç¤ºå±•ç¤ºäº†ç½‘ç»œä¸­ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´çš„æœ€ä½³è·¯å¾„ï¼ˆçº¢è‰²è·¯å¾„ï¼‰ï¼Œåœ¨æ‰€æœ‰å¯ç”¨è·¯å¾„ä¸­é€‰æ‹©çš„â€œæœ€ä½³â€è·¯å¾„æ˜¯â€œæœ€çŸ­â€çš„ï¼š
- en: '![](img/70f9d33c-5edf-4d4c-8b2b-4ca7c71f4682.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70f9d33c-5edf-4d4c-8b2b-4ca7c71f4682.png)'
- en: 'There are many paths available to reach the same destination: only one is the
    shortest.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰è®¸å¤šè·¯å¾„å¯ä»¥åˆ°è¾¾ç›¸åŒçš„ç›®çš„åœ°ï¼šåªæœ‰ä¸€æ¡æ˜¯æœ€çŸ­çš„ã€‚
- en: Let's now examine the concepts underlying this technology. We will begin by
    comparing two very popular techniques.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è®©æˆ‘ä»¬æ¥åˆ†æè¿™é¡¹æŠ€æœ¯çš„åŸºæœ¬æ¦‚å¿µã€‚æˆ‘ä»¬å°†é€šè¿‡æ¯”è¾ƒä¸¤ç§éå¸¸æµè¡Œçš„æŠ€æœ¯å¼€å§‹ã€‚
- en: Learning the top-down DP approach
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å­¦ä¹ è‡ªé¡¶å‘ä¸‹çš„DPæ–¹æ³•
- en: 'To understand the mechanism behind DP, we can compare it with another very
    common problem-solving mechanismâ€”**divide and conquer**. With this mechanism,
    a problem is divided into two or more subproblems, and the solution of the original
    problem is constructed starting from the subproblem solutions. This approach is
    called a top-down technique and works according to the following procedure:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ç†è§£åŠ¨æ€è§„åˆ’èƒŒåçš„æœºåˆ¶ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶ä¸å¦ä¸€ç§éå¸¸å¸¸è§çš„è§£å†³é—®é¢˜çš„æœºåˆ¶â€”â€”**åˆ†æ²»æ³•**è¿›è¡Œæ¯”è¾ƒã€‚é€šè¿‡åˆ†æ²»æ³•ï¼Œä¸€ä¸ªé—®é¢˜è¢«åˆ†è§£æˆä¸¤ä¸ªæˆ–æ›´å¤šçš„å­é—®é¢˜ï¼ŒåŸé—®é¢˜çš„è§£æ˜¯ä»å­é—®é¢˜çš„è§£å¼€å§‹æ„å»ºçš„ã€‚è¿™ç§æ–¹æ³•å«åšè‡ªé¡¶å‘ä¸‹çš„æŠ€æœ¯ï¼ŒæŒ‰ä»¥ä¸‹æ­¥éª¤è¿›è¡Œï¼š
- en: Divide the problem instance into two or more sub-instances.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å°†é—®é¢˜å®ä¾‹åˆ†è§£æˆä¸¤ä¸ªæˆ–æ›´å¤šçš„å­å®ä¾‹ã€‚
- en: Recursively solve the problem for each sub-instance.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å¯¹æ¯ä¸ªå­å®ä¾‹é€’å½’åœ°è§£å†³é—®é¢˜ã€‚
- en: Recombine the subproblem solution in order to obtain the global solution.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: é‡æ–°ç»„åˆå­é—®é¢˜çš„è§£ï¼Œä»¥è·å¾—å…¨å±€è§£ã€‚
- en: This mechanism is widely applied to the resolution of multiple problems. The
    most popular applications are two of the most commonly used sorting algorithmsâ€”quick
    sort and merge sort.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§æœºåˆ¶å¹¿æ³›åº”ç”¨äºè§£å†³å¤šä¸ªé—®é¢˜ã€‚æœ€å¸¸è§çš„åº”ç”¨æ˜¯ä¸¤ç§æœ€å¸¸ç”¨çš„æ’åºç®—æ³•â€”â€”å¿«é€Ÿæ’åºå’Œå½’å¹¶æ’åºã€‚
- en: For example, in the **quick sort** algorithm, the elements of the list to be
    sorted are divided into two blocks, the smaller ones and the larger ones of a
    pivot, and the algorithm is called recursively on the two blocks.Â In merge sort,
    the algorithm finds the index of the central position and divides the list into
    two blocks each with n/2 elements. Then the algorithm is called recursively on
    the two blocks.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œåœ¨**å¿«é€Ÿæ’åº**ç®—æ³•ä¸­ï¼Œå¾…æ’åºåˆ—è¡¨çš„å…ƒç´ è¢«åˆ†ä¸ºä¸¤ä¸ªå—ï¼Œä¸€å—æ˜¯å°äºä¸»å…ƒçš„å…ƒç´ ï¼Œå¦ä¸€å—æ˜¯å¤§äºä¸»å…ƒçš„å…ƒç´ ï¼Œç„¶åç®—æ³•ä¼šé€’å½’åœ°å¯¹è¿™ä¸¤ä¸ªå—è¿›è¡Œè°ƒç”¨ã€‚å½’å¹¶æ’åºä¸­ï¼Œç®—æ³•æ‰¾åˆ°ä¸­é—´ä½ç½®çš„ç´¢å¼•ï¼Œå¹¶å°†åˆ—è¡¨åˆ†æˆä¸¤ä¸ªå„åŒ…å«
    n/2 å…ƒç´ çš„å—ã€‚ç„¶åï¼Œç®—æ³•ä¼šé€’å½’åœ°å¯¹è¿™ä¸¤ä¸ªå—è¿›è¡Œè°ƒç”¨ã€‚
- en: There are cases in which divide and conquer is not applicable because we do
    not know how to get subproblemsâ€”the problem does not contain enough information
    to allow us to decide how to break it into several parts.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰äº›æƒ…å†µä¸‹ï¼Œåˆ†æ²»æ³•æ— æ³•åº”ç”¨ï¼Œå› ä¸ºæˆ‘ä»¬ä¸çŸ¥é“å¦‚ä½•è·å¾—å­é—®é¢˜â€”â€”é—®é¢˜æœ¬èº«å¹¶ä¸åŒ…å«è¶³å¤Ÿçš„ä¿¡æ¯æ¥è®©æˆ‘ä»¬å†³å®šå¦‚ä½•å°†å…¶åˆ†è§£ä¸ºå¤šä¸ªéƒ¨åˆ†ã€‚
- en: 'In this case, DP comes into play: we proceed to calculate the solutions of
    all possible subproblems, and starting from sub-solutions we obtain new sub-solutions
    until the original problem is solved. Unlike the divide and conquer mechanism,
    the subproblems to be solved are not necessarily disjoint, which means one subproblem
    can be common to several other subproblems. In order to avoid recalculation of
    a subproblem more than once, the subproblems are resolved with a bottom-up strategyâ€”from
    the smallest subproblem to the largest subproblem, and the solutions to these
    subproblems are stored in appropriate tables so that they are available (if necessary)
    for the solution of other subproblems.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒåŠ¨æ€è§„åˆ’å‘æŒ¥ä½œç”¨ï¼šæˆ‘ä»¬ç»§ç»­è®¡ç®—æ‰€æœ‰å¯èƒ½çš„å­é—®é¢˜çš„è§£ï¼Œå¹¶ä»å­è§£å¼€å§‹ï¼Œé€æ­¥å¾—åˆ°æ–°çš„å­è§£ï¼Œç›´åˆ°è§£å†³åŸé—®é¢˜ã€‚ä¸åˆ†æ²»æ³•ä¸åŒï¼Œå¾…è§£å†³çš„å­é—®é¢˜ä¸ä¸€å®šæ˜¯äº’ä¸ç›¸äº¤çš„ï¼Œè¿™æ„å‘³ç€ä¸€ä¸ªå­é—®é¢˜å¯ä»¥æ˜¯å¤šä¸ªå…¶ä»–å­é—®é¢˜çš„å…±åŒéƒ¨åˆ†ã€‚ä¸ºäº†é¿å…å¯¹å­é—®é¢˜è¿›è¡Œé‡å¤è®¡ç®—ï¼Œå­é—®é¢˜é€šè¿‡è‡ªåº•å‘ä¸Šçš„ç­–ç•¥è§£å†³â€”â€”ä»æœ€å°çš„å­é—®é¢˜å¼€å§‹è§£å†³ï¼Œé€æ­¥å‘å¤§çš„å­é—®é¢˜æ¨è¿›ï¼Œå¹¶å°†è¿™äº›å­é—®é¢˜çš„è§£å­˜å‚¨åœ¨é€‚å½“çš„è¡¨æ ¼ä¸­ï¼Œä»¥ä¾¿å®ƒä»¬å¯ä»¥åœ¨éœ€è¦æ—¶ï¼ˆå¦‚æœ‰å¿…è¦ï¼‰ä¸ºè§£å†³å…¶ä»–å­é—®é¢˜æä¾›å¸®åŠ©ã€‚
- en: Often in recursive algorithms we find ourselves dealing with procedures that
    are unnecessarily burdensome from a computational point of view. Let's see how
    we can tackle this problem.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨é€’å½’ç®—æ³•ä¸­ï¼Œæˆ‘ä»¬å¸¸å¸¸é‡åˆ°ä¸€äº›ä»è®¡ç®—è§’åº¦æ¥çœ‹ä¸å¿…è¦çš„ç¹é‡è¿‡ç¨‹ã€‚è®©æˆ‘ä»¬çœ‹çœ‹å¦‚ä½•è§£å†³è¿™ä¸ªé—®é¢˜ã€‚
- en: Analyzing the difference between recursion and memoization
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: åˆ†æé€’å½’å’Œè®°å¿†åŒ–ä¹‹é—´çš„åŒºåˆ«
- en: On the basis of what has been said here, we can deduce that DP is used in cases
    where there is a recursive definition of the problem, but the direct transformation
    of this definition into an algorithm generates a program of exponential complexity
    due to the repeated calculation on the same subsets of data from the different
    recursive calls. An example is the calculation of the Fibonacci numbers, which
    we will analyze in detail later.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œæ‰€è¯´çš„åŸºç¡€ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥æ¨æ–­å‡ºåŠ¨æ€è§„åˆ’ï¼ˆDPï¼‰ç”¨äºé‚£äº›å…·æœ‰é€’å½’å®šä¹‰çš„é—®é¢˜ï¼Œä½†å°†è¯¥å®šä¹‰ç›´æ¥è½¬åŒ–ä¸ºç®—æ³•ä¼šç”±äºä¸åŒé€’å½’è°ƒç”¨å¯¹ç›¸åŒæ•°æ®å­é›†çš„é‡å¤è®¡ç®—ï¼Œå¯¼è‡´ç¨‹åºçš„æ—¶é—´å¤æ‚åº¦å‘ˆæŒ‡æ•°å¢é•¿ã€‚ä¸€ä¸ªä¾‹å­æ˜¯æ–æ³¢é‚£å¥‘æ•°çš„è®¡ç®—ï¼Œæˆ‘ä»¬å°†åœ¨åç»­è¯¦ç»†åˆ†æã€‚
- en: We have seen that DP is a technique for solving recursive problems more efficiently.
    Why does this happen? Many times in the recursive procedures we solve the subproblems
    repeatedly. In DP this does not happenâ€”we memorize the solution of these subproblems
    so that we do not have to solve them again. This is called **memoization**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»çœ‹åˆ°ï¼ŒåŠ¨æ€è§„åˆ’ï¼ˆDPï¼‰æ˜¯ä¸€ç§æ›´é«˜æ•ˆåœ°è§£å†³é€’å½’é—®é¢˜çš„æŠ€æœ¯ã€‚è¿™æ˜¯ä¸ºä»€ä¹ˆå‘¢ï¼Ÿåœ¨é€’å½’è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å¾ˆå¤šæ—¶å€™ä¼šé‡å¤åœ°è§£å†³å­é—®é¢˜ã€‚åœ¨åŠ¨æ€è§„åˆ’ä¸­ï¼Œæƒ…å†µå¹¶éå¦‚æ­¤â€”â€”æˆ‘ä»¬ä¼šè®°ä½è¿™äº›å­é—®é¢˜çš„è§£ï¼Œä»è€Œé¿å…å†æ¬¡æ±‚è§£ã€‚è¿™ç§åšæ³•å«åš**è®°å¿†åŒ–**ã€‚
- en: If the value of a variable at a given step depends on the results of previous
    calculations, and if the same calculations are repeated over and over, then it
    is convenient to store intermediate results so as to avoid repeating computationally
    expensive calculations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä¸€ä¸ªå˜é‡åœ¨æŸä¸€ç»™å®šæ­¥éª¤çš„å€¼ä¾èµ–äºä¹‹å‰è®¡ç®—çš„ç»“æœï¼Œå¹¶ä¸”è¿™äº›è®¡ç®—ä¼šè¢«é‡å¤å¤šæ¬¡ï¼Œé‚£ä¹ˆå­˜å‚¨ä¸­é—´ç»“æœå°±å˜å¾—éå¸¸æœ‰ç”¨ï¼Œä»è€Œé¿å…é‡å¤è®¡ç®—é‚£äº›è®¡ç®—æˆæœ¬é«˜æ˜‚çš„éƒ¨åˆ†ã€‚
- en: 'To better understand the difference between recursion and memoization, let''s
    analyze a simple example: the calculation of the factorial of a number. It is
    called factorial of a natural number n, indicated with *n!*, the product of positive
    integers less than or equal to that number. The calculation of the factorial of
    n is given by the following formula:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†æ›´å¥½åœ°ç†è§£é€’å½’å’Œè®°å¿†åŒ–ä¹‹é—´çš„åŒºåˆ«ï¼Œæˆ‘ä»¬æ¥åˆ†æä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼šè®¡ç®—ä¸€ä¸ªæ•°å­—çš„é˜¶ä¹˜ã€‚ä¸€ä¸ªè‡ªç„¶æ•°nçš„é˜¶ä¹˜ï¼Œè®°ä½œ*n!*ï¼Œæ˜¯å°äºæˆ–ç­‰äºè¯¥æ•°å­—çš„æ‰€æœ‰æ­£æ•´æ•°çš„ä¹˜ç§¯ã€‚nçš„é˜¶ä¹˜è®¡ç®—å…¬å¼å¦‚ä¸‹ï¼š
- en: '![](img/6c2795e7-8eef-4276-8325-fccbaf3ad1aa.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c2795e7-8eef-4276-8325-fccbaf3ad1aa.png)'
- en: 'The calculation of the factorial of a number can also be defined recursively:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªæ•°å­—çš„é˜¶ä¹˜ä¹Ÿå¯ä»¥é€šè¿‡é€’å½’æ¥å®šä¹‰ï¼š
- en: '![](img/68a097b4-8e80-4694-9e01-3ec25e5e14b2.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68a097b4-8e80-4694-9e01-3ec25e5e14b2.png)'
- en: 'A function is called **recursive** if it calls itself. The recursive function
    can directly solve only particular cases of a problem called base cases (such
    as those present in the previous formula): if it is invoked, passing some data
    that constitute one of the base cases, then it returns a result. At each call,
    the data is reduced, so at a certain point we arrive at one of the base cases.
    When the function calls itself, it suspends its execution to make the new call.
    The execution resumes when the internal call to itself ends. The sequence of recursive
    calls ends when the innermost one (nested) encounters one of the base cases. Now
    let''s see how to optimize this technique.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä¸€ä¸ªå‡½æ•°è°ƒç”¨è‡ªèº«ï¼Œåˆ™ç§°è¯¥å‡½æ•°ä¸º**é€’å½’**å‡½æ•°ã€‚é€’å½’å‡½æ•°åªèƒ½ç›´æ¥è§£å†³é—®é¢˜çš„æŸäº›ç‰¹å®šæƒ…å†µï¼Œè¿™äº›ç‰¹å®šæƒ…å†µç§°ä¸ºåŸºå‡†æƒ…å†µï¼ˆä¾‹å¦‚ä¹‹å‰å…¬å¼ä¸­çš„é‚£äº›æƒ…å†µï¼‰ï¼šå¦‚æœä¼ å…¥çš„æ•°æ®å±äºæŸä¸ªåŸºå‡†æƒ…å†µï¼Œå®ƒå°±è¿”å›ä¸€ä¸ªç»“æœã€‚åœ¨æ¯æ¬¡è°ƒç”¨æ—¶ï¼Œæ•°æ®éƒ½ä¼šå‡å°‘ï¼Œç›´åˆ°æŸä¸ªæ—¶åˆ»ï¼Œæˆ‘ä»¬åˆ°è¾¾äº†åŸºå‡†æƒ…å†µã€‚å½“å‡½æ•°è°ƒç”¨è‡ªèº«æ—¶ï¼Œå®ƒä¼šæš‚åœå½“å‰æ‰§è¡Œï¼Œå»æ‰§è¡Œæ–°çš„è°ƒç”¨ã€‚å†…éƒ¨è°ƒç”¨ç»“æŸåï¼Œæ‰§è¡Œä¼šæ¢å¤ã€‚é€’å½’è°ƒç”¨çš„åºåˆ—åœ¨æœ€å†…å±‚çš„è°ƒç”¨é‡åˆ°åŸºå‡†æƒ…å†µæ—¶ç»ˆæ­¢ã€‚ç°åœ¨è®©æˆ‘ä»¬çœ‹çœ‹å¦‚ä½•ä¼˜åŒ–è¿™ç§æŠ€æœ¯ã€‚
- en: Learning theÂ optimization techniques
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å­¦ä¹ ä¼˜åŒ–æŠ€æœ¯
- en: An optimization problem is a problem whose solution can be measured in terms
    of a cost function, also called an objective. The value to look for is normally
    the minimum value or the maximum value of this function. Optimization problems
    can be reduced to a sequence of decision problems.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ä¼˜åŒ–é—®é¢˜æ˜¯ä¸€ä¸ªå¯ä»¥é€šè¿‡æˆæœ¬å‡½æ•°ï¼ˆä¹Ÿå«åšç›®æ ‡å‡½æ•°ï¼‰æ¥è¡¡é‡å…¶è§£çš„é—®é¢˜ã€‚è¦å¯»æ‰¾çš„å€¼é€šå¸¸æ˜¯è¯¥å‡½æ•°çš„æœ€å°å€¼æˆ–æœ€å¤§å€¼ã€‚ä¼˜åŒ–é—®é¢˜å¯ä»¥è¢«ç®€åŒ–ä¸ºä¸€ç³»åˆ—çš„å†³ç­–é—®é¢˜ã€‚
- en: To solve an optimization problem it is necessary to use an iterative algorithm.
    That is a calculation program that, given a current approximation of the solution,
    determines a new approximationÂ with an appropriate sequence of operations. Starting
    from an initial approximation, a succession of possible solutions to the problem
    is thus determined.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: è¦è§£å†³ä¼˜åŒ–é—®é¢˜ï¼Œå¿…é¡»ä½¿ç”¨è¿­ä»£ç®—æ³•ã€‚å³ä¸€ç§è®¡ç®—ç¨‹åºï¼Œå®ƒåœ¨ç»™å®šå½“å‰è§£çš„è¿‘ä¼¼å€¼æ—¶ï¼Œé€šè¿‡é€‚å½“çš„æ“ä½œåºåˆ—æ¥ç¡®å®šä¸€ä¸ªæ–°çš„è¿‘ä¼¼å€¼ã€‚ä»ä¸€ä¸ªåˆå§‹è¿‘ä¼¼å€¼å¼€å§‹ï¼Œé—®é¢˜çš„å¯èƒ½è§£å°±ä»¥ä¸€ç§è¿ç»­çš„æ–¹å¼è¢«ç¡®å®šå‡ºæ¥ã€‚
- en: 'The search algorithms of the optimal solution can be classified into the following
    three classes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€ä¼˜è§£çš„æœç´¢ç®—æ³•å¯ä»¥åˆ†ä¸ºä»¥ä¸‹ä¸‰ç±»ï¼š
- en: '**Enumerative techniques**:Â Enumerative techniques look for the optimal solution
    in all the points of the domain of the function. Simplifications can come from
    reducing the problem to simpler subproblems. DPÂ is one of these techniques.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**åˆ—ä¸¾æŠ€æœ¯**ï¼šåˆ—ä¸¾æŠ€æœ¯é€šè¿‡éå†å‡½æ•°å®šä¹‰åŸŸå†…çš„æ‰€æœ‰ç‚¹æ¥å¯»æ‰¾æœ€ä¼˜è§£ã€‚é€šè¿‡å°†é—®é¢˜ç®€åŒ–ä¸ºæ›´ç®€å•çš„å­é—®é¢˜ï¼Œå¯ä»¥å‡å°‘é—®é¢˜çš„å¤æ‚æ€§ã€‚åŠ¨æ€è§„åˆ’ï¼ˆDPï¼‰å°±æ˜¯å…¶ä¸­çš„ä¸€ç§æŠ€æœ¯ã€‚'
- en: '**Numerical techniques**:Â These techniques optimize the problem by exploiting
    a set of necessary and sufficient conditions.Â These can be classified as direct
    and indirect. Indirect methods look for the least function by solving a set of
    non-linear functions and searching the solution iteratively until the gradient
    of the cost function is null. Direct methods make the gradient guide the search
    for the solution.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**æ•°å€¼æŠ€å·§**ï¼šè¿™äº›æŠ€å·§é€šè¿‡åˆ©ç”¨ä¸€ç»„å¿…è¦ä¸”å……åˆ†çš„æ¡ä»¶æ¥ä¼˜åŒ–é—®é¢˜ã€‚å®ƒä»¬å¯ä»¥åˆ†ä¸ºç›´æ¥æ–¹æ³•å’Œé—´æ¥æ–¹æ³•ã€‚é—´æ¥æ–¹æ³•é€šè¿‡æ±‚è§£ä¸€ç»„éçº¿æ€§æ–¹ç¨‹å¹¶è¿­ä»£åœ°å¯»æ‰¾è§£ï¼Œç›´åˆ°ä»£ä»·å‡½æ•°çš„æ¢¯åº¦ä¸ºé›¶ï¼Œæ¥å¯»æ‰¾æœ€å°å€¼ã€‚ç›´æ¥æ–¹æ³•åˆ™é€šè¿‡æ¢¯åº¦æŒ‡å¯¼æœç´¢è§£çš„è¿‡ç¨‹ã€‚'
- en: '**Probabilistic techniques**:Â Probabilistic techniques are based on enumerative
    techniques, but they use additional information to carry out the research and
    can be seen as evolutionary processes.Â This category includes the simulated annealing
    algorithm, which uses a thermodynamic evolutionary process, and the class of genetic
    algorithms, which exploit biological evolutionary techniques.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**æ¦‚ç‡æŠ€å·§**ï¼šæ¦‚ç‡æŠ€å·§åŸºäºæšä¸¾æŠ€æœ¯ï¼Œä½†å®ƒä»¬ä½¿ç”¨é¢å¤–çš„ä¿¡æ¯æ¥è¿›è¡Œç ”ç©¶ï¼Œå¯ä»¥çœ‹ä½œæ˜¯è¿›åŒ–è¿‡ç¨‹ã€‚è¿™ä¸€ç±»åŒ…æ‹¬æ¨¡æ‹Ÿé€€ç«ç®—æ³•ï¼Œå®ƒä½¿ç”¨çƒ­åŠ›å­¦è¿›åŒ–è¿‡ç¨‹ï¼Œä»¥åŠåŸºå› ç®—æ³•ç±»ï¼Œå®ƒä»¬åˆ©ç”¨ç”Ÿç‰©è¿›åŒ–æŠ€æœ¯ã€‚'
- en: In the next section, we will discuss these optimization techniques based on
    DP.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸‹ä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†è®¨è®ºåŸºäºåŠ¨æ€è§„åˆ’ï¼ˆDPï¼‰çš„ä¼˜åŒ–æŠ€æœ¯ã€‚
- en: Calculating the Fibonacci sequence
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: è®¡ç®—è´¹æ³¢é‚£å¥‘æ•°åˆ—
- en: 'Leonardo Pisano, also called Fibonacci, was a famous Italian mathematician
    (Pisa 1175 - 1240). His name is linked to the Fibonacci succession, which arose
    from a problem proposed by the Emperor Frederick II of Swabia. In Pisa in 1223
    in a tournament of mathematicians, he proposed the following problem: *How many
    pairs of rabbits are obtained in a year, excluding cases of death, supposing that
    each couple gives birth to another couple every month and that the youngest couples
    are able to reproduce already at the second month of life?*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ—å¥¥çº³å¤šÂ·çš®è¨è¯ºï¼Œä¹Ÿå«è´¹æ³¢é‚£å¥‘ï¼Œæ˜¯ä¸€ä½è‘—åçš„æ„å¤§åˆ©æ•°å­¦å®¶ï¼ˆçš®è¨ï¼Œ1175 - 1240ï¼‰ã€‚ä»–çš„åå­—ä¸è´¹æ³¢é‚£å¥‘æ•°åˆ—ç›¸å…³ï¼Œè¯¥æ•°åˆ—æºè‡ªæ–¯ç“¦æ¯”äºšçš‡å¸è…“ç‰¹çƒˆäºŒä¸–æå‡ºçš„ä¸€ä¸ªé—®é¢˜ã€‚1223å¹´ï¼Œåœ¨æ¯”è¨çš„æ•°å­¦å®¶æ¯”èµ›ä¸­ï¼Œä»–æå‡ºäº†å¦‚ä¸‹é—®é¢˜ï¼š*åœ¨ä¸è€ƒè™‘æ­»äº¡çš„æƒ…å†µä¸‹ï¼Œæ¯å¯¹å…”å­æ¯æœˆç”Ÿè‚²ä¸€å¯¹å…”å­ï¼Œä¸”æœ€å¹´è½»çš„å…”å­åœ¨ç”Ÿå‘½çš„ç¬¬äºŒä¸ªæœˆå°±èƒ½ç¹æ®–ï¼Œä¸€å¹´å†…èƒ½å¾—åˆ°å¤šå°‘å¯¹å…”å­ï¼Ÿ*
- en: 'Fibonacci gave such a quick answer to the test that someone thought the tournament
    was rigged:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: è´¹æ³¢é‚£å¥‘å¯¹æµ‹è¯•ç»™å‡ºäº†å¦‚æ­¤å¿«é€Ÿçš„å›ç­”ï¼Œä»¥è‡³äºæœ‰äººè®¤ä¸ºæ¯”èµ›æ˜¯ä½œå¼Šçš„ï¼š
- en: '![](img/c66e948b-867c-4e25-b839-a0f4eacfa772.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c66e948b-867c-4e25-b839-a0f4eacfa772.png)'
- en: 'Look at the series given here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: çœ‹çœ‹è¿™é‡Œç»™å‡ºçš„æ•°åˆ—ï¼š
- en: The first 2 elements are 1, 1.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å‰ä¸¤ä¸ªå…ƒç´ æ˜¯ 1, 1ã€‚
- en: Every other element is given by the sum of the two preceding it.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¯ä¸ªå…ƒç´ æ˜¯ç”±å‰ä¸¤ä¸ªå…ƒç´ ä¹‹å’Œç»™å‡ºçš„ã€‚
- en: 'Indicating with *F(n)*, the number of pairs present in month n, the Fibonacci
    sequence becomes the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ *F(n)* è¡¨ç¤ºç¬¬ n ä¸ªæœˆçš„å¯¹æ•°ï¼Œè´¹æ³¢é‚£å¥‘æ•°åˆ—å˜ä¸ºä»¥ä¸‹å½¢å¼ï¼š
- en: '*F(1) = 1*'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*F(1) = 1*'
- en: '*F(2) = 1*'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*F(2) = 1*'
- en: '*F(n) = F (n-1) + F (n-2)* in the *n*^(th) month, where *n*> 2'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*F(n) = F (n-1) + F (n-2)* åœ¨ç¬¬ *n* ä¸ªæœˆï¼Œå…¶ä¸­ *n*> 2'
- en: On the basis of this definition we conventionally assume *F(0) = 0*, so that
    the recursive relation *F(n) = F(n-1) + F(n-2)* is valid also for *n = 2*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: åŸºäºè¿™ä¸ªå®šä¹‰ï¼Œæˆ‘ä»¬é€šå¸¸å‡è®¾ *F(0) = 0*ï¼Œä»¥ä¾¿é€’å½’å…³ç³» *F(n) = F(n-1) + F(n-2)* åœ¨ *n = 2* æ—¶ä¹Ÿæˆç«‹ã€‚
- en: The Fibonacci succession has led us to study many areas of mathematics and natural
    sciences. However, despite having discovered this important succession, Fibonacci
    did not grasp many aspects of it. Four centuries later, Kepler observed that the
    relationship between two successive terms tended to the Golden Ratio.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: è´¹æ³¢é‚£å¥‘æ•°åˆ—ä¿ƒä½¿æˆ‘ä»¬ç ”ç©¶äº†æ•°å­¦å’Œè‡ªç„¶ç§‘å­¦çš„è®¸å¤šé¢†åŸŸã€‚ç„¶è€Œï¼Œå°½ç®¡å‘ç°äº†è¿™ä¸€é‡è¦æ•°åˆ—ï¼Œè´¹æ³¢é‚£å¥‘å¹¶æ²¡æœ‰æŒæ¡å®ƒçš„è®¸å¤šæ–¹é¢ã€‚å››ä¸ªä¸–çºªåï¼Œå¼€æ™®å‹’è§‚å¯Ÿåˆ°ï¼Œä¸¤ä¸ªè¿ç»­é¡¹ä¹‹é—´çš„å…³ç³»è¶‹å‘äºé»„é‡‘æ¯”ä¾‹ã€‚
- en: 'So let''s see a simple function in R that calculates the Fibonacci number through
    a recursive procedure:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆï¼Œæ¥çœ‹çœ‹ä¸€ä¸ªç®€å•çš„ R å‡½æ•°ï¼Œå®ƒé€šè¿‡é€’å½’è¿‡ç¨‹è®¡ç®—è´¹æ³¢é‚£å¥‘æ•°ï¼š
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Within the function, there is an `if` structure with two options: if `n> 2`
    the function calls itself when `n<=2` returns `1`. The call to `FibRec(n-1)` asks
    the function to solve a problem simpler than the initial one (the value is lower),
    but it is always the same problem. The function continues to call itself until
    it reaches the basic case that it can solve immediately. To compare two solution
    techniques, the `Sys.time()` function is used to calculate the computational cost.
    The results are shown as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å‡½æ•°å†…éƒ¨ï¼Œæœ‰ä¸€ä¸ª `if` ç»“æ„åŒ…å«ä¸¤ä¸ªé€‰é¡¹ï¼šå¦‚æœ `n> 2`ï¼Œå‡½æ•°ä¼šè°ƒç”¨è‡ªèº«ï¼›å½“ `n<=2` æ—¶è¿”å› `1`ã€‚å¯¹ `FibRec(n-1)` çš„è°ƒç”¨è¦æ±‚å‡½æ•°è§£å†³æ¯”æœ€åˆé—®é¢˜æ›´ç®€å•çš„é—®é¢˜ï¼ˆæ•°å€¼è¾ƒå°ï¼‰ï¼Œä½†é—®é¢˜å§‹ç»ˆæ˜¯ç›¸åŒçš„ã€‚å‡½æ•°ä¼šä¸€ç›´è°ƒç”¨è‡ªèº«ï¼Œç›´åˆ°è¾¾åˆ°å®ƒå¯ä»¥ç«‹å³è§£å†³çš„åŸºæœ¬æƒ…å†µã€‚ä¸ºäº†æ¯”è¾ƒä¸¤ç§è§£å†³æŠ€æœ¯ï¼Œä½¿ç”¨
    `Sys.time()` å‡½æ•°æ¥è®¡ç®—è®¡ç®—æˆæœ¬ã€‚ç»“æœå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This program, given the nature of the recursive algorithm used, requires n +
    1 invocations of the factorial function to arrive at a result, and each of these
    invocations, in turn, has a cost associated with the time taken by the function
    to return the calculated value.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºä½¿ç”¨çš„é€’å½’ç®—æ³•çš„æ€§è´¨ï¼Œè¯¥ç¨‹åºéœ€è¦è¿›è¡Œ n + 1 æ¬¡é˜¶ä¹˜å‡½æ•°è°ƒç”¨æ‰èƒ½å¾—åˆ°ç»“æœï¼Œå¹¶ä¸”æ¯æ¬¡è°ƒç”¨éƒ½ä¼´éšç€ä¸å‡½æ•°è¿”å›è®¡ç®—å€¼æ‰€éœ€æ—¶é—´ç›¸å…³çš„æˆæœ¬ã€‚
- en: 'This program can be improved through memoization as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡è®°å¿†åŒ–ï¼Œå¯ä»¥æŒ‰å¦‚ä¸‹æ–¹å¼æ”¹è¿›è¯¥ç¨‹åºï¼š
- en: Create a variable to store temporary results (`RecTable`).
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: åˆ›å»ºä¸€ä¸ªå˜é‡æ¥å­˜å‚¨ä¸´æ—¶ç»“æœï¼ˆ`RecTable`ï¼‰ã€‚
- en: Before performing a calculation, find out if the calculation has already been
    done. If so, use the stored result.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: åœ¨è¿›è¡Œè®¡ç®—ä¹‹å‰ï¼Œå…ˆæ£€æŸ¥è¯¥è®¡ç®—æ˜¯å¦å·²ç»å®Œæˆã€‚å¦‚æœå®Œæˆäº†ï¼Œåˆ™ä½¿ç”¨å­˜å‚¨çš„ç»“æœã€‚
- en: If we are calculating this for the first time, store the results for future
    use.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å¦‚æœè¿™æ˜¯ç¬¬ä¸€æ¬¡è®¡ç®—ï¼Œå­˜å‚¨ç»“æœä»¥å¤‡å°†æ¥ä½¿ç”¨ã€‚
- en: 'A memoized version of the program is shown in the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹ä»£ç å±•ç¤ºäº†ç¨‹åºçš„è®°å¿†åŒ–ç‰ˆæœ¬ï¼š
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this case, we store the Fibonacci numbers in a table that can then be retrieved
    for the next calculation. In this way, the entire calculation is avoided at each
    occurrence. Memoization increases the efficiency of a function in terms of time.
    The improvement is highlighted as often as this function is called, thus determining
    an acceleration of the algorithm. Here are the results:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°†æ–æ³¢é‚£å¥‘æ•°å­˜å‚¨åœ¨ä¸€ä¸ªè¡¨ä¸­ï¼Œä¹‹åå¯ä»¥åœ¨ä¸‹ä¸€æ¬¡è®¡ç®—æ—¶æ£€ç´¢ã€‚è¿™æ ·ï¼Œé¿å…äº†æ¯æ¬¡éƒ½è¿›è¡Œæ•´ä¸ªè®¡ç®—ã€‚è®°å¿†åŒ–æé«˜äº†å‡½æ•°çš„æ—¶é—´æ•ˆç‡ã€‚æ¯æ¬¡è¯¥å‡½æ•°è¢«è°ƒç”¨æ—¶ï¼Œéƒ½ä¼šçªå‡ºæ”¹è¿›ï¼Œä»è€ŒåŠ é€Ÿäº†ç®—æ³•ã€‚ä»¥ä¸‹æ˜¯ç»“æœï¼š
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: From the comparison between the two computational costs, it is possible to notice
    that the version with memoization is faster. Now let's see how to use the potential
    offered by DP in the context of reinforcement learning.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡æ¯”è¾ƒä¸¤ç§è®¡ç®—æˆæœ¬ï¼Œå¯ä»¥å‘ç°å¸¦æœ‰è®°å¿†åŒ–çš„ç‰ˆæœ¬æ›´å¿«ã€‚ç°åœ¨è®©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹å¦‚ä½•åœ¨å¼ºåŒ–å­¦ä¹ çš„èƒŒæ™¯ä¸‹åˆ©ç”¨ DP æä¾›çš„æ½œåŠ›ã€‚
- en: Implementing DPÂ in reinforcement learning applications
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: åœ¨å¼ºåŒ–å­¦ä¹ åº”ç”¨ä¸­å®ç° DP
- en: DP represents a set of algorithms that can be used to calculate an optimal policy
    given a perfect model of the environment in the form of an MDP. The fundamental
    idea of DP, as well as reinforcement learning in general, is using state values
    and actions to look for good policies.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: DP ä»£è¡¨ä¸€ç»„ç®—æ³•ï¼Œå¯ç”¨äºåœ¨ç¯å¢ƒçš„å®Œç¾æ¨¡å‹ï¼ˆä»¥ MDP å½¢å¼ï¼‰ä¸‹è®¡ç®—æœ€ä¼˜ç­–ç•¥ã€‚DP çš„åŸºæœ¬æ€æƒ³ï¼Œä»¥åŠå¼ºåŒ–å­¦ä¹ çš„ä¸€èˆ¬æ€æƒ³ï¼Œæ˜¯åˆ©ç”¨çŠ¶æ€å€¼å’ŒåŠ¨ä½œæ¥å¯»æ‰¾è‰¯å¥½çš„ç­–ç•¥ã€‚
- en: 'The DP methods approach the resolution of Markov decision-making processes
    through the iteration of two processes called **policy evaluation** and **policy
    improvement**:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: DP æ–¹æ³•é€šè¿‡è¿­ä»£ä¸¤ä¸ªè¿‡ç¨‹æ¥è§£å†³é©¬å°”å¯å¤«å†³ç­–è¿‡ç¨‹ï¼Œåˆ†åˆ«æ˜¯ **ç­–ç•¥è¯„ä¼°** å’Œ **ç­–ç•¥æ”¹è¿›**ï¼š
- en: Policy evaluation algorithm consists of applying an iterative method to the
    resolution of the Bellman equation. Since convergence is guaranteed to us only
    for k â†’ âˆ, we must be content to have good approximations by imposing a stopping
    condition.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç­–ç•¥è¯„ä¼°ç®—æ³•é€šè¿‡åº”ç”¨è¿­ä»£æ–¹æ³•æ¥æ±‚è§£è´å°”æ›¼æ–¹ç¨‹ã€‚ç”±äºåªæœ‰å½“ k â†’ âˆ æ—¶æ”¶æ•›æ‰æœ‰ä¿éšœï¼Œæˆ‘ä»¬å¿…é¡»æ»¡è¶³äºé€šè¿‡è®¾ç½®åœæ­¢æ¡ä»¶å¾—åˆ°è‰¯å¥½çš„è¿‘ä¼¼ã€‚
- en: Policy improvement algorithm improves the policy based on current values.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç­–ç•¥æ”¹è¿›ç®—æ³•åŸºäºå½“å‰å€¼æ¥æ”¹è¿›ç­–ç•¥ã€‚
- en: A disadvantage of the policy iteration algorithm is that in every step we have
    to evaluate a policy. This involves an iterative process that we do not knowÂ the
    time of convergence ofÂ a priori, which will depend on how the starting policy
    was chosen.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ç­–ç•¥è¿­ä»£ç®—æ³•çš„ä¸€ä¸ªç¼ºç‚¹æ˜¯æ¯ä¸€æ­¥éƒ½éœ€è¦è¯„ä¼°ä¸€ä¸ªç­–ç•¥ã€‚è¿™æ¶‰åŠåˆ°ä¸€ä¸ªè¿­ä»£è¿‡ç¨‹ï¼Œæˆ‘ä»¬äº‹å…ˆå¹¶ä¸çŸ¥é“å®ƒçš„æ”¶æ•›æ—¶é—´ï¼Œè¿™å°†å–å†³äºèµ·å§‹ç­–ç•¥æ˜¯å¦‚ä½•é€‰æ‹©çš„ã€‚
- en: One way to overcome this drawback is to cut off the evaluation of the policy
    at a specific step. This operation does not change the guarantee of convergence
    to the optimal value. A special case in which the assessment of the policy is
    blockedÂ step by stepÂ (also called sweep) defines the value iteration algorithm.
    In the value iteration algorithm, a single iteration of calculation of the values
    is performed between each step of the policy improvement.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: å…‹æœè¿™ä¸€ç¼ºç‚¹çš„ä¸€ç§æ–¹æ³•æ˜¯ï¼Œåœ¨ç‰¹å®šæ­¥éª¤ä¸­åˆ‡æ–­ç­–ç•¥çš„è¯„ä¼°ã€‚è¿™ä¸€æ“ä½œä¸ä¼šæ”¹å˜æ”¶æ•›åˆ°æœ€ä¼˜å€¼çš„ä¿è¯ã€‚åœ¨ç­–ç•¥è¯„ä¼°è¢«é€æ­¥é˜»æ–­ï¼ˆä¹Ÿå«åšéå†ï¼‰çš„ç‰¹æ®Šæƒ…å†µä¸‹ï¼Œå®šä¹‰äº†å€¼è¿­ä»£ç®—æ³•ã€‚åœ¨å€¼è¿­ä»£ç®—æ³•ä¸­ï¼Œæ¯æ¬¡æ”¿ç­–æ”¹è¿›æ­¥éª¤ä¹‹é—´éƒ½ä¼šæ‰§è¡Œä¸€æ¬¡å€¼è®¡ç®—çš„è¿­ä»£ã€‚
- en: The DP algorithms are therefore essentially based on policy evaluation and policy
    improvement that take place in parallel. The repeated execution of these two processes
    makes the general process converge towards the optimal solution. In the policy
    iteration algorithm, the two phases alternate and each ends before the other begins.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼ŒDP ç®—æ³•æœ¬è´¨ä¸Šæ˜¯åŸºäºç­–ç•¥è¯„ä¼°å’Œç­–ç•¥æ”¹è¿›ï¼Œè¿™ä¸¤ä¸ªè¿‡ç¨‹å¹¶è¡Œè¿›è¡Œã€‚åå¤æ‰§è¡Œè¿™ä¸¤ä¸ªè¿‡ç¨‹ä½¿å¾—æ•´ä¸ªè¿‡ç¨‹è¶‹å‘äºæœ€ä¼˜è§£ã€‚åœ¨ç­–ç•¥è¿­ä»£ç®—æ³•ä¸­ï¼Œè¿™ä¸¤ä¸ªé˜¶æ®µäº¤æ›¿è¿›è¡Œï¼Œä¸”æ¯ä¸ªé˜¶æ®µç»“æŸåæ‰å¼€å§‹ä¸‹ä¸€ä¸ªé˜¶æ®µã€‚
- en: The DP methods operate through the entire set of states that can be assumed
    by the environment, performing a complete backup for each state at each iteration.
    Each update operation performed by the backup updates the value of a status based
    on the values â€‹â€‹of all possible successor states. These states are weighed for
    their probability of occurrence, induced by the policy of choice and by the dynamics
    of the environment. Full backups are closely related to the Bellman equation,
    they are nothing more than the transformation of the equation into assignment
    instructions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: DP æ–¹æ³•é€šè¿‡ç¯å¢ƒä¸­æ‰€æœ‰å¯èƒ½çš„çŠ¶æ€é›†è¿›è¡Œæ“ä½œï¼Œåœ¨æ¯æ¬¡è¿­ä»£æ—¶å¯¹æ¯ä¸ªçŠ¶æ€æ‰§è¡Œå®Œæ•´çš„å¤‡ä»½æ“ä½œã€‚æ¯æ¬¡å¤‡ä»½æ“ä½œéƒ½æ ¹æ®æ‰€æœ‰å¯èƒ½çš„åç»§çŠ¶æ€çš„å€¼æ›´æ–°ä¸€ä¸ªçŠ¶æ€çš„å€¼ã€‚è¿™äº›çŠ¶æ€ä¼šæ ¹æ®å®ƒä»¬å‘ç”Ÿçš„æ¦‚ç‡è¿›è¡ŒåŠ æƒï¼Œè¿™ä¸ªæ¦‚ç‡ç”±ç­–ç•¥é€‰æ‹©å’Œç¯å¢ƒçš„åŠ¨æ€æ€§å…±åŒå†³å®šã€‚å®Œæ•´å¤‡ä»½ä¸è´å°”æ›¼æ–¹ç¨‹å¯†åˆ‡ç›¸å…³ï¼Œå®ƒä»¬ä¸è¿‡æ˜¯å°†è´å°”æ›¼æ–¹ç¨‹è½¬åŒ–ä¸ºèµ‹å€¼æŒ‡ä»¤çš„è¿‡ç¨‹ã€‚
- en: When a complete backup iteration does not bring any change to the state values,
    convergence is obtained and therefore the final state values â€‹â€‹fully satisfy the
    Bellman equation. The DP methods are applicable only if there is a perfect model
    of the alternator, which must be equivalent to an MDP.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ä¸€æ¬¡å®Œæ•´çš„å¤‡ä»½è¿­ä»£æ²¡æœ‰å¯¹çŠ¶æ€å€¼äº§ç”Ÿä»»ä½•å˜åŒ–æ—¶ï¼Œæ”¶æ•›å°±è¾¾æˆï¼Œå› æ­¤æœ€ç»ˆçš„çŠ¶æ€å€¼å®Œå…¨æ»¡è¶³è´å°”æ›¼æ–¹ç¨‹ã€‚DP æ–¹æ³•ä»…åœ¨å­˜åœ¨å®Œç¾çš„äº¤æ›¿å™¨æ¨¡å‹æ—¶é€‚ç”¨ï¼Œè¯¥æ¨¡å‹å¿…é¡»ç­‰åŒäºé©¬å°”å¯å¤«å†³ç­–è¿‡ç¨‹ï¼ˆMDPï¼‰ã€‚
- en: Precisely for this reason, the DP algorithms are of little use in reinforcement
    learning, both for their assumption of a perfect model of the environment and
    for the high and expensive computation. But it is still opportune to mention them
    because they represent the theoretical basis of reinforcement learning. In fact,
    all the methods of reinforcement learning try to achieve the same goal of the
    DP methods, only with lower computational cost and without the assumption of a
    perfect model of the environment.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£æ˜¯ç”±äºè¿™ä¸ªåŸå› ï¼ŒDP ç®—æ³•åœ¨å¼ºåŒ–å­¦ä¹ ä¸­çš„åº”ç”¨æœ‰é™ï¼Œæ—¢å› ä¸ºå®ƒå‡è®¾ç¯å¢ƒæœ‰å®Œç¾æ¨¡å‹ï¼Œåˆå› ä¸ºè®¡ç®—é‡é«˜ä¸”æ˜‚è´µã€‚ä½†ä»ç„¶æœ‰å¿…è¦æåŠå®ƒä»¬ï¼Œå› ä¸ºå®ƒä»¬ä»£è¡¨äº†å¼ºåŒ–å­¦ä¹ çš„ç†è®ºåŸºç¡€ã€‚äº‹å®ä¸Šï¼Œæ‰€æœ‰å¼ºåŒ–å­¦ä¹ æ–¹æ³•éƒ½è¯•å›¾è¾¾åˆ°
    DP æ–¹æ³•çš„åŒæ ·ç›®æ ‡ï¼Œåªæ˜¯è®¡ç®—æˆæœ¬è¾ƒä½ï¼Œå¹¶ä¸”ä¸å‡è®¾ç¯å¢ƒæœ‰å®Œç¾çš„æ¨¡å‹ã€‚
- en: The DP methods converge to the optimal solution with a number of polynomial
    operations with respect to the number of states ğ‘› and actions ğ‘š against the number
    of exponential operations ğ‘š*ğ‘› required by methods based on direct search.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: DP æ–¹æ³•é€šè¿‡ä¸çŠ¶æ€æ•° ğ‘› å’ŒåŠ¨ä½œæ•° ğ‘š ç›¸æ¯”çš„å¤šé¡¹å¼æ“ä½œæ¬¡æ•°ï¼Œæ”¶æ•›åˆ°æœ€ä¼˜è§£ï¼Œè€Œä¸ä¹‹ç›¸å¯¹çš„æ˜¯åŸºäºç›´æ¥æœç´¢çš„æ–¹æ³•éœ€è¦ ğ‘š*ğ‘› çš„æŒ‡æ•°æ“ä½œæ¬¡æ•°ã€‚
- en: DP methods update the estimates of the state values on the basis of the estimates
    made in the previous steps.Â This represents a special property, which is called
    bootstrapping. Several methods of RL perform bootstrapping, even methods that
    do not require a perfect model of the environment, as required by the DP methods.
    Let's see a practical case of using DP.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: DP æ–¹æ³•åŸºäºå…ˆå‰æ­¥éª¤ä¸­åšå‡ºçš„ä¼°è®¡ï¼Œæ›´æ–°çŠ¶æ€å€¼çš„ä¼°ç®—ã€‚è¿™ä»£è¡¨äº†ä¸€ç§ç‰¹æ®Šçš„å±æ€§ï¼Œç§°ä¸ºè‡ªä¸¾ï¼ˆbootstrappingï¼‰ã€‚å¤šç§å¼ºåŒ–å­¦ä¹ æ–¹æ³•æ‰§è¡Œè‡ªä¸¾ï¼Œå³ä¾¿æ˜¯é‚£äº›ä¸è¦æ±‚ç¯å¢ƒçš„å®Œç¾æ¨¡å‹ï¼ˆå¦‚
    DP æ–¹æ³•æ‰€éœ€çš„ï¼‰ï¼Œä¹ŸåŒæ ·æ‰§è¡Œè‡ªä¸¾ã€‚æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªä½¿ç”¨ DP çš„å®é™…æ¡ˆä¾‹ã€‚
- en: Solving the knapsack problem
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ±‚è§£èƒŒåŒ…é—®é¢˜
- en: In this section, we will analyze a classic problem that's been studied for more
    than a century, since 1897â€”the knapsack problem. The first to deal with the knapsack
    problem was the mathematician Tobias Dantzig who gave it the name deriving it
    from the common problem of packing the most useful items without overloading the
    knapsack.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†åˆ†æä¸€ä¸ªç»è¿‡è¶…è¿‡ä¸€ä¸ªä¸–çºªç ”ç©¶çš„ç»å…¸é—®é¢˜ï¼Œè‡ª1897å¹´ä»¥æ¥â€”èƒŒåŒ…é—®é¢˜ã€‚é¦–ä½å¤„ç†èƒŒåŒ…é—®é¢˜çš„æ˜¯æ•°å­¦å®¶æ‰˜æ¯”äºšæ–¯Â·ä¸¹é½æ ¼ï¼Œä»–å°†å…¶å‘½åä¸ºæºè‡ªæ™®é€šçš„è£…è½½æœ€æœ‰ç”¨ç‰©å“è€Œä¸è¿‡è½½èƒŒåŒ…çš„é—®é¢˜ã€‚
- en: 'A problem of this type can be associated with different situations arising
    from real life. To better characterize the problem, we will propose a rather unique
    one: a thief goes into a house and wants to steal valuables. He puts them in his
    knapsack, but is bound by weight. Each object has its own value and weight, so
    he must choose the objects that are of high value but not high weight. It must
    not exceed the weight limit in the knapsack, but at the same time optimize the
    value.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§ç±»å‹çš„é—®é¢˜å¯ä»¥ä¸ç°å®ç”Ÿæ´»ä¸­ä¸åŒæƒ…å†µè”ç³»èµ·æ¥ã€‚ä¸ºäº†æ›´å¥½åœ°æè¿°è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å°†æå‡ºä¸€ä¸ªéå¸¸ç‹¬ç‰¹çš„æƒ…æ™¯ï¼šä¸€ä¸ªå°å·è¿›å…¥æˆ¿å­å¹¶æƒ³å·èµ°è´µé‡ç‰©å“ã€‚ä»–æŠŠå®ƒä»¬æ”¾åœ¨ä»–çš„èƒŒåŒ…é‡Œï¼Œä½†å—åˆ°é‡é‡çš„é™åˆ¶ã€‚æ¯ä¸ªç‰©ä½“éƒ½æœ‰è‡ªå·±çš„ä»·å€¼å’Œé‡é‡ï¼Œæ‰€ä»¥ä»–å¿…é¡»é€‰æ‹©ä»·å€¼é«˜ä½†é‡é‡ä¸å¤§çš„ç‰©å“ã€‚ä¸èƒ½è¶…è¿‡èƒŒåŒ…çš„é‡é‡é™åˆ¶ï¼Œä½†åŒæ—¶åˆè¦ä¼˜åŒ–ä»·å€¼ã€‚
- en: 'Now, we will address the problem from a mathematical point of view. Suppose
    we have a set X composed of n objects labeled with integers from 1 to *n*: {1,
    2, ..., *n*}. These objects meet the following conditions:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬å°†ä»æ•°å­¦çš„è§’åº¦è§£å†³è¿™ä¸ªé—®é¢˜ã€‚å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªç”±æ•´æ•°æ ‡è®°ä¸º1åˆ°*n*çš„nä¸ªå¯¹è±¡ç»„æˆçš„é›†åˆXï¼š{1, 2, ..., *n*}ã€‚è¿™äº›å¯¹è±¡æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š
- en: The *i*^(th) object has a weight *p[i]* and value *v[i]*.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç¬¬iä¸ªç‰©å“å…·æœ‰é‡é‡p[i]å’Œä»·å€¼v[i]ã€‚
- en: There is only one instance of each object.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¯ä¸ªç‰©ä½“åªæœ‰ä¸€ä¸ªå®ä¾‹ã€‚
- en: 'We have a container able to carry at most a weight equal to P. We want to determine
    a subset Y âŠ† X of objects:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æœ‰ä¸€ä¸ªå®¹å™¨ï¼Œæœ€å¤šå¯ä»¥æºå¸¦é‡é‡ä¸ºPçš„ç‰©å“ã€‚æˆ‘ä»¬æƒ³ç¡®å®šå¯¹è±¡çš„å­é›†Y âŠ† Xï¼š
- en: The total weight of the objects in Y is â‰¤ P.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yä¸­ç‰©å“çš„æ€»é‡é‡â‰¤ Pã€‚
- en: The total value of the objects in Y is the maximum possible.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yä¸­ç‰©å“çš„æ€»ä»·å€¼æ˜¯å¯èƒ½çš„æœ€å¤§å€¼ã€‚
- en: 'These two conditions in mathematical formalism take the following form:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸¤ä¸ªæ•°å­¦å½¢å¼ä¸­çš„æ¡ä»¶å¦‚ä¸‹ï¼š
- en: 'We want to determine a subset Y âŠ† X of objects so that:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¸Œæœ›ç¡®å®šä¸€ä¸ªå¯¹è±¡çš„å­é›†Y âŠ† Xï¼Œä»¥ä¾¿ï¼š
- en: '![](img/bd3ae9bc-72ff-4ab3-a500-4520fd52432d.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd3ae9bc-72ff-4ab3-a500-4520fd52432d.png)'
- en: 'To maximize the following overall value:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸ºäº†æœ€å¤§åŒ–ä»¥ä¸‹æ€»ä»·å€¼ï¼š
- en: '![](img/c4604c6c-d216-4a30-93ad-9152c363f5ef.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c4604c6c-d216-4a30-93ad-9152c363f5ef.png)'
- en: 'As it has been placed, this is an optimization problem. In general, an optimization
    problem has two parts:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æ‰€æ”¾ç½®çš„é‚£æ ·ï¼Œè¿™æ˜¯ä¸€ä¸ªä¼˜åŒ–é—®é¢˜ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œä¼˜åŒ–é—®é¢˜æœ‰ä¸¤ä¸ªéƒ¨åˆ†ï¼š
- en: A set of constraints (possibly empty) that must be respected.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ç»„å¿…é¡»éµå®ˆçš„çº¦æŸï¼ˆå¯èƒ½ä¸ºç©ºï¼‰ã€‚
- en: An objective function that must be maximized or minimized.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¿…é¡»æœ€å¤§åŒ–æˆ–æœ€å°åŒ–çš„ç›®æ ‡å‡½æ•°ã€‚
- en: The mathematical formalism that we have adopted to define the problem unequivocally
    clarifies the two parts we've just mentioned. Many real problems can be formulated
    relatively simply as optimization problems that can then be solved with a calculator.
    Reducing a new problem to a known problem allows the use of existing solutions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»é‡‡ç”¨çš„æ•°å­¦å½¢å¼å®šä¹‰é—®é¢˜ï¼Œæ˜ç¡®æ¾„æ¸…äº†æˆ‘ä»¬åˆšæ‰æåˆ°çš„ä¸¤éƒ¨åˆ†ã€‚è®¸å¤šå®é™…é—®é¢˜å¯ä»¥ç›¸å¯¹ç®€å•åœ°è¢«è¡¨è¿°ä¸ºå¯ä»¥ä½¿ç”¨è®¡ç®—å™¨è§£å†³çš„ä¼˜åŒ–é—®é¢˜ã€‚å°†æ–°é—®é¢˜ç®€åŒ–ä¸ºå·²çŸ¥é—®é¢˜å…è®¸ä½¿ç”¨ç°æœ‰çš„è§£å†³æ–¹æ¡ˆã€‚
- en: As with most of the problems, even for optimization problems, there are different
    approaches to the problem that allow us to reach the solution. Naturally, they
    differ in the complexity of each algorithm in terms of time and memory requirements
    and in terms of programming efforts required.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¤§å¤šæ•°é—®é¢˜ä¸€æ ·ï¼Œå³ä½¿å¯¹äºä¼˜åŒ–é—®é¢˜ï¼Œè§£å†³é—®é¢˜çš„ä¸åŒæ–¹æ³•ä¹Ÿå…è®¸æˆ‘ä»¬è¾¾åˆ°è§£å†³æ–¹æ¡ˆã€‚å®ƒä»¬åœ¨æ—¶é—´å’Œå†…å­˜è¦æ±‚çš„å¤æ‚æ€§ä»¥åŠæ‰€éœ€çš„ç¼–ç¨‹å·¥ä½œæ–¹é¢è‡ªç„¶æœ‰æ‰€ä¸åŒã€‚
- en: 'There are two versions of the problem:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰ä¸¤ä¸ªé—®é¢˜çš„ç‰ˆæœ¬ï¼š
- en: '**0-1 knapsack problem**: Each item must be entirely accepted or rejected.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**0-1èƒŒåŒ…é—®é¢˜**ï¼šæ¯ä¸ªç‰©å“è¦ä¹ˆå…¨éƒ¨æ¥å—ï¼Œè¦ä¹ˆå…¨éƒ¨æ‹’ç»ã€‚'
- en: '**Fractional knapsack problem**: We can take fractions of items.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**åˆ†æ•°èƒŒåŒ…é—®é¢˜**ï¼šæˆ‘ä»¬å¯ä»¥å–ç‰©å“çš„åˆ†æ•°éƒ¨åˆ†ã€‚'
- en: The substantial difference between the two problems lies in the possibility
    of splitting the items. In the 0-1 knapsack problem, we cannot divide the articles.
    On the contrary, in the fractional knapsack, we can divide the objects to maximize
    the total value of the backpack.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸¤ä¸ªé—®é¢˜ä¹‹é—´çš„å®è´¨å·®å¼‚åœ¨äºç‰©å“æ˜¯å¦å¯ä»¥åˆ†å‰²ã€‚åœ¨0-1èƒŒåŒ…é—®é¢˜ä¸­ï¼Œæˆ‘ä»¬ä¸èƒ½åˆ†å‰²ç‰©å“ã€‚ç›¸åï¼Œåœ¨åˆ†æ•°èƒŒåŒ…ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥åˆ†å‰²ç‰©ä½“ä»¥æœ€å¤§åŒ–èƒŒåŒ…çš„æ€»ä»·å€¼ã€‚
- en: The problem of the knapsack that we have introduced can be easily applied to
    a problem of optimization of a financial portfolio. In fact, it is sufficient
    to associate the weight of the objects with the weight of the risk of the financial
    product we are considering and the value of the objects with the expected value
    of the financial product. Based on these assumptions, it is possible to select
    financial products that maximize the expected value, keeping the risk below a
    specific value.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä»‹ç»çš„èƒŒåŒ…é—®é¢˜å¯ä»¥å¾ˆå®¹æ˜“åœ°åº”ç”¨äºé‡‘èæŠ•èµ„ç»„åˆä¼˜åŒ–é—®é¢˜ã€‚å®é™…ä¸Šï¼Œåªéœ€å°†ç‰©ä½“çš„é‡é‡ä¸è€ƒè™‘ä¸­çš„é‡‘èäº§å“çš„é£é™©æƒé‡ç›¸å…³è”ï¼Œå°†ç‰©ä½“çš„ä»·å€¼ä¸é‡‘èäº§å“çš„é¢„æœŸä»·å€¼ç›¸å…³è”å³å¯ã€‚åŸºäºè¿™äº›å‡è®¾ï¼Œå¯ä»¥é€‰æ‹©ä½¿é¢„æœŸä»·å€¼æœ€å¤§åŒ–ï¼Œå¹¶å°†é£é™©ä¿æŒåœ¨ç‰¹å®šå€¼ä»¥ä¸‹çš„é‡‘èäº§å“ã€‚
- en: 'In the following sections, we will address the knapsack problem through three
    different approaches:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ¥ä¸‹æ¥çš„éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†é€šè¿‡ä¸‰ç§ä¸åŒçš„æ–¹æ³•è§£å†³èƒŒåŒ…é—®é¢˜ï¼š
- en: Brute force
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æš´åŠ›ç®—æ³•
- en: Greedy algorithms
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è´ªå©ªç®—æ³•
- en: DP
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DP
- en: We will try to go into each solution inÂ depth, highlighting their strengths
    and weaknesses.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†æ·±å…¥æ¢è®¨æ¯ä¸ªè§£å†³æ–¹æ¡ˆï¼Œçªå‡ºå®ƒä»¬çš„ä¼˜ç¼ºç‚¹ã€‚
- en: Brute force
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æš´åŠ›ç®—æ³•
- en: Brute force lists all the possible values that could represent a solution and
    checks whether each value satisfies the conditions imposed by the problem.Â This
    algorithm is easily implemented and always returns a solution if it exists, but
    its cost is proportional to the number of possible solutions. Therefore, brute
    force research is typically used when the size of the problem is limited or when
    hypotheses are available that allow us to reduce the set of possible solutions.
    The method is also used when the simplicity of implementation is more important
    than speed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: æš´åŠ›ç®—æ³•åˆ—å‡ºäº†å¯èƒ½è¡¨ç¤ºè§£å†³æ–¹æ¡ˆçš„æ‰€æœ‰å¯èƒ½å€¼ï¼Œå¹¶æ£€æŸ¥æ¯ä¸ªå€¼æ˜¯å¦æ»¡è¶³é—®é¢˜æ‰€æ–½åŠ çš„æ¡ä»¶ã€‚æ­¤ç®—æ³•æ˜“äºå®ç°ï¼Œå¦‚æœå­˜åœ¨è§£å†³æ–¹æ¡ˆï¼Œåˆ™æ€»æ˜¯è¿”å›è§£å†³æ–¹æ¡ˆï¼Œä½†å…¶æˆæœ¬ä¸å¯èƒ½è§£çš„æ•°é‡æˆæ­£æ¯”ã€‚å› æ­¤ï¼Œé€šå¸¸åœ¨é—®é¢˜è§„æ¨¡æœ‰é™æˆ–å­˜åœ¨å¯ä»¥å‡å°‘å¯èƒ½è§£é›†çš„å‡è®¾æ—¶ä½¿ç”¨æš´åŠ›æœç´¢ã€‚è¯¥æ–¹æ³•ä¹Ÿç”¨äºåœ¨å®ç°ç®€å•æ€§æ¯”é€Ÿåº¦æ›´é‡è¦æ—¶ã€‚
- en: 'To solve the knapsack problem, brute force is the most immediate solution:
    examine all the possible ways to fill the knapsack, which are *2n*, and print
    an optimal solution (there could be more than one). This approach, for *n* > 15,
    becomes very slow. This algorithm is usually based directly on the definition
    of the problem and on the understandingÂ of the concepts involved.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: è¦è§£å†³èƒŒåŒ…é—®é¢˜ï¼Œæš´åŠ›ç®—æ³•æ˜¯æœ€ç›´æ¥çš„è§£å†³æ–¹æ¡ˆï¼šæ£€æŸ¥å¡«å……èƒŒåŒ…çš„æ‰€æœ‰å¯èƒ½æ–¹æ³•ï¼Œè¿™äº›æ–¹æ³•æœ‰*2n*ç§ï¼Œå¹¶æ‰“å°å‡ºä¸€ä¸ªæœ€ä¼˜è§£ï¼ˆå¯èƒ½ä¸æ­¢ä¸€ä¸ªï¼‰ã€‚å¯¹äº*n* > 15ï¼Œè¿™ç§æ–¹æ³•å˜å¾—éå¸¸æ…¢ã€‚è¿™ç§ç®—æ³•é€šå¸¸ç›´æ¥åŸºäºé—®é¢˜çš„å®šä¹‰å’Œç›¸å…³æ¦‚å¿µçš„ç†è§£ã€‚
- en: 'Here are the essentials of this straightforward algorithm:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯è¿™ä¸ªç®€å•ç®—æ³•çš„è¦ç‚¹ï¼š
- en: Enumerates every possible combination.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æšä¸¾æ¯ç§å¯èƒ½çš„ç»„åˆã€‚
- en: Choose the best solution (all the combinations are examined, and the one with
    the maximum value and with a total weight less than or equal to PÂ is returned).
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: é€‰æ‹©æœ€ä½³è§£å†³æ–¹æ¡ˆï¼ˆæ£€æŸ¥æ‰€æœ‰ç»„åˆï¼Œè¿”å›æœ€å¤§å€¼ä¸”æ€»é‡é‡å°äºæˆ–ç­‰äºPçš„ç»„åˆï¼‰ã€‚
- en: Optimality is ensured.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¼˜åŒ–æ€§å¾—åˆ°ä¿è¯ã€‚
- en: Extremely costly in time for large *n*. Running time will be *O(2n)*.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯¹äºè¾ƒå¤§çš„*n*ï¼Œæ—¶é—´æˆæœ¬æé«˜ã€‚è¿è¡Œæ—¶é—´å°†ä¸º*O(2n)*ã€‚
- en: 'In the following code block is an example code for solving a 0-1 knapsack problem:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸‹é¢çš„ä»£ç å—ä¸­æ˜¯è§£å†³0-1èƒŒåŒ…é—®é¢˜çš„ç¤ºä¾‹ä»£ç ï¼š
- en: '[PRE4]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will analyze this code line by line. The first lines set the data:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†é€è¡Œåˆ†æè¿™æ®µä»£ç ã€‚å‰å‡ è¡Œè®¾ç½®äº†æ•°æ®ï¼š
- en: '[PRE5]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s look at each element:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬é€ä¸ªå…ƒç´ çœ‹ä¸€ä¸‹ï¼š
- en: '`W` is the maximum weight capacity.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`W` æ˜¯æœ€å¤§é‡é‡å®¹é‡ã€‚'
- en: '`WeightArray` is the weights array.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeightArray` æ˜¯é‡é‡æ•°ç»„ã€‚'
- en: '`ValueArray` is the values array.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ValueArray` æ˜¯å€¼æ•°ç»„ã€‚'
- en: '`DataKnap` is a dataframe containing weights and values.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataKnap` æ˜¯åŒ…å«é‡é‡å’Œå€¼çš„æ•°æ®æ¡†ã€‚'
- en: 'Now we will initialize the variables used in the algorithm:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å°†åˆå§‹åŒ–ç®—æ³•ä¸­ä½¿ç”¨çš„å˜é‡ï¼š
- en: '[PRE6]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we said, the brute force algorithm systematically lists all the possible
    values that could represent a solution and check whether each value satisfies
    the conditions imposed by the problem. Since four objects were passed to the system,
    a loop with four steps will be set as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚å‰æ‰€è¿°ï¼Œæš´åŠ›ç®—æ³•ç³»ç»Ÿåœ°åˆ—å‡ºäº†å¯èƒ½è¡¨ç¤ºè§£å†³æ–¹æ¡ˆçš„æ‰€æœ‰å¯èƒ½å€¼ï¼Œå¹¶æ£€æŸ¥æ¯ä¸ªå€¼æ˜¯å¦æ»¡è¶³é—®é¢˜æ‰€æ–½åŠ çš„æ¡ä»¶ã€‚ç”±äºç³»ç»Ÿä¼ é€’äº†å››ä¸ªå¯¹è±¡ï¼Œå°†è®¾ç½®ä¸€ä¸ªå››æ­¥å¾ªç¯å¦‚ä¸‹ï¼š
- en: '[PRE7]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For each step of the `for` loop, we will calculate all the combinations of
    the objects taken,Â `i`, at a time without repetition. To do this, the `combn()`
    function was used:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äº`for`å¾ªç¯çš„æ¯ä¸€æ­¥ï¼Œæˆ‘ä»¬å°†è®¡ç®—æ‰€æœ‰å–å‡ºçš„ç‰©ä½“çš„ç»„åˆï¼Œ`i`æ¬¡ä¸é‡å¤ã€‚ä¸ºæ­¤ï¼Œä½¿ç”¨äº†`combn()`å‡½æ•°ï¼š
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This function generates all combinations of the elements of theÂ `DataKnap`
    columns taken `i` at a time. Now we will sum theÂ returnedÂ array:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªå‡½æ•°ç”Ÿæˆæ‰€æœ‰`DataKnap`åˆ—ä¸­å…ƒç´ çš„ç»„åˆï¼Œå–`i`ä¸ªå…ƒç´ ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†å¯¹è¿”å›çš„æ•°ç»„è¿›è¡Œæ±‚å’Œï¼š
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now it is necessary to select only the combinations that return a sum of weightsÂ `<=W`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨éœ€è¦é€‰æ‹©åªè¿”å›é‡é‡æ€»å’Œ`<=W`çš„ç»„åˆï¼š
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If this operation returns at least one combination, we will calculate the best
    solution:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœè¯¥æ“ä½œè¿”å›è‡³å°‘ä¸€ä¸ªç»„åˆï¼Œæˆ‘ä»¬å°†è®¡ç®—æœ€ä½³è§£ï¼š
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, the list of the best combinations will be printed:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæœ€ä½³ç»„åˆçš„åˆ—è¡¨å°†è¢«æ‰“å°å‡ºæ¥ï¼š
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here are the results returned by the 0-1 knapsack problem solution:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹æ˜¯0-1èƒŒåŒ…é—®é¢˜è§£è¿”å›çš„ç»“æœï¼š
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The results mean that the best solution return values equal to 37 and the objects
    selected are in 3rd and 4th position. As anticipated, the optimal solution to
    the problem we have just dealt with is the most immediate but also the most expensive
    from the computational point of view. In the following sections, we will seek
    to obtain other solutions, trying save in calculation terms.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æœè¡¨æ˜ï¼Œæœ€ä½³è§£è¿”å›å€¼ä¸º37ï¼Œæ‰€é€‰ç‰©ä½“ä½äºç¬¬3å’Œç¬¬4ä½ç½®ã€‚æ­£å¦‚é¢„æœŸçš„é‚£æ ·ï¼Œæˆ‘ä»¬åˆšæ‰å¤„ç†çš„èƒŒåŒ…é—®é¢˜çš„æœ€ä¼˜è§£æ˜¯æœ€ç›´æ¥çš„ï¼Œä½†ä»è®¡ç®—çš„è§’åº¦æ¥çœ‹ä¹Ÿæ˜¯æœ€æ˜‚è´µçš„ã€‚åœ¨æ¥ä¸‹æ¥çš„éƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬å°†å°è¯•è·å¾—å…¶ä»–è§£ï¼ŒåŠ›æ±‚åœ¨è®¡ç®—ä¸ŠèŠ‚çœå¼€é”€ã€‚
- en: Greedy algorithms
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: è´ªå¿ƒç®—æ³•
- en: Before introducing a greedy algorithm to find an optimal solution to the problem
    of the knapsack, it is appropriate to recall the main characteristics of any greedy
    technique. Any greedy technique proceeds iteratively. Starting from an empty solution,
    element A is added to the partial solution under construction at each iteration.
    Of all the possible candidates to be added, element A is the most promising one,
    that is, if chosen, it leads to the greatest improvement of the objective function.
    It is clear that not all problems can be solved with this strategy; but, only
    those for which it is possible to show that making the best choice at the moment
    leads to an optimal solution globally.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å¼•å…¥è´ªå¿ƒç®—æ³•æ¥å¯»æ‰¾èƒŒåŒ…é—®é¢˜çš„æœ€ä¼˜è§£ä¹‹å‰ï¼Œå›é¡¾ä¸€ä¸‹ä»»ä½•è´ªå¿ƒæŠ€æœ¯çš„ä¸»è¦ç‰¹ç‚¹æ˜¯å¾ˆæœ‰å¿…è¦çš„ã€‚ä»»ä½•è´ªå¿ƒæŠ€æœ¯éƒ½æ˜¯è¿­ä»£è¿›è¡Œçš„ã€‚ä»ä¸€ä¸ªç©ºçš„è§£å¼€å§‹ï¼Œåœ¨æ¯æ¬¡è¿­ä»£ä¸­ï¼Œå…ƒç´ Aä¼šè¢«æ·»åŠ åˆ°æ­£åœ¨æ„å»ºçš„éƒ¨åˆ†è§£ä¸­ã€‚åœ¨æ‰€æœ‰å¯ä»¥æ·»åŠ çš„å€™é€‰å…ƒç´ ä¸­ï¼Œå…ƒç´ Aæ˜¯æœ€æœ‰å‰é€”çš„ï¼Œå³å¦‚æœé€‰æ‹©å®ƒï¼Œå®ƒå°†å¯¼è‡´ç›®æ ‡å‡½æ•°çš„æœ€å¤§æ”¹è¿›ã€‚æ˜¾ç„¶ï¼Œå¹¶ä¸æ˜¯æ‰€æœ‰é—®é¢˜éƒ½èƒ½é€šè¿‡è¿™ç§ç­–ç•¥è§£å†³ï¼›åªæœ‰é‚£äº›å¯ä»¥è¯æ˜å½“å‰åšå‡ºæœ€ä½³é€‰æ‹©èƒ½å¯¼è‡´å…¨å±€æœ€ä¼˜è§£çš„é—®é¢˜ï¼Œæ‰èƒ½ä½¿ç”¨è¿™ç§æ–¹æ³•ã€‚
- en: 'Let''s look at an algorithm first that simply performs the following operations:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬é¦–å…ˆçœ‹ä¸€ä¸ªç®€å•çš„ç®—æ³•ï¼Œæ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š
- en: Discards all objects weighing more than the maximum capacity (preprocessing).
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä¸¢å¼ƒæ‰€æœ‰é‡é‡è¶…è¿‡æœ€å¤§å®¹é‡çš„ç‰©ä½“ï¼ˆé¢„å¤„ç†ï¼‰ã€‚
- en: Sorts the objects for a given criterion.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æ ¹æ®ç»™å®šçš„æ ‡å‡†å¯¹ç‰©ä½“è¿›è¡Œæ’åºã€‚
- en: Selects the objects one at a time until the weight constraint is respected.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä¸€æ¬¡é€‰æ‹©ä¸€ä¸ªç‰©ä½“ï¼Œç›´åˆ°æ»¡è¶³é‡é‡é™åˆ¶ã€‚
- en: Returns the value of the solution and the set of selected objects.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è¿”å›è§£çš„å€¼å’Œæ‰€é€‰ç‰©ä½“çš„é›†åˆã€‚
- en: 'In the following code block, we can see the code for executing the algorithm:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä»¥ä¸‹ä»£ç å—ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°æ‰§è¡Œè¯¥ç®—æ³•çš„ä»£ç ï¼š
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will analyze this code line by line. The initial lines set the initial data:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†é€è¡Œåˆ†æè¿™æ®µä»£ç ã€‚åˆå§‹çš„å‡ è¡Œè®¾ç½®äº†åˆå§‹æ•°æ®ï¼š
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To find the best solution, we first perform a descending pre-order of the objects
    based on the density of value, calculated as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†æ‰¾åˆ°æœ€ä½³è§£ï¼Œæˆ‘ä»¬é¦–å…ˆå¯¹ç‰©ä½“æŒ‰ä»·å€¼å¯†åº¦è¿›è¡Œé™åºæ’åˆ—ï¼Œè®¡ç®—æ–¹æ³•å¦‚ä¸‹ï¼š
- en: '![](img/72ec34ce-d3bb-4c0e-ad08-d93ac0b700fd.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72ec34ce-d3bb-4c0e-ad08-d93ac0b700fd.png)'
- en: 'This technique is implemented in the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§æŠ€æœ¯åœ¨ä»¥ä¸‹ä»£ç ä¸­å®ç°ï¼š
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following lines are used to initialize the variables:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹å‡ è¡Œç”¨äºåˆå§‹åŒ–å˜é‡ï¼š
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, a `while` loop will be used to iterate the procedure:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œå°†ä½¿ç”¨`while`å¾ªç¯æ¥è¿­ä»£è¯¥è¿‡ç¨‹ï¼š
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The loop will be repeated until both codes are true. As soon as one of the two
    is false, the loop will be stopped. The first check is performed on the number
    of rows of the data matrix, at most there will be as many iterations as there
    are rows. The second check is carried out on the maximum capacity set. As soon
    as this is exceeded, the loop will be stopped.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: å¾ªç¯ä¼šä¸€ç›´é‡å¤ï¼Œç›´åˆ°ä¸¤ä¸ªæ¡ä»¶éƒ½ä¸ºçœŸã€‚ä¸€æ—¦å…¶ä¸­ä¸€ä¸ªæ¡ä»¶ä¸ºå‡ï¼Œå¾ªç¯å°±ä¼šåœæ­¢ã€‚ç¬¬ä¸€æ¬¡æ£€æŸ¥æ˜¯åœ¨æ•°æ®çŸ©é˜µçš„è¡Œæ•°ä¸Šè¿›è¡Œçš„ï¼Œæœ€å¤šä¼šæœ‰ä¸è¡Œæ•°ç›¸ç­‰çš„è¿­ä»£æ¬¡æ•°ã€‚ç¬¬äºŒæ¬¡æ£€æŸ¥æ˜¯åœ¨è®¾å®šçš„æœ€å¤§å®¹é‡ä¸Šè¿›è¡Œçš„ã€‚ä¸€æ—¦è¶…è¿‡è¿™ä¸ªå®¹é‡ï¼Œå¾ªç¯ä¼šåœæ­¢ã€‚
- en: 'Finally, the results are printed:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œç»“æœä¼šè¢«æ‰“å°å‡ºæ¥ï¼š
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The results are shown in the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æœæ˜¾ç¤ºå¦‚ä¸‹ï¼š
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: From the analysis of the previous data, we can note that we have not obtained
    the optimal solution as in the case of the brute force algorithm, but the procedure
    is very fast.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ä»å¯¹å‰é¢æ•°æ®çš„åˆ†æä¸­ï¼Œæˆ‘ä»¬å¯ä»¥æ³¨æ„åˆ°ï¼Œæˆ‘ä»¬æ²¡æœ‰åƒæš´åŠ›ç®—æ³•é‚£æ ·è·å¾—æœ€ä¼˜è§£ï¼Œä½†è¿™ä¸ªè¿‡ç¨‹éå¸¸å¿«é€Ÿã€‚
- en: Implementing a solution with DP
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä½¿ç”¨åŠ¨æ€è§„åˆ’å®ç°è§£æ³•
- en: In the previous sections, we have seen how the knapsack problem can be solved
    through different approaches. In particular, we have learned to treat this problem
    with an algorithm called brute force. In this case, we obtained the optimal solution
    with an extremely heavy computational cost. On the contrary, the greedy solution,
    seen later, gave us a lighter algorithm from a computational point of view but
    did not allow us to obtain the optimal solution. A solution that combines both
    these needs â€“ optimal solution and fast algorithm â€“ can be provided by DP.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å‰é¢çš„ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å·²ç»çœ‹åˆ°äº†å¦‚ä½•é€šè¿‡ä¸åŒçš„æ–¹å¼è§£å†³èƒŒåŒ…é—®é¢˜ã€‚ç‰¹åˆ«æ˜¯ï¼Œæˆ‘ä»¬å­¦ä¼šäº†ç”¨ä¸€ç§å«åšæš´åŠ›æ±‚è§£çš„ç®—æ³•æ¥å¤„ç†è¿™ä¸ªé—®é¢˜ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬é€šè¿‡æå¤§çš„è®¡ç®—ä»£ä»·è·å¾—äº†æœ€ä¼˜è§£ã€‚ç›¸åï¼Œåé¢çœ‹åˆ°çš„è´ªå¿ƒç®—æ³•ä»è®¡ç®—çš„è§’åº¦ç»™æˆ‘ä»¬æä¾›äº†ä¸€ä¸ªæ›´è½»é‡çš„ç®—æ³•ï¼Œä½†å®ƒæ— æ³•è·å¾—æœ€ä¼˜è§£ã€‚é€šè¿‡åŠ¨æ€è§„åˆ’ï¼ˆDPï¼‰ï¼Œå¯ä»¥æä¾›ä¸€ä¸ªåŒæ—¶æ»¡è¶³æœ€ä¼˜è§£å’Œå¿«é€Ÿç®—æ³•è¿™ä¸¤ä¸ªéœ€æ±‚çš„è§£æ³•ã€‚
- en: In DP, we subdivide an optimization problem into simpler subproblems and store
    the solution for each subproblem so that each subproblem is solved only once.
    The idea behind the method is to calculate solutions to subproblems once and store
    the solutions in a table so that they can be reused (repeatedly) later.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨åŠ¨æ€è§„åˆ’ä¸­ï¼Œæˆ‘ä»¬å°†ä¸€ä¸ªä¼˜åŒ–é—®é¢˜åˆ†è§£ä¸ºæ›´ç®€å•çš„å­é—®é¢˜ï¼Œå¹¶å­˜å‚¨æ¯ä¸ªå­é—®é¢˜çš„è§£ï¼Œä»¥ä¾¿æ¯ä¸ªå­é—®é¢˜ä»…è§£å†³ä¸€æ¬¡ã€‚è¯¥æ–¹æ³•çš„æ ¸å¿ƒæ€æƒ³æ˜¯ï¼Œé¦–å…ˆè®¡ç®—å­é—®é¢˜çš„è§£å¹¶å°†å…¶å­˜å‚¨åœ¨è¡¨æ ¼ä¸­ï¼Œä»¥ä¾¿ç¨åå¯ä»¥é‡å¤ä½¿ç”¨è¿™äº›è§£ï¼ˆé‡å¤ä½¿ç”¨ï¼‰ã€‚
- en: 'In the following code block, a knapsack problem solution is implemented using
    DP:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸‹é¢çš„ä»£ç å—ä¸­ï¼Œä½¿ç”¨åŠ¨æ€è§„åˆ’å®ç°äº†ä¸€ä¸ªèƒŒåŒ…é—®é¢˜çš„è§£å†³æ–¹æ¡ˆï¼š
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will analyze this code line by line. This algorithm starts with the definition
    of the data that will be used in the procedure:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†é€è¡Œåˆ†æè¿™æ®µä»£ç ã€‚è¿™ä¸ªç®—æ³•ä»å®šä¹‰å°†åœ¨è¿‡ç¨‹ä¸­ä½¿ç”¨çš„æ•°æ®å¼€å§‹ï¼š
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And then define the other variables:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åå®šä¹‰å…¶ä»–å˜é‡ï¼š
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s look at the elements of this code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹è¿™æ®µä»£ç çš„å…ƒç´ ï¼š
- en: '`Tabweights`Â is a vector containing the weights and 0 as the first element.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tabweights` æ˜¯ä¸€ä¸ªåŒ…å«é‡é‡å’Œ 0 ä½œä¸ºç¬¬ä¸€ä¸ªå…ƒç´ çš„å‘é‡ã€‚'
- en: '`TabValues`Â is a vector containing the values and 0 as the first element.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TabValues` æ˜¯ä¸€ä¸ªåŒ…å«å€¼å’Œ 0 ä½œä¸ºç¬¬ä¸€ä¸ªå…ƒç´ çš„å‘é‡ã€‚'
- en: '`n`Â is the number of objects.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n` æ˜¯ç‰©å“çš„æ•°é‡ã€‚'
- en: '`TabMatrix`Â is a tabular matrix.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TabMatrix` æ˜¯ä¸€ä¸ªè¡¨æ ¼çŸ©é˜µã€‚'
- en: 'We first define and initialize the table that will contain the values. The
    table is built column by column from the top to the bottom, as shown in the following
    diagram:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬é¦–å…ˆå®šä¹‰å¹¶åˆå§‹åŒ–ä¸€ä¸ªå°†åŒ…å«å€¼çš„è¡¨æ ¼ã€‚è¯¥è¡¨æ ¼æ˜¯ä»ä¸Šåˆ°ä¸‹æŒ‰åˆ—æ„å»ºçš„ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š
- en: '![](img/ff9520f5-86ed-4b1c-b46e-36f64f08a3cd.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff9520f5-86ed-4b1c-b46e-36f64f08a3cd.png)'
- en: 'Then we set an iterative loop on all objects and on all weight values:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬è®¾ç½®ä¸€ä¸ªå¯¹æ‰€æœ‰ç‰©å“å’Œæ‰€æœ‰é‡é‡å€¼çš„è¿­ä»£å¾ªç¯ï¼š
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First, we fill the first line `i=1` with 0\. This means that when no object
    is considered the weight is 0, so we fill the first column w = 1 with 0\. This
    means that when the weight is 0, the objects considered are 0\. Practically, we
    initialize the first line to 0, which corresponds to the case in which, for different
    transportable weights, we have no object (T[1, w] = 0). Initialize the first column
    to 0, which corresponds to the case in which, for several possible objects, I
    have a backpack of zero capacity (T [i, 1] = 0).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæˆ‘ä»¬ç”¨ 0 å¡«å……ç¬¬ä¸€è¡Œ `i=1`ã€‚è¿™æ„å‘³ç€å½“æ²¡æœ‰ç‰©å“æ—¶ï¼Œé‡é‡ä¸º 0ï¼Œå› æ­¤æˆ‘ä»¬å°†ç¬¬ä¸€åˆ— w = 1 å¡«å……ä¸º 0ã€‚è¿™æ„å‘³ç€å½“é‡é‡ä¸º 0 æ—¶ï¼Œæ‰€è€ƒè™‘çš„ç‰©å“ä¸º
    0ã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬å°†ç¬¬ä¸€è¡Œåˆå§‹åŒ–ä¸º 0ï¼Œè¿™å¯¹åº”äºå¯¹äºä¸åŒçš„å¯è¿è¾“é‡é‡ï¼Œæˆ‘ä»¬æ²¡æœ‰ä»»ä½•ç‰©å“çš„æƒ…å†µï¼ˆT[1, w] = 0ï¼‰ã€‚å°†ç¬¬ä¸€åˆ—åˆå§‹åŒ–ä¸º 0ï¼Œè¿™å¯¹åº”äºå¯¹äºå¤šä¸ªå¯èƒ½çš„ç‰©å“ï¼Œæˆ‘æœ‰ä¸€ä¸ªé›¶å®¹é‡çš„èƒŒåŒ…çš„æƒ…å†µï¼ˆT[i,
    1] = 0ï¼‰ã€‚
- en: 'The rule to fill the table is provided by the following algorithm:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: å¡«å……è¡¨æ ¼çš„è§„åˆ™ç”±ä»¥ä¸‹ç®—æ³•æä¾›ï¼š
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If the weight of the *i^(th)*Â element is greater than that of the column then
    the *i^(th)* element will be equal to the previous one, altitudes will be calculated
    with the following formula:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœç¬¬ *i^(th)* ä¸ªå…ƒç´ çš„é‡é‡å¤§äºåˆ—çš„é‡é‡ï¼Œåˆ™ç¬¬ *i^(th)* ä¸ªå…ƒç´ å°†ç­‰äºå‰ä¸€ä¸ªå…ƒç´ ï¼Œæµ·æ‹”å°†é€šè¿‡ä»¥ä¸‹å…¬å¼è®¡ç®—ï¼š
- en: '![](img/e0cc1149-7f7d-46fc-a9b1-9202e45e46b4.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0cc1149-7f7d-46fc-a9b1-9202e45e46b4.png)'
- en: 'Once the last cell of the last row of the table has been reached, we can memorize
    the result obtained, which represents the maximum value of the objects that can
    be carried in the knapsack:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦åˆ°è¾¾è¡¨æ ¼æœ€åä¸€è¡Œçš„æœ€åä¸€ä¸ªå•å…ƒæ ¼ï¼Œæˆ‘ä»¬å¯ä»¥è®°ä½å¾—åˆ°çš„ç»“æœï¼Œè¿™ä»£è¡¨èƒŒåŒ…ä¸­å¯ä»¥æºå¸¦ç‰©å“çš„æœ€å¤§å€¼ï¼š
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following result is returned:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: è¿”å›ä»¥ä¸‹ç»“æœï¼š
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The procedure followed so far does not indicate which subset provides the optimal
    solution. We must extract this information by analyzing the last column of the
    table (w = P); we will run through it from the last value to the top one:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢çš„è¿‡ç¨‹æ²¡æœ‰æŒ‡å‡ºå“ªä¸ªå­é›†æä¾›æœ€ä¼˜è§£ã€‚æˆ‘ä»¬å¿…é¡»é€šè¿‡åˆ†æè¡¨æ ¼çš„æœ€åä¸€åˆ—ï¼ˆw = Pï¼‰æ¥æå–æ­¤ä¿¡æ¯ï¼›æˆ‘ä»¬å°†ä»æœ€åä¸€ä¸ªå€¼å¼€å§‹ï¼Œé€æ­¥å‘ä¸Šè¿è¡Œã€‚
- en: '[PRE28]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the current element is the same as the previous one, let''s move on to the
    next one; otherwise, the current object is included in the knapsack:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœå½“å‰å…ƒç´ ä¸å‰ä¸€ä¸ªå…ƒç´ ç›¸åŒï¼Œæˆ‘ä»¬å°±è·³åˆ°ä¸‹ä¸€ä¸ªï¼›å¦åˆ™ï¼Œå½“å‰ç‰©ä½“å°†è¢«åŒ…å«åœ¨èƒŒåŒ…ä¸­ï¼š
- en: '[PRE29]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If an element is inserted in the backpack, the column is obtained by subtracting
    the current value of `w` from the weight relative to the selected object:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœå…ƒç´ è¢«æ’å…¥åˆ°èƒŒåŒ…ä¸­ï¼Œé€šè¿‡ä»é€‰å®šç‰©ä½“çš„é‡é‡ä¸­å‡å»å½“å‰`w`å€¼æ¥è·å¾—åˆ—å€¼ï¼š
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, the items selected will be printed:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæ‰€é€‰çš„ç‰©å“å°†è¢«æ‰“å°å‡ºæ¥ï¼š
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The results are shown in the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æœå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The DP algorithm allowed us to obtain the optimal solution, saving on computational
    costs.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: åŠ¨æ€è§„åˆ’ï¼ˆDPï¼‰ç®—æ³•ä½¿æˆ‘ä»¬èƒ½å¤Ÿè·å¾—æœ€ä¼˜è§£ï¼Œä»è€ŒèŠ‚çœè®¡ç®—æˆæœ¬ã€‚
- en: In the next section, we will analyze a practical case; we will optimize the
    navigation system of a robot.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸‹ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†åˆ†æä¸€ä¸ªå®é™…æ¡ˆä¾‹ï¼›æˆ‘ä»¬å°†ä¼˜åŒ–æœºå™¨äººçš„å¯¼èˆªç³»ç»Ÿã€‚
- en: Optimization of a robot navigation system
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æœºå™¨äººå¯¼èˆªç³»ç»Ÿçš„ä¼˜åŒ–
- en: A robot is a machine that performs particular actions based on the commands
    that are provided, either based on direct human supervision, or independently
    based on general guidelines using the artificial intelligence processes. Robots
    should be able to replace or assist humans with activities such as, manufacturing,
    construction, handling heavy and dangerous materials in conditions not suitable
    for humans, or simply to free a person from commitments.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: æœºå™¨äººæ˜¯ä¸€ç§æ ¹æ®æä¾›çš„æŒ‡ä»¤æ‰§è¡Œç‰¹å®šåŠ¨ä½œçš„æœºå™¨ï¼Œè¿™äº›æŒ‡ä»¤å¯ä»¥æ˜¯åŸºäºç›´æ¥äººå·¥ç›‘ç£ï¼Œæˆ–åŸºäºä½¿ç”¨äººå·¥æ™ºèƒ½è¿‡ç¨‹çš„é€šç”¨æŒ‡å¯¼æ¥ç‹¬ç«‹æ‰§è¡Œçš„ã€‚æœºå™¨äººåº”è¯¥èƒ½å¤Ÿæ›¿ä»£æˆ–ååŠ©äººç±»å®Œæˆè¯¸å¦‚åˆ¶é€ ã€å»ºç­‘ã€åœ¨ä¸é€‚åˆäººç±»çš„æ¡ä»¶ä¸‹å¤„ç†é‡å‹å’Œå±é™©ç‰©æ–™ï¼Œæˆ–è€…ä»…ä»…æ˜¯è§£æ”¾ä¸€ä¸ªäººå…äºæ‰¿æ‹…æŸäº›è´£ä»»çš„å·¥ä½œã€‚
- en: A robot should be equipped with guided connections by feedback between perception
    and action, and not by direct human control. The action can take the form of electromagnetic
    motors, or actuators, that move a limb, open and close a gripper, or move the
    robot. Step-by-step control and feedback are provided by a program that runs from
    an external or internal robot computer, or from a microcontroller. Based on this
    definition, the robot concept can include almost all automated devices.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: æœºå™¨äººåº”é€šè¿‡æ„ŸçŸ¥ä¸è¡ŒåŠ¨ä¹‹é—´çš„åé¦ˆæ¥è£…å¤‡å¼•å¯¼è¿æ¥ï¼Œè€Œä¸æ˜¯é€šè¿‡ç›´æ¥çš„äººå·¥æ§åˆ¶ã€‚åŠ¨ä½œå¯ä»¥é€šè¿‡ç”µç£é©¬è¾¾æˆ–æ‰§è¡Œå™¨çš„å½¢å¼æ¥è¿›è¡Œï¼Œè¿™äº›æ‰§è¡Œå™¨å¯ä»¥ç§»åŠ¨å››è‚¢ã€å¼€å…³å¤¹çˆªæˆ–ç§»åŠ¨æœºå™¨äººã€‚é€æ­¥æ§åˆ¶å’Œåé¦ˆç”±ä¸€ä¸ªå¤–éƒ¨æˆ–å†…éƒ¨æœºå™¨äººè®¡ç®—æœºæˆ–å¾®æ§åˆ¶å™¨è¿è¡Œçš„ç¨‹åºæä¾›ã€‚æ ¹æ®è¿™ä¸ªå®šä¹‰ï¼Œæœºå™¨äººæ¦‚å¿µå‡ ä¹å¯ä»¥åŒ…æ‹¬æ‰€æœ‰è‡ªåŠ¨åŒ–è®¾å¤‡ã€‚
- en: Training an agent to move in an environment
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: è®­ç»ƒä¸€ä¸ªä»£ç†åœ¨ç¯å¢ƒä¸­ç§»åŠ¨
- en: To understand how the problems connected with the autonomous navigation of a
    robot are tackled, we will begin with a broadly-based problemâ€”theÂ `gridworld`
    problem. In these problems, the environment is defined as a simple 2D rectangular
    grid of dimensions (N, M) with an agent starting from a grid square and trying
    to move to another grid square located elsewhere. This environment is perfect
    for the application of reinforcement learning algorithms to discover optimal routes
    and policies for the agents on the grid to reach the desired target grid squares
    in the fewest number of moves.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ç†è§£å¦‚ä½•è§£å†³ä¸æœºå™¨äººè‡ªä¸»å¯¼èˆªç›¸å…³çš„é—®é¢˜ï¼Œæˆ‘ä»¬å°†ä»ä¸€ä¸ªå¹¿æ³›çš„é—®é¢˜å¼€å§‹â€”â€”`gridworld`é—®é¢˜ã€‚åœ¨è¿™äº›é—®é¢˜ä¸­ï¼Œç¯å¢ƒè¢«å®šä¹‰ä¸ºä¸€ä¸ªç®€å•çš„äºŒç»´çŸ©å½¢ç½‘æ ¼ï¼Œå°ºå¯¸ä¸º(N,
    M)ï¼Œä»£ç†ä»ä¸€ä¸ªç½‘æ ¼æ ¼å­å‡ºå‘ï¼Œè¯•å›¾ç§»åŠ¨åˆ°å¦ä¸€ä¸ªä½äºå…¶ä»–ä½ç½®çš„ç½‘æ ¼æ ¼å­ã€‚è¿™ä¸ªç¯å¢ƒéå¸¸é€‚åˆåº”ç”¨å¼ºåŒ–å­¦ä¹ ç®—æ³•ï¼Œå¸®åŠ©ä»£ç†åœ¨ç½‘æ ¼ä¸Šå‘ç°åˆ°è¾¾ç›®æ ‡ç½‘æ ¼æ ¼å­çš„æœ€ä¼˜è·¯å¾„å’Œç­–ç•¥ï¼Œä»¥æœ€å°‘çš„ç§»åŠ¨æ¬¡æ•°è¾¾åˆ°ç›®æ ‡ã€‚
- en: 'The following diagram shows a 5 x 5 grid:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹å›¾ç¤ºå±•ç¤ºäº†ä¸€ä¸ª 5 x 5 çš„ç½‘æ ¼ï¼š
- en: '![](img/725e3703-65b4-4651-91c5-45826b1d2643.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/725e3703-65b4-4651-91c5-45826b1d2643.png)'
- en: The agent evolves while exploring the states. There were no terminals. The agent
    can move {right, left, up, and down}. If the action takes the agent off the grid,
    he remains in the same state, but a negative reward is applied. For all other
    states (and actions) it is R = -2, except for the actions that move the agent
    to the finish line. In this case, all four actions get R = +20 and bring the agent
    to the final state.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ä»£ç†åœ¨æ¢ç´¢çŠ¶æ€çš„è¿‡ç¨‹ä¸­ä¸æ–­æ¼”åŒ–ã€‚è¯¥ç¯å¢ƒæ²¡æœ‰ç»ˆæ­¢çŠ¶æ€ã€‚ä»£ç†å¯ä»¥æ‰§è¡Œ{å³ç§»ã€å·¦ç§»ã€ä¸Šç§»ã€ä¸‹ç§»}çš„åŠ¨ä½œã€‚å¦‚æœåŠ¨ä½œä½¿ä»£ç†ç§»å‡ºç½‘æ ¼ï¼Œä»£ç†å°†ä¿æŒåœ¨å½“å‰çŠ¶æ€ï¼Œä½†ä¼šåº”ç”¨ä¸€ä¸ªè´Ÿå¥–åŠ±ã€‚å¯¹äºæ‰€æœ‰å…¶ä»–çŠ¶æ€ï¼ˆå’ŒåŠ¨ä½œï¼‰ï¼Œå¥–åŠ±ä¸ºR
    = -2ï¼Œé™¤äº†å°†ä»£ç†ç§»è‡³ç»ˆç‚¹çš„åŠ¨ä½œã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå››ä¸ªåŠ¨ä½œçš„å¥–åŠ±ä¸ºR = +20ï¼Œå¹¶å°†ä»£ç†å¸¦åˆ°æœ€ç»ˆçŠ¶æ€ã€‚
- en: 'To better understand the context, we will only deal with the problem of a 2
    x 2 grid with a wall that prohibits the passage from the 1st grid to the 4th,
    as indicated in the following diagram:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†æ›´å¥½åœ°ç†è§£ä¸Šä¸‹æ–‡ï¼Œæˆ‘ä»¬å°†åªå¤„ç†ä¸€ä¸ª2 x 2ç½‘æ ¼çš„é—®é¢˜ï¼Œè¯¥ç½‘æ ¼ä¸­æœ‰ä¸€å µå¢™ï¼Œç¦æ­¢ä»ç¬¬1æ ¼åˆ°ç¬¬4æ ¼çš„é€šè¿‡ï¼Œå…·ä½“å¦‚ä»¥ä¸‹å›¾æ‰€ç¤ºï¼š
- en: '![](img/53d3833c-7bc8-453c-bd47-49b2a51a1c49.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53d3833c-7bc8-453c-bd47-49b2a51a1c49.png)'
- en: 'Our goal is to develop the best policy to reach cell C4 (end) starting from
    cell C1 (start). The following code is an example of solving a gridworld problem:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„ç›®æ ‡æ˜¯åˆ¶å®šå‡ºæœ€ä¼˜ç­–ç•¥ï¼Œä»C1ï¼ˆèµ·ç‚¹ï¼‰å‡ºå‘ï¼Œæœ€ç»ˆåˆ°è¾¾C4ï¼ˆç»ˆç‚¹ï¼‰ã€‚ä»¥ä¸‹ä»£ç æ˜¯è§£å†³ç½‘æ ¼ä¸–ç•Œé—®é¢˜çš„ä¸€ä¸ªç¤ºä¾‹ï¼š
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We will analyze this code line by line. First, we loaded the library:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†é€è¡Œåˆ†æè¿™æ®µä»£ç ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬åŠ è½½äº†åº“ï¼š
- en: '[PRE34]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we set all possible actions:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬è®¾ç½®æ‰€æœ‰å¯èƒ½çš„åŠ¨ä½œï¼š
- en: '[PRE35]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Each action matrix is of the 4 x 4 type. In fact, it contains all the probabilities
    from each state (represented by the lines) when it is possible to transit to another
    state (represented by the columns). For example, the first row of the MoveUp matrix
    contains all the probabilities that start from the state C1 it is possible to
    pass in the other states with the action up. It is clear that in this state, with
    this action, I can transit in the state C2\. In fact, the relative probability
    is 0.7\. The second row of the same matrix contains the probabilities from the
    state C2 passes to the other states with the action up, in which case the highest
    probability is that it remains in this state.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: æ¯ä¸ªåŠ¨ä½œçŸ©é˜µéƒ½æ˜¯4 x 4ç±»å‹ã€‚äº‹å®ä¸Šï¼Œå®ƒåŒ…å«äº†ä»æ¯ä¸ªçŠ¶æ€ï¼ˆç”±è¡Œè¡¨ç¤ºï¼‰å‡ºå‘ï¼Œåœ¨å¯èƒ½è½¬ç§»åˆ°å…¶ä»–çŠ¶æ€ï¼ˆç”±åˆ—è¡¨ç¤ºï¼‰æ—¶çš„æ‰€æœ‰æ¦‚ç‡ã€‚ä¾‹å¦‚ï¼ŒMoveUpçŸ©é˜µçš„ç¬¬ä¸€è¡ŒåŒ…å«äº†ä»C1çŠ¶æ€å‡ºå‘ï¼Œè¿›è¡Œå‘ä¸Šçš„åŠ¨ä½œæ—¶èƒ½å¤Ÿè½¬ç§»åˆ°å…¶ä»–çŠ¶æ€çš„æ‰€æœ‰æ¦‚ç‡ã€‚æ˜¾ç„¶ï¼Œåœ¨è¿™ä¸ªçŠ¶æ€ä¸‹ï¼Œæ‰§è¡Œæ­¤åŠ¨ä½œæ—¶ï¼Œæˆ‘å¯ä»¥è½¬ç§»åˆ°çŠ¶æ€C2ã€‚äº‹å®ä¸Šï¼Œç›¸å…³çš„æ¦‚ç‡æ˜¯0.7ã€‚ç›¸åŒçŸ©é˜µçš„ç¬¬äºŒè¡ŒåŒ…å«äº†ä»C2çŠ¶æ€å‡ºå‘ï¼Œæ‰§è¡Œå‘ä¸Šçš„åŠ¨ä½œæ—¶èƒ½å¤Ÿè½¬ç§»åˆ°å…¶ä»–çŠ¶æ€çš„æ¦‚ç‡ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæœ€å¤§æ¦‚ç‡æ˜¯å®ƒä¿æŒåœ¨æ­¤çŠ¶æ€ã€‚
- en: 'In the next step, we will combine all actions defined in a list:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸‹ä¸€æ­¥ï¼Œæˆ‘ä»¬å°†æŠŠæ‰€æœ‰å®šä¹‰çš„åŠ¨ä½œåˆå¹¶æˆä¸€ä¸ªåˆ—è¡¨ï¼š
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s define the rewards and penalties allowed for the problem according to
    the hypothesis:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: æ ¹æ®å‡è®¾ï¼Œæˆ‘ä»¬æ¥å®šä¹‰é—®é¢˜å…è®¸çš„å¥–åŠ±å’Œæƒ©ç½šï¼š
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Before we move on, we have to check the format of the problem as we have defined.
    We will use the `mdp_check()` function:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç»§ç»­ä¹‹å‰ï¼Œæˆ‘ä»¬å¿…é¡»æ£€æŸ¥æˆ‘ä»¬å®šä¹‰çš„é—®é¢˜æ ¼å¼ã€‚æˆ‘ä»¬å°†ä½¿ç”¨`mdp_check()`å‡½æ•°ï¼š
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This function checks whether the MDP defined by the transition probability
    array (`AllActions`) and the reward matrix (`AllRewards`) is valid. If `AllActions`
    and `AllRewards` are correct, the function returns an empty error message. In
    the opposite case, the function returns an error message describing the problem.
    Let''s search the optimal policy for the navigation from C1 to C4:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªå‡½æ•°æ£€æŸ¥ç”±è½¬ç§»æ¦‚ç‡æ•°ç»„ï¼ˆ`AllActions`ï¼‰å’Œå¥–åŠ±çŸ©é˜µï¼ˆ`AllRewards`ï¼‰å®šä¹‰çš„MDPæ˜¯å¦æœ‰æ•ˆã€‚å¦‚æœ`AllActions`å’Œ`AllRewards`æ˜¯æ­£ç¡®çš„ï¼Œå‡½æ•°å°†è¿”å›ä¸€ä¸ªç©ºçš„é”™è¯¯æ¶ˆæ¯ã€‚åä¹‹ï¼Œå‡½æ•°å°†è¿”å›ä¸€ä¸ªæè¿°é—®é¢˜çš„é”™è¯¯æ¶ˆæ¯ã€‚è®©æˆ‘ä»¬æœç´¢ä»C1åˆ°C4çš„æœ€ä¼˜ç­–ç•¥ï¼š
- en: '[PRE39]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'TheÂ `mdp_policy_iteration()` function was used. This function applies the policy
    iteration algorithm to solve discounted MDP. The algorithm consists in improving
    the policy iteratively, using the evaluation of the current policy. Iterating
    is stopped when two successive policies are identical or when a specified number
    of iterations have been performed. Three arguments were passed:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨äº†`mdp_policy_iteration()`å‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°åº”ç”¨ç­–ç•¥è¿­ä»£ç®—æ³•æ¥è§£å†³æŠ˜æ‰£MDPã€‚è¯¥ç®—æ³•çš„åŸºæœ¬æ€è·¯æ˜¯é€šè¿‡è¯„ä¼°å½“å‰ç­–ç•¥ï¼Œè¿­ä»£åœ°æ”¹å–„ç­–ç•¥ã€‚å½“ä¸¤æ¬¡è¿ç»­çš„ç­–ç•¥ç›¸åŒæˆ–å·²è¾¾åˆ°æŒ‡å®šçš„è¿­ä»£æ¬¡æ•°æ—¶ï¼Œè¿­ä»£è¿‡ç¨‹åœæ­¢ã€‚ä¼ å…¥äº†ä¸‰ä¸ªå‚æ•°ï¼š
- en: '`AllActions`: Transition probability array. This array can be a three-dimensional
    array, or a list, each element containing a sparse matrix.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AllActions`ï¼šè½¬ç§»æ¦‚ç‡æ•°ç»„ã€‚è¿™ä¸ªæ•°ç»„å¯ä»¥æ˜¯ä¸€ä¸ªä¸‰ç»´æ•°ç»„ï¼Œä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œæ¯ä¸ªå…ƒç´ åŒ…å«ä¸€ä¸ªç¨€ç–çŸ©é˜µã€‚'
- en: '`AllRewards`: Reward array. This array can be a three-dimensional array or
    a list, each element containing a sparse matrix or a two-dimensional matrix possibly
    sparse.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AllRewards`ï¼šå¥–åŠ±æ•°ç»„ã€‚è¿™ä¸ªæ•°ç»„å¯ä»¥æ˜¯ä¸€ä¸ªä¸‰ç»´æ•°ç»„æˆ–ä¸€ä¸ªåˆ—è¡¨ï¼Œæ¯ä¸ªå…ƒç´ åŒ…å«ä¸€ä¸ªç¨€ç–çŸ©é˜µæˆ–ä¸€ä¸ªå¯èƒ½æ˜¯ç¨€ç–çš„äºŒç»´çŸ©é˜µã€‚'
- en: '`discount`: Discount factor. Discount is a real number between [0; 1].'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`discount`ï¼šæŠ˜æ‰£å› å­ã€‚æŠ˜æ‰£å› å­æ˜¯ä¸€ä¸ªä»‹äº[0; 1]ä¹‹é—´çš„å®æ•°ã€‚'
- en: 'At this point, we can recover the policy:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°æ­¤ä¸ºæ­¢ï¼Œæˆ‘ä»¬å¯ä»¥æ¢å¤ç­–ç•¥ï¼š
- en: '[PRE40]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following results are returned:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: è¿”å›ä»¥ä¸‹ç»“æœï¼š
- en: '[PRE41]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To better understand the policy, we can extract the names of the actions defined
    with the policy:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†æ›´å¥½åœ°ç†è§£ç­–ç•¥ï¼Œæˆ‘ä»¬å¯ä»¥æå–ç”±ç­–ç•¥å®šä¹‰çš„åŠ¨ä½œåç§°ï¼š
- en: '[PRE42]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following results are returned:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: è¿”å›ä»¥ä¸‹ç»“æœï¼š
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now we can extract the optimal values at each step. These values can be different
    in each run:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¯ä»¥æå–æ¯ä¸ªæ­¥éª¤çš„æœ€ä¼˜å€¼ã€‚è¿™äº›å€¼åœ¨æ¯æ¬¡è¿è¡Œæ—¶å¯èƒ½ä¸åŒï¼š
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following results are returned:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: è¿”å›ä»¥ä¸‹ç»“æœï¼š
- en: '[PRE45]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We talked about iterations. In fact, we can see in how many iterations the
    algorithm has taken to reach convergence:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è®¨è®ºäº†è¿­ä»£ã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ç®—æ³•åœ¨å¤šå°‘æ¬¡è¿­ä»£åè¾¾åˆ°æ”¶æ•›ï¼š
- en: '[PRE46]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The following results are returned:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: è¿”å›ä»¥ä¸‹ç»“æœï¼š
- en: '[PRE47]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we print the time of execution:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæˆ‘ä»¬æ‰“å°äº†æ‰§è¡Œæ—¶é—´ï¼š
- en: '[PRE48]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following result is returned:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: è¿”å›ä»¥ä¸‹ç»“æœï¼š
- en: '[PRE49]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The problem faced is trivial but allows us to understand how it must be addressed.
    A larger grid must be treated in the same way unless it defines the matrices of
    the actions and rewards that will be the greatest.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: é¢ä¸´çš„é—®é¢˜çœ‹ä¼¼å¾®ä¸è¶³é“ï¼Œä½†å®ƒè®©æˆ‘ä»¬ç†è§£äº†å¿…é¡»å¦‚ä½•å¤„ç†ã€‚é™¤éå®šä¹‰äº†æœ€å¤§è¡ŒåŠ¨å’Œå¥–åŠ±çš„çŸ©é˜µï¼Œå¦åˆ™å¿…é¡»ä»¥ç›¸åŒçš„æ–¹å¼å¤„ç†æ›´å¤§çš„ç½‘æ ¼ã€‚
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ€»ç»“
- en: 'In this chapter, we have addressed the basics concepts of the optimization
    techniques. To begin with, we learned the essential elements underlying DP. In
    DP, we subdivide an optimization problem into simpler subproblems: we proceed
    to calculate the solutions of all possible subproblems, and from these sub-solutions
    we obtain new sub-solutions, and then solve the original problem.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬è®¨è®ºäº†ä¼˜åŒ–æŠ€æœ¯çš„åŸºæœ¬æ¦‚å¿µã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å­¦ä¹ äº†åŠ¨æ€è§„åˆ’ï¼ˆDPï¼‰èƒŒåçš„åŸºæœ¬å…ƒç´ ã€‚åœ¨åŠ¨æ€è§„åˆ’ä¸­ï¼Œæˆ‘ä»¬å°†ä¸€ä¸ªä¼˜åŒ–é—®é¢˜ç»†åˆ†ä¸ºæ›´ç®€å•çš„å­é—®é¢˜ï¼šæˆ‘ä»¬è®¡ç®—æ‰€æœ‰å¯èƒ½å­é—®é¢˜çš„è§£ï¼Œä»è¿™äº›å­è§£ä¸­è·å–æ–°çš„å­è§£ï¼Œç„¶åè§£å†³åŸå§‹é—®é¢˜ã€‚
- en: 'Then we learned the difference between recursion and memoization.Â Subsequently,
    we learned the basis of the knapsack problem. This problem was addressed through
    three different approaches: brute force, greedy algorithms, and DP. For each approach,
    a solution algorithm was provided and the results were compared.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬å­¦ä¹ äº†é€’å½’ä¸å¤‡å¿˜å½•åŒ–çš„åŒºåˆ«ã€‚éšåï¼Œæˆ‘ä»¬å­¦ä¹ äº†èƒŒåŒ…é—®é¢˜çš„åŸºç¡€ã€‚è¿™ä¸ªé—®é¢˜é€šè¿‡ä¸‰ç§ä¸åŒçš„æ–¹æ³•è¿›è¡Œäº†è§£å†³ï¼šæš´åŠ›æ³•ã€è´ªå¿ƒç®—æ³•å’ŒåŠ¨æ€è§„åˆ’ã€‚å¯¹äºæ¯ç§æ–¹æ³•ï¼Œæä¾›äº†ä¸€ä¸ªè§£æ³•ç®—æ³•å¹¶è¿›è¡Œäº†ç»“æœæ¯”è¾ƒã€‚
- en: Finally, the optimization of a navigation route was discussed. To handle autonomous
    navigation of a robot, we learned to tackle the problem of searching for a path
    in a gridworld. In this way, we have seen how to solve the problem of finding
    the optimal policy to find the route.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæˆ‘ä»¬è®¨è®ºäº†å¯¼èˆªè·¯å¾„çš„ä¼˜åŒ–é—®é¢˜ã€‚ä¸ºäº†å¤„ç†æœºå™¨äººè‡ªä¸»å¯¼èˆªï¼Œæˆ‘ä»¬å­¦ä¹ äº†å¦‚ä½•è§£å†³åœ¨ç½‘æ ¼ä¸–ç•Œä¸­å¯»æ‰¾è·¯å¾„çš„é—®é¢˜ã€‚é€šè¿‡è¿™ç§æ–¹å¼ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†å¦‚ä½•è§£å†³æ‰¾åˆ°æœ€ä½³ç­–ç•¥ä»¥ç¡®å®šè·¯å¾„çš„é—®é¢˜ã€‚
- en: In the next chapter, we will learn the basic concepts of forecasting techniques.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸‹ä¸€ç« ï¼Œæˆ‘ä»¬å°†å­¦ä¹ é¢„æµ‹æŠ€æœ¯çš„åŸºæœ¬æ¦‚å¿µã€‚
