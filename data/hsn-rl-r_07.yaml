- en: Dynamic Programming for Optimal Policies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态规划与最优策略
- en: '**Dynamic programming** (**DP**) represents a set of algorithms that can be
    used to calculate an optimal policy given a perfect model of the environment in
    the form of a **Markov decision process** (**MDP**). DP methods update the estimates
    of the state values on the basis of the estimates made in the previous steps. In
    DP, an optimization problem is decomposed into simpler subproblems and the solution
    for each subproblem is stored so that each subproblem is solved only once. In
    this chapter, we will learn how to select the optimal portfolio using DP through
    an R code implementation.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态规划**（**DP**）代表了一组可以用来计算最优策略的算法，前提是有一个完美的环境模型，以**马尔可夫决策过程**（**MDP**）的形式给出。DP方法根据之前步骤中的估计值来更新状态值的估计。在DP中，优化问题被分解为更简单的子问题，每个子问题的解被存储，以便每个子问题只被解决一次。在本章中，我们将学习如何通过R代码实现DP来选择最优的投资组合。'
- en: 'The following topics are covered in the chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Understanding DP
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解DP
- en: Learning the top-down DP approach
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习自顶向下的DP方法
- en: Analyzing the difference between recursion and memoization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析递归与备忘录化的区别
- en: Learning the optimization techniques
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习优化技术
- en: Implementing DP in reinforcement learning applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在强化学习应用中实现DP
- en: Solving the knapsack problem
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决背包问题
- en: Optimization of a robot navigation system
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人导航系统的优化
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码如何运行：
- en: '[http://bit.ly/2RPIFfB](http://bit.ly/2RPIFfB)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2RPIFfB](http://bit.ly/2RPIFfB)'
- en: Understanding DP
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解DP
- en: DP is a mathematical methodology developed by Richard Bellman in the 1950s.
    It is used to solve problems in which a series of interdependent decisions must
    be addressed in sequence. The underlying principle behind this methodology is
    that of Bellman's optimality—whatever the initial status and the initial decision,
    subsequent decisions must provide an optimal policy with respect to the status
    resulting from the previous decision. This is the essential feature of an optimal
    policy.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: DP（动态规划）是理查德·贝尔曼（Richard Bellman）在1950年代开发的数学方法论。它用于解决需要按顺序处理一系列相互依赖的决策问题。该方法论背后的基本原则是贝尔曼的最优性——无论初始状态和初始决策如何，后续的决策必须相对于前一个决策所导致的状态提供最优的策略。这是最优策略的本质特征。
- en: Consider an example of finding the best path that joins two positions. The optimality
    principle states that every sub-path included in it, between any intermediate
    and final position, must in turn be optimal. Based on this principle, DP solves
    a problem by making one decision at a time. At each step, the best policy for
    the future is determined, regardless of past choices (it is a Markov process),
    if these are also optimal.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 设想一个寻找连接两个位置的最佳路径的例子。最优性原则指出，路径中每一个子路径，无论是从中间位置到最终位置，都必须是最优的。基于这一原则，DP通过一次作出一个决策来解决问题。在每一步，都会确定未来的最佳策略，而不考虑过去的选择（它是一个马尔可夫过程），前提是这些选择也是最优的。
- en: DP is therefore effectively applicable whenever the original problem can be
    broken down into a series of minor subproblems, or when the cost paid or the profit
    obtained are expressed as the sum of the elementary costs associated with each
    individual decision. More generally, the cost must be expressed through some operators
    as a composition of elementary costs that are individually dependent on a single
    decision.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，DP在原问题可以分解为一系列较小的子问题，或当支付的成本或获得的利润可以表示为与每个单独决策相关的基本成本之和时，DP是有效的。更一般地，成本必须通过某些运算符表示为基本成本的组合，这些基本成本各自依赖于单个决策。
- en: 'The following diagram shows the best route between two nodes of a network (the
    red path) among all those available (and by "best" I mean "shortest"):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了网络中两个节点之间的最佳路径（红色路径），在所有可用路径中选择的“最佳”路径是“最短”的：
- en: '![](img/70f9d33c-5edf-4d4c-8b2b-4ca7c71f4682.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70f9d33c-5edf-4d4c-8b2b-4ca7c71f4682.png)'
- en: 'There are many paths available to reach the same destination: only one is the
    shortest.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多路径可以到达相同的目的地：只有一条是最短的。
- en: Let's now examine the concepts underlying this technology. We will begin by
    comparing two very popular techniques.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来分析这项技术的基本概念。我们将通过比较两种非常流行的技术开始。
- en: Learning the top-down DP approach
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习自顶向下的DP方法
- en: 'To understand the mechanism behind DP, we can compare it with another very
    common problem-solving mechanism—**divide and conquer**. With this mechanism,
    a problem is divided into two or more subproblems, and the solution of the original
    problem is constructed starting from the subproblem solutions. This approach is
    called a top-down technique and works according to the following procedure:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解动态规划背后的机制，我们可以将其与另一种非常常见的解决问题的机制——**分治法**进行比较。通过分治法，一个问题被分解成两个或更多的子问题，原问题的解是从子问题的解开始构建的。这种方法叫做自顶向下的技术，按以下步骤进行：
- en: Divide the problem instance into two or more sub-instances.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将问题实例分解成两个或更多的子实例。
- en: Recursively solve the problem for each sub-instance.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个子实例递归地解决问题。
- en: Recombine the subproblem solution in order to obtain the global solution.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新组合子问题的解，以获得全局解。
- en: This mechanism is widely applied to the resolution of multiple problems. The
    most popular applications are two of the most commonly used sorting algorithms—quick
    sort and merge sort.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制广泛应用于解决多个问题。最常见的应用是两种最常用的排序算法——快速排序和归并排序。
- en: For example, in the **quick sort** algorithm, the elements of the list to be
    sorted are divided into two blocks, the smaller ones and the larger ones of a
    pivot, and the algorithm is called recursively on the two blocks. In merge sort,
    the algorithm finds the index of the central position and divides the list into
    two blocks each with n/2 elements. Then the algorithm is called recursively on
    the two blocks.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在**快速排序**算法中，待排序列表的元素被分为两个块，一块是小于主元的元素，另一块是大于主元的元素，然后算法会递归地对这两个块进行调用。归并排序中，算法找到中间位置的索引，并将列表分成两个各包含
    n/2 元素的块。然后，算法会递归地对这两个块进行调用。
- en: There are cases in which divide and conquer is not applicable because we do
    not know how to get subproblems—the problem does not contain enough information
    to allow us to decide how to break it into several parts.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，分治法无法应用，因为我们不知道如何获得子问题——问题本身并不包含足够的信息来让我们决定如何将其分解为多个部分。
- en: 'In this case, DP comes into play: we proceed to calculate the solutions of
    all possible subproblems, and starting from sub-solutions we obtain new sub-solutions
    until the original problem is solved. Unlike the divide and conquer mechanism,
    the subproblems to be solved are not necessarily disjoint, which means one subproblem
    can be common to several other subproblems. In order to avoid recalculation of
    a subproblem more than once, the subproblems are resolved with a bottom-up strategy—from
    the smallest subproblem to the largest subproblem, and the solutions to these
    subproblems are stored in appropriate tables so that they are available (if necessary)
    for the solution of other subproblems.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，动态规划发挥作用：我们继续计算所有可能的子问题的解，并从子解开始，逐步得到新的子解，直到解决原问题。与分治法不同，待解决的子问题不一定是互不相交的，这意味着一个子问题可以是多个其他子问题的共同部分。为了避免对子问题进行重复计算，子问题通过自底向上的策略解决——从最小的子问题开始解决，逐步向大的子问题推进，并将这些子问题的解存储在适当的表格中，以便它们可以在需要时（如有必要）为解决其他子问题提供帮助。
- en: Often in recursive algorithms we find ourselves dealing with procedures that
    are unnecessarily burdensome from a computational point of view. Let's see how
    we can tackle this problem.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在递归算法中，我们常常遇到一些从计算角度来看不必要的繁重过程。让我们看看如何解决这个问题。
- en: Analyzing the difference between recursion and memoization
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析递归和记忆化之间的区别
- en: On the basis of what has been said here, we can deduce that DP is used in cases
    where there is a recursive definition of the problem, but the direct transformation
    of this definition into an algorithm generates a program of exponential complexity
    due to the repeated calculation on the same subsets of data from the different
    recursive calls. An example is the calculation of the Fibonacci numbers, which
    we will analyze in detail later.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里所说的基础上，我们可以推断出动态规划（DP）用于那些具有递归定义的问题，但将该定义直接转化为算法会由于不同递归调用对相同数据子集的重复计算，导致程序的时间复杂度呈指数增长。一个例子是斐波那契数的计算，我们将在后续详细分析。
- en: We have seen that DP is a technique for solving recursive problems more efficiently.
    Why does this happen? Many times in the recursive procedures we solve the subproblems
    repeatedly. In DP this does not happen—we memorize the solution of these subproblems
    so that we do not have to solve them again. This is called **memoization**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，动态规划（DP）是一种更高效地解决递归问题的技术。这是为什么呢？在递归过程中，我们很多时候会重复地解决子问题。在动态规划中，情况并非如此——我们会记住这些子问题的解，从而避免再次求解。这种做法叫做**记忆化**。
- en: If the value of a variable at a given step depends on the results of previous
    calculations, and if the same calculations are repeated over and over, then it
    is convenient to store intermediate results so as to avoid repeating computationally
    expensive calculations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个变量在某一给定步骤的值依赖于之前计算的结果，并且这些计算会被重复多次，那么存储中间结果就变得非常有用，从而避免重复计算那些计算成本高昂的部分。
- en: 'To better understand the difference between recursion and memoization, let''s
    analyze a simple example: the calculation of the factorial of a number. It is
    called factorial of a natural number n, indicated with *n!*, the product of positive
    integers less than or equal to that number. The calculation of the factorial of
    n is given by the following formula:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解递归和记忆化之间的区别，我们来分析一个简单的例子：计算一个数字的阶乘。一个自然数n的阶乘，记作*n!*，是小于或等于该数字的所有正整数的乘积。n的阶乘计算公式如下：
- en: '![](img/6c2795e7-8eef-4276-8325-fccbaf3ad1aa.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c2795e7-8eef-4276-8325-fccbaf3ad1aa.png)'
- en: 'The calculation of the factorial of a number can also be defined recursively:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数字的阶乘也可以通过递归来定义：
- en: '![](img/68a097b4-8e80-4694-9e01-3ec25e5e14b2.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68a097b4-8e80-4694-9e01-3ec25e5e14b2.png)'
- en: 'A function is called **recursive** if it calls itself. The recursive function
    can directly solve only particular cases of a problem called base cases (such
    as those present in the previous formula): if it is invoked, passing some data
    that constitute one of the base cases, then it returns a result. At each call,
    the data is reduced, so at a certain point we arrive at one of the base cases.
    When the function calls itself, it suspends its execution to make the new call.
    The execution resumes when the internal call to itself ends. The sequence of recursive
    calls ends when the innermost one (nested) encounters one of the base cases. Now
    let''s see how to optimize this technique.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数调用自身，则称该函数为**递归**函数。递归函数只能直接解决问题的某些特定情况，这些特定情况称为基准情况（例如之前公式中的那些情况）：如果传入的数据属于某个基准情况，它就返回一个结果。在每次调用时，数据都会减少，直到某个时刻，我们到达了基准情况。当函数调用自身时，它会暂停当前执行，去执行新的调用。内部调用结束后，执行会恢复。递归调用的序列在最内层的调用遇到基准情况时终止。现在让我们看看如何优化这种技术。
- en: Learning the optimization techniques
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习优化技术
- en: An optimization problem is a problem whose solution can be measured in terms
    of a cost function, also called an objective. The value to look for is normally
    the minimum value or the maximum value of this function. Optimization problems
    can be reduced to a sequence of decision problems.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 优化问题是一个可以通过成本函数（也叫做目标函数）来衡量其解的问题。要寻找的值通常是该函数的最小值或最大值。优化问题可以被简化为一系列的决策问题。
- en: To solve an optimization problem it is necessary to use an iterative algorithm.
    That is a calculation program that, given a current approximation of the solution,
    determines a new approximation with an appropriate sequence of operations. Starting
    from an initial approximation, a succession of possible solutions to the problem
    is thus determined.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决优化问题，必须使用迭代算法。即一种计算程序，它在给定当前解的近似值时，通过适当的操作序列来确定一个新的近似值。从一个初始近似值开始，问题的可能解就以一种连续的方式被确定出来。
- en: 'The search algorithms of the optimal solution can be classified into the following
    three classes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最优解的搜索算法可以分为以下三类：
- en: '**Enumerative techniques**: Enumerative techniques look for the optimal solution
    in all the points of the domain of the function. Simplifications can come from
    reducing the problem to simpler subproblems. DP is one of these techniques.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列举技术**：列举技术通过遍历函数定义域内的所有点来寻找最优解。通过将问题简化为更简单的子问题，可以减少问题的复杂性。动态规划（DP）就是其中的一种技术。'
- en: '**Numerical techniques**: These techniques optimize the problem by exploiting
    a set of necessary and sufficient conditions. These can be classified as direct
    and indirect. Indirect methods look for the least function by solving a set of
    non-linear functions and searching the solution iteratively until the gradient
    of the cost function is null. Direct methods make the gradient guide the search
    for the solution.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数值技巧**：这些技巧通过利用一组必要且充分的条件来优化问题。它们可以分为直接方法和间接方法。间接方法通过求解一组非线性方程并迭代地寻找解，直到代价函数的梯度为零，来寻找最小值。直接方法则通过梯度指导搜索解的过程。'
- en: '**Probabilistic techniques**: Probabilistic techniques are based on enumerative
    techniques, but they use additional information to carry out the research and
    can be seen as evolutionary processes. This category includes the simulated annealing
    algorithm, which uses a thermodynamic evolutionary process, and the class of genetic
    algorithms, which exploit biological evolutionary techniques.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**概率技巧**：概率技巧基于枚举技术，但它们使用额外的信息来进行研究，可以看作是进化过程。这一类包括模拟退火算法，它使用热力学进化过程，以及基因算法类，它们利用生物进化技术。'
- en: In the next section, we will discuss these optimization techniques based on
    DP.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将讨论基于动态规划（DP）的优化技术。
- en: Calculating the Fibonacci sequence
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算费波那契数列
- en: 'Leonardo Pisano, also called Fibonacci, was a famous Italian mathematician
    (Pisa 1175 - 1240). His name is linked to the Fibonacci succession, which arose
    from a problem proposed by the Emperor Frederick II of Swabia. In Pisa in 1223
    in a tournament of mathematicians, he proposed the following problem: *How many
    pairs of rabbits are obtained in a year, excluding cases of death, supposing that
    each couple gives birth to another couple every month and that the youngest couples
    are able to reproduce already at the second month of life?*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列奥纳多·皮萨诺，也叫费波那契，是一位著名的意大利数学家（皮萨，1175 - 1240）。他的名字与费波那契数列相关，该数列源自斯瓦比亚皇帝腓特烈二世提出的一个问题。1223年，在比萨的数学家比赛中，他提出了如下问题：*在不考虑死亡的情况下，每对兔子每月生育一对兔子，且最年轻的兔子在生命的第二个月就能繁殖，一年内能得到多少对兔子？*
- en: 'Fibonacci gave such a quick answer to the test that someone thought the tournament
    was rigged:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 费波那契对测试给出了如此快速的回答，以至于有人认为比赛是作弊的：
- en: '![](img/c66e948b-867c-4e25-b839-a0f4eacfa772.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c66e948b-867c-4e25-b839-a0f4eacfa772.png)'
- en: 'Look at the series given here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这里给出的数列：
- en: The first 2 elements are 1, 1.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前两个元素是 1, 1。
- en: Every other element is given by the sum of the two preceding it.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个元素是由前两个元素之和给出的。
- en: 'Indicating with *F(n)*, the number of pairs present in month n, the Fibonacci
    sequence becomes the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以 *F(n)* 表示第 n 个月的对数，费波那契数列变为以下形式：
- en: '*F(1) = 1*'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*F(1) = 1*'
- en: '*F(2) = 1*'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*F(2) = 1*'
- en: '*F(n) = F (n-1) + F (n-2)* in the *n*^(th) month, where *n*> 2'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*F(n) = F (n-1) + F (n-2)* 在第 *n* 个月，其中 *n*> 2'
- en: On the basis of this definition we conventionally assume *F(0) = 0*, so that
    the recursive relation *F(n) = F(n-1) + F(n-2)* is valid also for *n = 2*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个定义，我们通常假设 *F(0) = 0*，以便递归关系 *F(n) = F(n-1) + F(n-2)* 在 *n = 2* 时也成立。
- en: The Fibonacci succession has led us to study many areas of mathematics and natural
    sciences. However, despite having discovered this important succession, Fibonacci
    did not grasp many aspects of it. Four centuries later, Kepler observed that the
    relationship between two successive terms tended to the Golden Ratio.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 费波那契数列促使我们研究了数学和自然科学的许多领域。然而，尽管发现了这一重要数列，费波那契并没有掌握它的许多方面。四个世纪后，开普勒观察到，两个连续项之间的关系趋向于黄金比例。
- en: 'So let''s see a simple function in R that calculates the Fibonacci number through
    a recursive procedure:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，来看看一个简单的 R 函数，它通过递归过程计算费波那契数：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Within the function, there is an `if` structure with two options: if `n> 2`
    the function calls itself when `n<=2` returns `1`. The call to `FibRec(n-1)` asks
    the function to solve a problem simpler than the initial one (the value is lower),
    but it is always the same problem. The function continues to call itself until
    it reaches the basic case that it can solve immediately. To compare two solution
    techniques, the `Sys.time()` function is used to calculate the computational cost.
    The results are shown as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，有一个 `if` 结构包含两个选项：如果 `n> 2`，函数会调用自身；当 `n<=2` 时返回 `1`。对 `FibRec(n-1)` 的调用要求函数解决比最初问题更简单的问题（数值较小），但问题始终是相同的。函数会一直调用自身，直到达到它可以立即解决的基本情况。为了比较两种解决技术，使用
    `Sys.time()` 函数来计算计算成本。结果如下所示：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This program, given the nature of the recursive algorithm used, requires n +
    1 invocations of the factorial function to arrive at a result, and each of these
    invocations, in turn, has a cost associated with the time taken by the function
    to return the calculated value.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用的递归算法的性质，该程序需要进行 n + 1 次阶乘函数调用才能得到结果，并且每次调用都伴随着与函数返回计算值所需时间相关的成本。
- en: 'This program can be improved through memoization as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过记忆化，可以按如下方式改进该程序：
- en: Create a variable to store temporary results (`RecTable`).
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量来存储临时结果（`RecTable`）。
- en: Before performing a calculation, find out if the calculation has already been
    done. If so, use the stored result.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行计算之前，先检查该计算是否已经完成。如果完成了，则使用存储的结果。
- en: If we are calculating this for the first time, store the results for future
    use.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这是第一次计算，存储结果以备将来使用。
- en: 'A memoized version of the program is shown in the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了程序的记忆化版本：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this case, we store the Fibonacci numbers in a table that can then be retrieved
    for the next calculation. In this way, the entire calculation is avoided at each
    occurrence. Memoization increases the efficiency of a function in terms of time.
    The improvement is highlighted as often as this function is called, thus determining
    an acceleration of the algorithm. Here are the results:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将斐波那契数存储在一个表中，之后可以在下一次计算时检索。这样，避免了每次都进行整个计算。记忆化提高了函数的时间效率。每次该函数被调用时，都会突出改进，从而加速了算法。以下是结果：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: From the comparison between the two computational costs, it is possible to notice
    that the version with memoization is faster. Now let's see how to use the potential
    offered by DP in the context of reinforcement learning.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比较两种计算成本，可以发现带有记忆化的版本更快。现在让我们来看一下如何在强化学习的背景下利用 DP 提供的潜力。
- en: Implementing DP in reinforcement learning applications
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在强化学习应用中实现 DP
- en: DP represents a set of algorithms that can be used to calculate an optimal policy
    given a perfect model of the environment in the form of an MDP. The fundamental
    idea of DP, as well as reinforcement learning in general, is using state values
    and actions to look for good policies.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: DP 代表一组算法，可用于在环境的完美模型（以 MDP 形式）下计算最优策略。DP 的基本思想，以及强化学习的一般思想，是利用状态值和动作来寻找良好的策略。
- en: 'The DP methods approach the resolution of Markov decision-making processes
    through the iteration of two processes called **policy evaluation** and **policy
    improvement**:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: DP 方法通过迭代两个过程来解决马尔可夫决策过程，分别是 **策略评估** 和 **策略改进**：
- en: Policy evaluation algorithm consists of applying an iterative method to the
    resolution of the Bellman equation. Since convergence is guaranteed to us only
    for k → ∞, we must be content to have good approximations by imposing a stopping
    condition.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略评估算法通过应用迭代方法来求解贝尔曼方程。由于只有当 k → ∞ 时收敛才有保障，我们必须满足于通过设置停止条件得到良好的近似。
- en: Policy improvement algorithm improves the policy based on current values.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略改进算法基于当前值来改进策略。
- en: A disadvantage of the policy iteration algorithm is that in every step we have
    to evaluate a policy. This involves an iterative process that we do not know the
    time of convergence of a priori, which will depend on how the starting policy
    was chosen.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 策略迭代算法的一个缺点是每一步都需要评估一个策略。这涉及到一个迭代过程，我们事先并不知道它的收敛时间，这将取决于起始策略是如何选择的。
- en: One way to overcome this drawback is to cut off the evaluation of the policy
    at a specific step. This operation does not change the guarantee of convergence
    to the optimal value. A special case in which the assessment of the policy is
    blocked step by step (also called sweep) defines the value iteration algorithm.
    In the value iteration algorithm, a single iteration of calculation of the values
    is performed between each step of the policy improvement.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 克服这一缺点的一种方法是，在特定步骤中切断策略的评估。这一操作不会改变收敛到最优值的保证。在策略评估被逐步阻断（也叫做遍历）的特殊情况下，定义了值迭代算法。在值迭代算法中，每次政策改进步骤之间都会执行一次值计算的迭代。
- en: The DP algorithms are therefore essentially based on policy evaluation and policy
    improvement that take place in parallel. The repeated execution of these two processes
    makes the general process converge towards the optimal solution. In the policy
    iteration algorithm, the two phases alternate and each ends before the other begins.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，DP 算法本质上是基于策略评估和策略改进，这两个过程并行进行。反复执行这两个过程使得整个过程趋向于最优解。在策略迭代算法中，这两个阶段交替进行，且每个阶段结束后才开始下一个阶段。
- en: The DP methods operate through the entire set of states that can be assumed
    by the environment, performing a complete backup for each state at each iteration.
    Each update operation performed by the backup updates the value of a status based
    on the values ​​of all possible successor states. These states are weighed for
    their probability of occurrence, induced by the policy of choice and by the dynamics
    of the environment. Full backups are closely related to the Bellman equation,
    they are nothing more than the transformation of the equation into assignment
    instructions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: DP 方法通过环境中所有可能的状态集进行操作，在每次迭代时对每个状态执行完整的备份操作。每次备份操作都根据所有可能的后继状态的值更新一个状态的值。这些状态会根据它们发生的概率进行加权，这个概率由策略选择和环境的动态性共同决定。完整备份与贝尔曼方程密切相关，它们不过是将贝尔曼方程转化为赋值指令的过程。
- en: When a complete backup iteration does not bring any change to the state values,
    convergence is obtained and therefore the final state values ​​fully satisfy the
    Bellman equation. The DP methods are applicable only if there is a perfect model
    of the alternator, which must be equivalent to an MDP.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当一次完整的备份迭代没有对状态值产生任何变化时，收敛就达成，因此最终的状态值完全满足贝尔曼方程。DP 方法仅在存在完美的交替器模型时适用，该模型必须等同于马尔可夫决策过程（MDP）。
- en: Precisely for this reason, the DP algorithms are of little use in reinforcement
    learning, both for their assumption of a perfect model of the environment and
    for the high and expensive computation. But it is still opportune to mention them
    because they represent the theoretical basis of reinforcement learning. In fact,
    all the methods of reinforcement learning try to achieve the same goal of the
    DP methods, only with lower computational cost and without the assumption of a
    perfect model of the environment.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正是由于这个原因，DP 算法在强化学习中的应用有限，既因为它假设环境有完美模型，又因为计算量高且昂贵。但仍然有必要提及它们，因为它们代表了强化学习的理论基础。事实上，所有强化学习方法都试图达到
    DP 方法的同样目标，只是计算成本较低，并且不假设环境有完美的模型。
- en: The DP methods converge to the optimal solution with a number of polynomial
    operations with respect to the number of states 𝑛 and actions 𝑚 against the number
    of exponential operations 𝑚*𝑛 required by methods based on direct search.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: DP 方法通过与状态数 𝑛 和动作数 𝑚 相比的多项式操作次数，收敛到最优解，而与之相对的是基于直接搜索的方法需要 𝑚*𝑛 的指数操作次数。
- en: DP methods update the estimates of the state values on the basis of the estimates
    made in the previous steps. This represents a special property, which is called
    bootstrapping. Several methods of RL perform bootstrapping, even methods that
    do not require a perfect model of the environment, as required by the DP methods.
    Let's see a practical case of using DP.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: DP 方法基于先前步骤中做出的估计，更新状态值的估算。这代表了一种特殊的属性，称为自举（bootstrapping）。多种强化学习方法执行自举，即便是那些不要求环境的完美模型（如
    DP 方法所需的），也同样执行自举。我们来看一个使用 DP 的实际案例。
- en: Solving the knapsack problem
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 求解背包问题
- en: In this section, we will analyze a classic problem that's been studied for more
    than a century, since 1897—the knapsack problem. The first to deal with the knapsack
    problem was the mathematician Tobias Dantzig who gave it the name deriving it
    from the common problem of packing the most useful items without overloading the
    knapsack.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将分析一个经过超过一个世纪研究的经典问题，自1897年以来—背包问题。首位处理背包问题的是数学家托比亚斯·丹齐格，他将其命名为源自普通的装载最有用物品而不过载背包的问题。
- en: 'A problem of this type can be associated with different situations arising
    from real life. To better characterize the problem, we will propose a rather unique
    one: a thief goes into a house and wants to steal valuables. He puts them in his
    knapsack, but is bound by weight. Each object has its own value and weight, so
    he must choose the objects that are of high value but not high weight. It must
    not exceed the weight limit in the knapsack, but at the same time optimize the
    value.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的问题可以与现实生活中不同情况联系起来。为了更好地描述这个问题，我们将提出一个非常独特的情景：一个小偷进入房子并想偷走贵重物品。他把它们放在他的背包里，但受到重量的限制。每个物体都有自己的价值和重量，所以他必须选择价值高但重量不大的物品。不能超过背包的重量限制，但同时又要优化价值。
- en: 'Now, we will address the problem from a mathematical point of view. Suppose
    we have a set X composed of n objects labeled with integers from 1 to *n*: {1,
    2, ..., *n*}. These objects meet the following conditions:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从数学的角度解决这个问题。假设我们有一个由整数标记为1到*n*的n个对象组成的集合X：{1, 2, ..., *n*}。这些对象满足以下条件：
- en: The *i*^(th) object has a weight *p[i]* and value *v[i]*.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第i个物品具有重量p[i]和价值v[i]。
- en: There is only one instance of each object.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个物体只有一个实例。
- en: 'We have a container able to carry at most a weight equal to P. We want to determine
    a subset Y ⊆ X of objects:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个容器，最多可以携带重量为P的物品。我们想确定对象的子集Y ⊆ X：
- en: The total weight of the objects in Y is ≤ P.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Y中物品的总重量≤ P。
- en: The total value of the objects in Y is the maximum possible.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Y中物品的总价值是可能的最大值。
- en: 'These two conditions in mathematical formalism take the following form:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个数学形式中的条件如下：
- en: 'We want to determine a subset Y ⊆ X of objects so that:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望确定一个对象的子集Y ⊆ X，以便：
- en: '![](img/bd3ae9bc-72ff-4ab3-a500-4520fd52432d.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd3ae9bc-72ff-4ab3-a500-4520fd52432d.png)'
- en: 'To maximize the following overall value:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了最大化以下总价值：
- en: '![](img/c4604c6c-d216-4a30-93ad-9152c363f5ef.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c4604c6c-d216-4a30-93ad-9152c363f5ef.png)'
- en: 'As it has been placed, this is an optimization problem. In general, an optimization
    problem has two parts:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如所放置的那样，这是一个优化问题。一般来说，优化问题有两个部分：
- en: A set of constraints (possibly empty) that must be respected.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组必须遵守的约束（可能为空）。
- en: An objective function that must be maximized or minimized.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须最大化或最小化的目标函数。
- en: The mathematical formalism that we have adopted to define the problem unequivocally
    clarifies the two parts we've just mentioned. Many real problems can be formulated
    relatively simply as optimization problems that can then be solved with a calculator.
    Reducing a new problem to a known problem allows the use of existing solutions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经采用的数学形式定义问题，明确澄清了我们刚才提到的两部分。许多实际问题可以相对简单地被表述为可以使用计算器解决的优化问题。将新问题简化为已知问题允许使用现有的解决方案。
- en: As with most of the problems, even for optimization problems, there are different
    approaches to the problem that allow us to reach the solution. Naturally, they
    differ in the complexity of each algorithm in terms of time and memory requirements
    and in terms of programming efforts required.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数问题一样，即使对于优化问题，解决问题的不同方法也允许我们达到解决方案。它们在时间和内存要求的复杂性以及所需的编程工作方面自然有所不同。
- en: 'There are two versions of the problem:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个问题的版本：
- en: '**0-1 knapsack problem**: Each item must be entirely accepted or rejected.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**0-1背包问题**：每个物品要么全部接受，要么全部拒绝。'
- en: '**Fractional knapsack problem**: We can take fractions of items.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分数背包问题**：我们可以取物品的分数部分。'
- en: The substantial difference between the two problems lies in the possibility
    of splitting the items. In the 0-1 knapsack problem, we cannot divide the articles.
    On the contrary, in the fractional knapsack, we can divide the objects to maximize
    the total value of the backpack.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个问题之间的实质差异在于物品是否可以分割。在0-1背包问题中，我们不能分割物品。相反，在分数背包中，我们可以分割物体以最大化背包的总价值。
- en: The problem of the knapsack that we have introduced can be easily applied to
    a problem of optimization of a financial portfolio. In fact, it is sufficient
    to associate the weight of the objects with the weight of the risk of the financial
    product we are considering and the value of the objects with the expected value
    of the financial product. Based on these assumptions, it is possible to select
    financial products that maximize the expected value, keeping the risk below a
    specific value.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍的背包问题可以很容易地应用于金融投资组合优化问题。实际上，只需将物体的重量与考虑中的金融产品的风险权重相关联，将物体的价值与金融产品的预期价值相关联即可。基于这些假设，可以选择使预期价值最大化，并将风险保持在特定值以下的金融产品。
- en: 'In the following sections, we will address the knapsack problem through three
    different approaches:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将通过三种不同的方法解决背包问题：
- en: Brute force
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴力算法
- en: Greedy algorithms
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贪婪算法
- en: DP
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DP
- en: We will try to go into each solution in depth, highlighting their strengths
    and weaknesses.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入探讨每个解决方案，突出它们的优缺点。
- en: Brute force
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴力算法
- en: Brute force lists all the possible values that could represent a solution and
    checks whether each value satisfies the conditions imposed by the problem. This
    algorithm is easily implemented and always returns a solution if it exists, but
    its cost is proportional to the number of possible solutions. Therefore, brute
    force research is typically used when the size of the problem is limited or when
    hypotheses are available that allow us to reduce the set of possible solutions.
    The method is also used when the simplicity of implementation is more important
    than speed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 暴力算法列出了可能表示解决方案的所有可能值，并检查每个值是否满足问题所施加的条件。此算法易于实现，如果存在解决方案，则总是返回解决方案，但其成本与可能解的数量成正比。因此，通常在问题规模有限或存在可以减少可能解集的假设时使用暴力搜索。该方法也用于在实现简单性比速度更重要时。
- en: 'To solve the knapsack problem, brute force is the most immediate solution:
    examine all the possible ways to fill the knapsack, which are *2n*, and print
    an optimal solution (there could be more than one). This approach, for *n* > 15,
    becomes very slow. This algorithm is usually based directly on the definition
    of the problem and on the understanding of the concepts involved.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决背包问题，暴力算法是最直接的解决方案：检查填充背包的所有可能方法，这些方法有*2n*种，并打印出一个最优解（可能不止一个）。对于*n* > 15，这种方法变得非常慢。这种算法通常直接基于问题的定义和相关概念的理解。
- en: 'Here are the essentials of this straightforward algorithm:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个简单算法的要点：
- en: Enumerates every possible combination.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举每种可能的组合。
- en: Choose the best solution (all the combinations are examined, and the one with
    the maximum value and with a total weight less than or equal to P is returned).
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择最佳解决方案（检查所有组合，返回最大值且总重量小于或等于P的组合）。
- en: Optimality is ensured.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化性得到保证。
- en: Extremely costly in time for large *n*. Running time will be *O(2n)*.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于较大的*n*，时间成本极高。运行时间将为*O(2n)*。
- en: 'In the following code block is an example code for solving a 0-1 knapsack problem:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中是解决0-1背包问题的示例代码：
- en: '[PRE4]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will analyze this code line by line. The first lines set the data:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐行分析这段代码。前几行设置了数据：
- en: '[PRE5]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s look at each element:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个元素看一下：
- en: '`W` is the maximum weight capacity.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`W` 是最大重量容量。'
- en: '`WeightArray` is the weights array.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeightArray` 是重量数组。'
- en: '`ValueArray` is the values array.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ValueArray` 是值数组。'
- en: '`DataKnap` is a dataframe containing weights and values.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataKnap` 是包含重量和值的数据框。'
- en: 'Now we will initialize the variables used in the algorithm:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将初始化算法中使用的变量：
- en: '[PRE6]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we said, the brute force algorithm systematically lists all the possible
    values that could represent a solution and check whether each value satisfies
    the conditions imposed by the problem. Since four objects were passed to the system,
    a loop with four steps will be set as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，暴力算法系统地列出了可能表示解决方案的所有可能值，并检查每个值是否满足问题所施加的条件。由于系统传递了四个对象，将设置一个四步循环如下：
- en: '[PRE7]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For each step of the `for` loop, we will calculate all the combinations of
    the objects taken, `i`, at a time without repetition. To do this, the `combn()`
    function was used:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`for`循环的每一步，我们将计算所有取出的物体的组合，`i`次不重复。为此，使用了`combn()`函数：
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This function generates all combinations of the elements of the `DataKnap`
    columns taken `i` at a time. Now we will sum the returned array:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数生成所有`DataKnap`列中元素的组合，取`i`个元素。接下来，我们将对返回的数组进行求和：
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now it is necessary to select only the combinations that return a sum of weights `<=W`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要选择只返回重量总和`<=W`的组合：
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If this operation returns at least one combination, we will calculate the best
    solution:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该操作返回至少一个组合，我们将计算最佳解：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, the list of the best combinations will be printed:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最佳组合的列表将被打印出来：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here are the results returned by the 0-1 knapsack problem solution:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是0-1背包问题解返回的结果：
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The results mean that the best solution return values equal to 37 and the objects
    selected are in 3rd and 4th position. As anticipated, the optimal solution to
    the problem we have just dealt with is the most immediate but also the most expensive
    from the computational point of view. In the following sections, we will seek
    to obtain other solutions, trying save in calculation terms.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，最佳解返回值为37，所选物体位于第3和第4位置。正如预期的那样，我们刚才处理的背包问题的最优解是最直接的，但从计算的角度来看也是最昂贵的。在接下来的部分中，我们将尝试获得其他解，力求在计算上节省开销。
- en: Greedy algorithms
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 贪心算法
- en: Before introducing a greedy algorithm to find an optimal solution to the problem
    of the knapsack, it is appropriate to recall the main characteristics of any greedy
    technique. Any greedy technique proceeds iteratively. Starting from an empty solution,
    element A is added to the partial solution under construction at each iteration.
    Of all the possible candidates to be added, element A is the most promising one,
    that is, if chosen, it leads to the greatest improvement of the objective function.
    It is clear that not all problems can be solved with this strategy; but, only
    those for which it is possible to show that making the best choice at the moment
    leads to an optimal solution globally.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入贪心算法来寻找背包问题的最优解之前，回顾一下任何贪心技术的主要特点是很有必要的。任何贪心技术都是迭代进行的。从一个空的解开始，在每次迭代中，元素A会被添加到正在构建的部分解中。在所有可以添加的候选元素中，元素A是最有前途的，即如果选择它，它将导致目标函数的最大改进。显然，并不是所有问题都能通过这种策略解决；只有那些可以证明当前做出最佳选择能导致全局最优解的问题，才能使用这种方法。
- en: 'Let''s look at an algorithm first that simply performs the following operations:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一个简单的算法，执行以下操作：
- en: Discards all objects weighing more than the maximum capacity (preprocessing).
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 丢弃所有重量超过最大容量的物体（预处理）。
- en: Sorts the objects for a given criterion.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据给定的标准对物体进行排序。
- en: Selects the objects one at a time until the weight constraint is respected.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一次选择一个物体，直到满足重量限制。
- en: Returns the value of the solution and the set of selected objects.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回解的值和所选物体的集合。
- en: 'In the following code block, we can see the code for executing the algorithm:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块中，我们可以看到执行该算法的代码：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will analyze this code line by line. The initial lines set the initial data:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐行分析这段代码。初始的几行设置了初始数据：
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To find the best solution, we first perform a descending pre-order of the objects
    based on the density of value, calculated as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到最佳解，我们首先对物体按价值密度进行降序排列，计算方法如下：
- en: '![](img/72ec34ce-d3bb-4c0e-ad08-d93ac0b700fd.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72ec34ce-d3bb-4c0e-ad08-d93ac0b700fd.png)'
- en: 'This technique is implemented in the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在以下代码中实现：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following lines are used to initialize the variables:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行用于初始化变量：
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, a `while` loop will be used to iterate the procedure:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将使用`while`循环来迭代该过程：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The loop will be repeated until both codes are true. As soon as one of the two
    is false, the loop will be stopped. The first check is performed on the number
    of rows of the data matrix, at most there will be as many iterations as there
    are rows. The second check is carried out on the maximum capacity set. As soon
    as this is exceeded, the loop will be stopped.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 循环会一直重复，直到两个条件都为真。一旦其中一个条件为假，循环就会停止。第一次检查是在数据矩阵的行数上进行的，最多会有与行数相等的迭代次数。第二次检查是在设定的最大容量上进行的。一旦超过这个容量，循环会停止。
- en: 'Finally, the results are printed:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，结果会被打印出来：
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The results are shown in the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示如下：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: From the analysis of the previous data, we can note that we have not obtained
    the optimal solution as in the case of the brute force algorithm, but the procedure
    is very fast.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 从对前面数据的分析中，我们可以注意到，我们没有像暴力算法那样获得最优解，但这个过程非常快速。
- en: Implementing a solution with DP
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动态规划实现解法
- en: In the previous sections, we have seen how the knapsack problem can be solved
    through different approaches. In particular, we have learned to treat this problem
    with an algorithm called brute force. In this case, we obtained the optimal solution
    with an extremely heavy computational cost. On the contrary, the greedy solution,
    seen later, gave us a lighter algorithm from a computational point of view but
    did not allow us to obtain the optimal solution. A solution that combines both
    these needs – optimal solution and fast algorithm – can be provided by DP.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经看到了如何通过不同的方式解决背包问题。特别是，我们学会了用一种叫做暴力求解的算法来处理这个问题。在这种情况下，我们通过极大的计算代价获得了最优解。相反，后面看到的贪心算法从计算的角度给我们提供了一个更轻量的算法，但它无法获得最优解。通过动态规划（DP），可以提供一个同时满足最优解和快速算法这两个需求的解法。
- en: In DP, we subdivide an optimization problem into simpler subproblems and store
    the solution for each subproblem so that each subproblem is solved only once.
    The idea behind the method is to calculate solutions to subproblems once and store
    the solutions in a table so that they can be reused (repeatedly) later.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态规划中，我们将一个优化问题分解为更简单的子问题，并存储每个子问题的解，以便每个子问题仅解决一次。该方法的核心思想是，首先计算子问题的解并将其存储在表格中，以便稍后可以重复使用这些解（重复使用）。
- en: 'In the following code block, a knapsack problem solution is implemented using
    DP:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，使用动态规划实现了一个背包问题的解决方案：
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will analyze this code line by line. This algorithm starts with the definition
    of the data that will be used in the procedure:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐行分析这段代码。这个算法从定义将在过程中使用的数据开始：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And then define the other variables:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后定义其他变量：
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s look at the elements of this code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一下这段代码的元素：
- en: '`Tabweights` is a vector containing the weights and 0 as the first element.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tabweights` 是一个包含重量和 0 作为第一个元素的向量。'
- en: '`TabValues` is a vector containing the values and 0 as the first element.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TabValues` 是一个包含值和 0 作为第一个元素的向量。'
- en: '`n` is the number of objects.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n` 是物品的数量。'
- en: '`TabMatrix` is a tabular matrix.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TabMatrix` 是一个表格矩阵。'
- en: 'We first define and initialize the table that will contain the values. The
    table is built column by column from the top to the bottom, as shown in the following
    diagram:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义并初始化一个将包含值的表格。该表格是从上到下按列构建的，如下图所示：
- en: '![](img/ff9520f5-86ed-4b1c-b46e-36f64f08a3cd.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff9520f5-86ed-4b1c-b46e-36f64f08a3cd.png)'
- en: 'Then we set an iterative loop on all objects and on all weight values:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们设置一个对所有物品和所有重量值的迭代循环：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First, we fill the first line `i=1` with 0\. This means that when no object
    is considered the weight is 0, so we fill the first column w = 1 with 0\. This
    means that when the weight is 0, the objects considered are 0\. Practically, we
    initialize the first line to 0, which corresponds to the case in which, for different
    transportable weights, we have no object (T[1, w] = 0). Initialize the first column
    to 0, which corresponds to the case in which, for several possible objects, I
    have a backpack of zero capacity (T [i, 1] = 0).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们用 0 填充第一行 `i=1`。这意味着当没有物品时，重量为 0，因此我们将第一列 w = 1 填充为 0。这意味着当重量为 0 时，所考虑的物品为
    0。实际上，我们将第一行初始化为 0，这对应于对于不同的可运输重量，我们没有任何物品的情况（T[1, w] = 0）。将第一列初始化为 0，这对应于对于多个可能的物品，我有一个零容量的背包的情况（T[i,
    1] = 0）。
- en: 'The rule to fill the table is provided by the following algorithm:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 填充表格的规则由以下算法提供：
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If the weight of the *i^(th)* element is greater than that of the column then
    the *i^(th)* element will be equal to the previous one, altitudes will be calculated
    with the following formula:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第 *i^(th)* 个元素的重量大于列的重量，则第 *i^(th)* 个元素将等于前一个元素，海拔将通过以下公式计算：
- en: '![](img/e0cc1149-7f7d-46fc-a9b1-9202e45e46b4.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0cc1149-7f7d-46fc-a9b1-9202e45e46b4.png)'
- en: 'Once the last cell of the last row of the table has been reached, we can memorize
    the result obtained, which represents the maximum value of the objects that can
    be carried in the knapsack:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦到达表格最后一行的最后一个单元格，我们可以记住得到的结果，这代表背包中可以携带物品的最大值：
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following result is returned:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 返回以下结果：
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The procedure followed so far does not indicate which subset provides the optimal
    solution. We must extract this information by analyzing the last column of the
    table (w = P); we will run through it from the last value to the top one:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的过程没有指出哪个子集提供最优解。我们必须通过分析表格的最后一列（w = P）来提取此信息；我们将从最后一个值开始，逐步向上运行。
- en: '[PRE28]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the current element is the same as the previous one, let''s move on to the
    next one; otherwise, the current object is included in the knapsack:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前元素与前一个元素相同，我们就跳到下一个；否则，当前物体将被包含在背包中：
- en: '[PRE29]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If an element is inserted in the backpack, the column is obtained by subtracting
    the current value of `w` from the weight relative to the selected object:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元素被插入到背包中，通过从选定物体的重量中减去当前`w`值来获得列值：
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, the items selected will be printed:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所选的物品将被打印出来：
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The results are shown in the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The DP algorithm allowed us to obtain the optimal solution, saving on computational
    costs.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 动态规划（DP）算法使我们能够获得最优解，从而节省计算成本。
- en: In the next section, we will analyze a practical case; we will optimize the
    navigation system of a robot.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将分析一个实际案例；我们将优化机器人的导航系统。
- en: Optimization of a robot navigation system
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器人导航系统的优化
- en: A robot is a machine that performs particular actions based on the commands
    that are provided, either based on direct human supervision, or independently
    based on general guidelines using the artificial intelligence processes. Robots
    should be able to replace or assist humans with activities such as, manufacturing,
    construction, handling heavy and dangerous materials in conditions not suitable
    for humans, or simply to free a person from commitments.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人是一种根据提供的指令执行特定动作的机器，这些指令可以是基于直接人工监督，或基于使用人工智能过程的通用指导来独立执行的。机器人应该能够替代或协助人类完成诸如制造、建筑、在不适合人类的条件下处理重型和危险物料，或者仅仅是解放一个人免于承担某些责任的工作。
- en: A robot should be equipped with guided connections by feedback between perception
    and action, and not by direct human control. The action can take the form of electromagnetic
    motors, or actuators, that move a limb, open and close a gripper, or move the
    robot. Step-by-step control and feedback are provided by a program that runs from
    an external or internal robot computer, or from a microcontroller. Based on this
    definition, the robot concept can include almost all automated devices.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人应通过感知与行动之间的反馈来装备引导连接，而不是通过直接的人工控制。动作可以通过电磁马达或执行器的形式来进行，这些执行器可以移动四肢、开关夹爪或移动机器人。逐步控制和反馈由一个外部或内部机器人计算机或微控制器运行的程序提供。根据这个定义，机器人概念几乎可以包括所有自动化设备。
- en: Training an agent to move in an environment
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练一个代理在环境中移动
- en: To understand how the problems connected with the autonomous navigation of a
    robot are tackled, we will begin with a broadly-based problem—the `gridworld`
    problem. In these problems, the environment is defined as a simple 2D rectangular
    grid of dimensions (N, M) with an agent starting from a grid square and trying
    to move to another grid square located elsewhere. This environment is perfect
    for the application of reinforcement learning algorithms to discover optimal routes
    and policies for the agents on the grid to reach the desired target grid squares
    in the fewest number of moves.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解如何解决与机器人自主导航相关的问题，我们将从一个广泛的问题开始——`gridworld`问题。在这些问题中，环境被定义为一个简单的二维矩形网格，尺寸为(N,
    M)，代理从一个网格格子出发，试图移动到另一个位于其他位置的网格格子。这个环境非常适合应用强化学习算法，帮助代理在网格上发现到达目标网格格子的最优路径和策略，以最少的移动次数达到目标。
- en: 'The following diagram shows a 5 x 5 grid:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了一个 5 x 5 的网格：
- en: '![](img/725e3703-65b4-4651-91c5-45826b1d2643.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/725e3703-65b4-4651-91c5-45826b1d2643.png)'
- en: The agent evolves while exploring the states. There were no terminals. The agent
    can move {right, left, up, and down}. If the action takes the agent off the grid,
    he remains in the same state, but a negative reward is applied. For all other
    states (and actions) it is R = -2, except for the actions that move the agent
    to the finish line. In this case, all four actions get R = +20 and bring the agent
    to the final state.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 代理在探索状态的过程中不断演化。该环境没有终止状态。代理可以执行{右移、左移、上移、下移}的动作。如果动作使代理移出网格，代理将保持在当前状态，但会应用一个负奖励。对于所有其他状态（和动作），奖励为R
    = -2，除了将代理移至终点的动作。在这种情况下，四个动作的奖励为R = +20，并将代理带到最终状态。
- en: 'To better understand the context, we will only deal with the problem of a 2
    x 2 grid with a wall that prohibits the passage from the 1st grid to the 4th,
    as indicated in the following diagram:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解上下文，我们将只处理一个2 x 2网格的问题，该网格中有一堵墙，禁止从第1格到第4格的通过，具体如以下图所示：
- en: '![](img/53d3833c-7bc8-453c-bd47-49b2a51a1c49.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53d3833c-7bc8-453c-bd47-49b2a51a1c49.png)'
- en: 'Our goal is to develop the best policy to reach cell C4 (end) starting from
    cell C1 (start). The following code is an example of solving a gridworld problem:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是制定出最优策略，从C1（起点）出发，最终到达C4（终点）。以下代码是解决网格世界问题的一个示例：
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We will analyze this code line by line. First, we loaded the library:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐行分析这段代码。首先，我们加载了库：
- en: '[PRE34]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we set all possible actions:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置所有可能的动作：
- en: '[PRE35]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Each action matrix is of the 4 x 4 type. In fact, it contains all the probabilities
    from each state (represented by the lines) when it is possible to transit to another
    state (represented by the columns). For example, the first row of the MoveUp matrix
    contains all the probabilities that start from the state C1 it is possible to
    pass in the other states with the action up. It is clear that in this state, with
    this action, I can transit in the state C2\. In fact, the relative probability
    is 0.7\. The second row of the same matrix contains the probabilities from the
    state C2 passes to the other states with the action up, in which case the highest
    probability is that it remains in this state.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 每个动作矩阵都是4 x 4类型。事实上，它包含了从每个状态（由行表示）出发，在可能转移到其他状态（由列表示）时的所有概率。例如，MoveUp矩阵的第一行包含了从C1状态出发，进行向上的动作时能够转移到其他状态的所有概率。显然，在这个状态下，执行此动作时，我可以转移到状态C2。事实上，相关的概率是0.7。相同矩阵的第二行包含了从C2状态出发，执行向上的动作时能够转移到其他状态的概率，在这种情况下，最大概率是它保持在此状态。
- en: 'In the next step, we will combine all actions defined in a list:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步，我们将把所有定义的动作合并成一个列表：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s define the rewards and penalties allowed for the problem according to
    the hypothesis:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 根据假设，我们来定义问题允许的奖励和惩罚：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Before we move on, we have to check the format of the problem as we have defined.
    We will use the `mdp_check()` function:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们必须检查我们定义的问题格式。我们将使用`mdp_check()`函数：
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This function checks whether the MDP defined by the transition probability
    array (`AllActions`) and the reward matrix (`AllRewards`) is valid. If `AllActions`
    and `AllRewards` are correct, the function returns an empty error message. In
    the opposite case, the function returns an error message describing the problem.
    Let''s search the optimal policy for the navigation from C1 to C4:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数检查由转移概率数组（`AllActions`）和奖励矩阵（`AllRewards`）定义的MDP是否有效。如果`AllActions`和`AllRewards`是正确的，函数将返回一个空的错误消息。反之，函数将返回一个描述问题的错误消息。让我们搜索从C1到C4的最优策略：
- en: '[PRE39]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `mdp_policy_iteration()` function was used. This function applies the policy
    iteration algorithm to solve discounted MDP. The algorithm consists in improving
    the policy iteratively, using the evaluation of the current policy. Iterating
    is stopped when two successive policies are identical or when a specified number
    of iterations have been performed. Three arguments were passed:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用了`mdp_policy_iteration()`函数。这个函数应用策略迭代算法来解决折扣MDP。该算法的基本思路是通过评估当前策略，迭代地改善策略。当两次连续的策略相同或已达到指定的迭代次数时，迭代过程停止。传入了三个参数：
- en: '`AllActions`: Transition probability array. This array can be a three-dimensional
    array, or a list, each element containing a sparse matrix.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AllActions`：转移概率数组。这个数组可以是一个三维数组，也可以是一个列表，每个元素包含一个稀疏矩阵。'
- en: '`AllRewards`: Reward array. This array can be a three-dimensional array or
    a list, each element containing a sparse matrix or a two-dimensional matrix possibly
    sparse.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AllRewards`：奖励数组。这个数组可以是一个三维数组或一个列表，每个元素包含一个稀疏矩阵或一个可能是稀疏的二维矩阵。'
- en: '`discount`: Discount factor. Discount is a real number between [0; 1].'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`discount`：折扣因子。折扣因子是一个介于[0; 1]之间的实数。'
- en: 'At this point, we can recover the policy:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们可以恢复策略：
- en: '[PRE40]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following results are returned:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 返回以下结果：
- en: '[PRE41]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To better understand the policy, we can extract the names of the actions defined
    with the policy:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解策略，我们可以提取由策略定义的动作名称：
- en: '[PRE42]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following results are returned:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 返回以下结果：
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now we can extract the optimal values at each step. These values can be different
    in each run:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以提取每个步骤的最优值。这些值在每次运行时可能不同：
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following results are returned:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 返回以下结果：
- en: '[PRE45]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We talked about iterations. In fact, we can see in how many iterations the
    algorithm has taken to reach convergence:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了迭代。实际上，我们可以看到算法在多少次迭代后达到收敛：
- en: '[PRE46]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The following results are returned:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 返回以下结果：
- en: '[PRE47]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we print the time of execution:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们打印了执行时间：
- en: '[PRE48]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following result is returned:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 返回以下结果：
- en: '[PRE49]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The problem faced is trivial but allows us to understand how it must be addressed.
    A larger grid must be treated in the same way unless it defines the matrices of
    the actions and rewards that will be the greatest.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 面临的问题看似微不足道，但它让我们理解了必须如何处理。除非定义了最大行动和奖励的矩阵，否则必须以相同的方式处理更大的网格。
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we have addressed the basics concepts of the optimization
    techniques. To begin with, we learned the essential elements underlying DP. In
    DP, we subdivide an optimization problem into simpler subproblems: we proceed
    to calculate the solutions of all possible subproblems, and from these sub-solutions
    we obtain new sub-solutions, and then solve the original problem.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了优化技术的基本概念。首先，我们学习了动态规划（DP）背后的基本元素。在动态规划中，我们将一个优化问题细分为更简单的子问题：我们计算所有可能子问题的解，从这些子解中获取新的子解，然后解决原始问题。
- en: 'Then we learned the difference between recursion and memoization. Subsequently,
    we learned the basis of the knapsack problem. This problem was addressed through
    three different approaches: brute force, greedy algorithms, and DP. For each approach,
    a solution algorithm was provided and the results were compared.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们学习了递归与备忘录化的区别。随后，我们学习了背包问题的基础。这个问题通过三种不同的方法进行了解决：暴力法、贪心算法和动态规划。对于每种方法，提供了一个解法算法并进行了结果比较。
- en: Finally, the optimization of a navigation route was discussed. To handle autonomous
    navigation of a robot, we learned to tackle the problem of searching for a path
    in a gridworld. In this way, we have seen how to solve the problem of finding
    the optimal policy to find the route.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了导航路径的优化问题。为了处理机器人自主导航，我们学习了如何解决在网格世界中寻找路径的问题。通过这种方式，我们看到了如何解决找到最佳策略以确定路径的问题。
- en: In the next chapter, we will learn the basic concepts of forecasting techniques.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习预测技术的基本概念。
