- en: Getting Started with TensorFlow.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 TensorFlow.js
- en: So far, we have gently introduced ourselves to the wonderful world of deep learning
    and we have got a fair sense of what deep learning has to offer in terms of making
    today's web applications more intelligent. In [Chapter 1](f97d928f-3614-4d12-ad37-d5736008f542.xhtml),
    *Demystifying Artificial Intelligence and Fundamentals of Machine Learning*, we
    saw a detailed overview of the web applications before and after AI breakout.
    In [Chapter 3](a33bccdc-8664-4ae7-be82-b066e5b64850.xhtml), *Creating Your First
    Deep Learning Web Application*, we built ourselves a simple image classifier-based
    web application using a simple neural network.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经轻松地了解了深度学习的奇妙世界，并对深度学习在使现代 Web 应用更加智能方面的潜力有了一个大致的了解。在[第一章](f97d928f-3614-4d12-ad37-d5736008f542.xhtml)，*揭开人工智能的神秘面纱与机器学习基础*中，我们详细了解了
    AI 突破前后的 Web 应用概况。在[第三章](a33bccdc-8664-4ae7-be82-b066e5b64850.xhtml)，*创建你的第一个深度学习
    Web 应用*中，我们使用一个简单的神经网络构建了一个基于图像分类的 Web 应用。
- en: Web applications are all around us and they have easily become inseparable parts
    of our day-to-day lives. When it comes to building web applications, the use of
    JavaScript is too hard to ignore. So, what if we built an intelligent web application
    using JavaScript and no other scripting language? In this chapter, we are going
    to see how we can use a JavaScript library, called **TensorFlow.js** (**TF.js**),
    to build a deep learning-enabled web application—we are going to do all of this
    in a web browser.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Web 应用无处不在，已经成为我们日常生活中不可或缺的一部分。在构建 Web 应用时，JavaScript 的使用几乎是无法忽视的。那么，如果我们只使用
    JavaScript，而不依赖其他脚本语言，来构建一个智能的 Web 应用会怎样呢？在本章中，我们将展示如何使用一个名为 **TensorFlow.js**（**TF.js**）的
    JavaScript 库，构建一个支持深度学习的 Web 应用——这一切都将在 Web 浏览器中完成。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The fundamentals of TF.js and its offerings
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TF.js 的基本原理及其功能
- en: Developing a deep learning model with TF.js and making inferences
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 TF.js 开发深度学习模型并进行推理
- en: Using the pretrained models directly in the browser
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中直接使用预训练模型
- en: Building a web application to recognize flower species
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个用于识别花卉种类的 Web 应用
- en: Advantages and limitations of TF.js
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TF.js 的优势与局限
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can access the code used in this chapter at [https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/tree/master/Chapter4](https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/tree/master/Chapter4).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以访问本章使用的代码，地址为 [https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/tree/master/Chapter4](https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/tree/master/Chapter4)。
- en: 'To work on this chapter, you''ll need the following software:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的内容，你需要以下软件：
- en: TF.js 0.15.1+
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TF.js 0.15.1+
- en: The `@tensorflow/tfjs-node` 0.3.0+ package from the NPM repository
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 NPM 仓库的 `@tensorflow/tfjs-node` 0.3.0+ 包
- en: The fundamentals of TF.js
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TF.js 的基本原理
- en: In this section, we are going to briefly review some of the fundamental concepts
    of TF.js. We will start off by introducing TensorFlow and then we will proceed
    to study different components of TF.js.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要回顾一些 TF.js 的基本概念。我们将从介绍 TensorFlow 开始，然后继续研究 TF.js 的不同组件。
- en: What is TensorFlow?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 TensorFlow？
- en: Before we can begin discussing TF.js, we must understand what TensorFlow is.
    TensorFlow is an open source library that is developed and maintained by Google.
    It is built on a data structure called tensors. Tensors are the generalized form
    of scalar and vector. TensorFlow provides a lot of efficient utilities for high-performance
    numerical computing across a wide range of scientific domains. TensorFlow also
    provides a very flexible suite of utilities for carrying out machine learning
    and deep learning development and research. You are encouraged to visit TensorFlow's
    official website at [https://www.tensorflow.org/](https://www.tensorflow.org/)
    for more information.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论 TF.js 之前，我们必须了解什么是 TensorFlow。TensorFlow 是一个由 Google 开发和维护的开源库。它基于一种称为张量的数据结构构建。张量是标量和向量的广义形式。TensorFlow
    提供了许多高效的工具，适用于广泛的科学领域中的高性能数值计算。TensorFlow 还提供了一套非常灵活的工具，用于进行机器学习和深度学习的开发与研究。你可以访问
    TensorFlow 的官方网站 [https://www.tensorflow.org/](https://www.tensorflow.org/) 获取更多信息。
- en: What is TF.js?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 TF.js？
- en: 'TF.js is a JavaScript library that provides an ecosystem to build and deploy
    machine learning models. It offers the following functionalities:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: TF.js 是一个 JavaScript 库，提供了一个构建和部署机器学习模型的生态系统。它提供了以下功能：
- en: Developing machine learning models with JavaScript
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JavaScript开发机器学习模型
- en: Using pretrained machine learning models
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预训练的机器学习模型
- en: Deploying machine learning models
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署机器学习模型
- en: TF.js provides you with all the elements required for a machine learning project.
    It has dedicated modules for data preprocessing, tensor handling, model building,
    model evaluation, and much more, but all in JavaScript. Before we move on to digging
    deeper into this, let's quickly understand the need for TF.js.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: TF.js为你提供了机器学习项目所需的所有元素。它有专门的模块用于数据预处理、张量处理、模型构建、模型评估等，但所有这些都是用JavaScript完成的。在深入了解这些之前，让我们快速理解TF.js的必要性。
- en: Why TF.js?
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择TF.js？
- en: As we saw in the previous chapter, it is quite easy and intuitive to simply
    train and host a model online, wrap it up in a REST API, and then use the API
    on any frontend to display our results. Why, then, would the need to use TF.js
    arise?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一章节中看到的那样，在线训练和托管一个模型、将其封装在一个REST API中，然后在任何前端使用API来展示我们的结果是非常简单和直观的。那么，为什么还会需要使用TF.js呢？
- en: A simple answer to this question would be if there is an AI in the browser!
    Think of a game that requires the use of an AI agent that learns from the human
    player's method of playing to become tougher or easier as the game progresses.
    Now, this would be overkill if, at every split second, the game kept sending requests
    to the server to transfer data to and from the game and the server. What's more,
    it might easily result in a **Denial of Service** (**DoS**) attack.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的简单答案是：如果浏览器中有AI！想象一下一个游戏，它需要使用一个AI代理，这个代理通过学习人类玩家的玩法方式，在游戏进程中变得更强或更弱。如果在每一瞬间，游戏都不断向服务器发送请求，来传输数据到游戏和服务器之间，这就过于冗余了。更重要的是，这可能很容易导致**拒绝服务**（**DoS**）攻击。
- en: 'So, having an AI that can live and learn in the browser itself makes sense
    when the agent has to keep learning in real time. It could also be a hybrid in
    two ways:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在浏览器中拥有一个可以自行生存并实时学习的AI是有意义的，尤其是当代理需要实时不断学习时。它也可以是两种方式的混合：
- en: If a pretrained model is loaded during the rendering of the agent and, from
    there, it begins learning and updating the model on the server at intervals.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在代理渲染期间加载了一个预训练模型，并且从那里开始，代理会在服务器上间隔性地学习并更新模型。
- en: If multiple versions of the AI agent run on several systems at once and they
    learn from interaction on the system on which they run. Also, if their collective
    learning is assimilated on the server and the agents fetch updates from the server
    at intervals.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果多个版本的AI代理同时在几个系统上运行，并且它们从各自的系统互动中学习。而且，如果它们的集体学习被汇总到服务器上，代理将在间隔时从服务器获取更新。
- en: So, using TF.js greatly reduces strong dependence on the page that the human
    user will interact with to communicate with the server at every step.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用TF.js大大减少了对人类用户与服务器进行每一步通信时依赖页面的强度。
- en: We can now build a mini project that shows the power of TF.js. Don't worry about
    the TF.js ecosystem for now—we will cover all the elements of the project as we
    go along.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以构建一个小项目，展示TF.js的强大功能。现在不用担心TF.js生态系统——我们会在过程中涵盖项目的所有元素。
- en: The basic concepts of TF.js
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TF.js的基本概念
- en: 'The following are the components of TF.js that we will be using in our project:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在项目中使用的TF.js组件：
- en: Tensors
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 张量
- en: Variables
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量
- en: Operations
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作
- en: Models
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型
- en: Layers
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 层
- en: Let's look at each of them in detail.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看它们每个。
- en: Tensors
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 张量
- en: 'Like TensorFlow, the central data processing unit in TF.js is tensors. Goodfellow
    et al. (in their book on deep learning) make the following observation:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与TensorFlow一样，TF.js中的中央数据处理单元是张量。Goodfellow等人（在他们的深度学习书中）做出了以下观察：
- en: In the general case, an array of numbers arranged on a regular grid with a variable
    number of axes is known as a tensor.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，按规则网格排列的数字数组，具有可变数量的轴，被称为张量。
- en: 'Simply described, a tensor is a container of one- or multi-dimensional arrays.
    The following are some examples of tensors that you may already know:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，张量是一个容器，包含一维或多维数组。以下是一些你可能已经知道的张量示例：
- en: Scalar (a rank zero tensor)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标量（一个秩为零的张量）
- en: Vector (a one-dimensional or rank-one tensor)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量（一个一维或秩为一的张量）
- en: Matrix (a two-dimensional or rank-two tensor)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵（一个二维或秩为二的张量）
- en: 'We can create a tensor with respect to a given shape in TF.js as shown:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据给定的形状在TF.js中创建一个张量，如下所示：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`a` is a tensor that was created and its contents can be printed using the
    following command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`a` 是一个已创建的张量，其内容可以使用以下命令打印出来：'
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following output is printed:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出被打印：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`a` is a matrix (a rank-two tensor). TF.js also provides dedicated functions,
    such as `tf.scalar`, `tf.tensor1d`, `tf.tensor2d`, `tf.tensor3d`, and `tf.tensor4d` to
    create tensors of specific shapes without having to specify the `shape` argument
    explicitly. It also provides better readability. Tensors are immutable in TF.js.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`a` 是一个矩阵（一个二阶张量）。TF.js 还提供了专门的函数，如 `tf.scalar`、`tf.tensor1d`、`tf.tensor2d`、`tf.tensor3d`
    和 `tf.tensor4d`，用于创建具有特定形状的张量，而无需显式指定 `shape` 参数。这也提高了可读性。在 TF.js 中，张量是不可变的。'
- en: Variables
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: 'Unlike tensors, variables are mutable in TF.js. Variables are particularly
    useful during the training of a neural network as they consist of lots of intermediate
    data stores and updates. The following is an example of how variables can be used
    in TF.js:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与张量不同，变量在 TF.js 中是可变的。变量在神经网络训练过程中尤为重要，因为它们包含了大量中间数据存储和更新。以下是如何在 TF.js 中使用变量的示例：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let's now look at operators.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下运算符。
- en: Operators
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符
- en: 'Operators let you perform mathematical operations on data. TF.js provides various
    operations for manipulating tensors. As tensors are immutable in nature, operators
    don''t change the data contained in the tensors—they return new tensors as results
    instead. You can perform binary operations, such as addition, multiplication,
    and subtraction, on tensors. You can even chain multiple operations. The following
    example shows the use of two different operators in TF.js using chaining:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符让你对数据进行数学运算。TF.js 提供了各种用于操作张量的运算符。由于张量本质上是不可变的，运算符不会改变张量中的数据——它们会返回新的张量作为结果。你可以对张量执行二元操作，如加法、乘法和减法。你甚至可以链式调用多个操作。以下示例展示了如何在
    TF.js 中使用两个不同的运算符进行链式操作：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We first created two two-dimensional tensors and assigned them to `e` and `f`.
    We then added them and took their squares.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了两个二维张量，并将它们分别赋值给`e`和`f`。接着，我们对它们进行了相加并求平方。
- en: 'This produces the following output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, we will cover models and layers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论模型和层。
- en: Models and layers
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型与层
- en: In deep learning literature, a model refers to the neural network itself, specifically,
    the neural network architecture. As discussed in [Chapter 2](9a68dbce-f50e-4c5a-80e2-2b7f40e082ca.xhtml),
    *Getting Started With Deep Learning Using Python*, a neural network consists of
    basic components, such as layers, neurons, and connections, in between layers.
    TF.js provides two functions with which to create these models—`tf.model` and
    `tf.sequential`. `tf.model` helps you to get more sophisticated architectures,
    such as skipping certain layers, whereas `tf.sequential` provides a way to create
    linear stacks of layers without skipping, branching, and so on.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在深度学习文献中，模型指的是神经网络本身，特别是神经网络架构。如在[第二章](9a68dbce-f50e-4c5a-80e2-2b7f40e082ca.xhtml)《使用
    Python 入门深度学习》中所讨论，神经网络由基本组件组成，如层、神经元以及层之间的连接。TF.js 提供了两个创建这些模型的函数——`tf.model`
    和 `tf.sequential`。`tf.model` 帮助你构建更复杂的架构，例如跳过某些层，而 `tf.sequential` 提供了一种创建线性层堆栈的方式，不涉及跳过、分支等操作。
- en: 'TF.js provides different types of dedicated layers for different types of tasks—`tf.layers.dense`,
    `tf.layers.dropout`, `tf.layers.conv1d`, `tf.layers.simpleRNN`, `tf.layers.gru`,
    and `tf.layers.lstm`. The following example demonstrates a simple neural network
    model with the help of `tf.sequential` and `tf.layers.dense`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: TF.js 提供了多种专用层类型，用于不同任务的需求——`tf.layers.dense`、`tf.layers.dropout`、`tf.layers.conv1d`、`tf.layers.simpleRNN`、`tf.layers.gru`
    和 `tf.layers.lstm`。以下示例通过 `tf.sequential` 和 `tf.layers.dense` 展示了一个简单的神经网络模型：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding example creates a simple neural network that has the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例创建了一个简单的神经网络，其特点如下：
- en: Two layers (remember, we don't consider the input layer when counting the total
    number of layers). The network takes an input that has four features (the `inputShape` argument helps
    to specify that).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个层（记住，在计算总层数时我们不考虑输入层）。该网络接受一个具有四个特征的输入（`inputShape` 参数有助于指定这一点）。
- en: 'The first layer contains four neurons (hence `units: 4`). The second layer
    (the output layer) has only one neuron.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '第一层包含四个神经元（因此是`units: 4`）。第二层（输出层）只有一个神经元。'
- en: The `relu` activation function is used for the first layer, and the `sigmoid`
    activation function is used for the output layer.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个层使用 `relu` 激活函数，输出层使用 `sigmoid` 激活函数。
- en: You are encouraged to go to [https://js.tensorflow.org/api/latest/index.html](https://js.tensorflow.org/api/latest/index.html)
    to learn more about the preceding components of TF.js.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励您访问 [https://js.tensorflow.org/api/latest/index.html](https://js.tensorflow.org/api/latest/index.html)
    了解 TF.js 的前述组件。
- en: A case study using TF.js
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TF.js 的案例研究
- en: We will follow all the steps that are typically involved in a machine learning
    project (which we discussed in [Chapter 1](f97d928f-3614-4d12-ad37-d5736008f542.xhtml),
    *Demystifying Artificial Intelligence and Fundamentals of Machine Learning*).
    A good project starts with a well-defined problem statement. So, let's quickly
    take a look at that and decide the subsequent steps accordingly.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循通常涉及到的机器学习项目中的所有步骤（我们在 [第1章](f97d928f-3614-4d12-ad37-d5736008f542.xhtml)
    中讨论过，*揭秘人工智能和机器学习基础*）。一个好的项目从一个清晰定义的问题陈述开始。因此，让我们快速浏览一下，并据此决定后续步骤。
- en: A problem statement for our TF.js mini-project
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们 TF.js 小项目的问题陈述
- en: The problem we will look at here is probably one of the most famous challenges
    you will come across when starting your journey in machine learning—classifying
    and predicting the type of an Iris flower by learning its features from the Iris
    flower dataset. Training, as well as the prediction, will be performed in the
    browser itself.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们将要探讨的问题可能是你在机器学习初学时遇到的最著名的挑战之一——通过学习鸢尾花数据集中的特征来分类和预测鸢尾花的类型。训练和预测将在浏览器中执行。
- en: We have defined the problem statement for our project. What will follow is the
    data preparation step. The data is already available to us, so we don't need to
    collect it ourselves. But, before we prepare the data, it would be good to know
    a bit more about the data itself.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为项目定义了问题陈述。接下来将进行数据准备步骤。数据已经可用，因此我们不需要自行收集。但是，在准备数据之前，了解数据本身的更多信息会很有帮助。
- en: The Iris flower dataset
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鸢尾花数据集
- en: 'Introduced by Ronald Fisher, the statistician and biologist, in 1936, the Iris
    flower dataset contains 150 rows of data and about 3 different varieties of the
    Iris flower. The columns are as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由统计学家兼生物学家罗纳德·费舍尔于1936年引入的鸢尾花数据集包含150行数据，大约有3种不同的鸢尾花品种。列名如下：
- en: Sepal length (cm)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 萼片长度（cm）
- en: Sepal width (cm)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 萼片宽度（cm）
- en: Petal length (cm)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花瓣长度（cm）
- en: Petal width (cm)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花瓣宽度（cm）
- en: 'Variety:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 种类：
- en: Setosa
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 山鸢尾
- en: Versicolour
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变色鸢尾
- en: Virginica
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维吉尼亚
- en: You can get the raw dataset and learn more about it at [http://archive.ics.uci.edu/ml/datasets/Iris](http://archive.ics.uci.edu/ml/datasets/Iris).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [http://archive.ics.uci.edu/ml/datasets/Iris](http://archive.ics.uci.edu/ml/datasets/Iris)
    获取原始数据集并了解更多。
- en: Your first deep learning web application with TF.js
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的第一个 TF.js 深度学习 Web 应用程序
- en: In this section, we are going to develop a web application with the help of
    TF.js. This application will include the steps for a standard, full stack, deep
    learning-enabled web project. We will begin by preparing the data, we will then
    study the project architecture briefly, and then, we will proceed toward building
    the required components as we go.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 TF.js 开发一个 Web 应用程序。此应用程序将包括标准的全栈深度学习支持的 Web 项目步骤。我们将从准备数据开始，然后简要研究项目架构，然后按需构建所需的组件。
- en: Preparing the dataset
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备数据集
- en: The Iris flower dataset, in its original form, is a CSV file containing the
    data of 150 rows split into 5 columns in a comma-separated format, with each entry
    separated by a new line.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 鸢尾花数据集原始形式是一个包含150行数据的 CSV 文件，以逗号分隔的格式，每个条目以新行分隔。
- en: However, we will be using a JSON format of the data for easier operability with
    JavaScript. The dataset in JSON format can be downloaded from [https://gist.github.com/xprilion/33cc85952d317644c944274ee6071547](https://gist.github.com/xprilion/33cc85952d317644c944274ee6071547).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了更轻松地与 JavaScript 运行，我们将使用数据的 JSON 格式。JSON 格式的数据集可以从 [https://gist.github.com/xprilion/33cc85952d317644c944274ee6071547](https://gist.github.com/xprilion/33cc85952d317644c944274ee6071547)
    下载。
- en: 'You can use simple functions in any language to convert a CSV file into a JSON
    file, with the column names changed as per the following conventions:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用任何语言中的简单函数，将 CSV 文件转换为 JSON 文件，按照以下约定更改列名：
- en: 'Sepal length: `sepal_length`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 萼片长度：`sepal_length`
- en: 'Sepal width: `sepal_width`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 萼片宽度：`sepal_width`
- en: 'Petal length: `petal_length`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花瓣长度：`petal_length`
- en: 'Petal width: `petal_width`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花瓣宽度：`petal_width`
- en: 'Variety: `species`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 种类：`species`
- en: We will use these property names in JSON while developing the tensors for model
    building.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型构建时，我们将使用这些属性名称的 JSON 格式。
- en: Project architecture
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目架构
- en: We will be using Node.js in this project to create a server. This is done so
    that we get the benefits of faster computational performance of TF.js when used
    through the Node.js backend. We will create a very basic frontend that will be
    able to issue a command to perform the training of the neural network built using
    TF.js and another button to issue a command to predict the class of a hypothetical
    feature vector of an Iris flower based on input provided by the user.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，我们将使用Node.js来创建一个服务器。这样做是为了能够通过Node.js后端使用TF.js，从而获得更快的计算性能。我们将创建一个非常基础的前端，用户可以通过它来发出命令，训练由TF.js构建的神经网络，并使用另一个按钮发出命令，根据用户提供的输入预测一朵鸢尾花的特征向量的类别。
- en: 'The following diagram shows the components of the project, along with their
    interactions:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了项目的组成部分及其相互作用：
- en: '![](img/8e47dac3-cf66-406f-8222-dbf2905cd686.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e47dac3-cf66-406f-8222-dbf2905cd686.png)'
- en: Now that we know about the architecture, let's start with the project.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了架构，接下来让我们开始项目的开发。
- en: Starting up the project
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动项目
- en: To start working on the project, you first need to install the latest versions
    of Node.js and **Node Package Manager** (**NPM**). While a standard way to do
    this would be to read the documentation provided on the Node.js website, we would
    suggest installing Node.js and NPM using **Node Version Manager** (**NVM**).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始进行项目开发，首先需要安装Node.js和**Node包管理器**（**NPM**）的最新版本。虽然标准的做法是阅读Node.js官网提供的文档，我们建议使用**Node版本管理器**（**NVM**）来安装Node.js和NPM。
- en: The setup instructions and files can be found at [https://githu](https://github.com/creationix/nvm)[b.com/creationix/nvm](https://github.com/creationix/nvm)[.](https://github.com/creationix/nvm)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 安装说明和文件可以在[https://githu](https://github.com/creationix/nvm)[b.com/creationix/nvm](https://github.com/creationix/nvm)[.](https://github.com/creationix/nvm)
- en: 'Once Node.js and NPM are installed, we''re ready to start working on the project
    itself:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了Node.js和NPM，我们就可以开始进行项目的开发了：
- en: Create a folder called `tfjs-iris`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`tfjs-iris`的文件夹。
- en: 'Open up a Terminal and use the following command to initiate the package manager
    for this project:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，并使用以下命令初始化该项目的包管理器：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This should create a file, `package.json`, in your project directory. The output
    for the preceding command is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在项目目录中创建一个`package.json`文件。前面的命令输出如下：
- en: '![](img/d566a0e8-10d6-4418-9e82-a59447d8f27a.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d566a0e8-10d6-4418-9e82-a59447d8f27a.png)'
- en: Notice that the output is in JSON format. The `main` key defines the file that
    will be the entry point for the program if it is imported as a module. The value
    for `main` in this project is set, by default, to `index.js`. However, this file
    is not yet created. Let's work on the `index.js` file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输出格式为JSON格式。`main`键定义了在作为模块导入时程序的入口文件。在本项目中，`main`的默认值设置为`index.js`。不过，这个文件尚未创建。让我们来创建`index.js`文件。
- en: We will be using the `express` module of Node.js to create our server. You can
    read more about `express` at [https://expressjs.com.](https://expressjs.com/)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Node.js的`express`模块来创建我们的服务器。你可以在[https://expressjs.com](https://expressjs.com/)上了解更多关于`express`的信息。
- en: 'To use `express`, we will need to add the module to our project. To do this,
    use the following code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用`express`，我们需要将这个模块添加到我们的项目中。为此，请使用以下代码：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will add the `express` module dependency to the `package.json` file and
    install it in the `node_modules` directory inside the working directory of the
    project.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`express`模块的依赖添加到`package.json`文件中，并将其安装到项目的`node_modules`目录中。
- en: 'Create a file called `index.js` in the root directory of the project repository
    and add the following code:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目仓库的根目录下创建一个名为`index.js`的文件，并添加以下代码：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This creates an `express` application object. We will now be adding TF.js to
    the project. The simplest way to do this is to install it via NPM. The complete
    setup instructions can be found at [https://js.tensorflow.org/setup/](https://js.tensorflow.org/setup/).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个`express`应用程序对象。接下来，我们将把TF.js添加到项目中。最简单的方法是通过NPM安装。完整的安装说明可以在[https://js.tensorflow.org/setup/](https://js.tensorflow.org/setup/)找到。
- en: 'Use the following command to install the `TF.js` module in the Terminal:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在终端中安装`TF.js`模块：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can now proceed to add the module to our `index.js` file:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以继续将该模块添加到我们的`index.js`文件中了：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will also require the `body-parser` module from Express.js to handle the
    incoming query data from the client side, which will be sent via AJAX `POST` requests.
    To do so, we use the following command:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要Express.js中的`body-parser`模块来处理来自客户端的查询数据，这些数据将通过AJAX `POST`请求发送。为此，我们使用以下命令：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We now create a `body-parser` object and bind it to the application using the
    following code:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在创建一个`body-parser`对象，并使用以下代码将其绑定到应用程序：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At this stage, `package.json` should contain the following snippet that lists
    the dependencies of your project:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，`package.json`应包含列出项目依赖项的以下代码片段：
- en: '![](img/64f57e1d-2a8d-481d-b2bc-27ed8c7d89fd.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64f57e1d-2a8d-481d-b2bc-27ed8c7d89fd.png)'
- en: 'Note that the preceding versions may change. We can now import the `iris.json` file, which
    we will be training our model on:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的版本可能会发生变化。我们现在可以导入`iris.json`文件，这是我们将要训练的模型数据：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With the initial setup done, we can now proceed to write the TF.js code to train
    on the available dataset.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 初始设置完成后，我们现在可以继续编写TF.js代码，在可用数据集上进行训练。
- en: Creating a TF.js model
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建TF.js模型
- en: 'Let''s begin by reading the data we have stored in the `iris` variable to a
    `tensor2d` object:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过将存储在`iris`变量中的数据读取到一个`tensor2d`对象中：
- en: 'In your `index.js` file, add the following code:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`index.js`文件中，添加以下代码：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We do not have any test data yet; this will be provided by the user.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前还没有任何测试数据；这些将由用户提供。
- en: 'Next, we create a one-hot encoding of the possible three varieties of flowers:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个可能的三种花卉品种的独热编码：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We are now ready to create the model for training. The following code might
    remind you of the code we used in the previous chapter when we were creating a
    model for the MNIST handwritten digits dataset. This is simply due to the fact
    that we are still using the concepts of TensorFlow, only in a different language!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始创建训练模型的代码。以下代码可能让你想起我们在上一章中为MNIST手写数字数据集创建模型时使用的代码。这仅仅是因为我们仍然在使用TensorFlow的概念，只不过是用不同的语言！
- en: 'We first declare a sequential TensorFlow model:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先声明一个顺序的TensorFlow模型：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, let''s add a layer of neurons to the model:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们为模型添加一层神经元：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `inputShape` parameter indicates the shape of the input that will be added
    to this layer. The `units` parameter sets the number of neurons to be used in
    this layer. The `activation` function we are using is the `sigmoid` function.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`inputShape`参数表示将添加到该层的输入的形状。`units`参数设置该层中使用的神经元数量。我们使用的激活函数是`sigmoid`函数。'
- en: 'Let''s now add the output layer:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们添加输出层：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we will have 3 neurons in the output layer, and the input to be expected
    at this layer is 10, which matches the number of neurons in the previous layer.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将输出层中有3个神经元，且该层的输入为10，这与前一层中的神经元数量相匹配。
- en: Apart from the input layer, we just have one hidden layer and the output layer.
    This is acceptable in this application because the dataset is small and the prediction
    is simple. Note that we used the `softmax` activation function here, which produces
    class probabilities as outputs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 除了输入层外，我们只有一个隐藏层和输出层。由于数据集较小且预测简单，因此在此应用中是可以接受的。请注意，我们在这里使用了`softmax`激活函数，它会输出类别概率。
- en: This is particularly useful in our case as the problem is a multi-class classification
    problem.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这在我们的案例中特别有用，因为问题是一个多类分类问题。
- en: 'With this done, we are now ready to compile our model. To do this, we use the
    following code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这一切后，我们现在可以准备编译我们的模型。为此，我们使用以下代码：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Since we have a classification problem at hand where there are multiple possible
    labels, we use `categoricalCrossentropy` as the `loss` function. For optimization,
    the `adam` optimizer is used. You are encouraged to experiment with other hyperparameter
    values.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们手头有一个分类问题，其中有多个可能的标签，因此我们使用`categoricalCrossentropy`作为`loss`函数。为了优化，我们使用`adam`优化器。鼓励你尝试其他超参数值。
- en: 'We can generate a summary of the model using the following code:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码生成模型的摘要：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, we will train our TF.js model.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将训练我们的TF.js模型。
- en: Training the TF.js model
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练TF.js模型
- en: 'We will now write an `async` function. The reason for doing this is so that
    the JavaScript on the client side that invokes our function doesn''t get stuck
    waiting for the result. A function that will take time to complete in our program
    is the `train_data()` function. This function performs the training of the model:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将编写一个 `async` 函数。这样做的原因是为了让客户端 JavaScript 调用我们的函数时，不会因为等待结果而卡住。我们程序中需要一定时间才能完成的函数是
    `train_data()` 函数。该函数负责模型的训练：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `train_data()` function can be run asynchronously. It also prints out the
    loss at every epoch of training to the console where we will run the server from.
    Let's now create an API that will invoke the `train_data()` function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`train_data()` 函数可以异步运行。它还会在每个训练周期输出损失值到我们运行服务器的控制台中。现在，让我们创建一个 API 来调用 `train_data()`
    函数。'
- en: First, we create a *middleware* called `doTrain`, which will be run before the
    API for training and will return any data.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为 `doTrain` 的 *中间件*，它将在训练 API 之前运行，并返回任何数据。
- en: You can read more about middlewares at [https://expressjs.com/en/guide/using-middleware.html](https://expressjs.com/en/guide/using-middleware.html).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://expressjs.com/en/guide/using-middleware.html](https://expressjs.com/en/guide/using-middleware.html)
    阅读更多关于中间件的内容。
- en: 'The `doTrain()` middleware accepts, in its arguments, the request made to the
    Node.js server, the variable for making the response, and the name of the function
    that will be used to forward the execution of the program after executing the
    block of code defined in the middleware:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`doTrain()` 中间件在其参数中接受对 Node.js 服务器发出的请求、用于响应的变量，以及在执行完中间件中定义的代码块后用来转发程序执行的函数：'
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `doTrain` middleware calls the `train_data()` function and awaits its result.
    The `train_data()` function returns a *Promise* so that the execution continues
    without freezing. The `next()` function runs right after the `train_data()` function
    is complete and it merely passes the execution of the program to the function
    that is *chained* next to the middleware, as shown:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`doTrain` 中间件调用 `train_data()` 函数并等待其结果。`train_data()` 函数返回一个 *Promise*，以便执行可以继续而不会冻结。`next()`
    函数在 `train_data()` 函数完成后立即运行，它只是将程序的执行传递给下一个链式调用的中间件函数，如下所示：'
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We now bind the `'/train'` route to the `express` app and then chain the `doTrain`
    middleware to it. Now, for every call made to the `'/train'` API, the middleware
    runs first and then the execution passes to the main block of code for the API.
    This block of code simply returns any arbitrary value to denote the completion
    of training.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将 `'/train'` 路由绑定到 `express` 应用中，然后将 `doTrain` 中间件链接到它。现在，每当调用 `'/train'`
    API 时，中间件会首先运行，然后执行会传递到 API 的主代码块。这个代码块简单地返回一个任意值，表示训练已完成。
- en: Predicting using the TF.js model
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TF.js 模型进行预测
- en: 'After the training is done, we also need to create an API to invoke the prediction
    function and return the predicted result. We bind the API to the `''/predict''`
    route with a `POST` method to make a request to this API, as shown:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 训练完成后，我们还需要创建一个 API 来调用预测函数并返回预测结果。我们将 API 绑定到 `'/predict'` 路由，并使用 `POST` 方法发起对该
    API 的请求，如下所示：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It is very simple to understand the code for the prediction API. Let''s discuss
    it in parts:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 理解预测 API 的代码非常简单。让我们分部分讨论：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This line binds the `''/predict''` route to the `POST` request method and opens
    the block of code for the statements that will handle requests made to this route:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行将 `'/predict'` 路由绑定到 `POST` 请求方法，并打开处理请求代码块，处理所有对该路由的请求：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'These lines create a TF.js `tensor2d` object from the data, which is received
    from the client side. It then runs the `predict` method on the model and stores
    the result in the output variable:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行创建了一个 TF.js `tensor2d` 对象，数据是从客户端接收到的。接着，它在模型上运行 `predict` 方法，并将结果存储在 output
    变量中：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This block of code merely finds the index that corresponds to the element in
    the `tensor2d` variable output that is highest. Remember that in a `softmax` activation
    output, the highest value corresponds to the predicted index.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码块仅仅是找出在 `tensor2d` 变量 output 中对应最大元素的索引。记住，在 `softmax` 激活输出中，最高值对应着预测的索引。
- en: 'After determining the maximum index from the output, we use a simple switch-case
    statement to decide what output is to be sent to the client from the API. The
    request data is also logged to the console visible on the server. Finally, we
    bind our Node.js application to listen to port `3000` using the following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定输出的最大索引之后，我们使用一个简单的 switch-case 语句来决定从 API 发送到客户端的输出内容。请求数据也会记录在服务器的控制台中。最后，我们使用以下代码将
    Node.js 应用绑定到监听 `3000` 端口：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We will now create a simple client in the following section.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个简单的客户端。
- en: Creating a simple client
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的客户端
- en: 'To handle the `''/''` route in our application, we add the following lines
    of code to `index.js`, which merely renders a static file, `index.html`, which
    is placed in the public folder:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理应用程序中的 `'/'` 路由，我们向 `index.js` 添加以下代码行，它仅渲染一个静态文件 `index.html`，该文件位于 public
    文件夹中：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s create the static `index.html` file by following these steps:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过以下步骤创建静态的 `index.html` 文件：
- en: 'First, create a folder, `public`, and inside it, create `index.html.` Add the
    following code to the `index.html` file:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个文件夹，`public`，并在其中创建 `index.html` 文件。将以下代码添加到 `index.html` 文件中：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After setting a simple UI to the client developed to call the APIs we have
    created using TF.js, we are ready to define the functions to deploy them from
    the client side. Notice that both the `"/train"` and `"/predict"` APIs will be
    called by a `POST` request:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在为客户端设置了一个简单的 UI，调用我们使用 TF.js 创建的 API 后，我们准备好定义功能并从客户端部署它们。请注意，`"/train"` 和
    `"/predict"` 两个 API 都将通过 `POST` 请求进行调用：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Let's now run the TF.js web app.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行 TF.js Web 应用。
- en: Running the TF.js web app
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行 TF.js Web 应用
- en: With all the application coded, we are now ready to run our application. First,
    open a Terminal and make the `tfjs-iris` folder containing the `package.json`
    file as your working directory in it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有应用编码后，我们现在准备运行应用程序。首先，打开终端，并将包含 `package.json` 文件的 `tfjs-iris` 文件夹设置为工作目录。
- en: 'Run the following line of code to start the Node.js server:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下代码行以启动 Node.js 服务器：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The command produces an output that resembles the following screenshot:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令产生的输出类似于以下截图：
- en: '![](img/36c2cc46-bbf1-471e-beb4-5bde0c30efe1.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36c2cc46-bbf1-471e-beb4-5bde0c30efe1.png)'
- en: 'Now, along with this output, the server starts at port `3000` and we can view
    the same in the browser. Open a browser and type `http://localhost:3000/` in the
    address bar to bring up the following output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着此输出，服务器在 `3000` 端口启动，我们可以在浏览器中查看相同内容。打开浏览器并在地址栏输入 `http://localhost:3000/`
    来显示以下输出：
- en: '![](img/d9ca1b9a-3a54-4848-be67-d133f21e5e88.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9ca1b9a-3a54-4848-be67-d133f21e5e88.png)'
- en: First, you must click on the Train button to invoke the `'/train'` API, which
    begins the training, and the button changes to a disabled state. Once the Predict! button is
    enabled, the training is complete and the user can send dummy data to the server
    to make predictions. Say we choose the 50^(th) row of data from the dataset and
    send it to the server with an expected output of `Setosa`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须点击训练按钮以调用`'/train'` API，这将开始训练，并且按钮会变为禁用状态。一旦预测按钮启用，训练完成，用户就可以向服务器发送虚拟数据进行预测。假设我们选择数据集中的第50行数据，并将其发送给服务器，期望的输出是`Setosa`。
- en: 'The following screenshot shows a small section of the final version of our
    project:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了我们项目最终版本的一小部分：
- en: '![](img/89c50dc0-72c8-4ccf-83db-1e588b47c268.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89c50dc0-72c8-4ccf-83db-1e588b47c268.png)'
- en: We see that the correct output is generated for the input provided.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到为提供的输入生成了正确的输出。
- en: Advantages and limitations of TF.js
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TF.js 的优点和限制
- en: 'Let''s now summarize some of the advantages TF.js brings over TensorFlow, besides
    the ones we have already talked about in this chapter:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们总结一些 TF.js 相比 TensorFlow 的优势，除了我们在本章中已经讨论的那些：
- en: '**Automatic GPU support**: You don''t need to install CUDA or GPU drivers separately
    with TF.js to benefit from the GPUs present on the system. This is because the
    browser itself implements GPU support.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动 GPU 支持**：使用 TF.js 时，你无需单独安装 CUDA 或 GPU 驱动程序即可利用系统中的 GPU。这是因为浏览器本身实现了 GPU
    支持。'
- en: '**Integration**: It is fairly simple to integrate TF.js into a web development
    project using Node.js and then import pretrained models to the project and run
    them in the browser.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成**：将 TF.js 集成到使用 Node.js 的 Web 开发项目中相当简单，然后将预训练模型导入到项目并在浏览器中运行它们。'
- en: 'However, it also has several disadvantages that have to be kept in mind whenever
    developing for production. Some of these are as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它也有几个缺点，无论何时开发用于生产的时候都需要牢记。其中一些如下：
- en: '**Speed**: TF.js is suitable for small datasets. On large-scale datasets, the
    computation speed suffers heavily and is nearly 10x slower.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：TF.js适合小数据集。在大规模数据集上，计算速度显著下降，几乎慢了10倍。'
- en: '**Lack of a tensor board**: This great tool, which enables TensorFlow models
    to be visualized, is missing in the JavaScript port of the framework since TF.js
    is only an API.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺少TensorBoard**：这个伟大的工具，用于可视化TensorFlow模型，在JavaScript版的框架TF.js中缺失，因为TF.js仅仅是一个API。'
- en: '**Incomplete support of APIs**: Not all of the TensorFlow APIs are available
    on TF.js, and so you might have to rethink the code logic or create your own functions
    to use certain features while developing with TF.js.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API的支持不完整**：并非所有TensorFlow的API在TF.js中都可用，因此在开发TF.js时，您可能需要重新考虑代码逻辑或创建自己的函数来使用某些功能。'
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how easy it is to create models with TF.js. You
    not only get the whole JavaScript ecosystem to work with, but you also get all
    the pretrained TensorFlow models within TF.js. We developed a simple web application
    using the Iris dataset and, along the way, we learned about several components
    that TF.js has to offer. By now, we have already built two simple end-to-end deep
    learning-based web applications.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了使用TF.js创建模型是多么容易。你不仅可以使用整个JavaScript生态系统，而且还可以使用TF.js中的所有预训练TensorFlow模型。我们使用鸢尾花数据集开发了一个简单的Web应用程序，在此过程中，我们了解了TF.js提供的几个组件。到目前为止，我们已经构建了两个简单的端到端基于深度学习的Web应用程序。
- en: Our progress is indeed apparent. In the upcoming chapters, we will be building
    our own deep learning APIs and using them to create intelligent web applications.
    But before that, let's make ourselves familiar with the whole concept of APIs
    in the next chapter.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的进展确实显而易见。在接下来的章节中，我们将构建我们自己的深度学习API，并使用它们创建智能Web应用程序。但在此之前，让我们在下一章中对API的整体概念有所了解。
