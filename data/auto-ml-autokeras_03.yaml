- en: '*Chapter 2*: Getting Started with AutoKeras'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：开始使用 AutoKeras'
- en: In this chapter, we will go over everything you need to get started with **AutoKeras**
    and put it into practice with a foundational, well-explained code example. By
    the end of this chapter, you'll know how to create a simple classifier for handwritten
    digits from the well-known **Modified National Institute of Standards and Technology**
    (**MNIST**) dataset, in just a few lines of code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将介绍你需要了解的一切，以便开始使用**AutoKeras**并通过一个基础且讲解充分的代码示例将其付诸实践。在本章结束时，你将知道如何用几行代码创建一个简单的手写数字分类器，数据来源于广为人知的**修改版国家标准与技术研究所**（**MNIST**）数据集。
- en: As we saw in the previous chapter, **DL** (**DL**) automation manages to speed
    up training time and benefit from allocating human resources (data scientists)
    in other pipeline processes that are less likely to be automated.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章看到的那样，**深度学习**（**DL**）自动化能够加快训练时间，并且通过将人力资源（数据科学家）分配到其他不太可能被自动化的管道流程中，获得更多好处。
- en: To carry out this automation, we have chosen AutoKeras. This is a **ML** (**ML**)
    automation framework based on **Keras**, a widely known neural network library
    based on **TensorFlow**, which provides high-level building blocks for developing
    DL models.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一自动化，我们选择了 AutoKeras。它是一个基于**Keras**的**机器学习**（**ML**）自动化框架，**Keras**是一个广为人知的基于**TensorFlow**的神经网络库，提供了构建深度学习模型的高级模块。
- en: 'Next, we will see how to install AutoKeras and put it into action with a practical
    example, but let''s first explain some relevant concepts, answering these questions:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍如何安装 AutoKeras，并通过一个实际示例将其投入使用，但首先我们将解释一些相关概念，解答以下问题：
- en: What is deep learning?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是深度学习？
- en: What is a neural network and how does it learn?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是神经网络，它是如何学习的？
- en: How do deep learning models learn?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度学习模型是如何学习的？
- en: Why AutoKeras?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择 AutoKeras？
- en: Installing AutoKeras
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 AutoKeras
- en: 'Hello MNIST: Implementing our first AutoKeras experiment'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hello MNIST：实现我们的第一个 AutoKeras 实验
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All coding examples in this book are available as Jupyter Notebook/s that can
    be downloaded from the following website: [https://github.com/PacktPublishing/Automated-Machine-Learning-with-AutoKeras](https://github.com/PacktPublishing/Automated-Machine-Learning-with-AutoKeras).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有编码示例都可以作为 Jupyter Notebook 下载，下载地址为：[https://github.com/PacktPublishing/Automated-Machine-Learning-with-AutoKeras](https://github.com/PacktPublishing/Automated-Machine-Learning-with-AutoKeras)。
- en: Jupyter Notebook provides a Python-based environment where code can be developed
    as a sequence of steps, which are called cells. The notebook also provides flexibility
    to install libraries/dependencies on the go by executing Linux-based commands
    in the cells.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter Notebook 提供了一个基于 Python 的环境，可以将代码开发成一系列的步骤，称为单元格。该笔记本还提供了灵活性，可以通过在单元格中执行基于
    Linux 的命令来即时安装库/依赖项。
- en: 'So, to run the coding examples in this chapter, you only need a computer with
    Jupyter installed. For instance, in Ubuntu/Linux, you can install it with this
    line:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，为了运行本章中的编码示例，你只需要一台安装了 Jupyter 的计算机。例如，在 Ubuntu/Linux 中，你可以使用以下命令安装：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The previous command will install the Jupyter notebook package and all its dependencies.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令将安装 Jupyter Notebook 包及其所有依赖项。
- en: You can also take a look at the *Installing AutoKeras on an Ubuntu Linux workstation*
    section for more details.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以查看*在 Ubuntu Linux 工作站上安装 AutoKeras*部分，了解更多详细信息。
- en: Alternatively, you can also run these notebooks using Google Colaboratory, in
    which case you will only need a web browser. See the *AutoKeras with Google Colaboratory*
    section for more details.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以使用 Google Colaboratory 运行这些笔记本，在这种情况下，你只需要一个网页浏览器。更多详情请见*在 Google Colaboratory
    上使用 AutoKeras*部分。
- en: What is deep learning?
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是深度学习？
- en: DL is a subcategory of ML, based on extracting patterns from data by implementing
    successive layers that are responsible for extracting relevant features. These
    patterns are learned through ML models called neural networks (inspired by our
    brain neurons) and structured in layers stacked one on top of the other, but what
    is a layer? A layer is a set of nodes called *cells* that perform an operation
    by processing an input and generating an output. This kind of operation can be
    stateless but it usually has a state that is stored in an array of float numbers,
    called *weights*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 深度学习（DL）是机器学习（ML）的一种子类别，通过实现一系列层来从数据中提取模式，这些层负责提取相关特征。这些模式通过称为神经网络的机器学习模型进行学习（灵感来源于我们的大脑神经元），并按层叠加的方式组织在一起。那么，什么是层呢？层是一组称为*单元*的节点，它们通过处理输入并生成输出来执行操作。这种操作可以是无状态的，但通常它会有一个状态，这个状态保存在一个浮动数值数组中，称为*权重*。
- en: 'Let''s look at a multilayer-depth neural network recognizing a single-digit
    image, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个多层深度神经网络识别单个数字图像，如下所示：
- en: '![Figure 2.1 – Visual representation of the layers of a neural network for
    digit classification'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.1 – 用于数字分类的神经网络层的视觉表示'
- en: '](img/B16953_02_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16953_02_01.jpg)'
- en: Figure 2.1 – Visual representation of the layers of a neural network for digit
    classification
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 用于数字分类的神经网络层的视觉表示
- en: We can think of the network as a funnel with several filters, in which each
    layer is equivalent to a filter that reduces impurities until the desired value
    is obtained.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以把网络看作是一个有多个过滤器的漏斗，其中每一层相当于一个过滤器，逐步减少杂质，直到获得期望的结果。
- en: DL has multiple applications in many fields such as computer vision, **natural
    language processing** (**NLP**), signal processing, and many others, so the techniques
    explained in this book can be applied to solve problems in multiple disciplines.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 深度学习在许多领域有着广泛的应用，如计算机视觉、**自然语言处理**（**NLP**）、信号处理等，因此本书中解释的技术可以应用于解决多个学科中的问题。
- en: We will now see a brief explanation of neural networks and how learning takes
    place.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来简要解释一下神经网络以及学习是如何进行的。
- en: What is a neural network and how does it learn?
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是神经网络，它是如何学习的？
- en: 'As we said previously, a neural network is a set of layers connected to each
    other. Each layer contains a set of nodes and each node has an associated weight.
    Neural network learning consists of simply modifying these weights in a suitable
    way so that the model makes good predictions. In the following diagram, we can
    see a simple two-layer network:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，神经网络是由一系列相互连接的层组成的。每一层包含一组节点，每个节点都有一个相关的权重。神经网络的学习就是通过适当地修改这些权重，使得模型能够做出准确的预测。在下面的图中，我们可以看到一个简单的两层网络：
- en: '![Figure 2.2 – Visual representation of a two-layer neural network](img/B16953_02_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 两层神经网络的视觉表示](img/B16953_02_02.jpg)'
- en: Figure 2.2 – Visual representation of a two-layer neural network
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 两层神经网络的视觉表示
- en: Each circle in the previous diagram is an artificial neuron, which is nothing
    more than a mathematical function inspired by the functioning of a biological
    neuron. These artificial neurons are the basic units in an artificial neural network
    and their operation consists of receiving one or more inputs (numerical values)
    and multiplying them by a factor or weight, and then adding the results to generate
    the output value.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图中的每一个圆圈都是一个人工神经元，它不过是受生物神经元工作方式启发的数学函数。这些人工神经元是人工神经网络中的基本单元，其工作原理是接收一个或多个输入（数值），并将其乘以一个因子或权重，然后将结果相加生成输出值。
- en: These models are simple but really powerful because from a set of data with
    defined inputs and outputs, they can learn to predict new data whose outputs we
    do not know. For example, if we train our neural network with house prices based
    on a series of input variables (square meters, location, and so on), the network
    could predict the price of new houses based on those variables.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模型虽然简单，但非常强大，因为它们可以通过一组已定义输入和输出的数据，学习预测我们不知道输出的新数据。例如，如果我们用一系列输入变量（如面积、位置等）训练神经网络来预测房价，网络就能够根据这些变量预测新房屋的价格。
- en: Having introduced the main concepts of DL models, let's now see how these models
    learn.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍了深度学习模型的主要概念后，接下来让我们看看这些模型是如何学习的。
- en: How do deep learning models learn?
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度学习模型是如何学习的？
- en: 'Let''s look at a multilayer-depth neural network recognizing a single-digit
    image, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个多层深度神经网络识别单个数字图像，如下所示：
- en: '![Figure 2.3 – Rendering of the layer content of a neural network for digit
    classification](img/B16953_02_03.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 用于数字分类的神经网络层内容渲染](img/B16953_02_03.jpg)'
- en: Figure 2.3 – Rendering of the layer content of a neural network for digit classification
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 用于数字分类的神经网络层内容渲染
- en: As you can see in the preceding diagram, the network extracts patterns from
    the digit image. In each layer, it obtains different representations, so each
    layer specializes in some specific features of the image, giving the necessary
    keys to identify the category to which it belongs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的图所示，网络从数字图像中提取模式。在每一层中，它获得不同的表示，因此每一层专注于图像的某些特征，为识别其所属类别提供了必要的线索。
- en: This is basically DL, a multistage technique of learning patterns from data.
    It's based on a very simple concept, but by tweaking it and scaling it high enough,
    you can make amazing predictions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是深度学习（DL），一种从数据中学习模式的多阶段技术。它基于一个非常简单的概念，但通过调整它并将其扩展到足够高的水平，你可以做出惊人的预测。
- en: Let's now see the reasons why AutoKeras is our preferred tool for **automated
    ML** (**AutoML**).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看为什么AutoKeras是我们首选的**自动化机器学习**（**AutoML**）工具。
- en: Why AutoKeras?
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择AutoKeras？
- en: 'As we explained in the previous chapter, AutoKeras is an open source AutoML
    framework that allows a non-ML expert to create high-performance models in a simple
    way. There are similar tools with the same objective, but AutoKeras is specialized
    in DL. Although it is not the only solution, there are several AutoML services
    available; most are cloud computing platforms (Amazon, Google, **International
    Business Machines** (**IBM**)) and have some significant disadvantages, which
    are outlined here:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一章所解释的，AutoKeras是一个开源的AutoML框架，允许非机器学习专家以简单的方式创建高性能模型。虽然有类似的工具具有相同的目标，但AutoKeras专注于深度学习（DL）。虽然它不是唯一的解决方案，还有许多可用的AutoML服务，但大多数是云计算平台（例如亚马逊、谷歌、**国际商业机器公司**（**IBM**）），并且有一些显著的缺点，下面将详细说明：
- en: Machine learning cloud platforms are expensive; you usually have a trial period
    with free credits, but if you want to use them regularly you will have to pay
    a bill every month.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习云平台价格昂贵；通常你会有一个带免费额度的试用期，但如果你想定期使用它们，就需要每月支付账单。
- en: Depending on the cloud platform, some of them are not easy to configure and
    scale, which sometimes requires you to have knowledge of containers and clusters.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据云平台的不同，其中一些平台配置和扩展较为困难，有时需要你具备容器和集群的知识。
- en: They tend to offer simple to use but less flexible out-of-the-box solutions.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们通常提供简单易用，但灵活性较差的现成解决方案。
- en: As AutoKeras is based on an open source model, it solves these problems because
    you can view the source code, install it, and run it locally for free.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于AutoKeras基于开源模型，它解决了这些问题，因为你可以查看源代码、安装它并在本地免费运行。
- en: 'AutoKeras is based on the following four main features that make it easy to
    install and use:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: AutoKeras基于以下四个主要特性，简化了安装和使用：
- en: It has a clear and intuitive **application programming interface** (**API**)
    based on the Keras API. Users without programming experience can easily learn
    how to use it, but it also allows advanced users to adjust lower-level system
    parameters.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个基于Keras API的清晰直观的**应用程序编程接口**（**API**）。没有编程经验的用户也能轻松学习如何使用它，但它也允许高级用户调整较低级的系统参数。
- en: It can work both locally and in the cloud.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以在本地和云端都能工作。
- en: It is based on a dynamic configuration that adapts the size of the neural architecture
    in the function of the **graphics processing unit** (**GPU**) memory available
    on the local system.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它基于动态配置，根据本地系统中可用的**图形处理单元**（**GPU**）内存调整神经网络架构的大小。
- en: It is actively developed and maintained by the open source community.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它由开源社区积极开发和维护。
- en: Let's look at a practical example that creates a simple classifier using AutoKeras
    to predict handwritten digits. But first, we will have to configure a work environment
    by installing AutoKeras and its necessary dependencies on it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个实际例子，使用AutoKeras创建一个简单的分类器来预测手写数字。但首先，我们需要配置一个工作环境，并在其上安装AutoKeras及其必要的依赖项。
- en: How to run the AutoKeras experiments?
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何运行AutoKeras实验？
- en: As the main tool to implement all the coding examples in this book, we will
    use Jupyter notebook.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本书中实现所有编码示例的主要工具，我们将使用Jupyter notebook。
- en: Note
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A **notebook** is a file generated by Jupyter Notebook ([https://jupyter.org](https://jupyter.org)),
    an open source framework for creating and sharing documents that incorporates
    live code, visualizations, and rich text. Both the editing and the execution is
    done in a web browser, adding snippets (called cells) of code and rich text that
    show us clearly and visually what is being programmed. Each of these code cells
    can be run independently, making development interactive and avoiding having to
    run all your code if there is an error.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**笔记本**是由Jupyter Notebook（[https://jupyter.org](https://jupyter.org)）生成的文件，Jupyter
    Notebook是一个开源框架，用于创建和共享集成实时代码、可视化和富文本的文档。编辑和执行都在网页浏览器中进行，添加代码片段（称为单元格）和富文本，清晰直观地展示我们正在编写的内容。每个代码单元格都可以独立运行，使开发过程更具互动性，避免了在出现错误时必须运行所有代码。'
- en: 'In the following screenshot, you can see how a Jupyter notebook is running
    our experiment (notebook file) in a web browser just by clicking the **Run** button
    on the toolbar:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下截图中，你可以看到如何通过点击工具栏上的 **运行** 按钮，在网页浏览器中运行我们的实验（notebook 文件）：
- en: '![Figure 2.4 – Jupyter notebook running just the training cell in AutoKeras
    experiment](img/B16953_02_04.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 在 Jupyter notebook 中仅运行训练单元的 AutoKeras 实验](img/B16953_02_04.jpg)'
- en: Figure 2.4 – Jupyter notebook running just the training cell in AutoKeras experiment
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 仅运行训练单元的 Jupyter notebook，在 AutoKeras 实验中
- en: Using Jupyter notebooks is a great way to get started with AutoKeras, but not
    the only one; alternatively, you can also create your experiments in standalone
    Python scripts and run them from the command line or from your own **integrated
    development environment** (**IDE**).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Jupyter notebook 是开始使用 AutoKeras 的好方法，但不是唯一的方法；你还可以创建独立的 Python 脚本并通过命令行或你自己的
    **集成开发环境** (**IDE**) 运行它们。
- en: Installing AutoKeras
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 AutoKeras
- en: In the following sections, we will explain in detail the different options that
    exist for installing AutoKeras and how to configure each one step by step.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将详细解释安装 AutoKeras 的不同选项，以及如何一步一步配置每个选项。
- en: 'There are two options to choose when installing AutoKeras: we can install it
    in a local workstation or we can install it in the cloud. Each of the two options
    has its pros and cons that we will analyze throughout this chapter.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 AutoKeras 时有两个选项：我们可以将其安装在本地工作站，或者将其安装在云端。我们将在本章中分析这两种选择的优缺点。
- en: Installing AutoKeras in the cloud
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在云端安装 AutoKeras
- en: 'In the cloud, we have opted for two options: install it on an **Amazon Web
    Services** (**AWS**) instance/container, or use **Google Colaboratory**. In both
    cases, we will connect to the cloud instance using Jupyter notebooks from a web
    browser, as shown in the following screenshot. We just need a computer with an
    internet connection to run the notebooks:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在云端，我们选择了两种方案：将其安装在 **亚马逊 Web 服务** (**AWS**) 实例/容器中，或者使用 **Google Colaboratory**。在这两种情况下，我们将通过网页浏览器的
    Jupyter notebook 连接到云实例，正如以下截图所示。我们只需要一台可以联网的计算机来运行这些 notebook：
- en: '![Figure 2.5 – AutoKeras cloud configurations'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.5 – AutoKeras 云端配置](img/B16953_02_05.jpg)'
- en: '](img/B16953_02_05.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16953_02_05.jpg)'
- en: Figure 2.5 – AutoKeras cloud configurations
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – AutoKeras 云端配置
- en: Let's look at the options for the cloud in more detail.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解云端的选项。
- en: AutoKeras with Google Colaboratory
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Google Colaboratory 的 AutoKeras
- en: Google offers a Jupyter notebook-hosting service called **Colaboratory** where
    you can upload your Jupyter notebooks and run them on Google's cloud servers,
    leveraging the power of Google hardware (GPU or **tensor processing unit** (**TPU**)),
    regardless of the power of your workstation. All you need is a web browser. Also,
    as we said before, notebooks can install their own dependencies, so the AutoKeras
    installation can be performed while running the notebook (as we are doing with
    the notebooks in this book).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Google 提供了一项名为 **Colaboratory** 的 Jupyter notebook 托管服务，你可以上传自己的 Jupyter notebook，并在
    Google 的云服务器上运行它们，利用 Google 硬件（GPU 或 **张量处理单元** (**TPU**)) 的计算能力，无论你的工作站性能如何。你只需要一个网页浏览器。正如我们之前所说，notebook
    可以安装其自身的依赖项，因此在运行 notebook 时可以完成 AutoKeras 的安装（就像我们在本书中的 notebook 操作一样）。
- en: 'You can run our MNIST notebook by just following these three steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需按照以下三个步骤，即可运行我们的 MNIST notebook：
- en: Create an account at [https://colab.research.google.com](https://colab.research.google.com).
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 [https://colab.research.google.com](https://colab.research.google.com) 创建一个帐户。
- en: 'In Colaboratory, open the experiment from GitHub with this link: [https://colab.research.google.com/github/PacktPublishing/Automated-Machine-Learning-with-AutoKeras/blob/main/Chapter02/Chapter2.ipynb](https://colab.research.google.com/github/PacktPublishing/Automated-Machine-Learning-with-AutoKeras/blob/main/Chapter02/Chapter2.ipynb).'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Colaboratory 中，通过此链接打开 GitHub 上的实验：[https://colab.research.google.com/github/PacktPublishing/Automated-Machine-Learning-with-AutoKeras/blob/main/Chapter02/Chapter2.ipynb](https://colab.research.google.com/github/PacktPublishing/Automated-Machine-Learning-with-AutoKeras/blob/main/Chapter02/Chapter2.ipynb)。
- en: Click the **Run** button to start the AutoKeras installation and run the experiment.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **运行** 按钮以开始安装 AutoKeras 并运行实验。
- en: 'In the following screenshot, you can see Colaboratory running our experiment:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下截图中，你可以看到 Colaboratory 正在运行我们的实验：
- en: '![Figure 2.6 – AutoKeras running in Google Colaboratory](img/B16953_02_06.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 在 Google Colaboratory 中运行的 AutoKeras](img/B16953_02_06.jpg)'
- en: Figure 2.6 – AutoKeras running in Google Colaboratory
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 在 Google Colaboratory 中运行的 AutoKeras
- en: So, Google Colaboratory is a very good option to explore and run your notebooks
    quickly and easily, but next, we will also explain in detail how to install Jupyter
    notebook, plus the necessary dependencies, to run our notebooks in an AWS instance
    or in your own workstation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，Google Colaboratory是一个非常好的选择，可以快速轻松地探索和运行你的笔记本，但接下来，我们也将详细解释如何安装Jupyter笔记本，以及必要的依赖项，以便在AWS实例或你自己的工作站中运行我们的笔记本。
- en: AutoKeras in AWS
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AWS中的AutoKeras
- en: 'Basically, we have to make sure we create an Amazon EC2 Ubuntu/ Linux instance
    with GPU support and the **Compute Unified Device Architecture** (**CUDA**) libraries.
    Because AutoKeras will be installed when our Jupyter notebook is running, we just
    have to install the Jupyter framework and run our notebooks there. The following
    screenshot shows the client and server sides of an AutoKeras installation in an
    AWS instance:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们需要确保创建一个支持GPU的Amazon EC2 Ubuntu/Linux实例，并且安装了**计算统一设备架构**（**CUDA**）库。因为AutoKeras将在我们的Jupyter笔记本运行时安装，所以我们只需安装Jupyter框架并在其中运行笔记本。以下截图展示了在AWS实例中安装AutoKeras的客户端和服务器端：
- en: '![Figure 2.7 – AutoKeras running in AWS instance'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.7 – AutoKeras在AWS实例中运行'
- en: '](img/B16953_02_07.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16953_02_07.jpg)'
- en: Figure 2.7 – AutoKeras running in AWS instance
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – AutoKeras在AWS实例中运行
- en: There are many instances of AWS, some of them with the CUDA and Jupyter libraries
    already preinstalled and its ports mapped to access from your browser. The configuration
    of these is outside the scope of this book, but at [https://docs.aws.amazon.com/dlami/](https://docs.aws.amazon.com/dlami/)
    there is detailed information on how to set up DL **Amazon Machine Images** (**AMIs**)
    that allow you to quickly build Amazon **Elastic Compute Cloud** (**EC2**) instances
    on Amazon Linux or Ubuntu, preinstalled with the most popular DL frameworks.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: AWS有许多实例，其中一些已经预装了CUDA和Jupyter库，并且其端口已映射，可以从浏览器访问。它们的配置超出了本书的范围，但在[https://docs.aws.amazon.com/dlami/](https://docs.aws.amazon.com/dlami/)上有关于如何设置DL
    **Amazon Machine Images**（**AMIs**）的详细信息，这些映像允许你在Amazon Linux或Ubuntu上快速构建带有最流行DL框架的Amazon
    **Elastic Compute Cloud**（**EC2**）实例。
- en: If you prefer containers over instances, you also have the option to run **AWS
    DL Containers** (**AWS DL Containers**) which are Docker images similar to previous
    AMIs, with DL software preinstalled. Find out more at [https://aws.amazon.com/machine-learning/containers/](https://aws.amazon.com/machine-learning/containers/).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用容器而不是实例，你也可以选择运行**AWS DL Containers**（**AWS DL Containers**），这是一种类似于之前AMIs的Docker镜像，预装了DL软件。了解更多信息，请访问[https://aws.amazon.com/machine-learning/containers/](https://aws.amazon.com/machine-learning/containers/)。
- en: 'AutoKeras in the cloud: advantages and disadvantages'
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 云中的AutoKeras：优缺点
- en: If you don't have a powerful GPU, the cloud is a good and inexpensive option
    to get started without having to buy additional hardware.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有强大的GPU，云计算是一个很好的且廉价的选择，可以在不购买额外硬件的情况下入门。
- en: The cloud offering makes it easy to get started with AutoKeras; you can set
    it up from scratch on an AWS instance, upload your experiments to cloud services
    such as Google Colaboratory ([colab.research.google.com](http://colab.research.google.com)),
    or run the training on a remote server using an AutoKeras extension. At the end
    of the book, we will see an extension called TensorFlow Cloud that allows you
    to run your program on **Google Cloud Platform** (**GCP**) just by inserting a
    few more lines of code, taking easy advantage of the computing power in this cloud
    platform.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务使得开始使用AutoKeras变得容易；你可以从头开始在AWS实例中设置它，将你的实验上传到像Google Colaboratory这样的云服务([colab.research.google.com](http://colab.research.google.com))，或者使用AutoKeras扩展在远程服务器上运行训练。在书的结尾，我们将看到一个叫做TensorFlow
    Cloud的扩展，它可以让你只需插入几行代码，就能在**Google Cloud Platform**（**GCP**）上运行你的程序，轻松利用这个云平台的计算能力。
- en: But for a more intensive use of DL, this configuration is not the most suitable
    in the long run. Cloud instances or services are expensive, and if you need to
    train a model for more than a few hours, it is worth investing in a local workstation
    with one or more GPUs.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于更密集的DL使用，这种配置从长远来看并不是最合适的选择。云实例或服务是昂贵的，如果你需要训练一个模型超过几个小时，投资一台配备一个或多个GPU的本地工作站是值得的。
- en: On the other hand, if you need a large-scale on-demand configuration, setting
    up your own server cluster requires high cost in human and hardware resources
    and is much more difficult to scale and maintain than the cloud alternative.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你需要大规模的按需配置，建立自己的服务器集群需要高昂的人力和硬件资源成本，且比云计算替代方案更难扩展和维护。
- en: 'In this screenshot, you can see main differences between cloud and on-premises:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这张截图中，你可以看到云端与本地之间的主要差异：
- en: '![Figure 2.8 – AutoKeras in the cloud versus local costs](img/B16953_02_08.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – 云端与本地的AutoKeras成本比较](img/B16953_02_08.jpg)'
- en: Figure 2.8 – AutoKeras in the cloud versus local costs
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 云端与本地的AutoKeras成本比较
- en: In short, running AutoKeras in the cloud is a very good way to start. You can
    follow the code examples in this book and get cutting-edge prediction results
    using the power of cloud tools such as Google Colaboratory, but if you are planning
    to run your own experiments for several days or even weeks of training, it's best
    to get your own GPUs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，在云端运行AutoKeras是一个非常好的起步方式。你可以按照本书中的代码示例，利用Google Colaboratory等云工具的强大功能，获得前沿的预测结果，但如果你计划运行自己的实验，并进行几天甚至几周的训练，最好还是购买自己的GPU。
- en: Installing AutoKeras locally
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在本地安装AutoKeras
- en: If you already have your own hardware resources, it's time to install the software
    to run your models there. The options that are outlined next will guide you to
    achieve that goal.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经拥有自己的硬件资源，现在是时候安装软件来运行你的模型了。接下来的选项将指导你完成这一过程。
- en: Which operating system to choose
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择操作系统
- en: When it comes to choosing an operating system for AutoKeras, Linux is undoubtedly
    the most suitable option for both your workstation and the cloud.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择操作系统来运行AutoKeras时，Linux无疑是最适合你的工作站和云端的选择。
- en: Although it is possible to use AutoKeras in Windows, this is not recommended.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以在Windows中使用AutoKeras，但不推荐这样做。
- en: 'More specifically, the ideal option is an Ubuntu Linux machine due to the number
    of packages available and because it is the system most used by the ML community.
    If you use Windows, the simplest and fastest solution to get everything working
    is to install Ubuntu with a dual boot on your workstation, following the instructions
    in this link: [https://help.ubuntu.com/community/WindowsDualBoot](https://help.ubuntu.com/community/WindowsDualBoot).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，理想的选择是Ubuntu Linux机器，因为它有丰富的包可供使用，并且是机器学习社区最常用的系统。如果你使用Windows，最简单快速的解决方案是通过双启动安装Ubuntu，按照此链接中的说明操作：[https://help.ubuntu.com/community/WindowsDualBoot](https://help.ubuntu.com/community/WindowsDualBoot)。
- en: You can also use an AutoKeras Docker image, but depending on your hardware,
    this sometimes creates problems in accessing the GPUs.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用AutoKeras的Docker镜像，但根据你的硬件配置，这有时会导致无法访问GPU的问题。
- en: Installing AutoKeras on an Ubuntu Linux workstation
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Ubuntu Linux工作站上安装AutoKeras
- en: 'Once you have Ubuntu installed on your workstation, you can follow these steps
    to install AutoKeras and run the notebook files that come with this book:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在工作站上安装了Ubuntu，你可以按照以下步骤安装AutoKeras并运行本书附带的笔记本文件：
- en: 'Open a shell and run these commands to install the Jupyter notebook:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行这些命令来安装Jupyter笔记本：
- en: '[PRE1]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run this command to start the notebook:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行此命令启动笔记本：
- en: '[PRE2]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, go to `http://127.0.0.1:8888` in your browser and open the notebook file.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在浏览器中访问`http://127.0.0.1:8888`并打开笔记本文件。
- en: In the top menu, go to **Runtime** -> **Run All** to run the experiment. AutoKeras
    and its dependencies will be installed before running the rest of the code.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部菜单中，选择**Runtime** -> **Run All**来运行实验。AutoKeras及其依赖项将在运行其余代码之前安装。
- en: Important note
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: '**GPU setup (optional)**: If you have GPUs on your workstation and want AutoKeras
    to use them to accelerate the training of these, you can follow this tutorial
    to set this up:'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**GPU设置（可选）**：如果你在工作站上有GPU，并且希望AutoKeras使用它们加速训练，你可以按照此教程进行设置：'
- en: '[https://www.tensorflow.org/install/gpu](https://www.tensorflow.org/install/gpu)'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://www.tensorflow.org/install/gpu](https://www.tensorflow.org/install/gpu)'
- en: Keep in mind that AutoKeras is a work in progress and it evolves very quickly,
    and there may be changes in the installation process. I therefore recommend taking
    a look at the latest installation instructions, at [https://autokeras.com/install/](https://autokeras.com/install/).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，AutoKeras仍在不断发展中，并且变化很快，安装过程可能会有所调整。因此，我建议你查看最新的安装说明，网址是[https://autokeras.com/install/](https://autokeras.com/install/)。
- en: Run AutoKeras using a Docker container. The easiest way to get started with
    TensorFlow and Keras is to run in a Docker container.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Docker容器运行AutoKeras。开始使用TensorFlow和Keras的最简单方式是通过Docker容器运行。
- en: '**Docker** is a set of tools that allows you to install software in packages
    called containers, using virtualization at the operating system level. Each of
    the containers behaves like a single operating system with its own software, libraries,
    and configuration files, and these are isolated from each other. The process for
    creating a Docker container involves three steps, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker** 是一套工具，允许你以名为容器的软件包形式安装软件，利用操作系统级的虚拟化。每个容器表现得像一个独立的操作系统，拥有自己的软件、库和配置文件，并且这些容器彼此隔离。创建
    Docker 容器的过程包括三个步骤，如下所示：'
- en: First, a Docker container is defined in a file called **Dockerfile**.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在名为 **Dockerfile** 的文件中定义一个 Docker 容器。
- en: Then, using the Docker command-line tool, you can build an image from this Dockerfile.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用 Docker 命令行工具，你可以从这个 Dockerfile 构建一个镜像。
- en: Finally, you can start a Docker container from this image.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以从这个镜像启动 Docker 容器。
- en: 'You can see these three steps in the following diagram:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下图示中看到这三个步骤：
- en: '![Figure 2.9 – Building a container from a Dockerfile'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.9 – 从 Dockerfile 构建容器'
- en: '](img/B16953_02_09.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16953_02_09.jpg)'
- en: Figure 2.9 – Building a container from a Dockerfile
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – 从 Dockerfile 构建容器
- en: There is a public repository for Docker images called Docker Hub ([https://hub.docker.com/](https://hub.docker.com/)).
    There, you can find thousands of Docker images with preinstalled software packages.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像有一个公共的存储库，叫做 Docker Hub（[https://hub.docker.com/](https://hub.docker.com/)）。在这里，你可以找到成千上万的预安装软件包的
    Docker 镜像。
- en: 'You can use a Docker image for AutoKeras with the latest version of the framework
    and get its dependencies already installed using the following steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 AutoKeras 的 Docker 镜像，其中已安装最新版本的框架及其依赖项，步骤如下：
- en: 'Download the latest AutoKeras Docker image to your machine, as follows:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式将最新的 AutoKeras Docker 镜像下载到你的机器上：
- en: '[PRE3]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the AutoKeras Docker container, as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式运行 AutoKeras Docker 容器：
- en: '[PRE4]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you need more memory, just change the `shm-size` value.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你需要更多内存，只需更改 `shm-size` 的值。
- en: 'Run a local Python script inside the container, as follows:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式在容器内运行本地 Python 脚本：
- en: '[PRE5]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that we have mounted the `hostDir:/app` host folder where the Python
    file to execute is located.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经挂载了 `hostDir:/app` 主机文件夹，该文件夹中包含要执行的 Python 文件。
- en: You can also install the Jupyter notebook and run the AutoKeras installation
    process from the notebook experiment, as we did in the previous section.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以安装 Jupyter notebook 并从 notebook 实验中运行 AutoKeras 安装过程，正如我们在前一节中所做的那样。
- en: 'Hello MNIST: Implementing our first AutoKeras experiment'
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello MNIST：实现我们的第一个 AutoKeras 实验
- en: Our first experiment will be an image classifier using the MNIST dataset. This
    MINST classification task is like the *"hello world"* of DL. It is a classic problem
    of classifying images of handwritten digits into 10 categories (0 to 9). The images
    come from the MNIST, the most famous and widely used dataset in ML. It contains
    70,000 images (60,000 for training and 10,000 for testing) collected in the 1980s
    by the NIST.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个实验将是使用 MNIST 数据集的图像分类器。这个 MNIST 分类任务就像是深度学习的 *"hello world"*。它是一个经典的将手写数字图像分类为
    10 类（0 到 9）的任务。这些图像来自 MNIST，它是机器学习中最著名且被广泛使用的数据集。它包含了 70,000 张图像（其中 60,000 张用于训练，10,000
    张用于测试），这些图像是 1980 年代由 NIST 收集的。
- en: 'In the next screenshot, you can see some samples of every number in the MNIST
    dataset:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一张截图中，你可以看到 MNIST 数据集中每个数字的一些样本：
- en: '![Figure 2.10 – MNIST dataset sample images'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.10 – MNIST 数据集样本图像'
- en: '](img/B16953_02_10.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16953_02_10.jpg)'
- en: Figure 2.10 – MNIST dataset sample images
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – MNIST 数据集样本图像
- en: AutoKeras is designed to easily classify all types of data inputs—such as structured
    data, text, or images—as each of them contains a specific class.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: AutoKeras 旨在轻松分类各种类型的数据输入——例如结构化数据、文本或图像——因为每种数据都包含一个特定的类别。
- en: For this task, we will use `ImageClassifier`. This class generates and tests
    different models and hyperparameters, returning an optimal classifier to categorize
    the images of handwritten digits.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个任务，我们将使用 `ImageClassifier`。这个类会生成并测试不同的模型和超参数，返回一个最优分类器，用于分类手写数字图像。
- en: Now, let's have a look at the most relevant cells of the notebook in detail.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细查看 notebook 中最相关的单元格。
- en: Importing the needed packages
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入所需的包
- en: 'Load AutoKeras and the required packages, such as matplotlib, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式加载 AutoKeras 和所需的包，比如 matplotlib：
- en: '[PRE6]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding packages include a plotting Python library that we have used to
    plot some digital representations, and the dataset we used is the MNIST handwritten
    digits dataset.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的包中包括了一个绘图库，我们已使用它来绘制一些数字表示，所使用的数据集是MNIST手写数字数据集。
- en: Getting the MNIST dataset
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取MNIST数据集
- en: 'We have to first load the MNIST data in memory and have a quick look at the
    dataset shape. To do this, we run the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要将MNIST数据加载到内存中，并快速查看数据集的形状。为此，我们运行以下代码：
- en: '[PRE7]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following output will be displayed:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出将会显示：
- en: '[PRE8]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can see from the preceding output that each dataset contains images of size
    `28x28` pixels.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到每个数据集包含`28x28`像素大小的图像。
- en: 'Now, let''s see what a digit looks like by running the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过运行以下代码来看看一个数字长什么样：
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following output will be displayed:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出将会显示：
- en: '![Figure 2.11 – Training and test samples visualization'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.11 – 训练和测试样本可视化'
- en: '](img/B16953_02_11.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16953_02_11.jpg)'
- en: Figure 2.11 – Training and test samples visualization
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – 训练和测试样本可视化
- en: Once we have looked at some samples of datasets, let's look at their distribution.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们查看了数据集的一些样本，就可以看看它们的分布情况。
- en: How are the digits distributed?
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字是如何分布的？
- en: 'When we are working with datasets, it is very important to check that the data
    is distributed homogeneously. This can be done easily by using `numpy` functions,
    as shown in the following code block:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理数据集时，非常重要的一点是检查数据是否均匀分布。通过使用`numpy`函数可以轻松完成这项工作，如以下代码块所示：
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following output will be displayed:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出将会显示：
- en: '![Figure 2.12 – Training and test dataset histograms'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.12 – 训练和测试数据集直方图'
- en: '](img/B16953_02_12.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16953_02_12.jpg)'
- en: Figure 2.12 – Training and test dataset histograms
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 – 训练和测试数据集直方图
- en: It seems homogeneous—each set of digits has similar amounts of samples, so it's
    now time to create our model.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 数据似乎是均匀分布的——每组数字的样本数量相似，因此现在是时候创建我们的模型了。
- en: Creating an image classifier
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建图像分类器
- en: 'We will now use the AutoKeras `ImageClassifier` class to find the best classification
    model. Just for this little example, we set `max_trials` (the maximum number of
    different Keras models to try) to 1 and the number of epochs to train each model
    to 20, but for real use it is recommended to set a large number of trials and
    not to set the `epochs` parameter, to use an adaptive number of epochs automatically.
    The code can be seen here:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用AutoKeras的`ImageClassifier`类来找到最佳的分类模型。仅仅为了这个小例子，我们将`max_trials`（最大尝试的不同Keras模型数量）设置为1，并将训练每个模型的epoch数量设置为20，但对于实际使用，建议设置较大的尝试次数，并且不要设置`epochs`参数，以便自动使用自适应的epoch数量。代码如下所示：
- en: '[PRE11]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s run the training to search for the optimal classifier for the MNIST
    training dataset, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行训练，寻找适合MNIST训练数据集的最佳分类器，步骤如下：
- en: '[PRE12]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following output will be displayed:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出将会显示：
- en: '![Figure 2.13 – Notebook output of image classifier training'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.13 – 图像分类器训练的笔记本输出'
- en: '](img/B16953_02_13.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16953_02_13.jpg)'
- en: Figure 2.13 – Notebook output of image classifier training
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 – 图像分类器训练的笔记本输出
- en: In the previous output, we can see that the model has reached quite good accuracy
    for the training dataset in just a couple of minutes. We can also see that the
    best generated model was saved to disk.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到模型在几分钟内就达到了相当不错的训练数据集准确率。我们还可以看到最佳生成的模型已保存到磁盘。
- en: We can also see that the precision increases in each epoch, so if we increase
    the number of *epochs* we would have a more precise model, although it would also
    take longer to finish. It is also important to take into account that after a
    high number of epochs, the model will usually stop learning.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到精度在每个*epoch*中增加，因此如果我们增加*epoch*的数量，模型会更精确，尽管也会花费更长时间完成。还需要注意的是，在经过大量的epoch后，模型通常会停止学习。
- en: Let's test it with the test dataset to know the actual accuracy of the prediction.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用测试数据集进行测试，以了解预测的实际准确率。
- en: Evaluating the model with the test set
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用测试集评估模型
- en: 'After training, it''s time to measure the actual prediction of our model using
    the reserved test dataset. In this way, we can rule out that the good results
    obtained with the training set were due to overfitting. Have a look at the following
    code snippet:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 训练完成后，是时候使用保留的测试数据集来测量模型的实际预测结果。通过这种方式，我们可以排除训练集上获得的良好结果是由于过拟合导致的。看看以下代码片段：
- en: '[PRE13]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following output will be displayed:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出将会显示：
- en: '[PRE14]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can see here that there is really good prediction accuracy using our test
    dataset (98.8%), considering that we only spent a couple of minutes in the training
    phase.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，使用我们的测试数据集，预测准确率非常高（98.8%），考虑到我们在训练阶段只花了几分钟时间。
- en: 'Let''s have a look at how it is predicting a single test sample. First, we
    visualize the number and its true value, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看它是如何预测单个测试样本的。首先，我们可视化数字及其真实值，如下所示：
- en: '[PRE15]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following output will be displayed:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出将被显示：
- en: '![Figure 2.14 – Test sample to be predicted](img/B16953_02_14.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.14 – 待预测的测试样本](img/B16953_02_14.jpg)'
- en: Figure 2.14 – Test sample to be predicted
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14 – 待预测的测试样本
- en: 'Now, we print the predicted value using our classifier, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用我们的分类器打印预测值，如下所示：
- en: '[PRE16]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following output will be displayed:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出将被显示：
- en: '[PRE17]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can see that the output matches the true value, so our classifier has predicted
    this correctly. Let's now take a look inside the classifier to understand how
    it is working.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，输出与真实值匹配，因此我们的分类器预测是正确的。现在，让我们深入了解分类器，理解它是如何工作的。
- en: Visualizing the model
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化模型
- en: 'We are now exporting our classifier model to Keras so that we can see a little
    summary, with the architecture of the best generated model found. Here is the
    code we need to do this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将我们的分类器模型导出到Keras，这样我们可以看到一些摘要信息，包括找到的最佳生成模型的架构。以下是我们需要做的代码：
- en: '[PRE18]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following output will be displayed:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出将被显示：
- en: '![Figure 2.15 – Image classifier model architecture summary](img/B16953_02_15.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.15 – 图像分类模型架构总结](img/B16953_02_15.jpg)'
- en: Figure 2.15 – Image classifier model architecture summary
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 – 图像分类模型架构总结
- en: If you do not have experience in Keras or Tensorflow this output will be a bit
    confusing, but don't worry—it's not necessary to understand it to use AutoKeras
    because the tool does all the work, abstracting us from these details, but it's
    always good to know how it works. In later chapters, we will see what each layer
    means in detail, but let's see an overview of what's going on here.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有Keras或Tensorflow的经验，输出可能会有些令人困惑，但别担心——要使用AutoKeras并不需要理解这些细节，因为工具会做所有的工作，将我们从这些细节中抽象出来。不过，了解它是如何工作的总是有益的。在后续章节中，我们将详细了解每一层的含义，但现在让我们先看看这里发生了什么。
- en: Each layer performs a transformation operation of the input data, passing the
    transformed data to the next layer.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 每一层执行对输入数据的变换操作，将变换后的数据传递给下一层。
- en: 'The first layer has a 28x28 input that corresponds to the pixels of the image,
    as seen in the following code snippet:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 第一层有一个28x28的输入，对应图像的像素，如下所示的代码片段：
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following tree layers transform and normalize the image to adapt it to
    the input of the convolutional operations (Conv2D):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下树状层对图像进行变换和归一化，以适应卷积操作（Conv2D）的输入：
- en: '[PRE20]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The convolutional operations layers, widely used for the classification of
    images, extract characteristics of the image through the use of filters (we will
    talk about this in later chapters). We can see the process in the following snippet:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 卷积操作层广泛应用于图像分类，它通过使用滤波器提取图像的特征（我们将在后面的章节中讨论这一点）。我们可以在以下片段中看到这个过程：
- en: '[PRE21]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Subsequently there are several layers that prevent overfitting by performing
    dropout (arbitrarily disconnecting part of the neural connections), as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，出现了多个层，防止过拟合，通过执行dropout（随机断开部分神经连接），具体如下：
- en: '[PRE22]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, a full connect operation is performed that reduces the dimension of the
    output of the convolutional operations to 10 elements that correspond to the numbers
    from 0 to 9, as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行全连接操作，将卷积操作的输出维度缩减为10个元素，这些元素对应从0到9的数字，具体如下：
- en: '[PRE23]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, the last layer (Softmax) is left with only the highest value of the
    10 elements that will correspond to the final predicted number, as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一层（Softmax）只保留10个元素中最高的值，这个值将对应最终预测的数字，具体如下：
- en: '[PRE24]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There is a more graphical way to visualize the model, so let''s see it by running
    the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种更具图形化的方式来可视化模型，让我们通过运行以下代码来查看：
- en: '[PRE25]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following output will be displayed:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出将被显示：
- en: '![Figure 2.16 – Image classifier model architecture visualization'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.16 – 图像分类模型架构可视化]'
- en: '](img/B16953_02_16.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16953_02_16.jpg)'
- en: Figure 2.16 – Image classifier model architecture visualization
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 – 图像分类模型架构可视化
- en: In the preceding diagram, each block represents a layer and the output of each
    is connected to the input of the next, except the first block (whose input is
    the image) and the last block (whose output is the prediction).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述图中，每个块代表一个层，每个层的输出连接到下一个层的输入，除了第一个块（其输入是图像）和最后一个块（其输出是预测值）。
- en: Creating an image regressor
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建图像回归器
- en: 'Now, we will use a different approach to figure out the digit values from the
    image: a regression model call regressor.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用不同的方法来从图像中找出数字值：一个称为回归器的回归模型。
- en: The image regressor will try to predict the scalar value of the digit instead,
    to classify it in a 0-9 category.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图像回归器将尝试预测数字的标量值，而不是将其分类为 0-9 类别。
- en: AutoKeras has already a special class ready to use called `ImageRegressor`,
    which will find the best regression model.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: AutoKeras 已经有一个准备好使用的特殊类称为 `ImageRegressor`，它将找到最佳的回归模型。
- en: As we did with the classifier, for this little example we set `max_trials` (the
    maximum number of different Keras models to try) to 1 and the number of epochs
    to train each model to 20, but for real use it is recommended to set a large number
    of trials and not to set the `epochs` parameter to use an adaptive number of epochs
    automatically.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对分类器所做的那样，对于这个小例子，我们将 `max_trials`（尝试的不同 Keras 模型的最大数量）设置为 1，并将每个模型训练的时期数设置为
    20，但是对于实际使用，建议设置一个较大的试验数，并且不设置 `epochs` 参数以自动使用自适应数量的 epochs。
- en: 'First, we initialize the image regressor, as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们初始化图像回归器，如下所示：
- en: '[PRE26]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, feed the image regressor with the training dataset, as follows.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用训练数据集来喂养图像回归器，如下所示。
- en: '[PRE27]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now is the moment of truth—let's evaluate it with our test set.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是真相的时刻——让我们用我们的测试集来评估它。
- en: Evaluating the model with the test set
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用测试集评估模型
- en: 'Finally, we evaluate the best model with the testing dataset, using the following
    code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用以下代码评估最佳模型与测试数据集：
- en: '[PRE28]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following output will be displayed:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示以下输出：
- en: '![Figure 2.17 – Notebook output of image regressor training'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.17 – 图像回归器训练的笔记本输出'
- en: '](img/B16953_02_17.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16953_02_17.jpg)'
- en: Figure 2.17 – Notebook output of image regressor training
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17 – 图像回归器训练的笔记本输出
- en: After 20 minutes, the best model found has a `0.083`, which isn't bad. MSE is
    a widely used metric for measuring performance in regression models.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在 20 分钟后，找到的最佳模型具有 `0.083` 的值，这并不差。均方误差（MSE）是衡量回归模型性能的广泛使用的度量标准。
- en: 'Let''s predict the first 10 digits of the test dataset with the best model
    found, and print the predicted and true values to compare them. We can do this
    by running the following code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用找到的最佳模型预测测试数据集的前 10 个数字，并打印预测值和真实值以进行比较。我们可以通过运行以下代码来实现：
- en: '[PRE29]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following output will be displayed:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示以下输出：
- en: '[PRE30]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As you can see, it''s predicting the true value in every one of the cases.
    Let''s see it in a more graphical way by running the following code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，它在每一个案例中都预测了真实值。让我们通过运行以下代码以更加图形化地看待它：
- en: '[PRE31]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following output will be displayed:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示以下输出：
- en: '![Figure 2.18 – Image digits labeled with the predicted values](img/B16953_02_18.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.18 – 图像数字标签与预测值](img/B16953_02_18.jpg)'
- en: Figure 2.18 – Image digits labeled with the predicted values
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18 – 图像数字标签与预测值
- en: Notice that we have rounded up the float values returned by the regressor to
    compare them to the true values. This is done because regressors always return
    continuous values that they approximate to the real value, so if we want to predict
    discrete values (0 to 9 digits), we have to do a rounding to return the predicted
    value.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经将回归器返回的浮点值四舍五入以与真实值进行比较。这是因为回归器总是返回接近实际值的连续值，所以如果我们想要预测离散值（0到9的数字），我们必须进行四舍五入以返回预测值。
- en: Now, as we did with the classifier, let's take a look at the architecture of
    the best generated model.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就像我们对分类器所做的那样，让我们来看看生成的最佳模型的架构。
- en: Visualizing the model
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化模型
- en: 'We export the model to a Keras model and then we make a call to the `model.summary`
    function to see the architecture, as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将模型导出为 Keras 模型，然后调用 `model.summary` 函数来查看架构，如下所示：
- en: '[PRE32]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following output will be displayed:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示以下输出：
- en: '![Figure 2.19 – Image regressor model architecture summary'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.19 – 图像回归模型架构摘要'
- en: '](img/B16953_02_19.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16953_02_19.jpg)'
- en: Figure 2.19 – Image regressor model architecture summary
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.19 – 图像回归模型架构摘要
- en: 'As we did with the classifier, there is a more visual way to see it, as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对分类器所做的那样，有一种更加直观的方式来看待它，如下所示：
- en: '[PRE33]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following output will be displayed:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出将会显示：
- en: '![Figure 2.20 – Image regressor model architecture visualization](img/B16953_02_20.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.20 – 图像回归模型架构可视化](img/B16953_02_20.jpg)'
- en: Figure 2.20 – Image regressor model architecture visualization
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.20 – 图像回归模型架构可视化
- en: In this example of the classifier, we have given a quick view of each block.
    We will not go deeper here, as I think this is enough for a "getting started"
    chapter. In the following chapters, we will explain in more detail each of the
    blocks that appear in the screenshots.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个分类器的示例中，我们简要展示了每个模块的概况。我们不会在这里深入讲解，因为我认为这对于“入门”章节已经足够。在接下来的章节中，我们将更详细地解释截图中出现的每个模块。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned the main options for getting started with
    AutoKeras, from installation to running in various environments.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学习了如何使用AutoKeras的主要选项，从安装到在不同环境中的运行。
- en: You have also seen the power of AutoKeras by implementing two different approaches
    of a high-precision image classifier in just a few lines of code and 2 minutes
    of training.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你也已经看到了AutoKeras的强大功能，通过仅用几行代码和2分钟的训练，成功实现了两种高精度图像分类器的方法。
- en: Now that you have learned to implement a DL model from scratch, following these
    same steps and simply changing the dataset, your model would be able to classify
    all kinds of images.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了从头实现一个深度学习模型，只需要按照相同的步骤并简单地更换数据集，你的模型就能够分类各种图像。
- en: In the following chapters, you will learn how to solve more complicated tasks
    related to images, structured data, and plaintext as input data sources, but before
    that, in the next chapter, we will see how to prepare the data to feed to AutoKeras
    by using some interesting tools to automate this process as much as possible.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将学习如何解决与图像、结构化数据和纯文本等输入数据源相关的更复杂任务。但在此之前，在下一章，我们将介绍如何使用一些有趣的工具来准备数据，以尽可能自动化地将其输入到AutoKeras。
