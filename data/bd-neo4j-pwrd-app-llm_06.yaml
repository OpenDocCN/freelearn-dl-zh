- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Implementing Powerful Search Functionalities with Neo4j and Haystack
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Neo4j 和 Haystack 实现强大的搜索功能
- en: In this chapter, we embark on a journey to integrate Haystack with Neo4j, combining
    the capabilities of LLMs and graph databases to build an AI-powered search system.
    **Haystack** is an open-source framework that enables developers to create AI-powered
    applications by leveraging modern NLP techniques, machine learning models, and
    graph-based data. For our intelligent search, Haystack will serve as a cohesive
    platform for orchestrating LLMs, search engines, and databases, delivering highly
    contextualized and relevant search results.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始将 Haystack 与 Neo4j 集成，结合 LLM 和图数据库的能力来构建一个由 AI 驱动的搜索系统。**Haystack**
    是一个开源框架，使开发者能够通过利用现代 NLP 技术、机器学习模型和基于图的数据来创建 AI 驱动的应用程序。对于我们的智能搜索，Haystack 将作为一个统一的平台来协调
    LLM、搜索引擎和数据库，提供高度上下文化和相关的搜索结果。
- en: Building upon the work from the previous chapter—where we cleaned and structured
    our Neo4j data—we will start by generating embeddings using OpenAI’s GPT models.
    These embeddings will enrich the graph, making it more powerful and capable of
    handling nuanced, context-aware search queries. Haystack will serve as the bridge
    between OpenAI’s models and the Neo4j graph database, allowing us to combine the
    strengths of both.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章的工作基础上——我们清理并结构化 Neo4j 数据——我们将首先使用 OpenAI 的 GPT 模型生成嵌入。这些嵌入将丰富图结构，使其更强大，并能够处理细微的、上下文感知的搜索查询。Haystack
    将作为 OpenAI 模型和 Neo4j 图数据库之间的桥梁，使我们能够结合两者的优势。
- en: In this chapter, you will learn how to set up and configure Haystack for seamless
    integration with Neo4j. We will walk you through building powerful search functionalities
    and finally deploying this fully functional search system, using Gradio on Hugging
    Face Spaces.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何设置和配置 Haystack 以实现与 Neo4j 的无缝集成。我们将引导您构建强大的搜索功能，并最终使用 Hugging Face
    Spaces 上的 Gradio 部署这个完全功能化的搜索系统。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Generating embeddings with Haystack to enhance your Neo4j graph
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Haystack 生成嵌入以增强您的 Neo4j 图
- en: Connecting Haystack to Neo4j for advanced vector search
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Haystack 连接到 Neo4j 进行高级向量搜索
- en: Building powerful search experiences
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建强大的搜索体验
- en: Fine-tuning your Haystack integration
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微调您的 Haystack 集成
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To successfully implement the integration of Haystack and Neo4j, and to build
    an AI-powered search system, you will need to ensure that your environment is
    properly set up. Here is a list of the technical requirements for this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功实现 Haystack 和 Neo4j 的集成，并构建一个由 AI 驱动的搜索系统，您需要确保您的环境已正确设置。以下是本章的技术要求列表：
- en: '**Python**: You will need Python `3.11` installed on your system. Python is
    used for scripting and interacting with the Neo4j database. You can download Python
    from the official Python website: [https://www.python.org/downloads/](https://www.python.org/downloads/).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python**：您需要在您的系统上安装 Python `3.11`。Python 用于脚本编写和与 Neo4j 数据库交互。您可以从官方 Python
    网站下载 Python：[https://www.python.org/downloads/](https://www.python.org/downloads/)。'
- en: '**Neo4j AuraDB or local Neo4j instance**: You will need access to a Neo4j database
    to store and query your graph data. This can be either a locally installed Neo4j
    instance or a cloud-hosted Neo4j AuraDB instance. If you are following along from
    the previous chapter, where we talked about the `graph_build.py` script ([https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch4/graph_build.py](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch4/graph_build.py)),
    you can continue using the same Neo4j instance that was set up and populated with
    data. This ensures continuity and allows you to build on top of the structured
    data that has already been imported.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Neo4j AuraDB 或本地 Neo4j 实例**：您需要访问一个 Neo4j 数据库来存储和查询您的图数据。这可以是本地安装的 Neo4j
    实例或云托管的 Neo4j AuraDB 实例。如果您正在跟随前一章的内容，其中我们讨论了 `graph_build.py` 脚本 ([https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch4/graph_build.py](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch4/graph_build.py))，您可以继续使用已设置并填充数据的相同
    Neo4j 实例。这确保了连续性，并允许您在已导入的结构化数据之上构建。'
- en: '**Cypher query language**: Familiarity with the Cypher query language is essential,
    as we will be using Cypher extensively to create and query the graph. You can
    find out more about Cypher syntax in the Cypher query language documentation:
    [https://neo4j.com/docs/cypher/](https://neo4j.com/docs/cypher/).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cypher查询语言**：熟悉Cypher查询语言是必要的，因为我们将在创建和查询图时广泛使用Cypher。你可以在Cypher查询语言文档中了解更多关于Cypher语法的细节：[https://neo4j.com/docs/cypher/](https://neo4j.com/docs/cypher/)。'
- en: '**Neo4j Python driver**: Install the Neo4j Python driver to connect to the
    Neo4j database using Python. You can install it via `pip`:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Neo4j Python驱动程序**：安装Neo4j Python驱动程序以使用Python连接到Neo4j数据库。你可以通过`pip`安装它：'
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Haystack**: We will be using Haystack v2.5.0.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Haystack**：我们将使用Haystack v2.5.0。'
- en: 'Install Haystack using pip:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pip安装Haystack：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**OpenAI API key**: To successfully generate embeddings using GPT-based models,
    you will need an OpenAI API key.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenAI API密钥**：要成功使用基于GPT的模型生成嵌入，你需要一个OpenAI API密钥。'
- en: Obtain the API key by signing up for an account at OpenAI ([https://platform.openai.com/signup](https://platform.openai.com/signup))
    if you do not have one.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有账户，请在OpenAI（[https://platform.openai.com/signup](https://platform.openai.com/signup)）注册以获取API密钥。
- en: '**Note**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: A free-tier API key will not work for most use cases in this project. You will
    need an active paid OpenAI subscription to access the necessary endpoints and
    usage limits.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 免费层API密钥在本项目的多数用例中都不会工作。你需要一个活跃的付费OpenAI订阅才能访问必要的端点和使用限制。
- en: Once you are logged in, navigate to the **API keys** section ([https://platform.openai.com/api-keys](https://platform.openai.com/api-keys))
    in your OpenAI dashboard and generate a new API key.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，导航到你的OpenAI仪表板中的**API密钥**部分（[https://platform.openai.com/api-keys](https://platform.openai.com/api-keys)）并生成一个新的API密钥。
- en: 'You also need to install the OpenAI package using pip. Run the following command
    in your terminal:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要使用pip安装OpenAI包。在你的终端中运行以下命令：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Gradio**: Gradio will be used to create a user-friendly chatbot interface.
    Install Gradio using pip:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gradio**：我们将使用Gradio创建一个用户友好的聊天机器人界面。使用pip安装Gradio：'
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Hugging Face account**: To host your chatbot on Hugging Face Spaces, you
    will need a Hugging Face account. If you do not have one, sign up on the Hugging
    Face website: [https://huggingface.co/](https://huggingface.co/).'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hugging Face账户**：要将你的聊天机器人托管在Hugging Face Spaces上，你需要一个Hugging Face账户。如果你还没有账户，请在Hugging
    Face网站上注册：[https://huggingface.co/](https://huggingface.co/)。'
- en: '**Google Cloud Storage (optional)**: If you are storing your CSV files on Google
    Cloud Storage, ensure that your file paths are properly configured in the script.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Cloud Storage（可选）**：如果你将CSV文件存储在Google Cloud Storage上，请确保在脚本中正确配置了文件路径。'
- en: '**python-dotenv package**: Make sure to install the `python-dotenv` package
    to manage environment variables in your project:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**python-dotenv包**：确保安装`python-dotenv`包以管理项目中的环境变量：'
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'All the code for this chapter is available in the following GitHub repository:
    [https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码都可在以下GitHub仓库中找到：[https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs)。
- en: Inside this repository, navigate to the folder named `ch6` to access the code
    examples and resources related to this chapter. This folder contains all the necessary
    scripts, files, and configurations required to implement the Neo4j and Haystack
    integration, as well as build the AI-powered search system using the movies dataset.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在此仓库中，导航到名为`ch6`的文件夹以访问与本章相关的代码示例和资源。此文件夹包含实现Neo4j和Haystack集成以及使用电影数据集构建AI驱动的搜索系统所需的所有必要脚本、文件和配置。
- en: Make sure to clone or download the repository so you can follow along with the
    code examples throughout this chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 确保克隆或下载仓库，这样你就可以跟随本章中的代码示例进行操作。
- en: Generating embeddings with Haystack to enhance your Neo4j graph
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Haystack生成嵌入以增强你的Neo4j图
- en: In this section, we will focus on generating embeddings for the movie plots
    that we added to our Neo4j graph in the previous chapter. **Embeddings** are a
    critical part of modern search systems, as they convert text into high-dimensional
    vectors that enable similarity search. This enables the search engine to understand
    the contextual relationships between words and phrases, improving the accuracy
    and relevance of search results.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将专注于生成上一章中添加到我们的Neo4j图中的电影剧情的嵌入。**嵌入**是现代搜索系统的一个关键部分，因为它们将文本转换为高维向量，从而实现相似度搜索。这使得搜索引擎能够理解单词和短语之间的上下文关系，提高搜索结果的准确性和相关性。
- en: We will integrate Haystack with OpenAI’s GPT-based models to generate these
    embeddings and store them in your Neo4j graph. This will enable a more accurate
    and context-aware search functionality.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将集成Haystack与OpenAI的基于GPT的模型以生成这些嵌入，并将它们存储在你的Neo4j图中。这将启用更准确和上下文感知的搜索功能。
- en: Initializing Haystack and OpenAI for embeddings
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化Haystack和OpenAI以生成嵌入
- en: 'Before generating embeddings, you will need to ensure that Haystack is set
    up and integrated with OpenAI’s API to retrieve embeddings from their GPT-based
    models. Follow these steps to set up Haystack:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成嵌入之前，你需要确保Haystack已设置并集成到OpenAI的API中，以从其基于GPT的模型中检索嵌入。按照以下步骤设置Haystack：
- en: 'Install the required libraries (if you have not already) by using the following
    command:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下命令安装所需的库（如果你还没有安装）：
- en: '[PRE5]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, configure your OpenAI API key and ensure that it is set up in your `.env`
    file:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，配置你的OpenAI API密钥，并确保它在你的`.env`文件中设置：
- en: '[PRE6]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Initialize Haystack with OpenAI embeddings by creating a Python script that
    initializes Haystack and connects to OpenAI to generate the embeddings:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个初始化Haystack并连接到OpenAI以生成嵌入的Python脚本来初始化Haystack使用OpenAI嵌入：
- en: '[PRE7]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This configuration initializes Haystack with an in-memory document store and
    sets up the retriever using OpenAI embeddings.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置初始化Haystack使用内存中的文档存储，并使用OpenAI嵌入设置检索器。
- en: Generating embeddings for movie plots
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为电影剧情生成嵌入
- en: 'Next, we will generate embeddings for the movie plots stored in the Neo4j graph.
    The goal is to retrieve the plot descriptions, generate embeddings for them, and
    link these embeddings back to the respective movie nodes:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为存储在Neo4j图中的电影剧情生成嵌入。目标是检索剧情描述，为它们生成嵌入，并将这些嵌入链接回相应的电影节点：
- en: '**Query movie plots from Neo4j**: First, you will need to query the movie plots
    from Neo4j. Use the following Cypher query to retrieve movie titles and plot summaries:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从Neo4j查询电影剧情**：首先，你需要从Neo4j查询电影剧情。使用以下Cypher查询检索电影标题和剧情摘要：'
- en: '[PRE8]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will return the `tmdbId` value and overview (that is, the plot summary)
    for each movie in the graph.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回图中的每个电影的`tmdbId`值和概述（即剧情摘要）。
- en: '**Generate embeddings using OpenAI and Haystack:** Once the plot summaries
    are retrieved, generate embeddings using Haystack’s `OpenAITextEmbedder`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用OpenAI和Haystack生成嵌入**：一旦检索到剧情摘要，就可以使用Haystack的`OpenAITextEmbedder`生成嵌入：'
- en: '[PRE9]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Store embeddings in Neo4j**: With the embeddings generated, the next step
    is to store them in your Neo4j graph. Each movie node will be updated with a property
    that stores its embedding:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在Neo4j中存储嵌入**：生成嵌入后，下一步是将它们存储在你的Neo4j图中。每个电影节点都将更新一个属性，以存储其嵌入：'
- en: '[PRE10]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will store the embeddings as a property called `embedding` in each `Movie`
    node in the Neo4j graph.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在Neo4j图中的每个`Movie`节点中存储名为`embedding`的属性。
- en: '**Verify the embedding storage in Neo4j**: Once the embeddings are stored,
    you can verify their presence in Neo4j by querying a few nodes to check the `embedding`
    property:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**验证Neo4j中的嵌入存储**：一旦嵌入存储，你可以通过查询几个节点来检查`embedding`属性以验证它们的存在：'
- en: '[PRE11]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This query will return the titles and embeddings for a few movies, allowing
    you to verify that the embeddings were successfully stored.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询将返回一些电影的标题和嵌入，以便你可以验证嵌入是否已成功存储。
- en: '**Note**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'These are just the snippets of the code. The full version is available in the
    GitHub repository: [https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch5/generate_embeddings.py](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch5/generate_embeddings.py).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是代码片段。完整版本可在GitHub仓库中找到：[https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch5/generate_embeddings.py](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch5/generate_embeddings.py)。
- en: We have now enriched our graph with these embeddings and thus added similarity
    search, which will allow us to perform more context-aware and intelligent queries.
    This step is crucial for enhancing the search experience and enabling advanced
    retrieval operations based on the meaning of text, rather than simple keyword
    matching.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经用这些嵌入丰富了我们的图，从而添加了相似性搜索，这将使我们能够执行更具有上下文意识和智能的查询。这一步对于增强搜索体验和基于文本意义的先进检索操作至关重要，而不是简单的关键词匹配。
- en: Now that our Neo4j graph has been enriched with vector embeddings, the next
    step is to connect Haystack to Neo4j for advanced vector search. In the upcoming
    section, we will focus on how to use these embeddings to perform efficient and
    accurate vector searches within Neo4j, enabling us to retrieve movies or nodes
    based on their vector similarity.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经用向量嵌入丰富了我们的 Neo4j 图，下一步是将 Haystack 连接到 Neo4j 以进行高级向量搜索。在接下来的章节中，我们将重点介绍如何使用这些嵌入在
    Neo4j 中执行高效且准确的向量搜索，使我们能够根据它们的向量相似性检索电影或节点。
- en: Connecting Haystack to Neo4j for advanced vector search
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Haystack 连接到 Neo4j 以进行高级向量搜索
- en: With the movie embeddings now stored in Neo4j, we need to configure a vector
    index on the `embedding` property, which will allow us to efficiently search for
    movies based on their vector similarity. By creating a vector index in Neo4j,
    we enable rapid retrieval of nodes that are close in the high-dimensional embedding
    space, making it possible to perform sophisticated queries, such as finding movies
    with similar plot summaries.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在电影嵌入已存储在 Neo4j 中，我们需要在 `embedding` 属性上配置一个向量索引，这将使我们能够根据它们的向量相似性高效地搜索电影。通过在
    Neo4j 中创建向量索引，我们能够快速检索在高维嵌入空间中彼此接近的节点，这使得执行复杂的查询成为可能，例如找到具有相似剧情摘要的电影。
- en: Once the vector index has been created, it will be integrated with Haystack
    to perform vector-based retrieval from Neo4j. This search will be based on vector
    similarity mechanisms such as cosine similarity.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了向量索引，它将与 Haystack 集成以从 Neo4j 执行基于向量的检索。此搜索将基于向量相似性机制，如余弦相似性。
- en: Creating a vector search index in Neo4j
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Neo4j 中创建向量搜索索引
- en: 'You will first want to drop any existing vector index on the embedding property
    (if one exists) and then create a new one for performing vector searches. This
    is how you can do that using Cypher queries in your Python script:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先需要删除嵌入属性上的任何现有向量索引（如果存在），然后创建一个新的索引以执行向量搜索。这是您如何在 Python 脚本中使用 Cypher 查询来完成此操作的示例：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Performing similarity search with Haystack and a Neo4j vector index
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Haystack 和 Neo4j 向量索引执行相似性搜索
- en: After creating a vector index on the Neo4j graph, you can leverage Haystack
    to perform similarity search queries based on movie plot embeddings. This approach
    allows you to compare the similarity between a given movie plot or any text query
    and existing movie overviews, returning the most relevant results based on their
    embeddings. In this example, we use the `OpenAITextEmbedder` model from the Haystack
    library to convert the text query into an embedding and then use it to search
    the Neo4j graph for movies with similar plots.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Neo4j 图上创建向量索引后，您可以利用 Haystack 执行基于电影剧情嵌入的相似性搜索查询。这种方法允许您比较给定电影剧情或任何文本查询与现有电影概述之间的相似性，根据它们的嵌入返回最相关的结果。在这个示例中，我们使用
    Haystack 库中的 `OpenAITextEmbedder` 模型将文本查询转换为嵌入，然后使用它来搜索具有相似剧情的 Neo4j 图中的电影。
- en: 'This is how you generate the query embedding and perform the similarity search:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您生成查询嵌入并执行相似性搜索的方法：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Running a vector search query with Haystack and Neo4j
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Haystack 和 Neo4j 运行向量搜索查询
- en: Once the vector index has been created and the embeddings are stored in Neo4j,
    you can perform a vector-based search by passing a query or a sample movie plot.
    The system will generate an embedding for the query, compare it with the embeddings
    stored in Neo4j, and return the most related results.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了向量索引并将嵌入存储在 Neo4j 中，您就可以通过传递查询或样本电影剧情来执行基于向量的搜索。系统将为查询生成一个嵌入，将其与存储在 Neo4j
    中的嵌入进行比较，并返回最相关的结果。
- en: 'Here is an example of a vector search using Haystack that displays the most
    similar movie plots without Cypher:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用 Haystack 进行向量搜索的示例，它显示了最相似的电影剧情，而不使用 Cypher：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, we will integrate Neo4j Cypher queries with Haystack to run a vector search,
    enabling the retrieval of similar movie plots.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将集成 Neo4j Cypher 查询与 Haystack 以运行向量搜索，从而实现类似剧情的检索。
- en: Running a vector search query using Cypher and Haystack
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Cypher 和 Haystack 运行向量搜索查询
- en: To run a vector search, we will use Cypher’s graph querying capabilities while
    performing similarity searches using vector embeddings generated by `OpenAITextEmbedder`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行向量搜索，我们将使用Cypher的图查询功能，同时使用由`OpenAITextEmbedder`生成的向量嵌入进行相似度搜索。
- en: Unlike directly querying the vector index using Haystack, this approach combines
    Cypher’s flexibility to return more complex data, such as movie metadata (e.g.,
    cast and genres), along with embeddings, while still maintaining the efficiency
    of vector similarity search.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接使用Haystack查询向量索引不同，这种方法结合了Cypher的灵活性，可以返回更复杂的数据，例如电影元数据（例如，演员和类型），同时仍然保持向量相似度搜索的效率。
- en: 'Here are the steps involved in this process:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里涉及到的步骤如下：
- en: '**Embed the query using OpenAITextEmbedder**: Convert the user’s text query
    (e.g., a movie plot) into a high-dimensional vector embedding.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用OpenAITextEmbedder嵌入查询**：将用户的文本查询（例如，电影剧情）转换为高维向量嵌入。'
- en: '**Search using Neo4j and Cypher**: Use Cypher to retrieve similar movies by
    comparing the query embedding with movie plot embeddings stored in Neo4j’s vector
    index.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用Neo4j和Cypher进行搜索**：使用Cypher通过比较查询嵌入与存储在Neo4j向量索引中的电影剧情嵌入来检索相似电影。'
- en: '**Return enriched data**: Fetch additional movie information, such as the title,
    overview, cast, genres, and score (similarity), for each result.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**返回丰富数据**：为每个结果检索额外的电影信息，例如标题、概述、演员、类型和评分（相似度）。'
- en: 'This is how you implement vector search:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是实现向量搜索的方法：
- en: '**Define the Cypher query**: We start by defining a Cypher query that searches
    the Neo4j vector index (`overview_embeddings`) to retrieve the `top_k` most similar
    movies based on the cosine similarity between the query embedding and movie embeddings:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定义Cypher查询**：我们首先定义一个Cypher查询，该查询搜索Neo4j向量索引（`overview_embeddings`），以检索基于查询嵌入和电影嵌入之间的余弦相似度的`top_k`最相似的电影：'
- en: '[PRE15]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Generate the query embedding**: Using `OpenAITextEmbedder`, we convert the
    user’s input query (e.g., a movie plot) into an embedding. This embedding will
    be passed to the Neo4j vector index for comparison with the stored movie embeddings:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生成查询嵌入**：使用`OpenAITextEmbedder`，我们将用户的输入查询（例如，电影剧情）转换为嵌入。此嵌入将被传递到Neo4j向量索引，以便与存储的电影嵌入进行比较：'
- en: '[PRE16]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Run the vector search using the Haystack pipeline**: We set up the Haystack
    pipeline to manage the Haystack components:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用Haystack管道运行向量搜索**：我们设置Haystack管道来管理Haystack组件：'
- en: '`query_embedder` generates embeddings from the user query'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`query_embedder`从用户查询生成嵌入'
- en: '`retriever` runs the Cypher query on Neo4j using the query embedding and returns
    the most similar movies:'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retriever`在Neo4j上使用查询嵌入运行Cypher查询，并返回最相似的电影：'
- en: '[PRE17]'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Display the results**: Once the search is complete, we extract the results
    from the Neo4j graph and display the movie title, overview, and similarity score:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**显示结果**：一旦搜索完成，我们从Neo4j图中提取结果，并显示电影标题、概述和相似度分数：'
- en: '[PRE18]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Using Cypher and Haystack offers several benefits, including the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Cypher和Haystack提供了以下好处：
- en: '**Cypher’s flexibility**: By combining Cypher with Haystack, we can not only
    query the embeddings but also retrieve additional graph-based information such
    as cast, genres, and relationships between entities.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cypher的灵活性**：通过结合Cypher和Haystack，我们不仅可以查询嵌入，还可以检索基于图的其他信息，例如演员、类型和实体之间的关系。'
- en: '**Enriched results**: In addition to retrieving the most similar movies, you
    can easily extend the query to fetch related metadata (e.g., actors, genres, ratings)
    or refine the search with additional filtering conditions (e.g., release year,
    genre).'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**丰富结果**：除了检索最相似的电影外，您还可以轻松扩展查询以检索相关元数据（例如，演员、类型、评分）或使用额外的过滤条件（例如，上映年份、类型）来细化搜索。'
- en: '**Optimized for large graphs**: Neo4j’s vector index allows efficient querying
    of large datasets with complex relationships, while Haystack’s embedding models
    provide an accurate understanding of movie plots.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**针对大型图优化**：Neo4j的向量索引允许高效查询具有复杂关系的大型数据集，而Haystack的嵌入模型提供了对电影剧情的准确理解。'
- en: Let’s take a look at an example use case next.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一个示例用例。
- en: Example use case
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例用例
- en: 'Consider finding movies with plots such as *A hero must save the world from
    destruction*. By using the pipeline we just created, you can retrieve relevant
    results:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑寻找剧情类似于*一个英雄必须拯救世界免于毁灭*的电影。通过使用我们刚刚创建的管道，您可以检索相关结果：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This pipeline combines the best of both worlds—similarity search through vector
    embeddings and the rich data capabilities of graph querying with Cypher—allowing
    powerful, flexible searches over large datasets such as movies.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此管道结合了两者之长——通过向量嵌入进行相似度搜索和通过 Cypher 进行图查询的丰富数据功能——允许在大型数据集（如电影）上进行强大且灵活的搜索。
- en: '**Note**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'These are just the snippets of the code. The full version is available in the
    GitHub repository: [https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch5/vector_search.py](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch5/vector_search.py).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是代码片段。完整版本可在 GitHub 仓库中找到：[https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch5/vector_search.py](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch5/vector_search.py)。
- en: We have now connected Haystack to Neo4j and enabled advanced vector search functionality.
    With the vector index in place, Neo4j can now efficiently search for similar movie
    nodes based on their embeddings similarity. Haystack’s integration allows you
    to seamlessly perform these searches using `Neo4jDynamicDocumentRetriever`. This
    retriever performs a search for similar items in your graph by leveraging vector
    embeddings and Neo4j’s graph capabilities.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经将 Haystack 连接到 Neo4j 并启用了高级向量搜索功能。有了向量索引，Neo4j 现在可以高效地根据嵌入相似度搜索类似的电影节点。Haystack
    的集成允许您无缝地使用 `Neo4jDynamicDocumentRetriever` 执行这些搜索。此检索器通过利用向量嵌入和 Neo4j 的图功能在您的图中搜索类似项。
- en: In the next section, we will explore how to build a search-driven chatbot that
    leverages the power of Haystack and Neo4j to deliver rich, context-aware responses.
    Using Gradio, we will create an intuitive chatbot interface that can interact
    with users and perform advanced searches through natural language queries. This
    will bring together the strengths of LLMs, vector search, and Neo4j to create
    a user-friendly, AI-powered search experience.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何构建一个利用 Haystack 和 Neo4j 的强大功能来提供丰富、上下文感知响应的搜索驱动聊天机器人。使用 Gradio，我们将创建一个直观的聊天机器人界面，可以与用户交互并通过自然语言查询执行高级搜索。这将结合
    LLMs、向量搜索和 Neo4j 的优势，创建一个用户友好、AI 驱动的搜索体验。
- en: Building a search-driven chatbot with Gradio and Haystack
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Gradio 和 Haystack 构建 search-driven 聊天机器人
- en: In this section, we will integrate Gradio to build an interactive chatbot interface
    powered by Haystack and Neo4j. Gradio makes it easy to create a web-based interface
    for interacting with your chatbot. The chatbot will allow users to input queries,
    which will then trigger a vector-based search of movie embeddings stored in Neo4j.
    The chatbot will return detailed responses, including the movie titles, overviews,
    and similarity scores, providing an informative and user-friendly experience.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将集成 Gradio 来构建一个由 Haystack 和 Neo4j 驱动的交互式聊天机器人界面。Gradio 使得创建一个用于与聊天机器人交互的基于网页的界面变得简单。聊天机器人将允许用户输入查询，然后触发对存储在
    Neo4j 中的电影嵌入的基于向量的搜索。聊天机器人将返回详细的响应，包括电影标题、概述和相似度分数，提供信息丰富且用户友好的体验。
- en: Setting up a Gradio interface
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Gradio 界面
- en: 'If you have not installed Gradio yet, do so by running the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未安装 Gradio，请通过运行以下命令进行安装：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Note**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The script in this chapter works fine with Gradio v `5.23.1`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的脚本与 Gradio v `5.23.1` 兼容。
- en: 'Next, we will set up a basic Gradio interface that triggers our search pipeline
    and displays the results:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将设置一个基本的 Gradio 界面，该界面触发我们的搜索管道并显示结果：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This interface allows users to input text queries, and the chatbot will use
    the `perform_vector_search_cypher()` function to search for the most relevant
    movies.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此界面允许用户输入文本查询，聊天机器人将使用 `perform_vector_search_cypher()` 函数搜索最相关的电影。
- en: Integrating with Haystack and Neo4j
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 Haystack 和 Neo4j 集成
- en: To power the chatbot, we will connect it to Haystack’s embedding generation
    and Neo4j’s vector search capabilities. We will be using `OpenAITextEmbedder`
    to generate the embeddings for both the queries and the movie plots stored in
    Neo4j. The movie embeddings are stored in a vector index inside Neo4j, which we
    query for the most similar movies.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为聊天机器人提供动力，我们将将其连接到 Haystack 的嵌入生成和 Neo4j 的向量搜索功能。我们将使用 `OpenAITextEmbedder`
    为查询和存储在 Neo4j 中的电影情节生成嵌入。电影嵌入存储在 Neo4j 内部的向量索引中，我们将查询最相似的电影。
- en: 'This is how to integrate our chatbot with the previous Haystack setup:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何将我们的聊天机器人与之前的 Haystack 设置集成：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Connecting Gradio to the full pipeline
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Gradio 连接到完整管道
- en: Now, connect this Gradio chatbot with the Haystack and Neo4j pipeline you have
    already set up. The Gradio interface will call the `perform_vector_search_cypher()`
    function, which in turn utilizes `Neo4jDynamicDocumentRetriever` to search for
    similar movies based on the user’s query.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将这个 Gradio 聊天机器人连接到您已经设置的 Haystack 和 Neo4j 管道。Gradio 接口将调用 `perform_vector_search_cypher()`
    函数，该函数反过来利用 `Neo4jDynamicDocumentRetriever` 根据用户的查询搜索类似的电影。
- en: 'Update the `main()` function to initialize the chatbot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `main()` 函数以初始化聊天机器人：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Running the chatbot
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行聊天机器人
- en: 'To run the chatbot, simply execute your Python script. The Gradio interface
    will be launched in your browser, allowing you to interact with the chatbot in
    real time:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行聊天机器人，只需执行您的 Python 脚本。Gradio 接口将在您的浏览器中启动，让您能够实时与聊天机器人互动：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'A Gradio interface will launch in your browser, allowing you to interact with
    the chatbot in real time. You can enter queries such as this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中将会启动一个 Gradio 接口，让您能够实时与聊天机器人互动。您可以输入如下查询：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The chatbot will return movie plots that are similar to this query based on
    the vector search.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天机器人将根据向量搜索返回与该查询相似的剧情。
- en: '**Note**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'These are just the snippets of the code. The full version is available in the
    GitHub repository: [https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch5/search_chatbot.py](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch5/search_chatbot.py).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是代码片段。完整版本可在 GitHub 仓库中找到：[https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch5/search_chatbot.py](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/blob/main/ch5/search_chatbot.py)。
- en: As we come to the end of this section, we have built a fully functional search-driven
    chatbot using Gradio, Haystack, and Neo4j. The chatbot leverages the embeddings
    stored in Neo4j to perform advanced vector-based searches, returning contextually
    relevant results to the user in the form of retrieving meaningful movie titles
    and actors from Neo4j in response to user queries.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们接近本节的结尾时，我们已经使用 Gradio、Haystack 和 Neo4j 构建了一个功能齐全的搜索驱动聊天机器人。该聊天机器人利用存储在 Neo4j
    中的嵌入来执行高级基于向量的搜索，通过从 Neo4j 中检索有意义的电影标题和演员来以用户查询的形式向用户返回上下文相关的结果。
- en: However, this is just the beginning. In the next section, we will dive deeper
    into fine-tuning your Haystack integration and also explore advanced techniques
    such as optimizing search performance, adjusting retrieval models, and refining
    the chatbot’s responses to create an even more seamless and efficient search-driven
    experience.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这仅仅是开始。在下一节中，我们将更深入地探讨如何微调您的 Haystack 集成，并探索高级技术，例如优化搜索性能、调整检索模型以及改进聊天机器人的响应，以创建一个更加无缝和高效的搜索驱动体验。
- en: Fine-tuning your Haystack integration
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微调您的 Haystack 集成
- en: It is now time to explore how to fine-tune this integration for improved performance
    and user experience. While the current setup provides rich, contextually aware
    responses, there are several advanced techniques, you can implement to optimize
    the search process, improve retrieval accuracy, and make the chatbot’s interactions
    more seamless.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候探索如何微调此集成以提升性能和用户体验了。虽然当前的设置提供了丰富且上下文感知的响应，但您还可以实施一些高级技术来优化搜索过程、提高检索准确性，并使聊天机器人的交互更加流畅。
- en: In this section, we will focus on adjusting key components of Haystack, including
    experimenting with different embedding models, optimizing Neo4j queries for faster
    results, and improving how the chatbot displays its responses. These enhancements
    will help you scale your chatbot to handle more complex queries, improve response
    times, and deliver even more relevant search results.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将专注于调整 Haystack 的关键组件，包括尝试不同的嵌入模型、优化 Neo4j 查询以获得更快的速度，以及改进聊天机器人显示其响应的方式。这些改进将帮助您扩展聊天机器人以处理更复杂的查询，提高响应时间，并呈现更加相关的搜索结果。
- en: Experimenting with different embedding models
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试不同的嵌入模型
- en: Currently, we are using OpenAI’s `text-embedding-ada-002` model to generate
    embeddings. While this model has served as a reliable and performant choice across
    a wide range of tasks since its release, it’s worth noting that OpenAI has recently
    introduced new models—such as `text-embedding-3-small` and `text-embedding-3-large`—that
    offer significant improvements in both performance and cost-efficiency. For example,
    `text-embedding-3-small` achieves better results in multilingual and English-language
    tasks, while also being up to five times more cost-effective than `text-embedding-ada-002`.
    Although we have not switched models in this project for consistency, readers
    who are implementing similar pipelines may consider using `text-embedding-3-small`
    to improve efficiency without compromising performance—especially if embedding
    generation is a frequent or large-scale operation.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在使用 OpenAI 的 `text-embedding-ada-002` 模型来生成嵌入。虽然这个模型自发布以来一直作为各种任务的可靠和高效选择，但值得注意的是，OpenAI
    最近推出了新的模型——例如 `text-embedding-3-small` 和 `text-embedding-3-large`——它们在性能和成本效益方面都取得了显著改进。例如，`text-embedding-3-small`
    在多语言和英语任务中实现了更好的结果，同时比 `text-embedding-ada-002` 至少节省五倍的成本。尽管我们在这个项目中没有切换模型以保持一致性，但正在实施类似管道的读者可以考虑使用
    `text-embedding-3-small` 来提高效率，同时不牺牲性能——特别是如果嵌入生成是频繁或大规模操作的话。
- en: However, Haystack supports various other models, and you can experiment with
    different ones to see which provides the most accurate or relevant results for
    your specific use case. For instance, you could switch to a more sophisticated
    OpenAI model with higher dimensions or try another embedding service supported
    by Haystack.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Haystack 支持各种其他模型，并且你可以尝试不同的模型以查看哪个为你特定的用例提供了最准确或最相关的结果。例如，你可以切换到一个更复杂的 OpenAI
    模型，具有更高的维度，或者尝试 Haystack 支持的另一个嵌入服务。
- en: 'This is how you can easily switch to a different model:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你可以轻松切换到不同模型的方法：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can also explore other models from OpenAI or even integrate different embedding
    services to see which performs best for your movie chatbot.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以探索 OpenAI 的其他模型，甚至集成不同的嵌入服务，以查看哪个对你的电影聊天机器人表现最佳。
- en: Optimizing Neo4j for faster queries
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化 Neo4j 以实现更快的查询
- en: While Neo4j is already efficient at handling graph-based queries, there are
    several optimizations you can apply, especially for large datasets. You can index
    additional properties to improve query performance.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Neo4j 已经在处理基于图查询方面非常高效，但你还可以应用一些优化，特别是对于大型数据集。你可以索引额外的属性以提高查询性能。
- en: Indexing additional properties
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引额外属性
- en: 'In addition to the vector index on the embedding property, you can index other
    frequently queried properties, such as `title` or `tmdbId`, to speed up retrieval.
    This will ensure that whenever you filter or retrieve movies based on these properties,
    the search is quicker and more efficient:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 除了嵌入属性上的向量索引之外，你还可以索引其他频繁查询的属性，例如 `title` 或 `tmdbId`，以加快检索速度。这将确保每次你根据这些属性过滤或检索电影时，搜索都更快、更高效：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: By indexing these properties, you can optimize lookups when the search is not
    solely based on embeddings, such as when filtering by title or retrieving a specific
    movie.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过索引这些属性，你可以在搜索不仅基于嵌入时优化查找，例如在按标题过滤或检索特定电影时。
- en: To continuously improve the chatbot’s search experience, you can log user queries
    and analyze them over time. Let’s talk about this in detail.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了持续改进聊天机器人的搜索体验，你可以记录用户查询并随着时间的推移进行分析。让我们详细谈谈这一点。
- en: Logging and analyzing queries
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录和分析查询
- en: Logging helps you track the most common search patterns. Based on logs of user
    queries and their analysis, you can adjust the indexing strategy, optimize the
    retriever, or tweak the embedding model for better accuracy.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 记录可以帮助你跟踪最常见的搜索模式。基于用户查询的日志及其分析，你可以调整索引策略，优化检索器，或调整嵌入模型以获得更好的准确性。
- en: 'This is how to implement a simple logging mechanism:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是实现简单日志记录机制的方法：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Every time a user inputs a query, it will be logged for future analysis. You
    can then analyze these logs to make informed adjustments to the system, ensuring
    that it becomes more responsive and accurate over time.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户输入一个查询时，它将被记录以供将来分析。然后你可以分析这些日志，对系统进行有根据的调整，确保它随着时间的推移变得更加响应和准确。
- en: These techniques can help you significantly enhance the performance, accuracy,
    and user experience of your search-driven chatbot. Whether it is experimenting
    with different embedding models, optimizing Neo4j queries, or improving how the
    results are formatted, each adjustment brings you closer to a seamless and powerful
    user interaction.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术可以帮助您显著提升搜索驱动的聊天机器人的性能、准确性和用户体验。无论是尝试不同的嵌入模型、优化Neo4j查询，还是改进结果格式，每一次调整都让您更接近无缝且强大的用户交互。
- en: These advanced techniques allow your chatbot to scale effectively, handle more
    complex queries, and return even more relevant and engaging results.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这些高级技术使您的聊天机器人能够有效扩展，处理更复杂的查询，并返回更加相关和吸引人的结果。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we successfully built a fully functional search-driven chatbot
    by integrating Gradio, Haystack, and Neo4j. We began by enriching our Neo4j graph
    with movie embeddings generated by OpenAI’s models, enabling advanced vector-based
    search functionality. From there, we connected Haystack to Neo4j, allowing us
    to perform similarity searches on the embeddings stored in the graph. Finally,
    we wrapped it all up by creating a user-friendly chatbot interface with Gradio,
    which dynamically retrieves movie details such as titles and actors based on user
    queries.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过整合Gradio、Haystack和Neo4j成功构建了一个功能齐全的搜索驱动的聊天机器人。我们首先通过OpenAI的模型生成的电影嵌入丰富了我们的Neo4j图，从而实现了高级的基于向量的搜索功能。从那里，我们将Haystack连接到Neo4j，使我们能够在图中存储的嵌入上执行相似度搜索。最后，我们通过创建一个用户友好的聊天机器人界面（使用Gradio），根据用户查询动态检索电影详情，如标题和演员，来完成整个构建过程。
- en: In the next chapter we will focus on advanced search capabilities and search
    optimization with Haystack. We will also discuss query optimization for large
    graphs.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将重点关注Haystack的高级搜索能力和搜索优化。我们还将讨论大型图的查询优化。
