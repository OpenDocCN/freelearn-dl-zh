- en: Anatomy of a Modern AI Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代 AI 应用的构成
- en: In this chapter, we will discuss the importance of good architecture design
    for **artificial intelligence** (**AI**) applications. First, we will cover the
    architecture design principles and then create a reference architecture for our
    hands-on projects. In this chapter, we will recreate the Amazon Rekognition demo
    with our reference architecture and the components that make it up. We will learn
    how to use several AWS tools and services to build our hands-on project in the
    serverless style and then deploy it to the AWS cloud.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将讨论**人工智能**（**AI**）应用架构设计的重要性。首先，我们将介绍架构设计原则，然后为我们的动手项目创建一个参考架构。在本章中，我们将使用我们的参考架构及其组成部分重新创建
    Amazon Rekognition 演示。我们将学习如何使用多个 AWS 工具和服务，以无服务器的方式构建我们的动手项目，然后将其部署到 AWS 云中。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the success factors of artificial intelligence applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解人工智能应用的成功因素
- en: Understanding the architecture design principles for AI applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 AI 应用的架构设计原则
- en: Understanding the architecture of modern AI applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解现代 AI 应用的架构
- en: Creating custom AI capabilities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建定制的 AI 能力
- en: Developing an AI application locally using AWS Chalice
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AWS Chalice 在本地开发 AI 应用
- en: Developing a demo application web user interface
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发演示应用的网页用户界面
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This book's GitHub repository, which contains the source code for this chapter,
    can be found at [https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-on-Amazon-Web-Services](https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-on-Amazon-Web-Services).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的 GitHub 仓库，包含本章节的源代码，可以在 [https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-on-Amazon-Web-Services](https://github.com/PacktPublishing/Hands-On-Artificial-Intelligence-on-Amazon-Web-Services)
    找到。
- en: Understanding the success factors of artificial intelligence applications
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解人工智能应用的成功因素
- en: 'Let''s talk about what makes an AI application successful, and really, what
    makes any software application successful. There are two main factors that determine
    application success:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来讨论一下是什么使得 AI 应用成功，实际上，任何软件应用成功的关键也类似。有两个主要因素决定应用的成功：
- en: The first factor is whether the application is a solution that actually solves
    a particular problem.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个因素是应用是否能够真正解决某个特定问题。
- en: The second factor is how well the application is implemented to deliver the
    solution to the problem.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个因素是应用实现的质量，即如何有效地将解决方案交付给问题。
- en: Basically, we are talking about *what to build* and *how to build it*. Both
    of these factors are difficult to get right and for the majority of cases, both
    of them are required to make an application successful.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们讨论的是*构建什么*和*如何构建*这两个问题。要做到这两点都非常困难，在大多数情况下，成功的应用都需要这两个因素。
- en: The fact is, deciding on precisely *what to build* is the more important factor
    of the two. If we get this factor wrong, we will have a flawed product that will
    not deliver a viable solution to the problem. It will not matter how elegant the
    architecture is or how clean the code base is—a flawed product will be unsuccessful.
    Deciding on precisely what to build is rarely a one-shot deal, though. It is a
    fallacy to believe that the perfect solution can be designed in advance. In many
    cases, your target customers don't even know what they want or need. Successful
    solutions require extensive iterations of product development, customer feedback,
    and a tremendous amount of effort to refine the product requirements.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，决定*构建什么*才是两者中更为重要的因素。如果我们在这一点上做错了，最终产品将是有缺陷的，无法提供问题的可行解决方案。不管架构有多么优雅，代码基础有多干净——一个有缺陷的产品最终都会失败。然而，决定*构建什么*往往不是一次性就能搞定的。这种信念是错误的——认为完美的解决方案可以提前设计出来。在许多情况下，你的目标客户甚至不知道他们需要什么或想要什么。成功的解决方案需要经过反复的产品开发迭代、客户反馈，并且需要大量的努力来完善产品需求。
- en: This need to iterate and experiment with the solution makes *how to build it*
    an important factor for finding out *what to build*. It doesn't take a tremendous
    amount of skill to get an application to work. You can always get the first iteration,
    the first version, or the first pivot, to work with sheer determination and brute
    force. It might not be elegant, but the application works. However, when the first
    iteration is not the right solution to the problem, then a more elegant architecture
    and a cleaner code base will enable faster iterations and pivots, thus giving
    you more opportunities to figure out *what to build*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种需要反复迭代和实验的特性使得*如何构建*成为找到*构建什么*的一个重要因素。让一个应用程序工作并不需要大量技能。你总是可以通过坚定的决心和蛮力实现第一次迭代、第一次版本或第一次转型，应用程序就能工作。它可能不优雅，但至少能运行。然而，当第一次迭代不是问题的正确解决方案时，一个更优雅的架构和更干净的代码库将支持更快的迭代和转型，从而为你提供更多机会去找出*构建什么*。
- en: Understanding the architecture design principles for AI applications
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解AI应用程序的架构设计原则
- en: 'Building elegant applications is not trivial, but building elegant AI applications
    can be even harder. As AI practitioners in a rapidly changing technology landscape,
    it''s important to understand good architecture design principles and to have
    a passion for software craftsmanship since it takes relentless discipline to build
    and maintain applications that can adapt to the fast-evolving AI technologies.
    Good architecture design can easily adapt to changes. However, it is impossible
    to predict all future changes. Therefore, we need to rely on a set of well-accepted
    design principles to guide us on good application architecture. Let''s go over
    them now:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 构建优雅的应用程序并非易事，但构建优雅的AI应用程序可能更加困难。作为在快速变化的技术环境中工作的AI从业者，理解良好的架构设计原则并且对软件工艺充满热情是至关重要的，因为构建和维护能够适应快速发展的AI技术的应用程序需要不断的纪律性。良好的架构设计能够轻松适应变化。然而，不可能预测所有未来的变化。因此，我们需要依赖一套广泛接受的设计原则来指导我们构建良好的应用程序架构。现在我们一起来看看这些原则：
- en: A well-architected application should be built on top of small services with
    focused business capabilities. By small, we don't necessarily mean a small amount
    of code. Instead, small services should follow the single responsibility principle;
    that is, to do one or very few things well.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个设计良好的应用程序应该建立在具有专注业务能力的小型服务之上。这里的“小型”并不一定意味着代码量少，而是小型服务应该遵循单一职责原则；即做好一件或非常少的事情。
- en: These small services are much easier to implement, test, and deploy. They are
    also easier to reuse and to compose more business capabilities.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些小型服务更容易实现、测试和部署。它们也更容易复用，并且能够组合出更多的业务能力。
- en: A good application architecture should have well-defined boundaries to enforce
    separation of concerns.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个好的应用程序架构应该有明确的边界，以强制执行关注点分离。
- en: The services and components of the application should maintain this separation
    by hiding internal implementation details from the others.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的服务和组件应该通过隐藏内部实现细节来保持这种分离。
- en: This separation allows services and components to be replaceable with minimal
    impact on the rest of the application, thus supporting easier evolution and improvement
    of the solution.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种分离允许服务和组件在对应用程序其余部分的影响最小的情况下被替换，从而支持解决方案的更容易演化和改进。
- en: If you are new to software architecture design, the differences between good
    and bad designs might appear subtle. It will take you a lot of experience to acquire
    the knowledge and skills you need to truly appreciate good design. In this book,
    we will provide you with examples of elegant designs that are good starting points
    for AI applications.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是软件架构设计的新手，好的设计和差的设计之间的区别可能看起来微妙。你需要大量的经验才能获得真正理解好设计所需的知识和技能。在本书中，我们将为你提供一些优雅设计的例子，它们是AI应用程序的良好起点。
- en: Understanding the architecture of modern AI applications
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解现代AI应用程序的架构
- en: Defining a clean architecture design is a necessary step for developing successful
    AI applications, and we recommend four basic components that make it up.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 定义清晰的架构设计是开发成功AI应用程序的必要步骤，我们推荐四个基本组成部分来构建它。
- en: 'These four components are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个组成部分如下：
- en: '**User interfaces**: These are the user-facing components that deliver the
    business capabilities of your application to the end users:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户界面**：这是面向用户的组件，向最终用户提供应用程序的业务能力：'
- en: They are also known as frontends. Examples of user interfaces include websites,
    mobile apps, wearables, and voice assistant interfaces.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们也被称为前端。用户界面的例子包括网站、移动应用、可穿戴设备和语音助手界面。
- en: The same application can deliver different tailored user experiences by choosing
    different device form factors, interaction modalities, and user interfaces.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的应用程序可以通过选择不同的设备形态、交互方式和用户界面，提供不同的定制化用户体验。
- en: How you deliver intelligent capabilities on a web page is going to be very different
    than how you would do so on wearable devices.
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在网页上提供智能能力，与在可穿戴设备上提供智能能力的方式会有很大的不同。
- en: As an AI practitioner, an important skill is designing the user experience to
    deliver your intelligent capabilities to the users. Getting this part right is
    one of the most important factors for the success of your AI applications.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名 AI 从业者，一个重要的技能是设计用户体验，将你的智能能力传递给用户。做好这一部分是你的 AI 应用成功的最重要因素之一。
- en: '**Orchestration layer**: These are the public APIs that will be called by your
    user interfaces to deliver the business capabilities:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协调层**：这些是公共 API，将被你的用户界面调用以提供业务能力：'
- en: Usually, these APIs are the entry points to the backend.
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，这些 API 是通向后台的入口点。
- en: The public APIs should be tailored to the specific interfaces and modalities
    in order to deliver the best experiences to the users.
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共 API 应根据特定的界面和交互方式进行定制，以便为用户提供最佳体验。
- en: The public APIs will call upon one or more small services (through private APIs)
    to deliver business capabilities.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共 API 将通过私有 API 调用一个或多个小型服务，以提供业务能力。
- en: They play an orchestration role to combine several lower-level capabilities
    to compose higher-level capabilities that are needed by the user interfaces. There
    are other names for these public APIs that you might be familiar with; that is,
    **Backends for Frontends** (or **BFFs**) and experience APIs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在组合多个底层能力以形成用户界面所需的更高层次能力中起到了协调作用。这些公共 API 还有其他名称，你可能听说过；比如，**前端的后端**（或**BFFs**）和体验
    API。
- en: '**Private APIs**: The private APIs define the interaction contracts that are
    used by the public APIs to access lower-level services:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有 API**：私有 API 定义了交互契约，公共 API 使用这些契约来访问更底层的服务：'
- en: The private APIs wrap the service implementations, which provide certain capabilities,
    in order to hide their details.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有 API 封装了服务实现，这些实现提供特定的能力，以隐藏其详细信息。
- en: These APIs play a key role in the composability and the replaceability qualities
    of software systems.
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些 API 在软件系统的可组合性和可替换性特性中发挥着关键作用。
- en: The private APIs are the interfaces for the common capabilities that can be
    composed and reused by multiple applications.
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有 API 是可以被多个应用组合和重用的通用能力接口。
- en: These private APIs follow the service-oriented design pattern. You might be
    familiar with this pattern from similar architectures, such as microservices architecture
    and **service-oriented architecture** (or **SOA**).
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些私有 API 遵循面向服务设计模式。你可能对这种模式比较熟悉，比如微服务架构和**面向服务架构**（或**SOA**）。
- en: They should be designed with the single responsibility principle in mind.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们应该以单一职责原则为设计基础。
- en: A set of well-designed private APIs is a valuable asset and competitive advantage
    for any organization. The organization will be able to rapidly innovate, improve,
    and deploy solutions to the market.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一组设计良好的私有 API 对任何组织来说都是宝贵的资产和竞争优势。组织将能够迅速创新、改进并将解决方案推向市场。
- en: '**Vendor/custom services:** These are the implementations of the business capabilities,
    whether they are AI or otherwise:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**供应商/自定义服务**：这些是业务能力的实现，无论是 AI 还是其他：'
- en: These implementations can be provided by vendors as web services or hosted within
    your infrastructure. They can also be custom solutions that have been built by
    your organization.
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些实现可以由供应商作为 Web 服务提供，或者托管在你的基础设施中。它们也可以是你所在组织构建的定制解决方案。
- en: These services have their own APIs, such as RESTful endpoints or SDKs that the
    private APIs will call upon to wrap the implementations.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些服务有自己的 API，如 RESTful 端点或 SDK，私有 API 将通过它们来封装这些实现。
- en: In this book, we will be leveraging Amazon as the vendor to provide many of
    the web services via the *boto3* SDK. Later in this book, we will also teach you
    how to build custom AI capabilities using AWS' Machine Learning services and deploy
    them as ML models with RESTful endpoints.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将利用 Amazon 作为供应商，通过 *boto3* SDK 提供许多 Web 服务。稍后在本书中，我们还将教你如何使用 AWS 的机器学习服务构建自定义的
    AI 能力，并将其作为 ML 模型通过 RESTful 接口进行部署。
- en: 'The following diagram illustrates the organization of these basic architecture
    components and layers:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了这些基本架构组件和层次的组织结构：
- en: '![](img/fb81a005-0eec-4874-9c04-307294527e17.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb81a005-0eec-4874-9c04-307294527e17.png)'
- en: 'The key to a clean architecture is to keep these components separated through
    well-defined interaction contracts between each layer:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 干净架构的关键是通过每一层之间定义明确的交互契约，保持这些组件的分离：
- en: The user interfaces should only know about the public APIs in the orchestration
    layer.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面应该只知道编排层中的公共 API。
- en: The public APIs should only know about the private APIs that they depend on.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共 API 应该只知道它们依赖的私有 API。
- en: The private APIs should only know about the service implementations they wrap
    around.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有 API 应该只知道它们所封装的服务实现。
- en: This is the principle of information hiding, which is applied at the architecture
    level.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是信息隐藏的原则，它在架构层面得到应用。
- en: There are many benefits to enforcing these logical boundaries at the architecture
    level, for example, if we would like to switch to a better vendor service. All
    we need to do is create a new set of private APIs to wrap around the new vendor
    service while keeping the same private API contracts to the public APIs (and then
    retire the old private APIs). This way, the public APIs, as well as the user interfaces,
    won't be affected by this change. This limits the impact of the change to a specific
    part of the application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在架构层面强制执行这些逻辑边界有许多好处，例如，如果我们想切换到更好的供应商服务，我们只需创建一组新的私有 API 来封装新的供应商服务，同时保持与公共
    API 相同的私有 API 契约（然后淘汰旧的私有 API）。这样，公共 API 和用户界面就不会受到这一变化的影响。这将把变化的影响限制在应用程序的特定部分。
- en: Most of the applications we use today are composed of a frontend and a backend.
    The frontend usually runs in a browser or on a mobile device, while the backend
    runs on server infrastructure in the cloud or in a private data center. The architecture
    that's recommended here is a good starting point for these types of applications.
    There are more specialized applications, such as embedded systems, that might
    require a different architecture design. We will not dive into the architecture
    needs of these more specialized applications in this book.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们今天使用的大多数应用程序由前端和后端组成。前端通常运行在浏览器或移动设备上，而后端则运行在云端或私有数据中心的服务器基础设施上。这里推荐的架构是这些类型应用程序的良好起点。还有一些更为专业化的应用程序，如嵌入式系统，可能需要不同的架构设计。我们在本书中不会深入讨论这些更专业化应用程序的架构需求。
- en: Creation of custom AI capabilities
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义的 AI 能力
- en: 'As AI practitioners, there are two distinct development life cycles we can
    be involved in:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 AI 从业者，我们可以参与的有两个不同的开发生命周期：
- en: The AI application development life cycle
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AI 应用开发生命周期
- en: The AI capability development life cycle
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AI 能力开发生命周期
- en: Usually, especially in larger organizations where roles are more specialized,
    an AI practitioner only participates in one of these life cycles. Even if you
    do not participate in one of these life cycles, getting a good understanding of
    both is useful for all AI practitioners.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，特别是在角色更加专业化的大型组织中，AI 从业者仅参与其中一个生命周期。即使你不参与其中一个生命周期，了解两个生命周期的基本内容对所有 AI 从业者都是有益的。
- en: '**The AI application development life cycle** involves iterating the solution,
    designing the user experience, defining the application architecture, and integrating
    the various business capabilities. This is similar to the traditional software
    development life cycle, but with the intent of embedding intelligence into the
    solutions.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**AI 应用开发生命周期**涉及解决方案的迭代、用户体验的设计、应用架构的定义，以及各种业务能力的集成。这类似于传统的软件开发生命周期，但目的是将智能嵌入到解决方案中。'
- en: '**The AI capability development life cycle** deals with developing intelligent
    capabilities using data and machine learning techniques. The data products that
    are created during the AI capability''s development life cycle can then be integrated
    into the applications as AI capabilities or AI services. In other words, the AI
    capability development life cycle produces custom AI capabilities that the AI
    application development life cycle consumes.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**AI能力开发生命周期**涉及使用数据和机器学习技术开发智能能力。在AI能力开发生命周期中创建的数据产品可以集成到应用程序中作为AI能力或AI服务。换句话说，AI能力开发生命周期产生了定制的AI能力，而AI应用开发生命周期则消耗这些能力。'
- en: 'Different sets of technical and problem-solving skills are needed by these
    two life cycles. The following diagram provides an overview of the steps that
    are required to create AI capabilities:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个生命周期需要不同的技术和问题解决技能。以下图表提供了创建AI能力所需步骤的概述：
- en: '![](img/897a3bf6-815d-4db1-80cf-baf25c9f4427.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/897a3bf6-815d-4db1-80cf-baf25c9f4427.png)'
- en: AI capabilities are at the heart of AI applications. As we mentioned in [Chapter
    1](606f673e-f72c-43ed-9a1e-fc06796b1303.xhtml), *Introduction to Artificial Intelligence
    and Amazon Web Services*, data is the new intellectual property. Any successful
    organization should have a well-defined data strategy to collect, store, process,
    and disseminate data. Raw and processed datasets should be safely placed and made
    available in data storage systems such as databases, data lakes, and data warehouses.
    From these data stores, data scientists can access data to support the analysis
    that's specific to a business problem or question they are working on. Some of
    the analysis results will generate useful business insights with the potential
    to perform predictive analysis. With these insights, data scientists can then
    choose from various machine learning algorithms to train machine learning models
    to perform automated predictions and decision-making, including classifications
    and regression analysis.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: AI能力是AI应用的核心。正如我们在[第一章](606f673e-f72c-43ed-9a1e-fc06796b1303.xhtml)中提到的，*人工智能与亚马逊Web服务简介*，数据是新的知识产权。任何成功的组织都应该拥有明确的数据战略，用于收集、存储、处理和传播数据。原始和处理过的数据集应该安全地存放并在数据存储系统中提供，如数据库、数据湖和数据仓库。从这些数据存储中，数据科学家可以访问数据以支持他们正在处理的特定业务问题或问题的分析。部分分析结果将产生有价值的商业洞察，具有执行预测分析的潜力。通过这些洞察，数据科学家可以选择各种机器学习算法来训练机器学习模型，以执行自动化预测和决策，包括分类和回归分析。
- en: Once trained and tuned, machine learning models can then be deployed as AI services
    with interfaces for applications to access their intelligence. For example, Amazon
    SageMaker lets us train machine learning models and then deploy them as web services
    with RESTful endpoints. Finally, as a part of your data strategy, the feedback
    data from deployed AI services should be collected to improve future iterations
    of the AI services.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦经过训练和调整，机器学习模型就可以作为AI服务进行部署，并提供接口供应用程序访问其智能。例如，Amazon SageMaker允许我们训练机器学习模型，并将其作为具有RESTful端点的Web服务进行部署。最后，作为数据战略的一部分，应该收集从已部署AI服务中获取的反馈数据，以改进未来版本的AI服务。
- en: As we mentioned in the previous chapter, we highly recommend that you first
    leverage existing AI services from vendors such as AWS as much as possible for
    your intelligent-enabled applications. Each one of the AWS AI capabilities has
    gone through numerous iterations of the AI capability development life cycle with
    a massive amount of data that most organizations do not have access to. It only
    makes sense to build your own AI capabilities if you have a true data intellectual
    property or a need that's not addressed by the vendor solutions. It takes a tremendous
    amount of effort, skill, and time to train production-ready machine learning models.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一章中提到的，我们强烈建议您尽可能多地利用AWS等供应商现有的AI服务来为您的智能应用提供支持。每个AWS AI能力都经历了多个AI能力开发生命周期的迭代，并且使用了大量大多数组织无法访问的数据。如果您拥有真正的数据知识产权或需求尚未被供应商解决，构建您自己的AI能力才是有意义的。训练一个可以投入生产的机器学习模型需要大量的努力、技能和时间。
- en: The second part of this book will focus on the AI application development life
    cycle, while the third part of this book will focus on the AI capability development
    life cycle.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的第二部分将重点讨论AI应用开发生命周期，而第三部分将重点讨论AI能力开发生命周期。
- en: Working with a hands-on AI application architecture
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与实践中的AI应用架构合作
- en: In the previous section, we recommended an architecture design for modern AI
    applications. In this section, we will define the specific technologies and tech
    stacks we will use in this book to implement the recommended architecture design.
    We evaluated several factors when deciding on the best choices for this book,
    including simplicity, learning curve, industry trends, and others. Keep in mind
    that there can be many valid technology choices and implementations for the recommended
    architecture design.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们推荐了现代AI应用程序的架构设计。在本节中，我们将定义用于实现推荐架构设计的具体技术和技术栈。在决定本书最佳选择时，我们评估了多个因素，包括简易性、学习曲线、行业趋势等。请记住，推荐架构设计可能有许多有效的技术选择和实施方法。
- en: 'For the hands-on AI application development projects, we will use the following
    architecture and technology stack:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于动手实施的AI应用开发项目，我们将采用以下架构和技术栈：
- en: '![](img/2048621a-c064-47d8-9366-ce21c016120b.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2048621a-c064-47d8-9366-ce21c016120b.png)'
- en: 'As the preceding diagram illustrates, the AI application projects will be made
    up of the four basic architectural components we discussed earlier:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的图表所示，AI应用项目将由我们前面讨论过的四个基本架构组件组成：
- en: '**User interfaces**: We will be using web pages as user interfaces. We will
    develop relatively simple user interfaces using HTML, CSS, and JavaScript. HTML
    and CSS will display the UI components and handle user inputs. JavaScript will
    communicate with the server backend via the public APIs in the orchestration layer.
    The project web pages will be deployed on AWS S3 as a static website without the
    need for traditional web servers. This is known as serverless because we don''t
    need to manage and maintain any server infrastructure.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户界面**：我们将使用网页作为用户界面。我们将使用HTML、CSS和JavaScript开发相对简单的用户界面。HTML和CSS将显示UI组件并处理用户输入。JavaScript将通过编排层的公共API与服务器后端进行通信。项目网页将部署在AWS
    S3上作为静态网站，无需传统的Web服务器。这被称为无服务器，因为我们不需要管理和维护任何服务器基础设施。'
- en: We are using plain HTML and JavaScript to limit the scope of this book. You
    should consider single-page web application frameworks such as Angular, React,
    or Vue for your web user interfaces after finishing the hands-on projects in this
    book.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用普通的HTML和JavaScript来限制本书的范围。完成本书中的实际项目后，您应考虑使用Angular、React或Vue等单页Web应用程序框架来开发您的Web用户界面。
- en: Also, you are not limited to web applications as the only choice for AI applications.
    Other user interfaces and modalities, such as mobile or voice assistant devices,
    can sometimes provide a better user experience. We recommend that you think about
    how the application design should be changed in order to support these other user
    interfaces and modalities. These thought experiments will help you build the design
    muscles for AI practitioners.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，AI应用程序并不仅限于Web应用作为唯一选择。其他用户界面和模式，如移动设备或语音助手设备，有时可以提供更好的用户体验。我们建议您考虑如何修改应用设计以支持这些其他用户界面和模式。这些思想实验将帮助您为AI从业者构建设计能力。
- en: '**Orchestration layer**: We will be using AWS Chalice, a Python serverless
    microframework for AWS. Chalice allows us to quickly develop and test Python applications
    in its local development environment, and then easily deploy the Python applications
    to Amazon API Gateway and AWS Lambda as highly available and scalable serverless
    backends. Amazon API Gateway is a fully managed service that will host our public
    APIs as RESTful endpoints. The API Gateway will forward the RESTful requests that
    were issued to our public APIs to AWS Lambda functions where our orchestration
    logic will be deployed to. AWS Lambda is a serverless technology that lets us
    run code without provisioning or manage servers. When a Lambda function is invoked,
    for instance, from the API Gateway, the code is automatically triggered and run
    on the AWS infrastructure. You only pay for the computing resources that are consumed.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编排层**：我们将使用AWS Chalice，这是一个用于AWS的Python无服务器微框架。Chalice允许我们在其本地开发环境中快速开发和测试Python应用程序，然后轻松地将Python应用程序部署到Amazon
    API Gateway和AWS Lambda作为高可用性和可扩展性的无服务器后端。Amazon API Gateway是一个完全托管的服务，将托管我们的公共API作为RESTful端点。API
    Gateway将向AWS Lambda函数转发发往我们的公共API的RESTful请求，在那里我们的编排逻辑将被部署。AWS Lambda是一种无服务器技术，允许我们在不预配或管理服务器的情况下运行代码。例如，当从API
    Gateway调用Lambda函数时，代码将自动触发并在AWS基础设施上运行。您只需支付消耗的计算资源。'
- en: '**Private APIs**: We will be packaging the private APIs as Python libraries
    within the Chalice framework. Chalice allows us to write code in a modular way
    by structuring some services as libraries in the `Chalicelib` directory. In our
    hands-on projects, the private APIs are plain old Python classes with well-defined
    method signatures to provide access to the service implementations. In our projects,
    the boundary between the public and private APIs is logical rather than physical;
    therefore, attention must be paid to ensure the cleanliness of the architecture
    layers.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有API**：我们将把私有API打包为Chalice框架中的Python库。Chalice允许我们通过将一些服务结构化为`Chalicelib`目录中的库，以模块化的方式编写代码。在我们的实际项目中，私有API是简单的Python类，具有明确定义的方法签名，以提供对服务实现的访问。在我们的项目中，公共API与私有API之间的边界是逻辑上的，而非物理上的；因此，必须注意确保架构层次的清晰性。'
- en: We will be reusing some of the private APIs in multiple projects. Our mechanism
    of reuse is similar to shared libraries. In larger organizations, the private
    APIs are usually deployed as RESTful endpoints so that different applications
    can easily share them.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在多个项目中重用一些私有API。我们的重用机制类似于共享库。在较大的组织中，私有API通常作为RESTful端点进行部署，以便不同的应用程序可以轻松共享它们。
- en: '**Vendor services**: We will be leveraging AWS for various capabilities. For
    example, we need to develop these intelligent-enabled applications, including
    AI capabilities and more. The private APIs will access the AWS services in the
    cloud via the *boto3* SDK. Clean design requires *boto3* and AWS implementation
    details to be completely wrapped and hidden by the private APIs; the public APIs
    should not know which vendor services or custom solutions are used by the private
    APIs to provide these capabilities.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**供应商服务**：我们将利用AWS提供的各种能力。例如，我们需要开发这些智能应用，包括AI能力等。私有API将通过*boto3* SDK访问云中的AWS服务。清晰的设计要求私有API将*boto3*和AWS实现细节完全封装并隐藏；公共API不应知道私有API使用了哪些供应商服务或自定义解决方案来提供这些能力。'
- en: Object detector architecture
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象检测器架构
- en: We will be recreating the *Amazon Rekognition* demo with our own web frontend
    and Python backend. First, let's understand the architecture of the Object Detector
    application we are about to develop.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用我们自己的网页前端和Python后端重新创建*Amazon Rekognition*演示。首先，让我们理解一下我们即将开发的对象检测器应用程序的架构。
- en: 'Using the reference architecture design and the technology stack we discussed
    previously, here is the architecture for the Object Detector application:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前讨论的参考架构设计和技术栈，以下是对象检测器应用程序的架构：
- en: '![](img/e5a349ff-420e-4d9a-b779-3d33dd3aadb6.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5a349ff-420e-4d9a-b779-3d33dd3aadb6.png)'
- en: 'The user will interact with the Object Detector through a web user interface:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将通过网页用户界面与对象检测器进行交互：
- en: We will provide a web user interface for users so that they can see the Object
    Detection demo.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将提供一个网页用户界面供用户使用，以便他们查看对象检测演示。
- en: 'The web user interface will interact with the orchestration layer containing
    just one RESTful endpoint: the Demo Object Detection endpoint.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网页用户界面将与包含唯一RESTful端点的协调层进行交互：Demo对象检测端点。
- en: The endpoint interacts with both the Storage Service and the Recognition Service
    to perform the Object Detection demo.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该端点与存储服务和识别服务进行交互，以执行对象检测演示。
- en: The Storage Service and the Recognition Service calls the Amazon S3 and Amazon
    Rekognition services using the *Boto3* SDK, respectively.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储服务和识别服务分别通过*Boto3* SDK调用Amazon S3和Amazon Rekognition服务。
- en: Component interactions of the Object Detector
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象检测器的组件交互
- en: 'Let''s understand the interactions between the various components of the Object
    Detector application:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解一下对象检测器应用程序中各个组件之间的交互：
- en: '![](img/5055dc1a-60b4-46cb-844c-a2297ee05f35.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5055dc1a-60b4-46cb-844c-a2297ee05f35.png)'
- en: 'From the user''s perspective, the application loads a random image and displays
    the objects (or labels) that have been detected within that image. The demo workflow
    is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的角度看，应用程序加载一张随机图片，并显示已检测到的物体（或标签）。演示工作流如下：
- en: The object detector application's web interface calls the Demo Object Detection
    endpoint to start the demo.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象检测器应用程序的网页界面调用Demo对象检测端点以启动演示。
- en: The endpoint calls the Storage Service to get a list of files that are stored
    in a specified S3 bucket.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该端点调用存储服务以获取存储在指定S3存储桶中的文件列表。
- en: After receiving the list of files, the endpoint randomly selects an image file
    for the demo.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收到文件列表后，端点会随机选择一个图像文件进行演示。
- en: The endpoint then calls the Recognition Service to perform object detection
    on the selected image file.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，端点调用识别服务对选定的图像文件执行对象检测。
- en: After receiving the object labels, the endpoint packages the results in JSON
    format.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收对象标签后，端点将结果打包成JSON格式。
- en: Finally, the web interface displays the randomly selected image and its detection
    results.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终，网页界面会显示随机选择的图像及其检测结果。
- en: Creating the base project structure
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基础项目结构
- en: 'Next, let''s create the hands-on project structure. Follow these steps to create
    the architecture and technology stack:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建实际操作的项目结构。按照以下步骤创建架构和技术栈：
- en: 'In Terminal, we will create the root project directory and enter it with the
    following commands:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，我们将创建根项目目录并使用以下命令进入该目录：
- en: '[PRE0]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will create placeholders for the web frontend by creating a directory named
    `Website`. Within this directory, we will have two files, `index.html` and `scripts.js`,
    as follows:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过创建一个名为`Website`的目录来为Web前端创建占位符。在此目录中，我们将有两个文件，`index.html`和`scripts.js`，如下所示：
- en: '[PRE1]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will create a Python 3 virtual environment with `pipenv` in the project''s
    root directory. Our Python portion of the project needs two packages, `boto3`
    and `chalice`. We can install them with the following commands:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在项目的根目录中使用`pipenv`创建一个Python 3虚拟环境。我们项目的Python部分需要两个包，`boto3`和`chalice`。我们可以使用以下命令安装它们：
- en: '[PRE2]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Remember that the Python packages that were installed via `pipenv` are only
    available if we activate the virtual environment. One way to do this is with the
    following command:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请记住，通过`pipenv`安装的Python包仅在我们激活虚拟环境时才可用。一种激活方法是使用以下命令：
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, while still in the virtual environment, we will create the orchestration
    layer as an AWS Chalice project named `Capabilities` with the following commands:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在仍处于虚拟环境中的情况下，我们将使用以下命令创建一个名为`Capabilities`的AWS Chalice项目作为编排层：
- en: '[PRE4]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This command will create a Chalice project structure within the `ObjectDetector`
    directory. The Chalice project structure should look similar to the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将在`ObjectDetector`目录下创建一个Chalice项目结构。Chalice项目结构应该类似于以下内容：
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this project structure, we have the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目结构中，我们有以下内容：
- en: The `config.json` file contains configuration options for deploying our Chalice
    application to AWS.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config.json`文件包含了将我们的Chalice应用程序部署到AWS的配置选项。'
- en: The `app.py` file is the main Python file where our public orchestration APIs
    are defined and implemented.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.py`文件是我们的主要Python文件，其中定义并实现了公共编排API。'
- en: The `requirements.txt` file specifies the Python packages that are needed by
    the application when it is deployed to AWS. These packages are different from
    the packages we installed using Pipenv. The Pipenv installed packages are the
    ones we need during development in the local environment; the packages in the
    `requirements.txt` file are the ones the application needs to run in the AWS cloud.
    For example, AWS Chalice is required during the development of the application
    but it is not needed once the application has been deployed to AWS.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requirements.txt`文件指定了应用程序部署到AWS时所需的Python包。这些包不同于我们使用Pipenv安装的包。Pipenv安装的包是在本地开发环境中需要的；而`requirements.txt`文件中的包是应用程序在AWS云中运行时所需的。例如，AWS
    Chalice在开发应用程序时是必需的，但一旦应用程序部署到AWS后，就不再需要它。'
- en: '`boto3` is required when we''re running our projects in the AWS cloud; however,
    it is already provided in the AWS Lambda runtime environment, and so we do not
    need to explicitly specify it in the `requirements.txt` file. Do remember to include
    any other Python packages that the applications need in that file, though.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在AWS云中运行项目时，`boto3`是必需的；不过，它已经在AWS Lambda运行时环境中提供，因此我们不需要在`requirements.txt`文件中显式指定它。但请记得在该文件中包含应用程序所需的其他Python包。
- en: Now, we need to create a `chalicelib` Python package within the Chalice project
    structure in the `Capabilities` directory. Chalice will automatically include
    any of the Python files in `chalicelib` in the deployment package. We will use
    `chalicelib` to hold the Python classes that implement our private APIs.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在`Capabilities`目录下的Chalice项目结构中创建一个`chalicelib` Python包。Chalice会自动将`chalicelib`中的任何Python文件包含在部署包中。我们将使用`chalicelib`来存放实现私有API的Python类。
- en: 'To create the `chalicelib` package, issue the following commands:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`chalicelib`包，请执行以下命令：
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that `__init__.py` makes `chalicelib` a proper Python package.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`__init__.py`使`chalicelib`成为一个合适的Python包。
- en: 'We should have the following project directory structure:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该有以下的项目目录结构：
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is the project structure for the `ObjectDetector` application. It contains
    all the layers of the AI application architecture we defined earlier. This project
    structure is also the base structure for all the hands-on projects in part 2 of
    this book.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`ObjectDetector`应用程序的项目结构。它包含了我们之前定义的AI应用架构的所有层次。这个项目结构也是本书第二部分中所有实践项目的基础结构。
- en: Developing an AI application locally using AWS Chalice
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS Chalice在本地开发AI应用
- en: 'First, let''s implement the private APIs and services that provide common capabilities.
    We will have two services; both of them should be created in the `chalicelib`
    directory:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们实现提供通用功能的私有API和服务。我们将有两个服务，它们都应在`chalicelib`目录中创建：
- en: '`StorageService`:The `StorageService` class that''s implemented in the `storage_service.py`
    file connects to AWS S3 via `boto3` to perform tasks on files we need for the
    applications.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`StorageService`：`StorageService`类在`storage_service.py`文件中实现，通过`boto3`连接到AWS
    S3，以便对应用程序所需的文件执行操作。'
- en: 'Let''s implement `StorageService`, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现`StorageService`，如下所示：
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the class, there is currently a constructor and two methods:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，目前有一个构造函数和两个方法：
- en: The `__init__()` constructor takes a parameter, `storage_location`. In this
    implementation of `StorageService`, `storage_location` represents the S3 bucket
    where files will be stored. However, we purposely gave this parameter a generic
    name so that different implementations of `StorageService` can use other storage
    services besides AWS S3.
  id: totrans-135
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__()`构造函数接受一个参数，`storage_location`。在`StorageService`的这个实现中，`storage_location`表示文件存储的S3桶。然而，我们故意给这个参数起了一个通用的名称，这样不同的`StorageService`实现可以使用AWS
    S3以外的其他存储服务。'
- en: The first method, `get_storage_location()`, just returns the S3 bucket name
    as `storage_location`. Other service implementations will use this method to get
    the generic storage location.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个方法，`get_storage_location()`，只是返回S3桶的名称作为`storage_location`。其他服务实现将使用此方法来获取通用的存储位置。
- en: The second method, `list_files()`, retrieves a list of files from an S3 bucket
    specified by `storage_location`. The files in this bucket are then returned as
    a list of Python objects. Each object describes a file, including its location,
    filename, and URL.
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个方法，`list_files()`，从指定的`storage_location`的S3桶中检索文件列表。然后，这些文件作为Python对象的列表返回。每个对象描述一个文件，包括其位置、文件名和URL。
- en: Note that we are also describing the files using more generic terms, such as
    location, filename, and URL, rather than bucket, key, and s3 URL. In addition,
    we are returning a new Python list with our own JSON format, rather than returning
    the available response from *boto3*. This prevents AWS implementation details
    from leaking out of this private API's implementation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们也在使用更通用的术语来描述文件，如位置、文件名和URL，而不是桶、键和s3 URL。此外，我们返回的是一个包含自定义JSON格式的新Python列表，而不是返回来自*boto3*的可用响应。这可以防止AWS的实现细节泄露到这个私有API的实现中。
- en: The design decisions in `StorageService` are made to hide the implementation
    details from its clients. Because we are hiding the `boto3` and S3 details, we
    are free to change `StorageService` so that we can use other SDKs or services
    to implement the file storage capabilities.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`StorageService`中的设计决策是为了隐藏实现细节，避免暴露给其客户端。因为我们隐藏了`boto3`和S3的细节，我们可以自由地修改`StorageService`，使其能够使用其他SDK或服务来实现文件存储功能。'
- en: '`RecognitionService`: The `RecognitionService` class that''s implemented in
    the `recognition_service.py` file calls the Amazon Rekognition service via `boto3`
    to perform image and video analysis tasks.'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RecognitionService`：`RecognitionService`类在`recognition_service.py`文件中实现，通过`boto3`调用Amazon
    Rekognition服务，以执行图像和视频分析任务。'
- en: 'Let''s implement `RecognitionService`, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现`RecognitionService`，如下所示：
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this class, it currently has a constructor and one method:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，目前有一个构造函数和一个方法：
- en: The `__init__()` constructor takes in `StorageService` as a dependency to get
    the necessary files. This allows new implementations of `StorageService` to be
    injected and used by `RecognitionService`; that is, as long as the new implementations
    of `StorageService` implement the same API contract. This is known as the dependency
    injection design pattern, which makes software components more modular, reusable,
    and readable.
  id: totrans-144
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__()` 构造函数接受 `StorageService` 作为依赖项来获取必要的文件。这允许将新的 `StorageService`
    实现注入并供 `RecognitionService` 使用；即，只要新的 `StorageService` 实现遵循相同的 API 契约。这被称为依赖注入设计模式，它使软件组件更具模块化、可重用性和可读性。'
- en: The `detect_objects()` method takes in an image filename, including both the
    path and name portions, and then performs object detection on the specified image.
    This method implementation assumes that the image file is stored in an S3 bucket
    and calls Rekognition's `detect_labels()` function from the `boto3` SDK. When
    the labels are returned by *boto3*, this method constructs a new Python list,
    with each item in the list describing an object that was detected and the confidence
    level of the detection.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detect_objects()` 方法接受一个图像文件名，包括路径和名称部分，然后对指定的图像执行对象检测。此方法实现假设图像文件存储在 S3 桶中，并从
    `boto3` SDK 调用 Rekognition 的 `detect_labels()` 函数。当 *boto3* 返回标签时，该方法会构造一个新的 Python
    列表，列表中的每一项描述了检测到的对象及其检测的置信度。'
- en: Note that, from the method's signatures (the parameters and return value), it
    does not expose the fact that the S3 and Rekognition services are used. This is
    the same information-hiding practice we used in `StorageService`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从方法的签名（参数和返回值）来看，它并没有暴露出使用 S3 和 Rekognition 服务的事实。这与我们在 `StorageService`
    中使用的信息隐藏实践相同。
- en: In `RecognitionService`, we could use the `StorageService` that was passed in
    through the constructor to get the actual image files and perform detection on
    the image files. Instead, we are directly passing the image files' buckets and
    names through the `detect_labels()` function. This latter implementation choice
    takes advantage of the fact that AWS S3 and Amazon Rekognition are nicely integrated.
    The important point is that the private API's contract allows both implementations,
    and our design decision picked the latter implementation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `RecognitionService` 中，我们本可以使用构造函数中传递的 `StorageService` 来获取实际的图像文件并对其进行检测。但我们直接通过
    `detect_labels()` 函数传递图像文件的桶和名称。这种后者的实现方式利用了 AWS S3 和 Amazon Rekognition 的良好集成。关键点是私有
    API 的契约支持这两种实现，而我们的设计决策选择了后者。
- en: '`app.py`:Next, let''s implement the public APIs that are tailored for our image
    recognition web application. We only need one public API for the demo application.
    It should be implemented in the `app.py` file in the Chalice project structure.'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`app.py`：接下来，让我们实现专为图像识别 Web 应用程序量身定制的公共 API。我们只需要一个公共 API 来演示应用程序。它应该在 Chalice
    项目结构中的 `app.py` 文件中实现。'
- en: 'Replace the existing contents of `app.py` with the following code block. Let''s
    understand the components of the class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码块替换 `app.py` 中的现有内容。让我们理解该类的组件：
- en: The `demo_object_detection()` function uses `StorageService` and `RecognitionService`
    to perform its tasks; therefore, we need to import these from `chalicelib` and
    create new instances of these services.
  id: totrans-150
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`demo_object_detection()` 函数使用 `StorageService` 和 `RecognitionService` 来执行其任务；因此，我们需要从
    `chalicelib` 导入这些服务并创建这些服务的新实例。'
- en: '`storage_location` is initialized to `contents.aws.ai`, which contains the
    image files we uploaded in the previous chapter. You should replace `contents.aws.ai`
    with your own S3 bucket.'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`storage_location` 被初始化为 `contents.aws.ai`，该位置包含我们在上一章上传的图像文件。你应将 `contents.aws.ai`
    替换为你自己的 S3 桶。'
- en: 'This function is annotated with `@app.route(''/demo-object-detection'', cors
    = True)`. This is a special construct used by Chalice to define a RESTful endpoint
    with a URL path called `/demo-object-detection`:'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数使用 `@app.route('/demo-object-detection', cors = True)` 注解。这是 Chalice 用于定义一个名为
    `/demo-object-detection` 的 RESTful 端点的特殊结构：
- en: Chalice maps this endpoint to the `demo_object_detection()` Python function.
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chalice 将此端点映射到 `demo_object_detection()` Python 函数。
- en: 'The annotation also sets `cors` to true, which enables **Cross-Origin Resource
    Sharing** (**CORS**) by adding certain HTTP headers to the response of this endpoint.
    These extra HTTP headers tell a browser to let a web application running at one
    origin (domain) so that it has permission to access resources from a different
    origin (domain, protocol, or port number) other than its own. Let''s have a look
    at the implementations in the following class:'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解还将`cors`设置为true，这通过在此端点的响应中添加特定的HTTP头部，启用了**跨源资源共享**（**CORS**）。这些额外的HTTP头部会告诉浏览器允许在一个源（域名）下运行的网页应用程序访问不同源（包括不同的域名、协议或端口号）上的资源。让我们看一下下面类中的实现：
- en: The Chalice annotation syntax might look familiar to Flask developers. AWS Chalice
    borrows a lot of its design and syntax from the Flask framework.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Chalice的注解语法可能对Flask开发者来说很熟悉。AWS Chalice从Flask框架中借鉴了很多设计和语法。
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s talk about the preceding code in detail:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论一下前面的代码：
- en: The `demo_object_detection()` function gets a list of image files (files that
    have a `.jpg` extension) from `StorageService` and then randomly selects one of
    them to perform the object detection demo.
  id: totrans-158
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`demo_object_detection()`函数从`StorageService`获取一个包含图像文件（扩展名为`.jpg`的文件）列表，并随机选择其中一个进行目标检测演示。'
- en: Random selection is implemented here to simplify our demo application so that
    it only displays one image and its detection results.
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机选择在这里实现，以简化我们的演示应用程序，使其仅显示一张图像及其检测结果。
- en: Once the image has been randomly selected, the function calls `detect_objects()`
    from `RecognitionService` and then generates an HTTP response in the **JavaScript
    Object Notation** (**JSON**) format.
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦图像被随机选择，函数会调用`RecognitionService`中的`detect_objects()`，然后生成一个**JavaScript对象表示法**（**JSON**）格式的HTTP响应。
- en: Chalice automatically wraps the response object in the proper HTTP headers,
    response code, and the JSON payload. The JSON format is part of the contract between
    our frontend and this public API.
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chalice会自动将响应对象包装在适当的HTTP头部、响应代码和JSON负载中。JSON格式是我们前端与这个公共API之间的合同的一部分。
- en: We are ready to run and test the application's backend locally. Chalice provides
    a local mode, which includes a local HTTP server that you can use to test the
    endpoints.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好在本地运行并测试应用程序的后端了。Chalice提供了一个本地模式，其中包括一个本地HTTP服务器，您可以使用它来测试端点。
- en: 'Start the `chalice local` mode within the `pipenv` virtual environment with
    the following commands:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`pipenv`虚拟环境中，通过以下命令启动`chalice local`模式：
- en: '[PRE11]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, the local HTTP server is running at the address and port number in the
    Terminal output; that is, `http://127.0.0.1:8000`. Keep in mind that even though
    we are running the endpoint locally, the services that the endpoint calls are
    making requests to AWS via the `boto3` SDK.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，本地HTTP服务器已在终端输出的地址和端口号上运行，也就是`http://127.0.0.1:8000`。请记住，尽管我们在本地运行端点，但端点调用的服务通过`boto3`
    SDK向AWS发出请求。
- en: Chalice's local mode automatically detected the AWS credentials in the `~/.aws/credentials`
    file. Our service implementations, which are using `boto3`, will use the key pairs
    that are found there and will issue requests with the corresponding user's permissions.
    If this user does not have permissions for S3 or Rekognition, the request to the
    endpoint will fail.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Chalice的本地模式自动检测到了`~/.aws/credentials`文件中的AWS凭证。我们的服务实现会使用`boto3`中找到的密钥对，并使用相应用户的权限发出请求。如果该用户没有S3或Rekognition的权限，向端点发出的请求将会失败。
- en: 'We can now issue HTTP requests to the local server to test the `/demo-object-detection`
    endpoint. For example, you can use the Unix `curl` command as follows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以向本地服务器发出HTTP请求，以测试`/demo-object-detection`端点。例如，您可以使用Unix的`curl`命令，如下所示：
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that, in this code, we just append the endpoint URL path to the base address
    and port number where the local HTTP server is running. The request should return
    JSON output back from the local endpoint.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这段代码中，我们只是将端点的URL路径附加到本地HTTP服务器运行的基本地址和端口号上。请求应该返回来自本地端点的JSON输出。
- en: This is the JSON that our web user interface will receive and use to display
    the detection results to the user.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的网页用户界面将接收并用于向用户展示检测结果的JSON格式数据。
- en: Developing a demo application web user interface
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发演示应用程序的网页用户界面
- en: Next, let's create a simple web user interface with HTML and JavaScript in the
    `index.html` and `script.js` files in the website directory.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在网站目录中的`index.html`和`script.js`文件中使用HTML和JavaScript创建一个简单的网页用户界面。
- en: 'Refer to the code in the `index.html` file, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 `index.html` 文件中的代码，如下所示：
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We are using standard HTML tags here, so the code of the web page should be
    easy to follow for anyone familiar with HTML. A few things worth pointing out
    are as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用标准的HTML标签，因此，任何熟悉HTML的人都应该能轻松跟随网页的代码。以下是几个值得注意的事项：
- en: We are including a couple of **Cascading Style Sheets** (**CSS**) from [www.w3schools.com](http://www.w3schools.com)
    to make our web interface a bit prettier than plain HTML. Most of the classes
    in the HTML tags are defined in these style sheets.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从 [www.w3schools.com](http://www.w3schools.com) 引入了几种 **层叠样式表** (**CSS**)
    来使我们的网页界面比简单的HTML更加美观。HTML标签中的大多数类都是在这些样式表中定义的。
- en: The `<img>` tag with the `image` ID will be used to display the randomly selected
    demo image. This ID will be used by JavaScript to add the image dynamically.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有 `image` ID 的 `<img>` 标签将用于显示随机选择的演示图片。JavaScript会使用这个ID来动态添加图片。
- en: The `<div>` tag with the `objects` ID will be used to display the objects that
    were detected in the demo image. This ID will also be used by JavaScript to add
    the object labels and confidence levels dynamically.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有 `objects` ID 的 `<div>` 标签将用于显示在演示图片中检测到的对象。这个ID也将被JavaScript用来动态添加对象标签和置信度。
- en: The `scripts.js` file is included toward the bottom of the HTML file. This adds
    the dynamic behaviors that were implemented in JavaScript to this HTML page.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scripts.js` 文件位于HTML文件的底部。这为该HTML页面添加了通过JavaScript实现的动态行为。'
- en: The `runDemo()` function from `scripts.js` is run when the HTML page is loaded
    in a browser. This is accomplished in the `index.html` page's `<body>` tag with
    the `onload` attribute.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当HTML页面在浏览器中加载时，`scripts.js` 中的 `runDemo()` 函数会被调用。这是在 `index.html` 页面 `<body>`
    标签中的 `onload` 属性实现的。
- en: 'Please refer to the code of the `scripts.js` file, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下 `scripts.js` 文件的代码：
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s talk about the preceding code in detail:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论一下之前的代码：
- en: The script has only one function, `runDemo()`. This function makes an HTTP `GET`
    request to the `/demo-object-detection` endpoint running on the local HTTP server
    via the Fetch API that's available in JavaScript.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本只有一个函数，`runDemo()`。这个函数通过JavaScript中可用的Fetch API，向本地HTTP服务器上运行的 `/demo-object-detection`
    端点发送HTTP `GET` 请求。
- en: If the response from the local endpoint is `ok`, then it converts the payload
    into a JSON object and passes it down to the next processing block.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果本地端点的响应为 `ok`，则它会将负载转换为JSON对象，并将其传递到下一个处理块。
- en: The `runDemo()` function then looks for an HTML element with the `image` ID,
    which is the `<img>` tag in HTML, and specifies the `src` attribute as the `imageUrl`
    returned by the endpoint. Remember, this `imageUrl` is set to the URL of the image
    file stored in S3\. The `<img>` tag's `alt` attribute is set to `imageName`. `imageName`
    will be displayed to the user if the image cannot be loaded for some reason.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，`runDemo()` 函数会查找具有 `image` ID 的HTML元素，也就是HTML中的 `<img>` 标签，并将 `src` 属性指定为端点返回的
    `imageUrl`。记住，这个 `imageUrl` 是指向存储在S3中的图片文件的URL。`<img>` 标签的 `alt` 属性设置为 `imageName`。如果图片因某种原因无法加载，`imageName`
    将显示给用户。
- en: Note that the image in S3 must be set to public readable in order for the website
    to display it. If you only see the `alt` text, double-check that the image is
    readable by the public.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，S3中的图片必须设置为公共可读，网站才能显示该图片。如果你只看到 `alt` 文本，请重新检查图片是否对公众可读。
- en: The `runDemo()` function then looks for an HTML element with the `objects` ID,
    which is a `<div>` tag, and appends a `<h6>` heading element for each object returned
    by the local endpoint, including each object's label and detection confidence
    level.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，`runDemo()` 函数会查找具有 `objects` ID 的HTML元素，也就是一个 `<div>` 标签，并为本地端点返回的每个对象附加一个
    `<h6>` 标题元素，其中包括每个对象的标签和检测置信度。
- en: 'Now, we are ready to see this website in action. To run the website locally,
    simply open the `index.html` file in your browser. You should see a web page similar
    to the following screenshot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好查看这个网站的实际效果了。要在本地运行网站，只需在浏览器中打开 `index.html` 文件即可。你应该会看到一个类似以下截图的网页：
- en: '![](img/857da830-9229-4755-8b7f-a17b6a98b505.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/857da830-9229-4755-8b7f-a17b6a98b505.png)'
- en: Upload a few JPEG image files and refresh the page a few times to see the object
    detection demo run; the demo will select a different image that's stored in your
    S3 bucket each time it runs. The `ObjectDetector` application is not as fancy
    as the Amazon Rekognition demo, but pat yourself on the back for creating a well-architected
    AI application!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 上传几个 JPEG 图像文件并刷新页面几次，看看对象检测演示如何运行；每次运行时，演示将选择存储在 S3 桶中的不同图像。`ObjectDetector`
    应用程序虽然不如 Amazon Rekognition 演示那样花哨，但为自己创造了一个架构良好的 AI 应用程序而自豪吧！
- en: The local HTTP server will run continuously unless you explicitly stop it. To
    stop the local HTTP server, go to the Terminal window that's running `chalice
    local` and press *Ctrl* + *C*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本地 HTTP 服务器将持续运行，除非你明确停止它。要停止本地 HTTP 服务器，请进入正在运行 `chalice local` 的终端窗口，并按下 *Ctrl*
    + *C*。
- en: 'The final project structure for the `ObjectDetector` application should look
    as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObjectDetector` 应用程序的最终项目结构应如下所示：'
- en: '[PRE15]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It's now time to make our AI application public and deploy it to the AWS cloud.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们的 AI 应用程序公开并部署到 AWS 云上了。
- en: Deploying AI application backends to AWS via Chalice
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 AI 应用程序后端通过 Chalice 部署到 AWS
- en: Deployment to AWS with Chalice is amazingly simple yet powerful. Chalice automatically
    translates the endpoint annotations in `app.py` into HTTP endpoints and deploys
    them onto the Amazon API Gateway as public APIs. Chalice also deploys the Python
    code in `app.py` and `chalicelib` as AWS Lambda functions and then connects the
    API gateway endpoints as triggers to these Lambda functions. This simplicity is
    the reason why we chose a serverless framework such as AWS Chalice to develop
    our hands-on projects.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Chalice 部署到 AWS 非常简单而强大。Chalice 会自动将 `app.py` 中的端点注解转换为 HTTP 端点，并将它们作为公共
    API 部署到 Amazon API Gateway。Chalice 还将 `app.py` 和 `chalicelib` 中的 Python 代码部署为
    AWS Lambda 函数，然后将 API 网关端点作为触发器连接到这些 Lambda 函数。这种简易性就是我们选择 AWS Chalice 作为无服务器框架来开发实际项目的原因。
- en: 'When we ran the backend locally, Chalice automatically detected the AWS credentials
    in our development environment and made them available to the application. Which
    credentials will the application use when it is running in AWS? Chalice automatically
    creates an AWS IAM role for the application during the deployment process. Then,
    the application will run with the permissions that have been granted to this role.
    Chalice can automatically detect the necessary permissions, but this feature is
    considered experimental at the time of writing and does not work well with our
    projects'' structures. For our projects, we need to tell Chalice to *not* perform
    this analysis for us by setting `autogen_policy` to `false` in the `config.json`
    file in the `.chalice` directory of the project structure. The following is the
    `config.json` file:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本地运行后端时，Chalice 会自动检测到我们开发环境中的 AWS 凭证，并将其提供给应用程序。那么，当应用程序在 AWS 中运行时，它将使用哪些凭证呢？Chalice
    在部署过程中会自动为应用程序创建一个 AWS IAM 角色。然后，应用程序将以已授予该角色的权限运行。Chalice 可以自动检测所需的权限，但此功能在本文撰写时仍被视为实验性，并且与我们项目的结构不兼容。对于我们的项目，我们需要告诉
    Chalice *不要* 为我们执行此分析，通过在项目结构的 `.chalice` 目录中的 `config.json` 文件中将 `autogen_policy`
    设置为 `false` 来实现。以下是 `config.json` 文件：
- en: '[PRE16]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that, in this configuration, there is a `dev` stage in `config.json`. Chalice
    provides us with the ability to deploy our application in multiple environments.
    Different environments are used by mature software organizations to perform various
    software life cycle tasks, such as testing and maintenance in an isolated manner.
    For example, we have the development (`dev`) environment for rapid experimentation,
    quality assurance (`qa`) for integration testing, user acceptance testing (`uat`)
    for business requirement validation, performance (`prof`) for stress testing,
    and product (`prod`) for live traffic from end users.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在此配置中，`config.json` 中有一个 `dev` 阶段。Chalice 提供了将应用程序部署到多个环境的能力。不同的环境被成熟的软件组织用来以隔离的方式执行各种软件生命周期任务，如测试和维护。例如，我们有用于快速实验的开发（`dev`）环境，质量保证（`qa`）用于集成测试，用户验收测试（`uat`）用于业务需求验证，性能（`prof`）用于压力测试，产品（`prod`）用于来自最终用户的实时流量。
- en: 'Next, we need to create a new file, `policy-dev.json`, in the `.chalice` directory
    to manually specify the AWS services the project needs:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在 `.chalice` 目录中创建一个新文件 `policy-dev.json`，手动指定项目所需的 AWS 服务：
- en: '[PRE17]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we are specifying S3 and Rekognition, in addition to some permissions
    to allow the project to push logs to CloudWatch.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定了 S3 和 Rekognition，此外还包括一些权限，以允许项目将日志推送到 CloudWatch。
- en: 'Now, we are ready to deploy the backend on the AWS Chalice framework:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好在 AWS Chalice 框架上部署后端了：
- en: 'Run the following command within the `Capabilities` directory:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Capabilities` 目录中运行以下命令：
- en: '[PRE18]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When the deployment is complete, in the output, Chalice will show a RESTful
    API URL that looks similar to `https://<UID>.execute-api.us-east-1.amazonaws.com/api/`,
    where `<UID>` is a unique identifier string. This is the server URL your frontend
    app should hit to access the application backend running on AWS.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 部署完成后，Chalice 会在输出中显示一个类似 `https://<UID>.execute-api.us-east-1.amazonaws.com/api/`
    的 RESTful API URL，其中 `<UID>` 是一个唯一标识符字符串。这是您的前端应用程序应该访问的服务器 URL，以连接到在 AWS 上运行的应用程序后端。
- en: 'You can now verify the results of the Chalice deployment in the AWS Management
    Console under three services:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在 AWS 管理控制台的三个服务中验证 Chalice 部署的结果：
- en: Amazon API Gateway
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon API Gateway
- en: AWS Lambda
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Lambda
- en: Identity and Access Management
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份和访问管理
- en: Take a look at the console pages of these services and see what AWS Chalice
    has set up for our application.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这些服务的控制台页面，看看 AWS Chalice 为我们的应用程序设置了什么。
- en: 'Use the `curl` command to test the remote endpoint, as follows. You should
    get similar output to when we were testing with the local endpoint:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `curl` 命令测试远程端点，命令如下。您应该会得到类似于我们在测试本地端点时的输出：
- en: '[PRE19]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Congratulations! You've just deployed a serverless backend for an AI application
    that is highly available and scalable, running in the cloud.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您刚刚部署了一个无服务器的 AI 应用后端，它具有高可用性和可扩展性，并运行在云端。
- en: Deploying a static website via AWS S3
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 AWS S3 部署静态网站
- en: Next, let's deploy the frontend web user interface to AWS S3.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将前端网页用户界面部署到 AWS S3。
- en: 'One of the buckets we created in the previous chapter was for the purpose of
    website hosting. Let''s configure it via the AWS Management Console for static
    website hosting:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章节中创建的一个桶是用于网站托管的。让我们通过 AWS 管理控制台为其配置静态网站托管：
- en: Navigate to the **Amazon S3** service in the management console and click on
    your bucket.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到管理控制台中的 **Amazon S3** 服务并点击您的桶。
- en: 'In the **Properties** tab, as shown in the following screenshot, click on the
    **Static website hostin****g** card:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Properties** 选项卡中，如下图所示，点击 **Static website hosting** 卡片：
- en: '![](img/de924c16-f2ea-40f6-8a72-28eda90e4419.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de924c16-f2ea-40f6-8a72-28eda90e4419.png)'
- en: When you click on the **Static website hosting** card, a configuration card
    will pop up.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您点击 **Static website hosting** 卡片时，会弹出一个配置卡片。
- en: Select **Use this bucket to host a website** and enter `index.html` and `error.html`
    for the **Index document** and **Error document** fields, respectively.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Use this bucket to host a website**，并分别在 **Index document** 和 **Error document**
    字段中输入 `index.html` 和 `error.html`。
- en: 'Copy the **Endpoint** URL on your configuration page and then click **Save**.
    This endpoint URL will be the public address of your static website:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制配置页面上的 **Endpoint** URL，然后点击 **Save**。这个端点 URL 将是您的静态网站的公共地址：
- en: '![](img/14db876d-8b7d-4fae-8b14-d25048edacde.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14db876d-8b7d-4fae-8b14-d25048edacde.png)'
- en: Next, we can upload the `index.html` and `scripts.js` files to this S3 bucket.
    Before we do that, we need to make a change in `scripts.js`. Remember, the website
    will be running in the cloud now, and won't have access to our local HTTP server.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以将 `index.html` 和 `scripts.js` 文件上传到这个 S3 桶。在上传之前，我们需要对 `scripts.js`
    进行更改。请记住，网站现在将运行在云中，无法访问我们的本地 HTTP 服务器。
- en: 'Replace the local server URL in the `scripts.js` file with the one from our
    backend deployment, as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `scripts.js` 文件中的本地服务器 URL 替换为我们后端部署的 URL，如下所示：
- en: '[PRE20]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finally, set the permissions of the `index.html` and `scripts.js` files to publicly
    readable. To do that, we need to modify the S3 bucket permissions under the **Permissions**
    tab.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将 `index.html` 和 `scripts.js` 文件的权限设置为公开可读。为此，我们需要在 **Permissions** 选项卡下修改
    S3 桶的权限。
- en: 'Click on the **Public access settings** button, uncheck all four checkboxes,
    and then type `confirm` to confirm these changes. This will allow the contents
    of this S3 bucket to be made publicly accessible, as follows:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Public access settings** 按钮，取消选中所有四个复选框，然后输入 `confirm` 以确认这些更改。这将允许将此 S3
    桶的内容公开访问，如下所示：
- en: '![](img/825dc8b3-2ef9-4727-8b52-dfb95c14ac50.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/825dc8b3-2ef9-4727-8b52-dfb95c14ac50.png)'
- en: 'Now, we are able to make the files public by selecting both files, clicking
    on **Actions**, and clicking on **Make public**, as shown in the following screenshot:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过选择这两个文件，点击 **Actions**，然后点击 **Make public**，将文件设置为公开，如下图所示：
- en: '![](img/77181fa1-98ed-4025-a675-8cf253bb64bb.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77181fa1-98ed-4025-a675-8cf253bb64bb.png)'
- en: Open the S3 endpoint URL in your browser. The URL should look something like
    `http://<BUCKET>.s3-website-us-east-1.amazonaws.com/`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开 S3 端点 URL。该 URL 应该类似于 `http://<BUCKET>.s3-website-us-east-1.amazonaws.com/`。
- en: Your `ObjectDetector` website is now running in your browser and it's communicating
    with the backend running on AWS to demo your intelligent-enabled application's
    capability. Both the frontend and the backend are serverless and both are running
    on the AWS cloud infrastructure, which scales automatically with demand.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `ObjectDetector` 网站现在已经在浏览器中运行，并且它正在与运行在 AWS 上的后端进行通信，以展示你的智能应用功能。前端和后端都是无服务器架构，且都运行在
    AWS 云基础设施上，能够根据需求自动扩展。
- en: Congratulations! You've just developed an end-to-end AI application to AWS!
    You can now share this AI application with anyone in the world with a browser.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你！你刚刚将一个端到端的 AI 应用开发并部署到 AWS 上！现在，你可以与任何拥有浏览器的人分享这个 AI 应用。
- en: Even though your new AWS account might have free-tier services, you should still
    limit the number of people you share the website URL and API endpoints with. You
    will be charged if the AWS resources that are consumed exceed the amount that's
    covered under the free-tier plan.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你新的 AWS 账户可能拥有免费层服务，你仍然应该限制与你共享网站 URL 和 API 端点的人员数量。如果所消耗的 AWS 资源超出免费层计划覆盖的额度，你将会被收费。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed the importance of good architecture design for
    artificial intelligence applications. We created a reference architecture design
    for web applications that will be the template for all of our hands-on projects
    in part 2 of this book. Using this reference architecture, we recreated the Amazon
    Rekognition demo application using several AWS tools and services in the serverless
    style. We built the demo application's backend with AWS Chalice and *boto3* and
    leveraged AWS S3 and Amazon Rekognition to provide the business capabilities.
    Through the hands-on project, we showed you how architecture boundaries and good
    design allow for flexible application development and evolution. We also built
    a simple web user interface for the demo application with HTML, CSS, and JavaScript.
    Finally, we deployed the demo application as a serverless application to the AWS
    cloud.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了良好的架构设计对人工智能应用的重要性。我们为 Web 应用创建了一个参考架构设计，该设计将作为本书第二部分所有实践项目的模板。利用这个参考架构，我们通过
    AWS 的多个工具和服务，以无服务器架构的方式重建了 Amazon Rekognition 演示应用。我们使用 AWS Chalice 和 *boto3*
    构建了演示应用的后端，并利用 AWS S3 和 Amazon Rekognition 提供了业务功能。通过这个实践项目，我们向你展示了架构边界和良好设计如何促进灵活的应用开发与演化。我们还用
    HTML、CSS 和 JavaScript 为演示应用构建了一个简单的 Web 用户界面。最后，我们将演示应用作为无服务器应用部署到 AWS 云上。
- en: Now that we have experience building a simple yet elegant intelligent-enabled
    application, we are ready to use the same architecture template and toolset to
    build more AI applications in part 2 of this book.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了构建一个简单而优雅的智能应用的经验，准备好在本书第二部分使用相同的架构模板和工具集来构建更多的人工智能应用。
- en: Further reading
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'You can refer to the following links for more information on the anatomy of
    a modern AI application:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考以下链接获取有关现代 AI 应用架构的更多信息：
- en: '[http://www.cs.nott.ac.uk/~pszcah/G51ISS/Documents/NoSilverBullet.html](http://www.cs.nott.ac.uk/~pszcah/G51ISS/Documents/NoSilverBullet.html)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.cs.nott.ac.uk/~pszcah/G51ISS/Documents/NoSilverBullet.html](http://www.cs.nott.ac.uk/~pszcah/G51ISS/Documents/NoSilverBullet.html)'
- en: '[https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)'
