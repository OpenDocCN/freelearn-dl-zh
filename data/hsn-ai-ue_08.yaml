- en: Crowds
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 群体
- en: In this chapter, we are going to wrap up our talk about what comes built-in
    in terms of Artificial Intelligence in Unreal. Then, we will embark on a journey
    in which we will build an interesting AI Behavior Tree from scratch, before checking
    the huge Debug system (which includes AI Debugging) underneath Unreal.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将总结关于虚幻引擎中内置的人工智能的讨论。然后，我们将开始一段旅程，从头开始构建一个有趣的AI行为树，然后再检查虚幻引擎底下的巨大调试系统（包括AI调试）。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Crowds in Games
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏中的群体
- en: RVO avoidance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RVO避免
- en: Crowd Manager
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 群体管理者
- en: These topics may be short, but that doesn't make them less important or easy
    to implement. So, let's get started!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些主题可能很短，但这并不意味着它们不重要或容易实施。所以，让我们开始吧！
- en: Crowds in games
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏中的群体
- en: Have you ever been stuck in a busy mall at Christmas or surrounded by a large
    crowd during a sporting event? Perhaps you were shopping among the bazaars of
    heavily fragrant spice markets? Now, imagine that all of the people in this environment
    disappeared. How would this change the mood? Quite significantly, I would imagine.
    Regardless of how big or how small a crowd of people is within an environment,
    they definitely add to the overall atmosphere.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾在圣诞节时被困在繁忙的购物中心，或者在体育赛事中被一大群人包围？也许你曾在香气扑鼻的香料市场的摊位间购物？现在，想象一下这个环境中的所有人突然消失。这会改变氛围吗？我想会相当显著。无论环境中的群体大小如何，它们无疑都会增加整体氛围。
- en: Some great examples of crowds in games include the *Assassin's Creed* series*:*
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中群体的一些优秀例子包括*刺客信条*系列*：
- en: '![](img/fccc6dba-124d-44ea-8dd0-250b0171e317.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fccc6dba-124d-44ea-8dd0-250b0171e317.png)'
- en: 'Crowds in *Assassin''s Creed: Syndicate*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*刺客信条：大革命*中的群体'
- en: Crowds can include both interactive NPCs and those that simply just wander around,
    minding their own business. In some cases, like in *Assassin's Creed*, members
    of the crowd will play an important role such as requiring you to protect them,
    offering you protection, or even requiring your resources (e.g. beggars asking
    for money). In other situations, crowds will have no impact on your gameplay other
    than getting in your way!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 群体可以包括既可交互的非玩家角色（NPC），也可以是那些只是四处闲逛、忙着自己的事情的人。在某些情况下，比如在*刺客信条*中，群体中的成员将扮演重要的角色，例如要求你保护他们，为你提供保护，甚至要求你的资源（例如乞丐要钱）。在其他情况下，群体除了挡道外，对你的游戏玩法没有任何影响！
- en: Building believable crowds
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建可信的群体
- en: While crowds are large collections of people, usually with a common purpose
    when in a given location, they require a bit of thought behind their creation.
    It's not as simple as dumping a bunch of NPCs, giving them some autonomy (e.g.
    via artificial intelligence), and pressing play. Building a believable crowd requires
    us to consider a few things.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然群体是大量人群的集合，通常在特定地点有共同的目的，但它们的创建需要一些思考。这不仅仅是简单地堆砌一帮NPC，给他们一些自主性（例如通过人工智能），然后按下播放。构建一个可信的群体需要我们考虑一些事情。
- en: 'The first consideration is the different kinds of people that should be there.
    Going back to our example of spice markets, you''re likely to find shop merchants,
    buyers, beggars, children, and so on. In the following screenshot from the game
    *Stacking*, there are no large crowds or groups of people:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要考虑的是应该有哪些不同类型的人。回到我们关于香料市场的例子，你可能会找到店主、买家、乞丐、孩子等等。在游戏*堆叠*的以下屏幕截图中，没有大量的人群或人群：
- en: '![](img/34952a76-1d08-4c60-a5ee-5ce52452a4db.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34952a76-1d08-4c60-a5ee-5ce52452a4db.png)'
- en: A small crowd in *Stacking*
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*堆叠*中的小人群'
- en: 'However, in *Dead Rising*, as shown in the following screenshot, there is quite
    an extensive crowd of people (zombies, in this case), all trying to attack you:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在*末日危机*中，如以下屏幕截图所示，有一大群人（在这种情况下是僵尸），都在试图攻击你：
- en: '![](img/f6cc5ae1-2397-4f4e-9dfb-d6230e0dde77.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6cc5ae1-2397-4f4e-9dfb-d6230e0dde77.png)'
- en: A big crowd of zombies attacking the player in *Dead Rising*
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在*末日危机*中，一大群僵尸正在攻击玩家
- en: The next consideration is more of an aesthetic one. For instance, depending
    on its location in both space and time, the type of movement, clothes, ages, etc.,
    will also vary. It is highly unlikely (unless that is the angle you're going for)
    that you will have characters dressed as if they are going to a 1930s cocktail
    party, if you're attacking templars during the third crusade.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个考虑因素更多的是美学方面。例如，根据其在空间和时间中的位置，运动类型、服装、年龄等也会有所不同。如果你在第三十字军东征期间攻击圣骑士，你不太可能（除非这是你追求的角度）看到穿着好像要去20世纪30年代鸡尾酒会的人物。
- en: Then, we have the aural consideration. What does this crowd sound like? Are
    they loud or are do they speak in soft murmurs? Perhaps there are bikes whizzing
    past with kids ringing their bells. All of these aspects are important in creating
    a convincing crowd.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有听觉方面的考虑。这个群体听起来是什么样子？他们是喧闹的还是低声细语？也许有自行车飞驰而过，孩子们在摇铃。所有这些方面都是创建逼真群体的重要元素。
- en: Last, but not least, we have the crowd's movement. How do they move? Do they
    follow a specific path, are they guided down particular areas, or are they free
    to roam wherever they choose?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，我们还有群体的移动。他们是怎样移动的？他们是遵循特定的路径，是被引导到特定的区域，还是可以自由地漫游到他们选择的任何地方？
- en: Animals
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动物
- en: 'Now, not all crowds take on human (or part/like human) form. Crowds can also
    exist in terms of groups of animals. As we discussed previously, the same considerations
    also need to be taken into account when developing crowds of animals. You also
    have to pay attention to how animals interact with each other because it is quite
    different from the way humans do. For example, wolves are likely to be in different
    sized crowds, or "packs", than, say, a  flock of vultures or a herd of deer, as
    in the following image:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，并非所有群体都采取人类（或部分/类似人类）的形式。群体也可以是动物群体。正如我们之前讨论的，在开发动物群体时也需要考虑相同的因素。你还得注意动物之间的互动方式，因为这与人类的方式大不相同。例如，狼可能存在于不同大小的群体中，或者说“群体”中，比如说秃鹫群或鹿群，就像以下图片所示：
- en: '![](img/d74ac053-f9eb-4918-87d0-c8e854d85461.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d74ac053-f9eb-4918-87d0-c8e854d85461.png)'
- en: '(Top): Attacking groups of Vultures in *Assassin''s Creed: Origins*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: （顶部）：*刺客信条：起源* 中攻击秃鹫群体
- en: '(Bottom): Herd of deer in *Far Cry 4*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: （底部）：*孤岛惊魂4* 中的鹿群
- en: Crowd movement
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 群体移动
- en: When it comes to more technical aspects of a crowd's functionality, we must
    consider the extent of interaction that a crowd has with the player. For example,
    if a player hits them while running past them, do members of the crowd respond?
    If so, how?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到群体功能的更多技术方面时，我们必须考虑群体与玩家之间交互的范围。例如，如果玩家在跑过他们时击中他们，群体成员会做出反应吗？如果会，他们是如何反应的？
- en: 'In games like Pro Evolution Soccer, FIFA, Rocket League, etc., crowds don''t
    interact with the player beyond cheering or booing, depending on the situation.
    Of course, they also add to the atmosphere with inaudible chanting/conversations/cheering:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在像《实况足球》、《FIFA》、《火箭联盟》等游戏里，群体在根据情况欢呼或嘘声之外，不会与玩家进行交互。当然，他们也会通过不可听见的呐喊/对话/欢呼来增加氛围：
- en: '![](img/c833ee5c-e8c1-42d3-9ab0-591e8488f296.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c833ee5c-e8c1-42d3-9ab0-591e8488f296.png)'
- en: Crowd in *FIFA 2018*
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*FIFA 2018* 中的群体'
- en: Often, this behavior is created by using cleverly animated (vertex) materials
    to simulate a large crowd that the player sees only over a distance and doesn't
    interact with.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这种行为是通过使用巧妙动画的（顶点）材料来模拟一个玩家只能从远处看到且不与之互动的大群体来创造的。
- en: Crowd dynamics and creating realistic behavior
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 群体动力学和创建逼真的行为
- en: Since we have talked about some of the characteristics that help to create realistic
    crowd behavior, let's talk about the ways that we can implement this from a more
    technical standpoint.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了一些有助于创建逼真群体行为的特征，让我们从更技术性的角度来谈谈我们可以如何实现这一点。
- en: Flow-based
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于流动
- en: These types of approaches focus on the crowd rather than its components. This
    means that the distinctive behaviors of individuals (within the crowd) occur due
    to input from their surroundings.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的方案关注的是群体而不是其组成部分。这意味着个体（在群体中）的独特行为是由于周围环境的输入而产生的。
- en: Entity-based
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体基础
- en: These types of approaches mean that the characters in these crowds do not have
    any autonomy. This is because their behavior is based on a set of predefined rules
    that are meant to simulate social/psychological influences that occur in individuals
    that are a part of a crowd. In this way, all the movements of characters are determined
    by these rules.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这类方法意味着这些人群中的角色没有任何自主性。这是因为他们的行为基于一系列预定义的规则，旨在模拟属于人群的个体中发生的社会/心理影响。这样，所有角色的移动都由这些规则决定。
- en: Agent-based
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于智能体
- en: This is perhaps the most dynamic and flexible approach to crowds. In agent-based
    approaches, characters are autonomous and can interact with individuals. This
    is to say that each character within a crowd of this type has (to a certain extent)
    a level of intelligence, which allows them to react based on a set of rules that
    are influenced by their surroundings.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是处理人群最动态和灵活的方法。在基于智能体的方法中，角色是自主的，并且可以与个体互动。也就是说，这种类型的人群中的每个角色（在一定程度上）都有一定的智能，这使它们能够根据受其周围环境影响的规则集做出反应。
- en: This is the kind of approach that we will be using with our AI systems, and,
    in this chapter, we will explore the built-in Unreal systems that handle crowds.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将在我们的AI系统中使用的方法，在本章中，我们将探讨处理人群的内置Unreal系统。
- en: Crowds in Unreal
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unreal中的人群
- en: In Unreal, handling a huge crowd might be challenging, especially if you are
    going to have a complicated system. In fact, a crowd system needs to run fast
    and make the crowd behave realistically.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unreal中，处理大量人群可能会很具挑战性，尤其是如果你打算有一个复杂的系统。事实上，人群系统需要快速运行并使人群表现出真实的行为。
- en: Having a huge crowd that built-in systems don't scale properly means that you
    are probably basing (almost) your entire gameplay on the crowd. In this case,
    you should go for implementing your own Crowd system, even by modifying the built-in
    one. However, for most games, the built-in systems are more than enough.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内置系统无法适当地扩展大量人群，那么你很可能是基于（几乎）你的整个游戏玩法来构建人群的。在这种情况下，你应该考虑实现自己的人群系统，即使是通过修改内置系统。然而，对于大多数游戏来说，内置系统已经足够了。
- en: 'In Unreal, there are two built-in systems for crowd simulation/management.
    These are as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unreal中，有两个内置系统用于人群模拟/管理。具体如下：
- en: UCharacterMovementComponent's RVO
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UCharacterMovementComponent的RVO
- en: Detour Crowd System
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Detour人群系统
- en: Although it is possible to keep them both running, it is not advisable to do
    so. So, be sure to use the one that suits your needs the best, or create your
    own.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以同时运行它们，但这样做并不建议。所以，请确保使用最适合你需求的那个，或者创建自己的。
- en: Reciprocal Velocity Obstacles (RVO)
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互易速度障碍（RVO）
- en: '**Reciprocal Velocity Obstacles** (**RVO**) is an algorithm that was discovered
    by the three researchers Jur van den Berg, Ming C. Lin, and Dinesh Manocha in
    2008 in their paper "*Reciprocal Velocity Obstacles for Real-Time Multi-Agent
    Navigation*".'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**互易速度障碍**（**RVO**）是一种算法，由三位研究人员Jur van den Berg、Ming C. Lin和Dinesh Manocha在2008年发表的论文"*互易速度障碍用于实时多智能体导航*"中发现。'
- en: The RVO algorithm is path agnostic, which means that it is not aware of the
    path that the agent is following, nor the navmesh where the agent is navigating.
    Moreover, each agent navigates independently of one another without explicit communication.
    As a result, RVO is very fast to run, even for a large number of agents, and provides
    sufficient realistic behavior if the number of incoming collisions is limited.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: RVO算法是无路径感知的，这意味着它不知道智能体所遵循的路径，也不知道智能体正在导航的导航网格。此外，每个智能体都是独立于其他智能体进行导航，而不需要明确的通信。因此，RVO即使对于大量智能体来说也非常快速，如果碰撞的数量有限，它还能提供足够的真实行为。
- en: RVO in Unreal
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unreal中的RVO
- en: The implementation of the RVO algorithm within the Unreal Engine goes way back
    to the Unreal Development Kit, or UDK (UE3). In UE4, you can find the algorithm
    that was implemented within the Character Movement Component.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: RVO算法在Unreal Engine中的实现可以追溯到Unreal Development Kit，或UDK（UE3）。在UE4中，你可以在角色移动组件中找到实现的算法。
- en: 'To activate RVO on a specific character, open up its *Character Movement Component*
    and navigate to the *Character Movement: Avoidance* section. Here, you will be
    able to turn on the algorithm and set a few settings, as shown in the following
    screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要在特定角色上激活RVO，请打开其*角色移动组件*并导航到*角色移动：避让*部分。在这里，你可以打开算法并设置一些设置，如下面的截图所示：
- en: '![](img/812b9af2-4c28-4a59-94ab-faf157ff92b2.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/812b9af2-4c28-4a59-94ab-faf157ff92b2.png)'
- en: 'The following settings are available (you need to click on the little arrow
    at the bottom to expand all the settings):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下设置可供选择（您需要点击底部的箭头以展开所有设置）：
- en: '**Use RVOAvoidance**: Specifies whether or not the RVO algorithm is used on
    this character.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用RVO避障**：指定是否在此角色上使用RVO算法。'
- en: '**Avoidance Consideration Radius**: The RVO algorithm will consider only obstacles
    that fall within this radius. Hence, if nothing is within this radius, RVO will
    not change the course of the character. On the other hand, if obstacles (e.g.
    other characters) are present within this radius, RVO will try to avoid them.
    This parameter is really important, and it needs to be tweaked properly (depending
    on what kind of obstacles your character will encounter) when RVO is used.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避障考虑半径**：RVO算法只会考虑位于此半径内的障碍物。因此，如果在此半径内没有障碍物，RVO不会改变角色的航线。另一方面，如果障碍物（例如其他角色）位于此半径内，RVO将尝试避开它们。此参数非常重要，当使用RVO时，需要根据角色可能遇到的障碍物类型进行适当的调整。'
- en: '**Avoidance Weight**: This indicates how heavily RVO needs to intervene on
    the avoidance of the obstacles. In fact, the algorithm will try to average between
    the direction the character is heading, and a direction to avoid the obstacles.
    This is the strength of the RVO algorithms and determines its behavior. The default
    value is 0.5, which works in the majority of cases.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避障权重**：这表示RVO在避障障碍物时需要干预的强度。实际上，算法会尝试在角色前进的方向和避开障碍物的方向之间取平均值。这是RVO算法的强度，决定了其行为。默认值是0.5，在大多数情况下都适用。'
- en: '**Avoidance UID**: This is an identification number that is automatically generated
    when RVO is used (you cannot set it). It is important when you want to interact
    with the Avoidance Manager (see the *RVO in C++* section for more information).'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避障UID**：这是一个在RVO使用时自动生成的识别号（您无法设置它）。当您想要与避障管理器交互时，它很重要（有关更多信息，请参阅*C++中的RVO*部分）。'
- en: '**Avoidance Group**: This indicates which avoidance group(s) this character
    belongs to.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避障组别**：这表示这个角色属于哪个避障组别。'
- en: '**Groups to Avoid**: This indicates which of the avoidance groups this character
    needs to avoid.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**要避免的组别**：这表示这个角色需要避开哪些避障组别。'
- en: '**Groups to ignore**: This indicates which of the avoidance groups this character
    needs to ignore, and thus not take them into consideration when performing RVO
    avoidance.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**忽略的组别**：这表示这个角色需要忽略哪些避障组，因此在执行RVO避障时不会考虑它们。'
- en: In the case of multiplayer games, the RVO algorithm will only run on the server.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在多人游戏中，RVO算法仅在服务器上运行。
- en: This is enough to use the algorithm and use it in production for your game.
    However, if you are curious and want to dig a little bit deeper, move on to the
    following subsection.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这就足够使用该算法并在您的游戏中进行生产使用了。然而，如果您好奇并想深入了解，请继续阅读以下子节。
- en: Advanced RVO settings
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级RVO设置
- en: 'This section is divided in two sections: what we can do in a blueprint, and
    what we can do in C++.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本节分为两个部分：我们可以在蓝图中进行什么操作，以及我们可以在C++中进行什么操作。
- en: RVO in Blueprint
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝图中的RVO
- en: 'If you have a reference to the character component, you will notice that you
    can read all of its variables (all of the Get-functions are here), but that you
    cannot set them (there are no Set-functions), as shown in the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有角色组件的引用，您会注意到您可以读取其所有变量（所有Get函数都在这里），但无法设置它们（没有Set函数），如下面的截图所示：
- en: '![](img/9ae2af71-d930-4de6-adb1-f72b4f3c0587.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ae2af71-d930-4de6-adb1-f72b4f3c0587.png)'
- en: 'It seems like you cannot turn RVO on and off any time you like during gameplay
    in Blueprint, but this is not true. In fact, it is still possible to slightly
    change RVO settings in real-time (at gameplay time). In particular, you can change
    whether RVO is running or not with the following node:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来您无法在游戏过程中随时开启或关闭RVO，但这并不正确。实际上，您仍然可以在实时（游戏时间）中稍微改变RVO设置。特别是，您可以使用以下节点来改变RVO是否运行：
- en: '![](img/c7259a3c-19e0-42a4-9db9-62b3d8164b52.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7259a3c-19e0-42a4-9db9-62b3d8164b52.png)'
- en: The reason why you cannot edit the bool variable directly is clear if you look
    at the C++ implementation, in which the character needs to be registered to an
    RVO manager. In fact, it might be the first time that RVO is turned on, and all
    the initialization (e.g. registering to the RVO manager) needs to be handled.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看C++实现，其中角色需要注册到RVO管理器，那么为什么不能直接编辑布尔变量是显而易见的。实际上，这可能是RVO第一次被开启，所有初始化（例如，注册到RVO管理器）都需要处理。
- en: 'Moreover, you can also change in which avoidance group(s) the character belongs
    and which ones, instead, should be avoided, by using the following two nodes:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以通过以下两个节点来更改角色所属的避障组以及哪些角色应该被避免：
- en: '![](img/46b8286b-bc65-4980-8b98-bcca6dbf1912.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/46b8286b-bc65-4980-8b98-bcca6dbf1912.png)'
- en: Besides these three functions, you are pretty limited in what you can do in
    real-time with RVO, but C++ unlocks new possibilities.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这三个函数之外，你在实时使用RVO方面相当有限，但C++开启了新的可能性。
- en: RVO in C++
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的RVO
- en: Of course, every time you reach the C++ realm in Unreal, your possibilities
    gets really wide in terms of what you can do. In this section, we explore some
    of these possibilities.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，每次你进入Unreal的C++领域时，你可以在做什么方面有非常广泛的可能性。在本节中，我们将探讨这些可能性中的一些。
- en: First of all, you will have direct access to the *UAvoidanceManager*, which
    stores data of all the agents that use RVO.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将直接访问*UAvoidanceManager*，它存储了使用RVO的所有代理的数据。
- en: From a reference of the *Character Movement Component*, you can retrieve the
    ***Avoidance UID***, which can be used to query the Avoidance Manager on getting
    the *FNavAvoidanceData* structure, which holds the specific avoidance data of
    the character. Besides having access to the data in the structure, you can use
    it to further query the *Avoidance Manager* to obtain more grain information.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从*角色移动组件*的参考中，你可以检索到***避障UID***，这可以用来查询避障管理器以获取*FNavAvoidanceData*结构，该结构包含角色的特定避障数据。除了可以访问结构中的数据外，你还可以用它进一步查询*避障管理器*以获取更多信息。
- en: Let's say you want to do manual velocity planning. You can gain access to the
    current velocity by using the `GetAvoidanceVelocity()` function.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想进行手动速度规划。你可以通过使用`GetAvoidanceVelocity()`函数来获取当前速度。
- en: 'However, the best way to learn about all of your possibilities is by looking
    at the source code. In particular, you will need to look at the following file:
    `Runtime/Engine/Classes/AI/Navigation/AvoidanceManager.h`.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，了解所有可能性的最佳方式是查看源代码。特别是，你需要查看以下文件：`Runtime/Engine/Classes/AI/Navigation/AvoidanceManager.h`。
- en: RVO observations
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RVO观察
- en: 'The following are some of my observations from using this approach:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我使用这种方法的一些观察结果：
- en: Since it is path and navmesh agnostic, the agent could potentially be pushed
    away from the Navmesh. This means that you need to take into consideration this
    possibility (and how often this might happen, e.g. if your maps have wall boundaries,
    then the character cannot be pushed away from the navmesh).
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它是路径和navmesh无关的，代理可能被推离navmesh。这意味着你需要考虑这种可能性（以及这种情况可能发生的频率，例如，如果你的地图有墙壁边界，那么角色不能被推离navmesh）。
- en: If you want RVO working on non-character actors, then you will need to reimplement
    the RVO algorithm on your own (or adapt your actors to use the Character Movement
    Component).
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想让RVO在非角色演员上工作，那么你需要自己重新实现RVO算法（或者调整你的演员以使用角色移动组件）。
- en: RVO might not work well if there are many characters in a very confined space
    (e.g. non-realistic behavior, such as lateral sliding).
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在非常拥挤的空间中有许多角色（例如，非现实的行为，如横向滑动），RVO可能工作得不好。
- en: If the Avoidance Consideration Radius is high and the character needs to position
    itself among other characters, the position might be difficult for the character
    (and thus lead to strange, weird, and unnatural behaviors).
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果避障考虑半径很高，并且角色需要在其他角色之间定位自己，那么位置可能对角色来说很困难（从而可能导致奇怪、古怪和不自然的行为）。
- en: RVO is very fast, even with many characters running RVO at the same level. In
    fact, the overhead cost is almost nothing if there are no obstacles, so by using
    an appropriate Avoidance Consideration Radius, many characters can be handled
    without any issues.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RVO非常快，即使有多个角色在同一级别运行RVO。事实上，如果没有障碍物，开销成本几乎可以忽略不计，因此通过使用适当的避障考虑半径，可以处理许多角色而不会出现任何问题。
- en: You can implement the father of the RVO algorithm, the VO, which is RVO but
    without weighting. It is even faster if performance is really a concern, but realism
    will decrease. You can gather more information on this by taking a look at the
    references in the next section. For instance, by modifying the avoidance manager
    in the source code of the engine, you will be able to easily implement this algorithm
    (or anything else of your choice).
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以实现 RVO 算法的鼻祖，即 VO，它是 RVO 但没有加权。如果性能真的是一个关注点，它甚至可以更快，但现实感会降低。你可以通过查看下一节的参考文献来获取更多关于此的信息。例如，通过修改引擎源代码中的避免管理器，你将能够轻松实现此算法（或任何你选择的其他算法）。
- en: RVO resources
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RVO 资源
- en: 'The following are some further RVO resources you can have a look at:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些你可以查看的进一步 RVO 资源：
- en: 'The original RVO paper is available at the following link: [http://gamma.cs.unc.edu/RVO/icra2008.pdf](http://gamma.cs.unc.edu/RVO/icra2008.pdf)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始的 RVO 论文可在以下链接找到：[http://gamma.cs.unc.edu/RVO/icra2008.pdf](http://gamma.cs.unc.edu/RVO/icra2008.pdf)
- en: 'More information about RVO from the creators: [http://gamma.cs.unc.edu/RVO](http://gamma.cs.unc.edu/RVO)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 RVO 的更多信息，请参阅创作者的网站：[http://gamma.cs.unc.edu/RVO](http://gamma.cs.unc.edu/RVO)
- en: 'RVO version 2 (the version that''s implemented within Unreal engine): [http://gamma.cs.unc.edu/RVO2/](http://gamma.cs.unc.edu/RVO2/)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RVO 版本 2（在 Unreal 引擎中实现版本）：[http://gamma.cs.unc.edu/RVO2/](http://gamma.cs.unc.edu/RVO2/)
- en: Detour Crowd
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Detour Crowd
- en: Another built-in Unreal system is the ***Detour Crowd***. It is based on the
    *Recats Library*, and in contrast to RVO, it will take into consideration the
    Navmesh on which the agents are moving. The system works pretty much out of the
    box already, but, let's dig deep into how it works and how we can use it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个内置的 Unreal 系统是 ***Detour Crowd***。它基于 *Recats Library*，与 RVO 相比，它将考虑代理移动的
    Navmesh。该系统已经几乎可以直接使用，但让我们深入了解它是如何工作的以及我们如何使用它。
- en: How the Detour Crowd system works
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Detour Crowd 系统的工作原理
- en: Within your Game World exists an object called **DetourCrowdManager**. It is
    responsible for coordinating crowds in your game. In particular, an agent that
    is registered to the **DetourCrowdManager** will be taken into consideration.
    The **DetourCrowdManager** accepts anything that implements the **ICrowdAgentInterface**,
    which provides data to the Manager about the agent.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的游戏世界中存在一个名为 **DetourCrowdManager** 的对象。它负责协调游戏中的群体。特别是，注册到 **DetourCrowdManager**
    的代理将被考虑在内。**DetourCrowdManager** 接受任何实现了 **ICrowdAgentInterface** 的内容，该接口为 Manager
    提供有关代理的数据。
- en: Actually, under the hood, the *Detour Crowd Manager* is using the Detour Crowd
    algorithm that was developed by *Mikko Mononen* in the *Recast Library*, which
    has been slightly modified by Epic Games for their needs. Therefore, the Detour
    Crowd Component offers an interface between the *Unreal Framework* and the *Recast
    Detour*. You can find more information about this by reviewing the resources at
    the end of this section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在底层，*Detour Crowd Manager* 使用的是由 *Mikko Mononen* 在 *Recast Library* 中开发的
    Detour Crowd 算法，Epic Games 为其需求进行了轻微修改。因此，Detour Crowd Component 为 *Unreal Framework*
    和 *Recast Detour* 提供了一个接口。你可以通过查看本节末尾的资源来获取更多关于此的信息。
- en: Potentially, you can create an agent by implementing the **ICrowdAgentInterface**.
    However, Unreal provides you with a special component called **UCrowdFollowingComponent**,
    which implements the **ICrowdAgentInterface**, along with other functionalities.
    As a result, anything that has the **UCrowdFollowingComponent** is eligible to
    be an agent with the Crowd Manager. Actually, the component itself will auto-register
    itself to the Crowd Manager and will activate the *Detour Behaviour*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有潜力通过实现 **ICrowdAgentInterface** 来创建代理。然而，Unreal 为你提供了一个名为 **UCrowdFollowingComponent**
    的特殊组件，该组件实现了 **ICrowdAgentInterface**，以及其他功能。因此，任何具有 **UCrowdFollowingComponent**
    的内容都有资格成为具有群体管理器的代理。实际上，该组件将自动将自己注册到群体管理器并激活 *Detour Behaviour*。
- en: To make things easier, the **ADetourCrowdAIController** is a pre-made controller
    that will automatically add the **UCrowdFollowingComponent** to the controller
    itself. Hence, this time, the system is triggered by the AI Controller from the
    **Character Movement Component** directly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更简单，**ADetourCrowdAIController** 是一个预制的控制器，它将自动将 **UCrowdFollowingComponent**
    添加到控制器本身。因此，这次，系统是由 **Character Movement Component** 的 AI 控制器直接触发的。
- en: 'The following diagram helps explain this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表有助于解释这一点：
- en: '![](img/ace7f5ee-2899-442d-aee4-ffd57beb66bf.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ace7f5ee-2899-442d-aee4-ffd57beb66bf.png)'
- en: Using the Detour Crowd system
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Detour Crowd 系统
- en: 'The easiest way to use the *Detour Crowd* system is by letting your AI controller
    inheriting from the Detour Crowd AI Controller, as shown in the following screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*Detour Crowd*系统的最简单方法是让您的AI控制器继承自Detour Crowd AI Controller，如下面的截图所示：
- en: '![](img/dce536e2-243b-4ed3-aaa2-da50d8d9b7a6.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dce536e2-243b-4ed3-aaa2-da50d8d9b7a6.png)'
- en: In C++, you will need to inherit from **ADetourCrowdAIController **(or add the
    ***UDetourCrowdFollowingComponent*** to your controller).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，您需要继承自**ADetourCrowdAIController**（或向您的控制器添加**UDetourCrowdFollowingComponent**）。
- en: Once you have done this for all the controllers that you want to use the *Detour
    Crowd*, the system will pretty much work out of the box.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您为所有想要使用*Detour Crowd*的控制器完成设置，系统将基本上能够直接工作。
- en: Detour Crowd settings
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Detour Crowd设置
- en: If you are using the **UCrowdFollowingComponent**, this component will implement
    the **ICrowdAgentInterface** by using the **Avoidance Settings** in the **Character
    Movement Component** (if one is available).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用**UCrowdFollowingComponent**，则该组件将通过在**Character Movement Component**（如果可用）中使用**避免设置**来实现**ICrowdAgentInterface**。
- en: 'As a result, all the **Avoidance Settings** we saw in the *RVO* section will
    be taken into consideration by the *Detour Crowd*. Therefore, all of the settings
    that are highlighted in the following screenshot will still be valid for our AI
    Character:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在*RVO*部分看到的所有**避免设置**都将被*Detour Crowd*考虑。因此，以下截图中所突出显示的所有设置仍然适用于我们的AI角色：
- en: '![](img/48a1a4c1-fc4b-42a3-9881-3535c05cbbac.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/48a1a4c1-fc4b-42a3-9881-3535c05cbbac.png)'
- en: Please note that the **Avoidance Weight** will not be taken into consideration
    by the Detour System since it is an *RVO*-specific parameter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，**避免权重**将不会被Detour系统考虑，因为它是一个*RVO*特定的参数。
- en: Consequently, all the blueprint functions we have seen (e.g. to change the group
    mask) are also valid.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们之前看到的所有蓝图函数（例如，更改组掩码）也都是有效的。
- en: 'These were specific settings on a per-character basis, but it is possible to
    tweak the overall *Detour Crowd settings*. To do this, navigate into the **Project
    Settings**, and under the **Engine** section, you will find an entry called **Crowd
    Manager**, as shown in the following screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是针对每个角色的特定设置，但您可以调整整体的*Detour Crowd设置*。为此，导航到**项目设置**，在**引擎**部分，您将找到一个名为**Crowd
    Manager**的条目，如下面的截图所示：
- en: '![](img/9679dcc6-72ea-4e63-b614-5da06ba8b31e.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9679dcc6-72ea-4e63-b614-5da06ba8b31e.png)'
- en: 'From here, we have access to all the ***Detour Crowd Manager settings***. Most
    of these settings are from the original *Recast Crowd algorithm*, and the *Unreal
    Detour Crowd Manager* offers an interface where you can set these variables in
    the algorithm. Let''s start from the easier ones:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以访问所有的***Detour Crowd Manager设置***。这些设置中的大多数来自原始的*Recast Crowd算法*，而*Unreal
    Detour Crowd Manager*提供了一个接口，您可以在算法中设置这些变量。让我们从简单的开始：
- en: '**Max Agents**: This is the maximum number of agents that the Crowd Manager
    will handle. Of course, the higher the number, the more agents you can place at
    once, but this will hit performance. You should plan how many agents your game
    needs carefully. Moreover, if you look at the source code, this number will be
    used to allocate the memory that''s necessary for the Crowd Manager to handle
    the agents. This is useful to keep in mind in situations in which memory is low.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大代理数**: 这是Crowd Manager将处理的代理的最大数量。当然，数字越高，您可以一次放置的代理就越多，但这会影响性能。您应该仔细规划游戏所需的代理数量。此外，如果您查看源代码，这个数字将用于为Crowd
    Manager处理代理分配必要的内存。在内存较低的情况下，这一点值得注意。'
- en: '**Max Agent Radius**: This is the maximum size that an agent that has detoured
    from the Crowd Manager can go.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大代理半径**: 这是从Crowd Manager偏离的代理可以到达的最大尺寸。'
- en: '**Max Avoided Agents**: This is the maximum number of agents that the Detour
    System takes into consideration, and it also called neighbors. In other words,
    this specifies how many neighbor agents (maximum) should be taken into account
    for the avoidance behavior.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大避免代理数**: 这是Detour系统考虑的最大代理数量，也称为邻居。换句话说，这指定了应该考虑多少个邻居代理（最大）以进行避免行为。'
- en: '**Max Avoided Walls**: This is the maximum number of walls (in general, obstacle
    segments) that the Detour System should take into consideration. It works in a
    similar fashion to Max Avoided Agents, but asks about how many segments of the
    surrounding obstacles around the system need to be taken into account.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大避免墙壁数**：这是Detour系统应考虑的最大墙壁数（通常，障碍物段）。它的工作方式与最大避免智能体类似，但询问系统周围周围障碍物的多少段需要考虑。'
- en: '**Navmesh Check Interval**: This is for implementing how many seconds an agent
    that has gone off the navmesh should check and recalculate its position (the system
    will try to push the agent back onto the navmesh).'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Navmesh检查间隔**：这是实现智能体离开navmesh后应该检查和重新计算其位置多少秒的设置（系统将尝试将智能体推回navmesh）。'
- en: '**Path Optimization Interval**: This checks, in seconds, how often an agent
    should try to re-optimize its own path.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路径优化间隔**：这是检查智能体应该多久尝试重新优化其路径的设置（以秒为单位）。'
- en: '**Separation Dir Clamp**: When another agent is behind, this value indicates
    the clamp separation force to left/right (dot product between *forward* and *dirToNei;* thus,
    a value of -1 means that this separation behavior is disabled).'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分离方向限制**：当另一个智能体在后面时，此值表示向左/右的夹紧分离力（*forward*与*dirToNei*的点积；因此，-1的值表示此分离行为被禁用）。'
- en: '**Path Offset Radius Multiplier**: When the agent is turning close to a corner,
    an offset to the path is applied. This variable is a multiplier to this offset
    (so that you are free to reduce and increase this offset).'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路径偏移半径乘数**：当智能体接近角落转弯时，会对路径应用偏移。这个变量是这个偏移的乘数（这样您可以自由地增加或减少这个偏移）。'
- en: '**Resolve Collisions**: Despite the best efforts of the Detour System, agents
    may still collide. In such an event, the collision should be handled by the Detour
    System (with a value of true for this variable). In this case, this variable is
    set to false and the agents will be using a Character Movement Component. This
    component will take care of resolving the collision.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决碰撞**：尽管Detour系统尽了最大努力，智能体仍然可能会发生碰撞。在这种情况下，碰撞应由Detour系统处理（此变量的值为true）。在这种情况下，此变量设置为false，智能体将使用Character
    Movement组件。这个组件将负责解决碰撞。'
- en: 'The **Avoidance Config** parameter, which is shown in the following screenshot,
    is the heart of how sampling is done within the Detour Crowd Algorithm:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个屏幕截图中显示的**避免配置**参数是Detour人群算法中采样如何进行的核心：
- en: '![](img/a132e02e-9383-4844-b0c3-3aa648b324bf.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a132e02e-9383-4844-b0c3-3aa648b324bf.png)'
- en: '**Avoidance Config** is an array of different sampling configurations, with
    slightly different parameters set. By default, there are four of them, corresponding
    to different sampling avoidance quality: low, medium, good, and high, respectively.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免配置**是一个不同采样配置的数组，参数略有不同。默认情况下，有四个，分别对应不同的采样避免质量：低、中、好和高。'
- en: The quality level is set in the **UCrowdFollowingComponent** with the **AvoidanceQuality**
    variable, which uses the **ECrowdAvoidanceQuality** enum. If you have a reference
    to your **UCrowdFollowingComponent**, you can use the `SetCrowdAvoidanceQuality()`
    function.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 质量级别是在**UCrowdFollowingComponent**中的**AvoidanceQuality**变量中设置的，该变量使用**ECrowdAvoidanceQuality**枚举。如果您有对您的**UCrowdFollowingComponent**的引用，您可以使用`SetCrowdAvoidanceQuality()`函数。
- en: Going back to the setting, if you want to add or remove a configuration, you
    will need to create your own version of the **UCrowdFollowingComponent** (alternatively,
    you can inherit from it and override functions), which takes into consideration
    a different number of configurations.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到设置，如果您想添加或删除配置，您需要创建自己的**UCrowdFollowingComponent**版本（或者，您可以继承它并重写函数），这将考虑不同数量的配置。
- en: However, changing the number of configuration means that your game/application
    is making particular use of the *Detour System*!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，改变配置的数量意味着您的游戏/应用程序正在特别使用*Detour系统*！
- en: 'Without changing the number of configurations, you can change the settings
    of these four quality configurations. These parameters are shown in the following
    screenshot (this is from the first configuration):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在不改变配置数量的情况下，您可以更改这四个质量配置的设置。这些参数在以下屏幕截图中显示（这是第一个配置）：
- en: '![](img/694621a2-55ad-4a41-a1b1-58aedc32f82d.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/694621a2-55ad-4a41-a1b1-58aedc32f82d.png)'
- en: To fully understand these settings, you should get to know how the algorithm
    works, but let's try and get our head around it without this.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全理解这些设置，您应该了解算法是如何工作的，但让我们在没有这个的情况下尝试理解它。
- en: 'The part of the algorithm that does the sampling starts by creating a set of
    rings (the number is indicated in the **Adaptive Rings** parameter) around the
    center point (where the agent is initially, with a bias, due to the **Velocity
    Bias** parameter, in the direction of the velocity). Each of these rings is sampled
    (divided) by **Adaptive Division**. Then, the algorithm recursively refines the
    search by using a smaller set of rings, which are centered on the best sample
    of the previous iteration. The algorithm repeats this process **Adaptive Depth**
    times. At each iteration, the best sample is chosen by considering the following,
    and the different parameters determine the weight (how important the consideration
    is with respect to the others):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 算法中执行采样的部分首先在中心点（代理最初的位置，由于**Velocity Bias**参数的偏差，在速度方向上）周围创建一组环形（环形数量由**Adaptive
    Rings**参数指示）。这些环形中的每一个都通过**Adaptive Division**进行采样（分割）。然后，算法通过使用较小的一组环形，这些环形以上一迭代中最佳样本为中心，递归地细化搜索。算法重复此过程**Adaptive
    Depth**次。在每次迭代中，通过考虑以下因素并选择最佳样本，不同的参数确定权重（相对于其他因素的重要性）：
- en: Does the direction of the agent match the current velocity? The weight is **DesiredVelocityWeight**.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理的方向是否与当前速度匹配？其权重为**DesiredVelocityWeight**。
- en: Does the agent go sideways? The weight is **SideBiasWeight**.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理是否向侧面移动？其权重为**SideBiasWeight**。
- en: Does the agent collide with any known obstacle? The weight is **ImpactTimeWeight**
    (it scans a range by considering the current velocity of the agent if it collides
    using that velocity within **ImpactTimeRange** seconds).
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理是否与任何已知障碍物发生碰撞？其权重为**ImpactTimeWeight**（如果代理在**ImpactTimeRange**秒内使用该速度发生碰撞，它将扫描一个范围，考虑代理的当前速度）。
- en: 'The following diagram should help you understand the different parameters:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表应有助于你理解不同的参数：
- en: '![](img/cb115d43-0ae0-40b4-b1ce-0a47d1a8dee4.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb115d43-0ae0-40b4-b1ce-0a47d1a8dee4.png)'
- en: Debugging the Detour Crowd Manager
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试Detour Crowd Manager
- en: The Crowd Manager has an integration with the visual logger, which means that,
    with some work, we can visually debug the Detour Crowd Manager. We will explore
    this in more detail in [Chapter 13](a8cbf52e-71e1-4f9d-a2bd-913a1e8bd8e1.xhtml), *Gameplay
    Debugger*, in which we will learn more about the Visual Logger further.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Crowd Manager与可视化记录器集成了，这意味着，通过一些工作，我们可以可视化地调试Detour Crowd Manager。我们将在第13章[Chapter
    13](a8cbf52e-71e1-4f9d-a2bd-913a1e8bd8e1.xhtml)，*游戏调试器*中更详细地探讨这一点，我们将了解更多关于可视化记录器的信息。
- en: More crowd resources
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多人群资源
- en: 'Here some resources if you want to extend your knowledge of the Detour Crowd
    Algorithm and/or explore other alternatives:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想扩展你对Detour Crowd Algorithm的了解或探索其他替代方案，以下是一些资源：
- en: 'Mikko Mononen''s original Recast Library: [https://github.com/recastnavigation/recastnavigation](https://github.com/recastnavigation/recastnavigation)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mikko Mononen的原始Recast Library：[https://github.com/recastnavigation/recastnavigation](https://github.com/recastnavigation/recastnavigation)
- en: 'A collection of many interesting research algorithms for handling crowds: [http://gamma.cs.unc.edu/research/crowds](http://gamma.cs.unc.edu/research/crowds)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列处理人群的有趣研究算法：[http://gamma.cs.unc.edu/research/crowds](http://gamma.cs.unc.edu/research/crowds)
- en: Of course, you are welcome to keep exploring on your own!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以继续自己探索！
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how the Unreal Engine handles crowds. In particular,
    we have seen two built-in systems. The first one is called ***Reciprocal Velocity
    Obstacles (RVO)***, which is very fast, but not very precise. The second is the
    **Detour Crowd**, which is a bit more expensive, but more precise and realistic.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了Unreal Engine如何处理人群。特别是，我们看到了两个内置系统。第一个被称为**互易速度障碍（RVO）**，它非常快，但不是很精确。第二个是**Detour
    Crowd**，它稍微昂贵一些，但更精确和逼真。
- en: In the next chapter, we will move on and learn how to implement our own *Behavior
    Tree* from scratch.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续学习如何从头开始实现自己的*行为树*。
