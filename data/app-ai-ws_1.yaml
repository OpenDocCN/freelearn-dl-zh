- en: 1\. Introduction to Artificial Intelligence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 人工智能简介
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will be introduced to the fundamentals of Artificial Intelligence
    (AI), which are the foundations of various fields of AI. You will also come across
    different algorithms, including MinMax and A*, through simple coding exercises
    using the Python programming language. You will also be implementing your first
    AI through a simple tic-tac-toe game where you will be teaching the program how
    to win against a human player. By the end of this chapter, you will learn how
    to use popular Python libraries to develop intelligent AI-driven programs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向你介绍人工智能（AI）的基础知识，这些知识是各种人工智能领域的基础。你还将通过简单的编码练习使用Python编程语言接触不同的算法，包括MinMax和A*。你还将通过一个简单的井字棋游戏实现你的第一个人工智能程序，在这个游戏中，你将教会程序如何击败人类玩家。到本章结束时，你将学会如何使用流行的Python库开发智能的人工智能驱动程序。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Before discussing the different AI techniques and algorithms, we will look at
    the fundamentals of AI and machine learning and go through a few basic definitions.
    Real-world examples will be used to present the basic concepts of AI in an easy-to-digest
    way.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论不同的人工智能技术和算法之前，我们将先了解人工智能和机器学习的基础知识，并介绍一些基本定义。将通过现实世界的例子以易于理解的方式呈现人工智能的基本概念。
- en: AI attempts to replicate human intelligence using hardware and software solutions.
    It is based on reverse engineering. For example, artificial neural networks are
    modeled after the way the human brain works. Beyond neural networks, there are
    many other models in neuroscience that can be used to solve real-world problems
    using AI. Companies that are known to be using AI in their fields include Google,
    with Google Translate, Apple, with Face ID, Amazon, with its Alexa products, and
    even Uber and Tesla, who are still working on building self-driving cars.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能尝试使用硬件和软件解决方案复制人类智能。它基于逆向工程。例如，人工神经网络是模拟人类大脑工作方式的模型。除了神经网络之外，神经科学中还有许多其他模型可以用来通过人工智能解决现实世界的问题。已知在各自领域中使用人工智能的公司包括：谷歌（Google），提供Google翻译；苹果（Apple），提供Face
    ID；亚马逊（Amazon），提供Alexa产品；甚至Uber和特斯拉（Tesla），他们仍在致力于开发自动驾驶汽车。
- en: On the other hand, machine learning is a term that is often confused with AI.
    It originates from the 1950s and was first defined by Arthur Lee Samuel in 1959.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，机器学习是一个常常与人工智能混淆的术语。它起源于1950年代，并由阿瑟·李·塞缪尔（Arthur Lee Samuel）于1959年首次定义。
- en: 'In his book called *Machine Learning*, Tom Mitchell proposed a simple definition
    of it: "*The field of machine learning is concerned with the question of how to
    construct computer programs that automatically improve with experience.*"'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的书《*机器学习*》中，汤姆·米切尔提出了一个简单的定义：“*机器学习领域关注的是如何构建能够随着经验自动改进的计算机程序。*”
- en: We can understand this as machine learning being the field where the goal is
    to build a computer program capable of learning patterns from data and improve
    its learning ability with more data.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以理解为，机器学习是一个领域，目标是构建一个能够从数据中学习模式并随着更多数据的增加而提高学习能力的计算机程序。
- en: He also proposed a more formal definition, which is that a computer program
    is said to learn from experience, **E**, with respect to a task, **T**, and a
    performance measure, **P**, if its performance on **T**, as measured by **P**,
    improves with experience, **E**. This can be translated as what a computer program
    requires in order for it to be learning. We can see **E** (the experience) as
    the data that needs to be fed to the machine, **T**, as the type of decision that
    the machine needs to perform, and **P** as the measure of its performance.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 他还提出了一个更正式的定义，即计算机程序如果在任务**T**上，通过性能度量**P**衡量后，其在**T**上的表现随着经验**E**的积累而改进，那么可以说它在从经验中学习。这可以转化为计算机程序需要什么才能被认为是在学习。我们可以将**E**（经验）理解为需要输入给机器的数据，**T**作为机器需要执行的决策类型，而**P**则是衡量其表现的标准。
- en: From these two definitions, we can conclude that machine learning is one way
    to achieve AI. However, you can have AI without machine learning. For instance,
    if you hardcode rules and decision trees, or you apply search techniques, you
    can create an AI agent, even though your approach has little to do with machine
    learning.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从这两个定义中，我们可以得出结论：机器学习是实现人工智能的一种方式。然而，你也可以不使用机器学习就拥有人工智能。例如，如果你硬编码规则和决策树，或者应用搜索技术，你仍然可以创建一个人工智能代理，尽管你的方法与机器学习关系不大。
- en: AI and machine learning have helped the scientific community harness the explosion
    of big data with more and more data being created every second. With AI and machine
    learning, scientists can extract information that human eyes cannot process fast
    enough on these huge datasets.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能和机器学习帮助科学界应对大数据的爆炸性增长，每秒钟都会生成越来越多的数据。通过人工智能和机器学习，科学家们可以从这些庞大的数据集中提取人眼无法快速处理的信息。
- en: Now that we have been introduced to AI and machine learning, let's focus on
    AI.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了人工智能和机器学习，接下来让我们聚焦于人工智能。
- en: How Does AI Solve Problems?
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 人工智能如何解决问题？
- en: '*AI automates human intelligence based on the way a human brain processes information.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*人工智能根据人类大脑处理信息的方式来自动化人类智能。*'
- en: Whenever we solve a problem or interact with people, we go through a process.
    By doing this, we limit the scope of a problem or interaction. This process can
    often be modeled and automated in AI.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们解决问题或与他人互动时，我们都会经历一个过程。通过这样做，我们限制了问题或互动的范围。这个过程通常可以在人工智能中建模并自动化。
- en: '*AI makes computers appear to think like humans.*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*人工智能使计算机看起来像人类一样思考。*'
- en: Sometimes, it feels like the AI knows what we need. Just think about the personalized
    coupons you receive after shopping online. AI knows which product we will most
    likely be purchasing. Machines are able to learn your preferences through the
    implementation of different techniques and models, which we will look at later
    in this book.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，感觉人工智能知道我们需要什么。只需想想你在网上购物后收到的个性化优惠券。人工智能知道我们最可能购买的产品。通过实施不同的技术和模型，机器能够学习你的偏好，我们将在本书后面讨论这些内容。
- en: '*AI is performed by computers that are executing low-level instructions.*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*人工智能是由执行低级指令的计算机实现的。*'
- en: Even though a solution may appear to be intelligent, we write code, just like
    with any other software solution in AI. Even if we are simulating neurons, simple
    machine code and computer hardware executes the *thinking* process.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 即使一个解决方案看起来似乎很智能，我们仍然编写代码，就像在任何其他人工智能软件解决方案中一样。即使我们在模拟神经元，简单的机器代码和计算机硬件也执行着*思维*过程。
- en: Most AI applications have one primary objective. When we interact with an AI
    application, it seems human-like because it can restrict a problem domain to a
    primary objective. Therefore, the process whereby the AI reaches the objective
    can be broken down into smaller and simpler low-level instructions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人工智能应用都有一个主要目标。当我们与一个人工智能应用互动时，它看起来像人类，因为它能够将问题领域限制在一个主要目标上。因此，人工智能实现目标的过程可以被分解为更小、更简单的低级指令。
- en: '*AI may stimulate human senses and thinking processes for specialized fields.*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*人工智能可能会刺激人类感官和思维过程，应用于专业领域。*'
- en: You must be able to simulate human senses and thoughts, and sometimes trick
    AI into believing that we are interacting with another human. In some special
    cases, we can even enhance our own senses.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须能够模拟人类的感官和思维，有时甚至要欺骗人工智能相信我们正在与另一个人互动。在某些特殊情况下，我们甚至可以增强我们自己的感官。
- en: Similarly, when we interact with a chatbot, for instance, we expect the bot
    to understand us. We expect the chatbot or even a voice recognition system to
    provide a computer-human interface that fulfills our expectations. In order to
    meet these expectations, computers need to emulate human thought processes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当我们与聊天机器人互动时，我们希望机器人能理解我们。我们期望聊天机器人甚至语音识别系统提供一个计算机与人类之间的接口，满足我们的期望。为了满足这些期望，计算机需要模拟人类的思维过程。
- en: Diversity of Disciplines in AI
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 人工智能中的学科多样性
- en: A self-driving car that cannot sense other cars driving on the same highway
    would be incredibly dangerous. The AI agent needs to process and sense what is
    around it in order to drive the car. However, this is not enough since, without
    understanding the physics of moving objects, driving the car in a normal environment
    would be an almost impossible, not to mention deadly, task.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一辆无法感知高速公路上其他行驶的车辆的自动驾驶汽车将非常危险。人工智能代理需要处理并感知周围的环境才能驾驶汽车。然而，这还不够，因为如果没有理解运动物体的物理学，在正常环境中驾驶汽车几乎是不可能的，更不用说可能是致命的任务了。
- en: 'In order to create a usable AI solution, different disciplines are involved,
    such as the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个可用的人工智能解决方案，涉及不同的学科，例如：
- en: '**Robotics**: To move objects in space'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机器人学**：在空间中移动物体'
- en: '**Algorithm theory**: To construct efficient algorithms'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算法理论**：构建高效的算法'
- en: '**Statistics**: To derive useful results, predict the future, and analyze the
    past'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统计学**：推导有用的结果、预测未来并分析过去'
- en: '**Psychology**: To model how the human brain works'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**心理学**：模拟人类大脑的工作方式'
- en: '**Software engineering**: To create maintainable solutions that endure the
    test of time'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件工程**：创建可维护的解决方案，能够经受住时间的考验'
- en: '**Computer science or computer programming**: To implement our software solutions
    in practice'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算机科学或计算机编程**：在实践中实现我们的软件解决方案'
- en: '**Mathematics**: To perform complex mathematical operations'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数学**：执行复杂的数学运算'
- en: '**Control theory**: To create feed-forward and feedback systems'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制理论**：创建前馈和反馈系统'
- en: '**Information theory**: To represent, encode, decode, and compress information'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息理论**：表示、编码、解码和压缩信息'
- en: '**Graph theory**: To model and optimize different points in space and to represent
    hierarchies'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图论**：对空间中的不同点进行建模与优化，并表示层次结构'
- en: '**Physics**: To model the real world'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理学**：对现实世界进行建模'
- en: '**Computer graphics and image processing**: To display and process images and
    movies'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算机图形学和图像处理**：显示和处理图像与电影'
- en: In this book, we will cover a few of these disciplines, including algorithm
    theory, statistics, computer science, mathematics, and image processing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将介绍这些学科中的一些内容，包括算法理论、统计学、计算机科学、数学和图像处理。
- en: Fields and Applications of AI
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AI的领域与应用
- en: Now that we have been introduced to AI, let's move on and see its application
    in real life.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了AI的基本概念，让我们继续看看它在现实生活中的应用。
- en: Simulation of Human Behavior
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 人类行为的模拟
- en: 'Humans have five basic senses that can be divided into visual (seeing), auditory
    (listening), kinesthetic (moving), olfactory (smelling), and gustatory (tasting).
    However, for the purposes of understanding how to create intelligent machines,
    we can separate these disciplines as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 人类有五种基本感官，可以分为视觉（看）、听觉（听）、运动觉（动）、嗅觉（闻）和味觉（尝）。然而，为了理解如何创建智能机器，我们可以将这些学科分开如下：
- en: Listening and speaking
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 听力和口语
- en: Understanding language
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解语言
- en: Remembering things
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记忆事物
- en: Thinking
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 思维
- en: Seeing
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视觉
- en: Moving
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运动
- en: 'A few of these are out of scope for us because the purpose of this chapter
    is to understand the fundamentals. In order to move a robot arm, for instance,
    we would have to study complex university-level math to understand what''s going
    on, but we will only be sticking to the practical aspects in this book:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些超出了我们讨论的范围，因为本章的目的是理解基础知识。例如，要移动机器臂，我们必须学习复杂的大学数学才能理解其原理，但在本书中，我们将仅关注实际应用：
- en: '**Listening and speaking**: Using a speech recognition system, AI can collect
    information from a user. Using speech synthesis, it can turn internal data into
    understandable sounds. Speech recognition and speech synthesis techniques deal
    with the recognition and construction of human sounds that are emitted or that
    humans can understand.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**听力和口语**：通过语音识别系统，AI可以从用户处收集信息。利用语音合成，AI可以将内部数据转化为可理解的声音。语音识别和语音合成技术处理的是人类发出的声音或人类能够理解的声音的识别与构建。'
- en: For instance, imagine you are on a trip to a country where you don't speak the
    local language. You can speak into the microphone of your phone, expect it to
    *understand* what you say, and then translate it into the other language. The
    same can happen in reverse with the locals speaking and AI translating the sounds
    into a language you understand. Speech recognition and speech synthesis make this
    possible.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，假设你正在前往一个你不懂当地语言的国家旅行。你可以对着手机的麦克风说话，期望它能够*理解*你所说的内容，然后将其翻译成另一种语言。相反，当当地人说话时，AI也可以将声音翻译成你能理解的语言。语音识别和语音合成使得这一切成为可能。
- en: Note
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: An example of speech synthesis is Google Translate. You can navigate to [https://translate.google.com/](https://translate.google.com/)
    and make the translator speak words in a non-English language by clicking the
    loudspeaker button below the translated word.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 语音合成的一个例子是谷歌翻译。你可以访问[https://translate.google.com/](https://translate.google.com/)，通过点击翻译后的单词下方的扬声器按钮，让翻译器朗读非英语的单词。
- en: '**Understanding language**: We can understand natural language by processing
    it. This field is called natural language processing, or NLP.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解语言**：我们可以通过处理自然语言来理解它。这个领域被称为自然语言处理（NLP）。'
- en: When it comes to NLP, we tend to learn languages based on statistical learning
    by learning the statistical relationship between syllables.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在NLP（自然语言处理）领域，我们往往通过学习音节之间的统计关系来学习语言。
- en: '**Remembering things**: We need to represent things we know about the world.
    This is where creating knowledge bases and hierarchical representations called
    **ontologies** comes into play. Ontologies categorize things and ideas in our
    world and contain relations between these categories.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记忆**：我们需要表示我们对世界的了解。这就是创建知识库和分层表示（称为**本体论**）的作用。本体论对我们世界中的事物和观念进行分类，并包含这些类别之间的关系。'
- en: '**Thinking**: Our AI system has to be an expert in a certain domain by using
    an expert system. An expert system can be based on mathematical logic in a deterministic
    way, as well as in a fuzzy, non-deterministic way.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**思考**：我们的人工智能系统必须通过使用专家系统成为某一领域的专家。专家系统可以基于数学逻辑以确定性方式进行构建，也可以以模糊的、非确定性的方式进行构建。'
- en: The knowledge base of an expert system is represented using different techniques.
    As the problem domain grows, we create hierarchical ontologies.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 专家系统的知识库使用不同的技术表示。随着问题领域的扩大，我们创建了分层的本体论。
- en: We can replicate this structure by modeling the network on the building blocks
    of the brain. These building blocks are called neurons, and the network itself
    is called a neural network.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过将网络建模为大脑的构建模块来复制这个结构。这些构建模块称为神经元，而网络本身称为神经网络。
- en: '**Seeing**: We have to interact with the real world through our senses. We
    have only touched upon auditory senses so far, in regard to speech recognition
    and synthesis. What if we had to see things? If that was the case, we would have
    to create computer vision techniques to learn about our environment. After all,
    recognizing faces is useful, and most humans are experts at that.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视觉**：我们必须通过感官与现实世界互动。到目前为止，我们仅触及了听觉感官，涉及语音识别和合成。那么如果我们需要看东西呢？如果是这样，我们就必须创建计算机视觉技术来了解我们的环境。毕竟，识别面孔是有用的，而且大多数人类在这方面都是专家。'
- en: Computer vision depends on image processing. Although image processing is not
    directly an AI discipline, it is a required discipline for AI.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算机视觉依赖于图像处理。尽管图像处理本身不是直接的人工智能学科，但它是人工智能所需的学科。
- en: '**Moving**: Moving and touching are natural to us humans, but they are very
    complex tasks for computers. Moving is handled by robotics. This is a very math-heavy
    topic.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运动**：运动和触摸对我们人类来说是自然的，但对计算机来说却是非常复杂的任务。运动由机器人技术处理。这是一个非常需要数学的课题。'
- en: Robotics is based on control theory, where you create a feedback loop and control
    the movement of your object based on the feedback gathered. Control theory has
    applications in other fields that have absolutely nothing to do with moving objects
    in space. This is because the feedback loops that are required are similar to
    those modeled in economics.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 机器人技术基于控制理论，您需要创建一个反馈回路，并根据收集到的反馈控制物体的运动。控制理论在其他领域也有应用，这些领域与空间中的物体运动完全无关。这是因为所需的反馈回路与经济学中建模的反馈回路相似。
- en: Simulating Intelligence – the Turing Test
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟智能——图灵测试
- en: Alan Turing, inventor of the Turing machine, an abstract concept that's used
    in algorithm theory, suggested a way to test intelligence. This test is referred
    to as the **Turing test** in AI literature.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 艾伦·图灵，图灵机的发明者，图灵机是算法理论中使用的一个抽象概念，他提出了一种测试智能的方法。这个测试在人工智能文献中被称为**图灵测试**。
- en: Using a text interface, an interrogator chats to a human and a chatbot. The
    job of the chatbot is to mislead the interrogator to the extent that they cannot
    tell whether the computer is human.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文本接口，提问者与人类和聊天机器人进行对话。聊天机器人的任务是误导提问者，使其无法分辨计算机是否是人类。
- en: What Disciplines Do We Need to Pass the Turing Test?
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们需要哪些学科才能通过图灵测试？
- en: First, we need to understand a spoken language to know what the interrogator
    is saying. We do this by using **Natural Language Processing** (**NLP**). We also
    must respond to the interrogator in a credible way by learning from previous questions
    and answers using AI models.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要理解口语语言，以了解提问者在说什么。我们通过使用**自然语言处理**（**NLP**）来实现这一点。我们还必须通过学习之前的问题和答案，并使用AI模型以可信的方式回应提问者。
- en: We need to be an expert of things that the human mind tends to be interested
    in. We need to build an expert system of humanity, involving the taxonomy of objects
    and abstract thoughts in our world, as well as historical events and even emotions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要成为人类大脑倾向于感兴趣的事物的专家。我们需要建立一个人类学的专家系统，涉及我们世界中的物体和抽象思想的分类法，以及历史事件甚至情感。
- en: Passing the Turing test is very hard. Current predictions suggest we won't be
    able to create a system good enough to pass the Turing test until the late 2020s.
    Pushing this even further, if this is not enough, we can advance to the Total
    Turing Test, which also includes movement and vision.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过图灵测试非常困难。目前的预测表明，我们在2020年代末之前无法创建足够好的系统通过图灵测试。如果这还不够，我们可以进一步推进到完全图灵测试，它还包括运动和视觉。
- en: Next, we will move on and look at the tools and learning models in AI.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续讨论人工智能中的工具和学习模型。
- en: AI Tools and Learning Models
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工智能工具与学习模型
- en: In the previous sections, we discovered the fundamentals of AI. One of the core
    tasks of AI is learning. This is where intelligent agents come into the picture.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们发现了人工智能的基础知识。人工智能的核心任务之一是学习。这就是智能体出现的地方。
- en: Intelligent Agents
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 智能体
- en: When solving AI problems, we create an actor in the environment that can gather
    data from its surroundings and influence its surroundings. This actor is called
    an **intelligent agent**.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决人工智能问题时，我们在环境中创建一个能够从周围环境收集数据并影响其环境的行为者。这个行为者被称为**智能体**。
- en: 'An intelligent agent is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个智能体如下所示：
- en: Is autonomous
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是自主的
- en: Observes its surroundings through sensors
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过传感器观察其周围环境
- en: Acts in its environment using actuators (which are the components that are responsible
    for moving and controlling a mechanism)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过执行器在其环境中行动（执行器是负责移动和控制机制的组件）
- en: Directs its activities toward achieving goals
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其活动指向实现目标
- en: Agents may also learn and have access to a knowledge base.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 智能体还可以学习并访问知识库。
- en: We can think of an agent as a function that maps perceptions to actions. If
    the agent has an internal knowledge base, then perceptions, actions, and reactions
    may alter the knowledge base as well.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将智能体看作是一个将感知映射到行动的函数。如果智能体有一个内部知识库，那么感知、行动和反应也可能会改变知识库。
- en: Actions may be rewarded or punished. Setting up a correct goal and implementing
    a carrot and stick situation helps the agent learn. If goals are set up correctly,
    agents have a chance of beating the often more complex human brain. This is because
    the primary goal of the human brain is survival, regardless of the game we are
    playing. An agent's primary motive is reaching the goal itself. Therefore, intelligent
    agents do not get embarrassed when making a random move without any knowledge.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 行动可能会得到奖励或惩罚。设定正确的目标并实施胡萝卜与大棒的策略有助于智能体学习。如果目标设定正确，智能体有机会战胜通常更复杂的人脑。这是因为人脑的主要目标是生存，不论我们在玩什么游戏。智能体的主要动机是达成目标。因此，智能体在没有任何知识的情况下做出随机动作时，并不会感到尴尬。
- en: The Role of Python in AI
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python在人工智能中的作用
- en: 'In order to put basic AI concepts into practice, we need a programming language
    that supports AI. In this book, we have chosen Python. There are a few reasons
    why Python is such a good choice for AI:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将基本的人工智能概念付诸实践，我们需要一种支持人工智能的编程语言。在本书中，我们选择了Python。有几个原因使得Python成为人工智能的良好选择：
- en: '**Convenience and Compatibility:** Python is a high-level programming language.
    This means that you don''t have to worry about memory allocation, pointers, or
    machine code in general. You can write code in a convenient fashion and rely on
    Python''s robustness. Python is also cross-platform compatible.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**便捷性与兼容性：** Python是一种高级编程语言。这意味着你无需担心内存分配、指针或机器代码等问题。你可以便捷地编写代码，并依赖Python的强大功能。Python也具有跨平台兼容性。'
- en: '**Popularity:** The strong emphasis on developer experience makes Python a
    very popular choice among software developers. In fact, according to a 2018 developer
    survey by [https://www.hackerrank.com](https://www.hackerrank.com), across all
    ages, Python ranks as the number one preferred language of software developers.
    This is because Python is easily readable and simple. Therefore, Python is great
    for rapid application development.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流行度：** 强调开发者体验使得Python成为软件开发人员的热门选择。事实上，根据[https://www.hackerrank.com](https://www.hackerrank.com)的2018年开发者调查，Python在所有年龄段的软件开发人员中，都是最受欢迎的编程语言。这是因为Python易于阅读且简单。因此，Python非常适合快速应用开发。'
- en: '**Efficiency:** Despite being an interpreted language, Python is comparable
    to other languages that are used in data science, such as R. Its main advantage
    is memory efficiency, since Python can handle large, in-memory databases.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率：** 尽管Python是一种解释型语言，但它与数据科学中使用的其他语言，如R，具有可比性。其主要优势在于内存效率，因为Python能够处理大型内存数据库。'
- en: Note
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Python is a multi-purpose language. It can be used to create desktop applications,
    database applications, mobile applications, and games. The network programming
    features of Python are also worth mentioning. Furthermore, Python is an excellent
    prototyping tool.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Python 是一种多用途语言。它可以用于创建桌面应用、数据库应用、移动应用和游戏。Python 的网络编程功能也值得一提。此外，Python 是一个优秀的原型设计工具。
- en: Why Is Python Dominant in Machine Learning, Data Science, and AI?
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么 Python 在机器学习、数据科学和人工智能中占主导地位？
- en: To understand the dominant nature of Python in machine learning, data science,
    and AI, we have to compare Python to other languages that are also used in these
    fields.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 Python 在机器学习、数据科学和人工智能领域的主导地位，我们必须将 Python 与其他在这些领域也有应用的语言进行比较。
- en: Compared to R, which is a programming language built for statisticians, Python
    is much more versatile and easy as it allows programmers to build a diverse range
    of applications, from games to AI applications.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 相比于 R 这种为统计学家设计的编程语言，Python 更加多功能和简便，因为它允许程序员构建各种各样的应用，从游戏到人工智能应用。
- en: Compared to Java and C++, writing programs in Python is significantly faster.
    Python also provides a high degree of flexibility.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Java 和 C++ 相比，使用 Python 编写程序的速度要快得多。Python 还提供了高度的灵活性。
- en: 'There are some languages that are similar in nature when it comes to flexibility
    and convenience: Ruby and JavaScript. Python has an advantage over these languages
    because of the AI ecosystem that''s available for Python. In any field, open source,
    third-party library support vastly determines the success of that language. Python''s
    third-party AI library support is excellent.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些语言在灵活性和便利性方面与 Python 类似：Ruby 和 JavaScript。Python 相对于这些语言有优势，因为 Python 拥有一个强大的人工智能生态系统。在任何领域，开源的第三方库支持在很大程度上决定了该语言的成功。Python
    的第三方 AI 库支持非常出色。
- en: Anaconda in Python
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 中的 Anaconda
- en: We installed Anaconda in the *Preface*. Anaconda will be our number one tool
    when it comes to experimenting with AI.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*前言*中安装了 Anaconda。Anaconda 将是我们进行 AI 实验时的首选工具。
- en: Anaconda comes with packages, IDEs, data visualization libraries, and high-performance
    tools for parallel computing in one place. Anaconda hides configuration problems
    and the complexity of maintaining a stack for data science, machine learning,
    and AI. This feature is especially useful in Windows, where version mismatches
    and configuration problems tend to arise the most.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Anaconda 附带了包、IDE、数据可视化库和高性能并行计算工具，所有这些功能都集中在一个地方。Anaconda 隐藏了配置问题和维护数据科学、机器学习与
    AI 堆栈的复杂性。这个特点在 Windows 系统中特别有用，因为在 Windows 中，版本不匹配和配置问题往往最为常见。
- en: Anaconda comes with Jupyter Notebook, where you can write code and comments
    in a documentation style. When you experiment with AI features, the flow of your
    ideas resembles an interactive tutorial where you run each step of your code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Anaconda 附带了 Jupyter Notebook，你可以在其中以文档样式编写代码和注释。当你实验 AI 特性时，代码的执行步骤像是一个互动式教程，你可以逐步运行每个代码片段。
- en: Note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**IDE** stands for **Integrated Development Environment**. While a text editor
    provides some functionalities to highlight and format code, an IDE goes beyond
    the features of text editors by providing tools to automatically refactor, test,
    debug, package, run, and deploy code.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**IDE** 代表 **集成开发环境**。文本编辑器提供了一些高亮和格式化代码的功能，而 IDE 在文本编辑器的基础上提供了更多功能，包括自动重构、测试、调试、打包、运行和部署代码的工具。'
- en: Python Libraries for AI
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 的人工智能库
- en: 'The list of libraries presented here is not complete as there are more than
    700 available in Anaconda. However, these specific ones will get you off to a
    good start because they will give you a good foundation to be able to implement
    the fundamental AI algorithms in Python:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出的库并不完整，因为 Anaconda 中可用的库超过 700 个。然而，这些特定的库会为你打下一个良好的基础，因为它们能帮助你在 Python
    中实现基本的 AI 算法：
- en: '**NumPy**: NumPy is a computing library for Python. As Python does not come
    with a built-in array data structure, we have to use a library to model vectors
    and matrices efficiently. In data science, we need these data structures to perform
    simple mathematical operations. We will use NumPy extensively in future chapters.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NumPy**：NumPy 是 Python 的一个计算库。由于 Python 本身没有内置数组数据结构，我们必须使用库来高效地表示向量和矩阵。在数据科学中，我们需要这些数据结构来执行简单的数学运算。在未来的章节中，我们将广泛使用
    NumPy。'
- en: '**SciPy**: SciPy is an advanced library containing algorithms that are used
    for data science. It is a great complementary library to NumPy because it gives
    you all the advanced algorithms you need, whether it be a linear algebra algorithm,
    image processing tool, or a matrix operation.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SciPy**：SciPy 是一个包含用于数据科学的算法的高级库。它是 NumPy 的一个很好的补充库，因为它提供了你需要的所有高级算法，无论是线性代数算法、图像处理工具，还是矩阵操作。'
- en: '**pandas**: pandas provides fast, flexible, and expressive data structures,
    such as one-dimensional series and two-dimensional DataFrames. It efficiently
    loads, formats, and handles complex tables of different types.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pandas**：pandas 提供了快速、灵活且富有表现力的数据结构，如一维序列和二维 DataFrame。它高效地加载、格式化和处理不同类型的复杂表格数据。'
- en: '**scikit-learn**: scikit-learn is Python''s main machine learning library.
    It is based on the NumPy and SciPy libraries. scikit-learn provides you with the
    functionality required to perform both classification and regression, data preprocessing,
    as well as supervised and unsupervised learning.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**scikit-learn**：scikit-learn 是 Python 主要的机器学习库，基于 NumPy 和 SciPy 库。scikit-learn
    提供了执行分类、回归、数据预处理以及监督和非监督学习所需的功能。'
- en: '**NLTK**: We will not deal with NLP in this book, but NLTK is still worth mentioning
    because this library is the main natural language toolkit of Python. You can perform
    classification, tokenization, stemming, tagging, parsing, semantic reasoning,
    and many other operations using this library.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NLTK**：本书不会涉及自然语言处理（NLP），但 NLTK 值得一提，因为它是 Python 的主要自然语言工具包。你可以使用这个库执行分类、分词、词干提取、标注、解析、语义推理等多种操作。'
- en: '**TensorFlow**: TensorFlow is Google''s neural network library, and it is perfect
    for implementing deep learning AI. The flexible core of TensorFlow can be used
    to solve a vast variety of numerical computation problems. Some real-world applications
    of TensorFlow include Google voice recognition and object identification.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TensorFlow**：TensorFlow 是 Google 的神经网络库，非常适合实现深度学习 AI。TensorFlow 的灵活核心可以用来解决各种数值计算问题。TensorFlow
    的一些现实应用包括 Google 语音识别和物体识别。'
- en: A Brief Introduction to the NumPy Library
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NumPy 库简要介绍
- en: The NumPy library will play a major role in this book, so it is worth exploring
    it further.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 库在本书中将发挥重要作用，因此值得深入探讨。
- en: 'After launching your Jupyter Notebook, you can simply import `numpy` as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Jupyter Notebook 后，你可以简单地按如下方式导入 `numpy`：
- en: '[PRE0]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once `numpy` has been imported, you can access it using its alias, `np`. NumPy
    contains the efficient implementation of some data structures, such as vectors
    and matrices.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦导入了 `numpy`，你可以通过它的别名 `np` 来访问它。NumPy 包含了高效实现的一些数据结构，如向量和矩阵。
- en: 'Let''s see how we can define vectors and matrices:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何定义向量和矩阵：
- en: '[PRE1]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The expected output is this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出是这样的：
- en: '[PRE2]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can declare a matrix using the following syntax:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下语法声明一个矩阵：
- en: '[PRE3]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The expected output is this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出是这样的：
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `array` method creates an array data structure, while `.mat` creates a matrix.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`array` 方法创建一个数组数据结构，而 `.mat` 创建一个矩阵。'
- en: 'We can perform many operations with matrices. These include addition, subtraction,
    and multiplication. Let''s have a look at these operations here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对矩阵执行许多操作，包括加法、减法和乘法。我们来看看这些操作：
- en: 'Addition in matrices:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵中的加法：
- en: '[PRE5]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The expected output is this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出是这样的：
- en: '[PRE6]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Subtraction in matrices:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵中的减法：
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The expected output is this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出是这样的：
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Multiplication in matrices:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵中的乘法：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The expected output is this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出是这样的：
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Matrix addition and subtraction work cell by cell.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的加法和减法按单元逐个进行。
- en: 'Matrix multiplication works according to linear algebra rules. To calculate
    matrix multiplication manually, you have to align the two matrices, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵乘法遵循线性代数规则。要手动计算矩阵乘法，你需要将两个矩阵对齐，具体如下：
- en: '![Figure 1.1: Multiplication calculation with two matrices'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.1：两个矩阵的乘法计算'
- en: '](img/B16060_01_01.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_01.jpg)'
- en: 'Figure 1.1: Multiplication calculation with two matrices'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：两个矩阵的乘法计算
- en: To get the *(i,j)*th element of the matrix, you compute the dot (scalar) product
    on the *i*th row of the matrix with the *j*th column. The scalar product of two
    vectors is the sum of the product of their corresponding coordinates.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取矩阵的 *(i,j)* 元素，你需要计算矩阵第 *i* 行与第 *j* 列的点积（标量积）。两个向量的标量积是它们对应坐标的乘积之和。
- en: 'Another frequent matrix operation is the determinant of the matrix. The determinant
    is a number associated with square matrices. Calculating the determinant using
    NumPy''s `linalg` function (linear algebra algorithms) can be seen in the following
    line of code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的矩阵运算是矩阵的行列式。行列式是与方阵相关的一个数字。使用 NumPy 的 `linalg` 函数（线性代数算法）计算行列式的代码如下所示：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The expected output is this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下所示：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Technically, the determinant can be calculated as `1*3 – 2*3 = -3`. Notice that
    NumPy calculates the determinant using floating-point arithmetic, so the accuracy
    of the result is not perfect. The error is due to the way floating points are
    represented in most programming languages.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，行列式可以计算为 `1*3 – 2*3 = -3`。请注意，NumPy 使用浮点运算来计算行列式，因此结果的准确性并不完美。误差是由于大多数编程语言中浮点数表示的方式造成的。
- en: 'We can also transpose a matrix, as shown in the following line of code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以转置一个矩阵，如以下代码所示：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The expected output is this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下所示：
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When calculating the transpose of a matrix, we flip its values over its main
    diagonal.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 计算矩阵的转置时，我们将其值翻转至主对角线的位置。
- en: NumPy has many other important features, so we will use it in most of the chapters
    in this book.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 还有许多其他重要的功能，因此我们将在本书的大部分章节中使用它。
- en: 'Exercise 1.01: Matrix Operations Using NumPy'
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.01：使用 NumPy 进行矩阵运算
- en: We will be using Jupyter Notebook and the following matrix to solve this exercise.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Jupyter Notebook 和以下矩阵来解决这个练习。
- en: 'We will calculate the square of the matrix, which is determinant of the matrix
    and the transpose of the matrix shown in the following figure, using NumPy:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将计算矩阵的平方，即矩阵的行列式和矩阵的转置，如下图所示，使用 NumPy：
- en: '![Figure 1.2: A simple matrix representation'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.2：一个简单的矩阵表示](img/B16060_01_02.jpg)'
- en: '](img/B16060_01_02.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_02.jpg)'
- en: 'Figure 1.2: A simple matrix representation'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2：一个简单的矩阵表示
- en: 'The following steps will help you to complete this exercise:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: Open a new Jupyter Notebook file.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Jupyter Notebook 文件。
- en: 'Import the `numpy` library as `np`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `numpy` 库并命名为 `np`：
- en: '[PRE15]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a two-dimensional array called `A` for storing the `[[1,2,3],[4,5,6],[7,8,9]]`
    matrix using `np.mat`:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `np.mat` 创建一个名为 `A` 的二维数组，用于存储 `[[1,2,3],[4,5,6],[7,8,9]]` 矩阵：
- en: '[PRE16]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The expected output is this:'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下所示：
- en: '[PRE17]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: If you have created an `np.array` instead of `np.mat`, the solution for the
    array multiplication will be incorrect.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您创建的是 `np.array` 而非 `np.mat`，则数组乘法的结果将不正确。
- en: 'Next, we perform matrix multiplication using the asterisk and save the result
    in a variable called `matmult`, as shown in the following code snippet:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用星号进行矩阵乘法，并将结果保存在一个名为 `matmult` 的变量中，如以下代码片段所示：
- en: '[PRE18]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The expected output is this:'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下所示：
- en: '[PRE19]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, manually calculate the square of `A` by performing matrix multiplication.
    For instance, the top-left element of the matrix is calculated as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过进行矩阵乘法手动计算 `A` 的平方。例如，矩阵的左上角元素的计算方式如下：
- en: '[PRE20]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The expected output is this:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下所示：
- en: '[PRE21]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Use `np.linalg.det` to calculate the determinant of the matrix and save the
    result in a variable called `det`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `np.linalg.det` 计算矩阵的行列式，并将结果保存在名为 `det` 的变量中：
- en: '[PRE22]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The expected output (might vary slightly) is this:'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出（可能会略有不同）如下所示：
- en: '[PRE23]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Use `np.matrix.transpose` to get the transpose of the matrix and save the result
    in a variable called `transpose`:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `np.matrix.transpose` 获取矩阵的转置，并将结果保存在名为 `transpose` 的变量中：
- en: '[PRE24]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The expected output is this:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下所示：
- en: '[PRE25]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If `T` is the transpose of matrix `A`, then `T[j][i]` is equal to `A[i][j]`.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 `T` 是矩阵 `A` 的转置，那么 `T[j][i]` 等于 `A[i][j]`。
- en: Note
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/316Vd6Z](https://packt.live/316Vd6Z).
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 若要访问该部分的源代码，请参阅 [https://packt.live/316Vd6Z](https://packt.live/316Vd6Z)。
- en: You can also run this example online at [https://packt.live/2BrogHL](https://packt.live/2BrogHL).
    You must execute the entire Notebook in order to get the desired result.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您也可以在网上运行此示例，访问 [https://packt.live/2BrogHL](https://packt.live/2BrogHL)。您必须执行整个
    Notebook 以获得预期结果。
- en: By completing this exercise, you have seen that NumPy comes with many useful
    features for vectors, matrices, and other mathematical structures.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此练习后，您已经看到 NumPy 提供了许多用于向量、矩阵和其他数学结构的有用功能。
- en: In the upcoming section, we will be implementing AI in an interesting tic-tac-toe
    game using Python.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将使用 Python 实现一个有趣的井字游戏 AI。
- en: Python for Game AI
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏 AI 的 Python 实现
- en: 'An AI game player is nothing but an intelligent agent with a clear goal: to
    win the game and defeat all the other players. AI experiments have achieved surprising
    results when it comes to games. Today, no human can defeat an AI in the game of
    chess.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: AI游戏玩家其实就是一个有明确目标的智能代理：赢得游戏并击败所有其他玩家。AI实验在游戏方面取得了惊人的结果。今天，没有人类能够在国际象棋游戏中击败AI。
- en: The game *Go* was the last game where human players could consistently defeat
    a computer player. However, in 2017, Google's game-playing AI called AlphaGo defeated
    the world number 1 ranked Go player.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*围棋*曾是最后一个人类玩家能够持续击败电脑玩家的游戏。然而，在2017年，谷歌的围棋AI AlphaGo击败了世界排名第一的围棋选手。'
- en: Intelligent Agents in Games
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏中的智能代理
- en: An intelligent agent plays according to the rules of the game. The agent can
    sense the current state of the game through its sensors and can evaluate the potential
    steps. Once the agent finds the best possible step, it performs the action using
    its actuators. The agent finds the best possible action to reach the goal based
    on the information it has. Actions are either rewarded or punished. The carrot
    and stick are excellent examples of rewards and punishment. Imagine a donkey in
    front of your cart. You put a carrot in front of the eyes of the donkey, so the
    animal starts walking toward it. As soon as the donkey stops, the rider may apply
    punishment with a stick. This is not a human way of moving, but rewards and punishment
    control living organisms to some extent. The same happens to humans at school,
    at work, and in everyday life as well. Instead of carrots and sticks, we have
    income and legal punishment to shape our behavior.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 智能代理根据游戏规则进行操作。代理可以通过其传感器感知当前游戏状态，并评估潜在的步骤。一旦代理找到最好的步骤，它就会通过执行器执行该动作。代理根据它拥有的信息找到最佳的动作以达到目标。动作会获得奖励或惩罚。胡萝卜和大棒就是奖励和惩罚的典型例子。想象一下，在你的小车前面有一只驴。你把胡萝卜放在驴眼前，于是它开始朝着胡萝卜走去。只要驴停下来，骑手可能就会用大棒惩罚它。这并不是人类的移动方式，但奖励和惩罚在某种程度上控制了生物体的行为。人类在学校、工作和日常生活中也会面临同样的情况。我们没有胡萝卜和大棒，而是通过收入和法律惩罚来塑造我们的行为。
- en: In most games, a good sequence of actions results in a reward. When a human
    player feels rewarded, that makes the human feel happy. Humans tend to act in
    a way that maximizes their happiness. Intelligent agents, on the other hand, are
    only interested in their goal, which is to maximize their reward and minimize
    the punishment that's affecting their performance score.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数游戏中，一系列好的动作会导致奖励。当人类玩家感到被奖励时，会感到快乐。人类倾向于采取最大化自己幸福的方式行动。而智能代理则只关心自己的目标，即最大化奖励并最小化影响其表现的惩罚。
- en: When modeling games, we must determine their state space. An action causes a
    state transition. When we explore the consequences of all possible actions, we
    get a decision tree. This tree goes deeper as we start exploring the possible
    future actions of all players until the game ends.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在建模游戏时，我们必须确定它们的状态空间。一个动作会导致状态转变。当我们探索所有可能动作的后果时，我们得到一个决策树。随着我们开始探索所有玩家未来可能的动作，这棵树会变得更深，直到游戏结束。
- en: The strength of AI is the execution of millions of possible steps each second.
    Therefore, game AI often boils down to a search exercise. When exploring all of
    the possible sequences of moves in a game, we get the state tree of a game.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: AI的优势在于每秒可以执行数百万种可能的步骤。因此，游戏AI通常归结为一次搜索练习。在探索游戏中所有可能的棋步序列时，我们得到一个游戏的状态树。
- en: Consider a chess AI. What is the problem with evaluating all possible moves
    by building a state tree consisting of all of the possible sequences of moves?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 试想一下一个国际象棋AI。通过构建一个包含所有可能棋步序列的状态树来评估所有可能的棋步，问题在哪里？
- en: Chess is an EXPTIME game complexity-wise. The number of possible moves explodes
    combinatorically.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 国际象棋是一个在复杂度上属于EXPTIME级别的游戏。可能的棋步数以组合方式爆炸式增长。
- en: 'White starts with 20 possible moves: the eight pawns may move either one or
    two steps, and the two knights may move either up-up-left, or up-up-right. Then,
    black can make any of these 20 moves. There are already 20*20 = 400 possible combinations
    after just one move per player.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 白方开始时有20种可能的走法：8个兵可以走一步或两步，2匹马可以走“上-上-左”或“上-上-右”。然后，黑方可以做这20种走法中的任何一种。仅仅每个玩家走一步，就已经有20*20
    = 400种可能的组合。
- en: After the second move, we get 8,902 possible board constellations, and this
    number just keeps on growing. Just take seven moves, and you have to search through
    10,921,506 possible constellations.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步之后，我们得到了 8,902 种可能的棋盘排列，这个数字不断增长。只需要七步，你就得搜索 10,921,506 种可能的排列。
- en: The average length of a chess game is approximately 40 moves. Some exceptional
    games take more than 200 moves to finish.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一局棋的平均长度大约是 40 步。有些特别的游戏可能需要超过 200 步才能结束。
- en: As a consequence, the computer player simply does not have time to explore the
    whole state space. Therefore, the search activity has to be guided with proper
    rewards, punishment, and simplifications of the rules.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，计算机玩家根本没有足够的时间去探索整个状态空间。因此，搜索活动必须通过适当的奖励、惩罚和规则简化来引导。
- en: Breadth First Search and Depth First Search
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 广度优先搜索和深度优先搜索
- en: 'Creating a game AI is often a search exercise. Therefore, we need to be familiar
    with the two primary search techniques:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 创建游戏 AI 通常是一个搜索过程。因此，我们需要熟悉两种主要的搜索技术：
- en: '**Breadth First Search** (**BFS**)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广度优先搜索**（**BFS**）'
- en: '**Depth First Search** (**DFS**)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度优先搜索**（**DFS**）'
- en: These search techniques are applied on a directed rooted tree.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这些搜索技术应用于有向根树。
- en: 'A tree is a data structure that has **nodes**, and **edges** connecting these
    nodes in such a way that any two nodes of the tree are connected by exactly one
    path. Have a look at the following figure:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 树是一种数据结构，它有**节点**和**边**，这些节点通过边连接在一起，使得树中任意两个节点之间正好有一条路径相连。请看下图：
- en: '![Figure 1.3: A directed rooted tree'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.3：有向根树'
- en: '](img/B16060_01_03.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_03.jpg)'
- en: 'Figure 1.3: A directed rooted tree'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3：有向根树
- en: When the tree is rooted, there is a special node in the tree called the **root**,
    which is where we begin our traversal. A directed tree is a tree where the edges
    may only be traversed in one direction. Nodes may be internal nodes or leaves.
    **Internal nodes** have at least one edge, through which we can leave the node.
    A **leaf** has no edges pointing out from the node.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当树被根植时，树中有一个特殊的节点，称为**根节点**，这是我们开始遍历的地方。一个有向树是指树的边只能单向遍历。节点可以是内部节点或叶节点。**内部节点**至少有一条边，通过这条边我们可以离开该节点。**叶节点**没有任何指向外部的边。
- en: In AI search, the root of the tree is the starting state. We traverse from this
    state by generating the successor nodes of the search tree. Search techniques
    differ, depending on the order in which we visit these successor nodes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AI 搜索中，树的根节点是起始状态。我们从这个状态开始，生成搜索树的后继节点并进行遍历。搜索技术的不同，取决于我们访问这些后继节点的顺序。
- en: Breadth First Search (BFS)
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 广度优先搜索（BFS）
- en: 'BFS is a search technique that, starting from the root node (node 1), will
    start exploring the closest node on the same depth (or level) before moving to
    the next depth:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: BFS 是一种搜索技术，它从根节点（节点 1）开始，首先探索同一深度（或层级）上最靠近的节点，然后再移动到下一个深度：
- en: '![Figure 1.4: A BFS tree'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4：广度优先搜索（BFS）树'
- en: '](img/B16060_01_04.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_04.jpg)'
- en: 'Figure 1.4: A BFS tree'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4：广度优先搜索（BFS）树
- en: In the preceding figure, you can see the search order of the BFS technique.
    Starting from the root node (`1`), BFS will go to the next level and explore the
    closest node (`2`) before looking at the other nodes on the same level (`3` and
    `4`). Then, it will move to the next level and explore `5` and `6` as they are
    close to each other before going back through to node `3`, finishing on the last
    node (`7`), and so on.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，你可以看到 BFS 技术的搜索顺序。从根节点（`1`）开始，BFS 会移动到下一层，并探索最接近的节点（`2`），然后再查看同一层上的其他节点（`3`
    和 `4`）。接着，它会移动到下一层，探索 `5` 和 `6`，因为它们彼此接近，然后回到节点 `3`，最后到达节点 `7`，以此类推。
- en: Depth First Search (DFS)
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深度优先搜索（DFS）
- en: 'DFS is a search technique that, starting from the root node (node 1), will
    start exploring the same branch as much as possible before moving to the next
    closest branch:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: DFS 是一种搜索技术，它从根节点（节点 1）开始，尽可能多地探索同一分支，然后再移动到下一个最接近的分支：
- en: '![Figure 1.5: A DFS tree'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.5：深度优先搜索（DFS）树'
- en: '](img/B16060_01_05.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_05.jpg)'
- en: 'Figure 1.5: A DFS tree'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5：深度优先搜索（DFS）树
- en: In the preceding figure, you can see the search order of the DFS technique.
    Starting from the root node (`1`), DFS will go to the closest node (`2`) and explore
    all the way to the end of the branch (`3`) on the third depth before going back
    to the node (`2`) and finish by exploring its second branch (`4`). Then, it will
    move back to the second depth and start the same process with the next branch
    (`6`) before finishing with the last branch (`7`).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图示中，你可以看到DFS技术的搜索顺序。从根节点（`1`）开始，DFS会转到最接近的节点（`2`），并在第三层深度探索到分支的尽头（`3`），然后回到节点（`2`），完成探索它的第二个分支（`4`）。接着，它将返回到第二层深度并以相同的方式开始下一分支（`6`），最终完成最后一个分支（`7`）。
- en: 'Now, suppose we have a tree defined by its root and a function that generates
    all the successor nodes from the root. In the following example, each node has
    a value and a depth. We start from `1` and may either increase the value by `1`
    or `2`. Our goal is to reach the value `5`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有一个由根节点定义的树，并且有一个函数从根节点生成所有后继节点。在以下示例中，每个节点都有一个值和深度。我们从`1`开始，可能将值增加`1`或`2`。我们的目标是达到值`5`：
- en: Note
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE26]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding code snippet, we have initialized the root node as having
    a value and depth of `1`. Then, we created a function called `succ` that takes
    a node as input. This function will have 3 different cases:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将根节点初始化为值和深度为`1`。然后，我们创建了一个名为`succ`的函数，该函数以一个节点为输入。这个函数有三种不同的情况：
- en: If the input node value is `5`, then return nothing as we will have already
    reached our goal (`5`).
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入的节点值是`5`，则不返回任何内容，因为我们已经达到了目标（`5`）。
- en: If the input node value is `4`, then return the value `5` and add `1` to the
    current depth.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入节点值为`4`，则返回值`5`并将当前深度加`1`。
- en: If the value is anything else, then add `1` to the depth and create two cases
    for the value, `+1` and `+2`.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果值是其他任何内容，则将深度加`1`，并为该值创建两个情况，`+1`和`+2`。
- en: 'First, we will perform BFS, as shown here:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将执行BFS，如下所示：
- en: '[PRE27]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding code snippet, we have implemented the `bfs_tree` function
    by taking a node as input. This function can be broken down into three parts:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们通过将一个节点作为输入实现了`bfs_tree`函数。这个函数可以分为三部分：
- en: The `nodes_to_visit` and `visited_nodes` variables.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`nodes_to_visit`和`visited_nodes`变量。'
- en: 'The **second part** is where BFS is implemented:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二部分**是实现BFS的地方：'
- en: The `current_node` variable takes away the first element of the `nodes_to_visit`
    variable.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current_node`变量从`nodes_to_visit`变量中取出第一个元素。'
- en: The `visited_nodes` variable adds this element to its list.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`visited_nodes`变量将此元素添加到它的列表中。'
- en: The `nodes_to_visit` variable adds the newly generated nodes from the call of
    `succ` with the `current_node` as input to it.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nodes_to_visit`变量将通过调用`succ`函数并以`current_node`作为输入生成的新节点添加到其中。'
- en: The preceding three instructions are wrapped into a loop defined by the number
    of elements inside the `nodes_to_visit` variable. As long as `nodes_to_visit`
    has at least one element, then the loop will keep going.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的三条指令被包装成一个由`nodes_to_visit`变量中元素数量定义的循环。只要`nodes_to_visit`中至少有一个元素，循环就会继续进行。
- en: The `visited_nodes` variable.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`visited_nodes`变量。'
- en: 'The expected output is this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 期望的输出是这样的：
- en: '[PRE28]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, BFS is searching through the values of the same depth before
    moving to the next level of depth and exploring the values of it. Notice how depth
    and value are increasing in sequence. This will not be the case in DFS.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，BFS在深入到下一个深度层级之前，先在当前深度层级中遍历所有值，并且可以看到深度和数值是按顺序递增的。DFS则不如此。
- en: 'If we had to traverse a graph instead of a directed rooted tree, BFS would
    look different: whenever we visit a node, we would have to check whether the node
    had been visited before. If the node had been visited before, we would simply
    ignore it.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要遍历一个图而不是一个有向根树，BFS将有所不同：每当我们访问一个节点时，我们需要检查该节点是否已经访问过。如果该节点已访问过，我们将直接忽略它。
- en: In this chapter, we will only use Breadth First Traversal on trees. DFS is surprisingly
    similar to BFS. The difference between DFS and BFS is the sequence in which you
    access the nodes. While BFS visits all the children of a node before visiting
    any other nodes, DFS digs deep into the tree.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将仅在树上使用广度优先遍历（BFS）。深度优先遍历（DFS）与BFS非常相似。DFS和BFS的区别在于访问节点的顺序。BFS会在访问其他节点之前先访问一个节点的所有子节点，而DFS则深入树的深层。
- en: 'Have a look at the following example, where we''re implementing DFS:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下示例，在其中我们实现了DFS：
- en: '[PRE29]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding code snippet, we have implemented the `dfs_tree` function
    by taking a node as input. This function can be broken down into three parts:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们通过将一个节点作为输入实现了 `dfs_tree` 函数。该函数可以分为三部分：
- en: The `nodes_to_visit` and `visited_nodes` variables.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`nodes_to_visit` 和 `visited_nodes` 变量。'
- en: 'The **second part** is where DFS is implemented:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二部分**是实现 DFS 的地方：'
- en: The `current_node` variable takes away the last element of the `nodes_to_visit`
    variable.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current_node` 变量移除 `nodes_to_visit` 变量中的最后一个元素。'
- en: The `visited_nodes` variable adds this element to its list.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`visited_nodes` 变量将此元素添加到其列表中。'
- en: The `nodes_to_visit` variable adds the newly generated nodes from the call of
    `succ` with `current_node` as input to it.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nodes_to_visit` 变量将通过调用 `succ` 函数并将 `current_node` 作为输入生成的新节点添加到其中。'
- en: The preceding three instructions are wrapped into a loop defined by the number
    of elements inside the `nodes_to_visit` variable. As long as `nodes_to_visit`
    has at least one element, then the loop will keep going.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的三条指令被封装在一个循环中，循环的次数由 `nodes_to_visit` 变量中的元素个数决定。只要 `nodes_to_visit` 至少有一个元素，循环就会继续进行。
- en: At the end, that is at the `visited_nodes`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，也就是在 `visited_nodes` 中。
- en: As you can see, the main difference between BFS and DFS is the order in which
    we took an element out of `nodes_to_visit`. For BFS, we take the first element,
    whereas for DFS, we take the last one.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，BFS 和 DFS 之间的主要区别在于我们从 `nodes_to_visit` 中取出元素的顺序。对于 BFS，我们取第一个元素，而对于 DFS，我们取最后一个元素。
- en: 'The expected output is this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出是这样的：
- en: '[PRE30]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice how the DFS algorithm digs deep fast (the depth reaches higher values
    faster than BFS). It does not necessarily find the shortest path first, but it
    is guaranteed to find a leaf before exploring a second path.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 DFS 算法如何快速深入（深度比 BFS 更快地达到更高的值）。它不一定先找到最短路径，但可以保证在探索第二条路径之前先找到一个叶子节点。
- en: In game AI, the BFS algorithm is often better for the evaluation of game states
    because DFS may get lost. Imagine starting a chess game, where a DFS algorithm
    may easily get lost in exploring the options for a move.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏 AI 中，BFS 算法通常更适合评估游戏状态，因为 DFS 可能会迷失。想象一下，开始一场国际象棋游戏，DFS 算法可能会轻易迷失在探索走法选项中。
- en: Exploring the State Space of a Game
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索游戏的状态空间
- en: 'Let''s explore the state space of a simple game: tic-tac-toe. A state space
    is the set of all possible configurations of a game, which, in this case, means
    all the possible moves.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一个简单游戏的状态空间：井字游戏。状态空间是指游戏中所有可能的配置，在这种情况下，意味着所有可能的移动。
- en: In tic-tac-toe, a 3x3 game board is given. Two players play this game. One plays
    with the sign X, while the other plays with the sign O. X starts the game, and
    each player makes a move after the other. The goal of the game is to get three
    of your own signs horizontally, vertically, or diagonally.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在井字游戏中，给定一个 3x3 的棋盘。两个玩家玩这个游戏。一个玩家使用标记 X，另一个玩家使用标记 O。X 先开始游戏，之后两名玩家轮流进行移动。游戏的目标是横向、纵向或对角线排列三个自己的标记。
- en: 'Let''s denote the cells of the tic-tac-toe board, as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式表示井字游戏棋盘的单元格：
- en: '![Figure 1.6: Tic-tac-toe board'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.6：井字游戏棋盘'
- en: '](img/B16060_01_06.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_06.jpg)'
- en: 'Figure 1.6: Tic-tac-toe board'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6：井字游戏棋盘
- en: 'In the following example, `X` started at position `1`. `O` retaliated at position
    `5`, `X` made a move at position `9`, and then `O` moved to position `3`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`X` 从位置 `1` 开始。`O` 在位置 `5` 反击，`X` 在位置 `9` 移动，然后 `O` 移动到位置 `3`：
- en: '![Figure 1.7: Tic-tac-toe board with noughts and crosses'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.7：井字游戏棋盘，标记为圈和叉'
- en: '](img/B16060_01_07.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_07.jpg)'
- en: 'Figure 1.7: Tic-tac-toe board with noughts and crosses'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7：井字游戏棋盘，标记为圈和叉
- en: This was a mistake by the second player, because now `X` is forced to place
    a sign on cell `7`, creating two future scenarios for winning the game. It does
    not matter whether `O` defends by moving to cell `4` or `8` – `X` will win the
    game by selecting the other unoccupied cell.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二个玩家的错误，因为现在 `X` 被迫将标记放在单元格 `7` 上，创造了两种未来的赢得比赛的情景。无论 `O` 是否通过移动到单元格 `4` 或
    `8` 来防守——`X` 都会通过选择另一个未占用的单元格赢得比赛。
- en: Note
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can try out the game at [http://www.half-real.net/tictactoe/](http://www.half-real.net/tictactoe/).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [http://www.half-real.net/tictactoe/](http://www.half-real.net/tictactoe/)
    尝试这个游戏。
- en: For simplicity, we will only explore the state space belonging to the cases
    when the AI player starts. We will start with an AI player who plays randomly,
    placing a sign in an empty cell. After playing with this AI player, we will create
    a complete decision tree. Once we generate all possible game states, you will
    experience their combinatorial explosion. As our goal is to make these complexities
    simple, we will use several different techniques to make the AI player smarter
    and reduce the size of the decision tree.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们将只探讨AI玩家先手时的状态空间。我们将从一个随机下棋的AI玩家开始，它会在空白格子中随机放置一个符号。在与这个AI玩家对弈之后，我们将创建一棵完整的决策树。一旦我们生成了所有可能的游戏状态，你将体验到它们的组合爆炸。由于我们的目标是将这些复杂性简化，我们将使用几种不同的技术使AI玩家更智能，并减少决策树的大小。
- en: By the end of this experiment, we will have a decision tree that has fewer than
    200 different game endings and, as a bonus, the AI player will never lose a single
    game.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验结束时，我们将拥有一棵少于200种不同游戏结局的决策树，作为奖励，AI玩家将永远不会输掉一场游戏。
- en: 'To make a random move, you will have to know how to choose a random element
    from a list using Python. We will use the `choice` function of the `random` library
    to do so:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行随机移动，你需要知道如何使用Python从列表中选择一个随机元素。我们将使用`random`库的`choice`函数来实现：
- en: '[PRE31]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This time, the output is `6`, but for you, it can be any number from the list.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这次输出是`6`，但对你来说，它可以是列表中的任何数字。
- en: The output of the `choice` function is a random element of the list.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`choice`函数的输出是列表中的一个随机元素。'
- en: Note
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will use the factorial notation in the following section. A factorial is
    denoted by the "!" exclamation mark. By definition, 0! = 1, and n! = n*(n-1)!.
    In our example, 9! = 9* 8! = 9*8*7! = … = 9*8*7*6*5*4*3*2*1.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将使用阶乘符号。阶乘用"!"符号表示。根据定义，0! = 1，且n! = n*(n-1)!。在我们的例子中，9! = 9*8! =
    9*8*7! = … = 9*8*7*6*5*4*3*2*1。
- en: Estimating the Number of Possible States in a Tic-Tac-Toe Game
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 估算井字游戏中可能状态的数量
- en: 'Make a rough estimate of the number of possible states on each level of the
    state space of the tic-tac-toe game:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 粗略估算井字游戏状态空间每一层的可能状态数量：
- en: In our estimation, we will not stop until all of the cells of the board have
    been filled. A player might win before the game ends, but for the sake of uniformity,
    we will continue the game.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的估算中，我们不会在游戏结束前停止，直到所有格子都被填满。虽然玩家可能在游戏结束前就获胜，但为了统一起见，我们将继续进行游戏。
- en: The first player will choose one of the nine cells. The second player will choose
    one out of the eight remaining cells. The first player can then choose one out
    of the seven remaining cells. This goes on until either player wins the game,
    or the first player is forced to make the ninth and last move.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个玩家将选择九个格子中的一个。第二个玩家将选择剩下的八个格子中的一个。然后第一个玩家可以选择剩下的七个格子中的一个。这个过程一直持续，直到任一玩家获胜，或者第一个玩家被迫进行第九步最后一步。
- en: The number of possible decision sequences is, therefore, 9! = 362,880\. A few
    of these sequences are invalid because a player may win the game in fewer than
    nine moves. It takes at least five moves to win a game because the first player
    needs to move three times.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，可能的决策序列数为9! = 362,880。由于玩家可能在少于九步的情况下获胜，所以其中一些序列是无效的。至少需要五步才能获胜，因为第一个玩家需要三次移动。
- en: To calculate the exact size of the state space, we have to calculate the number
    of games that are won in five, six, seven, and eight steps. This calculation is
    simple, but due to its brute-force nature, it is beyond our scope. Therefore,
    we will settle on the magnitude of the state space.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了计算状态空间的准确大小，我们需要计算在五步、六步、七步和八步内获胜的游戏数量。这个计算很简单，但由于其蛮力性质，超出了我们的讨论范围。因此，我们将专注于状态空间的数量级。
- en: Note
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: After generating all possible tic-tac-toe games, researchers counted 255,168
    possible games. Out of those games, 131,184 were won by the first player, 77,904
    were won by the second player, and 46,080 games ended with a draw. Visit [http://www.half-real.net/tictactoe/allgamesoftictactoe.zip](http://www.half-real.net/tictactoe/allgamesoftictactoe.zip)
    to download all possible tic-tac-toe games.
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在生成所有可能的井字游戏后，研究人员统计了255,168种可能的游戏。在这些游戏中，131,184场由第一玩家获胜，77,904场由第二玩家获胜，46,080场以平局结束。请访问[http://www.half-real.net/tictactoe/allgamesoftictactoe.zip](http://www.half-real.net/tictactoe/allgamesoftictactoe.zip)下载所有可能的井字游戏。
- en: Even a simple game such as tic-tac-toe has a lot of states. Just imagine how
    hard it would be to start exploring all possible chess games. Therefore, we can
    conclude that brute-force searching is rarely ideal.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是简单的井字游戏也有很多状态。试想一下，探索所有可能的象棋游戏会有多难。因此，我们可以得出结论，暴力搜索很少是理想的选择。
- en: 'Exercise 1.02: Creating an AI with Random Behavior for the Tic-Tac-Toe Game'
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.02：为井字游戏创建一个具有随机行为的AI
- en: In this exercise, we'll create a framework for the tic-tac-toe game for experimentation.
    We will be modeling the game on the assumption that the AI player always starts
    the game. You will create a function that prints your internal representation,
    allows your opponent to enter a move randomly, and determines whether a player
    has won.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将为井字游戏创建一个实验框架。我们将假设AI玩家总是先开始游戏。您将创建一个打印内部表示的函数，允许对手随机输入一个移动，并判断玩家是否获胜。
- en: Note
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To ensure that this happens correctly, you will need to have completed the previous
    exercise.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保此操作正确进行，您需要完成前面的练习。
- en: 'The following steps will help you to complete this exercise:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: Begin by opening a new Jupyter Notebook file.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开一个新的Jupyter Notebook文件。
- en: 'We will import the `choice` function from the `random` library:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从`random`库中导入`choice`函数：
- en: '[PRE32]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, model the nine cells in a simple string for simplicity. A nine-character
    long Python string stores these cells in the following order: "`123456789`". Let''s
    determine the index triples that must contain matching signs so that a player
    wins the game:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了简化问题，将九个单元格建模为一个简单的字符串。一个九个字符长的Python字符串按以下顺序存储这些单元格："`123456789`"。我们来确定必须包含匹配符号的索引三元组，以便玩家获胜：
- en: '[PRE33]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Define the sign constants for empty cells, the AI, and the opponent player:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义空单元格、AI和对手玩家的符号常量：
- en: '[PRE34]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code snippet, we have assigned a different sign for the AI
    and the player.
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们为AI和玩家分配了不同的符号。
- en: 'Create a function that prints a board. We will add an empty row before and
    after the board so that we can easily read the game state:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个打印棋盘的函数。我们将在棋盘的前后添加一个空行，以便更容易地读取游戏状态：
- en: '[PRE35]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Describe a move of the human player. The input arguments are the boards, the
    row numbers from `1` to `3`, and the column numbers from `1` to `3`. The return
    value of this function is a board containing the new move:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述人类玩家的移动。输入参数是棋盘、从`1`到`3`的行号和从`1`到`3`的列号。该函数的返回值是包含新移动的棋盘：
- en: '[PRE36]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we have defined a function called `opponent_move` that will help us to
    calculate the index of the board based on the input (row and column). You will
    be able to see the resulting position on the board.
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`opponent_move`的函数，它将帮助我们根据输入（行和列）计算棋盘上的索引。您将能够看到在棋盘上的结果位置。
- en: 'Now, we need to define a random move on the part of the AI player. We will
    generate all possible moves with the `all_moves_from_board` function, and then
    select a random move from the list of possible moves:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要为AI玩家定义一个随机移动。我们将使用`all_moves_from_board`函数生成所有可能的移动，然后从可能的移动列表中选择一个随机移动：
- en: '[PRE37]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding code snippet, we defined a function called `all_moves_from_board`
    that goes through all the indexes on the board and checks whether they are empty
    (`v == EMPTY_SIGN`). If that's the case, this means that the move can be played
    and that the index has been added to a list of moves (`move_list`). Finally, we
    defined the `ai_move` function in order to randomly let the AI choose an index
    that is equal to a move in the game.
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了一个名为`all_moves_from_board`的函数，它遍历棋盘上的所有索引并检查它们是否为空（`v == EMPTY_SIGN`）。如果是这样，这意味着该位置可以进行移动，并且该索引已添加到移动列表（`move_list`）中。最后，我们定义了`ai_move`函数，以便AI随机选择一个与游戏中的移动相等的索引。
- en: 'Determine whether a player has won the game:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定玩家是否获胜：
- en: '[PRE38]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding code snippet, we have defined the `game_won_by` function, which
    checks whether the board contains a combo of three identical indexes from the
    `combo_indices` variable to end the game.
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了`game_won_by`函数，该函数检查棋盘上是否包含来自`combo_indices`变量的三个相同索引的组合，从而结束游戏。
- en: 'Finally, create a game loop so that we can test the interaction between the
    computer player and the human player. We will conduct a brute-force search in
    the following examples:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个游戏循环，以便我们测试计算机玩家和人类玩家之间的互动。在接下来的示例中，我们将进行暴力搜索：
- en: '[PRE39]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding code snippet, we defined the function, which can be broken
    down into various parts.
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了函数，可以将其分解为不同部分。
- en: The first part is to initialize the board and fill it with empty signs (`board
    = EMPTY_SIGN * 9`). Then, we create a counter of the empty cell, which will help
    us to create a loop and determine the AI's turn.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一部分是初始化棋盘并填充空标记（`board = EMPTY_SIGN * 9`）。然后，我们创建一个空格计数器，这将帮助我们创建一个循环并确定AI的回合。
- en: The second part is to create a function for the player and the AI engine to
    play the game against each other. As soon as one player makes a move, the `empty_cell_count`
    variable will decrease by 1\. The loop will keep going until either the `game_won_by`
    function finds a winner or there are no more possible moves on the board.
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二部分是创建一个函数，让玩家和AI引擎相互对战。一旦某一玩家进行移动，`empty_cell_count`变量将减少1。循环将继续，直到`game_won_by`函数找到胜者，或棋盘上没有更多可能的移动。
- en: 'Use the `game_loop` function to run the game:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`game_loop`函数来运行游戏：
- en: '[PRE40]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The expected output (partially shown) is this:'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 期望的输出（部分展示）是：
- en: '![Figure 1.8: Final output (partially shown) of the game'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.8：游戏的最终输出（部分展示）'
- en: '](img/B16060_01_08.jpg)'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_01_08.jpg)'
- en: 'Figure 1.8: Final output (partially shown) of the game'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8：游戏的最终输出（部分展示）
- en: Note
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3fUws2l](https://packt.live/3fUws2l).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考[https://packt.live/3fUws2l](https://packt.live/3fUws2l)。
- en: You can also run this example online at [https://packt.live/3hVzjcT](https://packt.live/3hVzjcT).
    You must execute the entire Notebook in order to get the desired result.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/3hVzjcT](https://packt.live/3hVzjcT)上运行这个示例。你必须执行整个Notebook，才能得到期望的结果。
- en: By completing this exercise, you have seen that even an opponent who is playing
    randomly may win from time to time if their opponent makes a mistake.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个练习后，你会发现，即使是一个随机游戏的对手，如果其对手犯了错误，也有可能会偶尔获胜。
- en: 'Activity 1.01: Generating All Possible Sequences of Steps in a Tic-Tac-Toe
    Game'
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 1.01：生成井字游戏中的所有可能步骤序列
- en: This activity will explore the combinatorial explosion that is possible when
    two players play randomly. We will be using a program that, building on the previous
    results, generates all possible sequences of moves between a computer player and
    a human player.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动将探索当两名玩家随机游戏时可能出现的组合爆炸。我们将使用一个程序，基于之前的结果，生成计算机玩家和人类玩家之间所有可能的移动序列。
- en: 'Let''s assume that the human player may make any possible move. In this example,
    given that the computer player is playing randomly, we will examine the wins,
    losses, and draws belonging to two randomly playing players:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 假设人类玩家可以做任何可能的移动。在这个例子中，由于计算机玩家是随机移动的，我们将检查两个随机玩家之间的胜负和平局：
- en: 'The following steps will help you to complete this activity:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成这个活动：
- en: Reuse all the function codes of *Steps 2–9* from the previous *Exercise 1.02*,
    *Creating an AI with Random Behavior for the Tic-Tac-Toe Game*.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重用前一个*练习 1.02*中*步骤 2-9*的所有函数代码，*创建一个随机行为的井字游戏 AI*。
- en: Create a function that maps the `all_moves_from_board` function on each element
    of a list of board spaces/squares. This way, we will have all of the nodes of
    a decision tree. The decision tree starts with `[ EMPTY_SIGN * 9 ]` and expands
    after each move.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，将`all_moves_from_board`函数应用于棋盘空间/方格列表中的每个元素。通过这种方式，我们将得到决策树的所有节点。决策树从`[
    EMPTY_SIGN * 9 ]`开始，并在每次移动后扩展。
- en: Create a `filter_wins` function that takes finished games out of the list of
    moves and appends them in an array containing the board states won by the AI player
    and the opponent player.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`filter_wins`函数，将已完成的游戏从移动列表中移除，并将它们追加到包含AI玩家和对手玩家获胜状态的数组中。
- en: 'Create a `count_possibilities` function that prints and returns the number
    of decision tree leaves that ended with a draw, were won by the first player,
    and were won by the second player:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`count_possibilities`函数，打印并返回以平局结束、第一玩家获胜和第二玩家获胜的决策树叶子数：
- en: We have up to nine steps in each state. In the 0th, 2nd, 4th, 6th, and 8th iterations,
    the AI player moves. In all other iterations, the opponent moves. We create all
    possible moves in all steps and take out finished games from the move list.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个状态下我们最多有九个步骤。在第0、2、4、6和8次迭代中，AI玩家移动。在所有其他迭代中，对手玩家移动。我们创建所有步骤中的所有可能移动，并从移动列表中移除已完成的游戏。
- en: Finally, execute the number of possibilities to experience the combinatorial
    explosion.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，执行可能性的数量以体验组合爆炸。
- en: 'The expected output is this:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 期望的输出是这个：
- en: '[PRE41]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 322.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第 322 页找到。
- en: So far, we've understood the significance of an intelligent agent. We also examined
    the game states for a game AI. Now, we will focus on how to create and introduce
    intelligence to an agent.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经理解了智能代理的意义。我们还检查了游戏 AI 的游戏状态。现在，我们将专注于如何为代理创建和引入智能。
- en: We will look at reducing the number of states in the state space, analyze the
    stages that a game board can undergo, and make the environment work in such a
    way that we win.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究如何减少状态空间中的状态数量，分析游戏棋盘可能经历的阶段，并使环境以一种我们能够获胜的方式运作。
- en: Have a look at the following exercise, where we'll teach an intelligent agent
    to win.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下练习，我们将在其中教导智能代理获胜。
- en: 'Exercise 1.03: Teaching the Agent to Win'
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.03：教代理获胜
- en: In this exercise, we will see how the steps needed to win can be reduced. We
    will be making the agent that we developed in the previous section activity detect
    situations where it can win a game.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们将看到如何减少获胜所需的步骤。我们将让我们在前一节中开发的代理检测能够获胜的游戏局面。
- en: 'The following steps will help you to complete this exercise:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成此练习：
- en: Open a new Jupyter Notebook file.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Jupyter Notebook 文件。
- en: Reuse the previous code from *Steps 2–6* from *Activity 1*, *Generating All
    Possible Sequences of Steps in a Tic-Tac-Toe Game*.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重用*步骤 2–6*中*活动 1*的前面代码，*生成井字游戏中所有可能的步骤序列*。
- en: Define two functions, `ai_move` and `all_moves_from_board`.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个函数，`ai_move`和`all_moves_from_board`。
- en: 'We create `ai_move` so that it returns a move that will consider its own previous
    moves. If the game can be won in that move, `ai_move` will select that move:'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们创建了`ai_move`，使其返回一个考虑自身先前走法的步骤。如果在该步中游戏可以获胜，`ai_move`将选择该步：
- en: '[PRE42]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding code snippet, we have defined the `ai_move` function, which
    will make the AI choose a winning move from a list of all the possible moves from
    the current state of the game if it's applicable. If not, it will still choose
    a random move.
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了`ai_move`函数，它将在适用的情况下从当前游戏状态下的所有可能走法中选择一个获胜的走法。如果没有，它仍然会选择一个随机的走法。
- en: 'Next, test the code snippet with a game loop. Whenever the AI has the opportunity
    to win the game, it will always place the `X` in the correct cell:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用游戏循环测试代码片段。每当 AI 有机会赢得游戏时，它总是会将`X`放在正确的格子里：
- en: '[PRE43]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The expected output is this:'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 期望的输出是这个：
- en: '![Figure 1.9: The agent winning the game'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.9：代理获胜'
- en: '](img/B16060_01_09.jpg)'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16060_01_09.jpg)'
- en: 'Figure 1.9: The agent winning the game'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.9：代理获胜
- en: 'Now, count all the possible moves. To do this, we must change the `all_moves_from_board`
    function to include this improvement. We must do this so that, if the game is
    won by `AI_SIGN`, it will return that value:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，计算所有可能的走法。为此，我们必须修改`all_moves_from_board`函数以包括这一改进。我们必须这么做，以便如果游戏被`AI_SIGN`获胜，它将返回该值：
- en: '[PRE44]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding code snippet, we have defined a function to generate all possible
    moves. As soon as we find a move that wins the game for the AI, we return it.
    We do not care whether the AI has multiple options to win the game in one move
    – we just return the first possibility. If the AI cannot win, we return all possible
    moves. Let's see what this means in terms of counting all of the possibilities
    at each step.
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了一个生成所有可能走法的函数。一旦我们找到一个能让 AI 获胜的步骤，我们就返回它。我们不在乎 AI 是否有多个选项可以在一步内获胜——我们只是返回第一个可能性。如果
    AI 无法获胜，我们返回所有可能的走法。让我们看看在每一步中计算所有可能性的意义。
- en: Enter the following function to find all the possibilities.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下函数来查找所有可能性。
- en: '[PRE45]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The expected output is this:'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 期望的输出是这个：
- en: '[PRE46]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/317pyTa](https://packt.live/317pyTa).
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 若要访问此特定部分的源代码，请参考[https://packt.live/317pyTa](https://packt.live/317pyTa)。
- en: You can also run this example online at [https://packt.live/2YnLpDS](https://packt.live/2YnLpDS).
    You must execute the entire Notebook in order to get the desired result.
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以在线运行这个示例，访问[https://packt.live/2YnLpDS](https://packt.live/2YnLpDS)。你必须执行整个
    Notebook 才能获得期望的结果。
- en: With that, we have seen that the AI is still not winning most of the time. This
    means that we need to introduce more concepts to the AI to make it stronger. To
    teach the AI how to win, we need to teach it how to make defensive moves against
    losses.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一点，我们已经看到AI在大多数情况下仍然无法获胜。这意味着我们需要引入更多的概念来增强AI的能力。为了教会AI如何获胜，我们需要教它如何进行防守性移动，以避免失败。
- en: Defending the AI against Losses
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防守AI免受失败
- en: In the next activity, we will make the AI computer player play better compared
    to our previous exercise so that we can reduce the state space and the number
    of losses.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个活动中，我们将使AI电脑玩家的表现优于之前的练习，以减少状态空间和失败次数。
- en: 'Activity 1.02: Teaching the Agent to Realize Situations When It Defends Against
    Losses'
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 1.02：教代理识别防守失败的情境
- en: 'In this activity, we will force the computer to defend against a loss if the
    player puts their third sign in a row, column, or diagonal line:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将强制电脑防守，以防玩家在行、列或对角线上放置第三个标记：
- en: Reuse all the code from *Steps 2–6* from the previous, *Exercise 1.03*, *Teaching
    the Agent to Win*.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重用之前的*步骤 2–6*中的所有代码，*练习 1.03*，*教代理获胜*。
- en: Create a function called `player_can_win` that takes all the moves from the
    board using the `all_moves_from_board` function and iterates over it using a variable
    called `next_move`. On each iteration, it checks whether the game can be won by
    the sign, and then it returns `true` or `false`.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`player_can_win`的函数，该函数通过`all_moves_from_board`函数获取棋盘上的所有移动，并通过一个名为`next_move`的变量遍历它。在每次迭代中，检查该标记是否能赢得比赛，然后返回`true`或`false`。
- en: Extend the AI's move so that it prefers making safe moves. A move is safe if
    the opponent cannot win the game in the next step.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展AI的移动，使其倾向于选择安全的移动。如果对方在下一步无法赢得游戏，那么该移动就是安全的。
- en: Test the new application. You will find that the AI has made the correct move.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试新应用程序。你会发现AI做出了正确的移动。
- en: Place this logic in the state space generator and check how well the computer
    player is doing by generating all possible games.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这一逻辑放入状态空间生成器，并通过生成所有可能的游戏，检查电脑玩家的表现。
- en: 'The expected output is this:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '[PRE47]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 325.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在第325页找到。
- en: Once we complete this activity, we notice that despite our efforts to make the
    AI better, it can still lose in **962** ways. We will eliminate all these losses
    in the next activity.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成这个活动，我们会注意到，尽管我们努力提高AI的能力，它仍然能以**962**种方式输掉比赛。我们将在下一个活动中消除所有这些失败。
- en: 'Activity 1.03: Fixing the First and Second Moves of the AI to Make It Invincible'
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 1.03：修正AI的第一步和第二步，使其变得无敌
- en: 'In this activity, we will be combining our previous activities by teaching
    the AI how to recognize both a win and a loss so that it can focus on finding
    moves that are more useful than others. We will be reducing the possible games
    by hardcoding the first and second moves:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将结合之前的活动，教AI如何识别胜利和失败，这样它就可以集中精力寻找比其他移动更有用的移动。我们将通过硬编码第一步和第二步来减少可能的游戏数：
- en: Reuse the code from *Steps 2–4* of the previous, *Activity 1.02*, *Teaching
    the Agent to Realize Situations When It Defends Against Losses*.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重用之前的*步骤 2–4*中的所有代码，*活动 1.02*，*教代理识别防守失败的情境*。
- en: Count the number of empty fields on the board and make a hardcoded move in case
    there are 9 or 7 empty fields. You can experiment with different hardcoded moves.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算棋盘上空白格的数量，并在空白格有9个或7个时进行硬编码的移动。你可以尝试不同的硬编码移动。
- en: Occupying any corner, and then occupying the opposite corner, leads to no losses.
    If the opponent occupies the opposite corner, making a move in the middle results
    in no losses.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 占据任何一个角落，然后占据对角的另一个角落，可以避免失败。如果对方占据了对角的另一个角落，那么在中间下棋也不会失败。
- en: After fixing the first two steps, we only need to deal with 8 possibilities
    instead of 504\. We also need to guide the AI into a state where the hardcoded
    rules are enough so that it never loses a game.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修正前两步后，我们只需要处理8种可能性，而不是504种。我们还需要引导AI进入一个状态，在这个状态下，硬编码规则足够使其永远不会输掉游戏。
- en: 'The expected output is this:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '[PRE48]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 328.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在第328页找到。
- en: 'Let''s summarize the important techniques that we applied to reduce the state
    space so far:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下到目前为止我们应用的减少状态空间的重要技巧：
- en: '**Empirical simplification**: We accepted that the optimal first move is a
    corner move. We simply hardcoded a move instead of considering alternatives to
    focus on other aspects of the game. In more complex games, empirical moves are
    often misleading. The most famous chess AI victories often contain a violation
    of the common knowledge of chess grand masters.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**经验性简化**：我们接受了最佳的第一步是角落移动。我们直接硬编码了一个移动，而不是考虑其他可能的选择，以便集中精力关注游戏的其他方面。在更复杂的游戏中，经验性移动往往具有误导性。最著名的国际象棋
    AI 胜利通常包含了对国际象棋大师们普遍认知的违反。'
- en: '**Symmetry**: After we started with a corner move, we noticed that positions
    1, 3, 7, and 9 were equivalent to the perspective of winning the game. Even though
    we didn''t take this idea further, we noticed that we could even rotate the table
    to reduce the state space even further and consider all four corner moves as the
    exact same move.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对称性**：在我们从角落位置开始移动后，我们注意到位置 1、3、7 和 9 在赢得游戏的角度上是等效的。即使我们没有进一步探讨这一点，我们也发现可以旋转棋盘来进一步减少状态空间，并将所有四个角落的移动视为相同的移动。'
- en: '**Reduction in different permutations leading to the same state**: Suppose
    we can make the moves A or B and suppose our opponent makes move X, where X is
    not equal to either move A or B. If we explore the sequence A, X, B, and we start
    exploring the sequence B, X, then we don''t have to consider the sequence B, X,
    A. This is because the two sequences lead to the exact same game state, and we
    have already explored a state containing these three moves before, that is, A,
    X, and B. The order of the sequence doesn''t matter as it leads to the same result.
    This allows us to significantly reduce the number of possible moves.'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不同排列的简化导致相同状态**：假设我们可以进行 A 或 B 的移动，并假设我们的对手进行了 X 移动，其中 X 既不等于 A 也不等于 B。如果我们探索
    A、X、B 的序列，然后开始探索 B、X 的序列，那么我们就不必再考虑 B、X、A 的序列。这是因为这两个序列会导致完全相同的游戏状态，而我们之前已经探索过包含这三步的状态，即
    A、X 和 B。序列的顺序并不重要，因为它们会导致相同的结果。这使我们能够显著减少可能的移动数量。'
- en: '**Forced moves for the player**: When a player collects two signs horizontally,
    vertically, or diagonally, and the third cell in the row is empty, we are forced
    to occupy that empty cell either to win the game or to prevent the opponent from
    winning the game. Forced moves may imply other forced moves, which reduces the
    state space even further.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家的强制性移动**：当玩家在水平方向、垂直方向或对角线方向上收集了两个符号，并且该行的第三个格子为空时，我们被迫占据该空格，无论是为了赢得游戏，还是为了防止对手赢得游戏。强制性移动可能会暗示其他强制性移动，从而进一步减少状态空间。'
- en: '**Forced moves for the opponent**: When a move from the opponent is clearly
    optimal, it does not make sense to consider scenarios where the opponent does
    not make the optimal move. When the opponent can win the game by occupying a cell,
    it does not matter whether we go on a long exploration of the cases when the opponent
    misses the optimal move. We save a lot less by not exploring cases when the opponent
    fails to prevent us from winning the game. This is because after the opponent
    makes a mistake, we will simply win the game.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对手的强制性移动**：当对手的某一移动显然是最佳时，考虑对手不做最佳移动的情形就没有意义。如果对手通过占据某个格子可以赢得游戏，我们就不需要在对手错失最佳移动时进行长时间的探索。通过不探索对手未能阻止我们赢得游戏的情况，我们节省的时间非常有限。这是因为在对手犯错后，我们会直接赢得游戏。'
- en: '**Random move**: When we cannot decide and don''t have the capacity to search,
    we move randomly. Random moves are almost always inferior to a search-based educated
    guess, but at times, we have no other choice.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机移动**：当我们无法决定且没有能力进行搜索时，我们会随机移动。随机移动几乎总是不如基于搜索的推测，但有时我们别无选择。'
- en: Heuristics
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启发式方法
- en: In this section, we will formalize informed search techniques by defining and
    applying heuristics to guide our search. We will be looking at heuristics and
    creating them in the sections ahead.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过定义和应用启发式方法来规范化信息化搜索技术，以引导我们的搜索。接下来的章节中，我们将探讨启发式方法并进行创建。
- en: Uninformed and Informed Searches
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无信息和有信息搜索
- en: In the tic-tac-toe example, we implemented a greedy algorithm that first focused
    on winning, and then focused on not losing. When it comes to winning the game
    immediately, the greedy algorithm is optimal because there is never a better step
    than winning the game. When it comes to not losing, it matters how we avoid the
    loss. Our algorithm simply choses a random safe move without considering how many
    winning opportunities we have created.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在井字棋的例子中，我们实现了一个贪婪算法，首先专注于赢得比赛，然后专注于避免输掉比赛。当谈到立即赢得游戏时，贪婪算法是最优的，因为没有比赢得游戏更好的步骤。至于避免输掉比赛，关键在于我们如何避免失败。我们的算法仅仅选择一个随机的安全移动，而不考虑我们创造了多少个赢的机会。
- en: BFS and DFS are part of uninformed searching because they consider all possible
    states in the game, which can be very time-consuming. On the other hand, heuristic
    informed searches will explore the space of available states intelligently in
    order to reach the goal faster.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先搜索（BFS）和深度优先搜索（DFS）是无信息搜索的一部分，因为它们考虑了游戏中的所有可能状态，这可能非常耗时。另一方面，启发式信息搜索将智能地探索可用状态的空间，以更快地到达目标。
- en: Creating Heuristics
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建启发式方法
- en: If we want to make better decisions, we apply heuristics to guide the search
    in the right direction by considering long-term benefits. This way, we can make
    a more informed decision in the present based on what could happen in the future.
    This can also help us solve problems faster.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想做出更好的决策，可以应用启发式方法，通过考虑长期收益来指导搜索朝着正确的方向前进。通过这种方式，我们可以根据未来可能发生的事情，在当前做出更有信息的决策。这也有助于我们更快地解决问题。
- en: 'We can construct heuristics as follows:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按如下方式构建启发式方法：
- en: In terms of the utility of making a move in the game
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从在游戏中做出移动的效用来看
- en: In terms of the utility of a given game state from the perspective of a player
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从玩家的角度来看，给定游戏状态的效用
- en: In terms of the distance from our goal
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从距离目标的远近来看
- en: Heuristics are functions that evaluate a game state or a transition to a new
    game state based on their utility. Heuristics are the cornerstones of making a
    search problem informed.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 启发式方法是根据它们的效用评估游戏状态或转移到新游戏状态的函数。启发式方法是使搜索问题具备信息的基石。
- en: In this book, we will use utility and cost as negated terms. Maximizing utility
    and minimizing the cost of a move are considered synonyms.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将效用和成本作为对立的术语来使用。最大化效用和最小化移动成本被视为同义词。
- en: A commonly used example of a heuristic evaluation function occurs in pathfinding
    problems. Suppose we are looking to reach a destination or a goal. Each step has
    an associated cost symbolizing the travel distance. Our goal is to minimize the
    cost of reaching the destination or goal (minimizing the travel distance).
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 启发式评估函数的一个常见示例出现在路径寻找问题中。假设我们想要到达一个目标或目的地。每一步都有一个与之相关的成本，表示旅行的距离。我们的目标是最小化到达目的地或目标的成本（即最小化旅行距离）。
- en: One example of heuristic evaluation for solving this pathfinding problem will
    be to take the coordinates between the current state (position) and the goal (destination)
    and calculate the distance between these two points. The distance between two
    points is the length of the straight line connecting the points. This heuristic
    is called the **Euclidean distance** (as shown in the *Figure 1.10*).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此路径寻找问题的一个启发式评估示例是，取当前状态（位置）和目标（目的地）之间的坐标，计算这两点之间的距离。两点之间的距离是连接这两点的直线的长度。这个启发式方法被称为**欧几里得距离**（如*图1.10*所示）。
- en: Now, suppose we define our pathfinding problem in a maze, where we can only
    move up, down, left, or right. There are a few obstacles in the maze that block
    our moves, so using the Euclidean distance is not ideal. A better heuristic would
    be to use the Manhattan distance, which can be defined as the sum of the horizontal
    and vertical distances between the coordinates of the current state and the goal.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们将路径寻找问题定义为一个迷宫，其中我们只能向上、向下、向左或向右移动。迷宫中有一些障碍物阻挡我们的移动，因此使用欧几里得距离并不理想。一个更好的启发式方法是使用曼哈顿距离，可以定义为当前状态和目标之间的水平和垂直距离之和。
- en: Admissible and Non-Admissible Heuristics
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可接受和不可接受的启发式方法
- en: The two heuristics we just defined regarding pathfinding problems are called
    admissible heuristics when they're used on their given problem domain.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才定义的关于路径寻找问题的两个启发式方法，在其给定问题领域中被称为可接受启发式方法。
- en: Admissible means that we may underestimate the cost of reaching the end state
    but that we never overestimate it. Later, we will explore an algorithm that finds
    the shortest path between the current state and the goal state. The optimal nature
    of this algorithm depends on whether we can define an admissible heuristic function.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 可接受性意味着我们可能低估了达到终局状态的成本，但从不高估它。稍后我们将探讨一种算法，找出当前状态和目标状态之间的最短路径。这个算法的最优性质取决于我们能否定义一个可接受的启发式函数。
- en: An example of a non-admissible heuristic would be the Euclidean distance that's
    applied to a real-world map.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非可接受启发式的例子就是应用于现实地图的欧几里得距离。
- en: 'Imagine that we want to move from point A to point B in the city of Manhattan.
    Here, the Euclidean distance will be the straight line between the two points,
    but, as we know, we cannot just go straight in a city such as Manhattan (*unless
    we can fly*). In this case, the Euclidean distance is underestimating the cost
    of reaching the goal. A better heuristic would be the Manhattan distance:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们想从曼哈顿的A点移动到B点。这里，欧几里得距离是两点之间的直线距离，但正如我们所知，在像曼哈顿这样的城市中，我们不可能直接走直线（*除非我们能飞*）。在这种情况下，欧几里得距离低估了到达目标的成本。一个更好的启发式方法应该是曼哈顿距离：
- en: '![Figure 1.10: Euclidian (blue line) distance and Manhattan (red line) distance
    in the city of Manhattan'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.10：曼哈顿市中的欧几里得（蓝线）距离和曼哈顿（红线）距离'
- en: '](img/B16060_01_10.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_10.jpg)'
- en: 'Figure 1.10: Euclidian distance (blue line) and Manhattan distance (red line)
    in the city of Manhattan'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10：曼哈顿市中的欧几里得距离（蓝线）和曼哈顿距离（红线）
- en: Note
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding map of Manhattan is sourced from Google Maps.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的曼哈顿地图来源于Google地图。
- en: Since we overestimated the cost of traveling from the current node to the goal,
    the Euclidean distance is not admissible when we cannot move diagonally.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们高估了从当前节点到目标的旅行成本，当我们不能进行对角线移动时，欧几里得距离就不再适用了。
- en: Heuristic Evaluation
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启发式评估
- en: We can create a heuristic evaluation for our tic-tac-toe game state from the
    perspective of the starting player by defining the utility of a move.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从起始玩家的角度，通过定义一步的效用值，为我们的井字游戏状态创建一个启发式评估。
- en: 'Heuristic 1: Simple Evaluation of the Endgame'
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启发式 1：简单的残局评估
- en: 'Let''s define a simple heuristic by evaluating a board. We can set the utility
    for the game as one of the following:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来定义一个简单的启发式方法，通过评估棋盘。我们可以将游戏的效用值设为以下之一：
- en: +1, if the state implies that the AI player will win the game
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果状态表明AI玩家将赢得游戏：+1。
- en: -1, if the state implies that the AI player will lose the game
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果状态表明AI玩家将输掉游戏：-1。
- en: 0, if a draw has been reached or no clear winner can be identified from the
    current state
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果已经平局或无法从当前状态明确识别出赢家：0。
- en: This heuristic is simple because anyone can look at a board and analyze whether
    a player is about to win.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这个启发式方法很简单，因为任何人都可以看着棋盘分析一个玩家是否即将获胜。
- en: The utility of this heuristic depends on whether we can play many moves in advance.
    Notice that we cannot even win the game within five steps. In *Activity 1.01*,
    *Generating All Possible Sequences of Steps in a Tic-Tac-Toe Game*, we saw that
    by the time we reach step five, we have 13,680 possible combinations leading to
    it. In most of these 13,680 cases, our heuristic returns zero as we can't identify
    a clear winner yet.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这个启发式的效用值取决于我们能否提前进行多步操作。请注意，我们甚至在五步内都无法赢得比赛。在*活动 1.01*，*生成所有可能的井字游戏步骤序列*中，我们看到到达第五步时，我们已经有13,680种可能的组合。在这13,680种情况中，由于我们尚未能识别出明确的赢家，我们的启发式方法返回的值为零。
- en: If our algorithm does not look deeper than these five steps, we are completely
    clueless on how to start the game. Therefore, we should invent a better heuristic.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的算法只看这五步，那么我们对于如何开始游戏完全没有头绪。因此，我们应该发明一个更好的启发式方法。
- en: 'Heuristic 2: Utility of a Move'
  id: totrans-448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启发式 2：一步的效用
- en: 'Let''s change the utility for the game as follows:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来改变游戏的效用值，如下所示：
- en: 'Two AI signs in a row, column, or diagonal, and the third cell is empty: +1000
    for the empty cell.'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在一行、列或对角线中有两个AI标志，且第三个格子为空：为空格子加+1000。
- en: 'The opponent has two signs in a row, column, or diagonal, and the third cell
    is empty: +100 for the empty cell.'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对手在一行、列或对角线中有两个标志，且第三个格子为空：为空格子加+100。
- en: 'One AI sign in a row, column, or diagonal, and the other two cells are empty:
    +10 for the empty cells.'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在一行、列或对角线中有一个AI标志，另外两个格子为空：为空格子加+10。
- en: 'No AI or opponent signs in a row, column, or diagonal: +1 for the empty cells.'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在一行、列或对角线中没有AI或对手的标志：为空格子加+1。
- en: Occupied cells get a value of minus infinity. In practice, due to the nature
    of the rules, -1 will also do.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被占用的单元格将获得负无穷大值。实际上，由于规则的性质，-1 也足够了。
- en: Why do we use a multiplicative factor of 10 for the first three rules compared
    to the fourth one? We do this because there are eight possible ways of making
    three in a row, column, and diagonal. So, even by knowing nothing about the game,
    we are certain that a lower-level rule may not accumulate to overriding a higher-level
    rule. In other words, we will never defend against the opponent's moves if we
    can win the game.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们将前面三个规则与第四个规则的乘数因子设为 10？我们这样做是因为有八种可能的方式可以形成三连线、三列或对角线。所以，即使我们对游戏一无所知，我们也能确定较低级别的规则不会覆盖更高级别的规则。换句话说，如果我们能赢得比赛，我们就永远不会防守对手的棋步。
- en: Note
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As the job of our opponent is also to win, we can compute this heuristic from
    the opponent's point of view. Our task is to maximize this value, too, so that
    we can defend against the optimal plays of our opponent. This is the idea behind
    the Minmax algorithm as well, which will be covered later in this chapter. If
    we wanted to convert this heuristic into a heuristic that describes the current
    board, we could compute the heuristic value for all open cells and take the maximum
    of the values for the AI character so that we can maximize our utility.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的对手的任务也是赢得比赛，我们可以从对手的角度计算这个启发式函数。我们的任务是最大化这个值，从而防止对手做出最优的棋步。这也是 Minmax 算法背后的理念，稍后在本章会介绍。如果我们想将这个启发式函数转换为描述当前棋盘的函数，我们可以计算所有开放单元格的启发式值，并取出
    AI 角色的最大值，这样我们就可以最大化我们的效用。
- en: For each board, we will create a utility matrix.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个棋盘，我们将创建一个效用矩阵。
- en: 'For example, consider the following board, with `O` signs as the player and
    `X` signs as the AI:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下棋盘，其中 `O` 代表玩家，`X` 代表 AI：
- en: '![Figure 1.11: Tic-tac-toe game state'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.11：井字游戏状态'
- en: '](img/B16060_01_11.jpg)'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_11.jpg)'
- en: 'Figure 1.11: Tic-tac-toe game state'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11：井字游戏状态
- en: 'From here, we can construct its utility matrix shown in the following figure:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以构建其效用矩阵，如下图所示：
- en: '![Figure 1.12: Tic-tac-toe game utility matrix'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.12：井字游戏效用矩阵'
- en: '](img/B16060_01_12.jpg)'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_12.jpg)'
- en: 'Figure 1.12: Tic-tac-toe game utility matrix'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12：井字游戏效用矩阵
- en: On the second row, the left cell is not beneficial if we were to select it.
    Note that if we had a more optimal utility function, we would reward blocking
    the opponent.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，左侧单元格如果选择了它将没有益处。请注意，如果我们有一个更优的效用函数，我们会奖励阻挡对手的棋步。
- en: The two cells of the third column both get a `10`-point boost for two in a row.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 第三列的两个单元格因为两连线而分别获得`10`分的加成。
- en: The top-right cell also gets `100` points for defending against the diagonal
    of the opponent.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 右上角的单元格也因为防御对手的对角线而获得`100`分。
- en: From this matrix, evidently, we should choose the top-right move. At any stage
    of the game, we were able to define the utility of each cell; this was a static
    evaluation of the heuristic function.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个矩阵可以明显看出，我们应该选择右上角的移动。在游戏的任何阶段，我们都能够定义每个单元格的效用；这是一种静态的启发式函数评估。
- en: We can use this heuristic to guide us toward an optimal next move or to give
    a more educated score on the current board by taking the maximum of these values.
    We have technically used parts of this heuristic in the form of hardcoded rules.
    Note, though, that the real utility of heuristics is not the static evaluation
    of a board, but the guidance it provides for limiting the search space.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个启发式函数来指导我们做出最优的下一步棋，或者通过取这些值的最大值来更有根据地评分当前棋盘。实际上，我们已经以硬编码规则的形式使用了部分启发式函数。不过请注意，启发式函数的真正作用不是对棋盘进行静态评估，而是为限制搜索空间提供指导。
- en: 'Exercise 1.04: Tic-Tac-Toe Static Evaluation with a Heuristic Function'
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.04：使用启发式函数进行井字游戏静态评估
- en: In this exercise, you will be performing a static evaluation on the tic-tac-toe
    game using a heuristic function.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用启发式函数对井字游戏进行静态评估。
- en: 'The following steps will help you to complete this exercise:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: Open a new Jupyter Notebook file.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Jupyter Notebook 文件。
- en: Reuse the code from *Steps 2–6* of *Activity 1.01*, *Generating All Possible
    Sequences of Steps in a Tic-Tac-Toe Game*.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重用 *步骤 2-6* 中的代码，*活动 1.01：生成井字游戏的所有可能步骤序列*。
- en: 'Create a function that takes the board as input and returns `0` if the cell
    is empty, and `-1` if it''s not empty:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，该函数以棋盘为输入，如果单元格为空则返回`0`，如果单元格不为空则返回`-1`：
- en: '[PRE49]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, create a function that takes the utility vector of possible moves, takes
    three indices inside the utility vector representing a triple, and returns a function,
    as shown in the following code snippet:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个函数，它接受可能走法的效用向量，取效用向量中的三个索引表示一个三元组，并返回一个函数，如以下代码片段所示：
- en: '[PRE50]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the preceding code snippet, the returned function will expect a `points`
    parameter and the `utilities` vector as input and will add points to each cell
    in (`i`, `j`, `k`), as long as the original value of that cell is non-negative
    (`>=0`). In other words, we increased the utility of empty cells only.
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，返回的函数将期望一个`points`参数和`utilities`向量作为输入，并将分数添加到(`i`，`j`，`k`)的每个单元格，只要该单元格的原始值非负（`>=0`）。换句话说，我们仅增加了空白单元格的效用。
- en: 'Now, create the utility matrix belonging to any board constellation where you
    will add the `generate_add_score` function defined previously to update the score.
    You will also implement the rules that we discussed prior to this activity. These
    rules are as follows:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建属于任意棋盘配置的效用矩阵，你将添加先前定义的`generate_add_score`函数来更新分数。你还将实现我们在本活动之前讨论的规则。具体规则如下：
- en: 'Two AI signs in a row, column, or diagonal, and the third cell is empty: +1000
    for the empty cell.'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 两个 AI 标记在行、列或对角线连续出现，且第三个单元格为空：空白单元格得+1000分。
- en: 'The opponent has two signs in a row, column, or diagonal, and the third cell
    is empty: +100 for the empty cell.'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对手在行、列或对角线连续出现两个标记，且第三个单元格为空：空白单元格得+100分。
- en: 'One AI sign in a row, column, or diagonal, and the other two cells are empty:
    +10 for the empty cells.'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个 AI 标记在行、列或对角线连续出现，另外两个单元格为空：空白单元格得+10分。
- en: 'No AI or opponent signs in a row, column, or diagonal: +1 for the empty cells.'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有 AI 或对手在行、列或对角线连续出现：空白单元格得+1分。
- en: 'Let''s create the utility matrix now:'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在让我们创建效用矩阵：
- en: '[PRE51]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create a function that selects the move with the highest utility value. If
    multiple moves have the same utility, the function returns both moves:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，选择具有最高效用值的走法。如果多个走法具有相同效用，该函数返回这两个走法：
- en: '[PRE52]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, run the application, as shown in the following code snippet:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行应用程序，如以下代码片段所示：
- en: '[PRE53]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The expected output is this:'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '[PRE54]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2VpGyAv](https://packt.live/2VpGyAv).
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 若要访问此特定部分的源代码，请参阅[https://packt.live/2VpGyAv](https://packt.live/2VpGyAv)。
- en: You can also run this example online at [https://packt.live/2YnyO3K](https://packt.live/2YnyO3K).
    You must execute the entire Notebook in order to get the desired result.
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以在网上运行此示例：[https://packt.live/2YnyO3K](https://packt.live/2YnyO3K)。你必须执行整个笔记本才能得到预期的结果。
- en: By completing this exercise, we have observed that the AI is underperforming
    compared to our previous activity, *Activity 1.03*, *Fixing the First and Second
    Moves of the AI to Make It Invincible*. In this situation, hardcoding the first
    two moves was better than setting up the heuristic, but this is because we haven't
    set up the heuristic properly.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成此练习，我们观察到 AI 的表现较我们之前的活动 *Activity 1.03*（*固定 AI 的第一步和第二步，使其无敌*）有所下降。在这种情况下，将前两步硬编码比设置启发式方法更好，但这是因为我们还没有正确设置启发式方法。
- en: Using Heuristics for an Informed Search
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用启发式方法进行有指导的搜索
- en: We have not experienced the real power of heuristics yet as we made moves without
    the knowledge of the effects of our future moves, thereby effecting reasonable
    play from our opponents.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未真正体验到启发式方法的强大，因为我们在没有了解未来走法效果的情况下做出了决策，从而影响了对手的合理玩法。
- en: Therefore, a more accurate heuristic leads to more losses than simply hardcoding
    the first two moves in the game. Note that in the previous section, we selected
    these two moves based on the statistics we generated based on running the game
    with fixed first moves. This approach is essentially what heuristic search should
    be all about.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，更准确的启发式方法比单纯将前两步固定的做法带来了更多的失败。请注意，在前一部分中，我们是根据通过运行具有固定前两步的游戏所生成的统计数据来选择这两步的。这种方法本质上就是启发式搜索应该实现的目标。
- en: Types of Heuristics
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启发式方法的类型
- en: Static evaluation cannot compete with generating hundreds of thousands of future
    states and selecting a play that maximizes our rewards. This is because our heuristics
    are not exact and are likely not admissible either.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 静态评估无法与生成数十万种未来状态并选择最大化奖励的玩法竞争。这是因为我们的启发式方法并不精确，且很可能也不可接受。
- en: We saw in the preceding exercise that heuristics are not always optimal. We
    came up with rules that allowed the AI to always win the game or finish with a
    draw. These heuristics allowed the AI to win very frequently, at the expense of
    losing in a few cases. A heuristic is said to be admissible if we underestimate
    the utility of a game state, but we never overestimate it.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的练习中看到，启发式并不总是最优的。我们提出了规则，使得 AI 总是赢得游戏或以平局结束。这些启发式让 AI 很频繁地获胜，但也以少数几次失败为代价。启发式被称为可接受的，当我们低估了游戏状态的效用，但从未高估它。
- en: In the tic-tac-toe example, we likely overestimated the utility in a few game
    states, and why is that? Because we ended up with a loss 12 times. A few of the
    game states that led to a loss had a maximum heuristic score. To prove that our
    heuristic is not admissible, all we need to do is find a potentially winning game
    state that we ignored while choosing a game state that led to a loss.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 在井字游戏的例子中，我们可能高估了某些游戏状态的效用，为什么呢？因为我们最终输掉了 12 次。那些导致失败的游戏状态具有最高的启发式得分。为了证明我们的启发式不是可接受的，我们需要做的就是找到一个我们忽略的潜在获胜游戏状态，而这个状态在选择导致失败的游戏状态时被忽视。
- en: 'There are two more features that describe heuristics, that is, optimal and
    complete:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个描述启发式的特征，即：最优和完整：
- en: Optimal heuristics always find the best possible solution.
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最优启发式始终能够找到最佳的解决方案。
- en: Complete heuristics has two definitions, depending on how we define the problem
    domain. In a loose sense, a heuristic is said to be complete if it always finds
    a solution. In a strict sense, a heuristic is said to be complete if it finds
    all possible solutions. Our tic-tac-toe heuristic is not complete because we ignored
    many possible winning states on purpose, favoring a losing state.
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整的启发式有两个定义，取决于我们如何定义问题领域。从宽泛的意义上讲，如果启发式始终能够找到一个解，它就被称为完整的。严格来说，如果启发式能够找到所有可能的解，那么它才是完整的。我们的井字游戏启发式并不完整，因为我们故意忽略了许多可能的获胜状态，偏向选择了一个失败状态。
- en: As you can see, defining an accurate heuristic requires a lot of details and
    thinking in order to obtain a perfect AI agent. If you are not correctly estimating
    the utility in the game states, then you can end up with an AI underperforming
    hardcoded rules.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，定义准确的启发式需要很多细节和思考，才能获得一个完美的 AI 智能体。如果你没有正确估计游戏状态中的效用，那么你可能会得到一个表现不佳的硬编码规则的
    AI。
- en: In the next section, we'll look at a better approach to executing the shortest
    pathfinding between the current state and the goal state.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一种更好的方法，用于执行当前状态与目标状态之间的最短路径寻找。
- en: Pathfinding with the A* Algorithm
  id: totrans-511
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 A* 算法进行路径寻找
- en: In the first two sections, we learned how to define an intelligent agent and
    how to create a heuristic that guides the agent toward a desired state. We learned
    that this was not perfect because, at times, we ignored a few winning states in
    favor of a few losing states.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两节中，我们学习了如何定义智能体，以及如何创建引导智能体走向期望状态的启发式。我们了解到，这种方法并不完美，因为有时我们会偏向忽略一些获胜状态，而选择一些失败状态。
- en: Now, we will learn about a structured and optimal approach so that we can execute
    a search for finding the shortest path between the current state and the goal
    state by using the A* ("*A star*" instead of "*A asterisk*") algorithm.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习一种结构化且最优的方法，以便使用 A*（“*A star*”而不是“*A asterisk*”）算法执行搜索，寻找当前状态与目标状态之间的最短路径。
- en: 'Have a look at the following figure:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下图像：
- en: '![Figure 1.13: Finding the shortest path in a maze'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.13：在迷宫中寻找最短路径'
- en: '](img/B16060_01_13.jpg)'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_13.jpg)'
- en: 'Figure 1.13: Finding the shortest path in a maze'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.13：在迷宫中寻找最短路径
- en: 'For a human, it is simple to find the shortest path by merely looking at the
    figure. We can conclude that there are two potential candidates for the shortest
    path: route one starts upward, and route two starts to the left. However, the
    AI does not know about these options. In fact, the most logical first step for
    a computer player would be moving to the square denoted by the number `3` in the
    following figure.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 对于人类来说，只需通过查看图像就可以轻松找到最短路径。我们可以得出结论，最短路径有两个潜在候选：第一条路线从上方开始，第二条路线从左侧开始。然而，AI
    并不了解这些选择。事实上，对于计算机玩家来说，最合理的第一步是移动到下图中由数字 `3` 标示的方格。
- en: 'Why? Because this is the only step that decreases the distance between the
    starting state and the goal state. All the other steps initially move away from
    the goal state:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？因为这是唯一一个能够减少起始状态与目标状态之间距离的步骤。所有其他步骤最初都会远离目标状态：
- en: '![Figure 1.14: Shortest pathfinding game board with utilities'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.14：带有工具的最短路径寻找游戏板'
- en: '](img/B16060_01_14.jpg)'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_14.jpg)'
- en: 'Figure 1.14: Shortest pathfinding game board with utilities'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.14：带有工具的最短路径寻找游戏板
- en: In the next exercise, we'll see how the BFS algorithm performs on the pathfinding
    problem before introducing you to the A* algorithm.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将看到 BFS 算法在路径寻找问题中的表现，然后再向你介绍 A* 算法。
- en: 'Exercise 1.05: Finding the Shortest Path Using BFS'
  id: totrans-524
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.05：使用 BFS 寻找最短路径
- en: In this exercise, we will be finding the shortest path to our goal using the
    BFS algorithm.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 BFS 算法找到到达目标的最短路径。
- en: 'The following steps will help you to complete this exercise:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成这个练习：
- en: Open a new Jupyter Notebook file.
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Jupyter Notebook 文件。
- en: 'Begin by importing the `math` library:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先导入 `math` 库：
- en: '[PRE55]'
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, describe the board, the initial state, and the final state using Python.
    Create a function that returns a list of possible successors. Use tuples, where
    the first coordinate denotes the row number from `1` to `7` and the second coordinate
    denotes the column number from `1` to `9`:'
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用 Python 描述棋盘、初始状态和最终状态。创建一个返回可能后继状态的函数。使用元组，其中第一个坐标表示行号（从 `1` 到 `7`），第二个坐标表示列号（从
    `1` 到 `9`）：
- en: '[PRE56]'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, use array comprehension to generate the successor states, as shown in
    the following code:'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用数组推导生成后继状态，如下代码所示：
- en: '[PRE57]'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The function is generating all the possible moves from a current field that
    does not end up being blocked by an obstacle. We also add a filter to exclude
    moves that return to a field we have visited already to avoid infinite loops.
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该函数生成当前区域所有可能的移动，前提是这些移动不会被障碍物阻塞。我们还添加了一个过滤器，以排除返回到我们已经访问过的区域的移动，从而避免无限循环。
- en: 'Next, implement the initial costs, as shown in the following code snippet:'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，实现初始代价，如下代码片段所示：
- en: '[PRE58]'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, implement the updated costs using `costs`, `current_node`, and `successor_node`:'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 `costs`、`current_node` 和 `successor_node` 实现更新后的代价：
- en: '[PRE59]'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, implement the BFS algorithm to search the state of the tree and save
    the result in a variable called `bfs`:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现 BFS 算法来搜索树的状态，并将结果保存在名为 `bfs` 的变量中：
- en: '[PRE60]'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the preceding code snippet, we have reused the `bfs_tree` function that we
    looked at earlier in the *Breadth First Search* section of this book. However,
    we added the `update_costs` function to update the costs.
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们重新使用了本书 *广度优先搜索* 部分中我们已经看过的 `bfs_tree` 函数。但我们添加了 `update_costs`
    函数来更新代价。
- en: 'The expected output is this:'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 期望的输出是这样的：
- en: '[PRE61]'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, you can see that a simple BFS algorithm successfully determines the cost
    from the start node to any nodes, including the target node.
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，你可以看到一个简单的 BFS 算法成功地确定了从起始节点到任何节点（包括目标节点）的代价。
- en: 'Now, measure the number of steps required to find the goal node and save the
    result in the `bfs_v` variable, as shown in the following code snippet:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，测量找到目标节点所需的步骤数，并将结果保存在`bfs_v`变量中，如下代码片段所示：
- en: '[PRE62]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the preceding code snippet, we have added a step counter variable in order
    to print the number of steps at the end of the search.
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们添加了一个步骤计数器变量，以便在搜索结束时打印步数。
- en: 'The expected output is this:'
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 期望的输出是这样的：
- en: '[PRE63]'
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3fMYwEt](https://packt.live/3fMYwEt).
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 若要访问此部分的源代码，请参考 [https://packt.live/3fMYwEt](https://packt.live/3fMYwEt)。
- en: You can also run this example online at [https://packt.live/3duuLqp](https://packt.live/3duuLqp).
    You must execute the entire Notebook in order to get the desired result.
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/3duuLqp](https://packt.live/3duuLqp)上在线运行这个示例。你必须执行整个
    Notebook 才能得到预期结果。
- en: 'In this exercise, we used the BFS algorithm to find the shortest path to the
    goal. It took BFS `110` steps to reach the goal. Now, we will learn about an algorithm
    that can find the shortest path from the start node to the goal node: the A* algorithm.'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用了 BFS 算法来找到最短路径。BFS 用了`110`步到达目标。现在，我们将学习一个可以从起始节点找到目标节点最短路径的算法：A*
    算法。
- en: Introducing the A* Algorithm
  id: totrans-554
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 A* 算法
- en: 'A* is a complete and optimal heuristic search algorithm that finds the shortest
    possible path between the current game state and the winning state. The definition
    of complete and optimal in this state are as follows:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: A* 是一个完整且最优的启发式搜索算法，能够找到当前游戏状态到获胜状态之间的最短路径。在这种状态下，完整性和最优性的定义如下：
- en: Complete means that A* always finds a solution.
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整性意味着 A* 总是能找到一个解决方案。
- en: Optimal means that A* will find the best solution.
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最优意味着A*会找到最佳解。
- en: 'To set up the A* algorithm, we need the following:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置A*算法，我们需要以下内容：
- en: An initial state
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始状态
- en: A description of the goal states
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标状态的描述
- en: Admissible heuristics to measure progress toward the goal state
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于衡量向目标状态推进的可接受启发式方法
- en: A way to generate the next steps toward the goal
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成通向目标的下一步方式
- en: 'Once the setup is complete, we execute the A* algorithm using the following
    steps on the initial state:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，我们将使用以下步骤在初始状态下执行A*算法：
- en: We generate all possible next steps.
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们生成所有可能的下一步。
- en: We store these children in the order of their distance from the goal.
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们按距离目标的远近顺序存储这些子节点。
- en: We select the child with the best score first and repeat these three steps on
    the child with the best score as the initial state. This is the shortest path
    to get to a node from the starting node.
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先选择得分最好的子节点，然后对这个子节点应用这三步，将其作为初始状态。这样可以得到从起点到某个节点的最短路径。
- en: 'Let''s take, for example, the following figure:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下图形：
- en: '![Figure 1.15: Tree with heuristic distance'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.15：带有启发式距离的树'
- en: '](img/B16060_01_15.jpg)'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_15.jpg)'
- en: 'Figure 1.15: Tree with heuristic distance'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.15：带有启发式距离的树
- en: The first step will be to generate all the possible moves from the origin, `A`,
    which is moving from `A` to `B (A,B)` or to `C (A,C)`.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是生成所有从起点`A`开始的可能移动方式，分别是从`A`到`B (A,B)`或到`C (A,C)`。
- en: The second step is to use the heuristic (the distance) to order the two possible
    moves, `(A,B)`, with `10`, which is shorter compared to `(A,C)` with `100`.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是使用启发式值（距离）来排序两个可能的移动，`(A,B)`的启发式值为`10`，而`(A,C)`的启发式值为`100`，显然`(A,B)`较短。
- en: The third step is to choose the shortest heuristic, which is `(A,B)`, and move
    to `B`.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步是选择最短的启发式值，`(A,B)`，并移动到`B`。
- en: Now, we will repeat the same steps with `B` as the origin.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将以`B`为起点重复相同的步骤。
- en: At the end, we will reach the goal `F` with the path (`A,B,D,F`) with a cumulative
    heuristic of 24\. If we were following another path, such as (`A,B,E,F`), the
    cumulative heuristic will be 30, which is higher than the shortest path.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们将通过路径(`A,B,D,F`)到达目标`F`，其累计启发式值为24。如果我们选择另一条路径，例如(`A,B,E,F`)，其累计启发式值为30，明显高于最短路径。
- en: We did not even look at (`A,C,F`) as it was already way over the shortest path.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至没有考虑到(`A,C,F`)，因为它已经远远超出了最短路径。
- en: 'In pathfinding, a good heuristic is the Euclidean distance. If the current
    node is (x, y) and the goal node is (u, v), then we have the following:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 在路径寻找中，一个好的启发式方法是欧几里得距离。如果当前节点为(x, y)，目标节点为(u, v)，则我们有以下公式：
- en: '*distance_from_end( node ) = sqrt( abs( x – u ) ** 2 + abs( y – v ) ** 2 )*'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '*distance_from_end( node ) = sqrt( abs( x – u ) ** 2 + abs( y – v ) ** 2 )*'
- en: Here, `distance_from_end(node)` is an admissible heuristic estimation showing
    how far we are from the goal node.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`distance_from_end(node)`是一个可接受的启发式估算，表示当前节点距离目标节点的距离。
- en: 'We also have the following:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要考虑以下内容：
- en: '`sqrt` is the square root function. Do not forget to import it from the `math`
    library.'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqrt`是平方根函数。别忘了从`math`库导入它。'
- en: '`abs` is the absolute value function, that is, `abs( -2 ) = abs( 2 ) = 2`.'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abs`是绝对值函数，即`abs( -2 ) = abs( 2 ) = 2`。'
- en: '`x ** 2` is `x` raised to the second power.'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x ** 2`表示`x`的平方。'
- en: We will use the `distance_from_start` matrix to store the distances from the
    start node. In the algorithm, we will refer to this cost matrix as `distance_from_start(n1)`.
    For any node, `n1`, that has coordinates `(x1, y1)`, this distance is equivalent
    to `distance_from_start[x1][y1]`.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`distance_from_start`矩阵来存储从起点到各个节点的距离。在算法中，我们会将这个成本矩阵称为`distance_from_start(n1)`。对于任何节点`n1`，其坐标为`(x1,
    y1)`，该距离等同于`distance_from_start[x1][y1]`。
- en: We will use the `succ(n)` notation to generate a list of successor nodes from
    `n`.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`succ(n)`符号来生成从`n`出发的后继节点列表。
- en: Note
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE64]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Have a look at the pseudocode of the algorithm:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下算法的伪代码：
- en: '[PRE65]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Regarding the retrieval of the shortest path, we can use the `costs` matrix.
    This matrix contains the distance of each node on the path from the start node.
    As cost always decreases when walking backward, all we need to do is start with
    the end node and walk backward greedily toward decreasing costs:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 关于最短路径的检索，我们可以使用`costs`矩阵。该矩阵包含从起点到路径上每个节点的距离。由于在回退时成本总是减少，我们所需要做的就是从终点开始，贪婪地向着成本递减的方向回退：
- en: '[PRE66]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'A* shines when we have one start state and one goal state. The complexity of
    the A* algorithm is `O( E )`, where `E` stands for all possible edges in the field.
    In our example, we have up to four edges leaving any node: up, down, left, and
    right.'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们只有一个起始状态和一个目标状态时，A*算法表现得尤为出色。A*算法的复杂度是`O( E )`，其中`E`表示场景中所有可能的边。在我们的示例中，每个节点最多有四条边：上、下、左、右。
- en: Note
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To sort the frontier list in the proper order, we must use a special Python
    data structure: a priority queue.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 要按正确顺序排序边界列表，我们必须使用一种特殊的Python数据结构：优先队列。
- en: 'Have a look at the following example:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的示例：
- en: '[PRE67]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The expected output is this:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出是这个：
- en: '[PRE68]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The data still contains the second item. If you type in the following command,
    you will be able to see it:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 数据仍然包含第二个项目。如果你输入以下命令，你将能看到它：
- en: '[PRE69]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The expected output is this:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出是这个：
- en: '[PRE70]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Why is it important that the heuristic being used by the algorithm is admissible?
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么算法使用的启发式方法是可接受的，这一点很重要？
- en: Because this is how we guarantee the optimal nature of the algorithm. For any
    node `x`, we are measuring the sum of the distances from the start node to `x`.
    This is the estimated distance from `x` to the end node. If the estimation never
    overestimates the distance from `x` to the end node, we will never overestimate
    the total distance. Once we are at the goal node, our estimation is zero, and
    the total distance from the start to the end becomes an exact number.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这就是我们确保算法最优性的方式。对于任何节点`x`，我们在测量从起始节点到`x`的距离的总和。这是从`x`到终点节点的估计距离。如果这种估计从未高估`x`到终点节点的距离，我们就不会高估总距离。一旦到达目标节点，我们的估计就是零，从起点到终点的总距离变为准确值。
- en: We can be sure that our solution is optimal because there are no other items
    in the priority queue that have a lower estimated cost. Given that we never overestimate
    our costs, we can be sure that all of the nodes in the frontier of the algorithm
    have either similar total costs or higher total costs than the path we found.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确信我们的解决方案是最优的，因为优先队列中没有其他项具有更低的估算成本。鉴于我们从不高估成本，我们可以确定，算法边界中的所有节点的总成本要么与我们找到的路径相似，要么更高。
- en: 'In the following example, we can see how to implement the A* algorithm to find
    the path with the lowest cost:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们可以看到如何实现A*算法以找到最低成本的路径：
- en: '![ Figure 1.16: Shortest pathfinding game board'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '![ 图 1.16：最短路径寻路游戏板'
- en: '](img/B16060_01_16.jpg)'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_16.jpg)'
- en: 'Figure 1.16: Shortest pathfinding game board'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.16：最短路径寻路游戏板
- en: 'We import `math` and `heapq`:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了`math`和`heapq`：
- en: '[PRE71]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Next, we'll reuse the initialization code from *Steps 2–5* of the previous,
    *Exercise 1.05*, *Finding the Shortest Path Using BFS*.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重用上一个*步骤 2–5*中的初始化代码，*练习 1.05*，*使用BFS找到最短路径*。
- en: Note
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'We have omitted the function to update costs because we will do so within the
    A* algorithm:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了更新成本的函数，因为我们将在A*算法中进行更新：
- en: 'Next, we need to initialize the A* algorithm''s frontier and internal lists.
    For `frontier`, we will use a Python `PriorityQueue`. Do not execute this code
    directly; we will use these four lines inside the A* search function:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要初始化A*算法的边界和内部列表。对于`frontier`，我们将使用Python的`PriorityQueue`。不要直接执行此代码；我们将在A*搜索函数中使用这四行代码：
- en: '[PRE72]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, it is time to implement a heuristic function that measures the distance
    between the current node and the goal node using the algorithm we saw in the heuristic
    section:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候实现一个启发式函数，用来衡量当前节点与目标节点之间的距离，采用我们在启发式部分看到的算法：
- en: '[PRE73]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The final step will be to translate the A* algorithm into functioning code:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的步骤将是将A*算法转换为可运行的代码：
- en: '[PRE74]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The expected output is this:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出是这个：
- en: '[PRE75]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: There are a few differences between our implementation and the original algorithm.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现与原始算法有一些差异。
- en: We defined a `distance_from_start` function to make it easier and more semantic
    to access the `costs` matrix. Note that we number the node indices starting with
    1, while in the matrix, indices start with zero. Therefore, we subtract 1 from
    the node values to get the indices.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`distance_from_start`函数，使得访问`costs`矩阵更简便且更具语义。请注意，我们的节点索引从1开始，而在矩阵中，索引是从0开始的。因此，我们从节点值中减去1来获取索引。
- en: When generating the successor nodes, we automatically ruled out nodes that are
    in the internal set. `successors = succ(node, internal)` makes sure that we only
    get the neighbors whose examination is not closed yet, meaning that their score
    is not necessarily optimal.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成后继节点时，我们自动排除了在内部集合中的节点。`successors = succ(node, internal)`确保我们只得到尚未关闭检查的邻居节点，意味着它们的分数不一定是最优的。
- en: Therefore, we may skip the step check since internal nodes will never end up
    in `succ(n)`.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以跳过步骤检查，因为内部节点永远不会出现在`succ(n)`中。
- en: Since we are using a priority queue, we must determine the estimated priority
    of nodes before inserting them. However, we will only insert the node in the frontier
    if we know that this node does not have an entry with a lower score.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是优先队列，我们必须在插入节点之前确定节点的预估优先级。然而，只有当我们知道该节点没有更低分数的条目时，才会将其插入到前沿中。
- en: It may happen that nodes are already in the frontier queue with a higher score.
    In this case, we remove this entry before inserting it into the right place in
    the priority queue. When we find the end node, we simply return the length of
    the shortest path instead of the path itself.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会出现节点已经在前沿队列中，且分数更高的情况。在这种情况下，我们会在将其插入优先队列的正确位置之前，移除这个条目。当我们找到终点节点时，我们只需返回最短路径的长度，而不是路径本身。
- en: 'To follow what the A* algorithm does, execute the following example code and
    observe the logs:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解A*算法的工作过程，请执行以下示例代码并观察日志：
- en: '[PRE76]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Here, we build the `astar_verbose` function by reusing the code from the `astar`
    function and adding print functions in order to create a log.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过重新使用`astar`函数中的代码并添加打印功能来创建`astar_verbose`函数，从而生成日志。
- en: 'The expected output is this:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出结果是：
- en: '![Figure 1.17: Astar function logs'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.17：Astar函数日志'
- en: '](img/B16060_01_17.jpg)'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_17.jpg)'
- en: 'Figure 1.17: Astar function logs'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.17：Astar函数日志
- en: We have seen that the A* search returns the right values. The question is, how
    can we reconstruct the whole path?
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到A*搜索返回了正确的值。问题是，我们如何重建整个路径呢？
- en: 'For this, we remove the `print` statements from the code for clarity and continue
    with the A* algorithm that we implemented in the previous step. Instead of returning
    the length of the shortest path, we have to return the path itself. We will write
    a function that extracts this path by walking backward from the end node, analyzing
    the `costs` matrix. Do not define this function globally yet. We define it as
    a local function in the A* algorithm that we created previously:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们从代码中删除了`print`语句以提高清晰度，并继续使用我们在前一步实现的A*算法。我们不再返回最短路径的长度，而是返回路径本身。我们将编写一个函数，通过从终点节点向后遍历并分析`costs`矩阵来提取这个路径。暂时不要全局定义这个函数，我们将在之前创建的A*算法中将其定义为局部函数：
- en: '[PRE77]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now that we''ve seen how to deconstruct the path, let''s return it inside the
    A* algorithm:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何解构路径，让我们把它返回到A*算法中：
- en: '[PRE78]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In the preceding code snippet, we have reused the `a-star` function defined
    previously with the notable difference of adding the `get_shortest_path` function.
    Then, we use this function to replace the priority queue since we want the algorithm
    to always choose the shortest path.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们重新使用了之前定义的`a-star`函数，主要的不同之处在于添加了`get_shortest_path`函数。然后，我们使用这个函数替代优先队列，因为我们希望算法总是选择最短的路径。
- en: 'The expected output is this:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出结果是：
- en: '![Figure 1.18: Output showing the priority queue'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.18：显示优先队列的输出'
- en: '](img/B16060_01_18.jpg)'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_18.jpg)'
- en: 'Figure 1.18: Output showing the priority queue'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.18：显示优先队列的输出
- en: Technically, we do not need to reconstruct the path from the `costs` matrix.
    We could record the parent node of each node in the matrix and simply retrieve
    the coordinates to save a bit of searching.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来看，我们不需要从`costs`矩阵中重建路径。我们可以在矩阵中记录每个节点的父节点，并简单地检索坐标以节省一些查找时间。
- en: We are not expecting you to understand all the preceding script as it is quite
    advanced, so we are going to use a library that will simplify it for us.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不指望你理解前面脚本的所有内容，因为它相当高级，所以我们将使用一个简化它的库。
- en: A* Search in Practice Using the simpleai Library
  id: totrans-648
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用simpleai库中的A*搜索实践
- en: The `simpleai` library is available on GitHub and contains many popular AI tools
    and techniques.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '`simpleai`库可在GitHub上获取，包含许多流行的AI工具和技术。'
- en: Note
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can access this library at [https://github.com/simpleai-team/simpleai](https://github.com/simpleai-team/simpleai).
    The documentation of the `simpleai` library can be accessed here: [http://simpleai.readthedocs.io/en/latest/](http://simpleai.readthedocs.io/en/latest/).
    To access the `simpleai` library, first, you have to install it.'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此访问该库：[https://github.com/simpleai-team/simpleai](https://github.com/simpleai-team/simpleai)。`simpleai`
    库的文档可以在此访问：[http://simpleai.readthedocs.io/en/latest/](http://simpleai.readthedocs.io/en/latest/)。要使用
    `simpleai` 库，首先需要安装它。
- en: 'The `simpleai` library can be installed as follows:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '`simpleai` 库可以通过以下方式安装：'
- en: '[PRE79]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Once `simpleai` has been installed, you can import classes and functions from
    the `simpleai` library into a Jupyter Notebook:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 `simpleai`，你就可以在 Jupyter Notebook 中导入 `simpleai` 库的类和函数：
- en: '[PRE80]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '`SearchProblem` gives you a frame for defining any search problems. The `astar`
    import is responsible for executing the A* algorithm inside the search problem.'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '`SearchProblem` 为定义任何搜索问题提供了框架。`astar` 导入负责在搜索问题中执行 A* 算法。'
- en: For simplicity, we have not used classes in the previous code examples to focus
    on the algorithms in a plain old style without any clutter.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，我们在之前的代码示例中没有使用类，以便专注于以简单的旧式风格呈现算法，避免杂乱无章。
- en: Note
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that the `simpleai` library will force us to use classes.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`simpleai` 库将强制我们使用类。
- en: 'To describe a search problem, you need to provide the following:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 要描述一个搜索问题，你需要提供以下内容：
- en: '`constructor`: This initializes the state space, thus describing the problem.
    We will make the `Size`, `Start`, `End`, and `Obstacles` values available in the
    object by adding it to these as properties. At the end of the constructor, do
    not forget to call the super constructor, and do not forget to supply the initial
    state.'
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constructor`：初始化状态空间，从而描述问题。我们通过将 `Size`、`Start`、`End` 和 `Obstacles` 作为属性添加到对象中，使这些值可用。在构造函数的末尾，不要忘记调用父类构造函数，并且不要忘记提供初始状态。'
- en: '`actions( state )`: This returns a list of actions that we can perform from
    a given state. We will use this function to generate new states. Semantically,
    it would make more sense to create action constants such as UP, DOWN, LEFT, and
    RIGHT, and then interpret these action constants as a result. However, in this
    implementation, we will simply interpret an action as "move to `(x, y)`", and
    represent this command as `(x, y)`. This function contains more-or-less the logic
    that we implemented in the `succ` function previously, except that we won''t filter
    the result based on a set of visited nodes.'
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actions( state )`：返回我们可以从给定状态执行的动作列表。我们将使用此函数生成新状态。从语义上讲，创建像 UP、DOWN、LEFT
    和 RIGHT 这样的动作常量会更有意义，然后将这些常量作为结果进行解释。然而，在这个实现中，我们将简单地将动作解释为“移动到 `(x, y)`”，并将这个命令表示为
    `(x, y)`。此函数大致包含了我们在 `succ` 函数中实现的逻辑，只不过我们不会根据已访问的节点集合来筛选结果。'
- en: '`result( state0, action)`: This returns the new state of action that was applied
    to `state0`.'
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`result( state0, action)`：返回应用于 `state0` 的动作所产生的新状态。'
- en: '`is_goal( state )`: This returns `true` if the state is a goal state. In our
    implementation, we will have to compare the state to the end state coordinates.'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_goal( state )`：如果状态是目标状态，则返回 `true`。在我们的实现中，我们需要将状态与终点状态坐标进行比较。'
- en: '`cost( self, state, action, newState )`: This is the cost of moving from `state`
    to `newState` via `action`. In our example, the cost of a move is uniformly 1.'
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cost( self, state, action, newState )`：这是从 `state` 到 `newState` 通过 `action`
    的移动成本。在我们的示例中，每次移动的成本均为 1。'
- en: 'Have a look at the following example:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下示例：
- en: '[PRE81]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In the preceding code snippet, we used the `simpleai` package to simplify our
    code. We also had to define a class called `ShortestPath` in order to use the
    package.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用了 `simpleai` 包来简化我们的代码。我们还必须定义一个名为 `ShortestPath` 的类才能使用该包。
- en: 'The expected output is this:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 1.19: Output showing the queue using the simpleai library'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.19：使用 simpleai 库显示队列的输出'
- en: '](img/B16060_01_19.jpg)'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_19.jpg)'
- en: 'Figure 1.19: Output showing the queue using the simpleai library'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.19：使用 simpleai 库显示队列的输出
- en: The `simpleai` library made the search description a lot easier than the manual
    implementation. All we need to do is define a few basic methods, and then we have
    access to an effective search implementation.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '`simpleai` 库使得搜索描述比手动实现要简单得多。我们只需要定义一些基本方法，然后就可以访问一个有效的搜索实现。'
- en: In the next section, we will be looking at the Minmax algorithm, along with
    pruning.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将讨论 Minmax 算法及其剪枝技术。
- en: Game AI with the Minmax Algorithm and Alpha-Beta Pruning
  id: totrans-675
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Minmax 算法和 Alpha-Beta 剪枝的游戏 AI
- en: In the first two sections, we saw how hard it was to create a winning strategy
    for a simple game such as tic-tac-toe. The previous section introduced a few structures
    for solving search problems with the A* algorithm. We also saw that tools such
    as the `simpleai` library help us to reduce the effort we put in to describe a
    task with code.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个部分中，我们看到为简单的井字棋游戏创建一个获胜策略是多么困难。上一部分介绍了几种利用 A* 算法解决搜索问题的结构。我们还看到，像 `simpleai`
    库这样的工具帮助我们减少了在代码中描述任务时所付出的努力。
- en: We will use all of this knowledge to supercharge our game AI skills and solve
    more complex problems.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用所有这些知识来提升我们的游戏 AI 技能，并解决更复杂的问题。
- en: Search Algorithms for Turn-Based Multiplayer Games
  id: totrans-678
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回合制多人游戏的搜索算法
- en: Turn-based multiplayer games such as tic-tac-toe are similar to pathfinding
    problems. We have an initial state and we have a set of end states where we win
    the game.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 类似井字棋这类回合制多人游戏与路径寻找问题相似。我们有一个初始状态，并且有一组结束状态，在这些状态下我们赢得了游戏。
- en: The challenge with turn-based multiplayer games is the combinatorial explosion
    of the opponent's possible moves. This difference justifies treating turn-based
    games differently to a regular pathfinding problem.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 回合制多人游戏的挑战在于对手可能移动的组合爆炸。这种差异使得我们有理由将回合制游戏与常规的路径寻找问题区别开来。
- en: For instance, in the tic-tac-toe game, from an empty board, we can select one
    of the nine cells and place our sign there, assuming we start the game. Let's
    denote this algorithm with the `succ` function, symbolizing the creation of successor
    states. Consider we have the initial state denoted by `Si`.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在井字棋游戏中，从空白棋盘开始，我们可以选择九个格子中的一个并将我们的标志放在那里，假设我们先开始游戏。我们可以用 `succ` 函数来表示这个算法，象征着后继状态的创建。假设我们有一个初始状态，记作
    `Si`。
- en: 'Here, we have `succ(Si) returns [ S1, S2, ..., Sn ]`, where `S1, S2, ..., Sn`
    are successor states:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有 `succ(Si) returns [ S1, S2, ..., Sn ]`，其中 `S1, S2, ..., Sn` 是后继状态：
- en: '![Figure 1.20: Tree diagram denoting the successor states of the function'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.20：表示函数后继状态的树形图'
- en: '](img/B16060_01_20.jpg)'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_20.jpg)'
- en: 'Figure 1.20: Tree diagram denoting the successor states of the function'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.20：表示函数后继状态的树形图
- en: 'Then, the opponent also makes a move, meaning that from each possible state,
    we have to examine even more states:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对手也进行移动，这意味着我们需要从每个可能的状态开始，检查更多的状态：
- en: '![Figure 1.21: Tree diagram denoting parent-successor relationships'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.21：表示父节点-后继节点关系的树形图'
- en: '](img/B16060_01_21.jpg)'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_21.jpg)'
- en: 'Figure 1.21: Tree diagram denoting parent-successor relationships'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.21：表示父节点-后继节点关系的树形图
- en: 'The expansion of possible future states stops in one of two cases:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 可能未来状态的扩展会在两种情况下停止：
- en: The game ends.
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏结束。
- en: Due to resource limitations, it is not worth explaining any more moves beyond
    a certain depth for the state of a certain utility.
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于资源限制，对于某一效用的状态，超出某一深度后再继续解释更多的移动是不值得的。
- en: Once we stop expanding, we have to make a static heuristic evaluation of the
    state. This is exactly what we did previously with the A* algorithm, when choosing
    the best move; however, we never considered future states.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们停止扩展，我们就必须对状态进行静态启发式评估。这正是我们之前在 A* 算法中所做的，选择最佳移动时；然而，我们从未考虑过未来的状态。
- en: Therefore, even though our algorithm became more and more complex, without using
    the knowledge of possible future states, we had a hard time detecting whether
    our current move would likely be a winning one or a losing one.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管我们的算法变得越来越复杂，但如果不使用可能的未来状态知识，我们很难判断当前的移动是可能的胜利还是失败。
- en: The only way for us to take control of the future was to change our heuristic
    while knowing how many games we would win, lose, or tie in the future. We could
    either maximize our wins or minimize our losses. We still did not dig deep enough
    to see whether our losses could have been avoided through smarter play on the
    part of the AI.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 我们掌控未来的唯一方法是改变我们的启发式，同时知道未来我们会赢多少局、输多少局，或者平局。我们可以最大化我们的胜利，或者最小化我们的失败。我们仍然没有深入探讨，是否通过
    AI 更聪明的操作，我们的失败本可以避免。
- en: All these problems can be avoided by digging deeper into future states and recursively
    evaluating the utility of the branches.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题都可以通过深入挖掘未来状态并递归评估各分支的效用来避免。
- en: To consider future states, we will learn about the **Minmax** algorithm and
    its variant, the **NegaMax** algorithm.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 为了考虑未来的状态，我们将学习 **Minmax** 算法及其变种 **NegaMax** 算法。
- en: The Minmax Algorithm
  id: totrans-698
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Minmax 算法
- en: 'Suppose there is a game where a heuristic function can evaluate a game state
    from the perspective of the AI player. For instance, we used a specific evaluation
    for the tic-tac-toe exercise:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个游戏，其中启发式函数可以从 AI 玩家角度评估游戏状态。例如，我们在井字棋练习中使用了一个特定的评估方法：
- en: +1,000 points for a move that won the game
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: +1,000 分，表示获胜的棋步
- en: +100 points for a move preventing the opponent from winning the game
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: +100 分，表示通过一步棋阻止对手获胜
- en: +10 points for a move creating two in a row, column, or diagonal
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: +10 分，表示通过一步棋形成两行、列或对角线
- en: +1 point for a move creating one in a row, column, or diagonal
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: +1 分，表示通过一步棋形成一行、列或对角线
- en: This static evaluation is straightforward to implement on any node. The problem
    is that as we go deep into the tree of all possible future states, we do not yet
    know what to do with these scores. This is where the Minmax algorithm comes into
    play.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 这种静态评估在任何节点上实现都很简单。问题是，当我们深入到所有可能的未来状态的树中时，我们还不知道如何处理这些分数。这个时候，Minmax 算法就派上用场了。
- en: 'Suppose we construct a tree with each possible move that could be performed
    by each player up to a certain depth. At the bottom of the tree, we evaluate each
    option. For the sake of simplicity, let''s assume that we have a search tree that
    appears as follows:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们构建了一棵树，树中包含每个玩家在某一深度范围内可能采取的每一步棋。在树的底部，我们评估每个选项。为了简单起见，假设我们的搜索树如下所示：
- en: '![Figure 1.22: Example of a search tree up to a certain depth'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.22：到达一定深度的搜索树示例'
- en: '](img/B16060_01_22.jpg)'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_22.jpg)'
- en: 'Figure 1.22: Example of a search tree up to a certain depth'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.22：到达一定深度的搜索树示例
- en: The AI plays with `X`, and the player plays with `O`. A node with `X` means
    that it is `X`'s turn to move. A node with `O` means it is `O`'s turn to act.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: AI 以 `X` 作为棋子，玩家以 `O` 作为棋子。一个包含 `X` 的节点表示该轮是 `X` 走棋。一个包含 `O` 的节点表示该轮是 `O` 走棋。
- en: 'Suppose there are all `O` leaves at the bottom of the tree, and we didn''t
    compute any more values because of resource limitations. Our task is to evaluate
    the utility of the leaves:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 假设树的底部全是 `O` 叶节点，并且由于资源限制，我们没有计算更多的值。我们的任务是评估这些叶节点的效用：
- en: '![Figure 1.23: Example of a search tree with possible moves'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.23：可能走法的搜索树示例'
- en: '](img/B16060_01_23.jpg)'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_23.jpg)'
- en: 'Figure 1.23: Example of a search tree with possible moves'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.23：可能走法的搜索树示例
- en: 'We have to select the best possible move from our perspective because our goal
    is to maximize the utility of our move. This aspiration to maximize our gains
    represents the Max part in the Minmax algorithm:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须从自己的角度选择最佳的走法，因为我们的目标是最大化走法的效用。最大化收益的愿望代表了 Minmax 算法中的 Max 部分：
- en: '![Figure 1.24: Example of a search tree with the best possible move'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.24：最佳走法的搜索树示例'
- en: '](img/B16060_01_24.jpg)'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_24.jpg)'
- en: 'Figure 1.24: Example of a search tree with the best possible move'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.24：最佳走法的搜索树示例
- en: 'If we move one level higher, it is our opponent''s turn to act. Our opponent
    picks the value that is the least beneficial to us. This is because our opponent''s
    job is to minimize our chances of winning the game. This is the Min part of the
    Minmax algorithm:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向上一层移动，那么就轮到对手行动了。我们的对手会选择对我们最不利的值。因为对手的任务是最小化我们获胜的机会。这就是 Minmax 算法中的 Min
    部分：
- en: '![Figure 1.25: Minimizing the chances of winning the game'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.25：最小化获胜机会'
- en: '](img/B16060_01_25.jpg)'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_25.jpg)'
- en: 'Figure 1.25: Minimizing the chances of winning the game'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.25：最小化获胜机会
- en: 'At the top, we can choose between a move with utility `101` and another move
    with utility `21`. Since we are maximizing our value, we should pick `101`:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 在最上面，我们可以在效用为 `101` 和效用为 `21` 的两个走法之间进行选择。由于我们要最大化我们的价值，我们应该选择效用为 `101` 的走法：
- en: '![Figure 1.26: Maximizing the chances of winning the game'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.26：最大化获胜机会'
- en: '](img/B16060_01_26.jpg)'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_26.jpg)'
- en: 'Figure 1.26: Maximizing the chances of winning the game'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.26：最大化获胜机会
- en: 'Let''s see how we can implement this idea:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现这个想法：
- en: '[PRE82]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This is the Minmax algorithm. We evaluate the leaves from our perspective.
    Then, from the bottom up, we apply a recursive definition:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Minmax 算法。我们从自己的角度评估叶节点。然后，从下往上，我们应用递归定义：
- en: Our opponent plays optimally by selecting the worst possible node from our perspective.
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的对手通过选择对我们最不利的节点来进行最佳游戏。
- en: We play optimally by selecting the best possible node from our perspective.
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过选择对我们最有利的节点来进行最佳游戏。
- en: 'We need a few more things in order to understand the application of the Minmax
    algorithm on the tic-tac-toe game:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解Minmax算法在井字棋游戏中的应用，我们还需要一些额外的信息：
- en: '`is_end_state` is a function that determines whether the state should be evaluated
    instead of digging deeper, either because the game has ended, or because the game
    is about to end using forced moves. Using our utility function, it is safe to
    say that as soon as we reach a score of 1,000 or higher, we have effectively won
    the game. Therefore, `is_end_state` can simply check the score of a node and determine
    whether we need to dig deeper.'
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_end_state`是一个函数，用于判断是否应该评估当前状态，而不是继续深入搜索。这通常发生在游戏结束时，或者因为强制性走法导致游戏即将结束。利用我们的效用函数，可以安全地说，一旦我们获得1,000分或更高分数时，我们就有效地赢得了游戏。因此，`is_end_state`可以简单地检查节点的得分，判断是否需要继续深入。'
- en: Although the `successors` function only depends on the state, it is practical
    to pass the information of whose turn it is to make a move. Therefore, do not
    hesitate to add an argument if needed; you do not have to follow the pseudo code.
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管`successors`函数只依赖于状态，但传递轮到谁走的信息是很实际的。因此，如果需要，可以添加一个参数；你不必完全遵循伪代码。
- en: We want to minimize our efforts in implementing the Minmax algorithm. For this
    reason, we will evaluate existing implementations of the algorithm. We will also
    simplify the duality of the description of the algorithm in the remainder of this
    section.
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望尽量减少在实现Minmax算法时的努力。因此，我们将评估现有的算法实现。同时，在本节的其余部分，我们将简化算法描述的对偶性。
- en: The suggested utility function is quite accurate compared to the utility functions
    that we could be using in this algorithm. In general, the deeper we go, the less
    accurate our utility function has to be. For instance, if we could go nine steps
    deep into the tic-tac-toe game, all we would need to do is award 1 point for a
    win, 0 for a draw, and -1 point for a loss, given that, in nine steps, the board
    is complete, and we have all of the necessary information to make the evaluation.
    If we could only look four steps deep, this utility function would be completely
    useless at the start of the game because we need at least five steps to win the
    game.
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所建议的效用函数与我们在该算法中可能使用的效用函数相比，十分准确。一般而言，越是向深层次搜索，我们的效用函数所需的准确性就越低。例如，如果我们可以深入到井字棋的九步之内，我们所需要做的只是为胜利奖励1分，为平局奖励0分，为失败扣1分，因为在九步内，棋盘已完成，我们拥有了做出评估所需的所有信息。如果我们只能看到四步深度，这个效用函数在游戏开始时就完全没用了，因为我们至少需要五步才能赢得游戏。
- en: The Minmax algorithm could be optimized further by pruning the tree. Pruning
    is an act where we get rid of branches that do not contribute to the result. By
    eliminating unnecessary computations, we save precious resources that could be
    used to go deeper into the tree.
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Minmax算法可以通过修剪树进一步优化。修剪是一种通过去除不贡献于结果的分支来优化算法的操作。通过消除不必要的计算，我们节省了宝贵的资源，这些资源可以用于深入搜索树。
- en: Optimizing the Minmax Algorithm with Alpha-Beta Pruning
  id: totrans-737
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Alpha-Beta剪枝优化Minmax算法
- en: The last consideration in the previous thought process primed us to explore
    possible optimizations by reducing the search space by focusing our attention
    on nodes that matter.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 上述思考过程中的最后一个考虑因素促使我们探索通过集中注意力于关键节点，减少搜索空间，从而实现优化。
- en: There are a few constellations of nodes in the tree where we can be sure that
    the evaluation of a subtree does not contribute to the end result. We will find,
    examine, and generalize these constellations to optimize the Minmax algorithm.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 树中有一些节点组合，我们可以确定评估某个子树不会对最终结果产生贡献。我们将找出这些组合，进行分析，并总结出它们以优化Minmax算法。
- en: 'Let''s examine pruning through the previous example of nodes:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过之前的节点示例来检查剪枝过程：
- en: '![Figure 1.27: Search tree demonstrating pruning nodes'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.27：演示剪枝节点的搜索树'
- en: '](img/B16060_01_27.jpg)'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_27.jpg)'
- en: 'Figure 1.27: Search tree demonstrating pruning nodes'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.27：演示剪枝节点的搜索树
- en: After computing the nodes with values `101`, `23`, and `110`, we can conclude
    that two levels above, the value `101` will be chosen. Why?
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算了值为`101`、`23`和`110`的节点后，我们可以得出结论：在两层以上的地方，值为`101`的节点将被选择。为什么？
- en: Suppose X <= 110\. Here, the maximum of `110` and X will be chosen, which is
    `110`, and X will be omitted.
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设X <= 110。在这种情况下，将选择`110`和X中的最大值，即`110`，而X将被忽略。
- en: Suppose X > 110\. Here, the maximum of `110` and X is X. One level above, the
    algorithm will choose the lowest value out of the two. The minimum of `101` and
    X will always be `101`, because X > 110\. Therefore, X will be omitted a level
    above.
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设 X > 110。这里，`110` 和 X 的最大值是 X。往上一层，算法将从两者中选择最小值。`101` 和 X 的最小值始终是 `101`，因为
    X > 110。因此，X 会在上一层被省略。
- en: This is how we prune the tree.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们修剪树的方式。
- en: On the right-hand side, suppose we computed branches `10` and `21`. Their maximum
    is `21`. The implication of computing these values is that we can omit the computation
    of nodes Y1, Y2, and Y3, and we know that the value of Y4 is less than or equal
    to `21`. Why?
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，假设我们计算了分支 `10` 和 `21`。它们的最大值是 `21`。计算这些值的意义是我们可以省略对节点 Y1、Y2 和 Y3 的计算，并且知道
    Y4 的值小于或等于 `21`。为什么？
- en: The minimum of `21` and Y3 is never greater than `21`. Therefore, Y4 will never
    be greater than `21`.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '`21` 和 Y3 的最小值永远不会大于 `21`。因此，Y4 的值永远不会大于 `21`。'
- en: 'We can now choose between a node with utility `101` and another node with a
    maximal utility of `21`. It is obvious that we have to choose the node with utility
    `101`:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在一个效用值为 `101` 的节点和一个效用最大值为 `21` 的节点之间做选择。显然，我们必须选择效用值为 `101` 的节点：
- en: '![Figure 1.28: Example of pruning a tree'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.28：修剪树的示例'
- en: '](img/B16060_01_28.jpg)'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_28.jpg)'
- en: 'Figure 1.28: Example of pruning a tree'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.28：修剪树的示例
- en: This is the idea behind alpha-beta pruning. We prune subtrees that we know are
    not going to be needed.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 alpha-beta 剪枝的核心思想。我们剪枝掉那些我们知道不会被使用的子树。
- en: Let's see how we can implement alpha-beta pruning in the Minmax algorithm.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 Minmax 算法中实现 alpha-beta 剪枝。
- en: 'First, we will add an alpha and a beta argument to the argument list of Minmax:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将向 Minmax 的参数列表中添加 alpha 和 beta 参数：
- en: '[PRE83]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In the preceding code snippet, we added the `alpha` and `beta` arguments to
    the `MinMax` function in order to calculate the new alpha score as being the maximum
    between `alpha` and `beta` in the maximizing branch.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将 `alpha` 和 `beta` 参数添加到 `MinMax` 函数中，以便在最大化分支中计算出 `alpha` 和 `beta`
    之间的最大值作为新的 alpha 值。
- en: 'Now, we need to do the same with the minimizing branch:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要对最小化分支做相同的操作：
- en: '[PRE84]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: In the preceding code snippet, we added the new beta score in the `else` branch,
    which is the minimum between `alpha` and `beta` in the minimizing branch.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们在 `else` 分支中添加了新的 beta 值，它是最小化分支中 `alpha` 和 `beta` 之间的最小值。
- en: We are done with the implementation. It is recommended that you mentally execute
    the algorithm on our example tree step by step to get a feel for the implementation.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了实现。建议你在我们的示例树上逐步执行算法，以便更好地理解实现过程。
- en: 'One important piece is missing that has prevented us from doing the execution
    properly: the initial values for `alpha` and `beta`. Any number that is outside
    the possible range of utility values will do. We will use positive and negative
    infinity as initial values to call the Minmax algorithm:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要部分缺失，导致我们无法正确执行：`alpha` 和 `beta` 的初始值。任何在可能的效用值范围外的数字都可以作为初始值。我们将使用正负无穷大作为初始值来调用
    Minmax 算法：
- en: '[PRE85]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: In the next section, we will look at the DRYing technique while using the NegaMax
    algorithm.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨使用 NegaMax 算法时的 DRY 技术。
- en: DRYing Up the Minmax Algorithm – the NegaMax Algorithm
  id: totrans-766
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使 Minmax 算法更简洁——NegaMax 算法
- en: The Minmax algorithm works great, especially with alpha-beta pruning. The only
    problem is that we have `if` and `else` branches in the algorithm that essentially
    negates each other.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: Minmax 算法运行良好，特别是结合了 alpha-beta 剪枝。唯一的问题是算法中存在 `if` 和 `else` 分支，它们实际上是相互否定的。
- en: As we know, in computer science, there is DRY code and WET code. **DRY** stands
    for **Don't Repeat Yourself**. **WET** stands for **Write Everything Twice**.
    When we write the same code twice, we double our chance of making a mistake while
    writing it. We also double our chances of each maintenance effort being executed
    in the future. Hence, it is better to reuse our code.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，在计算机科学中，有 DRY 代码和 WET 代码。**DRY** 代表 **Don't Repeat Yourself**（不要重复自己）。**WET**
    代表 **Write Everything Twice**（写两遍所有内容）。当我们重复编写相同的代码时，我们增加了写错的机会，也加大了每次维护时出错的概率。因此，最好复用代码。
- en: When implementing the Minmax algorithm, we always compute the utility of a node
    from the perspective of the AI player. This is why we have to have a utility-maximizing
    branch and a utility-minimizing branch in the implementations that are dual in
    nature. As we prefer clean code that describes the problem only once, we could
    get rid of this duality by changing the point of view of the evaluation.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现Minmax算法时，我们总是从AI玩家的角度计算节点的效用。这就是为什么在实现中，我们需要有效用最大化的分支和有效用最小化的分支，它们本质上是对立的。由于我们偏向于编写描述问题的简洁代码，我们可以通过改变评估的视角来消除这种对立。
- en: Whenever the AI player's turn comes, nothing changes in the algorithm.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 每当AI玩家的回合到来时，算法不需要做任何改变。
- en: Whenever the opponent's turn comes, we negate the perspective. Minimizing the
    AI player's utility is equivalent to maximizing the opponent's utility.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 每当对手的回合到来时，我们会反转视角。最小化AI玩家的效用等同于最大化对手的效用。
- en: 'This simplifies the Minmax algorithm:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 这简化了Minmax算法：
- en: '[PRE86]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: There are necessary conditions for using the NegaMax algorithm; for instance,
    the evaluation of the board state has to be symmetric. If a game state is worth
    +20 from the first player's perspective, it is worth -20 from the second player's
    perspective. Therefore, we often normalize the scores around zero.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NegaMax算法时有一些必要条件；例如，棋盘状态的评估必须是对称的。如果从第一玩家的角度，某个游戏状态的价值为+20，那么从第二玩家的角度，它的价值应为-20。因此，我们通常将得分归一化，使其围绕零。
- en: Using the EasyAI Library
  id: totrans-775
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用EasyAI库
- en: We have already looked at the `simpleai` library, which helped us execute searches
    on pathfinding problems. Now, we will use the `EasyAI` library, which can easily
    handle an AI search on two-player games, reducing the implementation of the tic-tac-toe
    problem to writing a few functions on scoring the utility of a board and determining
    when the game ends.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用过`simpleai`库，它帮助我们执行路径寻找问题的搜索。现在，我们将使用`EasyAI`库，它可以轻松处理二人对战游戏的AI搜索，将井字棋问题的实现简化为编写几个用于评估棋盘效用并判断游戏结束的函数。
- en: 'To install `EasyAI`, type the following command in Jupyter Notebook:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`EasyAI`，请在Jupyter Notebook中输入以下命令：
- en: '[PRE87]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Note
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: You can read the documentation of the library on GitHub at [https://github.com/Zulko/easyAI](https://github.com/Zulko/easyAI).
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上查看该库的文档，网址为[https://github.com/Zulko/easyAI](https://github.com/Zulko/easyAI)。
- en: 'Activity 1.04: Connect Four'
  id: totrans-781
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 1.04：四连棋
- en: In this activity, we will practice using the `EasyAI` library and develop a
    heuristic. We will be using the game *Connect Four* for this. The game board is
    seven cells wide and seven cells high. When you make a move, you can only select
    the column in which you drop your token. Then, gravity pulls the token down to
    the lowest possible empty cell. Your objective is to connect four of your own
    tokens horizontally, vertically, or diagonally, before your opponent does, or
    you run out of empty spaces.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 在本活动中，我们将练习使用`EasyAI`库并开发启发式方法。我们将使用游戏*四连棋*进行练习。游戏棋盘宽7格，高7格。每当你进行一次移动时，你只能选择一个列来放置你的棋子。然后，重力会将棋子拉到底部的空格。你的目标是在对方之前，横向、纵向或斜向连接四个自己的棋子，或者当棋盘没有空位时，游戏结束。
- en: Note
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: The rules of the game can be found at [https://en.wikipedia.org/wiki/Connect_Four](https://en.wikipedia.org/wiki/Connect_Four).
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏规则可以在[https://en.wikipedia.org/wiki/Connect_Four](https://en.wikipedia.org/wiki/Connect_Four)找到。
- en: Open a new Jupyter Notebook file.
  id: totrans-785
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Jupyter Notebook文件。
- en: Write the `init` method to generate all the possible winning combinations in
    the game and save them for future use.
  id: totrans-786
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`init`方法，生成游戏中所有可能的胜利组合，并保存以备将来使用。
- en: Write a function to enumerate all the possible moves. Then, for each column,
    check whether there is an unoccupied field. If there is one, make the column a
    possible move.
  id: totrans-787
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数来列举所有可能的移动。然后，检查每一列是否有空位。如果有空位，则将该列视为可能的移动。
- en: Create a function to make a move (it will be similar to the possible move function),
    and then check the column of the move and find the first empty cell, starting
    from the bottom.
  id: totrans-788
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数来进行移动（它将类似于可能移动函数），然后检查该列并从底部开始找到第一个空格。
- en: Reuse the lose function from the tic-tac-toe example.
  id: totrans-789
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重用井字棋示例中的输掉函数。
- en: Implement the show method that prints the board and try out the game.
  id: totrans-790
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现显示方法，打印棋盘并尝试游戏。
- en: Note
  id: totrans-791
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注
- en: The solution to this activity can be found on page 330.
  id: totrans-792
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第330页找到。
- en: 'The expected output is this:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出是这样的：
- en: '![Figure 1.29: Expected output for the game Connect Four'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.29：四连棋游戏的预期输出](https://example.org/figure1.29)'
- en: '](img/B16060_01_29.jpg)'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16060_01_29.jpg)'
- en: 'Figure 1.29: Expected output for the game Connect Four'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.29：游戏《四子棋》的预期输出
- en: Summary
  id: totrans-797
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how AI can be used to enhance or substitute human
    abilities such as to listen, speak, understand language, store and retrieve information,
    think, see, and move.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到AI如何用于增强或替代人类的能力，例如听、说、理解语言、存储和检索信息、思考、看和移动。
- en: Then, we moved on to learning about intelligent agents and the way they interact
    with the environment, solving a problem in a seemingly intelligent way to pursue
    a goal.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们开始学习智能体以及它们如何与环境互动，通过看似智能的方式解决问题并追求目标。
- en: Then, we introduced Python and learned about its role in AI. We looked at a
    few important Python libraries for developing AI and prepared data for the intelligent
    agents. We then created a tic-tac-toe game based on predefined rules. We quantified
    these rules into a number, a process that we call heuristics. We learned how to
    use heuristics in the A* search algorithm to find an optimal solution to a problem.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们介绍了Python，并学习了它在AI中的作用。我们研究了一些重要的Python库，用于开发AI，并为智能体准备了数据。随后，我们基于预定义的规则创建了一个井字棋游戏。我们将这些规则量化成数字，这个过程我们称之为启发式。我们学习了如何在A*搜索算法中使用启发式来找到问题的最优解。
- en: Finally, we got to know about the Minmax and NegaMax algorithms so that the
    AI could win two-player games. In the next chapter, you will be introduced to
    regression.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们了解了Minmax和NegaMax算法，使得AI能够在双人游戏中获胜。在下一章中，你将接触到回归分析。
