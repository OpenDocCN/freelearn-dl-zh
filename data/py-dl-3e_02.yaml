- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Neural Networks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 神经网络
- en: In [*Chapter 1*](B19627_01.xhtml#_idTextAnchor016), we introduced a number of
    basic **machine learning** (**ML**) concepts and techniques. We went through the
    main ML paradigms, as well as some popular classic ML algorithms, and we finished
    on **neural networks** (**NN**). In this chapter, we will formally introduce what
    NNs are, discuss their mathematical foundations, describe in detail how their
    building blocks work, see how we can stack many layers to create a deep feedforward
    NN, and then learn how to train them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B19627_01.xhtml#_idTextAnchor016)中，我们介绍了许多基本的**机器学习**（**ML**）概念和技术。我们讲解了主要的机器学习范式以及一些经典的流行机器学习算法，最后介绍了**神经网络**（**NN**）。在本章中，我们将正式介绍神经网络是什么，讨论它们的数学基础，详细描述其构建模块如何工作，看看我们如何堆叠多个层来创建深度前馈神经网络，并学习如何训练它们。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: The need for NNs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 神经网络的需求
- en: The math of NNs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 神经网络的数学
- en: An introduction to NNs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 神经网络简介
- en: Training NNs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练神经网络
- en: The link between NNs and the human brain
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 神经网络与人类大脑的联系
- en: Initially, NNs were inspired by the biological brain (hence the name). Over
    time, however, we’ve stopped trying to emulate how the brain works, and instead,
    we’re focused on finding the correct configurations for specific tasks, including
    computer vision, natural language processing, and speech recognition. You can
    think of it this way – for a long time, we were inspired by the flight of birds,
    but, in the end, we created airplanes, which are quite different. We are still
    far from matching the potential of the brain. Perhaps the machine learning algorithms
    of the future will resemble the brain more, but that’s not the case now. Hence,
    for the rest of this book, we won’t try to create analogies between the brain
    and NNs. To follow this train of thought, we’ll call the smallest building NN
    building blocks **units**, instead of neurons, as they were originally known.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，神经网络（NN）是受生物大脑的启发（因此得名）。然而，随着时间的推移，我们已不再尝试模仿大脑的工作方式，而是集中精力寻找适用于特定任务的正确配置，包括计算机视觉、自然语言处理和语音识别。你可以这样理解——长时间以来，我们受到了鸟类飞行的启发，但最终我们创造了飞机，这与鸟类飞行是截然不同的。我们仍然远未能与大脑的潜力相匹配。也许未来的机器学习算法会更像大脑，但现在情况并非如此。因此，在本书的其余部分，我们将不再试图在大脑和神经网络之间做类比。为了沿着这个思路进行，我们将把最小的神经网络构建模块称为**单元**，而不是最初的“神经元”。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We’ll implement the example in this chapter using Python. If you don’t have
    an environment set up with these tools, fret not – the example is available as
    a Jupyter notebook on Google Colab. You can find the code examples in the book’s
    GitHub repository: [https://github.com/PacktPublishing/Python-Deep-Learning-Third-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Python-Deep-Learning-Third-Edition/tree/main/Chapter02).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中使用 Python 实现示例。如果你尚未设置好相关工具的环境，不用担心——该示例可以在 Google Colab 上作为 Jupyter
    notebook 使用。你可以在本书的 GitHub 仓库中找到代码示例：[https://github.com/PacktPublishing/Python-Deep-Learning-Third-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Python-Deep-Learning-Third-Edition/tree/main/Chapter02)。
- en: The need for NNs
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 神经网络的需求
- en: NNs have been around for many years, and they’ve gone through several periods,
    during which they’ve fallen in and out of favor. However, recently, they have
    steadily gained ground over many other competing machine learning algorithms.
    This resurgence is due to computers getting faster, the use of **graphical processing
    units** (**GPUs**) versus the most traditional use of **central processing units**
    (**CPUs**), better algorithms and NN design, and increasingly larger datasets,
    which we’ll look at in this book. To get an idea of their success, let’s look
    at the ImageNet Large Scale Visual Recognition Challenge ([http://image-net.org/challenges/LSVRC/](http://image-net.org/challenges/LSVRC/),
    or just **ImageNet**). The participants train their algorithms using the ImageNet
    database. It contains more than 1 million high-resolution color images in over
    1,000 categories (one category may be images of cars, another of people, trees,
    and so on). One of the tasks in the challenge is to classify unknown images into
    these categories. In 2011, the winner achieved a top-five accuracy of 74.2%. In
    2012, Alex Krizhevsky and his team entered the competition with a convolutional
    network (a special type of deep network). That year, they won with a top-five
    accuracy of 84.7%. Since then, the winning algorithms have always been NNs, and
    the current top-five accuracy is around 99%. However, deep learning algorithms
    have excelled in other areas – for example, both Google Now and Apple’s Siri assistants
    rely on deep networks for speech recognition and Google’s use of deep learning
    for their translation engines. Recent image and text generation systems such as
    Stability AI’s Stable Diffusion and OpenAI’s DALL-E and ChatGPT are implemented
    with NNs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 神经网络已经存在了许多年，并经历了多个阶段，期间它们的受欢迎程度时高时低。然而，最近，它们在许多其他竞争的机器学习算法中稳步占据了主导地位。这一复兴归因于计算机速度的提升，**图形处理单元**（**GPU**）的使用取代了最传统的**中央处理单元**（**CPU**）使用，算法和神经网络设计的改进，以及日益增大的数据集，这些我们将在本书中探讨。为了让你了解它们的成功，让我们来看看ImageNet大规模视觉识别挑战赛（[http://image-net.org/challenges/LSVRC/](http://image-net.org/challenges/LSVRC/)，或者简称**ImageNet**）。参与者通过使用ImageNet数据库来训练他们的算法。该数据库包含了超过100万张高分辨率彩色图像，涵盖了1,000多个类别（一个类别可能是汽车的图像，另一个类别是人的图像、树木的图像等等）。该挑战赛中的一个任务是将未知的图像分类到这些类别中。2011年，获胜者实现了74.2%的前五名准确率。2012年，Alex
    Krizhevsky及其团队带着卷积网络（深度网络的一种特殊类型）参加了比赛。那年，他们以84.7%的前五名准确率赢得了比赛。从那时起，获胜的算法总是神经网络，而当前的前五名准确率大约为99%。然而，深度学习算法在其他领域也表现出色——例如，谷歌的Google
    Now和苹果的Siri助手依赖深度网络进行语音识别，谷歌也利用深度学习进行翻译引擎的开发。最近的图像和文本生成系统，如Stability AI的Stable
    Diffusion和OpenAI的DALL-E与ChatGPT，都是使用神经网络实现的。
- en: 'We’ll talk about these exciting advances in the following chapters, but for
    now, we’ll focus on the mathematical foundations of NNs. To help us with this
    task, we’ll use simple networks with one or two layers. You can think of these
    as toy examples that are not deep networks, but understanding how they work is
    important. Here’s why:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中讨论这些激动人心的进展，但现在，我们将专注于神经网络的数学基础。为了帮助我们完成这项任务，我们将使用具有一两层的简单网络。你可以将这些视为玩具示例，它们不是深度网络，但理解它们的工作原理非常重要。原因如下：
- en: Knowing the theory of NNs will help you understand the rest of the book because
    a large majority of NNs in use today share common principles. Understanding simple
    networks means that you’ll understand deep networks too.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解神经网络的理论将帮助你理解本书的其余部分，因为如今大多数使用中的神经网络都共享一些共同的原理。理解简单的网络意味着你也能理解深度网络。
- en: Having some fundamental knowledge is always good. It will help you a lot when
    you face some new material (even material not included in this book).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一些基础知识总是有益的。当你面对一些新的材料时（即使是本书未涉及的材料），它会对你大有帮助。
- en: I hope these arguments will convince you of the importance of this chapter.
    As a small consolation, we’ll talk about deep learning in depth (pun intended)
    in [*Chapter 3*](B19627_03.xhtml#_idTextAnchor079).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这些论点能说服你本章的重要性。作为一个小小的安慰，我们将在[*第3章*](B19627_03.xhtml#_idTextAnchor079)中深入讨论深度学习（这个双关语用得很恰当）。
- en: The math of NNs
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 神经网络的数学
- en: In the following few sections, we’ll discuss the mathematical principles of
    NNs. This way, we’ll be able to explain NNs through these very principles in a
    fundamental and structured way.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个部分中，我们将讨论神经网络的数学原理。通过这种方式，我们将能够以一种基础且结构化的方式，通过这些原理来解释神经网络。
- en: Linear algebra
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性代数
- en: Linear algebra deals with objects such as vectors and matrices, linear transformations,
    and linear equations such as ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math>](img/32.png).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数处理的对象包括向量、矩阵、线性变换和线性方程，如 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math>](img/32.png)。
- en: 'Linear algebra identifies the following mathematical objects:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数识别以下数学对象：
- en: '**Scalar**: A single number.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标量**：一个单独的数字。'
- en: '**Vector**: A one-dimensional array of numbers (also known as components or
    **scalars**), where each element has an index. We can denote vectors either with
    a superscript arrow (![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover><mi>x</mi><mo
    stretchy="true">→</mo></mover></mrow></math>](img/33.png)) or in bold (**x**),
    but we’ll mostly use the bold notation throughout the book. The following is an
    example of a vector:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向量**：一个一维的数字数组（也称为分量或**标量**），每个元素都有一个索引。我们可以用上标箭头 (![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover><mi>x</mi><mo
    stretchy="true">→</mo></mover></mrow></math>](img/33.png)) 或加粗字体 (**x**) 来表示向量，但在本书中我们将主要使用加粗符号。以下是一个向量的示例：'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="bold">x</mml:mi><mml:mo>=</mml:mo><mml:mover
    accent="true"><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mo>→</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/34.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="bold">x</mml:mi><mml:mo>=</mml:mo><mml:mover
    accent="true"><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mo>→</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/34.png)'
- en: 'We can represent a *n*-dimensional vector as the coordinates of a point in
    an *n*-dimensional Euclidean space, ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/35.png).
    Think of Euclidean space as a coordinate system – the vector starts at the center
    of that system, and each of the vector’s elements represents the coordinate of
    the point along its corresponding coordinate axis. The following figure shows
    a vector in a three-dimensional coordinate system, ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:math>](img/36.png):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将一个 *n* 维向量表示为一个点在 *n* 维欧几里得空间中的坐标，![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/35.png)。可以将欧几里得空间视为一个坐标系——向量从该坐标系的中心开始，每个向量的元素表示沿其相应坐标轴的点的坐标。下图显示了三维坐标系中的一个向量，![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:math>](img/36.png)：
- en: '![Figure 2.1 – Vector representation in a three-dimensional space](img/B19627_02_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 三维空间中的向量表示](img/B19627_02_01.jpg)'
- en: Figure 2.1 – Vector representation in a three-dimensional space
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 三维空间中的向量表示
- en: 'The figure can also help us define two additional properties of the vector:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该图还帮助我们定义了向量的两个额外属性：
- en: '**Magnitude** (or **length**):'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大小**（或**长度**）：'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfenced
    open="|" close="|"><mi mathvariant="bold">x</mi></mfenced><mo>=</mo><msqrt><mrow><msubsup><mi>x</mi><mn>1</mn><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>x</mi><mn>2</mn><mn>2</mn></msubsup><mo>+</mo><mo>…</mo><mo>+</mo><msubsup><mi>x</mi><mi>n</mi><mn>2</mn></msubsup></mrow></msqrt></mrow></mrow></math>](img/37.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfenced
    open="|" close="|"><mi mathvariant="bold">x</mi></mfenced><mo>=</mo><msqrt><mrow><msubsup><mi>x</mi><mn>1</mn><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>x</mi><mn>2</mn><mn>2</mn></msubsup><mo>+</mo><mo>…</mo><mo>+</mo><msubsup><mi>x</mi><mi>n</mi><mn>2</mn></msubsup></mrow></msqrt></mrow></mrow></math>](img/37.png)'
- en: Think of the magnitude as a generalization of the Pythagorean theorem for an
    n-dimensional space.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将大小视为勾股定理在 n 维空间中的推广。
- en: '**Direction**: The angle between the vector and each axis of the vector space.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方向**：向量与向量空间中各轴之间的角度。'
- en: '**Matrix**: A two-dimensional array of scalars, where each element is identified
    by a row and a column. We’ll denote a matrix with a bold capital letter – for
    example, **A**. Conversely, we’ll denote the matrix elements with the small matrix
    letter, with the row and column as subscript indices – for example, ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/38.png).
    We can see an example of the matrix notation in the following formula:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**矩阵**：一个二维标量数组，每个元素通过行和列来标识。我们用粗体大写字母表示矩阵—例如，**A**。相反，我们用小写字母表示矩阵元素，并将行和列作为下标—例如，![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/38.png)。我们可以在下面的公式中看到矩阵符号的例子：'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="bold">A</mml:mi><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mtd><mml:mtd><mml:mo>⋯</mml:mo></mml:mtd><mml:mtd><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>⋮</mml:mo></mml:mtd><mml:mtd><mml:mo>⋱</mml:mo></mml:mtd><mml:mtd><mml:mo>⋮</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="bold-italic">m</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mtd><mml:mtd><mml:mo>⋯</mml:mo></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="bold-italic">m</mml:mi><mml:mi mathvariant="bold-italic">n</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:math>](img/39.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="bold">A</mml:mi><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mtd><mml:mtd><mml:mo>⋯</mml:mo></mml:mtd><mml:mtd><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>⋮</mml:mo></mml:mtd><mml:mtd><mml:mo>⋱</mml:mo></mml:mtd><mml:mtd><mml:mo>⋮</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="bold-italic">m</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mtd><mml:mtd><mml:mo>⋯</mml:mo></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="bold-italic">m</mml:mi><mml:mi mathvariant="bold-italic">n</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:math>](img/39.png)'
- en: We can represent a vector as either a single-row *1×n* matrix (**row matrix**)
    or a single-column *n×1* matrix (**column matrix**). Transformed like this, the
    vector can participate in different matrix operations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将向量表示为单行的 *1×n* 矩阵（**行矩阵**）或单列的 *n×1* 矩阵（**列矩阵**）。通过这种转换，向量可以参与不同的矩阵运算。
- en: '**Tensor**: The term *tensor* originates from mathematics and physics, where
    it existed long before we started using it in ML. Its definition in these fields
    differs from the one in ML. Fortunately, the tensor in the context of ML is just
    a multi-dimensional array with the following properties:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**张量**：*张量* 这一术语来源于数学和物理学，在我们开始在机器学习中使用它之前，它就已经存在。这些领域中的定义与机器学习中的定义不同。幸运的是，在机器学习的背景下，张量仅仅是一个具有以下属性的多维数组：'
- en: '**Rank**: The number of array dimensions. Vectors and matrices are special
    cases of tensors. A tensor of rank 0 is a scalar, a tensor of rank 1 is a vector,
    and a tensor of rank 2 is a matrix. There is no limit on the number of dimensions,
    and some types of NNs can use tensors of rank 4 or more.'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**秩**：数组的维度数量。向量和矩阵是张量的特殊情况。秩为 0 的张量是标量，秩为 1 的张量是向量，秩为 2 的张量是矩阵。维度数量没有限制，某些类型的神经网络可以使用秩为
    4 或更高的张量。'
- en: '**Shape**: The size of each of the tensor’s dimensions.'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**形状**：张量每个维度的大小。'
- en: '**Data type** of the tensor values. In practice, the data types include 16-,
    32-, and 64-bit floats and 8-, 16-, 32-, and 64-bit integers.'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 张量值的 **数据类型**。在实际应用中，数据类型包括 16 位、32 位和 64 位浮动数，以及 8 位、16 位、32 位和 64 位整数。
- en: The tensor is the main data structure of libraries such as PyTorch, Keras, and
    TensorFlow.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 张量是像 PyTorch、Keras 和 TensorFlow 等库的主要数据结构。
- en: The nature of tensors
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 张量的性质
- en: 'You can find a detailed discussion on the nature of tensors here: [https://stats.stackexchange.com/questions/198061/why-the-sudden-fascination-with-tensors](https://stats.stackexchange.com/questions/198061/why-the-sudden-fascination-with-tensors).
    You can also compare this with the PyTorch ([https://pytorch.org/docs/stable/tensors.html](https://pytorch.org/docs/stable/tensors.html))
    and TensorFlow ([https://www.tensorflow.org/guide/tensor](https://www.tensorflow.org/guide/tensor))
    and tensor definitions.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到关于张量性质的详细讨论：[https://stats.stackexchange.com/questions/198061/why-the-sudden-fascination-with-tensors](https://stats.stackexchange.com/questions/198061/why-the-sudden-fascination-with-tensors)。你还可以将此与
    PyTorch ([https://pytorch.org/docs/stable/tensors.html](https://pytorch.org/docs/stable/tensors.html))
    和 TensorFlow ([https://www.tensorflow.org/guide/tensor](https://www.tensorflow.org/guide/tensor))
    的张量定义进行对比。
- en: Now that we’ve introduced vectors, matrices, and tensors, let’s continue with
    some of the linear operations they can participate in.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经介绍了向量、矩阵和张量，让我们继续讨论它们能参与的某些线性运算。
- en: Vector and matrix operations
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向量和矩阵运算
- en: 'We’ll focus on the operations that relate to NNs, starting with vectors:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重点讨论与神经网络（NNs）相关的运算，从向量开始：
- en: '**Vector addition**: Adds two or more *n*-dimensional vectors, **a** and **b**
    (and so on) to a new vector:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向量加法**：将两个或更多 *n* 维向量 **a** 和 **b**（等等）加在一起，得到一个新的向量：'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="bold">a</mml:mi><mml:mo>+</mml:mo><mml:mi
    mathvariant="bold">b</mml:mi><mml:mo>=</mml:mo><mml:mfenced open="[" close="]"
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/40.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="bold">a</mml:mi><mml:mo>+</mml:mo><mml:mi
    mathvariant="bold">b</mml:mi><mml:mo>=</mml:mo><mml:mfenced open="[" close="]"
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/40.png)'
- en: '**Dot (or scalar) product**: Combines two *n*-dimensional vectors, **a** and
    **b**, into a **scalar value**:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点积（或标量积）**：将两个 *n* 维向量 **a** 和 **b** 合并为一个 **标量值**：'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="bold">a</mml:mi><mml:mo>⋅</mml:mo><mml:mi
    mathvariant="bold">b</mml:mi><mml:mo>=</mml:mo><mml:mfenced open="|" close="|"
    separators="|"><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow></mml:mfenced><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow></mml:mfenced><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>θ</mml:mi></mml:math>](img/41.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="bold">a</mml:mi><mml:mo>⋅</mml:mo><mml:mi
    mathvariant="bold">b</mml:mi><mml:mo>=</mml:mo><mml:mfenced open="|" close="|"
    separators="|"><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow></mml:mfenced><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow></mml:mfenced><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>θ</mml:mi></mml:math>](img/41.png)'
- en: 'Here, the angle between the two vectors is *θ*, and ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/42.png)
    and ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/43.png)
    are their magnitudes. For example, if the vectors are *two*-dimensional and their
    components are ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math>](img/44.png),
    the preceding formula becomes the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，两个向量之间的夹角是*θ*，而![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/42.png)
    和 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/43.png)
    是它们的大小。例如，如果这些向量是*二维*的，且它们的分量为 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math>](img/44.png)，则上面的公式变为如下：
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="bold">a</mml:mi><mml:mo>⋅</mml:mo><mml:mi
    mathvariant="bold">b</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math>](img/45.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="bold">a</mml:mi><mml:mo>⋅</mml:mo><mml:mi
    mathvariant="bold">b</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math>](img/45.png)'
- en: 'The following diagram illustrates the dot product of **a** and **b**:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了**a**和**b**的点积：
- en: '![Figure 2.2 – The dot product of vectors – top: vector components, and bottom:
    the dot product of the two vectors](img/B19627_02_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 向量的点积 – 上方：向量分量，和下方：两个向量的点积](img/B19627_02_02.jpg)'
- en: 'Figure 2.2 – The dot product of vectors – top: vector components, and bottom:
    the dot product of the two vectors'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 向量的点积 – 上方：向量分量，和下方：两个向量的点积
- en: 'We can think of the dot product as a similarity measure between the two vectors,
    where the angle *θ* indicates how similar they are. If *θ* is small (the vectors
    have similar directions), then their dot product will be higher because ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>θ</mml:mi></mml:math>](img/46.png)
    will converge toward 1\. In this context, we can define a **cosine similarity**
    between two vectors as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将点积视为两个向量之间的相似度度量，其中角度*θ*表示它们的相似程度。如果*θ*很小（即向量方向相似），那么它们的点积将更高，因为![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>θ</mml:mi></mml:math>](img/46.png)会趋近于
    1。在这种情况下，我们可以定义两个向量之间的**余弦相似度**如下：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi><mo>=</mo><mfrac><mrow><mi
    mathvariant="bold">a</mi><mo>⋅</mo><mi mathvariant="bold">b</mi></mrow><mrow><mfenced
    open="|" close="|"><mi mathvariant="bold">a</mi></mfenced><mfenced open="|" close="|"><mi
    mathvariant="bold">b</mi></mfenced></mrow></mfrac></mrow></mrow></math>](img/47.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi><mo>=</mo><mfrac><mrow><mi
    mathvariant="bold">a</mi><mo>⋅</mo><mi mathvariant="bold">b</mi></mrow><mrow><mfenced
    open="|" close="|"><mi mathvariant="bold">a</mi></mfenced><mfenced open="|" close="|"><mi
    mathvariant="bold">b</mi></mfenced></mrow></mfrac></mrow></mrow></math>](img/47.png)'
- en: '**Cross (or vector) product**: A combination of two vectors, **a** and **b**,
    in a new vector, which is perpendicular to both initial vectors. The magnitude
    of the output vector is equal to the following:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**叉积（或向量积）**：两个向量**a**和**b**的组合，得到一个新的向量，该向量垂直于两个初始向量。输出向量的大小等于以下公式：'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="bold">a</mml:mi><mml:mo>×</mml:mo><mml:mi
    mathvariant="bold">b</mml:mi><mml:mo>=</mml:mo><mml:mfenced open="|" close="|"
    separators="|"><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow></mml:mfenced><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow></mml:mfenced><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>θ</mml:mi></mml:math>](img/48.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="bold">a</mml:mi><mml:mo>×</mml:mo><mml:mi
    mathvariant="bold">b</mml:mi><mml:mo>=</mml:mo><mml:mfenced open="|" close="|"
    separators="|"><mml:mrow><mml:mi mathvariant="bold">a</mml:mi></mml:mrow></mml:mfenced><mml:mfenced
    open="|" close="|" separators="|"><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow></mml:mfenced><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>θ</mml:mi></mml:math>](img/48.png)'
- en: 'We can see an example of a cross product of two-dimensional vectors in the
    following diagram:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在下图中看到二维向量叉积的例子：
- en: '![Figure 2.3 – A cross product of two two-dimensional vectors](img/B19627_02_03.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 两个二维向量的叉积](img/B19627_02_03.jpg)'
- en: Figure 2.3 – A cross product of two two-dimensional vectors
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 两个二维向量的叉积
- en: The output vector is perpendicular (or **normal**) to the plane, which contains
    the input vectors. The output vector magnitude is equal to the area of a parallelogram
    with sides, the **a** and **b** vectors (denoted with light blue in the preceding
    diagram).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 输出向量垂直（或**法向**）于包含输入向量的平面。输出向量的大小等于由**a**和**b**向量（在前面的图中以浅蓝色表示）构成的平行四边形的面积。
- en: 'Now, let’s focus on the matrix operations:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们关注矩阵运算：
- en: '**Matrix transpose**: Flip the matrix along its main diagonal, represented
    by the set of all matrix elements, ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/49.png),
    where *i=j*. We’ll denote the transpose operation with ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>⊤</mml:mi></mml:math>](img/50.png)
    in superscript form. The cell ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/51.png)
    of **A** is equal to the cell ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/49.png)
    of ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>⊤</mml:mi></mml:mrow></mml:msup></mml:math>](img/53.png):'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**矩阵转置**：沿着矩阵的主对角线翻转矩阵，表示为矩阵中所有元素的集合，![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/49.png)，其中
    *i=j*。我们用 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>⊤</mml:mi></mml:math>](img/50.png)
    来表示转置操作。**A** 的单元格 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/51.png)
    等于 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/49.png)
    的单元格，且该单元格属于 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>⊤</mml:mi></mml:mrow></mml:msup></mml:math>](img/53.png)。'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:msub><mml:mrow><mml:mfenced open="[" close="]" separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">⊤</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi
    mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/54.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:msub><mml:mrow><mml:mfenced open="[" close="]" separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">⊤</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi
    mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/54.png)'
- en: 'The transpose of an *m×n* matrix is an *n×m* matrix, as we can see with the
    following examples:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*m×n* 矩阵的转置是一个 *n×m* 矩阵，以下例子可以帮助理解：'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="bold">A</mml:mi><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>13</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>23</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>31</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>33</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>⇒</mml:mo><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">⊤</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>31</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>13</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>23</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>33</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:math>](img/55.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="bold">A</mml:mi><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>13</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>23</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>31</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>33</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>⇒</mml:mo><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">⊤</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>31</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>13</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>23</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>33</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:math>](img/55.png)'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi
    mathvariant="bold">A</mi><mo>=</mo><mfenced open="[" close="]"><mtable columnspacing="0.8000em
    0.8000em" columnwidth="auto auto auto" columnalign="center center center" rowspacing="1.0000ex"
    rowalign="baseline baseline"><mtr><mtd><msub><mi>a</mi><mn>11</mn></msub></mtd><mtd><msub><mi>a</mi><mn>12</mn></msub></mtd><mtd><msub><mi>a</mi><mn>13</mn></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mn>21</mn></msub></mtd><mtd><msub><mi>a</mi><mn>22</mn></msub></mtd><mtd><msub><mi>a</mi><mn>23</mn></msub></mtd></mtr></mtable></mfenced><mo>⇒</mo><msup><mi
    mathvariant="bold">A</mi><mi mathvariant="normal">⊤</mi></msup><mo>=</mo><mfenced
    open="[" close="]"><mtable columnspacing="0.8000em" columnwidth="auto auto" columnalign="center
    center" rowspacing="1.0000ex 1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><msub><mi>a</mi><mn>11</mn></msub></mtd><mtd><msub><mi>a</mi><mn>21</mn></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mn>12</mn></msub></mtd><mtd><msub><mi>a</mi><mn>22</mn></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mn>13</mn></msub></mtd><mtd><msub><mi>a</mi><mn>23</mn></msub></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/56.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi
    mathvariant="bold">A</mi><mo>=</mo><mfenced open="[" close="]"><mtable columnspacing="0.8000em
    0.8000em" columnwidth="auto auto auto" columnalign="center center center" rowspacing="1.0000ex"
    rowalign="baseline baseline"><mtr><mtd><msub><mi>a</mi><mn>11</mn></msub></mtd><mtd><msub><mi>a</mi><mn>12</mn></msub></mtd><mtd><msub><mi>a</mi><mn>13</mn></msub></mtd></tr><mtr><mtd><msub><mi>a</mi><mn>21</mn></msub></mtd><mtd><msub><mi>a</mi><mn>22</mn></msub></mtd><mtd><msub><mi>a</mi><mn>23</mn></msub></td></mtr></mtable></mfenced><mo>⇒</mo><msup><mi
    mathvariant="bold">A</mi><mi mathvariant="normal">⊤</mi></msup><mo>=</mo><mfenced
    open="[" close="]"><mtable columnspacing="0.8000em" columnwidth="auto" columnalign="center"
    rowspacing="1.0000ex 1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><msub><mi>a</mi><mn>11</mn></msub></mtd><mtd><msub><mi>a</mi><mn>21</mn></msub></mtd></tr><mtr><mtd><msub><mi>a</mi><mn>12</mn></msub></mtd><mtd><msub><mi>a</mi><mn>22</mn></msub></td></mtr><mtr><mtd><msub><mi>a</mi><mn>13</mn></msub></mtd><mtd><msub><mi>a</mi><mn>23</mn></msub></td></mtr></mtable></mfenced></mrow></mrow></math>](img/56.png)'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi
    mathvariant="bold">A</mi><mo>=</mo><mfenced open="[" close="]"><mtable columnspacing="0.8000em
    0.8000em" columnwidth="auto auto auto" columnalign="center center center" rowalign="baseline"><mtr><mtd><msub><mi>a</mi><mn>11</mn></msub></mtd><mtd><msub><mi>a</mi><mn>12</mn></msub></mtd><mtd><msub><mi>a</mi><mn>13</mn></msub></mtd></mtr></mtable></mfenced><mo>⇒</mo><msup><mi
    mathvariant="bold">A</mi><mi mathvariant="normal">⊤</mi></msup><mo>=</mo><mfenced
    open="[" close="]"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><msub><mi>a</mi><mn>11</mn></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mn>12</mn></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mn>13</mn></msub></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/57.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi
    mathvariant="bold">A</mi><mo>=</mo><mfenced open="[" close="]"><mtable columnspacing="0.8000em
    0.8000em" columnwidth="auto auto auto" columnalign="center center center" rowspacing="1.0000ex"
    rowalign="baseline"><mtr><mtd><msub><mi>a</mi><mn>11</mn></msub></mtd><mtd><msub><mi>a</mi><mn>12</mn></msub></mtd><mtd><msub><mi>a</mi><mn>13</mn></msub></mtd></mtr></mtable></mfenced><mo>⇒</mo><msup><mi
    mathvariant="bold">A</mi><mi mathvariant="normal">⊤</mi></msup><mo>=</mo><mfenced
    open="[" close="]"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><msub><mi>a</mi><mn>11</mn></msub></mtd></tr><mtr><mtd><msub><mi>a</mi><mn>12</mn></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mn>13</mn></msub></mtd></tr></mtable></mfenced></mrow></mrow></math>](img/57.png)'
- en: '**Matrix-scalar multiplication**: Multiplication of a matrix, **A**, by a scalar,
    *y*, into a new matrix with the same size as the original:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**矩阵-标量乘法**：将矩阵**A**与标量*y*相乘，生成一个与原矩阵相同大小的新矩阵：'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="bold">A</mml:mi><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mi>y</mml:mi></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mi>y</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mi>y</mml:mi></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mi>y</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:math>](img/58.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="bold">A</mml:mi><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mi>y</mml:mi></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mi>y</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mi>y</mml:mi></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mi>y</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:math>](img/58.png)'
- en: '**Matrix-matrix addition**: Element-wise addition of two or more matrices,
    **A** and **B** (and so on), into a new matrix. All input matrices must be the
    same size:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**矩阵加法**：两个或多个矩阵（**A** 和 **B** 等）逐元素相加，得到一个新的矩阵。所有输入矩阵必须具有相同的大小：'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="bold">A</mml:mi><mml:mo>+</mml:mo><mml:mi
    mathvariant="bold">B</mml:mi><mml:mo>=</mml:mo><mml:mfenced open="[" close="]"
    separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:math>](img/59.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="bold">A</mml:mi><mml:mo>+</mml:mo><mml:mi
    mathvariant="bold">B</mml:mi><mml:mo>=</mml:mo><mml:mfenced open="[" close="]"
    separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:math>](img/59.png)'
- en: '**Matrix-vector multiplication**: Multiplication of a matrix, **A**, by a vector,
    **x**, into a new vector:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**矩阵-向量乘法**：将矩阵**A**与向量**x**相乘，得到一个新的向量：'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="bold">A</mml:mi><mml:mi mathvariant="bold">x</mml:mi><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>31</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>31</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:math>](img/60.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="bold">A</mml:mi><mml:mi mathvariant="bold">x</mml:mi><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>31</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>31</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:math>](img/60.png)'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mfenced open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/61.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mfenced open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/61.png)'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="bold">A</mml:mi><mml:mi mathvariant="bold">x</mml:mi><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>3</mml:mn></mml:mtd><mml:mtd><mml:mn>4</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>5</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>6</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn><mml:mo>×</mml:mo><mml:mn>5</mml:mn><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo>×</mml:mo><mml:mn>6</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>3</mml:mn><mml:mo>×</mml:mo><mml:mn>5</mml:mn><mml:mo>+</mml:mo><mml:mn>4</mml:mn><mml:mo>×</mml:mo><mml:mn>6</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>17</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>39</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:math>](img/62.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="bold">A</mml:mi><mml:mi mathvariant="bold">x</mml:mi><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>3</mml:mn></mml:mtd><mml:mtd><mml:mn>4</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>5</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>6</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn><mml:mo>×</mml:mo><mml:mn>5</mml:mn><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo>×</mml:mo><mml:mn>6</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>3</mml:mn><mml:mo>×</mml:mo><mml:mn>5</mml:mn><mml:mo>+</mml:mn><mml:mn>4</mml:mn><mml:mo>×</mml:mo><mml:mn>6</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>17</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>39</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:math>](img/62.png)'
- en: The number of matrix columns must be equal to the vector size. The result of
    an *m×n* matrix, multiplied by an *n*-dimensional vector, is an *m*-dimensional
    vector. We can assume that the rows of the matrix are *n*-dimensional vectors.
    Then, each value of the output vector is the dot product between the corresponding
    matrix row vector and **x**.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的列数必须与向量的大小相等。一个 *m×n* 矩阵与一个 *n* 维向量相乘的结果是一个 *m* 维向量。我们可以假设矩阵的每一行都是 *n* 维向量。那么，输出向量的每一个值都是对应矩阵行向量与**x**的点积。
- en: '**Matrix multiplication**: A binary operation, which represents the multiplication
    of two matrices, **A** and **B**, into a single output matrix. We can think of
    it as multiple matrix-vector multiplications, where each column of the second
    matrix is a vector:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**矩阵乘法**：一种二元运算，表示两个矩阵 **A** 和 **B** 的乘积，得到一个单一的输出矩阵。我们可以将其看作是多个矩阵-向量乘法，其中第二个矩阵的每一列都是一个向量：'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="bold">A</mml:mi><mml:mi mathvariant="bold">B</mml:mi><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>13</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>23</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>31</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>13</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>31</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>13</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>23</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>31</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>23</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:math>](img/63.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="bold">A</mml:mi><mml:mi mathvariant="bold">B</mml:mi><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>13</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>23</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>31</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>13</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>31</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>13</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>22</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></m'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="bold">A</mml:mi><mml:mi mathvariant="bold">B</mml:mi><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>2</mml:mn></mml:mtd><mml:mtd><mml:mn>3</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>4</mml:mn></mml:mtd><mml:mtd><mml:mn>5</mml:mn></mml:mtd><mml:mtd><mml:mn>6</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>3</mml:mn></mml:mtd><mml:mtd><mml:mn>4</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>5</mml:mn></mml:mtd><mml:mtd><mml:mn>6</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>6</mml:mn><mml:mo>+</mml:mo><mml:mn>15</mml:mn></mml:mtd><mml:mtd><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mn>8</mml:mn><mml:mo>+</mml:mo><mml:mn>18</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>4</mml:mn><mml:mo>+</mml:mo><mml:mn>15</mml:mn><mml:mo>+</mml:mo><mml:mn>30</mml:mn></mml:mtd><mml:mtd><mml:mn>8</mml:mn><mml:mo>+</mml:mo><mml:mn>20</mml:mn><mml:mo>+</mml:mo><mml:mn>36</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>22</mml:mn></mml:mtd><mml:mtd><mml:mn>28</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>49</mml:mn></mml:mtd><mml:mtd><mml:mn>64</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:math>](img/64.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="bold">A</mml:mi><mml:mi mathvariant="bold">B</mml:mi><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>2</mml:mn></mml:mtd><mml:mtd><mml:mn>3</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>4</mml:mn></mml:mtd><mml:mtd><mml:mn>5</mml:mn></mml:mtd><mml:mtd><mml:mn>6</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>3</mml:mn></mml:mtd><mml:mtd><mml:mn>4</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>5</mml:mn></mml:mtd><mml:mtd><mml:mn>6</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>6</mml:mn><mml:mo>+</mml:mo><mml:mn>15</mml:mn></mml:mtd><mml:mtd><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mn>8</mml:mn><mml:mo>+</mml:mo><mml:mn>18</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>4</mml:mn><mml:mo>+</mml:mo><mml:mn>15</mml:mn><mml:mo>+</mml:mo><mml:mn>30</mml:mn></mml:mtd><mml:mtd><mml:mn>8</mml:mn><mml:mo>+</mml:mo><mml:mn>20</mml:mn><mml:mo>+</mml:mo><mml:mn>36</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>22</mml:mn></mml:mtd><mml:mtd><mml:mn>28</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>49</mml:mn></mml:mtd><mml:mtd><mml:mn>64</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:math>](img/64.png)'
- en: If we represent the two vectors as matrices, their dot product, ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi
    mathvariant="bold">a</mml:mi><mml:mo>⋅</mml:mo><mml:mi mathvariant="bold">b</mml:mi><mml:mo>=</mml:mo><mml:mi
    mathvariant="bold">a</mml:mi><mml:msup><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mrow><mml:mi>⊤</mml:mi></mml:mrow></mml:msup></mml:math>](img/65.png),
    is equivalent to matrix-matrix multiplication.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这两个向量表示为矩阵，它们的点积，![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="bold">a</mml:mi><mml:mo>⋅</mml:mo><mml:mi
    mathvariant="bold">b</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="bold">a</mml:mi><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">b</mml:mi></mml:mrow><mml:mrow><mml:mi>⊤</mml:mi></mml:mrow></mml:msup></mml:math>](img/65.png)，等同于矩阵与矩阵的乘法。
- en: You can now breathe a sigh of relief because we’ve concluded our introduction
    to linear algebra. Not all is well though, as we’ll focus on probability theory
    next.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以松一口气了，因为我们已经结束了线性代数的介绍。虽然所有的困难还没有结束，接下来我们将重点讨论概率论。
- en: An introduction to probability
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概率论简介
- en: In this section, we’ll introduce some basic concepts of probability theory.
    They will help us later in the book when we discuss NN training algorithms and
    natural language processing.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将介绍一些概率论的基本概念。它们将帮助我们在本书后面讨论神经网络训练算法和自然语言处理时更好地理解相关内容。
- en: 'We’ll start with the concept of a **statistical experiment**, which has the
    following properties:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从**统计实验**的概念开始，统计实验有以下特点：
- en: It is composed of multiple independent trials
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它由多个独立的试验组成
- en: The outcome of each trial is determined by chance (it is **non-deterministic**)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次试验的结果是由偶然决定的（它是**非确定性的**）
- en: It has multiple possible outcomes, known as **events**
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有多个可能的结果，称为**事件**
- en: We know in advance all possible experiment outcomes
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们提前知道所有可能的实验结果
- en: Examples of statistical experiments include a coin toss with two possible outcomes
    (heads or tails) and a dice roll with six possible outcomes (1 to 6).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 统计实验的例子包括硬币抛掷（有两个可能结果：正面或反面）和掷骰子（有六个可能结果：1到6）。
- en: The likelihood that some event, *е*, would occur is known as **probability**
    P(*е*). It is a value in the range of [0, 1]. P(*e*) = 0.5 indicates a 50–50 chance
    that the event will occur, P(*e*) = 0 indicates that the event cannot occur, and
    P(*e*) = 1 indicates that it will always occur.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 某个事件*e*发生的可能性被称为**概率**P(*e*)。它的值在[0, 1]之间。P(*e*) = 0.5表示该事件有50%的可能性发生，P(*e*)
    = 0表示该事件不可能发生，P(*e*) = 1表示该事件必定发生。
- en: 'We can approach probability in two ways:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式来处理概率：
- en: '**Theoretical**: All events are equally likely to occur and the probability
    of the event (outcome) we’re interested in is as follows:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理论**：所有事件的发生概率是相等的，我们感兴趣的事件（结果）的概率如下：'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>P</mtext><mfenced
    open="(" close=")"><mtext>e</mtext></mfenced><mo>=</mo><mfrac><mrow><mtext>N</mtext><mtext>umber of successful outcomes</mtext></mrow><mrow><mtext>T</mtext><mtext>otal number of outcomes</mtext></mrow></mfrac></mrow></mrow></math>](img/66.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>P</mtext><mfenced
    open="(" close=")"><mtext>e</mtext></mfenced><mo>=</mo><mfrac><mrow><mtext>N</mtext><mtext>umber of successful outcomes</mtext></mrow><mrow><mtext>T</mtext><mtext>otal number of outcomes</mtext></mrow></mfrac></mrow></mrow></math>](img/66.png)'
- en: The theoretical probability of the two possible outcomes in the coin toss example
    is P(heads) = P(tails) = 1/2\. In the dice roll example, we have P(each side of
    the dice) = 1/6.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 硬币抛掷的理论概率是P(正面) = P(反面) = 1/2。在掷骰子的例子中，我们有P(每一面) = 1/6。
- en: '**Empirical**: This is the number of times an event, *e*, occurs in relation
    to all trials:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**经验**：这是事件*e*发生的次数与所有试验次数的比值：'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>P</mtext><mfenced
    open="(" close=")"><mi>e</mi></mfenced><mo>=</mo><mfrac><mrow><mtext>N</mtext><mtext>umber of times</mtext><mi>e</mi><mtext>occurs</mtext></mrow><mrow><mtext>T</mtext><mtext>otal number of trials</mtext></mrow></mfrac></mrow></mrow></math>](img/67.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>P</mtext><mfenced
    open="(" close=")"><mi>e</mi></mfenced><mo>=</mo><mfrac><mrow><mtext>N</mtext><mtext>umber of times</mtext><mi>e</mi><mtext>occurs</mtext></mrow><mrow><mtext>T</mtext><mtext>otal number of trials</mtext></mrow></mfrac></mrow></mrow></math>](img/67.png)'
- en: The empirical result of the experiment may show that the events aren’t equally
    likely. For example, if we toss a coin 100 times and observe heads 47 times, the
    empirical probability for heads is P(heads) = 47 / 100 = 0.47\. The law of large
    numbers tells us that we’ll calculate the probability more accurately with a higher
    number of trials.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 实验的经验结果可能表明事件的发生并非等概率。例如，如果我们抛硬币100次，正面朝上的次数是47次，则正面朝上的经验概率为P(正面) = 47 / 100
    = 0.47。大数法则告诉我们，试验次数越多，计算的概率就越准确。
- en: Now, we’ll discuss probability in the context of sets.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在集合的背景下讨论概率。
- en: Probability and sets
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概率与集合
- en: 'In this section, we’ll introduce sets and their properties. We’ll also see
    how to apply these properties in probability theory. Let’s start with some definitions:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍集合及其属性。我们还将看到如何在概率论中应用这些属性。首先从一些定义开始：
- en: '**Sample space**: The **set** (get it?) of all possible events (outcomes) of
    an experiment. We’ll denote it with a capital letter. Like Python, we’ll list
    all events in the sample space with {}. For example, the sample spaces of coin
    toss and dice roll events are ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><msub><mi
    mathvariant="normal">S</mi><mi>c</mi></msub><mo>=</mo><mfenced open="{" close="}"><mrow><mtext>heads,</mtext><mtext>tails</mtext></mrow></mfenced></mrow></mrow></math>](img/68.png)
    and ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi
    mathvariant="normal">S</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced
    open="{" close="}" separators="|"><mml:mrow><mml:mn>1,2</mml:mn><mml:mo>,</mml:mo><mml:mn>3,4</mml:mn><mml:mo>,</mml:mo><mml:mn>5,6</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/69.png)![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi
    mathvariant="normal">S</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced
    open="{" close="}" separators="|"><mml:mrow><mml:mn>1,2</mml:mn><mml:mo>,</mml:mo><mml:mn>3,4</mml:mn><mml:mo>,</mml:mo><mml:mn>5,6</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/70.png)
    respectively.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**样本空间**：实验的**所有可能事件**（结果）的集合。我们用大写字母表示它。像Python一样，我们用{}列出样本空间中的所有事件。例如，掷硬币和掷骰子的样本空间分别是
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><msub><mi mathvariant="normal">S</mi><mi>c</mi></msub><mo>=</mo><mfenced
    open="{" close="}"><mrow><mtext>heads,</mtext><mtext>tails</mtext></mrow></mfenced></mrow></mrow></math>](img/68.png)
    和 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi
    mathvariant="normal">S</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced
    open="{" close="}" separators="|"><mml:mrow><mml:mn>1,2</mml:mn><mml:mo>,</mml:mo><mml:mn>3,4</mml:mn><mml:mo>,</mml:mo><mml:mn>5,6</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/69.png)![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi
    mathvariant="normal">S</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced
    open="{" close="}" separators="|"><mml:mrow><mml:mn>1,2</mml:mn><mml:mo>,</mml:mo><mml:mn>3,4</mml:mn><mml:mo>,</mml:mo><mml:mn>5,6</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/70.png)。'
- en: '**Sample point**: A single event (for example, tails) of the sample space.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**样本点**：样本空间中的单个事件（例如，反面）。'
- en: '**Event**: A single sample point or a combination (**subset**) of sample points
    of the sample space. For example, a combined event is for the dice to land on
    an odd number, ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi
    mathvariant="normal">S</mml:mi></mml:mrow><mml:mrow><mml:mi>o</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced
    open="{" close="}" separators="|"><mml:mrow><mml:mn>1,3</mml:mn><mml:mo>,</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/71.png).'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**：样本空间中的单个样本点或样本点的组合（**子集**）。例如，掷骰子落在奇数上的联合事件是 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi
    mathvariant="normal">S</mml:mi></mml:mrow><mml:mrow><mml:mi>o</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced
    open="{" close="}" separators="|"><mml:mrow><mml:mn>1,3</mml:mn><mml:mo>,</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/71.png)。'
- en: 'Let’s assume that we have a set (sample space), S = {1, 2, 3, 4, 5}, and two
    subsets (combined events), A = {1, 2, 3} and B = {3, 4, 5}. We’ll use them to
    define the following set operations:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个集合（样本空间），S = {1, 2, 3, 4, 5}，和两个子集（联合事件），A = {1, 2, 3} 和 B = {3, 4, 5}。我们将用它们来定义以下集合运算：
- en: '**Intersection**: A set of elements that exist in both A and B:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交集**：A和B中同时存在的元素的集合：'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mtext>A</mml:mtext><mml:mo>∩</mml:mo><mml:mtext>B</mml:mtext><mml:mo>=</mml:mo><mml:mfenced
    open="{" close="}" separators="|"><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/72.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mtext>A</mml:mtext><mml:mo>∩</mml:mo><mml:mtext>B</mml:mtext><mml:mo>=</mml:mo><mml:mfenced
    open="{" close="}" separators="|"><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/72.png)'
- en: If the intersection of A and B is an empty set {}, they are **disjoint**.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果A和B的交集是空集{}，则它们是**不相交**的。
- en: '**Complement**: A set of all elements that aren’t included in A or B:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**补集**：A或B中未包含的所有元素的集合：'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mtext>A</mtext><mo>′</mo></mrow><mo>=</mo><mfenced
    open="{" close="}"><mn>4,5</mn></mfenced><mrow><mtext>B</mtext><mo>′</mo></mrow><mo>=</mo><mfenced
    open="{" close="}"><mn>1,2</mn></mfenced></mrow></mrow></math>](img/73.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mtext>A</mtext><mo>′</mo></mrow><mo>=</mo><mfenced
    open="{" close="}"><mn>4,5</mn></mfenced><mrow><mtext>B</mtext><mo>′</mo></mrow><mo>=</mo><mfenced
    open="{" close="}"><mn>1,2</mn></mfenced></mrow></mrow></math>](https://example.org/img/73.png)'
- en: '**Union**: A set of all elements that exist in either A or B:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并集**：包含A或B中所有元素的集合：'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mtext>A</mml:mtext><mml:mo>∪</mml:mo><mml:mtext>B</mml:mtext><mml:mo>=</mml:mo><mml:mfenced
    open="{" close="}" separators="|"><mml:mrow><mml:mn>1,2</mml:mn><mml:mo>,</mml:mo><mml:mn>3,4</mml:mn><mml:mo>,</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/74.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mtext>A</mml:mtext><mml:mo>∪</mml:mo><mml:mtext>B</mml:mtext><mml:mo>=</mml:mo><mml:mfenced
    open="{" close="}" separators="|"><mml:mrow><mml:mn>1,2</mml:mn><mml:mo>,</mml:mo><mml:mn>3,4</mml:mn><mml:mo>,</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:mfenced></mml:math>](https://example.org/img/74.png)'
- en: 'The following Venn diagrams illustrate these operations:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的维恩图展示了这些操作：
- en: '![Figure 2.4 – Venn diagrams of the possible set relationships](img/B19627_02_04.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 2.4 – 可能集合关系的维恩图](https://example.org/img/B19627_02_04.jpg)'
- en: Figure 2.4 – Venn diagrams of the possible set relationships
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 可能集合关系的维恩图
- en: 'Now, let’s see how to transfer the set operations in the probability domain.
    We’ll work with independent events – that is, the occurrence of one event doesn’t
    affect the probability of the occurrence of another. For example, the outcomes
    of the different coin tosses are independent of one another. With that, let’s
    define the set operations in terms of probability and events:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在概率领域中进行集合操作。我们将处理独立事件——也就是说，一个事件的发生不会影响另一个事件发生的概率。例如，不同硬币投掷的结果彼此独立。因此，让我们根据概率和事件定义集合操作：
- en: '**The intersection of two events**: A set of sample points that exist in both
    events. The probability of the intersection is called **joint probability**:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**两个事件的交集**：存在于两个事件中的样本点的集合。交集的概率称为**联合概率**：'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mtext>P(A∩B)=P(A)</mml:mtext><mml:mtext>×</mml:mtext><mml:mtext>P(B)</mml:mtext></mml:math>](img/75.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mtext>P(A∩B)=P(A)</mml:mtext><mml:mtext>×</mml:mtext><mml:mtext>P(B)</mml:mtext></mml:math>](https://example.org/img/75.png)'
- en: Let’s say that we want to compute the probability of a card being simultaneously
    spades and an ace (more poetically, the ace of spades). The probability for spades
    is P(spades) = 13/52 = ¼, and the probability of an ace is P(ace) = 4/52 = 1/13\.
    The joint probability of the two is P(ace, spades) = (1/13) ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>×</mml:mo></mml:math>](img/76.png)
    (1/4) = 1/52\. We can intuitively validate this result because the ace of spades
    is a unique card, and its probability would be 1/52\. Since we draw a single card,
    the two events occur at the same time and are independent. Had they occurred successively
    – for example, two card draws, where one is a black and the other is an ace –
    we would fall in the domain of conditional probability.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要计算一张卡牌同时是黑桃和一张A牌（更有诗意地说，黑桃A）。黑桃的概率为P(黑桃) = 13/52 = ¼，而A牌的概率为P(A) = 4/52
    = 1/13。两者的联合概率为P(A, 黑桃) = (1/13) ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>×</mml:mo></mml:math>
    (1/4) = 1/52。我们可以直观地验证这个结果，因为黑桃A是一张独特的牌，其概率应为1/52。由于我们抽取的是一张牌，这两个事件同时发生且独立。如果它们依次发生——例如，两次抽卡，其中一次是黑桃，另一次是A——我们将进入条件概率的领域。
- en: The probability of the occurrence of a single event, P(A), is also known as
    **marginal probability** (as opposed to joint probability).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 单个事件发生的概率P(A)也称为**边际概率**（与联合概率相对）。
- en: '**Disjoint (or mutually exclusive) events**: Two or more events that don’t
    share any outcomes. In other words, their respective sample space subsets are
    disjoint. For example, the events of odd or even dice rolls are disjoint. The
    following is true for disjoint events:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互斥（或互相排斥）事件**：两个或多个事件没有共同的结果。换句话说，它们各自的样本空间子集是互斥的。例如，掷骰子的奇数和偶数事件是互斥的。对于互斥事件，有如下性质：'
- en: The joint probability for these events to occur together is P(A![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>∩</mo></mrow></math>](img/77.png)B)
    = 0
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些事件共同发生的联合概率是P(A![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>∩</mo></mrow></math>](img/77.png)B)
    = 0
- en: The sum of the probabilities of disjoint events is ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><msubsup><mo>∑</mo><mrow
    /><mrow /></msubsup><mrow><mtext>P</mtext><mfenced open="(" close=")"><mrow><mtext>disjoint</mtext><mtext>events</mtext></mrow></mfenced></mrow></mrow><mo>≤</mo><mn>1</mn></mrow></mrow></math>](img/78.png)
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互斥事件的概率总和是 ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><msubsup><mo>∑</mo><mrow
    /><mrow /></msubsup><mrow><mtext>P</mtext><mfenced open="(" close=")"><mrow><mtext>互斥</mtext><mtext>事件</mtext></mrow></mfenced></mrow></mrow><mo>≤</mo><mn>1</mn></mrow></mrow></math>](img/78.png)
- en: '**Jointly exhaustive events**: The subsets of such events contain the whole
    sample space between themselves. For example, events A = {1, 2, 3} and B = {4,
    5, 6} are jointly exhaustive because, together, they cover the whole sample space
    S = {1, 2, 3, 4, 5, 6}. The following is true for the probability of jointly exhaustive
    events:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**联合穷尽事件**：此类事件的子集相互之间包含整个样本空间。例如，事件A = {1, 2, 3} 和 B = {4, 5, 6} 是联合穷尽的，因为它们共同覆盖了整个样本空间S
    = {1, 2, 3, 4, 5, 6}。对于联合穷尽事件，其概率有如下性质：'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><munderover><mo>∑</mo><mrow
    /><mrow /></munderover><mrow><mtext>P</mtext><mfenced open="(" close=")"><mtext>jointly exhaustive events</mtext></mfenced></mrow></mrow><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/79.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><munderover><mo>∑</mo><mrow
    /><mrow /></munderover><mrow><mtext>P</mtext><mfenced open="(" close=")"><mtext>联合穷尽事件</mtext></mfenced></mrow></mrow><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/79.png)'
- en: '**Complement events**: Two or more events that are disjoint and jointly exhaustive
    at the same time. For example, odd and even dice roll events are complementary.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互斥事件**：两个或多个事件彼此没有共同的结果，并且它们是联合穷尽的。例如，掷骰子的奇数和偶数事件是互斥的。'
- en: '**Union of events**: A set of events coming from either A or B (not necessarily
    in both). The probability of this union is:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件的并集**：一组来自A或B（不一定都在两个集合中）的事件。该并集的概率是：'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mtext>P(A</mml:mtext><mml:mtext>∪</mml:mtext><mml:mtext>B)=P(A)+P(B)-P(A∩B)</mml:mtext></mml:math>](img/80.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mtext>P(A</mml:mtext><mml:mtext>∪</mml:mtext><mml:mtext>B)=P(A)+P(B)-P(A∩B)</mml:mtext></mml:math>](img/80.png)'
- en: So far, we have discussed independent events. Now, let’s see what happens if
    the events are not independent.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了独立事件。现在，让我们看看如果事件不是独立的会发生什么。
- en: Conditional probability and the Bayes rule
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件概率和贝叶斯定理
- en: If event A occurs before B and the occurrence of A changes the probability of
    the occurrence of B, then the two events are dependent. To understand this, let’s
    imagine that we draw consecutive cards from the deck. When the deck is full, the
    probability of drawing a spade is P(spade) = 13/52 = 0.25\. However, once we’ve
    drawn the first spade, the probability of picking a spade on the second turn changes.
    Now, we only have 51 cards and 1 less spade. The probability of the second draw
    is called **conditional probability**, P(B|A). This is the probability of event
    B (the second draw of a spade) to occur, given that event A (the first draw of
    a spade) has occurred. The probability of picking a spade on the second draw is
    P(spade2|spade1) = 12/51 = 0.235.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件A发生在B之前，并且A的发生改变了B发生的概率，那么这两个事件是相关的。为了理解这一点，假设我们从一副牌中抽取连续的牌。当牌堆满时，抽到黑桃的概率是P(黑桃)
    = 13/52 = 0.25。然而，一旦我们抽到了第一张黑桃，第二次抽到黑桃的概率就会发生变化。现在，我们只有51张牌，而且黑桃减少了1张。第二次抽到黑桃的概率被称为**条件概率**，P(B|A)。这是指在事件A（第一次抽到黑桃）已经发生的情况下，事件B（第二次抽到黑桃）发生的概率。第二次抽到黑桃的概率是P(黑桃2|黑桃1)
    = 12/51 = 0.235。
- en: 'We can extend the joint probability formula (introduced in the preceding section)
    for dependent events:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展前面章节中介绍的联合概率公式，来适应相关事件：
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mtext>P(A∩B)=P(A)</mml:mtext><mml:mo>×</mml:mo><mml:mtext>P(B|A)</mml:mtext></mml:math>](img/81.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mtext>P(A∩B)=P(A)</mml:mtext><mml:mo>×</mml:mo><mml:mtext>P(B|A)</mml:mtext></mml:math>](img/81.png)'
- en: 'However, this formula is just a special case for two events. We can extend
    it even further for multiple events, ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math>](img/82.png).
    This new generic formula is known as the **chain rule** **of probability**:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个公式只是两个事件的特例。我们可以进一步扩展它以适用于多个事件，![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math>](img/82.png)。这个新的通用公式被称为**概率链式法则**：
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mtext>P</mml:mtext><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>n</mml:mtext></mml:mrow></mml:msub><mml:mo>∩</mml:mo><mml:mo>…</mml:mo><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>1</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>n</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>n-1</mml:mtext></mml:mrow></mml:msub><mml:mo>∩</mml:mo><mml:mo>…</mml:mo><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>1</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>×</mml:mo><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>n-1</mml:mtext></mml:mrow></mml:msub><mml:mo>∩</mml:mo><mml:mo>…</mml:mo><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>1</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/83.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mtext>P</mml:mtext><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>n</mml:mtext></mml:mrow></mml:msub><mml:mo>∩</mml:mo><mml:mo>…</mml:mo><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>1</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>n</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>n-1</mml:mtext></mml:mrow></mml:msub><mml:mo>∩</mml:mo><mml:mo>…</mml:mo><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>1</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>×</mml:mo><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>n-1</mml:mtext></mml:mrow></mml:msub><mml:mo>∩</mml:mo><mml:mo>…</mml:mo><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>1</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/83.png)'
- en: 'For example, the chain rule for three events is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，三个事件的链式法则如下所示：
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mtext>P</mml:mtext><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>3</mml:mtext></mml:mrow></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>2</mml:mtext></mml:mrow></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>1</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>3</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>2</mml:mtext></mml:mrow></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>1</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>×</mml:mo><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>2</mml:mtext></mml:mrow></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>1</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>3</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>2</mml:mtext></mml:mrow></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>1</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>×</mml:mo><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>2</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>1</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>×</mml:mo><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>1</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/84.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mtext>P</mml:mtext><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>3</mml:mtext></mml:mrow></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>2</mml:mtext></mml:mrow></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>1</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>3</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>2</mml:mtext></mml:mrow></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>1</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>×</mml:mo><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>2</mml:mtext></mml:mrow></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>1</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>3</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>2</mml:mtext></mml:mrow></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>1</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>×</mml:mo><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>2</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>1</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>×</mml:mo><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>1</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/84.png)'
- en: 'We can use this property to derive the formula for the conditional probability
    itself:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这个性质来推导条件概率本身的公式：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>P(B|A)</mtext><mo>=</mo><mfrac><mrow><mtext>P</mtext><mfenced
    open="(" close=")"><mtext>A∩B</mtext></mfenced></mrow><mtext>P(A)</mtext></mfrac></mrow></mrow></math>](img/85.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>P(B|A)</mtext><mo>=</mo><mfrac><mrow><mtext>P</mtext><mfenced
    open="(" close=")"><mtext>A∩B</mtext></mfenced></mrow><mtext>P(A)</mtext></mfrac></mrow></mrow></math>](img/85.png)'
- en: 'Let’s discuss the intuition behind this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来讨论一下其中的直觉：
- en: '**P(A** **∩** **B)** indicates that we’re only interested in the occurrences
    of B, if A has already occurred – that is, we’re interested in the joint occurrence
    of the events, hence the joint probability.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**P(A** **∩** **B)** 表示我们只关心事件 B 的发生，前提是 A 已经发生——也就是说，我们关注事件的联合发生，因此是联合概率。'
- en: '**P(A)** indicates that we’re interested only in the subset of outcomes when
    event A has occurred. We already know that A has occurred, and therefore, we restrict
    our observations to these outcomes.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**P(A)** 表示我们只关注事件 A 发生时的结果子集。我们已经知道 A 发生了，因此我们将观察范围限制在这些结果上。'
- en: 'The following is true for dependent events:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下对于依赖事件是成立的：
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mtext>P</mml:mtext><mml:mfenced separators="|"><mml:mrow><mml:mtext>A</mml:mtext><mml:mo>∩</mml:mo><mml:mtext>B</mml:mtext></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow></mml:mfenced><mml:mo>×</mml:mo><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:mtext>B</mml:mtext></mml:mrow><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow></mml:mfenced></mml:math>](img/86.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mtext>P</mml:mtext><mml:mfenced separators="|"><mml:mrow><mml:mtext>A</mml:mtext><mml:mo>∩</mml:mo><mml:mtext>B</mml:mtext></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow></mml:mfenced><mml:mo>×</mml:mo><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:mtext>B</mml:mtext></mml:mrow><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow></mml:mfenced></mml:math>](img/86.png)'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mtext>P</mml:mtext><mml:mfenced separators="|"><mml:mrow><mml:mtext>A</mml:mtext><mml:mo>∩</mml:mo><mml:mtext>B</mml:mtext></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:mtext>B</mml:mtext></mml:mrow></mml:mfenced><mml:mo>×</mml:mo><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>B</mml:mtext></mml:mrow></mml:mfenced></mml:math>](img/87.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mtext>P</mml:mtext><mml:mfenced separators="|"><mml:mrow><mml:mtext>A</mml:mtext><mml:mo>∩</mml:mo><mml:mtext>B</mml:mtext></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:mtext>B</mml:mtext></mml:mrow></mml:mfenced><mml:mo>×</mml:mo><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow><mml:mrow><mml:mtext>B</mml:mtext></mml:mrow></mml:mfenced></mml:math>](img/87.png)'
- en: 'We can use this rule to replace the value of P(A∩B) in the conditional probability
    formula to derive what is known as the **Bayes rule**:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个规则来替换条件概率公式中的 P(A∩B) 值，从而推导出被称为 **贝叶斯规则** 的公式：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>P</mtext><mfenced
    open="(" close=")"><mtext>A∩B</mtext></mfenced><mtext>=P</mtext><mfenced open="("
    close=")"><mtext>A</mtext></mfenced><mo>×</mo><mtext>P</mtext><mfenced open="("
    close=")"><mrow><mtext>B</mtext><mo>|</mo><mtext>A</mtext></mrow></mfenced><mtext>=P</mtext><mfenced
    open="(" close=")"><mtext>B</mtext></mfenced><mo>×</mo><mtext>P</mtext><mfenced
    open="(" close=")"><mrow><mtext>A</mtext><mo>|</mo><mtext>B</mtext></mrow></mfenced><mtext>⇔</mtext><mtext>  </mtext><mtext>P</mtext><mfenced
    open="(" close=")"><mrow><mtext>B</mtext><mo>|</mo><mtext>A</mtext></mrow></mfenced><mtext>=</mtext><mfrac><mrow><mtext>P</mtext><mfenced
    open="(" close=")"><mtext>A∩B</mtext></mfenced></mrow><mrow><mtext>P</mtext><mfenced
    open="(" close=")"><mtext>A</mtext></mfenced></mrow></mfrac><mtext>=</mtext><mfrac><mrow><mtext>P</mtext><mfenced
    open="(" close=")"><mtext>B</mtext></mfenced><mo>×</mo><mtext>P</mtext><mfenced
    open="(" close=")"><mrow><mtext>A</mtext><mo>|</mo><mtext>B</mtext></mrow></mfenced></mrow><mrow><mtext>P</mtext><mfenced
    open="(" close=")"><mtext>A</mtext></mfenced></mrow></mfrac></mrow></mrow></math>](img/88.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>P</mtext><mfenced
    open="(" close=")"><mtext>A∩B</mtext></mfenced><mtext>=P</mtext><mfenced open="("
    close=")"><mtext>A</mtext></mfenced><mo>×</mo><mtext>P</mtext><mfenced open="("
    close=")"><mrow><mtext>B</mtext><mo>|</mo><mtext>A</mtext></mrow></mfenced><mtext>=P</mtext><mfenced
    open="(" close=")"><mtext>B</mtext></mfenced><mo>×</mo><mtext>P</mtext><mfenced
    open="(" close=")"><mrow><mtext>A</mtext><mo>|</mo><mtext>B</mtext></mrow></mfenced><mtext>⇔</mtext><mtext>  </mtext><mtext>P</mtext><mfenced
    open="(" close=")"><mrow><mtext>B</mtext><mo>|</mo><mtext>A</mtext></mrow></mfenced><mtext>=</mtext><mfrac><mrow><mtext>P</mtext><mfenced
    open="(" close=")"><mtext>A∩B</mtext></mfenced></mrow><mrow><mtext>P</mtext><mfenced
    open="(" close=")"><mtext>A</mtext></mfenced></mrow></mfrac><mtext>=</mtext><mfrac><mrow><mtext>P</mtext><mfenced
    open="(" close=")"><mtext>B</mtext></mfenced><mo>×</mo><mtext>P</mtext><mfenced
    open="(" close=")"><mrow><mtext>A</mtext><mo>|</mo><mtext>B</mtext></mrow></mfenced></mrow><mrow><mtext>P</mtext><mfenced
    open="(" close=")"><mtext>A</mtext></mfenced></mrow></mfrac></mrow></mrow></math>](img/88.png)'
- en: The Bayes rule makes it possible to compute the conditional probability, P(B|A),
    if we know the opposite conditional probability, P(A|B). P(A) and P(B|A) are known
    as **prior probability and posterior** **probability**, respectively.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 贝叶斯定理使我们能够计算条件概率P(B|A)，如果我们知道反向的条件概率P(A|B)。P(A)和P(B|A)分别被称为**先验概率**和**后验概率**。
- en: 'We can illustrate the Bayes rule with a classic example from the realm of medical
    testing. A patient is administered a medical test for a disease, which comes out
    positive. Most tests have a sensitivity value, which is the percentage chance
    of the test being positive when administered to people with a particular disease.
    Using this information, we’ll apply the Bayes rule to compute the actual probability
    of the patient having the disease, given that the test is positive. We get the
    following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个经典的医学检测例子来说明贝叶斯定理。一位病人接受了某种疾病的医学检测，结果显示为阳性。大多数检测都有一个灵敏度值，即当对患有特定疾病的人进行检测时，测试为阳性的概率。利用这些信息，我们将应用贝叶斯定理来计算在测试为阳性的情况下，病人患病的实际概率。我们得到如下公式：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>P</mtext><mfenced
    open="(" close=")"><mrow><mtext>has disease</mtext><mo>|</mo><mtext>test</mtext><mo>=</mo><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi></mrow></mfenced><mo>=</mo><mfrac><mrow><mtext>P</mtext><mfenced
    open="(" close=")"><mtext>has disease</mtext></mfenced><mo>×</mo><mtext>P</mtext><mfenced
    open="(" close=")"><mrow><mtext>test</mtext><mo>=</mo><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi><mo>|</mo><mtext>has disease</mtext></mrow></mfenced></mrow><mrow><mtext>P</mtext><mfenced
    open="(" close=")"><mrow><mtext>test</mtext><mo>=</mo><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi></mrow></mfenced></mrow></mfrac></mrow></mrow></math>](img/89.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>P</mtext><mfenced
    open="(" close=")"><mrow><mtext>has disease</mtext><mo>|</mo><mtext>test</mtext><mo>=</mo><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi></mrow></mfenced><mo>=</mo><mfrac><mrow><mtext>P</mtext><mfenced
    open="(" close=")"><mtext>has disease</mtext></mfenced><mo>×</mo><mtext>P</mtext><mfenced
    open="(" close=")"><mrow><mtext>test</mtext><mo>=</mo><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi><mo>|</mo><mtext>has disease</mtext></mrow></mfenced></mrow><mrow><mtext>P</mtext><mfenced
    open="(" close=")"><mrow><mtext>test</mtext><mo>=</mo><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi></mrow></mfenced></mrow></mfrac></mrow></mrow></math>](img/89.png)'
- en: We can think of P(has disease) as the probability of the disease in the general
    population.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将P(患病)看作是一般人群中患病的概率。
- en: 'Now, we’ll make some assumptions about the disease and the sensitivity of the
    test:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将对疾病和测试的灵敏度做一些假设：
- en: 'The test is 98% sensitive – that is, it will detect only 98% of all positive
    cases: P(test=positive|has disease) = 0.98'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该测试的敏感度为98%——也就是说，它只能检测出98%的所有阳性病例：P(测试=阳性|患病) = 0.98
- en: 'Two per cent of the people under 50 have this kind of disease: P(has disease)
    = 0.02'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 50岁以下的2%的人患有这种疾病：P(患病) = 0.02
- en: 'The test is positive for 3.9% of the population when administered to people
    under 50: P(test=positive) = 0.039'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对50岁以下的人群进行测试时，3.9%的人群测试结果为阳性：P(测试=阳性) = 0.039
- en: 'We can ask the following question: if a test is 98% sensitive and a 45-year-old
    person is administered the test, which turns out to be positive, what is the probability
    that they have the disease? We can calculate it with the Bayes rule:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以问这样一个问题：如果一个测试的敏感度是98%，并且对一位45岁的人进行测试，结果为阳性，那么他患病的概率是多少？我们可以用贝叶斯规则来计算：
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mtext>P</mml:mtext><mml:mfenced separators="|"><mml:mrow><mml:mtext>has disease</mml:mtext></mml:mrow><mml:mrow><mml:mtext>test</mml:mtext><mml:mo>=</mml:mo><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:mtext>has disease</mml:mtext></mml:mrow></mml:mfenced><mml:mo>×</mml:mo><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:mtext>test</mml:mtext><mml:mo>=</mml:mo><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mtext>has disease</mml:mtext></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:mtext>test</mml:mtext><mml:mo>=</mml:mo><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>0.02</mml:mn><mml:mo>×</mml:mo><mml:mn>0.98</mml:mn></mml:mrow><mml:mrow><mml:mn>0.039</mml:mn></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn></mml:math>](img/90.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mtext>P</mml:mtext><mml:mfenced separators="|"><mml:mrow><mml:mtext>has disease</mml:mtext></mml:mrow><mml:mrow><mml:mtext>test</mml:mtext><mml:mo>=</mml:mo><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:mtext>has disease</mml:mtext></mml:mrow></mml:mfenced><mml:mo>×</mml:mo><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:mtext>test</mml:mtext><mml:mo>=</mml:mo><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mtext>has disease</mml:mtext></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mtext>P</mml:mtext><mml:mfenced
    separators="|"><mml:mrow><mml:mtext>test</mml:mtext><mml:mo>=</mml:mo><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>0.02</mml:mn><mml:mo>×</mml:mo><mml:mn>0.98</mml:mn></mml:mrow><mml:mrow><mml:mn>0.039</mml:mn></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn></mml:math>](img/90.png)'
- en: This example can serve as an introduction to the next section, where we’ll introduce
    the confusion matrix.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以作为下一节的引入，在这一节中我们将介绍混淆矩阵。
- en: Confusion matrix
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混淆矩阵
- en: 'The **confusion matrix** is used to evaluate the performance of a binary classification
    algorithm, similar to the medical test we introduced in the *Conditional probability
    and the Bayes* *rule* section:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**混淆矩阵**用于评估二分类算法的性能，类似于我们在*条件概率和贝叶斯* *规则* 部分介绍的医学测试：'
- en: '![Figure 2.5 – Confusion matrix](img/B19627_02_05.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – 混淆矩阵](img/B19627_02_05.jpg)'
- en: Figure 2.5 – Confusion matrix
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 混淆矩阵
- en: 'The relationship between the actual condition (**P** and **N**) and the predicted
    outcome (**PP** and **PN**) allows us to place the prediction in one of four categories:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 实际情况（**P** 和 **N**）与预测结果（**PP** 和 **PN**）之间的关系使我们能够将预测结果归类为四种类别之一：
- en: '**True positive (TP)**: The actual and predicted values are both true'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**真阳性 (TP)**：实际值和预测值都是正'
- en: '**True negative (TN)**: The actual and predicted values are both false'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**真阴性 (TN)**：实际值和预测值都是假'
- en: '**False positive (FP)**: The actual value is negative, but the classification
    algorithm has predicted a positive value'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**假阳性 (FP)**：实际值为负，但分类算法预测为正'
- en: '**False negative (FN)**: The actual value is positive, but the algorithm has
    predicted a negative value'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**假阴性（FN）**：实际值为正，但算法预测为负值。'
- en: 'Based on these categories, we’ll introduce some measures that evaluate different
    aspects of the performance of the algorithm:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些分类，我们将引入一些衡量算法性能不同方面的指标：
- en: '**Accuracy** = ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle
    scriptlevel="+1"><mfrac><mrow><mtext>TP</mtext><mtext>+</mtext><mtext>TN</mtext></mrow><mtext>TP + FP + FN+TN</mtext></mfrac></mstyle></mrow></math>](img/91.png):
    The fraction of correct predictions among all cases.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准确率** = ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle
    scriptlevel="+1"><mfrac><mrow><mtext>TP</mtext><mtext>+</mtext><mtext>TN</mtext></mrow><mtext>TP + FP + FN+TN</mtext></mfrac></mstyle></mrow></math>](img/91.png)：所有案例中正确预测的比例。'
- en: '**Precision** = ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mtext>TP</mml:mtext></mml:mrow><mml:mrow><mml:mtext>TP + FP</mml:mtext></mml:mrow></mml:mfrac></mml:math>](img/92.png):
    The fraction of positive predictions that were actually correct.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**精确率** = ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mtext>TP</mml:mtext></mml:mrow><mml:mrow><mml:mtext>TP + FP</mml:mtext></mml:mrow></mml:mfrac></mml:math>](img/92.png)：所有正类预测中实际正确的比例。'
- en: '**Recall** (or **sensitivity**) = ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mtext>TP</mml:mtext></mml:mrow><mml:mrow><mml:mtext>TP + FN</mml:mtext></mml:mrow></mml:mfrac></mml:math>](img/93.png):
    The fraction of actual positive cases that were predicted correctly.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**召回率**（或 **敏感度**）= ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mtext>TP</mml:mtext></mml:mrow><mml:mrow><mml:mtext>TP + FN</mml:mtext></mml:mrow></mml:mfrac></mml:math>](img/93.png)：实际正类案例中被正确预测的比例。'
- en: '**Specificity** = ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mtext>TN</mml:mtext></mml:mrow><mml:mrow><mml:mtext>TN + FP</mml:mtext></mml:mrow></mml:mfrac></mml:math>](img/94.png):
    The fraction of actual negative cases that were predicted correctly.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特异性** = ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mtext>TN</mml:mtext></mml:mrow><mml:mrow><mml:mtext>TN + FP</mml:mtext></mml:mrow></mml:mfrac></mml:math>](img/94.png)：实际负类案例中被正确预测的比例。'
- en: '**F1 score** = ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>2</mml:mn><mml:mo>⋅</mml:mo><mml:mfrac><mml:mrow><mml:mtext>precision</mml:mtext><mml:mo>×</mml:mo><mml:mtext>recall</mml:mtext></mml:mrow><mml:mrow><mml:mtext>precision+recall</mml:mtext></mml:mrow></mml:mfrac></mml:math>](img/95.png):
    Represents the balance between precision and recall. Because of the multiplication
    of the two measures, the F1 score will have a high value when both measures have
    high values.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**F1 分数** = ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>2</mml:mn><mml:mo>⋅</mml:mo><mml:mfrac><mml:mrow><mml:mtext>precision</mml:mtext><mml:mo>×</mml:mo><mml:mtext>recall</mml:mtext></mml:mrow><mml:mrow><mml:mtext>precision+recall</mml:mtext></mml:mrow></mml:mfrac></mml:math>](img/95.png)：表示精确率和召回率之间的平衡。由于这两个指标的相乘，当这两个值都较高时，F1
    分数也会较高。'
- en: In the following section, we’ll discuss the field of differential calculus,
    which will help us to train NNs.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将讨论微积分领域，这将帮助我们训练神经网络。
- en: Differential calculus
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微积分
- en: 'We can think of an ML algorithm as a mathematical function with inputs and
    parameters (which is the case for NNs). Our goal is to adjust these parameters
    in a way that will allow the ML function to closely approximate some other target
    function. To do this, we need to know how the output of the ML function changes
    when we change some of its parameters (called weights). Fortunately, differential
    calculus can help us here – it deals with the rate of change of a function with
    respect to a variable (parameter) that the function depends on. To understand
    how this works, we’ll start with a function, *f(x)*, with a single parameter,
    *x*, which has the following graph:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将机器学习算法视为一个具有输入和参数的数学函数（神经网络也是如此）。我们的目标是调整这些参数，以便让机器学习函数能够尽可能接近某个目标函数。为了做到这一点，我们需要知道当我们改变某些参数（称为权重）时，机器学习函数的输出如何变化。幸运的是，微积分可以帮助我们——它研究函数对于一个变量（参数）变化的变化率。为了理解这一点，我们将从一个具有单一参数
    *x* 的函数 *f(x)* 开始，其图形如下：
- en: '![Figure 2.6 – A sample graph of a function, f(x), with a single parameter,
    x. The function graph is denoted with an uninterrupted blue line; the slope is
    denoted with an interrupted red line](img/B19627_02_06.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 一个具有单一参数 *x* 的函数 *f(x)* 的示例图。函数图通过连续的蓝色线表示；斜率通过断开的红色线表示](img/B19627_02_06.jpg)'
- en: Figure 2.6 – A sample graph of a function, f(x), with a single parameter, x.
    The function graph is denoted with an uninterrupted blue line; the slope is denoted
    with an interrupted red line
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 一个具有单一参数 *x* 的函数 *f(x)* 的示例图。函数图通过连续的蓝色线表示；斜率通过断开的红色线表示。
- en: 'We can approximate how *f(x)* changes with respect to *x* for any value of
    *x* by calculating the slope of the function for that value. If the slope is positive,
    the function increases, and it decreases if the slope is negative. The steepness
    of the slope indicates the rate of change of the function for that value. We can
    calculate the slope with the following formula:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过计算该值处函数的斜率，来近似 *f(x)* 相对于 *x* 的变化。如果斜率为正，则函数增加；如果斜率为负，则函数减少。斜率的陡峭程度表示该值处函数的变化速率。我们可以用以下公式来计算斜率：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>slope</mtext><mo>=</mo><mfrac><mrow><mtext>Δ</mtext><mi>y</mi></mrow><mrow><mtext>Δ</mtext><mi>x</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>f</mi><mfenced
    open="(" close=")"><mrow><mi>x</mi><mo>+</mo><mtext>Δ</mtext><mi>x</mi></mrow></mfenced><mo>−</mo><mi>f</mi><mfenced
    open="(" close=")"><mi>x</mi></mfenced></mrow><mrow><mtext>Δ</mtext><mi>x</mi></mrow></mfrac></mrow></mrow></math>](img/96.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mtext>斜率</mtext><mo>=</mo><mfrac><mrow><mtext>Δ</mtext><mi>y</mi></mrow><mrow><mtext>Δ</mtext><mi>x</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>f</mi><mfenced
    open="(" close=")"><mrow><mi>x</mi><mo>+</mo><mtext>Δ</mtext><mi>x</mi></mrow></mfenced><mo>−</mo><mi>f</mi><mfenced
    open="(" close=")"><mi>x</mi></mfenced></mrow><mrow><mtext>Δ</mtext><mi>x</mi></mrow></mfrac></mrow></mrow></math>](img/96.png)'
- en: 'The idea here is simple – we calculate the difference between the two values
    of *f* at *x* and *x+Δx* (*Δx* is a very small value) – *Δy = f(x + Δx) - f(x).*
    The ratio between *Δy* and *Δx* gives us the slope. But why is *Δx* required to
    be small? If *Δx* is too big, the part of the function graph between *x* and *x+Δx*
    may change significantly, and the slope measurement would be inaccurate. When
    *Δx* converges to 0, we’ll assume that our slope approximates the actual slope
    at a single point of the graph. In this case, we call the slope the **first derivative**
    of *f(x)*. We can express this in mathematical terms via the following equation:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的思路很简单——我们计算 *f* 在 *x* 和 *x+Δx* 处的两个值之差（*Δx* 是一个非常小的值）——*Δy = f(x + Δx) -
    f(x)*。*Δy* 和 *Δx* 的比值给我们斜率。那么，为什么 *Δx* 必须很小呢？如果 *Δx* 太大，*x* 和 *x+Δx* 之间的函数图形部分可能会发生较大变化，斜率测量将不准确。当
    *Δx* 收敛到 0 时，我们假设我们的斜率近似于图形上某一点的实际斜率。在这种情况下，我们称斜率为 **f(x)** 的**一阶导数**。我们可以通过以下公式用数学语言表示：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>f</mi><mo>′</mo></mrow><mfenced
    open="(" close=")"><mi>x</mi></mfenced><mo>=</mo><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>=</mo><munder><mi>lim</mi><mrow><mtext>Δ</mtext><mi>x</mi><mo>→</mo><mn>0</mn></mrow></munder><mfrac><mrow><mi>f</mi><mfenced
    open="(" close=")"><mrow><mi>x</mi><mo>+</mo><mtext>Δ</mtext><mi>x</mi></mrow></mfenced><mo>−</mo><mi>f</mi><mfenced
    open="(" close=")"><mi>x</mi></mfenced></mrow><mrow><mtext>Δ</mtext><mi>x</mi></mrow></mfrac></mrow></mrow></math>](img/97.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>f</mi><mo>′</mo></mrow><mfenced
    open="(" close=")"><mi>x</mi></mfenced><mo>=</mo><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>=</mo><munder><mi>lim</mi><mrow><mtext>Δ</mtext><mi>x</mi><mo>→</mo><mn>0</mn></mrow></munder><mfrac><mrow><mi>f</mi><mfenced
    open="(" close=")"><mrow><mi>x</mi><mo>+</mo><mtext>Δ</mtext><mi>x</mi></mrow></mfenced><mo>−</mo><mi>f</mi><mfenced
    open="(" close=")"><mi>x</mi></mfenced></mrow><mrow><mtext>Δ</mtext><mi>x</mi></mrow></mfrac></mrow></mrow></math>](img/97.png)'
- en: 'Here, ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><munder><mi>lim</mi><mrow><mtext>Δ</mtext><mi>x</mi><mo>→</mo><mn>0</mn></mrow></munder></mrow></math>](img/98.png)is
    the mathematical concept of the limit (*Δx* approaches 0), and *f’(x)* and *dy/dx*
    are Lagrange’s and Leibniz’s notations for derivatives, respectively. The process
    of finding the derivative of *f* is called **differentiation**. The following
    diagram shows slopes at different values of *x*:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><munder><mi>lim</mi><mrow><mtext>Δ</mtext><mi>x</mi><mo>→</mo><mn>0</mn></mrow></munder></mrow></math>](img/98.png)是极限的数学概念（*Δx*
    趋近于 0），而 *f’(x)* 和 *dy/dx* 分别是拉格朗日和莱布尼茨表示导数的符号。求 *f* 的导数的过程称为**微分**。下图展示了不同 x
    值的斜率：
- en: '![Figure 2.7 – Slopes at different values of x](img/B19627_02_07.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – 不同 x 值的斜率](img/B19627_02_07.jpg)'
- en: Figure 2.7 – Slopes at different values of x
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 不同 x 值的斜率
- en: The points, where *f* neither increases nor decreases as we change *x*, are
    called **saddle points**. The values of *f* at the saddle points are called the
    **local minimum** and the **local maximum**. Conversely, the slopes of *f* at
    the saddle points are 0.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *f* 在变化 *x* 时既不增加也不减少的点，称为**鞍点**。在鞍点处的 *f* 值称为**局部最小值**和**局部最大值**。相反，鞍点处的
    *f* 的斜率为 0。
- en: So far, we have discussed a function with a single parameter, *x*. Now, let’s
    focus on a function with multiple parameters, ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/99.png).
    The derivative of *f* with respect to any of the parameters, ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/100.png),
    is called a **partial derivative** and is denoted by ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:mi>f</mml:mi><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:mi>x</mml:mi></mml:math>](img/101.png).
    To compute the partial derivative, we will assume that all the other parameters,
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/102.png),
    are constants. We’ll denote the partial derivatives of the components of a vector
    with ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∇</mml:mo><mml:mo>=</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/103.png).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了只有一个参数的函数 *x*。现在，让我们关注一个具有多个参数的函数，![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/99.png)。*f*
    相对于任意参数的导数，![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/100.png)，被称为
    **偏导数**，并表示为 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:mi>f</mml:mi><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:mi>x</mml:mi></mml:math>](img/101.png)。计算偏导数时，我们将假设其他所有参数，![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/102.png)，是常数。我们将用
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∇</mml:mo><mml:mo>=</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:math>](img/103.png)来表示向量组件的偏导数。
- en: 'Finally, let’s discuss some useful differentiation rules:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们讨论一些有用的求导规则：
- en: '**Chain rule**: *f* and *g* are functions and *h(x)= f(g(x))*. The derivative
    of *f* with respect to *x* for any *x* is as follows:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链式法则**：*f* 和 *g* 是函数，且 *h(x)= f(g(x))*。对于任意 *x*，*f* 相对于 *x* 的导数如下：'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:msup><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">''</mml:mi></mml:mrow></mml:msup><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">''</mml:mi></mml:mrow></mml:msup><mml:mfenced separators="|"><mml:mrow><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">''</mml:mi></mml:mrow></mml:msup><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced><mml:mtext>or</mml:mtext><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:mfrac><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>f</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfrac><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>f</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mfrac><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:mfrac><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>g</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/104.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:msup><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">''</mml:mi></mml:mrow></mml:msup><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">''</mml:mi></mml:mrow></mml:msup><mml:mfenced separators="|"><mml:mrow><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">''</mml:mi></mml:mrow></mml:msup><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced><mml:mtext>or</mml:mtext><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:mfrac><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>f</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfrac><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>f</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mfrac><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:mfrac><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:mi>g</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/104.png)'
- en: '**Sum rule**: *f* and *g* are some functions and *h(x) = f(x) + g(x)*. The
    sum rule states the following:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**求和法则**：*f* 和 *g* 是一些函数，*h(x) = f(x) + g(x)*。求和法则表明以下内容：'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>h</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced><mml:mo>⟹</mml:mo><mml:msup><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">''</mml:mi></mml:mrow></mml:msup><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>f</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">''</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">''</mml:mi></mml:mrow></mml:msup><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">''</mml:mi></mml:mrow></mml:msup><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/105.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>h</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced><mml:mo>⟹</mml:mo><mml:msup><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">''</mml:mi></mml:mrow></mml:msup><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>f</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">''</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">''</mml:mi></mml:mrow></mml:msup><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">''</mml:mi></mml:mrow></mml:msup><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/105.png)'
- en: '**Common functions**:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常见函数**:'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">''</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/106.png)'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">''</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math>](img/106.png)'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>a</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">''</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mi>a</mml:mi></mml:math>](img/107.png),
    where *a* is a scalar'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>a</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">''</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mi>a</mml:mi></mml:math>](img/107.png),
    其中*a*是一个标量'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">''</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math>](img/108.png),
    where *a* is a scalar'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">''</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math>](img/108.png),
    其中*a*是一个标量'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>x</mml:mi></mml:math>](img/109.png)'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>x</mml:mi></mml:math>](img/109.png)'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">''</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msup></mml:math>](img/110.png)'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">''</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msup></mml:math>](img/110.png)'
- en: The mathematical foundations of NNs and NNs themselves form a kind of knowledge
    hierarchy. Think of the topics we discussed in *The math of NNs* section as the
    building blocks of NNs. They represent an important step toward a comprehensive
    understanding of NNs, which will help us throughout this book and beyond. Now,
    we have the necessary preparation to learn full-fledged NNs.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 神经网络及其数学基础构成了一种知识层次结构。把我们在*神经网络的数学*部分讨论的内容看作是神经网络的构建块。它们代表了理解神经网络的一个重要步骤，这将有助于我们在本书以及未来的学习中。现在，我们已经做好了学习完整神经网络的必要准备。
- en: An introduction to NNs
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 神经网络简介
- en: 'We can describe NNs as a mathematical model for information processing. As
    discussed in [*Chapter 1*](B19627_01.xhtml#_idTextAnchor016), this is a good way
    to describe any ML algorithm, but in this chapter, it has a specific meaning in
    the context of NNs. An NN is not a fixed program but rather a model, a system
    that processes information, or inputs. The characteristics of an NN are as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将神经网络描述为一种信息处理的数学模型。正如在[*第一章*](B19627_01.xhtml#_idTextAnchor016)中讨论的那样，这是描述任何机器学习算法的一个良好方式，但在本章中，它在神经网络的上下文中具有特定含义。神经网络不是一个固定的程序，而是一个模型，一个处理信息或输入的系统。神经网络的特征如下：
- en: Information processing occurs in its simplest form, over simple elements called
    **units**
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息处理以最简单的形式发生，作用于被称为**单元**的简单元素上。
- en: Units are connected, and they exchange signals between them through connection
    links
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元相互连接，并通过连接链路交换信号。
- en: Connection links between units can be stronger or weaker, and this determines
    how information is processed
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元之间的连接链路可以更强或更弱，这决定了信息的处理方式。
- en: Each unit has an internal state that is determined by all the incoming connections
    from other units
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个单元都有一个内部状态，该状态由所有来自其他单元的输入连接决定。
- en: Each unit has a different **activation function** that is calculated on its
    state and determines its output signal
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个单元都有不同的**激活函数**，该函数根据单元的状态计算，并决定其输出信号。
- en: A more general description of an NN would be as a computational graph of mathematical
    operations, but we will learn more about that later.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对神经网络的更一般描述可以是数学运算的计算图，但我们将在后面进一步学习这个内容。
- en: 'We can identify two main characteristics of an NN:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以识别神经网络的两个主要特征：
- en: '**Neural net architecture**: This describes the set of connections – namely,
    feedforward, recurrent, multi- or single-layered, and so on – between the units,
    the number of layers, and the number of units in each layer.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**神经网络架构**：这描述了单元之间的连接方式——即前馈、递归、多层或单层等——层数和每层单元的数量。'
- en: '**Learning**: This describes what is commonly defined as training. The most
    common but not exclusive way to train an NN is with **gradient descent** (**GD**)
    and **backpropagation** (**BP**).'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学习**：这描述了通常定义为训练的过程。训练神经网络最常见但并非唯一的方式是使用**梯度下降**（**GD**）和**反向传播**（**BP**）。'
- en: We’ll start our discussion from the smallest building block of the NN – the
    unit.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从神经网络的最小构建块——单元开始讨论。
- en: Units – the smallest NN building block
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元——神经网络的最小构建块
- en: 'Units are mathematical functions that can be defined as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 单元是可以定义为以下数学函数：
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mrow><mml:munderover><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/111.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mrow><mml:munderover><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/111.png)'
- en: 'Here, we do the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们做以下操作：
- en: 'We compute the weighted sum ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><msubsup><mo>∑</mo><mrow
    /><mrow /></msubsup><msub><mi>x</mi><mi>i</mi></msub></mrow><msub><mi>w</mi><mi>i</mi></msub><mo>+</mo><mi>b</mi></mrow></mrow></math>](img/112.png)
    (also known as an activation value). Let’s focus on the components of this sum:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们计算加权和 ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><msubsup><mo>∑</mo><mrow
    /><mrow /></msubsup><msub><mi>x</mi><mi>i</mi></msub></mrow><msub><mi>w</mi><mi>i</mi></msub><mo>+</mo><mi>b</mi></mrow></mrow></math>](img/112.png)（也称为激活值）。让我们聚焦于这个和的组成部分：
- en: The inputs ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/113.png)
    are numerical values that represent either the outputs of other units of the network,
    or the values of the input data itself
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/113.png)
    是表示网络中其他单元输出或输入数据本身值的数值。
- en: The weights ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/114.png)
    are numerical values that represent either the strength of the inputs or the strength
    of the connections between the units
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 权重 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/114.png)
    是表示输入强度或单元间连接强度的数值。
- en: The weight *b* is a special weight called **bias**, which represents an always-on
    input unit with a value of 1
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 权重 *b* 是一个特殊的权重，称为**偏置**，它表示一个始终开启的输入单元，值为1。
- en: 'Alternatively, we can substitute ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/115.png)
    and ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/15.png)
    with their vector representations, where x =  → x  = [x 1, x 2, … , x n] and ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi
    mathvariant="bold">w</mml:mi><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mo>→</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/117.png).
    Here, the formula will use the dot product of the two vectors:'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，我们可以用它们的向量表示来替代 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/115.png)
    和 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/15.png)，其中
    x =  → x  = [x 1, x 2, … , x n] 和 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="bold">w</mml:mi><mml:mo>=</mml:mo><mml:mover
    accent="true"><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mo>→</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/117.png)。这里，公式将使用两个向量的点积：
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi><mml:mo>⋅</mml:mo><mml:mi
    mathvariant="bold">w</mml:mi><mml:mo>+</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mo>→</mml:mo></mml:mover><mml:mo>⋅</mml:mo><mml:mover
    accent="true"><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mo>→</mml:mo></mml:mover><mml:mo>+</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/118.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi><mml:mo>⋅</mml:mo><mml:mi
    mathvariant="bold">w</mml:mi><mml:mo>+</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mo>→</mml:mo></mml:mover><mml:mo>⋅</mml:mo><mml:mover
    accent="true"><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mo>→</mml:mo></mml:mover><mml:mo>+</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/118.png)'
- en: '2. The sum ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><msubsup><mo>∑</mo><mrow
    /><mrow /></msubsup><msub><mi>x</mi><mi>i</mi></msub></mrow><msub><mi>w</mi><mi>i</mi></msub><mo>+</mo><mi>b</mi></mrow></mrow></math>](img/119.png)
    serves as input to the **activation function** *f* (also known as **transfer function**).
    The output of *f* is a single **numerical value**, which represents the output
    of the unit itself. The activation function has the following properties:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 总和 ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><msubsup><mo>∑</mo><mrow
    /><mrow /></msubsup><msub><mi>x</mi><mi>i</mi></msub></mrow><msub><mi>w</mi><mi>i</mi></msub><mo>+</mo><mi>b</mi></mrow></mrow></math>](img/119.png)
    作为 **激活函数** *f*（也称为 **传输函数**）的输入。*f* 的输出是一个单一的 **数值**，代表单元本身的输出。激活函数具有以下特性：
- en: '**Non-linear**: *f* is the source of non-linearity in an NN – if the NN was
    entirely linear, it would only be able to approximate other linear functions'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非线性**：*f* 是神经网络（NN）中非线性的来源——如果神经网络完全线性，它只会逼近其他线性函数'
- en: '**Differentiable**: This makes it possible to train the network with GD and
    BP'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可微分**：这使得可以通过梯度下降（GD）和反向传播（BP）来训练网络'
- en: Don’t worry if you don’t understand everything – we’ll discuss activation functions
    in detail later in the chapter.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你并不完全理解，不用担心——我们将在本章稍后详细讨论激活函数。
- en: 'The following diagram (left) shows a unit:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 下图（左侧）展示了一个单元：
- en: '![Figure 2.8 – Left: a unit and its equivalent formula, and right: a geometric
    representation of a perceptron](img/B19627_02_08.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – 左：一个单元及其等效公式，右：感知机的几何表示](img/B19627_02_08.jpg)'
- en: 'Figure 2.8 – Left: a unit and its equivalent formula, and right: a geometric
    representation of a perceptron'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 左：一个单元及其等效公式，右：感知机的几何表示
- en: The input vector **x** will be perpendicular to the weight vector **w** if ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi
    mathvariant="bold">x</mml:mi><mml:mo>⋅</mml:mo><mml:mi mathvariant="bold">w</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math>](img/120.png).
    Therefore, all **x** vectors, where ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="bold">x</mml:mi><mml:mo>⋅</mml:mo><mml:mi
    mathvariant="bold">w</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math>](img/121.png),
    define a hyperplane in vector space ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/122.png),
    where *n* is the dimension of **x**. In the case of two-dimensional input ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/123.png),
    we can represent the hyperplane as a line. This could be illustrated with the
    perceptron (or **binary classifier**) – a unit with a **threshold activation function**,
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>f</mi><mfenced
    open="(" close=")"><mi>a</mi></mfenced><mo>=</mo><mn>1</mn><mtext>if</mtext><mi>a</mi><mo>≥</mo><mn>0</mn><mtext>else</mtext><mn>0</mn></mrow></mrow></math>](img/124.png)![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>f</mi><mfenced open="("
    close=")"><mi>a</mi></mfenced><mo>=</mo><mn>1</mn><mtext>if</mtext><mi>a</mi><mo>≥</mo><mn>0</mn><mtext>else</mtext><mn>0</mn></mrow></mrow></math>](img/125.png),
    that classifies its input in one of the two classes. The geometric representation
    of the perceptron with two inputs ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/126.png)
    is a line (or **decision boundary**) separating the two classes (to the right
    in the preceding diagram).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 输入向量**x**与权重向量**w**垂直时，满足![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="bold">x</mml:mi><mml:mo>⋅</mml:mo><mml:mi
    mathvariant="bold">w</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math>](img/120.png)。因此，所有满足![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi
    mathvariant="bold">x</mml:mi><mml:mo>⋅</mml:mo><mml:mi mathvariant="bold">w</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math>](img/121.png)的**x**向量定义了一个超平面，该超平面位于向量空间![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/122.png)，其中*n*是**x**的维度。在二维输入情况下![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/123.png)，我们可以将超平面表示为一条直线。这可以通过感知器（或**二分类器**）来说明——一个带有**阈值激活函数**的单元，![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>f</mi><mfenced open="("
    close=")"><mi>a</mi></mfenced><mo>=</mo><mn>1</mn><mtext>if</mtext><mi>a</mi><mo>≥</mo><mn>0</mn><mtext>else</mtext><mn>0</mn></mrow></mrow></math>](img/124.png)![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>f</mi><mfenced open="("
    close=")"><mi>a</mi></mfenced><mo>=</mo><mn>1</mn><mtext>if</mtext><mi>a</mi><mo>≥</mo><mn>0</mn><mtext>else</mtext><mn>0</mn></mrow></mrow></math>](img/125.png)，它将输入分类为两个类别中的一个。带有两个输入的感知器的几何表示![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/126.png)是一条直线（或**决策边界**），它将两个类别分开（如前图所示，位于右侧）。
- en: In the preceding diagram, we can also see that the role of the bias, *b*, is
    to allow the hyperplane to shift away from the center of the coordinate system.
    If we don’t use bias, the unit will have limited representation power.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图示中，我们也可以看到偏置 *b* 的作用是使超平面能够从坐标系的中心移动。如果我们不使用偏置，单元的表示能力将受到限制。
- en: 'The unit is a generalization of several algorithms we introduced in [*Chapter
    1*](B19627_01.xhtml#_idTextAnchor016):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 单元是我们在[*第1章*](B19627_01.xhtml#_idTextAnchor016)中介绍的几种算法的概括：
- en: A unit with an identity activation function *f(x) = x* is equivalent to **multiple**
    **linear regression**
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有恒等激活函数 *f(x) = x* 的单元相当于**多元** **线性回归**。
- en: A unit with a **sigmoid activation** function is equivalent to logistic regression
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有**sigmoid 激活函数**的单元相当于逻辑回归。
- en: A unit with a threshold activation function is equivalent to a perceptron
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有阈值激活函数的单元相当于感知机。
- en: We already know from [*Chapter 1*](B19627_01.xhtml#_idTextAnchor016) that the
    perceptron (hence the unit) only works with linearly separable classes, and now
    we know that is because it defines a hyperplane. This imposes a serious limitation
    on the unit because it cannot classify linearly inseparable problems – even simple
    ones such as **exclusive or** (**XOR**). To overcome this limitation, we’ll need
    to organize the units in an NN. However, before we discuss full-fledged NNs, we’ll
    focus on the next NN building block – the layers.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从[*第1章*](B19627_01.xhtml#_idTextAnchor016)中了解到，感知机（因此也包括单元）只对线性可分的类别有效，而现在我们知道这是因为它定义了一个超平面。这对单元来说是一个严重的限制，因为它无法处理线性不可分的问题——即使是像**异或**（**XOR**）这样简单的问题。为了克服这个限制，我们需要将单元组织成神经网络（NN）。然而，在讨论完整的神经网络之前，我们将重点讨论下一个神经网络构建块——层。
- en: Layers as operations
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 层作为操作。
- en: 'An NN can have an indefinite number of units, which are organized in interconnected
    layers. A layer has the following properties:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 神经网络（NN）可以有无限数量的单元，这些单元按层次组织并互相连接。每一层具有以下特性：
- en: It combines the scalar outputs of multiple units in a single output vector.
    A unit can convey limited information because its output is a scalar. By combining
    the unit outputs, instead of a single activation, we can now consider the vector
    in its entirety. This way, we can convey a lot more information, not only because
    the vector has multiple values but also because the relative ratios between them
    carry additional meaning.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将多个单元的标量输出组合成一个单一的输出向量。单元的输出是标量，因此它只能传达有限的信息。通过组合单元的输出，而不是单一的激活函数，我们现在可以整体考虑向量。这样，我们就能传递更多的信息，不仅因为向量有多个值，还因为它们之间的相对比率承载了额外的含义。
- en: The units of one layer can be connected to the units of other layers, but not
    to other units of the same layer. Because of this, we can parallelize the computation
    of the outputs of all units in a single layer (thereby increasing the computational
    speed). This ability is one of the major reasons for the success of DL in recent
    years.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一层的单元可以与其他层的单元连接，但不能与同一层的其他单元连接。由于这一点，我们可以并行计算单层所有单元的输出（从而提高计算速度）。这种能力是近年来深度学习（DL）成功的主要原因之一。
- en: We can generalize multivariate regression to a layer, as opposed to only linear
    or logistic regression to a single unit. In other words, we can approximate multiple
    values with a layer as opposed to a single value with a unit. This happens in
    the case of classification output, where each output unit represents the probability
    the input belongs to a certain class.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将多变量回归推广到一层，而不仅仅是将线性回归或逻辑回归应用于单一单元。换句话说，我们可以用一层来近似多个值，而不是用单一单元来近似单个值。这在分类输出的情况下尤为适用，其中每个输出单元代表输入属于某个类别的概率。
- en: 'In classical NNs (that is, NNs before DL, when they were just one of many ML
    algorithms), the primary type of layer is the **fully connected** (**FC**) layer.
    In this layer, every unit receives weighted input from all the components of the
    input vector, **x**. This can represent either the output of another layer in
    the network or a sample of the input dataset. Let’s assume that the size of the
    input vector is *m*, and that the FC layer has *n* units and an activation function,
    *f*, which is the same for all the units. Each of the *n* units will have *m*
    weights – one for each of the *m* inputs. The following is a formula we can use
    for the output of a single unit, *j*, of an FC layer. It’s the same as the formula
    we defined in the *Units – the smallest NN building block* section, but we’ll
    include the unit index here:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典神经网络（即深度学习之前的神经网络，那时它们只是众多机器学习算法中的一种）中，主要的层类型是**全连接**（**FC**）层。在这一层中，每个单元都会从输入向量的所有组件接收加权输入，**x**。这可以表示网络中另一个层的输出或输入数据集的一个样本。假设输入向量的大小为*m*，且FC层有*n*个单元和一个激活函数*f*，这个激活函数对所有单元都是相同的。每个*n*个单元会有*m*个权重——每个*m*个输入对应一个权重。下面是我们可以用来表示FC层单个单元*j*输出的公式。它与我们在*单元
    - 最小神经网络构建块*部分定义的公式相同，但这里我们将包括单元索引：
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mrow><mml:munderover><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/127.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mrow><mml:munderover><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math>](img/127.png)'
- en: Here, ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/128.png)
    is the weight between the *j*-th layer unit and the *i*-th value of the input
    vector, **x**. We can represent the weights connecting the elements of **x** to
    the units as an *m×n* matrix, **W**. Each column of **W** represents the weight
    vector of all the inputs to a single unit of the layer. In this case, the output
    vector of the layer, **y**, is the result of matrix-vector multiplication.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/128.png)
    是*第j*层单元与输入向量的*第i*个值之间的权重，**x**。我们可以将连接**x**的各个元素与单元的权重表示为一个*m×n*的矩阵**W**。**W**的每一列代表该层单个单元的所有输入的权重向量。在这种情况下，层的输出向量**y**是矩阵-向量乘法的结果。
- en: We can also combine multiple input sample vectors, ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/129.png),
    in an input matrix, **X**, where each input data vector, ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/130.png),
    is represented by a row in **X**. The matrix itself is referred to as a **batch**.
    Then, we’ll simultaneously compute all output vectors, ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">y</mml:mi></mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/131.png),
    corresponding to the input samples, ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/132.png).
    In this case, we will have matrix-matrix multiplication, **XW**, and the layer
    output is also a matrix, **Y**.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将多个输入样本向量，![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/129.png)，组合成一个输入矩阵**X**，其中每个输入数据向量，![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/130.png)通过**X**中的一行表示。该矩阵本身被称为**批次**。然后，我们将同时计算所有输出向量，![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">y</mml:mi></mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/131.png)，对应于输入样本，![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/132.png)。在这种情况下，我们将进行矩阵-矩阵乘法，**XW**，并且层的输出也是一个矩阵，**Y**。
- en: 'The following diagram shows an example of an FC layer, as well as its equivalent
    formulas in the batch and single sample scenarios:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了一个全连接层的示例，以及在批次和单个样本场景下的等效公式：
- en: '![Figure 2.9 – An FC layer with vector/matrix inputs and outputs and its equivalent
    formulas](img/B19627_02_09.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – 一个带有向量/矩阵输入输出的全连接层及其等效公式](img/B19627_02_09.jpg)'
- en: Figure 2.9 – An FC layer with vector/matrix inputs and outputs and its equivalent
    formulas
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – 一个带有向量/矩阵输入输出的全连接层及其等效公式
- en: We have explicitly separated the bias and input weight matrices, but in practice,
    the underlying implementation may use a shared weight matrix and append an additional
    row of 1s to the input data.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经明确分开了偏置和输入权重矩阵，但实际上，底层实现可能使用共享的权重矩阵，并将一行额外的1添加到输入数据中。
- en: So far, we represented the input data samples as vectors, which we can combine
    in a matrix. However, the input data can have more dimensions. For example, we
    can represent an RGB image with three dimensions – three two-dimensional channels
    (one channel for each color). To combine multiple images in a batch, we’ll need
    a fourth dimension. In such cases, we can use input/output **tensors** instead
    of matrices.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们将输入数据样本表示为向量，能够将它们组合成矩阵。然而，输入数据可以有更多的维度。例如，我们可以用三维来表示RGB图像——三个二维通道（每个颜色一个通道）。为了将多个图像组合在一个批次中，我们需要一个第四维度。在这种情况下，我们可以使用输入/输出**张量**而不是矩阵。
- en: 'We’ll also use different types of layers to process multidimensional data.
    One such type is the convolutional layer, which we’ll discuss in [*Chapter 4*](B19627_04.xhtml#_idTextAnchor107).
    We have many other layer types, such as attention, pooling, and so on. Some of
    the layers have trainable weights (FC, attention, convolutional), while others
    don’t (pooling). We can also use the terms functions or operations interchangeably
    with the layer. For example, in TensorFlow and PyTorch, the FC layer we just described
    is a combination of two sequential operations. First, we perform the weighted
    sum of the weights and inputs, and then we feed the result as an input to the
    activation function operation. In practice (that is, when working with DL libraries),
    the basic building block of an NN is not the unit but an operation that takes
    one or more tensors as input and outputs one or more tensors:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用不同类型的层来处理多维数据。其中一种类型是卷积层，我们将在[*第4章*](B19627_04.xhtml#_idTextAnchor107)中讨论。我们有许多其他类型的层，如注意力层、池化层等。有些层具有可训练的权重（全连接层、注意力层、卷积层），而有些则没有（池化层）。我们也可以将“函数”或“操作”与“层”互换使用。例如，在
    TensorFlow 和 PyTorch 中，我们刚才描述的全连接层是两个顺序操作的组合。首先，我们对权重和输入进行加权求和，然后将结果作为输入传递给激活函数操作。在实际应用中（即在使用深度学习库时），神经网络的基本构建块不是单元，而是一个操作，它接受一个或多个张量作为输入，并输出一个或多个张量：
- en: '![Figure 2.10 – A function (or operation) with input and output tensors](img/B19627_02_10.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – 一个带有输入和输出张量的函数（或操作）](img/B19627_02_10.jpg)'
- en: Figure 2.10 – A function (or operation) with input and output tensors
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – 一个带有输入和输出张量的函数（或操作）
- en: Finally, we have all the necessary information to discuss NNs in their full
    glory.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们拥有了讨论神经网络（NNs）完整细节所需的所有信息。
- en: Multi-layer NNs
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多层神经网络
- en: 'As we have mentioned several times, single-layer neural nets can only classify
    linearly separable classes. However, there is nothing that prevents us from introducing
    more layers between the input and the output. These extra layers are called hidden
    layers. The following diagram demonstrates a three-layer fully connected NN with
    two hidden layers:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们多次提到的，单层神经网络只能分类线性可分的类别。然而，实际上并没有什么阻止我们在输入和输出之间引入更多的层。这些额外的层称为隐藏层。下图展示了一个具有两个隐藏层的三层全连接神经网络：
- en: '![Figure 2.11 – Multi-layer feed-forward network](img/B19627_02_11.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11 – 多层前馈网络](img/B19627_02_11.jpg)'
- en: Figure 2.11 – Multi-layer feed-forward network
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – 多层前馈网络
- en: The input layer has *k* input units, the first hidden layer has *n* hidden units,
    and the second hidden layer has *m* hidden units. On top is the always-on bias
    unit. The output, in this example, is the two units, ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/133.png)
    and ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/134.png),
    where each unit represents one of two possible classes. The output unit with the
    highest activation value will determine the NN’s class prediction for the given
    input sample. Each of the hidden units has a non-linear activation function, and
    the outputs have a special activation function called **softmax**, which we’ll
    discuss in the *Activation functions* section. A unit from one layer is connected
    to all units from the previous and following layers (hence fully connected). Each
    connection has its own weight, *w*, which is not depicted for reasons of simplicity.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 输入层有 *k* 个输入单元，第一个隐藏层有 *n* 个隐藏单元，第二个隐藏层有 *m* 个隐藏单元。最上面是一个始终开启的偏置单元。输出在这个例子中是两个单元，![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/133.png)
    和 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/134.png)，其中每个单元表示两个可能类别之一。具有最高激活值的输出单元将决定神经网络对给定输入样本的类别预测。每个隐藏单元都有一个非线性激活函数，而输出层则具有一种特别的激活函数叫做**softmax**，我们将在*激活函数*部分中讨论。一个层中的单元与前一层和后一层的所有单元相连（因此是全连接的）。每个连接都有自己的权重，*w*，为了简化图示未显示出来。
- en: As we mentioned in [*Chapter 1*](B19627_01.xhtml#_idTextAnchor016), we can think
    of the hidden layers as the NN’s internal representation of the input data. This
    is the way the NN understands the input sample with its own internal logic. However,
    this internal representation is non-interpretable by humans. To bridge the gap
    between the network’s representation and the actual data we’re interested in,
    we need the output layer. You can think of this as a translator; we use it to
    understand the network’s logic, and at the same time, we can convert it to the
    actual target values that we are interested in.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第一章*](B19627_01.xhtml#_idTextAnchor016)中提到的，我们可以将隐藏层看作是神经网络对输入数据的内部表示。这是神经网络用自己的内部逻辑理解输入样本的方式。然而，这种内部表示是人类无法解释的。为了弥合网络表示和我们关注的实际数据之间的差距，我们需要输出层。你可以将它看作一个翻译器；我们用它来理解网络的逻辑，同时也能将其转换为我们关心的实际目标值。
- en: 'However, we are not limited to single-path networks with sequential layers,
    as shown in the preceding diagram. The layers (or operations in general) form
    **directed acyclic graphs**. In such a graph, the information cannot pass twice
    through the same layer (no loops) and it flows in only one direction, from the
    input to the output. The network in the preceding diagram is just a special case
    of a graph whose layers are connected sequentially. The following diagram also
    depicts a valid NN with two input layers, a single output layer, and randomly
    interconnected hidden layers. The layers are represented as operations ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/135.png)
    (*i* is an index that helps us differentiate between multiple operations):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们并不局限于具有顺序层的单路径网络，如前图所示。这些层（或一般操作）构成**有向无环图**。在这样的图中，信息不能通过同一层两次（没有循环），且信息仅沿一个方向流动，从输入到输出。前面的网络图只是一个特殊的图例，其中的层按顺序连接。下图也展示了一个有效的神经网络，具有两个输入层、一个输出层以及随机互联的隐藏层。这些层被表示为操作
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/135.png)
    (*i* 是帮助我们区分多个操作的索引)：
- en: '![Figure 2.12 – NN as a graph of operations](img/B19627_02_12.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12 – 神经网络作为操作图](img/B19627_02_12.jpg)'
- en: Figure 2.12 – NN as a graph of operations
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 – 神经网络作为操作图
- en: Recurrent networks
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 递归网络
- en: There is a special class of NNs called **recurrent networks**, which represent
    a **directed cyclic graph** (they can have loops). We’ll discuss them in detail
    in [*Chapter 6*](B19627_06.xhtml#_idTextAnchor185).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊类型的神经网络，称为**递归网络**，它们表示**有向循环图**（可以有循环）。我们将在[*第六章*](B19627_06.xhtml#_idTextAnchor185)中详细讨论它们。
- en: 'In this section, we introduced the most basic type of NN – that is, the unit
    – gradually expanded it to layers, and then generalized it as a graph of operations.
    We can also think of it in another way. The operations have precise mathematical
    definitions. Therefore, the NN, as a composition of functions is also a mathematical
    function, where the input data represents the function arguments, and the set
    of network weights, *θ* (a set of all weight matrices, **W**), are its parameters.
    We’ll denote it with either ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/136.png)
    or ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/137.png).
    Let’s assume that, when an operation receives input from more than one source
    (input data or other operations), we use the elementwise sum to combine the multiple
    input tensors. Then, we can represent the NN as a series of nested functions/operations.
    The equivalent formula for the feed-forward network on the left is as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们介绍了最基本的神经网络类型——即单元——并逐步扩展到层级，然后将其概括为操作图。我们也可以从另一个角度来思考它。这些操作有着精确的数学定义。因此，神经网络作为函数的组合，实际上也是一个数学函数，其中输入数据代表函数的参数，网络权重集合*θ*（即所有权重矩阵的集合，**W**）则是其参数。我们可以用![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/136.png)
    或者 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>f</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/137.png)
    来表示它。假设当一个操作接收到来自多个来源（输入数据或其他操作）的输入时，我们使用逐元素求和来合并多个输入张量。然后，我们可以将神经网络表示为一系列嵌套的函数/操作。左侧前馈网络的等效公式如下：
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>f</mml:mi><mml:mi>f</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mn>5</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math>](img/138.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>f</mml:mi><mml:mi>f</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mn>5</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced>'
- en: Now that we’re familiar with the full NN architecture, let’s discuss the different
    types of activation functions.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了完整的神经网络架构，让我们来讨论不同类型的激活函数。
- en: Activation functions
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 激活函数
- en: 'We now know that multi-layer networks can classify linearly inseparable classes,
    but to do this, they need to satisfy one more condition. If the units don’t have
    activation functions, their output would be the weighted sum of the inputs, ![<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><msubsup><mo>∑</mo><mrow
    /><mrow /></msubsup><msub><mi>x</mi><mi>i</mi></msub></mrow><msub><mi>w</mi><mi>i</mi></msub><mo>+</mo><mi>b</mi></mrow></mrow></math>](img/139.png),
    which is a linear function. Then, the entire NN – that is, a composition of units
    – becomes a composition of linear functions, which is also a linear function.
    This means that even if we add hidden layers, the network will still be equivalent
    to a simple linear regression model, with all its limitations. To turn the network
    into a non-linear function, we’ll use non-linear activation functions for the
    units. Usually, all units in the same layer have the same activation function,
    but different layers may have different activation functions. We’ll start with
    three popular activation functions. The first two are from the *classic* period
    of NNs, while the third is contemporary:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道，多层网络可以对线性不可分的类进行分类，但为此它们还需要满足一个条件。如果单元没有激活函数，它们的输出将是输入的加权和，![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><msubsup><mo>∑</mo><mrow
    /><mrow /></msubsup><msub><mi>x</mi><mi>i</mi></msub></mrow><msub><mi>w</mi><mi>i</mi></msub><mo>+</mo><mi>b</mi></mrow></mrow></math>](img/139.png)，这就是一个线性函数。那么，整个神经网络——也就是单元的组合——将变成线性函数的组合，这也是一个线性函数。这意味着即使我们加入隐藏层，网络仍然等价于一个简单的线性回归模型，具有所有的局限性。为了将网络转变为非线性函数，我们将使用非线性激活函数来处理这些单元。通常，同一层的所有单元都使用相同的激活函数，但不同层之间可以使用不同的激活函数。我们将从三种常见的激活函数开始，前两种来自神经网络的*经典*时期，第三种则是当代的：
- en: '**Sigmoid**: Its output is bounded between 0 and 1 and can be interpreted stochastically
    as the probability of the unit being active. Because of these properties, the
    sigmoid was the most popular activation function for a long time. However, it
    also has some less desirable properties (more on that later), which led to its
    decline in use. The following diagram shows the sigmoid function, its derivative,
    and their graphs (the derivative will be useful when we discuss BP):'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sigmoid**：它的输出值被限制在0和1之间，可以在随机过程中解释为该单元被激活的概率。由于这些特性，sigmoid曾是最受欢迎的激活函数。然而，它也有一些不太理想的属性（稍后会详细讨论），这导致了它的使用逐渐减少。下图展示了sigmoid函数及其导数的图形（导数将在我们讨论反向传播时派上用场）：'
- en: '![Figure 2.13 – The sigmoid activation function](img/B19627_02_13.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图2.13 – sigmoid激活函数](img/B19627_02_13.jpg)'
- en: Figure 2.13 – The sigmoid activation function
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 – sigmoid激活函数
- en: '**Hyperbolic tangent (tanh)**: The name speaks for itself. The principal difference
    with the sigmoid is that the tanh is in the (-1, 1) range. The following diagram
    shows the tanh function, its derivative, and their graphs:'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双曲正切函数（tanh）**：其名称就已说明了其含义。与sigmoid的主要区别在于，tanh的取值范围是(-1, 1)。下图展示了tanh函数及其导数的图形：'
- en: '![Figure 2.14 – The hyperbolic tangent activation function](img/B19627_02_14.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图2.14 – 双曲正切激活函数](img/B19627_02_14.jpg)'
- en: Figure 2.14 – The hyperbolic tangent activation function
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 – 双曲正切激活函数
- en: '**Rectified Linear Unit (ReLU)**: This is the new kid on the block (that is,
    compared to the *veterans*). ReLU was first successfully used in 2011 (see *Deep
    Sparse Rectifier Neural Networks* at [http://proceedings.mlr.press/v15/glorot11a/glorot11a.pdf](http://proceedings.mlr.press/v15/glorot11a/glorot11a.pdf)).
    The following diagram shows the ReLU function, its derivative, and their graphs:'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修正线性单元（ReLU）**：这是新兴的技术（与*前辈们*相比）。ReLU首次成功应用于2011年（参见[《深度稀疏修正神经网络》](http://proceedings.mlr.press/v15/glorot11a/glorot11a.pdf)）。下图展示了ReLU函数及其导数的图形：'
- en: '![Figure 2.15 – The ReLU activation function](img/B19627_02_15.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图2.15 – ReLU激活函数](img/B19627_02_15.jpg)'
- en: Figure 2.15 – The ReLU activation function
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15 – ReLU激活函数
- en: As we can see, the ReLU repeats its input when x > 0 and stays at 0 otherwise.
    This activation has several important advantages over sigmoid and tanh, which
    make it possible to train NNs with more hidden layers (that is, deeper networks).
    We’ll discuss these advantages, as well as other types of activation functions,
    in [*Chapter 3*](B19627_03.xhtml#_idTextAnchor079).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，当x > 0时，ReLU会重复其输入，而在其他情况下保持为0。这种激活函数相较于sigmoid和tanh具有几个重要的优势，使得训练拥有更多隐藏层（即更深层网络）的神经网络成为可能。我们将在[*第3章*](B19627_03.xhtml#_idTextAnchor079)中讨论这些优势以及其他类型的激活函数。
- en: In the next section, we’ll demonstrate how NNs can approximate any function.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将展示神经网络如何逼近任何函数。
- en: The universal approximation theorem
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛化逼近定理
- en: 'In the *Multi-layer NNs* section, we defined the NN as a function, ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/140.png),
    where **x** is the input data (most often a vector or a tensor) and *θ* is the
    NN weights. Conversely, the training dataset is a collection of input samples
    and labels, which represents another, real-world, function ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/141.png).
    The NN function ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/142.png)
    **approximates** the function ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/141.png):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在*多层神经网络（NNs）*部分，我们将神经网络定义为一个函数，![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/140.png)，其中**x**是输入数据（通常是一个向量或张量），*θ*是神经网络的权重。相反，训练数据集是输入样本和标签的集合，表示另一个现实世界中的函数！[<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/141.png)。神经网络函数![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/142.png)**近似**了函数![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/141.png)：
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced><mml:mo>≈</mml:mo><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/144.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced><mml:mo>≈</mml:mo><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/144.png)'
- en: The universal approximation theorem states that any continuous function on compact
    subsets of ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/122.png)
    can be approximated to an arbitrary degree of accuracy by a feedforward NN, with
    at least one hidden layer with a finite number of units and a non-linear activation.
    This is significant because it tells us that there are no theoretical insurmountable
    limitations in terms of NNs. In practice, an NN with a single hidden layer will
    perform poorly in many tasks, but at least we can aspire to a bright future with
    all-powerful NNs. We can understand the universal approximation theorem with an
    intuitive example.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 普遍逼近定理指出，任何在有限子集上的连续函数 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/122.png)
    都可以通过一个至少包含一个隐含层、有限数量单元和非线性激活的前馈神经网络（NN）来逼近到任意精度。这是重要的，因为它告诉我们，在神经网络的理论上没有不可逾越的限制。实际上，虽然只有一个隐含层的神经网络在许多任务中表现不佳，但至少我们可以期待神经网络的光明前景。我们可以通过一个直观的例子来理解普遍逼近定理。
- en: Note
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The idea for the following example was inspired by Michael A. Nielsen’s book
    *Neural Networks and Deep* *Learning* ([http://neuralnetworksanddeeplearning.com/](http://neuralnetworksanddeeplearning.com/)).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下例子的灵感来源于 Michael A. Nielsen 的书籍 *神经网络与深度* *学习* ([http://neuralnetworksanddeeplearning.com/](http://neuralnetworksanddeeplearning.com/))。
- en: 'We’ll design an NN with one hidden layer that approximates the **boxcar function**
    (shown on the right in the following diagram). This is a type of step function,
    which is 0 across all input values, except in a narrow range, where it is equal
    to a constant value, *A*. A series of **translated** step functions can approximate
    any continuous function on a compact subset of ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="double-struck">R</mml:mi></mml:math>](img/146.png),
    as shown in the left figure of the following diagram:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设计一个带有单一隐含层的神经网络，用于逼近 **箱型函数**（见下图右侧）。这是一种阶梯函数，在所有输入值上都为 0，只有在一个狭窄范围内，它才取常数值
    *A*。一系列 **平移** 的阶梯函数可以逼近任何在有限子集上的连续函数 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math>](img/146.png)，如下图左侧所示：
- en: '![Figure 2.16 – Left: a continuous function approximation with a series of
    step functions, and right: a single boxcar step function](img/B19627_02_16.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.16 – 左：使用一系列阶梯函数来逼近连续函数，右：一个单一的箱型阶梯函数](img/B19627_02_16.jpg)'
- en: 'Figure 2.16 – Left: a continuous function approximation with a series of step
    functions, and right: a single boxcar step function'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 – 左：使用一系列阶梯函数来逼近连续函数，右：一个单一的箱型阶梯函数
- en: 'We’ll start building our boxcar NN with a single unit, with a single scalar
    input, *x*, and sigmoid activation. The following figure shows the unit, as well
    as its equivalent formula:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从构建一个带有单一单元的箱型神经网络开始，该单元具有一个标量输入 *x*，并采用 sigmoid 激活函数。下图展示了该单元及其等效公式：
- en: '![Figure 2.17 – A unit with single input and sigmoid activation](img/B19627_02_17.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.17 – 带有单一输入和 sigmoid 激活的单元](img/B19627_02_17.jpg)'
- en: Figure 2.17 – A unit with single input and sigmoid activation
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17 – 带有单一输入和 sigmoid 激活的单元
- en: 'In the following diagrams, we can see the unit output for different values
    of *b* and *w* with inputs, *x*, in the range [-10: 10]:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '在接下来的图示中，我们可以看到在输入 *x* 范围为 [-10: 10] 时，不同 *b* 和 *w* 值下的单元输出：'
- en: '![Figure 2.18 – The unit output based on diﬀerent values of w and b. The network
    input, x, is represented on the x axis](img/B19627_02_18.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.18 – 基于不同 *w* 和 *b* 值的单元输出。网络输入 *x* 显示在 x 轴上](img/B19627_02_18.jpg)'
- en: Figure 2.18 – The unit output based on diﬀerent values of w and b. The network
    input, x, is represented on the x axis
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18 – 基于不同 *w* 和 *b* 值的单元输出。网络输入 *x* 显示在 x 轴上。
- en: 'We can see that the weight, *w*, determines the steepness of the sigmoid function.
    We can also see that the formula, *t = -b/w*, determines the translation of the
    function along the *x* axis. Let’s cover the different graphs in the preceding
    diagram:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到权重 *w* 决定了 sigmoid 函数的陡峭程度。我们还可以看到公式 *t = -b/w* 决定了函数沿 *x* 轴的平移。让我们看看前面图示中的不同图形：
- en: '**Top-left**: Regular sigmoid'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左上角**：常规sigmoid'
- en: '**Top-right**: A large weight, *w*, amplifies the input, *x*, to a point where
    the sigmoid output resembles threshold activation'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右上角**：一个较大的权重，*w*，放大输入，*x*，直到sigmoid输出类似于阈值激活'
- en: '**Bottom-left**: The bias, *b*, translates the unit activation along the *x*
    axis'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左下角**：偏置，*b*，沿 *x* 轴平移单元激活'
- en: '**Bottom-right**: We can simultaneously translate the activation along the
    *x* axis with the bias, *b*, and reverse the activation with a negative value
    of the weight, *w*'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右下角**：我们可以同时通过偏置，*b*，沿 *x* 轴平移激活，并通过负值权重，*w*，反转激活'
- en: 'We can intuitively see that the unit can implement all the pieces of the box
    function. However, to create a full box function, we’ll have to combine two such
    units in an NN with one hidden layer. The following diagram shows the NN architecture,
    along with the weights and biases of the units, as well as the box function that’s
    produced by the network:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直观地看到，这个单元可以实现箱形函数的所有部分。然而，为了创建一个完整的箱形函数，我们需要在一个有一个隐藏层的神经网络中结合两个这样的单元。以下图显示了神经网络架构，以及单元的权重和偏置，还有网络生成的箱形函数：
- en: '![Figure 2.19 – A box function approximation NN](img/B19627_02_19.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 2.19 – A box function approximation NN](img/B19627_02_19.jpg)'
- en: Figure 2.19 – A box function approximation NN
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.19 – 箱形函数近似神经网络
- en: 'Here’s how it works:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 其工作原理如下：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>x</mi><mo><</mo><mo>-</mo><mn>5</mn></mrow></mrow></math>](img/147.png):
    the NN output is 0.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>x</mi><mo><</mo><mo>-</mo><mn>5</mn></mrow></mrow></math>](img/147.png)：神经网络输出为0。'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi><mml:mo>≥</mml:mo></mml:math>](img/148.png)5:
    The top unit activates for the upper step of the function and stays active for
    all values of ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi><mml:mo>≥</mml:mo><mml:mn>5</mml:mn></mml:math>](img/149.png).'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi><mml:mo>≥</mml:mo></mml:math>](img/148.png)5：顶层单元对函数的上升阶梯激活，并且在所有值为
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi><mml:mo>≥</mml:mo><mml:mn>5</mml:mn></mml:math>](img/149.png)时保持激活。'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:math>](img/150.png)0:
    The bottom unit activates for the bottom step of the function and stays active
    for all ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi><mml:mo>≥</mml:mo><mml:mn>10</mml:mn></mml:math>](img/151.png).
    The outputs of the two hidden units cancel each other out because of the weights
    in the output layer, which are the same but with opposite signs.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:math>](img/150.png)0：底层单元对函数的下阶梯激活，并且在所有
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>x</mml:mi><mml:mo>≥</mml:mo><mml:mn>10</mml:mn></mml:math>](img/151.png)时保持激活。由于输出层的权重相同但符号相反，两个隐藏单元的输出相互抵消。'
- en: The weights of the output layer determine the constant value, *A = 5*, of the
    boxcar function.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出层的权重决定了箱形函数的常数值，*A = 5*。
- en: The output of this network is 5 in the [-5:5] interval and 0 for all other inputs.
    We can approximate additional boxes by adding more units to the hidden layer in
    a similar manner.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 该网络的输出在[-5:5]区间内为5，其他输入则输出0。我们可以通过以类似的方式向隐藏层添加更多单元来近似其他箱形函数。
- en: Now that we’re familiar with the structure of an NN, let’s focus on their training
    process.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了神经网络（NN）的结构，让我们关注它们的训练过程。
- en: Training NNs
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练神经网络
- en: 'The NN function ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/152.png)
    **approximates** the function ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/153.png):
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced><mml:mo>≈</mml:mo><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/154.png).
    The goal of the training is to find parameters, *θ*, such that ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/155.png)
    will best approximate ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/156.png).
    First, we’ll see how to do that for a'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/152.png)
    **近似** 函数 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/153.png)：
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced><mml:mo>≈</mml:mo><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/154.png)。训练的目标是找到参数
    *θ*，使得 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/155.png)
    能够最佳地近似 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>g</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced></mml:math>](img/156.png)。首先，我们将看到如何为单层网络使用一个名为
    GD 的优化算法。
- en: single-layer network, using an optimization algorithm called GD. Then, we’ll
    extend it to a deep feedforward network with the help of BP.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将把它扩展到一个深度前馈网络，借助 BP 的帮助。
- en: Note
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Note
- en: We should note that an NN and its training algorithm are two separate things.
    This means we can adjust the weights of a network in some way other than GD and
    BP, but this is the most popular and efficient way to do so and is, ostensibly,
    the only way that is currently used in practice.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意，NN 和其训练算法是两个独立的东西。这意味着我们可以通过除了 GD 和 BP 之外的某种方式调整网络的权重，但这是目前在实践中使用的最流行和高效的方式。
- en: GD
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GD
- en: 'For the purposes of this section, we’ll train a simple NN using the **mean
    square error** (**MSE**) cost function. It measures the difference (known as **error**)
    between the network output and the training data labels of all training samples:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用**均方误差**（**MSE**）成本函数训练一个简单的 NN。它衡量了网络输出与所有训练样本的训练数据标签之间的差异（称为**误差**）。
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>J</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msup><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math>](img/157.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi>J</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msup><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math>](img/157.png)'
- en: 'At first, this might look scary, but fear not! Behind the scenes, it’s very
    simple and straightforward mathematics (I know that sounds even scarier!). Let’s
    discuss its components:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这可能看起来有些吓人，但别担心！背后其实是非常简单直接的数学（我知道这听起来更吓人！）。让我们来讨论它的组成部分：
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/158.png):
    The output of the NN, where *θ* is the set of all network weights. For the remainder
    of this section, we’ll denote the individual weights with ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/159.png)
    (unlike the *w* notation in the rest of the sections).'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math>](img/158.png):
    神经网络的输出，其中 *θ* 是所有网络权重的集合。在本节的其余部分，我们将使用 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/159.png)
    来表示各个单独的权重（与其他部分使用的 *w* 符号不同）。'
- en: '*n*: The total number of samples in the training set.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n*: 训练集中的样本总数。'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/132.png):
    The vector representation of a training sample, where the superscript *i* indicates
    the *i*-th sample of the dataset. We use superscript because ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/132.png)
    is a vector, and the subscript is reserved for each of the vector components.
    For example, ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/162.png)
    is the *j*-th component of the *i*-th training sample.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/132.png)：训练样本的向量表示，其中上标*i*表示数据集的第*i*个样本。我们使用上标是因为![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/132.png)是一个向量，且下标通常保留给每个向量分量。例如，![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/162.png)是第*i*个训练样本的第*j*个分量。'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/163.png):
    The label associated with the training sample, ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/132.png).'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/163.png)：与训练样本相关联的标签，![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/132.png)。'
- en: Note
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: In this example, we will use MSE, but in practice, there are different types
    of cost functions. We’ll discuss them in [*Chapter 3*](B19627_03.xhtml#_idTextAnchor079).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用均方误差（MSE），但实际上有不同类型的代价函数。我们将在[*第3章*](B19627_03.xhtml#_idTextAnchor079)中讨论它们。
- en: 'First, GD computes the derivative (gradient) of *J(θ)* with respect to all
    the network weights. The gradient gives us an indication of how *J(θ)* changes
    with respect to each weight. Then, the algorithm uses this information to update
    the weights in a way that will minimize *J(θ)* in future occurrences of the same
    input/target pairs. The goal is to gradually reach the **global minimum** of the
    cost function, where the gradient is 0\. The following is a visualization of GD
    for MSE with respect to a single NN weight:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，梯度下降（GD）计算代价函数*J(θ)*对所有网络权重的导数（梯度）。梯度告诉我们*J(θ)*如何随着每个权重的变化而变化。然后，算法利用这些信息以更新权重的方式，使得将来相同输入/目标对的*J(θ)*值最小化。目标是逐步达到代价函数的**全局最小值**，此时梯度为0。以下是对单个神经网络权重的MSE梯度下降（GD）可视化：
- en: '![Figure 2.20 – An MSE diagram](img/B19627_02_20.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.20 – MSE 图示](img/B19627_02_20.jpg)'
- en: Figure 2.20 – An MSE diagram
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.20 – MSE 图示
- en: 'Let’s go over the execution of GD step by step:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解GD的执行过程：
- en: Initialize the network weights, *θ*, with random values.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化网络权重*θ*，赋予随机值。
- en: 'Repeat until the cost function, *J(θ)*, falls below a certain threshold:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复以下过程，直到代价函数*J(θ)*降到某个阈值以下：
- en: '**Forward pass**: Compute the MSE *J(θ)* cost function for all the samples
    of the training set using the preceding formula'
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前向传播**：使用前述公式计算训练集所有样本的 MSE *J(θ)* 成本函数。'
- en: '**Backward pass**: Compute the partial derivatives (gradients) of *J(θ)* with
    respect to all the network weights ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/165.png),
    using the chain rule:'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反向传播**：使用链式法则计算 *J(θ)* 对所有网络权重 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/165.png)
    的偏导数（梯度）。'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msup><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo><mml:msup><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math>](img/166.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msup><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo><mml:msup><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math>](img/166.png)'
- en: 'Let’s analyze the partial derivative ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:mfenced><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/167.png).
    *J* is a function of ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/168.png)
    by being a function of the network output. Therefore, it is also a function of
    the NN function itself – that is, *J(f(θ))*. Then, by following the chain rule,
    we get the following: ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mstyle
    scriptlevel="+1"><mfrac><mrow><mo>∂</mo><mi>J</mi><mfenced open="(" close=")"><mi>θ</mi></mfenced></mrow><mrow><mo>∂</mo><msub><mi>θ</mi><mi>j</mi></msub></mrow></mfrac></mstyle><mo>=</mo><mstyle
    scriptlevel="+1"><mfrac><mrow><mo>∂</mo><mi>J</mi><mfenced open="(" close=")"><mrow><mi>f</mi><mfenced
    open="(" close=")"><mi>θ</mi></mfenced></mrow></mfenced></mrow><mrow><mo>∂</mo><msub><mi>θ</mi><mi>j</mi></msub></mrow></mfrac></mstyle><mo>=</mo><mstyle
    scriptlevel="+1"><mfrac><mrow><mo>∂</mo><mi>J</mi><mfenced open="(" close=")"><mrow><mi>f</mi><mfenced
    open="(" close=")"><mi>θ</mi></mfenced></mrow></mfenced></mrow><mrow><mo>∂</mo><mi>f</mi><mfenced
    open="(" close=")"><mi>θ</mi></mfenced></mrow></mfrac></mstyle><mstyle scriptlevel="+1"><mfrac><mrow><mo>∂</mo><mi>f</mi><mfenced
    open="(" close=")"><mi>θ</mi></mfenced></mrow><mrow><mo>∂</mo><msub><mi>θ</mi><mi>j</mi></msub></mrow></mfrac></mstyle></mrow></mrow></math>](img/169.png)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下偏导数 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:mfenced><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/167.png)。*J*
    是一个关于 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/168.png)
    的函数，因为它是网络输出的函数。因此，它也是 NN 函数本身的函数——即 *J(f(θ))*。然后，按照链式法则，我们得到以下公式：![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mstyle
    scriptlevel="+1"><mfrac><mrow><mo>∂</mo><mi>J</mi><mfenced open="(" close=")"><mi>θ</mi></mfenced></mrow><mrow><mo>∂</mo><msub><mi>θ</mi><mi>j</mi></msub></mrow></mfrac></mstyle><mo>=</mo><mstyle
    scriptlevel="+1"><mfrac><mrow><mo>∂</mo><mi>J</mi><mfenced open="(" close=")"><mrow><mi>f</mi><mfenced
    open="(" close=")"><mi>θ</mi></mfenced></mrow></mfenced></mrow><mrow><mo>∂</mo><msub><mi>θ</mi><mi>j</mi></msub></mrow></mfrac></mstyle><mo>=</mo><mstyle
    scriptlevel="+1"><mfrac><mrow><mo>∂</mo><mi>J</mi><mfenced open="(" close=")"><mrow><mi>f</mi><mfenced
    open="(" close=")"><mi>θ</mi></mfenced></mrow></mfenced></mrow><mrow><mo>∂</mo><mi>f</mi><mfenced
    open="(" close=")"><mi>θ</mi></mfenced></mrow></mfrac></mstyle><mstyle scriptlevel="+1"><mfrac><mrow><mo>∂</mo><mi>f</mi><mfenced
    open="(" close=")"><mi>θ</mi></mfenced></mrow><mrow><mo>∂</mo><msub><mi>θ</mi><mi>j</mi></msub></mrow></mfrac></mstyle></mrow></mrow></math>](img/169.png)
- en: 'Use these gradient values to update each of the network weights:'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这些梯度值来更新每个网络权重：
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mi>η</mml:mi><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mi>η</mml:mi><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math>](img/170.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mi>η</mml:mi><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mi>η</mml:mi><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math>](img/170.png)'
- en: Here, *η* is the **learning rate**, which determines the step size at which
    the optimizer makes updates to the weights during training. Let’s note that as
    we move closer to the global minimum, the gradient will get smaller and we’ll
    update the weights in finer steps.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*η* 是**学习率**，它决定了优化器在训练过程中更新权重时的步长。需要注意的是，随着我们逐渐接近全局最小值，梯度会变得越来越小，我们将以更细的步伐更新权重。
- en: 'To better understand how GD works, we’ll use linear regression as an example.
    Let’s recall that linear regression is equivalent to a single NN unit with an
    identity activation function, *f(x) =* *x*:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解梯度下降（GD）是如何工作的，我们以线性回归为例。我们可以回顾一下，线性回归相当于一个具有恒等激活函数的单一神经网络单元，*f(x) =*
    *x*：
- en: The linear regression is represented by the function ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mrow><mml:msubsup><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/171.png),
    where *m* is the dimension of the input vector (equal to the number of weights)
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性回归由以下函数表示 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mrow><mml:msubsup><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/171.png)，其中
    *m* 是输入向量的维度（等于权重的数量）。
- en: Then, we have the MSE cost function – ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>J</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:mrow><mml:msubsup><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:msup><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mrow><mml:msubsup><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:mrow></mml:mrow><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math>](img/172.png)
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们有 MSE 代价函数 – ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>J</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:mrow><mml:msubsup><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:msup><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mrow><mml:msubsup><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mrow></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:mrow></mml:mrow><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math>](img/172.png)
- en: 'Then, we compute the partial derivative ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:mfenced><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/173.png)
    with respect to a single network weight ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/174.png)
    using the chain rule and the sum rule:'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们计算偏导数 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:mfenced><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/173.png)
    相对于单个网络权重 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/174.png)，使用链式法则和求和法则：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfrac><mrow><mo>∂</mo><mi>J</mi><mfenced
    open="(" close=")"><mi>θ</mi></mfenced></mrow><mrow><mo>∂</mo><msub><mi>θ</mi><mi>j</mi></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><mo>∂</mo><mstyle
    scriptlevel="+1"><mfrac><mn>1</mn><mrow><mn>2</mn><mi>n</mi></mrow></mfrac></mstyle><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msup><mfenced
    open="(" close=")"><mrow><mfenced open="(" close=")"><mrow><mrow><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup><msubsup><mi>x</mi><mi>j</mi><mfenced
    open="(" close=")"><mi>i</mi></mfenced></msubsup></mrow><msub><mi>θ</mi><mi>j</mi></msub></mrow></mfenced><mo>−</mo><msup><mi>t</mi><mfenced
    open="(" close=")"><mi>i</mi></mfenced></msup></mrow></mfenced><mn>2</mn></msup></mrow></mrow><mrow><mo>∂</mo><msub><mi>θ</mi><mi>j</mi></msub></mrow></mfrac></mrow></mrow></math>](img/175.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfrac><mrow><mo>∂</mo><mi>J</mi><mfenced
    open="(" close=")"><mi>θ</mi></mfenced></mrow><mrow><mo>∂</mo><msub><mi>θ</mi><mi>j</mi></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><mo>∂</mo><mstyle
    scriptlevel="+1"><mfrac><mn>1</mn><mrow><mn>2</mn><mi>n</mi></mrow></mfrac></mstyle><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msup><mfenced
    open="(" close=")"><mrow><mfenced open="(" close=")"><mrow><mrow><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup><msubsup><mi>x</mi><mi>j</mi><mfenced
    open="(" close=")"><mi>i</mi></mfenced></msubsup></mrow><msub><mi>θ</mi><mi>j</mi></msub></mrow></mfenced><mo>−</mo><msup><mi>t</mi><mfenced
    open="(" close=")"><mi>i</mi></mfenced></msup></mrow></mfenced><mn>2</mn></msup></mrow></mrow><mrow><mo>∂</mo><msub><mi>θ</mi><mi>j</mi></msub></mrow></mfrac></mrow></mrow></math>](img/175.png)'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>n</mi></mrow></mfrac><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mrow><mo>∂</mo><msup><mfenced
    open="(" close=")"><mrow><mfenced open="(" close=")"><mrow><mrow><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup><msubsup><mi>x</mi><mi>j</mi><mfenced
    open="(" close=")"><mi>i</mi></mfenced></msubsup></mrow><msub><mi>θ</mi><mi>j</mi></msub></mrow></mfenced><mo>−</mo><msup><mi>t</mi><mfenced
    open="(" close=")"><mi>i</mi></mfenced></msup></mrow></mfenced><mn>2</mn></msup></mrow><mrow><mo>∂</mo><msub><mi>θ</mi><mi>j</mi></msub></mrow></mfrac></mrow></mrow></mrow></math>](img/176.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>n</mi></mrow></mfrac><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mrow><mo>∂</mo><msup><mfenced
    open="(" close=")"><mrow><mfenced open="(" close=")"><mrow><mrow><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup><msubsup><mi>x</mi><mi>j</mi><mfenced
    open="(" close=")"><mi>i</mi></mfenced></msubsup></mrow><msub><mi>θ</mi><mi>j</mi></msub></mrow></mfenced><mo>−</mo><msup><mi>t</mi><mfenced
    open="(" close=")"><mi>i</mi></mfenced></msup></mrow></mfenced><mn>2</mn></msup></mrow><mrow><mo>∂</mo><msub><mi>θ</mi><mi>j</mi></msub></mrow></mfrac></mrow></mrow></mrow></math>](img/176.png)'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:mrow></mml:mrow><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math>](img/177.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:mrow></mml:mrow><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math>](img/177.png)'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math>](img/178.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:mrow><mml:munderover><mml:mo
    stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:msub><mml:mfenced
    separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>-</mml:mo><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math>](img/178.png)'
- en: Now that we have the gradient, ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:mfenced><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/179.png),
    we can update the weight ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/180.png)
    using the learning rate *η*
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们得到了梯度， ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:mfenced><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/179.png)，我们可以使用学习率*η*来更新权重
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/180.png)
- en: 'So far, we’ve discussed a GD that works with NNs with multiple weights. However,
    for the sake of simplicity, the preceding diagram illustrates the relationship
    between the cost function and a single-weight NN. Let’s remedy this by introducing
    a more complex cost function for an NN with two weights, ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/181.png)
    and ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/182.png):'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '到目前为止，我们讨论的是一个适用于具有多个权重的神经网络（NN）的梯度下降算法。然而，为了简化起见，前面的图示说明了成本函数与单一权重神经网络之间的关系。让我们通过引入一个具有两个权重的更复杂的神经网络成本函数来解决这个问题，分别为
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/181.png)
    和 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math>](img/182.png):'
- en: '![Figure 2.21 – The cost function J with respect to two weights](img/B19627_02_21.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.21 – 关于两个权重的成本函数 J](img/B19627_02_21.jpg)'
- en: Figure 2.21 – The cost function J with respect to two weights
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.21 – 关于两个权重的成本函数 J
- en: The function has a local and a global minimum. Nothing prevents GD from converging
    to the local minimum, instead of the global one, thus finding a sub-optimal approximation
    to the target function. We can try to mitigate this by increasing the learning
    rate *η*. The idea is that even if GD converges toward the local minimum, the
    larger *η* will help us *jump* over the saddle and converge toward the global
    maximum. The risk is that the opposite could happen – if GD correctly converges
    toward the global maximum, the larger learning rate could make it *jump* over
    to the local minimum instead.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数有局部最小值和全局最小值。没有什么可以阻止梯度下降（GD）收敛到局部最小值，而不是全局最小值，从而找到一个次优的目标函数近似。我们可以通过增大学习率*η*来尝试缓解这个问题。其想法是，即使GD收敛到局部最小值，较大的*η*也能帮助我们*跳跃*过鞍点并收敛到全局最小值。风险在于，反之也可能发生——如果GD正确地收敛到全局最小值，较大的学习率可能会使其*跳跃*到局部最小值。
- en: A more elegant way to prevent this issue is to use **momentum**. This extends
    vanilla GD by adjusting the current weight update with the values of the previous
    weight updates – that is, if the weight update at step t-1 was big, it will also
    increase the weight update of step t. We can explain momentum with an analogy.
    Think of the loss function surface as the surface of a hill. Now, imagine that
    we are holding a ball at the top of the hill (maximum). If we drop the ball, thanks
    to the Earth’s gravity, it will start rolling toward the bottom of the hill (minimum).
    The more distance it travels, the more its speed will increase. In other words,
    it will gain momentum (hence the name of the optimization).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 防止此问题的一个更优雅的方法是使用**动量**。这通过调整当前权重更新与之前权重更新的值来扩展了普通的梯度下降——也就是说，如果步骤 t-1 的权重更新很大，它也会增加步骤
    t 的权重更新。我们可以通过类比来解释动量。可以将损失函数表面看作是一座山的表面。现在，假设我们把一个球放在山顶（最大值）上。如果我们放开球，依靠地球的重力，它会开始滚向山谷底部（最小值）。它行进的距离越远，速度就越快。换句话说，它会获得动量（因此优化方法也得名）。
- en: 'Now, let’s look at how to implement momentum in the weight update rule ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mi>η</mml:mi><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:mfenced><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/183.png).
    We’ll assume that we are at step t of the training process:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在权重更新规则中实现动量 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mi>η</mml:mi><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:mfenced><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/183.png)。我们假设现在处于训练过程中的第
    t 步：
- en: 'First, we’ll calculate the current weight update value ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:math>](img/184.png)
    by also including the velocity of the previous update ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/185.png):
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:mi>μ</mml:mi><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mi>η</mml:mi><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:mfenced><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/186.png).
    Here, μ is a hyperparameter in the [0:1] range called the momentum rate. ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:math>](img/187.png)
    is initialized as 0 during the first iteration.'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将计算当前的权重更新值 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:math>](img/184.png)，并包括上次更新的速度
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math>](img/185.png)：![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:mi>μ</mml:mi><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mi>η</mml:mi><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:mfenced><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/186.png)。这里，μ是一个范围在[0:1]之间的超参数，称为动量率。![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:math>](img/187.png)
    在第一次迭代时初始化为0。
- en: Then, we perform the actual weight update – ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:math>](img/188.png).
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们执行实际的权重更新 – ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:math>](img/188.png)。
- en: Finding the best values of the learning rate *η* and the momentum rate *μ* is
    an empirical task. They can depend on the NN architecture, the type and size of
    a dataset, and other factors. In addition, we might have to adjust them during
    training. Since the NN weights are randomly initialized, we usually start with
    a larger *η* so that GD can quickly advance while the initial value of the cost
    function (error) is large. Once the decrease in the cost function starts plateauing,
    we can decrease the learning rate. In this way, GD can find minimums that would
    have been *jumped over* with the larger learning rate.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 找到最佳的学习率 *η* 和动量率 *μ* 是一项经验任务。它们可能依赖于神经网络的架构、数据集的类型和大小以及其他因素。此外，我们可能需要在训练过程中调整它们。由于神经网络的权重是随机初始化的，我们通常从较大的
    *η* 开始，以便梯度下降（GD）可以快速推进，尤其是在成本函数（误差）初始值较大时。一旦成本函数的下降开始趋于平稳，我们就可以降低学习率。通过这种方式，梯度下降可以找到那些在较大学习率下可能*跳过*的最小值。
- en: 'Alternatively, we can use an adaptive learning rate algorithm such as **Adam**
    (see *Adam: A Method for Stochastic Optimization* at [https://arxiv.org/abs/1412.6980](https://arxiv.org/abs/1412.6980)).
    It calculates individual and adaptive learning rates for every weight, based on
    previous weight updates (momentum).'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '另外，我们可以使用一种自适应学习率算法，如 **Adam**（请参阅 [https://arxiv.org/abs/1412.6980](https://arxiv.org/abs/1412.6980)
    中的 *Adam: A Method for Stochastic Optimization*）。它根据之前的权重更新（动量）为每个权重计算个性化和自适应的学习率。'
- en: 'The GD we just described is called **batch gradient descent** because it accumulates
    the error across *all* training samples and then performs a single weight update.
    This is fine for small datasets but could become impractical for large ones, as
    the training would take a long time with such sporadic updates. In practice, we
    would use two modifications:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚描述的 GD 称为 **批量梯度下降**，因为它在 *所有* 训练样本上累积误差，然后进行一次权重更新。这对于小型数据集来说没问题，但对于大型数据集来说可能变得不切实际，因为这种偶尔更新的方式会导致训练时间很长。在实际应用中，我们会使用两种修改：
- en: '**Stochastic (or online) gradient descent** (**SGD**): Updates the weights
    after every training sample.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机（或在线）梯度下降**（**SGD**）：在每个训练样本之后更新权重。'
- en: '**Mini-batch gradient descent**: Accumulates the error over batches of *k*
    samples (called **mini-batches**) and performs one weight update after each mini-batch.
    It is a hybrid between online and batch GD. In practice, we’ll almost always use
    mini-batch GD over the other modifications.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小批量梯度下降**：在每个小批量（称为**小批量**）的 *k* 个样本上累积误差，并在每个小批量之后进行一次权重更新。它是在线 GD 和批量 GD
    之间的一种混合方式。在实践中，我们几乎总是会使用小批量 GD，而不是其他修改。'
- en: The next step in our learning journey is to understand how to apply GD to train
    networks with more than one layer.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习旅程的下一步是了解如何将 GD 应用到多层网络的训练中。
- en: Backpropagation
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反向传播
- en: 'In this section, we’ll discuss how to combine GD with the BP algorithm to update
    the weights of networks with more than one layer. As we demonstrated in the *GD*
    section, this means finding the derivative of the cost function *J(θ)* with respect
    to each network weight. We already took a step in this direction with the help
    of the chain rule:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何将 GD 与 BP 算法结合，以更新多层网络的权重。正如我们在 *GD* 部分演示的那样，这意味着求出成本函数 *J(θ)* 对每个网络权重的导数。我们已经借助链式法则在这方面迈出了第一步：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfrac><mrow><mo>∂</mo><mi>J</mi><mfenced
    open="(" close=")"><mi>θ</mi></mfenced></mrow><mrow><mo>∂</mo><msub><mi>θ</mi><mi>j</mi></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><mo>∂</mo><mi>J</mi><mfenced
    open="(" close=")"><mrow><mi>f</mi><mfenced open="(" close=")"><mi>θ</mi></mfenced></mrow></mfenced></mrow><mrow><mo>∂</mo><msub><mi>θ</mi><mi>j</mi></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><mo>∂</mo><mi>J</mi><mfenced
    open="(" close=")"><mrow><mi>f</mi><mfenced open="(" close=")"><mi>θ</mi></mfenced></mrow></mfenced></mrow><mrow><mo>∂</mo><mi>f</mi><mfenced
    open="(" close=")"><mi>θ</mi></mfenced></mrow></mfrac><mfrac><mrow><mo>∂</mo><mi>f</mi><mfenced
    open="(" close=")"><mi>θ</mi></mfenced></mrow><mrow><mo>∂</mo><msub><mi>θ</mi><mi>j</mi></msub></mrow></mfrac></mrow></mrow></math>](img/189.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfrac><mrow><mo>∂</mo><mi>J</mi><mfenced
    open="(" close=")"><mi>θ</mi></mfenced></mrow><mrow><mo>∂</mo><msub><mi>θ</mi><mi>j</mi></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><mo>∂</mo><mi>J</mi><mfenced
    open="(" close=")"><mrow><mi>f</mi><mfenced open="(" close=")"><mi>θ</mi></mfenced></mrow></mfenced></mrow><mrow><mo>∂</mo><msub><mi>θ</mi><mi>j</mi></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><mo>∂</mo><mi>J</mi><mfenced
    open="(" close=")"><mrow><mi>f</mi><mfenced open="(" close=")"><mi>θ</mi></mfenced></mrow></mfenced></mrow><mrow><mo>∂</mo><mi>f</mi><mfenced
    open="(" close=")"><mi>θ</mi></mfenced></mrow></mfrac><mfrac><mrow><mo>∂</mo><mi>f</mi><mfenced
    open="(" close=")"><mi>θ</mi></mfenced></mrow><mrow><mo>∂</mo><msub><mi>θ</mi><mi>j</mi></msub></mrow></mfrac></mrow></mrow></math>](img/189.png)'
- en: 'Here, *f(θ)* is the network output and ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/190.png)
    is the *j*-th network weight. In this section, we’ll push the envelope further,
    and we’ll learn how to derive the NN function itself for all the network weights
    (hint – the chain rule). We’ll do this by propagating the error gradient backward
    through the network (hence the name). Let’s start with a few assumptions:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*f(θ)* 是网络的输出，![
- en: For the sake of simplicity, we’ll work with a sequential feedforward NN. *Sequential*
    means that each layer takes input from the preceding layer and sends its output
    to the following layer.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了简化起见，我们将使用顺序前馈神经网络（NN）。*顺序*意味着每一层都从前一层接收输入，并将其输出发送到下一层。
- en: We’ll define ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/191.png)
    as the weight between the *i*-th unit of layer *l* and the *j*-th unit of the
    subsequent layer *l+1*. In a multi-layer network, *l* and *l+1* can be any two
    consecutive layers, including input, hidden, and output layers.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将定义 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/191.png)
    作为层 *l* 中第 *i* 个单元与下一层 *l+1* 中第 *j* 个单元之间的权重。在多层网络中，*l* 和 *l+1* 可以是任何两个连续的层，包括输入层、隐藏层和输出层。
- en: We’ll denote the output of the *i*-th unit of layer *l* with ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/192.png)
    and the output of the *j*-th unit of layer *l+1* with ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/193.png).
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将用 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/192.png)
    来表示层 *l* 中第 *i* 个单元的输出，用 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/193.png)
    来表示层 *l+1* 中第 *j* 个单元的输出。
- en: We’ll denote the input to the activation function (that is, the weighted sum
    of the inputs before activation) of unit *j* of layer *l*, with ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/194.png).
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将用 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/194.png)
    来表示层 *l* 中单元 *j* 激活函数的输入（即激活前输入的加权和）。
- en: 'The following diagram shows all the notations we introduced:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了我们介绍的所有符号：
- en: '![Figure 2.22 – Layer l represents the input, layer l+1 represents the output,
    and w connects the y activation in layer l to the inputs of the j-th unit of layer
    l+1](img/B19627_02_22.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.22 – 层 l 代表输入，层 l+1 代表输出，w 连接层 l 中的 y 激活到层 l+1 中第 j 个单元的输入](img/B19627_02_22.jpg)'
- en: Figure 2.22 – Layer l represents the input, layer l+1 represents the output,
    and w connects the y activation in layer l to the inputs of the j-th unit of layer
    l+1
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.22 – 层l表示输入层，层l+1表示输出层，w连接了层l中的y激活到层l+1中第j个单元的输入。
- en: 'Armed with this useful knowledge, let’s get down to business:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了这些有用的知识后，我们开始正式讨论：
- en: 'First, we’ll assume that *l* and *l+1* are the second-to-last and the last
    (output) network layers, respectively. Knowing this, the derivative of *J* with
    respect to ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/195.png)
    is as follows:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们假设 *l* 和 *l+1* 分别是倒数第二层和最后一层（输出层）。了解这一点后，*J* 关于 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/195.png)
    的导数如下所示：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfrac><mrow><mo>∂</mo><mi>J</mi></mrow><mrow><mo>∂</mo><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><mo>∂</mo><mi>J</mi></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow></mfrac><mfrac><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><mrow><mo>∂</mo><msubsup><mi>a</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow></mfrac><mfrac><mrow><mo>∂</mo><msubsup><mi>a</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><mrow><mo>∂</mo><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow></mfrac></mrow></mrow></math>](img/196.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfrac><mrow><mo>∂</mo><mi>J</mi></mrow><mrow><mo>∂</mo><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><mo>∂</mo><mi>J</mi></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow></mfrac><mfrac><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><mrow><mo>∂</mo><msubsup><mi>a</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow></mfrac><mfrac><mrow><mo>∂</mo><msubsup><mi>a</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><mrow><mo>∂</mo><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow></mfrac></mrow></mrow></math>](img/196.png)'
- en: 2. Let’s focus on ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/197.png).
    Here, we compute the partial derivative of the weighted sum of the output of layer
    *l* with respect to one of the weights, ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/198.png).
    As we discussed in the *Differential calculus* section, in partial derivatives,
    we’ll consider all the function parameters except ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/128.png)
    constants. When we derive ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/200.png),
    they all become 0, and we’re only left with ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/201.png).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 让我们聚焦于 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/197.png)。这里，我们计算的是层
    *l* 输出的加权和对其中一个权重的偏导数，![
- en: 'Therefore, we get the following:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得出以下结论：
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/202.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/202.png)'
- en: '3. The formula from point 1 holds for any two consecutive hidden layers, *l*
    and *l+1*, of the network. We know that ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/203.png),
    and we also know that ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/204.png)
    is the derivative of the activation function, which we can calculate (see the
    *Activation functions* section). All we need to do is calculate the derivative
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/205.png)
    (recall that, here, *l+1* is a hidden layer). Let’s note that this is the derivative
    of the error with respect to the activation function in layer *l+1*. We can now
    calculate all the derivatives, starting from the last layer and moving backward,
    because the following apply:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 第1点中的公式适用于网络中任何两个连续的隐藏层，*l* 和 *l+1*。我们知道，![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/203.png)，同时我们还知道，![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/204.png)
    是激活函数的导数，我们可以计算它（参见 *激活函数* 部分）。我们需要做的就是计算导数 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/205.png)（回想一下，这里，*l+1*
    是一个隐藏层）。我们可以注意到，这是相对于 *l+1* 层中激活函数的误差导数。现在我们可以从最后一层开始，逐步向后计算所有的导数，因为以下内容成立：
- en: We can calculate this derivative for the last layer
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以计算最后一层的这个导数。
- en: We have a formula that allows us to calculate the derivative for one layer,
    assuming that we can calculate the derivative for the next
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个公式，可以让我们计算一个层的导数，前提是我们能够计算下一层的导数。
- en: '4. With these points in mind, we get the following equation by applying the
    chain rule:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 牢记这些要点后，我们通过应用链式法则得到以下公式：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfrac><mrow><mo>∂</mo><mi>J</mi></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>i</mi><mfenced
    open="(" close=")"><mi>l</mi></mfenced></msubsup></mrow></mfrac><mo>=</mo><mrow><munderover><mo>∑</mo><mi>j</mi><mrow
    /></munderover><mrow><mfrac><mrow><mo>∂</mo><mi>J</mi></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow></mfrac><mfrac><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>i</mi><mfenced
    open="(" close=")"><mi>l</mi></mfenced></msubsup></mrow></mfrac></mrow></mrow><mo>=</mo><mrow><munderover><mo>∑</mo><mi>j</mi><mrow
    /></munderover><mrow><mfrac><mrow><mo>∂</mo><mi>J</mi></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow></mfrac><mfrac><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><mrow><mo>∂</mo><msubsup><mi>a</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow></mfrac><mfrac><mrow><mo>∂</mo><msubsup><mi>a</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>i</mi><mfenced
    open="(" close=")"><mi>l</mi></mfenced></msubsup></mrow></mfrac></mrow></mrow></mrow></mrow></math>](img/206.png)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfrac><mrow><mo>∂</mo><mi>J</mi></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>i</mi><mfenced
    open="(" close=")"><mi>l</mi></mfenced></msubsup></mrow></mfrac><mo>=</mo><mrow><munderover><mo>∑</mo><mi>j</mi><mrow
    /></munderover><mrow><mfrac><mrow><mo>∂</mo><mi>J</mi></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow></mfrac><mfrac><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>i</mi><mfenced
    open="(" close=")"><mi>l</mi></mfenced></msubsup></mrow></mfrac></mrow></mrow><mo>=</mo><mrow><munderover><mo>∑</mo><mi>j</mi><mrow
    /></munderover><mrow><mfrac><mrow><mo>∂</mo><mi>J</mi></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow></mfrac><mfrac><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><mrow><mo>∂</mo><msubsup><mi>a</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow></mfrac><mfrac><mrow><mo>∂</mo><msubsup><mi>a</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>i</mi><mfenced
    open="(" close=")"><mi>l</mi></mfenced></msubsup></mrow></mfrac></mrow></mrow></mrow></mrow></math>](img/206.png)'
- en: The sum over j reflects the fact that, in the feedforward part of the network,
    the output ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/207.png)
    is fed to all the units in layer *l+1*. Therefore, they all contribute to ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/208.png)
    when the error is propagated backward.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/207.png)
    在网络的前馈部分中，输出被馈送到第 *l+1* 层的所有单元。因此，它们在向后传播错误时都会对 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/208.png)
    有所贡献。'
- en: Note
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the *Layers as operations* section, we discussed that in the forward pass,
    we can simultaneously compute all outputs of layer *l+1* as a matrix-matrix multiplication
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">Y</mml:mi></mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">W</mml:mi></mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/209.png).
    Here, ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">Y</mml:mi></mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/210.png)
    is the layer output of layer *l*, and ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">W</mml:mi></mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/211.png)
    is the weight matrix between layers *l* and *l+1*. In the forward pass, one column
    of ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">W</mml:mi></mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/212.png)
    represents the weights from all units of the input layer *l* to a single unit
    of the output layer *l+1*. We can also represent the backward pass as a matrix-matrix
    multiplication by using the transpose weight matrix ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">W</mml:mi></mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">W</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi>⊤</mml:mi></mml:mrow></mml:msup></mml:math>](img/213.png).
    A column of the transposed matrix represents the weights of all units of *l*,
    which contributed to a particular unit of *l+1* during the forward phase.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在*层作为操作*部分，我们讨论了在前向传递中，如何通过矩阵-矩阵乘法同时计算出层*l+1*的所有输出 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">Y</mml:mi></mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">W</mml:mi></mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/209.png)。在这里，![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">Y</mml:mi></mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/210.png)
    是层*l*的层输出，![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">W</mml:mi></mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/211.png)
    是层*l*和层*l+1*之间的权重矩阵。在前向传递中，![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">W</mml:mi></mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/212.png)
    的一列代表了从输入层*l*的所有单元到输出层*l+1*的某个单元的权重。在反向传递中，我们也可以通过使用转置权重矩阵来表示矩阵-矩阵乘法！[<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi
    mathvariant="bold">W</mml:mi></mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mfenced
    open="[" close="]" separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">W</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi>⊤</mml:mi></mml:mrow></mml:msup></mml:math>](img/213.png)。转置矩阵的一列代表了所有来自*l*的单元权重，这些权重在前向传递阶段贡献给了*l+1*的某个特定单元。
- en: Once again, we can calculate ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/214.png).
    Using the same logic that we followed in *step 3*, we can compute that ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/215.png).
    Therefore, once we know ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/216.png),
    we can calculate ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/217.png)![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/218.png).
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次计算 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/214.png)。
    使用我们在*步骤 3*中遵循的相同逻辑，我们可以计算出 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/215.png)。
    因此，一旦我们知道 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/216.png)，我们可以计算出
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/217.png)![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/218.png)。
- en: Since we can calculate ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/219.png)
    for the last layer, we can move backward and calculate ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/220.png)
    for any layer and, therefore, ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/221.png)
    for any layer.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以计算 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/219.png)
    用于最后一层，我们可以向后移动并计算 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/220.png)
    对于任何层，并因此计算 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∂</mml:mo><mml:mi>J</mml:mi><mml:mtext>/</mml:mtext><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math>](img/221.png)
    对于任何层。
- en: '5. To summarize, let’s say we have a sequence of layers where the following
    applies:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 总结一下，假设我们有一系列层，其中适用以下内容：
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math>](img/222.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math>](img/222.png)'
- en: 'Here, we have the following fundamental equations:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有以下基本方程式：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfrac><mrow><mo>∂</mo><mi>J</mi></mrow><mrow><mo>∂</mo><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><mo>∂</mo><mi>J</mi></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow></mfrac><mfrac><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><mrow><mo>∂</mo><msubsup><mi>a</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow></mfrac><mfrac><mrow><mo>∂</mo><msubsup><mi>a</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><mrow><mo>∂</mo><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow></mfrac></mrow></mrow></math>](img/196.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfrac><mrow><mo>∂</mo><mi>J</mi></mrow><mrow><mo>∂</mo><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><mo>∂</mo><mi>J</mi></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow></mfrac><mfrac><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><mrow><mo>∂</mo><msubsup><mi>a</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow></mfrac><mfrac><mrow><mo>∂</mo><msubsup><mi>a</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><mrow><mo>∂</mo><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow></mfrac></mrow></mrow></math>](img/196.png)'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfrac><mrow><mo>∂</mo><mi>J</mi></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>i</mi><mfenced
    open="(" close=")"><mi>l</mi></mfenced></msubsup></mrow></mfrac><mo>=</mo><mrow><munderover><mo>∑</mo><mi>j</mi><mrow
    /></munderover><mrow><mfrac><mrow><mo>∂</mo><mi>J</mi></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow></mfrac><mfrac><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>i</mi><mfenced
    open="(" close=")"><mi>l</mi></mfenced></msubsup></mrow></mfrac></mrow></mrow><mo>=</mo><mrow><munderover><mo>∑</mo><mi>j</mi><mrow
    /></munderover><mrow><mfrac><mrow><mo>∂</mo><mi>J</mi></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow></mfrac><mfrac><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><mrow><mo>∂</mo><msubsup><mi>a</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow></mfrac><mfrac><mrow><mo>∂</mo><msubsup><mi>a</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>i</mi><mfenced
    open="(" close=")"><mi>l</mi></mfenced></msubsup></mrow></mfrac></mrow></mrow></mrow></mrow></math>](img/206.png)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfrac><mrow><mo>∂</mo><mi>J</mi></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>i</mi><mfenced
    open="(" close=")"><mi>l</mi></mfenced></msubsup></mrow></mfrac><mo>=</mo><mrow><munderover><mo>∑</mo><mi>j</mi><mrow
    /></munderover><mrow><mfrac><mrow><mo>∂</mo><mi>J</mi></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow></mfrac><mfrac><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>i</mi><mfenced
    open="(" close=")"><mi>l</mi></mfenced></msubsup></mrow></mfrac></mrow></mrow><mo>=</mo><mrow><munderover><mo>∑</mo><mi>j</mi><mrow
    /></munderover><mrow><mfrac><mrow><mo>∂</mo><mi>J</mi></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow></mfrac><mfrac><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><mrow><mo>∂</mo><msubsup><mi>a</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow></mfrac><mfrac><mrow><mo>∂</mo><msubsup><mi>a</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>i</mi><mfenced
    open="(" close=")"><mi>l</mi></mfenced></msubsup></mrow></mfrac></mrow></mrow></mrow></mrow></math>](img/206.png)'
- en: By using these two equations, we can calculate the derivatives for the cost
    with respect to each layer.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两个方程，我们可以计算出每一层的成本函数的导数。
- en: '6. If we set ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msubsup><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo><mml:mi>J</mml:mi></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:mrow></mml:mfrac><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:mrow></mml:mfrac></mml:math>](img/225.png),
    then ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/226.png)
    represents the variation in cost with respect to the activation value, and we
    can think of ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/227.png)
    as the error at unit ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/228.png).
    We can rewrite these equations as follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 如果我们设置 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msubsup><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo><mml:mi>J</mml:mi></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:mrow></mml:mfrac><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:mrow></mml:mfrac></mml:math>](img/225.png)，那么
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/226.png)
    表示相对于激活值的成本变化，我们可以将 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/227.png)
    看作是单元 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:math>](img/228.png)
    的误差。我们可以将这些方程改写如下：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfrac><mrow><mo>∂</mo><mi>J</mi></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>i</mi><mfenced
    open="(" close=")"><mi>l</mi></mfenced></msubsup></mrow></mfrac><mo>=</mo><mrow><munderover><mo>∑</mo><mi>j</mi><mrow
    /></munderover><mrow><mfrac><mrow><mo>∂</mo><mi>J</mi></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow></mfrac><mfrac><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>i</mi><mfenced
    open="(" close=")"><mi>l</mi></mfenced></msubsup></mrow></mfrac></mrow></mrow><mo>=</mo><mrow><munderover><mo>∑</mo><mi>j</mi><mrow
    /></munderover><mrow><mfrac><mrow><mo>∂</mo><mi>J</mi></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow></mfrac><mfrac><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><mrow><mo>∂</mo><msubsup><mi>a</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow></mfrac><mfrac><mrow><mo>∂</mo><msubsup><mi>a</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>i</mi><mfenced
    open="(" close=")"><mi>l</mi></mfenced></msubsup></mrow></mfrac></mrow></mrow><mo>=</mo><mrow><munderover><mo>∑</mo><mi>j</mi><mrow
    /></munderover><msubsup><mi>δ</mi><mi>j</mi><mfenced open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow></mrow></math>](img/229.png)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfrac><mrow><mo>∂</mo><mi>J</mi></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>i</mi><mfenced
    open="(" close=")"><mi>l</mi></mfenced></msubsup></mrow></mfrac><mo>=</mo><mrow><munderover><mo>∑</mo><mi>j</mi><mrow
    /></munderover><mrow><mfrac><mrow><mo>∂</mo><mi>J</mi></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow></mfrac><mfrac><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>i</mi><mfenced
    open="(" close=")"><mi>l</mi></mfenced></msubsup></mrow></mfrac></mrow></mrow><mo>=</mo><mrow><munderover><mo>∑</mo><mi>j</mi><mrow
    /></munderover><mrow><mfrac><mrow><mo>∂</mo><mi>J</mi></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow></mfrac><mfrac><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><mrow><mo>∂</mo><msubsup><mi>a</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow></mfrac><mfrac><mrow><mo>∂</mo><msubsup><mi>a</mi><mi>j</mi><mfenced
    open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>i</mi><mfenced
    open="(" close=")"><mi>l</mi></mfenced></msubsup></mrow></mfrac></mrow></mrow><mo>=</mo><mrow><munderover><mo>∑</mo><mi>j</mi><mrow
    /></munderover><msubsup><mi>δ</mi><mi>j</mi><mfenced open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow></mrow></math>](img/229.png)'
- en: 'Following this, we can write the following equation:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以写出以下方程：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msubsup><mi>δ</mi><mi>i</mi><mfenced
    open="(" close=")"><mi>l</mi></mfenced></msubsup><mo>=</mo><mfenced open="(" close=")"><mrow><mrow><munderover><mo>∑</mo><mi>j</mi><mrow
    /></munderover><msubsup><mi>δ</mi><mi>j</mi><mfenced open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow></mfenced><mfrac><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>i</mi><mfenced
    open="(" close=")"><mi>l</mi></mfenced></msubsup></mrow><mrow><mo>∂</mo><msubsup><mi>a</mi><mi>i</mi><mfenced
    open="(" close=")"><mi>l</mi></mfenced></msubsup></mrow></mfrac></mrow></mrow></math>](img/230.png)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msubsup><mi>δ</mi><mi>i</mi><mfenced
    open="(" close=")"><mi>l</mi></mfenced></msubsup><mo>=</mo><mfenced open="(" close=")"><mrow><mrow><munderover><mo>∑</mo><mi>j</mi><mrow
    /></munderover><msubsup><mi>δ</mi><mi>j</mi><mfenced open="(" close=")"><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></mfenced></msubsup></mrow><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow></mfenced><mfrac><mrow><mo>∂</mo><msubsup><mi>y</mi><mi>i</mi><mfenced
    open="(" close=")"><mi>l</mi></mfenced></msubsup></mrow><mrow><mo>∂</mo><msubsup><mi>a</mi><mi>i</mi><mfenced
    open="(" close=")"><mi>l</mi></mfenced></msubsup></mrow></mfrac></mrow></mrow></math>](img/230.png)'
- en: These two equations provide us with an alternative view of BP, since there is
    a variation in cost with respect to the activation value. They provide us with
    a way to calculate the variation for any layer *l* once we know the variation
    for the following layer, *l+1*.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方程为我们提供了BP的另一种视角，因为成本随着激活值的变化而变化。它们为我们提供了一种计算任意层* l *变化的方法，只要我们知道下一层* l+1
    *的变化。
- en: '7. We can combine these equations to show the following:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 7. 我们可以将这些方程组合起来显示如下：
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo><mml:mi>J</mml:mi></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/231.png)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo><mml:mi>J</mml:mi></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/231.png)'
- en: '8. The updated rule for the weights of each layer is given by the following
    equation:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 8. 每层权重的更新规则由以下方程给出：
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mi>η</mml:mi><mml:msubsup><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/232.png)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:mi>η</mml:mi><mml:msubsup><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mfenced
    separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msubsup></mml:math>](img/232.png)'
- en: Now that we’re familiar with GD and BP, let’s implement them in Python.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了GD和BP，让我们在Python中实现它们。
- en: A code example of an NN for the XOR function
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XOR函数的NN的代码示例
- en: 'In this section, we’ll create a simple network with one hidden layer, which
    solves the XOR function. Let’s recall that XOR is a linearly inseparable problem,
    hence the need for a hidden layer. The source code will allow you to easily modify
    the number of layers and the number of units per layer, so you can try a number
    of different scenarios. We won’t use any ML libraries. Instead, we’ll implement
    them from scratch, with only the help of `numpy`. We’ll also use `matplotlib`
    to visualize the results:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个具有一个隐藏层的简单网络，该网络解决XOR函数问题。我们回顾一下，XOR是一个线性不可分的问题，因此需要一个隐藏层。源代码将允许你轻松修改层数和每层的单元数，便于你尝试不同的场景。我们将不使用任何机器学习库，而是从零开始实现它们，仅借助`numpy`。我们还将使用`matplotlib`来可视化结果：
- en: 'Let’s start by importing these libraries:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先导入这些库：
- en: '[PRE0]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we will define the activation function and its derivative. In this example,
    we will use `tanh(x)`:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将定义激活函数及其导数。在这个例子中，我们将使用`tanh(x)`：
- en: '[PRE1]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we will start the definition of the `NeuralNetwork` class and its constructor
    (note that all its methods and properties have to be properly indented):'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将开始定义`NeuralNetwork`类及其构造函数（请注意，所有的方法和属性都必须正确缩进）：
- en: '[PRE2]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, `net_arch` is a one-dimensional array containing the number of units for
    each layer. For example `[2, 4, 1]` means an input layer with two units, a hidden
    layer with four units, and an output layer with one unit. Since we are studying
    the XOR function, the input layer will have two units, and the output layer will
    only have one unit. However, the number of hidden units can vary.
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，`net_arch`是一个一维数组，包含每一层的单元数。例如，`[2, 4, 1]`表示输入层有两个单元，隐藏层有四个单元，输出层有一个单元。由于我们正在研究XOR函数，输入层将有两个单元，输出层只有一个单元。然而，隐藏单元的数量可以变化。
- en: To conclude the constructor, we will initialize the network weights with random
    values in the range (-1, 1).
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了结束构造函数，我们将使用范围为(-1, 1)的随机值来初始化网络权重。
- en: 'Now, we need to define the fit function, which will train our network:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要定义`fit`函数，它将训练我们的网络：
- en: '[PRE3]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will start the implementation by concatenating `bias` to the training `data`
    in a new variable, `input_data` (the source code is indented within the method
    definition):'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过将`bias`与训练`data`连接到一个新的变量`input_data`来开始实现（源代码在方法定义内进行了缩进）：
- en: '[PRE4]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, we’ll run the training for a number of `epochs`:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将运行训练若干`epochs`：
- en: '[PRE5]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Within the loop, we’ll visualize the epoch number and the prediction output
    of the NN at the start of each epoch:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环中，我们将在每个epoch开始时可视化epoch编号和神经网络的预测输出：
- en: '[PRE6]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Within the loop, we select a random sample from the training set and propagate
    it forward through the hidden network layers:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环中，我们从训练集随机选择一个样本，并将其通过隐藏网络层进行前向传播：
- en: '[PRE7]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Outside the loop, we will calculate the last layer output and the error:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环外，我们将计算最后一层的输出和误差：
- en: '[PRE8]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we will propagate the error back (backward pass):'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将反向传播误差（反向传播）：
- en: '[PRE9]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we will update the weights based on the errors we just computed. We
    will multiply its output delta and input activation to get the gradient of the
    weight. Then, we will update the weight using the learning rate:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将根据我们刚刚计算的误差更新权重。我们将用输出的delta与输入激活相乘，得到权重的梯度。然后，我们将使用学习率更新权重：
- en: '[PRE10]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This concludes the implementation of the `fit` method.
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就完成了`fit`方法的实现。
- en: 'We’ll now write a `predict` function to check the results, which returns the
    network output for the given input:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将编写一个`predict`函数来检查结果，该函数返回给定输入的网络输出：
- en: '[PRE11]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we’ll write the `plot_decision_regions` method, which plots the hyperplane
    separating the classes (in our case, represented as lines), based on the input
    variables. We will create a two-dimensional grid with one axis for each input
    variable. We will plot the NN predictions for all input value combinations across
    the whole grid. We will take the network output larger than 0.5 to be `true` and
    `false` otherwise (we’ll see the plots at the end of the section):'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将编写`plot_decision_regions`方法，该方法根据输入变量绘制分隔类的超平面（在我们的例子中表示为直线）。我们将创建一个二维网格，每个输入变量对应一个轴。我们将绘制神经网络对整个网格的所有输入值组合的预测结果。我们会将网络输出大于0.5的视为`true`，否则视为`false`（我们将在本节的最后看到这些图）：
- en: '[PRE12]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This concludes the implementation of the `NeuralNetwork` class.
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就完成了`NeuralNetwork`类的实现。
- en: 'Finally, we can run the program with the following code:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用以下代码运行程序：
- en: '[PRE13]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We will build the default network, `nn = NeuralNetwork([2,2,1])`. The first
    and last values (`2` and `1`) represent the input and output layers and cannot
    be modified, but we can add different numbers of hidden layers with different
    numbers of units. For example, `([2,4,3,1])` will represent a three-layer NN,
    with four units in the first hidden layer and three units in the second hidden
    layer.
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将构建默认的网络，`nn = NeuralNetwork([2,2,1])`。第一个和最后一个值（`2`和`1`）代表输入层和输出层，不能修改，但我们可以添加不同数量的隐藏层和不同数量的单元。例如，`([2,4,3,1])`将表示一个三层的神经网络，第一个隐藏层有四个单元，第二个隐藏层有三个单元。
- en: We will use `numpy.random.seed(0)` to ensure that the weight initialization
    is consistent across runs, so we can compare their results. This is a common practice
    when training NNs.
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用`numpy.random.seed(0)`来确保权重初始化在每次运行时的一致性，以便我们能够比较它们的结果。这是在训练神经网络时的常见做法。
- en: Now, we will define the training XOR data and labels in `x` and `y` respectively.
    We will run the training for 10 epochs. Finally, we will plot the result.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将分别在`x`和`y`中定义训练 XOR 数据和标签。我们将训练 10 个周期。最后，我们将绘制结果。
- en: 'In the following diagrams, you can see how the `nn.plot_decision_regions` function
    method plots the hyperplanes, which separate the classes. The circles represent
    the network output for the `(true, true)` and `(false, false)` inputs, while the
    triangles represent the `(true, false)` and `(false, true)` inputs for the XOR
    function. To the left, we can see the hyperplane of an NN with two hidden units,
    and to the right, we can see an NN with four hidden units:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的图示中，你可以看到`nn.plot_decision_regions`函数方法如何绘制超平面，这些超平面将不同的类别分开。圆圈表示`(true,
    true)`和`(false, false)`输入的网络输出，而三角形表示XOR函数的`(true, false)`和`(false, true)`输入。在左边，我们可以看到一个具有两个隐藏单元的神经网络的超平面，而在右边，我们可以看到一个具有四个隐藏单元的神经网络：
- en: '![Figure 2.23 – Left: the hyperplane learned by an NN with two hidden units,
    and right: the hyperplane of an NN with four hidden units](img/B19627_02_23.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.23 – 左：具有两个隐藏单元的神经网络所学习到的超平面，右：具有四个隐藏单元的神经网络的超平面](img/B19627_02_23.jpg)'
- en: 'Figure 2.23 – Left: the hyperplane learned by an NN with two hidden units,
    and right: the hyperplane of an NN with four hidden units'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.23 – 左：具有两个隐藏单元的神经网络所学习到的超平面，右：具有四个隐藏单元的神经网络的超平面
- en: Networks with different architectures can produce different separating regions.
    In the preceding figure, we can see that while the network finds the right solution,
    the curves separating the regions will be different, depending on the chosen architecture.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 具有不同架构的网络可以产生不同的分离区域。在前面的图中，我们可以看到，尽管网络找到了正确的解决方案，但分隔区域的曲线会有所不同，这取决于所选择的架构。
- en: We are now ready to start looking more closely at what deep neural nets are
    and their applications.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备开始更深入地了解深度神经网络及其应用。
- en: Summary
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced NNs in detail, and we mentioned their success
    vis-à-vis other competing algorithms. NNs are comprised of interconnected units,
    where the weights of the connections characterize the strength of the communication
    between different units. We discussed different network architectures, how an
    NN can have many layers, and why inner (hidden) layers are important. We explained
    how information flows from the input to the output by passing from one layer to
    the next, based on weights and the activation function. Finally, we showed how
    to train NNs – that is, how to adjust their weights using GD and BP.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细介绍了神经网络（NNs），并提到了它们相对于其他竞争算法的成功。神经网络由互相连接的单元组成，连接的权重决定了不同单元之间通信的强度。我们讨论了不同的网络架构，神经网络如何拥有多个层次，以及为什么内部（隐藏）层非常重要。我们解释了信息是如何从输入流向输出的，经过每一层的传递，基于权重和激活函数。最后，我们展示了如何训练神经网络——也就是如何通过梯度下降（GD）和反向传播（BP）调整它们的权重。
- en: In the following chapter, we’ll continue discussing deep NNs. We’ll explain
    in particular the meaning of *deep* in deep learning, and that it not only refers
    to the number of hidden layers in a network but to the quality of the learning
    of the network. For this purpose, we’ll show how NNs learn to recognize features
    and compile them as representations of larger objects. We’ll also describe a few
    important deep learning libraries and, finally, provide a concrete example of
    applying NNs to handwritten digit recognition.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将继续讨论深度神经网络（NNs）。我们将特别解释*深度*在深度学习中的含义，这不仅指网络中隐藏层的数量，还指网络学习的质量。为此，我们将展示神经网络如何学习识别特征并将其组合成更大对象的表示。我们还将介绍一些重要的深度学习库，最后提供一个具体的示例，展示如何将神经网络应用于手写数字识别。
