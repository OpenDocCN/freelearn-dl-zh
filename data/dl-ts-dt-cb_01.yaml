- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Getting Started with Time Series
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始时间序列分析
- en: In this chapter, we introduce the main concepts and techniques used in time
    series analysis. The chapter begins by defining time series and explaining why
    the analysis of these datasets is a relevant topic in data science. After that,
    we describe how to load time series data using the `pandas` library. The chapter
    dives into the basic components of a time series, such as trend and seasonality.
    One key concept of time series analysis covered in this chapter is that of stationarity.
    We will explore several methods to assess stationarity using statistical tests.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了时间序列分析中使用的主要概念和技术。本章首先定义时间序列并解释为什么分析这些数据集是数据科学中的一个重要话题。接下来，我们描述了如何使用 `pandas`
    库加载时间序列数据。本章深入探讨了时间序列的基本组成部分，如趋势和季节性。本章涵盖的一个关键概念是平稳性。我们将探讨几种使用统计检验评估平稳性的方法。
- en: 'The following recipes will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: Loading a time series using `pandas`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `pandas` 加载时间序列
- en: Visualizing a time series
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化时间序列
- en: Resampling a time series
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重采样时间序列
- en: Dealing with missing values
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理缺失值
- en: Decomposing a time series
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分解时间序列
- en: Computing autocorrelation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算自相关
- en: Detecting stationarity
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测平稳性
- en: Dealing with heteroskedasticity
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异方差性
- en: Loading and visualizing a multivariate time series
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载并可视化多变量时间序列
- en: Resampling a multivariate time series
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重采样多变量时间序列
- en: Analyzing the correlation among pairs of variables
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析变量对之间的相关性
- en: By the end of this chapter, you will have a solid foundation in the main aspects
    of time series analysis. This includes loading and preprocessing time series data,
    identifying its basic components, decomposing time series, detecting stationarity,
    and expanding this understanding to a multivariate setting. This knowledge will
    serve as a building block for the subsequent chapters.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，您将对时间序列分析的主要方面有一个扎实的基础。这包括加载和预处理时间序列数据、识别其基本组成部分、分解时间序列、检测平稳性，并将这些理解扩展到多变量设置。这些知识将为后续章节打下基础。
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To work through this chapter, you need to have Python 3.9 installed on your
    machine. We will work with the following libraries:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章内容，您需要在计算机上安装 Python 3.9。我们将使用以下库：
- en: '`pandas` (2.1.4)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pandas` (2.1.4)'
- en: '`numpy` (1.26.3)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numpy` (1.26.3)'
- en: '`statsmodels` (0.14.1)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`statsmodels` (0.14.1)'
- en: '`pmdarima` (2.0.4)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pmdarima` (2.0.4)'
- en: '`seaborn` (0.13.2)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seaborn` (0.13.2)'
- en: 'You can install these libraries using `pip`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `pip` 安装这些库：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In our setup, we used `pip` version 23.3.1\. The code for this chapter can
    be found at the following GitHub URL: [https://github.com/PacktPublishing/Deep-Learning-for-Time-Series-Data-Cookbook](https://github.com/PacktPublishing/Deep-Learning-for-Time-Series-Data-Cookbook)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的环境中，我们使用了 `pip` 版本 23.3.1。该章的代码可以在以下 GitHub URL 上找到：[https://github.com/PacktPublishing/Deep-Learning-for-Time-Series-Data-Cookbook](https://github.com/PacktPublishing/Deep-Learning-for-Time-Series-Data-Cookbook)
- en: Loading a time series using pandas
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pandas 加载时间序列
- en: In this first recipe, we start by loading a dataset in a Python session using
    `pandas`. Throughout this book, we’ll work with time series using `pandas` data
    structures. `pandas` is a useful Python package for data analysis and manipulation.
    Univariate time series can be structured as `pandas` Series objects, where the
    values of the series have an associated index or timestamp with a `pandas.Index`
    structure.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一个食谱中，我们首先使用 `pandas` 在 Python 会话中加载数据集。在本书中，我们将使用 `pandas` 数据结构处理时间序列。`pandas`
    是一个用于数据分析和处理的有用 Python 包。一元时间序列可以结构化为 `pandas` Series 对象，其中序列的值具有与 `pandas.Index`
    结构相关联的索引或时间戳。
- en: Getting ready
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will focus on a dataset related to solar radiation that was collected by
    the U.S. Department of Agriculture. The data, which contains information about
    solar radiation (in watts per square meter), spans from October 1, 2007, to October
    1, 2013\. It was collected at an hourly frequency totaling 52,608 observations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于一个与太阳辐射相关的数据集，该数据集由美国农业部收集。该数据包含关于太阳辐射（以每平方米瓦特为单位）的信息，数据跨度从 2007 年 10
    月 1 日到 2013 年 10 月 1 日。数据以每小时为频率，共计 52,608 个观测值。
- en: 'You can download the dataset from the GitHub URL provided in the *Technical
    requirements* section of this chapter. You can also find the original source at
    the following URL: [https://catalog.data.gov/dataset/data-from-weather-snow-and-streamflow-data-from-four-western-juniper-dominated-experimenta-b9e22](https://catalog.data.gov/dataset/data-from-weather-snow-and-streamflow-data-from-four-western-juniper-dominated-experimenta-b9e22).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从本章的*技术要求*部分提供的GitHub URL下载数据集。你也可以在以下URL找到原始数据源：[https://catalog.data.gov/dataset/data-from-weather-snow-and-streamflow-data-from-four-western-juniper-dominated-experimenta-b9e22](https://catalog.data.gov/dataset/data-from-weather-snow-and-streamflow-data-from-four-western-juniper-dominated-experimenta-b9e22)。
- en: How to do it…
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The dataset is a `.csv` file. In `pandas`, we can load a `.csv` file using
    the `pd.read_csv``()` function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 该数据集是一个`.csv`文件。在`pandas`中，我们可以使用`pd.read_csv``()`函数加载`.csv`文件：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding code, note the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，注意以下几点：
- en: First, we import `pandas` using the `import` keyword. Importing this library
    is a necessary step to make its methods available in a Python session.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们使用`import`关键字导入`pandas`。导入这个库是使其方法在Python会话中可用的必要步骤。
- en: The main argument to `pd.read_csv` is the file location. The `parse_dates` argument
    automatically converts the input variables (in this case, `Datetime`) into a datetime
    format. The `index_col` argument sets the index of the data to the `Datetime`
    column.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pd.read_csv`的主要参数是文件位置。`parse_dates`参数会自动将输入变量（在此案例中是`Datetime`）转换为日期时间格式。`index_col`参数将数据的索引设置为`Datetime`列。'
- en: Finally, we subset the `data` object using squared brackets to get the `Incoming
    Solar` column, which contains the information about solar radiation at each time
    step.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们使用方括号对`data`对象进行子集化，以获取`Incoming Solar`列，该列包含每个时间步长的太阳辐射信息。
- en: How it works…
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: The following table shows a sample of the data. Each row represents the level
    of the time series at a particular hour.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了数据的一个样本。每行表示特定小时的时间序列水平。
- en: '| **Datetime** | **Incoming Solar** |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **日期时间** | **入射太阳辐射** |'
- en: '| --- | --- |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 2007-10-01 09:00:00 | 35.4 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 2007-10-01 09:00:00 | 35.4 |'
- en: '| 2007-10-01 10:00:00 | 63.8 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 2007-10-01 10:00:00 | 63.8 |'
- en: '| 2007-10-01 11:00:00 | 99.4 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 2007-10-01 11:00:00 | 99.4 |'
- en: '| 2007-10-01 12:00:00 | 174.5 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 2007-10-01 12:00:00 | 174.5 |'
- en: '| 2007-10-01 13:00:00 | 157.9 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 2007-10-01 13:00:00 | 157.9 |'
- en: '| 2007-10-01 14:00:00 | 345.8 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 2007-10-01 14:00:00 | 345.8 |'
- en: '| 2007-10-01 15:00:00 | 329.8 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 2007-10-01 15:00:00 | 329.8 |'
- en: '| 2007-10-01 16:00:00 | 114.6 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 2007-10-01 16:00:00 | 114.6 |'
- en: '| 2007-10-01 17:00:00 | 29.9 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 2007-10-01 17:00:00 | 29.9 |'
- en: '| 2007-10-01 18:00:00 | 10.9 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 2007-10-01 18:00:00 | 10.9 |'
- en: '| 2007-10-01 19:00:00 | 0.0 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 2007-10-01 19:00:00 | 0.0 |'
- en: 'Table 1.1: Sample of an hourly univariate time series'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.1：每小时单变量时间序列示例
- en: 'The `series` object that contains the time series is a `pandas` Series data
    structure. This structure contains several methods for time series analysis. We
    could also create a Series object by calling `pd.Series` with a dataset and the
    respective time series. The following is an example of this: `pd.Series(data=values,
    index=timestamps)`, where `values` refers to the time series values and `timestamps`
    represents the respective timestamp of each observation.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 包含时间序列的`series`对象是一个`pandas` Series数据结构。该结构包含多个时间序列分析方法。我们也可以通过调用`pd.Series`，并提供数据集和相应的时间序列，来创建Series对象。以下是一个示例：`pd.Series(data=values,
    index=timestamps)`，其中`values`是时间序列的值，`timestamps`表示每个观测的时间戳。
- en: Visualizing a time series
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化时间序列
- en: Now, we have a time series loaded in a Python session. This recipe walks you
    through the process of visualizing a time series in Python. Our goal is to create
    a line plot of the time series data, with the dates on the *x* axis and the value
    of the series on the *y* axis.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将时间序列加载到Python会话中。这个教程将带你完成在Python中可视化时间序列的过程。我们的目标是创建一个时间序列的折线图，图中日期位于*X*轴，系列的值位于*Y*轴。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: There are several data visualization libraries in Python. Visualizing a time
    series is useful to quickly identify patterns such as trends or seasonal effects.
    A graphic is an easy way to understand the dynamics of the data and to spot any
    anomalies within it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中有多个数据可视化库。可视化时间序列有助于快速识别趋势或季节性影响等模式。图形是理解数据动态和发现其中异常的简便方式。
- en: 'In this recipe, we will create a time series plot using two different libraries:
    `pandas` and `seaborn`. `seaborn` is a popular data visualization Python library.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将使用两个不同的库创建时间序列图：`pandas`和`seaborn`。`seaborn`是一个流行的数据可视化Python库。
- en: How to do it…
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: '`pandas` Series objects contain a `plot``()` method for visualizing time series.
    You can use it as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas` Series 对象包含一个用于可视化时间序列的 `plot()` 方法。你可以按如下方式使用它：'
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `plot``()` method is called with two arguments. We use the `figsize` argument
    to change the size of the plot. In this case, we set the width and height of the
    figure to `12` and `6` inches, respectively. Another argument is `title`, which
    we set to `Solar radiation time series`. You can check the `pandas` documentation
    for a complete list of acceptable arguments.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `plot()` 方法并传入两个参数。我们使用 `figsize` 参数来更改图表的大小。在此案例中，我们将图表的宽度和高度分别设置为 `12`
    英寸和 `6` 英寸。另一个参数是 `title`，我们将其设置为 `Solar radiation time series`。你可以查看 `pandas`
    文档，获取完整的参数列表。
- en: 'You use it to plot a time series using `seaborn` as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按如下方式使用 `seaborn` 绘制时间序列图：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code includes the following steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码包括以下步骤：
- en: Import `seaborn` and `matplotlib`, two data visualization libraries.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `seaborn` 和 `matplotlib`，这两个是数据可视化库。
- en: Transform the time series into a `pandas` DataFrame object by calling the `reset_index``()`
    method. This step is required because `seaborn` takes DataFrame objects as the
    main input.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `reset_index()` 方法，将时间序列转换为 `pandas` DataFrame 对象。这个步骤是必须的，因为 `seaborn`
    以 DataFrame 对象作为主要输入。
- en: Configure the figure size using `plt.rcParams` to a width of 12 inches and a
    height of 6 inches.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `plt.rcParams` 配置图形大小，设置宽度为 12 英寸，高度为 6 英寸。
- en: Set the plot theme to `darkgrid` using the `set_theme``()` method.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `set_theme()` 方法将图表主题设置为 `darkgrid`。
- en: 'Use the `lineplot``()` method to build the plot. Besides the input data, it
    takes the name of the column for each of the axes: `Datetime` and `Incoming Solar`
    for the *x* axis and *y* axis, respectively.'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `lineplot()` 方法构建图表。除了输入数据外，它还需要指定每个轴的列名：分别为 *x* 轴的 `Datetime` 和 *y* 轴的 `Incoming
    Solar`。
- en: Configure the plot parameters, namely the *y*-axis label (`ylabel`), *x*-axis
    label (`xlabel`), and `title`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置图表参数，即 *y* 轴标签（`ylabel`）、*x* 轴标签（`xlabel`）和 `title`。
- en: Finally, we use the `show` method to display the plot and `savefig` to store
    it as a `.``png` file.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用 `show` 方法来展示图表，并使用 `savefig` 方法将图表保存为 `.png` 文件。
- en: How it works…
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The following figure shows the plot obtained from the `seaborn` library:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了从 `seaborn` 库获得的图形：
- en: '![Figure 1.1: Time series plot using seaborn](img/B21145_01_001.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1：使用 seaborn 绘制的时间序列图](img/B21145_01_001.jpg)'
- en: 'Figure 1.1: Time series plot using seaborn'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：使用 seaborn 绘制的时间序列图
- en: The example time series shows a strong yearly seasonality, where the average
    level is lower at the start of the year. Apart from some fluctuations and seasonality,
    the long-term average level of the time series remains stable over time.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 示例时间序列显示了强烈的年度季节性，其中年初的平均水平较低。除了部分波动和季节性因素外，时间序列的长期平均水平在时间上保持稳定。
- en: We learned about two ways of creating a time series plot. One uses the `plot``()`
    method that is available in `pandas`, and another one uses `seaborn`, a Python
    library dedicated to data visualization. The first one provides a quick way of
    visualizing your data. But `seaborn` has a more powerful visualization toolkit
    that you can use to create beautiful plots.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了两种创建时间序列图的方法。一种使用 `pandas` 中的 `plot()` 方法，另一种使用 `seaborn`，这是一个专注于数据可视化的
    Python 库。第一种方法提供了一种快速可视化数据的方式。而 `seaborn` 提供了更强大的可视化工具包，能够帮助你创建美观的图表。
- en: There’s more…
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: The type of plot created in this recipe is called a line plot. Both `pandas`
    and `seaborn` can be used to create other types of plots. We encourage you to
    go through the documentation to learn about these.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程中创建的图表类型称为折线图。`pandas` 和 `seaborn` 都可以用来创建其他类型的图表。我们鼓励你阅读文档，了解更多类型的图表。
- en: Resampling a time series
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对时间序列进行重采样
- en: Time series resampling is the process of changing the frequency of a time series,
    for example, from hourly to daily. This task is a common preprocessing step in
    time series analysis and this recipe shows how to do it with `pandas`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列重采样是改变时间序列频率的过程，例如将其从每小时调整为每日。这是时间序列分析中的一个常见预处理步骤，本教程展示了如何使用 `pandas` 完成此任务。
- en: Getting ready
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Changing the frequency of a time series is a common preprocessing step before
    analysis. For example, the time series used in the preceding recipes has an hourly
    granularity. Yet, our goal may be to study daily variations. In such cases, we
    can resample the data into a different period. Resampling is also an effective
    way of handling irregular time series – those that are collected in irregularly
    spaced periods.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 更改时间序列的频率是分析前常见的预处理步骤。例如，前面章节中使用的时间序列具有每小时的粒度。然而，我们的目标可能是研究日常变化。在这种情况下，我们可以将数据重新采样为不同的周期。重新采样也是处理不规则时间序列的有效方法——那些在不规则间隔的时间段内收集的数据。
- en: How to do it…
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何操作的……
- en: 'We’ll go over two different scenarios where resampling a time series may be
    useful: when changing the sampling frequency and when dealing with irregular time
    series.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论重新采样时间序列可能有用的两种不同情况：改变采样频率和处理不规则时间序列。
- en: 'The following code resamples the time series into a daily granularity:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将时间序列重新采样为每日粒度：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The daily granularity is specified with the input `D` to the `resample` () method.
    The values of each corresponding day are summed together using the `sum``()` method.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每日粒度通过输入`D`到`resample()`方法中指定。每天的每个对应值通过`sum()`方法进行求和。
- en: Most time series analysis methods work under the assumption that the time series
    is regular; in other words, it is collected in regularly spaced time intervals
    (for example, every day). But some time series are naturally irregular. For instance,
    the sales of a retail product occur at arbitrary timestamps as customers arrive
    at a store.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时间序列分析方法假设时间序列是规则的；换句话说，它是按照规则的时间间隔（例如每天一次）收集的。但有些时间序列本身是自然不规则的。例如，零售产品的销售发生在任意时间戳，随着顾客进入商店。
- en: 'Let us simulate sale events with the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下代码模拟销售事件：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code creates `1000` sale events from `2023-01-01 09:00` to `2023-04-01`.
    A sample of this series is shown in the following table:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了从`2023-01-01 09:00`到`2023-04-01`的`1000`个销售事件。此序列的示例如下表所示：
- en: '| **ID** | **Timestamp** |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **ID** | **时间戳** |'
- en: '| --- | --- |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | 2023-01-01 15:18:10 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2023-01-01 15:18:10 |'
- en: '| 2 | 2023-01-01 15:28:15 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2023-01-01 15:28:15 |'
- en: '| 3 | 2023-01-01 16:31:57 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 2023-01-01 16:31:57 |'
- en: '| 4 | 2023-01-01 16:52:29 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 2023-01-01 16:52:29 |'
- en: '| 5 | 2023-01-01 23:01:24 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 2023-01-01 23:01:24 |'
- en: '| 6 | 2023-01-01 23:44:39 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 2023-01-01 23:44:39 |'
- en: 'Table 1.2: Sample of an irregular time series'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.2：不规则时间序列示例
- en: 'Irregular time series can be transformed into a regular frequency by resampling.
    In the case of sales, we will count how many sales occurred each day:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 不规则时间序列可以通过重新采样转化为规则频率。在销售数据的情况下，我们将计算每天发生了多少销售：
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, we create a time series of zeros based on the irregular timestamps (`ts_sales`).
    Then, we resample this dataset into a daily frequency (`D`) and use the `count``()`
    method to count how many observations occur each day. The `tot_sales` reconstructed
    time series can be used for other tasks, such as forecasting daily sales.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们基于不规则的时间戳（`ts_sales`）创建一个零值时间序列。然后，我们将此数据集重新采样为每日频率（`D`），并使用`count`方法统计每天发生的观察次数。重建后的`tot_sales`时间序列可以用于其他任务，例如预测每日销售额。
- en: How it works…
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'A sample of the reconstructed time series concerning solar radiation is shown
    in the following table:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 重建后的与太阳辐射相关的时间序列示例如下表所示：
- en: '| **Datetime** | **Incoming Solar** |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| **日期时间** | **入射太阳辐射** |'
- en: '| --- | --- |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 2007-10-01 | 1381.5 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 2007-10-01 | 1381.5 |'
- en: '| 2007-10-02 | 3953.2 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 2007-10-02 | 3953.2 |'
- en: '| 2007-10-03 | 3098.1 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 2007-10-03 | 3098.1 |'
- en: '| 2007-10-04 | 2213.9 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 2007-10-04 | 2213.9 |'
- en: 'Table 1.3: Solar radiation time series after resampling'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.3：重新采样后的太阳辐射时间序列
- en: Resampling is a cornerstone preprocessing step in time series analysis. This
    technique can be used to change a time series into a different granularity or
    to convert an irregular time series into a regular one.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 重新采样是时间序列分析中的一个基础预处理步骤。这项技术可以用来将时间序列转换为不同的粒度，或者将不规则时间序列转换为规则时间序列。
- en: The summary statistic is an important input to consider. In the first case,
    we used `sum` to add the hourly solar radiation values observed each day. In the
    case of the irregular time series, we used the `count``()` method to count how
    many events occurred in each period. Yet, you can use other summary statistics
    according to your needs. For example, using the mean would take the average value
    of each period to resample the time series.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 总结统计量是一个需要考虑的重要输入。在第一个案例中，我们使用`sum`来将每天观察到的小时太阳辐射值加总。在不规则时间序列的情况下，我们使用`count()`方法来计算每个周期内发生了多少事件。不过，您可以根据需求使用其他的总结统计量。例如，使用均值可以取每个周期的平均值来重新采样时间序列。
- en: There’s more…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'We resampled to daily granularity. A list of available options is available
    here: [https://pandas.pydata.org/docs/user_guide/timeseries.html#dateoffset-objects](https://pandas.pydata.org/docs/user_guide/timeseries.html#dateoffset-objects).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将数据重新采样至日粒度。可用选项的列表在此：[https://pandas.pydata.org/docs/user_guide/timeseries.html#dateoffset-objects](https://pandas.pydata.org/docs/user_guide/timeseries.html#dateoffset-objects)。
- en: Dealing with missing values
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理缺失值
- en: In this recipe, we’ll cover how to impute time series missing values. We’ll
    discuss different methods of imputing missing values and the factors to consider
    when choosing a method. We’ll show an example of how to solve this problem using
    `pandas`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将讨论如何对时间序列中的缺失值进行插补。我们将探讨不同的插补方法以及在选择方法时需要考虑的因素。我们还将展示如何使用`pandas`解决这个问题的示例。
- en: Getting ready
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Missing values are an issue that plagues all kinds of data, including time series.
    Observations are often unavailable for various reasons, such as sensor failure
    or annotation errors. In such cases, data imputation can be used to overcome this
    problem. Data imputation works by assigning a value based on some rule, such as
    the mean or some predefined value.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 缺失值是困扰各种数据的问题，包括时间序列。由于传感器故障或标注错误等原因，观察值往往无法获取。在这种情况下，可以使用数据插补来克服这个问题。数据插补是通过根据某些规则（如均值或预定义值）分配一个值来实现的。
- en: How to do it…
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We start by simulating missing data. The following code removes 60% of observations
    from a sample of two years of the solar radiation time series:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从模拟缺失数据开始。以下代码从一组两年的太阳辐射时间序列中移除了60%的观察值：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We leverage the `np.random.choice``()` method from `numpy` to select a random
    sample of the time series. The observations of this sample are changed to a missing
    value (`np.nan`).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用`numpy`中的`np.random.choice()`方法随机选择时间序列中的一部分样本。这些样本的观察值将被更改为缺失值（`np.nan`）。
- en: 'In datasets without temporal order, it is common to impute missing values using
    central statistics such as the mean or median. This can be done as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有时间顺序的数据集中，通常使用中心统计量（如均值或中位数）来插补缺失值。可以按照如下方式进行：
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Time series imputation must take into account the temporal nature of observations.
    This means that the assigned value should follow the dynamics of the series. A
    more common approach in time series is to impute missing data with the last known
    observation. This approach is implemented in the `ffill``()` method:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列插补必须考虑到观察值的时间特性。这意味着所分配的值应该遵循序列的动态。时间序列中更常见的方法是用最后一个已知的观察值来插补缺失数据。这个方法可以通过`ffill()`函数实现：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Another, less common, approach that uses the order of observations is `bfill``()`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种较不常见的方法是利用观察值的顺序，使用`bfill()`函数：
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `bfill``()` method imputes missing data with the next available observation
    in the dataset.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`bfill()`方法使用数据集中下一个可用的观察值来插补缺失数据。'
- en: How it works…
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理…
- en: 'The following figure shows the reconstructed time series after imputation with
    each method:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了使用每种方法插补后的重建时间序列：
- en: '![Figure 1.2: Imputing missing data with different strategies](img/B21145_01_002.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2：使用不同策略插补缺失数据](img/B21145_01_002.jpg)'
- en: 'Figure 1.2: Imputing missing data with different strategies'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2：使用不同策略插补缺失数据
- en: The `mean` imputation approach misses the time series dynamics, while both `ffill`
    and `bfill` lead to a reconstructed time series with similar dynamics as the original
    time series. Usually, `ffill` is preferable because it does not break the temporal
    order of observations, that is, using future information to alter (impute) the
    past.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`mean`插补方法忽略了时间序列的动态，而`ffill`和`bfill`则能保持时间序列与原始序列相似的动态。通常情况下，`ffill`更为优选，因为它不会打乱观察值的时间顺序，即不使用未来的信息来改变（插补）过去的值。'
- en: There’s more…
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: The imputation process can also be carried out using some conditions, such as
    limiting the number of imputed observations. You can learn more about this in
    the documentation pages of these functions, for example, [https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.ffill.html](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.ffill.html).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 插补过程也可以在某些条件下进行，例如限制插补观测值的数量。您可以在这些函数的文档页面中了解更多信息，例如[https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.ffill.html](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.ffill.html)。
- en: Decomposing a time series
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列分解
- en: Time series decomposition is the process of splitting a time series into its
    basic components, such as trend or seasonality. This recipe explores different
    techniques to solve this task and how to choose among them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列分解是将时间序列拆分成其基本组成部分的过程，如趋势或季节性。这个配方探讨了不同的技术来解决这个任务以及如何在它们之间做出选择。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'A time series is composed of three parts – trend, seasonality, and the remainder:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列由三个部分组成——趋势、季节性和残差：
- en: The trend characterizes the long-term change in the level of a time series.
    Trends can be upward (increase in level) or downward (decrease in level), and
    they can also change over time.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 趋势描述了时间序列水平的长期变化。趋势可以是上升（水平增加）或下降（水平减少），并且它们可能随着时间变化。
- en: Seasonality refers to regular variations in fixed periods, such as every day.
    The solar radiation time series plotted in the preceding recipe shows a clear
    yearly seasonality. Solar radiation is higher during summer and lower during winter.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 季节性是指在固定时间周期内的规律性变化，比如每天一次。前面配方中绘制的太阳辐射时间序列显示了明显的年度季节性。夏季太阳辐射较高，冬季较低。
- en: The remainder (also called irregular) of the time series is what is left after
    removing the trend and seasonal components.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间序列的残差（也称为不规则部分）是去除趋势和季节性成分后的剩余部分。
- en: Breaking a time series into its components is useful to understand the underlying
    structure of the data.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将时间序列分解成其组件有助于理解数据的基本结构。
- en: 'We’ll describe the process of time series decomposition with two methods: the
    classical decomposition approach and a method based on local regression. You’ll
    also learn how to extend the latter method to time series with multiple seasonal
    patterns.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过两种方法描述时间序列分解过程：经典分解方法和基于局部回归的方法。你还将学习如何将后者方法扩展到具有多个季节模式的时间序列。
- en: How to do it…
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'There are several approaches for decomposing a time series into its basic parts.
    The simplest method is known as classical decomposition. This approach is implemented
    in the `statsmodels` library and can be used as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以将时间序列分解成其基本部分。最简单的方法被称为经典分解。此方法在`statsmodels`库中实现，可以按如下方式使用：
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Besides the dataset, you need to specify the period and the type of model. For
    a daily time series with a yearly seasonality, the period should be set to `365`,
    which is the number of days in a year. The `model` parameter can be either `additive`
    or `multiplicative`. We’ll go into more detail about this in the next section.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数据集外，您还需要指定周期和模型类型。对于具有年度季节性的日常时间序列，周期应设置为`365`，即一年中的天数。`model`参数可以是`additive`（加法模型）或`multiplicative`（乘法模型）。我们将在下一部分详细讨论。
- en: 'Each component is stored as an attribute of the results in an object:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件都作为结果对象的一个属性存储：
- en: '[PRE12]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Each of these attributes returns a time series with the respective component.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性中的每一个都返回一个包含相应组件的时间序列。
- en: 'Arguably, one of the most popular methods for time series decomposition is
    `statsmodels`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，时间序列分解中最流行的方法之一是`statsmodels`：
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the case of `STL`, you don’t need to specify a model as we did with the classical
    method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`STL`方法，我们不需要像经典方法那样指定模型。
- en: Usually, time series decomposition approaches work under the assumption that
    the dataset contains a single seasonal pattern. Yet, time series collected in
    high sampling frequencies (such as hourly or daily) can contain multiple seasonal
    patterns. For example, an hourly time series can show both regular daily and weekly
    variations.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，时间序列分解方法假设数据集只包含单一的季节模式。然而，以高采样频率（如每小时或每天）收集的时间序列可能包含多个季节模式。例如，每小时的时间序列可能同时显示日常和每周的规律性变化。
- en: 'The `MSTL``()` method (short for `period` argument. An example is shown in
    the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`MSTL`方法（`period`参数的简称）如下代码所示：'
- en: '[PRE14]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code, we passed two periods as input: `7` and `365`. These
    periods attempt to capture weekly and yearly seasonality in a daily time series.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们传递了两个周期作为输入：`7` 和 `365`。这些周期尝试捕捉日常时间序列中的每周和每年季节性。
- en: How it works…
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In a given time step `i`, the value of the time series (`Y`i) can be decomposed
    using an additive model, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的时间步 `i` 中，时间序列的值（`Y`i）可以使用加性模型进行分解，如下所示：
- en: '*Y*i *=* *Trend*i*+Seasonality*i*+Remainder*i'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*Y*i *=* *趋势*i*+季节性*i*+残差*i'
- en: 'This decomposition can also be multiplicative:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分解也可以是乘法性的：
- en: '*Y*i *=* *Trend*i*×Seasonality*i*×Remainder*i'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*Y*i *=* *趋势*i*×季节性*i*×残差*i'
- en: The most appropriate approach, additive or multiplicative, depends on the input
    data. But you can turn a multiplicative decomposition into an additive one by
    transforming the data with the logarithm function. The logarithm stabilizes the
    variance, thus making the series additive regarding its components.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最合适的方法，加性还是乘性，取决于输入数据。但你可以通过对数据应用对数函数，将乘法分解转换为加法分解。对数可以稳定方差，从而使得时间序列的成分在加性方面表现得更加一致。
- en: 'The results of the classical decomposition are shown in the following figure:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 类别分解的结果如下面的图所示：
- en: '![Figure 1.3: Time series components after decomposition with the classical
    method](img/B21145_01_003.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3: 经典方法分解后的时间序列成分](img/B21145_01_003.jpg)'
- en: 'Figure 1.3: Time series components after decomposition with the classical method'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '图 1.3: 经典方法分解后的时间序列成分'
- en: In the classical decomposition, the trend is estimated using a moving average,
    for example, the average of the last 24 hours (for hourly series). Seasonality
    is estimated by averaging the values of each period. `STL` is a more flexible
    method for decomposing a time series. It can handle complex patterns, such as
    irregular trends or outliers. `STL` leverages **LOESS**, which stands for **locally
    weighted scatterplot smoothing**, to extract each component.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典分解中，趋势是通过移动平均估算的，例如，最近24小时的平均值（对于每小时的序列）。季节性是通过对每个周期的值进行平均来估算的。`STL` 是一种更灵活的时间序列分解方法。它能够处理复杂的模式，如不规则的趋势或异常值。`STL`
    利用**LOESS**（局部加权散点平滑法）来提取每个成分。
- en: There’s more…
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Decomposition is usually done for data exploration purposes. But it can also
    be used as a preprocessing step for forecasting. For example, some studies show
    that removing seasonality before training a neural network improves forecasting
    performance.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 分解通常用于数据探索目的。但它也可以作为预测的预处理步骤。例如，一些研究表明，在训练神经网络之前去除季节性成分，可以提高预测性能。
- en: See also
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'You can learn more about this in the following references:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下参考文献了解更多信息：
- en: 'Hewamalage, Hansika, Christoph Bergmeir, and Kasun Bandara. “Recurrent neural
    networks for time series forecasting: Current status and future directions.” *International
    Journal of Forecasting* 37.1 (2021): 388-427.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Hewamalage, Hansika, Christoph Bergmeir, 和 Kasun Bandara. “基于递归神经网络的时间序列预测：现状与未来方向。”
    *国际预测期刊* 37.1 (2021): 388-427.'
- en: 'Hyndman, Rob J., and George Athanasopoulos. *Forecasting: Principles and Practice*.
    OTexts, 2018.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Hyndman, Rob J., 和 George Athanasopoulos. *Forecasting: Principles and Practice*.
    OTexts, 2018.'
- en: Computing autocorrelation
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算自相关
- en: This recipe guides you through the process of computing autocorrelation. Autocorrelation
    is a measure of the correlation between a time series and itself at different
    lags, and it is helpful to understand the structure of time series, specifically,
    to quantify how past values affect the future.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将引导你计算自相关。自相关是衡量时间序列与自身在不同滞后期之间相关性的一种度量，它有助于理解时间序列的结构，特别是量化过去的值如何影响未来。
- en: Getting ready
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Correlation is a statistic that measures the linear relationship between two
    random variables. Autocorrelation extends this notion to time series data. In
    time series, the value observed in a given time step will be similar to the values
    observed before it. The autocorrelation function quantifies the linear relationship
    between a time series and a lagged version of itself. A lagged time series refers
    to a time series that is shifted over a number of periods.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 相关性是衡量两个随机变量之间线性关系的统计量。自相关将这一概念扩展到时间序列数据。在时间序列中，给定时间步观察到的值通常与之前观察到的值相似。自相关函数量化了时间序列与其滞后版本之间的线性关系。滞后时间序列是指经过若干期移位后的时间序列。
- en: How to do it…
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We can compute the autocorrelation function using `statsmodels`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `statsmodels` 计算自相关函数：
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The inputs to the function are a time series and the number of lags to analyze.
    In this case, we compute autocorrelation up to `365` lags, a full year of data.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的输入是一个时间序列和要分析的滞后期数。在这个案例中，我们计算了直到`365`个滞后的自相关，即一整年的数据。
- en: 'We can also use `statsmodels` to compute the partial autocorrelation function.
    This measure extends the autocorrelation by controlling for the correlation of
    the time series at shorter lags:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`statsmodels`库计算偏自相关函数。这个度量通过控制时间序列在较短滞后期的相关性，扩展了自相关：
- en: '[PRE16]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `statsmodels` library also provides functions to plot the results of autocorrelation
    analysis:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`statsmodels`库还提供了绘制自相关分析结果的函数：'
- en: '[PRE17]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The following figure shows the autocorrelation of the daily solar radiation
    time series up to `365` lags.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了每日太阳辐射时间序列的自相关，滞后期数为`365`。
- en: '![Figure 1.4: Autocorrelation scores up to 365 lags. The oscillations indicate
    seasonality](img/B21145_01_004.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4：自相关分数至365个滞后。波动表示季节性](img/B21145_01_004.jpg)'
- en: 'Figure 1.4: Autocorrelation scores up to 365 lags. The oscillations indicate
    seasonality'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：自相关分数至365个滞后。波动表示季节性
- en: The oscillations in this plot are due to the yearly seasonal pattern. The analysis
    of autocorrelation is a useful approach to detecting seasonality.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 该图中的波动是由于年度季节性模式引起的。自相关分析是检测季节性的一种有效方法。
- en: There’s more…
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'The autocorrelation at each seasonal lag is usually large and positive. Besides,
    sometimes autocorrelation decays slowly along the lags, which indicates the presence
    of a trend. You can learn more about this from the following URL: [https://otexts.com/fpp3/components.html](https://otexts.com/fpp3/components.html).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 每个季节性滞后的自相关通常很大且为正。此外，有时自相关沿着滞后期逐渐衰减，这表明存在趋势。你可以通过以下网址了解更多信息：[https://otexts.com/fpp3/components.html](https://otexts.com/fpp3/components.html)。
- en: The partial autocorrelation function is an important tool for identifying the
    order of autoregressive models. The idea is to select the number of lags whose
    partial autocorrelation is significant.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 偏自相关函数是识别自回归模型阶数的重要工具。其基本思路是选择偏自相关显著的滞后期数。
- en: Detecting stationarity
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测平稳性
- en: Stationarity is a central concept in time series analysis and an important assumption
    made by many time series models. This recipe walks you through the process of
    testing a time series for stationarity.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 平稳性是时间序列分析中的一个核心概念，也是许多时间序列模型的重要假设。本文将指导你如何测试一个时间序列的平稳性。
- en: Getting ready
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: A time series is stationary if its statistical properties do not change. It
    does not mean that the series does not change over time, just that the way it
    changes does not itself change over time. This includes the level of the time
    series, which is constant under stationary conditions. Time series patterns such
    as trend or seasonality break stationarity. Therefore, it may help to deal with
    these issues before modeling. As we described in the *Decomposing a time series*
    recipe, there is evidence that removing seasonality improves the forecasts of
    deep learning models.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一个时间序列是平稳的，如果它的统计特性不发生变化。这并不意味着序列随时间不变化，而是指其变化的方式本身不随时间变化。这包括时间序列的水平，在平稳条件下是恒定的。时间序列中的趋势或季节性会破坏平稳性。因此，在建模之前，处理这些问题可能会有所帮助。正如我们在*时间序列分解*一节中描述的那样，移除季节性会改善深度学习模型的预测。
- en: 'We can stabilize the mean level of the time series by differencing. Differencing
    is the process of taking the difference between consecutive observations. This
    process works in two steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过差分来稳定时间序列的均值水平。差分是计算连续观测值之间差异的过程。这个过程分为两步：
- en: Estimate the number of differencing steps required for stationarity.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 估计所需的差分步骤以实现平稳性。
- en: Apply the required number of differencing operations.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用所需的差分操作次数。
- en: How to do it…
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We can estimate the required differencing steps with statistical tests, such
    as the augmented Dickey-Fuller test, or the KPSS test. These are implemented in
    the `ndiffs``()` function, which is available in the `pmdarima` library:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过统计检验来估计所需的差分步骤，比如增强型迪基-富勒检验（Augmented Dickey-Fuller Test）或KPSS检验。这些检验可以通过`ndiffs()`函数在`pmdarima`库中实现：
- en: '[PRE18]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Besides the time series, we pass `test=''adf''` as an input to set the method
    to the augmented Dickey-Fuller test. The output of this function is the number
    of differencing steps, which in this case is `1`. Then, we can differentiate the
    time series using the `diff``()` method:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 除了时间序列，我们还传递了`test='adf'`作为输入，设置方法为增强型Dickey-Fuller检验。该函数的输出是差分步骤的次数，在这个例子中是`1`。然后，我们可以使用`diff()`方法对时间序列进行差分：
- en: '[PRE19]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Differencing can also be applied over seasonal periods. In such cases, seasonal
    differencing involves computing the difference between consecutive observations
    of the same seasonal period:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 差分也可以应用于季节性周期。在这种情况下，季节性差分涉及计算同一季节性周期之间连续观察值的差异：
- en: '[PRE20]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Besides the data and the test (`ch` for Canova-Hansen), we also specify the
    number of periods. In this case, this parameter is set to `365` (number of days
    in a year).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数据和检验（`ch`表示Canova-Hansen检验），我们还指定了周期数。在此案例中，该参数设置为`365`（一年中的天数）。
- en: How it works…
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The differenced time series is shown in the following figure.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了差分后的时间序列。
- en: '![Figure 1.5: Sample of the series of changes between consecutive periods after
    differencing](img/B21145_01_005.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5：差分后连续时期之间变化序列的示例](img/B21145_01_005.jpg)'
- en: 'Figure 1.5: Sample of the series of changes between consecutive periods after
    differencing'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5：差分后连续时期之间变化序列的示例
- en: Differencing works as a preprocessing step. First, the time series is differenced
    until it becomes stationary. Then, a forecasting model is created based on the
    differenced time series. The forecasts provided by the model can be transformed
    to the original scale by reverting the differencing operations.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 差分作为一种预处理步骤。首先，对时间序列进行差分，直到它变为平稳序列。然后，基于差分后的时间序列创建预测模型。通过反向差分操作，可以将模型提供的预测结果转换回原始尺度。
- en: There’s more…
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'In this recipe, we focused on two particular methods for testing stationarity.
    You can check other options in the function documentation: [https://alkaline-ml.com/pmdarima/modules/generated/pmdarima.arima.ndiffs.html](https://alkaline-ml.com/pmdarima/modules/generated/pmdarima.arima.ndiffs.html).'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们重点介绍了两种测试平稳性的方法。你可以在函数文档中查看其他选项：[https://alkaline-ml.com/pmdarima/modules/generated/pmdarima.arima.ndiffs.html](https://alkaline-ml.com/pmdarima/modules/generated/pmdarima.arima.ndiffs.html)。
- en: Dealing with heteroskedasticity
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异方差性
- en: In this recipe, we delve into the variance of time series. The variance of a
    time series is a measure of how spread out the data is and how this dispersion
    evolves over time. You’ll learn how to handle data with a changing variance.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们深入探讨了时间序列的方差。时间序列的方差是衡量数据分布程度以及这种分布如何随时间变化的指标。你将学习如何处理具有变化方差的数据。
- en: Getting ready
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The variance of time series can change over time, which also violates stationarity.
    In such cases, the time series is referred to as heteroskedastic and usually shows
    a long-tailed distribution. This means the data is left- or right-skewed. This
    condition is problematic because it impacts the training of neural networks and
    other models.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列的方差可能会随时间变化，这也违反了平稳性。在这种情况下，时间序列被称为异方差性，通常显示长尾分布。这意味着数据是左偏或右偏的。这种情况是有问题的，因为它会影响神经网络和其他模型的训练。
- en: How to do it…
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: Dealing with non-constant variance is a two-step process. First, we use statistical
    tests to check whether a time series is heteroskedastic. Then, we use transformations
    such as the logarithm to stabilize the variance.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 处理非恒定方差是一个两步过程。首先，我们使用统计检验来检查时间序列是否为异方差性。然后，我们使用如对数变换等方法来稳定方差。
- en: 'We can detect heteroskedasticity using statistical tests such as the White
    test or the Breusch-Pagan test. The following code implements these tests based
    on the `statsmodels` library:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用统计检验方法，如White检验或Breusch-Pagan检验，来检测异方差性。以下代码基于`statsmodels`库实现了这些检验：
- en: '[PRE21]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding code follows these steps:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码按照以下步骤执行：
- en: Import the `statsmodels` modules `ols` and `stats`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`statsmodels`模块`ols`和`stats`。
- en: Create a DataFrame based on the values of the time series and the row they were
    collected at (`1` for the first observation).
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据时间序列的值和数据采集的行号（`1`表示第一次观察）创建一个DataFrame。
- en: Create a linear model that relates the values of the time series with the `time`
    column.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个线性模型，将时间序列的值与`time`列相关联。
- en: Run `het_white` (White) and `het_breuschpagan` (Breusch-Pagan) to apply the
    variance tests.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`het_white`（White）和`het_breuschpagan`（Breusch-Pagan）来应用方差检验。
- en: The output of the tests is a p-value, where the null hypothesis posits that
    the time series has constant variance. So, if the p-value is below the significance
    value, we reject the null hypothesis and assume heteroskedasticity.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的输出是一个p值，其中原假设认为时间序列具有恒定方差。因此，如果p值低于显著性值，我们就拒绝原假设，并假设存在异方差性。
- en: 'The simplest way to deal with non-constant variance is by transforming the
    data using the logarithm. This operation can be implemented as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 处理非恒定方差的最简单方法是使用对数变换数据。该操作可以按如下方式实现：
- en: '[PRE22]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding code is a Python class called `LogTransformation`. It contains
    two methods: `transform``()` and `inverse_transform``()`. The first transforms
    the data using the logarithm and the second reverts that operation.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一个名为`LogTransformation`的Python类。它包含两个方法：`transform``()`和`inverse_transform``()`。第一个方法使用对数变换数据，第二个方法则恢复该操作。
- en: 'We apply the `transform``()` method to the time series as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`transform``()`方法应用于时间序列，方法如下：
- en: '[PRE23]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The log is a particular case of Box-Cox transformation that is available in
    the `scipy` library. You can implement this method as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对数是`scipy`库中可用的Box-Cox变换的特殊情况。你可以按如下方式实现该方法：
- en: '[PRE24]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `stats.boxcox``()` method estimates a transformation parameter, `lmbda`,
    which can be used to revert the operation.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`stats.boxcox``()`方法估算一个变换参数`lmbda`，该参数可以用来恢复该操作。'
- en: How it works…
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The transformations outlined in this recipe stabilize the variance of a time
    series. They also bring the data distribution closer to the `Normal` distribution.
    These transformations are especially useful for neural networks as they help avoid
    saturation areas. In neural networks, saturation occurs when the model becomes
    insensitive to different inputs, thus compromising the training process.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中概述的变换可以稳定时间序列的方差。它们还将数据分布拉近`正态`分布。这些变换对于神经网络特别有用，因为它们有助于避免饱和区。在神经网络中，当模型对不同输入变得不敏感时，就会发生饱和，从而影响训练过程。
- en: There’s more…
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'The Yeo-Johnson power transformation is similar to the Box-Cox transformation
    but allows for negative values in the time series. You can learn more about this
    method with the following link: [https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.yeojohnson.html](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.yeojohnson.html).'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Yeo-Johnson幂变换类似于Box-Cox变换，但它允许时间序列中出现负值。你可以通过以下链接了解更多关于该方法的信息：[https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.yeojohnson.html](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.yeojohnson.html)。
- en: See also
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'You can learn more about the importance of the logarithm transformation in
    the following reference:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下参考文献了解更多关于对数变换的重要性：
- en: 'Bandara, Kasun, Christoph Bergmeir, and Slawek Smyl. “Forecasting across time
    series databases using recurrent neural networks on groups of similar series:
    A clustering approach.” *Expert Systems with Applications* 140 (2020): 112896.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 'Bandara, Kasun, Christoph Bergmeir, 和 Slawek Smyl。“使用群体相似系列的递归神经网络进行跨时间序列数据库的预测：一种聚类方法。”
    *Expert Systems with Applications* 140 (2020): 112896。'
- en: Loading and visualizing a multivariate time series
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和可视化多元时间序列
- en: So far, we’ve learned how to analyze univariate time series. Yet, multivariate
    time series are also relevant in real-world problems. This recipe explores how
    to load a multivariate time series. Before, we used the `pandas` Series structure
    to handle univariate time series. Multivariate time series are better structured
    as `pandas` DataFrame objects.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已学习如何分析单变量时间序列。然而，多元时间序列在现实问题中同样具有重要意义。本节将探讨如何加载多元时间序列。之前，我们使用了`pandas`的Series结构来处理单变量时间序列。而多元时间序列则更适合使用`pandas`的DataFrame对象来处理。
- en: Getting ready
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: A multivariate time series contains multiple variables. The concepts underlying
    time series analysis are extended to cases where multiple variables evolve over
    time and are interrelated with each other. The relationship between the different
    variables can be difficult to model, especially when the number of these variables
    is large.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 多元时间序列包含多个变量。时间序列分析中的基本概念被扩展到多个变量随时间变化并彼此相互关联的情况。不同变量之间的关系可能难以建模，尤其是当这些变量的数量很大时。
- en: In many real-world applications, multiple variables can influence each other
    and exhibit a temporal dependency. For example, in weather modeling, the incoming
    solar radiation is correlated with other meteorological variables, such as air
    temperature or humidity. Considering these variables with a single multivariate
    model can be fundamental for modeling the dynamics of the data and getting better
    predictions.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多实际应用中，多个变量可能相互影响并表现出时间依赖性。例如，在天气建模中，入射太阳辐射与其他气象变量（如空气温度或湿度）相关联。将这些变量纳入单一的多变量模型中，可能对于建模数据的动态行为并获得更好的预测至关重要。
- en: We’ll continue to study the solar radiation dataset. This time series is extended
    by including extra meteorological information.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续研究太阳辐射数据集。这次时间序列通过添加额外的气象信息来扩展。
- en: How to do it…
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'We’ll start by reading a multivariate time series. Like in the *Loading a time
    series using pandas* recipe, we resort to `pandas` and read a `.csv` file into
    a DataFrame data structure:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从读取一个多变量时间序列开始。与 *使用 pandas 加载时间序列* 方法一样，我们依赖 `pandas` 来读取 `.csv` 文件并将其导入
    DataFrame 数据结构：
- en: '[PRE25]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `parse_dates` and `index_col` arguments ensure that the index of the DataFrame
    is a `DatetimeIndex` object. This is important so that `pandas` treats this object
    as a time series. After loading the time series, we can transform and visualize
    it using the `plot``()` method:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse_dates` 和 `index_col` 参数确保 DataFrame 的索引是一个 `DatetimeIndex` 对象。这一点非常重要，因为
    `pandas` 会将这个对象视为时间序列。加载时间序列后，我们可以使用 `plot` `()` 方法对其进行转换和可视化：'
- en: '[PRE26]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding code follows these steps:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码遵循了以下步骤：
- en: First, we transform the data using the logarithm.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用对数变换数据。
- en: We take the last 1,000 observations to make the visualization less cluttered.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们选取最后 1,000 个观察值，以使得可视化图表不显得过于杂乱。
- en: Finally, we use the `plot``()` method to create a visualization. We also call
    `legend` to configure the legend of the plot.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用 `plot` `()` 方法创建可视化图表。我们还调用 `legend` 来配置图表的图例。
- en: How it works…
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'A sample of the multivariate time series is displayed in the following figure:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了一个多变量时间序列的示例：
- en: '![Figure 1.6: Multivariate time series plot](img/B21145_01_006.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6：多变量时间序列图](img/B21145_01_006.jpg)'
- en: 'Figure 1.6: Multivariate time series plot'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6：多变量时间序列图
- en: The process of loading a multivariate time series works like the univariate
    case. The main difference is that a multivariate time series is stored in Python
    as a DataFrame object rather than a Series one.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 加载多变量时间序列的过程与单变量的情况类似。主要的区别是，多变量时间序列在 Python 中是作为 DataFrame 对象存储，而不是 Series
    对象。
- en: From the preceding plot, we can notice that different variables follow different
    distributions and have distinct average and dispersion levels.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图表中，我们可以注意到，不同的变量遵循不同的分布，并且有着不同的平均值和离散程度。
- en: Resampling a multivariate time series
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重采样多变量时间序列
- en: This recipe revisits the topic of resampling but focuses on multivariate time
    series. We’ll explain why resampling can be a bit tricky for multivariate time
    series due to the eventual need to use distinct summary statistics for different
    variables.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 本方法回顾了重采样的主题，但重点讲解了多变量时间序列。我们将解释为什么重采样对多变量时间序列来说可能有点棘手，因为通常需要对不同的变量使用不同的汇总统计量。
- en: Getting ready
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: When resampling a multivariate time, you may need to apply different summary
    statistics depending on the variable. For example, you may want to sum up the
    solar radiation observed at each hour to get a sense of how much power you could
    generate. Yet, taking the average, instead of the sum, is more sensible when summarizing
    wind speed because this variable is not cumulative.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在重采样多变量时间序列时，可能需要根据不同的变量应用不同的汇总统计量。例如，您可能希望将每小时观察到的太阳辐射加总，以估算您能生成多少能量。然而，在总结风速时，取平均值而不是总和更为合理，因为风速变量不是累积的。
- en: How to do it…
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'We can pass a Python dictionary that details which statistic should be applied
    to each variable. Then, we can pass this dictionary to the `agg` `()` method,
    as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以传递一个 Python 字典，详细说明每个变量应应用哪种统计量。然后，我们可以将这个字典传递给 `agg` `()` 方法，如下所示：
- en: '[PRE27]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We aggregate the time series into a daily periodicity using different summary
    statistics. For example, we want to sum up the solar radiation observed each day.
    For the air temperature variable (`Air Temp`), we take the maximum value observed
    each day.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用不同的汇总统计量将时间序列聚合为日周期性。例如，我们想要汇总每天观察到的太阳辐射。对于空气温度变量（`Air Temp`），我们选择每天观察到的最大值。
- en: How it works…
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: By using a dictionary to pass different summary statistics, we can adjust the
    frequency of the time series in a more flexible way. Note that if you wanted to
    apply the mean for all variables, you would not need a dictionary. A simpler way
    would be to run `data.resample('D').mean()`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用字典传递不同的汇总统计量，我们可以以更灵活的方式调整时间序列的频率。请注意，如果你希望对所有变量应用均值，则无需使用字典。更简单的方法是运行`data.resample('D').mean()`。
- en: Analyzing correlation among pairs of variables
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析变量对之间的相关性
- en: This recipe walks you through the process of using correlation to analyze a
    multivariate time series. This task is useful to understand the relationship among
    the different variables in the series and thereby understand its dynamics.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将引导你通过使用相关性分析多变量时间序列的过程。这个任务对于理解系列中不同变量之间的关系，并进一步理解其动态特征非常有用。
- en: Getting ready
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: A common way to analyze the dynamics of multiple variables is by computing the
    correlation of each pair. You can use this information to perform feature selection.
    For example, when pairs of variables are highly correlated, you may want to keep
    only one of them.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 分析多个变量动态的常见方法是计算每对变量的相关性。你可以利用这些信息进行特征选择。例如，当变量对之间高度相关时，你可能只想保留其中一个。
- en: How to do it…
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到……
- en: 'First, we compute the correlation among each pair of variables:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们计算每对变量之间的相关性：
- en: '[PRE28]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can visualize the results using a heatmap from the `seaborn` library:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`seaborn`库的热力图来可视化结果：
- en: '[PRE29]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Heatmaps are a common way of visualizing matrices. We pick a diverging color
    set from `sns.diverging_palette` to distinguish between negative correlation (blue)
    and positive correlation (red).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 热力图是可视化矩阵的常用方式。我们从`sns.diverging_palette`中选择一个渐变色调来区分负相关（蓝色）和正相关（红色）。
- en: How it works…
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'The following figure shows the heatmap with the correlation results:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了带有相关性结果的热力图：
- en: '![Figure 1.7: Correlation matrix for a multivariate time series](img/B21145_01_007.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.7: 多变量时间序列的相关矩阵](img/B21145_01_007.jpg)'
- en: 'Figure 1.7: Correlation matrix for a multivariate time series'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '图 1.7: 多变量时间序列的相关矩阵'
- en: The `corr``()` method computes the correlation among each pair of variables
    in the `data_daily` object. In this case, we use the Pearson correlation with
    the `method='pearson'` argument. Kendall and Spearman are two common alternatives
    to the Pearson correlation.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`corr()`方法计算`data_daily`对象中每对变量之间的相关性。在这个例子中，我们使用的是皮尔逊相关性，并指定`method=''pearson''`参数。Kendall和Spearman是皮尔逊相关性的两种常见替代方法。'
