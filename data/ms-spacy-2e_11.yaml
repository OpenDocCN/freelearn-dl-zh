- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Integrating spaCy with Third-Party Libraries
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 spaCy 与第三方库集成
- en: In this chapter, we’ll explore how to integrate spaCy with third-party libraries,
    focusing on building web applications and APIs for NLP tasks. We will start with
    **Streamlit** , a Python framework that simplifies the creation of web applications
    without needing extensive front-end knowledge. We’ll demonstrate how to create
    a simple **Named Entity Recognition** ( **NER** ) app using Streamlit and **spacy-streamlit**
    . Following this, we’ll dive into **FastAPI** , a modern framework for building
    APIs, known for its speed and use of Python type hints. We’ll learn how to create
    an API that extracts entities from text using a spaCy model, showcasing the ease
    with which you can build NLP-powered services.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何将 spaCy 与第三方库集成，重点关注构建用于 NLP 任务的 Web 应用和 API。我们将从 **Streamlit**
    开始，这是一个简化 Web 应用创建的 Python 框架，无需广泛的前端知识。我们将演示如何使用 Streamlit 和 **spacy-streamlit**
    创建一个简单的 **命名实体识别**（**NER**）应用。在此之后，我们将深入研究 **FastAPI**，这是一个用于构建 API 的现代框架，以其速度和
    Python 类型提示的使用而闻名。我们将学习如何创建一个使用 spaCy 模型从文本中提取实体的 API，展示了构建 NLP 驱动的服务的简便性。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Building spaCy-powered Apps with Streamlit
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Streamlit 构建 spaCy 驱动的应用
- en: Building APIs for NLP models using FastAPI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 FastAPI 为 NLP 模型构建 API
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the data and the code for this Chapter can be found at [https://github.com/PacktPublishing/Mastering-spaCy-Second-Edition](https://github.com/PacktPublishing/Mastering-spaCy-Second-Edition)
    .
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有数据和代码都可以在 [https://github.com/PacktPublishing/Mastering-spaCy-Second-Edition](https://github.com/PacktPublishing/Mastering-spaCy-Second-Edition)
    找到。
- en: Building spaCy-powered Apps with Streamlit
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Streamlit 构建 spaCy 驱动的应用
- en: As data scientists and NLP engineers, the main programming language we use in
    our day-to-day is Python. If you don’t have a background in front-end development
    and have ever tried to build a web application or had to deal with CSS, you know
    how hard and frustrating it can be to work developing applications to work in
    the browser. Streamlit is a framework in Python designed to help us create web
    applications in a simple and fast way using pure Python. It is built on top of
    the **Tornado** Python web server framework ( [https://www.tornadoweb.org/en/stable/index.html](https://www.tornadoweb.org/en/stable/index.html)
    ) and uses **React** in the frontend. Luckily, we don’t need to know how to use
    any of these technologies to create our web apps, since with Streamlit, we can
    create widgets on the page by simply declaring some Python variables. We can also
    smoothly deploy, manage, and share Streamlit Web Apps by using the *community
    cloud* feature ( [https://streamlit.io/cloud](https://streamlit.io/cloud) ). The
    deployment can be done in one click and is free.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 作为数据科学家和 NLP 工程师，我们在日常工作中主要使用的编程语言是 Python。如果你没有前端开发背景，曾经尝试构建 Web 应用或处理过 CSS，你就知道要在浏览器中开发应用程序是多么困难和令人沮丧。Streamlit
    是一个 Python 框架，旨在帮助我们以简单快捷的方式使用纯 Python 创建 Web 应用。它建立在 **Tornado** Python Web 服务器框架之上（[https://www.tornadoweb.org/en/stable/index.html](https://www.tornadoweb.org/en/stable/index.html)），并在前端使用
    **React**。幸运的是，我们不需要了解这些技术的使用方法来创建我们的 Web 应用，因为有了 Streamlit，我们只需声明一些 Python 变量就可以在页面上创建小部件。我们还可以通过使用
    *社区云* 功能（[https://streamlit.io/cloud](https://streamlit.io/cloud)）来平滑地部署、管理和共享
    Streamlit Web 应用。部署只需一键即可完成，并且是免费的。
- en: In this section, we will first learn the basics of Streamlit and then how to
    use the **spacy-streamlit** package to use spaCy visualizations as the building
    blocks of the web apps.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先学习 Streamlit 的基础知识，然后学习如何使用 **spacy-streamlit** 包将 spaCy 可视化作为构建 Web
    应用的基石。
- en: Building NLP apps with spacy-streamlit
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 spacy-streamlit 构建 NLP 应用
- en: To start using Streamlit the first step is to install the library using **pip
    install streamlit** . We create the web applications using a Python script. The
    **streamlit run app.py** command runs a local server on the machine. To check
    whether everything is okay with the installation, let’s run the **streamlit hello**
    command. *Figure 11* *.1* shows this demo page in the browser.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Streamlit，第一步是使用 **pip install streamlit** 安装库。我们使用 Python 脚本创建 Web 应用。**streamlit
    run app.py** 命令在机器上运行本地服务器。为了检查安装是否正常，让我们运行 **streamlit hello** 命令。*图 11* *.1*
    展示了浏览器中的这个演示页面。
- en: '![Figure 11.1 – Streamlit hello page](img/B22441_11_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – Streamlit 欢迎页面](img/B22441_11_01.jpg)'
- en: Figure 11.1 – Streamlit hello page
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – Streamlit 欢迎页面
- en: 'As we were talking about in the introduction section, creating widgets and
    visual components with Streamlit can be done by simply declaring a variable. We
    can also add interactivity to the apps using Streamlit input widgets. The main
    ones are **st.text_input** , **st.button** , and **st.slider** . The library has
    a large list of page elements. Here are some of the main ones and their descriptions:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在引言部分所讨论的，使用Streamlit创建小部件和视觉组件可以通过简单地声明一个变量来完成。我们还可以通过使用Streamlit输入小部件来为应用程序添加交互性。主要的小部件有**st.text_input**、**st.button**和**st.slider**。该库有一个长长的页面元素列表。以下是一些主要元素及其描述：
- en: '**st.write** : This writes the content on the page and automatically detects
    the type of the content to present it properly. If you write **st.write(''hi friends'')**
    , it will display the text; if you provide a dataframe instead of a string, it
    will present the dataframe with the proper formatting.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**st.write**：这将内容写入页面，并自动检测内容的类型以正确呈现。如果您写入**st.write(''hi friends'')**，它将显示文本；如果您提供数据框而不是字符串，它将以适当的格式呈现数据框。'
- en: '**st.title** : This will display the text in the title formatting.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**st.title**：这将显示以标题格式化的文本。'
- en: '**st.markdown** : This will display the text formatted in Markdown.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**st.markdown**：这将显示以Markdown格式化的文本。'
- en: '**st.dataframe** : This will display a dataframe as an interactive table.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**st.dataframe**：这将以交互式表格的形式显示数据框。'
- en: 'The **spacy-streamlit** package provides tools for visualizing spaCy models
    and developing interactive apps. It features various components that you can integrate
    into your own Streamlit applications, including visualizers for syntactic dependencies,
    named entities, text classification, token attributes, and more. Let’s build an
    app to get a glimpse of how Streamlit and **spacy-streamlit** work together. First,
    you need to install the package with **pip install spacy-streamlit** . With the
    library installed, let’s go ahead and build an app to display the entities of
    the model we trained in [*Chapter 8*](B22441_08.xhtml#_idTextAnchor109) :'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**spacy-streamlit**包提供了可视化spaCy模型和开发交互式应用程序的工具。它具有各种组件，可以集成到您自己的Streamlit应用程序中，包括句法依存关系、命名实体、文本分类、标记属性等的可视化器。让我们构建一个应用程序，以了解Streamlit和**spacy-streamlit**是如何协同工作的。首先，您需要使用**pip
    install spacy-streamlit**安装该包。安装了库之后，让我们继续构建一个应用程序来显示我们在[*第8章*](B22441_08.xhtml#_idTextAnchor109)中训练的模型中的实体：'
- en: 'First, we import both packages, **Streamlit** and **spacy_streamlit** :'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入两个包，**Streamlit**和**spacy_streamlit**：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s define a default text to the **st.text_input** component:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为**st.text_input**组件定义一个默认文本：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we define the path to the [*Chapter 8*](B22441_08.xhtml#_idTextAnchor109)
    final model:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们定义[*第8章*](B22441_08.xhtml#_idTextAnchor109)最终模型的路径：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s add a title and the text input. The content of **text_input** will be
    saved on the **text** variable:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个标题和文本输入。**text_input**的内容将被保存在**text**变量中：
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We still have some work to do, but first, let’s see what the app looks like
    with only this code. Save the code to an **app.py** script and run **streamlit
    run app.py** to serve it on our local machine. *Figure 11* *.2* shows what we
    have so far.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些工作要做，但首先，让我们看看只有这段代码时应用程序的样子。将代码保存到**app.py**脚本中，然后运行**streamlit run app.py**以在本地机器上提供服务。*图11.2*展示了我们目前所拥有的内容。
- en: '![Figure 11.2 – The Streamlit app with the text_area component](img/B22441_11_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – 带有text_area组件的Streamlit应用程序](img/B22441_11_02.jpg)'
- en: Figure 11.2 – The Streamlit app with the text_area component
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 带有text_area组件的Streamlit应用程序
- en: 'When building apps with Streamlit, every time the user interacts with an input
    widget, the library *reruns the entire Python script from top to bottom* . Our
    app needs to load the model before processing the text, so this could mean that
    every time a user types another text in the **st.text_area** widget, they would
    have to wait for the model to load again. To handle this, Streamlit has the cache
    feature ( [https://docs.streamlit.io/get-started/fundamentals/advanced-concepts#caching](https://docs.streamlit.io/get-started/fundamentals/advanced-concepts#caching)
    ) and **spacy-streamlit** implements the **process_text()** method. It caches
    loaded models and creates **Doc** objects. Let’s use the method to process the
    text of our app, continuing the list we’ve started:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Streamlit 构建应用时，每次用户与输入小部件交互时，库都会从顶部到底部重新运行整个 Python 脚本。我们的应用需要在处理文本之前加载模型，这意味着每次用户在
    **st.text_area** 小部件中输入另一个文本时，他们可能需要等待模型再次加载。为了处理这种情况，Streamlit 有缓存功能（[https://docs.streamlit.io/get-started/fundamentals/advanced-concepts#caching](https://docs.streamlit.io/get-started/fundamentals/advanced-concepts#caching)）和
    **spacy-streamlit** 实现了 **process_text()** 方法。它缓存加载的模型并创建 **Doc** 对象。让我们使用该方法来处理我们应用中的文本，继续我们开始的列表：
- en: 'The **process_text ()** method expects the path to the model and the text that
    will be processed:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**process_text ()** 方法期望模型路径和将要处理的文本：'
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, to display the entities, we will use the **visualize_ner()** function:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了显示实体，我们将使用 **visualize_ner()** 函数：
- en: '[PRE5]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Figure 11* *.3* shows the final app.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11* *.3* 显示了最终的应用。'
- en: '![Figure 11.3 – NER app built with Streamlit](img/B22441_11_03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 使用 Streamlit 构建的 NER 应用](img/B22441_11_03.jpg)'
- en: Figure 11.3 – NER app built with Streamlit
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 使用 Streamlit 构建的 NER 应用
- en: 'We want to add a button so the users can type their own text and see the entities.
    Since Streamlit re-runs all the script code every time we interact with a widget,
    we cannot use the **st.button** widget. What we’ll do is use the **st.form** widget,
    which sends all widget values inside the form to Streamlit in a batch. We will
    use the **with** context manager to create the form. Let’s do it:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想添加一个按钮，让用户可以输入自己的文本并查看实体。由于每次我们与小部件交互时，Streamlit 都会重新运行所有脚本代码，所以我们不能使用 **st.button**
    小部件。我们将使用 **st.form** 小部件，它将表单内的所有小部件值批量发送到 Streamlit。我们将使用 **with** 上下文管理器来创建表单。让我们试试：
- en: 'We will put all the elements that should be reloaded inside the form context
    manager. So, when the user presses the submit button, we will process the doc
    and display it using the visualizer:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把所有应该重新加载的元素放入表单上下文管理器中。因此，当用户按下提交按钮时，我们将处理文档并使用可视化器显示它：
- en: '[PRE6]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Figure 11* *.4* shows the app, now with the **Submit** button.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11* *.4* 显示了应用，现在有了 **提交** 按钮。'
- en: '![Figure 11.4 – Streamlit app with form and Submit button](img/B22441_11_04.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – 带有表单和提交按钮的 Streamlit 应用](img/B22441_11_04.jpg)'
- en: Figure 11.4 – Streamlit app with form and Submit button
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 带有表单和提交按钮的 Streamlit 应用
- en: 'The next list has the full code of the web app:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个列表包含了网络应用的完整代码：
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We were able to build a beautiful NLP app with just some lines of code by using
    both the **streamlit** and **spacy-streamlit** libraries. Other **spacy-streamlit**
    visualizers are **visualize_parser()** , **visualize_spans()** , **visualize_textcat()**
    , **visualize_similarity()** , and **visualize_tokens()** .
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 **streamlit** 和 **spacy-streamlit** 库，我们仅用几行代码就能构建一个漂亮的 NLP 应用。其他 **spacy-streamlit**
    可视化器包括 **visualize_parser()**、**visualize_spans()**、**visualize_textcat()**、**visualize_similarity()**
    和 **visualize_tokens()**。
- en: 'Sometimes, we need to build APIs for our NLP projects instead of interactive
    web applications. For this scenario, we can use another cool library: **FastAPI**
    . Let’s learn more about it in the next section.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要为我们的 NLP 项目构建 API 而不是交互式网络应用。对于这种情况，我们可以使用另一个酷炫的库：**FastAPI**。让我们在下一节中了解更多关于它的信息。
- en: Building APIs for NLP models using FastAPI
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 FastAPI 构建 NLP 模型的 API
- en: '**FastAPI** is a Python web framework for building APIs. It’s built on top
    of another two Python libraries, **Starlette** and **Pydantic** , making it one
    of the fastest Python frameworks available. FastAPI is based on standard Python
    type hints. With type hinting, we can specify the expected type of a variable,
    function parameter, or return value. This feature helps us catch bugs earlier
    in the development process, so let’s learn how to use type hints before heading
    to FastAPI usage.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**FastAPI** 是一个用于构建 API 的 Python 网络框架。它建立在另外两个 Python 库 **Starlette** 和 **Pydantic**
    之上，使其成为可用的最快 Python 框架之一。FastAPI 基于标准的 Python 类型提示。通过类型提示，我们可以指定变量、函数参数或返回值的预期类型。这个特性帮助我们更早地捕捉到开发过程中的错误，所以在我们学习如何使用类型提示之前，让我们先了解如何使用它。'
- en: Python type hinting 101
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python类型提示101
- en: 'Python is a dynamically typed language, meaning it performs the type checks
    of the variables at runtime. For example, if we run this code, it does not throw
    any errors:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种动态类型语言，这意味着它在运行时执行变量的类型检查。例如，如果我们运行此代码，它不会抛出任何错误：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This runs smoothly because the Python interpreter handles the transition of
    **string_or_int** from **String** to **int** . This can lead to bugs because of
    silent errors. **Type hinting** provides a way to specify the expected types in
    our code, so it reduces our chances of creating bugs. Let’s see an example of
    a simple function without it first:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这运行得顺利，因为Python解释器处理了**string_or_int**从**String**到**int**的转换。这可能导致由于静默错误而出现的bug。**类型提示**提供了一种在代码中指定预期类型的方法，因此它减少了我们创建bug的机会。让我们先看看一个没有类型提示的简单函数的例子：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Imagine this function is in a code base and you just import it to use in your
    code. There is no way to see what the writer of the function was expecting as
    the type of the **name** parameter and no information about the return type. To
    get this information, we need to read to check the code of the function. The situation
    changes if we use type hints:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这个函数在一个代码库中，你只是导入它来在你的代码中使用。没有办法看到函数的作者期望**name**参数的类型，也没有关于返回类型的信息。为了获取这些信息，我们需要阅读并检查函数的代码。如果我们使用类型提示，情况就会改变：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now with these type hints, your code editor can help you and show the types.
    *Figure 11* *.5* shows what happens in *Visual Studio Code* , for example.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这些类型提示可以帮助你的代码编辑器，并显示类型。*图11.5*显示了例如在*Visual Studio Code*中会发生什么。
- en: '![Figure 11.5 – Type hinting in Visual Studio Code](img/B22441_11_05.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图11.5 – Visual Studio Code中的类型提示](img/B22441_11_05.jpg)'
- en: Figure 11.5 – Type hinting in Visual Studio Code
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 – Visual Studio Code中的类型提示
- en: FastAPI uses type hints to offer type checks, leading to fewer bugs and developer-induced
    errors. Now that we know what type hinting is, let’s create an API for our spaCy
    model using FastAPI.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI使用类型提示提供类型检查，导致bug和开发者引起的错误更少。现在我们知道了类型提示是什么，让我们使用FastAPI为我们的spaCy模型创建一个API。
- en: Creating an API for the spaCy model with FastAPI
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用FastAPI为spaCy模型创建API
- en: The two main HTTP methods we use to build APIs are **GET** and **POST** . **GET**
    is used when the request does not change any state and **POST** is usually used
    when the action can alter the state (add an element to the dataset, edit a value,
    etc.). In other words, **GET** is used to *read data* and **POST** is used to
    *create data* . When using the **GET** requests, we pass the parameters in the
    URL address. With **POST** requests, we can pass the parameters in the request
    body. FastAPI allows us to choose which request type we want by using the methods
    with the **@app.get()** or **@app.post()** Python decorators.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建API时使用的两个主要HTTP方法是**GET**和**POST**。**GET**用于请求不改变任何状态时，**POST**通常用于动作可以改变状态（向数据集添加元素、编辑值等）时。换句话说，**GET**用于*读取数据*，**POST**用于*创建数据*。在使用**GET**请求时，我们在URL地址中传递参数。在使用**POST**请求时，我们可以在请求体中传递参数。FastAPI允许我们通过使用带有**@app.get()**或**@app.post()**
    Python装饰器的函数来选择我们想要的请求类型。
- en: 'Let’s create an API with the **GET** method that returns a **json** object.
    First, you need to install FastAPI with the **pip install fastapi[standard]**
    command. Now create a **main.py** file with these commands:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用**GET**方法创建一个返回**json**对象的API。首先，你需要使用**pip install fastapi[standard]**命令安装FastAPI。现在创建一个包含以下命令的**main.py**文件：
- en: 'First, import the library and create the **app** object:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入库并创建**app**对象：
- en: '[PRE11]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now let’s create the **GET** method. We will add the **@app.get("/")** decorator.
    The **"/"** means the URL path to call this method will be the root of our site:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建**GET**方法。我们将添加**@app.get("/")**装饰器。**"/"**表示调用此方法的URL路径将是我们的网站的根路径：
- en: '[PRE12]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To run the server locally go to the command line and type **fastapi dev** **main.py**
    . *Figure 11* *.6* shows what you should see if you open your browser and go to
    the **http://127.0.0.1:8000/** URL.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在本地运行服务器，请转到命令行并输入**fastapi dev main.py**。*图11.6*显示了如果你打开浏览器并访问**http://127.0.0.1:8000/**
    URL时应该看到的内容。
- en: '![Figure 11.6 – The response of the GET endpoint](img/B22441_11_06.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图11.6 – GET端点的响应](img/B22441_11_06.jpg)'
- en: Figure 11.6 – The response of the GET endpoint
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 – GET端点的响应
- en: One of the nice things about FastAPI is that it creates docs for the APIs automatically.
    By default, it uses **Swagger UI** ( [https://github.com/swagger-api/swagger-ui](https://github.com/swagger-api/swagger-ui)
    ). Go to **http://127.0.0.1:8000/docs** to check it out. *Figure 11* *.7* shows
    the documentation docs of our FastAPI .
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FastAPI的一个优点是它自动为API创建文档。默认情况下，它使用**Swagger UI** ([https://github.com/swagger-api/swagger-ui](https://github.com/swagger-api/swagger-ui))。前往**http://127.0.0.1:8000/docs**查看。*图11*
    *.7*显示了我们的FastAPI的文档文档。
- en: '![Figure 11.7 – The documentation of our API created automatically by FastAPI](img/B22441_11_07.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图11.7 – 由FastAPI自动创建的我们的API文档](img/B22441_11_07.jpg)'
- en: Figure 11.7 – The documentation of our API created automatically by FastAPI
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 – 由FastAPI自动创建的我们的API文档
- en: 'We will create an API in the same style we’ve used to create the Streamlit
    web app. The API should receive a list of texts and return a JSON response with
    the entities. Here is an example of a request:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个API，其风格与我们创建Streamlit网络应用时使用的风格相同。该API应接收一个文本列表，并返回一个包含实体的JSON响应。以下是一个请求示例：
- en: '[PRE13]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The response of the API for this request should be as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此请求，API的响应应该是以下内容：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'FastAPI uses the **Pydantic** models to validate the data and build the API
    documentation. Let’s create some Pydantic models to specify the **POST** request
    of our API. We do that by creating Python classes that are inherited from Pydantic’s
    **BaseModel** class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI使用**Pydantic**模型来验证数据并构建API文档。让我们创建一些Pydantic模型来指定我们的API的**POST**请求。我们通过创建继承自Pydantic的**BaseModel**类的Python类来实现这一点：
- en: 'To extract the entities, the API will need to know the record identifier and
    the text, so let’s create a class for it:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了提取实体，API需要知道记录标识符和文本，因此让我们为它创建一个类：
- en: '[PRE15]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The API can work with a batch of texts, so the body parameter of the request
    can have many items. Let’s create this class:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API可以处理文本批次，因此请求的正文参数可以包含多个项目。让我们创建这个类：
- en: '[PRE16]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now it’s time to use spaCy to extract the entities to generate the response.
    We will create a class very similar to the one used in this Cookiecutter by Microsoft:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候使用spaCy提取实体以生成响应了。我们将创建一个与Microsoft的此Cookiecutter中使用的类非常相似的类：
- en: '[https://github.com/microsoft/cookiecutter-spacy-fastapi](https://github.com/microsoft/cookiecutter-spacy-fastapi)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/microsoft/cookiecutter-spacy-fastapi](https://github.com/microsoft/cookiecutter-spacy-fastapi)'
- en: 'Let’s do it:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'We should initiate the **EntityExtractor** class providing an **nlp** model
    and the key values for the record identifier and the record text:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该初始化**EntityExtractor**类，提供一个**nlp**模型以及记录标识符和记录文本的关键值：
- en: '[PRE17]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now let’s create the method to extract the entities. The method will loop through
    the docs created by **nlp.pipe()** and create a list with the entities’ names,
    labels, and start and end characters for the entity in the text:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建一个提取实体的方法。该方法将遍历由**nlp.pipe()**创建的文档，并为文本中的实体创建一个包含实体名称、标签以及实体起始和结束字符的列表：
- en: '[PRE18]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To test whether this code is working, let’s save it to an **extractor.py**
    script and import the class like this:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试此代码是否正常工作，让我们将其保存到**extractor.py**脚本中，并按如下方式导入类：
- en: '[PRE19]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We’re using the model trained in [*Chapter 8*](B22441_08.xhtml#_idTextAnchor109)
    to extract the entities. The response should this dictionary with the entity’s
    names, labels, and matches:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用在[*第8章*](B22441_08.xhtml#_idTextAnchor109)中训练的模型来提取实体。响应应该是包含实体名称、标签和匹配项的字典：
- en: '[PRE20]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now we are ready to finish our API. The **/entities** path will be the **POST**
    endpoint to send the texts for extraction. Let’s get back to the FastAPI code
    to create this method.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好完成我们的API。**/entities**路径将是发送文本进行提取的**POST**端点。让我们回到FastAPI代码中创建此方法。
- en: 'The **POST** request is defined using the **@app.post()** decorator. First,
    we will need to parse the received data to a list of dictionaries with the **record_id**
    and **text** keys:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**POST**请求使用**@app.post()**装饰器定义。首先，我们需要将接收到的数据解析为具有**record_id**和**text**键的字典列表：'
- en: '[PRE21]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we will call the **EntityExtractor** class, send the docs, and return the
    entities:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将调用**EntityExtractor**类，发送文档，并返回实体：
- en: '[PRE22]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you add this code to the **main.py** file, run **fastapi run main.py** in
    the terminal, and go to the **/docs** URL, you should now see the **POST /entities**
    endpoint specification.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您将此代码添加到**main.py**文件中，然后在终端中运行**fastapi run main.py**，并访问**/docs** URL，您现在应该能看到**POST
    /entities**端点规范。
- en: Another cool thing about Swagger UI is that we can test the endpoint directly
    in the browser. Click on the **POST /entities** down arrow button and then the
    **Try it out** button on the right. Now you can paste our example request and
    click on the blue **Execute** button. *Figure 11* *.8* shows the **POST /entities**
    arrow button.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于 Swagger UI 的另一个酷点是，我们可以在浏览器中直接测试端点。点击 **POST /entities** 向下的箭头按钮，然后点击右侧的
    **Try it out** 按钮。现在你可以粘贴我们的示例请求，然后点击蓝色的 **Execute** 按钮。*图 11.8* 显示了 **POST /entities**
    的箭头按钮。
- en: '![Figure 11.8 – The button to send data to the entities endpoint](img/B22441_11_08.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.8 – 发送数据到实体端点的按钮](img/B22441_11_08.jpg)'
- en: Figure 11.8 – The button to send data to the entities endpoint
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 – 发送数据到实体端点的按钮
- en: 'The next list has the full code of our API:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表包含了我们 API 的完整代码：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It’s pretty cool to get all these functionalities with just some lines of code,
    right? This is just the basics of how to use FastAPI. You can check a lot of more
    advanced stuff in the library’s documentation at [https://fastapi.tiangolo.com/learn/](https://fastapi.tiangolo.com/learn/)
    .
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 只用几行代码就能获得所有这些功能，这真是太酷了，对吧？这仅仅是使用 FastAPI 的基础知识。你可以在库的文档中查看更多高级内容，请访问 [https://fastapi.tiangolo.com/learn/](https://fastapi.tiangolo.com/learn/)。
- en: Summary
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter introduced two powerful tools for integrating spaCy with third-party
    libraries: Streamlit for building interactive web applications and FastAPI for
    creating fast, type-safe APIs. We demonstrated how to build an NER web app using
    Streamlit and the spacy-streamlit package, leveraging Streamlit’s simplicity and
    interactivity. We then transitioned to building an API with FastAPI, emphasizing
    the importance of type hints in reducing bugs and improving code reliability.
    By combining spaCy with these frameworks, you learned that you could create effective,
    user-friendly NLP applications and services with minimal effort.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了将 spaCy 与第三方库集成的两个强大工具：用于构建交互式网络应用的 Streamlit 和用于创建快速、类型安全的 API 的 FastAPI。我们展示了如何使用
    Streamlit 和 spacy-streamlit 包构建一个 NER 网络应用，利用 Streamlit 的简洁性和交互性。然后我们转向使用 FastAPI
    构建API，强调类型提示在减少错误和提高代码可靠性方面的重要性。通过将 spaCy 与这些框架结合，你了解到你可以以最小的努力创建有效的、用户友好的 NLP
    应用和服务。
- en: With this last chapter, we close out the book. It was quite a journey! I hope
    you’ve gained some ground knowledge of the main spaCy’s functionalities, but most
    importantly, I hope you can now create solutions with spaCy that follow some of
    the main software engineering principles for writing good code. I can’t wait to
    see what you’ll build next!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章的最后，我们结束了这本书。这是一段相当精彩的旅程！我希望你已经对 spaCy 的主要功能有了基本的了解，但更重要的是，我希望你现在能够使用 spaCy
    创建遵循一些主要软件工程原则编写良好代码的解决方案。我迫不及待地想看看你接下来会构建什么！
