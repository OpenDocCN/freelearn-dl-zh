- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: 'Expanding the LLM Toolkit for Coders: Beyond LLMs'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展编码者的LLM工具包：超越LLM
- en: In the rapidly changing world of software development, LLMs, such as OpenAI’s
    GPT series and OpenAI o1, Google’s Gemini, and Meta’s Llama 3 have garnered significant
    attention for their ability to assist with coding tasks. However, while LLMs are
    powerful tools, they are not the only game in town. There exists a plethora of
    non-LLM AI tools designed to complement the coding process, enhancing productivity
    and efficiency. This chapter explores these tools, discussing their capabilities,
    limitations, and how they can be integrated into a comprehensive coding toolkit.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发这个快速变化的领域，像OpenAI的GPT系列和OpenAI o1、Google的Gemini以及Meta的Llama 3等LLM，因其在编码任务中的辅助能力而受到了广泛关注。然而，尽管LLM是强大的工具，但它们并不是唯一的选择。还有许多非LLM
    AI工具，旨在补充编码过程，提升生产力和效率。本章将探讨这些工具，讨论它们的能力、局限性，以及如何将它们集成到全面的编码工具包中。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含以下主题：
- en: Code completion and generation tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码补全和生成工具
- en: '**Static code analysis** ( **SCA** ) and code review tools'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态代码分析**（**SCA**）和代码审查工具'
- en: Testing and debugging tools
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和调试工具
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you’ll need the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所需的工具：
- en: Access to a browser to get these AI code tools.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问浏览器以获取这些AI代码工具。
- en: A laptop or desktop to install the software.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台可安装软件的笔记本电脑或台式机。
- en: An **integrated development environment** ( **IDE** ) for Python, such as Visual
    Studio, Spyder, IDLE, PyCharm, or Atom.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于Python的**集成开发环境**（**IDE**），如Visual Studio、Spyder、IDLE、PyCharm或Atom。
- en: 'An IDE for Javascript, such as Visual Studio, Atom, or Brackets. An online
    interpreter will not be good enough here. Here are some examples:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一款用于Javascript的IDE，如Visual Studio、Atom或Brackets。在线解释器在这里不够用。以下是一些示例：
- en: '[https://onecompiler.com/javascript](https://onecompiler.com/javascript)'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://onecompiler.com/javascript](https://onecompiler.com/javascript)'
- en: '[https://jipsen.github.io/js.html](https://jipsen.github.io/js.html)'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://jipsen.github.io/js.html](https://jipsen.github.io/js.html)'
- en: A Java IDE, such as IntelliJ IDEA, Eclipse, or NetBeans.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一款Java集成开发环境（IDE），如IntelliJ IDEA、Eclipse或NetBeans。
- en: Some code examples require bash (basic shell) for Unix **operating** **systems**
    ( **OSs** ).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些代码示例需要在Unix **操作系统**（**OSs**）上使用bash（基础shell）。
- en: 'Get the code in this chapter here: [https://github.com/PacktPublishing/Coding-with-ChatGPT-and-other-LLMs/tree/main/Chapter10](https://github.com/PacktPublishing/Coding-with-ChatGPT-and-other-LLMs/tree/main/Chapter10)
    .'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取本章的代码，请点击这里：[https://github.com/PacktPublishing/Coding-with-ChatGPT-and-other-LLMs/tree/main/Chapter10](https://github.com/PacktPublishing/Coding-with-ChatGPT-and-other-LLMs/tree/main/Chapter10)。
- en: Now, let’s learn how to use non-LLM tools to make code generation, analysis,
    and testing much easier.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何使用非LLM工具使代码生成、分析和测试变得更加简单。
- en: Code completion and generation tools
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码补全和生成工具
- en: Code completion and generation tools are designed to assist developers in writing
    code more efficiently. These tools leverage various techniques, including syntax
    analysis, semantic understanding, and **machine learning** ( **ML** ) algorithms,
    to predict and suggest code snippets as developers type. The usefulness of these
    tools can’t be overstated, as they streamline the coding process, reduce errors,
    and enhance overall productivity. In this section, we will explore several code
    completion and generation tools, their features, and practical examples to give
    you a good understanding of how they can be integrated into your coding workflow.
    Let’s explore some of the most popular tools available, including Eclipse’s Content
    Assist, PyCharm’s code completion tool, NetBeans’ code completion tool, and **Visual
    Studio Code’s** ( **VS** **Code’s** ) IntelliSense.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 代码补全和生成工具旨在帮助开发人员更高效地编写代码。这些工具利用各种技术，包括语法分析、语义理解和**机器学习**（**ML**）算法，在开发人员输入代码时预测并建议代码片段。这些工具的实用性不容小觑，因为它们能简化编码过程，减少错误，并提升整体生产力。在本节中，我们将探讨几款代码补全和生成工具，介绍它们的特点和实际应用示例，帮助你更好地理解它们如何融入到你的编码工作流程中。让我们来看看一些最受欢迎的工具，包括Eclipse的内容辅助、PyCharm的代码补全工具、NetBeans的代码补全工具以及**Visual
    Studio Code**（**VS Code**）的IntelliSense。
- en: Overall, these tools help the developer improve code accuracy, speed up development,
    learn new syntax and APIs, and make code more readable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，这些工具帮助开发人员提高代码准确性，加快开发速度，学习新语法和API，并使代码更具可读性。
- en: Eclipse’s Content Assist
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Eclipse的内容辅助
- en: Eclipse, a versatile IDE, features a robust code completion plugin tool known
    as **Content Assist** . This tool enhances developer productivity by providing
    relevant suggestions as you type and analyzing the current context scope and prefix
    of your code to offer keywords, methods, variables, and more. This not only speeds
    up coding but also reduces errors.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse 是一款多功能的 IDE，具有强大的代码补全插件工具 **内容助手**。该工具通过提供相关建议来提高开发者的工作效率，建议会基于你输入的内容，分析代码的当前上下文和前缀，提供关键字、方法、变量等。这不仅加快了编码速度，还减少了错误。
- en: One of Content Assist’s standout features is its seamless integration into the
    Eclipse IDE, requiring no additional installation. This built-in nature means
    developers can immediately benefit from its code completion capabilities without
    extra setup. The convenience of having such a tool readily available makes development
    life much easier.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 内容助手的一个显著特点是其与 Eclipse IDE 的无缝集成，无需额外安装。内置的特性意味着开发者可以立即受益于它的代码补全能力，无需额外的设置。拥有这样一个随时可用的工具使开发工作变得更加轻松。
- en: Content Assist is highly customizable, allowing users to tailor suggestions
    to their specific needs. Developers can configure the types of suggestions they
    want, such as method names, variable names, or entire code snippets. You can filter
    the suggestions for relevance, type, or accessibility. Also, users can adjust
    trigger settings, deciding whether Content Assist should activate automatically
    or manually. This flexibility ensures the tool adapts to various coding styles
    and preferences.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 内容助手具有高度的可定制性，允许用户根据自己的特定需求定制建议。开发者可以配置他们想要的建议类型，比如方法名称、变量名称或整个代码片段。你可以根据相关性、类型或可访问性来过滤建议。此外，用户还可以调整触发设置，决定内容助手是自动激活还是手动激活。这种灵活性确保了该工具能够适应不同的编码风格和偏好。
- en: 'Suggestions are based on the letters you’ve just entered; a list of suggestions
    and relevance appears in this order:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 建议是基于你刚输入的字母，建议列表会按照以下顺序出现并显示相关性：
- en: Fields
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段
- en: Variables
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量
- en: Methods
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法
- en: Functions
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Classes
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Structs
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体
- en: Unions
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联合体
- en: Namespaces
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: Enumerations
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: 'You can trigger the code completion by hitting *Ctrl* + the space bar, but
    this is customizable, and it also triggers when you type any of the following:
    “ **."** , “ **->"** , or “ **::"** .'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过按 *Ctrl* + 空格键来触发代码补全，但这一设置是可定制的，当你输入以下内容时，也会触发代码补全：“ **."** ”，“ **->"**
    ”或“ **::"** 。
- en: You can make templates for code you write often; if you enter *Ctrl* + the space
    bar, a list of your templates will appear, depending on scope, and you can insert
    the one you want.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为经常编写的代码创建模板；如果你按下 *Ctrl* + 空格键，依赖于作用域，会出现你的模板列表，你可以选择插入你需要的模板。
- en: 'Examples include a **do while** loop in C or C++, a main method in Java:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 示例包括 C 或 C++ 中的 **do while** 循环，Java 中的 main 方法：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or, an **include guard** (a.k.a. a **macro guard** , **header guard** , or
    **file guard** ) in C++/C:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在 C++/C 中使用 **包含保护**（也叫 **宏保护**、**头文件保护** 或 **文件保护**）：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These stop you from accidentally including a library multiple times [Wiki_Include].
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些能防止你意外地多次包含一个库 [Wiki_Include]。
- en: 'In Java, you would use a **for loop** :'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，你会使用 **for 循环**：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Or, you would use a **try-catch block** .
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你会使用 **try-catch 块**。
- en: 'For Python, examples include a **function definition** :'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python，示例包括 **函数定义**：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'They also include a **class definition** :'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 它们还包括 **类定义**：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[ Eclipse_Help, Gemini]'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[Eclipse_Help, Gemini]'
- en: Another significant advantage is its wide language support. Being in the Eclipse
    environment, Content Assist supports numerous programming languages, including
    Java, C++, Python, and PHP. This makes Content Assist a great tool for developers
    working in multi-language environments. Whether developing a web application in
    JavaScript, a desktop application in Java, or a script in Python, Content Assist
    provides relevant suggestions to speed up the coding process.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个显著的优点是其广泛的语言支持。由于在 Eclipse 环境中，内容助手支持众多编程语言，包括 Java、C++、Python 和 PHP。这使得内容助手成为多语言开发环境中开发者的好工具。无论是在
    JavaScript 中开发 Web 应用程序，在 Java 中开发桌面应用程序，还是在 Python 中编写脚本，内容助手都能提供相关建议，加快编码过程。
- en: There are some drawbacks, however. Performance can be an issue, especially with
    larger projects, where code completion suggestions might be slower compared to
    dedicated tools. This delay can disrupt the coding flow and reduce productivity.
    Also, while Content Assist provides useful suggestions, they may not always be
    as contextually relevant or advanced as those offered by specialized tools or
    those powered by ML models.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它也有一些缺点。性能可能是一个问题，尤其是在大型项目中，代码补全建议可能比专用工具更慢。这种延迟可能打断编码流程并降低生产力。而且，虽然内容辅助提供有用的建议，但它们可能并不总是像专门工具或由机器学习模型驱动的工具那样上下文相关或先进。
- en: Despite these limitations, Eclipse’s Content Assist remains a valuable tool
    for many developers. Its integration with the Eclipse IDE, combined with customization
    options and wide language support, makes it a practical choice for various coding
    tasks. For developers prioritizing an IDE with robust multi-language support,
    Content Assist offers a balanced mix of convenience and functionality.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些限制，Eclipse 的内容辅助仍然是许多开发者的宝贵工具。它与 Eclipse IDE 的集成，再加上可定制选项和广泛的语言支持，使其成为多种编码任务的实用选择。对于那些优先考虑支持多语言的
    IDE 的开发者来说，内容辅助提供了一种便利与功能兼具的平衡。
- en: 'Here are some pros of using Content Assist:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用内容辅助的一些优点：
- en: No additional installation required
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要额外安装。
- en: It offers various settings to tailor suggestions to your needs
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了多种设置，以便根据你的需求调整建议。
- en: It supports a vast array of programming languages
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持广泛的编程语言。
- en: It is integrated directly into the Eclipse IDE
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它直接集成在 Eclipse IDE 中。
- en: It can be configured to activate automatically or manually
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以配置为自动或手动激活。
- en: 'Here are some cons of using Content Assist:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用内容辅助的一些缺点：
- en: It can sometimes be slower than dedicated code completion tools, especially
    with larger projects
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大型项目中，它有时可能比专用的代码补全工具更慢。
- en: It may not always provide the most contextually relevant suggestions compared
    to specialized tools or those powered by ML models
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与专门的工具或由机器学习模型驱动的工具相比，它可能并不总是提供最具上下文相关性的建议。
- en: In summary, Eclipse’s Content Assist is a valuable tool for developers looking
    for an integrated, customizable, and versatile code completion feature. While
    it may not always match the performance or advanced capabilities of dedicated
    tools, its built-in nature and wide language support make it a solid choice for
    many coding environments. Whether you are a seasoned developer or just starting,
    Content Assist can help streamline your coding process and improve your overall
    productivity.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Eclipse 的内容辅助是一个对开发者来说非常有价值的工具，适合寻找集成化、可定制且多功能的代码补全功能的开发者。尽管它可能并不总是与专门工具的性能或高级功能相匹配，但其内置特性和广泛的语言支持使其成为许多编码环境中的一个可靠选择。无论你是经验丰富的开发者还是刚刚起步，内容辅助都能帮助简化你的编码过程，提升整体生产力。
- en: 'For more detailed information about Content Assist, you can refer to the Eclipse
    Help documentation: [https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.cdt.doc.user%2Fconcepts%2Fcdt_c_content_assist.htm](https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.cdt.doc.user%2Fconcepts%2Fcdt_c_content_assist.htm)
    .'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有关内容辅助的更详细信息，你可以参考 Eclipse 帮助文档：[https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.cdt.doc.user%2Fconcepts%2Fcdt_c_content_assist.htm](https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.cdt.doc.user%2Fconcepts%2Fcdt_c_content_assist.htm)。
- en: PyCharm’s code completion
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyCharm 的代码补全。
- en: '**PyCharm** , developed by JetBrains, is a widely acclaimed IDE specifically
    designed for Python development. One of its standout features is its intelligent
    code completion, which significantly improves your coding experience by giving
    you context-aware suggestions that go beyond basic code completions. This feature
    can carry out static analysis and use ML to provide highly relevant recommendations,
    including method calls, variable names, and code snippets.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**PyCharm**，由 JetBrains 开发，是一款广受好评的专门为 Python 开发设计的 IDE。其突出特点之一是智能代码补全，它通过提供超越基本代码补全的上下文感知建议，显著提升了你的编码体验。该功能可以执行静态分析，并使用机器学习提供高度相关的推荐，包括方法调用、变量名称和代码片段。'
- en: PyCharm’s code completion tool is deeply integrated with Python, making it an
    excellent choice for Python developers. The IDE indexes your entire project upon
    startup, allowing it to provide accurate and contextually relevant suggestions
    as you type. This deep integration ensures that the code completion feature understands
    the nuances of Python syntax and semantics, offering suggestions that have correct
    syntax and are appropriate for the context.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 的代码补全工具与 Python 深度集成，是 Python 开发者的绝佳选择。IDE 在启动时会对整个项目进行索引，从而在你输入时提供准确且具有上下文相关性的建议。这种深度集成确保了代码补全功能能够理解
    Python 语法和语义的细微差别，提供具有正确语法且适用于当前上下文的建议。
- en: One of the key advantages of PyCharm’s code completion tool is its context-aware
    nature. The tool analyzes the current context as you code to provide the most
    relevant suggestions. For example, if you’re inside a class method, it will prioritize
    method names and variables that are accessible within that scope. This context-awareness
    extends to understanding the types of variables and suggesting methods and properties
    that are applicable to those types. This intelligent behavior helps reduce the
    amount of boilerplate code you need to write and minimizes the chances of errors.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 的代码补全工具的一个关键优势是其上下文感知特性。该工具在你编写代码时会分析当前上下文，提供最相关的建议。例如，如果你在一个类的方法中，它会优先显示该作用域内可访问的方法名称和变量。此上下文感知能力扩展到理解变量的类型，并建议适用于这些类型的方法和属性。这种智能行为有助于减少你需要编写的样板代码，并最小化错误的发生几率。
- en: In addition to basic code completion, PyCharm offers smart type-matching completion.
    This feature filters the suggestion list to show only the types that are applicable
    to the current context. For example, if you’re assigning a value to a variable,
    it will suggest only those values that match the variable’s type. This smart filtering
    helps in maintaining type safety and ensures that your code adheres to the expected
    type constraints.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本的代码补全功能，PyCharm 还提供智能类型匹配补全。此功能会筛选建议列表，仅显示适用于当前上下文的类型。例如，如果你正在为一个变量赋值，它只会建议与该变量类型匹配的值。这个智能筛选有助于保持类型安全，并确保你的代码符合预期的类型约束。
- en: Here are some examples of using code completion.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些使用代码补全的示例。
- en: Start by typing a name in PyCharm, then hit *Ctrl* + the space bar. Alternatively,
    go to the menu and select **Code** | **Code Completion** , then you can choose
    the **Basic** version. For **Basic Completion** , you can do Methods, Method parameters,
    Dictionaries, Django templates, and File path completions [Python].
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PyCharm 中开始输入一个名称，然后按 *Ctrl* + 空格键。或者，你也可以进入菜单选择 **Code** | **Code Completion**，然后选择
    **Basic** 版本。对于 **Basic Completion**，你可以进行方法、方法参数、字典、Django 模板和文件路径的补全 [Python]。
- en: Pressing *Ctrl* + the space bar a second time or *Ctrl* + *Alt* + the space
    bar gives you the names of classes, functions, modules, and variables that start
    with the same letters you’ve written.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次按 *Ctrl* + 空格键或 *Ctrl* + *Alt* + 空格键，你将得到与你输入的字母开头相同的类、函数、模块和变量的名称。
- en: Other kinds of code completion are smart, hierarchical, chained, docstring,
    custom, live templates, postfix, and type hints [Jetbrains_Completion].
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型的代码补全包括智能补全、层级补全、链式补全、文档字符串补全、自定义补全、实时模板补全、后缀补全和类型提示补全 [Jetbrains_Completion]。
- en: 'Smart type-matching completion gives you a list of relevant types from the
    current context (around the cursor). For example, exception types. If you hit
    *Ctrl* + *Shift* + the space bar, it’ll give you a list of the relevant types
    or you could use the menu: **Code** | **Code Completion** | **Type-Matching**
    .'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 智能类型匹配补全会根据当前上下文（光标周围）提供相关类型的列表。例如，异常类型。如果你按 *Ctrl* + *Shift* + 空格键，它会显示相关类型的列表，或者你也可以使用菜单：**Code**
    | **Code Completion** | **Type-Matching**。
- en: Refactoring
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构
- en: PyCharm can also do a great deal of refactoring. Its refactoring tools work
    alongside its code completion feature. These tools allow you to rename variables,
    extract methods, and perform other refactoring operations easily. The refactoring
    tools are context-aware and ensure that changes are propagated throughout your
    code base, maintaining consistency and reducing the risk of introducing errors.
    This deep integration of refactoring tools with code completion makes PyCharm
    a very useful IDE for maintaining and improving code quality.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm也可以进行大量的重构。它的重构工具与代码补全功能协同工作。这些工具允许你轻松地重命名变量、提取方法以及执行其他重构操作。重构工具是基于上下文的，确保变更在你的代码库中得以传播，保持一致性并减少引入错误的风险。重构工具与代码补全的深度集成，使PyCharm成为一个非常有用的IDE，用于维护和提升代码质量。
- en: 'There are PyCharm components: project view, structure tool window, editor,
    and UML class diagram. To get started with refactoring, there are two ways:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm包含一些组件：项目视图、结构工具窗口、编辑器和UML类图。要开始进行重构，有两种方法：
- en: Hover over some code.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在一些代码上。
- en: Select the code, and from the menu, select **Refactor** | **Refactor This**
    or press *Ctrl* + *Alt* + *Shift* + *T* .
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择代码，然后从菜单中选择**重构** | **重构此项**，或者按*Ctrl* + *Alt* + *Shift* + *T*。
- en: Then, select the refactoring option you’d like.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择你想要的重构选项。
- en: You’ll get a dialog box where you can enter the refactoring options, then you
    can click **OK** or **Refactor** [Jetbrains_refactoring].
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到一个对话框，你可以在其中输入重构选项，然后点击**确定**或**重构** [Jetbrains_refactoring]。
- en: 'There are many excellent things you can do with code completion, however, there
    are some drawbacks. PyCharm is a commercial tool, and while it offers a free Community
    edition, many of its advanced features, including some aspects of code completion,
    are available only in the Professional edition, which requires a license. This
    can be a limitation for developers or organizations with budget constraints. You
    can see the difference between the versions, along with a link to pricing, here:
    [https://www.jetbrains.com/pycharm/editions/](https://www.jetbrains.com/pycharm/editions/)
    .'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过代码自动补全做很多很棒的事情，但也有一些缺点。PyCharm是一个商业工具，虽然它提供了免费的社区版，但许多高级功能，包括一些代码补全功能，只在专业版中提供，专业版需要购买许可证。这对预算有限的开发者或组织来说可能是一个限制。你可以在这里看到不同版本之间的差异，并查看定价链接：[https://www.jetbrains.com/pycharm/editions/](https://www.jetbrains.com/pycharm/editions/)。
- en: Another consideration is that PyCharm can be resource-intensive, especially
    when working with large projects. The IDE’s comprehensive indexing and analysis
    capabilities need quite a lot of computational resources, which can lead to slower
    performance on less powerful machines. This resource intensity can sometimes result
    in delays in code completion suggestions, which can disrupt the coding flow.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的因素是，PyCharm可能会消耗大量资源，尤其是在处理大型项目时。IDE的全面索引和分析功能需要相当多的计算资源，这可能会导致在性能较差的机器上运行缓慢。这种资源密集型使用有时会导致代码补全建议的延迟，从而打断编码的流畅性。
- en: 'Despite these drawbacks, PyCharm’s code completion remains a highly valuable
    tool for Python developers. Its intelligent, context-aware suggestions, deep integration
    with Python, and powerful refactoring tools make it an excellent choice for both
    novice and experienced developers. The ability to customize the behavior of code
    completion means you can define how it helps to check and complete your code:
    you can tailor the tool to your specific preferences.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些缺点，PyCharm的代码补全仍然是Python开发者非常有价值的工具。它智能的、基于上下文的建议、与Python的深度集成以及强大的重构工具，使其成为初学者和经验丰富的开发者的优选。代码补全行为的可定制性意味着你可以定义它如何帮助检查和完成代码：你可以根据自己的具体偏好来调整这个工具。
- en: 'Here are some pros of using PyCharm’s code completion tool:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用PyCharm代码自动补全工具的一些优点：
- en: It offers highly relevant code completions based on your code’s context
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它根据你代码的上下文提供高度相关的代码补全。
- en: It provides a seamless Python development experience
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了无缝的Python开发体验。
- en: It includes excellent refactoring features to improve code quality
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包括优秀的重构功能，可以提高代码质量。
- en: 'Here are some cons of using PyCharm’s code completion tool:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用PyCharm代码自动补全工具的一些缺点：
- en: It requires a paid license for full use
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全使用需要付费许可证。
- en: It can be resource-intensive, especially for large projects
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能会消耗大量资源，特别是在大型项目中。
- en: In summary, PyCharm’s code completion is a robust and intelligent feature that
    significantly enhances the Python development experience. Its context-aware suggestions,
    deep integration with Python, and powerful refactoring tools make it a very good
    choice for Python developers. While it requires a license for full use and can
    be resource-intensive, the benefits it offers in terms of productivity and code
    quality make it a worthwhile investment for many developers.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，PyCharm的代码自动完成是一个强大而智能的功能，大大提升了Python开发体验。它的上下文感知建议、与Python的深度集成以及强大的重构工具，使其成为Python开发者的极好选择。尽管完全使用该功能需要许可证，并且可能对资源要求较高，但它在提升生产力和代码质量方面的好处，使其对许多开发人员来说是值得投资的。
- en: 'You can find out more about PyCharm’s code completion tool here: [https://www.jetbrains.com/help/pycharm/auto-completing-code.html](https://www.jetbrains.com/help/pycharm/auto-completing-code.html)
    .'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于PyCharm代码自动完成功能的信息：[https://www.jetbrains.com/help/pycharm/auto-completing-code.html](https://www.jetbrains.com/help/pycharm/auto-completing-code.html)。
- en: NetBeans’ code completion
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NetBeans的代码自动完成
- en: NetBeans offers a full code completion feature. This feature is designed to
    enhance the coding experience by providing relevant suggestions for keywords,
    methods, variables, and more, across various programming languages. NetBeans’
    code completion tool is a valuable tool for you to increase your productivity
    and reduce your coding errors.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans提供了完整的代码自动完成功能。此功能旨在通过提供与关键字、方法、变量等相关的建议，提升编程体验，支持多种编程语言。NetBeans的代码自动完成功能是提高生产力和减少编码错误的宝贵工具。
- en: NetBeans’ code completion tool is pretty user-friendly. The design makes it
    easy for developers to use, regardless of their level of experience. The code
    completion feature is integrated into the editor, allowing suggestions to appear
    as you type. This integration helps streamline the coding process, making it faster
    and more efficient. The interface is designed to be straightforward, so even new
    users can quickly become familiar with the tool.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans的代码自动完成工具非常用户友好。其设计使得开发人员无论经验水平如何，都能轻松使用。代码自动完成功能集成在编辑器中，允许在你输入时自动出现建议。这种集成有助于简化编码过程，使其更加快捷高效。界面设计简单直观，即使是新用户也能快速熟悉该工具。
- en: 'NetBeans’ Editor Code Completion API has two classes, **CompletionItem** and
    **Completion** **Provider** . Code completion is also activated with *Ctrl* +
    the space bar or through the menus: in Windows, this is the pathway: **Tools**
    | **Options** | **Editor** | **Code Completion** . In macOS, this is the pathway:
    **NetBeans** | **Preferences…** | **Editor** | **Code Completion** . Similar to
    other tools, it will take what you have written and make a list of suggestions
    that shortens as you type, and the most relevant suggestions will be at the top
    of the list. You can specify the code completion trigger, but the default is.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans的编辑器代码自动完成API有两个类，**CompletionItem**和**Completion** **Provider**。代码自动完成同样可以通过*Ctrl*
    + 空格键或通过菜单激活：在Windows中，这个路径是：**工具** | **选项** | **编辑器** | **代码自动完成**；在macOS中，这个路径是：**NetBeans**
    | **偏好设置…** | **编辑器** | **代码自动完成**。与其他工具类似，它会根据你所写的内容生成一个建议列表，随着你输入，列表会缩短，最相关的建议会排在列表的顶部。你可以指定代码自动完成的触发方式，但默认情况下是这样的。
- en: There’s another version of code completion called **hippie completion** , which
    searches the current scope of your code, searching the current document and then
    other documents if the desired result is not found. It is activated with *Ctrl*
    + *K* in Windows or *cmd* + *K* in macOS.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种叫做**hippie completion**的代码自动完成版本，它会搜索当前代码的作用域，首先搜索当前文档，如果没有找到期望的结果，则继续搜索其他文档。Windows系统中使用*Ctrl*
    + *K*，在macOS系统中使用*cmd* + *K*来激活该功能。
- en: If you are declaring an object or a variable of a type, then pressing *Ctrl*
    + the space bar will suggest objects of that type, for example, if you’re declaring
    an **int** , then the first time you hit *Ctrl* + the space bar, it’ll give you
    ints. If you activate code completion again with the same keys, it’ll suggest
    all items, not just ints.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在声明一个对象或变量类型，按*Ctrl* + 空格键将建议该类型的对象，例如，如果你声明一个**int**，第一次按*Ctrl* + 空格键时，它会给你所有int类型的选项。如果你再次使用相同的快捷键激活代码自动完成，它会建议所有项，而不仅仅是int类型。
- en: 'If you use the *Tab* button, the tool will fill in the most commonly used prefixes
    and suggestions, for example, **print** ; if you type **System.out.p** , the following
    will appear:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用*Tab*键，该工具将填充最常用的前缀和建议，例如，**print**；如果你输入**System.out.p**，将出现以下内容：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Use the *Tab* key to use the selected option.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*Tab*键选择建议项。
- en: 'NetBeans’ code completion tool will also complete subwords. This is based on
    which letters you’ve typed in, but it’s everything relating to those letters,
    not just things starting with those letters. So, it still works if you’ve forgotten
    the initial letters for the item! An example of this is if you type in **Binding.prop**
    , it’ll give you the following suggestions:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans 的代码自动完成工具还会自动完成子词。这取决于你输入的字母，但它会关联到这些字母相关的所有内容，而不仅仅是以这些字母开头的内容。因此，即使你忘记了项目的首字母，它仍然可以正常工作！举个例子，如果你输入
    **Binding.prop**，它会提供以下建议：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you need a chain of commands, press *Ctrl* + the space bar twice, and all
    available chains will be displayed. It looks for variables, fields, and methods.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要一系列命令时，按 *Ctrl* + 空格键两次，所有可用的命令链都会显示出来。它会查找变量、字段和方法。
- en: 'For example, if you type in the string **bindName =** , the completion tool
    can display the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，当你输入字符串 **bindName =** 时，自动完成工具可以显示以下内容：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There are even more ways that NetBeans’ code completion tool helps you code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans 的代码自动完成工具还以更多方式帮助你编码。
- en: 'Go here for a tutorial on how to implement the Editor Code Completion API in
    the context of HTML files: [https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/](https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/)
    [ Netbeans_Completion, Netbeans_SmartCode].'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何在 HTML 文件的上下文中实现编辑器代码自动完成 API 的教程，请访问：[https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/](https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/)
    [ Netbeans_Completion, Netbeans_SmartCode]。
- en: However, there are some drawbacks to NetBeans’ code completion tool. Performance
    can sometimes be an issue with NetBeans, especially when working with larger projects.
    The code completion feature might be slower compared to more specialized tools
    designed specifically for code completion. This can be particularly noticeable
    when dealing with large code bases or projects and all their dependencies. The
    delay in suggestions can disrupt the coding flow and reduce overall productivity.
    Also, NetBeans does have a comprehensive set of features, but it may not provide
    as many advanced capabilities as some commercial IDEs. For example, commercial
    tools often have ML models to offer more sophisticated and context-aware code
    completions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，NetBeans 的代码自动完成工具也存在一些缺点。在处理较大项目时，性能有时会成为问题。与专门设计用于代码自动完成的工具相比，NetBeans
    的代码自动完成功能可能会较慢。这在处理大型代码库或项目及其所有依赖项时尤为明显。建议的延迟可能会打乱编码流畅性，降低整体生产力。此外，尽管 NetBeans
    提供了一整套功能，但它可能不像一些商业 IDE 那样提供那么多高级功能。例如，商业工具通常拥有机器学习模型，能够提供更复杂和上下文感知的代码自动完成。
- en: These advanced tools can provide more accurate suggestions, especially in complex
    coding scenarios. NetBeans, while robust, might not have some of these cutting-edge
    features, which can be a limitation for developers looking for the most advanced
    tools around.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些高级工具能够提供更准确的建议，尤其是在复杂的编码场景中。虽然 NetBeans 非常强大，但可能缺少一些这些前沿功能，这对寻找最先进工具的开发者来说是一个限制。
- en: Despite these limitations, NetBeans’ code completion remains a highly valuable
    tool for many developers. Its user-friendly interface, cross-platform compatibility,
    and open source nature make it an attractive option for a wide range of users.
    The ability to customize the behavior of code completion makes it even more useful
    for your coding, so you can tailor the tool, just like PyCharm’s tool [NetBeans_Completion].
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些局限性，NetBeans 的代码自动完成仍然是许多开发者高度重视的工具。其用户友好的界面、跨平台兼容性和开源特性，使其成为广泛用户的有吸引力选择。能够自定义代码自动完成的行为，使它对于你的编码更加有用，你可以像使用
    PyCharm 的工具一样定制它 [NetBeans_Completion]。
- en: 'Here are some pros of using NetBeans’ code completion feature:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NetBeans 代码自动完成功能的一些优点如下：
- en: It has an intuitive interface for easy use
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有直观的界面，易于使用
- en: It works on Windows, OSX, and Linux
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持 Windows、OSX 和 Linux 操作系统
- en: It is free and open source, making it accessible to all developers
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是免费的并且是开源的，使得所有开发者都能使用
- en: 'Here are some cons of using NetBeans’ code completion feature:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NetBeans 代码自动完成功能的一些缺点如下：
- en: It can sometimes be slower than more specialized code completion tools
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有时会比更专业的代码自动完成工具慢
- en: It may not offer as many advanced features as some commercial IDEs
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能不像一些商业 IDE 那样提供那么多高级功能
- en: In summary, NetBeans’ code completion feature is a robust, versatile tool that
    helps the development experience a lot. Its intuitive interface, cross-platform
    support, and open source accessibility make it an excellent choice for developers.
    While it may not always match the performance or advanced capabilities of specialized
    commercial tools, its comprehensive feature set and ease of use make it a solid
    choice for a lot of coding environments. So, if you’re an experienced developer
    or a newbie, NetBeans’ code completion can help streamline your coding process
    and improve your productivity. Let the tools do the heavy lifting. They say that
    a lazy coder is the best coder. Make and get tools that help you. Don’t do everything
    yourself.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，NetBeans 的代码补全功能是一个强大且多功能的工具，可以极大地帮助开发体验。其直观的界面、跨平台支持以及开源可访问性，使其成为开发者的优秀选择。虽然它可能无法与专门的商业工具在性能或高级功能上相媲美，但其全面的功能集和易用性使其成为许多编码环境中的坚实选择。因此，无论你是经验丰富的开发者还是新手，NetBeans
    的代码补全都能帮助简化你的编码过程，提高你的工作效率。让工具帮你完成繁重的工作。人们常说，懒惰的程序员是最好的程序员。制作并获取能帮你提高效率的工具，不必事事亲力亲为。
- en: 'Learn more about NetBeans’ code completion tool right here: [https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/](https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/)
    .'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多关于 NetBeans 代码补全工具的信息，请访问：[https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/](https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/)。
- en: VS Code’s IntelliSense
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VS Code 的 IntelliSense
- en: VS Code is offered by Microsoft. One of its best features is IntelliSense. IntelliSense
    analyzes the context of your code to provide relevant suggestions, including method
    calls, variables, and keywords, making coding faster and reducing the likelihood
    of errors.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 是由 Microsoft 提供的，其中一个最佳特性就是 IntelliSense。IntelliSense 会分析代码的上下文，提供相关的建议，包括方法调用、变量和关键字，从而加快编码速度并减少出错的可能性。
- en: One of the primary advantages of IntelliSense is its lightweight nature. Despite
    its powerful capabilities, VS Code remains fast and efficient, even when working
    with large projects. This performance efficiency is crucial for developers who
    need a responsive and reliable coding environment. The lightweight design ensures
    that IntelliSense can provide real-time suggestions without causing significant
    delays or performance issues, even in extensive code bases.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliSense 的主要优点之一是它的轻量化特性。尽管功能强大，VS Code 仍然保持着快速和高效的性能，即使在处理大型项目时也不例外。这种性能效率对于需要一个响应迅速且可靠的编码环境的开发者来说至关重要。轻量化的设计确保
    IntelliSense 能够提供实时建议，而不会导致显著的延迟或性能问题，即使是在庞大的代码库中也是如此。
- en: Like the tools from PyCharm and NetBeans, IntelliSense is also highly customizable,
    offering a wide range of options to tailor the tool to your specific needs. Developers
    can configure various aspects of IntelliSense, such as the types of suggestions
    it provides and the triggers for displaying these suggestions. This customization
    allows you to create a coding environment that aligns with your workflow and preferences.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与 PyCharm 和 NetBeans 的工具类似，IntelliSense 也是高度可定制的，提供广泛的选项来根据你的特定需求调整工具的设置。开发者可以配置
    IntelliSense 的各个方面，例如它提供的建议类型以及触发这些建议显示的条件。这种定制化允许你创建一个与你的工作流和偏好相匹配的编码环境。
- en: VS Code also allows user-defined snippets, enabling you to create and use custom
    code templates that can be quickly inserted into your code. This is now available
    in many IDEs but it’s a useful tool to have and make use of.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 还允许用户定义代码片段，使你能够创建并使用自定义代码模板，这些模板可以迅速插入到你的代码中。这项功能现在已经在许多集成开发环境（IDE）中提供，但它仍然是一个非常实用的工具。
- en: The Visual Studio Marketplace offers a vast array of plugins that can extend
    the functionality of IntelliSense and the editor as a whole. These plugins cover
    a wide range of programming languages, frameworks, and tools, allowing developers
    to enhance their coding environment with additional features and capabilities.
    Whether you need support for a specific language, integration with version control
    systems, or tools for debugging and testing, the marketplace has a plugin to meet
    your needs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Marketplace 提供了大量插件，可以扩展 IntelliSense 和整个编辑器的功能。这些插件覆盖了各种编程语言、框架和工具，允许开发者通过附加的功能和能力来增强他们的编码环境。无论你需要某个特定语言的支持，还是需要与版本控制系统集成，或是需要调试和测试的工具，市场上都能找到满足你需求的插件。
- en: Let’s look at the negatives.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下它的负面影响。
- en: One thing to think about is that while IntelliSense offers good code completion,
    it may not be as specialized for certain programming languages or frameworks as
    some dedicated IDEs. For example, an IDE specifically designed for Java development
    might offer more advanced and context-aware suggestions for Java code compared
    to VS Code. However, the large list of plugins helps mitigate this limitation
    by allowing you to add language-specific extensions that enhance IntelliSense’s
    capabilities for your preferred languages and frameworks.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的一点是，尽管 IntelliSense 提供了良好的代码补全功能，但与一些专门的集成开发环境（IDE）相比，它在某些编程语言或框架上可能不够专业。例如，专为
    Java 开发设计的 IDE 可能会为 Java 代码提供比 VS Code 更加高级和具备上下文感知的建议。然而，丰富的插件列表通过允许你添加特定语言的扩展，帮助缓解这一限制，增强了
    IntelliSense 在你偏好的语言和框架上的能力。
- en: 'Here are some pros of using VS Code’s IntelliSense:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 VS Code IntelliSense 的一些优点如下：
- en: '**Lightweight** : It is fast and efficient, even for large projects'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻量级** : 即使是大型项目，IntelliSense 也快速高效。'
- en: '**Highly customizable** : It offers a wide range of customization options'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高度可定制** : 它提供了广泛的定制选项。'
- en: '**.NET support** : IntelliSense has strong support for .NET languages, such
    as C#, F#, and VB.NET, and it excels in these languages'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET 支持** : IntelliSense 对 .NET 语言（如 C#、F# 和 VB.NET）提供了强大的支持，并且在这些语言上表现出色。'
- en: 'Here are some cons of using VS Code’s IntelliSense:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 VS Code IntelliSense 的一些缺点如下：
- en: '**Variable performance** : IntelliSense’s accuracy and completeness depend
    on language and project setup. Less common languages and more complex projects
    can see IntelliSense underperform.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量性能** : IntelliSense 的准确性和完整性取决于语言和项目的设置。较少使用的语言和更复杂的项目可能会导致 IntelliSense
    性能不佳。'
- en: '**Potential performance overhead** : In complex projects, IntelliSense might
    consume more system resources than some alternative tools.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**潜在的性能开销** : 在复杂的项目中，IntelliSense 可能会消耗比某些替代工具更多的系统资源。'
- en: In summary, VS Code’s IntelliSense is a really useful tool for developers. Its
    lightweight design, high customizability, and all those plugins make it a valuable
    choice for a lot of different coding tasks. You can tailor IntelliSense to how
    you like to work, so it can assist you in a way that fits in with how you enjoy
    working.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，VS Code 的 IntelliSense 对开发者来说是一个非常有用的工具。它的轻量级设计、高度的可定制性，以及大量插件使得它成为许多不同编码任务的宝贵选择。你可以根据自己的工作方式定制
    IntelliSense，使其以适合你工作风格的方式帮助你。
- en: 'Here’s more information about VS Code’s IntelliSense: https://code.visualstudio.com/docs/editor/intellisense
    .'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关于 VS Code IntelliSense 的更多信息：[https://code.visualstudio.com/docs/editor/intellisense](https://code.visualstudio.com/docs/editor/intellisense)。
- en: Now, let’s get into the SCA and the code review tools.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看 SCA 和代码审查工具。
- en: SCA tools help you to find issues before running code, analyze large code bases,
    and automate routine checks.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: SCA 工具帮助你在运行代码之前发现问题，分析大型代码库，并自动执行常规检查。
- en: Code review tools help experienced coders suggest improvements to code, help
    teams collaborate more, and also think about the wider environment of the code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查工具帮助经验丰富的编码人员提出改进代码的建议，帮助团队更好地协作，并且考虑代码的更广泛环境。
- en: SCA and code review tools
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SCA 和代码审查工具
- en: SCA and code review tools have become indispensable in modern software development,
    playing a critical role in ensuring code quality and reliability before the code
    is executed. These tools meticulously analyze source code to identify potential
    bugs, security vulnerabilities, style inconsistencies, and other issues that could
    compromise the software. By catching these problems early in the development process,
    SCA tools help maintain high standards of software quality, reduce the risk of
    defects in production, and ultimately save time and resources.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: SCA 和代码审查工具在现代软件开发中已变得不可或缺，它们在确保代码质量和可靠性方面起着关键作用，尤其是在代码执行之前。这些工具会细致地分析源代码，找出潜在的错误、安全漏洞、风格不一致和其他可能影响软件的问题。通过在开发过程早期捕捉这些问题，SCA
    工具帮助保持高标准的软件质量，减少生产中的缺陷风险，最终节省时间和资源。
- en: One of the primary benefits of SCA tools is their ability to provide immediate
    feedback to developers. As code is written, these tools scan the source code and
    highlight potential issues, allowing developers to address them on the spot. This
    real-time feedback loop is invaluable for maintaining code quality and ensuring
    that best practices are followed consistently. Additionally, SCA tools often integrate
    seamlessly with popular IDEs and CI/CD pipelines, making them an integral part
    of the development workflow.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: SCA 工具的主要优点之一是它们能够为开发者提供即时反馈。随着代码的编写，这些工具会扫描源代码并突出潜在问题，允许开发者立刻解决。这种实时反馈循环对于维持代码质量并确保始终遵循最佳实践至关重要。此外，SCA
    工具通常与流行的 IDE 和 CI/CD 管道无缝集成，使其成为开发工作流的核心部分。
- en: There are several well-known SCA tools available, each with its own set of features
    and capabilities. For example, SonarQube is a widely used tool that supports multiple
    programming languages and provides comprehensive reports on code quality, security
    vulnerabilities, and technical debt. It offers detailed insights into code issues
    and suggests possible fixes, helping developers improve their code base over time.
    Another popular tool is ESLint, which is specifically designed for JavaScript
    and TypeScript. ESLint allows developers to enforce coding standards and catch
    common errors, making it an essential tool for frontend development.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种知名的 SCA 工具可供选择，每种工具都有自己的一套功能和能力。例如，SonarQube 是一个广泛使用的工具，支持多种编程语言，并提供关于代码质量、安全漏洞和技术债务的全面报告。它深入分析代码问题，并提出可能的修复建议，帮助开发者随着时间的推移改进代码库。另一个受欢迎的工具是
    ESLint，它专为 JavaScript 和 TypeScript 设计。ESLint 允许开发者强制执行编码标准并捕捉常见错误，是前端开发中必不可少的工具。
- en: SonarQube
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SonarQube
- en: '**SonarQube** is a widely used static analysis tool that supports multiple
    programming languages, including Java, C#, and JavaScript. It provides a platform
    for continuous inspection of code quality, enabling teams to detect bugs, vulnerabilities,
    and code smells. This tool is for maintaining high standards of software quality
    and making sure the code is reliable and secure before it gets to production.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**SonarQube** 是一个广泛使用的静态分析工具，支持多种编程语言，包括 Java、C# 和 JavaScript。它提供了一个持续检查代码质量的平台，使团队能够发现错误、漏洞和代码异味。这个工具用于维持高标准的软件质量，并确保代码在投入生产之前是可靠和安全的。'
- en: SonarQube can detect bugs and vulnerabilities in code repositories. By scanning
    the source code, SonarQube finds potential issues that could lead to runtime errors
    or security breaches. This proactive approach allows developers to address problems
    early in the development process, reducing the risk of costly fixes later on.
    The tool provides detailed insights into what the bugs and vulnerabilities are,
    helping developers understand the root causes and think of the best solutions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: SonarQube 可以检测代码库中的错误和漏洞。通过扫描源代码，SonarQube 能发现可能导致运行时错误或安全漏洞的问题。这种主动的做法使开发者能够在开发过程的早期解决问题，从而减少日后修复的成本。该工具提供了关于错误和漏洞的详细信息，帮助开发者理解根本原因并考虑最佳解决方案。
- en: SonarQube also has a lot of code metrics that are great for maintaining high-quality
    code. These metrics include code coverage, complexity, and duplication rates.
    Code coverage measures the extent to which the code base is tested by automated
    tests, providing an indication of the robustness of the testing process. Complexity
    metrics help identify overly complicated code that may be difficult to maintain
    or prone to errors. Duplication rates highlight areas of the code base where similar
    code is repeated, suggesting opportunities for refactoring to improve maintainability
    and reduce technical debt.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: SonarQube 还提供了许多有助于维持高质量代码的代码度量指标。这些指标包括代码覆盖率、复杂度和重复率。代码覆盖率衡量了自动化测试对代码库的测试程度，从而反映测试过程的健壮性。复杂度指标有助于识别过于复杂的代码，这类代码可能难以维护或容易出错。重复率则突出了代码库中重复出现的相似代码，提示可以进行重构以提高可维护性并减少技术债务。
- en: SonarQube’s integration with CI/CD pipelines is another significant advantage.
    By integrating SonarQube into the CI/CD process, teams can ensure that code quality
    checks are an integral part of the development workflow. This integration allows
    for automatic code analysis with every commit, providing immediate feedback to
    developers and preventing the introduction of new issues into the code base. The
    integration with popular CI/CD tools, such as Jenkins, Azure DevOps, and GitLab,
    makes it easy to incorporate SonarQube into existing development processes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: SonarQube 与 CI/CD 流水线的集成是另一个显著的优势。通过将 SonarQube 集成到 CI/CD 流程中，团队可以确保代码质量检查成为开发工作流的一个不可或缺的部分。这种集成使得每次提交代码时都能自动进行代码分析，提供即时反馈给开发者，并防止在代码库中引入新的问题。与流行的
    CI/CD 工具（如 Jenkins、Azure DevOps 和 GitLab）集成，使得将 SonarQube 融入现有开发流程变得容易。
- en: 'Using SonarQube is straightforward. To analyze a project, developers can use
    the SonarQube scanner, a command-line tool that sends the code to the SonarQube
    server for analysis. For example, to analyze a Java project, you’d do the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SonarQube 很简单。要分析一个项目，开发者可以使用 SonarQube 扫描器，这是一个命令行工具，它将代码发送到 SonarQube 服务器进行分析。例如，要分析一个
    Java 项目，你可以按以下步骤操作：
- en: 'First, download it at the following link: [https://www.sonarsource.com/products/sonarqube/](https://www.sonarsource.com/products/sonarqube/)
    .'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在以下链接下载：[https://www.sonarsource.com/products/sonarqube/](https://www.sonarsource.com/products/sonarqube/)。
- en: Install SonarScanner with [https://docs.sonarsource.com/sonarqube/9.7/analyzing-source-code/scanners/sonarscanner/](https://docs.sonarsource.com/sonarqube/9.7/analyzing-source-code/scanners/sonarscanner/)
    .
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下链接安装 SonarScanner：[https://docs.sonarsource.com/sonarqube/9.7/analyzing-source-code/scanners/sonarscanner/](https://docs.sonarsource.com/sonarqube/9.7/analyzing-source-code/scanners/sonarscanner/)。
- en: 'Configure SonarScanner by creating a **sonar-project.properties** file in the
    root directory of the Java project:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 Java 项目的根目录下创建一个**sonar-project.properties**文件来配置 SonarScanner：
- en: 'Specify the project key, name, and source directories:'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定项目密钥、名称和源代码目录：
- en: '[PRE8]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, you would run the following command to analyze the project:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以运行以下命令来分析项目：
- en: '[PRE9]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This command specifies the project key and the source directory to be analyzed.
    The results of the analysis are then available on the SonarQube dashboard, where
    developers can review the findings and take appropriate action.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令指定了项目密钥和要分析的源代码目录。分析结果随后会显示在 SonarQube 仪表盘上，开发者可以查看结果并采取适当的措施。
- en: Despite its many advantages, SonarQube is not without its challenges. One potential
    negative is the possibility of false positives, where the tool flags an issue
    that is not actually a problem. This can lead to unnecessary work for developers
    and may cause frustration. Additionally, while SonarQube does a pretty comprehensive
    analysis, it may not catch all types of issues, particularly those related to
    the runtime behavior of the code. Therefore, it is important to use static analysis
    with other testing methods, such as unit testing and integration testing, to ensure
    comprehensive coverage.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 SonarQube 有很多优点，但也存在一些挑战。一个潜在的负面因素是误报的可能性，即工具标记了一个实际上并不是问题的情况。这可能导致开发者进行不必要的工作，并可能引发挫败感。此外，尽管
    SonarQube 做了相当全面的分析，但它可能无法捕捉到所有类型的问题，尤其是与代码运行时行为相关的问题。因此，重要的是将静态分析与其他测试方法（如单元测试和集成测试）结合使用，以确保全面覆盖。
- en: 'Here are some pros of using SonarQube:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SonarQube 的一些优点如下：
- en: SonarQube supports a wide range of programming languages, making it able to
    help in diverse projects
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SonarQube 支持多种编程语言，使其能够在各种项目中提供帮助。
- en: It provides detailed reports on code quality, allowing teams to prioritize issues
    effectively
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供关于代码质量的详细报告，帮助团队有效地优先处理问题。
- en: A strong community and a variety of plugins enhance SonarQube’s functionality
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强大的社区和各种插件增强了 SonarQube 的功能。
- en: There is a free version and paid versions for more functionality
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了免费版本和付费版本以获得更多功能。
- en: 'Here are some cons of using SonarQube:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SonarQube 的一些缺点如下：
- en: SonarQube can sometimes produce false positives, which developers should review
    carefully
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SonarQube 有时会产生误报，开发者应仔细审查这些问题。
- en: Running SonarQube can be resource-intensive, particularly for large code bases,
    which may require dedicated infrastructure
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 SonarQube 可能会消耗较多资源，特别是对于大型代码库，可能需要专门的基础设施。
- en: In conclusion, SonarQube is a useful tool for SCA and continuous inspection
    of code quality. Its ability to detect bugs, vulnerabilities, and code smells,
    combined with its comprehensive code metrics and seamless integration with CI/CD
    pipelines, makes it an invaluable asset for development teams. By incorporating
    SonarQube into the development process, teams can maintain high standards of software
    quality, reduce the risk of defects, and deliver reliable and secure software
    solutions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，SonarQube 是一个非常有用的静态代码分析（SCA）工具，能够持续检查代码质量。它检测错误、漏洞和代码异味的能力，再加上全面的代码指标和与
    CI/CD 流水线的无缝集成，使其成为开发团队不可或缺的资产。通过将 SonarQube 融入开发流程，团队可以保持高标准的软件质量，减少缺陷风险，并交付可靠且安全的软件解决方案。
- en: 'More information can be found at SonarQube’s site: [https://www.sonarsource.com/products/sonarqube/](https://www.sonarsource.com/products/sonarqube/)
    .'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请访问 SonarQube 官方网站：[https://www.sonarsource.com/products/sonarqube/](https://www.sonarsource.com/products/sonarqube/)。
- en: ESLint
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ESLint
- en: '**ESLint** is a static analysis tool specifically for JavaScript and JSX. (JSX
    is an XML-like extension for Javascript.) ESLint plays an important role in modern
    web development by helping developers keep to coding standards and identify problematic
    patterns in their code. This tool is helpful for maintaining code quality and
    consistency across projects, making it a favorite among developers working with
    JavaScript.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**ESLint** 是专门为 JavaScript 和 JSX 设计的静态分析工具。（JSX 是一种类似 XML 的 JavaScript 扩展。）ESLint
    在现代 Web 开发中扮演着重要角色，帮助开发人员遵循编码标准并识别代码中的问题模式。这个工具有助于在项目中保持代码质量和一致性，使它成为开发人员在处理 JavaScript
    时的最爱。'
- en: Like the code completion tools, ESLint has customizable rules. ESLint allows
    users to define their own rules and share configurations across teams, promoting
    consistency in coding practices. This flexibility ensures that teams can stick
    to their specific coding standards, no matter what the project’s requirements
    are. For instance, you can create rules that enforce the use of single quotes
    for strings or require semicolons at the end of statements. You can also specify
    indentation style, variable naming conventions, function length, and even code
    complexity. This level of customization helps maintain a uniform code style, which
    is particularly beneficial in large teams or open source projects where multiple
    contributors are involved.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 与代码自动补全工具类似，ESLint 具有可定制的规则。ESLint 允许用户定义自己的规则并在团队间共享配置，从而促进编码实践的一致性。这种灵活性确保团队可以遵循特定的编码标准，无论项目的要求如何。例如，你可以创建规则，强制使用单引号来表示字符串，或要求语句末尾必须有分号。你还可以指定缩进样式、变量命名约定、函数长度，甚至代码复杂度。这种定制化程度有助于维持统一的代码风格，特别适用于大型团队或开源项目，其中涉及多个贡献者。
- en: Another feature ESLint has is its easy integration with CI/CD pipelines. By
    integrating ESLint into the CI/CD process, developers can ensure that code quality
    checks are performed automatically before deployment. This integration helps catch
    issues early in the development cycle, reducing the risk of bugs and inconsistencies
    making it into production. Popular CI/CD tools, such as Jenkins, Travis CI, and
    GitHub Actions, support ESLint, making it easy to incorporate into existing workflows.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint 另一个特点是它能够轻松与 CI/CD 流水线集成。通过将 ESLint 集成到 CI/CD 流程中，开发人员可以确保在部署之前自动进行代码质量检查。这种集成有助于在开发周期的早期发现问题，从而减少了缺陷和不一致性进入生产环境的风险。流行的
    CI/CD 工具，如 Jenkins、Travis CI 和 GitHub Actions，都支持 ESLint，使其能够轻松融入现有的工作流。
- en: ESLint also offers robust fixing capabilities. Many of the issues detected by
    ESLint can be automatically fixed, saving you time and effort in your development.
    For example, if ESLint detects a missing semicolon or an incorrect quote style,
    it can automatically correct these issues based on the defined rules. This auto-fix
    feature is particularly useful for addressing minor code style violations, allowing
    developers to focus on more complex tasks.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint 还提供了强大的修复功能。ESLint 检测到的许多问题可以自动修复，从而节省开发人员的时间和精力。例如，如果 ESLint 检测到缺少分号或引号样式不正确，它可以根据定义的规则自动纠正这些问题。这个自动修复功能尤其适用于解决小的代码风格违规，允许开发人员将精力集中在更复杂的任务上。
- en: 'Using ESLint is straightforward. Developers can configure ESLint by creating
    a configuration file, typically named **.eslintrc.js** , which defines the environment,
    extends configurations, and specifies the rules. Here is an example of an ESLint
    configuration:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ESLint非常简单。开发人员可以通过创建一个配置文件（通常命名为**.eslintrc.js**），定义环境、扩展配置和指定规则来配置ESLint。以下是ESLint配置的示例：
- en: '[PRE10]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**env** : This specifies the environment in which the code will be run. In
    this case, it’s configured for both browser and ES6 environments.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**env**：这指定了代码将要运行的环境。在这种情况下，它配置了浏览器和ES6环境。'
- en: '**extends** : This setting extends the recommended ESLint ruleset, providing
    a good starting point for enforcing common coding standards.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**extends**：此设置扩展了推荐的ESLint规则集，为执行常见编码标准提供了一个良好的起点。'
- en: '**rules** : This section allows you to customize specific rules. Here, you’ve
    enforced the use of semicolons and single quotes.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rules**：这一部分允许您定制特定的规则。在这里，您已经强制使用了分号和单引号。'
- en: Despite its many advantages, ESLint does have some issues. One possible challenge
    is the initial setup. Configuring ESLint to fit a team’s specific needs requires
    lots of time, especially for new users who may find the extensive configuration
    options overwhelming. However, once set up, ESLint provides significant long-term
    benefits in terms of code quality and consistency.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管ESLint有许多优点，但也存在一些问题。一个可能的挑战是初始设置。配置ESLint以适应团队特定需求需要大量时间，尤其是对于可能觉得广泛的配置选项令人不知所措的新用户来说。然而，一旦设置完成，ESLint在代码质量和一致性方面提供了显著的长期利益。
- en: Another thing to think about is the learning curve associated with ESLint. While
    the tool is highly configurable, new users may need time to become familiar with
    its features and how to customize it effectively. Fortunately, ESLint has an active
    community that contributes to a wealth of plugins and shared configurations, providing
    ample resources and support for new users.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件需要考虑的事情是与ESLint相关联的学习曲线。虽然这个工具高度可配置，但新用户可能需要时间来熟悉其功能及如何有效地进行定制。幸运的是，ESLint有一个活跃的社区，为新用户提供了丰富的插件和共享配置，提供了充足的资源和支持。
- en: 'Here are some pros of using ESLint:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用ESLint的一些优点：
- en: '**Highly configurable** : ESLint’s flexibility allows teams to enforce their
    coding standards effectively'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高度可配置**：ESLint的灵活性允许团队有效地执行其编码标准。'
- en: '**Active community** : A large community contributes to a wealth of plugins
    and shared configurations'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活跃社区**：庞大的社区为插件和共享配置提供了丰富的贡献。'
- en: 'Here are some cons of using ESLint:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用ESLint的一些缺点：
- en: '**Setup time** : ESLint requires an initial investment of time to configure
    rules that fit a team’s needs.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Setup time**：ESLint需要一开始投入时间来配置符合团队需求的规则。'
- en: '**False positives** : Similar to some other tools in this chapter, ESLint may
    sometimes flag issues that are not actual errors or violations of coding standards;
    these are false positives. This can be frustrating and can mean you have to make
    extra code changes for no benefit.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**False positives**：与本章中的其他一些工具类似，ESLint有时可能会标记一些并非实际错误或违反编码标准的问题；这些是误报。这可能令人沮丧，并意味着您必须为无效的代码变更做出额外的更改。'
- en: ESLint can be restrictive, enforcing strict rules that may not always be appropriate
    for certain code styles or use cases.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ESLint可能会有一些限制，强制执行严格的规则，这些规则并不总是适合某些代码风格或使用情况。
- en: In conclusion, ESLint is a very helpful tool for JavaScript and JSX development.
    Its customizable rules, integration with CI/CD pipelines, and automatic fixing
    capabilities make it a powerful ally in sticking to high code quality and consistency.
    While it may require an initial investment of time to configure and a learning
    curve for new users, the benefits it offers in terms of productivity and code
    reliability make it well worth the effort. Whether you are working on a small
    project or a large-scale application, ESLint can help ensure that your code adheres
    to best practices and remains maintainable over time. As you may have seen in
    previous chapters, code standards can be rather stringent and detailed, so having
    tools to keep to these can be a great help.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，ESLint对JavaScript和JSX开发非常有帮助。它的可定制规则、与CI/CD流水线的集成以及自动修复能力使其成为坚持高代码质量和一致性的强大工具。虽然配置可能需要一开始投入时间和新用户需要一定的学习曲线，但它在提高生产力和代码可靠性方面提供的优势绝对是值得的。无论您是在开发小项目还是大型应用程序，ESLint都可以帮助确保您的代码遵循最佳实践并且随着时间的推移易于维护。正如您在之前章节中可能已经看到的，代码标准可能非常严格和详细，因此拥有工具来保持这些标准可以提供很大的帮助。
- en: 'More information can be found at ESLint’s official site: [https://eslint.org/](https://eslint.org/)
    .'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息可以在ESLint的官方网站找到：[https://eslint.org/](https://eslint.org/)。
- en: PMD
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PMD
- en: '**PMD** is an open source SCA tool that is helpful for developers to identify
    potential issues in their code. It supports a few programming languages, including
    Java, JavaScript, and XML (with some support for C, C++, C#, Python, and PHP).
    PMD is mainly for Java. It focuses on finding common programming flaws, such as
    unused variables, empty catch blocks, and unnecessary object creation. This makes
    PMD a great tool for maintaining high standards of code quality and ensuring that
    software is reliable and efficient, especially in Java.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**PMD**是一个开源的SCA工具，对于开发者识别代码中的潜在问题非常有帮助。它支持几种编程语言，包括Java、JavaScript和XML（并对C、C++、C#、Python和PHP有一些支持）。PMD主要用于Java，专注于发现常见的编程缺陷，如未使用的变量、空的catch块和不必要的对象创建。这使得PMD成为一个极好的工具，用于保持高标准的代码质量，确保软件的可靠性和效率，尤其是在Java开发中。'
- en: One of the features of PMD is its rule-based analysis. PMD uses a set of predefined
    rules to analyze code and identify potential issues. These rules cover a wide
    range of common programming mistakes and best practices, helping developers catch
    errors early in the development process. The predefined rules are comprehensive
    and cover various aspects of coding, from syntax errors to more complex logical
    issues. This thorough analysis helps in maintaining a clean and efficient code
    base.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: PMD的一个特点是基于规则的分析。PMD使用一组预定义规则来分析代码并识别潜在问题。这些规则涵盖了各种常见的编程错误和最佳实践，帮助开发者在开发过程中尽早发现错误。预定义的规则非常全面，涵盖了从语法错误到更复杂的逻辑问题等多个方面。这种彻底的分析有助于保持代码库的清晰和高效。
- en: In addition to its predefined rules, PMD allows you, as a developer, to create
    custom rules tailored to your desired coding standards and practices. This customizability
    is one of PMD’s best features, as it enables teams to enforce their unique coding
    guidelines and ensure consistency across projects. Custom rules can be written
    in Java or using XPath queries, providing flexibility in how they are defined
    and implemented. This ability to tailor the tool to specific needs makes PMD highly
    adaptable to different development environments and requirements.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 除了预定义的规则外，PMD还允许开发者创建自定义规则，以满足你期望的编码标准和实践。这种可定制性是PMD的最佳特点之一，因为它使团队能够强制执行独特的编码指南，并确保项目之间的一致性。自定义规则可以使用Java编写或通过XPath查询定义，这为定义和实现规则提供了灵活性。根据具体需求调整工具的能力使PMD能够高度适应不同的开发环境和需求。
- en: 'PMD also integrates with popular build tools, such as Maven and Gradle (the
    PMD Maven plugin is available at [https://github.com/apache/maven-pmd-plugin](https://github.com/apache/maven-pmd-plugin)
    and the PMD Gradle plugin is available at [https://docs.gradle.org/current/userguide/pmd_plugin.html](https://docs.gradle.org/current/userguide/pmd_plugin.html)
    ), making it easy to incorporate into existing workflows. This integration ensures
    that code quality checks are an integral part of the build process, providing
    continuous feedback to developers and preventing the introduction of new issues
    into the code base. By running PMD as part of the build process, teams can catch
    and address issues early, reducing the risk of defects in production. For example,
    to run PMD on a Java project using Maven, you would use the following command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: PMD还与流行的构建工具集成，如Maven和Gradle（PMD Maven插件可在[https://github.com/apache/maven-pmd-plugin](https://github.com/apache/maven-pmd-plugin)找到，PMD
    Gradle插件可在[https://docs.gradle.org/current/userguide/pmd_plugin.html](https://docs.gradle.org/current/userguide/pmd_plugin.html)找到），使其可以轻松融入现有的工作流中。这种集成确保了代码质量检查成为构建过程的一个组成部分，为开发者提供持续反馈，并防止将新问题引入代码库。通过将PMD作为构建过程的一部分运行，团队可以早期捕获并解决问题，降低生产环境中缺陷的风险。例如，要在使用Maven的Java项目上运行PMD，你可以使用以下命令：
- en: '[PRE11]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run this in bash. This command triggers PMD to analyze the project and generate
    a report on any issues found, allowing developers to review and address them promptly.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在bash中运行此命令。此命令触发PMD分析项目并生成关于发现问题的报告，允许开发者及时审查并解决这些问题。
- en: Despite its many advantages, PMD does have some limitations. One potential thing
    is its limited language support. While PMD supports several languages, its primary
    focus is on Java, which may not suit all projects. This can be a limitation for
    teams working with a diverse set of programming languages. However, PMD does support
    other languages, such as JavaScript, Salesforce Apex, and more, which can still
    be beneficial for many projects.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 PMD 有许多优点，但也存在一些局限性。一个潜在的问题是它有限的语言支持。虽然 PMD 支持几种语言，但它的主要关注点是 Java，这可能不适合所有项目。这对于使用多种编程语言的团队来说可能是一个限制。然而，PMD
    也支持其他语言，如 JavaScript、Salesforce Apex 等，这对于许多项目仍然有很大的帮助。
- en: Another consideration is the complexity of configuring PMD with custom rules.
    Setting up PMD to enforce specific coding standards can be complex, especially
    for new users who may not be familiar with the tool’s configuration options. This
    is similar to some other tools in this chapter. This initial setup requires an
    investment of time and effort, but the long-term benefits of having a tailored
    static analysis tool can be significant. You’ll most likely find that the one-time
    time investment is really worth it for all the repeated help every day.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的因素是为 PMD 配置自定义规则的复杂性。设置 PMD 来强制执行特定的编码标准可能比较复杂，特别是对于那些不熟悉该工具配置选项的新用户来说。这与本章中的其他一些工具类似。这一初步设置需要投入时间和精力，但长期来看，拥有一个量身定制的静态分析工具是非常值得的。你会发现，这一度过的时间投资真的为每天的反复帮助带来了很大的回报。
- en: 'Here are some pros of using PMD:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用 PMD 的一些优点：
- en: PMD is free to use, making it accessible for developers and teams of all sizes
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PMD 是免费的，因此适用于各种规模的开发人员和团队
- en: The ability to create custom rules allows teams to enforce their specific coding
    standards
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义规则的能力使团队能够强制执行特定的编码标准
- en: 'Here are some cons of using PMD:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用 PMD 的一些缺点：
- en: While PMD supports several languages, its primary focus is on Java, which may
    not suit all projects
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管 PMD 支持多种语言，但它的主要关注点是 Java，这可能不适用于所有项目
- en: Setting up PMD with custom rules can be complex for new users
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 PMD 配置自定义规则对新用户来说可能比较复杂
- en: In conclusion, PMD is a SCA tool for Java and other languages that helps developers
    maintain high standards of code quality. Its rule-based analysis, customizability,
    and integration with build tools make it a good tool for many development teams.
    While it may have some limitations in terms of language support and configuration
    complexity, the benefits it offers in terms of identifying potential issues and
    enforcing coding standards make it a valuable asset in the software development
    process. By incorporating PMD into their workflows, your teams can ensure that
    your code is reliable, efficient, and adheres to best practices, ultimately leading
    to higher-quality software.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，PMD 是一个适用于 Java 和其他语言的 SCA 工具，帮助开发人员保持高标准的代码质量。它基于规则的分析、可定制性以及与构建工具的集成使它成为许多开发团队的良好工具。虽然它在语言支持和配置复杂性方面可能存在一些限制，但在发现潜在问题和执行编码标准方面所带来的好处，使其成为软件开发过程中宝贵的工具。通过将
    PMD 融入团队的工作流程，您可以确保代码可靠、高效，并符合最佳实践，最终带来更高质量的软件。
- en: 'More information can be found at PMD’s site: [https://pmd.github.io/](https://pmd.github.io/)
    .'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息可以在 PMD 的网站找到：[https://pmd.github.io/](https://pmd.github.io/)。
- en: Checkstyle for Java
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java 的 Checkstyle
- en: As we’ve already gone through a few tools, I shall make this brief.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经讲解了一些工具，我会简要说明。
- en: '**Checkstyle** is a valuable tool for ensuring Java code adheres to predefined
    coding standards. By automating code checks, it maintains consistency and quality
    across projects, making code easier to read, understand, and maintain.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**Checkstyle** 是一个非常有价值的工具，确保 Java 代码遵循预定义的编码标准。通过自动化代码检查，它保持项目的一致性和质量，使代码更容易阅读、理解和维护。'
- en: 'Here are some of its key features:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是它的一些关键特性：
- en: It checks code against customizable rules for naming conventions, formatting,
    design patterns, and more
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它根据可定制的规则检查代码，包括命名规范、格式化、设计模式等
- en: It seamlessly integrates with Eclipse and IntelliJ IDEA for real-time feedback
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与 Eclipse 和 IntelliJ IDEA 无缝集成，提供实时反馈
- en: It allows you to define your own rules to match specific coding practices
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许你定义自己的规则，以匹配特定的编码实践
- en: 'This is how it works:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作原理如下：
- en: Configure Checkstyle in your build tool (e.g., Maven, Gradle) to specify your
    desired ruleset.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建工具中配置 Checkstyle（例如 Maven、Gradle），以指定所需的规则集。
- en: Checkstyle analyzes your Java code against these rules.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Checkstyle 会根据这些规则分析你的 Java 代码。
- en: It generates reports highlighting violations and provides suggestions for improvement.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它生成报告，突出显示违规项，并提供改进建议。
- en: Here is an example (Maven).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例（Maven）。
- en: 'This is XML code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 XML 代码：
- en: '[PRE12]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here are some of the pros of using Checkstyle:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用 Checkstyle 的一些优点：
- en: '**Focus on Java** : Checkstyle is specifically designed for Java, making it
    highly effective for Java projects'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**专注于 Java**：Checkstyle 专门为 Java 设计，使其在 Java 项目中非常有效'
- en: '**Real-time feedback** : Integration with IDEs allows developers to receive
    immediate feedback on coding standards'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时反馈**：与 IDE 的集成使开发人员能够立即获得编码标准的反馈'
- en: 'Here are some of the cons of using Checkstyle:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用 Checkstyle 的一些缺点：
- en: '**Java only** : Checkstyle is limited to Java, which may not be suitable for
    multi-language projects'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅限 Java**：Checkstyle 仅限于 Java，可能不适用于多语言项目'
- en: '**Configuration overhead** : Setting up and maintaining Checkstyle configurations
    can be time-consuming'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置开销**：设置和维护 Checkstyle 配置可能会耗费大量时间'
- en: By using Checkstyle, you can ensure your Java code meets high-quality standards,
    promoting readability, maintainability, and team collaboration.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 Checkstyle，您可以确保您的 Java 代码符合高质量标准，促进可读性、可维护性和团队协作。
- en: '**Source** : [https://github.com/jvalentino/jenkins-agent-maven](https://github.com/jvalentino/jenkins-agent-maven)
    .'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**来源**：[https://github.com/jvalentino/jenkins-agent-maven](https://github.com/jvalentino/jenkins-agent-maven)。'
- en: 'You can find more information here: [https://checkstyle.sourceforge.io/](https://checkstyle.sourceforge.io/)
    .'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到更多信息：[https://checkstyle.sourceforge.io/](https://checkstyle.sourceforge.io/)。
- en: Fortify Static Code Analyzer
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fortify 静态代码分析器
- en: '**Fortify** , developed by OpenText, is a commercial static analysis tool that
    excels at identifying security vulnerabilities in source code. It supports a wide
    range of programming languages, making it a versatile choice for diverse development
    teams.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fortify**，由 OpenText 开发，是一个商业静态分析工具，擅长识别源代码中的安全漏洞。它支持多种编程语言，是多元化开发团队的理想选择。'
- en: 'Here are some key features of Fortify:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 Fortify 的一些关键特性：
- en: Fortify’s deep analysis capabilities uncover a broad spectrum of security risks
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fortify 的深度分析能力揭示了广泛的安全风险
- en: You can generate actionable reports with remediation guidance to address identified
    vulnerabilities effectively
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以生成具有修复指导的可操作报告，有效解决已识别的漏洞
- en: You can integrate Fortify into your CI/CD pipeline for continuous security checks
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将 Fortify 集成到 CI/CD 流水线中，进行持续的安全检查
- en: 'This is how it works:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的工作方式：
- en: Run Fortify on your code to identify vulnerabilities.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码上运行 Fortify，以识别漏洞。
- en: Review detailed reports for insights and remediation guidance.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看详细报告，获取见解和修复指导。
- en: Integrate Fortify into your development workflow for continuous security checks.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Fortify 集成到您的开发工作流中，以便进行持续的安全检查。
- en: 'Here are some pros of using Fortify:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用 Fortify 的一些优点：
- en: It is ideal for large-scale projects and organizations
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它非常适合大型项目和组织
- en: It detects a wide range of vulnerabilities
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它能够检测各种漏洞
- en: It provides clear guidance for remediation
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了清晰的修复指导
- en: 'Here are some cons of using Fortify:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用 Fortify 的一些缺点：
- en: It requires a commercial license
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要商业许可证
- en: Initial setup and configuration can be involved
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始设置和配置可能比较复杂
- en: In conclusion, Fortify is a valuable tool for organizations looking to strengthen
    their software security posture. While it requires an investment, the benefits
    in terms of vulnerability detection and risk mitigation can be substantial. By
    incorporating Fortify into your development process, you can ensure that your
    code meets the highest security standards.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，Fortify 是一个对那些希望加强软件安全性的组织非常有价值的工具。尽管它需要一定的投资，但在漏洞检测和风险缓解方面的收益是巨大的。通过将 Fortify
    纳入您的开发过程，您可以确保您的代码符合最高的安全标准。
- en: 'Fortify’s official site gives more information: [https://www.microfocus.com/en-us/products/static-code-analysis-sast/overview](https://www.microfocus.com/en-us/products/static-code-analysis-sast/overview)
    .'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Fortify 的官方网站提供更多信息：[https://www.microfocus.com/en-us/products/static-code-analysis-sast/overview](https://www.microfocus.com/en-us/products/static-code-analysis-sast/overview)。
- en: 'Here are some more sources:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是更多来源：
- en: '[https://www.microfocus.com/documentation/fortify-static-code-analyzer-and-tools/2310/](https://www.microfocus.com/documentation/fortify-static-code-analyzer-and-tools/2310/)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.microfocus.com/documentation/fortify-static-code-analyzer-and-tools/2310/](https://www.microfocus.com/documentation/fortify-static-code-analyzer-and-tools/2310/)'
- en: '[https://www.opentext.com/products/fortify-static-code-analyzer](https://www.opentext.com/products/fortify-static-code-analyzer)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.opentext.com/products/fortify-static-code-analyzer](https://www.opentext.com/products/fortify-static-code-analyzer)'
- en: '[https://bing.com/search?q=Fortify+Static+Code+Analyzer+summary](https://bing.com/search?q=Fortify+Static+Code+Analyzer+summary)'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://bing.com/search?q=Fortify+Static+Code+Analyzer+summary](https://bing.com/search?q=Fortify+Static+Code+Analyzer+summary)'
- en: '[https://www.microfocus.com/media/data-sheet/fortify_static_code_analyzer_static_application_security_testing_ds.pdf](https://www.microfocus.com/media/data-sheet/fortify_static_code_analyzer_static_application_security_testing_ds.pdf)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.microfocus.com/media/data-sheet/fortify_static_code_analyzer_static_application_security_testing_ds.pdf](https://www.microfocus.com/media/data-sheet/fortify_static_code_analyzer_static_application_security_testing_ds.pdf)'
- en: '[https://gemini.google.com/](https://gemini.google.com/)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://gemini.google.com/](https://gemini.google.com/)'
- en: '[https://copilot.microsoft.com/](https://copilot.microsoft.com/)'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://copilot.microsoft.com/](https://copilot.microsoft.com/)'
- en: CodeSonar
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CodeSonar
- en: '**CodeSonar** , a static analysis tool from GrammaTech, also called a **static
    application security testing** ( **SAST** ) tool, is an excellent tool for ensuring
    code quality and safety, especially in critical industries, such as automotive,
    aerospace, and medical devices.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**CodeSonar**，由GrammaTech提供的静态分析工具，也被称为**静态应用程序安全测试**（**SAST**）工具，是确保代码质量和安全的优秀工具，尤其在汽车、航空航天和医疗设备等关键行业中。'
- en: 'Here are some of its key features:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是它的一些关键特性：
- en: It uncovers a wide range of issues, from memory leaks to concurrency problems
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它能发现广泛的问题，从内存泄漏到并发问题
- en: It works smoothly with popular IDEs and build systems
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与流行的IDE和构建系统配合良好
- en: It helps you understand complex code structures with visual aids
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它帮助你通过可视化工具理解复杂的代码结构
- en: 'This is how it works:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 其工作原理如下：
- en: CodeSonar scans your code for potential issues.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CodeSonar扫描你的代码，查找潜在问题。
- en: Detailed reports highlight vulnerabilities and provide insights.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 详细报告突出显示漏洞并提供洞察。
- en: Easily integrate CodeSonar into your development workflow.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 轻松将CodeSonar集成到你的开发工作流中。
- en: 'Here are the pros of using CodeSonar:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用CodeSonar的优点：
- en: It catches bugs before they become costly problems
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在问题变得代价高昂之前就能捕捉到错误
- en: It ensures high-quality, safe code
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它确保代码质量和安全性
- en: It understands your code’s structure and dependencies
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它理解你的代码结构和依赖关系
- en: 'Here are the cons of using CodeSonar:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用CodeSonar的缺点：
- en: It may require a license
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能需要许可证
- en: It can take time to master its features
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能需要一些时间来掌握其功能
- en: The initial setup might require effort
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始设置可能需要一些努力
- en: In conclusion, CodeSonar is a valuable tool for maintaining code quality and
    safety. While it may have a learning curve and require an investment, the benefits
    it offers in terms of preventing costly errors and ensuring reliable software
    make it a worthwhile consideration for many development teams.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，CodeSonar是维护代码质量和安全的宝贵工具。尽管它可能有一定的学习曲线并需要投资，但它在防止代价高昂的错误和确保可靠软件方面所提供的好处，使得它成为许多开发团队值得考虑的工具。
- en: 'Learn more about it at CodeSonar’s site: https://codesecure.com/our-products/codesonar/
    .'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多信息，请访问CodeSonar网站：[https://codesecure.com/our-products/codesonar/](https://codesecure.com/our-products/codesonar/)。
- en: Coverity
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Coverity
- en: '**Coverity** , by Synopsys, is a static analysis tool that empowers development
    teams in enterprise environments to identify and fix defects early in the software
    development life cycle.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**Coverity**，由Synopsys提供，是一款静态分析工具，它帮助企业环境中的开发团队在软件开发生命周期的早期识别并修复缺陷。'
- en: 'Here are its key features:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是它的主要功能：
- en: Coverity scans code for a wide range of issues, providing detailed reports and
    remediation guidance
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Coverity扫描代码，查找各种问题，提供详细的报告和修复建议
- en: It integrates seamlessly with popular CI/CD tools for automated code quality
    checks
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与流行的CI/CD工具无缝集成，进行自动化的代码质量检查
- en: You can monitor code health metrics and track progress over time with customizable
    dashboards
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过可定制的仪表板监控代码健康指标，并跟踪进展
- en: 'Here are the pros of using Coverity:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用Coverity的优点：
- en: It proactively detects defects and vulnerabilities, strengthening code health
    and security
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它主动检测缺陷和漏洞，增强代码健康和安全性
- en: It catches issues early, reducing costly bug fixes later in the development
    process
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它早期发现问题，减少后期开发过程中代价高昂的漏洞修复
- en: You can gain insights into code quality through customizable dashboards
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过可定制的仪表板了解代码质量
- en: 'Here are the cons of using Coverity:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用Coverity的缺点：
- en: It requires a commercial license, which may not be feasible for small teams
    or individual developers
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要商业许可证，对于小团队或个人开发者来说，可能不太可行
- en: The initial setup can be complex and require dedicated resources
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始设置可能比较复杂，并需要专门的资源
- en: Extensive features and configuration options have a learning curve for new users
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丰富的功能和配置选项对新用户来说有一定的学习曲线
- en: In conclusion, for large-scale projects, Coverity’s comprehensive defect detection,
    CI/CD integration, and customizable dashboards make it a valuable tool for maintaining
    high code quality and security. While there’s a cost and learning curve, the long-term
    benefits outweigh them for many development teams.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，对于大型项目，Coverity 的全面缺陷检测、CI/CD 集成和可定制的仪表盘使其成为维护高质量和高安全性代码的宝贵工具。尽管它有一定的费用和学习曲线，但对于许多开发团队来说，其长期利益远远超过这些成本。
- en: Popular CI/CD tools, such as Jenkins ( [https://www.devopsschool.com/blog/what-is-coverity-and-how-it-works-an-overview-and-its-use-cases/](https://www.devopsschool.com/blog/what-is-coverity-and-how-it-works-an-overview-and-its-use-cases/)
    ), GitLab, and Azure DevOps, support Coverity, making it easy to integrate into
    existing development processes.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的 CI/CD 工具，如 Jenkins（[https://www.devopsschool.com/blog/what-is-coverity-and-how-it-works-an-overview-and-its-use-cases/](https://www.devopsschool.com/blog/what-is-coverity-and-how-it-works-an-overview-and-its-use-cases/)）、GitLab
    和 Azure DevOps，支持 Coverity，这使得它可以轻松地集成到现有的开发流程中。
- en: 'See the Coverity site for more information: [https://www.synopsys.com/software-integrity/security-testing/static-analysis-sast.html](https://www.synopsys.com/software-integrity/security-testing/static-analysis-sast.html)
    .'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请参见 Coverity 网站：[https://www.synopsys.com/software-integrity/security-testing/static-analysis-sast.html](https://www.synopsys.com/software-integrity/security-testing/static-analysis-sast.html)。
- en: 'Here are the sources: [https://www.devopsschool.com/blog/what-is-coverity-and-how-it-works-an-overview-and-its-use-cases/](https://www.devopsschool.com/blog/what-is-coverity-and-how-it-works-an-overview-and-its-use-cases/)
    , [https://www.trustradius.com/products/synopsys-coverity-static-application-security-testing-sast/reviews?qs=pros-and-cons](https://www.trustradius.com/products/synopsys-coverity-static-application-security-testing-sast/reviews?qs=pros-and-cons)
    , [https://www.gartner.com/reviews/market/application-security-testing/vendor/synopsys/product/coverity-static-application-security-testing](https://www.gartner.com/reviews/market/application-security-testing/vendor/synopsys/product/coverity-static-application-security-testing)
    , [https://stackshare.io/coverity-scan](https://stackshare.io/coverity-scan) ,
    [https://www.softwareadvice.com/app-development/coverity-static-analysis-profile/](https://www.softwareadvice.com/app-development/coverity-static-analysis-profile/)
    , [https://en.wikipedia.org/wiki/Coverity](https://en.wikipedia.org/wiki/Coverity)
    , [https://gemini.google.com/](https://gemini.google.com/) , [https://copilot.microsoft.com/](https://copilot.microsoft.com/)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是来源：[https://www.devopsschool.com/blog/what-is-coverity-and-how-it-works-an-overview-and-its-use-cases/](https://www.devopsschool.com/blog/what-is-coverity-and-how-it-works-an-overview-and-its-use-cases/)，[https://www.trustradius.com/products/synopsys-coverity-static-application-security-testing-sast/reviews?qs=pros-and-cons](https://www.trustradius.com/products/synopsys-coverity-static-application-security-testing-sast/reviews?qs=pros-and-cons)，[https://www.gartner.com/reviews/market/application-security-testing/vendor/synopsys/product/coverity-static-application-security-testing](https://www.gartner.com/reviews/market/application-security-testing/vendor/synopsys/product/coverity-static-application-security-testing)，[https://stackshare.io/coverity-scan](https://stackshare.io/coverity-scan)，[https://www.softwareadvice.com/app-development/coverity-static-analysis-profile/](https://www.softwareadvice.com/app-development/coverity-static-analysis-profile/)，[https://en.wikipedia.org/wiki/Coverity](https://en.wikipedia.org/wiki/Coverity)，[https://gemini.google.com/](https://gemini.google.com/)，[https://copilot.microsoft.com/](https://copilot.microsoft.com/)
- en: FindBugs/SpotBugs
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FindBugs/SpotBugs
- en: '**SpotBugs** , which succeeded FindBugs, is a specialized static analysis tool
    designed for Java that excels at detecting potential bugs in Java code. By leveraging
    a comprehensive set of bug patterns, it identifies common coding mistakes, ensuring
    higher code quality and reliability. SpotBugs operates by analyzing Java bytecode,
    which allows it to uncover potential issues based on a predefined set of patterns.
    This method of analysis is particularly effective in pinpointing bugs that might
    not be immediately apparent through manual code reviews.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**SpotBugs**，继承了 FindBugs，是一款专门为 Java 设计的静态分析工具，擅长检测 Java 代码中的潜在 bug。通过利用一整套
    bug 模式，它能够识别常见的编码错误，从而确保代码质量和可靠性更高。SpotBugs 通过分析 Java 字节码来工作，这使得它能够根据预定义的模式发现潜在问题。这种分析方法特别有效于发现那些通过手动代码审查可能不容易察觉的
    bug。'
- en: One of the best features of SpotBugs is its great integration with popular build
    tools, such as Maven and Gradle. This integration facilitates its inclusion in
    existing development workflows, making it a convenient choice for CI/CD pipelines.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: SpotBugs 的一大优势是与流行构建工具（如 Maven 和 Gradle）的良好集成。这种集成使它能轻松地融入现有的开发工作流程，成为 CI/CD
    管道中的便捷选择。
- en: SpotBugs is known for its user-friendly setup and ease of use, which makes it
    accessible to developers of all skill levels. Whether you are a novice developer
    or an experienced professional, SpotBugs provides a straightforward way to enhance
    your code’s robustness. Its ability to integrate smoothly into various development
    environments and its ease of use make it a valuable tool for maintaining high
    standards of code quality in Java projects.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: SpotBugs 以其用户友好的设置和易用性而著称，适合各种技能水平的开发者。无论你是初学者还是经验丰富的专业人士，SpotBugs 都能提供一个简单的方式来增强代码的健壮性。它能够平滑地集成到各种开发环境中，且易于使用，是维护
    Java 项目代码质量高标准的宝贵工具。
- en: 'For example, run this in bash:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 bash 中运行以下命令：
- en: '[PRE13]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here are the pros of using SpotBugs:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用 SpotBugs 的优点：
- en: '**Free and open source** : SpotBugs is free to use, making it accessible for
    developers and teams'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**免费且开源**：SpotBugs 免费使用，开发者和团队可以轻松访问。'
- en: '**Focus on Java** : Its specialization in Java means it provides highly relevant
    analyses for Java projects'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**专注于 Java**：它在 Java 方面的专长意味着它为 Java 项目提供高度相关的分析。'
- en: 'Here are the cons of using SpotBugs:'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是使用 SpotBugs 的缺点：
- en: '**Limited language support** : SpotBugs is specifically for Java, which may
    limit its usability for multi-language projects.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言支持有限**：SpotBugs 专门用于 Java，这可能会限制其在多语言项目中的可用性。'
- en: '**False positives** : Like many static analysis tools, it can produce false
    positives that require manual review.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**误报**：像许多静态分析工具一样，它可能会产生误报，需要手动审核。'
- en: In conclusion, SpotBugs is a static analysis tool for Java developers, offering
    a robust solution for identifying and rectifying potential bugs. Its ease of integration
    with build tools and user-friendly setup make it accessible to developers at all
    levels, ensuring that high standards of code quality are maintained across projects.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总之，SpotBugs 是一个静态分析工具，专为 Java 开发者设计，提供了一个强大的解决方案来识别和修复潜在的错误。它与构建工具的便捷集成和用户友好的设置，使得各级开发者都能轻松使用，从而确保项目中代码质量的高标准。
- en: 'More information can be found on the SpotBugs site: [https://spotbugs.github.io/](https://spotbugs.github.io/)
    .'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多信息请访问 SpotBugs 网站：[https://spotbugs.github.io/](https://spotbugs.github.io/)。
- en: Bandit
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bandit
- en: '**Bandit** is an SCA, or rather a SAST, tool that helps you identify security
    vulnerabilities in Python code. It scans for common issues, such as hardcoded
    passwords and insecure API usage, ensuring your Python applications remain secure.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bandit** 是一个 SCA，或者说是一个 SAST 工具，帮助你识别 Python 代码中的安全漏洞。它扫描常见问题，如硬编码密码和不安全的
    API 使用，确保你的 Python 应用程序保持安全。'
- en: 'Here are its key features:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 其主要特点如下：
- en: '**Comprehensive vulnerability detection** : It identifies a wide range of security
    risks'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全面的漏洞检测**：它可以识别多种安全风险。'
- en: '**Customizable rules** : Tailor Bandit to your specific needs'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可定制规则**：根据你的具体需求定制 Bandit。'
- en: '**CI/CD integration** : Automate security checks for continuous monitoring'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CI/CD 集成**：自动化安全检查，实现持续监控。'
- en: 'For a usage example, run this in bash:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 使用示例，在 bash 中运行以下命令：
- en: '[PRE14]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here are the pros of using Bandit:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用 Bandit 的优点：
- en: '**Python-specific** : Bandit is tailored for Python, making it highly effective
    for identifying security issues in Python code'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**专为 Python 设计**：Bandit 专门为 Python 量身定制，因此在识别 Python 代码中的安全问题方面非常有效。'
- en: '**Open source** : As an open source tool, Bandit is free to use and accessible
    to all developers'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开源**：作为一个开源工具，Bandit 可以免费使用，任何开发者都可以访问。'
- en: 'Here are the cons of using Bandit:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用 Bandit 的缺点：
- en: '**Limited to Python** : Bandit is specifically designed for Python, so it may
    not be suitable for projects that use multiple languages'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅限 Python**：Bandit 专门为 Python 设计，因此可能不适用于使用多种语言的项目。'
- en: '**False positives** : Like many static analysis tools, Bandit can generate
    false positives that require manual review'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**误报**：像许多静态分析工具一样，Bandit 也可能生成误报，需要手动审核。'
- en: In conclusion, Bandit is a valuable tool for Python developers focused on security.
    Its ability to detect a wide range of security vulnerabilities, coupled with customizable
    rules and seamless CI/CD integration, makes it an essential asset for maintaining
    secure code bases. By incorporating Bandit into their development workflows, developers
    can proactively address security risks and ensure that their applications remain
    secure against potential threats.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，Bandit是针对安全性关注的Python开发者的宝贵工具。它能够检测多种安全漏洞，再加上可定制的规则和无缝的CI/CD集成，使其成为维护安全代码库的重要资产。通过将Bandit纳入开发工作流，开发者可以主动应对安全风险，确保他们的应用程序在潜在威胁面前保持安全。
- en: 'Check out Bandit’s site: [https://bandit.readthedocs.io/](https://bandit.readthedocs.io/)
    .'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Bandit的网站：[https://bandit.readthedocs.io/](https://bandit.readthedocs.io/)
    。
- en: HoundCI
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HoundCI
- en: '**HoundCI** is a GitHub-integrated tool that enforces code quality standards.
    It provides real-time feedback on pull requests, ensuring clean, consistent code.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**HoundCI** 是一个与GitHub集成的工具，用于执行代码质量标准。它为拉取请求提供实时反馈，确保代码干净、一致。'
- en: 'Here are its key features:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是它的关键功能：
- en: It identifies style violations and issues during pull requests
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在拉取请求过程中识别风格违规和问题
- en: It tailors HoundCI to your specific coding standards
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它根据您的特定编码标准定制HoundCI
- en: It works with various programming languages
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持多种编程语言
- en: 'Here are the pros of using HoundCI:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用HoundCI的优点：
- en: HoundCI provides immediate feedback on code style issues, helping teams maintain
    consistent coding practices
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HoundCI为代码风格问题提供即时反馈，帮助团队保持一致的编码实践
- en: The seamless integration with GitHub makes it easy to incorporate into existing
    workflows
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与GitHub的无缝集成使得它容易融入现有工作流
- en: 'Here are the cons of using HoundCI:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用HoundCI的缺点：
- en: HoundCI focuses primarily on style and best practices, which may not cover deeper
    static analysis needs
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HoundCI主要关注风格和最佳实践，可能无法覆盖更深层次的静态分析需求
- en: It is specifically designed for GitHub repositories, limiting its usability
    for teams using other version control systems
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它专为GitHub仓库设计，限制了其在使用其他版本控制系统的团队中的可用性
- en: 'See more at HoundCI’s official site: [https://houndci.com/](https://houndci.com/)
    .'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 访问HoundCI的官方网站，了解更多：[https://houndci.com/](https://houndci.com/) 。
- en: 'Here are the sources: [https://github.com/houndci/hound](https://github.com/houndci/hound)
    , [https://github.com/marketplace/hound](https://github.com/marketplace/hound)
    , [https://www.houndci.com/configuration](https://www.houndci.com/configuration)'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相关链接：[https://github.com/houndci/hound](https://github.com/houndci/hound)
    , [https://github.com/marketplace/hound](https://github.com/marketplace/hound)
    , [https://www.houndci.com/configuration](https://www.houndci.com/configuration)
- en: Next, we’ll look at testing and debugging tools. Testing and debugging tools
    are also essential for ensuring the quality and reliability of software. They
    help identify and fix errors early in the development process, preventing potential
    issues from affecting end users and saving time and resources.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看测试和调试工具。测试和调试工具对于确保软件质量和可靠性也至关重要。它们帮助在开发过程中尽早识别和修复错误，防止潜在问题影响最终用户，节省时间和资源。
- en: Testing and debugging tools
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和调试工具
- en: Testing and debugging tools are also critical components in the software development
    life cycle, ensuring that code functions correctly and meets quality standards.
    These tools help identify issues early in the development process, ultimately
    saving time and resources by addressing potential problems before they escalate.
    In this section, we will explore various testing and debugging tools and their
    features, advantages, and limitations, with a focus on how they can enhance your
    development workflow.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 测试和调试工具是软件开发生命周期中的关键组成部分，确保代码正确运行并符合质量标准。这些工具帮助在开发过程中尽早识别问题，通过在问题升级之前解决潜在问题，最终节省时间和资源。在本节中，我们将探讨各种测试和调试工具及其特性、优点和限制，并重点介绍它们如何提升您的开发工作流程。
- en: Jest
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jest
- en: '**Jest** is a widely used testing framework developed by Christoph Nakazawa,
    now Meta, but is an open source project with many developers. It’s particularly
    popular among JavaScript developers. It provides a comprehensive testing solution
    for JavaScript applications, focusing on simplicity and ease of use. Jest is especially
    favored for testing React applications, but it can also be used with other frameworks
    and libraries.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jest** 是一个由 Christoph Nakazawa 开发的广泛使用的测试框架，现为 Meta 所有，但它是一个开源项目，拥有许多开发者。它在
    JavaScript 开发者中尤其流行，提供了一个全面的 JavaScript 应用测试解决方案，注重简洁性和易用性。Jest 特别适用于测试 React
    应用，但也可以与其他框架和库一起使用。'
- en: One good feature of Jest is its snapshot testing capability. This allows developers
    to capture snapshots of component output, making it easy to verify that changes
    to the code do not introduce unintended side effects. When a component renders,
    Jest compares the output to a previously saved snapshot. If there are differences,
    Jest alerts the developer, enabling them to review the changes and ensure everything
    is functioning as expected. Jest also comes equipped with robust mocking capabilities,
    which allow developers to isolate components during testing. This is particularly
    useful when testing components that rely on external services or APIs. By mocking
    these dependencies, developers can focus on testing the component’s logic without
    concerning themselves with the behavior of external resources.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 的一个优点是其快照测试功能。这允许开发者捕捉组件输出的快照，方便验证代码的更改不会引入意外的副作用。当组件渲染时，Jest 会将输出与先前保存的快照进行比较。如果有差异，Jest
    会提醒开发者，便于他们回顾更改并确保一切按预期工作。Jest 还具备强大的模拟功能，允许开发者在测试过程中隔离组件。这在测试依赖外部服务或 API 的组件时特别有用。通过模拟这些依赖，开发者可以专注于测试组件的逻辑，而不必担心外部资源的行为。
- en: 'Here is an example with JavaScript code:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个包含 JavaScript 代码的示例：
- en: '[PRE15]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: While Jest is a powerful tool, it is essential to recognize that it may not
    be suitable for every testing scenario. For instance, in complex applications
    that require more specialized testing strategies, such as end-to-end testing or
    performance testing, developers may need to complement Jest with additional tools
    designed specifically for those purposes.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Jest 是一个强大的工具，但需要认识到，它可能并不适用于每一种测试场景。例如，在需要更专业测试策略的复杂应用中，比如端到端测试或性能测试，开发者可能需要结合使用专门为这些目的设计的其他工具。
- en: 'Nonetheless, Jest stands out as an excellent framework for unit and integration
    testing, helping developers maintain high-quality code throughout their projects.
    If you’d like more details and resources, you can visit Jest’s official site:
    [https://jestjs.io/](https://jestjs.io/) .'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，Jest 作为一个出色的单元和集成测试框架，帮助开发者在整个项目中维护高质量的代码。如果你想了解更多细节和资源，可以访问 Jest 的官方网站：[https://jestjs.io/](https://jestjs.io/)。
- en: Postman
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Postman
- en: '**Postman** is a leading tool for testing APIs, providing developers with a
    user-friendly interface to send requests and analyze responses. It simplifies
    the process of interacting with APIs, making it accessible for both seasoned developers
    and newcomers alike.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '**Postman** 是一个领先的 API 测试工具，提供了一个用户友好的界面，用于发送请求和分析响应。它简化了与 API 交互的过程，使得无论是资深开发者还是新手都能轻松使用。'
- en: One of Postman’s key features is its ability to create automated tests. Users
    can write test scripts that run automatically after sending requests, verifying
    that the API behaves as expected. This feature is invaluable for ensuring that
    API endpoints return the correct status codes, headers, and response bodies. By
    automating these tests, developers can quickly identify issues and maintain the
    integrity of their APIs as they evolve.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Postman 的一个关键特点是它能够创建自动化测试。用户可以编写测试脚本，在发送请求后自动运行，验证 API 是否按预期行为返回。这一功能对于确保 API
    端点返回正确的状态码、头部和响应体非常宝贵。通过自动化这些测试，开发者可以快速识别问题，并在 API 演变过程中保持其完整性。
- en: Postman also offers a collection runner, which allows users to group requests
    into collections and execute them in sequence. This is particularly useful for
    testing workflows that involve multiple API calls. For example, if an application
    requires a user to be authenticated before accessing certain endpoints, a developer
    can create a collection that first sends a login request and then proceeds to
    call protected endpoints. This sequential testing capability helps simulate real-world
    scenarios and ensures that the entire flow works as intended.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Postman 还提供了一个集合运行器，允许用户将请求组织成集合并按顺序执行。这对于涉及多个 API 调用的工作流测试特别有用。例如，如果一个应用要求用户在访问某些端点之前进行身份验证，开发者可以创建一个集合，首先发送登录请求，然后继续调用受保护的端点。这种顺序测试功能有助于模拟现实场景，确保整个流程按预期工作。
- en: 'Here is an example in JavaScript:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个 JavaScript 示例：
- en: '[PRE16]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Although Postman is feature-rich and widely regarded as an essential tool for
    API testing, it does come with a learning curve for those unfamiliar with API
    testing concepts. New users may need time to familiarize themselves with Postman’s
    interface and capabilities, but the investment is often well worth it.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Postman 功能丰富且被广泛认为是 API 测试的必备工具，但对于那些不熟悉 API 测试概念的人来说，它有一定的学习曲线。新用户可能需要一些时间来熟悉
    Postman 的界面和功能，但这笔投资通常是值得的。
- en: 'As a tool that supports collaboration among development teams, Postman enhances
    communication and streamlines the process of API development and testing. You
    can visit Postman’s official site for more information: [https://www.postman.com/](https://www.postman.com/)
    .'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 作为支持开发团队协作的工具，Postman 增强了沟通并简化了 API 开发和测试的流程。你可以访问 Postman 的官方网站了解更多信息：[https://www.postman.com/](https://www.postman.com/)
    。
- en: Cypress
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cypress
- en: '**Cypress** is an end-to-end testing framework designed specifically for modern
    web applications. It provides a powerful and easy-to-use platform for writing
    tests that simulate user interactions, allowing developers to ensure that their
    applications function correctly from the user’s perspective.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cypress** 是一个端到端的测试框架，专为现代 Web 应用程序设计。它提供了一个强大且易于使用的平台，用于编写模拟用户交互的测试，帮助开发者确保应用程序从用户的角度正常运行。'
- en: One of the notable features of Cypress is its real-time reloading capability.
    This means that as developers write tests, they can immediately see the results
    in the browser without needing to refresh manually. This instant feedback loop
    accelerates the development process and makes it easier to catch issues early.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress 的一个显著特点是其实时重载功能。这意味着开发者在编写测试时，可以立即在浏览器中看到测试结果，而无需手动刷新。这个即时反馈循环加速了开发过程，并使得早期发现问题变得更加容易。
- en: Cypress also offers an intuitive time travel feature, which allows developers
    to pause test execution and inspect the application at any point in time. This
    is particularly useful for debugging failures, as developers can see exactly what
    the application looked like when a test failed, making it easier to identify the
    root cause of issues.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress 还提供了一个直观的时间旅行功能，允许开发者在任何时候暂停测试执行并检查应用程序。这对于调试失败特别有用，因为开发者可以清楚地看到测试失败时应用程序的状态，从而更容易找出问题的根本原因。
- en: Also, Cypress integrates well with popular CI/CD tools, enabling automated testing
    in the development pipeline. This integration helps ensure that new code changes
    do not break existing functionality, maintaining the overall quality of the application.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Cypress 还与流行的 CI/CD 工具良好集成，使得开发流程中的自动化测试成为可能。这种集成帮助确保新的代码更改不会破坏现有功能，从而保持应用程序的整体质量。
- en: 'An example of testing with Cypress is as follows:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Cypress 进行测试的示例如下：
- en: 'Install Cypress bash: **npm install** **cypress –save-dev** .'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Cypress bash：**npm install** **cypress –save-dev** 。
- en: 'Open with bash: **npx** **cypress open** .'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 bash 打开：**npx** **cypress open** 。
- en: 'Run the test:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试：
- en: Click on the test suite you created (in this case, **My App** ).
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击你创建的测试套件（在这个例子中是 **My App** ）。
- en: Cypress will automatically run the test and display the results in the Test
    Runner UI.
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cypress 会自动运行测试并在 Test Runner UI 中显示结果。
- en: While Cypress is a robust testing tool, it is primarily focused on web applications.
    Developers working with mobile applications or other environments may need to
    seek additional testing solutions. Additionally, the learning curve for new users
    can be steep, especially for those unfamiliar with JavaScript and asynchronous
    programming.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Cypress 是一个强大的测试工具，但它主要专注于 Web 应用程序。处理移动应用程序或其他环境的开发者可能需要寻找额外的测试解决方案。此外，新的用户学习曲线较陡，特别是对于那些不熟悉
    JavaScript 和异步编程的人。
- en: 'For further details on Cypress, you can visit Cypress’s official site: [https://www.cypress.io/](https://www.cypress.io/)
    .'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Cypress 的信息，可以访问 Cypress 的官方网站：[https://www.cypress.io/](https://www.cypress.io/)。
- en: Selenium
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Selenium
- en: '**Selenium** is a well-established open source testing framework that allows
    developers to automate browsers for testing web applications. It supports multiple
    programming languages, including Java, C#, Python, and Ruby, making it a versatile
    choice for testing across different platforms.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**Selenium** 是一个成熟的开源测试框架，允许开发者自动化浏览器以测试 Web 应用程序。它支持多种编程语言，包括 Java、C#、Python
    和 Ruby，使其成为跨平台测试的多功能选择。'
- en: One of the strengths of Selenium is its ability to simulate user interactions
    with a web application. Developers can write scripts that automate tasks, such
    as clicking buttons, filling out forms, and navigating between pages. This capability
    makes Selenium particularly useful for end-to-end testing, where the goal is to
    verify that all components of an application work together as intended.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium 的一个优势是能够模拟用户与 Web 应用程序的交互。开发者可以编写脚本来自动化任务，如点击按钮、填写表单和在页面之间导航。这一功能使得
    Selenium 特别适用于端到端测试，其目的是验证应用程序的所有组件是否按预期协同工作。
- en: Selenium also supports a variety of browsers, enabling developers to perform
    cross-browser testing. This is important for ensuring that applications behave
    consistently across different web browsers and OSs. With the rise of mobile devices,
    Selenium has also expanded its capabilities to include mobile browser testing
    through tools such as Appium.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium 还支持多种浏览器，使开发者能够进行跨浏览器测试。这对于确保应用程序在不同的 Web 浏览器和操作系统中表现一致非常重要。随着移动设备的兴起，Selenium
    也扩展了其功能，通过工具如 Appium 支持移动浏览器测试。
- en: Despite its strengths, Selenium does have a few negatives. Setting up and maintaining
    Selenium tests can be complex, especially for larger applications, similar to
    other tools here. Additionally, tests can sometimes be brittle, meaning they may
    fail due to minor changes in the application’s UI or behavior rather than actual
    bugs. Developers need to invest time in creating robust tests and managing the
    associated maintenance.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Selenium 拥有许多优点，但也存在一些缺点。设置和维护 Selenium 测试可能比较复杂，尤其是对于大型应用程序，类似于其他工具。此外，测试有时可能会脆弱，也就是说，它们可能会因为应用程序
    UI 或行为的微小变化而失败，而不是实际的错误。开发者需要花时间创建健壮的测试并管理相关的维护工作。
- en: 'Check out Selenium’s website here: [https://www.selenium.dev/](https://www.selenium.dev/)
    .'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 Selenium 的官网：[https://www.selenium.dev/](https://www.selenium.dev/)。
- en: Mocha
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mocha
- en: '**Mocha** is a flexible testing framework for JavaScript that runs on Node.js
    and in the browser. It is designed to do asynchronous testing, making it easier
    to test applications that rely on callbacks or promises.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mocha** 是一个灵活的 JavaScript 测试框架，可以在 Node.js 和浏览器中运行。它旨在进行异步测试，使得测试依赖回调或承诺的应用程序变得更加容易。'
- en: One of Mocha’s defining features is its simple syntax, which allows developers
    to write clear and expressive tests. This simplicity is particularly beneficial
    for teams that prioritize readability and maintainability in their test code.
    Mocha supports various assertion libraries, giving developers the freedom to choose
    the one that best fits their needs. Popular choices include Chai, Should.js, and
    Assert.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 的一个显著特点是其简洁的语法，使得开发者能够编写清晰且富有表现力的测试代码。这种简洁性对于注重代码可读性和可维护性的团队特别有益。Mocha
    支持多种断言库，开发者可以自由选择最适合自己需求的库。流行的选择包括 Chai、Should.js 和 Assert。
- en: Mocha also provides a variety of reporting options, allowing developers to view
    test results in different formats. This flexibility makes it easier to integrate
    Mocha into existing development workflows and CI/CD pipelines.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 还提供了多种报告选项，允许开发者以不同格式查看测试结果。这种灵活性使得 Mocha 更容易集成到现有的开发工作流和 CI/CD 管道中。
- en: 'While Mocha is a good and efficient testing tool, one can note that it primarily
    focuses on unit testing. As a result, developers may need to complement Mocha
    with other tools for end-to-end or integration testing. Additionally, configuring
    Mocha can require some upfront effort, particularly for teams that are new to
    testing in JavaScript. For further details on Mocha, see here: [https://mochajs.org/](https://mochajs.org/)
    .'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Mocha是一个良好且高效的测试工具，但可以注意到它主要侧重于单元测试。因此，开发人员可能需要使用其他工具来补充Mocha进行端到端或集成测试。此外，配置Mocha可能需要一些前期工作，特别是对于那些刚接触JavaScript测试的团队。有关Mocha的更多细节，请参见此处：[https://mochajs.org/](https://mochajs.org/)。
- en: Charles Proxy
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Charles Proxy
- en: '**Charles Proxy** is a web debugging tool that allows developers to view all
    of the HTTP and SSL/HTTPS traffic between their computers and the internet. It
    acts as a proxy server, enabling developers to inspect and analyze requests and
    responses in real time.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '**Charles Proxy** 是一个网络调试工具，允许开发人员查看计算机与互联网之间所有HTTP和SSL/HTTPS流量。它充当代理服务器，使开发人员能够实时检查和分析请求和响应。'
- en: One of the primary uses of Charles Proxy is for API testing and debugging. By
    capturing network traffic, developers can easily identify issues such as incorrect
    request parameters, unexpected response formats, or authentication problems. This
    visibility is invaluable when working with APIs, as it allows developers to troubleshoot
    problems quickly and effectively.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: Charles Proxy的主要用途之一是API测试和调试。通过捕获网络流量，开发人员可以轻松识别诸如请求参数错误、响应格式异常或身份验证问题等问题。这种可视性对于处理API至关重要，因为它使开发人员能够快速有效地排查问题。
- en: Charles Proxy also supports features such as request modification and response
    simulation. This means that developers can modify requests on the fly, allowing
    them to test various scenarios without making changes to the actual application
    code.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: Charles Proxy还支持请求修改和响应模拟等功能。这意味着开发人员可以实时修改请求，从而在不更改实际应用程序代码的情况下测试不同的场景。
- en: Additionally, Charles Proxy can simulate different network conditions, enabling
    you to see how your application behaves under various circumstances.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Charles Proxy可以模拟不同的网络条件，使你能够查看应用程序在各种情况下的表现。
- en: Get the tool from [https://www.charlesproxy.com/](https://www.charlesproxy.com/)
    .
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 从[https://www.charlesproxy.com/](https://www.charlesproxy.com/) 获取工具。
- en: 'Configure Charles Proxy:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置Charles Proxy：
- en: If necessary, configure your system or browser to use Charles Proxy as the HTTP
    proxy. This usually involves setting the proxy settings in your browser or OS.
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，可以配置你的系统或浏览器使用Charles Proxy作为HTTP代理。通常，这涉及在浏览器或操作系统中设置代理。
- en: 'Open your application:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的应用程序：
- en: Launch the web application you want to test.
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动你要测试的Web应用程序。
- en: 'Intercept requests:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拦截请求：
- en: In Charles Proxy, enable the **Breakpoints** feature.
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Charles Proxy中，启用**断点**功能。
- en: Click on the **Tools** menu and select **Breakpoints** .
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击**工具**菜单并选择**断点**。
- en: Enable the **Enable** **breakpoints** option.
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用**启用** **断点**选项。
- en: 'Test your application:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试你的应用程序：
- en: Perform actions in your application that trigger HTTP requests. Charles Proxy
    will intercept these requests and pause them at the breakpoint.
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的应用程序中执行触发HTTP请求的操作。Charles Proxy将拦截这些请求并在断点处暂停。
- en: 'Inspect and modify the request:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查并修改请求：
- en: In Charles Proxy, examine the intercepted request details, including the URL,
    headers, and request body.
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Charles Proxy中，检查拦截的请求详情，包括URL、头部和请求正文。
- en: You can modify the request parameters, headers, or body to simulate different
    scenarios.
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以修改请求参数、头部或正文来模拟不同的场景。
- en: 'Continue the request:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续请求：
- en: To continue the request with the modified parameters, click the **Execute**
    button in Charles Proxy.
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 若要继续带有修改参数的请求，请点击Charles Proxy中的**执行**按钮。
- en: 'Here are some examples:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: '**Testing authentication** : Intercept the login request, modify the username
    or password, and observe the application’s response'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试身份验证**：拦截登录请求，修改用户名或密码，并观察应用程序的响应'
- en: '**Simulating network conditions** : Modify the request headers to simulate
    slow network speeds or different network types'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟网络条件**：修改请求头以模拟慢速网络速度或不同的网络类型'
- en: '**Debugging API calls** : Inspect the request and response to identify issues
    or errors in API interactions'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试API调用**：检查请求和响应，以识别API交互中的问题或错误'
- en: While Charles Proxy is a great debugging tool, it may not be suitable for all
    use cases. Developers working on large-scale applications may find that the volume
    of traffic can become overwhelming, making it challenging to pinpoint specific
    issues. Furthermore, there can be a learning curve for new users, particularly
    when it comes to navigating the interface and configuring settings. Most of these
    tools take a lot of work to get into, but they’re worth it.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Charles Proxy 是一款优秀的调试工具，但它可能并不适用于所有场景。对于开发大型应用程序的开发者来说，流量量可能变得过于庞大，导致难以定位具体问题。此外，新用户在学习如何操作界面和配置设置时，可能会面临一定的学习曲线。这些工具大多数都需要投入不少精力来掌握，但它们是值得的。
- en: 'If you want more information about Charles Proxy, you can visit Charles Proxy’s
    official site: [https://www.charlesproxy.com/](https://www.charlesproxy.com/)
    .'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 Charles Proxy 的信息，可以访问 Charles Proxy 的官方网站：[https://www.charlesproxy.com/](https://www.charlesproxy.com/)。
- en: Summary
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter sets the foundation for understanding the diverse range of non-LLM
    AI tools available to developers. By exploring their functionalities and best
    practices, you can better equip yourself with the knowledge to enhance your coding
    toolkit and workflow. For further reading and exploration of the tools discussed,
    please refer to the official websites linked throughout the chapter.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为理解可供开发者使用的各种非 LLM AI 工具奠定了基础。通过探索这些工具的功能和最佳实践，你可以更好地装备自己，提升编码工具包和工作流程。欲了解更多信息，阅读本章中链接的官方站点。
- en: In this chapter, we delved into a diverse array of non-LLM AI tools for coding,
    highlighting their functionalities, capabilities, and limitations.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了多种非 LLM AI 编程工具，重点介绍了它们的功能、能力和局限性。
- en: We began by examining code completion and generation tools, such as Content
    Assist and PyCharm and NetBeans’ code completion tools, which significantly enhance
    coding efficiency by providing real-time suggestions and automating repetitive
    tasks.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查了代码补全和生成工具，如 Content Assist 和 PyCharm 以及 NetBeans 的代码补全工具，这些工具通过提供实时建议和自动化重复任务，大大提高了编码效率。
- en: Following that, we explored static analysis tools, such as SonarQube and ESLint,
    which play a crucial role in maintaining code quality and identifying potential
    issues early in the development process.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了静态分析工具，如 SonarQube 和 ESLint，这些工具在保持代码质量和在开发过程中及早识别潜在问题方面发挥着至关重要的作用。
- en: Finally, we discussed testing and debugging tools, such as Jest and Postman,
    emphasizing their importance in ensuring that applications function correctly
    and meet user expectations.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了测试和调试工具，如 Jest 和 Postman，强调它们在确保应用程序正确运行并满足用户期望方面的重要性。
- en: The integration of these tools into your coding workflow creates a robust toolkit
    that enhances various aspects of the software development process. While LLMs
    offer valuable assistance, leveraging non-LLM tools can maximize productivity
    and ensure that your code is not only functional but also clean, maintainable,
    and efficient. By utilizing a combination of these tools, developers can effectively
    tackle challenges, streamline their workflows, and improve overall code quality.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些工具集成到你的编码工作流程中，能够创建一个强大的工具包，从而提升软件开发过程中的各个方面。虽然大语言模型（LLMs）提供了宝贵的帮助，但利用非 LLM
    工具可以最大化生产力，并确保你的代码不仅是功能性的，还干净、易维护且高效。通过结合使用这些工具，开发人员能够有效应对挑战，简化工作流程，并提高整体代码质量。
- en: This chapter helps developers without this knowledge begin to understand the
    extensive range of non-LLM AI tools available to developers. By exploring their
    functionalities and best practices, you can equip yourself with the knowledge
    necessary to enhance your coding toolkit and workflow.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 本章帮助没有相关知识的开发者开始理解可供开发者使用的广泛非 LLM AI 工具。通过探索它们的功能和最佳实践，你可以装备自己，掌握提升编码工具包和工作流程所需的知识。
- en: Getting into and mastering these tools will empower you to elevate your development
    practices, leading to a more productive and effective coding experience.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 学会并掌握这些工具，将使你能够提升开发实践，从而带来更高效、更有成效的编码体验。
- en: 'You.com is a good source of information on the software tools in this chapter:
    [https://you.com](https://you.com) [You.com].'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: You.com 是本章中软件工具的良好信息来源：[https://you.com](https://you.com) [You.com]。
- en: 'In [*Chapter 11*](B21009_11.xhtml#_idTextAnchor279) , we’ll be looking at how
    to leverage LLMs to help other people and ultimately maximize your career: why
    you should mentor others, more ways to share your work, networking, and some fresh
    approaches to using LLMs.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第11章*](B21009_11.xhtml#_idTextAnchor279)中，我们将探讨如何利用LLM帮助他人，并最终最大化你的职业生涯：为什么你应该指导他人，更多分享工作的方式，建立网络，以及使用LLM的一些新方法。
- en: Bibliography
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Aside from the sources mentioned earlier, here are some more:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前提到的来源，以下是一些更多的参考资料：
- en: '*Copilot* : Microsoft, [https://copilot.microsoft.com/](https://copilot.microsoft.com/)
    , [https://copilot.cloud.microsoft/en-GB/prompts](https://copilot.cloud.microsoft/en-GB/prompts)'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Copilot* : 微软，[https://copilot.microsoft.com/](https://copilot.microsoft.com/)，[https://copilot.cloud.microsoft/en-GB/prompts](https://copilot.cloud.microsoft/en-GB/prompts)'
- en: '*Eclipse_Help* : “Content Assist”, Eclipse, [https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.cdt.doc.user%2Fconcepts%2Fcdt_c_content_assist.htm](https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.cdt.doc.user%2Fconcepts%2Fcdt_c_content_assist.htm)'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Eclipse_Help* : “内容辅助”，Eclipse，[https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.cdt.doc.user%2Fconcepts%2Fcdt_c_content_assist.htm](https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.cdt.doc.user%2Fconcepts%2Fcdt_c_content_assist.htm)'
- en: '*Gemini* : [https://gemini.google.com/](https://gemini.google.com/)'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Gemini* : [https://gemini.google.com/](https://gemini.google.com/)'
- en: '*Jetbrains_Completion* : “Code completion”, JetBrains, [https://www.jetbrains.com/help/pycharm/auto-completing-code.html](https://www.jetbrains.com/help/pycharm/auto-completing-code.html)'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Jetbrains_Completion* : “代码补全”，JetBrains，[https://www.jetbrains.com/help/pycharm/auto-completing-code.html](https://www.jetbrains.com/help/pycharm/auto-completing-code.html)'
- en: '*Jetbrains_refactoring* : “Refactor code”, JetBrains, [https://www.jetbrains.com/help/pycharm/refactoring-source-code.html](https://www.jetbrains.com/help/pycharm/refactoring-source-code.html)'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Jetbrains_refactoring* : “重构代码”，JetBrains，[https://www.jetbrains.com/help/pycharm/refactoring-source-code.html](https://www.jetbrains.com/help/pycharm/refactoring-source-code.html)'
- en: '*NetBeans_Completion* : “NetBeans Code Completion Tutorial”, Apache, [https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/](https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/)'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NetBeans_Completion* : “NetBeans代码补全教程”，Apache，[https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/](https://netbeans.apache.org/tutorial/main/tutorials/nbm-code-completion/)'
- en: '*Netbeans_SmartCode* : “Code Assistance in the NetBeans IDE Java Editor: A
    Reference Guide: Smart Code Completion”, Apache: [https://netbeans.apache.org/tutorial/main/kb/docs/java/editor-codereference/#_smart_code_completion](https://netbeans.apache.org/tutorial/main/kb/docs/java/editor-codereference/#_smart_code_completion)'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Netbeans_SmartCode* : “NetBeans IDE Java编辑器中的代码辅助：参考指南：智能代码补全”，Apache：[https://netbeans.apache.org/tutorial/main/kb/docs/java/editor-codereference/#_smart_code_completion](https://netbeans.apache.org/tutorial/main/kb/docs/java/editor-codereference/#_smart_code_completion)'
- en: '*Wiki_Include* : “include guard”, various, [https://en.wikipedia.org/wiki/Include_guard](https://en.wikipedia.org/wiki/Include_guard)'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Wiki_Include* : “包含保护”，各种，[https://en.wikipedia.org/wiki/Include_guard](https://en.wikipedia.org/wiki/Include_guard)'
- en: '*You.com* : [https://you.com](https://you.com)'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*You.com* : [https://you.com](https://you.com)'
- en: 'Part 4: Maximizing Your Potential with LLMs: Beyond the Basics'
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4部分：用LLM最大化你的潜力：超越基础
- en: This section explores ways to leverage LLMs for personal and professional growth.
    We will check out various AI tools that can amplify the capabilities of LLMs,
    creating a very robust AI toolkit. We will cover strategies for mentorship, community
    involvement, and also advancing your career in the field of LLM-powered coding.
    Lastly, we will see the various emerging trends and technological advancements
    and the long-term impact of LLMs on software development.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了如何利用LLM促进个人和职业成长。我们将查看各种可以增强LLM能力的AI工具，创建一个非常强大的AI工具包。我们还将涵盖导师策略、社区参与以及在LLM驱动的编程领域推进职业发展的方法。最后，我们将了解各种新兴趋势、技术进展以及LLM对软件开发的长期影响。
- en: 'This section covers the following chapters:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 本节覆盖以下章节：
- en: '[*Chapter 11*](B21009_11.xhtml#_idTextAnchor279) *,* *Helping Others and Maximizing
    Your Career with LLMs*'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B21009_11.xhtml#_idTextAnchor279) *,* *用LLM帮助他人并最大化你的职业生涯*'
- en: '[*Chapter 12*](B21009_12.xhtml#_idTextAnchor308) *,* *The Future of LLMs in
    Software Development*'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B21009_12.xhtml#_idTextAnchor308) *,* *LLM在软件开发中的未来*'
