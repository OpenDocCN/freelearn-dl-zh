- en: Using Fuzzy Logic to Make Your AI Seem Alive
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模糊逻辑让你的AI看起来更有生命力
- en: 'Fuzzy logic is a fantastic way to represent the rules of your game in a more
    nuanced way. Perhaps more so than other concepts in this book, fuzzy logic is
    a very math-heavy topic. Most of the information can be represented purely in
    mathematical functions. For the sake of teaching the important concepts as they
    apply to Unity, most of the math has been simplified and implemented using Unity''s
    built-in features. Of course, if you are the type who loves math, this is a somewhat
    deep topic in that regard, so feel free to take the concepts covered in this book
    and run with them! In this chapter, we''ll learn the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊逻辑是一种以更细腻的方式表示你的游戏规则的方法。也许比这本书中的其他概念更甚，模糊逻辑是一个非常数学化的主题。大部分信息都可以用纯数学函数来表示。为了教学目的，将重要概念应用于Unity，大部分数学都已被简化，并使用Unity的内置功能实现。当然，如果你是那种喜欢数学的人，这个话题在某种程度上相当深入，所以请随意运用这本书中涵盖的概念！在本章中，我们将学习以下内容：
- en: What fuzzy logic is
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊逻辑是什么
- en: Where fuzzy logic is used
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊逻辑的应用领域
- en: How to implement fuzzy logic controllers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现模糊逻辑控制器
- en: What the other creative uses for fuzzy logic concepts are
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊逻辑概念的其他创造性用途是什么
- en: Defining fuzzy logic
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义模糊逻辑
- en: The simplest way to define fuzzy logic is by comparison to binary logic. In
    the previous chapters, we looked at transition rules as true or false or 0 or
    1 values. Is something visible? Is it at least a certain distance away? Even in
    instances where multiple values were being evaluated, all of the values had exactly
    two outcomes; thus, they were binary. In contrast, fuzzy values represent a much
    richer range of possibilities, where each value is represented as a float rather
    than an integer. We stop looking at values as 0 or 1, and we start looking at
    them as 0 to 1.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 定义模糊逻辑最简单的方法是通过与二进制逻辑的比较。在前面的章节中，我们研究了作为真或假、0或1值的转换规则。某物可见吗？它至少距离我们多远？即使在评估多个值的情况下，所有值都有确切的两个结果；因此，它们是二进制的。相比之下，模糊值代表了一个更丰富的可能性范围，其中每个值都表示为浮点数而不是整数。我们不再将值视为0或1，而是将它们视为0到1。
- en: A common example used to describe fuzzy logic is temperature. Fuzzy logic allows
    us to make decisions based on non-specific data. I can step outside on a sunny
    Californian summer's day and ascertain that it is warm, without knowing the temperature
    precisely. Conversely, if I were to find myself in Alaska during the winter, I
    would know that it is cold, again, without knowing the exact temperature. These
    concepts of cold, cool, warm, and hot are fuzzy ones. There is a good amount of
    ambiguity as to at what point we go from warm to hot. Fuzzy logic allows us to
    model these concepts as sets and determine their validity or truth by using a
    set of rules.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 描述模糊逻辑的一个常见例子是温度。模糊逻辑允许我们根据非具体数据做出决策。我可以在阳光明媚的加利福尼亚夏日的一天外出，确信天气温暖，而无需知道确切的温度。相反，如果我冬天在阿拉斯加，我会知道天气很冷，同样，无需知道确切的温度。冷、凉爽、温暖和热这些概念都是模糊的。从温暖到热的转变点存在相当多的歧义。模糊逻辑允许我们将这些概念建模为集合，并通过使用一组规则来确定它们的有效性或真实性。
- en: 'When people make decisions, people have some gray areas. That is to say, it''s
    not always black and white. The same concept applies to agents that rely on fuzzy
    logic. Say you hadn''t eaten in a few hours, and you were starting to feel a little
    hungry. At which point were you hungry enough to go grab a snack? You could look
    at the time right after a meal as 0, and 1 would be the point where you approached
    starvation. The following figure illustrates this point:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们做决策时，人们有一些灰色区域。也就是说，并不总是非黑即白。同样的概念也适用于依赖于模糊逻辑的代理。比如说，如果你几个小时没吃东西，开始觉得有点饿。在什么时刻你饿到足以去拿零食？你可以把饭后立刻的时间看作是0，而1则是接近饥饿的点。以下图示说明了这一点：
- en: '![](img/1cbfd7ea-ab8e-4c55-b672-4a68d65ad2c6.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1cbfd7ea-ab8e-4c55-b672-4a68d65ad2c6.png)'
- en: When making decisions, there are many factors that determine the ultimate choice.
    This leads into another aspect of fuzzy logic controllers—they can take into account
    as much data as necessary. Let's continue to look at our "should I eat?" example.
    We've only considered one value for making that decision, which is the time since
    the last time you ate. However, there are other factors that can affect this decision,
    such as how much energy you're expending and how lazy you are at that particular
    moment. Or am I the only one to use that as a deciding factor? Either way, you
    can see how multiple input values can affect the output, which we can think of
    as the "likeliness to have another meal."
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在做决定时，有许多因素决定了最终的选择。这引出了模糊逻辑控制器的一个方面——它们可以考虑到所需的所有数据。让我们继续看看我们的“我应该吃饭吗？”的例子。我们只考虑了一个值来做这个决定，那就是自上次你吃饭以来经过的时间。然而，还有其他因素会影响这个决定，比如你当时消耗了多少能量，以及你当时有多懒。或者我是唯一一个把那作为一个决定因素的人吗？无论如何，你可以看到多个输入值如何影响输出，我们可以将其视为“再次用餐的可能性。”
- en: Fuzzy logic systems can be very flexible due to their generic nature. You provide
    input, the fuzzy logic provides an output. What that output means to your game
    is entirely up to you. We've primarily looked at how the inputs would affect a
    decision, which, in reality, is taking the output and using it in a way the computer,
    our agent, can understand. However, the output can also be used to determine how
    much of something to do, how fast something happens, or for how long something
    happens.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模糊逻辑系统的通用性，它们可以非常灵活。你提供输入，模糊逻辑提供输出。这个输出对你游戏的意义完全取决于你。我们主要看了输入如何影响一个决定，实际上，这是将输出用于计算机、我们的代理可以理解的方式。然而，输出也可以用来确定做某事多少，某事发生多快，或者某事持续多久。
- en: For example, imagine your agent is a car in a sci-fi racing game that has a
    "nitro-boost" ability that lets it expend a resource to go faster. Our 0 to 1
    value can represent a normalized amount of time for it to use that boost or perhaps
    a normalized amount of fuel to use.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下你的代理是一个科幻赛车游戏中的汽车，它有一个“氮气助推”能力，可以让它消耗资源来加速。我们的0到1值可以代表使用该助推的标准化时间，或者可能是使用该助推的标准化燃料量。
- en: Picking fuzzy systems over binary systems
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择模糊系统而非二元系统
- en: As with the previous systems we covered in this book, and with most things in
    game programming, we must evaluate the requirements of our game and the technology
    and hardware limitations when deciding on the best way to tackle a problem.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在本书中之前介绍的系统一样，以及游戏编程中的大多数事情，我们必须在决定最佳解决问题的方法时评估我们游戏的需求、技术和硬件限制。
- en: As you might imagine, there is a performance cost associated with going from
    a simple yes/no system to a more nuanced fuzzy logic one, which is one of the
    reasons we may opt out of using it. Of course, being a more complex system doesn't
    necessarily always mean it's a better one. There will be times when you just want
    the simplicity and predictability of a binary system because it may fit your game
    better.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，从简单的是/否系统到更微妙的模糊逻辑系统，会有一定的性能成本，这也是我们可能选择不使用它的原因之一。当然，更复杂的系统并不一定总是更好的。有时你只是想要二元系统的简单性和可预测性，因为它可能更适合你的游戏。
- en: While there is some truth to the old adage, "the simpler, the better", one should
    also take into account the saying, "everything should be made as simple as possible,
    but not simpler". Though the quote is widely attributed to Albert Einstein, the
    father of relativity, it's not entirely clear who said it. The important thing
    to consider is the meaning of the quote itself. You should make your AI as simple
    as your game needs it to be, but not simpler. Pac-Man's AI works perfectly for
    the game–it's simple enough. However, rules say that simple would be out of place
    in a modern shooter or strategy game.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然老话“简单就是最好”有一定的道理，但我们也应该考虑另一句话，“尽可能简单，但不能更简单”。虽然这句话通常归功于相对论的创始人阿尔伯特·爱因斯坦，但并不完全清楚是谁说的。重要的是要考虑这句话本身的意义。你应该让你的AI尽可能简单，但不能更简单。吃豆人的AI对游戏来说工作得很好——它足够简单。然而，规则说，简单在现代射击游戏或策略游戏中可能不合适。
- en: Take the knowledge and examples in this book and find what works best for you.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 将本书中的知识和例子拿去，找到最适合你的方法。
- en: Using fuzzy logic
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模糊逻辑
- en: Once you understand the simple concepts behind fuzzy logic, it's easy to start
    thinking of the many, many ways in which it can be useful. In reality, it's just
    another tool in our belt, and each job requires different tools.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了模糊逻辑背后的简单概念，就很容易开始思考它可能有多少种有用的方式。实际上，它只是我们工具箱中的另一个工具，每个工作都需要不同的工具。
- en: Fuzzy logic is great at taking some data, evaluating it in a similar way to
    how a human would (albeit in a much simpler way), and then translating the data
    back to information that is usable by the system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊逻辑擅长处理一些数据，并以类似于人类的方式（尽管方式更为简单）对其进行评估，然后将数据转换成系统可用的信息。
- en: 'Fuzzy logic controllers have several real-world use cases. Some are more obvious
    than others, and while these are by no means one-to-one comparisons to our usage
    in game AI, they serve to illustrate a point:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊逻辑控制器有几个实际应用案例。有些比其他的应用更明显，尽管这些案例与我们在游戏AI中的使用并不是一一对应的，但它们有助于说明一个观点：
- en: '**Heating ventilation and air conditioning (HVAC) systems**: The temperature
    example when talking about fuzzy logic is not only a good theoretical approach
    to explaining fuzzy logic, but also a very common real-world example of fuzzy
    logic controllers in action.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**供暖、通风和空调（HVAC）系统**：在谈论模糊逻辑时提到的温度例子，不仅是一个很好的理论方法来解释模糊逻辑，而且也是一个模糊逻辑控制器在实际中非常常见的例子。'
- en: '**Automobiles**: Modern automobiles come equipped with very sophisticated computerized
    systems, from the air conditioning system (again), to fuel delivery, to automated
    braking systems. In fact, putting computers in automobiles has resulted in far
    more efficient systems than the old binary systems that were sometimes used.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**汽车**：现代汽车配备了非常复杂的计算机化系统，从空调系统（再次提到），到燃油输送，再到自动制动系统。实际上，在汽车中安装计算机已经导致了比过去有时使用的旧二进制系统更加高效的系统。'
- en: '**Your smartphone**: Ever notice how your screen dims and brightens depending
    on how much ambient light there is? Modern smartphone operating systems look at
    ambient light, the color of the data being displayed, and the current battery
    life to optimize screen brightness.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你的智能手机**：你是否注意过，根据周围光线的多少，你的屏幕会变暗或变亮？现代智能手机操作系统会考虑周围光线、正在显示的数据的颜色以及当前电池寿命，以优化屏幕亮度。'
- en: '**Washing machines**: Not my washing machine necessarily, as it''s quite old,
    but most modern washers (from the last 20 years) make some use of fuzzy logic.
    Load size, water dirtiness, temperature, and other factors are taken into account
    from cycle to cycle to optimize water use, energy consumption, and time.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**洗衣机**：不一定是我家的洗衣机，因为它的年代相当久远，但大多数现代洗衣机（过去20年生产的）都使用了一些模糊逻辑。从一次循环到下一次循环，会考虑装载量、水的污浊程度、温度和其他因素，以优化用水、能耗和时间。'
- en: If you take a look around your house, there is a good chance you'll find a few
    interesting uses of fuzzy logic, and I mean besides your computer, of course.
    While these are neat uses of the concept, they're not particularly exciting or
    game-related. I'm partial to games involving wizards, magic, and monsters, so
    let's look at a more relevant example.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你环顾你的房子，你很可能会发现一些有趣的模糊逻辑应用，当然，除了你的电脑之外。虽然这些是概念上的巧妙应用，但它们并不特别令人兴奋或与游戏相关。我偏爱涉及巫师、魔法和怪物游戏，所以让我们看看一个更相关的例子。
- en: Implementing a simple fuzzy logic system
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现简单的模糊逻辑系统
- en: For this example, we're going to use my good friend, Bob, the wizard. Bob lives
    in an RPG world, and he has some very powerful healing magic at his disposal.
    Bob has to decide when to cast this magic on himself based on his remaining **health
    points** (**HPs**).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用我的好朋友鲍勃，这位巫师。鲍勃生活在一个RPG世界中，他有一些非常强大的治疗魔法可以使用。鲍勃必须根据他剩余的**生命值（HPs**）来决定何时对自己使用这种魔法。
- en: 'In a binary system, Bob''s decision-making process might look like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在二进制系统中，鲍勃的决策过程可能看起来像这样：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We see that Bob''s health can be in one of two states—above 50, or not. Nothing
    wrong with that, but let''s have a look at what the fuzzy version of this same
    scenario might look like, starting with determining Bob''s health status:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，鲍勃的健康状态可以是两种状态之一——高于50，或者不是。这并没有什么问题，但让我们看看这个场景的模糊版本可能是什么样子，从确定鲍勃的健康状态开始：
- en: '![](img/36e6c128-2a3f-413d-8117-4fd0da005f8e.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/36e6c128-2a3f-413d-8117-4fd0da005f8e.png)'
- en: A typical function representing fuzzy values
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 表示模糊值的典型函数
- en: Before the panic sets in upon seeing charts and values that may not quite mean
    anything to you right away, let's dissect what we're looking at. Our first impulse
    might be to try to map the probability that Bob will cast a healing spell to how
    much health he is missing. That would, in simple terms, just be a linear function.
    Nothing really fuzzy about that—it's a linear relationship, and while it is a
    step above a binary decision in terms of complexity, it's still not truly fuzzy.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到图表和值时，在恐慌之前，让我们剖析我们所看到的内容。我们最初的冲动可能是尝试将鲍勃施展治疗咒语的概率映射到他缺失的健康程度。用简单的话说，这只是一个线性函数。这根本不是模糊的——它是一个线性关系，虽然在复杂性方面比二元决策高一个层次，但它仍然不是真正的模糊。
- en: Enter the concept of a membership function. It's key to our system, as it allows
    us to determine how true a statement is. In this example, we're not simply looking
    at raw values to determine whether or not Bob should cast his spell; instead,
    we're breaking it up into logical chunks of information for Bob to use in order
    to determine what his course of action should be.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 进入成员函数的概念。它是我们系统的关键，因为它允许我们确定一个陈述有多真实。在这个例子中，我们并不是简单地查看原始值来判断鲍勃是否应该施展咒语；相反，我们将它分解成逻辑信息块，供鲍勃使用，以确定他应该采取的行动。
- en: 'In this example, we''re comparing three statements and evaluating not only
    how true each one is, but which is the most true:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们比较三个陈述，并评估每个陈述有多真实，以及哪个是最真实的：
- en: Bob is in a critical condition
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鲍勃处于危急状态
- en: Bob is hurt
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鲍勃受伤
- en: Bob is healthy
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鲍勃是健康的
- en: If you're into official terminology, we call this determining the degree of
    membership to a set. Once we have this information, our agent can determine what
    to do with it next.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢官方术语，我们称之为确定集合的成员度。一旦我们有了这些信息，我们的代理就可以确定如何处理它。
- en: 'At a glance, you''ll notice it''s possible for two statements to be true at
    a time. Bob can be in a critical condition and hurt. He can also be somewhat hurt
    and a little bit healthy. You''re free to pick the thresholds for each, but, in
    this example, let''s evaluate these statements as per the preceding graph. The
    vertical value represents the degree of truth of a statement as a normalized float
    (0 to 1):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，你会发现两个陈述同时为真是有可能的。鲍勃可以处于危急状态和受伤状态。他也可以有点受伤和有点健康。你可以自由选择每个的阈值，但在这个例子中，让我们根据前面的图表评估这些陈述。垂直值表示陈述的真实度，作为一个归一化的浮点数（0到1）：
- en: At 0 percent health, we can see that the critical statement evaluates to 1\.
    It is absolutely true that Bob is critical when his health is gone.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在0%健康状态下，我们可以看到关键陈述评估为1。当鲍勃的健康耗尽时，这是一个绝对的真实陈述。
- en: At 40 percent health, Bob is hurt, and that is the truest statement.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在40%健康状态下，鲍勃受伤，这是最真实的陈述。
- en: At 100 percent health, the truest statement is that Bob is healthy.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在100%健康状态下，最真实的陈述是鲍勃是健康的。
- en: 'Anything outside of these absolutely true statements is squarely in fuzzy territory.
    For example, let''s say Bob''s health is at 65 percent. In that same chart, we
    can visualize it like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 任何超出这些绝对真实陈述的东西都完全处于模糊区域。例如，假设鲍勃的健康状况为65%。在同一张图表中，我们可以这样可视化：
- en: '![](img/4b2444bf-13f2-4f1a-b513-bf959709fbef.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b2444bf-13f2-4f1a-b513-bf959709fbef.png)'
- en: Bob's health at 65 percent
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃65%的健康状况
- en: 'The vertical line drawn through the chart at **65** represents Bob''s health.
    As we can see, it intersects both sets, which means that Bob is a little bit hurt,
    but he''s also kind of healthy. At a glance, we can tell, however, that the vertical
    line intercepts the **Hurt** set at a higher point in the graph. We can take this
    to mean that Bob is more hurt than he is healthy. To be specific, Bob is 37.5
    percent hurt, 12.5 percent healthy, and 0 percent critical. Let''s take a look
    at this in code; open up our `FuzzySample` scene in Unity. The hierarchy will
    look like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表上画出的垂直线代表**65**表示鲍勃的健康状况。正如我们所见，它与两个集合相交，这意味着鲍勃有点受伤，但他也很健康。然而，一眼就能看出，垂直线在图表中截取**受伤**集合的点比**健康**集合的点更高。我们可以理解为鲍勃受伤的程度比健康程度更高。具体来说，鲍勃受伤37.5%，健康12.5%，危急状态0%。让我们看看代码；在Unity中打开我们的`FuzzySample`场景。层次结构将如下所示：
- en: '![](img/273f2b9b-6011-429b-a282-43ef9f409313.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/273f2b9b-6011-429b-a282-43ef9f409313.png)'
- en: The hierarchy setup in our sample scene
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们样本场景中的层次结构设置
- en: The important game object to look at is `Fuzzy Example`. This contains the logic
    that we'll be looking at. In addition to that, we have our `Canvas` containing
    all of the labels and the input field and button that make this example work.
    Lastly, there's the Unity-generated `EventSystem` and `Main Camera`, which we
    can disregard. There isn't anything special going on with the setup for the scene,
    but it's a good idea to become familiar with it, and you are encouraged to poke
    around and tweak it to your heart's content after we've looked at why everything
    is there and what it all does.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 需要关注的重要游戏对象是`模糊示例`。它包含我们将要查看的逻辑。除此之外，我们还有包含所有标签和输入字段以及使此示例工作的按钮的`Canvas`。最后，还有Unity生成的`EventSystem`和`Main
    Camera`，我们可以忽略它们。场景的设置没有特别之处，但熟悉它是好主意，我们鼓励你在了解为什么一切都在那里以及它们各自的作用之后，尽情地探索和调整。
- en: 'With the `Fuzzy Example` game object selected, the inspector will look similar
    to the following image:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择`模糊示例`游戏对象时，检查器将类似于以下图片：
- en: '![](img/99f298ae-67ba-4700-8b35-c04b5a6d9a5a.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/99f298ae-67ba-4700-8b35-c04b5a6d9a5a.png)'
- en: The Fuzzy Example game object inspector
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊示例游戏对象检查器
- en: Our sample implementation is not necessarily something you'll take and implement
    in your game as it is, but it is meant to illustrate the previous points in a
    clear manner. We use Unity's `AnimationCurve` for each different set. It's a quick
    and easy way to visualize the very same lines in our earlier graph.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例实现不一定是你可以直接拿去在游戏中实现的东西，但它的目的是以清晰的方式说明前面的要点。我们为每个不同的集合使用Unity的`AnimationCurve`。这是一种快速且简单的方式来可视化我们早期图表中的相同线条。
- en: Unfortunately, there is no straightforward way to plot all the lines in the
    same graph, so we use a separate `AnimationCurve` for each set. In the preceding
    screenshot, they are labeled Critical, Hurt, and Healthy. The neat thing about
    these curves is that they come with a built-in method to evaluate them at a given
    point (*t*). For us, *t* does not represent time, but rather the amount of health
    Bob has.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有简单的方法可以在同一个图表中绘制所有线条，所以我们为每个集合使用一个单独的`AnimationCurve`。在前面的截图中，它们被标记为“关键”、“受伤”和“健康”。这些曲线的巧妙之处在于它们自带一个内置方法来评估给定点的值（*t*）。对我们来说，*t*并不代表时间，而是鲍勃的健康量。
- en: 'As in the preceding graph, the Unity example looks at a HP range of 0 to 100\.
    These curves also provide a simple user interface for editing the values. You
    can simply click on the curve in the inspector. That opens up the curve editing
    window. You can add points, move points, change tangents, and so on, as shown
    in the following screenshot:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的图表所示，Unity示例查看的是0到100的HP范围。这些曲线还提供了一个简单的用户界面来编辑这些值。你只需在检查器中点击曲线即可。这会打开曲线编辑窗口。你可以添加点、移动点、更改切线等，如以下截图所示：
- en: '![](img/dbabf929-7f69-43f3-83de-64f47f94abcc.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dbabf929-7f69-43f3-83de-64f47f94abcc.png)'
- en: Unity's curve editor window
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的曲线编辑器窗口
- en: Our example focuses on triangle-shaped sets. That is, linear graphs for each
    set. You are by no means restricted to this shape, though it is the most common.
    You could use a bell curve or a trapezoid, for that matter. To keep things simple,
    we'll stick to the triangle.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的例子专注于三角形形状的集合。也就是说，每个集合的线性图。你绝对不必局限于这种形状，尽管它是最常见的。你可以使用钟形曲线或梯形，如果需要的话。为了保持简单，我们将坚持使用三角形。
- en: You can learn more about Unity's `AnimationCurve` editor at [http://docs.unity3d.com/ScriptReference/AnimationCurve.html](http://docs.unity3d.com/ScriptReference/AnimationCurve.html).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://docs.unity3d.com/ScriptReference/AnimationCurve.html](http://docs.unity3d.com/ScriptReference/AnimationCurve.html)了解更多关于Unity的`AnimationCurve`编辑器的信息。
- en: The rest of the fields are just references to the different UI elements used
    in code that we'll be looking at later in this chapter. The names of these variables
    are fairly self-explanatory, however, so there isn't much guesswork to be done
    here.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的字段只是对我们在本章后面将要查看的代码中使用的不同UI元素的引用。然而，这些变量的名称相当直观，所以这里不需要太多的猜测。
- en: 'Next, we can take a look at how the scene is set up. If you play the scene,
    the game view will look something similar to the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以看看场景是如何设置的。如果你播放场景，游戏视图将类似于以下截图：
- en: '![](img/3a87ffea-f5f4-4297-995a-0613906c6a3b.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3a87ffea-f5f4-4297-995a-0613906c6a3b.png)'
- en: A simple UI to demonstrate fuzzy values
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的用户界面来演示模糊值
- en: We can see that we have three distinct groups, representing each question from
    the "Bob, the wizard" example. How healthy is Bob, how hurt is Bob, and how critical
    is Bob? For each set, upon evaluation, the value that starts off as **0 true** will
    dynamically adjust to represent the actual degree of membership.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们有三个不同的组，代表“鲍勃，巫师”示例中的每个问题。鲍勃有多健康，鲍勃有多受伤，鲍勃有多危急？对于每个集合，在评估时，最初为**0真**的值将动态调整以表示实际成员度。
- en: There is an input box in which you can type a percentage of health to use for
    the test. No fancy controls are in place for this, so be sure to enter a value
    from 0 to 100\. For the sake of consistency, let's enter a value of `65` into
    the box and then press the Evaluate! button.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有一个输入框，你可以输入用于测试的健康百分比。这个输入框没有复杂的控制，所以请确保输入一个介于0到100之间的值。为了保持一致性，让我们在框中输入`65`，然后按下“评估！”按钮。
- en: This will run some code, look at the curves, and yield the exact same results
    we saw in our graph earlier. While this shouldn't come as a surprise (the math
    is what it is, after all), there are fewer things more important in game programming
    than testing your assumptions, and sure enough, we've tested and verified our
    earlier statement.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行一些代码，查看曲线，并产生我们在之前的图表中看到的精确结果。虽然这不应该令人惊讶（毕竟数学就是这样），但在游戏编程中，没有比测试你的假设更重要的事情了，而且确实，我们已经测试并验证了之前的声明。
- en: 'After running the test by hitting the Evaluate! button, the game scene will
    look similar to the following screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击“评估！”按钮运行测试后，游戏场景将类似于以下截图：
- en: '![](img/86fd988c-3061-4cf3-9de0-9aec4b0238ca.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/86fd988c-3061-4cf3-9de0-9aec4b0238ca.png)'
- en: This is how Bob is doing at 65 percent health
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是鲍勃在65%健康时的状态
- en: 'Again, the values turn out to be 0.125 (or 12.5 percent) healthy and 0.375
    (or 37.5 percent) hurt. At this point, we''re still not doing anything with this
    data, but let''s take a look at the code that''s handling everything:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，值是0.125（或12.5%）的健康和0.375（或37.5%）的受伤。在这个时候，我们还没有对这个数据进行任何操作，但让我们看看处理这一切的代码：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We start off by declaring some variables. The `labelText` is simply a constant
    we use to plug into our label. We replace `{0}` with the real value.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明一些变量。`labelText`只是一个我们用来插入标签的常量。我们将`{0}`替换为实际值。
- en: Next, we declare the three `AnimationCurve` variables that we mentioned earlier.
    Making these public or otherwise accessible from the inspector is key to being
    able to edit them visually (though it is possible to construct curves by code),
    which is the whole point of using them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明之前提到的三个`AnimationCurve`变量。将这些变量设置为公共或从检查器中可访问是能够通过视觉编辑它们的关键（尽管也可以通过代码构建曲线），这正是使用它们的目的。
- en: 'The following four variables are just references to UI elements that we saw
    earlier in the screenshot of our inspector, and the last three variables are the
    actual float values that our curves will evaluate into:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下四个变量只是对我们之前在检查器截图中所看到的UI元素的引用，而最后三个变量是我们曲线将评估到的实际浮点值：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Start()` method doesn't require much explanation. We simply update our
    labels here so that they initialize to something other than the default text.
    The `EvaluateStatements()` method is much more interesting. We first do some simple
    null checking for our input string. We don't want to try and parse an empty string,
    so we return out of the function if it is empty. As mentioned earlier, there is
    no check in place to validate that you've input a numerical value, so be sure
    not to accidentally input a non-numerical value or you'll get an error.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()`方法不需要太多解释。我们在这里只是更新我们的标签，以便它们初始化为非默认文本。`EvaluateStatements()`方法则更有趣。我们首先对我们的输入字符串进行一些简单的空值检查。我们不希望尝试解析一个空字符串，所以如果它是空的，我们就从函数中返回。如前所述，没有检查来验证你是否输入了一个数值，所以请确保不要意外输入一个非数值，否则你会得到一个错误。'
- en: 'For each of the `AnimationCurve` variables, we call the `Evaluate(float t)`
    method, where we replace `t` with the parsed value we get from the input field.
    In the example we ran, that value would be `65`. Then, we update our labels once
    again to display the values we got. The code looks similar to this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个`AnimationCurve`变量，我们调用`Evaluate(float t)`方法，其中我们将`t`替换为从输入字段中获取的解析值。在我们运行的示例中，这个值将是`65`。然后，我们再次更新我们的标签以显示我们得到的价值。代码看起来像这样：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We simply take each label and replace the text with a formatted version of our
    `labelText` constant that replaces the `{0}` with the real value.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是取每个标签，并用格式化的`labelText`常量替换文本，将`{0}`替换为实际值。
- en: Expanding the sets
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展集合
- en: We discussed this topic in detail earlier, and it's important to understand
    that the values that make up the sets in our example are unique to Bob and his
    pain threshold. Let's say we have a second wizard, Jim, who's a bit more reckless.
    For him, critical might be below 20 percent, rather than 40 percent as it is for
    Bob. This is what I like to call a "happy bonus" from using fuzzy logic. Each
    agent in the game can have different rules that define their sets, but the system
    doesn't care. You could predefine these rules or have some degree of randomness
    determine the limits, and every single agent would behave uniquely and respond
    to things in their own way.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前详细讨论了这个问题，重要的是要理解，构成我们例子中集合的值是独一无二的，属于鲍勃和他的疼痛阈值。假设我们有一个第二位巫师吉姆，他有点鲁莽。对他来说，关键可能低于20%，而不是鲍勃的40%。这就是我喜欢称之为使用模糊逻辑的“快乐奖金”。游戏中的每个代理都可以有不同的规则来定义它们的集合，但系统并不关心。你可以预先定义这些规则，或者让某种程度的随机性决定极限，每个代理都会以独特的方式行为并做出反应。
- en: In addition, there is no reason to limit our sets to just three. Why not four
    or five? To the fuzzy logic controller, all that matters is that you determine
    what truth you're trying to arrive at, and how you get there; it doesn't care
    how many different sets or possibilities exist in that system.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们没有理由将我们的集合限制为只有三个。为什么不是四个或五个呢？对于模糊逻辑控制器来说，唯一重要的是你确定你试图达到什么真理，以及你是如何达到的；它不关心系统中存在多少不同的集合或可能性。
- en: Defuzzifying the data
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据去模糊化
- en: 'Yes, that''s a real (sort of) word. We''ve started with some crisp rules, which,
    in the context of fuzzy logic, means clear-cut, hard-defined data, which we then
    fuzzified (again, a sort of real word) by assigning membership functions to sets.
    The last step of the process is to defuzzify the data and make a decision. For
    this, we use simple Boolean operations, such as the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这是一个真正的（或者说）词。我们开始于一些清晰规则，在模糊逻辑的上下文中，这意味着明确、明确的数据，然后我们通过为集合分配隶属函数来模糊化（再次，这是一个（或者说）真正的词）数据。过程的最后一步是去模糊化数据并做出决策。为此，我们使用简单的布尔运算，如下所示：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, at this point, you may be saying, "Hold on a second. That looks an awful
    lot like a binary controller," and you'd be correct. So why go through all the
    trouble? Remember what we said earlier about ambiguous information? Without a
    fuzzy controller, how does our agent understand what it means to be critical,
    hurt, or healthy, for that matter? These are abstract concepts that mean very
    little on their own to a computer.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这个时候，你可能想说，“等等，这看起来非常像二进制控制器，”你是对的。那么为什么要费这么大的劲呢？还记得我们之前说的关于模糊信息的话吗？没有模糊控制器，我们的代理如何理解什么是关键、受伤或健康呢？这些都是对计算机本身意义不大的抽象概念。
- en: By using fuzzy logic, we're now able to use these vague terms, infer something
    from them, and do concrete things; in this case, cast a healing spell. Furthermore,
    we're able to allow each agent to determine what these vague terms mean to them
    on an individual level, allowing us not only to achieve unpredictability on an
    individual level, but even amongst several similar agents.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用模糊逻辑，我们现在能够使用这些模糊的术语，从中推断出一些东西，并做具体的事情；在这种情况下，施展治愈咒语。此外，我们能够允许每个代理在个人层面上确定这些模糊术语对他们的意义，这不仅使我们能够在个人层面上实现不可预测性，甚至在几个类似代理之间也能实现。
- en: 'The process is described best in the following diagram:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表最好地描述了这一过程：
- en: '![](img/14a3760b-32ab-4a26-915e-0f61eaf16387.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/14a3760b-32ab-4a26-915e-0f61eaf16387.png)'
- en: The fuzzy logic controller flow
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊逻辑控制器流程
- en: 'At the end of the day, they are still computers, so we''re bound to the most
    basic thing computers understand, 0s and 1s:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它们仍然是计算机，所以我们受限于计算机最基本理解的东西，0和1：
- en: We start with crisp data, that is, concrete, hard values that tell us something
    very specific.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从清晰的数据开始，即具体、明确的价值，它们告诉我们一些非常具体的事情。
- en: The fuzzification step is where we get to decide the abstract or ambiguous data
    that our agent will need to make a decision.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊化步骤是我们决定我们的代理需要做出决策的抽象或模糊数据的地方。
- en: During the inference step, our agent gets to decide what that data means. The
    agent gets to determine what is "true" based on a provided set of rules, meant
    to mimic the nuance of human decision-making.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在推理步骤中，我们的智能体需要决定这些数据意味着什么。智能体根据提供的一组旨在模仿人类决策细微差别的规则，来确定什么是“真实”的。
- en: The defuzzification step takes this human-friendly data and converts it into
    simple, computer-friendly information.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊化步骤将这种对人类友好的数据转换为简单、计算机友好的信息。
- en: We end with crisp data, ready for our wizard agent to use.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们最终得到清晰的数据，准备供我们的巫师智能体使用。
- en: Using the resulting crisp data
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用得到的结果数据
- en: 'The data output from a fuzzy controller can then be plugged into a behavior
    tree or a finite state machine. Of course, we can also combine multiple controllers''
    output to make decisions. In fact, we can take a whole bunch of them to achieve
    the most realistic or interesting result (as realistic as a magic-using wizard
    can be, anyway). The following figure illustrates a potential set of fuzzy logic
    controllers it can be used to determine whether or not to cast the heal spell:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊控制器的数据输出可以连接到行为树或有限状态机。当然，我们也可以组合多个控制器的输出来做决策。实际上，我们可以使用一大堆它们来达到最真实或最有趣的结果（无论如何，一个使用魔法的巫师可以有多真实）。以下图示展示了它可能用到的模糊逻辑控制器，以确定是否施放治疗术：
- en: '![](img/588bc666-d963-4120-8115-78fee8c5bd42.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/588bc666-d963-4120-8115-78fee8c5bd42.png)'
- en: 'We''ve looked at the health question already, but what about the rest? We have
    another set of questions that really don''t mean much to our agent on their own:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了健康问题，但其他问题呢？我们还有另一组问题，单独来看对智能体来说并没有太多意义：
- en: Do you have enough mana? Well, you can have a little bit of mana, some mana,
    or a lot of mana. It would not be uncommon for a human player to ask this question
    as they choose to cast a magic spell in a game or use an ability. "Enough" may
    literally be a binary amount, but more likely, it would be "enough to cast heal,
    and have some left for other spells." We start with a straightforward crisp value–the
    amount of mana the agent has available that we then stick to our fuzzy logic controller
    and get some crisp data at the other end.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你有足够的法力吗？好吧，你可以有一点点法力，一些法力，或者很多法力。一个人类玩家在游戏中选择施放魔法或使用技能时询问这个问题并不罕见。“足够”可能是一个二进制数量，但更有可能的是，“足够施放治疗术，并且还有剩余的法力用于其他法术。”我们从一个简单清晰的价值开始——智能体可用的法力数量，然后将其连接到模糊逻辑控制器，并在另一端获得一些清晰的数据。
- en: What about the enemy's strength? He could be weak, average, strong, or unbeatable.
    You can get creative with the input for your fuzzy logic controllers. You could,
    for example, just take a raw "strength" value from your enemy, but you could also
    take the difference between your "defensive" stat and the enemy's "attack power,"
    and plug that into your fuzzy logic controller. Remember, there is no restriction
    on how you process the data before it goes into the controller.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，敌人的力量如何？他可能是弱的、普通的、强大的或不可战胜的。你可以对你的模糊逻辑控制器输入进行创新。例如，你可以直接从敌人那里获取原始的“力量”值，但你也可以将你的“防御”属性与敌人的“攻击力”之间的差异放入模糊逻辑控制器。记住，在数据进入控制器之前，你处理数据的方式没有限制。
- en: Are my allies close? As we saw in [Chapter 2](9e338555-162c-4ed0-a519-035cfcea94ce.xhtml),
    *Finite State Machines and You*, a simple distance check can do wonders for a
    simple design, but, at times, you may need more than just that. You may need to
    take into account obstacles along the way—is that an ally behind a locked gate,
    making him unable to reach the agent? These types of questions could even be a
    nested set of statements that we need to evaluate.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我的盟友离我近吗？正如我们在[第二章](9e338555-162c-4ed0-a519-035cfcea94ce.xhtml)“有限状态机与您”中看到的，简单的距离检查可以对简单的设计产生神奇的效果，但有时你可能需要更多。你可能需要考虑沿途的障碍——那个在锁着的门后面的盟友，使他无法到达智能体？这类问题甚至可能是一组需要评估的嵌套语句。
- en: 'Now, if we were to take that last question with the nested controllers, it
    might start to look a little familiar:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们用嵌套控制器来处理最后一个问题，它可能开始看起来有点熟悉：
- en: '![](img/caf246da-3954-4a5a-90fe-6ffffd5e77e2.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/caf246da-3954-4a5a-90fe-6ffffd5e77e2.png)'
- en: The preceding figure is quite tree-like, isn't it? Sure enough, there is no
    reason why you couldn't build a behavior tree using fuzzy logic to evaluate each
    node. We end up with a very flexible, powerful, and nuanced AI system by combining
    these two concepts.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示非常像树状结构，不是吗？当然，没有理由不能使用模糊逻辑来评估每个节点，构建一个行为树。通过结合这两个概念，我们最终得到一个非常灵活、强大且细腻的人工智能系统。
- en: Using a simpler approach
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用更简单的方法
- en: 'If you choose to stick with a simple evaluation of the crisp output, in other
    words, not specifically a tree or an FSM, you can use more Boolean operators to
    decide what your agent is going to do. The pseudo code would look like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择坚持使用简单的清晰输出评估，换句话说，不是特定的树或有限状态机，你可以使用更多的布尔运算符来决定你的代理将要做什么。伪代码将如下所示：
- en: '[PRE5]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can check for conditions that are not true:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查不成立的条件：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can also string multiple conditions together:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将多个条件串联起来：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By looking at these simplified statements, you will have noticed yet another
    "happy bonus" of using fuzzy logic—the crisp output abstracts much of the decision-making
    conditionals and combines them into simplified data.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看这些简化的语句，你会注意到使用模糊逻辑的另一个“快乐奖励”——清晰的输出抽象了大部分决策条件，并将它们组合成简化的数据。
- en: Rather than having to parse through all the possibilities in your `if/else`
    statements and ending up with a bazillion of them or a gazillion switch statements,
    you can neatly bundle pockets of logic into fewer, more meaningful chunks of data.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是需要在你的 `if/else` 语句中解析所有可能性，最终导致有成千上万条或者更多 switch 语句，你可以将逻辑块整洁地打包成更少、更有意义的几块数据。
- en: In other words, you don't have to nest all the statements in a procedural way
    that is hard to read and difficult to reuse. As a design pattern, abstracting
    data via a fuzzy logic controller ends up being much more object-oriented and
    friendlier.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你不需要以程序化的方式嵌套所有语句，这样既难以阅读也难以重用。作为一个设计模式，通过模糊逻辑控制器抽象数据最终会变得更加面向对象和友好。
- en: The morality meter example
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 道德计示例
- en: The faction/morality meter example for this chapter covers a slightly different
    approach to implementing fuzzy logic via Unity. We build upon the implementation
    we covered in the basic fuzzy logic example.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的派系/道德计示例通过 Unity 实现模糊逻辑的方法略有不同。我们基于我们在基本模糊逻辑示例中介绍的实施方法进行构建。
- en: In this example, we create a simple dialogue sequence, where the player is presented
    a series of scenarios, or questions, that they can then answer according to their
    morality. For simplicity's sake, we've included a "good," "neutral," and "evil"
    answer for each question. Let's take a look at the code to understand this a bit
    better.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个简单的对话序列，玩家将面对一系列场景或问题，然后根据他们的道德来回答。为了简化起见，我们为每个问题都包含了“好”、“中立”和“邪恶”的答案。让我们看看代码，以便更好地理解这一点。
- en: The question and answer classes
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题和答案类
- en: 'The `Question` and `Answer` classes are very simple, and are used as data containers. 
    Let''s look at the `Question.cs` class first:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Question` 和 `Answer` 类非常简单，用作数据容器。让我们首先看看 `Question.cs` 类：'
- en: '[PRE8]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You may have noticed that the `Question` class does not derive from `MonoBehaviour`.
    It is a plain ol' vanilla C# class. As such, Unity will not serialize it by default,
    and it won't show up in the inspector. To let Unity know you want this class to
    be serialized, use the `System.Serializable` attribute at the top of the class
    definition.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到 `Question` 类并没有从 `MonoBehaviour` 继承。它是一个普通的 C# 类。因此，Unity 默认不会序列化它，它也不会在检查器中显示。为了让
    Unity 知道你想要这个类被序列化，请在类定义的顶部使用 `System.Serializable` 属性。
- en: 'As you can see, it''s only a few lines of code. The first field, `questionText`,
    will be edited via the inspector in a later step. It is the display text for the
    question/scenario we are presenting the user. The `answers` field is an array
    of `Answer` types. The `Answer.cs` code looks like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这只有几行代码。第一个字段 `questionText` 将在后续步骤中通过检查器进行编辑。它是我们向用户展示的问题/场景的显示文本。`answers`
    字段是一个 `Answer` 类型的数组。`Answer.cs` 代码如下：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Again, you'll notice this class is very simple. `answerText` is the text to
    display in the response button for the player, and the `moralityValue` field is
    a hidden value we use to calculate the player's morality alignment later on. For
    this example, we assume that each question has three answers and that the morality
    values are 0, 50, and 100 for each one.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你会注意到这个类非常简单。`answerText` 是用于玩家响应按钮中显示的文本，而 `moralityValue` 字段是我们用来稍后计算玩家道德对齐的隐藏值。在这个例子中，我们假设每个问题有三个答案，每个答案的道德值分别是
    0、50 和 100。
- en: Managing the conversation
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理对话
- en: 'Our `ConversationManager.cs` class is where all the heavy lifting happens for
    this sample. It manages the UI for our conversation, handles events, and calculates
    the results for us. For the first part, we initialize our question array and then
    handle the UI. We set up some variables at the top of the class, which looks like
    this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ConversationManager.cs`类是本示例中所有重头戏发生的地方。它管理我们的对话UI，处理事件，并为我们计算结果。对于第一部分，我们初始化问题数组，然后处理UI。我们在类的顶部设置了一些变量，如下所示：
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We''ll be able to see the UI elements these variables correspond to up ahead,
    but note that we explicitly expect a set number of answers, as we only provide
    three answer buttons for the UI. Of course, you can modify this to be more flexible
    or to fit your needs, but keep in mind that if you want to use more or fewer answers,
    you''ll need to make those changes here as well:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将能够看到这些变量对应的UI元素，但请注意，我们明确期望一个固定的答案数量，因为我们只为UI提供了三个答案按钮。当然，你可以修改它以使其更灵活或满足你的需求，但请记住，如果你想使用更多或更少的答案，你也需要在这里做出相应的更改：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Similar to our previous example, we use Unity''s `AnimationCurve` to specify
    our fuzzy values. We assume a few things with this setup:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的例子类似，我们使用Unity的`AnimationCurve`来指定我们的模糊值。在这个设置中，我们假设了几件事情：
- en: At *t=0*, our "good" value is at 1, and goes down to 0 from there
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*t=0*时，我们的“好”值是1，然后从那里下降到0
- en: At *t=50*, our "neutral" value is at 1
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*t=50*时，我们的“中立”值是1
- en: At *t=100*, our "evil" rating is at 1
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*t=100*时，我们的“邪恶”评分是1
- en: 'These values can be tweaked to your liking, but the current setup works well
    for the example. The following screenshot shows the curves set in the inspector:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值可以根据你的喜好进行调整，但当前的设置对于示例来说效果很好。以下截图显示了在检查器中设置的曲线：
- en: '![](img/cc9d157d-69f7-4fcd-9c74-66ce63711e98.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cc9d157d-69f7-4fcd-9c74-66ce63711e98.png)'
- en: Fuzzy curves for our morality gradient
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们道德梯度的模糊曲线
- en: Notice that the values shown here correspond to our earlier assumption that
    our "good" answer gives a value of 0, our "neutral" answer has a value of 50,
    and our "evil" answer has a value of 100.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里显示的值对应于我们之前的假设，即我们的“好”答案给出0的值，我们的“中立”答案有50的值，我们的“邪恶”答案有100的值。
- en: Loading up the questions
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载问题
- en: 'We provide a simple method named `LoadQuestion` to pull the values from our
    data classes into the UI and display them to the player. The code looks like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个名为`LoadQuestion`的简单方法，用于从我们的数据类中提取值到UI，并显示给玩家。代码如下：
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `LoadQuestion` method takes in a question index, which corresponds to the
    index of the question in the array `questions[]`. We first check that our index
    is in bounds, and end the conversation by calling `EndConversation()` if it isn't.
    If we are in bounds, we just populate the question text and the answer text for
    each answer button.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadQuestion`方法接受一个问题索引，该索引对应于数组`questions[]`中问题的索引。我们首先检查我们的索引是否在范围内，如果不在范围内，就通过调用`EndConversation()`结束对话。如果我们处于范围内，我们只需为每个答案按钮填充问题文本和答案文本。'
- en: Handling user input
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理用户输入
- en: 'The event that gets called when the user presses an answer button on the UI
    is `OnAnswerSubmitted`. The method is quite simple and is only a few lines of
    code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在UI上按下答案按钮时调用的事件是`OnAnswerSubmitted`。该方法相当简单，只有几行代码：
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The method does a few things:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法做了几件事情：
- en: It aggregates the answer value to the answer total. We'll look at how these
    values are assigned up ahead.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将答案值聚合到答案总数中。我们将在下面查看这些值是如何分配的。
- en: It increments the question index value.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它增加问题索引值。
- en: Finally, it calls `LoadQuestion` with the incremented index value from the previous
    bullet.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，它使用前一个要点中增加的索引值调用`LoadQuestion`。
- en: Calculating the results
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算结果
- en: Finally, we have the `EndConversation` method, which, as we saw, gets called
    when we have answered all the questions (and the question index is out of bounds,
    based on our `questions[]` array length).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`EndConversation`方法，正如我们所看到的，当回答了所有问题（并且基于我们的`questions[]`数组长度，问题索引超出范围）时会被调用。
- en: 'The first line simply disables the panel game object containing the question
    UI:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行简单地禁用了包含问题UI的面板游戏对象：
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The calculations are in the next block of code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 计算在下一块代码中：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We calculate the average of all of our answers by taking the `answerTotal` value
    (the sum of all the answers) and dividing it by the number of questions. We then
    individually evaluate each curve for good, neutral, and evil ratings using the
    average value we just calculated. We use the average as our *t* value in the evaluation
    method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将 `answerTotal` 值（所有答案的总和）除以问题的数量来计算所有答案的平均值。然后我们使用刚刚计算出的平均值分别评估每个曲线的好、中、恶评价。我们在评估方法中使用平均值为我们的
    *t* 值。
- en: 'Next, we use some simple `if`logic to determine which rating is higher, as
    seen in the following snippet:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用一些简单的 `if` 逻辑来确定哪个评价更高，如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see in the previous code, we have a little bit of a branching conditional
    structure to determine the highest value, from which we set the `alignmentText`
    value accordingly.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们有一个分支条件结构来确定最高值，然后根据这个值设置 `alignmentText` 的值。
- en: '`if` blocks can get a bit complex if you start to add too many conditions.
    In this case, you may want to consider placing the ratings into an array or dictionary,
    then sorting them, and/or using LINQ to get the highest value from it. For more
    on sorting dictionaries, check out Dot Net Perls:[ https://www.dotnetperls.com/sort-dictionary](https://www.dotnetperls.com/sort-dictionary)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开始添加太多条件，`if` 块可能会变得有些复杂。在这种情况下，您可能想要考虑将评价放入一个数组或字典中，然后对它们进行排序，并/或使用 LINQ
    从中获取最高值。有关排序字典的更多信息，请参阅 Dot Net Perls：[ https://www.dotnetperls.com/sort-dictionary](https://www.dotnetperls.com/sort-dictionary)
- en: 'Lastly, we display the results to the user:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们向用户展示结果：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We simply enable the results panel, and then append `alignmentText` to the
    `"Your morality alignment is:"` message, which would look like this in play mode
    (if you have a "good" rating):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需简单地启用结果面板，然后将 `alignmentText` 添加到 `"您的道德对齐是："` 消息中，在游戏模式中（如果您有“良好”评价）将看起来像这样：
- en: '![](img/c6c093f2-75a5-4ace-a2cb-88f5f86d0af4.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6c093f2-75a5-4ace-a2cb-88f5f86d0af4.png)'
- en: The game screen when you earn a "good" rating
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当你获得“良好”评价时的游戏屏幕
- en: Next up, we can take a look at our scene setup, and how all of our values get
    initialized for the sample project.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以看看我们的场景设置，以及所有值是如何在示例项目中初始化的。
- en: Scene setup
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景设置
- en: 'When you first open the `FactionScene` example scene, you''ll notice a UI that
    looks like this screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当您首次打开 `FactionScene` 示例场景时，您会注意到一个看起来像这张截图的用户界面：
- en: '![](img/a408ae35-dfa6-4a9c-955a-2f2132d845e9.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a408ae35-dfa6-4a9c-955a-2f2132d845e9.png)'
- en: The sample scene UI setup
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 示例场景用户界面设置
- en: 'As you can see in the preceding screenshot, the UI comprises several different
    panels, and the text components have been initialized with some sample text to
    help organize everything nicely. The hierarchy for the scene is shown in this
    screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一张截图所示，用户界面由几个不同的面板组成，文本组件已经用一些示例文本初始化，以帮助组织一切。场景的层次结构如下所示：
- en: '![](img/ae2bba4a-1f71-4bf3-8260-f70818273260.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae2bba4a-1f71-4bf3-8260-f70818273260.png)'
- en: The FactionScene hierarchy
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: FactionScene 层次结构
- en: As you can see, our canvas has two main panels at the root level—the QuestionPanel and
    a ResultPanel, which is disabled by default. This is because, as you may remember,
    we set that panel to `enabled` via code in our `EndConversation` method. At the
    bottom of the list, we have our ConversationManager game object, which contains
    our `ConversationManager` script.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的画布在根级别有两个主要面板——QuestionPanel 和默认禁用的 ResultPanel。这是因为，如您可能记得的，我们在 `EndConversation`
    方法中通过代码将此面板设置为 `enabled`。列表底部是我们的 ConversationManager 游戏对象，其中包含我们的 `ConversationManager`
    脚本。
- en: 'If you select it, you''ll see that the inspector looks like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择它，您会看到检查器看起来像这样：
- en: '![](img/47ab095e-b278-4db0-a55e-a51a37187a69.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47ab095e-b278-4db0-a55e-a51a37187a69.png)'
- en: The inspector for our Conversation Manager with all the values assigned
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 Conversation Manager 的检查器，所有值都已分配
- en: At first glance, the amount of information here may seem daunting, but let's
    take a look at each step, and you'll realize we've covered all of this already.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 初看，这里的信息量可能看起来令人畏惧，但让我们看看每一步，您会发现我们已经涵盖了所有这些内容。
- en: We first have our serialized array of questions. In this case, we have three
    questions (feel free to add more!). Each question then contains an array of (exactly)
    three answers, and the question text we saw earlier. For each answer, we have
    the answer text and morality value we saw earlier as well. Note that the order
    of the questions or answers doesn't necessarily matter, so long as your morality
    value corresponds to good, neutral, or evil.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先有一个序列化的问题数组。在这种情况下，我们有三个问题（请随意添加更多！）。每个问题包含一个（正好）三个答案的数组，以及我们之前看到的提问文本。对于每个答案，我们都有之前看到的答案文本和道德价值。请注意，问题或答案的顺序并不一定重要，只要你的道德价值对应于善良、中立或邪恶。
- en: We then have the UI section, in which we assign all the necessary elements.
    Everything in the hierarchy is named appropriately to make it easy to ensure that
    each field is populated with the correct game object.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是UI部分，其中我们分配所有必要的元素。层次结构中的每个元素都适当地命名，以便确保每个字段都填充了正确的游戏对象。
- en: Lastly, we have the morality curves that we saw previously. Again, feel free
    to tweak these to your heart's content!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有之前看到的道德曲线。再次提醒，请随意调整到您满意的程度！
- en: Testing the example
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试示例
- en: All that's left is to test the example! Hit play, and select some answers. The
    scenario provided puts you in the shoes of an adventurer heading into town. On
    his way, he encounters a goblin, a banker, and a knight. What would you do in
    each scenario? Feel free to play around with the wording, and add your own moral
    dilemmas!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是测试示例了！点击播放，并选择一些答案。提供的场景让你扮演一个进入城镇的冒险者。在他的路上，他遇到了一个哥布林、一个银行家和一位骑士。你会在每种情况下做什么？请随意玩弄措辞，并添加你自己的道德困境！
- en: Finding other uses for fuzzy logic
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找模糊逻辑的其他用途
- en: Fuzzy data is very peculiar and interesting in that it can be used in tandem
    with all of the major concepts we have introduced in this book. We saw how a series
    of fuzzy logic controllers can easily fit into a behavior tree structure, and
    it's not terribly difficult to imagine how it could be used with an FSM.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊数据非常奇特且有趣，因为它可以与我们在本书中介绍的所有主要概念一起使用。我们看到了一系列模糊逻辑控制器如何轻松地适应行为树结构，并且不难想象它如何与FSM一起使用。
- en: Merging with other concepts
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与其他概念合并
- en: 'Sensory systems also tend to make use of fuzzy logic. While seeing something
    can be a binary condition, in low-light or low-contrast environments, we can suddenly
    see how fuzzy the condition can become. You''ve probably experienced it at night:
    seeing an odd shape, dark in the distance, in the shadows, thinking "is that a
    cat?". It then turns out to be a trash bag, some other animal, or perhaps even
    your imagination. The same can be applied to sounds and smells.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 感官系统也倾向于使用模糊逻辑。虽然看到某物可能是一个二元条件，但在低光或低对比度环境中，我们可能会突然看到条件可以变得多么模糊。你可能晚上有过这样的经历：看到远处的一个奇怪的形状，在阴影中，你可能会想“那是一只猫吗？”结果却是一只垃圾袋，或其他动物，甚至可能是你的想象。同样的情况也适用于声音和气味。
- en: When it comes to pathfinding, we run into the cost of traversing certain areas
    of a grid, which a fuzzy logic controller can easily help to fuzzify and make
    more interesting.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到路径查找时，我们会遇到穿越网格某些区域的成本，模糊逻辑控制器可以轻松地帮助模糊化并使其更有趣。
- en: Should Bob cross the bridge and fight his way through the guards, or risk crossing
    the river and fighting the current? Well, if he's a good swimmer and a poor fighter,
    the choice is clear, right?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃应该过桥与守卫战斗，还是冒险过河与水流战斗？嗯，如果他是一个好的游泳者但不是一个好的战士，选择是明显的，对吧？
- en: Creating a truly unique experience
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创造真正独特的体验
- en: Our agents can use fuzzy logic to mimic personalities. Some agents may be more
    "brave" than others. Suddenly, their personal characteristics—how fast they are,
    how far they can run, their size, and so on—can be leveraged to arrive at the
    decisions that are unique to that agent.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的人工智能代理可以使用模糊逻辑来模仿性格。一些代理可能比其他代理更“勇敢”。突然，他们的个人特征——他们的速度、他们能跑多远、他们的体型等——可以被用来做出独特的决策。
- en: Personalities can be applied to enemies, allies and friends, NPCs, or even to
    the rules of the game. The game can take in crisp data from the player's progress,
    style of play, or level of progression, and dynamically adjust the difficulty
    to provide a more unique and personalized challenge.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 性格可以应用于敌人、盟友和好友、NPC，甚至可以应用于游戏规则。游戏可以从玩家的进度、游戏风格或进度水平中获取清晰的数据，并动态调整难度，以提供更独特和个性化的挑战。
- en: Fuzzy logic can even be used to dole out the technical game rules, such as the
    number of players in a given multiplayer lobby, the type of data to display to
    the player, and even how players are matched against other players. Taking the
    player's statistics and plugging those into a matchmaking system can help keep
    the player engaged by pitting them against the players that either match their
    style of play in a cooperative environment or players of a similar skill level
    in a competitive environment.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊逻辑甚至可以用来分配技术游戏规则，例如给定多人游戏大厅中的玩家数量、向玩家显示的数据类型，甚至如何将玩家与其他玩家匹配。将玩家的统计数据输入到匹配系统中，可以通过让玩家在与风格相似的合作环境中对抗匹配他们的游戏风格，或在竞争环境中对抗技能水平相似的玩家来保持玩家的参与度。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: I'm glad to see that you've made it to the end of the chapter. Fuzzy logic tends
    to become far less fuzzy once you understand the basic concepts. Being one of
    the more pure math concepts in the book, it can be a little daunting if you're
    not familiar with the lingo, but when presented in a familiar context, the mystery
    fades away, and you're left with a very powerful tool to use in your game.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我很高兴看到你已经到达了这一章的结尾。一旦你理解了基本概念，模糊逻辑就会变得不再那么模糊。作为书中较为纯粹数学概念之一，如果你不熟悉术语，可能会觉得有点令人畏惧，但一旦在熟悉的环境中呈现，神秘感就会消失，你将拥有一个在游戏中使用的非常强大的工具。
- en: We learned how fuzzy logic is used in the real world, and how it can help illustrate
    vague concepts in a way that binary systems cannot. We also learned how to implement
    our own fuzzy logic controllers using the concepts of member functions, degrees
    of membership, and fuzzy sets. In addition to this, we also played around with
    a faction/morality system to further illustrate the concept of fuzzy logic in
    the context of a choose-your-own-adventure-style interaction. Lastly, we explored
    the various ways in which we can use the resulting data, and how it can help make
    our agents more unique.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了模糊逻辑在现实世界中的应用，以及它如何以二进制系统无法实现的方式帮助说明模糊概念。我们还学习了如何使用成员函数、隶属度和模糊集的概念来实现我们自己的模糊逻辑控制器。除此之外，我们还尝试了一个派系/道德系统，以进一步说明在自选冒险风格交互中的模糊逻辑概念。最后，我们探讨了我们可以使用结果的多种方式，以及它如何帮助使我们的智能体更加独特。
- en: In the final chapter, we will look at several of the concepts introduced in
    this book working together.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章，我们将探讨这本书中介绍的一些概念是如何共同工作的。
