- en: Creating an E2E Web App Using DL APIs and Customer Support Chatbot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 DL API 和客户支持聊天机器人创建 E2E Web 应用程序
- en: In this chapter, we will draw together several tools and methods that we have
    learned how to use in previous chapters of this book, as well as introducing some
    great new tools and techniques, as well. This chapter covers a very important
    facet of an enterprise—customer support. For a budding business, customer support
    can be exhausting and frustrating to keep up with. More often than not, the questions
    raised by customers are easily answerable by referring to documentation or a set
    of FAQ answers provided by the company on their website, but customers don't often
    read through them. So, it would be great to have a layer of automation in place,
    where the most common queries will be answered by a chatbot that is always available
    and responsive throughout the day.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将整合之前章节中学习过的多个工具和方法，并引入一些全新的工具和技术。本章涵盖了企业非常重要的一个方面——客户支持。对于一个新兴的企业来说，客户支持可能既耗时又让人沮丧。客户提出的问题，通常通过查阅公司网站上提供的文档或常见问题解答（FAQ）就能轻松解答，但客户往往不愿意仔细阅读这些内容。因此，能够引入一层自动化，利用聊天机器人来回答最常见的查询，并确保该聊天机器人全天候响应，将会是一个极好的解决方案。
- en: This chapter discusses how to create a chatbot using Dialogflow to resolve general
    customer support queries and how to integrate it into a Django-based website.
    Furthermore, the chatbot will draw its answers from a Django API, which will be
    hosted separately. We'll explore ways of implementing bot personalities and introduce
    a method of implementing **Text-to-Speech** (**TTS**)- and **Speech-to-Text**
    (**STT**)-based user interfaces via the Web Speech API, which deploys neural networks
    right to the user's browser.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论如何使用 Dialogflow 创建聊天机器人以解决一般的客户支持问题，并将其集成到基于 Django 的网站中。此外，聊天机器人将从 Django
    API 中获取答案，该 API 将被单独托管。我们将探索如何实现聊天机器人个性，并介绍如何通过 Web Speech API 实现基于**语音合成**（**TTS**）和**语音转文本**（**STT**）的用户界面，该
    API 将神经网络直接部署到用户的浏览器中。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: An introduction to NLP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自然语言处理（NLP）简介
- en: An introduction to chatbots
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聊天机器人简介
- en: Creating a Dialogflow bot with the personality of a customer support representative
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个拥有客户支持代表个性的 Dialogflow 聊天机器人
- en: Using ngrok to facilitate HTTPS APIs on localhost
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ngrok 来便利本地 HTTPS API
- en: Creating a testing UI using Django for managing orders within a company
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Django 创建一个管理公司内部订单的测试用户界面
- en: Speech recognition and speech synthesis on a web page using the Web Speech API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Web Speech API 在网页上实现语音识别和语音合成
- en: We will be drawing insights from what we have learned in previous chapters and
    building on them, while at the same time revising a few concepts and introducing
    new ones along the way. Let's begin by understanding **Natural Language Processing**
    (**NLP**).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于之前章节所学的内容，进一步深入并加以扩展，同时修正一些概念，并在过程中引入新的概念。让我们从了解**自然语言处理**（**NLP**）开始。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can access the code for this chapter at [https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/tree/master/Chapter12](https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/tree/master/Chapter12).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/tree/master/Chapter12](https://github.com/PacktPublishing/Hands-On-Python-Deep-Learning-for-Web/tree/master/Chapter12)访问本章的代码。
- en: 'You''ll need the following software to run the code used in this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 运行本章代码所需的软件：
- en: Python 3.6+
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.6+
- en: Django 2.x
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django 2.x
- en: All other installations will be covered during the course of this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 其他所有安装内容将在本章中进行讲解。
- en: An introduction to NLP
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自然语言处理（NLP）简介
- en: A popular—and one of the most exciting—fields of machine learning and deep learning
    applications is NLP, which refers to a collection of techniques and methods developed
    to understand and generate human language. The goals of NLP begin with comprehending
    the meaning of human language text and extend to generating human language, such
    that the generated sentences are meaningful and make sense to humans who read
    that text. NLP has found major usage in building systems that are able to take
    instructions and requests directly from humans in the form of natural language,
    such as chatbots. However, chatbots also need to respond in natural language,
    which is another aspect of NLP.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 自然语言处理（NLP）是机器学习和深度学习应用中一个受欢迎且令人兴奋的领域，它指的是一系列旨在理解和生成自然语言的技术和方法。NLP的目标从理解人类语言文本的意义开始，扩展到生成有意义且让人类理解的自然语言句子。NLP已经广泛应用于构建能够直接从人类获取指令和请求的系统，如聊天机器人。然而，聊天机器人也需要用自然语言进行回应，这是NLP的另一个方面。
- en: Let's study some common terms related to NLP.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来研究一些与NLP相关的常见术语。
- en: Corpus
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语料库
- en: You will often come across the term **corpus** while you are studying NLP. In
    layman's terms, a corpus is a collection of writings from any one author or from
    a genre of literature. In the study of NLP, the dictionary definition of corpus
    gets a bit modified and can be stated as a collection of written text documents,
    such that they can all be categorized together by any metric of choice. These
    metrics might be authors, publishers, genres, types of writing, ranges of time,
    and other features associated with written texts.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习自然语言处理（NLP）时，你会经常遇到**语料库**这个术语。通俗来说，语料库是指某个作者的作品集或某个文学体裁的作品集。在NLP研究中，语料库的字典定义略有修改，可以表述为一组书面文本文件，这些文本可以根据选择的任何标准进行分类。这些标准可能包括作者、出版商、体裁、写作类型、时间范围以及与书面文本相关的其他特征。
- en: For example, a collection of Shakespeare's works or the threads on any forum
    for any given topic can both be considered a corpus.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一部莎士比亚的作品集或某个论坛上关于某个话题的所有帖子都可以被视为语料库。
- en: Parts of speech
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 词类
- en: When we decompose a sentence into its constituent words and perform a qualitative
    analysis of what each of the words of the sentence contributes to the overall
    meaning of that sentence, we perform the act of determining parts of speech. So,
    parts of speech are notations provided to words in a sentence based on how those
    words contribute to the meaning of the sentence.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将一个句子分解成各个单词，并对句子中每个单词对整个句子意义的贡献进行定性分析时，我们就进行了一种确定词类的操作。因此，词类是根据单词在句子中如何贡献句子意义而为单词提供的标注。
- en: In the English language, we commonly have eight types of parts of speech—the
    verb, the noun, the pronoun, the adjective, the adverb, the preposition, the conjunction,
    and the interjection.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，我们通常有八种词类——动词、名词、代词、形容词、副词、介词、连词和感叹词。
- en: For example, in the sentence "Ram is reading a book", "Ram" is a noun and the
    subject, "reading" is a word and the action, and "book" is a noun and the object.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在句子“Ram is reading a book”中，“Ram”是名词且是主语，“reading”是动词且是动作，“book”是名词且是宾语。
- en: You can read more about parts of speech at [http://partofspeech.org/](http://partofspeech.org/).
    You can try finding out the parts of speech of your own sentences at [https://linguakit.com/en/part-of-speech-tagging](https://linguakit.com/en/part-of-speech-tagging).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://partofspeech.org/](http://partofspeech.org/)上了解更多关于词类的信息。你也可以尝试在[https://linguakit.com/en/part-of-speech-tagging](https://linguakit.com/en/part-of-speech-tagging)上找出你自己句子的词类。
- en: Tokenization
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分词
- en: Tokenization is the process of breaking down documents into sentences and sentences
    into words. This is important because it would be a computational nightmare if
    any computer program attempted to process entire documents as single strings,
    due to the resource-intensiveness associated with processing strings.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 分词是将文档拆解成句子，再将句子拆解成单词的过程。这一点非常重要，因为如果任何计算机程序试图将整个文档作为一个单一字符串进行处理，会变得极为复杂，处理字符串所需的资源也会极其庞大。
- en: Furthermore, it is very rare that all sentences need to be read at once to be
    able to understand the meaning of an entire document. Often, each sentence has
    its own discrete meaning that can be assimilated with other sentences in the document
    by statistical methods to determine the overall meaning and content of any document.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通常不需要一次性阅读所有句子就能理解整个文档的含义。通常，每个句子都有其独立的含义，通过统计方法与文档中的其他句子结合，可以确定文档的整体意义和内容。
- en: Again, we often need to break down sentences into words in order to better process
    the sentence, such that the meaning of the sentence can be generalized and derived
    from a dictionary, where each word is listed individually.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们通常需要将句子拆解为单词，以便更好地处理句子，使句子的含义可以从字典中推导出来，其中每个单词都会单独列出。
- en: Stemming and lemmatization
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 词干提取和词形还原
- en: Stemming and lemmatization are closely related terms in NLP, but with a slight
    but significant difference. The objective of both methods is to determine the
    root word that any given word originates from, such that any derivates of the
    root word can be matched to the root word in the dictionary.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 词干提取和词形还原是自然语言处理中密切相关的术语，但它们之间有细微但重要的区别。两种方法的目标都是确定任何给定单词的词根，以便将该单词的派生形式与字典中的词根进行匹配。
- en: Stemming is a rule-based process where the words are trimmed and sometimes appended
    with modifiers that indicate its root word. However, stemming might, at times,
    produce root words that don't exist in the human dictionary and so mean nothing
    to the human reader.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 词干提取是一个基于规则的过程，其中单词会被修剪，有时会附加指示其词根的修饰符。然而，词干提取有时可能会生成在字典中不存在的词根，这样的词根对人类读者来说没有任何意义。
- en: Lemmatization is the process of converting words to their lemma, or their root
    word, as given in the dictionary. So, the originally intended meaning of the word
    can be derived from a human dictionary, making lemmatized text easier to work
    with than stemmed text. Furthermore, lemmatization takes into consideration the
    part of speech that any word is in any given sentence before determining its correct
    lemma, which a stemming algorithm overlooks. This makes lemmatization more context-aware
    than stemming.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 词形还原是将单词转换为其词根或词典中给出的基本形式的过程。因此，单词原本的含义可以从人类字典中推导出来，使得词形还原后的文本比词干提取文本更容易处理。此外，词形还原会考虑单词在句子中的词性，再确定其正确的词根，而词干提取算法则忽略这一点。这使得词形还原比词干提取更能理解上下文。
- en: Bag of words
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 词袋模型
- en: It is not possible for computers to directly process and work with text. Hence,
    all text must be converted into numbers before being fed into a machine learning
    model. The process of changing text to an array of numbers, such that it is possible
    to retrieve the most important pieces of the original text from the converted
    text at any point in time, is known as feature extraction or encoding. **Bag of
    Words** (**BoW**) is one popular and simple technique used to perform feature
    extraction on text.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机无法直接处理和处理文本。因此，所有文本在输入到机器学习模型之前必须转换为数字。将文本转换为一组数字的过程，使得在任何时候都可以从转换后的文本中提取出原始文本中最重要的部分，这个过程称为特征提取或编码。**词袋模型**（**BoW**）是执行文本特征提取的一个常见且简单的技术。
- en: 'The steps associated with a BoW implementation are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 词袋模型实现的步骤如下：
- en: Extract all the unique words from the document.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文档中提取所有唯一单词。
- en: Create a single vector with all the unique words in the document.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含文档中所有唯一单词的向量。
- en: Convert each document into a Boolean array based on whether any word in the
    word vector is present in that document or not.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据单词向量中的任何单词是否出现在该文档中，将每个文档转换为一个布尔数组。
- en: 'For example, consider the following three documents:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下三篇文档：
- en: Ram is a boy.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ram是一个男孩。
- en: Ram is a good boy.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ram是一个好男孩。
- en: Ram is not a girl.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ram不是女孩。
- en: The unique words present in these documents can be listed in a vector as ["Ram",
    "is", "a", "boy", "good", "not", "girl"].
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文档中出现的唯一单词可以列在一个向量中，表示为["Ram", "is", "a", "boy", "good", "not", "girl"]。
- en: 'So, each sentence can be converted as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个句子可以转换如下：
- en: '[1, 1, 1, 1, 0, 0, 0]'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[1, 1, 1, 1, 0, 0, 0]'
- en: '[1, 1, 1, 1, 1, 0, 0]'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[1, 1, 1, 1, 1, 0, 0]'
- en: '[1, 1, 1, 0, 0, 1, 1]'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[1, 1, 1, 0, 0, 1, 1]'
- en: You will observe that BoW tends to lose the information of where each word appears
    in the sentence or what meaning it contributes to the sentence. So, BoW is a very
    basic method of feature extraction and may not be suitable for several applications
    that require context-awareness.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现，BoW方法往往会丢失每个词语在句子中出现的位置或它对句子的贡献。因此，BoW是一个非常基础的特征提取方法，可能不适用于那些需要上下文感知的应用。
- en: Similarity
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相似度
- en: The similarity is the measure of how similar any two given sentences are. It
    is a very popular operation in the domain of computer science, and anywhere where
    records are maintained, for searching the right documents, searching words in
    any document, authentication, and other applications.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 相似度是衡量两句给定句子相似程度的标准。它是计算机科学领域中一个非常常见的操作，适用于所有需要维护记录的地方，如搜索正确文档、在文档中查找单词、身份验证及其他应用。
- en: There are several ways of calculating the similarity between any two given documents.
    The Jaccard index is one of the most basic forms, which computes the similarity
    of two documents based on the percentage ratio of the number of tokens that are
    the same in both documents over the total unique tokens in the documents.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 计算两个文档之间相似度的方法有很多。Jaccard指数是最基本的形式之一，它基于两个文档中相同的标记数量占文档中所有唯一标记总数的百分比来计算相似度。
- en: Cosine similarity is another very popular similarity index, which is computed
    by calculating the cosine formed between the vectors of two documents when converted
    into vectors using BoW or any other feature-extraction technique.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 余弦相似度是另一种非常流行的相似度指标，它通过计算将两个文档转化为向量后，两个向量之间形成的余弦角度来计算相似度，通常通过BoW或其他特征提取技术进行向量化。
- en: With these concepts in mind, let's move on to studying chatbots, which are one
    of the most popular forms of application of NLP.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记这些概念后，让我们继续研究聊天机器人，它们是自然语言处理应用中最流行的形式之一。
- en: An introduction to chatbots
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聊天机器人简介
- en: Chatbots are a segment of application of NLP that deals specifically with conversational
    interfaces. These interfaces can also expand their work to handle rudimentary
    commands and actions and are, in these cases, termed voice-based virtual assistants.
    Voice-based virtual assistants have been on the rise recently with the introduction
    of dedicated devices such as Google Home and Alexa by Amazon.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天机器人是自然语言处理（NLP）应用的一部分，专门处理对话界面。这些界面也可以扩展其功能，处理基础的命令和动作，这时它们被称为基于语音的虚拟助手。随着Google
    Home和Amazon的Alexa等专用设备的推出，基于语音的虚拟助手最近得到了快速发展。
- en: Chatbots can exist in multiple forms. They don't need to only be present as
    virtual assistants. You could talk to a chatbot in a game, where it tries to draw
    a storyline in a certain direction, or you could interact with the social chatbots
    that some companies use to reply to their customers on social media platforms,
    such as Twitter or Facebook. Chatbots can be considered a move over **Interactive
    Voice Response** (**IVR**) systems, with their added intelligence and ability
    to respond to unknown input, sometimes merely with a fallback reply or sometimes
    with a calculated response that draws on the input provided.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天机器人可以以多种形式存在。它们不需要仅仅作为虚拟助手出现。你可以在游戏中与聊天机器人互动，它会试图将故事情节引导向某个方向，或者你也可以与一些公司在社交媒体平台（如Twitter或Facebook）上使用的社交聊天机器人互动，回复客户的消息。聊天机器人可以被视为**互动语音响应**（**IVR**）系统的升级，具备了更高的智能和应对未知输入的能力，有时仅仅是回复一个默认的答复，有时则能根据提供的输入进行精确的计算性回应。
- en: A virtual assistant can also exist on a website, giving instructions and offering
    help to visitors. Assistants such as these are regularly found on websites, mostly
    offering instant support to consumer queries. You must have noticed the "Ask a
    question" or "May I help you" chatboxes, usually at the bottom-right side of the
    screen, on several websites that sell products or services. More often than not,
    they employ the use of automated chatbots instead of real people to answer queries.
    Only in cases where the query is too complex to be answered by the automated customer
    support chatbot is the query transferred to a real person.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟助手也可以存在于网站上，提供指导并为访问者提供帮助。这类助手通常出现在网站上，主要为消费者提供即时的查询支持。你一定见过许多网站上，通常位于屏幕右下角的“提问”或“我能帮你吗”聊天框。这些网站通常会用自动化的聊天机器人代替真人来回答查询。只有在查询过于复杂，无法通过自动化客服聊天机器人回答时，查询才会转交给真人客服。
- en: Creating conversational UIs is an art in itself. You need to be able to use
    words that are clear yet natural to a spoken tongue. You can learn more about
    creating conversational UIs at [https://designguidelines.withgoogle.com/conversation](https://designguidelines.withgoogle.com/conversation/).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 创建对话式UI本身就是一门艺术。你需要使用既清晰又自然的语言。你可以在[https://designguidelines.withgoogle.com/conversation](https://designguidelines.withgoogle.com/conversation/)了解更多关于创建对话式UI的内容。
- en: In the next section, we will work on creating a chatbot that acts as a customer
    support agent.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将创建一个充当客户支持代理的聊天机器人。
- en: Creating a Dialogflow bot with the personality of a customer support representative
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个具有客户支持代表个性的Dialogflow机器人
- en: Dialogflow is a very popular tool used to create chatbots. Similar to Wit.ai,
    Botpress, Microsoft Bot Framework, and several other ready-to-deploy services
    available for creating chatbots, Dialogflow comes with the added advantage of
    its tight integration with **Google Cloud Platform** (**GCP**) and the possibility
    of using Dialogflow agents as actions for the Google Assistant, which runs natively
    on billions of Android devices.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Dialogflow是一个非常流行的工具，用于创建聊天机器人。与Wit.ai、Botpress、Microsoft Bot Framework以及其他一些现成的聊天机器人创建服务类似，Dialogflow的优势在于它与**Google
    Cloud Platform**（**GCP**）的紧密集成，并且可以将Dialogflow代理作为Google Assistant的动作，Google Assistant原生运行在数十亿台Android设备上。
- en: Dialogflow was formerly known as Api.ai. After its acquisition by Google, it
    was renamed and has since grown in its popularity and extensibility. The platform
    allows very easy integration with several platforms, such as Facebook Messenger,
    Telegram, Slack, Line, Viber, and several other major communication platforms.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Dialogflow曾用名Api.ai。自从被Google收购后，它更名为Dialogflow，并在流行度和可扩展性方面得到了提升。该平台允许与多个平台进行非常容易的集成，如Facebook
    Messenger、Telegram、Slack、Line、Viber等多个主要通信平台。
- en: 'The project we will develop in this chapter will follow the following architecture
    diagram:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中开发的项目将遵循以下架构图：
- en: '![](img/a41d094b-e97b-407c-917d-75e3604a9f83.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a41d094b-e97b-407c-917d-75e3604a9f83.png)'
- en: We will use several libraries and services that are not mentioned in the preceding
    diagram. We'll introduce them during the course of the project and discuss why
    it is interesting for us to know about them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一些在前面的图示中未提及的库和服务。我们会在项目过程中介绍这些库和服务，并讨论为什么了解它们对我们来说很有趣。
- en: Getting started with Dialogflow
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Dialogflow
- en: To get started with Dialogflow, you should head to the official website, at
    [https://dialogflow.com](https://dialogflow.com), to get to the home page, which
    displays the product information and links to the documentation. It is always
    a great idea to study the documentation of any product or service you're trying
    to learn because it includes the entirety of the software's workings and functionalities.
    We will refer to sections in the documentation in the upcoming sections of this
    chapter.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Dialogflow，你应该访问其官方网站[https://dialogflow.com](https://dialogflow.com)，进入首页，页面上显示产品信息并链接到文档。学习你想要掌握的任何产品或服务的文档总是一个好主意，因为它包含了软件的全部工作原理和功能。我们将在本章的后续部分引用文档中的一些章节。
- en: You can find the Dialogflow documentation at [https://cloud.google.com/dialogflow/docs/](https://cloud.google.com/dialogflow/docs/).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://cloud.google.com/dialogflow/docs/](https://cloud.google.com/dialogflow/docs/)找到Dialogflow的文档。
- en: Dialogflow is closely integrated with GCP and so we must first create a Google
    account. To do so, create an account by going to [https://account.google.com](https://account.google.com).
    You might have to provide a number of permissions on your Google account if you
    are using your account for the first time with Dialogflow.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Dialogflow与GCP紧密集成，因此我们必须首先创建一个Google帐户。为此，请访问[https://account.google.com](https://account.google.com)创建帐户。如果你是第一次使用自己的Google帐户与Dialogflow配合使用，可能需要提供一些权限。
- en: Let's move on to the steps to explore and understand the Dialogflow account
    creation process and the various parts of the UI.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探讨如何了解Dialogflow帐户创建过程以及UI的各个部分。
- en: Step 1 – Opening the Dialogflow console
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一步 – 打开Dialogflow控制台
- en: 'You need to click on the Go to console button at the top-right corner of the
    page at [https://dialogflow.com](https://dialogflow.com). Alternatively, you can
    type [https://dialogflow.cloud.google.com/](https://dialogflow.cloud.google.com/)
    in your browser. If you''re a first-time user, you will see a screen as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要点击页面右上角的“转到控制台”按钮，网址是[https://dialogflow.com](https://dialogflow.com)。或者，您可以在浏览器中输入[https://dialogflow.cloud.google.com/](https://dialogflow.cloud.google.com/)。如果您是第一次使用，您将看到如下屏幕：
- en: '![](img/3f63c63f-055e-418d-ab6b-1584c6ee3e17.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f63c63f-055e-418d-ab6b-1584c6ee3e17.png)'
- en: The dashboard prompts you to create a new agent.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表盘提示您创建一个新代理。
- en: Step 2 – Creating a new agent
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2步 – 创建新代理
- en: We will now create a Dialogflow agent. In terms of Dialogflow, an agent is another
    name for a chatbot. It is the agent that receives, processes, and responds to
    all input provided by the user.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个Dialogflow代理。在Dialogflow中，代理是聊天机器人的另一个名称。正是这个代理接收、处理并响应用户提供的所有输入。
- en: Click on the Create Agent button and fill in the required information about
    the agent to your liking, which includes the agent's name, the default language,
    the timezone, and the Google project name.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“创建代理”按钮，并根据自己的需求填写代理的相关信息，包括代理的名称、默认语言、时区和Google项目名称。
- en: If you haven't used GCP prior to this step, you'll have to create a project.
    We've discussed the creation of GCP projects in [Chapter 6](093890b6-051d-49f9-9330-bdd58b92a762.xhtml),
    *Deep Learning on Google Cloud Platform Using Python*. Alternatively, you can
    simply let GCP automatically create a new project for you when creating the agent.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在这一步之前您没有使用过GCP，您需要创建一个项目。我们在[第六章](093890b6-051d-49f9-9330-bdd58b92a762.xhtml)《*使用Python在Google
    Cloud Platform上进行深度学习*》中讨论过创建GCP项目。或者，您也可以在创建代理时让GCP自动为您创建一个新项目。
- en: Step 3 – Understanding the dashboard
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3步 – 了解仪表盘
- en: 'After the successful creation of a Dialogflow agent, you''ll be presented with
    a dashboard like that in the following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功创建Dialogflow代理后，您将看到如下截图中的仪表盘：
- en: '![](img/9dc140c8-5a57-428c-8d95-fe121fb43532.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9dc140c8-5a57-428c-8d95-fe121fb43532.png)'
- en: On the left, you can see a menu containing the various components that make
    up the chatbot. This menu is going to be very useful and you should take a good
    look at all its contents to make sure you understand what we're referring to in
    the menu items. When we use sentences such as "Click on Entities", we mean we
    want you to click on the Entities item in this menu.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，您可以看到包含构成聊天机器人的各种组件的菜单。这个菜单非常有用，您应该仔细查看其中的所有内容，确保您理解我们在菜单项中所提到的内容。当我们使用诸如“点击实体”的句子时，我们指的是让您点击菜单中的“实体”项。
- en: The center section will hold different content depending upon which component
    in the menu has been clicked on. By default, when you open the Dialogflow console,
    it contains the list of intents of the chatbot. What are intents?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 中间部分将根据菜单中点击的组件而显示不同的内容。默认情况下，当您打开Dialogflow控制台时，它会显示聊天机器人的意图列表。什么是意图？
- en: 'An intent is an action that a user wishes to perform by any utterance they
    make to the chatbot. For example, when the user says `Bring me a cup of coffee`,
    their intent is to ask the chatbot to "bring coffee":'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 意图是用户通过任何对聊天机器人的话语想要执行的操作。例如，当用户说`给我一杯咖啡`时，他们的意图是让聊天机器人“拿来咖啡”：
- en: '![](img/b455813e-a6a5-486d-af4d-83efcfcd4c80.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b455813e-a6a5-486d-af4d-83efcfcd4c80.png)'
- en: On the far right, a panel is provided to test the chatbot at any moment. You
    can write any input text you wish to test the chatbot's response against and you'll
    be presented with a slew of information, along with the response that the chatbot
    produces.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在最右侧，提供了一个面板，可以随时测试聊天机器人的响应。您可以输入任何文本，测试聊天机器人的响应，系统将提供一堆信息和聊天机器人生成的响应。
- en: 'Consider the following testing input and response:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下测试输入和响应：
- en: '![](img/1c8a88f2-9d9a-4fbf-92cd-6ed636277b4e.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c8a88f2-9d9a-4fbf-92cd-6ed636277b4e.png)'
- en: When the user inputs `What is my order status`, the chatbot replies asking for
    the order ID of the order in question. This is matched to the `CheckOrderStatus`
    intent and requires a parameter named `OrderId`. We will be using this console
    regularly through this project to debug the chatbot during development.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入`我的订单状态是什么`时，聊天机器人会询问订单ID。这个请求会与`CheckOrderStatus`意图匹配，并需要一个名为`OrderId`的参数。我们将在本项目中定期使用此控制台来调试聊天机器人。
- en: While in the previous screenshots we've shown you a pre-configured agent with
    intents, your newly created agent won't have any custom intents at this point.
    Let's create them!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的截图中，我们向您展示了一个预配置的代理及其意图，而您新创建的代理此时还没有任何自定义意图。让我们来创建它们吧！
- en: Step 4 – Creating the intents
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 步 – 创建意图
- en: Now, let's create two intents. One intent will offer help to the user and the
    other will carry out a check on the status of the order ID provided by the user.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来创建两个意图。一个意图将为用户提供帮助，另一个则会检查用户提供的订单 ID 的状态。
- en: Step 4.1 – Creating HelpIntent
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4.1 步 – 创建 HelpIntent
- en: In this sub-step, click on the + button that is to the right of the Intents
    item in the left-hand side menu. You will be presented with a blank intent creation
    form.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在此子步骤中，点击左侧菜单中“Intents”项右侧的 + 按钮。您将看到一个空白的意图创建表单。
- en: 'You will be able to see the following headings in the intent creation form:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在意图创建表单中，您将能够看到以下标题：
- en: '![](img/e229400a-7d81-4313-80b8-0ed1a34a5b3f.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e229400a-7d81-4313-80b8-0ed1a34a5b3f.png)'
- en: For this intent, fill Intent Name in as `HelpIntent`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此意图，填写意图名称为`HelpIntent`。
- en: Now, follow the next steps to complete this intent creation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请按照接下来的步骤完成此意图的创建。
- en: '**Step 4.1.1 – Entering the training phrases for HelpIntent**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**第 4.1.1 步 – 输入 HelpIntent 的训练短语**'
- en: 'Now, we need to define phrases that are likely to invoke this intent to action.
    To do so, click on the Training Phrases heading and enter a few sample training
    phrases, as shown:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要定义可能触发该意图的短语。为此，点击“Training Phrases”标题，并输入一些示例训练短语，如下所示：
- en: '![](img/7dfccd76-fb68-4aae-8911-22af5e77a48c.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7dfccd76-fb68-4aae-8911-22af5e77a48c.png)'
- en: Make sure you click on Save whenever you make any changes to an intent.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每次对意图进行更改时，请确保点击“Save”保存。
- en: '**Step 4.1.2 – Adding a response**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**第 4.1.2 步 – 添加响应**'
- en: 'In order to respond to the user query in this intent, we need to define the
    possible responses. Click on the Responses heading in the intent creation form
    and add a sample response to the query, as shown:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了响应用户在该意图中的查询，我们需要定义可能的响应。点击意图创建表单中的“Responses”标题，并添加一个示例响应，如下所示：
- en: '![](img/64a15276-092b-46b6-9c1e-7a2cf89d5d7b.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64a15276-092b-46b6-9c1e-7a2cf89d5d7b.png)'
- en: Save the intent. Once we have finished building it, we can test the chatbot
    by entering an input similar to the training phrases we defined for this intent.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 保存该意图。一旦我们完成构建它，我们就可以通过输入类似于我们为该意图定义的训练短语的内容来测试聊天机器人。
- en: '**Step 4.1.3 – Testing the intent**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**第 4.1.3 步 – 测试意图**'
- en: 'Let''s test `HelpIntent`. In the right-hand side testing panel, input `Can
    you help me?`. The agent produces the following response:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试`HelpIntent`。在右侧的测试面板中，输入`Can you help me?`。代理将产生以下响应：
- en: '![](img/5addae4f-c070-4f96-83f6-b2e65a6bf5e9.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5addae4f-c070-4f96-83f6-b2e65a6bf5e9.png)'
- en: Notice the matched intent at the bottom of the preceding screenshot. Since `HelpIntent`
    has successfully matched to the input, which was not explicitly defined in the
    training phrases, we can conclude that the agent works well.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意前一截图底部匹配的意图。由于`HelpIntent`成功匹配了输入（该输入并未在训练短语中明确定义），我们可以得出结论，代理工作正常。
- en: Why is it important for the agent to respond to an input it has not been trained
    on? This is because while testing the agent for a particular intent, we want to
    be assured that any utterances exactly or closely matching the training phrases
    are matched by that intent. If it does not match closely related queries to the
    intent that is expected, you need to provide more training phrases and check whether
    there are any conflicting trainings in any other intents of the agent.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么代理需要对其未经过训练的输入做出响应呢？这是因为在测试某个特定意图时，我们希望确保任何与训练短语完全匹配或接近匹配的用户输入，都能被该意图正确匹配。如果它没有匹配到与预期意图相关的查询，您需要提供更多的训练短语，并检查是否有任何其他意图中的训练与之冲突。
- en: Now that we have an intent telling the user what this chatbot can be expected
    to do—that is, to check the status of the order—let's create an intent that can
    actually check the order status.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个意图，告诉用户这个聊天机器人可以做什么——也就是检查订单的状态——接下来我们来创建一个可以实际检查订单状态的意图。
- en: Step 4.2 – Creating the CheckOrderStatus intent
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4.2 步 – 创建 CheckOrderStatus 意图
- en: Click on the Create Intent button and enter the name of the intent as `CheckOrderStatus`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“Create Intent”按钮，并将意图名称输入为`CheckOrderStatus`。
- en: '**Step 4.2.1 – Entering the training phrases for the CheckOrderStatus intent**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**第 4.2.1 步 – 输入 CheckOrderStatus 意图的训练短语**'
- en: 'For this intent, we enter the following training phrases:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此意图，我们输入以下训练短语：
- en: '`What is the status for order id 12345?`'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`订单ID 12345的状态是什么？`'
- en: '`When will my product arrive?`'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`我的产品什么时候到？`'
- en: '`What has happened to my order?`'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`我的订单发生了什么？`'
- en: '`When will my order arrive?`'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`我的订单什么时候到？`'
- en: '`What''s my order status?`'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`我的订单状态是什么？`'
- en: Note that the first training phrase is different from the rest because it contains
    an order ID.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一个训练短语与其他短语不同，因为它包含了一个订单ID。
- en: We need to be able to identify it as an order ID and use that to fetch the order
    status.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要能够识别它为一个订单ID，并利用它来获取订单状态。
- en: '**Step 4.2.2 – Extracting and saving the order ID from the input**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤4.2.2 – 从输入中提取并保存订单ID**'
- en: 'In the first training phrase of the `CheckOrderStatus` intent, double-click
    on 12345 and a menu pops up, as shown:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CheckOrderStatus`意图的第一个训练短语中，双击12345，一个菜单会弹出，如下所示：
- en: '![](img/c98bee73-f7c7-4615-b3dc-d54da04384c7.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c98bee73-f7c7-4615-b3dc-d54da04384c7.png)'
- en: 'Choose @sys.number and then enter the parameter name as `OrderId`. Your training
    phrases will look as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 选择@sys.number，然后输入参数名称为`OrderId`。您的训练短语将如下所示：
- en: '![](img/76dcff96-1ac6-4b4d-a3f9-465c3f178ff2.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76dcff96-1ac6-4b4d-a3f9-465c3f178ff2.png)'
- en: But sometimes, as in the rest of the training phrases, the user will not mention
    the order ID without a prompt. Let's add a prompt and a way to store the order
    ID whenever it is found.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时，就像其他训练短语一样，用户在没有提示的情况下不会提到订单ID。让我们添加一个提示，并在找到订单ID时进行存储。
- en: '**Step 4.2.3 – Storing the parameter and prompting if not found**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤4.2.3 – 存储参数并在未找到时进行提示**'
- en: 'Scroll down to the Actions and parameters heading in the intent creation form.
    Enter `OrderId` for PARAMETER NAME and VALUE and check the REQUIRED checkbox.
    The following screenshot should look similar to what is on your screen now:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 向下滚动到意图创建表单中的“动作和参数”标题。输入`OrderId`作为参数名称和值，并勾选“必填”复选框。以下截图应该类似于当前屏幕上的内容：
- en: '![](img/b57ad591-d3d9-41d2-927b-357920901174.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b57ad591-d3d9-41d2-927b-357920901174.png)'
- en: On the right-hand side of the `OrderId` parameter, click on Define prompts to
    add a prompt for this parameter. A sample prompt could be `Sure, could you please
    let me know the Order ID? It looks like 12345!`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OrderId`参数的右侧，点击“定义提示”以为该参数添加提示。一个示例提示可以是`好的，您能告诉我订单ID吗？看起来是12345！`。
- en: We expect that after this prompt, the user will definitely state the order ID,
    which will then match the first training phrase of this intent.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预期在这个提示之后，用户一定会明确说明订单ID，然后与该意图的第一个训练短语匹配。
- en: After this, we need to define the response for this intent.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为这个意图定义响应。
- en: '**Step 4.2.4 – Turning on responses through Fulfillment for the CheckOrderStatus
    intent**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤4.2.4 – 为CheckOrderStatus意图启用通过完成的响应**'
- en: Remember that this intent would need to fetch the order status from the order
    ID obtained. In such a case, a constant set of responses will not serve the purpose.
    So, we'll take the help of the Fulfillment heading in the intent creation form.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，此意图需要从获得的订单ID中获取订单状态。在这种情况下，一组固定的响应将无法满足目的。因此，我们将利用意图创建表单中的“完成”部分。
- en: 'Scroll down and turn on the fulfillment method webhook for this intent. This
    section now should look as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 向下滚动并为此意图启用Webhook的完成方法。此部分现在应该如下所示：
- en: '![](img/9c9f4952-6bd9-4355-82d6-947bb003c29a.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c9f4952-6bd9-4355-82d6-947bb003c29a.png)'
- en: Fullfillment allows your Dialogflow agent to query external APIs to generate
    the response the agent has to make. The metadata associated with the query received
    by the agent is sent to the external API, which then understands and decides on
    the response the query needs to be given. This is useful for having dynamic responses
    through the chatbot.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 完成允许您的Dialogflow代理查询外部API，以生成代理所需的响应。代理接收到的查询相关的元数据将被发送到外部API，后者将理解并决定需要给出的响应。这对于通过聊天机器人提供动态响应非常有用。
- en: We must now define this webhook to handle the fetching of the order status using
    the order ID.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在必须定义这个Webhook，用于使用订单ID获取订单状态。
- en: Step 5 – Creating a webhook
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤5 – 创建Webhook
- en: We'll now create a webhook that will run on the Firebase cloud console and call
    an external API, which is present in our Order management portal.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个Webhook，它将在Firebase云控制台上运行并调用我们订单管理门户中的外部API。
- en: 'Click on the Fulfillment item in the menu bar. You''ll be presented with the
    option to switch on a webhook or to use a Firebase cloud function. Turn on the
    inline editor. Your screen will resemble the following screenshot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 点击菜单栏中的 Fulfillment 项目。您将看到启用 webhook 或使用 Firebase 云函数的选项。打开内联编辑器。您的屏幕将类似于以下截图：
- en: '![](img/a462f840-72e8-4bd3-adda-859232692693.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a462f840-72e8-4bd3-adda-859232692693.png)'
- en: We'll customize the two files present in the inline editor.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将自定义内联编辑器中的两个文件。
- en: Step 6 – Creating a Firebase cloud function
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤 6 – 创建 Firebase 云函数
- en: A Firebase cloud function runs on the Firebase platform and is billed as the
    provisions on the GCP project that you chose or created during the creation of
    your Dialogflow agent. You can read more about Cloud Functions at [https://dialogflow.com/docs/how-tos/getting-started-fulfillment](https://dialogflow.com/docs/how-tos/getting-started-fulfillment).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase 云函数在 Firebase 平台上运行，按您在创建 Dialogflow 代理时选择或创建的 GCP 项目的规定计费。您可以在[https://dialogflow.com/docs/how-tos/getting-started-fulfillment](https://dialogflow.com/docs/how-tos/getting-started-fulfillment)查看更多关于云函数的信息。
- en: Step 6.1 – Adding the required packages to package.json
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤 6.1 – 向 package.json 添加所需的包
- en: 'In the `package.json` file on the inline editor, we''ll add the `request` and
    `request-promise-native` packages to the dependencies, as shown:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在内联编辑器中的`package.json`文件里，我们将添加`request`和`request-promise-native`包到依赖项中，如下所示：
- en: '[PRE0]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These packages will be automatically fetched during the build of the agent,
    so you do not need to execute any commands explicitly to install them.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包将在代理构建时自动获取，因此您无需显式执行任何命令来安装它们。
- en: Step 6.2 – Adding logic to index.js
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤 6.2 – 向 index.js 添加逻辑
- en: 'We''ll be adding the code required to call the API of our order management
    system. Add the following function inside the `dialogflowFirebaseFulfillment`
    object definition:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加调用订单管理系统 API 所需的代码。将以下函数添加到`dialogflowFirebaseFulfillment`对象定义中：
- en: '[PRE1]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'At the end of the file, just before ending the `dialogflowFirebaseFulfillment`
    object definition, add the mapping for the function you created previously to
    the intent that was matched in the Dialogflow agent before invoking the webhook
    call for generating a response:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件末尾，在`dialogflowFirebaseFulfillment`对象定义结束之前，添加您之前创建的函数与 Dialogflow 代理中匹配的意图之间的映射，然后调用
    webhook 来生成响应：
- en: '[PRE2]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, click on Deploy to deploy this function. You will get notifications for
    the status of the deployment at the bottom right of the screen. Wait for the deployment
    and build to complete.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击部署（Deploy）按钮，部署该函数。您将在屏幕右下角看到部署状态通知。等待部署和构建完成。
- en: Step 7 – Adding a personality to the bot
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤 7 – 为机器人添加个性
- en: Adding a personality to the bot is more about how you chose your responses to
    be and how you drive the conversation through the responses and prompts in the
    agent.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为机器人添加个性更多的是关于您如何选择回应方式，以及如何通过代理中的回应和提示来推动对话。
- en: For example, while we chose a very standard response to the inputs of the user
    in the previous example, we could definitely make it more interesting by using
    real-world language or other decorative elements in the responses. It would appear
    very realistic if instead of directly showing the output from the response fetching
    API, we added conversational decorators, such as `Great, now let me see where
    your order is...` and during the fetching and loading of the response to the agent,
    we made the Fulfillment function generate conversational fillers such as `almost
    there...`, `just getting there...`, `hmmm, let me see...`, and other fillers,
    depending on the requirements of the situation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在之前的示例中，我们为用户的输入选择了一个非常标准的响应，但我们完全可以通过使用更贴近实际的语言或其他装饰元素让其变得更加有趣。如果我们不直接显示响应获取
    API 的输出，而是加入对话装饰元素，比如`太好了，现在让我看看您的订单进度...`，并且在获取和加载响应时，让 Fulfillment 函数生成如`快到了...`、`快要到了...`、`嗯，让我看看...`等对话填充词，依照具体情况的需求，这样看起来会非常真实。
- en: 'You can also set some interesting trivia to the chatbot using the Small Talk
    module of Dialogflow. To use it, click on the Small Talk menu item on the left
    and enable small talk. You can add several interesting responses that your bot
    will make if it gets a particular query, as shown:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过 Dialogflow 的小对话模块为聊天机器人设置一些有趣的琐事。要使用它，点击左侧的小对话菜单项并启用小对话。您可以添加一些有趣的响应，当您的机器人接收到特定查询时，会做出回应，如下所示：
- en: '![](img/175d0651-9d60-46d8-9d33-70fc6f938486.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/175d0651-9d60-46d8-9d33-70fc6f938486.png)'
- en: Small talk is very useful for adding a very unique personality to your chatbot!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 小对话非常有助于为你的聊天机器人添加独特的个性！
- en: In the next step, we will be creating a UI to interact with this chatbot directly
    from the order management website. However, since we're talking about REST API-based
    interfaces, we'll most likely host this UI separately from the API that we created
    for the order management system.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将创建一个UI，以便直接从订单管理网站与这个聊天机器人进行互动。然而，由于我们谈论的是基于REST API的接口，我们很可能会将这个UI与我们为订单管理系统创建的API分开托管。
- en: This cloud function calls an HTTPS API that you will need to create. In the
    next section, we will learn how to create an API that can handle HTTPS requests
    on your local machine.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个云函数调用了一个你需要创建的HTTPS API。在下一部分，我们将学习如何创建一个能够处理本地机器上HTTPS请求的API。
- en: Using ngrok to facilitate HTTPS APIs on localhost
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ngrok来便捷地在localhost上实现HTTPS API
- en: You will need to create your own order management system API for the cloud function
    script to work so that it can fetch the order status from the API. You can find
    a quick sample at [http://tiny.cc/omsapi](http://tiny.cc/omsapi). Your API must
    run on an HTTPS URL. To achieve this, you can use services such as PythonAnywhere
    and ngrok. While PythonAnywhere hosts your code on their servers and provides
    a fixed URL, ngrok can be installed and run locally to provide a forwarding address
    to `localhost`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为云函数脚本创建你自己的订单管理系统API，以便它能够从API获取订单状态。你可以在[http://tiny.cc/omsapi](http://tiny.cc/omsapi)找到一个快速示例。你的API必须在HTTPS
    URL上运行。为了实现这一点，你可以使用诸如PythonAnywhere和ngrok等服务。PythonAnywhere将在其服务器上托管你的代码并提供固定的URL，而ngrok可以安装并在本地运行，为`localhost`提供转发地址。
- en: 'Say you have to run your Django project for the order management API on port
    `8000` of your system and now wish to provide an HTTPS URL so that you can test
    it; you can do so easily with ngrok by following these steps:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要在系统的`8000`端口运行Django项目用于订单管理API，并希望提供一个HTTPS URL进行测试；你可以通过以下步骤使用ngrok轻松实现：
- en: Download the ngrok tool.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载ngrok工具。
- en: First, head over to [https://ngrok.com](https://ngrok.com) and click on the
    Download button in the top navigation menu. Choose the correct version of the
    tool according to your needs and download it to your system.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，访问[https://ngrok.com](https://ngrok.com)，点击顶部导航菜单中的下载按钮。根据需要选择合适版本的工具并下载到你的系统。
- en: Create an account.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个账户。
- en: Next, sign up for an account on the website and go to the dashboard. You can
    use GitHub or Google authentication to set up your account quickly.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在网站上注册一个账户并进入仪表板。你可以使用GitHub或Google认证来快速设置账户。
- en: 'You will see the following dashboard:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到如下仪表板：
- en: '![](img/e6d34b11-f143-43a2-bc9b-834b34f9dabc.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e6d34b11-f143-43a2-bc9b-834b34f9dabc.png)'
- en: Since you've already downloaded and installed the tool, you can skip directly
    to connecting your account.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你已经下载并安装了工具，你可以直接跳到连接账户的步骤。
- en: Connect your ngrok account with your tool.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的ngrok账户与工具连接。
- en: Copy the command given on the ngrok dashboard under the *Connect your account*
    section—it contains the authtoken for your account and, on running, connects the
    ngrok tool on your system to your ngrok account on the website.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 复制ngrok仪表板中*Connect your account*部分给出的命令——它包含你账户的authtoken，运行后将ngrok工具与你系统中的ngrok账户连接。
- en: Then, we're ready to move on to the `localhost` port.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们准备好继续处理`localhost`端口。
- en: Set up the ngrok address to forward to `localhost`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置ngrok地址以转发到`localhost`。
- en: 'Finally, use the following command to start forwarding all requests made to
    a randomly generated ngrok URL to `localhost`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用以下命令开始将所有发送到随机生成的ngrok URL的请求转发到`localhost`：
- en: '[PRE3]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The ngrok service starts and remains active as long as you keep the terminal
    open. You should see an output similar to the following screenshot on your screen:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ngrok服务启动后会保持活跃，只要你保持终端开启。你应该会在屏幕上看到类似于以下截图的输出：
- en: '![](img/876ab489-46d8-4ced-92a3-32a95fbb08c4.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/876ab489-46d8-4ced-92a3-32a95fbb08c4.png)'
- en: All requests made to your ngrok URL will be logged on the terminal. You can
    find your ngrok URL in the `Forwarding` row of the table just above the request
    logs. Notice that both the `http` and `https` ports are being forwarded. You can
    now use the API service running on your local machine to make calls from Firebase,
    which only allows HTTPS calls.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 所有发送到你的ngrok URL的请求都会在终端中记录。你可以在请求日志上方的表格中的`Forwarding`行找到你的ngrok URL。注意，`http`和`https`端口都会被转发。你现在可以使用在本地机器上运行的API服务，从Firebase发起调用，而Firebase只允许HTTPS调用。
- en: Creating a testing UI using Django to manage orders
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Django 创建测试 UI 来管理订单
- en: We've previously used Django in this book, namely in [Chapter 8](3bf31fe1-d41c-4410-a83c-1651da439c70.xhtml),
    *Deep Learning on Microsoft Azure Using Python*, and [Chapter 10](6158dd33-fac9-4a1f-867d-d53c827d7a7f.xhtml),
    *Securing Web Apps with Deep Learning*. So, we will skip over the nitty-gritty
    details of how Django works and how you can get started with it. Let's dive straight
    into creating a UI that you can interact with using your voice!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们之前使用过 Django，具体见 [第8章](3bf31fe1-d41c-4410-a83c-1651da439c70.xhtml)，*在
    Microsoft Azure 上使用 Python 进行深度学习*，以及 [第10章](6158dd33-fac9-4a1f-867d-d53c827d7a7f.xhtml)，*使用深度学习保护
    Web 应用程序*。因此，我们将跳过 Django 如何工作的细节以及如何开始使用它。让我们直接进入创建一个可以通过语音交互的 UI！
- en: If you have not installed Django on your system already, please follow the *A
    brief introduction to Django web development* section in [Chapter 8](3bf31fe1-d41c-4410-a83c-1651da439c70.xhtml),
    *Deep Learning on Microsoft Azure Using Python*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有在系统上安装 Django，请参考 [第8章](3bf31fe1-d41c-4410-a83c-1651da439c70.xhtml)，*在
    Microsoft Azure 上使用 Python 进行深度学习* 中的 *Django Web 开发简介* 部分。
- en: Step 1 – Creating a Django project
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一步 – 创建一个 Django 项目
- en: 'Every Django website is a project. To create one, use this command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Django 网站都是一个项目。要创建一个项目，请使用此命令：
- en: '[PRE4]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A directory named `ordersui` is created with the following directory structure:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `ordersui` 的目录，目录结构如下：
- en: '[PRE5]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's proceed with creating the modules for this project.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建该项目的模块。
- en: Step 2 – Creating an app that uses the API of the order management system
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二步 – 创建一个使用订单管理系统 API 的应用
- en: Remember that each Django project is composed of several Django apps working
    together. We will now create a Django app in this project that will consume the
    order management system API and provide a UI to see the content contained in the
    API database. This is important for verifying that the Dialogflow agent is properly
    working.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，每个 Django 项目由多个 Django 应用协同工作。现在我们将在这个项目中创建一个 Django 应用，该应用将使用订单管理系统的 API，并提供一个
    UI 以查看 API 数据库中的内容。这对验证 Dialogflow 代理是否正常工作非常重要。
- en: 'Switch to the `ordersui` directory using the `cd` command in a new terminal
    or command prompt. Then, use the following command to create an app:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的终端或命令提示符中使用 `cd` 命令切换到 `ordersui` 目录。然后，使用以下命令创建一个应用：
- en: '[PRE6]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will create a directory within the `ordersui` Django project app directory
    with the following structure:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 `ordersui` Django 项目的应用目录中创建一个目录，结构如下：
- en: '[PRE7]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Before we begin the development of modules, let's define some project-level
    settings in the next section.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始开发模块之前，让我们在下一节中定义一些项目级别的设置。
- en: Step 3 – Setting up settings.py
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三步 – 设置 settings.py
- en: We'll now make some configurations that are required in the `ordersui/settings.py`
    file.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将进行一些配置，这些配置在 `ordersui/settings.py` 文件中是必需的。
- en: Step 3.1 – Adding the apiui app to the list of installed apps
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三步.1 – 将 apiui 应用添加到已安装应用列表中
- en: 'In the list of `INSTALLED_APPS`, add the `apiui` app, as shown:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `INSTALLED_APPS` 列表中，添加 `apiui` 应用，如下所示：
- en: '[PRE8]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The Django framework only includes apps during runtime that are listed in the
    `INSTALLED_APPS` directive, as in the preceding code. We will also need to define
    the database connectivity for the project, which is shown in the next section.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Django 框架只会在运行时包括 `INSTALLED_APPS` 指令中列出的应用，如前面的代码所示。我们还需要定义项目的数据库连接，具体内容将在下一节中展示。
- en: Step 3.2 – Removing the database setting
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三步.2 – 移除数据库设置
- en: We'll remove the database connectivity setup configuration since we don't need
    a database connection in this UI.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将删除数据库连接设置配置，因为在这个 UI 中我们不需要数据库连接。
- en: 'Comment out the `DATABASES` dictionary, as shown:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注释掉 `DATABASES` 字典，如下所示：
- en: '[PRE9]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Save the file. With this done, we'll set up a URL route to point to the `apiui`
    routes.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件。完成此操作后，我们将设置一个 URL 路由指向 `apiui` 路由。
- en: Step 4 – Adding routes to apiui
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四步 – 向 apiui 添加路由
- en: 'Change the code in `ordersui/urls.py` to add the path to include the route
    setting file inside the `apiui` app. Your file will contain the following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 更改 `ordersui/urls.py` 中的代码，添加路径以包含 `apiui` 应用中的路由设置文件。你的文件将包含以下代码：
- en: '[PRE10]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Save the file. After setting the routes at the project level, we will need to
    set routes at the module level, as we'll do in the next section.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件。在项目级别设置完路由后，我们还需要在模块级别设置路由，正如我们将在下一节中做的那样。
- en: Step 5 – Adding routes within the apiui app
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五步 – 在 apiui 应用中添加路由
- en: 'Now that we''ve directed the project to use the `apiui` URL routes, we need
    to create the file required for this app. Create a file named `urls.py` within
    the `apiui` directory with the following content:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将项目配置为使用`apiui` URL路由，接下来我们需要为这个应用创建所需的文件。在`apiui`目录下创建一个名为`urls.py`的文件，并添加以下内容：
- en: '[PRE11]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Save the file. Now that we've specified the routes available in the application,
    we need to create views for each of these routes, as we'll do in the next section.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件。现在我们已经指定了应用中可用的路由，接下来我们需要为每个路由创建视图，正如我们在下一部分将要做的那样。
- en: Step 6 – Creating the views required
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6步 – 创建所需的视图
- en: In the routes we created, we mentioned two views—`indexView`, which does not
    take any parameters, and `viewOrder`, which takes a parameter called `orderId`.
    Create a new file called `views.py` in the `apiui` directory and follow the next
    steps to create the views required.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建的路由中，我们提到了两个视图——`indexView`，它不接受任何参数，以及`viewOrder`，它接受一个名为`orderId`的参数。在`apiui`目录中创建一个名为`views.py`的新文件，并按照下一步操作来创建所需的视图。
- en: Step 6.1 – Creating indexView
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6.1步 – 创建indexView
- en: 'This route will simply show the orders placed on the order management system.
    We use the following code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 该路由将简单地显示订单管理系统中的已下订单。我们使用以下代码：
- en: '[PRE12]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will create the `viewOrder` view in the following section.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的部分中创建`viewOrder`视图。
- en: Step 6.2 – Creating viewOrder
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6.2步 – 创建viewOrder
- en: 'If we pass an order ID to the same `/` route in the form of `/orderId`, then
    we should return the status of the order. Use the following code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将一个订单ID作为`/orderId`传递给相同的`/`路由，那么我们应该返回该订单的状态。使用以下代码：
- en: '[PRE13]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have finished creating the different views that we will need for this project;
    however, we're yet to create the templates they will be rendering. Let's create
    the templates required in the next section.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了创建该项目所需的不同视图；然而，我们还没有创建它们所呈现的模板。让我们在接下来的部分中创建所需的模板。
- en: Step 7 – Creating the templates
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7步 – 创建模板
- en: In the view we defined previously, we used two templates—`index.html` and `view.html`.
    But to make them appear in sync with the design, we'll also set up a `base.html`
    template, which will be the master template for the rest of the view templates
    in the UI.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前定义的视图中，我们使用了两个模板——`index.html`和`view.html`。但为了使它们与设计保持一致，我们还需要设置一个`base.html`模板，它将作为UI中其他视图模板的主模板。
- en: Since the templates are mostly just HTML boilerplate with little consequence
    to the vital content of the website, we have provided the code for these files
    at [http://tiny.cc/ordersui-templates](http://tiny.cc/ordersui-templates). You'll
    have to save the template files in a folder named `templates` inside the `apiui`
    directory.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些模板大多数只是HTML模板，对网站的核心内容影响不大，我们已将这些文件的代码提供在[http://tiny.cc/ordersui-templates](http://tiny.cc/ordersui-templates)上。你需要将模板文件保存在`apiui`目录下名为`templates`的文件夹中。
- en: 'At this stage, you''ll be able to start up the Django project server and check
    out the website on your browser by using the following command:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你将能够启动Django项目服务器，并通过以下命令在浏览器中查看网站：
- en: '[PRE14]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that our server is running, we will create a voice interface around it in
    the next section.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的服务器正在运行，我们将在下一部分围绕它创建一个语音接口。
- en: Speech recognition and speech synthesis on a web page using the Web Speech API
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Web语音API在网页上实现语音识别和语音合成
- en: 'A recent and very exciting development in the domain of web development is
    the introduction of the Web Speech API. While Google has rolled out full support
    for the Web Speech API in Google Chrome browsers for both desktop and Android,
    Safari and Firefox only have partial implementations available. The Web Speech
    API consists primarily of two components:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web开发领域，最近一个非常令人兴奋的发展是Web语音API的推出。虽然Google已经在Google Chrome浏览器（桌面版和Android版）中全面支持Web语音API，但Safari和Firefox仅提供了部分实现。Web语音API主要由两个组件构成：
- en: '**Speech synthesis**: More popularly known as **TTS**. It performs the action
    of generating voice narration for any given text.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语音合成**：更广为人知的是**TTS**。它的功能是为任何给定的文本生成语音讲解。'
- en: '**Speech recognition**: Also known as **STT**. It performs the function of
    recognizing the words spoken by the user and converting them into corresponding
    text.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语音识别**：也称为**STT**。它的功能是识别用户所说的词并将其转换为相应的文本。'
- en: 'You can go through the very detailed documentation of the Web Speech API, which
    is available at the Mozilla documentation page ( [http://tiny.cc/webspeech-moz](http://tiny.cc/webspeech-moz)
    ). You can find a demonstration of the technology provided by Google at [http://tiny.cc/webspeech-demo](http://tiny.cc/webspeech-demo):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以阅读 Web Speech API 的详细文档，文档可在 Mozilla 的文档页面找到（[http://tiny.cc/webspeech-moz](http://tiny.cc/webspeech-moz)）。你还可以看到
    Google 提供的技术演示，链接在此：[http://tiny.cc/webspeech-demo](http://tiny.cc/webspeech-demo)：
- en: '![](img/a516e800-2a10-471f-84b2-c76d65e116c1.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a516e800-2a10-471f-84b2-c76d65e116c1.png)'
- en: In the following steps, we'll add a Web Speech API-based Ask a question button
    to our website UI.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将向网站 UI 添加一个基于 Web Speech API 的提问按钮。
- en: Step 1 – Creating the button element
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤 1 – 创建按钮元素
- en: All the code in this section has to be put into the `base.html` template of
    the UI so that it is available on all of the pages of the website.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的所有代码必须放入 UI 的 `base.html` 模板中，以便在网站的所有页面中都能使用。
- en: 'We use the following code to quickly create a button with the Ask a question
    text that will be at the bottom-right corner of the web page sitewide:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下代码快速创建一个提问按钮文本，该按钮将位于网站的右下角：
- en: '[PRE15]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, we will need to initialize and configure the Web Speech API, as we will
    do in the next section.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要初始化并配置 Web Speech API，接下来我们将在下一节中进行此操作。
- en: Step 2 – Initializing the Web Speech API and performing configuration
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤 2 – 初始化 Web Speech API 并进行配置
- en: 'When the web page has finished loading, we need to initialize the Web Speech
    API object and set the necessary configurations for it. To do so, use the following
    code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当网页加载完成时，我们需要初始化 Web Speech API 对象，并为其设置必要的配置。为此，请使用以下代码：
- en: '[PRE16]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can see that we''ve initialized a web `SpeechRecognition` API object and
    then performed some configurations on it. Let''s try to understand these configurations:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们初始化了一个 Web `SpeechRecognition` API 对象，并对其进行了某些配置。让我们试着理解这些配置：
- en: '`recognition.interimResults` (Boolean) directs whether the API should attempt
    to recognize interim results or words that are yet to be spoken. This would add
    overhead to our use case and so is turned off. Having it turned on is more beneficial
    in situations where the speed of the transcription matters more than the accuracy
    of the transcription, such as when generating live transcriptions for a person
    speaking.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recognition.interimResults`（布尔值）指示 API 是否应尝试识别暂时的结果或尚未说出的单词。这会给我们的用例增加额外开销，因此已关闭。当需要转录速度而非转录准确性时（例如生成实时转录以记录某人讲话内容），开启此功能会更有益。'
- en: '`recognition.maxAlternatives` (number) tells the browser how many alternatives
    can be produced for the same speech segment. This is useful in cases where it
    is not very clear to the browser what was said and the user can be given an option
    to choose the correct recognition.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recognition.maxAlternatives`（数字）告诉浏览器同一语音片段可以生成多少个备选项。这在浏览器无法非常清楚地识别所说内容时非常有用，用户可以选择正确的识别结果。'
- en: '`recognition.continuous` (Boolean) tells the browser whether the audio has
    to be captured continuously or whether it should stop after recognizing the speech
    once.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recognition.continuous`（布尔值）告诉浏览器是否需要持续捕捉音频，或者是否在识别一次语音后停止。'
- en: 'However, we''ve not yet defined the code that is executed when a result is
    received after performing STT. We do so by adding code to the `recognition.onresult`
    function, as shown:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们尚未定义在执行语音转文本（STT）后接收到结果时执行的代码。我们通过向 `recognition.onresult` 函数添加代码来实现这一点，如下所示：
- en: '[PRE17]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding block of code creates an interim transcript while the user is
    speaking, which is continually updated as more words are spoken. When the user
    stops speaking, the interim transcript is appended to the final transcript and
    passed to the function handling the interaction with Dialogflow. After the response
    is received from the Dialogflow agent, the final transcript is reset for the next
    voice input from the user.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块在用户讲话时创建了一个临时的转录内容，并在更多单词被说出时不断更新。当用户停止讲话时，临时转录内容将附加到最终转录内容中，并传递给处理与 Dialogflow
    交互的函数。在从 Dialogflow 代理收到响应后，最终转录内容将重置，以准备接受下一个来自用户的语音输入。
- en: Notice that we've sent the final recognized transcript of the user's speech
    to a function named `goDialogFlow()`. Let's define this function.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已将用户语音的最终识别转录发送到名为 `goDialogFlow()` 的函数。让我们定义这个函数。
- en: Step 3 – Making a call to the Dialogflow agent
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤 3 – 调用 Dialogflow 代理
- en: 'Once we have the text version of the user''s speech-based query, we will send
    it to the Dialogflow agent, as shown:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获取到用户语音查询的文本版本，我们将把它发送到 Dialogflow 代理，如下所示：
- en: '[PRE18]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You'll observe that when the API call succeeds, we use the SpeechSynthesis API
    to speak out the result to the user. Its usage is much more simple than the SpeechRecognition
    API and so is the first of the two to appear on Firefox and Safari.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，当 API 调用成功时，我们使用 SpeechSynthesis API 将结果读出给用户。它的使用比 SpeechRecognition
    API 更加简单，因此它是第一个出现在 Firefox 和 Safari 浏览器上的。
- en: Notice the API URL used in the preceding function. It might look weird currently
    and you might wonder where we obtained this URL from. What we did was essentially
    skip the requirement of setting the Dialogflow agent service account configurations
    using the terminal, which is always local to the system the script is working
    on and is so difficult to transport.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意前面函数中使用的 API URL。它现在看起来可能有点奇怪，你可能会想知道我们是从哪里获得这个 URL 的。我们所做的实际上是跳过了使用终端设置
    Dialogflow 代理服务账号配置的要求，因为这些配置通常是本地系统特有的，且很难移植。
- en: To obtain a similar URL for your project, follow along with the following steps;
    otherwise, skip *step 4* and move directly on to *step 5*.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要为你的项目获取类似的 URL，请按照以下步骤操作；否则，可以跳过 *步骤 4*，直接进入 *步骤 5*。
- en: Step 4 – Creating a Dialogflow API proxy on Dialogflow Gateway by Ushakov
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤 4 – 在 Dialogflow Gateway 上创建 Dialogflow API 代理
- en: 'Head over to [https://dialogflow.cloud.ushakov.co/](https://dialogflow.cloud.ushakov.co/).
    You''ll be presented with an interface, as shown:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://dialogflow.cloud.ushakov.co/](https://dialogflow.cloud.ushakov.co/)。你将看到如下界面：
- en: '![](img/2de7c84c-4fa8-4746-9387-f965726690e7.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2de7c84c-4fa8-4746-9387-f965726690e7.png)'
- en: Dialogflow Gateway facilitates the interactions between your voice UI and the
    Dialogflow agent. This is very useful in situations where our project is hosted
    as a static website. Dialogflow Gateway provides simplified API wrappers around
    the Dialogflow API and is very easy to use.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Dialogflow Gateway 促进了你的语音用户界面与 Dialogflow 代理之间的互动。在我们的项目作为静态网站托管时，这非常有用。Dialogflow
    Gateway 为 Dialogflow API 提供了简化的 API 封装，使用起来非常简单。
- en: You'll have to create an account to get started with Dialogflow, shown in the
    next section.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要创建一个账户才能开始使用 Dialogflow，如下节所示。
- en: Step 4.1 – Creating an account on Dialogflow Gateway
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤 4.1 – 在 Dialogflow Gateway 上创建账户
- en: Click on Get Started to begin the account creation process on the platform.
    You'll be asked to sign in with your Google account. Make sure you use the same
    account that you used to create the Dialogflow agent previously.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“开始使用”以开始平台上的账户创建过程。系统会要求你使用 Google 账号登录。确保使用的是你之前创建 Dialogflow 代理时使用的同一账号。
- en: Step 4.2 – Creating a service account for your Dialogflow agent project
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤 4.2 – 为你的 Dialogflow 代理项目创建服务账号
- en: 'We previously discussed in detail how to create a service account for GCP projects
    in [Chapter 6](093890b6-051d-49f9-9330-bdd58b92a762.xhtml), *Deep Learning on
    Google Cloud Platform Using Python*. Create a new service key for the project
    linked to your Dialogflow agent, as shown:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在 [第六章](093890b6-051d-49f9-9330-bdd58b92a762.xhtml)《*使用 Python 在 Google
    Cloud Platform 上进行深度学习*》中详细讨论了如何为 GCP 项目创建服务账号。为与你的 Dialogflow 代理关联的项目创建一个新的服务密钥，如下所示：
- en: '![](img/ad8232d2-aff2-47bb-8654-343e8a131ef2.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad8232d2-aff2-47bb-8654-343e8a131ef2.png)'
- en: 'Once the key has been created successfully, a dialog box will pop up, telling
    you that the key has been saved to your computer, as shown:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦密钥成功创建，一个对话框会弹出，告诉你密钥已保存在计算机上，如下所示：
- en: '![](img/caea516d-c88e-49ce-9a31-be83ead57a5b.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/caea516d-c88e-49ce-9a31-be83ead57a5b.png)'
- en: The service account credentials are downloaded to your local system in the form
    of JSON, with the name as shown in the preceding screenshot.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 服务账号凭据以 JSON 格式下载到本地系统，文件名如前截图所示。
- en: Now, we will use this service account credentials file to connect Dialogflow
    Gateway to our Dialogflow agent.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用这个服务账号凭据文件将 Dialogflow Gateway 连接到我们的 Dialogflow 代理。
- en: Step 4.3 – Uploading the service key file to Dialogflow Gateway
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤 4.3 – 上传服务密钥文件到 Dialogflow Gateway
- en: 'On the Dialogflow Gateway console, you''ll find the Upload Keys button. Click
    on it to upload your generated service account key file. Once uploaded, the console
    will display your Dialogflow API proxy URLs, as shown:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Dialogflow Gateway 控制台上，你会看到“上传密钥”按钮。点击它上传你生成的服务账号密钥文件。上传完成后，控制台将显示你的 Dialogflow
    API 代理 URL，如下所示：
- en: '![](img/0dc2a2ff-d5ff-43e8-9208-afb12d3facbb.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0dc2a2ff-d5ff-43e8-9208-afb12d3facbb.png)'
- en: We'll use the Gateway URL in the function we defined previously.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在之前定义的函数中使用 Gateway URL。
- en: Step 5 – Adding a click handler for the button
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五步——为按钮添加点击处理程序
- en: Finally, we add a `click` handler to the Ask a question button so that it can
    trigger the speech recognition of the user input and the synthesis of output from
    the Dialogflow agent.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为“Ask a question”按钮添加一个 `click` 处理程序，使其能够触发用户输入的语音识别，并从 Dialogflow 代理合成输出。
- en: 'Within the document `ready` function defined in *step 2*, add the following
    `click` handler code:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 2* 中定义的 `ready` 函数内，添加以下 `click` 处理程序代码：
- en: '[PRE19]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, when the microphone starts listening for the user input, the button text
    changes to Speak!, prompting the user to start speaking.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当麦克风开始监听用户输入时，按钮文本会变成“Speak!”，提示用户开始讲话。
- en: Try testing the website on your setup and see how accurately you can get it
    to work!
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在您的设置上测试网站，看看它能准确地工作到什么程度！
- en: Summary
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we combined several technologies to come up with an end-to-end
    project that demonstrates one of the most rapidly growing aspects of applying
    deep learning to websites. We covered tools such as Dialogflow, Dialogflow Gateway,
    GCP IAM, Firebase Cloud Functions, and ngrok. We also demonstrated how to build
    a REST API-based UI and how to make it accessible using the Web Speech API. The
    Web Speech API, although presently at a nascent stage, is a cutting-edge piece
    of technology used in web browsers and is expected to grow rapidly in the coming
    years.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们结合了几种技术，提出了一个端到端的项目，展示了将深度学习应用于网站的快速发展的一个方面。我们涉及了诸如 Dialogflow、Dialogflow
    Gateway、GCP IAM、Firebase Cloud Functions 和 ngrok 等工具。我们还展示了如何构建一个基于 REST API 的
    UI，以及如何使用 Web Speech API 使其可访问。Web Speech API 尽管目前处于初期阶段，但它是一个用于 Web 浏览器的前沿技术，预计在未来几年将快速发展。
- en: It is safe to say that deep learning on the web has huge potential and will
    be a key factor in the success of many upcoming businesses. In the next chapter,
    we'll explore some of the hottest research areas in deep learning for web development
    and how we can plan to progress in the best way.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 可以肯定地说，深度学习在网络上的应用具有巨大的潜力，并将在许多即将到来的企业成功中起到关键作用。在下一章中，我们将探讨深度学习在 Web 开发中的一些热门研究领域，并讨论如何规划最佳的进展方式。
