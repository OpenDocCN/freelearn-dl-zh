- en: Behavior Trees
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为树
- en: '**Behavior trees** (**BTs**) have been gaining popularity among game developers
    very steadily. Over the last decade, BTs have become the pattern of choice for
    many developers when it comes to implementing behavioral rules for their AI agents.
    Games such as *Halo* and *Gears of War* are among the more famous franchises to
    make extensive use of BTs. An abundance of computing power in PCs, gaming consoles,
    and mobile devices has made them a good option for implementing AI in games of
    all types and scopes.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为树**（**BTs**）在游戏开发者中非常稳定地获得了人气。在过去十年中，BTs已经成为许多开发者实现其AI代理行为规则的首选模式。像*光环*和*战争机器*这样的游戏系列是广泛使用BTs的著名游戏之一。PC、游戏机和移动设备中丰富的计算能力使它们成为在所有类型和规模的游戏中实现AI的好选择。'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The basics of a behavior tree
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为树的基本概念
- en: The benefits of using existing behavior tree solutions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用现有行为树解决方案的好处
- en: How to implement our own behavior tree framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现我们自己的行为树框架
- en: How to implement a basic tree using our framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用我们的框架实现基本树
- en: Learning the basics of behavior trees
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习行为树的基本知识
- en: 'Behavior trees got their name from their hierarchical, branching system of
    nodes with a common parent, known as the root. As you''ve surely learned by now from
    reading this book, behavior trees too mimic the real thing they are named after—in
    this case, trees and their branching structure. If we were to visualize a behavior
    tree, it would look something like the following figure:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树因其具有共同父节点的分层、分支节点系统而得名，这个父节点被称为根节点。正如你通过阅读本书所学到的那样，行为树也模仿了它们所命名的真实事物——在这种情况下，是树木及其分支结构。如果我们可视化一个行为树，它看起来可能就像以下图示：
- en: '![](img/8fb25fdb-a320-469f-bc7a-41275648a156.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8fb25fdb-a320-469f-bc7a-41275648a156.png)'
- en: A basic tree structure
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 基本树结构
- en: Of course, behavior trees can be made up of any number of nodes and child nodes.
    The nodes at the very end of the hierarchy are referred to as leaf nodes, just
    like a tree. Nodes can represent behaviors or tests. Unlike state machines, which
    rely on transition rules to traverse through them, a BT's flow is defined strictly
    by each node's order within the larger hierarchy. A BT begins evaluating from
    the top of the tree (based on the preceding visualization), then continues through
    each child, which, in turn, runs through each of its children until a condition
    is met or the leaf node is reached. BTs always begin evaluating from the root
    node.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，行为树可以由任意数量的节点和子节点组成。在层次结构最底层的节点被称为叶节点，就像一棵树一样。节点可以表示行为或测试。与依赖于转换规则来遍历的状态机不同，BT的流程严格由每个节点在更大层次结构中的顺序定义。BT从树的顶部开始评估（基于前面的可视化），然后继续通过每个子节点，这些子节点又依次运行其各自的子节点，直到满足条件或达到叶节点。BT始终从根节点开始评估。
- en: Understanding different node types
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解不同的节点类型
- en: 'The names of the different types of node may vary depending on who you ask,
    and even nodes themselves are sometimes referred to as tasks. While the complexity
    of a tree is dependent entirely upon the needs of the AI, the high-level concepts
    about how BTs work are fairly easy to understand if we look at each component
    individually. The following is true for each node regardless of what type of node
    we''re referring to. A node will always return one of the following states:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类型节点的名称可能因人而异，节点本身有时也被称为任务。虽然树的结构完全取决于AI的需求，但如果我们单独查看每个组件，关于BT如何工作的基本概念相对容易理解。以下是对每种类型的节点都成立的事实。节点将始终返回以下状态之一：
- en: '**Success**: The condition the node was checking for has been met.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成功**：节点检查的条件已经满足。'
- en: '**Failure**: The condition the node was checking for was not, and will not,
    be met.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**失败**：节点检查的条件未满足，并且将不会满足。'
- en: '**Running**: The validity of the condition the node is checking for has not
    been determined. Think of this as our "please wait" state.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行**：节点检查的条件的有效性尚未确定。这可以被视为我们的“请等待”状态。'
- en: Due to the potential complexity of a BT, most implementations are asynchronous,
    which, at least for Unity, means that evaluating a tree will not block the game
    from continuing other operations. The evaluation process of the various nodes
    in a BT can take several frames, if necessary. If you had to evaluate several
    trees on any number of agents at a time, you can imagine how it would negatively
    affect the performance of the program to have to wait for each of them to return
    a true or false to the root node. This is why the "running" state is important.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于BT（行为树）的潜在复杂性，大多数实现都是异步的，至少对于Unity来说，这意味着评估树不会阻止游戏继续其他操作。BT中各个节点的评估过程可能需要几个帧。如果你必须同时评估任何数量的代理上的多个树，你可以想象，如果必须等待每个树返回true或false给根节点，这将对程序的性能产生负面影响。这就是为什么“运行”状态很重要的原因。
- en: Defining composite nodes
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义复合节点
- en: 'Composite nodes are called so as they have one or more children. Their state
    is based entirely upon the result of evaluating their children, and while their
    children are being evaluated, they will be in a "running" state. There are a couple
    of composite node types, which are mostly defined by how their children are evaluated:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 复合节点之所以被称为复合节点，是因为它们有一个或多个子节点。它们的状态完全基于评估子节点的结果，并且在评估子节点时，它们将处于“运行”状态。有几个复合节点类型，它们主要是由它们的子节点的评估方式来定义的：
- en: '**Sequences**: The defining characteristic of a sequence is that the entire
    sequence of children needs to complete successfully in order for it to evaluate
    as a success itself. If any of the children at any step of the sequence return
    false, the sequence itself will report a failure. It is important to note that,
    in general, sequences are executed from left to right. The following figures show
    a successful sequence and a failed sequence, respectively:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列**：序列的定义特征是，整个子节点序列必须成功完成，它本身才能评估为成功。如果在序列的任何步骤中，任何一个子节点返回false，序列本身将报告失败。重要的是要注意，通常情况下，序列是从左到右执行的。以下图分别显示了成功的序列和失败的序列：'
- en: '![](img/b830e1a0-c291-4a84-a362-6692b4382d0c.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b830e1a0-c291-4a84-a362-6692b4382d0c.png)'
- en: A successful sequence node
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的序列节点
- en: '![](img/713f4462-2fe4-48ae-b937-c0d4f1e675d0.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/713f4462-2fe4-48ae-b937-c0d4f1e675d0.png)'
- en: An unsuccessful sequence node
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 不成功的序列节点
- en: '**Selectors**: By comparison, selectors are much more forgiving parents to
    their children nodes. If any one of the children nodes in a selector sequence
    returns true, the selector says, "eh, good enough!" and returns true immediately,
    without evaluating any more of its children. The only way a selector node will
    return false is if all of its children are evaluated and none of them return a
    success.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择器**：相比之下，选择器对它们的子节点更加宽容。如果一个选择器序列中的任何一个子节点返回true，选择器就会说，“嗯，足够了！”并立即返回true，而不会评估其子节点中的更多内容。选择器节点返回false的唯一方式是评估所有子节点，但没有一个返回成功。'
- en: Of course, each composite node type has its use depending on the situation.
    You can think of the different types of sequence nodes as "and" and "or" conditionals.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，每种复合节点类型都有其用途，这取决于具体情况。你可以将不同类型的序列节点视为“与”和“或”条件。
- en: Understanding decorator nodes
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解装饰器节点
- en: 'The biggest difference between a composite node and a decorator node is that
    a decorator can have exactly one child, and one child only. At first, this may
    seem unnecessary as you would, in theory, be able to get the same functionality
    by containing the condition in the node itself rather than relying on its child,
    but the decorator node is special in that it essentially takes the state returned
    by the child and evaluates the response based on its own parameters. A decorator
    can even specify how its children are evaluated and how often they are evaluated.
    These are some common decorator types:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 复合节点和装饰器节点之间最大的区别是，装饰器可以恰好有一个子节点，且只有一个子节点。起初，这可能会显得不必要，因为理论上你可以通过在节点本身包含条件而不是依赖其子节点来获得相同的功能，但装饰器节点是特殊的，因为它本质上接受子节点返回的状态，并根据其自己的参数评估响应。装饰器甚至可以指定其子节点的评估方式和评估频率。以下是一些常见的装饰器类型：
- en: '**Inverter**: Think of the inverter as a NOT modifier. It takes the opposite
    of the state returned by its child. For example, if the child returns TRUE, the
    decorator evaluates as FALSE, and vice versa. This is the equivalent of having
    the `!` operator in front of a Boolean in C#.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逆变器**：将逆变器视为一个NOT修饰符。它接受其子节点返回的状态的反面。例如，如果子节点返回TRUE，装饰器评估为FALSE，反之亦然。这在C#中相当于在布尔值前加上`!`运算符。'
- en: '**Repeater**: This repeats the evaluation of the child a specified (or infinite)
    number of times until it evaluates as either TRUE or FALSE as determined by the
    decorator. For example, you may want to wait indefinitely until a certain condition
    is met, such as "having enough energy" before a character uses an attack.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重复器**：这个装饰器会重复评估子节点指定（或无限）次数，直到根据装饰器的判断评估为TRUE或FALSE。例如，您可能希望无限期地等待直到满足某些条件，例如在角色使用攻击之前“拥有足够的能量”。'
- en: '**Limiter**: This simply limits the number of times a node will be evaluated
    to avoid getting an agent stuck in an awkward infinite behavior loop. This decorator,
    in contrast to the repeater, can be used to make sure a character only tries to,
    for example, kick the door open so many times before giving up and trying something
    else.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制器**：这个装饰器简单地限制了节点被评估的次数，以避免智能体陷入尴尬的无穷行为循环。与重复器相比，这个装饰器可以用来确保角色在放弃并尝试其他方法之前，例如，只能尝试打开门几次。'
- en: 'Some decorator nodes can be used for debugging and testing your trees, for
    example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一些装饰节点可用于调试和测试您的树，例如：
- en: '**Fake state**: This always evaluates true or false as specified by the decorator.
    This is very helpful for asserting certain behavior in your agent. For example,
    you can also have the decorator maintain a fake "running" state indefinitely to
    see how other agents around it will behave.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**假状态**：这个状态总是根据装饰器的指定评估为真或假。这对于断言您的智能体中的某些行为非常有帮助。例如，您也可以让装饰器保持一个无限期的假“运行”状态，以观察周围的其他智能体的行为。'
- en: '**Breakpoint**: Just like a breakpoint in code, you can have this node fire
    off logic to notify you via debug logs or other methods that the node has been
    reached.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断点**：就像代码中的断点一样，您可以让这个节点触发逻辑，通过调试日志或其他方法通知您节点已被达到。'
- en: These types are not monolithic archetypes that are mutually exclusive. You can
    combine these types of nodes to suit your needs. Just be careful not to combine
    too much functionality into one decorator to the point where it may be more efficient
    or convenient to use a sequence node instead.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型不是互斥的单一原型。您可以将这些类型的节点组合起来以满足您的需求。只是要小心不要将太多功能组合到一个装饰器中，以至于使用序列节点可能更高效或更方便。
- en: Describing the leaf node
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述叶子节点
- en: We briefly covered leaf nodes earlier in the chapter to make a point about the
    structure of a BT, but leaf nodes, in reality, can be just about any sort of behavior.
    They are magical in the sense that they can be used to describe any sort of logic
    your agent can have. A leaf node can specify a walk function, shoot command, or
    kick action. It doesn't matter what it does or how you decide to have it evaluate
    its states, it just has to be the last node in its own hierarchy and return any
    of the three states a node can return.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章前面简要介绍了叶子节点，以说明BT的结构，但叶子节点实际上可以是任何类型的行为。它们在意义上是神奇的，因为它们可以用来描述智能体可以拥有的任何逻辑。叶子节点可以指定一个行走函数、射击命令或踢动作。它所做的或你决定如何评估其状态无关紧要，它只需是其自身层次结构中的最后一个节点，并返回节点可以返回的三个状态中的任何一个。
- en: Evaluating the existing solutions
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估现有解决方案
- en: The Unity asset store is an excellent resource for developers. Not only are
    you able to purchase art, audio, and other kinds of assets, but it is also populated
    with a large number of plugins and frameworks. Most relevant to our purposes,
    there are a number of behavior tree plugins available on the asset store, ranging
    from free to a few hundred dollars. Most, if not all, provide some sort of GUI
    to make visualizing and arranging a fairly painless experience.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 资产商店是开发者们的一个优秀资源。您不仅能够购买艺术、音频和其他类型的资产，而且它还包含大量插件和框架。对我们来说最重要的是，资产商店上有许多行为树插件可供选择，价格从免费到几百美元不等。大多数，如果不是全部，都提供某种形式的GUI，使得可视化和管理变得相对轻松。
- en: There are many advantages of going with an off-the-shelf solution from the asset
    store. Many of the frameworks include advanced functionality such as runtime (and
    often visual) debugging, robust APIs, serialization, and data-oriented tree support.
    Many even include sample leaf logic nodes to use in your game, minimizing the
    amount of coding you have to do to get up and running.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从资产商店中选择现成的解决方案有许多优点。许多框架包括高级功能，如运行时（和通常可视化）调试、健壮的API、序列化和面向数据树支持。许多甚至包括用于游戏的示例叶子逻辑节点，以最小化您需要编写的代码量来启动和运行。
- en: The previous edition of this book, *Unity 4.x Game AI Programming*, focused
    on developer AngryAnt's Behave plugin, which is currently available as Behave
    2 for Unity on the asset store as a paid plugin, which continues to be an excellent
    choice for your behavior tree needs (and so much more). It is a very robust, performant,
    and excellently designed framework.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的前一版，《Unity 4.x 游戏人工智能编程》，专注于开发者AngryAnt的Behave插件，该插件目前作为付费插件在资产商店上提供，名为Behave
    2 for Unity，继续成为满足您行为树需求（以及更多）的绝佳选择。它是一个非常健壮、性能出色且设计精良的框架。
- en: Some other alternatives are **Behavior Machine** and **Behavior Designer**,
    which offer different pricing tiers (Behavior Machine even offers a free edition)
    and a wide array of useful features. Many other options can be found for free
    around the web as both generic C# and Unity-specific implementations. Ultimately,
    as with any other system, the choice of rolling your own or using an existing
    solution will depend on your time, budget, and project.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些替代方案是**Behavior Machine**和**Behavior Designer**，它们提供不同的定价层次（Behavior Machine甚至提供免费版）和广泛的有用功能。在网络上可以找到许多其他免费选项，包括通用的C#和针对Unity的实现。最终，与其他任何系统一样，选择自己构建还是使用现有解决方案将取决于您的时间、预算和项目。
- en: Implementing a basic behavior tree framework
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现基本行为树框架
- en: While a fully-fledged implementation of a behavior tree with a GUI and its many
    node types and variations is outside the scope of this book, we can certainly
    focus on the core principles to get a solid grasp of what the concepts we've covered
    in this chapter look like in action. Provided with this chapter is the basic framework
    for a behavior tree. Our example will focus on simple logic to highlight the functionality
    of the tree, rather than muddy up the example with complex game logic. The goal
    of our example is to make you feel comfortable with what can seem like an intimidating
    concept in game AI, and give you the necessary tools to build your own tree and
    expand upon the provided code if you do so.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书的范围不包括具有图形用户界面（GUI）的完整行为树实现及其众多节点类型和变体，但我们当然可以专注于核心原则，以牢固掌握本章所涵盖的概念在实际操作中的样子。本章提供了行为树的基本框架。我们的示例将专注于简单的逻辑，以突出树的功能，而不是用复杂的游戏逻辑使示例变得复杂。我们的目标是让您对在游戏人工智能中可能显得令人生畏的概念感到舒适，并为您提供必要的工具来构建自己的树，并在需要时扩展提供的代码。
- en: Implementing a base Node class
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现基本节点类
- en: 'There is a base functionality that needs to go into every node. Our simple
    framework will have all the nodes derived from a base abstract `Node.cs` class.
    This class will provide said base functionality or at least the signature to expand
    upon that functionality:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点都需要一个基本功能。我们的简单框架将所有节点派生自一个基本的抽象`Node.cs`类。这个类将提供这种基本功能或至少是扩展该功能的签名：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The class is fairly simple. Think of `Node.cs` as a blueprint for all the other
    node types to be built upon. We begin with the `NodeReturn` delegate, which is
    not implemented in our example, but the next two fields are. However, `m_nodeState`
    is the state of a node at any given point. As we learned earlier, it will be either
    `FAILURE`, `SUCCESS`, or `RUNNING`. The `nodeState` value is simply a getter for
    `m_nodeState` since it is protected and we don't want any other area of the code
    directly setting `m_nodeState` inadvertently.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类相当简单。将`Node.cs`视为所有其他节点类型的基础蓝图。我们以`NodeReturn`委托开始，这在我们的示例中没有实现，但接下来的两个字段是。然而，`m_nodeState`是节点在任何给定点的状态。正如我们之前所学的，它将是`FAILURE`、`SUCCESS`或`RUNNING`之一。`nodeState`值只是`m_nodeState`的获取器，因为它受保护，我们不希望代码的其他任何部分意外地直接设置`m_nodeState`。
- en: Next, we have an empty constructor, for the sake of being explicit, even though
    it is not being used. Lastly, we have the meat and potatoes of our `Node.cs` class—the
    `Evaluate()` method. As we'll see in the classes that implement `Node.cs`, `Evaluate()`
    is where the magic happens. It runs the code that determines the state of the
    node.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个空构造函数，为了明确起见，尽管它没有被使用。最后，我们有了`Node.cs`类的核心内容——`Evaluate()`方法。正如我们将在实现`Node.cs`的类中看到的那样，`Evaluate()`是魔法发生的地方。它运行确定节点状态的代码。
- en: Extending nodes to selectors
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展节点到选择器
- en: 'To create a selector, we simply expand upon the functionality that we described
    in the `Node.cs` class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个选择器，我们只需扩展我们在`Node.cs`类中描述的功能：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As we learned earlier in the chapter, selectors are composite nodes: this means
    that they have one or more child nodes. These child nodes are stored in the `m_nodes
    List<Node>` variable. Although it''s conceivable that one could extend the functionality
    of this class to allow adding more child nodes after the class has been instantiated,
    we initially provide this list via the constructor.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面所学的，选择器是复合节点：这意味着它们有一个或多个子节点。这些子节点存储在 `m_nodes List<Node>` 变量中。尽管可以想象扩展这个类的功能以允许在类实例化后添加更多子节点，但我们最初通过构造函数提供这个列表。
- en: The next portion of the code is a bit more interesting as it shows us a real
    implementation of the concepts we learned earlier. The `Evaluate()` method runs
    through all of its child nodes and evaluates each one individually. As a failure
    doesn't necessarily mean a failure for the entire selector, if one of the children
    returns `FAILURE`, we simply continue on to the next one. Inversely, if any child
    returns `SUCCESS`, then we're all set; we can set this node's state accordingly
    and return that value. If we make it through the entire list of child nodes and
    none of them have returned `SUCCESS`, then we can essentially determine that the
    entire selector has failed and we assign and return a `FAILURE` state.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的下一部分更有趣，因为它展示了我们之前学到的概念的实际实现。`Evaluate()` 方法会遍历其所有子节点，并逐个评估它们。如果一个子节点返回 `FAILURE`
    并不必然意味着整个选择器的失败，如果其中一个子节点返回 `FAILURE`，我们就简单地继续到下一个子节点。相反，如果任何一个子节点返回 `SUCCESS`，那么我们就已经完成了；我们可以相应地设置这个节点的状态并返回该值。如果我们遍历了所有子节点并且它们都没有返回
    `SUCCESS`，那么我们基本上可以确定整个选择器已经失败，并分配并返回一个 `FAILURE` 状态。
- en: Moving on to sequences
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来是序列
- en: 'Sequences are very similar in their implementation, but as you might have guessed
    by now, the `Evaluate()` method behaves differently:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 序列在实现上非常相似，但正如你可能已经猜到的，`Evaluate()` 方法的行为有所不同：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Evaluate()` method in a sequence will need to return true for all the child
    nodes, and if any one of them fails during the process, the entire sequence fails,
    which is why we check for `FAILURE` first and set and report it accordingly. A
    `SUCCESS` state simply means we get to live to fight another day, and we continue
    on to the next child node. If any of the child nodes are determined to be in the
    `RUNNING` state, we report that as the state for the node, and then the parent
    node or the logic driving the entire tree can evaluate it again.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 序列中的 `Evaluate()` 方法需要为所有子节点返回 true，如果在过程中任何一个子节点失败，整个序列就会失败，这就是为什么我们首先检查 `FAILURE`
    并相应地设置和报告它的原因。`SUCCESS` 状态仅仅意味着我们还有机会再战一天，然后继续到下一个子节点。如果任何一个子节点被确定为处于 `RUNNING`
    状态，我们就报告这个状态为节点状态，然后父节点或驱动整个树的逻辑可以再次评估它。
- en: Implementing a decorator as an inverter
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将装饰器实现为逆或器
- en: 'The structure of `Inverter.cs` is a bit different, but it derives from `Node`,
    just like the rest of the nodes. Let''s take a look at the code and spot the differences:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Inverter.cs` 的结构略有不同，但它与所有其他节点一样，都源自 `Node`。让我们看看代码并找出差异：'
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, since a decorator only has one child, we don't have `List<Node>`,
    but rather a single node variable, `m_node`. We pass this node in via the constructor
    (essentially requiring it), but there is no reason you couldn't modify this code
    to provide an empty constructor and a method to assign the child node after instantiation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，由于装饰器只有一个子节点，所以我们没有 `List<Node>`，而是一个单独的节点变量 `m_node`。我们通过构造函数传递这个节点（本质上要求这样做），但没有理由你不能修改这段代码以提供一个空构造函数和一个在实例化后分配子节点的方法。
- en: 'The `Evalute()` implementation implements the behavior of an inverter that
    we described earlier in the chapter: when the child evaluates as `SUCCESS`, the
    inverter reports a `FAILURE`, and when the child evaluates as `FAILURE`, the inverter
    reports a `SUCCESS`. The `RUNNING` state is reported normally.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Evalute()` 的实现实现了我们在本章前面描述的逆或器的行为：当子节点评估为 `SUCCESS` 时，逆或器报告 `FAILURE`，而当子节点评估为
    `FAILURE` 时，逆或器报告 `SUCCESS`。`RUNNING` 状态则正常报告。'
- en: Creating a generic action node
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个通用的动作节点
- en: 'Now we arrive at `ActionNode.cs`, which is a generic leaf node to pass in some
    logic via a delegate. You are free to implement leaf nodes in any way that fits
    your logic, as long as it derives from `Node`. This particular example is equal
    parts flexible and restrictive. It''s flexible in the sense that it allows you
    to pass in any method matching the delegate signature, but is restrictive for
    this very reason—it only provides one delegate signature that doesn''t take in
    any arguments:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了`ActionNode.cs`，这是一个通用的叶节点，可以通过委托传递一些逻辑。您可以根据自己的逻辑以任何方式实现叶节点，只要它从`Node`派生。这个特定的例子既灵活又有限制。它在灵活性方面允许您传递任何与委托签名匹配的方法，但正因为如此，它只提供了一个不接受任何参数的委托签名：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The key for making this node work is the `m_action` delegate. For those familiar
    with C++, a delegate in C# can be thought of as a function pointer of sorts. You
    can also think of a delegate as a variable containing (or more accurately, pointing
    to) a function. This allows you to set the function to be called at runtime. The
    constructor requires you to pass in a method matching its signature, and is expecting
    that method to return a `NodeStates` enum. That method can implement any logic
    you want, as long as these conditions are met. Unlike other nodes we've implemented,
    this one doesn't fall through to any state outside of the switch itself, so it
    defaults to a `FAILURE` state. You may choose to default to a `SUCCESS` or `RUNNING`
    state, if you so wish, by modifying the default return.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使此节点工作关键是`m_action`委托。对于那些熟悉C++的人来说，C#中的委托可以被视为某种函数指针。您也可以将委托视为包含（或更准确地说，指向）函数的变量。这允许您在运行时设置要调用的函数。构造函数要求您传递一个与签名匹配的方法，并期望该方法返回一个`NodeStates`枚举。该方法可以实施任何您想要的逻辑，只要满足以下条件。与我们所实现的其它节点不同，此节点不会切换到switch之外的任何状态，因此它默认为`FAILURE`状态。您可以选择通过修改默认返回值来默认为`SUCCESS`或`RUNNING`状态。
- en: You can easily expand on this class by deriving from it or simply making the
    changes to it that you need. You can also skip this generic action node altogether
    and implement one-off versions of specific leaf nodes, but it's good practice
    to reuse as much code as possible. Just remember to derive from `Node` and implement
    the required code!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从它派生或简单地对其进行所需更改来轻松扩展此类。您还可以完全跳过这个通用动作节点，并实现特定叶节点的单次版本，但尽可能重用代码是一个好的实践。只需记住要从`Node`派生并实现所需的代码！
- en: Testing our framework
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的框架
- en: The framework that we just reviewed is nothing more than this. It provides us
    with all the functionality we need to make a tree, but we have to make the actual
    tree ourselves. For the purposes of this book, a somewhat manually constructed
    tree is provided.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚审查的框架实际上就是这个。它为我们提供了构建树所需的所有功能，但我们必须自己构建实际的树。为了本书的目的，提供了一个部分手动构建的树。
- en: Planning ahead
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提前规划
- en: 'Before we set up our tree, let''s look at what we''re trying to accomplish.
    It is often helpful to visualize a tree before implementing it. Our tree will
    count up from zero to a specified value. Along the way, it will check whether
    certain conditions are met for that value and report its state accordingly. The
    following diagram illustrates the basic hierarchy for our tree:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们设置树之前，让我们看看我们试图实现什么。在实现之前可视化树通常很有帮助。我们的树将从零计数到指定的值。在这个过程中，它将检查该值是否满足某些条件，并相应地报告其状态。以下图表说明了我们树的基礎层次结构：
- en: '![](img/c0d1c39a-65d9-4ff9-978c-b834ab6f2d10.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0d1c39a-65d9-4ff9-978c-b834ab6f2d10.png)'
- en: 'For our tests, we will use a three-tier tree, including the root node:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中，我们将使用一个三层树，包括根节点：
- en: '**Node 1**: This is our root node. It has children, and we want to be able
    to return a success if any of the children are a success, so we''ll implement it
    as a selector.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点 1**：这是我们根节点。它有子节点，我们希望能够在任何子节点成功的情况下返回成功，因此我们将它实现为一个选择器。'
- en: '**Node 2a**: We''ll implement this node using an `ActionNode`.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点 2a**：我们将使用`ActionNode`来实现此节点。'
- en: '**Node 2b**: We''ll use this node to demonstrate how our inverter works.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点 2b**：我们将使用此节点来演示我们的逆变器是如何工作的。'
- en: '**Node 2c**: We''ll run the same `ActionNode` from node **2a** again, and see
    how that affects our tree''s evaluation.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点 2c**：我们将再次从节点**2a**运行相同的`ActionNode`，并看看这对我们的树评估有何影响。'
- en: '**Node 3**: Node **3** happens to be the lone node in the third tier of the
    tree. It is the child of the **2b** decorator node. This means that if it reports
    `SUCCESS`, **2b** will report a `FAILURE`, and vice versa.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点 3**：节点 **3** 恰好是树第三层的唯一节点。它是 **2b** 装饰节点的一个子节点。这意味着如果它报告 `SUCCESS`，则 **2b**
    将报告 `FAILURE`，反之亦然。'
- en: At this point, we're still a bit vague on the implementation details, but the
    preceding diagram will help us to visualize our tree as we implement it in code.
    Keep it handy for reference as we go through the code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对实现细节仍然有些模糊，但前面的图将帮助我们可视化我们在代码中实现的树。在查看代码时，请将其保留以供参考。
- en: Examining our scene setup
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查我们的场景设置
- en: 'We''ve now looked at the basic structure of our tree, and before we jump in
    and dig into the actual code implementation, let''s look at our scene setup. The
    following screenshot shows our hierarchy; the nodes are highlighted for emphasis:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过了我们树的基本结构，在我们深入实际代码实现之前，让我们看看我们的场景设置。下面的截图显示了我们的层次结构；节点被突出显示以强调：
- en: '![](img/5b10126b-cb0d-411d-b231-77911792460a.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b10126b-cb0d-411d-b231-77911792460a.png)'
- en: 'The setup is quite simple. There is a quad with a world-space canvas, which
    is simply to display some information during the test. The nodes highlighted in
    the preceding screenshot will be referenced in the code later, and we''ll be using
    them to visualize the status of each individual node. The actual scene looks something
    like the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 设置相当简单。有一个带有世界空间画布的四边形，它只是用于在测试期间显示一些信息。前面截图中的突出显示的节点将在代码中稍后引用，我们将使用它们来可视化每个单独节点的状态。实际场景看起来大致如下截图所示：
- en: '![](img/d4cd6829-b2ae-44fd-b785-2c6b0611cc40.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4cd6829-b2ae-44fd-b785-2c6b0611cc40.png)'
- en: Our actual layout mimics the diagram we created earlier
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实际布局模仿了我们之前创建的图
- en: As you can see, we have one node or box representing each of the nodes that
    we laid out in our planning phase. These are referenced in the actual test code
    and will be changing colors according to the state that is returned.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有一个节点或框代表我们在规划阶段设置的每个节点。这些在实际情况的测试代码中会被引用，并且会根据返回的状态改变颜色。
- en: Exploring the MathTree code
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 MathTree 代码
- en: 'Without further ado, let''s have a look at the code driving our test. This
    is `MathTree.cs`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，让我们看看驱动我们测试的代码。这是 `MathTree.cs`：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first few variables are simply used for debugging. The three color variables
    are the colors we'll be assigning to our node boxes to visualize their state.
    By default, `RUNNING` is yellow, `SUCCESS` is green, and `FAILED` is red. This
    is pretty standard stuff; let's move along.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前几个变量只是用于调试。三个颜色变量是我们将分配给节点框以可视化其状态的颜色。默认情况下，`RUNNING` 是黄色，`SUCCESS` 是绿色，`FAILED`
    是红色。这是相当标准的事情；让我们继续前进。
- en: We then declare our actual nodes. As you can see, `m_rootNode` is a selector,
    as we mentioned earlier. Notice that we do not assign any of the node variables
    yet, since we have to pass in some data to their constructors.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们声明我们的实际节点。如您所见，`m_rootNode` 是一个选择器，正如我们之前提到的。请注意，我们还没有分配任何节点变量，因为我们必须向它们的构造函数传递一些数据。
- en: We then have the references to the boxes we saw in our scene. These are just
    game objects that we drag and drop into the inspector (we'll have a look at that
    after we inspect the code).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来有对我们在场景中看到的框的引用。这些只是我们拖放到检查器中的游戏对象（我们会在检查代码之后查看）。
- en: We then have a couple of `int` values, which will make more sense as we look
    at the logic, so we'll skip over these. Lastly, we have a unity UI Text variable
    that will display some values for us during the test.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来有几个 `int` 值，当我们查看逻辑时会更有意义，所以我们会跳过这些。最后，我们有一个 Unity UI Text 变量，在测试期间会显示一些值。
- en: 'Let''s get into the initialization of our actual nodes:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们实际节点的初始化：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For the sake of organization, we declare our nodes from the bottom of the tree
    to the top of the tree, or the root node. We do this because we cannot instantiate
    a parent without passing in its child nodes, so we have to instantiate the child
    nodes first. Notice that `m_node2A`, `m_node2C`, and `m_node3` are action nodes,
    so we pass in delegates (we'll look at these methods next). Then, `m_node2B`,
    being a selector, takes in a node as a child, in this case `m_node3`. After we've
    declared these tiers, we throw all the tier 2 nodes into a list because our tier
    1 node, the root node, is a selector that requires a list of children to be instantiated.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了组织结构，我们从树的底部到顶部声明我们的节点，或者说是根节点。我们这样做是因为我们不能在没有传递其子节点的情况下实例化父节点，所以我们必须首先实例化子节点。请注意，`m_node2A`、`m_node2C`和`m_node3`是动作节点，因此我们传递了代表（我们将在下一节中查看这些方法）。然后，作为选择器的`m_node2B`接受一个节点作为子节点，在这种情况下是`m_node3`。在我们声明了这些层级之后，我们将所有2级节点放入一个列表中，因为我们的1级节点，即根节点，是一个需要实例化子节点列表的选择器。
- en: 'After we''ve instantiated all of our nodes, we kick off the process and begin
    evaluating our root node using its `Evaluate()` method. The `UpdateBoxes()` method
    simply updates the `box` game objects that we declared earlier with the appropriate
    colors; we''ll look at that later on in this section:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实例化所有节点之后，我们启动流程，并开始使用其`Evaluate()`方法评估我们的根节点。`UpdateBoxes()`方法只是更新我们之前声明的`box`游戏对象的颜色；我们将在本节的稍后部分查看它：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There is not a whole lot to discuss here. Do notice that, because we set this
    tree up manually, we check each node individually and get its `nodeState` and
    set the colors using the `SetSucceeded` and `SetFailed` methods. Let''s move on
    to the meaty part of the class:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多可讨论的内容。请注意，因为我们手动设置了此树，所以我们逐个检查每个节点并获取其`nodeState`，然后使用`SetSucceeded`和`SetFailed`方法设置颜色。让我们继续到类的核心部分：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, we have `NotEqualToTarget()`, which is the method we passed into our
    decorator's child action node. We're essentially setting ourselves up for a double
    negative here, so try to follow along. This method returns a success if the current
    value is *not* equal to the target value, and returns false otherwise. The parent
    inverter decorator will then evaluate to the opposite of what this node returns.
    So, if the value is not equal, the inverter node will fail; otherwise, it will
    succeed. If you're feeling a bit lost at this point, don't worry. It will all
    make sense when we see this in action.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有`NotEqualToTarget()`，这是我们传递给装饰器子动作节点的方法。我们在这里实际上是在设置一个双重否定，所以尽量跟上。此方法在当前值不等于目标值时返回成功，否则返回false。父级反转装饰器将评估为与该节点返回值相反。所以，如果值不等于，反转节点将失败；否则，它将成功。如果您现在感到有些困惑，不要担心。当我们看到它在实际操作中的表现时，一切都会变得清晰。
- en: The next method is the `AddTen()` method, which is the method passed into our
    other two action nodes. It does exactly what the name implies—it adds 10 to our
    `m_currentValue` variable, then checks whether it's equal to our `m_targetValue`,
    and evaluates as `SUCCESS` if so, and `FAILURE` if not.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法是`AddTen()`方法，这是传递给我们的其他两个动作节点的方法。它确实做了它名字暗示的事情——将10加到我们的`m_currentValue`变量上，然后检查它是否等于我们的`m_targetValue`，如果是，则评估为`SUCCESS`，如果不是，则评估为`FAILURE`。
- en: The last few methods are self-explanatory so we will not go over them.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后几个方法比较直观，所以我们不会详细说明。
- en: Executing the test
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行测试
- en: 'Now that we have a pretty good idea of how the code works, let''s see it in
    action. First things first, however. Let''s make sure our component is properly
    set up. Select the Tree game object from the hierarchy, and its inspector should
    look similar to this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对代码的工作原理有了相当好的了解，让我们看看它在实际操作中的表现。首先，然而。让我们确保我们的组件被正确设置。从层次结构中选择Tree游戏对象，其检查器应该看起来类似于以下内容：
- en: '![](img/53ca85d6-29e9-4025-a991-7409bda131a8.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/53ca85d6-29e9-4025-a991-7409bda131a8.png)'
- en: The default settings for the component
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的默认设置
- en: 'As you can see, the state colors and box references have already been assigned
    for you, as well as the `m_valueLabel` variable. The `m_targetValue` variable
    has also been assigned for you via code. Make sure to leave it at (or set it to)
    20 before you hit play. Play the scene, and you''ll see your boxes lit up, as
    shown in the following screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，状态颜色和盒子引用已经为您分配，以及`m_valueLabel`变量。`m_targetValue`变量也已经通过代码为您分配。确保在播放之前将其保留为（或设置为）20。播放场景，您将看到您的盒子被点亮，如下面的截图所示：
- en: '![](img/30f951fc-e54e-4b01-946c-39cddfcb89c0.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/30f951fc-e54e-4b01-946c-39cddfcb89c0.png)'
- en: The boxes lit up, indicating the result of each node's evaluation
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 箱子被点亮，表示每个节点的评估结果
- en: 'As we can see, our root node evaluated to `SUCCESS`, which is what we intended,
    but let''s examine why, one step at a time, starting at tier 2:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们的根节点评估为 `SUCCESS`，这正是我们想要的，但让我们一步一步地检查原因，从第 2 层开始：
- en: '**Node 2A**: We started with `m_currentValue` at `0`, so upon adding `10` to
    it, it''s still not equal to our `m_targetValue` (`20`) and it fails. Thus, it
    is red.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点 2A**：我们从 `m_currentValue` 的 `0` 开始，所以当给它加上 `10` 后，它仍然不等于我们的 `m_targetValue`
    (`20`)，因此它失败了。因此，它是红色的。'
- en: '**Node 2B**: As it evaluates its child, once again, `m_currentValue` and `m_targetValue`
    are not equal. This returns `SUCCESS`. Then, the inverter logic kicks in and reverses
    this response so that it reports `FAILURE` for itself. So, we move on to the last
    node.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点 2B**：当它评估其子节点时，再次，`m_currentValue` 和 `m_targetValue` 不相等。这返回 `SUCCESS`。然后，反相逻辑启动并反转这个响应，使其报告自己的
    `FAILURE`。因此，我们继续到最后一个节点。'
- en: '**Node 2C**: Once again, we add `10` to `m_currentValue`. It then becomes `20`,
    which is equal to `m_targetValue`, and evaluates as `SUCCESS`, so our root node
    is successful as a result.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点 2C**：再次，我们将 `10` 加到 `m_currentValue` 上。它变成了 `20`，这等于 `m_targetValue`，评估结果为
    `SUCCESS`，因此我们的根节点因此成功。'
- en: 'The test is simple, but it illustrates the concepts clearly. Before we consider
    the test a success, let''s run it one more time, but change `m_targetValue` first.
    Set it to `30` in the inspector, as shown in the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 测试很简单，但它清楚地说明了概念。在我们认为测试成功之前，让我们再运行一次，但首先更改 `m_targetValue`。在检查器中将其设置为 `30`，如以下截图所示：
- en: '![](img/05297735-8c83-48f3-9238-37fc70d5a36f.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/05297735-8c83-48f3-9238-37fc70d5a36f.png)'
- en: The updated value is highlighted
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的值被突出显示
- en: 'A small change, to be sure, but it will change how the entire tree evaluates.
    Play the scene again, and we will end up with the set of nodes lit up, as shown
    in the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个小的变化，但它将改变整个树的评估方式。再次播放场景，我们最终会得到以下截图所示的节点点亮集合：
- en: '![](img/abe6813b-80d5-4d18-998c-3e6956516a24.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/abe6813b-80d5-4d18-998c-3e6956516a24.png)'
- en: A clearly different result from our first test
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们第一次测试明显不同的结果
- en: 'As you can see, all but one of the child nodes of our root failed, so it reports
    `FAILURE` for itself. Let''s look at why:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，除了一个子节点外，我们的根节点的所有子节点都失败了，因此它自己报告 `FAILURE`。让我们看看为什么：
- en: '**Node 2A**: Nothing really changes here from our original example. Our `m_currentValue`
    variable starts at `0` and ends up at `10`, which is not equal to our `m_targetValue`
    of `30`, so it fails.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点 2A**：这里与我们原始示例相比没有真正的变化。我们的 `m_currentValue` 变量从 `0` 开始，最终达到 `10`，这并不等于我们的
    `m_targetValue` `30`，因此它失败了。'
- en: '**Node 2B**: This evaluates its child once more, and because the child node
    reports `SUCCESS`, it reports `FAILURE` for itself, and we move on to the next
    node.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点 2B**：它再次评估其子节点，因为子节点报告 `SUCCESS`，它自己报告 `FAILURE`，然后我们继续到下一个节点。'
- en: '**Node 2C**: Once again, we add `10` to our `m_currentValue` variable, adding
    up to `20`, which, after having changed the `m_targetValue` variable, no longer
    evaluates to `SUCCESS`.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点 2C**：再次，我们将 `10` 加到我们的 `m_currentValue` 变量上，累计到 `20`，在更改了 `m_targetValue`
    变量之后，不再评估为 `SUCCESS`。'
- en: 'The current implementation of the nodes will have unevaluated nodes default
    to `SUCCESS`. This is because of our enum order, as you can see in `NodeState.cs`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的当前实现将未评估的节点默认设置为 `SUCCESS`。这是因为我们的枚举顺序，如您在 `NodeState.cs` 中所见：
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In our enum, `SUCCESS` is the first enumeration, so if a node never gets evaluated,
    the default value is never changed. If you were to change the `m_targetValue`
    variable to `10`, for example, all the nodes would light up to green. This is
    simply a by-product of our test implementation and doesn't actually reflect any
    design issues with our nodes. Our `UpdateBoxes()` method updates all the boxes
    whether they were evaluated or not. In this example, node **2A** would immediately
    evaluate as `SUCCESS`, which, in turn, would cause the root node to report `SUCCESS`,
    and neither node **2B**, **2C**, nor **3** would be evaluated at all, having no
    effect on the evaluation of the tree as a whole.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的枚举中，`SUCCESS` 是第一个枚举，所以如果一个节点从未被评估，默认值永远不会改变。如果您将 `m_targetValue` 变量更改为
    `10`，例如，所有节点都会点亮为绿色。这仅仅是我们的测试实现的一个副作用，实际上并不反映我们节点的设计问题。我们的 `UpdateBoxes()` 方法会更新所有盒子，无论它们是否被评估。在这个例子中，节点
    **2A** 会立即评估为 `SUCCESS`，这反过来又会导致根节点报告 `SUCCESS`，而节点 **2B**、**2C** 和 **3** 都不会评估，对整个树的评估没有影响。
- en: You are highly encouraged to play with this test. Change the root node implementation
    from a selector to a sequence, for example. By simply changing `public Selector
    m_rootNode;` to `public Sequence m_rootNode;` and `m_rootNode = new Selector(rootChildren);`
    to `m_rootNode = new Sequence(rootChildren);`, you can test a completely different
    set of functionality.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 非常鼓励你尝试这个测试。例如，将根节点实现从选择器改为序列。只需将 `public Selector m_rootNode;` 改为 `public Sequence
    m_rootNode;`，并将 `m_rootNode = new Selector(rootChildren);` 改为 `m_rootNode = new
    Sequence(rootChildren);`，你就可以测试一组完全不同的功能。
- en: HomeRock card game example
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HomeRock卡牌游戏示例
- en: 'To further illustrate potential uses for BTs, let''s take a look at the second
    example for this chapter included in the sample code. In the `CardGame` Unity
    scene, you''ll find an implementation of a turn-based card game, where the player
    and the AI opponent have three different abilities: attack, heal, and defend.
    The user gets to pick which ability to use on their turn, and the AI will use
    a BT to decide which course of action to take. The game ends when a player reaches
    0 hit points. The following image illustrates our game view:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步说明行为树的可能用途，让我们看看本章示例代码中的第二个例子。在`CardGame` Unity场景中，你可以找到一个回合制卡牌游戏的实现，其中玩家和AI对手有三种不同的能力：攻击、治疗和防御。用户可以在他们的回合选择使用哪种能力，AI将使用行为树来决定采取哪种行动。游戏在玩家生命值降至0时结束。以下图像展示了我们的游戏视图：
- en: '![](img/edbf4249-ce47-411a-8f09-b2f88adf1cf0.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/edbf4249-ce47-411a-8f09-b2f88adf1cf0.png)'
- en: Game screen for HomeRock—Heroes of Unity
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: HomeRock—Unity英雄的游戏屏幕
- en: As you can see here, the player can select their attack by clicking on one of
    the cards, which have been spruced up with some flavor text. The player's hit
    points are displayed in the lower-left corner, and the AI enemy's hit points are
    displayed in the top-right corner of the screen. The premise is simple, even if
    the example is a bit silly. Let's take a look at the scene setup before we dive
    into the code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，玩家可以通过点击一张卡片来选择他们的攻击方式，这些卡片已经添加了一些风味文本。玩家的生命值显示在屏幕左下角，AI敌人的生命值显示在屏幕右上角。前提很简单，即使例子有点愚蠢。在我们深入代码之前，让我们看看场景设置。
- en: The scene setup
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景设置
- en: 'There are quite a few things going on in this scene, as this example is a bit
    more complex than previous ones in this book. We''ll touch on each element, but
    will keep our focus on the topic at hand: behavior trees. Let''s take a look at
    the scene hierarchy, which looks like the following screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中发生了很多事情，因为这个例子比本书中之前的例子要复杂一些。我们将逐一介绍每个元素，但将重点放在手头的主题上：行为树。让我们看看场景层次结构，如下截图所示：
- en: '![](img/fef2c18f-c18a-4b31-bbca-dc61b05fd4da.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fef2c18f-c18a-4b31-bbca-dc61b05fd4da.png)'
- en: The scene hierarchy
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 场景层次结构
- en: In the hierarchy depicted in this screenshot, we'll find a few game-related
    elements, and you may also notice that the canvas has quite a few elements nested
    under it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个截图显示的层次结构中，我们会发现一些与游戏相关的元素，你也许还会注意到画布下嵌套了相当多的元素。
- en: 'The Game game object has two components on it—the Animator, which controls
    the game states, and the `Game.cs` component, which controls the game flow and
    rules. First, let''s take a look at the game states. The Animator has a reference
    to the `GameFlowStateMachine`**, **which looks like this screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Game` 游戏对象上有两个组件——`Animator`，它控制游戏状态，以及`Game.cs`组件，它控制游戏流程和规则。首先，让我们看看游戏状态。`Animator`
    有一个对`GameFlowStateMachine`的引用，如下截图所示：'
- en: '![](img/3f8240a2-b289-4426-97c5-48141acb07d2.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3f8240a2-b289-4426-97c5-48141acb07d2.png)'
- en: 'The state machine depicted has a few boilerplate states, such as **MainMenu**
    and **GameEnd**. You''ll notice that **MainMenu** is our entry point. While our
    sample doesn''t have a main menu, you could use this state to implement your own.
    In the sample, the state just automatically transitions to the **GameIntro** state.
    Again, **GameIntro** is provided as a staging area for you to implement any intro
    sequences or animations, but defaults to transitioning to the next stage, **MainGame**.
    Finally, we have **GameEnd**, which you can transition to from any state, so long
    as you hit the `EndGame` trigger. You may have noticed that **MainGame** is a
    nested tree, and if we double-click on it to dive into its contents, we''ll find
    a tree that looks like this screenshot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 所示的状态机有几个样板状态，如 **MainMenu** 和 **GameEnd**。你会注意到 **MainMenu** 是我们的入口点。虽然我们的示例没有主菜单，但你可以使用这个状态来实现自己的。在示例中，状态只是自动过渡到
    **GameIntro** 状态。再次强调，**GameIntro** 是一个提供给你实现任何开场序列或动画的舞台，但默认过渡到下一个阶段，**MainGame**。最后，我们有
    **GameEnd**，你可以从任何状态过渡到它，只要你触发了 `EndGame`。你可能已经注意到 **MainGame** 是一个嵌套的树，如果我们双击它来深入其内容，我们会找到一个看起来像这个截图的树：
- en: '![](img/173343d3-c345-43a8-9e30-796a1d003f3e.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/173343d3-c345-43a8-9e30-796a1d003f3e.png)'
- en: 'The setup shown in the previous screenshot is simple enough—there is a player
    turn and an enemy turn. These simply bounce back and forth whenever we set the
    `EndTurn` trigger. Next, we have our `Game.cs` component, which looks like this
    in the inspector:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个截图中的设置足够简单——有一个玩家回合和一个敌人回合。这些回合在设置 `EndTurn` 触发器时来回弹跳。接下来，我们有 `Game.cs` 组件，这在检查器中看起来是这样的：
- en: '![](img/ddc54488-6113-444e-8ff0-785c1c3f4bd0.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ddc54488-6113-444e-8ff0-785c1c3f4bd0.png)'
- en: 'In the previous screenshot, we can see that the Game component has some references
    to other scripts in our scene. We''ll get to those in a minute, but do notice
    that there is a reference to our state machine. Let''s dive into the `Game.cs`
    code to see what''s going on under the hood:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们可以看到游戏组件对场景中其他脚本的一些引用。我们稍后会涉及到这些，但请注意，有一个对状态机的引用。让我们深入到 `Game.cs`
    代码中，看看底层发生了什么：
- en: '[PRE10]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, we have all the serialized values we saw in the inspector just a moment
    ago, along with a private, non-serialized value, the `turn` value. This value
    flips between 0 and 1 for the player's turn and the AI's turn, respectively. Our
    `Awake` method does some setup, it initializes values in the `EnemyBehaviorTree.cs`
    script, and it adds some callbacks to the enemy AI controller and our player controller.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有在检查器中刚刚看到的所有序列化值，还有一个私有的非序列化值，即 `turn` 值。这个值在玩家的回合和AI的回合之间在0和1之间切换。我们的
    `Awake` 方法进行了一些设置，初始化 `EnemyBehaviorTree.cs` 脚本中的值，并添加了一些回调到敌人AI控制器和我们的玩家控制器。
- en: 'The `EvaluateAITree()` method simply wraps the enemy''s BT''s `Evaluate()`
    method. We do this for some pseudo-decoupling. Lastly, the `EndTurn()` method
    does a few things: it checks whether either of the players'' health is below 0,
    and ends the game if so; it also toggles the turn value, sets the appropriate
    trigger on the state machine, and updates the turn message on the `UIController`.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`EvaluateAITree()` 方法简单地封装了敌人的 BT 的 `Evaluate()` 方法。我们这样做是为了实现一些伪解耦。最后，`EndTurn()`
    方法执行了一些操作：检查两位玩家的健康值是否低于0，如果是，则结束游戏；它还切换回合值，在状态机设置适当的触发器，并更新 `UIController` 上的回合信息。'
- en: 'Next in our scene''s hierarchy, nested under the Game game object, we have
    a HumanPlayer game object, and an EnemyAI game object. Both have a `Player.cs`
    script, which simply contains data and methods that control that player''s values.
    The screenshot here shows the values for the HumanPlayer game object''s Player
    component:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们场景的层次结构中，在 Game 游戏对象下，我们有一个 HumanPlayer 游戏对象和一个 EnemyAI 游戏对象。两者都有一个 `Player.cs`
    脚本，该脚本仅包含控制和操作该玩家值的数据和方法。下面的截图显示了 HumanPlayer 游戏对象的 Player 组件的值：
- en: '![](img/8278b54c-7710-4075-afa4-9a43382c4310.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8278b54c-7710-4075-afa4-9a43382c4310.png)'
- en: 'In order to get a better idea of what the values shown in the preceding screenshot
    do, let''s take a look at the `Player.cs` script and break it down:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解前面截图中所显示的值的作用，让我们看一下 `Player.cs` 脚本并将其分解：
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first few values are fairly simple. We have the player's max health represented
    by `maxHealth` and their current health represented by `currentHealth`. We use
    a value called `lowHealthThreshold` for the AI to make some decisions. It gives
    us the ability to modify the AI's behavior based on its or its opponent's health.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 前几个值相当简单。`maxHealth` 代表玩家的最大健康值，`currentHealth` 代表当前健康值。我们使用 `lowHealthThreshold`
    这个值让 AI 做出一些决策。它让我们能够根据其或其对手的健康状况来修改 AI 的行为。
- en: We then list out some ability parameters. The `minHealAmount` and `maxHealAmount`
    represent the healing ability's lower and upper limits, respectively. The same
    goes for the `minDamage` and `maxDamage` fields for the attack ability. In the
    case of `isBuffed`, we use a bool to represent whether or not the player is "buffed,"
    which is a generic term in some game genres to denote that a character or player
    has a beneficial gameplay status. There are some properties and initialization
    in our `Awake` method, and then a series of ability methods.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后列出了一些能力参数。`minHealAmount` 和 `maxHealAmount` 分别代表治疗能力的下限和上限。对于攻击能力，`minDamage`
    和 `maxDamage` 字段也是如此。在 `isBuffed` 的情况下，我们使用 bool 来表示玩家是否“被增益”，这在某些游戏类型中是一个通用术语，表示角色或玩家具有有益的游戏状态。在我们的
    `Awake` 方法中还有一些属性和初始化，然后是一系列的能力方法。
- en: The `Buff()` method simply sets the `isBuffed` value to true. We use this in
    our damage calculation later on. The `Heal()` method picks a random number between
    the range specified by `minHealAmount` and `maxHealAmount`, and restores that
    much health to the player's `currentHealth` value. Lastly, the `Damage()` method
    applies a random amount of damage to the player (by subtracting from its current
    health), which is halved when the player's `isBuffed` flag is set to true.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`Buff()` 方法只是将 `isBuffed` 值设置为 true。我们稍后在伤害计算中使用这个值。`Heal()` 方法选择一个介于 `minHealAmount`
    和 `maxHealAmount` 指定范围内的随机数，并将这么多健康值恢复到玩家的 `currentHealth` 值。最后，`Damage()` 方法对玩家施加随机数量的伤害（通过从其当前健康值中减去），当玩家的
    `isBuffed` 标志设置为 true 时，伤害减半。'
- en: 'We can now take a look at the next component of the HumanPlayer game object,
    the `PlayerController.cs` script. The component''s inspector values can be seen
    in the following screenshot:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看看 HumanPlayer 游戏对象的下一个组件，`PlayerController.cs` 脚本。组件的检查器值可以在以下屏幕截图中看到：
- en: '![](img/e378e9c3-c256-4e55-adb3-4afd8cb3865a.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e378e9c3-c256-4e55-adb3-4afd8cb3865a.png)'
- en: The inspector showing all the assigned values for the player controller
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 显示玩家控制器所有分配值的检查器
- en: 'You''ll notice some references to its own `Player.cs` component as well as
    the enemy AI''s component. The Buttons section contains references to the ability
    card''s UI buttons. The code for the class looks like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到一些对其自身的 `Player.cs` 组件以及敌人 AI 组件的引用。按钮部分包含对能力卡 UI 按钮的引用。类的代码看起来是这样的：
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The variables up top are fairly straightforward, and they are the very values
    we just saw in the inspector. You''ll also find an `onActionExecuted` event here,
    which, if you remember, gets assigned from the `Game.cs` script''s `Awake()` function.
    In this class''s `Awake()`, we assign an `onClick` handler for each of the buttons:
    **Defend**, **Heal**, and **Attack**. Each of the methods calls the appropriate
    ability method on the `Player.cs` script, and then calls `EndTurn()`, which, in
    turn, calls the `onActionExecuted` callback. Refer back to the `Game.cs` script
    for what that does.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部的变量相当直接，它们正是我们在检查器中刚刚看到的那些值。你还会在这里找到一个 `onActionExecuted` 事件，如果你还记得的话，它是由
    `Game.cs` 脚本的 `Awake()` 函数分配的。在这个类的 `Awake()` 方法中，我们为每个按钮分配了一个 `onClick` 处理器：**防御**、**治疗**和**攻击**。每个方法都会在
    `Player.cs` 脚本上调用相应的技能方法，然后调用 `EndTurn()`，这反过来又调用 `onActionExecuted` 回调。请参考 `Game.cs`
    脚本了解它所执行的操作。
- en: The enemy state machine
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敌人状态机
- en: 'The `EnemyAI` game object has its own `Player.cs` script, as we saw earlier,
    but it also has the script we''re most interested in: the `EnemyBehaviorTree.cs`
    component. This component contains the BT for our enemy agent, along with some
    helper functionality. Let''s take a look at that code now:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`EnemyAI` 游戏对象有自己的 `Player.cs` 脚本，正如我们之前看到的，但它还有一个我们最感兴趣的脚本：`EnemyBehaviorTree.cs`
    组件。这个组件包含我们的敌人代理的 BT 以及一些辅助功能。现在让我们看看这段代码：'
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We start off with some declarations as usual. Most notably, we declare our
    nodes here. We have some familiar nodes, the `ActionNode`, the `Sequence`, and
    the `Selector`, which you should be familiar with by now. But you may have also
    noticed an unfamiliar node as well—the `RandomBinaryNode`.  Before digging deeper
    into the `EnemyBehaviorTree.cs` code, let''s take a look at the `RandomBinaryNode.cs`
    file to see what this node type does:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像往常一样开始一些声明。最值得注意的是，我们在这里声明了我们的节点。我们有一些熟悉的节点，比如`ActionNode`、`Sequence`和`Selector`，你应该现在已经熟悉它们了。但你可能也注意到了一个不熟悉的节点——`RandomBinaryNode`。在深入挖掘`EnemyBehaviorTree.cs`代码之前，让我们看一下`RandomBinaryNode.cs`文件，看看这个节点类型的作用：
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the node is very simple. We "roll" a random value between 0
    and 1 (keeping in mind that `Random.Range(int, int)` has an exclusive upper range,
    meaning it can return up to that value, but not including it), and return a `SUCCESS`
    state when the `roll` is `0`, and `FAILURE` otherwise.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，节点非常简单。我们“掷”一个介于0和1之间的随机值（记住`Random.Range(int, int)`有一个排他的上限，这意味着它可以返回到那个值，但不包括它），当`roll`为0时返回`SUCCESS`状态，否则返回`FAILURE`。
- en: 'Going back to the `EnemyBehaviorTree.cs` class, we have another delegate/event
    declaration:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`EnemyBehaviorTree.cs`类，我们还有一个委托/事件声明：
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Similar to the `onActionExecuted` event on the `PlayerController.cs` class,
    this one will be called after the AI executes its action and triggers the end-of-turn
    checks. Up next, we have the `Start()` method, which is important as it sets up
    our node structure, starting from the lowest-level nodes:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与`PlayerController.cs`类上的`onActionExecuted`事件类似，这个事件将在AI执行其动作并触发回合结束检查后被调用。接下来，我们有`Start()`方法，它很重要，因为它设置了我们的节点结构，从最低级别的节点开始：
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To better understand what''s going on in this section of the code, let''s take
    a look at the following diagram:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解代码这一部分正在发生什么，让我们看一下下面的图示：
- en: '![](img/0bf4df0e-541f-4a2e-b823-8de031061df3.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0bf4df0e-541f-4a2e-b823-8de031061df3.png)'
- en: Enemy turn behavior tree
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人回合行为树
- en: 'As you can see, the enemy turn is broken up into three steps—health check,
    attack check, and buff check. The health check node is a simple `ActionNode`.
    In this case, we''re modeling a fairly conservative agent, so it prioritizes its
    own health versus being aggressive. The node invokes the following method:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，敌人的回合被分解为三个步骤——健康检查、攻击检查和增益检查。健康检查节点是一个简单的`ActionNode`。在这种情况下，我们正在模拟一个相当保守的代理，因此它优先考虑自己的健康而不是攻击性。节点调用以下方法：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We then have the attack check node, which is also an `ActionNode`. This one
    then checks if the human player''s health is low, and attacks if so, in an attempt
    to go for the kill. This is the function it invokes:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有攻击检查节点，它也是一个`ActionNode`。这个节点会检查人类玩家的健康值是否很低，如果是，就会尝试攻击以试图杀死玩家。这个函数它会调用：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We then have a buff check node, that is actually a sequence, with two children
    nodes. The idea here is that if it did not heal, and it did not attack, the agent
    will attempt to buff itself. However, because this would lead to a loop where
    it buffs itself, the player attacks (thus removing the buff), and it buffs itself
    over and over until its health is low, we add a randomization factor via the `RandomBinaryNode`
    node. The actual buff check calls the following method:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有一个增益检查节点，实际上是一个序列，有两个子节点。这里的想法是，如果没有治疗，也没有攻击，代理将尝试给自己增益。然而，因为这会导致一个循环，其中它不断地给自己增益，玩家攻击（从而移除增益），然后它又不断地给自己增益，直到其健康值很低，所以我们通过`RandomBinaryNode`节点添加了一个随机化因素。实际的增益检查调用以下方法：
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The root node itself is a `Selector`, so that it only requires one child to
    return `SUCCESS` for it to return `SUCCESS` itself. However, we do not use the
    root node''s state value in this example. The last part of our AI code is the
    `Execute()` method, which as you may notice, is a coroutine. We do this to give
    the illusion that the AI is "thinking" about its move. The code looks like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 根节点本身是一个`Selector`，这意味着它只需要一个子节点返回`SUCCESS`，它自己就会返回`SUCCESS`。然而，在这个例子中，我们没有使用根节点的状态值。我们AI代码的最后部分是`Execute()`方法，正如你可能注意到的，它是一个协程。我们这样做是为了给AI“思考”其移动的错觉。代码如下所示：
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We evaluate the state of each node, and act accordingly. In the case that all
    nodes report a `FAILURE`, we fall back to an `else` clause that attacks the enemy.
    At each stage we debug the AI's "process" via debug logs. After all the `if` checks,
    we simply fire off our callback, which in turn calls the `EndTurn()` method we
    passed in earlier via the `Game.cs` script.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们评估每个节点的状态，并相应地采取行动。如果所有节点都报告`FAILURE`，我们将回退到`else`子句，攻击敌人。在每一个阶段，我们通过调试日志调试AI的“过程”。在所有的`if`检查之后，我们简单地触发我们的回调，该回调随后通过`Game.cs`脚本调用我们之前传入的`EndTurn()`方法。
- en: 'The last bit of code to look at for this example is the `EnemyTurnState.cs`
    `StateMachineBehaviour` script. It''s attached to the Enemy Turn state in the
    state machine. In it, we only implement the following two methods:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们需要查看的最后一段代码是`EnemyTurnState.cs`的`StateMachineBehaviour`脚本。它附加到状态机中的敌人回合状态。在其中，我们只实现了以下两个方法：
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see, `OnStateEnter` logs some information to the console, then calls
    the `EvaluteAITree()` method on the `Game.cs` script, which in turn calls the
    `Evaluate()` method on the `EnemyBehaviorTree.cs` script:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`OnStateEnter`将一些信息记录到控制台，然后调用`Game.cs`脚本上的`EvaluteAITree()`方法，该方法随后在`EnemyBehaviorTree.cs`脚本上调用`Evaluate()`方法：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `OnStateExit` method simply logs out some information to the console, so
    that when we enter play mode in the editor, we''ll see an output that looks like
    the following screenshot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnStateExit`方法只是将一些信息记录到控制台，这样当我们编辑器中进入播放模式时，我们会看到一个类似于以下截图的输出：'
- en: '![](img/0f665a42-a8cd-4a47-8db9-fc754505a97e.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f665a42-a8cd-4a47-8db9-fc754505a97e.png)'
- en: The preceding screenshot shows the console after the AI's first turn, where
    neither the AI agent nor the player have sustained enough damage for them to heal
    or attack, and the AI opted to defend itself instead, using the **Buff** ability.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了AI第一次回合后的控制台，此时AI代理和玩家都没有受到足够的伤害以使他们能够治疗或攻击，AI选择防御自己，使用**增益**能力。
- en: Testing the game
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏测试
- en: All you have to do is hit play, and play along. Each game should play differently
    depending on how the randomness of the abilities and the `RandomBinaryNode` play
    out. As you can see, even with the simple three-branch behavior tree used here,
    we're able to create a huge number of possible outcomes for the game. Adding more
    branches to suit your game design can give your game added challenge, replay value,
    and unpredictability.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你所要做的就是点击播放，并参与其中。每场比赛都应该根据能力和`RandomBinaryNode`的随机性不同而有所不同。正如你所见，即使使用这里简单的三分支行为树，我们也能为游戏创造大量的可能结果。添加更多分支以适应你的游戏设计可以给你的游戏增加额外的挑战、重玩价值和不可预测性。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we dug into how a behavior tree works, and then we looked at
    each individual type of node that can make up a behavior tree. We also learned
    the different scenarios where some nodes would be more helpful than others. After
    looking at some off-the-shelf solutions available in the Unity asset store, we
    applied this knowledge by implementing our own basic behavior tree framework in
    C# and explored its inner workings. With the knowledge and the tools out of the
    way, we created a sample behavior tree using our framework to test the concepts
    learned throughout the chapter. We then went on to explore the implementation
    of *HomeRock*, a sample card game that showcases an AI opponent. This knowledge
    prepares us to harness the power of behavior trees in games and take our AI implementations
    to the next level.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们深入探讨了行为树的工作原理，然后我们查看可以组成行为树的每个单独的节点类型。我们还学习了某些节点在某些情况下比其他节点更有帮助的不同场景。在查看Unity资产商店中可用的现成解决方案之后，我们通过在C#中实现自己的基本行为树框架并探索其内部工作原理来应用这些知识。在知识和工具准备就绪之后，我们使用我们的框架创建了一个示例行为树来测试本章学到的概念。然后我们继续探索实现*HomeRock*，一个示例卡牌游戏，展示了AI对手。这些知识使我们能够利用行为树在游戏中的力量，并将我们的AI实现提升到下一个层次。
- en: In the next chapter, [Chapter 7](4dbbb008-faf0-41a9-87d5-391ac3af5781.xhtml),
    *Using Fuzzy Logic to Make Your AI Seem Alive*, we'll look at new ways to add
    complexity and functionality to the concepts we've learned in this chapter, modifying
    behavior trees and FSMs, which we covered in [Chapter 2](9e338555-162c-4ed0-a519-035cfcea94ce.xhtml)*,*
    *Finite State Machines and You*, via the concept of fuzzy logic.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，[第7章](4dbbb008-faf0-41a9-87d5-391ac3af5781.xhtml)，“使用模糊逻辑让你的AI看起来更有生命力”，我们将探讨新的方法来增加我们在这章中学到的概念复杂性和功能性，修改行为树和FSM，这些我们在[第2章](9e338555-162c-4ed0-a519-035cfcea94ce.xhtml)“有限状态机与你”中讨论过，通过模糊逻辑的概念。
