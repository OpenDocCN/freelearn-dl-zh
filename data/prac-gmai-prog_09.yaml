- en: AI Planning and Collision Avoidance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AI规划和避障
- en: In this chapter, we will cover topics that will help bring a higher complexity
    level to our AI characters. The idea of this chapter is to give the power of planning
    and deciding to the characters. We have already explored some of the technical
    knowledge required to achieve this in the previous chapters, and now we will explore
    in detail the process of creating an AI character that can plan ahead their decisions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一些有助于提高AI角色复杂性的主题。本章的目的是赋予角色规划和决策的能力。我们已经在之前的章节中探索了一些实现这一目标所需的技术知识，现在我们将详细探讨创建一个能够提前规划决策的AI角色的过程。
- en: Search
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索
- en: We will start by talking about searching in video games. Search can be the first
    decision that our characters make because in most of the times, we want the characters
    to search for something, either searching for the player or for something else
    that will lead the character to their victory.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从视频游戏中的搜索开始讨论。搜索可能是我们的角色做出的第一个决策，因为在大多数情况下，我们希望角色去寻找某物，无论是寻找玩家还是其他能引导角色走向胜利的东西。
- en: Having our characters be able to successfully find something is very useful
    and can be highly important as well. This is a feature that can be found in a
    large number of video games, and for that reason, it is likely that we will need
    to use it as well.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们的角色能够成功找到某物非常有用，并且可能非常重要。这是一个可以在大量视频游戏中找到的功能，因此我们很可能也需要使用它。
- en: As we saw in previous examples, most of the times we have a player who walks
    around the map and when they come across an enemy, that enemy changes from an
    idle to offensive position. Now, we want the enemy to be proactive and constantly
    searching for the player instead of waiting for him. In our heads, we can start
    thinking about the process that is required for the enemy to start searching for
    the player. That process that we have in our heads needs to be planned, and that
    plan needs to be in the AI character's head. Basically, we want the AI thoughts
    to be the same as our thoughts because that will look realistic, and that is exactly
    what we want.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的例子中所看到的，大多数情况下，我们有一个在地图上四处走动的玩家，当他们遇到敌人时，那个敌人会从闲置状态变为攻击状态。现在，我们希望敌人能够主动出击，不断寻找玩家而不是等待他。在我们的脑海中，我们可以开始思考敌人开始寻找玩家的过程。我们脑海中已有的这个过程需要被规划，而这个计划需要存储在AI角色的脑海中。基本上，我们希望AI的思考过程与我们的思考过程相同，因为这样看起来更真实，这正是我们想要的。
- en: Other times, we might want the search to be secondary, where the main priority
    of the character is something else. This is very common for real-time strategy
    games, where the AI characters start exploring the map, and at a certain point,
    they find an enemy base. The searching wasn't their priority, but even then it
    is a part of the game-exploring the map and getting the opponent's location. After
    discovering the player's location, the AI character can decide whether exploring
    more of it becomes a priority or not and what would be their next step.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能希望搜索成为次要任务，此时角色的主要优先事项是其他事情。这在实时策略游戏中非常常见，AI角色开始探索地图，并在某个时刻发现敌人的基地。搜索并不是他们的首要任务，但即便如此，它仍然是游戏的一部分——探索地图和获取对手的位置。在发现玩家的位置后，AI角色可以决定是否将探索更多区域作为优先事项，以及他们的下一步行动。
- en: Also, we can create realistic animals for hunting games, for example, where
    the main objective of the animal is to eat and drink, so they have to constantly
    search for food or water, and if they are not hungry or thirsty anymore, they
    can search for a warm place to stay. However, meanwhile if the animal finds a
    predator, their priority will change immediately, and the animal will start searching
    for a safe place to stay.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以为狩猎游戏创建逼真的动物，例如，动物的主要目标是进食和饮水，因此它们必须不断寻找食物或水源，如果它们不再饥饿或口渴，它们可以寻找一个温暖的地方休息。然而，与此同时，如果动物发现捕食者，它们的优先级会立即改变，动物将开始寻找一个安全的地方休息。
- en: There are many decisions that can depend on a search system, and it is a feature
    that mimics what real life humans or animals do. We will cover the most common
    types of searches on video games, and the objective is to turn the AI character
    able to search and successfully find anything.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 许多决策都可能取决于搜索系统，这是一个模仿现实生活中人类或动物行为的特征。我们将介绍视频游戏中最常见的搜索类型，目标是使AI角色能够搜索并成功找到任何东西。
- en: Offensive search
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击性搜索
- en: The first type of search that we will create is an offensive search. By offensive
    search, we mean that this is set to be the primary objective of the AI character.
    The idea is that the character of the game for some reason needs to find the player,
    similar to the hide and seek game, where one of the players has to hide and the
    other one needs to find them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的第一种搜索类型是攻击性搜索。通过攻击性搜索，我们指的是这是设置为AI角色的主要目标。想法是游戏中的角色由于某种原因需要找到玩家，类似于捉迷藏游戏，其中一名玩家需要藏起来，而另一名玩家需要找到他们。
- en: 'We have a map where the character can walk freely, only taking in consideration
    the collision avoidance that they have to make (trees, hills, and rocks):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个角色可以自由走动的地图，只需考虑他们必须避免的碰撞（树木、山丘和岩石）：
- en: '![](img/306146e9-f5f3-4320-ac3d-48cb4f9c7443.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/306146e9-f5f3-4320-ac3d-48cb4f9c7443.png)'
- en: So, the first step is to create a system where the character can walk around
    the map. For this example, we have chosen to create a waypoint system where the
    character can move from point to point and explore the entire map.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一步是创建一个系统，让角色可以在地图上四处走动。在这个例子中，我们选择创建一个`waypoint`系统，角色可以从一个点到另一个点移动并探索整个地图。
- en: After importing the map and characters that we'll use on the game, we need to
    configure the waypoints that will be used by the character to know where they
    need to go. We can do this manually adding the coordinates into our code, but
    to simplify the process, we'll create objects on the scene that will serve as
    waypoints and delete the 3D mesh, because it won't be necessary.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入游戏中所使用的地图和角色之后，我们需要配置角色将使用的`waypoint`，以便知道他们需要去哪里。我们可以手动将坐标添加到我们的代码中，但为了简化过程，我们将在场景中创建作为`waypoint`的对象，并删除3D网格，因为它将不再必要。
- en: 'Now, we group all the waypoints that we have created and name the group as
    **waypoints**. Once we have the waypoints in place and grouped together, we can
    start creating the code that will tell our character how many waypoints they need
    to follow. This code is very useful because that way we can create different maps,
    using as many waypoints as we need without necessarily updating the character
    code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将我们创建的所有`waypoint`分组，并将该组命名为**waypoints**。一旦我们将`waypoint`放置并分组，我们就可以开始创建代码，告诉我们的角色他们需要遵循多少个`waypoint`。这段代码非常有用，因为这样我们可以创建不同的地图，使用我们需要的任意数量的`waypoint`，而不必更新角色代码：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code will be assigned to the group that we have created and will count
    the number of waypoints that has inside of it and ordering them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将被分配到我们创建的组中，并计算组内包含的`waypoint`数量并对它们进行排序。
- en: '![](img/469b1cb9-124a-4772-bb52-fed8e5142648.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/469b1cb9-124a-4772-bb52-fed8e5142648.png)'
- en: The blue spheres that we can see in preceding image represent the 3D meshes
    that we have used as waypoints. For this example, the character will follow eight
    points until they finish the path. Now, let's move on to the AI character code
    and see how we can make the AI character move from point to point using the points
    that we have created.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的图像中可以看到的蓝色球体代表我们用作`waypoint`的3D网格。在这个例子中，角色将跟随八个点直到完成路径。现在，让我们继续到AI角色代码，看看我们如何使用我们创建的点让AI角色从一点移动到另一点。
- en: 'We will start by creating the basic functions of the character-the health and
    speed-then we will create a new variable that will give them the next position
    and another variable that will be used to know which waypoint they need to follow:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建角色的基本功能——健康和速度——然后我们将创建一个新的变量，它将给出他们的下一个位置，另一个变量将用于知道他们需要遵循哪个`waypoint`：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we have the basic variables that are needed to make an enemy character
    move from point to point until they find the player. Let''s see how to use these
    in order to make it playable now:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了制作敌人角色从一点移动到另一点直到找到玩家的基本变量。让我们看看如何使用这些变量来使其现在可玩：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the `Start` function, we assigned the first `waypoint` that the characters
    need to follow that is, the `waypoint` number zero, the first on the transform
    list that we have created previously on the `waypoint` code. Also, we have determined
    the velocity of the character, and for this example, we have chosen `10f`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Start`函数中，我们分配了角色需要遵循的第一个`waypoint`，即`waypoint`编号零，也就是我们在`waypoint`代码中之前创建的变换列表中的第一个。此外，我们还确定了角色的速度，在这个例子中，我们选择了`10f`。
- en: Then, in the `Update` function, the character will calculate the distance between
    the next position and the current position, using the `Vector3 dir`. The character
    will constantly be moving on, so we have created a line of code that serves as
    movement for the character `transform.Translate` in this case. Knowing the distance
    and the speed information, the character will know how far it is from the next
    position, and once they reach the desirable distance from that point, they can
    move on to the next point. To make this happen, we will create an `if` statement
    that will tell the character when they reach `0.4f` (for this example) near from
    the point that he is moving into, that means that he already have arrived to that
    destination and he can start moving on to the next point `GetNextWaypoint()`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Update`函数中，角色将计算下一个位置与当前位置之间的距离，使用`Vector3 dir`。角色将不断移动，因此我们创建了一行代码，作为角色移动的代码`transform.Translate`。知道距离和速度信息后，角色将知道他们距离下一个位置有多远，一旦他们到达从该点期望的距离，他们就可以移动到下一个点。为了实现这一点，我们将创建一个`if`语句，告诉角色当他们接近他们正在移动进入的点`0.4f`（在这个例子中）时，这意味着他们已经到达了那个目的地，并且可以开始移动到下一个点`GetNextWaypoint()`。
- en: In the `GetNextWaypoint()` function, the character will start to confirm whether
    they already have arrived at the final destination; if they have, then the object
    can be destroyed, if not, they can follow the next waypoint. The `wavepointIndex++`
    will add one number to the index every time the character arrives at the waypoint
    position, moving from *`0>1>2>3>4>5`* and so on.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GetNextWaypoint()`函数中，角色将开始确认他们是否已经到达了最终目的地；如果是，则可以销毁该物体，如果不是，则可以跟随下一个航标点。每次角色到达航标位置时，`wavepointIndex++`将向索引添加一个数字，从而从*`0>1>2>3>4>5`*
    等等继续。
- en: 'Now, we assign the code to our character and place the character at the start
    position and test the game to check whether it is working properly:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将代码分配给我们的角色，并将角色放置在起始位置，测试游戏以检查它是否正常工作：
- en: '![](img/cf2103af-d861-4fd2-9edd-5474511e6c98.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf2103af-d861-4fd2-9edd-5474511e6c98.png)'
- en: 'Now, the character moves from one point to another, and this is the first and
    necessary step when developing a search system-the character needs to move around
    the map. Now, we just need to make it turn to the direction that they are facing
    and then we can start worrying about the search feature:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，角色从一个点到另一个点移动，这是开发搜索系统的第一步和必要步骤——角色需要在地图上移动。现在，我们只需要让它转向他们面对的方向，然后我们就可以开始关注搜索功能了：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, we have the character facing the direction that they are moving on, and
    we are ready to add the searching system.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，角色面向他们移动的方向，我们准备添加搜索系统。
- en: So, we have a character that is walking from point to point on the map, and
    at this moment even if they find the player, they won't stop walking and nothing
    will happen. So, that's what we are going to do now.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个在地图上从一点走到另一点的角色，在这个时候，即使他们找到了玩家，他们也不会停止行走，什么也不会发生。所以，这就是我们现在要做的。
- en: '![](img/d2245505-9131-4cbd-95ed-876efcb03f86.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2245505-9131-4cbd-95ed-876efcb03f86.png)'
- en: 'The approach that we have chosen to achieve the desired results is to add a
    trigger zone in form of a circle around the character, as we can see in the preceding
    screenshot. The character will be walking around the map, and when that trigger
    zone detects the player, the character has found the primary objective. Let''s
    add that into our character code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择添加一个触发区域来实现预期结果，这个触发区域是以角色为中心的圆形，正如我们在前面的截图中所看到的。角色将在地图上行走，当触发区域检测到玩家时，角色就找到了主要目标。让我们将这个功能添加到我们的角色代码中：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So, now we added a `void OnTriggerEnter` that verifies that the trigger zone
    gets in touch with something else. To check whether the object that has entered
    on the trigger zone is the player, we have an if statement that checks whether
    the object of the game has the tag `Player`. If that is true, the Boolean variable
    `Found` is changed to true. This Boolean variable will be very useful in a moment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在添加了一个`void OnTriggerEnter`函数，用于验证触发区域是否与其他物体接触。为了检查进入触发区域的物体是否是玩家，我们有一个if语句，它会检查游戏中的物体是否有`Player`标签。如果是这样，布尔变量`Found`会被设置为true。这个布尔变量在接下来会非常有用。
- en: 'Let''s test the game and check whether the character passes through the player
    and whether at that moment the variable `Found` has changed from false to true:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下游戏，看看角色是否能够穿过玩家，并且在这个时候变量`Found`是否从false变为true：
- en: '![](img/6a312676-a9c8-4683-a170-a4706dd9731d.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6a312676-a9c8-4683-a170-a4706dd9731d.png)'
- en: The search system that we just implemented works great; the character will walk
    around the map searching for the player and they can find the player without any
    issue. The next step is to tell the character to stop searching when they already
    have found the player.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚实现的搜索系统效果很好；角色将在地图上四处走动寻找玩家，并且可以毫无问题地找到玩家。下一步是告诉角色，当他们已经找到玩家时，停止搜索。
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With these last modifications, we have an AI character that goes around the
    map until they find the player and when they finally find them, they stop moving
    around and ready to plan what to do next.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些最后的修改，我们得到了一个AI角色，它在地图上四处走动，直到找到玩家。当他们最终找到玩家时，他们停止四处走动，并准备计划下一步的行动。
- en: What we have done here is use the `Found` Boolean to determine whether the player
    should be searching for the player or not.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是使用`Found`布尔值来确定玩家是否应该搜索玩家。
- en: '![](img/7eaa77f5-1b7b-4b16-94bc-e4bf6f3c9a1b.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7eaa77f5-1b7b-4b16-94bc-e4bf6f3c9a1b.png)'
- en: The preceding image represents the state of our character at the moment, and
    we are ready to implement more features on it to make them plan and take the best
    decisions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像代表了我们的角色当前的状态，我们准备在它上面实现更多功能，使其能够计划和做出最佳决策。
- en: This searching system can be applied to a lot of different game genres, and
    we can set it fairly quickly, which makes it a perfect way to start planning the
    AI character. Now, let's move on and work on the anticipation feature of the player
    character.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个搜索系统可以应用于许多不同的游戏类型，并且我们可以相当快速地设置它，这使得它成为规划AI角色的完美方式。现在，让我们继续工作，并着手实现玩家角色的预期功能。
- en: Predicting opponent actions
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预测对手行动
- en: Now, let's make the character anticipate what is going to happen even before
    getting in confrontation against the player. This is the part where the character
    AI starts to plan the best options available to accomplish the objective.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们让角色在对抗玩家之前就预期将要发生的事情。这是角色AI开始计划实现目标的最佳选项的部分。
- en: Let's take a look at how we can implement an anticipation system into the character
    AI. We will continue to use the example mentioned in the preceding section, where
    we have a soldier searching for another one in the map. At the moment, we have
    a character that moves around the map and stops when they find the player.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将预期系统集成到角色AI中。我们将继续使用前面提到的例子，其中有一个士兵在地图上寻找另一个士兵。目前，我们有一个在地图上移动并在找到玩家时停止的角色。
- en: If our character AI has found the player, most likely situation is for the player
    to find the character AI as well so that both characters are aware of each other.
    What are the chances of the player attacking the character AI? What are the chances
    of the player not having enough bullets to fire against the character? All of
    that is very subjective and very unpredictable. However, we want our character
    to have that in mind and anticipate the possible moves of the player.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的角色AI找到了玩家，最可能的情况是玩家也会找到角色AI，这样两个角色都会意识到对方的存在。玩家攻击角色AI的可能性有多大？玩家是否有足够的子弹射击角色？所有这些都是非常主观的和不可预测的。然而，我们希望我们的角色能够考虑到这一点，并预期玩家的可能行动。
- en: 'So, let''s start with a simple question: is the player facing the character?.
    Having the character to check this will help them to make a judgment about the
    possible outcomes. To achieve this result, we will be adding a trigger `Collider`
    in the back and another in front of each character of the game, including the
    player as we can see in the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从一个简单的问题开始：玩家是否面对着角色？让角色检查这一点将帮助他们判断可能的后果。为了达到这个结果，我们将在角色的后面添加一个触发器`Collider`，并在每个游戏角色的前面也添加一个，包括玩家，正如我们在下面的截图中所看到的：
- en: '![](img/668401cd-28f5-4f28-84e6-dbcac9508d54.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/668401cd-28f5-4f28-84e6-dbcac9508d54.png)'
- en: The idea of having two extra Colliders on each character is to help the other
    characters identify whether they are looking at the back or front side of the
    character. So, let's add this to every character of the game and name the trigger
    `Collider` with the names `back` and `front`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个角色上放置两个额外的`Collider`的目的是帮助其他角色识别他们是否在查看角色的背面或正面。因此，让我们将这个功能添加到游戏中的每个角色，并将触发器`Collider`命名为`back`和`front`。
- en: 'Now, let''s make the character distinguish between the back and the front trigger.
    It can be done in two different ways-the first way is by adding a stretched trigger
    collider in front of the character representing the observation range:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们让角色区分背面和正面触发器。这可以通过两种不同的方式实现——第一种方式是在角色前方添加一个拉伸的触发器碰撞器，代表观察范围：
- en: '![](img/a69075c2-ce9e-45af-ab50-d2e7095acb3d.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a69075c2-ce9e-45af-ab50-d2e7095acb3d.png)'
- en: 'Alternatively, we can create a RAYCAST starting from the character''s position
    and ending at the distance that we think is likely to be the vision range of our
    character as shown in the following screenshot:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以从角色的位置创建一个射线投射，直到我们认为可能是角色视野范围的距离，如下面的截图所示：
- en: '![](img/0b586143-db50-40e4-895f-0afaa96a64d4.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b586143-db50-40e4-895f-0afaa96a64d4.jpg)'
- en: Both methods have their advantages and disadvantages, and once again, we don't
    necessarily need to constantly use the most complicated methods to achieve great
    results. So, the advice here is to use the method that we are more comfortable
    with, and a good choice for this example would be the trigger `Collider` to represent
    the vision range of the character.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都有其优缺点，而且我们并不一定需要不断使用最复杂的方法来取得好结果。所以，这里的建议是使用我们更熟悉的方法，而对于这个例子来说，使用触发器`Collider`来代表角色的视野范围是一个不错的选择。
- en: 'Let''s add the trigger `Collider` in front of the character, and then we can
    start working on the code to make it detect the front or back side of the characters.
    The first thing we need to change in our code is to make the character face the
    player''s direction when they see him. The character wouldn''t be able to anticipate
    anything if they are not looking at the player, so let''s fix that first:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在角色前方添加触发器`Collider`，然后我们可以开始编写代码，使其检测角色的正面或背面。我们需要在代码中做的第一件事是在他们看到玩家时让角色面向玩家的方向。如果他们没有看着玩家，角色将无法预测任何事情，所以让我们先解决这个问题：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we have our AI character constantly facing the player when they see them.
    To make this work, we added our first line of code inside the `if (Found == true)`.
    Here, we used the `transform.LookAt` that makes the AI face the player character.
    When the player is spotted by our AI character, it automatically becomes the target:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们的AI角色看到玩家时，他们会始终面对玩家。为了使这起作用，我们在`if (Found == true)`内部添加了我们的第一行代码。在这里，我们使用了`transform.LookAt`，这使得AI面对玩家角色。当我们的AI角色发现玩家时，它自动成为目标：
- en: '![](img/29050f88-0b13-4fd7-882b-3b5b25e493a6.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29050f88-0b13-4fd7-882b-3b5b25e493a6.png)'
- en: Now that, we have our AI character facing the player, we can check whether they
    are looking at the back or front side of the player.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的AI角色面对着玩家，我们可以检查他们是否在看着玩家的背面或正面。
- en: It might look illogical for us to think that the character doesn't know the
    difference, but when developing an AI character, everything needs to be written
    on the code, especially details such as this one that can have a huge impact on
    anticipating, planning, and finally making a decision.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，认为角色不知道区别可能看起来不太合逻辑，但在开发AI角色时，所有内容都需要写入代码中，尤其是像这种可能对预测、计划和最终做出决策产生巨大影响的细节。
- en: 'So, now we have to use the trigger `Collider` that we added previously to check
    whether our AI character is facing the front or back side of the player that is
    in front of them. Let''s start by adding the following two new variables:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们必须使用之前添加的触发器`Collider`来检查我们的AI角色是否面对着他们前面的玩家的正面或背面。让我们先添加以下两个新变量：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The variables that we added are the Boolean `facingFront` and `facingBack`.
    The trigger will set one of these values to true, and that way, the character
    AI will know which side they are looking at. So, let''s configure the trigger:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的变量是布尔值`facingFront`和`facingBack`。触发器将其中一个值设置为true，这样角色AI就会知道他们正在看哪一侧。所以，让我们配置触发器：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So, what we did was having the trigger checking whether was colliding against
    the back or front side of the other character. To achieve this result, we have
    the trigger questioning whether the collision that it has detected was the `frontSide`
    object or `backSide` object. Only one of them can be true at a time.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们所做的是设置触发器来检查是否与另一个角色的背面或正面发生碰撞。为了达到这个结果，我们让触发器询问它检测到的碰撞是`frontSide`对象还是`backSide`对象。一次只能有一个为真。
- en: '![](img/a2795f93-935e-45ec-83ea-d71e7998a5f0.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2795f93-935e-45ec-83ea-d71e7998a5f0.png)'
- en: 'Now that, we have our character distinguishing the player''s back side and
    front side, we want him to be able to analyze the dangers of both situations.
    So, the first thing we will do is to have a very distinct difference of the situation
    when the character finds the player facing their back and when they are facing
    their front. When facing the front side, the player is ready to shoot at our AI
    character, so it is an even more dangerous situation. We will be creating a danger
    meter and can start importing this situation into the equation:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的角色已经能够区分玩家的背面和正面，我们希望他能够分析这两种情况的风险。所以，我们首先要做的是让角色在发现玩家背对或面对他时，情况有非常明显的区别。当面对正面时，玩家准备向我们的人工智能角色开枪，所以这是一个更加危险的情况。我们将创建一个危险计分器，并将这种状况纳入等式中：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the variables section, we add a new integer called `dangerMeter`. Now, we
    will add the values that will help determine whether the situation that our AI
    character is facing has a higher or lower risk to be attacked:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量部分，我们添加了一个新的整数变量，称为`dangerMeter`。现在，我们将添加一些值，以帮助我们确定我们的AI角色面临的情况是高风险还是低风险：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So, depending on the situation, we can add a small value that will represent
    a small risk or a big value that will represent a big risk. If the danger value
    is high, the AI character needs to anticipate a life-threatening situation, and
    for that reason, dramatic decisions probably will be made. On the other hand,
    if our character is facing a lower-risk situation, they can start planning something
    more precise and effective.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据具体情况，我们可以添加一个小的数值来代表小的风险，或者添加一个大的数值来代表大的风险。如果危险值很高，AI角色需要预见到可能危及生命的情况，因此可能会做出戏剧性的决定。另一方面，如果我们的角色面临的是低风险情况，他们可以开始制定更精确和有效的计划。
- en: Plenty of factors can be added to the `dangerMeter`, such as the location where
    our character is positioned in relation to the player. To make this, we need to
    divide the map into different zones and assign a level of risk that each zones
    has. For example, if the character is in the middle of the forest, it can be considered
    a moderated risk zone, whereas if they are in the open, it can be considered a
    higher risk zone. How many bullets our character has, the remaining lifelines,
    and endless more can be added into our `dangerMeter` equation. Having this implemented
    into our character will help him anticipate the situations that can happen to
    him.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将许多因素添加到`dangerMeter`中，例如我们的角色相对于玩家的位置。为了做到这一点，我们需要将地图划分为不同的区域，并为每个区域分配一个风险等级。例如，如果角色位于森林中央，它可以被认为是一个中等风险区域，而如果他们在开阔地带，它可以被认为是一个高风险区域。角色的子弹数量、剩余的生命线等等都可以添加到我们的`dangerMeter`等式中。将这一功能实现到角色中，将帮助他预见到可能发生的情况。
- en: Collision avoidance
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞避免
- en: 'Predicting collisions is a very useful thing to have been implemented into
    our AI characters and can be used on crowd systems too in order to make the crowd
    move more organically when one character is walking on the direction as another
    character as we saw in the previous chapter. Now, let''s take a look at a simple
    way to implement this feature:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 预测碰撞是我们AI角色应该具备的非常有用的功能，也可以用于人群系统中，以便在一个人物向另一个人物行进的方向上时，使人群移动得更自然。现在，让我们看看实现这一功能的一种简单方法：
- en: '![](img/d2efc8d9-77fd-4d1c-8238-e4ede7c38e8b.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d2efc8d9-77fd-4d1c-8238-e4ede7c38e8b.png)'
- en: To predict a collision, we need at least two objects or characters. In the preceding
    image, we have two spheres representing two characters and the dashed lines represent
    their movement. If the blue sphere moves toward the red sphere, at a certain point,
    they will collide with each other. The main objective here is to predict when
    that will happen and adjust the trajectory of the sphere so that it can avoid
    the collision.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了预测碰撞，我们需要至少两个物体或角色。在上面的图像中，我们有两个代表两个角色的球体，虚线代表它们的移动。如果蓝色球体向红色球体移动，在某个时刻，它们将相互碰撞。这里的主要目标是预测何时会发生碰撞，并调整球体的轨迹，使其能够避免碰撞。
- en: '![](img/d3082dba-73b6-4b14-9d4b-d9fe7f117c41.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d3082dba-73b6-4b14-9d4b-d9fe7f117c41.png)'
- en: 'In the preceding image, we can see the representation of what we need to do
    if we want our character to avoid colliding with the obstacle. We need to have
    the velocity vector that will indicate the direction of the character. This same
    vector will also be used to produce a new one called `ahead`, which is a copy
    of the velocity vector, but with a longer length. This means that the `ahead`
    vector represents the line of sight of our character, and as soon they see the
    obstacle, they will adjust their direction to avoid colliding with it. This is
    how we calculate the `ahead` vector:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，我们可以看到如果我们想让我们的角色避开障碍物碰撞，我们需要做什么。我们需要一个速度向量来指示角色的方向。这个相同的向量也将被用来产生一个新的向量，称为`ahead`，它是速度向量的一个副本，但长度更长。这意味着`ahead`向量代表了角色的视线，一旦他们看到障碍物，他们就会调整方向以避开它。这就是我们计算`ahead`向量的方式：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `ahead` is a `Vector3` variable, `velocity` is a `Vector3` variable, and
    `MAX_SEE_AHEAD` is a float variable that will tell how far ahead we can see. If
    we increase the `MAX_SEE_AHEAD` value, the earlier the character will start adjusting
    his direction, as demonstrated on the following diagram:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`ahead`是一个`Vector3`变量，`velocity`是一个`Vector3`变量，`MAX_SEE_AHEAD`是一个浮点变量，它将告诉我们我们能看到多远。如果我们增加`MAX_SEE_AHEAD`的值，角色将更早地开始调整方向，如下面的图所示：'
- en: '![](img/26f69b1c-f70d-49fc-b4c6-896a4e653ef2.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/26f69b1c-f70d-49fc-b4c6-896a4e653ef2.png)'
- en: 'To check for the collision, one solution that can be used is the line-sphere
    intersection, where the line is the `ahead` vector and the sphere is the obstacle.
    This method works, but we''ll be using a simplification of that, which is easier
    to understand and has identical results. So, the `ahead` vector will be used to
    produce another vector, and this vector will be half of its length:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查碰撞，一个可以使用的解决方案是线-球相交，其中线是`ahead`向量，球是障碍物。这种方法是有效的，但我们将使用一个简化版本，它更容易理解并且具有相同的结果。因此，`ahead`向量将被用来产生另一个向量，这个向量将是其长度的一半：
- en: '![](img/90fbb91f-0555-4af3-878f-33ca281cf93a.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/90fbb91f-0555-4af3-878f-33ca281cf93a.png)'
- en: 'In the preceding image, we can see that `ahead` and `ahead2` goes toward the
    same direction, the only difference is the length between them:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，我们可以看到`ahead`和`ahead2`指向同一方向，它们之间的唯一区别是长度：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We need to check for a collision to know whether one of those two vectors is
    inside the **OBSTACLE ZONE**. To calculate that, we can compare the distance between
    the vectors and the obstacle center. If the distance is less or equal to the **OBSTACLE
    ZONE**, then that means that our vectors are inside of the **OBSTACLE ZONE** and
    a collision was found.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要检查碰撞，以确定这两个向量中的任何一个是否在**障碍区域**内。为了计算这一点，我们可以比较向量与障碍物中心之间的距离。如果距离小于或等于**障碍区域**，那么这意味着我们的向量在**障碍区域**内，并且检测到了碰撞。
- en: '![](img/851321f2-681a-4ca0-b638-c7f0115573c7.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/851321f2-681a-4ca0-b638-c7f0115573c7.png)'
- en: The `ahead2` vector does not appear on the preceding diagram just to simplify
    it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`ahead2`向量在先前的图中没有显示，只是为了简化它。'
- en: 'If either of the two `ahead` vectors get inside of the **OBSTACLE ZONE**, it
    means that the obstacle is blocking the path, and to solve our problem, we will
    calculate the distance between the two points:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个`ahead`向量中的任何一个进入**障碍区域**，这意味着障碍物阻挡了路径，为了解决我们的问题，我们将计算两点之间的距离：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In case of having more than one obstacle blocking the path, we''ll need to
    check which one is closer to our character, then we can start avoiding the closer
    obstacle first and then move on to the second obstacle:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多于一个障碍物阻挡路径，我们需要检查哪个离我们的角色更近，然后我们可以先避开较近的障碍物，然后再处理第二个障碍物：
- en: '![](img/2a02969c-b5b4-4e09-85b0-6b7c9ad2979d.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2a02969c-b5b4-4e09-85b0-6b7c9ad2979d.png)'
- en: 'The closest obstacle, the most threatening, will be selected for calculation.
    Now, let''s take a look at how we can calculate and perform the avoidance:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最接近的障碍物，最危险的障碍物，将被选中进行计算。现在，让我们看看我们如何计算和执行避开操作：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After `avoidance` is calculated, it is normalized and scaled by `MAX_AVOID`,
    which is a number that is used to define the `avoidance` length. The higher the
    `MAX_AVOID` value is, the stronger is the avoidance, pushing our character away
    from the obstacle.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算避开后，它会被`MAX_AVOID`归一化和缩放，`MAX_AVOID`是一个用来定义避开长度的数字。`MAX_AVOID`的值越高，避开的效果越强，将我们的角色推离障碍物。
- en: '![](img/c57139c2-9a74-4731-948c-5d87c45d6909.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c57139c2-9a74-4731-948c-5d87c45d6909.png)'
- en: The position of any entity can be set as vectors, so they can be used in calculations
    with other vectors and forces.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实体的位置都可以设置为向量，因此它们可以用于与其他向量和力的计算。
- en: Now, we have the foundation to make our character predict and steer away from
    the obstacle position, avoiding collision with it. Using this in conjunction with
    a pathfinding, we can let our characters move freely in the game and enjoy the
    results.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了让我们的角色预测并避开障碍物位置的基础，避免与之碰撞。结合路径查找，我们可以让我们的角色在游戏中自由移动并享受结果。
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have explored how to make our AI character create and follow a plan to execute
    a determinate objective in this chapter. The idea is to think ahead what is going
    to happen and to prepare for that situation. To complete this, we have also explored
    how to make our AI character predict a collision with an object or another character.
    This will be fundamental not only to make our character move freely on the map,
    but also it serves as a new equation to have in mind when planning what to do.
    In our next chapter, we will be talking about awareness, how to develop one of
    the most iconic features of stealth games, and make our AI characters self-aware
    of what is happening around them with realistic field of view.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何让我们的AI角色创建并遵循一个计划以执行一个确定的目标。这个想法是提前思考将要发生的事情，并为这种情况做好准备。为了完成这个目标，我们还探讨了如何让我们的AI角色预测与物体或另一个角色的碰撞。这不仅对于让我们的角色在地图上自由移动是基本的，而且它也作为在规划要做什么时需要考虑的新方程。在我们下一章中，我们将讨论意识，如何发展潜行游戏中最具标志性的特征，并让我们的AI角色通过真实的视野范围意识到周围发生的事情。
