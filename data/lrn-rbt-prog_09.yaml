- en: '*Chapter 7*: Drive and Turn – Moving Motors with Python'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：驱动和转向 – 使用Python移动电机'
- en: In this chapter, we will take the robot we started building in the last chapter,
    connect the motors to the Raspberry Pi, and build the Python code to make them
    move. We will cover programming techniques to create a layer between the physical
    robot and its behavior code, to reduce the impact of hardware changes. Our code
    and build will get the robot moving! We finish by programming the robot to drive
    a small set path. The robot code layer will serve as a foundation for all our
    robot behaviors, and the set path will demonstrate how to use it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续构建上一章开始构建的机器人，将电机连接到树莓派，并构建Python代码来使它们移动。我们将介绍编程技术，在物理机器人和其行为代码之间创建一个层，以减少硬件变化的影响。我们的代码和构建将使机器人移动！我们通过编程机器人驾驶一个小路径来结束。机器人代码层将作为我们所有机器人行为的基础，而设定的路径将展示如何使用它。
- en: 'We cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Writing code to test your motors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写代码来测试你的电机
- en: Steering a robot
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驾驶机器人
- en: Making a `Robot` object—code for our experiments to talk to the robot
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`Robot`对象——我们的实验代码与机器人通信
- en: Writing a script to follow a predetermined path
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个脚本以遵循预定的路径
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete the experiments in this chapter, you will require the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的实验，你需要以下条件：
- en: A computer with access to the internet
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台可以访问互联网的电脑
- en: The chassis built in the [*Chapter 6*](B15660_06_Final_ASB_ePub.xhtml#_idTextAnchor096),
    *Building Robot Basics – Wheels, Power, and Wiring*
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[*第6章*](B15660_06_Final_ASB_ePub.xhtml#_idTextAnchor096)，*构建机器人基础 – 轮子、电源和布线*中构建的底盘
- en: The motor controller bought in [*Chapter 6*](B15660_06_Final_ASB_ePub.xhtml#_idTextAnchor096),
    *Building Robot Basics – Wheels, Power, and Wiring*
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[*第6章*](B15660_06_Final_ASB_ePub.xhtml#_idTextAnchor096)，*构建机器人基础 – 轮子、电源和布线*中购买的电机控制器
- en: A 2-meter by 2-meter flat space for the robot to drive on
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为机器人驾驶提供一个2米乘2米的平坦空间
- en: Important note
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: Be prepared to stop your robot from driving over the edges if you use a table!
    It's best to use the floor.
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你使用桌子，请准备好停止你的机器人从边缘驶过！最好使用地板。
- en: 'Check out the following video to see the code in action: [https://bit.ly/39sHxWL](https://bit.ly/39sHxWL)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：[https://bit.ly/39sHxWL](https://bit.ly/39sHxWL)
- en: Writing code to test your motors
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写代码来测试你的电机
- en: Before we get stuck in and do fancy things with the motors, we need to get them
    set up and test them. This way, we can make sure they work and iron out any problems.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用电机做一些花哨的事情之前，我们需要设置并测试它们。这样，我们可以确保它们工作并消除任何问题。
- en: We need to download the library to work with the motor board we have chosen.
    Many robot parts, apart from the simplest ones, have an interface library to control
    the motors and other devices on the board. It's time to log in to your Pi using
    PuTTY again.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要下载库来与我们所选择的电机板一起工作。许多机器人部件，除了最简单的部件外，都有一个接口库来控制板上的电机和其他设备。现在是时候再次使用PuTTY登录到你的Pi了。
- en: Preparing libraries
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备库
- en: 'We download this code from a project on GitHub using Git on the Raspberry Pi.
    So, we need to install Git on the Pi; we also need I2C (`i2c-tools` and `python3-smbus`)
    and `pip` to install things into Python. Type the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用树莓派上的Git从GitHub上的一个项目下载此代码。因此，我们需要在Pi上安装Git；我们还需要I2C（`i2c-tools`和`python3-smbus`）和`pip`来将东西安装到Python中。输入以下命令：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To get the library for the motor board, `Raspi_MotorHAT`, we use Git and download
    it from GitHub, installing it for use in any of your scripts with the following
    command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取电机板库`Raspi_MotorHAT`，我们使用Git从GitHub下载它，并使用以下命令将其安装以供任何脚本使用：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We now have the libraries prepared for starting the robot. Documentation for
    the `Raspi_MotorHAT` library is sparse but is at [https://github.com/orionrobots/Raspi_MotorHAT](https://github.com/orionrobots/Raspi_MotorHAT),
    along with examples of using it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了启动机器人的库。`Raspi_MotorHAT`库的文档很少，但可以在[https://github.com/orionrobots/Raspi_MotorHAT](https://github.com/orionrobots/Raspi_MotorHAT)找到，以及使用它的示例。
- en: Test – finding the Motor HAT
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 – 找到电机板
- en: 'The Raspberry Pi uses I2C to connect to this Motor HAT. `raspi-config` again.
    We also enable the **Serial Peripheral Interface** (**SPI**) while we are here.
    We may need this to connect other boards and sensors. Type the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派使用I2C连接到这个电机板。`raspi-config`再次。我们在这里还启用了**串行外设接口**（**SPI**）。我们可能需要它来连接其他板和传感器。输入以下命令：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we use interfacing settings on this. *Figure 7.1* shows how, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用此处的接口设置。*图7.1*显示了如何进行，如下所示：
- en: '![Figure 7.1 – Using raspi-config to enable SPI and I2C'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 – 使用raspi-config启用SPI和I2C'
- en: '](img/B15660_07_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15660_07_01.jpg)'
- en: Figure 7.1 – Using raspi-config to enable SPI and I2C
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 使用raspi-config启用SPI和I2C
- en: 'Refer to the screenshots in *Figure 7.1* and perform the following steps:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 参考图7.1中的截图并执行以下步骤：
- en: First, select **Interfacing Options**.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，选择**接口选项**。
- en: Next, select **I2C**.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择**I2C**。
- en: The Pi asks if you want this interface to be enabled. Select **<Yes>**.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pi会询问您是否想要启用此接口。选择**<是>**。
- en: You are then taken back to the initial screen and need to navigate again to
    the **Interfacing Options** screen. From there, select **SPI** and **<Yes>** again.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您将被带回到初始屏幕，需要再次导航到**接口选项**屏幕。从那里，选择**SPI**和**<是>**。
- en: A confirmation screen tells you now that SPI is enabled. Select **<Ok>**.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个确认屏幕告诉您现在SPI已被启用。选择**<确定>**。
- en: Finally, press *Esc* twice to finish `raspi-config`. It asks if you want to
    reboot. Select `sudo reboot` to reboot it.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，按两次*Esc*以完成`raspi-config`。它会询问您是否想要重新启动。选择`sudo reboot`以重新启动它。
- en: With I2C, we need a way to choose which device we are talking with. Just as
    with houses along a road, an address allows us to say which one we specifically
    want.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用I2C，我们需要一种方法来选择我们正在与之通信的设备。就像沿着道路的房子一样，一个地址允许我们说出我们具体想要哪一个。
- en: 'We should check that the Raspberry Pi can see the Motor HAT with `sudo i2cdetect
    -y 1` by running the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该检查树莓派是否可以通过以下代码使用`sudo i2cdetect -y 1`看到电机HAT：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This scans the I2C bus `1` for devices attached to our Raspberry Pi. It shows
    numbers at the addresses if something is found. The device found at addresses
    `6f` and `70` is our motor controller. If you cannot see this, power down the
    Raspberry Pi and carefully check that the Motor HAT has been plugged in, then
    try again.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这扫描I2C总线`1`上连接到我们的树莓派的设备。如果找到，会在地址上显示数字。地址`6f`和`70`上的设备是我们的电机控制器。如果您看不到这个，请关闭树莓派的电源，并仔细检查电机HAT是否已正确插入，然后再次尝试。
- en: The addresses are hexadecimal, where each digit counts to 16, using the digits
    `0`-`9`, then letters `A`-`F` instead of counting only 10\. When used in code,
    these get a `0x` prefix. This is a *zero* and then a lowercase x.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 地址是十六进制，其中每个数字计到16，使用数字`0`-`9`，然后是字母`A`-`F`，而不是只计算10。在代码中使用时，这些数字前面有一个`0x`前缀。这是一个*零*然后是一个小写的x。
- en: We have enabled the I2C (and SPI) bus, and we then used the `i2cdetect` tool
    to find our motor device. This confirms first that it is connected and responding,
    and secondly that we have the right address—`0x6f`—for it. We can now start to
    send commands to it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经启用了I2C（和SPI）总线，然后我们使用了`i2cdetect`工具来找到我们的电机设备。这首先确认它已连接并响应，其次确认我们有了正确的地址—`0x6f`。我们现在可以开始向它发送命令了。
- en: Test – demonstrating that the motors move
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 – 展示电机移动
- en: 'We need a test file to demonstrate that the motors work. Carry out the following
    steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个测试文件来演示电机是否工作。执行以下步骤：
- en: 'Create the following file, called `test_motors.py`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下文件，命名为`test_motors.py`：
- en: '[PRE4]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Upload this file to your Raspberry Pi using the methods found in [*Chapter 5*](B15660_05_Final_ASB_ePub.xhtml#_idTextAnchor081),
    *Backing Up the Code with Git and SD Card Copies*.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用在[*第5章*](B15660_05_Final_ASB_ePub.xhtml#_idTextAnchor081)中找到的方法将此文件上传到您的树莓派，*使用Git和SD卡副本备份代码*。
- en: Important note
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: Move your robot from your desk and down to the floor for this next step, as
    when it moves, it might not go in the direction you expect!
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将您的机器人从您的桌子移到地板上，进行下一步，因为当它移动时，它可能不会按照您预期的方向移动！
- en: 'To run this code, through PuTTY on the Pi, type the following:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行此代码，通过Pi上的PuTTY，键入以下内容：
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Your robot should now drive roughly forward. It may move slightly to the side,
    but it should not be turning or going backward, and both motors should be moving.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您的机器人现在应该大致向前行驶。它可能稍微向一侧移动，但它不应该转弯或后退，并且两个电机都应该在移动。
- en: Troubleshooting
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'If you see any problems, try this troubleshooting chart and go back:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到任何问题，请尝试以下故障排除图表并返回：
- en: '![](img/Table7.1(new).jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table7.1(new).jpg)'
- en: By this point, you should have a robot that will drive forward, have seen it
    move, and dealt with the preceding troubleshooting issues.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该有一个能够向前行驶的机器人，已经看到它移动，并处理了前面的故障排除问题。
- en: Understanding how the code works
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解代码是如何工作的
- en: Now, our motors are moving and the robot drives using the `test_motors.py` code.
    But how does our motor test code really work? In this section, let's take a closer
    look and understand this.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的电机正在移动，机器人使用`test_motors.py`代码进行驱动。但我们的电机测试代码实际上是如何工作的呢？在本节中，让我们仔细看看并理解这一点。
- en: 'The first few lines of code here are imports:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里代码的前几行是导入：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Imports are how Python code *pulls in* other libraries of code to use them.
    The `Raspi_MotorHAT` library is the one we installed for interacting with our
    motors. The `time` library allows us to work with time; in this case, we use it
    for a delay between starting and stopping motors. The `atexit` library allows
    us to run code when this file exits.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 导入是Python代码如何*拉入*其他代码库以供使用的方式。`Raspi_MotorHAT`库是我们为了与电机交互而安装的库。`time`库允许我们处理时间；在这种情况下，我们用它来在启动和停止电机之间设置延迟。`atexit`库允许我们在文件退出时运行代码。
- en: 'In the following lines, we connect the library to the Motor HAT and the two
    motors we have connected:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下几行中，我们将库连接到电机帽和我们所连接的两个电机：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first line here makes a `Raspi_MotorHAT` object with the I2C address `0x6f`
    passed in as `addr`, which we saw in the scan. We call the returned object `mh`
    as an abbreviation for the connected `Raspi_MotorHAT`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一行创建了一个带有I2C地址`0x6f`的`Raspi_MotorHAT`对象，这个地址我们在扫描中看到了。我们将返回的对象称为`mh`，作为连接的`Raspi_MotorHAT`的简称。
- en: 'We then create shortcuts to access the motors: `lm` for the left motor and
    `rm` for the right motor. We get these motor controls from the `mh` object, using
    the motor number shown on the board. Motor 1 is left, and motor 2 is right.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后创建快捷方式来访问电机：`lm`代表左电机，`rm`代表右电机。我们从`mh`对象中获取这些电机控制，使用板上显示的电机编号。电机1是左边的，电机2是右边的。
- en: 'We now define a function, `turn_off_motors`, which runs `Raspi_MotorHAT.RELEASE`
    on each motor on this board—an instruction to make the motors stop, as illustrated
    in the following code snippet:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在定义一个函数，`turn_off_motors`，它在这个板上的每个电机上运行`Raspi_MotorHAT.RELEASE`——这是一个使电机停止的指令，如下面的代码片段所示：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We pass that into `atexit.register(turn_off_motors)`, a command that runs when
    this file finishes—when Python exits. `atexit` runs even when there are errors.
    Without this, the code could break in some interesting way, and the robot keeps
    driving. Robots without this kind of safeguard have a habit of driving off tables
    and into walls. If they carry on trying to drive when their motors are stuck,
    it can damage the motors, motor controllers, and batteries, so it's better to
    stop.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个传递给`atexit.register(turn_off_motors)`，这是一个在文件结束时运行（当Python退出时）的命令。`atexit`即使在出现错误时也会运行。如果没有这个，代码可能会以一种有趣的方式崩溃，机器人会继续驱动。没有这种保护的机器人有从桌子上开走并撞到墙的习惯。如果它们在电机卡住时继续尝试驱动，可能会损坏电机、电机控制器和电池，所以最好是停止。
- en: 'The speed of the motors for this controller/library ranges from `0` to `255`.
    Our code sets the speed of each motor to just above half speed and then runs the
    `Raspi_MotorHAT.FORWARD` mode, which makes each motor drive forward, as illustrated
    in the following snippet:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个控制器/库的电机速度范围从`0`到`255`。我们的代码将每个电机的速度设置为略高于一半的速度，然后运行`Raspi_MotorHAT.FORWARD`模式，这使得每个电机向前驱动，如下面的代码片段所示：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we ask the code to wait for 1 second, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们让代码等待1秒钟，如下所示：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The sleep allows the motors to run in their forward-drive mode for 1 second.
    The program then exits. Since we told it to stop motors when the code exits, the
    motors stop.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`sleep`允许电机以正向驱动模式运行1秒钟。然后程序退出。由于我们告诉它在代码退出时停止电机，所以电机停止。'
- en: We've now written and understood the code to test the motors. You've also seen
    it running. This confirms that you have a viable robot, and you have also started
    using Python imports. You've learned the `atexit` trick to turn things off and
    about using a timer so that the robot has some time to run before exiting. Now,
    we look at how we can steer the robot.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经编写并理解了测试电机的代码。你也看到了它运行的情况。这证实了你有一个可行的机器人，并且你已经开始使用Python导入。你学习了使用`atexit`技巧来关闭事物，以及如何使用计时器，这样机器人在退出前有足够的时间运行。现在，我们来看看我们如何控制机器人。
- en: Steering a robot
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制机器人转向
- en: Now, we've made a robot drive forward. But how do we steer it? How does it turn
    left or right? In order to understand this, we need to first learn about a few
    significant forms of steering that exist. Let's take a look at some, settle on
    the one our robot uses, and write some test code to demonstrate it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经让机器人向前行驶。但我们是怎样控制它的？它是如何左转或右转的？为了理解这一点，我们首先需要了解一些重要的转向形式。让我们看看一些，确定我们的机器人使用的那个，并编写一些测试代码来演示它。
- en: Types of steering
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转向类型
- en: The most common techniques for steering a wheeled vehicle (including a robot)
    fall into two major categories—steerable wheels and fixed wheels, as discussed
    in the following subsections. Each of them comes with a couple of slightly unusual
    variants.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 驾驶轮式车辆（包括机器人）的最常见技术分为两大类——可转向轮和固定轮，如以下小节所述。每一类都带有几个稍微不寻常的变体。
- en: Steerable wheels
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可转向轮
- en: 'In movable wheel designs, one or more wheels in a robot face in a different
    direction from the others. When the robot drives, the differently positioned wheel
    makes the robot turn. There are two common styles of movable wheel steering on
    a robot, as shown here in *Figure 7.2*:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在可移动轮设计中，机器人中的一个或多个轮子与其他轮子朝向不同的方向。当机器人行驶时，不同位置的轮子使机器人转向。机器人的可移动轮转向有两种常见风格，如*图7.2*所示：
- en: '![Figure 7.2 – Steerable wheel types'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 – 可转向轮类型'
- en: '](img/B15660_07_02.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15660_07_02.jpg)'
- en: Figure 7.2 – Steerable wheel types
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 可转向轮类型
- en: 'The green arrows show the direction of movement. The white arrows show changes
    to the shape of the robot and the angle of the wheels. Going through *Figure 7.2*,
    we can note the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 绿色箭头显示移动方向。白色箭头显示机器人形状的变化和车轮的角度。通过*图7.2*，我们可以注意以下几点：
- en: Cars typically use **rack and pinion steering**. When straight, the car goes
    forward.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 汽车通常使用**齿条和齿轮转向**。当直线行驶时，汽车会向前行驶。
- en: When the lower bar is moved, shown by the white arrows, the car turns.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当下方的杆被移动时，由白色箭头所示，汽车会转向。
- en: The other common type is **wagon-style steering**, used in homemade racing karts.
    When straight, it goes forward.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种常见类型是**火车式转向**，用于家用赛车卡丁车。当直线行驶时，它会向前行驶。
- en: By turning the front bar, you can steer the vehicle.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转动前杆，你可以转向车辆。
- en: 'There are also other variants besides the ones we discussed previously. They
    include the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们之前讨论的变体之外，还有其他变体。它们包括以下内容：
- en: Robots with the ability to independently reorient each wheel and drive sideways
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够独立重新定位每个轮子并侧向行驶的机器人
- en: Ackerman steering, where the amount each wheel rotates is different
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阿克曼转向，其中每个轮子旋转的角度不同
- en: Rear steering, where a front set of wheels and a rear set of wheels steer—used
    in long vehicles
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后轮转向，其中前轮组和后轮组转向——用于长车辆
- en: 'A good example of wagon-style steering is the Unotron robot, shown here in
    *Figure 7.3*. This was built by my son from the Unotron chassis by 4tronix, with
    an Arduino Nano controller:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 火车式转向的一个很好的例子是Unotron机器人，如*图7.3*所示。这是我的儿子用4tronix的Unotron底盘和Arduino Nano控制器制作的：
- en: '![Figure 7.3 – Wagon-style steering Unotron robot'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3 – 火车式转向Unotron机器人'
- en: '](img/B15660_07_03.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15660_07_03.jpg)'
- en: Figure 7.3 – Wagon-style steering Unotron robot
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 火车式转向Unotron机器人
- en: In the Unotron design, there is a single motor-driven wheel at the back (under
    the motor controller). A servo motor turns the whole front plate, steering the
    two front wheels.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unotron设计中，有一个由电机驱动的单轮位于后方（在电机控制器下方）。伺服电机转动整个前板，从而转向两个前轮。
- en: The disadvantages of this type of steering are related to space, weight, and
    complexity. A chassis set up for movable wheel steering requires more moving parts
    and space to house them. Unotron is as simple as it gets. There is more complexity
    in other designs, which can lead to required maintenance.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型转向的缺点与空间、重量和复杂性有关。为可移动轮转向设置的底盘需要更多的活动部件和空间来容纳它们。Unotron是最简单的。其他设计中存在更多复杂性，这可能导致需要维护。
- en: The distance needed to make a turn (known as the turning circle) or for robots
    with steerable wheel systems is longer, as these must drive forward/backward to
    steer.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 实现转向（称为转向半径）或对于具有可转向轮系统的机器人所需的距离更长，因为这些必须向前/向后行驶以转向。
- en: You require one large motor for the fixed axle, as you cannot distribute power
    across two motors, or you need complex mechanisms to balance the input. If the
    mechanism does not center after steering, then the robot veers.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个大型电机用于固定轴，因为你不能在两个电机之间分配动力，或者你需要复杂的机构来平衡输入。如果机构在转向后没有居中，那么机器人就会偏离方向。
- en: Fixed wheels
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 固定轮子
- en: 'Fixed-wheel steering is used frequently in robots, whereby the wheels'' axes
    are fixed in relation to the chassis. The relative speed of each wheel or set
    of wheels sets the direction of the robot. That is, the wheels do not turn from
    side to side; however, by one side going faster than the other, the robot can
    make turns. A typical use of this is known as skid steering, which is illustrated
    in the following screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 固定转向轮在机器人中经常使用，其中车轮的轴线相对于底盘是固定的。每个车轮或一组车轮的相对速度决定了机器人的方向。也就是说，车轮不会从一侧转向另一侧；然而，通过一侧比另一侧更快，机器人可以转弯。这种典型用途被称为滑移转向，如下面的截图所示：
- en: '![Figure 7.4 – Fixed-wheel steering or skid steering'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4 – 固定转向轮或滑移转向'
- en: '](img/B15660_07_04.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15660_07_04.jpg)'
- en: Figure 7.4 – Fixed-wheel steering or skid steering
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 固定转向轮或滑移转向
- en: '*Figure 7.4* shows this in action. The white arrows show the relative speed
    of the motors. The green arrows show the direction of the robot.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.4* 展示了这一动作。白色箭头显示了电机的相对速度。绿色箭头显示了机器人的方向。'
- en: 'In the preceding figure, we can see the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到以下内容：
- en: The motors are going at the same speed, so the robot is driving straight forward.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电机以相同的速度运行，因此机器人正在直线前进。
- en: The motors on the right are going fast; the motors on the left are going slow.
    This robot is driving forward and left.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右侧的电机转速快；左侧的电机转速慢。这个机器人正在向前和向左行驶。
- en: This has several advantages. If you intend to use tank tracks, you need this
    type of drive system. It is mechanically simple in that a drive motor per wheel
    is all that is needed to make turns. Skid steering allows a robot to turn on the
    spot, doing a full 360 degrees in a turning circle the width of the widest/longest
    part of the robot.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这有几个优点。如果你打算使用坦克履带，你需要这种驱动系统。它在机械上很简单，因为每个车轮只需要一个驱动电机就可以转弯。滑移转向允许机器人原地转弯，在机器人最宽/最长部分的宽度内完成360度的转弯。
- en: There are some disadvantages to using this. When turning, a skid-steer system
    may drag wheels sideways, causing friction. Also, any minor differences in the
    motors, their gearing, or the controller output can result in a veer.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法有一些缺点。当转向时，滑移转向系统可能会将车轮向侧面拖动，造成摩擦。此外，电机、它们的齿轮或控制器输出的任何微小差异都可能导致偏航。
- en: Other steering systems
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他转向系统
- en: 'The controller we are using on our robot allows us to control four motor channels.
    A builder can use four motors for special wheel types, known as Mecanum wheels.
    These wheels allow skid-steering style motions along with crabbing motions so
    that a robot can drive left or right without turning. Technically, this is still
    fixed-wheel steering. *Figure 7.5* here shows a base with Mecanum wheels:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在机器人上使用的控制器允许我们控制四个电机通道。建造者可以使用四个电机来驱动特殊类型的轮子，称为麦轮。这些轮子允许滑移转向风格的运动以及蟹行运动，从而使机器人可以不转弯地左右行驶。从技术上讲，这仍然是固定转向轮。本图7.5中展示了带有麦轮的底盘：
- en: '![Figure 7.5 – Mecanum wheels on the Uranus Pod by Gwpcmu [CC BY 3.0'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 – 由Gwpcmu提供的Uranus Pod上的麦轮 [CC BY 3.0'
- en: (https://creativecommons.org/licenses/by/3.0)]
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: (https://creativecommons.org/licenses/by/3.0)]
- en: '](img/B15660_07_05.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15660_07_05.jpg)'
- en: Figure 7.5 – Mecanum wheels on the Uranus Pod by Gwpcmu [CC BY 3.0 (https://creativecommons.org/licenses/by/3.0)]
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 由Gwpcmu提供的Uranus Pod上的麦轮 [CC BY 3.0 (https://creativecommons.org/licenses/by/3.0)]
- en: These are amazingly flexible but mechanically complex, high maintenance, heavy,
    and a bit pricier than normal wheels. They are fun, however.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些轮子非常灵活，但机械结构复杂，维护成本高，重量大，而且比普通轮子贵一些。然而，它们很有趣。
- en: Steering the robot we are building
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制我们正在构建的机器人转向
- en: Based on the three-wheel chassis we have chosen, with one castor wheel and then
    a driven wheel on each side, independently controlled, we are using skid steering.
    By varying the speed and direction of these wheels, we steer our robot. We can
    also spin 360 degrees with it. The castor wheel negates the problem mentioned
    with the drag seen on four- and six-wheel skid-steer robots.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们选择的三个轮子底盘，其中有一个万向轮和每侧一个驱动轮，独立控制，我们正在使用滑移转向。通过改变这些轮子的速度和方向，我们控制我们的机器人。我们还可以用它旋转360度。万向轮抵消了在四轮和六轮滑移转向机器人上看到的拖动问题。
- en: 'We can make the robot spin on the spot with one change to the previous code.
    Making one motor go back while the other goes forward spins the robot. Let''s
    see how to do this, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过对之前的代码进行一次更改，使机器人原地旋转。让一个电机后退而另一个电机前进会使机器人旋转。让我们看看如何做到这一点，如下所示：
- en: 'Find the following lines in `test_motors.py`:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `test_motors.py` 文件中找到以下行：
- en: '[PRE11]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Modify this as follows so that one motor goes `BACKWARD`:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式修改，以便一个电机向`BACKWARD`方向行驶：
- en: '[PRE12]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Run this on the Pi with `python3 turn_motors.py`, and your robot now spins to
    the right. Swap them so left (`lm`) is `BACKWARD`, and right (`rm`) is `FORWARD`,
    and it spins the other way.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`python3 turn_motors.py`在Pi上运行此代码，现在你的机器人会向右旋转。交换它们，使左（`lm`）为`BACKWARD`，右（`rm`）为`FORWARD`，它会向相反方向旋转。
- en: 'What about less aggressive turns? In the previous code, before the direction
    lines, we also set the speed of each motor, as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于不那么剧烈的转向，在前面的代码中，在方向行之前，我们也设置了每个电机的速度，如下所示：
- en: '[PRE13]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: lm.setSpeed(100)
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: lm.setSpeed(100)
- en: rm.setSpeed(150)
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: rm.setSpeed(150)
- en: lm.run(Raspi_MotorHAT.FORWARD)
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: lm.run(Raspi_MotorHAT.FORWARD)
- en: rm.run(Raspi_MotorHAT.FORWARD)
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: rm.run(Raspi_MotorHAT.FORWARD)
- en: '[PRE14]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You've now seen a few ways to steer robots. Based on the design our robot has,
    you've then put one of them into practice, making a robot spin on the spot, and
    also drive forward and turn too. In the next section, we'll turn this into a layer
    for different behaviors to use the robot.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了几种控制机器人的方法。基于我们机器人的设计，你已经将其中之一付诸实践，使机器人原地旋转，并且也能向前行驶和转向。在下一节中，我们将将其转化为不同行为可以使用机器人的层。
- en: Making a Robot object – code for our experiments to talk to the robot
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建机器人对象 – 我们实验中与机器人通信的代码
- en: Now we have seen how to move and turn our robot, we come on to a layer of software
    to group up some of the hardware functions and isolate them from **behaviors**.
    By behaviors, I mean code to make a robot behave a certain way, for example following
    a line or avoiding walls. Why would we want that isolation?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何移动和转向我们的机器人，接下来我们将转向软件层，将一些硬件功能组合起来并将它们从**行为**中隔离出来。通过行为，我指的是使机器人以某种方式行为的代码，例如跟随线条或避开墙壁。我们为什么想要这种隔离？
- en: When we chose our motor controller, we made many trade-offs to find what works
    for our project. Motor controllers can change when the considerations change or
    when we simply want to build our next robot. Although controlling the speed and
    direction of two motors is the same kind of operation, each controller does it
    slightly differently. Creating a layer in front of a controller lets us use the
    same commands for it, even if it changes. This layer acts as a façade or interface
    to robot functionality.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们选择电机控制器时，我们做出了许多权衡，以找到适合我们项目的方案。当考虑因素改变或我们只是想要构建我们的下一个机器人时，电机控制器可能会改变。虽然控制两个电机的速度和方向是同一种操作，但每个控制器都以略微不同的方式执行。在控制器前面创建一个层让我们可以使用相同的命令，即使它发生了变化。这个层充当机器人功能的门面或接口。
- en: Each controller has quirks. With this one, we set a run mode and speed. Many
    controllers use 0 to mean stop, but this one uses a `RELEASE` mode, which is slightly
    different from speed 0, which holds the motors. Controllers often use negative
    numbers to mean go backward; this one has a `BACKWARD` mode. The speed values
    on this controller go from 0-255\. Some go from -128-128, or 0-10\. What we can
    do is to create an object with an interface to hide quirks specific to this controller.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每个控制器都有其特点。在这个控制器中，我们设置了一个运行模式和速度。许多控制器使用0表示停止，但这个控制器使用`RELEASE`模式，这与速度0略有不同，速度0会保持电机运行。控制器通常使用负数表示向后行驶；这个控制器有一个`BACKWARD`模式。这个控制器上的速度值从0到255。有些从-128到128，或从0到10。我们可以做的是创建一个具有接口的对象，以隐藏这个控制器特有的怪癖。
- en: Why make this object?
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么创建这个对象？
- en: 'You design an interface to give you a way to interact with some other code.
    It can simplify, or make more consistent, different underlying systems to make
    them behave the same way, as with all the types of motor controller mentioned.
    It also provides a way to cleanly separate parts of code into layers. Different
    layers mean that you can change one part of some code without it making considerable
    changes in another, as illustrated in the following figure:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你设计一个接口，以便你可以与其他代码进行交互。它可以简化或使不同的底层系统更加一致，使它们以相同的方式表现，就像所有提到的电机控制器类型一样。它还提供了一种将代码的不同部分干净地分离成层的方法。不同的层意味着你可以更改代码的一部分，而不会对另一部分造成重大变化，如下面的图所示：
- en: '![Figure 7.6 – Software layers'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.6 – 软件层](img/B15660_07_06.jpg)'
- en: '](img/B15660_07_06.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.6 – 软件层](img/B15660_07_06.jpg)'
- en: Figure 7.6 – Software layers
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 软件层
- en: In *Figure 7.6*, panel 1 shows a block of code that has different systems mixed.
    It's hard to change; adding a new behavior or swapping the motor controller in
    this code would be quite tricky. It's good to avoid mixing responsibilities in
    this way.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图7.6*中，面板1展示了一块代码，其中混合了不同的系统。这很难更改；在这个代码中添加新的行为或交换电机控制器会相当棘手。避免以这种方式混合责任是明智的。
- en: The code represented by panel 2 shows two separate systems interacting. They
    have a relationship where the *path-following behavior* is in control of the *robot
    hardware setup and control* code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块 2 表示两个独立系统之间的交互。它们之间存在一种关系，其中 *路径跟踪行为* 控制着 *机器人硬件设置和控制* 代码。
- en: Throughout the book we write many behaviors, and we can reuse the hardware control
    library, perhaps extending it occasionally. After all, who wants to keep writing
    the same code? When you extend and make new behaviors, you can use this layer
    again too.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们编写了许多行为，我们可以重用硬件控制库，偶尔扩展它。毕竟，谁愿意一遍又一遍地写相同的代码？当你扩展并创建新的行为时，你还可以再次使用这一层。
- en: The robot hardware setup/control block in the second panel of *Figure 7.6* is
    our `Robot` object. It is an interface to hide the quirks of the *Full Function
    Stepper HAT* board.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7.6* 的第二面板中的机器人硬件设置/控制块是我们的 `Robot` 对象。它是隐藏 *全功能步进 HAT* 板怪癖的接口。'
- en: This standard interface means we could make an object that looks the same from
    the outside on other robots, and our behaviors still work. Some serious robot
    builders use interfaces to swap real controllers for simulations of robots, to
    test complex behaviors.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标准接口意味着我们可以在其他机器人上创建一个外观相同的对象，并且我们的行为仍然有效。一些严肃的机器人构建者使用接口来交换真实控制器和机器人模拟，以测试复杂的行为。
- en: What do we put in the robot object?
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们在机器人对象中放什么？
- en: An object is a building block to make interfaces in Python. Objects have methods—things
    we can call on it to perform tasks. Objects also have members, bits of data, or
    references to other objects.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是 Python 中创建接口的构建块。对象有方法——我们可以调用它来执行任务。对象还有成员，即数据片段或对其他对象的引用。
- en: 'The next section builds code in the `Robot` object to do the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将在 `Robot` 对象中构建代码，以执行以下操作：
- en: 'Set up the Motor HAT and store its motors as members: `left_motor` and `right_motor`.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Motor HAT 并将其电机存储为成员：`left_motor` 和 `right_motor`。
- en: Deal with the `exit` state.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 `exit` 状态。
- en: Stop motors with a `stop_motors` method.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `stop_motors` 方法停止电机。
- en: Let us use percentages to mean speeds—values of 0 to 100\. We map this to what
    the controller wants.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们用百分比来表示速度——值为 0 到 100。我们将此映射到控制器想要的值。
- en: The modes are particular to this controller. Our interface uses negative values
    to mean going backward.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式是特定于这个控制器的。我们的接口使用负值表示向后移动。
- en: At a later stage, the `Robot` object can act as a gatekeeper to data buses that
    require code to hold exclusive locks on them and some of the hardware.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在稍后的阶段，`Robot` 对象可以充当数据总线的守门人，这些总线需要代码对其执行独占锁，以及一些硬件。
- en: Our interface (and therefore our object) does not contain behavior, other than
    the stopping-on-exit safeguard.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的接口（因此我们的对象）不包含行为，除了退出时停止的保护措施。
- en: 'We put it in a file named `robot.py`, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其放入一个名为 `robot.py` 的文件中，如下所示：
- en: '[PRE15]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This `class` has a `__init__` method, a special one that sets this layer up.
    The `__init__` method stores the output of the `getMotor` methods from the `Raspi_MotorHat`
    library in the `left_motor` and `right_motor` members. This method also registers
    a stop system. I have added some comments to state what the fragments of code
    do.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `class` 有一个 `__init__` 方法，这是一个特殊的方法，用于设置这一层。`__init__` 方法将 `Raspi_MotorHat`
    库中 `getMotor` 方法的输出存储在 `left_motor` 和 `right_motor` 成员中。此方法还注册了一个停止系统。我添加了一些注释来说明代码片段的功能。
- en: So far, our `Robot` object has set up our Motor HAT and has a way to stop the
    motors. The code is the same setup code we have seen before but is structured
    slightly differently.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的 `Robot` 对象已经设置了我们的 Motor HAT，并且有一种停止电机的方法。代码与之前看到的设置代码相同，但结构略有不同。
- en: 'We can test this in another file named `behavior_line.py`, as illustrated in
    the following code snippet:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在另一个名为 `behavior_line.py` 的文件中测试这一点，如下代码片段所示：
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This starts by pulling in the `robot.py` file we just created with an import.
    It goes forward for 1 second and stops. Run with `python3 behavior_line.py`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这首先通过导入我们刚刚创建的 `robot.py` 文件开始。它向前移动 1 秒然后停止。使用 `python3 behavior_line.py` 运行。
- en: 'We still have to set speeds specific to this board (not out of 100). Let''s
    fix that in `robot.py` (new code is in bold), as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然必须设置特定于该板的特定速度（不是 100）。让我们在 `robot.py` 中修复这个问题（新代码用粗体表示），如下所示：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can now use `convert_speed`, to use speeds from 0 to 100\. This returns speeds
    from 0 to 255 for this Motor HAT. For other motor boards, this returns something
    else.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用 `convert_speed` 来使用 0 到 100 的速度。这对于这个 Motor HAT 返回 0 到 255 的速度。对于其他电机板，它返回其他值。
- en: We multiply the speed by 255 and divide that by 100\. This formula is a way
    of turning a percentage into a fraction of 255\. We multiply first because we
    are doing integer (whole number) math, and dividing 80/100 with whole numbers
    gives 0, but dividing (80*255) by 100 returns 204\.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将速度乘以255，然后除以100。这个公式是将百分比转换为255的分数的一种方法。我们首先乘以，因为我们正在进行整数（整数）数学，用整数除以80/100会得到0，但用(80*255)除以100会得到204。
- en: 'This code is still unwieldy, though—to use it, we need the following in `behavior_line.py`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这段代码仍然难以处理——要使用它，我们需要在`behavior_line.py`中包含以下内容：
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This still uses the `run` and `setSpeed` methods of the `Raspi_MotorHAT` library,
    which are specific to this control board. Other boards don't work the same way.
    We can also collect up the cumbersome conversion a little.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然使用了`Raspi_MotorHAT`库的`run`和`setSpeed`方法，这些方法仅适用于这块控制板。其他板子的工作方式不同。我们还可以稍微简化一下繁琐的转换。
- en: We start by modifying the `convert_speed` method. It can be convenient for robots
    to use negative values to mean the motor goes backward. We still need to scale
    the speed, but we need to determine the run mode too.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先修改`convert_speed`方法。对于机器人来说，使用负值表示电机向后运行可能很方便。我们仍然需要缩放速度，但还需要确定运行模式。
- en: 'We need to do the following two things:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做以下两件事：
- en: Determine if the speed is above, below, or equal to zero, and set the mode for
    the `run` function.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定速度是高于、低于还是等于零，并为`run`函数设置模式。
- en: Remove the sign from the speed for `setSpeed`, so it's always a positive value.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`setSpeed`中移除速度的符号，使其始终为正值。
- en: The default mode that we get at speed zero is `RELEASE` or stop. If the speed
    is above 0, we return the `FORWARD` mode, and if it's below 0, we return `BACKWARD`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在速度为零时，我们得到的默认模式是`RELEASE`或停止。如果速度高于0，我们返回`FORWARD`模式，如果速度低于0，我们返回`BACKWARD`模式。
- en: 'We can use a simple `if` statement to get the correct `mode`. Let''s replace
    the `convert_speed` method in the class to return the mode and positive value.
    I''ve used comments to show the two sections to this function. Modify this in
    `robot.py`, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用简单的`if`语句来获取正确的`mode`。让我们将类中的`convert_speed`方法替换为返回模式和正值。我已经使用注释来显示这个函数的两个部分。在`robot.py`中修改如下：
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We''ve added one more operation to our speed calculation: `abs(speed)`. This
    operation returns the absolute value, which removes the sign from a number. For
    example, -80 and 80 both come out as 80, which means there is always a positive
    output from the method.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在速度计算中添加了一个额外的操作：`abs(speed)`。这个操作返回绝对值，从数字中移除了符号。例如，-80和80都会得到80，这意味着该方法始终有一个正输出。
- en: Next, we add some methods to directly set the speed and direction of the left
    and right motors in the robot. These call `convert_speed` and use the mode and
    output speed from it to make calls to the `Raspi_MotorHAT` functions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加了一些方法，可以直接设置机器人左右电机的速度和方向。这些方法调用`convert_speed`，并使用从中获得的模式和输出速度来调用`Raspi_MotorHAT`函数。
- en: 'We then need to change our motor movement methods to use this speed conversion,
    as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要更改我们的电机移动方法，以使用这种速度转换，如下所示：
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So, for each motor, we get the mode and output speed from the passed-in speed,
    then call `setSpeed` and `run`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于每个电机，我们从传入的速度中获取模式和输出速度，然后调用`setSpeed`和`run`。
- en: 'The whole of `robot.py` should now look like the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的整个`robot.py`应该看起来如下：
- en: '[PRE21]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Our simple behavior in `behavior_line.py` is now only a few lines, as can be
    seen in the following code snippet:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`behavior_line.py`中的简单行为现在只有几行，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This simplification means we can build on this code to create more behaviors.
    I have a common interface, and versions of the `Robot` object for my other robots.
    An exciting outcome is I can run this `behavior_lines.py` code on ArmBot (the
    robot seen at the end of [*Chapter 1*](B15660_01_Final_ASB_ePub.xhtml#_idTextAnchor019),
    *Introduction to Robotics*) or my other Raspberry Pi robots. They all go forward
    for 1 second at 80% of their motor speed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简化意味着我们可以在此基础上构建更多行为。我有一个通用接口，以及为我的其他机器人创建的`Robot`对象版本。一个令人兴奋的结果是，我可以在ArmBot（见[*第1章*](B15660_01_Final_ASB_ePub.xhtml#_idTextAnchor019)，*机器人简介*)或我的其他Raspberry
    Pi机器人上运行这个`behavior_lines.py`代码。它们都以80%的电机速度向前行驶1秒。
- en: Writing a script to follow a predetermined path
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写脚本以跟随预定路径
- en: 'So, we now get to the first behavior that feels like a robot. Let''s make a
    quick sketch of a path for us to get our robot to follow. For an example, see
    *Figure 7.7* here:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在得到了第一个感觉像机器人的行为。让我们快速绘制一条路径草图，以便我们的机器人能够跟随。例如，请参见这里的*图7.7*：
- en: '![Figure 7.7 – Path for our robot'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.7 – 我们机器人的路径'
- en: '](img/B15660_07_07.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15660_07_07.jpg)'
- en: Figure 7.7 – Path for our robot
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 我们机器人的路径
- en: In *Figure 7.7*, I've drawn a path. The straight lines are for driving forward;
    the **1**s mean 1 second. We don't yet have a way to consider distance traveled,
    only time. We may be able to guess at times relative to distances, but this isn't
    very precise or repeatable. The gentle curves are a turn where we slow one motor
    down more than the other.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 7.7* 中，我绘制了一条路径。直线是用于前进的；**1** 表示 1 秒。我们还没有考虑行驶距离的方法，只有时间。我们可能能够根据距离猜测时间，但这不是非常精确或可重复的。温柔的曲线是转弯，我们减慢一个电机的速度比另一个电机更多。
- en: The final spiral means a victory spin on the spot when the path is complete—we
    can do this by putting one motor in reverse while the other drives forward.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的螺旋意味着当路径完成时在原地胜利旋转——我们可以通过将一个电机反转而另一个电机前进来实现这一点。
- en: 'Let''s write this code. First, we want the imports: `sleep` and `robot`. But
    before we do anything, let''s make some helper functions for this behavior. I
    called my file `behavior_path.py`, and the code is shown in the following snippet:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写这段代码。首先，我们需要导入 `sleep` 和 `robot`。但在我们做任何事情之前，让我们为这种行为创建一些辅助函数。我把我的文件命名为
    `behavior_path.py`，代码如下所示：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The helpers use the same language we used to describe the behavior. We have
    `straight`, `turn_left`, `turn_right`, and `spin_left`. These are not in the `Robot`
    object because other behaviors may use more continuous behavior than this. I've
    called the `Robot` object `bot` now because one-letter variable names such as
    `r` become less easy to find, read, or reason about when there is more code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助器使用我们用来描述行为的相同语言。我们有 `straight`、`turn_left`、`turn_right` 和 `spin_left`。这些不是在
    `Robot` 对象中，因为其他行为可能需要比这更连续的行为。我现在把 `Robot` 对象称为 `bot`，因为当代码量增加时，像 `r` 这样的单字母变量名变得不那么容易找到、阅读或推理。
- en: 'These helpers each set the motor speeds, and then sleep for a determined number
    of seconds. We can then create the `Robot` object and sequence them by adding
    the following code to `behavior_path.py`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这些辅助器分别设置电机速度，然后睡眠一定数量的秒数。然后我们可以创建 `Robot` 对象，并通过向 `behavior_path.py` 添加以下代码来对它们进行排序：
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we can upload this to the Raspberry Pi, and run it via PuTTY with the
    following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将其上传到 Raspberry Pi，并通过 PuTTY 运行，如下所示：
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, if your robot is anything like mine, you saw it drive and make turns,
    but the turns have overshot in some way, and the robot may be veering to one side.
    We can fix the overshoot here by reducing the amount of time in the turn steps,
    like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你的机器人像我的一样，你看到它行驶并转弯，但转弯以某种方式超出了范围，机器人可能向一侧偏航。我们可以通过减少转弯步骤中的时间来解决这个问题，如下所示：
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You need to tweak these values to get close to 90-degree turns. This tweaking
    takes patience: change them and upload them. Tweaking values in code is a crude
    form of calibration to match the quirks of our robot. If you move between surfaces
    (for example, from a wooden floor to a carpet), then the timings will change.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要调整这些值以接近 90 度的转弯。这种调整需要耐心：更改它们并上传。在代码中调整值是一种粗略的校准形式，以匹配我们机器人的特性。如果你在表面之间移动（例如，从木地板到地毯），那么时间将发生变化。
- en: 'You may be able to account for some of the veering by tuning one motor to be
    slower in the `straight` function (adjust for your own robot''s veer), like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能能够通过调整一个电机在 `straight` 函数中的速度（根据你自己的机器人偏航进行调整）来解释一些偏航，如下所示：
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code holds up for a while but may be hard to fine-tune. Why do we get this
    veer?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以维持一段时间，但可能难以微调。为什么我们会得到这种偏航？
- en: Motor speeds can vary, even those from the same manufacturer. Other causes of
    minor variations are wheel diameters, axle positioning, weight distribution, slippery
    or uneven surfaces, wiring resistance, and motor controller variations. This variation
    makes it unlikely that you'd get a perfectly straight line from a robot this way.
    Depending on which sensors we are using, this may or may not be a problem. To
    account for this problem, we introduce encoders/speed sensors in a later chapter
    and calibrate those sensors to get a more accurate version of a path behavior.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 电机速度可能不同，即使是同一制造商的产品。其他引起微小变化的原因包括轮径、轴位置、重量分布、光滑或不平的表面、导线电阻和电机控制器变化。这种变化使得从这种方式获得一条完美的直线变得不太可能。根据我们使用哪些传感器，这可能是问题，也可能不是问题。为了解决这个问题，我们在后面的章节中引入编码器/速度传感器，并校准这些传感器以获得更精确的路径行为版本。
- en: Without sensors, a robot is not able to determine where it is or if it has bumped
    into anything. If the robot ran into a wall, you'd probably have to go and move
    it to where it had room to move.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 没有传感器，机器人无法确定自己的位置或是否撞到了任何东西。如果机器人撞到了墙，你可能需要去移动它，让它有足够的空间移动。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've learned how to install the libraries for the motor board
    and demonstrate that our motors work. We then started building the first layer
    of code for our behaviors to use, while noting how we could make a layer like
    that for other robots. We saw our robot move in a path and tuned it, while finding
    out some of the shortcomings of using motors without any sensors.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何安装电机板的库并演示我们的电机是否工作。然后我们开始构建用于我们行为的第一层代码，同时注意我们如何为其他机器人构建类似层次。我们看到了我们的机器人沿着路径移动，并对其进行了调整，同时发现了使用无传感器的电机的一些不足。
- en: 'You can now use this when starting any hardware project: get the motors/output
    devices tested first, then create a layer for a behavior to use them, such that
    if their hardware later changes, you only need to change the motor code.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在开始任何硬件项目时，你可以使用这个方法：首先测试电机/输出设备，然后创建一个用于行为的层，以便如果它们的硬件以后发生变化，你只需要更改电机代码。
- en: In the following chapters, we start adding sensors and building behaviors using
    these sensors.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们开始添加传感器并使用这些传感器构建行为。
- en: Exercises
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Try these further ideas to enhance your learning from this chapter:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下想法来增强你对本章内容的理解：
- en: Sketch out another simple path and write code for the robot to follow it. For
    example, try to follow a figure-of-8 shape using your experience.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制另一条简单的路径，并为机器人编写代码以跟随它。例如，尝试使用你的经验跟随一个8字形。
- en: Which methods would you add to the `Robot` object if you had an additional output
    to control, perhaps a single **light-emitting diode** (**LED**)?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你有额外的输出要控制，你会向`Robot`对象添加哪些方法？也许是一个单独的**发光二极管**（**LED**）？
- en: Consider how you would lay out a `Robot` object for a robot with kart-style
    steering. Which methods would it have? You don't need to write the code yet, but
    having an interface in mind is a good start. Hint—it probably has one motor speed
    for the drive and a motor position for the steering.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑如何为具有卡丁车式转向的机器人布局`Robot`对象。它会有哪些方法？你不需要立即编写代码，但有一个接口的想法是一个良好的开始。提示——它可能有一个用于驱动的电机速度和一个用于转向的电机位置。
- en: Further reading
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Please refer to the following for more information:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下内容以获取更多信息：
- en: For more information on the style used for the `Robot` object, along with the
    use of similar interfaces and classes, I recommend *Learning Object-Oriented Programming*,
    *Gastón C. Hillar*, *Packt Publishing*. This book not only works through these
    concepts in Python but takes them more generally and shows how **object-oriented**
    (**OO**) concepts also apply to the C# and JavaScript languages.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`Robot`对象使用的样式以及类似接口和类的使用，我推荐阅读*面向对象编程学习指南*，作者*加斯顿·希尔*，*Packt Publishing*。这本书不仅通过Python解释了这些概念，而且更广泛地展示了**面向对象**（**OO**）概念也适用于C#和JavaScript语言。
