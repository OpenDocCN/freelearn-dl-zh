- en: '*Chapter 9*: Programming RGB Strips in Python'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**第9章**：在Python中编程RGB灯带'
- en: LED lights can be used with a robot to debug and give it feedback so that the
    code running on the robot can show its state. Colored RGB LEDs let you mix the
    red, green, and blue components of light to make many colors, adding brightness
    and color to a robot. We have not paid much attention to making it look fun, so
    this time we will focus on that.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: LED灯光可以与机器人一起使用，用于调试和提供反馈，以便机器人上运行的代码可以显示其状态。彩色RGB LED允许你混合光的红色、绿色和蓝色成分，以制作多种颜色，为机器人增添亮度和色彩。我们之前并没有过多关注使其看起来有趣，所以这次我们将专注于这一点。
- en: Mixing different sequences of LEDs can be used to convey information in real
    time. You can use which are on/off, their brightness, or their color to represent
    information. This feedback is easier to read than a stream of text, which will
    help as sensors are added to the robot. This also means the code on the robot
    can show state without relying on the SSH terminal to do so.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过混合不同的LED序列，可以实时传达信息。你可以使用它们的开关状态、亮度或颜色来表示信息。这种反馈比文本流更容易阅读，这有助于在机器人上添加传感器时。这也意味着机器人上的代码可以显示状态，而无需依赖SSH终端来完成。
- en: 'In this chapter, we will learn the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: What is an RGB strip?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是RGB灯带？
- en: Comparing light strip technologies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较灯带技术
- en: Attaching the light strip to the Raspberry Pi
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将灯带连接到Raspberry Pi
- en: Making a robot display a code object
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让机器人显示代码对象
- en: Using the light strip for debugging the avoid behavior
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用灯带调试避障行为
- en: Making a rainbow display with LEDs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LED制作彩虹显示
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To build this you will need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建这个项目，你需要以下材料：
- en: A computer with internet access and Wi-Fi
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台可以访问互联网并连接Wi-Fi的电脑
- en: The robot, a Raspberry Pi, and the code from the previous chapter
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人、Raspberry Pi和上一章的代码
- en: The Pimoroni LED SHIM
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pimoroni LED SHIM
- en: The code for this chapter is on GitHub at [https://github.com/PacktPublishing/Learn-Robotics-Fundamentals-of-Robotics-Programming-Second-Edition/blob/master/chapter9](https://github.com/PacktPublishing/Learn-Robotics-Fundamentals-of-Robotics-Programming-Second-Edition/blob/master/chapter9).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在GitHub上找到：[https://github.com/PacktPublishing/Learn-Robotics-Fundamentals-of-Robotics-Programming-Second-Edition/blob/master/chapter9](https://github.com/PacktPublishing/Learn-Robotics-Fundamentals-of-Robotics-Programming-Second-Edition/blob/master/chapter9)。
- en: 'Check out the video at the following link to see the Code in Action: [https://bit.ly/39vglXm](https://bit.ly/39vglXm).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接中的视频，以查看代码的实际应用：[https://bit.ly/39vglXm](https://bit.ly/39vglXm)。
- en: What is an RGB strip?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是RGB灯带？
- en: Using lights to display data can be a simple yet flexible way to get data to
    the user without connecting a full display. For example, a single light could
    be turned on or off to indicate whether a robot is powered on or the state of
    a simple sensor. A multicolor light can change color to show more detail, to indicate
    a few different states that the robot is in. RGB in this chapter stands for Red-Green-Blue,
    so by controlling the intensity levels of these color channels in a light, multiple
    colors can be shown. We'll investigate how this happens later in the *RGB values*
    section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用灯光显示数据可以是一种简单而灵活的方式，将数据传递给用户，而无需连接完整的显示屏。例如，单个灯光可以打开或关闭，以指示机器人是否已开启或简单传感器的状态。多彩灯光可以改变颜色以显示更多细节，指示机器人处于几种不同的状态。在本章中，RGB代表红-绿-蓝，因此通过控制灯光中这些颜色通道的强度级别，可以显示多种颜色。我们将在“RGB值”部分稍后探讨这是如何发生的。
- en: Adding multiple lights lets you show more data. These can be in a strip (a line
    of lights), as well as panels/matrixes, rings, and other interesting shapes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 添加多个灯光可以显示更多数据。这些可以是灯带（一排灯光）、面板/矩阵、环形以及其他有趣的形状。
- en: Comparing light strip technologies
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较灯带技术
- en: There are many competing technologies for lights and light strips. For light
    types, incandescent lights, such as old light bulbs, tend to use a lot of power
    and take up too much space to be useful in robots. Fluorescent lights, such as
    kitchen strips or curly compact types, need complex power systems that also take
    up too much space. Electroluminescent wire, also known as EL wire, is often used
    to decorate objects by outlining them; it looks interesting but is tricky to control.
    **Light Emitting Diode** (**LED**) technology is low power and tends to be small
    and easy to control, which makes it best suited for robots such as ours. LEDs
    are also cheap.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于灯光和灯带，存在许多竞争技术。对于灯的类型，如旧灯泡这样的白炽灯，往往消耗大量电力，占用太多空间，在机器人中不实用。荧光灯，如厨房灯带或卷曲紧凑型灯，需要复杂的电源系统，也占用太多空间。电致发光线，也称为EL线，通常用于装饰物体，通过轮廓来装饰；它看起来很有趣，但控制起来很棘手。**发光二极管**（**LED**）技术功耗低，通常体积小，易于控制，这使得它非常适合我们这样的机器人。LED也很便宜。
- en: The most useful kind, in our case, which we will use in this chapter, are addressable
    RGB LEDs. Addressable means that each individual LED in the strip can be set to
    different colors and brightness, allowing a sequence of colors along the strip.
    To keep it simple, we will use a type with a built-in controller.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这个案例中，最有用的一种，我们将在本章中使用，是可寻址RGB LED。可寻址意味着条带中的每个单独的LED都可以设置为不同的颜色和亮度，从而在条带上形成颜色序列。为了简化，我们将使用一种内置控制器的类型。
- en: '*Figure 9.1* shows some of the types of addressable RGB LED configurations
    I have experimented with:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.1* 展示了我实验过的几种可寻址RGB LED配置类型：'
- en: '![](img/B15660_09_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_09_01.jpg)'
- en: Figure 9.1 – Types of addressable RGB LEDs
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 可寻址RGB LED的类型
- en: All of these LED controllers take a stream of data. Some types, such as the
    Neopixel, WS2812, SK9822, APA102C, DotStar, and 2801 types, take the red, green,
    and blue components that they need, and then pass the remaining data to the next
    LED. Designers arrange these LEDs into strips, rings, or square matrixes, chaining
    them to take advantage of how they pass the data along. The LED strips can come
    as rigid sticks or as flexible strips on a reel. For our robot, eight or more
    LEDs make for a great display.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些LED控制器都接收一系列数据。一些类型，如Neopixel、WS2812、SK9822、APA102C、DotStar和2801类型，取它们需要的红、绿、蓝组件，然后将剩余的数据传递给下一个LED。设计师将这些LED排列成条带、环形或方形矩阵，将它们串联起来以利用它们传递数据的方式。LED灯带可以是刚性棒或卷轴上的柔性条带。对于我们的机器人来说，8个或更多的LED就能构成一个很好的显示屏。
- en: There are also some completely different technologies, such as the LED SHIM
    from Pimoroni and LED matrices in color using shift registers. The Pimoroni LED
    SHIM is one of the easiest to use (with a Raspberry Pi) of the LED strips. It
    houses a controller (the IS31FL3731), which is controlled over the I2C data bus.
    The Pimoroni LED SHIM has 24 LEDs, which is more than enough to cater to our needs.
    It doesn't need any extra power handling and is also widely available.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些完全不同的技术，例如Pimoroni的LED SHIM和彩色LED矩阵，使用移位寄存器。Pimoroni LED SHIM是LED灯带中最容易使用的一种（与Raspberry
    Pi一起使用）。它包含一个控制器（IS31FL3731），通过I2C数据总线进行控制。Pimoroni LED SHIM有24个LED，这已经足够满足我们的需求。它不需要额外的电源处理，并且也广泛可用。
- en: Our robot uses the I2C data bus for the motor controller, which happily shares
    with other devices, such as the LED SHIM, by having a different address. I2C instructions
    are sent as an address for the device, followed by an I2C register to write and
    a value for it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们机器人使用I2C数据总线来控制电机，它通过拥有不同的地址，愉快地与其他设备共享，例如LED SHIM。I2C指令以设备地址发送，后面跟着一个要写入的I2C寄存器和它的值。
- en: Because of its simplicity and compatibility with our robot, I will continue
    this chapter with the Pimoroni LED SHIM. This can be bought from Mouser Electronics
    in most countries, along with Pimoroni, Adafruit, and SparkFun.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其简单性和与我们的机器人的兼容性，我将继续本章，使用Pimoroni LED SHIM。这种产品在大多数国家都可以从Mouser Electronics、Pimoroni、Adafruit和SparkFun购买。
- en: RGB values
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RGB值
- en: 'The colors red, green, and blue can mix to make almost any color combination.
    Systems express these as RGB values. RGB is the same principle used by most, if
    not all, color display screens you see. TVs, mobile phones, and computer screens
    use this. Multicolor LEDs use the same principle to produce many colors. Code
    usually specifies the amounts of each color to mix as three-number components,
    as shown in the following diagram:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 红色、绿色和蓝色可以混合成几乎任何颜色组合。系统用RGB值来表示这些颜色。RGB是您看到的几乎所有（如果不是所有）彩色显示屏所使用的相同原理。电视、移动电话和计算机屏幕都使用这个。多色LED使用相同的原理来产生多种颜色。代码通常指定混合每种颜色的数量，如下面的图所示：
- en: '![](img/B15660_09_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_09_02.jpg)'
- en: Figure 9.2 – The RGB color space [SharkD / CC BY-SA (https://creativecommons.org/licenses/by-sa/3.0)]
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – RGB颜色空间 [SharkD / CC BY-SA (https://creativecommons.org/licenses/by-sa/3.0)]
- en: The diagram in *Figure 9.2* shows an RGB color cube. It has arrows showing axes
    for increasing each of the red, green, and blue components. The exposed surfaces
    of the cube show different shades and intensities as the color combinations mix
    throughout the cube.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.2*中的图显示了RGB颜色立方体。它有箭头显示增加红色、绿色和蓝色各成分的轴。立方体的暴露表面显示了颜色组合在立方体内混合时的不同色调和强度。'
- en: The corner to the bottom-front-right is blue, the top-front-right is turquoise
    (mixing blue and green), the bottom-front-left is purple (mixing red and blue),
    the bottom-far-left is red (with no green or blue), and the top-far-left is yellow
    (high red and green, no blue).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 底部前右角是蓝色，顶部前右角是青色（混合蓝色和绿色），底部前左角是紫色（混合红色和蓝色），底部远左角是红色（没有绿色或蓝色），顶部远左角是黄色（高红色和绿色，没有蓝色）。
- en: As each value is increased, we get different colors from them being mixed. The
    top-front-left corner would be the maximum of all three – white. The bottom-rear-right
    corner would be the minimum of all three – black. The cutout shows a color with
    intensities as fractions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 随着每个值的增加，我们通过混合得到不同的颜色。顶部前左角将是三个中的最大值——白色。底部后右角将是三个中的最小值——黑色。裁剪图显示了以分数表示的强度颜色。
- en: In our code, we will use numbers ranging from 0 for absolutely turned off to
    255 for full intensity, with values in between for many levels of intensity. The
    colors are mixed by adding, so adding all of them at full brightness makes white.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们将使用从0（完全关闭）到255（全强度）的数字，中间的值表示许多级别的强度。颜色通过相加混合，所以将所有颜色在全亮度下相加得到白色。
- en: Although this theoretically gives many colors, in practice, the differences
    between the intensity of 250 and 255 are not discernible on most RGB LEDs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然理论上这可以提供许多颜色，但在实践中，250和255之间的强度差异在大多数RGB LED上是不可辨别的。
- en: You have seen some of the LED technologies and a little information about how
    to mix colors for them. We have also made a decision about which technology to
    use, the Pimoroni LED SHIM. Since we'll be attaching this to our robot, please
    buy one and come back for the next section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了一些LED技术以及如何混合它们颜色的信息。我们还决定使用哪种技术，即Pimoroni LED SHIM。由于我们将将其连接到我们的机器人上，请购买一个并在下一节回来。
- en: Attaching the light strip to the Raspberry Pi
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将灯条连接到Raspberry Pi
- en: 'Before we write code to display color sequences on the LED SHIM, we need to
    attach it to the Raspberry Pi on our robot. After we have finished this section,
    the robot block diagram will look as in *Figure 9.3*:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写代码在LED SHIM上显示颜色序列之前，我们需要将其连接到我们机器人上的Raspberry Pi。完成本节后，机器人框图将看起来像*图9.3*：
- en: '![](img/B15660_09_03.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_09_03.jpg)'
- en: Figure 9.3 – The robot block diagram with the LED strip
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 带有LED灯条的机器人框图
- en: The block diagram now shows the LED strip connected to the Raspberry Pi, with
    an arrow indicating information flow from the Raspberry Pi to the strip. The strip
    is highlighted as a new addition to the system. Let's see how this works.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的框图显示了LED灯条连接到Raspberry Pi，其中有一个箭头指示从Raspberry Pi到灯条的信息流。灯条被突出显示为系统的新增部分。让我们看看它是如何工作的。
- en: Attaching the LED strip to the robot
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将LED灯条连接到机器人
- en: 'The Pimoroni LED SHIM attaches quite readily to the Raspberry Pi. We put it
    on top of the motor controller, with its pass-through header, so that we can see
    the lights on top. Take a look at *Figure 9.4* to see how:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Pimoroni LED SHIM很容易连接到Raspberry Pi。我们将其放在电机控制器上，带有其旁路引脚，这样我们就可以看到顶部的灯光。看看*图9.4*看看如何：
- en: '![](img/B15660_09_04.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_09_04.jpg)'
- en: Figure 9.4 – Fitting the LEDs
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 安装LED
- en: 'Use *Figure 9.4* with the following steps to attach the strip:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤用*图9.4*来安装条带：
- en: The strip is small. Line the strip up with the header pins coming from the top
    of the motor HAT. You will need to unplug the wires already plugged into the Raspberry
    Pi to add the SHIM.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 条带很小。将条带与从电机HAT顶部来的排针对齐。你需要拔掉已经插入Raspberry Pi的线来添加SHIM。
- en: The wider part should be sticking out from the HAT. Gently push the SHIM onto
    the pins, only a little at first, working across the strip until all the pins
    are in the holes – it is slightly stiff but should grip on.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 较宽的部分应该从HAT上突出出来。轻轻地将SHIM推到引脚上，一开始只推一点，沿着条带工作，直到所有引脚都进入孔中——它稍微有点硬，但应该能抓牢。
- en: Once all the pins are in, evenly push the SHIM down so that the pins mostly
    stick out.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有引脚都插入，均匀地按下SHIM，使引脚大部分突出。
- en: Now, you'll need to replace the wires. Refer to *Figure 8.15* in [*Chapter 8*](B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150),
    *Programming Distance Sensors with Python*, for the distance sensor wiring information.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你需要更换电线。请参考[*第8章*](B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150)中的*图8.15*，*使用Python编程距离传感器*，以获取距离传感器的接线信息。
- en: Now that you've attached the LED SHIM, this robot is ready to light up. Let's
    program it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经连接了LED SHIM，这个机器人就准备好发光了。让我们来编程它。
- en: Making a robot display the code object
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使机器人显示代码对象
- en: Although we are building around the Pimoroni LED SHIM, we've already seen that
    there are other types of RGB LED systems. Since we might later swap the SHIM out
    for a different system, it would be a good idea to make an interface on top of
    the LEDs. Like the motor's interface, this decouples handling hardware and making
    behaviors.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们是在围绕Pimoroni LED SHIM构建，但我们已经看到还有其他类型的RGB LED系统。由于我们可能稍后会用不同的系统替换SHIM，因此在LEDs上制作一个接口是个好主意。就像电机的接口一样，这可以解耦硬件处理和行为制作。
- en: Making an LED interface
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建LED接口
- en: So, what interface do we want for the LEDs? First, we want them to be available
    on the robot as `robot.leds`. We want to clear the LEDs (turn them all off), set
    each individual LED to a different color, and set a bunch/range of LEDs to a list
    of colors.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们希望LEDs具有什么样的接口呢？首先，我们希望它们在机器上作为`robot.leds`可用。我们希望清除LEDs（将它们全部关闭），将每个单独的LED设置为不同的颜色，并将一组/范围的LED设置为颜色列表。
- en: It's useful for the code to tell us how many LEDs we have, so if the number
    changes, the animations or displays still make some sense.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 代码告诉我们有多少LEDs很有用，所以如果数量发生变化，动画或显示仍然有意义。
- en: For the colors, we use three values – `r`, `g`, and `b` – to represent the red,
    green, and blue components. Python has a type called a `color` as a parameter,
    this is a tuple of `(r, g, b)`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于颜色，我们使用三个值——`r`、`g`和`b`——来表示红色、绿色和蓝色成分。Python有一个名为`color`的类型作为参数，这是一个`(r,
    g, b)`的元组。
- en: The LEDs in strips are addressable, so our code uses an LED number starting
    at `0`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 条带上的LED是可寻址的，因此我们的代码使用从`0`开始的LED编号。
- en: 'So, as a structure, our code starts with `robot.leds`. `leds` will be a member
    of the existing `robot` class. It is an object with these members:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从结构上讲，我们的代码从`robot.leds`开始。`leds`将是现有`robot`类的一个成员。它是一个具有以下成员的对象：
- en: '`set_one(led_number, color)`: This sets one LED at `led_number` to the specified
    color.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_one(led_number, color)`: 这将`led_number`处的单个LED设置为指定的颜色。'
- en: '`set_range(led_range, color)`: This sets all the LEDs defined by a Python iterable
    `led_range` to `color`. A Python iterable can be a list of LED numbers [`0`, `3`],
    or it can be a range made using the `range` function. For example, `range(2,8)`
    creates the list `[2, 3, 4, 5, 6, 7]`.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_range(led_range, color)`: 这将Python可迭代对象`led_range`定义的所有LED设置为`color`。Python可迭代对象可以是LED编号列表`[0,
    3]`，或者可以使用`range`函数创建的范围。例如，`range(2,8)`创建列表`[2, 3, 4, 5, 6, 7]`。'
- en: '`set_all(color)`: This sets all of the LEDs to the color.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_all(color)`: 这将所有LED设置为指定的颜色。'
- en: '`clear()`: This clears all of the LEDs to black, turning them all off.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 这会将所有LED清除为黑色，将它们全部关闭。'
- en: '`show()`: All of the other methods prepare a display, allowing you to set combinations
    of LEDs. Nothing is updated on the LED device until your code calls this. This
    method reflects how most LED strips expect to set all the LEDs from one stream
    of data.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show()`: 所有其他方法都准备了一个显示，允许你设置LED的组合。直到你的代码调用此方法之前，LED设备上不会更新任何内容。此方法反映了大多数LED条带期望从一个数据流中设置所有LED的方式。'
- en: '`count`: This holds the number of LEDs in the strip.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`: 这保存了条带中LED的数量。'
- en: 'Keeping the preceding points in mind, let''s write this code for the LED SHIM:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 记住前面的要点，让我们为LED SHIM编写这段代码：
- en: 'First, we need to install the LED SHIM library. So, on the Raspberry Pi, type
    the following:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要安装LED SHIM库。因此，在Raspberry Pi上，输入以下内容：
- en: '[PRE0]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our code must start by importing this and setting up the device. Put the following
    code in `leds_led_shim.py` (named after the device type):'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的代码必须首先导入此设置并设置设备。将以下代码放入`leds_led_shim.py`（以设备类型命名）：
- en: '[PRE1]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we create the methods to interact with the strip. Setting a single LED
    is fairly straightforward:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建与条带交互的方法。设置单个LED相当直接：
- en: '[PRE2]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Setting a bunch of LEDs is also a simple wrapper in our code:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置多个LEDs在我们的代码中也是一个简单的包装器：
- en: '[PRE3]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We also want a way to set all of the LEDs. This code is similar to setting
    a single LED:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望有一种方法来设置所有的LEDs。此代码与设置单个LED的代码类似：
- en: '[PRE4]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s add a method for clearing the LEDs:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个清除LEDs的方法：
- en: '[PRE5]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we need the `show` code, to send the colors we''ve configured to the
    LEDs. The Pimoroni LED SHIM library has made this very simple:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要`show`代码，将我们配置的颜色发送到LEDs。Pimoroni LED SHIM库使得这个过程非常简单：
- en: '[PRE6]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have installed the LED SHIM library and created an interface for ourselves.
    We can use this interface to communicate with the LEDs, and it is designed to
    be swapped out for compatible code for a different type of LED device. Now, we'll
    make this LED interface available in our `Robot` object.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经安装了LED SHIM库，并为我们自己创建了一个接口。我们可以使用这个接口与LEDs通信，并且它被设计成可以替换为不同类型LED设备的兼容代码。现在，我们将这个LED接口在我们的`Robot`对象中可用。
- en: Adding LEDs to the Robot object
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将LEDs添加到Robot对象中
- en: 'Next, we update our `robot.py` file to deal with an LED system. For this, we
    do the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们更新我们的`robot.py`文件以处理LED系统。为此，我们执行以下操作：
- en: 'Start by adding the `leds_led_shim` file to the imports (the new code is in
    bold):'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将`leds_led_shim`文件添加到导入中（新的代码用粗体表示）：
- en: '[PRE7]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we add an instance of the SHIM to the constructor (`init`) method for
    `Robot` (the new code is in bold):'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在`Robot`的构造函数（`init`）方法中添加SHIM的一个实例（新的代码用粗体表示）：
- en: '[PRE8]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As we have to stop more than just the motors, we''ll swap `stop_motors` for
    a new `stop_all` method in the `atexit` call to stop other devices (such as the
    LEDs) too:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们需要停止的不仅仅是电机，我们将在`atexit`调用中将`stop_motors`替换为新的`stop_all`方法，以停止其他设备（如LEDs）：
- en: '[PRE9]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create the `stop_all` method, which stops the motors and clears the LEDs:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`stop_all`方法，该方法停止电机并清除LEDs：
- en: '[PRE10]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Important note
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: The complete code can be found at [https://github.com/PacktPublishing/Learn-Robotics-Fundamentals-of-Robotics-Programming-Second-Edition/blob/master/chapter9](https://github.com/PacktPublishing/Learn-Robotics-Fundamentals-of-Robotics-Programming-Second-Edition/blob/master/chapter9).
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整的代码可以在[https://github.com/PacktPublishing/Learn-Robotics-Fundamentals-of-Robotics-Programming-Second-Edition/blob/master/chapter9](https://github.com/PacktPublishing/Learn-Robotics-Fundamentals-of-Robotics-Programming-Second-Edition/blob/master/chapter9)找到。
- en: We have now added support for the LEDs to the `Robot` class, making the interface
    we designed earlier available, and ensuring that the LEDs are cleared when the
    robot code exits. Next, we will start testing and turning on LEDs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已将LED支持添加到`Robot`类中，使之前设计的接口可用，并确保在机器人代码退出时清除LEDs。接下来，我们将开始测试和打开LEDs。
- en: Testing one LED
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试一个LED
- en: We have installed some hardware, along with a library for it, and then added
    code to make this available in our robot. However, before we go further, we should
    make sure that everything works with a test. This is a good place to find any
    problems and troubleshoot them.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经安装了一些硬件及其库，并添加了代码以使这些内容在我们的机器人中可用。然而，在我们继续之前，我们应该确保一切都能通过测试正常工作。这是一个找到任何问题并进行故障排除的好地方。
- en: 'Let''s try testing a single LED. One aspect of our robot running Python that
    we''ve not explored is that it can run the Python **REPL** – **read, eval, print
    loop**. What that means is you can start Python and immediately type code to run
    there. We''ll use this to test our LEDs a little:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试测试一个单个LED。我们还没有探索的一个关于我们的机器人运行Python的方面是它可以运行Python **REPL** – **读取、评估、打印循环**。这意味着你可以启动Python并立即输入要运行的代码。我们将使用这个来测试我们的LEDs：
- en: Copy the `leds_led_shim.py` and `robot.py` code onto the Raspberry Pi.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`leds_led_shim.py`和`robot.py`代码复制到Raspberry Pi上。
- en: 'SSH into the robot, and just type `python3`. The Raspberry Pi should respond
    like this:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过SSH连接到机器人，并输入`python3`。Raspberry Pi应该这样响应：
- en: '[PRE11]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s get our `robot` library ready to use. Type the parts shown in bold:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们准备好我们的`robot`库以便使用。输入以下粗体显示的部分：
- en: '[PRE12]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, try turning on an LED, setting it to red:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试打开一个LED，将其设置为红色：
- en: '[PRE13]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Hmm – nothing happened. Remember, we need to call `leds.show` to display our
    setting on them:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 嗯 – 没有发生任何事情。记住，我们需要调用`leds.show`来显示我们的设置：
- en: '[PRE14]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You should now see a single red LED.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你现在应该看到一个红色的LED。
- en: 'Let''s try and set another to purple by mixing red and blue LEDs:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试将另一种颜色设置为紫色，通过混合红色和蓝色LED：
- en: '[PRE15]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To stop this session, press *Ctrl* +*D* on an empty line. The `atexit` code
    automatically turns all the LEDs off.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要停止此会话，请在空行上按 *Ctrl* +*D*。`atexit` 代码会自动关闭所有LED。
- en: You should now have seen an LED working and lighting up in multiple colors.
    This demonstrates that the code so far is good. If not, please refer to the following
    section. If this is all working, skip on ahead to the *Testing all LEDs* section.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该已经看到LED工作并点亮成多种颜色。这表明到目前为止的代码是好的。如果不是，请参阅以下部分。如果一切正常，请跳到 *测试所有LED* 部分。
- en: Troubleshooting
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障排除
- en: If you encounter problems trying to light the LEDs, there are some troubleshooting
    steps you can take.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在尝试点亮LED时遇到问题，可以采取一些故障排除步骤。
- en: 'If running the code shows errors, do the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行代码出现错误，请执行以下操作：
- en: Check that you have enabled I2C (as shown in [*Chapter 7*](B15660_07_Final_ASB_ePub.xhtml#_idTextAnchor131),
    *Drive and Turn – Moving Motors with Python*).
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认你已经启用了I2C（如[*第7章*](B15660_07_Final_ASB_ePub.xhtml#_idTextAnchor131)，*驱动和转向
    – 使用Python移动电机*所示）。
- en: Use `sudo i2cdetect -y 1`, as seen in [*Chapter 7*](B15660_07_Final_ASB_ePub.xhtml#_idTextAnchor131),
    *Drive and Turn – Moving Motors with Python*. You should see the LEDs at the address
    `74`.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `sudo i2cdetect -y 1`，如[*第7章*](B15660_07_Final_ASB_ePub.xhtml#_idTextAnchor131)，*驱动和转向
    – 使用Python移动电机*所示。你应该看到地址为 `74` 的LED。
- en: Check that you have installed the `ledshim` Python package with `pip3`.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认你已经使用 `pip3` 安装了 `ledshim` Python包。
- en: Carefully check the code for mistakes and errors. If it's the code from GitHub,
    create an issue!
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细检查代码中的错误和错误。如果是GitHub上的代码，请创建一个问题！
- en: 'If the LEDs do not light at all, do the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果LED根本不亮，请执行以下操作：
- en: Try running the example code that comes with the SHIM at [https://github.com/pimoroni/led-shim/tree/master/examples](https://github.com/pimoroni/led-shim/tree/master/examples).
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试运行SHIM附带示例代码，[https://github.com/pimoroni/led-shim/tree/master/examples](https://github.com/pimoroni/led-shim/tree/master/examples)。
- en: Ensure you have installed the LEDs the correct way around, as shown in *Figure
    9.4*.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你已按照 *图9.4* 所示正确安装LED。
- en: Ensure you have evenly pushed the LED strip down onto the header pins.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你已均匀地将LED条推到引脚上。
- en: Did you remember to use `leds.show()`?
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你记得使用 `leds.show()` 吗？
- en: By following these troubleshooting tips, you will have eliminated the most common
    issues with this system. You should now have a working LED and be able to proceed
    to the next section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些故障排除提示，你将消除这个系统中最常见的问题。你现在应该有一个工作的LED，并且能够进入下一节。
- en: Testing all LEDs
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 测试所有LED
- en: 'Now, we can try the `set_all` method. We''ll make something that simply flashes
    a couple of different colors on the LEDs. Create a file called `leds_test.py`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以尝试使用 `set_all` 方法。我们将制作一些简单的在LED上闪烁几种不同颜色的东西。创建一个名为 `leds_test.py` 的文件：
- en: 'First, we need imports. We need to import our `R``obot` library and `time`
    to animate this:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要导入。我们需要导入我们的 `R` 库和 `time` 来动画化：
- en: '[PRE16]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let''s set up our bot, along with a couple of named colors:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们设置我们的机器人，以及一些命名颜色：
- en: '[PRE17]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The next part is the main loop. It alternates between the two colors, with
    `sleep`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个部分是主循环。它交替两种颜色，使用 `sleep`：
- en: '[PRE18]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When you have uploaded these files to the Raspberry Pi, type the following
    to show the red/blue alternating LED display:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你将这些文件上传到Raspberry Pi后，输入以下命令以显示红/蓝交替LED显示：
- en: '[PRE19]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Press *Ctrl* + *C* on the terminal to stop this running.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中按 *Ctrl* + *C* 停止运行。
- en: We have now shown all the LEDs working. This has also shown them switching between
    different colors, using timing to produce a very simple animation. We can build
    on this, producing more interesting uses of color and animation, but first, we
    will divert to learn a bit more about mixing colors.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经展示了所有LED都在工作。这也展示了它们在不同颜色之间切换，使用时间产生一个非常简单的动画。我们可以在此基础上构建，产生更多有趣的颜色和动画应用，但首先，我们将转向学习更多关于混合颜色的知识。
- en: Making a rainbow display with the LEDs
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LED制作彩虹显示
- en: Now we get to use these for some fun. We will extend our avoiding behavior from
    the previous chapter to show rainbow bar graphs on a side corresponding to the
    distances read. We could also use this for sensors. Before we can link the movement
    to the animation, how is a rainbow created?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以用这些做一些有趣的事情。我们将扩展上一章中的避障行为，以显示对应于读取距离的彩虹条形图。我们也可以用这个来传感。在我们将运动与动画链接之前，彩虹是如何形成的？
- en: Colour systems
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 颜色系统
- en: RGB is how the hardware expects colors. However, RGB is less convenient for
    expressing intermediate colors or creating gradients between them. Colors that
    appear close to the eye can be a little far apart when in RGB. Because of this,
    there are other color systems.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: RGB是硬件期望的颜色。然而，RGB在表达中间颜色或创建它们之间的渐变时不太方便。在视觉上看起来接近的颜色在RGB中可能有点远。正因为如此，还有其他颜色系统。
- en: The other color system we use is **Hue, Saturation, and Value** (**HSV**). We
    use HSV in this chapter to make rainbow-type displays and when doing computer
    vision in a later chapter to assist our code in detecting objects.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的另一种颜色系统是**色调、饱和度和亮度**（**HSV**）。在本章中，我们使用HSV来制作彩虹型显示，并在后续章节中进行计算机视觉时，帮助我们的代码检测对象。
- en: Hue
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 色调
- en: 'Imagine taking the colors of the spectrum and placing them on a circle, blending
    through red to orange, orange to yellow, yellow to green, green to blue, blue
    to purple, and back around to red. The **hue** expresses a point around this circle.
    It does not affect the brightness of the color or how vivid it is. *Figure 9.5*
    shows how we can represent these points on a color wheel:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 想象将光谱的颜色放置在一个圆圈上，从红色到橙色，橙色到黄色，黄色到绿色，绿色到蓝色，蓝色到紫色，然后回到红色。**色调**表示这个圆圈上的一个点。它不影响颜色的亮度或其鲜艳程度。*图9.5*展示了我们如何在色轮上表示这些点：
- en: '![](img/B15660_09_05.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15660_09_05.png)'
- en: Figure 9.5 – A color wheel of hues
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 色调色轮
- en: In *Figure 9.5*, the circle shows that around 0 degrees, a red hue is seen.
    The compass points around the circle correspond to different colors. Colors are
    blended as you move around from one hue to another. You may have seen something
    like this in a color wheel gadget on a painting or drawing computer program. A
    continuous wheel setup like this is what lets us make a rainbow.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9.5*中，圆圈显示在0度左右，可以看到红色色调。圆圈上的罗盘指针对应不同的颜色。当你从一个色调移动到另一个色调时，颜色会混合。你可能在一个绘画或绘图计算机程序的颜色轮装置中见过类似的东西。这种连续的轮状设置让我们能够制作彩虹。
- en: Saturation
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 饱和度
- en: If you take a color such as red, it can be a grayish/dull red or a vivid, intense
    red. **Saturation** is an expression of the vividness of the color. As you go
    toward zero, it only makes shades of gray. As we increase the saturation, color
    begins to emerge – first in pastel tones, through to poster colors, and then to
    a striking hazard sign or pure colors at the high end of the saturation scale.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择一种颜色，比如红色，它可以是一种灰暗的/暗淡的红色，或者是一种鲜艳、强烈的红色。**饱和度**是颜色鲜艳程度的表达。当你接近零时，它只产生灰色调。当我们增加饱和度时，颜色开始出现——首先是淡色调，然后是海报色，然后是高饱和度尺度上的醒目的危险标志或纯色。
- en: Value
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 亮度
- en: The **value** of the color is its brightness. It ranges from black at 0, through
    to a very dark version of the color, to a very bright color. Note that this does
    not approach white (in other words, pink colors), but a very bright red. To make
    a white color, you need to reduce the saturation too. Other color systems (such
    as HSL) specify a *light* component that would make things white this way.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色的**亮度**是其亮度。它从0的黑色，通过到颜色的非常暗的版本，到一个非常亮的颜色。请注意，这并不接近白色（换句话说，粉红色），而是一个非常亮的红色。要制作白色，你还需要降低饱和度。其他颜色系统（如HSL）指定一个*光*成分，这样可以使事物变得白色。
- en: Converting HSV to RGB
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将HSV转换为RGB
- en: There are complicated formulas to convert between one color system to another.
    However, Python can make this conversion itself.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个颜色系统转换到另一个颜色系统之间有复杂的公式。然而，Python可以自己完成这种转换。
- en: We will use `colorsys.hsv_to_rgb` to make this conversion. It accepts the three
    HSV components as fractions between 0 and 1, inclusive.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`colorsys.hsv_to_rgb`来完成这种转换。它接受三个HSV成分作为介于0和1之间的分数，包括1。
- en: In the case of the hue component, 0 is the start of the circle, 0.5 represents
    180 degrees, the half circle, and 1 is all the way around to 360, the full circle.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在色调成分的情况下，0是圆圈的起点，0.5代表180度，半圆，而1是完全绕回到360度，即整个圆圈。
- en: The saturation component at 0 is gray, fully desaturated, and 1 is the most
    intense color.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 饱和度成分在0时为灰色，完全未饱和，而在1时为最鲜艳的颜色。
- en: The value component at 0 is black, fully dark, and at 1 is the brightest – a
    fully lit color.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 亮度成分在0时为黑色，完全黑暗，而在1时是最亮的——一个完全发光的颜色。
- en: 'To make a bright cyan color, we would go past the half circle to about 0.6
    for hue, 1.0 for saturation, and 1.0 for value:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要制作明亮的青色，我们需要将色调移动到大约0.6的位置，饱和度为1.0，亮度也为1.0：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: However, this is not enough. The output from the `colorsys` call is a tuple,
    a collection of three items for the R, G, and B components.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这还不够。`colorsys`调用的输出是一个元组，包含三个项目，用于R、G和B组件。
- en: 'The output components are in terms of 0 to 1.0, too. Most RGB systems expect
    values between 0 and 255\. To use them, we need to convert these values back up
    by multiplying them:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 输出组件也是以0到1.0为单位的。大多数RGB系统期望值在0到255之间。为了使用它们，我们需要通过乘以它们将这些值转换回来：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding line, we loop over each component, `c`, and multiply it by
    255\. By putting a `for` loop in square brackets like that in Python, we can loop
    over elements, and put the result back into a list.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行中，我们遍历每个组件`c`，并将其乘以255。通过在Python中用方括号将`for`循环放在那里，我们可以遍历元素，并将结果放回列表中。
- en: Now that you know how to convert HSV values to RGB, let's use this information
    to make a rainbow.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何将HSV值转换为RGB值，让我们使用这些信息来制作彩虹。
- en: Making a rainbow on the LEDs
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在LED上制作彩虹
- en: 'We can use our color system understanding to make a rainbow on the LEDs:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用我们对颜色系统的理解，在LED上制作彩虹：
- en: '![](img/B15660_09_06.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15660_09_06.jpg)'
- en: Figure 9.6 – LEDs showing a rainbow on the robot
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 机器人上显示彩虹的LED
- en: '*Figure 9.6* shows a rainbow being displayed on the LEDs attached to the robot.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.6*显示了在机器人上连接的LED上显示的彩虹。'
- en: 'Let''s make this! Make a new file called `led_rainbow.py`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！创建一个名为`led_rainbow.py`的新文件：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s go over this file line by line:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析这个文件：
- en: This code starts by importing `colorsys`.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码首先导入`colorsys`。
- en: We define a function, `show_rainbow`, which takes two parameters, a link to
    our LEDs system (which would usually be given `robot.leds`) and an LED range to
    set.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了一个函数`show_rainbow`，它接受两个参数，一个指向我们的LED系统（这通常会被赋予`robot.leds`）和一个要设置的LED范围。
- en: Because we want to know the length of our LED range, we need to make sure it
    is a list, so we cast this on the first line of our function.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为我们想知道我们的LED范围长度，所以我们需要确保它是一个列表，因此我们在函数的第一行进行了转换。
- en: For a rainbow, the hue value should sweep a full circle. In Python, `colorsys`
    is the values from 0 to 1\. We want to advance the hue a fraction of a step for
    each LED in the range. By dividing 1.0 by the number of LEDs in a range, we get
    this fraction.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于彩虹，色调值应该扫过一个完整的圆圈。在Python中，`colorsys`提供的是0到1的值。我们希望为范围中的每个LED前进一个分数步。通过将1.0除以范围中的LED数量，我们得到这个分数。
- en: We then loop over the LEDs. `enumerate` gives us an index while `led_address`
    advances. This code makes no assumptions about the range so that it could use
    an arbitrary list of LEDs.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们遍历LED。`enumerate`给我们一个索引，而`led_address`递增。这段代码对范围没有做出任何假设，因此它可以使用任意LED列表。
- en: We then multiply `hue_step` and `index` to give the `hue` value, the right fraction
    of 1.0 to use. The following line converts this into an RGB value with a fixed
    saturation and brightness value.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们将`hue_step`和`index`相乘以给出`hue`值，这是使用1.0的正确分数。下一行将这个值转换为具有固定饱和度和亮度值的RGB值。
- en: 'Because `colorsys` outputs values between 0 and 1, the code needs to multiply
    this by 255 and make the resulting number into an integer: `rgb = [int(c*255)
    for c in rgb]`.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于`colorsys`输出介于0和1之间的值，代码需要将这个值乘以255，并将结果数字转换为整数：`rgb = [int(c*255) for c in
    rgb]`。
- en: The code uses the `leds.set_one` method with this RGB value and the LED address.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码使用`leds.set_one`方法与这个RGB值和LED地址一起使用。
- en: 'Let''s test this with a file called `test_rainbow.py`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用名为`test_rainbow.py`的文件来测试这个：
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is quite similar to our previous red/blue test. However, in the first section,
    we use the `show_rainbow` function, which the code has imported from `led_rainbow`.
    It passed in the robot's LEDs and makes a range covering all of them.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的之前的红蓝测试非常相似。然而，在第一部分，我们使用了`show_rainbow`函数，该函数是从`led_rainbow`模块导入的。它传递了机器人的LED，并创建了一个覆盖所有LED的范围。
- en: The code waits for half a second and then clears the LEDs for half a second.
    These are in a loop to make an on/off rainbow effect. Start this with `python3
    test_rainbow.py`, and use *Ctrl* + *C* to stop it after seeing it work.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 代码等待半秒钟，然后清除LED半秒钟。这些都在循环中，以产生开/关彩虹效果。用`python3 test_rainbow.py`启动它，并在看到它工作后使用*Ctrl*
    + *C*停止它。
- en: Now that you've seen some simple animation and multicolor LED usage, we can
    take this to the next level by making the LEDs respond to sensors.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了一些简单的动画和多色LED的使用，我们可以通过让LED对传感器做出反应来将这个提升到下一个层次。
- en: Using the light strip for debugging the avoid behavior
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用灯带调试避障行为
- en: LEDs in rainbows are fun, and switching colors looks nice. However, LEDs can
    be used for practical purposes too. In [*Chapter 8*](B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150),
    *Programming Distance Sensors with Python*, we added sensors to our robot to avoid
    obstacles. You can follow along in a PuTTY window, and see what the sensors are
    detecting by reading the numbers. But we can do better; with the light strip,
    we can put information on the robot to tell us what it is detecting.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 彩虹中的LED很有趣，颜色切换看起来也很漂亮。然而，LED也可以用于实际目的。在[*第8章*](B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150)，“使用Python编程距离传感器”中，我们向我们的机器人添加了传感器以避免障碍物。你可以在PuTTY窗口中跟随操作，通过读取数字来查看传感器正在检测什么。但我们可以做得更好；有了灯光条，我们可以在机器人上放置信息，告诉我们它正在检测什么。
- en: In this section, we will tie the LED output together to values from a behavior,
    first by basic lighting, and then by making some rainbow colors, too.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将LED输出与行为值关联起来，首先是通过基本照明，然后是通过制作一些彩虹颜色。
- en: Adding basic LEDs to the avoid behavior
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将基本LED添加到避免行为中
- en: Before we get fancy and reintroduce the rainbow, let's start with the basic
    version. The intent here will be to make two *indicator* bars to the left and
    right side of the LED bar. For each bar, more LEDs will light when the corresponding
    distance sensor detects a closer obstacle. We'll make it so that the bars go into
    the middle, so when a single outer LED is lit, the obstacle is far away. When
    most or all of the LEDs on one side are lit, the obstacle is much closer.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们变得花哨并重新引入彩虹之前，让我们先从基本版本开始。这里的意图是制作两个位于LED条左右两侧的*指示*条。对于每条条，当相应的距离传感器检测到更近的障碍物时，更多的LED将被点亮。我们将使这些条进入中间，这样当单个外部的LED被点亮时，障碍物就远离。当一侧的大多数或所有LED都被点亮时，障碍物就非常接近。
- en: 'We need to add a few parts to our avoid behavior:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向我们的避免行为添加一些部分：
- en: Some variables to set up the LED display, and how our distances map to it
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些用于设置LED显示的变量，以及我们的距离如何映射到它
- en: A way to convert a distance in to how many LEDs to show
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种将距离转换为要显示的LED数量的方法
- en: A method to display the state of our sensors on the LEDs using the preceding
    items
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用前面提到的项目在LED上显示我们传感器状态的方法
- en: To call the `display_state` method from the behavior's main loop
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从行为的主循环中调用`display_state`方法
- en: 'Let''s see how to incorporate the preceding points. Open the `avoid_behavior.py`
    file that you made in [*Chapter 8*](B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150),
    *Programming Distance Sensors with Python*, and follow along:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何结合前面的要点。打开你在[*第8章*](B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150)，“使用Python编程距离传感器”中制作的`avoid_behavior.py`文件，并跟随操作：
- en: 'Before we can use the LEDs in this behavior, we need to separate them into
    the bars. In the `__init__` method of `ObstacleAvoidingBehavior`, add the following:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以在这种行为中使用LED之前，我们需要将它们分开成条。在`ObstacleAvoidingBehavior`的`__init__`方法中添加以下内容：
- en: '[PRE24]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we need a color for the LEDs when sensing. I chose red. I encourage you
    to try another:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要为感应时的LED选择一种颜色。我选择了红色。我鼓励你尝试另一种颜色：
- en: '[PRE25]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With the variables'' setup out of the way, let''s add a method for converting
    the distance into LEDs. I added this after the `__init__` method:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置好变量之后，让我们添加一个将距离转换为LED的方法。我在`__init__`方法之后添加了这个方法：
- en: '[PRE26]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The distances are in terms of meters, with 1.0 being 1 meter, so subtracting
    the distance from 1.0 inverts this. The `max` function will return the largest
    of the two values, here it is used to ensure we don''t go below zero:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 距离是以米为单位的，1.0代表1米，所以从1.0减去距离会反转这个值。`max`函数将返回两个值中的较大值，在这里它被用来确保我们不会低于零：
- en: '[PRE27]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we multiply this number, some fraction between 0 and 1, by the `self.led_half`
    value to get the number of LEDs to use. We round it up and turn this into an integer
    with `int(round())`, as we can only have a whole number of LEDs turned on. Rounding
    means that after our multiplication, if we end up with a value such as 3.8, we
    round it up to 4.0, then convert it into an integer to light four LEDs. We add
    1 to this so that there''s always at least one LED, and then return it:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将这个数字乘以0到1之间的某个分数，乘以`self.led_half`的值，以得到要使用的LED数量。我们将其向上取整，并用`int(round())`将其转换为整数，因为我们只能打开整数的LED。向上取整意味着在我们的乘法之后，如果我们得到一个如3.8这样的值，我们将它向上取整到4.0，然后将其转换为整数以点亮四个LED。我们给这个数加1，这样至少总有一个LED被点亮，然后返回它：
- en: '[PRE28]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The next method is a trickier one; it will create the two bars. Let''s start
    by declaring the method and clearing the LEDs:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个方法是一个更复杂的方法；它将创建两个条。让我们首先声明该方法并清除LED：
- en: '[PRE29]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For the left bar, we convert the left sensor distance to the number of LEDs,
    then create a range covering 0 to this number. It uses the `set_range` method
    to set a bunch of LEDs to `sense_color`. Note that your LEDs might be the other
    way around, in which case swap `left_distance` and `right_distance` in this `display`
    method:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于左侧条形，我们将左侧传感器的距离转换为LED数量，然后创建一个从0到这个数量的范围。它使用`set_range`方法将一组LED设置为`sense_color`。请注意，你的LED可能方向相反，在这种情况下，在这个`display`方法中交换`left_distance`和`right_distance`：
- en: '[PRE30]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The right side is trickier; after converting to an LED count, we need to create
    a range for the LEDs. The variable `led_bar` holds the number of LEDs to light.
    To light the right of the bar, we need to subtract this from the count of the
    LEDs to find the first LED, and create a range starting there to the total length.
    We must subtract 1 from the length – otherwise it will count 1 LED too far:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右侧稍微复杂一些；在转换为LED数量后，我们需要为LED创建一个范围。变量`led_bar`保存要点亮的LED数量。为了点亮条形的右侧，我们需要从这个LED数量中减去，以找到第一个LED，并从那里创建一个到总长度的范围。我们必须从长度中减去1
    – 否则它将多计算1个LED：
- en: '[PRE31]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we want to show the display we''ve now made:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想要展示我们现在制作的显示：
- en: '[PRE32]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We then display our readings on the LEDs by calling `display_state` inside
    the behavior''s `run` method. Here are a couple of lines for context, with the
    extra line highlighted:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在行为中的`run`方法内部调用`display_state`来在LED上显示我们的读数。这里有一些上下文中的几行，其中额外的一行被突出显示：
- en: '[PRE33]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Save this, send it to the Raspberry Pi, and run it. When it's running, you should
    be able to see the LEDs light up in a bar based on the distance. This is both
    satisfying and gives a good feel for what the robot is detecting. Let's make this
    a little more interesting by adding rainbows.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此代码，将其发送到Raspberry Pi并运行。当它在运行时，你应该能够看到LED根据距离点亮成条形。这既令人满意，也很好地感受到了机器人正在检测的内容。让我们通过添加彩虹让它更有趣。
- en: Adding rainbows
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加彩虹
- en: 'We can use our LED rainbow to make our distance-sensing demo even more fun:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的LED彩虹灯来让我们的距离感应演示变得更加有趣：
- en: '![](img/B15660_09_07.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_09_07.jpg)'
- en: Figure 9.7 – Distance sensor rainbow bars
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 距离传感器彩虹条
- en: '*Figure 9.7* shows a photo of the rainbow bars for each distance sensor. This
    is a great visual demonstration of the LEDs animating.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.7*显示了每个距离传感器的彩虹条的照片。这是一个很好的LED动画视觉演示。'
- en: 'Since we added a library for showing rainbows, we can reuse it here. Let''s
    see how to do it:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们添加了一个用于显示彩虹的库，我们可以在这里重用它。让我们看看如何做：
- en: Open up the `avoid_behaviour.py` code from the previous section.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开上一节中的`avoid_behaviour.py`代码。
- en: 'At the top, import `led_rainbow` so that we can use it:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部，导入`led_rainbow`以便我们可以使用它：
- en: '[PRE34]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Our existing code displayed a bar for the left. Instead of a bar, display a
    rainbow here. We need to ensure we have at least one item:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现有的代码显示了左侧的条形。在这里，我们不需要条形，而是显示一个彩虹。我们需要确保至少有一个项目：
- en: '[PRE35]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once again, the right side will be a little bit trickier; as we want the rainbow
    to go the other way, we need to make the range count backward for the rainbow
    too. The Python `range` function, along with the `start` and `end` parameters,
    takes a step parameter. By making a step of -1, we can count down in the range:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，右侧将稍微复杂一些；因为我们想让彩虹朝相反方向延伸，所以我们需要让彩虹的范围也倒计数。Python的`range`函数，连同`start`和`end`参数，还有一个步长参数。通过将步长设置为-1，我们可以在范围内倒计数：
- en: '[PRE36]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Upload this and run it, and the bar graph will be in rainbow colors instead
    of a solid color.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传此代码并运行它，条形图将显示彩虹颜色而不是纯色。
- en: You have gone from a single LED to a number of LEDs. With some work on color
    systems, we were able to generate a rainbow and use it to show the status of a
    behavior.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经从单个LED变成了多个LED。通过一些对颜色系统的处理，我们能够生成彩虹并使用它来显示行为的状态。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to interact with and use RGB LEDs, as well
    as how to choose and buy RGB LED strips that work with the Raspberry Pi. You learned
    how to make code for the LEDs on the robot, using them with robot behaviors. You
    also saw how the HSV color system works, which can be used to generate rainbows.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何与RGB LED交互和使用，以及如何选择和购买与Raspberry Pi兼容的RGB LED灯带。你学习了如何为机器人上的LED编写代码，使用它们与机器人行为结合。你还看到了HSV颜色系统是如何工作的，它可以用来生成彩虹。
- en: You can take the techniques used here to add LED-based status displays to robots
    and write code to link them with behaviors.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这里使用的技术用于向机器人添加基于LED的状态显示，并编写将它们与行为链接的代码。
- en: In the next chapter, we will look at servo motors and build a pan and tilt mechanism
    for moving sensors.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨伺服电机并构建一个用于移动传感器的云台机构。
- en: Exercises
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Try mixing a different RGB color, or looking one up, and using `set_one`, `set_all`,
    or `set_range` to light LEDs in that color.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试混合不同的RGB颜色，或者查找一种颜色，并使用`set_one`，`set_all`或`set_range`来点亮该颜色的LED。
- en: Use the show left rainbow and show right rainbow functions to make the robot
    turn on rainbows corresponding to the side it's turning to in the `behaviour_path`
    code.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`show_left_rainbow`和`show_right_rainbow`函数，在`behaviour_path`代码中使机器人转向时点亮对应侧的彩虹。
- en: By making a timer loop and advancing an index or changing a range, it would
    be possible to animate the rainbows or make them *scan* across the LED bar. Try
    this out.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个计时器循环并递增索引或改变范围，可以动画显示彩虹或使它们在LED条上*扫描*。试试这个方法。
- en: Could the other parts of the HSV color be used to make pulsing LED strips that
    change brightness?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HSV颜色模型的其他部分能否用来制作亮度变化的闪烁LED灯带？
- en: Further reading
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Please refer to the following for more information:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下内容获取更多信息：
- en: '*Make Electronics: Learning by Discovery*, *Charles Platt*, *Make Community,
    LLC*: I''ve only started to cover some basic electronics with the switch and breadboard.
    To get a real feel for electronics, *Make Electronics* is a superb introduction.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《通过探索学习电子学》*，*查尔斯·普拉特*，*Make Community, LLC*：我刚刚开始用开关和面包板介绍一些基本的电子学知识。要真正感受电子学的魅力，*《通过探索学习电子学》*是一本极好的入门书籍。'
- en: 'For more advanced electronics, try *Practical Electronics for Inventors, Fourth
    Edition*, *Paul Scherz*, *Simon Monk*, *McGraw-Hill Education TAB*: This gives
    practical building blocks for electronics that can be used to interface a robot
    controller with almost anything or build new sensors.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于更高级的电子学，尝试阅读*《发明者实用电子学，第四版》*，*保罗·舍尔茨*，*西蒙·蒙克*，*麦格劳-希尔教育TAB*：这本书提供了电子学的实用构建块，可以用来将机器人控制器与几乎任何设备接口或构建新的传感器。
- en: 'The `colorsys` library, like most Python core libraries, has a great reference:
    [https://docs.python.org/3/library/colorsys.html](https://docs.python.org/3/library/colorsys.html).'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`colorsys`库，像大多数Python核心库一样，有一个很好的参考：[https://docs.python.org/3/library/colorsys.html](https://docs.python.org/3/library/colorsys.html)。'
- en: Pimoroni have some other demos with the LED SHIM at [https://github.com/pimoroni/led-shim/tree/master/examples](https://github.com/pimoroni/led-shim/tree/master/examples).
    These could be fun to adapt to our LED layer.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pimoroni有一些使用LED SHIM的演示，可以在[https://github.com/pimoroni/led-shim/tree/master/examples](https://github.com/pimoroni/led-shim/tree/master/examples)找到。这些可能很有趣，可以改编到我们的LED层。
