- en: <st c="0">12</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">12</st>
- en: <st c="3">Combining RAG with the Power of AI Agents and LangGraph</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3">结合RAG与AI代理和LangGraph的力量</st>
- en: <st c="59">One call to an</st> **<st c="75">large language model</st>** <st
    c="95">(</st>**<st c="97">LLM</st>**<st c="100">) can be powerful, but put your
    logic in a loop with a goal toward achieving a more sophisticated task and you
    can take your</st> **<st c="226">retrieval-augmented generation</st>** <st c="256">(</st>**<st
    c="258">RAG</st>**<st c="261">) development to a whole new level.</st> <st c="298">That
    is the concept behind</st> **<st c="325">agents</st>**<st c="331">. The past year
    of development for LangChain has focused significant energy on improving support
    for</st> *<st c="432">agentic</st>* <st c="439">workflows, adding functionality
    that enables more precise control over agent behavior and capabilities.</st> <st
    c="544">Part of this progress has been in the emergence of</st> **<st c="595">LangGraph</st>**<st
    c="604">, another relatively new part of LangChain.</st> <st c="648">Together,
    agents and LangGraph pair well as a powerful approach to improving</st> <st c="725">RAG
    applications.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59">一次调用一个</st> **<st c="75">大型语言模型</st>** <st c="95">(</st>**<st c="97">LLM</st>**<st
    c="100">) 可以非常强大，但将你的逻辑放在一个循环中，以实现更复杂的任务为目标，你就可以将你的</st> **<st c="226">检索增强生成</st>**
    <st c="256">(</st>**<st c="258">RAG</st>**<st c="261">) 开发提升到全新的水平。</st> <st c="298">这就是</st>
    **<st c="325">代理</st>**<st c="331">背后的概念。过去一年LangChain的开发重点放在了提高对</st> *<st c="432">代理</st>*
    <st c="439">工作流程的支持上，增加了能够更精确控制代理行为和功能的功能。</st> <st c="544">这一进步的部分成果是</st> **<st
    c="595">LangGraph</st>**<st c="604">的出现，LangChain的另一个相对较新的部分。</st> <st c="648">共同来说，代理和LangGraph作为提高</st>
    <st c="725">RAG应用</st> 的强大方法，配合得很好。
- en: <st c="742">In this chapter, we will focus on gaining a deeper understanding
    of the elements of agents that can be utilized in RAG and then tie them back to
    your RAG efforts, covering topics such as</st> <st c="930">the following:</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="742">在本章中，我们将专注于深入了解可用于RAG的代理元素，然后将它们与你自己的RAG工作联系起来，涵盖以下主题：</st> <st
    c="930">以下内容：</st>
- en: <st c="944">Fundamentals of AI agents and</st> <st c="975">RAG integration</st>
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="944">AI代理和RAG集成的 fundamentals</st>
- en: <st c="990">Graphs, AI agents,</st> <st c="1010">and LangGraph</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="990">图，AI代理，</st> <st c="1010">和 LangGraph</st>
- en: <st c="1023">Adding a LangGraph retrieval agent to your</st> <st c="1067">RAG
    application</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1023">将LangGraph检索代理添加到你的</st> <st c="1067">RAG应用</st>
- en: <st c="1082">Tools</st> <st c="1089">and toolkits</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1082">工具</st> <st c="1089">和工具包</st>
- en: <st c="1101">Agent state</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1101">代理状态</st>
- en: <st c="1113">Core concepts of</st> <st c="1131">graph theory</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1113">图论的核心概念</st>
- en: <st c="1143">By the end of this chapter, you will have a solid grasp of how
    AI agents and LangGraph can enhance your RAG applications.</st> <st c="1266">In
    the next section, we will dive into the fundamentals of AI agents and RAG integration,
    setting the stage for the concepts and code lab</st> <st c="1404">that follow.</st>
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1143">到本章结束时，你将牢固掌握AI代理和LangGraph如何增强你的RAG应用。</st> <st c="1266">在下一节中，我们将深入探讨AI代理和RAG集成的
    fundamentals，为后续的概念和代码实验做好准备。</st>
- en: <st c="1416">Technical requirements</st>
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1416">技术要求</st>
- en: <st c="1439">The code for this chapter is placed in the following GitHub</st>
    <st c="1500">repository:</st> [<st c="1512">https://github.com/PacktPublishing/Unlocking-Data-with-Generative-AI-and-RAG/tree/main/Chapter_12</st>](https://github.com/PacktPublishing/Unlocking-Data-with-Generative-AI-and-RAG/tree/main/Chapter_12)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1439">本章的代码放置在以下GitHub</st> <st c="1500">仓库中：</st> [<st c="1512">https://github.com/PacktPublishing/Unlocking-Data-with-Generative-AI-and-RAG/tree/main/Chapter_12</st>](https://github.com/PacktPublishing/Unlocking-Data-with-Generative-AI-and-RAG/tree/main/Chapter_12)
- en: <st c="1609">Fundamentals of AI agents and RAG integration</st>
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1609">AI代理和RAG集成的 fundamentals</st>
- en: <st c="1655">When talking with new developers in generative AI, we have been
    told that the concept of an AI agent often tends to be one of the more challenging
    concepts to grasp.</st> <st c="1822">When experts talk about agents, they often
    talk about them in very abstract terms, focusing on all the things AI agents can
    be responsible for in a RAG application, but failing to really explain thoroughly
    what an AI agent is and how</st> <st c="2056">it works.</st>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1655">在与生成式AI的新开发者交谈时，我们被告知，AI代理的概念往往是更难理解的概念之一。</st> <st c="1822">当专家们谈论代理时，他们经常用非常抽象的术语来谈论它们，关注AI代理在RAG应用中可以负责的所有事情，但未能真正彻底地解释AI代理是什么以及它是如何</st>
    <st c="2056">工作的。</st>
- en: <st c="2065">I find that it is easiest to dispel the mystery of the AI</st>
    <st c="2123">agent by explaining what it really is, which is actually a very simple
    concept.</st> <st c="2204">To build an AI agent in its most basic form, you are
    simply taking the same LLM concept you have already been working with throughout
    these chapters and adding a loop that terminates when the intended task is done.</st>
    <st c="2419">That’s it!</st> <st c="2430">It’s just a</st> <st c="2442">loop folks!</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2065">我发现，通过解释它实际上是什么来消除AI代理的神秘感是最容易的，这是一个非常简单的概念。</st> <st c="2123">要构建最基本形式的AI代理，你只是将你在这些章节中一直在使用的相同的LLM概念添加一个循环，当预期任务完成时循环终止。</st>
    <st c="2419">就是这样！</st> <st c="2430">这只是个循环而已！</st>
- en: '*<st c="2453">Figure 12</st>**<st c="2463">.1</st>* <st c="2465">represents
    the</st> **<st c="2481">RAG agent loop</st>** <st c="2495">you will be working</st>
    <st c="2515">with in the code lab that you are about to</st> <st c="2559">dive
    into:</st>'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="2453">图12</st>**<st c="2463">.1</st>* <st c="2465">表示你将在即将投入使用的代码实验室中与之合作的**<st
    c="2481">RAG代理循环</st>** <st c="2495">：</st>'
- en: '![Figure 12.1 – Graph of the agent’s control flow](img/B22475_12_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 代理控制流程图](img/B22475_12_01.jpg)'
- en: <st c="2598">Figure 12.1 – Graph of the agent’s control flow</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2598">图12.1 – 代理控制流程图</st>
- en: <st c="2645">This represents a relatively simple set of logic steps that loop
    through until the agent decides it has successfully completed the task you have
    given it.</st> <st c="2801">The oval</st> <st c="2809">boxes, such as</st> *<st
    c="2825">agent</st>* <st c="2830">and</st> *<st c="2835">retrieve</st>*<st c="2843">,
    are called</st> **<st c="2856">nodes</st>** <st c="2861">and the lines are</st>
    <st c="2879">called</st> **<st c="2887">edges</st>**<st c="2892">. The dotted
    lines are also edges, but they are a specific type called</st> **<st c="2963">conditional
    edges</st>**<st c="2980">, which are edges</st> <st c="2997">that are also</st>
    <st c="3012">decision points.</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2645">这代表了一系列相对简单的逻辑步骤，循环执行，直到代理决定它已经成功完成了你给它分配的任务。</st> <st c="2801">椭圆形框，例如</st>
    *<st c="2825">代理</st> * <st c="2830">和</st> *<st c="2835">检索</st>*, 被称为**<st c="2856">节点</st>**
    <st c="2861">，而线条被称为**<st c="2879">边</st>**<st c="2892">。虚线也是边，但它们是特定类型的边，称为**<st
    c="2963">条件边</st>**<st c="2980">，这些边也是**<st c="2997">决策点</st>**。</st>
- en: <st c="3028">Despite the simplicity, the concept of adding a loop to your LLM
    calls does make it much more powerful than just using LLMs directly, because it
    takes more advantage of the LLM’s ability to reason and break tasks down into
    simpler tasks.</st> <st c="3267">This improves the chances of success in whatever
    task you are pursuing and will come in especially handy with more complex multi-step</st>
    <st c="3401">RAG tasks.</st>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3028">尽管简单，但在LLM调用中添加循环的概念确实使它比直接使用LLM更强大，因为它更多地利用了LLM推理和将任务分解成更简单任务的能力。</st>
    <st c="3267">这提高了你在追求的任何任务中取得成功的可能性，并且对于更复杂的多步骤**<st c="3401">RAG任务</st>**将特别有用。</st>
- en: <st c="3411">While your LLM is looping through agent tasks, you also provide
    functions called</st> *<st c="3493">tools</st>* <st c="3498">to the agent, and
    the LLM will use its reasoning capabilities to determine which tool to use, how
    to use that tool, and what data to feed it.</st> <st c="3641">This is where it
    can get really complex very quickly.</st> <st c="3695">You can have multiple agents,
    numerous tools, integrated knowledge graphs that help guide your agents down a
    specific path, numerous frameworks that offer different</st> *<st c="3860">flavors</st>*
    <st c="3867">of agents, numerous approaches to agent architecture, and much more.</st>
    <st c="3937">But in this chapter, we are going to focus specifically on how an
    AI agent can help improve RAG applications.</st> <st c="4047">Once you see the
    power of using an AI agent though, I have no doubt you will want to use it in
    other generative AI applications, and</st> <st c="4180">you should!</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3411">当你的LLM在循环执行代理任务时，你还会向代理提供称为**<st c="3493">工具</st>** <st c="3498">的函数，LLM将使用其推理能力来确定使用哪个工具，如何使用该工具，以及向其提供什么数据。</st>
    <st c="3641">这很快就会变得非常复杂。</st> <st c="3695">你可以有多个代理，众多工具，集成的知识图谱来引导你的代理沿着特定路径前进，众多框架提供不同**<st
    c="3860">风味</st>** <st c="3867">的代理，众多代理架构的方法，等等。</st> <st c="3937">但在这个章节中，我们将专门关注AI代理如何帮助改进RAG应用。</st>
    <st c="4047">一旦你看到了使用AI代理的力量，我毫不怀疑你将想要在其他生成式AI应用中使用它，而且**<st c="4180">你应该这样做</st>**！</st>
- en: <st c="4191">Living in an AI agent world</st>
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="4191">生活在智能体世界中</st>
- en: <st c="4219">With all the excitement</st> <st c="4243">around agents, you might
    think LLMs are already going obsolete.</st> <st c="4308">But that couldn’t be
    further from the truth.</st> <st c="4353">With AI agents, you are really tapping
    into an even more powerful version of an LLM, a version where the LLM serves as
    the “brain” of the agent, letting it reason and come up with multi-step solutions
    well beyond the one-off chat questions most people are using them for.</st> <st
    c="4625">The agent just provides a layer between the user and the LLM and pushes
    the LLM to accomplish a task that may take multiple queries of the LLM but will
    eventually, in theory, end up with a much</st> <st c="4819">better result.</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4219">在智能体周围的兴奋情绪中</st> <st c="4243">，你可能会认为LLM已经过时了。</st> <st c="4308">但事实远非如此。</st>
    <st c="4353">与AI智能体一起，你实际上是在挖掘一个更强大的LLM版本，在这个版本中，LLM充当智能体的“大脑”，使其能够进行推理并提出超越一次性聊天问题的多步解决方案。</st>
    <st c="4625">智能体只是在用户和LLM之间提供一个层次，推动LLM完成可能需要多次查询的任务，但最终，从理论上讲，将得到一个更好的结果。</st>
    <st c="4819">更好的结果。</st>
- en: <st c="4833">If you think about it, this matches up more with how problems are
    solved in the real world, where even simple decisions can be complex.</st> <st
    c="4970">Most tasks we do are based on a long chain of observations, reasoning,
    and adjustments to new experiences.</st> <st c="5077">Very rarely do we interact
    with people, tasks, and things in the real world in the same way we interact with
    LLMs online.</st> <st c="5199">There is often this building of understanding,
    knowledge, and context that takes place and helps us find the best solutions.</st>
    <st c="5324">AI agents are better able to handle this type of approach</st> <st
    c="5382">to problem-solving.</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4833">如果你这么想，这更符合现实世界中解决问题的方式，即使简单的决策也可能很复杂。</st> <st c="4970">我们做的许多任务都是基于一系列观察、推理和对新经验的调整。</st>
    <st c="5077">在现实世界中，我们很少以与在线使用LLM相同的方式与人们、任务和事物互动。</st> <st c="5199">通常会有这种理解和知识的构建过程，帮助我们找到最佳解决方案。</st>
    <st c="5324">AI智能体更能处理这种类型的解决问题的方法</st> <st c="5382">。</st>
- en: <st c="5401">Agents can make a big difference to your RAG efforts, but what
    about this concept of the LLMs being their brains?</st> <st c="5516">Let’s dive
    into the</st> <st c="5536">concept further.</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5401">智能体可以对您的RAG工作产生重大影响，但关于LLM作为其大脑的概念又如何呢？</st> <st c="5516">让我们进一步探讨</st>
    <st c="5536">这个概念。</st>
- en: <st c="5552">LLMs as the agents’ brains</st>
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="5552">作为智能体的大脑</st>
- en: <st c="5579">If you consider the LLM</st> <st c="5603">as the brain of your
    AI agent, the next logical step is that you likely want the</st> *<st c="5685">smartest</st>*
    <st c="5693">LLM you can find to be that brain.</st> <st c="5729">The capabilities
    of the LLM are going to affect your AI agent’s ability to reason and make decisions,
    which will certainly impact the results of the queries to your</st> <st c="5894">RAG
    application.</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5579">如果你认为LLM是您AI智能体的大脑，那么下一个合乎逻辑的步骤是，你很可能希望找到</st> *<st c="5685">最聪明</st>*
    <st c="5693">的LLM来充当这个大脑。</st> <st c="5729">LLM的能力将影响您的AI智能体推理和决策的能力，这无疑将影响您RAG应用的查询结果。</st>
- en: <st c="5910">There is one major</st> <st c="5929">way this metaphor of an LLM
    brain breaks down though, but in a very good way.</st> <st c="6008">Unlike agents
    in the real world, the AI agent can always swap out their LLM brain for another
    LLM brain.</st> <st c="6113">We could even give it multiple LLM brains that can
    serve to check each other and make sure things are proceeding as planned.</st>
    <st c="6238">This gives us greater flexibility that will help us continually improve
    the capabilities of</st> <st c="6330">our agents.</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5910">然而，这种LLM大脑的隐喻有一个主要的</st> <st c="5929">缺陷，但以一种非常好的方式。</st> <st c="6008">与现实世界中的智能体不同，AI智能体可以随时更换其LLM大脑为另一个LLM大脑。</st>
    <st c="6113">我们甚至可以给它多个LLM大脑，这些大脑可以相互检查并确保一切按计划进行。</st> <st c="6238">这为我们提供了更大的灵活性，将有助于我们不断改进智能体的能力。</st>
- en: <st c="6341">So, how does LangGraph, or graphs in general, relate to AI agents?</st>
    <st c="6409">We will discuss</st> <st c="6425">that next.</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6341">那么，LangGraph或一般意义上的图与AI智能体有何关联？</st> <st c="6409">我们将在下一节讨论</st>
    <st c="6425">这一点。</st>
- en: <st c="6435">Graphs, AI agents, and LangGraph</st>
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="6435">图、AI智能体和LangGraph</st>
- en: <st c="6468">LangChain introduced</st> <st c="6489">LangGraph in</st> <st c="6502">2024,
    so it is still relatively new.</st> <st c="6540">It is an extension built on top
    of</st> `<st c="6863">AgentExecutor</st>` <st c="6876">class, still exists, LangGraph
    is now the</st> *<st c="6919">recommended</st>* <st c="6930">way to build agents</st>
    <st c="6951">in LangChain.</st>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6468">LangChain在</st> <st c="6489">2024年引入了</st> <st c="6502">LangGraph，因此它仍然相对较新。</st>
    <st c="6540">它是建立在</st> `<st c="6863">AgentExecutor</st>` <st c="6876">类之上的扩展，仍然存在，LangGraph现在是</st>
    *<st c="6919">推荐</st>* <st c="6930">在LangChain中构建代理的</st> *<st c="6951">方式</st>*
- en: <st c="6964">LangGraph adds two important components</st> <st c="7004">for</st>
    <st c="7009">supporting agents:</st>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6964">LangGraph增加了两个重要的组件</st> <st c="7004">以支持代理：</st>
- en: <st c="7027">The ability to easily define cycles (</st><st c="7065">cyclical
    graphs)</st>
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="7027">轻松定义周期（</st><st c="7065">循环图</st>）
- en: <st c="7082">Built-in memory</st>
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="7082">内置内存</st>
- en: <st c="7098">It provides a pre-built object equivalent to</st> `<st c="7144">AgentExecutor</st>`<st
    c="7157">, allowing developers to orchestrate agents using a</st> <st c="7209">graph-based
    approach.</st>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7098">它提供了一个与</st> `<st c="7144">AgentExecutor</st>`<st c="7157">等效的预构建对象，允许开发者使用基于</st>
    <st c="7209">图的方法来编排代理。</st>
- en: <st c="7230">Over the past couple of years, numerous papers, concepts, and approaches
    have emerged for building agents into RAG applications, such as orchestration
    agents, ReAct agents, self-refine agents, and multi-agent frameworks.</st> <st
    c="7452">A common theme among these approaches is the concept of a cyclical graph
    that represents the agent’s control flow.</st> <st c="7567">While many of these
    approaches, from an implementation standpoint, are going obsolete, their concepts
    are still highly useful and are captured in the graph-based environment</st> <st
    c="7741">of LangGraph.</st>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7230">在过去的几年里，出现了许多将代理构建到RAG应用中的论文、概念和方法，例如编排代理、ReAct代理、自我优化代理和多代理框架。</st>
    <st c="7452">这些方法中的一个共同主题是表示代理控制流的循环图概念。</st> <st c="7567">虽然许多这些方法从实现的角度来看正在变得过时，但它们的概念仍然非常有用，并且被LangGraph的基于图的环境所捕捉。</st>
    <st c="7741">LangGraph已经成为支持代理并在RAG应用中管理它们的流程和过程的有力工具。</st>
- en: '**<st c="7754">LangGraph</st>** <st c="7764">has become</st> <st c="7775">a
    powerful tool for supporting agents and managing their flow and process in RAG
    applications.</st> <st c="7871">It enables developers to describe and represent
    single and multi-agent flows as graphs, providing extremely controlled</st> *<st
    c="7990">flows</st>*<st c="7995">. This controllability is crucial for avoiding
    the pitfalls encountered by developers when creating agents</st> <st c="8102">early
    on.</st>'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="7754">LangGraph</st>** <st c="7764">已经成为</st> <st c="7775">支持代理和管理它们在RAG应用中的流程和过程的有力工具。</st>
    <st c="7871">它使开发者能够将单代理和多代理流程描述和表示为图，提供极其可控的</st> *<st c="7990">流程</st>*<st c="7995">。这种可控性对于避免开发者早期创建代理时遇到的陷阱至关重要。</st>'
- en: <st c="8111">As an example, the popular ReAct approach was an early paradigm
    for building agents.</st> **<st c="8197">ReAct</st>** <st c="8202">stands for</st>
    **<st c="8214">reason + act</st>**<st c="8226">. In this pattern, an LLM</st>
    <st c="8251">first thinks about what to do and then decides an action to take.</st>
    <st c="8318">That action is then executed in an environment and an observation
    is returned.</st> <st c="8397">With that observation, the LLM then repeats this
    process.</st> <st c="8455">It uses reasoning to think about what to do next, decides
    another action to take, and continues until it has been determined that the goal
    has been met.</st> <st c="8608">If you map this process out, it may look something
    like what you see here in</st> *<st c="8685">Figure 12</st>**<st c="8694">.2</st>*<st
    c="8696">:</st>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8111">例如，流行的ReAct方法是为构建代理的早期范例。</st> **<st c="8197">ReAct</st>** <st
    c="8202">代表</st> **<st c="8214">reason + act</st>**<st c="8226">。在这个模式中，一个LLM</st>
    <st c="8251">首先思考要做什么，然后决定采取的行动。</st> <st c="8318">然后在这个环境中执行该行动，并返回一个观察结果。</st>
    <st c="8397">有了这个观察结果，LLM随后重复这个过程。</st> <st c="8455">它使用推理来思考接下来要做什么，决定另一个要采取的行动，并继续直到确定目标已经达成。</st>
    <st c="8608">如果你将这个过程绘制出来，它可能看起来就像你在</st> *<st c="8685">图12</st>**<st c="8694">.2</st>*<st
    c="8696">中看到的那样：</st>
- en: '![Figure 12.2 – ReAct cyclical graph representation](img/B22475_12_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – ReAct循环图表示](img/B22475_12_02.jpg)'
- en: <st c="8721">Figure 12.2 – ReAct cyclical graph representation</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8721">图12.2 – ReAct循环图表示</st>
- en: <st c="8770">The set of loops in</st> *<st c="8791">Figure 12</st>**<st c="8800">.2</st>*
    <st c="8802">can be represented</st> <st c="8821">by cyclical graphs in LangGraph,
    with each step represented by nodes and edges.</st> <st c="8902">Using this graphing
    paradigm, you can see how a tool such as LangGraph, a tool for building graphs
    in LangChain, can form the backbone of your agent framework.</st> <st c="9062">As
    we build our agent framework, we can represent these agent loops using LangGraph,
    which helps you describe and orchestrate the control flow.</st> <st c="9206">This
    focus on the control flow is critical to addressing some of the early challenges
    with agents, where a lack of control leads to rogue agents that can’t complete
    their loops or focus on the</st> <st c="9399">wrong task.</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8770">图12.2中的循环集合可以用LangGraph中的循环图来表示，每个步骤由节点和边表示。</st> <st c="8791">*<st
    c="8791">图12</st>**<st c="8800">.2</st>**</st c="8802">可以用LangGraph中的循环图来表示，每个步骤由节点和边表示。</st>
    <st c="8902">使用这种图形范式，你可以看到像LangGraph这样的工具，LangChain中构建图的工具，如何成为您代理框架的核心。</st>
    <st c="9062">在我们构建代理框架时，我们可以使用LangGraph来表示这些代理循环，这有助于您描述和编排控制流。</st> <st c="9206">这种对控制流的关注对于解决代理的一些早期挑战至关重要，缺乏控制会导致无法完成循环或专注于错误任务的代理。</st>
- en: <st c="9410">Another key element that LangGraph has built into it is persistence.</st>
    <st c="9480">Persistence can be used to maintain the memory of the agent, giving
    it the information it needs to reflect on all of its actions so far, and representing
    the</st> *<st c="9638">OBSERVE</st>* <st c="9645">component presented in</st>
    *<st c="9669">Figure 12</st>**<st c="9678">.2</st>*<st c="9680">. This is really
    helpful for having multiple conversations at the same time or remembering previous
    iterations and actions.</st> <st c="9804">This persistence also enables human-in-the-loop
    features that give you better control over what the agent is doing at key intervals
    during</st> <st c="9943">its actions.</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9410">LangGraph内置的另一个关键元素是持久性。</st> <st c="9480">持久性可以用来保持代理的记忆，给它提供所需的信息来反思迄今为止的所有行动，并代表在</st>
    *<st c="9638">图12</st>**<st c="9645">.2</st>**<st c="9680">中展示的* <st c="9638">OBSERVE</st>
    *组件。这非常有帮助，可以同时进行多个对话或记住之前的迭代和行动。</st> <st c="9804">这种持久性还使人类在循环中具有功能，让您在代理行动的关键间隔期间更好地控制其行为。</st>
- en: <st c="9955">The paper that introduced the ReAct approach to agent building
    can be found</st> <st c="10032">here:</st> [<st c="10038">https://arxiv.org/abs/2210.03629</st>](https://arxiv.org/abs/2210.03629)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9955">介绍ReAct方法构建代理的论文可以在以下位置找到：</st> <st c="10032">[<st c="10038">https://arxiv.org/abs/2210.03629</st>](https://arxiv.org/abs/2210.03629)
- en: <st c="10070">Let’s dive right into the code lab for building our agent and
    walk through more key individual concepts as we encounter them in</st> <st c="10199">the
    code.</st>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10070">让我们直接进入构建代理的代码实验室，并在代码中遇到它们时，更深入地探讨一些关键概念。</st> <st c="10199">。</st>
- en: <st c="10208">Code lab 12.1 – adding a LangGraph agent to RAG</st>
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="10208">代码实验室12.1 – 向RAG添加LangGraph代理</st>
- en: <st c="10256">In this code lab, we will add an agent</st> <st c="10295">to our
    existing RAG pipeline that can make decisions about whether to retrieve from an
    index or use a web search.</st> <st c="10410">We will show the inner thoughts
    of the agent as it processes data that it retrieves toward the goal of providing
    you with a more thorough response to your question.</st> <st c="10575">As we add
    the code for our agent, we will see new components, such as tools, toolkits, graphs,
    nodes, edges, and, of course, the agent itself.</st> <st c="10718">For each component,
    we will go more in-depth into how that component interacts and supports your RAG
    application.</st> <st c="10832">We will also add code so that this functions more
    like a chat session, rather than a</st> <st c="10917">Q&A session:</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码实验室中，我们将向现有的RAG管道添加一个代理<st c="10256">，它可以决定是否从索引中检索或使用网络搜索。</st> <st c="10295">我们将展示代理在处理数据时的内部想法，这些数据是为了向您提供更全面的回答。</st>
    <st c="10410">当我们添加代理的代码时，我们将看到新的组件，例如工具、工具包、图表、节点、边，当然还有代理本身。</st> <st c="10575">对于每个组件，我们将更深入地了解该组件如何与您的RAG应用程序交互和支持。</st>
    <st c="10718">我们还将添加代码，使这个功能更像是一个聊天会话，而不是一个</st> <st c="10832">问答会话：</st>
- en: <st c="10929">First, we will install some new packages to support our</st> <st
    c="10986">agent development:</st>
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="10929">首先，我们将安装一些新的包来支持我们的</st> <st c="10986">代理开发：</st>
- en: '[PRE0]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="11262">Next, we add a new LLM definition and update our</st> <st c="11312">existing
    one:</st>
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="11262">接下来，我们添加一个新的LLM定义并更新我们的</st> <st c="11312">现有定义：</st>
- en: '[PRE2]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="11479">The new</st> `<st c="11488">agent_llm</st>` <st c="11497">LLM
    instance will serve as our agent’s brain, handling reasoning and execution of
    the agent tasks, whereas the original</st> `<st c="11618">llm</st>` <st c="11621">instance
    will still be present in our general LLM to do the same LLM tasks we have used
    it for in the past.</st> <st c="11730">While the two LLMs are defined with the
    same model and parameters in our example, you could and should experiment with
    using different LLMs for these different tasks, to see if there is a combination
    that works better for your RAG applications.</st> <st c="11975">You could even
    add additional LLMs to handle specific tasks, such as the</st> `<st c="12048">improve</st>`
    <st c="12055">or</st> `<st c="12059">score_documents</st>` <st c="12074">functions
    in this code, if you find an LLM better at those tasks or have trained or fine-tuned
    your own for these particular actions.</st> <st c="12209">For example, It is common
    for simple tasks to be handled by faster, lower-cost LLMs as long as they can
    perform the task successfully.</st> <st c="12344">There is a lot of flexibility
    built into this code that you can take advantage of!</st> <st c="12427">Also,
    note that we add</st> `<st c="12450">streaming=True</st>` <st c="12464">to the
    LLM definition.</st> <st c="12488">This turns on streaming data from the LLM,
    which is more conducive to an agent that may make several calls, sometimes in
    parallel, constantly interacting with</st> <st c="12647">the LLM.</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11479">新的</st> `<st c="11488">agent_llm</st>` <st c="11497">LLM实例将作为我们代理的大脑，处理推理和执行代理任务，而原始的</st>
    `<st c="11618">llm</st>` <st c="11621">实例仍然存在于我们的通用LLM中，执行我们过去使用的相同LLM任务。</st>
    <st c="11730">虽然在我们的示例中，两个LLM使用相同的模型和参数定义，但您应该尝试使用不同的LLM来完成这些不同的任务，以查看是否有更适合您RAG应用的组合。</st>
    <st c="11975">您甚至可以添加额外的LLM来处理特定任务，例如，如果在这个代码中您发现某个LLM在那些任务上表现更好，或者您已经为这些特定操作训练或微调了自己的LLM，那么可以添加</st>
    `<st c="12048">improve</st>` <st c="12055">或</st> `<st c="12059">score_documents</st>`
    <st c="12074">函数。</st> <st c="12209">例如，对于简单任务，只要它们能成功完成任务，通常可以使用更快、成本更低的LLM来处理。</st>
    <st c="12344">此代码中内置了大量的灵活性，您可以充分利用这些灵活性！</st> <st c="12427">此外，请注意，我们在LLM定义中添加了</st>
    `<st c="12450">streaming=True</st>` <st c="12464">。</st> <st c="12488">这会开启从LLM流式传输数据，这对可能进行多次调用（有时是并行调用）并不断与</st>
    <st c="12647">LLM交互的代理更有利。</st>
- en: <st c="12655">Now, we are going to skip down to after the retriever definitions
    (</st>`<st c="12723">dense_retriever</st>`<st c="12739">,</st> `<st c="12741">sparse_retriever</st>`<st
    c="12757">, and</st> `<st c="12763">ensemble_retriever</st>`<st c="12781">) and
    add our first tool.</st> <st c="12808">A</st> **<st c="12810">tool</st>** <st
    c="12814">has a very specific and important meaning when it comes to agents; so,
    let’s talk about</st> <st c="12903">that now.</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12655">现在，我们将跳过检索器定义（</st>`<st c="12723">dense_retriever</st>`<st c="12739">，
    `<st c="12741">sparse_retriever</st>`<st c="12757">，和</st> `<st c="12763">ensemble_retriever</st>`<st
    c="12781">）之后的部分，并添加我们的第一个工具。</st> <st c="12808">在代理方面，</st> **<st c="12810">工具</st>**
    <st c="12814">有一个非常具体且重要的含义；因此，让我们现在来谈谈</st> <st c="12903">它。</st>
- en: <st c="12912">Tools and toolkits</st>
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="12912">工具和工具包</st>
- en: <st c="12931">In the following code, we are going to add</st> <st c="12974">a</st>
    **<st c="12977">web</st>** **<st c="12981">search</st>** <st c="12987">tool:</st>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12931">在下面的代码中，我们将添加</st> <st c="12974">一个</st> **<st c="12977">web</st>**
    **<st c="12981">search</st>** <st c="12987">工具：</st>
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="13297">You will need to get another API key and add it to the</st> `<st
    c="13353">env.txt</st>` <st c="13360">file we have used in the past for the OpenAI
    and Together APIs.</st> <st c="13425">Just like with those APIs, you will need
    to go to that website, set up your API key, and then copy that into your</st>
    `<st c="13539">env.txt</st>` <st c="13546">file.</st> <st c="13553">The Tavily
    website can be found at this</st> <st c="13593">URL:</st> [<st c="13598">https://tavily.com/</st>](https://tavily.com/)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13297">您需要获取另一个API密钥并将其添加到</st> `<st c="13353">env.txt</st>` <st c="13360">文件中，这是我们过去用于OpenAI和Together
    API的文件。</st> <st c="13425">就像那些API一样，您需要访问那个网站，设置您的API密钥，然后将它复制到您的</st> `<st c="13539">env.txt</st>`
    <st c="13546">文件中。</st> <st c="13553">Tavily网站可以通过此</st> <st c="13593">URL</st>
    找到：[<st c="13598">https://tavily.com/</st>](https://tavily.com/)
- en: <st c="13617">We run</st> <st c="13624">the code again that loads the data from
    the</st> `<st c="13669">env.txt</st>` <st c="13676">file and then we set up the</st>
    `<st c="13705">TavilySearchResults</st>` <st c="13724">object with</st> `<st c="13737">max_results</st>`
    <st c="13748">of</st> `<st c="13752">4</st>`<st c="13753">, meaning when we run
    it for search, we only want four search results maximum.</st> <st c="13832">We
    then assign the</st> `<st c="13851">web_search.name</st>` <st c="13866">variable
    to a variable called</st> `<st c="13897">web_search_name</st>` <st c="13912">so
    that we have that available later when we want to tell the agent about it.</st>
    <st c="13991">You can run this tool directly using</st> <st c="14028">this code:</st>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13617">我们再次运行</st> <st c="13624">从</st> `<st c="13669">env.txt</st>`
    <st c="13676">文件加载数据的</st>代码，然后我们设置了一个名为</st> `<st c="13705">TavilySearchResults</st>`
    <st c="13724">的对象，其</st> `<st c="13737">max_results</st>` <st c="13748">为</st>
    `<st c="13752">4</st>`<st c="13753">，这意味着当我们运行搜索时，我们只想获得最多四个搜索结果。</st> <st c="13832">然后我们将</st>
    `<st c="13851">web_search.name</st>` <st c="13866">变量分配给一个名为</st> `<st c="13897">web_search_name</st>`
    <st c="13912">的变量，以便我们稍后当需要告诉代理关于它时可以使用。</st> <st c="13991">您可以直接使用以下代码运行此工具：</st>
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="14068">Running this tool code with</st> `<st c="14097">user_query</st>`
    <st c="14107">will give you a result like this (truncated</st> <st c="14152">for
    brevity):</st>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14068">使用</st> `<st c="14097">user_query</st>` <st c="14107">运行此工具代码将得到如下结果（为了简洁而截断）：</st>
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="14856">We truncated this so we take up less space in the book, but try
    this in the code and you will see four results, as we asked for, and they all
    seem to be highly related to the topic</st> `<st c="15038">user_query</st>` <st
    c="15048">is asking about.</st> <st c="15066">Note that you will not need to run
    this tool directly in your code like we</st> <st c="15141">just did.</st>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14856">我们截断了这部分内容，以便在书中占用更少的空间，但在代码中尝试这样做，您将看到我们请求的四个结果，并且它们似乎都与</st>
    `<st c="15038">user_query</st>` <st c="15048">用户询问的主题</st>高度相关。</st> <st c="15066">请注意，您不需要像我们</st>
    <st c="15141">刚才那样直接在代码中运行此工具。</st>
- en: <st c="15150">At this point, you have just established your first agent tool!</st>
    <st c="15215">This is a search engine tool that your agent can use to retrieve
    more information from the internet to help it achieve its goal of answering the
    question your user poses</st> <st c="15385">to it.</st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15150">到此为止，您已经建立了您的第一个代理工具！</st> <st c="15215">这是一个搜索引擎工具，您的代理可以使用它从互联网上检索更多信息，以帮助它实现回答用户提出的问题的目标。</st>
    <st c="15385">到它。</st>
- en: '<st c="15391">The</st> *<st c="15396">tool</st>* <st c="15400">concept in LangChain</st>
    <st c="15421">and when building agents comes from the idea that you want to make
    actions available to your agent so that it can carry out its tasks.</st> <st c="15557">Tools
    are the mechanism that allows this to happen.</st> <st c="15609">You define a
    tool like we just did for the web search, and then you later add it to a list
    of tools that the agent can use to accomplish its tasks.</st> <st c="15757">Before
    we set up that list though, we want to create another tool that is central for
    a RAG application: a</st> <st c="15864">retriever tool:</st>'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15391">在LangChain</st> *<st c="15396">工具</st>* <st c="15400">概念以及构建代理时，其灵感来源于您希望使动作对代理可用，以便它可以执行其任务。</st>
    <st c="15557">工具是实现这一目标的机制。</st> <st c="15609">您定义一个工具，就像我们刚才为网络搜索所做的那样，然后您稍后将其添加到代理可以用来完成任务的工具列表中。</st>
    <st c="15757">在我们设置该列表之前，我们想要创建另一个对于RAG应用至关重要的工具：一个</st> <st c="15864">检索工具：</st>
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="16164">Note that with the web search</st> <st c="16194">tool, we imported
    it from</st> `<st c="16221">langchain_community.tools.tavily_search</st>`<st c="16260">,
    whereas with this tool, we use</st> `<st c="16293">langchain.tools.retriever</st>`<st
    c="16318">. This reflects the fact that Tavily is a third-party tool, whereas
    the retriever tool we create here is part of the core LangChain functionality.</st>
    <st c="16465">After importing the</st> `<st c="16485">create_retriever_tool</st>`
    <st c="16506">function, we use it to create the</st> `<st c="16541">retriever_tool</st>`
    <st c="16555">tool for our agent.</st> <st c="16576">Again, like with</st> `<st
    c="16593">web_search_name</st>`<st c="16608">, we pull out the</st> `<st c="16626">retriever_tool.name</st>`
    <st c="16645">variable we can reference later when we want to refer to it for
    the agent.</st> <st c="16721">You may notice the name of the actual retriever
    this tool will use, the</st> `<st c="16793">ensemble_retriever</st>` <st c="16811">retriever,
    which we created in</st> [*<st c="16843">Chapter 8</st>*](B22475_08.xhtml#_idTextAnchor152)<st
    c="16852">’s</st> *<st c="16856">8.3</st>* *<st c="16860">code lab</st>*<st c="16868">!</st>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16164">请注意，使用</st> <st c="16194">网络搜索</st> <st c="16221">工具时，我们从</st>
    `<st c="16221">langchain_community.tools.tavily_search</st>`<st c="16260">》导入，而使用这个工具时，我们使用</st>
    `<st c="16293">langchain.tools.retriever</st>`<st c="16318">》。这反映了Tavily是一个第三方工具，而我们在这里创建的检索工具是LangChain核心功能的一部分。</st>
    <st c="16465">导入</st> `<st c="16485">create_retriever_tool</st>` <st c="16506">函数后，我们使用它来创建</st>
    `<st c="16541">retriever_tool</st>` <st c="16555">工具供我们的代理使用。</st> <st c="16576">同样，就像</st>
    `<st c="16593">web_search_name</st>`<st c="16608">》一样，我们提取出</st> `<st c="16626">retriever_tool.name</st>`
    <st c="16645">变量，稍后当我们需要为代理引用它时可以引用。</st> <st c="16721">你可能注意到了这个工具将使用的实际检索器名称，即</st>
    `<st c="16793">ensemble_retriever</st>` <st c="16811">检索器，我们在</st> [*<st c="16843">第8章</st>*](B22475_08.xhtml#_idTextAnchor152)<st
    c="16852">》的</st> *<st c="16856">8.3</st>* *<st c="16860">代码实验室</st>*<st c="16868">》中创建的！</st>
- en: <st c="16869">You should also note that the name that we are giving this tool,
    as far as the agent is concerned, is found in the second field, and we are calling
    it</st> `<st c="17020">retrieve_google_environmental_question_answers</st>`<st
    c="17066">. When we name variables in code, we normally try to keep them smaller,
    but for tools that agents will use, it is helpful to provide more verbose names
    that will help the agent understand what can be</st> <st c="17266">used fully.</st>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16869">你还应该注意，这个工具的名称，从代理的角度来看，位于第二个字段，我们将其命名为</st> `<st c="17020">retrieve_google_environmental_question_answers</st>`<st
    c="17066">》。在代码中命名变量时，我们通常尝试使它们更小，但对于代理将使用的工具，提供更详细的名称有助于代理理解可以使用的内容。</st> <st
    c="17266">完全。</st>
- en: <st c="17277">We now have two tools for our agent!</st> <st c="17315">However,
    we still need to tell the agent about them eventually; so, we package them up
    into a list that we can later share with</st> <st c="17443">the agent:</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17277">我们现在为我们的代理有了两个工具！</st> <st c="17315">然而，我们最终还需要告诉代理关于它们的信息；因此，我们将它们打包成一个列表，稍后我们可以与</st>
    <st c="17443">代理共享：</st>
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="17490">You see here the two tools we created previously, the</st> `<st
    c="17545">web_search</st>` <st c="17555">tool and the</st> `<st c="17569">retriever_tool</st>`
    <st c="17583">tool, getting added to the tools list.</st> <st c="17623">If we
    had other tools we wanted to make available to the agent, we could add those to
    the list as well.</st> <st c="17727">In the LangChain</st> <st c="17743">ecosystem,
    there are hundreds of tools</st> <st c="17783">available:</st> [<st c="17794">https://python.langchain.com/v0.2/docs/integrations/tools/</st>](https://python.langchain.com/v0.2/docs/integrations/tools/)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17490">你在这里可以看到我们之前创建的两个工具，即</st> `<st c="17545">web_search</st>` <st
    c="17555">工具和</st> `<st c="17569">retriever_tool</st>` <st c="17583">工具，被添加到工具列表中。</st>
    <st c="17623">如果我们有其他想要提供给代理的工具，我们也可以将它们添加到列表中。</st> <st c="17727">在LangChain</st>
    <st c="17743">生态系统中有数百种工具</st> <st c="17783">可供使用：</st> [<st c="17794">https://python.langchain.com/v0.2/docs/integrations/tools/</st>](https://python.langchain.com/v0.2/docs/integrations/tools/)
- en: <st c="17852">You will want to make sure the LLM you are using is “good” at
    reasoning and using tools.</st> <st c="17942">In general, chat models tend to
    have been fine-tuned for tool calling and will be better at using tools.</st>
    <st c="18047">Non-chat-fine-tuned models may not be able to use tools, especially
    if the tools are complex or require multiple calls.</st> <st c="18167">Using well-written
    names and descriptions can play an important role in setting your agent LLM up
    for success</st> <st c="18277">as well.</st>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17852">你想要确保你使用的LLM在推理和使用工具方面是“优秀”的。</st> <st c="17942">一般来说，聊天模型通常已经针对工具调用进行了微调，因此在使用工具方面会更好。</st>
    <st c="18047">未针对聊天进行微调的模型可能无法使用工具，尤其是当工具复杂或需要多次调用时。</st> <st c="18167">使用良好的名称和描述可以在为你的代理LLM设定成功方面发挥重要作用。</st>
    <st c="18277">同样。</st>
- en: <st c="18285">In the agent we are building, we have all the tools we need, but
    you will also want to look at the toolkits, which are convenient groups of tools.</st>
    <st c="18433">LangChain provides a list of the current toolkits</st> <st c="18482">available
    on their</st> <st c="18502">website:</st> [<st c="18511">https://python.langchain.com/v0.2/docs/integrations/toolkits/</st>](https://python.langchain.com/v0.2/docs/integrations/toolkits/)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18285">在我们构建的代理中，我们拥有所有需要的工具，但你也会想看看工具包，这些是方便的工具组合。</st> <st c="18433">LangChain在其网站上提供当前可用的工具包列表</st>
    <st c="18482">：</st> [<st c="18511">https://python.langchain.com/v0.2/docs/integrations/toolkits/</st>](https://python.langchain.com/v0.2/docs/integrations/toolkits/)
- en: '<st c="18572">For example, if you have a data infrastructure that uses pandas
    DataFrames, you could use the pandas DataFrame toolkit to offer your agent various
    tools to access those DataFrames in different ways.</st> <st c="18772">Drawing
    straight from the LangChain website, toolkits are described as</st> <st c="18843">follows:
    (</st>[<st c="18853">https://python.langchain.com/v0.1/docs/modules/agents/concepts/#toolkits</st>](https://python.langchain.com/v0.1/docs/modules/agents/concepts/#toolkits)<st
    c="18926">)</st>'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18572">例如，如果你有一个使用pandas DataFrames的数据基础设施，你可以使用pandas DataFrame工具包为你提供各种工具，以不同的方式访问这些DataFrames。</st>
    <st c="18772">直接从LangChain网站引用，工具包被描述如下：</st> <st c="18843">（</st>[<st c="18853">https://python.langchain.com/v0.1/docs/modules/agents/concepts/#toolkits</st>](https://python.langchain.com/v0.1/docs/modules/agents/concepts/#toolkits)<st
    c="18926">）</st>
- en: <st c="18928">For many common tasks, an agent will need a set of related tools.</st>
    <st c="18994">For this LangChain provides the concept of toolkits - groups of
    around 3-5 tools needed to accomplish specific objectives.</st> <st c="19117">For
    example, the GitHub toolkit has a tool for searching through GitHub issues, a
    tool for reading a file, a tool for commenting, etc.</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18928">对于许多常见任务，代理将需要一套相关工具。</st> <st c="18994">为此，LangChain提供了工具包的概念——大约3-5个工具的组合，用于完成特定目标。</st>
    <st c="19117">例如，GitHub工具包包含用于搜索GitHub问题的工具、用于读取文件的工具、用于评论的工具等。</st>
- en: <st c="19251">So, basically, if you are focusing on a set of common tasks for
    your agent or a popular integration partner with LangChain (such as a Salesforce
    integration), there is likely a toolkit that will give you access to all the tools
    you need all</st> <st c="19493">at once.</st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19251">因此，基本上，如果你正在关注你的代理或LangChain（例如Salesforce集成）的一组常见任务，很可能有一个工具包可以让你一次性获得所有需要的工具。</st>
    <st c="19493">对于许多常见任务，代理将需要一套相关工具。</st>
- en: <st c="19501">Now that we have the tools established, let’s start building the
    components of our agent, starting with the</st> <st c="19610">agent state.</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19501">现在我们已经建立了工具，让我们开始构建代理的组件，从</st> <st c="19610">代理状态</st> 开始。
- en: <st c="19622">Agent state</st>
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="19622">代理状态</st>
- en: <st c="19634">The</st> `<st c="19740">AgentState</st>` <st c="19750">class that
    establishes the “state” for your agent and tracks it over time.</st> <st c="19826">This
    state is a local mechanism to the agent that you make available to all parts of
    the graph and can be stored in a</st> <st c="19944">persistence layer.</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19634">用于为你的代理建立“状态”并随时间跟踪的</st> `<st c="19740">AgentState</st>` <st
    c="19750">类。</st> <st c="19826">此状态是代理的本地机制，你可以将其提供给图的所有部分，并可以存储在持久层中。</st>
- en: <st c="19962">Here, we set up this state for our</st> <st c="19998">RAG agent:</st>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19962">在这里，我们为我们的</st> <st c="19998">RAG代理</st> 设置此状态：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="20250">This imports relevant packages for setting up</st> `<st c="20297">AgentState</st>`<st
    c="20307">. For example,</st> `<st c="20322">BaseMessage</st>` <st c="20333">is
    a base class for representing messages in the conversation between the user and
    the AI agent.</st> <st c="20431">It will be used to define the structure and properties
    of messages in the state of the conversation.</st> <st c="20532">It then defines
    a graph and a</st> `<st c="20562">"state"</st>` <st c="20569">object that it passes
    around to each node.</st> <st c="20613">You can set the state to be a variety
    of types of objects that you can store different types of data, but for our RAG
    agent, we set up our state to be a list</st> <st c="20771">of</st> `<st c="20774">"messages"</st>`<st
    c="20784">.</st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20250">这导入设置`<st c="20297">AgentState</st>`<st c="20307">的相关包。例如，`<st
    c="20322">BaseMessage</st>` <st c="20333">是用于表示用户与AI智能体之间对话的消息的基类。</st> <st c="20431">它将用于定义对话状态中消息的结构和属性。</st>
    <st c="20532">然后它定义了一个图和一个`<st c="20562">"state"</st>` <st c="20569">对象，并将其传递给每个节点。</st>
    <st c="20613">您可以设置状态为各种类型的对象，以便存储不同类型的数据，但对我们来说，我们设置我们的状态为一个`<st c="20774">"messages"</st>`<st
    c="20784">列表。</st>
- en: <st c="20785">We then need to import another round of packages to set up other
    parts of</st> <st c="20860">our agent:</st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20785">我们需要导入另一轮包来设置我们的智能体其他部分：</st> <st c="20860">我们的智能体：</st>
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="21022">In this code, we start with importing</st> `<st c="21061">HumanMessage</st>`<st
    c="21073">.</st> `<st c="21075">HumanMessage</st>` <st c="21087">is a specific
    type of message that represents a message sent by the human user.</st> <st c="21168">It
    will used when constructing the prompt for the agent to generate a response.</st>
    <st c="21248">We also import</st> `<st c="21263">BaseModel</st>` <st c="21272">and</st>
    `<st c="21277">Field</st>`<st c="21282">.</st> `<st c="21284">BaseModel</st>`
    <st c="21293">is a class from the</st> `<st c="21314">Pydantic</st>` <st c="21322">library
    that is used to define data models and validate data.</st> `<st c="21385">Field</st>`
    <st c="21390">is a class from</st> `<st c="21407">Pydantic</st>` <st c="21415">that
    is used to define the properties and validation rules for fields in a data model.</st>
    <st c="21503">Last, we import</st> `<st c="21519">tools_condition</st>`<st c="21534">.
    The</st> `<st c="21540">tools_condition</st>` <st c="21555">function is a pre-built
    function provided by the</st> `<st c="21605">LangGraph</st>` <st c="21614">library.</st>
    <st c="21624">It is used to assess the agent’s decision on whether to use specific
    tools based on the current state of</st> <st c="21729">the conversation.</st>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21022">在这段代码中，我们首先导入</st> `<st c="21061">HumanMessage</st>`<st c="21073">。</st>
    `<st c="21075">HumanMessage</st>` <st c="21087">是一种特定的消息类型，代表由人类用户发送的消息。</st>
    <st c="21168">它将在构建智能体生成响应的提示时使用。</st> <st c="21248">我们还导入</st> `<st c="21263">BaseModel</st>`
    <st c="21272">和</st> `<st c="21277">Field</st>`<st c="21282">。</st> `<st c="21284">BaseModel</st>`
    <st c="21293">是来自`<st c="21314">Pydantic</st>` <st c="21322">库的一个类，用于定义数据模型和验证数据。</st>
    `<st c="21385">Field</st>` <st c="21390">是来自`<st c="21407">Pydantic</st>` <st
    c="21415">的一个类，用于定义数据模型中字段的属性和验证规则。</st> <st c="21503">最后，我们导入</st> `<st c="21519">tools_condition</st>`<st
    c="21534">。`<st c="21540">tools_condition</st>` <st c="21555">函数是`<st c="21605">LangGraph</st>`
    <st c="21614">库提供的预构建函数。</st> <st c="21624">它用于根据当前对话状态评估智能体是否使用特定工具的决策。</st>
- en: <st c="21746">These imported classes and</st> <st c="21774">functions are used
    throughout the code to define the structure of messages, validate data, and control
    the flow of the conversation based on the agent’s decisions.</st> <st c="21938">They
    provide the necessary building blocks and utilities for constructing the language
    model application using the</st> `<st c="22053">LangGraph</st>` <st c="22062">library.</st>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21746">这些导入的类和函数在代码中用于定义消息的结构、验证数据和根据智能体的决策控制对话流程。</st> <st c="21938">它们为使用`<st
    c="22053">LangGraph</st>` <st c="22062">库构建语言模型应用程序提供了必要的构建块和实用工具。</st>
- en: <st c="22071">We then define our primary prompt (representing what the user
    would input)</st> <st c="22147">like this:</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22071">然后我们定义我们的主要提示（表示用户会输入的内容）：</st> <st c="22147">如下所示：</st>
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="22550">This is a replacement for the code that we were using in the past</st>
    <st c="22617">code labs:</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22550">这是过去我们在代码实验室中使用的代码的替代品：</st> <st c="22617">代码实验室：</st>
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="22670">We alter the name to</st> `<st c="22692">generation_prompt</st>`
    <st c="22709">to make this prompt’s use</st> <st c="22736">more clear.</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22670">我们将名称更改为</st> `<st c="22692">generation_prompt</st>` <st c="22709">，以使此提示的使用</st>
    <st c="22736">更加清晰。</st>
- en: <st c="22747">Our graph usage is about to pick up in our code, but first, we
    need to cover some basic graph</st> <st c="22842">theory concepts.</st>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22747">我们的代码中的图使用即将增加，但首先，我们需要介绍一些基本的图</st> <st c="22842">理论概念。</st>
- en: <st c="22858">Core concepts of graph theory</st>
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="22858">图论的核心概念</st>
- en: <st c="22888">To better understand how we are going to use LangGraph in the
    next few blocks of code, it is helpful to review some key concepts</st> <st c="23017">in</st>
    **<st c="23021">graph theory</st>**<st c="23033">.</st> **<st c="23035">Graphs</st>**
    <st c="23041">are mathematical</st> <st c="23058">structures that can be used
    to represent relationships between different objects.</st> <st c="23141">The objects
    are</st> <st c="23156">called</st> **<st c="23164">nodes</st>** <st c="23169">and
    the relationships between them, typically drawn</st> <st c="23221">with a line,
    are called</st> **<st c="23246">edges</st>**<st c="23251">. You have already seen
    these concepts in</st> *<st c="23293">Figure 12</st>**<st c="23302">.1</st>*<st
    c="23304">, but it is important to understand how they relate to any graph and
    how that is used</st> <st c="23390">in LangGraph.</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22888">为了更好地理解我们将在接下来的几段代码中使用 LangGraph 的方式，回顾一些</st> <st c="23017">图论</st>
    <st c="23033">中的关键概念是有帮助的。</st> **<st c="23035">图</st>** <st c="23041">是数学</st>
    <st c="23058">结构，可以用来表示不同对象之间的关系。</st> <st c="23141">这些对象被称为</st> **<st c="23164">节点</st>**
    <st c="23169">，它们之间的关系，通常用线表示，被称为</st> **<st c="23246">边</st>**<st c="23251">。您已经在
    *<st c="23293">图 12</st>**<st c="23302">.1</st>*<st c="23304"> 中看到了这些概念，但了解它们如何与任何图相关联以及如何在
    LangGraph 中使用它们是很重要的。</st>
- en: <st c="23403">With LangGraph, there are also specific types of edges representing
    different types of these relationships.</st> <st c="23512">The “conditional edge”
    that we mentioned along with</st> *<st c="23564">Figure 12</st>**<st c="23573">.1</st>*<st
    c="23575">, for example, represents when you need to make a decision about which
    node you should go to next; so, they represent the decisions.</st> <st c="23708">When
    talking about the ReAct paradigm, this has also been called</st> <st c="23772">the</st>
    **<st c="23777">action edge</st>**<st c="23788">, as it is where the action takes
    place, relating to the</st> *<st c="23845">reason + action</st>* <st c="23860">approach
    of ReAct.</st> *<st c="23880">Figure 12</st>**<st c="23889">.3</st>* <st c="23891">shows
    a basic graph consisting of nodes</st> <st c="23932">and edges:</st>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23403">在 LangGraph 中，也有表示这些关系不同类型的特定类型的边。</st> <st c="23512">例如，与 *<st
    c="23564">图 12</st>**<st c="23573">.1</st>*<st c="23575"> 一起提到的“条件边”，表示您需要决定下一步应该访问哪个节点；因此，它们代表决策。</st>
    <st c="23708">在讨论 ReAct 范式时，这也被称为</st> <st c="23772">**<st c="23777">动作边</st>**<st
    c="23788">**，因为它是在动作发生的地方，与 ReAct 的</st> *<st c="23845">原因 + 动作</st>** <st c="23860">方法相关。</st>
    *<st c="23880">图 12</st>**<st c="23889">.3</st>* <st c="23891">显示了由节点</st> <st
    c="23932">和边组成的</st> 基本图：</st>
- en: '![Figure 12.3 – Basic graph representing our RAG application](img/B22475_12_03.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3 – 表示我们 RAG 应用基本图的图形](img/B22475_12_03.jpg)'
- en: <st c="23955">Figure 12.3 – Basic graph representing our RAG application</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23955">图 12.3 – 表示我们 RAG 应用基本图的图形</st>
- en: <st c="24013">In this cyclical graph shown in</st> *<st c="24046">Figure 12</st>**<st
    c="24055">.3</st>*<st c="24057">, you see nodes representing the start, agent,
    retrieve tool, generation, observation, and end.</st> <st c="24153">The key edges
    are where the LLM makes the decision of what tool to use (retrieve is the only
    one available here), observes if what is retrieved is sufficient, and then pushes
    to generation.</st> <st c="24343">If it is decided that the retrieved data is
    not sufficient, there is an edge that sends the observation back to the agent
    to decide if it wants to try again.</st> <st c="24501">These decision points are
    the</st> *<st c="24531">conditional edges</st>* <st c="24548">we discussed.</st>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24013">如图 <st c="24046">图 12</st>**<st c="24055">.3</st>*<st c="24057">
    所示的循环图中，您可以看到代表开始、代理、检索工具、生成、观察和结束的节点。</st> <st c="24153">关键边是 LLM 决定使用哪个工具（这里只有检索可用），观察检索到的信息是否足够，然后推动到生成。</st>
    <st c="24343">如果决定检索到的数据不足，有一条边将观察结果发送回代理，以决定是否再次尝试。</st> <st c="24501">这些决策点是我们讨论的</st>
    *<st c="24531">条件边</st>* <st c="24548">。</st>
- en: <st c="24562">Nodes and edges in our agent</st>
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="24562">我们的智能体中的节点和边</st>
- en: '<st c="24591">OK, so let’s</st> <st c="24604">review.</st> <st c="24613">We’ve
    mentioned that an agentic RAG graph has three key components: the</st> *<st c="24685">state</st>*
    <st c="24690">that we already talked about, the</st> *<st c="24725">nodes</st>*
    <st c="24730">that append to or update the</st> <st c="24760">state, and the</st>
    *<st c="24775">conditional edges</st>* <st c="24792">that decide which node to
    visit next.</st> <st c="24831">We are now to the point where we can step through
    each of these in code blocks, seeing how the three components interact with</st>
    <st c="24957">each other.</st>'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24591">好的，让我们</st> <st c="24604">回顾一下。</st> <st c="24613">我们提到，一个代理RAG图有三个关键组件：我们之前提到的</st>
    *<st c="24685">状态</st>* <st c="24690">，添加到或更新状态的</st> *<st c="24725">节点</st> <st
    c="24730">，以及决定下一个要访问哪个节点的</st> *<st c="24775">条件边</st>* <st c="24792">。</st>
    <st c="24831">我们现在已经到了可以逐个在代码块中逐步通过这些组件，看到这三个组件如何相互作用的程度。</st>
- en: <st c="24968">Given this background, the first thing we will add to the code
    is the conditional edge, where the decisions are made.</st> <st c="25087">In this
    case, we are going to define an edge that determines if the retrieved documents
    are relevant to the question.</st> <st c="25205">This is the function that will
    decide whether to move on to the generation stage or to go back and</st> <st c="25304">try
    again:</st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24968">基于这个背景，我们将首先向代码中添加条件边，这是决策的地方。</st> <st c="25087">在这种情况下，我们将定义一个边，以确定检索到的文档是否与问题相关。</st>
    <st c="25205">这是将决定是否进入生成阶段或返回并</st> <st c="25304">重试的函数：</st>
- en: <st c="25314">We will step through this code in multiple steps, but keep in
    mind that this is one large function, starting with</st> <st c="25429">the definition:</st>
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="25314">我们将分多步逐步通过此代码，但请记住，这是一个大函数，从</st> <st c="25429">定义</st>开始：</st>
- en: '[PRE15]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: <st c="25507">This code starts by defining a function called</st> `<st c="25555">score_documents</st>`
    <st c="25570">that determines whether the retrieved documents are relevant to
    the given question.</st> <st c="25655">The function takes the state we’ve been
    discussing as a parameter, which is a set of messages that have been collected.</st>
    <st c="25775">This is how we make the state</st> `<st c="25805">available</st>`
    <st c="25814">to this conditional</st> <st c="25835">edge function.</st>
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="25507">此代码首先定义了一个名为</st> `<st c="25555">score_documents</st>` <st c="25570">的函数，该函数确定检索到的文档是否与给定问题相关。</st>
    <st c="25655">该函数接受我们一直在讨论的状态作为参数，这是一个收集到的消息集合。</st> <st c="25775">这就是我们使状态</st>
    `<st c="25805">可用</st>` <st c="25814">于此条件</st> <st c="25835">边函数</st>的方式。
- en: <st c="25849">Now, we build the</st> <st c="25868">data model:</st>
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="25849">现在，我们构建</st> <st c="25868">数据模型：</st>
- en: '[PRE17]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <st c="25977">This defines a data model class called</st> `<st c="26017">scoring</st>`
    <st c="26024">using</st> `<st c="26031">Pydantic</st>`<st c="26039">’s</st> `<st
    c="26043">BaseModel</st>`<st c="26052">. The</st> `<st c="26058">scoring</st>`
    <st c="26065">class has a single field called</st> `<st c="26098">binary_score</st>`<st
    c="26110">, which is a string representing the relevance score as either</st>
    `<st c="26173">yes</st>` <st c="26176">or</st> `<st c="26180">no</st>`<st c="26182">.</st>
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="25977">这定义了一个名为</st> `<st c="26017">scoring</st>` <st c="26024">的数据模型类，使用</st>
    `<st c="26031">Pydantic</st>`<st c="26039">的</st> `<st c="26043">BaseModel</st>`<st
    c="26052">。`<st c="26058">scoring</st>` <st c="26065">类有一个名为</st> `<st c="26098">binary_score</st>`<st
    c="26110">的单个字段，它是一个表示相关性得分的字符串，可以是</st> `<st c="26173">是</st>` <st c="26176">或</st>
    `<st c="26180">否</st>`<st c="26182">。</st>
- en: <st c="26183">Next, we add the LLM that will make</st> <st c="26220">this decision:</st>
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="26183">接下来，我们添加将做出此决定的LLM：</st>
- en: '[PRE20]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <st c="26287">This creates an instance of</st> `<st c="26316">llm_with_tool</st>`
    <st c="26329">by calling</st> `<st c="26341">llm.with_structured_output(scoring)</st>`<st
    c="26376">, combining the LLM with the scoring data model for structured</st>
    <st c="26439">output validation.</st>
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="26287">这通过调用</st> `<st c="26316">llm_with_tool</st>` <st c="26329">并使用</st>
    `<st c="26341">llm.with_structured_output(scoring)</st>`<st c="26376">创建了一个实例，将LLM与评分数据模型结合用于结构化</st>
    <st c="26439">输出验证。</st>
- en: <st c="26457">As we have</st> <st c="26468">seen in the past, we need to set
    up a</st> `<st c="26507">PromptTemplate</st>` <st c="26521">class to pass to the</st>
    <st c="26543">LLM.</st> <st c="26548">Here is</st> <st c="26556">that prompt:</st>
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="26457">正如我们过去所看到的，我们需要设置一个</st> `<st c="26507">PromptTemplate</st>` <st
    c="26521">类，并将其传递给</st> <st c="26543">LLM。</st> <st c="26548">以下是</st> <st c="26556">该提示：</st>
- en: '[PRE22]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: <st c="27034">This defines a prompt using the</st> `<st c="27066">PromptTemplate</st>`
    <st c="27080">class, providing instructions to the LLM for applying a binary score
    for the relevance of the retrieved document based on the</st> <st c="27207">given
    question.</st>
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="27034">这使用</st> `<st c="27066">PromptTemplate</st>` <st c="27080">类定义了一个提示，为LLM提供根据给定问题对检索到的文档的相关性应用二进制评分的说明。</st>
- en: <st c="27222">We can then use LCEL to build the chain that combines the prompt
    with the</st> `<st c="27297">llm_with_tool</st>` <st c="27310">tool we just</st>
    <st c="27324">set up:</st>
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="27222">然后我们可以使用LCEL构建一个链，将提示与刚刚</st> `<st c="27297">llm_with_tool</st>`
    <st c="27310">设置的工具</st> `<st c="27324">结合：</st>
- en: '[PRE29]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: <st c="27362">This chain represents the pipeline for scoring the documents.</st>
    <st c="27425">This defines the chain, but we haven’t invoked</st> <st c="27472">it
    yet.</st>
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="27362">这个链表示了评分文档的管道。</st> <st c="27425">这定义了链，但我们还没有调用</st> <st c="27472">它。</st>
- en: <st c="27479">First, we want to</st> <st c="27498">pull in the state.</st> <st
    c="27517">Next, we pull the state (</st>`<st c="27542">"messages"</st>`<st c="27553">)
    into the</st> <st c="27564">function so that we can use it, and we take the</st>
    <st c="27613">last message:</st>
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="27479">首先，我们想要</st> <st c="27498">获取状态。</st> <st c="27517">接下来，我们将状态（</st>`<st
    c="27542">"messages"</st>`<st c="27553">）拉入函数中，以便我们可以使用它，并取最后一条</st> <st c="27613">消息：</st>
- en: '[PRE30]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: <st c="27742">This extracts the necessary information from the</st> `<st c="27792">"state"</st>`
    <st c="27799">parameter and then preps the state/message as the context we are
    going to pass to our agent brain (LLM).</st> <st c="27905">The specific components
    extracted here include</st> <st c="27952">the following:</st>
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="27742">这从</st> `<st c="27792">"state"</st>` <st c="27799">参数中提取必要的信息，然后准备状态/消息作为我们将传递给我们的智能大脑（LLM）的上下文。</st>
    <st c="27905">这里提取的具体组件包括</st> <st c="27952">以下内容：</st>
- en: '`<st c="27966">messages</st>`<st c="27975">: The list of messages in</st> <st
    c="28002">the conversation</st>'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="27966">messages</st>`<st c="27975">: 对话中的消息列表</st>'
- en: '`<st c="28018">last_message</st>`<st c="28031">: The last message in</st> <st
    c="28054">the conversation</st>'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="28018">last_message</st>`<st c="28031">: 对话中的最后一条消息</st>'
- en: '`<st c="28070">question</st>`<st c="28079">: The content of the first message,
    which is assumed to be the</st> <st c="28143">user’s question</st>'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="28070">question</st>`<st c="28079">: 第一条消息的内容，假设它是</st> <st c="28143">用户的问题</st>'
- en: '`<st c="28158">docs</st>`<st c="28163">: The content of the last message, which
    is assumed to be the</st> <st c="28226">retrieved documents</st>'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="28158">docs</st>`<st c="28163">: 最后一条消息的内容，假设它是</st> <st c="28226">检索到的文档</st>'
- en: <st c="28245">Then, finally, we invoke the chain with the prompt filled (if
    you remember, we call this</st> `<st c="28362">question</st>` <st c="28370">and
    context</st> `<st c="28383">docs</st>` <st c="28387">to get the</st> <st c="28399">scored
    result:</st>
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="28245">然后，最后，我们使用填充的提示调用链（如果你还记得，我们称之为</st> `<st c="28362">question</st>`
    <st c="28370">和上下文</st> `<st c="28383">docs</st>` <st c="28387">以获取</st> <st c="28399">评分结果：</st>
- en: '[PRE34]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: <st c="28518">This extracts</st> <st c="28532">the</st> `<st c="28537">binary_score</st>`
    <st c="28549">variable from the</st> `<st c="28568">scored_result</st>` <st c="28581">object
    and assigns it to the</st> `<st c="28611">score</st>` <st c="28616">variable.</st>
    <st c="28627">The</st> `<st c="28631">llm_with_tool</st>` <st c="28644">step,
    which</st> <st c="28656">is the last step in the LangChain chain, aptly called</st>
    `<st c="28711">chain</st>`<st c="28716">, is going to return a string-based binary
    result based on the response from the</st> <st c="28797">scoring function:</st>
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="28518">这从</st> <st c="28532">`<st c="28537">binary_score</st>`</st> <st
    c="28549">变量从</st> `<st c="28568">scored_result</st>` <st c="28581">对象中提取，并将其分配给</st>
    `<st c="28611">score</st>` <st c="28616">变量。</st> <st c="28627">`<st c="28631">llm_with_tool</st>`</st>
    <st c="28644">步骤，这是LangChain链中的最后一步，恰当地称为</st> `<st c="28711">chain</st>`<st c="28716">，将根据评分函数的响应返回基于字符串的二进制结果：</st>
- en: '[PRE37]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: <st c="28969">This checks the value of the score.</st> <st c="29006">If the</st>
    `<st c="29013">score</st>` <st c="29018">value is</st> `<st c="29028">yes</st>`<st
    c="29031">, it prints a message indicating that the documents are relevant and
    returns</st> `<st c="29108">generate</st>` <st c="29116">as the final output from
    the</st> `<st c="29146">score_documents</st>` <st c="29161">function, suggesting
    that the next step is to generate a response.</st> <st c="29229">If the</st> `<st
    c="29236">score</st>` <st c="29241">value is</st> `<st c="29251">no</st>`<st c="29253">,
    or, technically, anything other than</st> `<st c="29292">yes</st>`<st c="29295">,
    it prints messages indicating that the documents are not relevant and returns</st>
    `<st c="29375">improve</st>`<st c="29382">, suggesting that the next step is to
    improve the query from</st> <st c="29443">the user.</st>
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="28969">这检查得分的值。</st> <st c="29006">如果</st> `<st c="29013">得分</st>` <st
    c="29018">值是</st> `<st c="29028">是</st>`<st c="29031">，它将打印一条消息，表明文档是相关的，并从</st>
    `<st c="29108">generate</st>` <st c="29116">函数返回作为最终输出，这表明下一步是生成一个响应。</st> <st
    c="29229">如果</st> `<st c="29236">得分</st>` <st c="29241">值是</st> `<st c="29251">否</st>`<st
    c="29253">，或者技术上讲，任何不是</st> `<st c="29292">是</st>`<st c="29295">的东西，它将打印消息表明文档是不相关的，并返回</st>
    `<st c="29375">改进</st>`<st c="29382">，这表明下一步是从</st> `<st c="29443">用户</st>` `<st
    c="29443">那里改进查询。</st>
- en: <st c="29452">Overall, this function acts as a decision point in the workflow,
    determining whether the retrieved documents are relevant to the question and directing
    the flow to either generate a response or rewrite the question based on the</st>
    <st c="29681">relevance score.</st>
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="29452">总的来说，这个函数在工作流程中充当决策点，确定检索到的文档是否与问题相关，并根据相关性得分将流程导向生成响应或重写问题。</st>
    <st c="29681">的。</st>
- en: <st c="29697">Now that we</st> <st c="29709">have our conditional edge defined,
    we are going to move on to</st> <st c="29772">defining our nodes, starting with</st>
    <st c="29806">the agent:</st>
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="29697">现在我们已经定义了我们的条件边，我们将继续定义我们的节点，从</st> <st c="29772">代理</st> `<st
    c="29806">开始：</st>
- en: '[PRE44]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: <st c="29981">This function represents the agent node on our graph and invokes
    the agent model to generate a response based on the current state.</st> <st c="30114">The</st>
    `<st c="30118">agent</st>` <st c="30123">function takes the current state (</st>`<st
    c="30158">"state"</st>`<st c="30166">) as input, which contains the messages in
    the conversation, prints a message indicating that it is calling the agent, extracts
    the messages from the state dictionary, uses the</st> `<st c="30344">agent_llm</st>`
    <st c="30353">instance of the</st> `<st c="30370">ChatOpenAI</st>` <st c="30380">class
    we defined earlier, representing the agent</st> *<st c="30430">brain</st>*<st
    c="30435">, and then binds the tools to the model using the</st> `<st c="30485">bind_tools</st>`
    <st c="30495">method.</st> <st c="30504">We then invoke the agent’s</st> `<st
    c="30531">llm</st>` <st c="30534">instance with the messages and assign the result
    to the</st> `<st c="30591">response</st>` <st c="30599">variable.</st>
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="29981">这个函数代表我们图上的代理节点，并调用代理模型根据当前状态生成响应。</st> <st c="30114">代理</st>
    `<st c="30118">函数接受当前状态（</st>`<st c="30158">"状态"</st>`<st c="30166">）作为输入，其中包含对话中的消息，打印一条消息表明它正在调用代理，从状态字典中提取消息，使用</st>
    `<st c="30344">agent_llm</st>` <st c="30353">实例的</st> `<st c="30370">ChatOpenAI</st>`
    <st c="30380">类，我们之前定义的，代表代理的</st> *<st c="30430">大脑</st>*<st c="30435">，然后使用</st>
    `<st c="30485">bind_tools</st>` <st c="30495">方法将工具绑定到模型。</st> <st c="30504">然后我们调用代理的</st>
    `<st c="30531">llm</st>` <st c="30534">实例，将消息传递给它，并将结果赋值给</st> `<st c="30591">response</st>`
    <st c="30599">变量。</st>
- en: <st c="30609">Our next node,</st> `<st c="30625">improve</st>`<st c="30632">,
    is responsible for transforming</st> `<st c="30666">user_query</st>` <st c="30676">to
    produce a better question if the agent determines this</st> <st c="30735">is needed:</st>
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="30609">我们的下一个节点</st> `<st c="30625">改进</st>`<st c="30632">，负责将</st> `<st
    c="30666">用户查询</st>` <st c="30676">转换为更好的问题，如果代理确定这是必需的：</st>
- en: '[PRE50]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: <st c="31148">This function, like all</st> <st c="31173">of our node and edge-related
    functions, takes the</st> <st c="31222">current state (</st>`<st c="31238">"state"</st>`<st
    c="31246">) as input.</st> <st c="31259">The function returns a dictionary with
    the response appended to the messages list.</st> <st c="31342">The function prints
    a message indicating that it is transforming the query, extracts the messages
    from the state dictionary, retrieves the content of the first message (</st>`<st
    c="31511">messages[0].content</st>`<st c="31531">), which is assumed to be the
    initial question, and assigns it to the</st> `<st c="31602">question</st>` <st
    c="31610">variable.</st> <st c="31621">We then set up a message using the</st>
    `<st c="31656">HumanMessage</st>` <st c="31668">class, indicating that we want
    the</st> `<st c="31704">llm</st>` <st c="31707">instance to reason about the underlying
    semantic intent of the question and formulate an improved question.</st> <st c="31816">The
    result from the</st> `<st c="31836">llm</st>` <st c="31839">instance is assigned
    to the</st> `<st c="31868">response</st>` <st c="31876">variable.</st> <st c="31887">Finally,
    it returns a dictionary with the response appended to the</st> <st c="31954">messages
    list.</st>
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="31148">此函数，就像我们所有的</st> <st c="31173">节点和边相关函数一样，接受</st> <st c="31222">当前状态（</st>`<st
    c="31238">"状态"</st>`<st c="31246">）作为输入。</st> <st c="31259">该函数返回一个字典，其中将响应附加到消息列表中。</st>
    <st c="31342">该函数打印一条消息表示正在转换查询，从状态字典中提取消息，检索第一条消息的内容（</st>`<st c="31511">messages[0].content</st>`<st
    c="31531">），假设它是初始问题，并将其分配给</st> `<st c="31602">问题</st>` <st c="31610">变量。</st>
    <st c="31621">然后我们使用</st> `<st c="31656">HumanMessage</st>` <st c="31668">类设置一条消息，表示我们希望</st>
    `<st c="31704">llm</st>` <st c="31707">实例推理问题的潜在语义意图并制定一个改进的问题。</st> <st c="31816">来自</st>
    `<st c="31836">llm</st>` <st c="31839">实例的结果分配给</st> `<st c="31868">响应</st>` <st
    c="31876">变量。</st> <st c="31887">最后，它返回一个字典，其中将响应附加到</st> `<st c="31954">消息列表</st>`。</st>
- en: <st c="31968">Our next node function is the</st> `<st c="31999">generate</st>`
    <st c="32007">function:</st>
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="31968">我们的下一个节点函数是</st> `<st c="31999">generate</st>` <st c="32007">函数：</st>
- en: '[PRE69]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: <st c="32366">This function is</st> <st c="32384">similar to our generation
    step in the previous chapter’s code</st> <st c="32446">labs but simplified to
    provide just the response.</st> <st c="32496">It generates an answer based on
    the retrieved documents and the question.</st> <st c="32570">The function takes
    the current state (</st>`<st c="32608">"state"</st>`<st c="32616">) as input,
    which contains the messages in the conversation, prints a message indicating that
    it is generating an answer, extracts the messages from the state dictionary, retrieves
    the content of the first message (</st>`<st c="32832">messages[0].content</st>`<st
    c="32852">), which is assumed to be the question, and assigns it to the</st> `<st
    c="32915">question</st>` <st c="32923">variable.</st>
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="32366">此函数</st> <st c="32384">类似于上一章代码中的生成步骤</st> <st c="32446">实验室，但简化了以仅提供响应。</st>
    <st c="32496">它基于检索到的文档和问题生成一个答案。</st> <st c="32570">该函数接受当前状态（</st>`<st c="32608">"状态"</st>`<st
    c="32616">）作为输入，其中包含对话中的消息，打印一条消息表示正在生成答案，从状态字典中提取消息，检索第一条消息的内容（</st>`<st c="32832">messages[0].content</st>`<st
    c="32852">），假设它是问题，并将其分配给</st> `<st c="32915">问题</st>` <st c="32923">变量。</st>
- en: <st c="32933">The function then retrieves the last message (</st>`<st c="32980">messages[-1]</st>`<st
    c="32993">) and assigns it to the</st> `<st c="33018">last_message</st>` <st c="33030">variable.</st>
    <st c="33041">The</st> `<st c="33045">docs</st>` <st c="33049">variable is assigned
    the content of</st> `<st c="33086">last_message</st>`<st c="33098">, which is
    assumed to be the retrieved documents.</st> <st c="33148">At this point, we create
    a chain called</st> `<st c="33188">rag_chain</st>` <st c="33197">by combining
    the</st> `<st c="33215">generation_prompt</st>`<st c="33232">,</st> `<st c="33234">llm</st>`<st
    c="33237">, and</st> `<st c="33243">str_output_parser</st>` <st c="33260">variables
    using the</st> `<st c="33281">|</st>` <st c="33282">operator.</st> <st c="33293">As
    with other LLM prompting, we hydrate the predefined</st> `<st c="33348">generation_prompt</st>`
    <st c="33365">as the prompt for generating the answer, which returns a</st> <st
    c="33422">dictionary</st> <st c="33434">with the</st> `<st c="33443">response</st>`
    <st c="33451">variable appended to the</st> `<st c="33477">messages</st>` <st
    c="33485">list.</st>
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="32933">该函数随后检索最后一条消息（</st>`<st c="32980">messages[-1]</st>`<st c="32993">）并将其分配给</st>
    `<st c="33018">last_message</st>` <st c="33030">变量。</st> <st c="33041">`<st c="33045">docs</st>`
    <st c="33049">变量被分配给`<st c="33086">last_message</st>`<st c="33098">的内容，假设这是检索到的文档。</st>
    <st c="33148">在此阶段，我们通过使用`<st c="33281">|</st>` <st c="33282">操作符</st>组合`<st c="33215">generation_prompt</st>`<st
    c="33232">`、`<st c="33234">llm</st>`<st c="33237">`和`<st c="33243">str_output_parser</st>`
    <st c="33260">变量来创建一个名为`<st c="33188">rag_chain</st>` <st c="33197">的链。</st> <st
    c="33293">与其他 LLM 提示一样，我们将预定义的`<st c="33348">generation_prompt</st>` <st c="33365">作为生成答案的提示，它返回一个包含`<st
    c="33443">response</st>` <st c="33451">变量并附加到`<st c="33477">messages</st>` <st
    c="33485">列表中的字典。</st>
- en: <st c="33491">Next, we want to set up our cyclical graphs using LangGraph and
    assign our nodes and edges</st> <st c="33583">to them.</st>
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33491">接下来，我们想要使用 LangGraph 设置我们的循环图，并将我们的节点和边</st> <st c="33583">分配给它们。</st>
- en: <st c="33591">Cyclical graph setup</st>
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="33591">循环图设置</st>
- en: <st c="33612">The next</st> <st c="33622">big step in our code</st> <st c="33643">is
    setting up our graphs</st> <st c="33668">using LangGraph:</st>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33612">我们代码中的下一个</st> <st c="33622">大步骤是使用 LangGraph</st> <st c="33643">设置我们的图</st>
    <st c="33668">：</st>
- en: <st c="33684">First, we import some important packages to get</st> <st c="33733">us
    started:</st>
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="33684">首先，我们导入一些重要的包以开始：</st> <st c="33733">：</st>
- en: '[PRE81]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: <st c="33828">This code imports the following necessary classes and functions
    from the</st> `<st c="33902">langgraph</st>` <st c="33911">library:</st>
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="33828">此代码从</st> `<st c="33902">langgraph</st>` <st c="33911">库中导入以下必要的类和函数：</st>
- en: '`<st c="33920">END</st>`<st c="33924">: A special node representing the end
    of</st> <st c="33966">the workflow</st>'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="33920">END</st>`<st c="33924">: 表示工作流程结束的特殊节点</st> <st c="33966">的</st>'
- en: '`<st c="33978">StateGraph</st>`<st c="33989">: A class for defining the state
    graph of</st> <st c="34032">the workflow</st>'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="33978">StateGraph</st>`<st c="33989">: 用于定义工作流程</st> <st c="34032">的状态图的类</st>'
- en: '`<st c="34044">ToolNode</st>`<st c="34053">: A class for defining a node that
    represents a tool</st> <st c="34107">or action</st>'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="34044">ToolNode</st>`<st c="34053">: 用于定义表示工具</st> <st c="34107">或动作</st>的节点的类'
- en: <st c="34116">We then pass</st> `<st c="34130">AgentState</st>` <st c="34140">as
    an argument to the</st> `<st c="34163">StateGraph</st>` <st c="34173">class we
    just imported for defining the state graph of</st> <st c="34229">the workflow:</st>
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="34116">然后，我们将</st> `<st c="34130">AgentState</st>` <st c="34140">作为参数传递给</st>
    `<st c="34163">StateGraph</st>` <st c="34173">类，我们刚刚导入它来定义工作流程</st> <st c="34229">的状态图：</st>
- en: '[PRE83]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: <st c="34276">This creates a new instance of</st> `<st c="34308">StateGraph</st>`
    <st c="34318">called</st> `<st c="34326">workflow</st>` <st c="34334">and defines
    a new graph for that</st> `<st c="34368">workflow</st>` `<st c="34376">StateGraph</st>`
    <st c="34387">instance.</st>
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="34276">这创建了一个名为</st> `<st c="34326">workflow</st>` <st c="34334">的新</st>
    `<st c="34308">StateGraph</st>` <st c="34318">实例</st> <st c="34334">，并为该</st>
    `<st c="34368">工作流程</st>` `<st c="34376">StateGraph</st>` <st c="34387">实例</st>定义了一个新的图。</st>
- en: <st c="34397">Next, we define the nodes we will cycle between and assign our
    node functions</st> <st c="34476">to them:</st>
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="34397">接下来，我们定义我们将循环的节点，并将我们的节点函数</st> <st c="34476">分配给它们：</st>
- en: '[PRE84]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: <st c="34820">This code adds</st> <st c="34836">multiple nodes to the</st> `<st
    c="34858">workflow</st>` <st c="34866">instance</st> <st c="34876">using the</st>
    `<st c="34886">add_node</st>` <st c="34894">method:</st>
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="34820">此代码使用</st> `<st c="34886">add_node</st>` <st c="34894">方法</st>
    <st c="34836">将多个节点添加到</st> `<st c="34858">工作流程</st>` <st c="34866">实例</st> <st
    c="34876">中：</st>
- en: '`<st c="34902">"agent"</st>`<st c="34910">: This node represents the agent
    node, which invokes the</st> <st c="34968">agent function.</st>'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="34902">"agent"</st>`<st c="34910">：此节点代表代理节点，它调用</st> <st c="34968">agent函数。</st>'
- en: '`<st c="34983">"retrieve"</st>`<st c="34994">: This node represents the retrieval
    node, which is a special</st> `<st c="35057">ToolNode</st>` <st c="35065">containing
    the tools list we defined early with the</st> `<st c="35118">web_search</st>`
    <st c="35128">and</st> `<st c="35133">retriever_tool</st>` <st c="35147">tools.</st>
    <st c="35155">In this code, to aid in readability, we explicitly break out the</st>
    `<st c="35220">ToolNode</st>` <st c="35228">class instance and define the</st>
    `<st c="35259">retrieve</st>` <st c="35267">variable with it, which indicates
    the “retrieve” focus of this node more explicitly.</st> <st c="35353">We then
    pass that</st> `<st c="35371">retrieve</st>` <st c="35379">variable into the</st>
    `<st c="35398">add_node</st>` <st c="35406">function.</st>'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="34983">"retrieve"</st>`<st c="34994">：此节点代表检索节点，它是一个特殊的</st> `<st c="35057">ToolNode</st>`
    <st c="35065">，包含我们早期定义的工具列表，包括</st> `<st c="35118">web_search</st>` <st c="35128">和</st>
    `<st c="35133">retriever_tool</st>` <st c="35147">工具。</st> <st c="35155">在此代码中，为了提高可读性，我们明确地分离出</st>
    `<st c="35220">ToolNode</st>` <st c="35228">类实例，并使用它定义了</st> `<st c="35259">retrieve</st>`
    <st c="35267">变量，这更明确地表示了此节点的“检索”焦点。</st> <st c="35353">然后我们将该</st> `<st c="35371">retrieve</st>`
    <st c="35379">变量传递给</st> `<st c="35398">add_node</st>` <st c="35406">函数。</st>'
- en: '`<st c="35416">"improve"</st>`<st c="35426">: This node represents the node
    for improving the question, which invokes the</st> `<st c="35505">improve</st>`
    <st c="35512">function.</st>'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="35416">"improve"</st>`<st c="35426">：此节点代表改进问题的节点，它调用</st> `<st c="35505">improve</st>`
    <st c="35512">函数。</st>'
- en: '`<st c="35522">"generate"</st>`<st c="35533">: This node represents the node
    for generating a response, which invokes the</st> `<st c="35611">generate</st>`
    <st c="35619">function.</st>'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="35522">"generate"</st>`<st c="35533">：此节点代表生成响应的节点，它调用</st> `<st c="35611">generate</st>`
    <st c="35619">函数。</st>'
- en: <st c="35629">Next, we need to define our starting point for</st> <st c="35677">our
    workflow:</st>
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="35629">接下来，我们需要定义我们的工作流</st> <st c="35677">的起点：</st>
- en: '[PRE91]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: <st c="35724">This sets the entry point of the</st> `<st c="35758">workflow</st>`
    <st c="35766">instance to the</st> `<st c="35783">"agent"</st>` <st c="35790">node</st>
    <st c="35796">using</st> `<st c="35802">workflow.set_entry_point("agent")</st>`<st
    c="35835">.</st>
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35724">这设置了</st> `<st c="35758">工作流</st>` <st c="35766">实例的</st> `<st
    c="35783">"agent"</st>` <st c="35790">节点</st> <st c="35796">使用</st> `<st c="35802">workflow.set_entry_point("agent")</st>`<st
    c="35835">.</st>
- en: <st c="35836">Next, we call the</st> `<st c="35855">"agent"</st>` <st c="35862">node
    to decide whether to retrieve</st> <st c="35898">or not:</st>
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="35836">接下来，我们调用</st> `<st c="35855">"agent"</st>` <st c="35862">节点来决定是否检索</st>
    <st c="35898">：</st>
- en: '[PRE92]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '<st c="36000">In this code,</st> `<st c="36014">tools_condition</st>` <st c="36029">is
    used as a conditional edge in the workflow graph.</st> <st c="36083">It determines
    whether the agent should proceed to the retrieval step (</st>`<st c="36153">"tools":
    "retrieve"</st>`<st c="36173">) or end the conversation (</st>`<st c="36201">END:
    END</st>`<st c="36210">) based on the agent’s decision.</st> <st c="36244">The
    retrieval step represents both of the tools that we made available for the agent
    to use where needed, and the other option, to end the conversation simply ends</st>
    <st c="36408">the workflow.</st>'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '<st c="36000">在此代码中，</st> `<st c="36014">tools_condition</st>` <st c="36029">被用作工作流程图中的条件边。</st>
    <st c="36083">它根据代理的决定确定代理是否应继续到检索步骤（</st>`<st c="36153">"tools": "retrieve"</st>`<st
    c="36173">）或结束对话（</st>`<st c="36201">END: END</st>`<st c="36210">）。</st> <st c="36244">检索步骤代表我们为代理提供的两个工具，供其按需使用，而另一个选项，简单地结束对话，则结束</st>
    <st c="36408">工作流程。</st>'
- en: <st c="36421">Here, we add more</st> <st c="36440">edges, which are used</st>
    <st c="36462">after the</st> `<st c="36472">"action"</st>` <st c="36480">node</st>
    <st c="36486">is called:</st>
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="36421">在此，我们添加更多</st> <st c="36440">边，这些边在调用</st> `<st c="36472">"action"</st>`
    <st c="36480">节点</st> <st c="36486">之后使用：</st>
- en: '[PRE98]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: <st c="36629">After the</st> `<st c="36640">"retrieve"</st>` <st c="36650">node
    is called, it adds conditional edges using</st> `<st c="36699">workflow.add_conditional_edges("retrieve",
    score_documents)</st>`<st c="36758">. This assesses the retrieved documents using
    the</st> `<st c="36808">score_documents</st>` <st c="36823">function and determines
    the next node based on the score.</st> <st c="36882">This also adds an edge from
    the</st> `<st c="36914">"generate"</st>` <st c="36924">node to the</st> `<st c="36937">END</st>`
    <st c="36940">node using</st> `<st c="36952">workflow.add_edge("generate", END)</st>`<st
    c="36986">. This indicates that, after generating a response, the workflow ends.</st>
    <st c="37057">Last, this adds an edge from the</st> `<st c="37090">"improve"</st>`
    <st c="37099">node back to the</st> `<st c="37117">"agent"</st>` <st c="37124">node
    using</st> `<st c="37136">workflow.add_edge("improve", "agent")</st>`<st c="37173">.
    This creates a loop where the improved question is sent back to the agent for</st>
    <st c="37253">further processing.</st>
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在调用 `<st c="36640">"retrieve"` <st c="36650">节点后，它使用</st> `<st c="36699">workflow.add_conditional_edges("retrieve",
    score_documents)</st>`<st c="36758">添加条件边。这使用</st> `<st c="36808">score_documents</st>`
    <st c="36823">函数评估检索到的文档，并根据分数确定下一个节点。</st> <st c="36882">这还会使用</st> `<st c="36952">workflow.add_edge("generate",
    END)</st>`<st c="36986">从</st> `<st c="36914">"generate"` <st c="36924">节点到</st>
    `<st c="36937">END</st>` <st c="36940">节点添加一个边。这表示在生成响应后，工作流程结束。</st> <st c="37057">最后，它使用</st>
    `<st c="37136">workflow.add_edge("improve", "agent")</st>`<st c="37173">从</st>
    `<st c="37090">"improve"` <st c="37099">节点回到</st> `<st c="37117">"agent"` <st
    c="37124">节点添加一个边。这创建了一个循环，改进的问题被发送回代理进行</st> <st c="37253">进一步处理。</st>
- en: <st c="37272">We are now ready to compile</st> <st c="37301">the graph:</st>
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="37272">我们现在准备好编译</st> `<st c="37301">图：</st>
- en: '[PRE102]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: <st c="37338">This line compiles the workflow graph using</st> `<st c="37383">workflow.compile</st>`
    <st c="37399">and assigns the compiled graph to the</st> `<st c="37438">graph</st>`
    <st c="37443">variable, which now represents a compiled version of the</st> `<st
    c="37501">StateGraph</st>` <st c="37511">graph instance we</st> <st c="37530">started
    with.</st>
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="37338">此行使用</st> `<st c="37383">workflow.compile</st>` <st c="37399">编译工作流程图，并将编译后的图赋值给</st>
    `<st c="37438">graph</st>` <st c="37443">变量，它现在代表了我们最初开始的</st> `<st c="37501">StateGraph</st>`
    <st c="37511">图实例的编译版本。</st>
- en: <st c="37543">We have already shown you the visualization of what this graph
    looks like earlier in this chapter in</st> *<st c="37645">Figure 12</st>**<st
    c="37654">.1</st>*<st c="37656">, but if you want to run the visualization yourself,
    you</st> <st c="37713">can use</st> <st c="37721">this code:</st>
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="37543">我们已经在本章前面展示了此图的可视化，</st> *<st c="37645">图12.1</st>**<st c="37654">，但如果你想要自己运行可视化，你可以使用</st>
    `<st c="37721">此代码：</st>`
- en: '[PRE103]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: <st c="37855">We can use</st> `<st c="37867">IPython</st>` <st c="37874">to
    generate</st> <st c="37887">this visualization.</st>
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="37855">我们可以使用</st> `<st c="37867">IPython</st>` <st c="37874">生成</st>
    `<st c="37887">此可视化。</st>
- en: <st c="37906">Last, we are going to finally put our agent</st> <st c="37951">to
    work:</st>
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="37906">最后，我们将最终让我们的代理</st> <st c="37951">开始工作：</st>
- en: '[PRE109]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: <st c="38024">This imports the</st> `<st c="38041">pprint</st>` <st c="38047">module,
    which provides a pretty-print function for formatting and printing data structures,
    allowing us to see a more human-readable version of our agent output.</st> <st
    c="38210">We then define a dictionary called</st> `<st c="38245">inputs</st>`
    <st c="38251">that represents the initial input to the workflow graph.</st> <st
    c="38309">The inputs dictionary contains a</st> `<st c="38342">"messages"</st>`
    <st c="38352">key with a list of tuples.</st> <st c="38380">In this case, it has
    a single tuple,</st> `<st c="38417">("user", user_query)</st>`<st c="38437">,
    where the</st> `<st c="38449">"user"</st>` <st c="38455">string represents the
    role of the message sender (</st>`<st c="38506">user</st>`<st c="38511">) and</st>
    `<st c="38518">user_query</st>` <st c="38528">is the user’s query</st> <st c="38549">or
    question.</st>
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="38024">此行导入</st> `<st c="38041">pprint</st>` <st c="38047">模块，它提供了一个格式化和打印数据结构的pretty-print函数，使我们能够看到我们代理输出的更易读版本。</st>
    <st c="38210">然后我们定义一个名为</st> `<st c="38245">inputs</st>` <st c="38251">的字典，它表示工作流程图的初始输入。</st>
    <st c="38309">输入字典包含一个</st> `<st c="38342">"messages"</st>` <st c="38352">键，其中包含一个元组列表。</st>
    <st c="38380">在这种情况下，它有一个单个元组，</st> `<st c="38417">("user", user_query)</st>`<st
    c="38437">，其中</st> `<st c="38449">"user"</st>` <st c="38455">字符串表示消息发送者的角色（</st>`<st
    c="38506">user</st>`<st c="38511">）和</st> `<st c="38518">user_query</st>` <st
    c="38528">是用户的查询或问题。</st>
- en: <st c="38561">We then initialize an empty string variable called</st> `<st c="38613">final_answer</st>`
    <st c="38625">to store the final answer generated by</st> <st c="38665">the workflow:</st>
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="38561">然后我们初始化一个名为</st> `<st c="38613">final_answer</st>` <st c="38625">的空字符串变量来存储工作流程</st>
    <st c="38665">生成的最终答案：</st>
- en: '[PRE115]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: <st c="38696">We then start our agent</st> <st c="38721">loop using the graph
    instance</st> <st c="38751">as</st> <st c="38754">the basis:</st>
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="38696">然后我们使用图实例</st> <st c="38721">作为</st> <st c="38751">基础来启动我们的代理</st>
    <st c="38754">循环：</st>
- en: '[PRE116]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: <st c="38973">This starts a double loop using the output in</st> `<st c="39020">graph.stream(inputs)</st>`<st
    c="39040">. This iterates over the outputs generated by the</st> `<st c="39090">graph</st>`
    <st c="39095">instance as it processes the inputs.</st> <st c="39133">The</st>
    `<st c="39137">graph.stream(inputs)</st>` <st c="39157">method streams the outputs
    from the</st> `<st c="39194">graph</st>` <st c="39199">instance execution.</st>
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="38973">这使用</st> `<st c="39020">graph.stream(inputs)</st>`<st c="39040">中的输出启动一个双重循环。</st>
    <st c="39090">graph</st> <st c="39095">实例在处理输入时生成输出。</st> <st c="39133">`<st c="39137">graph.stream(inputs)</st>`
    <st c="39157">方法从</st> `<st c="39194">graph</st>` <st c="39199">实例执行中流式传输输出。</st>
- en: <st c="39219">Inside the outer loop, it starts another loop for two variables,</st>
    `<st c="39285">key</st>` <st c="39288">and</st> `<st c="39293">value</st>`<st
    c="39298">, representing the key-value pairs in the</st> `<st c="39340">output.items</st>`
    <st c="39352">variable.</st> <st c="39363">This iterates over each of those key-value
    pairs, where the</st> `<st c="39423">key</st>` <st c="39426">variable represents
    the node name and the</st> `<st c="39469">value</st>` <st c="39474">variable represents
    the output generated by that node.</st> <st c="39530">This will print the node
    name using</st> `<st c="39566">pprint.pprint(f"Output from node '{key}':")</st>`
    <st c="39609">to indicate which node generated</st> <st c="39643">the output.</st>
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="39219">在外层循环内部，它为两个变量启动另一个循环，</st> `<st c="39285">key</st>` <st c="39288">和</st>
    `<st c="39293">value</st>`<st c="39298">，代表在</st> `<st c="39340">output.items</st>`
    <st c="39352">变量中的键值对。</st> <st c="39363">这会遍历每个键值对，其中</st> `<st c="39423">key</st>`
    <st c="39426">变量代表节点名称，而</st> `<st c="39469">value</st>` <st c="39474">变量代表该节点生成的输出。</st>
    <st c="39530">这将使用</st> `<st c="39566">pprint.pprint(f"Output from node '{key}':")</st>`
    <st c="39609">来指示哪个节点生成了</st> `<st c="39643">输出。</st>
- en: <st c="39654">The code pretty-prints the value (output) using</st> `<st c="39703">pprint.pprint(value,
    indent=2, width=80, depth=None)</st>`<st c="39755">. The</st> `<st c="39761">indent</st>`
    <st c="39767">parameter specifies the indentation level,</st> `<st c="39811">width</st>`
    <st c="39816">specifies the maximum width of the output, and</st> `<st c="39864">depth</st>`
    <st c="39869">specifies the maximum depth of nested data structures to print (</st>`<st
    c="39934">None</st>` <st c="39939">means</st> <st c="39946">no limit).</st>
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="39654">代码使用</st> `<st c="39703">pprint.pprint(value, indent=2, width=80,
    depth=None)</st>`<st c="39755">来美化打印值（输出）。</st> `<st c="39761">indent</st>` <st
    c="39767">参数指定缩进级别，</st> `<st c="39811">width</st>` <st c="39816">指定输出最大宽度，</st>
    `<st c="39864">depth</st>` <st c="39869">指定要打印的嵌套数据结构的最大深度（</st>`<st c="39934">None</st>`
    <st c="39939">表示</st> `<st c="39946">无限制）。</st>
- en: <st c="39956">It assigns the value (output) to the</st> `<st c="39994">final_answer</st>`
    <st c="40006">variable, overwriting it in each iteration.</st> <st c="40051">After
    the loop ends,</st> `<st c="40072">final_answer</st>` <st c="40084">will contain
    the output generated by the last node in</st> <st c="40139">the workflow.</st>
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="39956">它将值（输出）赋给</st> `<st c="39994">final_answer</st>` <st c="40006">变量，并在每次迭代中覆盖它。</st>
    <st c="40051">循环结束后，</st> `<st c="40072">final_answer</st>` <st c="40084">将包含工作流程中最后一个节点生成的输出。</st>
- en: <st c="40152">A nice</st> <st c="40160">feature of this code is that it allows
    you to see the</st> <st c="40213">intermediate outputs generated by each node
    in the graph and track the progress of the query processing.</st> <st c="40319">These
    print outputs represent the agent’s “thoughts” as it makes decisions within the
    loop.</st> <st c="40411">The pretty-printing helps in formatting the outputs for</st>
    <st c="40467">better readability.</st>
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="40152">此代码的一个优点是它允许您看到</st> <st c="40160">图中每个节点生成的中间输出，并跟踪查询处理的进度。</st>
    <st c="40213">这些打印输出代表了代理在循环中做出决策时的“思考”。</st> <st c="40319">美化打印有助于格式化输出，使其更易于阅读。</st>
- en: <st c="40486">When we start the agent and start seeing the output, we can see
    that a lot is</st> <st c="40565">going on!</st>
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们启动代理并开始看到输出时，我们可以看到有很多<st c="40486">事情在进行！</st>
- en: <st c="40574">I will truncate a lot of the printout, but this will give you
    an idea of what</st> <st c="40653">is provided:</st>
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="40574">我将截断大量的打印输出，但这将给你一个关于提供内容的</st> <st c="40653">概念：</st>
- en: '[PRE123]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: <st c="41280">This is the first part of our printout.</st> <st c="41321">Here,
    we see the agent is deciding to use the</st> `<st c="41367">retrieve_google_environmental_question_answers</st>`
    <st c="41413">tool.</st> <st c="41420">If you will recall, that is the text-based
    name we gave to the retriever tool when defining it.</st> <st c="41516">Good choice!</st>
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="41280">这是我们的打印输出的第一部分。</st> <st c="41321">在这里，我们看到代理决定使用</st> `<st c="41367">retrieve_google_environmental_question_answers</st>`
    <st c="41413">工具。</st> <st c="41420">如果你还记得，这是我们定义检索器工具时给它起的基于文本的名称。</st> <st
    c="41516">选择得很好！</st>
- en: <st c="41528">Next, the agent is going to determine if it thinks the documents
    retrieved</st> <st c="41604">are relevant:</st>
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="41528">接下来，代理将确定它认为检索到的文档是否相关：</st>
- en: '[PRE128]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: <st c="41669">The decision is that they are.</st> <st c="41701">Again, smart
    thinking,</st> <st c="41724">Mr.</st> <st c="41728">Agent.</st>
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="41669">决定是它们是。</st> <st c="41701">再次，明智的思考，</st> <st c="41724">先生，</st>
    <st c="41728">代理。</st>
- en: <st c="41734">Last, we see the</st> <st c="41751">output of what the agent is
    looking at, retrieved from</st> <st c="41806">the PDF document and the ensemble
    retriever we have been using (there was a lot of retrieved data here, so I truncated
    most of the</st> <st c="41938">actual content):</st>
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="41734">最后，我们看到代理正在查看的</st> <st c="41751">输出，这些数据是从</st> <st c="41806">PDF文档和我们一直在使用的集成检索器中检索到的（这里有很多检索到的数据，所以我截断了大部分的实际</st>
    <st c="41938">内容）：</st>
- en: '[PRE130]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: <st c="42326">When you look at the actual printout for this portion, you see
    that the retrieved data is concatenated together and provides substantial and
    in-depth data for our agent to</st> <st c="42499">work with.</st>
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="42326">当你查看这部分的实际打印输出时，你会看到检索到的数据被连接在一起，并为我们的代理提供了大量和深入的数据，以便</st> <st
    c="42499">使用。</st>
- en: <st c="42509">At this point, just like our original RAG application was doing,
    the agent takes the question, retrieved data, and formulates a response based
    on the generation</st> <st c="42671">prompt we</st> <st c="42681">gave it:</st>
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="42509">在这个阶段，就像我们的原始RAG应用程序所做的那样，代理接受问题、检索到的数据，并根据我们给出的生成</st> <st c="42671">提示来制定响应：</st>
- en: '[PRE134]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: <st c="43146">We included a mechanism here to print out the final message separately</st>
    <st c="43218">for readability:</st>
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="43146">我们在这里加入了一个机制，以便单独打印出最终消息，以便于阅读：</st>
- en: '[PRE145]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: <st c="43262">This will print</st> <st c="43279">this out:</st>
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="43262">这将打印</st> <st c="43279">以下内容：</st>
- en: '[PRE146]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: <st c="44089">That is the full output of</st> <st c="44117">our agent!</st>
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44089">这就是我们代理的全部输出！</st>
- en: <st c="44127">Summary</st>
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="44127">摘要</st>
- en: <st c="44135">In this chapter, we explored how AI agents and LangGraph can be
    combined to create more powerful and sophisticated RAG applications.</st> <st
    c="44269">We learned that an AI agent is essentially an LLM with a loop that allows
    it to reason and break tasks down into simpler steps, improving the chances of
    success in complex RAG tasks.</st> <st c="44452">LangGraph, an extension built
    on top of LCEL, provides support for building composable and customizable agentic
    workloads, enabling developers to orchestrate agents using a</st> <st c="44625">graph-based
    approach.</st>
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44135">在本章中，我们探讨了如何将AI代理和LangGraph结合起来创建更强大和复杂的RAG应用程序。</st> <st c="44269">我们了解到，AI代理本质上是一个具有循环的LLM，允许它进行推理并将任务分解成更简单的步骤，从而提高在复杂RAG任务中成功的可能性。</st>
    <st c="44452">LangGraph，建立在LCEL之上的扩展，为构建可组合和可定制的代理工作负载提供支持，使开发者能够使用基于</st> <st
    c="44625">图的方法来编排代理。</st>
- en: <st c="44646">We dove into the fundamentals of AI agents and RAG integration,
    discussing the concept of tools that agents can use to carry out tasks, and how
    LangGraph’s</st> `<st c="44803">AgentState</st>` <st c="44813">class tracks the
    state of the agent over time.</st> <st c="44861">We also covered the core concepts
    of graph theory, including nodes, edges, and conditional edges, which are crucial
    for understanding how</st> <st c="44999">LangGraph works.</st>
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44646">我们深入探讨了AI代理和RAG集成的根本，讨论了代理可以用来执行任务的工具的概念，以及LangGraph的</st> `<st
    c="44803">AgentState</st>` <st c="44813">类如何跟踪代理随时间的状态。</st> <st c="44861">我们还涵盖了图论的核心概念，包括节点、边和条件边，这对于理解LangGraph如何工作至关重要。</st>
- en: <st c="45015">In the code lab, we built a LangGraph retrieval agent for our
    RAG application, demonstrating how to create tools, define the agent state, set
    up prompts, and establish the cyclical graphs using LangGraph.</st> <st c="45221">We
    saw how the agent uses its reasoning capabilities to determine which tools to
    use, how to use them, and what data to feed them, ultimately providing a more
    thorough response to the</st> <st c="45405">user’s question.</st>
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码实验室中，我们为我们的RAG应用构建了一个LangGraph检索代理，展示了如何创建工具、定义代理状态、设置提示以及使用LangGraph建立循环图。<st
    c="45221">我们看到了代理如何利用其推理能力来确定使用哪些工具、如何使用它们以及提供什么数据，最终为</st> <st c="45405">用户的问题提供更全面的回答。</st>
- en: <st c="45421">Looking ahead, the next chapter will focus on how prompt engineering
    can be used to improve</st> <st c="45514">RAG applications.</st>
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 展望未来，下一章将重点介绍如何使用提示工程来改进<st c="45421">RAG应用</st>。
