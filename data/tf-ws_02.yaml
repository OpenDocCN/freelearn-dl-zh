- en: 2\. Loading and Processing Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 加载和处理数据
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn how to load and process a variety of data types
    for modeling in TensorFlow. You will implement methods to input data into TensorFlow
    models so that model training can be optimized.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何加载和处理多种数据类型，以便在 TensorFlow 中建模。你将实现将数据输入到 TensorFlow 模型中的方法，从而优化模型训练。
- en: By the end of this chapter, you will know how to input tabular data, images,
    text, and audio data and preprocess them so that they are suitable for training
    TensorFlow models.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将学会如何输入表格数据、图像、文本和音频数据，并进行预处理，使其适合用于训练 TensorFlow 模型。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, you learned how to create, utilize, and apply linear
    transformations to tensors using TensorFlow. The chapter started with the definition
    of tensors and how they can be created using the `Variable` class in the TensorFlow
    library. You then created tensors of various ranks and learned how to apply tensor
    addition, reshaping, transposition, and multiplication using the library. These
    are all examples of linear transformations. You concluded that chapter by covering
    optimization methods and activation functions and how they can be accessed in
    the TensorFlow library.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何使用 TensorFlow 创建、利用和应用线性变换到张量。该章首先介绍了张量的定义以及如何使用 TensorFlow 库中的
    `Variable` 类创建张量。然后，你创建了不同阶数的张量，并学习了如何使用该库进行张量加法、重塑、转置和乘法操作。这些都是线性变换的例子。你通过讲解优化方法和激活函数并如何在
    TensorFlow 库中访问它们，结束了这一章的内容。
- en: When training machine learning models in TensorFlow, you must supply the model
    with training data. The raw data that is available may come in a variety of formats—for
    example, tabular CSV files, images, audio, or text files. Different data sources
    are loaded and preprocessed in different ways in order to provide numerical tensors
    for TensorFlow models. For example, virtual assistants use voice queries as input
    interaction and then apply machine learning models to decipher input speech and
    perform specific actions as output. To create the models for this task, the audio
    data of the speech input must be loaded into memory. A preprocessing step also
    needs to be involved that converts the audio input into text. Following this,
    the text is converted into numerical tensors for model training. This is one example
    that demonstrates the complexity of creating models from non-tabular, non-numerical
    data such as audio data.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TensorFlow 中训练机器学习模型时，必须向模型提供训练数据。可用的原始数据可能有多种格式——例如，表格型 CSV 文件、图像、音频或文本文件。不同的数据源以不同的方式加载和预处理，以便为
    TensorFlow 模型提供数值张量。例如，虚拟助手使用语音查询作为输入交互，然后应用机器学习模型来解码输入的语音并执行特定的输出操作。为了创建这一任务的模型，必须将语音输入的音频数据加载到内存中。还需要一个预处理步骤，将音频输入转换为文本。之后，文本将被转换为数值张量以进行模型训练。这是一个例子，展示了从非表格型、非数值型数据（如音频数据）创建模型的复杂性。
- en: This chapter will explore a few of the common data types that are utilized for
    building machine learning models. You will load raw data into memory in an efficient
    manner, and then perform some preprocessing steps to convert the raw data into
    numerical tensors that are appropriate for training machine learning models. Luckily,
    machine learning libraries have advanced significantly, which means that training
    models with data types such as images, text, and audio is extremely accessible
    to practitioners.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨一些常用的数据类型，这些数据类型用于构建机器学习模型。你将以高效的方式将原始数据加载到内存中，然后执行一些预处理步骤，将原始数据转换为适合训练机器学习模型的数值张量。幸运的是，机器学习库已经取得了显著的进展，这意味着使用图像、文本和音频等数据类型训练模型对于实践者来说变得非常可行。
- en: Exploring Data Types
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索数据类型
- en: 'Depending on the source, raw data can be of different forms. Common forms of
    data include tabular data, images, video, audio, and text. For example, the output
    from a temperature logger (used to record the temperature at a given location
    over time) is tabular. Tabular data is structured with rows and columns, and,
    in the example of a temperature logger, each column may represent a characteristic
    for each record, such as the time, location, and temperature, while each row may
    represent the values of each record. The following table shows an example of numerical
    tabular data:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数据来源的不同，原始数据可以有不同的形式。常见的数据形式包括表格数据、图像、视频、音频和文本。例如，温度记录仪（用于记录给定地点随时间变化的温度）输出的数据是表格数据。表格数据是按行和列结构化的，在温度记录仪的例子中，每一列可能代表每条记录的某个特征，比如时间、地点和温度，而每一行则代表每条记录的数值。下表展示了数值型表格数据的示例：
- en: '![Figure 2.1: An example of 10 rows of tabular data that consists of numerical
    values'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.1：一个由数值组成的表格数据的示例，包含 10 行数据'
- en: '](img/B16341_02_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16341_02_01.jpg)'
- en: 'Figure 2.1: An example of 10 rows of tabular data that consists of numerical
    values'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：一个由数值组成的表格数据的示例，包含 10 行数据
- en: Image data represents another common form of raw data that is popular for building
    machine learning models. These models are popular due to the large volume of data
    that's available. With smartphones and security cameras recording all of life's
    moments, they have generated an enormous amount of data that can be used to train
    models.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图像数据代表另一种常见的原始数据形式，在构建机器学习模型时非常受欢迎。由于数据量巨大，这些模型也非常受欢迎。随着智能手机和监控摄像头记录下生活中的每一个瞬间，它们已经生成了大量可以用于训练模型的数据。
- en: 'The dimensions of image data for training are different than they are for tabular
    data. Each image has a height and width dimension, as well as a color channel
    adding a third dimension, and the quantity of images adding a fourth. As such,
    the input tensors for image data models are four-dimensional tensors, whereas
    the input tensors for tabular data are two-dimensional. The following figure shows
    an example of labeled training examples of boats and airplanes taken from the
    `Open Images` dataset ([https://storage.googleapis.com/openimages/web/index.html](https://storage.googleapis.com/openimages/web/index.html));
    the images have been preprocessed so that they all have the same height and width.
    This data could be used, for example, to train a binary classification model to
    classify images as boats or airplanes:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 用于训练的图像数据的维度与表格数据不同。每张图像都有高度和宽度维度，并且颜色通道增加了第三个维度，而图像数量则增加了第四个维度。因此，图像数据模型的输入张量是四维的，而表格数据的输入张量是二维的。下图展示了从`Open
    Images`数据集（[https://storage.googleapis.com/openimages/web/index.html](https://storage.googleapis.com/openimages/web/index.html)）中提取的带标签的船只和飞机的训练示例；这些图像已经过预处理，使得它们的高度和宽度相同。这个数据可以用来训练一个二分类模型，将图像分类为船只或飞机：
- en: '![Figure 2.2: A sample of image data that can be used for training machine
    learning models](img/B16341_02_02.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2：可以用于训练机器学习模型的图像数据样本](img/B16341_02_02.jpg)'
- en: 'Figure 2.2: A sample of image data that can be used for training machine learning
    models'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：可以用于训练机器学习模型的图像数据样本
- en: 'Other types of raw data that can be used to build machine learning models include
    text and audio. Like images, their popularity in the machine learning community
    is derived from the large amount of data that''s available. Both audio and text
    have the challenge of having indeterminate sizes. You will explore how this challenge
    can be overcome later in this chapter. The following figure shows an audio sample
    with a sample rate of 44.1 kHz, which means the audio data is sampled 44,100 times
    per second. This is an example of the type of raw data that is input into virtual
    assistants, from which they decipher the request and act accordingly:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型的原始数据，如文本和音频，也可以用来构建机器学习模型。像图像一样，它们在机器学习社区中的受欢迎程度来自于大量可用的数据。音频和文本都有大小不确定的挑战。你将在本章后面探索如何克服这一挑战。下图展示了一个采样率为
    44.1 kHz 的音频样本，这意味着音频数据每秒被采样 44,100 次。这是输入虚拟助手的原始数据类型的一个示例，虚拟助手通过这些数据解析请求并做出相应的动作：
- en: '![Figure 2.3: A visual representation of audio data'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.3：音频数据的可视化表示'
- en: '](img/B16341_02_03.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16341_02_03.jpg)'
- en: 'Figure 2.3: A visual representation of audio data'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3：音频数据的可视化表示
- en: Now that you know about some of the types of data you may encounter when building
    machine learning models, in the next section, you will uncover ways to preprocess
    different types of data.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了在构建机器学习模型时可能遇到的一些数据类型，接下来的部分将揭示如何预处理不同类型的数据。
- en: Data Preprocessing
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据预处理
- en: Data preprocessing refers to the process in which raw data is converted into
    a form that is appropriate for machine learning models to use as input. Each different
    data type will require different preprocessing steps, with the minimum requirement
    that the resulting tensor is composed solely of numerical elements, such as integers
    or decimal numbers. Numerical tensors are required since models rely on linear
    transformations such as addition and multiplication, which can only be performed
    on numerical tensors.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 数据预处理是指将原始数据转换为适合机器学习模型使用的形式的过程。不同的数据类型将需要不同的预处理步骤，最基本的要求是，结果张量仅包含数值元素，如整数或小数。需要数值张量，因为模型依赖于线性变换，如加法和乘法，而这些变换只能在数值张量上执行。
- en: While many datasets exist with solely numerical fields, many do not. They may
    have fields that are of the string, Boolean, categorical, or date data types that
    must all be converted into numerical fields. Some may be trivial; a Boolean field
    can be mapped so that `true` values are equal to `1` and `false` values are equal
    to `0`. Therefore, mapping a Boolean field to a numerical field is simple and
    all the necessary information is preserved. However, when converting other data
    types, such as date fields, you may lose information when converting into numerical
    fields unless it's explicitly stated otherwise.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多数据集仅包含数值字段，但也有很多数据集不止如此。它们可能包含字符串、布尔值、类别型或日期类型的字段，这些字段都必须转换为数值字段。有些转换可能很简单；例如，布尔值字段可以映射为
    `true` 对应 `1`，`false` 对应 `0`。因此，将布尔字段映射为数值字段是简单的，并且所有必要的信息都得以保留。然而，当转换其他数据类型（如日期字段）时，除非另有明确说明，否则转换为数值字段时可能会丢失信息。
- en: One example of a possible loss of information occurs when converting a date
    field into a numerical field by using Unix time. Unix time represents the number
    of seconds that have elapsed since the Unix epoch; that is, 00:00:00 UTC on January
    1, 1970, and leap seconds are ignored. Using Unix time removes the explicit indication
    of the month, day of the week, hour of the day, and so on, which may act as important
    features when training a model.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的信息丢失示例是将日期字段通过 Unix 时间转换为数值字段。Unix 时间表示自 Unix 纪元以来经过的秒数；即 1970 年 1 月 1
    日 00:00:00 UTC，忽略闰秒。使用 Unix 时间移除了月份、星期几、小时等的显式指示，而这些信息在训练模型时可能作为重要特征。
- en: 'When converting fields into numerical data types, it is important to preserve
    as much informational context as possible as it will aid any model that is trained
    to understand the relationship between the features and the target. The following
    diagram demonstrates how a date field can be converted into a series of numerical
    fields:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在将字段转换为数值数据类型时，重要的是尽可能保留信息上下文，因为这将有助于训练模型理解特征与目标之间的关系。以下图示展示了如何将日期字段转换为一系列数值字段：
- en: '![Figure 2.4: A numerical encoding of a date column'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.4：日期列的数值编码'
- en: '](img/B16341_02_04.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16341_02_04.jpg)'
- en: 'Figure 2.4: A numerical encoding of a date column'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4：日期列的数值编码
- en: 'As shown in the preceding diagram, on the left, the date field represents a
    given date, while on the right, there is a method providing numerical information:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，左侧是日期字段，表示一个特定日期，而右侧则提供了一种方法，将其转化为数值信息：
- en: The year is extracted from the date, which is an integer.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从日期中提取年份，作为整数。
- en: The month is one-hot encoded. There is a column for each month of the year and
    the month is binary encoded, if the date's month corresponds with the column's
    name.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 月份使用独热编码（one-hot encoding）。每个月份都有一个列，并且月份被二进制编码，如果日期的月份与该列的名称相符。
- en: A column is created indicating whether the date occurs on a weekend.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个列，指示日期是否为周末。
- en: This is just a method to encode the `date` column here; not all the preceding
    methods are necessary and there are many more that can be used. Encoding all the
    fields into numerical fields appropriately is important to create performant machine
    learning models that can learn the relationships between the features and the
    target.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里仅是对`date`列进行编码的方法；并不是所有前述的方法都是必须的，且还有许多其他方法可以使用。将所有字段适当地编码为数值字段对于创建高效的机器学习模型至关重要，这样模型才能学习特征与目标之间的关系。
- en: Data normalization is another preprocessing technique used to speed up the training
    process. The normalization process rescales the fields so that they are all of
    the same scale. This will also help ensure that the weights of the model are of
    the same scale.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 数据归一化是另一种预处理技术，用于加速训练过程。归一化过程会重新缩放字段，使它们都具有相同的尺度。这也有助于确保模型的权重具有相同的尺度。
- en: In the preceding diagram, the `year` column has the order of magnitude `10`3,
    and the other columns have the order `10`0\. This implies there are three orders
    of magnitude between the columns. Fields with values that are very different in
    scale will result in a less accurate model as the optimal weights to minimize
    the error function may not be discovered. This may be due to the tolerance limits
    or the learning rate that are defined as hyperparameters prior to training not
    being optimal for both scales when the weights are updated. In the preceding example,
    it may be beneficial to rescale the `year` column so that it has the same order
    of magnitude as the other columns.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图示中，`year`列的数量级为`10^3`，而其他列的数量级为`10^0`。这意味着列之间存在三个数量级的差异。字段的数值范围差异很大的话，可能会导致模型不够精确，因为在最小化误差函数时，可能无法找到最优的权重。这可能是由于在训练前定义的容忍限度或学习率，并不适用于这两个数量级的权重更新。在前面的例子中，重新缩放`year`列，使其与其他列具有相同的数量级，可能是有益的。
- en: Throughout this chapter, you will explore a variety of methods that can be used
    to preprocess tabular data, image data, text data, and audio data so that it can
    be used to train machine learning models.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将探索多种方法来预处理表格数据、图像数据、文本数据和音频数据，以便将其用于训练机器学习模型。
- en: Processing Tabular Data
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理表格数据
- en: In this section, you will learn how to load tabular data into a Python development
    environment so that it can be used for TensorFlow modeling. You will use pandas
    and scikit-learn to utilize the classes and functions that are useful for processing
    data. You will also explore methods that can be used to preprocess this data.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何将表格数据加载到Python开发环境中，以便可以用于TensorFlow建模。你将使用pandas和scikit-learn来利用有助于处理数据的类和函数，并探索可用于预处理数据的方法。
- en: 'Tabular data can be loaded into memory by using the pandas `read_csv` function
    and passing the path into the dataset. The function is well suited and easy to
    use for loading in tabular data and can be used as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用pandas的`read_csv`函数并传入数据集路径，将表格数据加载到内存中。这个函数非常适合且易于使用来加载表格数据，使用方法如下：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In order to normalize the data, you can use a scaler that is available in scikit-learn.
    There are multiple scalers that can be applied; `StandardScaler` will normalize
    the data so that the fields of the dataset have a mean of `0` and a standard deviation
    of `1`. Another common scaler that is used is `MinMaxScaler`, which will rescale
    the dataset so that the fields have a minimum value of `0` and a maximum value
    of `1`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对数据进行归一化，你可以使用在scikit-learn中可用的缩放器。可以应用多种缩放器；`StandardScaler`会对数据进行归一化，使数据集的字段均值为`0`，标准差为`1`。另一个常用的缩放器是`MinMaxScaler`，它会重新缩放数据集，使字段的最小值为`0`，最大值为`1`。
- en: 'To use a scaler, it must be initialized and fit to the dataset. By doing this,
    the dataset can be transformed by the scaler. In fact, the fitting and transformation
    processes can be performed in one step by using the `fit_transform` method, as
    follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用缩放器，必须先初始化并将其拟合到数据集。通过这样做，数据集就可以通过缩放器进行转换。实际上，拟合和转换过程可以通过使用`fit_transform`方法一步完成，如下所示：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the first exercise, you will learn how to use pandas and scikit-learn to
    load a dataset and preprocess it so that it is suitable for modeling.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个练习中，你将学习如何使用pandas和scikit-learn加载数据集并对其进行预处理，使其适合建模。
- en: 'Exercise 2.01: Loading Tabular Data and Rescaling Numerical Fields'
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.01：加载表格数据并重新缩放数值字段
- en: The dataset, `Bias_correction_ucl.csv`, contains information for bias correction
    of the next-day maximum and minimum air temperature forecast for Seoul, South
    Korea. The fields represent temperature measurements of the given date, the weather
    station at which the metrics were measured, model forecasts of weather-related
    metrics such as humidity, and projections for the temperature of the following
    day. You are required to preprocess the data to make all the columns normally
    distributed with a mean of `0` and a standard deviation of `1`. You will demonstrate
    the effects with the `Present_Tmax` column, which represents the maximum temperature
    on the given date at a given weather station.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集 `Bias_correction_ucl.csv` 包含了针对韩国首尔的次日最高和最低气温预报的偏差修正信息。各字段代表给定日期的温度测量值、测量数据的天气站、与天气相关的模型预报指标（如湿度），以及次日的温度预报。你需要对数据进行预处理，使所有列符合正态分布，均值为
    `0`，标准差为 `1`。你将以 `Present_Tmax` 列为例，展示其效果，该列表示给定日期和天气站的最高温度。
- en: Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The dataset can be found here: [https://packt.link/l83pR](https://packt.link/l83pR).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集可以在这里找到：[https://packt.link/l83pR](https://packt.link/l83pR)。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此练习：
- en: Open a new Jupyter notebook to implement this exercise. Save the file as `Exercise2-01.ipnyb`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Jupyter notebook 来实现这个练习。将文件保存为 `Exercise2-01.ipnyb`。
- en: 'In a new Jupyter Notebook cell, import the pandas library, as follows:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的 Jupyter Notebook 单元格中，导入 pandas 库，如下所示：
- en: '[PRE2]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the documentation for pandas at the following link: [https://pandas.pydata.org/docs/](https://pandas.pydata.org/docs/).'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在以下链接找到 pandas 的文档：[https://pandas.pydata.org/docs/](https://pandas.pydata.org/docs/)。
- en: 'Create a new pandas DataFrame named `df` and read the `Bias_correction_ucl.csv`
    file into it. Examine whether your data is properly loaded by printing the resultant
    DataFrame:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 pandas DataFrame，命名为 `df`，并将 `Bias_correction_ucl.csv` 文件读取到其中。通过打印结果
    DataFrame 来检查数据是否正确加载：
- en: '[PRE3]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure you change the path (highlighted) to the CSV file based on its location
    on your system. If you're running the Jupyter notebook from the same directory
    where the CSV file is stored, you can run the preceding code without any modification.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保根据 CSV 文件在系统中的位置更改路径（高亮部分）。如果你从存储 CSV 文件的同一目录运行 Jupyter notebook，则可以直接运行上述代码而无需修改。
- en: 'The output will be as follows:'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![Figure 2.5: The output from printing the DataFrame'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.5：打印 DataFrame 后的输出结果](img/B16341_02_05.jpg)'
- en: '](img/B16341_02_05.jpg)'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16341_02_06.jpg)'
- en: 'Figure 2.5: The output from printing the DataFrame'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.5：打印 DataFrame 后的输出结果
- en: 'Drop the `date` column using the `drop` method of the DataFrame and pass in
    the name of the column. The `date` column will be dropped as it is a non-numerical
    field and rescaling will not be possible when non-numerical fields exist. Since
    you are dropping a column, both the `axis=1` argument and the `inplace=True` argument
    should be passed:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 DataFrame 的 `drop` 方法删除 `date` 列，并传入列名。删除 `date` 列是因为它是非数值型字段，存在非数值型字段时无法进行缩放。由于要删除列，因此需要同时传入
    `axis=1` 和 `inplace=True` 参数：
- en: '[PRE4]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Plot a histogram of the `Present_Tmax` column that represents the maximum temperature
    across dates and weather stations within the dataset:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制表示数据集中各日期和天气站的最大温度的 `Present_Tmax` 列的直方图：
- en: '[PRE5]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output will be as follows:'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![Figure 2.6: A Temperature versus Frequency histogram of the Present_Tmax
    column'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.6：表示 `Present_Tmax` 列的温度与频率的直方图](img/B16341_02_06.jpg)'
- en: '](img/B16341_02_06.jpg)'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16341_02_05.jpg)'
- en: 'Figure 2.6: A Temperature versus Frequency histogram of the Present_Tmax column'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.6：表示 `Present_Tmax` 列的温度与频率的直方图
- en: The resultant histogram shows the distribution of values for the `Present_Tmax`
    column. You can see that the temperature values vary from 20 to 38 degrees Celsius.
    Plotting a histogram of the feature values is a good way to view the distribution
    of values to understand whether scaling is required as a preprocessing step.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果直方图显示了 `Present_Tmax` 列的值的分布。可以看到，温度值的范围从 20 到 38 摄氏度。绘制特征值的直方图是查看值的分布并判断是否需要缩放的好方法。
- en: 'Import the `StandardScaler` class from scikit-learn''s preprocessing package.
    Initialize the scaler, fit the scaler, and transform the DataFrame using the scaler''s
    `fit_transform` method. Create a new DataFrame, `df2`, using the transformed DataFrame
    since the result of the `fit_transform` method is a NumPy array. The standard
    scaler will transform the numerical fields so that the mean of the field is `0`
    and the standard deviation is `1`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 scikit-learn 的预处理包中导入 `StandardScaler` 类。初始化缩放器，拟合缩放器并使用缩放器的 `fit_transform`
    方法对 DataFrame 进行变换。由于 `fit_transform` 方法的结果是一个 NumPy 数组，因此使用变换后的 DataFrame 创建一个新的
    DataFrame `df2`。标准缩放器将对数值字段进行变换，使字段的均值为 `0`，标准差为 `1`：
- en: '[PRE6]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The values for the mean and standard deviation of the resulting transformed
    data can be input into the scaler.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果数据的均值和标准差可以输入到缩放器中。
- en: 'Plot a histogram of the transformed `Present_Tmax` column:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制变换后的 `Present_Tmax` 列的直方图：
- en: '[PRE7]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output will be as follows:'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 2.7: A histogram of the rescaled Present_Tmax column'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.7：重新缩放后的 Present_Tmax 列的直方图'
- en: '](img/B16341_02_07.jpg)'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16341_02_07.jpg)'
- en: 'Figure 2.7: A histogram of the rescaled Present_Tmax column'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7：重新缩放后的 Present_Tmax 列的直方图
- en: The resulting histogram shows that the temperature values range from around
    `-3` to `3` degrees Celsius, as evidenced by the range on the *x* axis of the
    histogram. By using the standard scaler, the values will always have a mean of
    `0` and a standard deviation of `1`. Having the features normalized can speed
    up the model training process.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的直方图显示，温度值的范围大约从 `-3` 到 `3` 摄氏度，可以从直方图的 *x* 轴范围中看出。使用标准缩放器后，数值将始终具有 `0` 的均值和
    `1` 的标准差。规范化特征可以加速模型训练过程。
- en: In this exercise, you successfully imported tabular data using the pandas library
    and performed some preprocessing using the scikit-learn library. The preprocessing
    of data included dropping the `date` column and scaling the numerical fields so
    that they have a mean value of `0` and a standard deviation of `1`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你成功地使用 pandas 库导入了表格数据，并使用 scikit-learn 库进行了一些预处理。数据的预处理包括删除 `date` 列和对数值字段进行缩放，使它们的均值为
    `0`，标准差为 `1`。
- en: In the following activity, you will load in tabular data using the pandas library
    and scale that data using the `MinMax` scaler present in scikit-learn. You will
    do so on the same dataset that you used in the prior exercise, which describes
    the bias correction of air temperature forecasts for Seoul, South Korea.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下活动中，你将使用 pandas 库加载表格数据，并使用 scikit-learn 中的 `MinMax` 缩放器对数据进行缩放。你将使用与之前练习中相同的数据集，该数据集描述了韩国首尔空气温度预报的偏差修正。
- en: 'Activity 2.01: Loading Tabular Data and Rescaling Numerical Fields with a MinMax
    Scaler'
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 2.01：加载表格数据并使用 MinMax 缩放器重新缩放数值字段
- en: In this activity, you are required to load tabular data and rescale the data
    using a `MinMax` scaler. The dataset, `Bias_correction_ucl.csv`, contains information
    for bias correction of the next-day maximum and minimum air temperature forecast
    for Seoul, South Korea. The fields represent temperature measurements of the given
    date, the weather station at which the metrics were measured, model forecasts
    of weather-related metrics such as humidity, and projections for the temperature
    the following day. You are required to scale the columns so that the minimum value
    of each column is `0` and the maximum value is `1`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，你需要加载表格数据并使用 `MinMax` 缩放器对数据进行重新缩放。数据集 `Bias_correction_ucl.csv` 包含了韩国首尔次日最大和最小空气温度预报的偏差修正信息。字段表示给定日期的温度测量值、测量指标的气象站、与天气相关的指标（如湿度）模型预测值以及次日的温度预测值。你需要对列进行缩放，使得每列的最小值为
    `0`，最大值为 `1`。
- en: 'Perform the following steps to complete this activity:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此活动的步骤如下：
- en: Open a new Jupyter notebook to implement this activity.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Jupyter notebook 来实现这个活动。
- en: Import pandas and the `Bias_correction_ucl.csv` dataset.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 pandas 和 `Bias_correction_ucl.csv` 数据集。
- en: Read the dataset using the pandas `read_csv` function.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 pandas 的 `read_csv` 函数读取数据集。
- en: Drop the `date` column of the DataFrame.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 DataFrame 的 `date` 列。
- en: Plot a histogram of the `Present_Tmax` column.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制 `Present_Tmax` 列的直方图。
- en: Import `MinMaxScaler` and fit it to and transform the feature DataFrame.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `MinMaxScaler` 并将其拟合到并变换特征 DataFrame。
- en: Plot a histogram of the transformed `Present_Tmax` column.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制变换后的 `Present_Tmax` 列的直方图。
- en: 'You should get an output similar to the following:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到类似以下的输出：
- en: '![Figure 2.8: Expected output of Activity 2.01'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.8：活动 2.01 的预期输出'
- en: '](img/B16341_02_08.jpg)'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16341_02_08.jpg)'
- en: 'Figure 2.8: Expected output of Activity 2.01'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8：活动 2.01 的预期输出
- en: Note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found via [this link](B16341_Solution_ePub.xhtml#_idTextAnchor255).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以通过[这个链接](B16341_Solution_ePub.xhtml#_idTextAnchor255)找到。
- en: 'One method of converting non-numerical fields such as categorical or date fields
    is to one-hot encode them. The `0` except for the one that corresponds to the
    correct column. The column headers of the newly created dummy columns correspond
    to the unique values. One-hot encoding can be achieved by using the `get_dummies`
    function of the pandas library and passing in the column to be encoded. An optional
    argument is to provide a prefix feature that adds a prefix to the column headers.
    This can be useful for referencing the columns:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 转换非数值字段（如分类字段或日期字段）的一种方法是进行独热编码。`0` 表示除了与正确列对应的那一列外的所有列。新创建的虚拟列的列头对应于唯一值。独热编码可以通过使用
    pandas 库的 `get_dummies` 函数来实现，并传入需要编码的列。一个可选的参数是提供前缀功能，为列头添加前缀，这对于引用列很有用：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When using the `get_dummies` function, `NaN` values are converted into all zeros.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `get_dummies` 函数时，`NaN` 值会被转换为全 0。
- en: In the following exercise, you'll learn how to preprocess non-numerical fields.
    You will utilize the same dataset that you used in the previous exercise and activity,
    which describes the bias correction of air temperature forecasts for Seoul, South
    Korea.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，你将学习如何预处理非数值字段。你将使用与之前的练习和活动相同的数据集，该数据集描述了韩国首尔的气温预报偏差修正。
- en: 'Exercise 2.02: Preprocessing Non-Numerical Data'
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.02：预处理非数值数据
- en: In this exercise, you will preprocess the `date` column by one-hot encoding
    the year and the month from the `date` column using the `get_dummies` function.
    You will join the one-hot-encoded columns with the original DataFrame and ensure
    that all the fields in the resultant DataFrame are numerical.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将通过使用 `get_dummies` 函数对 `date` 列的年份和月份进行独热编码来预处理 `date` 列。你将把独热编码后的列与原始
    DataFrame 合并，确保结果 DataFrame 中的所有字段都是数值类型。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个练习的步骤如下：
- en: Open a new Jupyter notebook to implement this exercise. Save the file as `Exercise2-02.ipnyb`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Jupyter notebook 来实现这个练习。将文件保存为 `Exercise2-02.ipnyb`。
- en: 'In a new Jupyter Notebook cell, import the pandas library, as follows:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的 Jupyter Notebook 单元格中，导入 pandas 库，如下所示：
- en: '[PRE9]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a new pandas DataFrame named `df` and read the `Bias_correction_ucl.csv`
    file into it. Examine whether your data is properly loaded by printing the resultant
    DataFrame:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 pandas DataFrame，命名为 `df`，并将 `Bias_correction_ucl.csv` 文件读取到其中。通过打印结果
    DataFrame 检查数据是否正确加载：
- en: '[PRE10]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure you change the path (highlighted) to the CSV file based on its location
    on your system. If you're running the Jupyter notebook from the same directory
    where the CSV file is stored, you can run the preceding code without any modification.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保根据文件在你系统上的位置更改路径（高亮部分）。如果你从存储 CSV 文件的目录运行 Jupyter notebook，你可以直接运行上述代码，而无需修改。
- en: 'Change the data type of the `date` column to `Date` using the pandas `to_datetime`
    function:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 pandas 的 `to_datetime` 函数将 `date` 列的数据类型更改为 `Date`：
- en: '[PRE11]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create dummy columns for `year` using the pandas `get_dummies` function. Pass
    in the year of the `date` column as the first argument and add a prefix to the
    columns of the resultant DataFrame. Print out the resultant DataFrame:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 pandas 的 `get_dummies` 函数为 `year` 创建虚拟列。将 `date` 列的年份作为第一个参数传入，并为结果 DataFrame
    的列添加前缀。打印出结果 DataFrame：
- en: '[PRE12]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output will be as follows:'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 2.9: Output of the get_dummies function applied to the year of the
    date column'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.9：应用 `get_dummies` 函数处理日期列的年份后的输出'
- en: '](img/B16341_02_09.jpg)'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16341_02_09.jpg)'
- en: 'Figure 2.9: Output of the get_dummies function applied to the year of the date
    column'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.9：应用 `get_dummies` 函数处理日期列的年份后的输出
- en: The resultant DataFrame contains only 0s and 1s. `1` corresponds to the value
    present in the original `date` column. Null values will have 0s for all columns
    in the newly created DataFrame.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果 DataFrame 只包含 0 和 1。`1` 对应于原始 `date` 列中存在的值。空值将在新创建的 DataFrame 中对所有列显示为 0。
- en: 'Repeat this for the month by creating dummy columns from the month of the `date`
    column. Print out the resulting DataFrame:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从 `date` 列的月份创建虚拟列来重复此操作。打印出生成的 DataFrame：
- en: '[PRE13]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output will be as follows:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 2.10: The output of the get_dummies function applied'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图2.10：应用get_dummies函数的输出'
- en: to the month of the date column
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到日期列的月份
- en: '](img/B16341_02_10.jpg)'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16341_02_10.jpg)'
- en: 'Figure 2.10: The output of the get_dummies function applied to the month of
    the date column'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.10：应用于日期列月份的get_dummies函数的输出
- en: The resultant DataFrame now contains only 0s and 1s for the month in the `date` column.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果DataFrame现在仅包含`date`列中月份的0和1。
- en: 'Concatenate the original DataFrame and the dummy DataFrames you created in
    *Steps 5* and *6*:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原始DataFrame与您在*步骤5*和*6*中创建的虚拟DataFrame连接起来：
- en: '[PRE14]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Drop the original `date` column since it is now redundant:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除原始`date`列，因为它现在是多余的：
- en: '[PRE15]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Verify that all the columns are now of the numerical data type:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证所有列现在都是数值数据类型：
- en: '[PRE16]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output will be as follows:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Figure 2.11: Output of the dtypes attribute of the resultant DataFrame'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图2.11：结果DataFrame的dtypes属性的输出'
- en: '](img/B16341_02_11.jpg)'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16341_02_11.jpg)'
- en: 'Figure 2.11: Output of the dtypes attribute of the resultant DataFrame'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11：结果DataFrame的dtypes属性的输出
- en: Here, you can see that all the data types of the resultant DataFrame are numerical.
    This means they can now be passed into an ANN for modeling.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到结果DataFrame的所有数据类型都是数值的。这意味着它们现在可以传递到ANN中进行建模。
- en: In this exercise, you successfully imported tabular data and preprocessed the
    `date` column using the pandas and scikit-learn libraries. You utilized the `get_dummies`
    function to convert categorical data into numerical data types.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在此练习中，您成功导入了表格数据，并使用pandas和scikit-learn库预处理了`date`列。您使用了`get_dummies`函数将分类数据转换为数值数据类型。
- en: Note
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Another method to attain a numerical data type from date data types is by using
    the `pandas.Series.dt` accessor object. More information about the available options
    can be found here: [https://pandas.pydata.org/docs/reference/api/pandas.Series.dt.html](https://pandas.pydata.org/docs/reference/api/pandas.Series.dt.html).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种从日期数据类型获取数值数据类型的方法是使用`pandas.Series.dt`访问器对象。有关可用选项的更多信息，请参阅：[https://pandas.pydata.org/docs/reference/api/pandas.Series.dt.html](https://pandas.pydata.org/docs/reference/api/pandas.Series.dt.html)。
- en: Processing non-numerical data is an important step in creating performant models.
    If possible, any domain knowledge should be imparted to the training data features.
    For example, when forecasting the temperature using the date, like the dataset
    used in the prior exercises and activity of this chapter, encoding the month would
    be helpful since the temperature is likely highly correlated with the month of
    the year. Encoding the day of the week, however, may not be useful as there is
    likely no correlation between the day of the week and temperature. Using this
    domain knowledge can aid the model to learn the underlying relationship between
    the features and the target.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 处理非数值数据是创建高性能模型的重要步骤。如果可能，应将任何领域知识传授给训练数据特征。例如，使用日期预测温度，就像在本章前面的练习和活动中使用的数据集一样，对月份进行编码将是有帮助的，因为温度很可能与年份的月份高度相关。然而，编码星期几可能没有用，因为星期几与温度可能没有相关性。使用这些领域知识可以帮助模型学习特征与目标之间的潜在关系。
- en: In the next section, you will learn how to process image data so that it can
    be input into machine learning models.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何处理图像数据，以便将其输入到机器学习模型中。
- en: Processing Image Data
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理图像数据
- en: A plethora of images is being generated every day by various organizations that
    can be used to create predictive models for tasks such as object detection, image
    classification, and object segmentation. When working with image data and some
    other raw data types, you often need to preprocess the data. Creating models from
    raw data with minimal preprocessing is one of the biggest benefits of using ANNs
    for modeling since the feature engineering step is minimal. Feature engineering
    usually involves using domain knowledge to create features out of the raw data,
    which is time consuming and has no guarantee of improvements in model performance.
    Utilizing ANNs with no feature engineering streamlines the training process and
    has no need for domain knowledge.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 各种组织每天生成大量图像，这些图像可用于创建预测模型，例如对象检测、图像分类和对象分割。在处理图像数据和其他一些原始数据类型时，通常需要预处理数据。使用ANN进行建模的最大优势之一是从原始数据创建模型时的最小预处理步骤。特征工程通常涉及使用领域知识从原始数据中创建特征，这是耗时的，并不能保证模型性能的提高。利用无需特征工程的ANN简化了训练过程，并且不需要领域知识。
- en: For example, locating tumors in medical images requires expert knowledge from
    those who have been trained for many years, but for ANNs, all that is required
    is sufficient labeled data for training. There will be a small amount of preprocessing
    that generally needs to be applied to these images. These steps are optional but
    helpful for standardizing the training process and creating performant models.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在医学图像中定位肿瘤需要经过多年训练的专家知识，但对于人工神经网络（ANNs）而言，只需要足够的标注数据进行训练。通常需要对这些图像进行少量的预处理步骤。这些步骤是可选的，但对于标准化训练过程和创建高性能模型是有帮助的。
- en: One preprocessing step is rescaling. Since images have color values that are
    integers that range between `0` and `255`, they are scaled to have values between
    `0` and `1`, similar to *Activity 2.01*, *Loading Tabular Data and Rescaling Numerical
    Fields with a MinMax Scaler*. Another common preprocessing step that you will
    explore later in this section is image augmentation, which is essentially the
    act of augmenting images to add a greater number of training examples and build
    a more robust model.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一项预处理步骤是重新缩放。由于图像的颜色值是整数，范围从`0`到`255`，它们被缩放为介于`0`和`1`之间的值，类似于*活动 2.01*，*加载表格数据并使用
    MinMax Scaler 重新缩放数值字段*。另一种常见的预处理步骤是图像增强，稍后在本节中你将进一步探讨，它本质上是通过增强图像来添加更多的训练样本，从而构建一个更强大的模型。
- en: This section also covers batch processing. Batch processing loads in the training
    data one batch at a time. This can result in slower training times than if the
    data was loaded in at once; however, this does allow you to train your models
    on very large-volume datasets. Training on images or audio are examples that often
    require large volumes to achieve performant results.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本节还介绍了批处理。批处理一次加载一批训练数据。这可能导致比一次性加载数据更慢的训练时间；然而，这允许你在非常大体量的数据集上训练模型。图像或音频训练是需要大量数据来获得良好性能的典型例子。
- en: For example, a typical image may be 100 KB in size. For a training dataset of
    1 million images, you would need 100 GB of memory, which may be unattainable to
    most. If the model is trained in batches of 32 images, the memory requirement
    is orders of magnitude less. Batch training allows you to augment the training
    data, as you will explore in a later section.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个典型的图像可能是 100 KB 大小。对于 100 万张图像的训练数据集，你将需要 100 GB 的内存，这对大多数人来说可能是不可实现的。如果模型以
    32 张图像为一批进行训练，那么内存需求将小很多。批量训练使你能够增强训练数据，稍后在本节中你将进一步了解这一点。
- en: Images can be loaded into memory using a class named `ImageDataGenerator`, which
    can be imported from Keras' preprocessing package. This is a class originally
    from Keras that can now be used in TensorFlow. When loading in images, you can
    rescale them. It is common practice to rescale images by the value of 1/255 pixels.
    This means that images that have values from 0 to 255 will now have values from
    0 to 1\.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图像可以通过一个名为`ImageDataGenerator`的类加载到内存中，该类可以从 Keras 的预处理包中导入。这个类最初来自 Keras，现在也可以在
    TensorFlow 中使用。在加载图像时，你可以对它们进行重新缩放。通常的做法是将图像按 1/255 像素的值进行重新缩放。这意味着原本在 0 到 255
    范围内的图像值现在将位于 0 到 1 之间。
- en: '`ImageDataGenerator` can be initialized with rescaling, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageDataGenerator` 可以通过以下方式初始化并进行重新缩放：'
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once the `ImageDataGenerator` class has been initialized, you can use the `flow_from_directory`
    method and pass in the directory that the images are located in. The directory
    should include sub-directories labeled with the class labels, and they should
    contain the images of the corresponding class. Another argument to be passed in
    is the desired size for the images, the batch size, and the class mode. The class
    mode determines the type of label arrays that are produced. Using the `flow_from_directory`
    method for binary classification with a batch size of 25 and an image size of
    64x64 can be done as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始化了 `ImageDataGenerator` 类，你可以使用 `flow_from_directory` 方法并传入图像所在的目录。该目录应包括按类标签标记的子目录，并且这些子目录应包含相应类别的图像。另一个需要传入的参数是所需的图像大小、批量大小以及类模式。类模式决定了生成的标签数组的类型。以下是使用
    `flow_from_directory` 方法进行二分类的示例，批量大小为 25，图像大小为 64x64：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the following exercise, you will load images into memory by utilizing the
    `ImageDataGenerator` class.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，你将利用 `ImageDataGenerator` 类将图像加载到内存中。
- en: Note
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The image data provided comes from the Open Image dataset, a full description
    of which can be found here: [https://storage.googleapis.com/openimages/web/index.html](https://storage.googleapis.com/openimages/web/index.html).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的图像数据来自Open Image数据集，完整描述可以在这里找到：[https://storage.googleapis.com/openimages/web/index.html](https://storage.googleapis.com/openimages/web/index.html)。
- en: Images can be viewed by plotting them using Matplotlib. This is a useful exercise
    for verifying that the images match their respective labels.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用Matplotlib绘制图像来查看图像。这是验证图像是否与其相应标签匹配的一个有用练习。
- en: 'Exercise 2.03: Loading Image Data for Batch Processing'
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.03：加载用于批量处理的图像数据
- en: In this exercise, you'll learn how to load in image data for batch processing.
    The `image_data` folder contains a set of images of boats and airplanes. You will
    load the images of boats and airplanes for batch processing and rescale them so
    that the image values range between `0` and `1`. You are then tasked with printing
    the labeled images of a batch from the data generator.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，你将学习如何加载用于批量处理的图像数据。`image_data`文件夹包含一组船只和飞机的图像。你将加载船只和飞机的图像进行批量处理，并对它们进行重新缩放，使得图像值在`0`和`1`之间。然后，你的任务是打印出来自数据生成器的批次图像及其标签。
- en: Note
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find `image_data` here: [https://packt.link/jZ2oc](https://packt.link/jZ2oc).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此找到`image_data`：[https://packt.link/jZ2oc](https://packt.link/jZ2oc)。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成此练习：
- en: Open a new Jupyter notebook to implement this exercise. Save the file as `Exercise2-03.ipnyb`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Jupyter Notebook来实现本练习。将文件保存为`Exercise2-03.ipnyb`。
- en: 'In a new Jupyter Notebook cell, import the `ImageDataGenerator` class from
    `tensorflow.keras.preprocessing.image`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的Jupyter Notebook单元格中，从`tensorflow.keras.preprocessing.image`导入`ImageDataGenerator`类：
- en: '[PRE19]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Instantiate the `ImageDataGenerator` class and pass the `rescale` argument
    with the value `1./255` to convert image values so that they''re between `0` and
    `1`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化`ImageDataGenerator`类，并传递`rescale`参数，值为`1./255`，以将图像值转换为介于`0`和`1`之间：
- en: '[PRE20]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Use the data generator''s `flow_from_directory` method to direct the data generator
    to the image data. Pass in the arguments for the target size, the batch size,
    and the class mode:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数据生成器的`flow_from_directory`方法，指示数据生成器加载图像数据。传入目标尺寸、批次大小和类别模式的参数：
- en: '[PRE21]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a function to display the images in the batch. The function will plot
    the first 25 images in a 5x5 array with their associated labels:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数来显示批量图像。该函数将以5x5数组的形式绘制前25张图像及其对应的标签：
- en: '[PRE22]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Take a batch from the data generator and pass it to the function to display
    the images and their labels:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据生成器中获取一个批次并将其传递给函数以显示图像及其标签：
- en: '[PRE23]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output will be as follows:'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 2.12: The images from a batch'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.12：来自一批的图像'
- en: '](img/B16341_02_12.jpg)'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16341_02_12.jpg)'
- en: 'Figure 2.12: The images from a batch'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12：来自一批的图像
- en: Here, you can see the output of a batch of images of boats and airplanes that
    can be input into a model. Note that all the images are the same size, which was
    achieved by modifying the aspect ratio of the images. This ensures consistency
    in the images as they are passed into an ANN.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到一批船只和飞机的图像输出，这些图像可以输入到模型中。请注意，所有图像的大小相同，这是通过修改图像的长宽比实现的。这样可以确保图像在传入人工神经网络（ANN）时的一致性。
- en: In this exercise, you learned how to import images in batches so they can be
    used for training ANNs. Images are loaded one batch at a time and by limiting
    the number of training images per batch, you can ensure that the RAM of the machine
    is not exceeded.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，你将学习如何以批量的方式导入图像，以便它们可以用于训练人工神经网络（ANN）。图像是一次加载一个批次的，通过限制每个批次的训练图像数量，你可以确保不会超出计算机的RAM。
- en: In the following section, you will see how to augment images as they are loaded
    in.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，你将看到如何在图像加载时进行增强。
- en: Image Augmentation
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像增强
- en: Image augmentation is the process of modifying images to increase the number
    of training examples available. This process can include zooming in on the image,
    rotating the image, or flipping the image vertically or horizontally. This can
    be performed if the augmentation process does not change the context of the image.
    For example, an image of a banana, when flipped horizontally, is still recognizable
    as a banana, and new images of bananas are likely to be of either orientation.
    In this case, providing a model for both orientations during the training process
    will help build a robust model.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图像增强是通过修改图像来增加可用训练样本数量的过程。该过程可以包括放大图像、旋转图像或水平/垂直翻转图像。如果增强过程不会改变图像的上下文，则可以进行增强。例如，当香蕉图像水平翻转时，它仍然可以被识别为香蕉，并且新生成的香蕉图像很可能是任意方向的。在这种情况下，训练过程中提供模型的两种方向将有助于构建一个更强大的模型。
- en: However, if you have an image of a boat, it may not be appropriate to flip it
    vertically, as this does not represent how boats commonly exist in images, upside-down.
    Ultimately the goal of image augmentation is to increase the number of training
    images that resemble the object in its everyday occurrence, preserving the context.
    This will help the trained model perform well on new, unseen images. An example
    of image augmentation can be seen in the following figure, in which an image of
    a banana has been augmented three times; the left image is the original image,
    and those on the right are the augmented images.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您有一张船只的图像，垂直翻转可能不合适，因为这并不代表船只通常在图像中的存在方式——船只不会倒立。图像增强的最终目标是增加训练图像的数量，这些图像应与物体在日常生活中的出现方式相似，并保留其上下文。这有助于训练出的模型在面对新的、未见过的图像时表现良好。图像增强的一个例子可以在下图中看到，图中的香蕉图像经过了三次增强；左侧图像为原始图像，右侧图像为增强后的图像。
- en: 'The top-right image is the original image flipped horizontally, the middle-right
    image is the original image zoomed in by 15%, and the bottom-right image is the
    original image rotated by 10 degrees. After this augmentation process, you have
    four images of a banana, each of which has the banana in different positions and
    orientations:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 右上角的图像是原始图像水平翻转后的结果，右中间的图像是原始图像放大了 15%，右下角的图像是原始图像旋转了 10 度。经过这个增强过程后，您会得到四张香蕉图像，每张图像的香蕉处于不同的位置和方向：
- en: '![Figure 2.13: An example of image augmentation'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.13：图像增强示例'
- en: '](img/B16341_02_13.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16341_02_13.jpg)'
- en: 'Figure 2.13: An example of image augmentation'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13：图像增强示例
- en: 'Image augmentation can be achieved with TensorFlow''s `ImageDataGenerator`
    class when the images are loaded with each batch. Similar to image rescaling,
    various image augmentation processes can be applied. The arguments for common
    augmentation processes include the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图像增强可以通过 TensorFlow 的 `ImageDataGenerator` 类在每批图像加载时进行。与图像重缩放类似，可以应用多种图像增强过程。常见增强过程的参数包括：
- en: '`horizontal_flip`: Flips the image horizontally.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`horizontal_flip`：水平翻转图像。'
- en: '`vertical_flip`: Flips the image vertically.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vertical_flip`：垂直翻转图像。'
- en: '`rotation_range`: Rotates the image up to a given number of degrees.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotation_range`：旋转图像至指定的度数。'
- en: '`width_shift_range`: Shifts the image along its width axis up to a given fraction
    or pixel amount.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width_shift_range`：沿图像的宽度轴移动图像，最多移动指定的比例或像素量。'
- en: '`height_shift_range`: Shifts the image along its height axis up to a given
    fraction or pixel amount.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`height_shift_range`：沿图像的高度轴移动图像，最多移动指定的比例或像素量。'
- en: '`brightness_range`: Modifies the brightness of the image up to a given amount.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`brightness_range`：修改图像的亮度，最大可调整到指定的值。'
- en: '`shear_range`: Shears the image up to a given amount.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shear_range`：按指定量剪切图像。'
- en: '`zoom_range`: Zooms in the image up to a given amount.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zoom_range`：按指定的比例放大图像。'
- en: 'Image augmentation can be applied when instantiating the `ImageDataGenerator`
    class, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图像增强可以在实例化 `ImageDataGenerator` 类时应用，示例如下：
- en: '[PRE24]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the following activity, you perform image augmentation using TensorFlow's
    `ImageDataGenerator` class. The process is as simple as passing in parameters.
    You will use the same dataset that you used in *Exercise 2.03*, *Loading Image
    Data for Batch Processing*, which contains images of boats and airplanes.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下活动中，您将使用 TensorFlow 的 `ImageDataGenerator` 类进行图像增强。这个过程非常简单，只需要传入参数即可。您将使用与*练习
    2.03*、*批处理图像数据加载*中相同的数据集，该数据集包含了船只和飞机的图像。
- en: 'Activity 2.02: Loading Image Data for Batch Processing'
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 2.02：批处理图像数据加载
- en: In this activity, you will load image data for batch processing and augment
    the images in the process. The `image_data` folder contains a set of images of
    boats and airplanes. You are required to load in image data for batch processing
    and adjust the input data with random perturbations such as rotations, flipping
    the image horizontally, and adding shear to the images. This will create additional
    training data from the existing image data and will lead to more accurate and
    robust machine learning models by increasing the number of different training
    examples even if only a few are available. You are then tasked with printing the
    labeled images of a batch from the data generator.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将加载图像数据进行批处理，并在此过程中增强图像。`image_data`文件夹包含一组船只和飞机的图像。你需要加载图像数据进行批处理，并通过随机扰动（如旋转、水平翻转图像和为图像添加剪切）调整输入数据。这将从现有的图像数据中创建额外的训练数据，并通过增加不同的训练样本数来提高机器学习模型的准确性和鲁棒性，即使只有少量样本可用。接着，你的任务是打印出从数据生成器中提取的一批带标签的图像。
- en: 'The steps for this activity are as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的步骤如下：
- en: Open a new Jupyter notebook to implement this activity.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Jupyter notebook 来实现这个活动。
- en: Import the `ImageDataGenerator` class from `tensorflow.keras.preprocessing.image`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`tensorflow.keras.preprocessing.image`导入`ImageDataGenerator`类。
- en: Instantiate `ImageDataGenerator` and set the `rescale=1./255`, `shear_range=0.2`,
    `rotation_range=180`, `zoom_range=0.2`, and `horizontal_flip=True` arguments.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化`ImageDataGenerator`并设置`rescale=1./255`、`shear_range=0.2`、`rotation_range=180`、`zoom_range=0.2`和`horizontal_flip=True`参数。
- en: Use the `flow_from_directory` method to direct the data generator to the images
    while passing in the target size as `64x64`, a batch size of `25`, and the class
    mode as `binary`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`flow_from_directory`方法，将数据生成器指向图像，同时传入目标尺寸`64x64`、批量大小`25`，并将类别模式设置为`binary`。
- en: Create a function to display the first 25 images in a 5x5 array with their associated
    labels.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，将前25个图像按5x5的数组显示，并附上相关标签。
- en: Take a batch from the data generator and pass it to the function to display
    the images and their labels.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据生成器中取一个批次，并将其传递给函数以显示图像及其标签。
- en: Note
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found via [this link](B16341_Solution_ePub.xhtml#_idTextAnchor256).
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以通过[这个链接](B16341_Solution_ePub.xhtml#_idTextAnchor256)找到。
- en: In this activity, you augmented images in batches so they could be used for
    training ANNs. You've seen that when images are used as input, they can be augmented
    to generate a larger number of effective training examples.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你批量增强了图像，使其可以用于训练人工神经网络（ANNs）。你已经看到，当图像作为输入时，它们可以被增强以生成更多有效的训练样本。
- en: You learned how to load images in batches, which enables you to train on huge
    volumes of data that may not fit into the memory of your machine at one time.
    You also learned how to augment images using the `ImageDataGenerator` class, which
    essentially generates new training examples from the images in your training set.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你学会了如何批量加载图像，这使得你可以在巨大的数据量上进行训练，而这些数据可能无法一次性全部加载到机器的内存中。你还学会了如何使用`ImageDataGenerator`类增强图像，它本质上是从训练集中的图像生成新的训练样本。
- en: In the next section, you will learn how to load and preprocess text data.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何加载和预处理文本数据。
- en: Text Processing
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本处理
- en: Text data represents a large class of raw data that is readily available. For
    example, text data can be from web pages such as Wikipedia, transcribed speech,
    or social media conversations—all of which are increasing at a massive scale and
    must be processed before they can be used for training machine learning models.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 文本数据代表了一大类易于获取的原始数据。例如，文本数据可以来自网页，如维基百科、转录的语音或社交媒体对话——这些数据量在大规模增加，且在用于训练机器学习模型之前必须进行处理。
- en: 'Working with text data can be challenging for several different reasons, including
    the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 处理文本数据可能会面临多种挑战，包括以下几种：
- en: Thousands of different words exist.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在成千上万种不同的单词。
- en: Different languages present challenges.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的语言带来了不同的挑战。
- en: Text data often varies in size.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本数据通常在大小上有所不同。
- en: There are many ways to convert text data into a numerical representation. One
    way is to one-hot encode the words, much like you did with the date field in *Exercise 2.02*,
    *Preprocessing Non-Numerical Data*. However, this presents issues when training
    models since large datasets with many unique words will result in a sparse dataset
    and can lead to slow training speeds and potentially inaccurate models. Moreover,
    if a new word is encountered that was not in the training data, the model cannot
    use that word.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以将文本数据转换为数值表示。一种方法是对单词进行独热编码，这就像你在*练习 2.02*中处理日期字段时做的那样，*预处理非数值数据*。然而，这在训练模型时会带来问题，因为如果数据集包含大量独特的单词，就会导致数据稀疏，从而可能导致训练速度缓慢并且模型可能不准确。此外，如果遇到一个新单词，而这个单词不在训练数据中，模型就无法使用该单词。
- en: 'One popular method that''s used to represent text data is to convert the entire
    piece of text into embedding vectors. Pretrained models exist to convert raw text
    into vectors. These models are usually trained on large volumes of text. Using
    word embedding vectors from pretrained models has some distinct advantages:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常用的方法是将整个文本转换为嵌入向量。已有预训练模型将原始文本转换为向量。这些模型通常在大量文本数据上训练。使用预训练模型的单词嵌入向量具有一些明显的优势：
- en: The resulting vectors have a fixed size.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果向量的大小是固定的。
- en: The vectors maintain contextual information, so they benefit from transfer learning.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量保持上下文信息，因此它们能受益于迁移学习。
- en: No further preprocessing of the data needs to be done and the results of the
    embedding can be fed directly into an ANN.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要对数据进行进一步的预处理，嵌入的结果可以直接输入到人工神经网络（ANN）中。
- en: 'While TensorFlow Hub will be covered in more depth in the next chapter, the
    following is an example of how to use pretrained models as a preprocessing step.
    To load in the pretrained model, you need to import the `tensorflow_hub` library.
    By doing this, the URL of the model can be loaded. Then, the model can be loaded
    into the environment by calling the `KerasLayer` class, which wraps the model
    so that it can be used like any other TensorFlow model. It can be created as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然TensorFlow Hub将在下一章中更深入地讲解，但下面是如何将预训练模型用作预处理步骤的示例。要加载预训练模型，您需要导入`tensorflow_hub`库。通过这样做，可以加载模型的URL。然后，可以通过调用`KerasLayer`类将模型加载到环境中，`KerasLayer`类会将模型封装，使其可以像其他TensorFlow模型一样使用。可以如下创建：
- en: '[PRE25]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The data type of the input data, indicated by the `dtype` parameter, should
    be used as input for the `KerasLayer` class, as well as a Boolean argument indicating
    whether the weights are trainable. Once the model has been loaded using the `tensorflow_hub`
    library, it can be called on text data, as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数据的数据类型，由`dtype`参数指示，应作为输入传递给`KerasLayer`类，同时还需要一个布尔参数，指示权重是否可训练。一旦使用`tensorflow_hub`库加载了模型，就可以在文本数据上调用它，如下所示：
- en: '[PRE26]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This will run the data through the pretrained model. The output will be based
    on the architecture and weights of the pretrained model.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过预训练模型运行数据。输出将基于预训练模型的架构和权重。
- en: In the following exercise, you will explore how to load in data that includes
    a text field, batch the dataset, and apply a pretrained model to the text field
    to convert the field into embedded vectors.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的练习中，您将学习如何加载包含文本字段的数据，批量处理数据集，并将预训练模型应用于文本字段，将该字段转换为嵌入向量。
- en: Note
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The pretrained model can be found here: [https://tfhub.dev/google/tf2-preview/gnews-swivel-20dim/1](https://tfhub.dev/google/tf2-preview/gnews-swivel-20dim/1).'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 预训练模型可以在这里找到：[https://tfhub.dev/google/tf2-preview/gnews-swivel-20dim/1](https://tfhub.dev/google/tf2-preview/gnews-swivel-20dim/1)。
- en: 'The dataset can be found here: [https://archive.ics.uci.edu/ml/datasets/Drug+Review+Dataset+%28Drugs.com%29](https://archive.ics.uci.edu/ml/datasets/Drug+Review+Dataset+%28Drugs.com%29).'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集可以在这里找到：[https://archive.ics.uci.edu/ml/datasets/Drug+Review+Dataset+%28Drugs.com%29](https://archive.ics.uci.edu/ml/datasets/Drug+Review+Dataset+%28Drugs.com%29)。
- en: 'Exercise 2.04: Loading Text Data for TensorFlow Models'
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.04：为TensorFlow模型加载文本数据
- en: The dataset, `drugsComTrain_raw.tsv`, contains information related to patient
    reviews on specific drugs, along with their related conditions and a rating indicating
    the patient's satisfaction with the drug. In this exercise, you will load in text
    data for batch processing. You will apply a pretrained model from TensorFlow Hub
    to perform a word embedding on the patient reviews. You are required to work on
    the `review` field only as that contains text data.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集`drugsComTrain_raw.tsv`包含与患者对特定药物的评价相关的信息，包括患者对药物的满意度评分以及与之相关的病情。在本练习中，您将加载文本数据进行批处理。您将应用一个来自TensorFlow
    Hub的预训练模型，对患者评论进行词嵌入。您需要只处理`review`字段，因为该字段包含文本数据。
- en: 'Perform the following steps:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Open a new Jupyter notebook to implement this exercise. Save the file as `Exercise2-04.ipnyb`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Jupyter notebook 来实现这个练习。将文件保存为`Exercise2-04.ipnyb`。
- en: 'In a new Jupyter Notebook cell, import the TensorFlow library:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的 Jupyter Notebook 单元格中，导入 TensorFlow 库：
- en: '[PRE27]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a TensorFlow dataset object using the library''s `make_csv_dataset`
    function. Set the `batch_size` argument equal to `1` and the `field_delim` argument
    to `''\t''` since the dataset is tab-delimited:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用库的`make_csv_dataset`函数创建一个 TensorFlow 数据集对象。将`batch_size`参数设置为`1`，并将`field_delim`参数设置为`\t`，因为数据集是制表符分隔的：
- en: '[PRE28]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a function that takes a dataset object as input and shuffles, repeats,
    and batches the dataset:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，将数据集对象作为输入，并对数据集进行洗牌、重复和批处理：
- en: '[PRE29]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Apply the function to the dataset object you created in *Step 3*, setting `batch_size`
    equal to `5`:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对您在*步骤3*中创建的数据集对象应用该函数，设置`batch_size`等于`5`：
- en: '[PRE30]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Take the first batch and print it out:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取第一批数据并打印出来：
- en: '[PRE31]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You should get output similar to the following:'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该会看到类似以下的输出：
- en: '![Figure 2.14: A batch from the dataset object'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.14：来自数据集对象的一批数据'
- en: '](img/B16341_02_14.jpg)'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16341_02_14.jpg)'
- en: 'Figure 2.14: A batch from the dataset object'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.14：来自数据集对象的一批数据
- en: The output represents the input data in tensor format.
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出表示输入数据的张量格式。
- en: 'Import the pretrained word embedding model from TensorFlow Hub and create a
    Keras layer:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 TensorFlow Hub 导入预训练的词嵌入模型，并创建一个 Keras 层：
- en: '[PRE32]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Take one batch from the dataset, flatten the tensor corresponding to the `review`
    field, apply the pretrained layer, and print it out:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据集中取出一批数据，展平对应`review`字段的张量，应用预训练层并打印输出：
- en: '[PRE33]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This will display the following output:'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将显示以下输出：
- en: '![Figure 2.15: A batch of the review column after the pretrained model'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.15：应用预训练模型后，评论列的一批数据'
- en: has been applied to the text
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 已应用于文本
- en: '](img/B16341_02_15.jpg)'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16341_02_15.jpg)'
- en: 'Figure 2.15: A batch of the review column after the pretrained model has been
    applied to the text'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15：应用预训练模型后，评论列的一批数据
- en: The preceding output represents the embedding vectors for the first batch of
    drug reviews. The specific values may not mean much at first glance but encoded
    within the embeddings is contextual information based on the dataset that the
    embedding model was trained upon. The batch size is equal to `5` and the embedding
    vector size is `20`, which means the resulting size, after applying the pretrained
    layer, is `5x20`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出表示了第一批药物评论的嵌入向量。具体的值乍一看可能没有太大意义，但嵌入中编码了基于数据集的信息，这些数据集是嵌入模型训练的基础。批处理大小为`5`，嵌入向量的大小为`20`，这意味着在应用预训练层后，得到的大小为`5x20`。
- en: In this exercise, you learned how to import tabular data that might contain
    a variety of data types. You took the `review` field and applied a pretrained
    word embedding model to convert the text into a numerical tensor. Ultimately,
    you preprocessed and batched the text data so that it was appropriate for large-scale
    training. This is one way to represent text so that it can be input into machine
    learning models in TensorFlow. In fact, other pretrained word embedding models
    can be used and are available on TensorFlow Hub. You will learn more about how
    to utilize TensorFlow Hub in the next chapter.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，您学习了如何导入可能包含各种数据类型的表格数据。您处理了`review`字段，并应用了预训练的词嵌入模型，将文本转换为数值张量。最终，您对文本数据进行了预处理和批处理，使其适合大规模训练。这是一种表示文本的方式，使其能够输入到TensorFlow的机器学习模型中。实际上，还可以使用其他预训练的词嵌入模型，这些模型可以在TensorFlow
    Hub上找到。在下一章中，您将进一步学习如何使用 TensorFlow Hub。
- en: In this section, you learned about one way to preprocess text data for use in
    machine learning models. There are a number of different methods you could have
    used to generate a numerical tensor from the text. For example, you could have
    one-hot encoded the words, removed the stop words, stemmed and lemmatized the
    words, or even done something as simple as counting the number of words in each
    review. The method demonstrated in this section is advantageous as it is simple
    to implement. Also, the word embedding incorporates contextual information in
    the text that is difficult to encode in other methods, such as one-hot encoding.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你了解了如何为机器学习模型预处理文本数据的一种方法。实际上，你可以使用许多不同的方法来生成数值张量，例如，可以对单词进行独热编码、去除停用词、进行词干提取和词形还原，或者甚至做一些简单的操作，如统计每个评论中的单词数量。本节展示的方法具有优势，因为它简单易实施。此外，词嵌入方法能够结合文本中的上下文信息，而这些信息在其他方法中（如独热编码）难以编码。
- en: Ultimately, it is up to the practitioner to apply any domain knowledge to the
    preprocessing step to retain as much contextual information as possible. This
    will allow any subsequent models to learn the underlying function between the
    features and the target variable.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，是否将任何领域知识应用于预处理步骤以保留尽可能多的上下文信息，取决于实践者自身。这将使任何后续模型能够学习特征和目标变量之间的潜在函数。
- en: In the next section, you will learn how to load and process audio data so that
    the data can be used for TensorFlow models.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将学习如何加载和处理音频数据，以便这些数据可以用于 TensorFlow 模型。
- en: Audio Processing
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频处理
- en: 'This section will demonstrate how to load audio data in batches, as well as
    how to process it so that it can be used to train machine learning models. There
    is some advanced signal processing that takes place to preprocess audio files.
    Some of these steps are optional, but they are presented to provide a comprehensive
    approach to processing audio data. Since each audio file can be hundreds of KB,
    you will utilize batch processing, as you did when processing image data. Batch
    processing can be achieved by creating a dataset object. A generic method for
    creating a dataset object from raw data is using TensorFlow''s `from_tensor_slice`
    function. This function generates a dataset object by slicing a tensor along its
    first dimension. It can be used as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将演示如何批量加载音频数据，以及如何处理它以便用于训练机器学习模型。音频文件的预处理涉及一些高级信号处理步骤。这些步骤有些是可选的，但为了提供全面的音频数据处理方法，我们将呈现这些步骤。由于每个音频文件可能有数百
    KB，因此你将利用批处理，就像处理图像数据时一样。批处理可以通过创建数据集对象来实现。创建数据集对象的一种通用方法是使用 TensorFlow 的 `from_tensor_slice`
    函数。此函数通过沿张量的第一维切片来生成数据集对象，使用方式如下：
- en: '[PRE34]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Loading audio data into a Python environment can be achieved using TensorFlow
    by reading the file into memory using the `read_file` function, then decoding
    the file using the `decode_wav` function. When using the `decode_wav` function,
    the sample rate, which represents how many data points comprise 1 second of data,
    as well as the desired channel to use must be passed in as arguments. For example,
    if a value of `-1` is passed for the desired channel, then all the audio channels
    will be decoded. Importing the audio file can be achieved as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 TensorFlow 将音频数据加载到 Python 环境中，方法是使用 `read_file` 函数将文件读取到内存中，然后使用 `decode_wav`
    函数解码文件。在使用 `decode_wav` 函数时，必须传入样本率（即表示 1 秒钟数据点的数量）以及所需的通道。例如，如果传入 `-1` 作为所需通道的值，则将解码所有音频通道。导入音频文件的方式如下：
- en: '[PRE35]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As with text data, you must preprocess the data so that the resulting numerical
    tensor has the same size as the data. This is achieved by sampling the audio file
    after converting the data into the frequency domain. Sampling the audio can be
    thought of as splitting the audio file into chunks that are always the same size.
    For example, a 30-second audio file can be split into 30 1-second non-overlapping
    audio samples, and in the same way, a 15-second audio file can be split into 15
    1-second non-overlapping samples. Thus, your result is 45 equally sized audio
    samples.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 与文本数据一样，你必须对数据进行预处理，以便生成的数值张量与数据的大小相匹配。这是通过在将数据转换到频域后对音频文件进行采样来实现的。音频采样可以看作是将音频文件切割成始终相同大小的片段。例如，一个
    30 秒的音频文件可以切分成 30 个 1 秒钟的不重叠音频样本，同样，一个 15 秒钟的音频文件可以切分成 15 个 1 秒钟的不重叠样本。这样，最终你会得到
    45 个大小相同的音频样本。
- en: Another common preprocessing step that can be performed on audio data is to
    convert the audio sample from the time domain into the frequency domain. Interpreting
    the data in the time domain is useful for understanding the intensity or volume
    of the audio, whereas the frequency domain can help you discover which frequencies
    are present. This is useful for classifying sounds since different objects have
    different characteristic sounds that will be present in the frequency domain.
    Audio data can be converted from the time domain into the frequency domain using
    the `stft` function.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的音频数据预处理步骤是将音频样本从时域转换到频域。在时域解释数据对于理解音频的强度或音量很有用，而频域则能帮助你发现哪些频率是存在的。这对于声音分类非常有用，因为不同的物体具有不同的特征声音，这些特征声音会出现在频域中。可以使用
    `stft` 函数将音频数据从时域转换到频域。
- en: 'This function takes the short-time Fourier transform of the input data. The
    arguments to the function include the frame length, which is an integer value
    that indicates the window length in samples; the frame step, which is an integer
    value that describes the number of samples to step; and the **Fast Fourier Transform**
    (**FFT**) length, which is an integer value that indicates the length of the FFT
    to apply. A spectrogram is the absolute value of the short-time Fourier transform
    as it is useful for visual interpretation. The short-time Fourier transform and
    spectrogram can be created as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数对输入数据进行短时傅里叶变换。函数的参数包括帧长度，这是一个整数值，表示窗口的长度（单位为样本）；帧步长，这是一个整数值，描述了每次步进的样本数；以及
    **快速傅里叶变换** (**FFT**) 长度，这是一个整数值，表示要应用的 FFT 长度。频谱图是短时傅里叶变换的绝对值，因为它对视觉解释非常有用。可以按以下方式创建短时傅里叶变换和频谱图：
- en: '[PRE36]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Another optional preprocessing step is to generate the **Mel-Frequency Cepstral
    Coefficients** (**MFCCs**). As the name suggests, the MFCCs are the coefficients
    of the mel-frequency cepstrum. The cepstrum is a representation of the short-term
    power spectrum of an audio signal. MFCCs are commonly used in applications for
    speech recognition and music information retrieval. As such, it may not be important
    to understand each step of how the MFCCs are generated but understanding that
    they can be applied as a preprocessing step to increase the information density
    of the audio data pipeline is beneficial.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可选的预处理步骤是生成 **梅尔频率倒谱系数** (**MFCCs**)。顾名思义，MFCC 是梅尔频率倒谱的系数。倒谱是音频信号短时功率谱的表示。MFCC
    常用于语音识别和音乐信息检索等应用。因此，理解每一步 MFCC 的生成过程可能并不重要，但理解它们可以作为预处理步骤来增加音频数据管道的信息密度是非常有益的。
- en: MFCCs are generated by creating a matrix to warp the linear scale to the mel
    scale. This matrix can be created using `linear_to_mel_weight_matrix` and by passing
    in the number of bands in the resulting mel spectrum, the number of bins in the
    source spectrogram, the sample rate, and the lower and upper frequencies to be
    included in the mel spectrum. Once the linear-to-mel weight matrix has been created,
    a tensor contraction with the spectrograms is applied along the first axis using
    the `tensordot` function.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: MFCC 是通过创建一个矩阵，将线性尺度映射到梅尔尺度来生成的。这个矩阵可以通过使用 `linear_to_mel_weight_matrix` 来创建，并传入生成的梅尔频谱中的带数、源频谱图中的频带数、采样率，以及要包含在梅尔频谱中的最低和最高频率。一旦线性到梅尔的权重矩阵创建完成，就可以使用
    `tensordot` 函数在第一个轴上对频谱图进行张量收缩。
- en: 'Following this, the log of the values is applied to generate the log mel spectrograms.
    Finally, the `mfccs_from_log_mel_spectrograms` function can be applied to generate
    the MFCCs that are passing in the log mel spectrograms. These steps can be applied
    as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，应用对值的对数转换以生成对数梅尔频谱图。最后，可以应用 `mfccs_from_log_mel_spectrograms` 函数，传入对数梅尔频谱图来生成
    MFCC。以下是这些步骤的应用方法：
- en: '[PRE37]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the following exercise, you will understand how audio data can be processed.
    In a similar manner to what you did in *Exercise 2.03*, *Loading Image Data for
    Batch Processing*, and *Exercise* *2.04*, *Loading Text Data for TensorFlow Models*,
    you will load the data in batches for efficient and scalable training. You will
    load in the audio files using TensorFlow's generic `read_file` function, then
    decode the audio data using TensorFlow's `decode_wav` function. You will then
    create a function that will generate the MFCCs from each audio sample. Finally,
    a dataset object will be generated that can be passed into a TensorFlow model
    for training. The dataset that you will be utilizing is Google's speech commands
    dataset, which consists of 1-second-long utterances of words.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，你将了解如何处理音频数据。与之前的*练习 2.03*，*加载图像数据以进行批量处理*，以及*练习 2.04*，*为 TensorFlow
    模型加载文本数据*类似，你将批量加载数据以提高训练效率和可扩展性。你将使用 TensorFlow 的通用 `read_file` 函数加载音频文件，然后使用
    TensorFlow 的 `decode_wav` 函数解码音频数据。接着，你将创建一个函数，从每个音频样本中生成 MFCC（梅尔频率倒谱系数）。最后，将生成一个数据集对象，传递给
    TensorFlow 模型进行训练。你将使用的数据集是 Google 的语音命令数据集，包含时长为 1 秒的单词发音。
- en: Note
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The dataset can be found here: [https://packt.link/Byurf](https://packt.link/Byurf).'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集可以在这里找到：[https://packt.link/Byurf](https://packt.link/Byurf)。
- en: 'Exercise 2.05: Loading Audio Data for TensorFlow Models'
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.05：为 TensorFlow 模型加载音频数据
- en: In this exercise, you'll learn how to load in audio data for batch processing.
    The dataset, `data_speech_commands_v0.02`, contains speech samples of people speaking
    the word `zero` for exactly 1 second with a sample rate of 44.1 kHz, meaning that
    for every second, there are 44,100 data points. You will apply some common audio
    preprocessing techniques, including converting the data into the Fourier domain,
    sampling the data to ensure the data has the same size as the model, and generating
    MFCCs for each audio sample. This will generate a preprocessed dataset object
    that can be input into a TensorFlow model for training.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，你将学习如何为批量处理加载音频数据。数据集 `data_speech_commands_v0.02` 包含人们发音单词 `zero` 的语音样本，时长恰好为
    1 秒，采样率为 44.1 kHz，意味着每秒有 44,100 个数据点。你将应用一些常见的音频预处理技术，包括将数据转换到傅里叶域、对数据进行采样以确保数据与模型大小一致，并为每个音频样本生成
    MFCC。这样将生成一个预处理的数据集对象，可以输入到 TensorFlow 模型进行训练。
- en: 'Perform the following steps:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Open a new Jupyter notebook to implement this exercise. Save the file as `Exercise2-05.ipnyb`.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Jupyter Notebook 来实现这个练习。将文件保存为 `Exercise2-05.ipnyb`。
- en: 'In a new Jupyter Notebook cell, import the `tensorflow` and `os` libraries:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的 Jupyter Notebook 单元中，导入 `tensorflow` 和 `os` 库：
- en: '[PRE38]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create a function that will load an audio file using TensorFlow''s `read_file`
    function and `decode_wav` function, respectively. Return the transpose of the
    resultant tensor:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，分别使用 TensorFlow 的 `read_file` 和 `decode_wav` 函数加载音频文件，并返回结果张量的转置：
- en: '[PRE39]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Load in the paths to the audio data as a list using `os.list_dir`:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `os.list_dir` 将音频数据的路径作为列表加载：
- en: '[PRE40]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Test the function by loading in the first audio file from the list and plotting
    it:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试函数，通过加载列表中的第一个音频文件并绘制它来验证：
- en: '[PRE41]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output will be as follows:'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 2.16: A visual representation of an audio file'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.16：音频文件的可视化表示'
- en: '](img/B16341_02_16.jpg)'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16341_02_16.jpg)'
- en: 'Figure 2.16: A visual representation of an audio file'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.16：音频文件的可视化表示
- en: The figure shows the waveform of the speech sample. The amplitude at a given
    time corresponds to the volume of the sound; high amplitude relates to high volume.
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图示显示了语音样本的波形。在某一时刻的振幅对应声音的音量；高振幅表示高音量。
- en: 'Create a function to generate the MFCCs from the audio data. First, apply the
    short-time Fourier transform passing in the audio signal as the first argument,
    the frame length set to `1024` as the second argument, the frame step set to `256`
    as the third argument, and the FFT length as the fourth parameter. Then, take
    the absolute value of the result to compute the spectrograms. The number of spectrogram
    bins is given by the length along the last axis of the short-time Fourier transform.
    Next, define the upper and lower bounds of the mel weight matrix as `80` and `7600`
    respectively and the number of mel bins as `80`. Then, compute the mel weight
    matrix using `linear_to_mel_weight_matrix` from TensorFlow''s signal package.
    Next, compute the mel spectrograms via tensor contraction using TensorFlow''s
    `tensordot` function along axis 1 of the spectrograms with the mel weight matrix.
    Then, take the log of the mel spectrograms before finally computing the MFCCs
    using TensorFlow''s `mfccs_from_log_mel_spectrograms` function. Then, return the
    MFCCs from the function:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，从音频数据中生成MFCC。首先，应用短时傅里叶变换，将音频信号作为第一个参数，帧长设置为`1024`作为第二个参数，帧步长设置为`256`作为第三个参数，FFT长度作为第四个参数。然后，取结果的绝对值来计算频谱图。频谱图的bin数由短时傅里叶变换的最后一个维度长度给出。接下来，定义mel权重矩阵的上下限分别为`80`和`7600`，mel的bin数为`80`。然后，使用TensorFlow的信号包中的`linear_to_mel_weight_matrix`计算mel权重矩阵。接着，通过张量收缩使用TensorFlow的`tensordot`函数，沿频谱图的第1轴与mel权重矩阵进行计算，得到mel频谱图。然后，对mel频谱图取对数，最后使用TensorFlow的`mfccs_from_log_mel_spectrograms`函数计算MFCC。最后，从函数中返回MFCC。
- en: '[PRE42]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Apply the function to generate the MFCCs for the audio data you loaded in *Step 5*:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用该函数为你在*步骤 5*中加载的音频数据生成MFCC：
- en: '[PRE43]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output will be as follows:'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Figure 2.17: A visual representation of the MFCCs of an audio file'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.17：音频文件MFCC的可视化表示'
- en: '](img/B16341_02_17.jpg)'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16341_02_17.jpg)'
- en: 'Figure 2.17: A visual representation of the MFCCs of an audio file'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.17：音频文件MFCC的可视化表示
- en: The preceding plot shows the MFCC values on the *x* axis and various points
    of the audio sample on the *y* axis. MFCCs are a different representation of the
    raw audio signal displayed in *Step 5* that has been proven to be useful in applications
    related to speech recognition.
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上面的图表显示了MFCC值在*x*轴上的分布，以及音频样本在*y*轴上的不同点。MFCC是原始音频信号的另一种表示方式，显示在*步骤 5*中，已被证明在语音识别相关应用中非常有用。
- en: 'Load `AUTOTUNE` so that you can use all the available threads of the CPU. Create
    a function that will take a dataset object, shuffle it, load the audio using the
    function you created in *Step 3*, generate the MFCCs using the function you created
    in *Step 6*, repeat the dataset object, batch it, and prefetch it. Use `AUTOTUNE`
    to prefetch with a buffer size based on your available CPU:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载`AUTOTUNE`，以便可以使用CPU的所有可用线程。创建一个函数，接受数据集对象，打乱数据集，使用你在*步骤 3*中创建的函数加载音频数据，使用你在*步骤
    6*中创建的函数生成MFCC，重复数据集对象，进行批处理，并进行预取操作。使用`AUTOTUNE`来根据可用的CPU预取数据，并设置缓冲区大小：
- en: '[PRE44]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Generate the training dataset using the function you created in *Step 8*. To
    do this, create a dataset object using TensorFlow''s `from_tensor_slices` function
    and pass in the paths to the audio files. After that, you can use the function
    you created in *Step 8*:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你在*步骤 8*中创建的函数生成训练数据集。为此，使用TensorFlow的`from_tensor_slices`函数创建数据集对象，并传入音频文件的路径。之后，你可以使用你在*步骤
    8*中创建的函数：
- en: '[PRE45]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Take the first batch of the dataset and print it out:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取数据集的第一批并打印出来：
- en: '[PRE46]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output will be as follows:'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Figure 2.18: A batch of the audio data after the MFCCs have been generated'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.18：生成MFCC后的一批音频数据'
- en: '](img/B16341_02_18.jpg)'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16341_02_18.jpg)'
- en: 'Figure 2.18: A batch of the audio data after the MFCCs have been generated'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18：生成MFCC后的一批音频数据
- en: The output shows the first batch of MFCC spectrum values in tensor form.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了第一批MFCC频谱值的张量形式。
- en: In this exercise, you imported audio data. You processed the dataset and batched
    the dataset so that it is appropriate for large-scale training. This method was
    a comprehensive approach in which the data was loaded and converted into the frequency
    domain, spectrograms were generated, and then finally the MFCCs were generated.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你导入了音频数据。你处理了数据集并对数据集进行了批处理，以便它适合大规模训练。这个方法是一个综合性的方案，其中数据被加载并转换到频域，生成了频谱图，然后最终生成了MFCC。
- en: In the next activity, you will load in audio data and take the absolute value
    of the input, followed by scaling the values logarithmically. This will ensure
    that there are no negative values in the dataset. You will use the same audio
    dataset that you used in *Exercise 2.05*, *Loading Audio Data for TensorFlow Models*,
    that is, Google's speech commands dataset. This dataset consists of 1-second-long
    utterances of words.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个活动中，你将加载音频数据并取输入的绝对值，随后对值进行对数缩放。这将确保数据集中没有负值。你将使用与*练习2.05*中使用的相同音频数据集，即Google的语音命令数据集。该数据集包含1秒钟长的单词发音。
- en: 'Activity 2.03: Loading Audio Data for Batch Processing'
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动2.03：为批处理加载音频数据
- en: In this activity, you will load audio data for batch processing. The audio preprocessing
    techniques that will be performed include taking the absolute value and using
    the logarithm of 1 plus the value. This will ensure the resulting values are non-negative
    and logarithmically scaled. The result will be a preprocessed dataset object that
    can be input into a TensorFlow model for training.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，你将加载音频数据进行批处理。所执行的音频预处理技术包括取绝对值并使用1加上该值的对数。这样可以确保结果值为非负且以对数形式缩放。最终结果将是一个可以输入到TensorFlow模型中进行训练的预处理数据集对象。
- en: 'The steps for this activity are as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的步骤如下：
- en: Open a new Jupyter notebook to implement this activity.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Jupyter笔记本以实现此活动。
- en: Import the TensorFlow and `os` libraries.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入TensorFlow和`os`库。
- en: Create a function that will load and then decode an audio file using TensorFlow's
    `read_file` function followed by the `decode_wav` function, respectively. Return
    the transpose of the resultant tensor from the function.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，使用TensorFlow的`read_file`函数加载音频文件，然后使用`decode_wav`函数解码。返回函数的结果张量的转置。
- en: Load the file paths into the audio data as a list using `os.list_dir`.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`os.list_dir`将文件路径加载到音频数据列表中。
- en: Create a function that takes a dataset object, shuffles it, loads the audio
    using the function you created in *step 2*, and applies the absolute value and
    the `log1p` function to the dataset. This function adds `1` to each value in the
    dataset and then applies the logarithm to the result. Next, repeat the dataset
    object, batch it, and prefetch it with a buffer size equal to the batch size.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，该函数接受一个数据集对象，对其进行打乱，使用你在*步骤2*中创建的函数加载音频，并对数据集应用绝对值和`log1p`函数。此函数将数据集中的每个值加上`1`，然后对结果应用对数。接下来，重复数据集对象，对其进行批处理，并使用等于批处理大小的缓冲区大小进行预取。
- en: Create a dataset object using TensorFlow's `from_tensor_slices` function and
    pass in the paths to the audio files. Then, apply the function you created in
    *Step 4* to the dataset created in *Step 5*.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用TensorFlow的`from_tensor_slices`函数创建一个数据集对象，并传入音频文件的路径。然后，将你在*第4步*中创建的函数应用到*第5步*中创建的数据集上。
- en: Take the first batch of the dataset and print it out.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取数据集的第一批数据并打印出来。
- en: Plot the first audio file from the batch.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制批次中的第一个音频文件。
- en: 'The output will look as follows:'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![Figure 2.19: Expected output of Activity 2.03'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图2.19：活动2.03的预期输出'
- en: '](img/B16341_02_19.jpg)'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16341_02_19.jpg)'
- en: 'Figure 2.19: Expected output of Activity 2.03'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19：活动2.03的预期输出
- en: Note
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found via [this link](B16341_Solution_ePub.xhtml#_idTextAnchor257).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以通过[此链接](B16341_Solution_ePub.xhtml#_idTextAnchor257)找到。
- en: In this activity, you learned how to load and preprocess audio data in batches.
    You used most of the functions that you used in *Exercise 2.05*, *Loading Audio
    Data for TensorFlow Models*, to load in the data and decode the raw data. The
    difference between *Exercise 2.05*, *Loading Audio Data for TensorFlow Models*,
    and *Activity 2.03*, *Loading Audio Data for Batch Processing*, is the preprocessing
    steps; *Exercise 2.05*, *Loading Audio Data for TensorFlow Models*, involved generating
    MFCCs for the audio data, whereas *Activity 2.03*, *Loading Audio Data for Batch
    Processing*, involved scaling the data logarithmically. Both demonstrate common
    preprocessing techniques that can be used for all applications involving modeling
    on audio data.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，你学习了如何批量加载和预处理音频数据。你使用了在*练习2.05*中使用的大部分函数，加载数据并解码原始数据。*练习2.05*与*活动2.03*之间的区别在于预处理步骤；*练习2.05*涉及为音频数据生成MFCC，而*活动2.03*则涉及对数据进行对数缩放。两者展示了可以用于所有音频数据建模应用的常见预处理技术。
- en: In this section, you have explored how audio data can be loaded in batches for
    TensorFlow modeling. The comprehensive approach demonstrated many advanced signal
    processing techniques that should provide practitioners who wish to use audio
    data for their own applications with a good starting point.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你探索了如何将音频数据批量加载以用于 TensorFlow 模型。这个全面的方法展示了许多高级信号处理技术，这些技术为希望将音频数据应用于自己项目的从业者提供了良好的起点。
- en: Summary
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to load different forms of data and perform
    some preprocessing steps for a variety of data types. You began with tabular data
    in the form of a CSV file. Since the dataset consisted of a single CSV file, you
    utilized the pandas library to load the file into memory.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何加载不同形式的数据并为各种数据类型执行一些预处理步骤。你首先处理的是以 CSV 文件形式呈现的表格数据。由于数据集仅由一个 CSV
    文件组成，你使用了 pandas 库将文件加载到内存中。
- en: You then proceeded to preprocess the data by scaling the fields and converting
    all the fields into numerical data types. This is important since TensorFlow models
    can only be trained on numerical data, and the training process is improved in
    terms of speed and accuracy if all the fields are of the same scale.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你继续对数据进行预处理，通过缩放字段并将所有字段转换为数值数据类型。这一点很重要，因为 TensorFlow 模型只能对数值数据进行训练，如果所有字段的尺度相同，训练过程的速度和准确性都会得到提升。
- en: Next, you explored how to load the image data. You batched the data so that
    you did not have to load in the entire dataset at once, which allowed you to augment
    the images. Image augmentation is useful as it increases the effective number
    of training examples and can help make a model more robust.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你探索了如何加载图像数据。你将数据批处理，这样就不需要一次性加载整个数据集，这也让你能够对图像进行数据增强。图像增强是有用的，因为它增加了有效的训练示例数量，并且有助于让模型更加稳健。
- en: You then learned how to load in text data and took advantage of pretrained models.
    This helped you embed text into vectors that retain contextual information about
    the text. This allowed text data to be input into TensorFlow models since they
    require numerical tensors as inputs.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你学习了如何加载文本数据并利用预训练模型。这帮助你将文本嵌入到向量中，这些向量保留了关于文本的上下文信息。这样，你就可以将文本数据输入到 TensorFlow
    模型中，因为它们需要数值张量作为输入。
- en: Finally, the final section covered how to load and process audio data and demonstrated
    some advanced signal processing techniques, including generating MFCCs, which
    can be used to generate informationally dense numerical tensors that can be input
    into TensorFlow models.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一部分讲解了如何加载和处理音频数据，并展示了一些高级信号处理技术，包括生成 MFCC（梅尔频率倒谱系数），它们可以用于生成信息密集的数值张量，并可以输入到
    TensorFlow 模型中。
- en: Loading and preprocessing data so that it can be input into machine learning
    models is an important and necessary first step to training any machine learning
    model. In the next chapter, you will explore many resources that TensorFlow provides
    to aid in the development of model building.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 加载和预处理数据，以便将其输入到机器学习模型中，是训练任何机器学习模型的一个重要且必要的第一步。在下一章中，你将探索 TensorFlow 提供的许多资源，这些资源有助于模型构建的开发。
