- en: Designing Behavior Trees - Part III
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计行为树 - 第三部分
- en: This chapter is a continuation of the previous one, and is the final part of
    *Designing Behavior Trees*. We will finish what we started. In particular, we
    will build the final *Behavior Tree* and make it run.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是上一章的延续，是**设计行为树**的最后一部分。我们将完成我们开始的工作。特别是，我们将构建最终的行为树并使其运行。
- en: 'In particular, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们将涵盖以下主题：
- en: Generating the ***Blackboard*** and the ***Behavior Tree*** assets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成**黑板**和**行为树**资产
- en: Setting up the ***Blackboard*** so that it can be used with the *Behavior Tree*
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置黑板（**Blackboard**）以便与行为树一起使用
- en: Implementing the ***Behavior Tree ***(using either the Blueprint or C++ nodes)
    to make a Chasing Behavior
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现行为树（使用蓝图或C++节点）以创建追逐行为
- en: '***Making the Behavior Tree running*** (both in a Blueprint or C++)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使行为树运行**（在蓝图或C++中）'
- en: '***Improving the C++ nodes*** of the Behavior Tree to better align with *best
    practices*'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进行为树的C++节点**以更好地符合最佳实践'
- en: Once again, we will be implementing everything in both Blueprint and C++ to
    give you a broader idea of what you can use. Alternatively, if you already know
    what you want to use, you can just follow one of the two implementations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们将同时在蓝图和C++中实现一切，以给你一个更广泛的想法，了解你可以使用什么。或者，如果你已经知道你想要使用什么，你只需遵循两种实现中的任何一个。
- en: This will conclude our journey of *Designing a Behavior Tree* from scratch,
    and at the end, we will have our Chasing Behavior complete.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这将结束我们从零开始设计行为树的旅程，最终我们将拥有完整的功能追逐行为。
- en: So, without further ado, let's dive into building the *Behavior Tree*!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无需多言，让我们开始构建行为树！
- en: Building the Behavior Tree
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建行为树
- en: The last step in creating the Chasing Behavior is to build the Behavior Tree.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 创建追逐行为的最后一步是构建行为树。
- en: At this stage, if you feel like you have missed something, just revise the ***Expected
    Behavior*** (the one we have described in Chapter 8) and *do a checklist* of what
    you will need to build this *Behavior Tree*. However, even if you did miss something,
    don't worry – you can create it at a later stage.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，如果你觉得你遗漏了什么，只需回顾一下**预期行为**（我们在第8章中描述的那个）并**制作一个清单**，列出你需要构建这个行为树所需的内容。然而，即使你确实遗漏了什么，也不要担心——你可以在稍后阶段创建它。
- en: Many developers start developing the *Behavior Tree* and then build the nodes
    when they need them. Unless you are really good or the tree is particularly simple,
    it is always advisable to plan a little bit ahead, like we have did in the last
    two chapters. By doing this, you will avoid many headaches later on, and by having
    a little work overhead at the beginning, you avoid a large, bug-fixing time cost.
    Of course, you will still need to do bug fixing, but planning should reduce the
    chance of introducing bugs, or achieving a different behavior from the one that
    was originally planned.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者开始开发行为树，并在需要时构建节点。除非你真的很擅长或者树特别简单，否则始终建议提前做一些规划，就像我们在前两章中所做的那样。通过这样做，你将避免以后出现很多头痛的问题，并且通过在开始时稍微增加一些工作量，你可以避免大量的错误修复时间成本。当然，你仍然需要进行错误修复，但规划应该会减少引入错误或实现与最初计划不同的行为的机会。
- en: From this point onward, you can use the Blueprint and C++ implementations (in
    case you have been using both), or just stick to the one you have been using so
    far. I will use the names from the Blueprint implementation, but the concepts
    for using our C++ nodes are exactly the same. In the end, I'll show a screenshot
    of the *Behavior Tree* build with CPP nodes instead.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，你可以使用蓝图和C++实现（如果你之前两者都使用过），或者只坚持使用你迄今为止一直在使用的那个。我将使用蓝图实现中的名称，但使用我们的C++节点的概念是完全相同的。最后，我会展示一个使用CPP节点构建的行为树截图。
- en: It's worth noting that we can also create a Mix tree. In fact, we can use both
    the C++ and the Blueprint nodes in the same tree. Since, in our case, we have
    a replica of each node in both Blueprint and C++, we should be free to use any
    as we like. However, this is not true, because we have made some nodes depending
    on the C++ AI controller, which was specific for that implementation. Thankfully
    in a project, you will not have replicas of everything, so if you have a specific
    AI Controller, both Blueprint and C++ node should refer to the same one.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们还可以创建一个混合树。实际上，我们可以在同一个树中使用C++和蓝图节点。由于在我们的案例中，我们在蓝图和C++中都有每个节点的副本，我们可以随意使用任何一种。然而，这并不正确，因为我们已经创建了一些依赖于特定于该实现的C++
    AI控制器的节点。幸运的是，在一个项目中，您不会对一切都有副本，所以如果您有一个特定的AI控制器，蓝图和C++节点都应该引用同一个。
- en: During the development of your project, keep in mind that you can create some
    *Behavior Tree* nodes in C++ and some in Blueprint. Some developers prototype
    their nodes in Blueprint and then move the development to C++. Try to find the
    formula and the right balance between C++ and Blueprint that works best for you
    or your team.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在您项目的开发过程中，请记住，您可以在C++中创建一些*行为树*节点，在蓝图中也创建一些。一些开发者使用蓝图原型化他们的节点，然后将开发转移到C++。尝试找到C++和蓝图之间的公式和最佳平衡，这对您或您的团队来说是最有效的。
- en: 'To start, if you haven''t already, create the *Behavior Tree Asset*, along
    with the *Blackboard*. In my case, I''m going to call the *Behavior Tree* ***BT_ChasingBehavior ***and
    the Blackboard ***BB_ChasingBlackboard***. Both are placed in the AI folder (where
    we created our Blueprint nodes), as shown in the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果您还没有创建，请创建*行为树资产*和*黑板*。在我的情况下，我将把*行为树*命名为***BT_ChasingBehavior***，黑板命名为***BB_ChasingBlackboard***。两者都放在AI文件夹中（我们创建蓝图节点的地方），如图所示：
- en: '![](img/5cade3b5-f974-4890-9650-0754da2a9345.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5cade3b5-f974-4890-9650-0754da2a9345.png)'
- en: You can reorder the `AI` folder a bit by creating sub-folders. For instance,
    you can create a sub-folder for your Decorators, another for your Tasks, and a
    third for your Services. Either way, this is a relatively small example, so we
    will leave the folder as it is.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过创建子文件夹来稍微重新排列`AI`文件夹。例如，您可以为您的设计器创建一个子文件夹，为您的任务创建另一个子文件夹，为您的服务创建第三个子文件夹。无论如何，这是一个相对较小的示例，所以我们将保持文件夹不变。
- en: Setting up the Blackboard
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置黑板
- en: Let's start by opening the *Blackboard Editor* (double-click on the asset).
    As you may recall, we need to have a Player reference.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开*黑板编辑器*（双击资产）开始。如您所回忆的那样，我们需要有一个玩家引用。
- en: 'Thus, create a ***New Key*** of type ***Object***:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，创建一个类型为***对象***的***新键***：
- en: '![](img/e532a773-dcc8-4ecd-955f-baac6abd1e33.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e532a773-dcc8-4ecd-955f-baac6abd1e33.png)'
- en: 'Rename it ***Player***, and in the *Details Panel*, under the ***Key Type*** (you
    might need to expand this), set the ***Base Class*** to be the Player Pawn of
    our choice (e.g. ***Player***, the class we created at the beginning of this chapter),
    as shown in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将其重命名为***Player***，然后在*详情面板*下，在***键类型***（可能需要展开此选项），将***基础类***设置为我们的选择（例如，***Player***，我们在本章开头创建的类），如图所示：
- en: '![](img/ac15c42a-77e9-46ef-bceb-d3e483b3b3db.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ac15c42a-77e9-46ef-bceb-d3e483b3b3db.png)'
- en: 'The next *Key* to add is the ***Destination***, which is of type Vector. This
    will be useful for determining a goal when the player is not in sight. Speaking
    of which, we need a third Key of type *boolean* named ***CanSeePlayer***, which
    is used to check if the Player is currently in sight or not. This is what the
    values of the *Blackboard* should look like:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要添加的*键*是***目的地***，其类型为Vector。当玩家不在视线范围内时，这将有助于确定一个目标。说到这里，我们需要一个名为***CanSeePlayer***的第三个键，类型为*布尔值*，用于检查玩家当前是否在视线范围内。这就是*黑板*应该看起来像的样子：
- en: '![](img/64a60bea-219c-40e9-a02a-cb3db0977b0b.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/64a60bea-219c-40e9-a02a-cb3db0977b0b.png)'
- en: Building the Tree
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建树
- en: 'Double-click on the ***BT_ChasingBehavior*** asset to open the *Behavior Tree
    Editor*. Make sure that you have ***BB_ChasingBlackboard*** selected for the tree,
    as shown in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 双击***BT_ChasingBehavior***资产以打开*行为树编辑器*。确保您已选择树中的***BB_ChasingBlackboard***，如图所示：
- en: '![](img/12001228-7b7e-468b-9baa-572755f192f7.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/12001228-7b7e-468b-9baa-572755f192f7.png)'
- en: 'From the ***Root*** node, we need to start with a ***Selector***. This *Selector*
    will be where the tree will split into two branches: the one that will chase the
    Player when in sight, and the other when he/she isn''t. On this very *Selector*,
    we need to attach our ***BTService_UpdateChasingBehavior*** Service (or if you
    wish, its C++ version, named ***UpdatedChasing***). Don''t forget to assign all
    the variables in the *Details Panel* (the *three Blackboard variables*), as shown
    in the following screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从**根**节点开始，我们需要一个**选择器**。这个**选择器**将是树将分为两个分支的地方：一个是在视线中追逐玩家时，另一个是在他/她不在视线中时。在这个**选择器**上，我们需要附加我们的**BTService_UpdateChasingBehavior**服务（或者如果您愿意，它的C++版本，命名为**UpdatedChasing**）。别忘了在**详细面板**中分配所有变量（**三个黑板变量**），如下面的截图所示：
- en: '![](img/50795f33-f026-4ae8-ac85-e6d1556a6fd8.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/50795f33-f026-4ae8-ac85-e6d1556a6fd8.png)'
- en: 'In the C++ version, we also need to assign the Player Class, along with the
    Blackboard Variables (since this is the way we designed our Service in C++). Hence,
    you will have something similar to this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++版本中，我们还需要分配玩家类，以及黑板变量（因为这是我们用C++设计服务的方式）。因此，您将得到类似以下的内容：
- en: '![](img/2cca03a5-239b-473c-8753-50c0034ddca3.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2cca03a5-239b-473c-8753-50c0034ddca3.png)'
- en: 'Once we have assigned all the variables, then this is what our Service will
    look like in the *Behavior Tree* when attached to the *Selector* node:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们分配了所有变量，那么当附加到**选择器**节点时，我们的服务在**行为树**中的样子如下所示：
- en: '![](img/7311d9a9-0370-47f5-bf5a-fa12a802818b.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7311d9a9-0370-47f5-bf5a-fa12a802818b.png)'
- en: From the *Selector*, add two ***Sequence*** nodes (each representing the two
    branches of the tree). Which one the *Selector* chooses will depend on the decorators
    we are going to place on these two nodes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从**选择器**中添加两个**序列**节点（每个代表树的两个分支）。**选择器**将选择哪个取决于我们将放置在这两个节点上的装饰器。
- en: 'Add both the ***Sequence*** nodes to ***BTDecorator_CheckBoolVariableBP*** (or
    the ***CheckBoolVariable*** C++ version of it). In the details panel, the *Bool
    Variable To Check* variable needs to be fed with the ***CanSeePlayer*** *Blackboard
    Key*, as shown in the following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个**序列**节点添加到**BTDecorator_CheckBoolVariableBP**（或其C++版本的**CheckBoolVariable**）。在详细面板中，需要将**要检查的布尔变量**变量设置为**CanSeePlayer**黑板键，如下面的截图所示：
- en: '![](img/3b5bf8ca-06f0-40ab-9044-a23555bf96f3.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3b5bf8ca-06f0-40ab-9044-a23555bf96f3.png)'
- en: 'However, for the sequence on the right, you should set the ***Inverse Condition*** checkbox
    to *true*. By doing this, we can check whether ***CanSeePlayer*** is set to *false*.
    This is a bit wordy, but here are the final results in the Details panel:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于右侧的序列，您应该将**逆条件**复选框设置为**true**。通过这样做，我们可以检查**CanSeePlayer**是否设置为**false**。这有点啰嗦，但以下是详细面板中的最终结果：
- en: '![](img/e9c8747a-39e7-46a5-b415-a84913cbbbe0.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e9c8747a-39e7-46a5-b415-a84913cbbbe0.png)'
- en: 'So far, our tree looks as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的树看起来如下所示：
- en: '![](img/c06bf2f1-4711-4ef4-8d16-bea6121e2b7f.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c06bf2f1-4711-4ef4-8d16-bea6121e2b7f.png)'
- en: 'From the sequence node on the left, we just need to chase the player by using
    the ***Move To*** task. You need to select the ***Player* **blackboard variable
    as the ***Blackboard Key***, as shown in the following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从左侧的序列节点，我们只需使用**移动到**任务来追踪玩家。您需要选择**玩家**黑板变量作为**黑板键**，如下面的截图所示：
- en: '![](img/4ca131c0-5140-4585-bc01-ba82b4b15840.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4ca131c0-5140-4585-bc01-ba82b4b15840.png)'
- en: 'This is the current stage of the tree:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是树的当前阶段：
- en: '![](img/acf0f974-5619-466d-be05-030bfd37e6df.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/acf0f974-5619-466d-be05-030bfd37e6df.png)'
- en: 'From the ***Sequence*** node on the right, we need to have two tasks. The first
    one is ***Move To*** again, but this time select the ***Destination*** variable
    as the ***Blackboard Key***, as shown in the following screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从右侧的**序列**节点，我们需要两个任务。第一个是**移动到**，但这次选择**目的地**变量作为**黑板键**，如下面的截图所示：
- en: '![](img/38b4bb64-3a50-4c54-86b6-a5f6c391ae4d.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/38b4bb64-3a50-4c54-86b6-a5f6c391ae4d.png)'
- en: 'This is what the tree looks like so far:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是到目前为止的树的样子：
- en: '![](img/f626e1a8-ac78-4682-8945-bdf9eee05168.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f626e1a8-ac78-4682-8945-bdf9eee05168.png)'
- en: 'The second *Task* is the one we have already created, ***BTTask_FindRandomLocationBP*** (or
    the ***Find Random Location*** C++ version). We need to set the ***DestinationKey*** with
    the ***Destination*** *Blackboard variable*, and as for the ***Radius***, we can
    choose a value (e.g. 30000, ten times more the default value). This is what the *Details*
    panel looks like:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个*任务*是我们已经创建的，***BTTask_FindRandomLocationBP***（或C++版本的***Find Random Location***）。我们需要将***DestinationKey***设置为***Destination***
    *黑板变量*，至于***Radius***，我们可以选择一个值（例如30000，是默认值的十倍）。这就是*详细信息*面板的样子：
- en: '![](img/dd525471-861b-472c-9a02-ecf30f330e69.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/dd525471-861b-472c-9a02-ecf30f330e69.png)'
- en: 'This is what the complete tree should look like:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是完整的树应该看起来像的样子：
- en: '![](img/42e5cf86-f25d-485b-a208-c868f0a2fb0f.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/42e5cf86-f25d-485b-a208-c868f0a2fb0f.png)'
- en: It seems like we have finished, but we have one more thing to do. In fact, at
    the moment, the Decorators don't control the flow of the Sub-Tree once the AI
    is executing it. In fact, we would like to abort the Task of moving to the Player
    if he/she is not in sight anymore; on the other hand, if the agent is going to
    a random location, we want the agent to chase the Player if he/she is in sight
    again.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们已经完成了，但我们还有一件事要做。事实上，目前，装饰器在AI执行子树时不会控制子树的流程。事实上，我们希望如果玩家不再在视野中，就中止移动到玩家的任务；另一方面，如果智能体正在前往随机位置，我们希望如果玩家再次出现在视野中，智能体去追逐玩家。
- en: 'To achieve this, we need to select our ***Decorators*** (one at the time) and
    set ***Observer Abort*** to ***Self***, as shown in the following screenshot:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们需要选择我们的***装饰器***（一次一个）并将***观察者中止***设置为***自我***，如下面的截图所示：
- en: '![](img/e935bd39-f8bc-4771-97de-81ae5097d43d.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/e935bd39-f8bc-4771-97de-81ae5097d43d.png)'
- en: 'If the Decorator is still selected, the nodes that will be aborted are highlighted
    in the Tree:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果装饰器仍然被选中，将要被中止的节点将在树中高亮显示：
- en: '![](img/1209ad61-9437-41ad-b166-34928c965f63.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/1209ad61-9437-41ad-b166-34928c965f63.png)'
- en: 'The tree slightly changes to reflect this behavior (under the ***Decorators***, the
    abort conditions are shown):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 树略微改变以反映这种行为（在***装饰器***下，显示中止条件）：
- en: '![](img/f665e500-daf6-499b-bb61-d69566dd8f96.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/f665e500-daf6-499b-bb61-d69566dd8f96.png)'
- en: 'If you have built the tree using C++ nodes, you will have something similar
    to this instead:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用C++节点构建了树，你将得到类似这样的东西：
- en: '![](img/493789be-3579-4c18-92ba-c1228813e109.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/493789be-3579-4c18-92ba-c1228813e109.png)'
- en: Moreover, you should notice that, just down below the Node name, not all information
    are displayed (e.g. in the *Decorators*, it doesn't say if its condition is inverted
    and what the abort conditions are). Later in the chapter, we will tackle this
    issue as well.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你应该注意，在节点名称下方，并非所有信息都会显示（例如，在*装饰器*中，它不会说明其条件是否反转以及中止条件是什么）。在章节的后面，我们也会解决这个问题。
- en: As you can see, the structure is very simple (and I have seen the same behavior
    being implemented in different trees), but it contains all the main concepts for ***Designing
    a Behavior Tree*** (including creating a node of each type: ***Decorator***, ***Service***,
    and ***Task***). The fact that the structure is simple doesn't mean that the behavior
    that represents it is simple too. In fact, what we have built is a very nice ***Chasing
    Behavior***!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，结构非常简单（我见过在不同的树中实现相同的行为），但它包含了设计行为树的所有主要概念（包括创建每种类型的节点：***装饰器***、***服务***和***任务***）。结构简单并不意味着代表它的行为也简单。事实上，我们构建的是一个非常好的***追逐行为***！
- en: We haven't touched upon Simple Parallel nodes, but those are used in more complicated
    trees for particular kind of behaviors with sub-trees. You don't have to worry –
    once you start mastering the art of creating *Behaviors Trees*, the use of Simple
    Parallel nodes will become natural.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有涉及到简单的并行节点，但那些在更复杂的树中用于特定子树的行为。你不必担心——一旦你开始掌握创建*行为树*的艺术，使用简单并行节点将变得自然。
- en: The last thing that's left to do is make this *Behavior Tree* run and then to
    test it in the game!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的事情是让这个*行为树*运行，然后在游戏中对其进行测试！
- en: Running the Behavior Tree
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行行为树
- en: We have already created the whole setup, including actors, controllers, perception,
    and navigation. However, we don't have any code that makes this Behavior Tree
    run on our agent. Of course, we will cover both the Blueprint case and the C++
    one.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了整个设置，包括演员、控制器、感知和导航。然而，我们没有使这个行为树在我们的智能体上运行的任何代码。当然，我们将涵盖蓝图案例和C++案例。
- en: Running the Behavior Tree using the Blueprint controller
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用蓝图控制器运行行为树
- en: If we have a Blueprint controller set up, we can easily modify it to get the
    Behavior Tree running immediately.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已设置蓝图控制器，我们可以轻松地修改它，以便立即运行行为树。
- en: 'In fact, once we open the Editor, we can add the *Run Behavior Tree* node after 
    overriding the *Event OnPossess *and choose the right *Behavior Tree*, as shown
    in the following screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，一旦我们打开编辑器，我们可以在重写*Event OnPossess*后添加*运行行为树*节点，并选择正确的*行为树*，如图所示：
- en: '![](img/0bd4942e-a919-4dc0-ada3-7b7585860e55.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0bd4942e-a919-4dc0-ada3-7b7585860e55.png)'
- en: Save it, and you are good to go! Run the game and see if it works (of course,
    the AI controller needs to be set to ***BP_ChasingAIController***).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 保存它，然后你就可以开始了！运行游戏，看看它是否工作（当然，AI控制器需要设置为**BP_ChasingAIController**）。
- en: Running the Behavior Tree using the C++ controller
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C++控制器运行行为树
- en: 'Unluckily for C+,+ this is not as straightforward (as we already saw in [Chapter
    2](00781951-41e3-4e33-8512-052e7aecfd15.xhtml)*, Behavior Trees and Blackboards*).
    In particular, we have two choices: we hardcode the value or we get a reference
    to the tree using blueprints.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，对于C++来说，这并不像我们已经在[第2章](00781951-41e3-4e33-8512-052e7aecfd15.xhtml)*行为树和黑板*中看到的那样直接。特别是，我们有两种选择：我们硬编码值或使用蓝图获取树的引用。
- en: The first option is not very practical for this kind of stuff and it is not
    a best practice.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项对于这类东西不太实用，而且也不是最佳实践。
- en: For the second option, we have a variety of choices. In particular, I suggest
    that you create a *Behavior Tree* variable in the controller and use it so that
    it can be run on the `OnPossess()` function. Then, we can create a child of this
    class in the blueprint, where we can easily assign this variable. Finally, we
    can change the reference to the controller for our ***AIChasingAgent***.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二种选项，我们有多种选择。特别是，我建议你在控制器中创建一个*行为树*变量并使用它，以便它可以在`OnPossess()`函数上运行。然后，我们可以在蓝图中的这个类中创建一个子类，在那里我们可以轻松地分配这个变量。最后，我们可以更改对**AIChasingAgent**控制器的引用。
- en: Alternatively, you can place the *Behavior Tree* on the *Character/Pawn* that
    the AI will control, like we did in *Chapter 2*. That would be the best approach;
    however, in this moment it is good to see different alternatives in case you are
    in a situation in which you will need the *Behavior Tree* directly on the controller.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以将*行为树*放在AI将要控制的*Character/Pawn*上，就像我们在*第2章*中所做的那样。这将是最理想的方法；然而，在这个时候，看到不同的替代方案是好的，以防你处于需要直接在控制器上使用*行为树*的情况。
- en: 'Let''s start by opening the header file of our C++ controller and adding the
    following public variable (with the `UPROPERTY()` macro, since it needs to be
    editable in Blueprint):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开我们的C++控制器头文件并添加以下公共变量开始（使用`UPROPERTY()`宏，因为它需要在蓝图中进行编辑）：
- en: '[PRE0]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we need to override the `OnPossess()` function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要重写`OnPossess()`函数：
- en: '[PRE1]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, in the `.cpp` file, we need to include the *Behavior Tree class*, so
    we need to add the following statement:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`.cpp`文件中，我们需要包含*行为树类*，因此我们需要添加以下语句：
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, in the `OnPossess()` implementation, we just run the Behavior Tree:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`OnPossess()`的实现中，我们只需运行行为树：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After compiling the code, we can right-click on the C++ controller and select ***Create
    Blueprint class based on ChasingAIController***, as shown in the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 编译代码后，我们可以在C++控制器上右键单击并选择**基于ChasingAIController创建蓝图类**，如图所示：
- en: '![](img/cb0bb51d-17a8-4fe8-baa8-713577b61681.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cb0bb51d-17a8-4fe8-baa8-713577b61681.png)'
- en: 'Then, we can place this Blueprint inside the AI folder and name it ***CPP_ChasingAIController*** (to
    distinguish it from *BP_ChasingAIController*):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将这个蓝图放在AI文件夹中，命名为**CPP_ChasingAIController**（以区分*BP_ChasingAIController*）：
- en: '![](img/1c55c897-67e1-40ee-81b5-6975c2792598.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1c55c897-67e1-40ee-81b5-6975c2792598.png)'
- en: 'Its *Blueprint Editor* should open automatically (if not, just double-click
    on the asset to open it). Set the ***Behavior Tree*** variable in the *Details
    Panel*, as shown in the following screenshot (of course, we will need to set the
    *C++ version* of the *Behavior Tree*):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 它的*蓝图编辑器*应该会自动打开（如果没有，只需双击资产打开它）。在*详细信息面板*中设置**行为树**变量，如图所示（当然，我们需要设置*行为树*的*C++版本*）：
- en: '![](img/614c7993-25a9-40c7-85ad-2330b1f59755.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/614c7993-25a9-40c7-85ad-2330b1f59755.png)'
- en: Compile and save the *Blueprint*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并保存*蓝图*。
- en: 'Finally, in the ***AI_ChasingAgent*** blueprint, let''s change its settings
    (from the *Details* panel in the ***Pawn*** tab) so that it will use the new controller:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在***AI_ChasingAgent***蓝图上，让我们更改其设置（从***Pawn***选项卡中的*详细信息*面板），使其使用新的控制器：
- en: '![](img/7581820f-462c-4dde-8c0d-fdf15a506759.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7581820f-462c-4dde-8c0d-fdf15a506759.png)'
- en: This concludes how to run the *Behavior Tree* on a *C++ controller*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了如何在*C++控制器*上运行*行为树*。
- en: Bug Correction
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误修正
- en: If you have though to have finished, well, that's not it. In fact, when designing
    a Behavior Tree, there must always be a phase of debugging and check if everything
    works as it should. Actually, on purpose I built the tree with something that
    doesn't work. Can you figure it out? Give it a try before keep reading.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以为你已经完成了，嗯，那还不是。事实上，在设计行为树时，必须始终有一个调试阶段，检查一切是否按预期工作。实际上，我故意构建了一个不工作的树。你能找出问题吗？在继续阅读之前试一试。
- en: The first problem is that, the Destination Key in the Blackboard, until the
    Player is not on sight, it will never get initialized. Moreover, there is another
    problem, when the AI enemy is seeking the Last Known Position of the player, but
    it is not reachable, it will fail the task. As a result, the sequence will not
    allow to go in the next Task to select a *Random Destination*. How can we fix
    this? Let's give it a try before we keep reading.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题在于，直到玩家出现在视野中，黑板上的目的地键永远不会初始化。此外，还有一个问题，当AI敌人寻找玩家的最后一个已知位置，但不可达时，它将失败任务。结果，序列将不允许进入下一个任务以选择一个*随机目的地*。我们如何解决这个问题？在继续阅读之前让我们试一试。
- en: There are many approaches to this. For instance, you might have though to use
    the "*Force Success*" Decorator. It is not a bad idea at all, actually, this are
    the kind of cases in which you would use this Decorator (to add an optional Branch
    to the Sequence, so regardless if the Move To fails, we can still pick a Random
    Destination). Unfortunately, it doesn't work well with the setup we have with
    the other two decorators.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以做到这一点。例如，你可能想过使用“*强制成功*”装饰器。这绝对不是一个坏主意，实际上，这就是你可能会使用这个装饰器的情况（向序列添加一个可选分支，这样即使“移动到”失败，我们仍然可以选择一个随机目的地）。不幸的是，它与其他两个装饰器的设置不太兼容。
- en: 'Thus, another solution is to modify the tree in the following way. We need
    to substitute the second Sequence with a Selector, with two Sequences as children.
    In the first Sequence, we place our Move To Task followed by the Find Random Destination
    one. In the other Sequence they are inverted. As result, in case the Task to follow
    the Last Known Player Position fails, the tree can revert back to Find a Random
    Location. If you wish, you could also remove the last Move To in the second Sequence,
    but I''m leaving it there for clarity; especially for those who struggle to grasp
    how *Behavior Tree* works. At the end, this is how it should look like the Behavior
    Tree (Blueprint version):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，另一种解决方案是以下方式修改树。我们需要将第二个序列替换为一个选择器，并有两个序列作为子节点。在第一个序列中，我们放置我们的“移动到任务”然后是“找到随机目的地”。在另一个序列中它们是相反的。结果，如果跟随最后一个已知玩家位置的任务失败，树可以回退到“找到一个随机位置”。如果你愿意，你也可以从第二个序列中移除最后一个“移动到”，但我留下它以提高清晰度；特别是对于那些难以理解*行为树*工作原理的人来说。最后，这是行为树（蓝图版本）应该看起来像的：
- en: '![](img/fd0fbae0-60ef-4684-9c35-161a98aba46c.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fd0fbae0-60ef-4684-9c35-161a98aba46c.png)'
- en: 'And this is how the C++ version should change (the changes of the next section
    have already been implemented in this picture):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是C++版本应该改变的样子（下一节中的更改已经在这个图片中实现）：
- en: '![](img/2869bfc3-5bdd-49fe-a375-4f55f421631b.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2869bfc3-5bdd-49fe-a375-4f55f421631b.png)'
- en: Of course the solution is not unique, and you may find better ways to do it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，解决方案不是唯一的，你可能会找到更好的方法来做这件事。
- en: What about our first problem of the *Destination* never be initialized? Well,
    we don't have this problem anymore with the proposed solution, since if the first
    *Sequence* (in the right-branch) fails, then the second one will set the *Destination*
    to a *Random Location*. In fact, when debugging Behavior Trees, you always need
    to be careful to each modification and how this affects the whole tree. Imagine
    this for a complex Behavior, and you can get an idea of the time required for
    such Task.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的第一个问题，即*目的地*永远不会初始化？嗯，有了提出的解决方案，我们就不再有这个问题了，因为如果第一个*序列*（在右分支）失败，那么第二个将把*目的地*设置为一个*随机位置*。实际上，在调试行为树时，你总是需要小心每个修改以及它对整个树的影响。想象一下复杂行为的情况，你就可以得到这种任务所需时间的概念。
- en: 'Once we have fixed this, we can always check for other bugs and/or try to improve
    the set up. Here a couple of other issues, which I leave you to fix, in order
    to practice with *Behavior Trees*:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们解决这个问题，我们就可以检查其他错误，或者尝试改进设置。以下是一些其他问题，我将留给你去解决，以便练习使用行为树：
- en: When the *Behavior Tree* starts its execution, the *Destination* is set to the
    zero vector. This means, that the AI, if doesn't see the Player, will go straight
    to the *World Origin*. Can you try to avoid it? Try to think, which are the different
    alternatives we have? The best would be to have a Random Destination In range.
    How can we achieve that?
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当行为树开始执行时，*目的地*被设置为零向量。这意味着，如果AI没有看到玩家，它将直接前往*世界原点*。你能尝试避免这种情况吗？试着思考一下，我们有哪些不同的选择？最好的选择是在范围内有一个随机目的地。我们如何实现这一点？
- en: At the moment, when we do the Cast in the Perception System, we just select
    a broader class of *BehaviorTreeDesignCharacter*. However, this causes problems
    if you have more than one AI in the level. How can you fix that? For sure, you
    can change the Cast into something more specific, so to reduce it only to the
    Player. But what if you cannot do that, because both Players and friendly AI must
    share the same class? You could try to use the different Teams to distinguish
    enemies, allies and neutral; recall from Chapter 5.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，当我们进行感知系统中的转换时，我们只是选择一个更广泛的*BehaviorTreeDesignCharacter*类。然而，如果你在级别中有多个AI，这会导致问题。你该如何解决这个问题？当然，你可以将转换改为更具体的东西，仅将其限制为玩家。但如果你不能这样做，因为玩家和友军AI必须共享同一个类，你该怎么办？你可以尝试使用不同的队伍来区分敌人、盟友和中立者；回想一下第5章。
- en: Of course, this was just a very small example of *Behavior Tree*, yet it took
    three solid chapters to go through it in details. I will leave you exploring Behavior
    Trees for your games, but before that, the next section will talk about some suggestions
    on how to improve the C++ code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个非常小的行为树示例，但要详细讲解它需要三个完整的章节。我将留给你探索游戏中的行为树，但在那之前，下一节将讨论一些关于如何改进C++代码的建议。
- en: Improving further (C++ only)
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步改进（仅限C++）
- en: We have made a very nice Behavior Tree by programming the different nodes we
    have used. However, when you work on a big project or with other team members,
    you should ensure that your nodes are as solid as possible. In fact, in the C++
    implementation, we added a static description to our nodes to show which variables
    were set, and that was fantastic. But we can do more!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过编程不同的节点创建了一个非常好的行为树。然而，当你在一个大项目或与其他团队成员一起工作时，你应该确保你的节点尽可能稳固。实际上，在C++实现中，我们在节点中添加了一个静态描述，以显示设置了哪些变量，这真是太棒了。但我们还能做更多！
- en: This section will guide you through improving the C++ nodes even further.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将指导你进一步改进C++节点。
- en: Node Name
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点名称
- en: 'Unreal does a good job in C++ Behavior Tree nodes by cutting out the prefix
    (e.g. "***BTTask_***") and directly showing the name of the Task (or Decorator
    or Service). In the blueprint, it keeps the whole prefix instead, as you see in
    the following screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal在C++行为树节点方面做得很好，通过去除前缀（例如"***BTTask_***")，直接显示任务（或装饰器或服务）的名称。在蓝图界面中，它保留了整个前缀，如下面的截图所示：
- en: '![](img/c3121d28-a5f2-48e1-82f6-f0d73f76f70e.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c3121d28-a5f2-48e1-82f6-f0d73f76f70e.png)'
- en: 'As we saw in the previous chapters, you can modify the name that will be displayed
    by changing the ***Node Name*** property in the *Details* panel:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中看到的，你可以通过更改“*详情*”面板中的“***节点名称***”属性来修改将显示的名称：
- en: '![](img/d3bae5b3-5897-4208-abcc-34a08b43038f.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d3bae5b3-5897-4208-abcc-34a08b43038f.png)'
- en: 'This is reflected in the Behavior Tree:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这在行为树中得到了反映：
- en: '![](img/7928766e-7ce9-4487-aaea-e20bcf9a7281.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7928766e-7ce9-4487-aaea-e20bcf9a7281.png)'
- en: Thus, when you write a C++ node, it's good practice to give a default ***Node
    Name***. You can do this by simply assigning it in the constructor. So, let's
    do this for all three C++ nodes we have created.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你编写C++节点时，一个好的做法是提供一个默认的***节点名称***。你可以通过在构造函数中简单地分配它来实现这一点。所以，让我们为我们创建的所有三个C++节点做这件事。
- en: 'In the *Decorator* header file, we need to add the declaration of the constructor:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在*装饰器*头文件中，我们需要添加构造函数的声明：
- en: '[PRE4]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Its implementation in the `.cpp` file is straightforward, since we just need
    to add the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.cpp`文件中的实现很简单，因为我们只需要添加以下内容：
- en: '[PRE5]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is the final result:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最终结果：
- en: '![](img/b09da5ce-8ccf-42b8-8e5d-320c004e630a.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b09da5ce-8ccf-42b8-8e5d-320c004e630a.png)'
- en: 'We need to do this with our Task, too. So, let''s declare the constructor in
    the header file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也需要对我们的任务做同样的事情。所以，让我们在头文件中声明构造函数：
- en: '[PRE6]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Its implementation in the `.cpp` file is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 它在`.cpp`文件中的实现如下：
- en: '[PRE7]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is how it looks in the Behavior Tree Editor:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它在行为树编辑器中的样子：
- en: '![](img/7c16018a-7b00-4895-8950-d2100ba9e137.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7c16018a-7b00-4895-8950-d2100ba9e137.png)'
- en: 'Finally, we already have a constructor for our Service, so we just need to
    add a line to its constructor in the `.cpp` file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经有了我们的Service构造函数，所以我们只需要在`.cpp`文件中添加一行：
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The service will appear with a nice name in the Behavior Tree Editor:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务将在行为树编辑器中显示一个漂亮的名字：
- en: '![](img/ff5d104e-4add-4206-8724-4ad2d05cf3ec.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ff5d104e-4add-4206-8724-4ad2d05cf3ec.png)'
- en: A better description for the Decorator
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对装饰器的更好描述
- en: As we mentioned previously, when we use the C++ version of the Decorator, we
    are unable to see whether the condition is reversed, or the aborts settings.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，当我们使用装饰器的C++版本时，我们无法看到条件是否反转，或者中止设置。
- en: To add them into our static description, we need to change the code slightly.
    Fortunately, the header describing all of these properties is given in the parent
    class of our Decorator, and so we don't need to write the code from scratch. We
    need to store the return value of the parent function (by using the `Super::GetStaticDescription()` function)
    in a local FString Variable.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要将它们添加到我们的静态描述中，我们需要稍微修改一下代码。幸运的是，描述所有这些属性的头部文件在我们装饰器的父类中给出，所以我们不需要从头编写代码。我们需要将父函数的返回值（通过使用`Super::GetStaticDescription()`函数）存储在一个本地的FString变量中。
- en: 'Then, we can add a couple of new lines and append the original Static Description
    we made. Finally, we return the new variable:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以添加几行新代码，并附加我们创建的原生静态描述。最后，我们返回新的变量：
- en: '[PRE9]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is the final effect:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是最终的效果：
- en: '![](img/c0170df2-400d-4730-91ee-4746531103e6.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c0170df2-400d-4730-91ee-4746531103e6.png)'
- en: Of course, you can use the `Super::GetStaticDescription()` function for Tasks
    and Services as well.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您也可以为任务和服务使用`Super::GetStaticDescription()`函数。
- en: Filtering Blackboard Keys
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤黑板键
- en: When we insert *Blackboard Keys* in the *Details Panel*, we can insert any key
    that's present in the *Bl**ackboard*. However, when we use our ***CheckBoolVariable*** Decorator,
    we only want boolean keys in the ***BoolVariableToCheck***.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在*详细信息面板*中插入*黑板键*时，我们可以插入黑板中存在的任何键。然而，当我们使用我们的***检查布尔变量***装饰器时，我们只想在***要检查的布尔变量***中插入布尔键。
- en: We can achieve this by adding some filters in the constructor, as we learned
    back in [Chapter 6](e8c4d8a9-579e-4e38-b02a-a9002f1c48ce.xhtml), *Extending the
    Behavior Tree*. Let's do this for all three nodes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在构造函数中添加一些过滤器来实现这一点，就像我们在[第6章](e8c4d8a9-579e-4e38-b02a-a9002f1c48ce.xhtml)，“扩展行为树”中学到的那样。让我们为所有三个节点都这样做。
- en: 'In the implementation of the *Constructor* of our ***Check Bool Variable Decorator*** (`.cpp`
    file), we need to add the following filter so that it can only select boolean
    keys:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的***检查布尔变量装饰器***的*构造函数*（`.cpp`文件）实现中，我们需要添加以下过滤器，以便它只能选择布尔键：
- en: '[PRE10]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, our *Decorator* will only be able to accept Boolean keys:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的*装饰器*将只能接受布尔键：
- en: '![](img/28b60dbe-21ae-44b1-8a8f-b133b0cb7edc.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/28b60dbe-21ae-44b1-8a8f-b133b0cb7edc.png)'
- en: 'Likewise, we can do the same for our *Task* for the Destination Vector, which
    is of type Vector. In its *Constructor* (`.cpp` file), add the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以为我们的*任务*（类型为Vector）做同样的操作。在其*构造函数*（`.cpp`文件）中添加以下内容：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, our ***Find Random Location Task*** can only accept Vector Keys:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 ***随机位置查找任务*** 只能接受Vector键：
- en: '![](img/3ce3ce9b-bd51-4056-81d9-3be4169ae8cf.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3ce3ce9b-bd51-4056-81d9-3be4169ae8cf.png)'
- en: 'Finally, in our ***Update Chasing Behavior Service***, we need to do the same,
    but for each of the three variables. In particular, in the *Object* filter, we
    need to specify a class. In this example, we can just filter based on `AActor`.
    So, in the `.cpp` file, add the following lines:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的***更新追逐行为服务***中，我们需要做同样的操作，但针对每个三个变量。特别是，在*对象*过滤器中，我们需要指定一个类。在这个例子中，我们只需基于`AActor`进行过滤。因此，在`.cpp`文件中添加以下行：
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is how it appears when we try to select a key for our *Service*:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们尝试为我们的*服务*选择键时的样子：
- en: '![](img/e5283aee-c6af-41ff-a88f-a0b7bd6a606b.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e5283aee-c6af-41ff-a88f-a0b7bd6a606b.png)'
- en: This concludes this section and our journey of creating a *Behavior Tree* from
    scratch.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了本节，以及我们从零开始创建*行为树*的旅程。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have completed what we started in the previous two chapters.
    In fact, we have built a Behavior Tree from scratch, starting from the design
    phase, and implementing all the components we needed along the way (both in Blueprint
    and C++!).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们完成了在前两章中开始的工作。实际上，我们从设计阶段开始，从头构建了一个行为树，并在过程中实现了所有需要的组件（包括蓝图和C++！）。
- en: In particular, in this chapter we have seen how to build the Behavior Tree,
    along with the Blackboard; make the Behavior Tree run (both in a Blueprint and
    C++ setup); and improved the C++ implementation of the nodes by assigning node
    names, placing a header in the Decorator, and filtering the *Blackboard Key* selectors
    based on their type.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在本章中，我们看到了如何构建行为树，以及黑板；使行为树运行（无论是在蓝图还是C++设置中）；并通过分配节点名称、在装饰器中放置头文件以及根据其类型过滤*黑板键*选择器来改进节点的C++实现。
- en: This chapter concludes the main features of the Unreal Engine AI Framework.
    However, this doesn't mean that we are finished with this Framework just yet.
    In fact, we can now perform an extensive debugging of the AI, which is the topic
    we are going to face in the next chapters.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 本章总结了虚幻引擎AI框架的主要特性。然而，这并不意味着我们就此完成了对这个框架的研究。实际上，我们现在可以对AI进行广泛的调试，这是我们在下一章将要面对的主题。
