- en: '*Chapter 12*: Putting It All Together'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：整合一切'
- en: Over the previous eleven chapters, we've looked at various AI methods and built
    some simple demo applications using Unity3D. In this final chapter, we'll develop
    a more complex game example using some of the techniques we explored in previous
    chapters. The techniques we'll be using in this chapter include navigation meshes
    and **finite-state machines** (**FSMs**), but, more importantly, we will learn
    how to navigate and add AI to a pre-existing complex game. So, unlike the other
    chapters, this example is more like a real-world scenario.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前十一章中，我们探讨了各种人工智能方法，并使用Unity3D构建了一些简单的演示应用程序。在本章中，我们将使用之前章节中探索的一些技术来开发一个更复杂的游戏示例。本章我们将使用的技术包括导航网格和**有限状态机**（**FSMs**），但更重要的是，我们将学习如何导航并添加人工智能到一个现有的复杂游戏中。因此，与之前的章节不同，这个示例更像是一个真实世界的场景。
- en: In this chapter, we'll add AI to a simple tank combat game called *TANKS!* and
    contained in one of the official Unity tutorials, which, in turn, was inspired
    by an historic tank game called *Combat* for the Atari 2600\. In the default version,
    TANKS! is a two-player game. Each player takes control of a tank, and the goal
    is to destroy each other. To make things more complicated, the player can decide
    the shot's strength (and, thus, the distance) by pressing and holding the *Spacebar*
    for a shorter or longer duration.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为名为 *TANKS!* 的简单坦克战斗游戏添加人工智能，该游戏包含在官方Unity教程中，而该教程又受到了历史坦克游戏 *Combat*（Atari
    2600上的游戏）的启发。在默认版本中，TANKS! 是一个双人游戏。每个玩家控制一辆坦克，目标是摧毁对方。为了使事情更加复杂，玩家可以通过按住 *空格键*
    的时间长短来决定射击的强度（以及因此的距离）。
- en: However, because we are AI developers, we want to build an AI for the enemy
    tank to play in single-player mode. So, this is what we'll do in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，因为我们作为人工智能开发者，我们希望为敌方坦克构建一个可以在单人模式中游玩的人工智能。所以，这就是本章我们将要做的。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Developing the basic game structure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发基本游戏结构
- en: Adding automated navigation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加自动化导航
- en: Creating decision-making AI with FSM
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FSM创建决策人工智能
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you just need Unity3D 2022\. You can find the example project
    described in this chapter in the `Chapter 12` folder in the book''s GitHub repository:
    [https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter12).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你只需要Unity3D 2022。你可以在这个章节的GitHub仓库中的`Chapter 12`文件夹中找到本章描述的示例项目：[https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter12)。
- en: Developing the basic game structure
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发基本游戏结构
- en: For this demo, we will write an AI for the free tutorial game *TANKS!*. You
    can download the base game from Unity Asset Store (`https://assetstore.unity.com/packages/essentials/tutorial-projects/tanks-tutorial-46209`),
    or follow along with the version included in the `Chapter 12` folder of this book's
    GitHub repository. The version included with this book has the advantage of already
    having been tested for Unity 2022.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个演示，我们将为免费教程游戏 *TANKS!* 编写人工智能。你可以从Unity Asset Store（`https://assetstore.unity.com/packages/essentials/tutorial-projects/tanks-tutorial-46209`）下载基础游戏，或者跟随本书GitHub仓库中`Chapter
    12`文件夹中的版本。本书附带版本的优势是已经针对Unity 2022进行了测试。
- en: In either case, the game is the same. When we start the game, we see a pleasant
    desert scenario, with rocks, structures, palm trees, and so on. Using the keyboard,
    we should be able to control the blue tank (the tank moves with *W*, *A*, *S*,
    and *D* and shoots with the *Spacebar*).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，游戏都是一样的。当我们开始游戏时，我们看到一个愉快的沙漠场景，有岩石、结构、棕榈树等等。使用键盘，我们应该能够控制蓝色坦克（坦克通过 *W*、*A*、*S*
    和 *D* 移动，并通过 *空格键* 射击）。
- en: 'The following screenshot shows the basic structure of the game:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了游戏的基本结构：
- en: '![Figure 12.1 – Basic hierarchy of the game'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1 – 游戏的基本层次结构'
- en: '](img/B17984_12_1.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_12_1.jpg)'
- en: Figure 12.1 – Basic hierarchy of the game
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 游戏的基本层次结构
- en: 'The first time you start with an existing project, spend as much time as you
    can familiarizing yourself with the game structure, the basic scripts, and the
    components. You must know how to operate at ease in a project you don''t know.
    To do this, run the game a couple of times, try minor modifications to the code
    to see the effect, and add debug messages to learn about the flow in which information
    moves around the game. The following image will give you an idea of how the game
    will look when we run it:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次使用现有项目时，尽可能多地花时间熟悉游戏结构、基本脚本和组件。你必须知道如何在不知道的项目中轻松操作。为此，运行游戏几次，尝试对代码进行一些小的修改以查看效果，并添加调试信息以了解信息在游戏中的流动。以下图片将给你一个我们运行游戏时游戏外观的印象：
- en: '![Figure 12.2 – The TANKS! game in action'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2 – TANKS!游戏中的实际操作'
- en: '](img/B17984_12_2.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17984_12_2.jpg)'
- en: Figure 12.2 – The TANKS! game in action
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – TANKS!游戏中的实际操作
- en: Info
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: It may be helpful to follow the complete Unity tutorial, available at [https://unity3d.com/learn/tutorials/s/tanks-tutorial](https://unity3d.com/learn/tutorials/s/tanks-tutorial).
    Even if it does not involve AI and is quite old (the tutorial has been recorded
    in 2015), you will still find many important teachings for game development, such
    as how to design a game manager, basic controls, and audio.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循完整的Unity教程可能会有所帮助，该教程可在[https://unity3d.com/learn/tutorials/s/tanks-tutorial](https://unity3d.com/learn/tutorials/s/tanks-tutorial)找到。即使它不涉及AI并且相当陈旧（教程是在2015年录制的），你仍然可以找到许多对游戏开发非常重要的指导，例如如何设计游戏管理器、基本控制和音频。
- en: Adding automated navigation
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加自动导航
- en: The first step is to modify the level to support automated navigation. In the
    original game, the players control all the moving objects (the tanks), so pathfinding
    is unnecessary. Now that we want to add AI, we need to have a world representation
    through which the AI can move. Luckily, this process is straightforward, thanks
    to NavMeshes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是修改关卡以支持自动导航。在原始游戏中，玩家控制所有移动对象（坦克），因此路径查找是不必要的。现在我们想要添加AI，我们需要有一个世界表示，通过这个表示AI可以移动。幸运的是，这个过程很简单，多亏了导航网格。
- en: Creating the NavMesh
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建导航网格
- en: 'To do this, perform the following steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个任务，请执行以下步骤：
- en: 'Open the Navigation window (**Window** | **AI** | **Navigation**) and look
    at the NavMesh generation parameters. In this case, NavMesh generation is relatively
    easy: we are only interested in moving around on the ground surface plane, so
    there are no jumps, no links, and no slopes we need to care of.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开导航窗口（**窗口** | **AI** | **导航**）并查看导航网格生成参数。在这种情况下，导航网格生成相对简单：我们只对在地面上移动感兴趣，所以没有跳跃、没有链接，也没有需要关心的斜坡。
- en: The only adjustment to the default NavMesh parameters we need to make is for
    the baking agent size (that is, the measures of the virtual agent used by Unity
    to verify whether a location is large enough to allow the Agent to pass).
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要调整默认导航网格参数的唯一调整是烘焙代理大小（即Unity用于验证位置是否足够大以允许代理通过的虚拟代理的尺寸）。
- en: 'The tanks used in the game are about three units large, so we need to instruct
    the generator to remove the areas that are too small for the tank to pass through.
    The following screenshot shows the baking setting for the navigation mesh:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏中使用的坦克大约有三单位大，因此我们需要指示生成器移除坦克无法通过的区域。以下截图显示了导航网格的烘焙设置：
- en: '![Figure 12.3 – The NavMesh baking options'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3 – 导航网格烘焙选项'
- en: '](img/B17984_12_3.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17984_12_3.jpg)'
- en: Figure 12.3 – The NavMesh baking options
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 导航网格烘焙选项
- en: 'Just to be on the safe side, we use an `1.8` and reduce the `20` (after all,
    we are not interested in slopes: the game is completely flat).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保安全，我们使用`1.8`并减少`20`（毕竟，我们对斜坡不感兴趣：游戏是完全平坦的）。
- en: 'After that, press **Bake**. You should get a nice NavMesh, as in the following
    screenshot:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，按**烘焙**。你应该会得到一个很好的导航网格，就像以下截图所示：
- en: '![Figure 12.4 – The baked NavMesh in the map'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.4 – 地图中的烘焙导航网格'
- en: '](img/B17984_12_4.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17984_12_4.jpg)'
- en: Figure 12.4 – The baked NavMesh in the map
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – 地图中的烘焙导航网格
- en: We now want to add some patrolling points that the AI tank can follow. To do
    this, we create an empty GameObject; feel free to create as many other GameObject
    instances as you like.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想要添加一些巡逻点，AI坦克可以跟随。为此，我们创建一个空的GameObject；你可以随意创建尽可能多的其他GameObject实例。
- en: Then, we create a `PatrolPoint` tag, and tag all the patrol points with it.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个`PatrolPoint`标签，并将所有巡逻点都标记为该标签。
- en: '![Figure 12.5 – The patrol points labeled PPoint in the Editor view'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5 – 在编辑器视图中标记为PPoint的巡逻点'
- en: '](img/B17984_12_5.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_12_5.jpg)'
- en: Figure 12.5 – The patrol points labeled PPoint in the Editor view
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – 在编辑器视图中标记为PPoint的巡逻点
- en: Now that we have a world representation and a set of points that we can use
    to wander around, we need to create an AI-controlled agent.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个世界表示和一组我们可以用来四处游荡的点，我们需要创建一个由AI控制的代理。
- en: Setting up the Agent
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置代理
- en: 'Unfortunately, the game does not support AI, so we need to add the Agent ourselves.
    To do this, perform the following steps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，游戏不支持AI，因此我们需要自己添加代理。为此，执行以下步骤：
- en: We have to identify the player tank. There is no tank in the scene, as you can
    see from the game hierarchy. As you should know from your preliminary exploration,
    it is the job of `GameManager` to spawn the tanks. The tank model we'll use is
    a prefab called **CompleteTank**.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须识别玩家坦克。正如您从游戏层次结构中看到的那样，场景中没有坦克。正如您在初步探索中应该知道的那样，`GameManager`负责生成坦克。我们将使用的坦克模型是一个名为**CompleteTank**的预制件。
- en: Let's copy the prefab and call it `CompleteTankAI`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们复制预制件并将其命名为`CompleteTankAI`。
- en: Then we need to add the **Nav Mesh Agent** component to it so that we can move
    it around on the new NavMesh.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要添加**Nav Mesh Agent**组件，以便我们可以在新的NavMesh上移动它。
- en: '![Figure 12.6 – The Inspector for the Nav Mesh Agent component'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.6 – Nav Mesh Agent组件的检查器'
- en: '](img/B17984_12_6.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17984_12_6.jpg)'
- en: Figure 12.6 – The Inspector for the Nav Mesh Agent component
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – Nav Mesh Agent组件的检查器
- en: But this is not enough. First, we'll reuse the `TankShooting` script from the
    **TANKS!** demo, so we need to disable shooting if this script is attached to
    an AI (otherwise, the player could shoot for the AI agent).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但这还不够。首先，我们将重用**TANKS!**演示中的`TankShooting`脚本，因此如果此脚本附加到AI上，我们需要禁用射击（否则玩家可以为AI代理射击）。
- en: 'For this, we create a public Boolean variable, called `m_IsAI`. Note that for
    this demo, we are using the variable naming convention of the original tutorial.
    This is to not confuse people working from the Asset Store. Moreover, it is always
    wise to adopt the coding convention of an existing project without imposing our
    preferences on the entire code base. Anyway, let''s add the following lines to
    the `Update` script:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了这个，我们创建一个名为`m_IsAI`的公共布尔变量。请注意，对于这个演示，我们使用原始教程的变量命名约定。这是为了避免让从Asset Store工作的人感到困惑。此外，始终采用现有项目的编码约定是明智的，而不是在整个代码库上强加我们的偏好。无论如何，让我们将以下行添加到`Update`脚本中：
- en: '[PRE0]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These lines just stop the `Update` script for the AI agent, thereby disabling
    player input for AI characters. It is important to enable this variable in the
    AI tank prefab. We also need to add another patch; in fact, if we disable the
    input, we will also disable the shot strength.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行只是停止AI代理的`Update`脚本，从而禁用AI角色的玩家输入。在AI坦克预制件中启用此变量很重要。我们还需要添加另一个补丁；实际上，如果我们禁用输入，我们也会禁用射击强度。
- en: 'So, we need to add this back into the `Fire` function:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们需要将以下内容添加回`Fire`函数：
- en: '[PRE1]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We are replacing the variable shooting force with a constant shooting force
    for simplicity.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用恒定射击力替换了射击力变量，以简化操作。
- en: Info
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: 'As an exercise, you could make `m_CurrentLaunchForce` a parameter of the `Fire()`
    functions. We also make the `Fire()` function public: in fact, we need to call
    this function from the FSM that we''ll implement later.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，您可以将`m_CurrentLaunchForce`作为`Fire()`函数的参数。我们还使`Fire()`函数公开：实际上，我们需要从稍后要实现的FSM中调用此函数。
- en: Finally, we can remove the `TankMovement` component from the Tank AI prefab.
    Now it is time to update the `GameManager` script to enable *player versus computer*
    mode.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以从坦克AI预制件中移除`TankMovement`组件。现在，是时候更新`GameManager`脚本以启用*玩家对计算机*模式了。
- en: Fixing the GameManager script
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复GameManager脚本
- en: 'As a final step, we need to instruct the `GameManager` script to spawn a player
    tank and an AI tank:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们需要指示`GameManager`脚本生成一个玩家坦克和一个AI坦克：
- en: 'Open the `GameManager` script and add a new public variable in which we''ll
    store the new AI tank prefab:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GameManager`脚本，并添加一个新的公共变量，我们将在这个变量中存储新的AI坦克预制件：
- en: '[PRE2]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, modify the `SpawnAllTanks` function in this way:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，以这种方式修改`SpawnAllTanks`函数：
- en: '[PRE3]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that this game is a single-player game, we assume that the first tank is
    always the player (we spawn the `m_TankPrefab` model), and any other tank is AI-controlled
    (we spawn the `m_TankAIPrefab` model).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个游戏是单人游戏，我们假设第一个坦克总是玩家（我们生成`m_TankPrefab`模型），任何其他坦克都是AI控制的（我们生成`m_TankAIPrefab`模型）。
- en: Finally, just add the prefab to the Inspector as follows. Remember to enable
    the `m_IsAI` variable in the `CompleteTankAI` prefab and change its layer from
    **Player** to **AI**.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，只需按照以下方式将预制件添加到检查器中。请记住，在`CompleteTankAI`预制件中启用`m_IsAI`变量，并将其层从**玩家**更改为**AI**。
- en: '![Figure 12.7 – The Game Manager script in the inspector'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.7 – 检查器中的游戏管理器脚本'
- en: '](img/B17984_12_7.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17984_12_7.jpg)'
- en: Figure 12.7 – The Game Manager script in the inspector
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 – 检查器中的游戏管理器脚本
- en: Now that we have set up the basics, it is finally time to write the AI of the
    enemy tanks.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了基础知识，现在是时候编写敌方坦克的AI了。
- en: Creating decision-making AI with FSM
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FSM创建决策AI
- en: In [*Chapter 2*](B17984_02_Epub.xhtml#_idTextAnchor100), *Finite State Machines*,
    we saw how to implement a simple FSM. In this section, we are using the same technique,
    but will apply it to the more complex scenario of this demo.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B17984_02_Epub.xhtml#_idTextAnchor100)，“有限状态机”中，我们看到了如何实现一个简单的有限状态机（FSM）。在本节中，我们使用相同的技巧，但将应用于本演示的更复杂场景。
- en: First, we need an FSM plan. We are interested only in connecting the FSM to
    the existing game for this demo, so we will keep it simple. The FSM for our tank
    is composed of just two states – patrolling and shooting.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个FSM计划。我们只对将FSM连接到现有游戏的本演示感兴趣，所以我们将保持简单。我们的坦克FSM由两个状态组成——巡逻和射击。
- en: 'The plan is nice and straightforward:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 计划很棒且直接：
- en: The AI tank starts in the `Patrol` state and wanders around the previously defined
    patrolling points.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 人工智能坦克从“巡逻”状态开始，在之前定义的巡逻点周围徘徊。
- en: Then, if the players get in range, the tank switches to the `Attack` state.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，如果玩家进入范围，坦克将切换到“攻击”状态。
- en: In the `Attack` state, the tank turns toward the player and starts shooting
    at it.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“攻击”状态下，坦克转向玩家并开始对其射击。
- en: Finally, if we are in the `Attack` state and the players leave the AI's range,
    the tank will return to the `Patrol` state.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果我们处于“攻击”状态，而玩家离开AI的范围，坦克将返回到“巡逻”状态。
- en: '![Figure 12.8 – The simple FSM for the enemy tanks'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.8 – 敌方坦克的简单FSM'
- en: '](img/B17984_12_08.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17984_12_08.jpg)'
- en: Figure 12.8 – The simple FSM for the enemy tanks
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 – 敌方坦克的简单FSM
- en: 'For the implementation, perform the following steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实现，执行以下步骤：
- en: 'Let''s start with the FSM class:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从FSM类开始：
- en: '[PRE4]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, this class extends the `Complete.TankMovement` script. In this
    way, we can reuse the existing `TankMovement` code for things such as the engine
    sounds and other cosmetic aspects.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个类扩展了`Complete.TankMovement`脚本。这样，我们可以重用现有的`TankMovement`代码，用于引擎声音和其他外观方面。
- en: As explained in [*Chapter 2*](B17984_02_Epub.xhtml#_idTextAnchor100), *Finite
    State Machines*, the FSM class stores the data we need for the decision-making
    AI. Moreover, it contains the functions that the actual `Update`, `FixedUpdate`,
    and `Start` methods. In the FSM class, we want to store all the patrol points
    and the destination point (the current patrol points the tank is looking for).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第2章*](B17984_02_Epub.xhtml#_idTextAnchor100)，“有限状态机”中所述，FSM类存储了我们需要的决策AI数据。此外，它包含实际的`Update`、`FixedUpdate`和`Start`方法。在FSM类中，我们希望存储所有巡逻点和目的地点（坦克正在寻找的当前巡逻点）。
- en: 'Now it is time for the complete controller. We create a new `AITankController`
    script with the following initial content:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候创建完整的控制器了。我们创建一个新的`AITankController`脚本，其初始内容如下：
- en: '[PRE5]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, the class starts by extending FSM and defining the states.
    As you can see in the `FSMState` enum, we have `Patrol` and `Attack`, an empty
    state (`None`), and a final state (`Dead`). Then we add some class attributes
    to store the data we need.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，类首先扩展了FSM并定义了状态。如您在`FSMState`枚举中看到的，我们有“巡逻”和“攻击”，一个空状态（`None`），以及一个最终状态（`Dead`）。然后我们添加了一些类属性来存储我们需要的资料。
- en: The first two attributes are references to the `TankShooter` and `TankHealth`
    scripts in the tank. We will use them to check the health and to fire bullets.
    Then we have an `isDead` Boolean to stop FSM execution. Then we have `elapsedTime`
    and `shootRate` for controlling how rapidly the tank will shoot, followed by two
    private attributes that store a reference to the player (if in range) and a reference
    to `NavMeshAgent`. Lastly, we have a variable holding the current state in the
    FSM.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个属性是对坦克中`TankShooter`和`TankHealth`脚本的引用。我们将使用它们来检查健康状况并发射子弹。然后有一个`isDead`布尔值来停止FSM执行。然后有`elapsedTime`和`shootRate`来控制坦克射击的频率，接着是两个私有属性，用于存储对玩家（如果在其范围内）和对`NavMeshAgent`的引用。最后，我们有一个变量用于存储FSM中的当前状态。
- en: 'The `Initialize` function is used to initialize, of course, the FSM:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Initialize`函数用于初始化，当然，是FSM：'
- en: '[PRE6]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this function, we do three things:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们做了三件事：
- en: We get the reference to `NavMeshAgent`.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们获取`NavMeshAgent`的引用。
- en: We get a list of all `PatrolPoint` in the scene
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们获取场景中所有`PatrolPoint`的列表
- en: We randomly select one of the patrol points as the Agent's current destination.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们随机选择一个巡逻点作为代理的当前目的地。
- en: 'Then it is time for the `Update` function. Before this, however, we need to
    expose the tanks'' current health. Let''s add the following line to the `TankHealth`
    component:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后是`Update`函数。然而，在此之前，我们需要公开坦克的当前健康值。让我们向`TankHealth`组件添加以下行：
- en: '[PRE7]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We add the `CurrentHealth` property so that we can get read-only public access
    to the private member, `m_CurrentHealth`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`CurrentHealth`属性，以便我们可以获取只读公共访问权限到私有成员`m_CurrentHealth`。
- en: 'We are now ready to implement the FSM''s `FSMUpdate` method:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备好实现FSM的`FSMUpdate`方法：
- en: '[PRE8]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we explained previously, the main task of the `Update` function is to invoke
    the proper function depending on the current state. In addition to that, `FSMUpdate`
    also updates the `elapsedTime` timer and sets the Agent to the `Dead` state if
    the tank has no health.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前解释的，`Update`函数的主要任务是调用适当的函数，取决于当前状态。除了那之外，`FSMUpdate`还更新了`elapsedTime`计时器，如果坦克没有健康值，则将代理设置为`死亡`状态。
- en: 'The `Dead` state is very simple: the tank does nothing, and writes on the console
    that it is dead:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`死亡`状态非常简单：坦克什么都不做，并在控制台上写上它已经死亡：'
- en: '[PRE9]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `Attack` state is more interesting:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`攻击`状态更有趣：'
- en: '[PRE10]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the first part of the preceding code, we cast a sphere using Unity''s physics
    engine to *see* all the *players* in a radius of `15` units. Then, if there is
    none (meaning that the player is out of range), we switch to the `Patrol` state,
    remove the player reference, enable the `NavMeshAgent` component, and terminate
    the state. Otherwise, we proceed with the attack: we get the player reference,
    rotate the tank in its direction, and shoot (at the correct rate).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码的第一部分，我们使用Unity的物理引擎投射一个球体来*查看*半径为`15`单位的所有*玩家*。然后，如果没有玩家（意味着玩家在范围之外），我们切换到`巡逻`状态，移除玩家引用，启用`NavMeshAgent`组件，并终止状态。否则，我们继续攻击：获取玩家引用，将坦克旋转到其方向，并射击（以正确的速率）。
- en: 'Luckily, the original game already implemented the `Fire` function! That''s
    why good class design is essential: if a class is functional, you can reutilize
    it very well, even for things that you didn''t initially consider!'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，原始游戏已经实现了`Fire`函数！这就是为什么良好的类设计是至关重要的：如果一个类是功能性的，你可以很好地重用它，即使是为了你最初没有考虑的事情！
- en: 'Finally, we have the `Patrol` state function:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有`巡逻`状态函数：
- en: '[PRE11]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If no player is in range, then we proceed to wander around. First, we check
    whether we have reached the current destination. If so, we need to select a new
    destination. Then, we set up the patrol point as the destination of the `navMeshAgent`
    component (as described in [*Chapter 8*](B17984_08_Epub.xhtml#_idTextAnchor447),
    *Navigation Mesh*).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有玩家在范围内，那么我们就开始四处游荡。首先，我们检查是否已经到达当前目的地。如果是这样，我们需要选择一个新的目的地。然后，我们将巡逻点设置为`navMeshAgent`组件的目标（如[*第8章*](B17984_08_Epub.xhtml#_idTextAnchor447)，*导航网格*）中所述）。
- en: 'The `IsInCurrentRange` function is just a simple comparison, as shown in the
    following code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IsInCurrentRange`函数只是一个简单的比较，如下面的代码所示：'
- en: '[PRE12]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'That''s it. Add the `AITankController` script to the `CompleteAITank` prefab
    and connect all the required elements. You can see how the `AITankController`
    component should look in the following screenshot:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这些。将`AITankController`脚本添加到`CompleteAITank`预制件中，并连接所有必需的元素。您可以在以下屏幕截图中看到`AITankController`组件应该看起来是什么样子：
- en: '![Figure 12.9 – The AI Tank Controller script in the Inspector'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.9 – 检查器中的AI坦克控制器脚本'
- en: '](img/B17984_12_9.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图B17984_12_9.jpg](img/B17984_12_9.jpg)'
- en: Figure 12.9 – The AI Tank Controller script in the Inspector
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9 – 检查器中的AI坦克控制器脚本
- en: Remember also to set the prefab's layer to **AI**.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 记得也将预制件的层设置为**AI**。
- en: '![Figure 12.10 – The Layer configuration for the CompleteTankAI prefab'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.10 – CompleteTankAI预制件的层配置'
- en: '](img/B17984_12_10.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图B17984_12_10.jpg](img/B17984_12_10.jpg)'
- en: Figure 12.10 – The Layer configuration for the CompleteTankAI prefab
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10 – CompleteTankAI预制件的层配置
- en: At this point, everything is in place. So run the game and enjoy your simple
    tank moving around, shooting at you.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切准备就绪。所以运行游戏，享受你的简单坦克四处移动，向你射击。
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we applied some of the AI techniques that we learned previously
    to our simple tanks combat game. Then, of course, we'd be able to use some more
    techniques in a larger game scope. Still, in this short chapter, we reused the
    simple FSM framework that we built in [*Chapter 2*](B17984_02_Epub.xhtml#_idTextAnchor100),
    *Finite State Machines*, as well as Unity's built-in navigation meshes capabilities.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将之前学到的某些人工智能技术应用于我们的简单坦克战斗游戏。当然，我们将在更大游戏范围内使用更多技术。然而，在本章简短的内容中，我们重用了在[*第二章*](B17984_02_Epub.xhtml#_idTextAnchor100)“有限状态机”中构建的简单FSM框架，以及Unity内置的导航网格功能。
- en: 'This example project is a perfect starting point for exploring the AI techniques
    introduced in this book. You can implement many more improvements to the AI of
    this demo, and I encourage you to play with it a bit more. There are several pieces
    of low-hanging fruit, so here are my suggestions:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例项目是探索本书中介绍的人工智能技术的完美起点。你可以对演示中的AI进行更多改进，我鼓励你多玩一会儿。有几个显而易见的机会，所以这里是我的建议：
- en: As a first exercise, you can increase the number of states, for instance, by
    adding a *Chasing* state in which the tank will actively look for the player.
    This structure is like the *Attack* state, but with a bigger radius. Then, as
    a more significant step, try to replace the FSM with a Behavior tree. The Behavior
    tree that we implemented in the Behavior tree demo is incredibly apt for this
    scenario. Finally, you need to change the script to call the correct function
    for the tank game, but it is an excellent exercise.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个练习，你可以增加状态的数量，例如，通过添加一个*追逐*状态，在这个状态下，坦克将积极寻找玩家。这种结构与*攻击*状态类似，但半径更大。然后，作为一个更重要的步骤，尝试用行为树替换FSM。我们在行为树演示中实现的行为树非常适合这种场景。最后，你需要修改脚本以调用坦克游戏的正确函数，但这是一个极好的练习。
- en: We hope that you learned something new in areas related to AI in games and Unity3D.
    We just scratched the surface of gameplay AI programming, but if you have reached
    the end of this book, you are suited for any challenge you may encounter in the
    future. Good luck, and have fun!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你在与游戏和Unity3D相关的AI领域学到了一些新东西。我们只是触及了游戏AI编程的表面，但如果你能读到这本书的结尾，你将适合未来可能遇到的任何挑战。祝你好运，玩得开心！
