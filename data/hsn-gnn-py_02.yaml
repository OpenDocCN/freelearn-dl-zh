- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Graph Theory for Graph Neural Networks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图论与图神经网络
- en: '**Graph theory** is a fundamental branch of mathematics that deals with the
    study of graphs and networks. A graph is a visual representation of complex data
    structures that helps us understand the relationships between different entities.
    Graph theory provides us with tools to model and analyze a vast array of real-world
    problems, such as transportation systems, social networks, and internet connectivity.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**图论**是数学的一个基础分支，研究图和网络的相关内容。图是复杂数据结构的可视化表示，帮助我们理解不同实体之间的关系。图论为我们提供了建模和分析各种现实问题的工具，如交通系统、社交网络和互联网连接等。'
- en: 'In this chapter, we will delve into the essentials of graph theory, covering
    three main topics: graph properties, graph concepts, and graph algorithms. We
    will begin by defining graphs and their components. We will then introduce the
    different types of graphs and explain their properties and applications. Next,
    we will cover fundamental graph concepts, objects, and measures, including the
    adjacency matrix. Finally, we will dive into graph algorithms, focusing on the
    two fundamental algorithms, **breadth-first search** (**BFS**) and **depth-first**
    **search** (**DFS**).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨图论的基础知识，涵盖三个主要主题：图的属性、图的概念和图算法。我们将从定义图及其组成部分开始。然后，我们将介绍不同类型的图，并解释它们的属性和应用。接着，我们将讲解基本的图概念、对象和度量，包括邻接矩阵。最后，我们将深入讨论图算法，重点讲解两种基础算法：**广度优先搜索**（**BFS**）和**深度优先搜索**（**DFS**）。
- en: By the end of this chapter, you will have a solid foundation in graph theory,
    allowing you to tackle more advanced topics and design graph neural networks.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将建立起图论的坚实基础，从而能够处理更高级的主题并设计图神经网络。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主要内容：
- en: Introducing graph properties
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍图的属性
- en: Discovering graph concepts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索图的概念
- en: Exploring graph algorithms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索图算法
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples from this chapter can be found on GitHub at [https://github.com/PacktPublishing/Hands-On-Graph-Neural-Networks-Using-Python/tree/main/Chapter02](https://github.com/PacktPublishing/Hands-On-Graph-Neural-Networks-Using-Python/tree/main/Chapter02).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所有的代码示例可以在GitHub上找到，链接：[https://github.com/PacktPublishing/Hands-On-Graph-Neural-Networks-Using-Python/tree/main/Chapter02](https://github.com/PacktPublishing/Hands-On-Graph-Neural-Networks-Using-Python/tree/main/Chapter02)。
- en: The installation steps required to run the code on your local machine can be
    found in the *Preface* of this book.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的*前言*中可以找到在本地机器上运行代码所需的安装步骤。
- en: Introducing graph properties
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍图的属性
- en: In graph theory, a graph is a mathematical structure consisting of a set of
    objects, called **vertices** or **nodes**, and a set of connections, called **edges**,
    which link pairs of vertices. The notation ![](img/Formula_B19153_02_001.png)
    is used to represent a graph, where ![](img/Formula_B19153_02_002.png) is the
    graph, ![](img/Formula_B19153_02_003.png) is the set of vertices, and ![](img/Formula_B19153_02_0031.png)
    is the set of edges.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在图论中，图是由一组对象（称为**顶点**或**节点**）和一组连接（称为**边**）组成的数学结构，边连接顶点对。符号 ![](img/Formula_B19153_02_001.png)
    用于表示一个图，其中 ![](img/Formula_B19153_02_002.png) 是图， ![](img/Formula_B19153_02_003.png)
    是顶点集， ![](img/Formula_B19153_02_0031.png) 是边集。
- en: The nodes of a graph can represent any objects, such as cities, people, web
    pages, or molecules, and the edges represent the relationships or connections
    between them, such as physical roads, social relationships, hyperlinks, or chemical
    bonds.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图的节点可以表示任何对象，如城市、人物、网页或分子，边表示它们之间的关系或连接，例如物理道路、社交关系、超链接或化学键。
- en: This section provides an overview of fundamental graph properties that will
    be used extensively in later chapters.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了图的基本属性概述，这些属性将在后续章节中广泛使用。
- en: Directed graphs
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有向图
- en: One of the most basic properties of a graph is whether it is directed or undirected.
    In a **directed graph**, also called a **digraph**, each edge has a direction
    or orientation. This means that the edge connects two nodes in a particular direction,
    where one node is the source and the other is the destination. In contrast, an
    undirected graph has undirected edges, where the edges have no direction. This
    means that the edge between two vertices can be traversed in either direction,
    and the order in which we visit the nodes does not matter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图的最基本性质之一是它是有向图还是无向图。在**有向图**中，也叫**有向图**（**digraph**），每条边都有方向或指向性。这意味着边连接两个节点，并且有特定的方向，其中一个节点是源节点，另一个是目标节点。相比之下，无向图的边是无方向的，这意味着连接两个顶点的边可以在任意方向上遍历，并且访问节点的顺序无关紧要。
- en: 'In Python, we can use the `networkx` library to define an undirected graph
    as follows with `nx.Graph()`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以使用`networkx`库来定义一个无向图，代码如下：`nx.Graph()`：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `G` graph corresponds to the following figure:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`G`图对应以下图示：'
- en: '![Figure 2.1 – Example of an undirected graph](img/B19153_02_001.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 无向图示例](img/B19153_02_001.jpg)'
- en: Figure 2.1 – Example of an undirected graph
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 无向图示例
- en: 'The code to create a directed graph is similar; we simply replace `nx.Graph()`
    with `nx.DiGraph()`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 创建有向图的代码类似；我们只需将`nx.Graph()`替换为`nx.DiGraph()`：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `DG` graph corresponds to the following figure:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`DG`图对应以下图示：'
- en: '![Figure 2.2 – Example of a directed graph](img/B19153_02_002.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 有向图示例](img/B19153_02_002.jpg)'
- en: Figure 2.2 – Example of a directed graph
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 有向图示例
- en: In directed graphs, edges are typically represented using arrows to denote their
    orientation, as in *Figure 2**.2*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在有向图中，边通常使用箭头来表示其方向性，如在*图 2.2*中所示。
- en: Weighted graphs
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加权图
- en: Another important property of graphs is whether the edges are weighted or unweighted.
    In a **weighted graph**, each edge has a weight or cost associated with it. These
    weights can represent various factors, such as distance, travel time, or cost.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图的另一个重要属性是边是否加权。在**加权图**中，每条边都有一个与之相关的权重或代价。这些权重可以表示各种因素，如距离、旅行时间或成本。
- en: For example, in a transportation network, the weights of edges might represent
    the distances between different cities or the time it takes to travel between
    them. In contrast, unweighted graphs have no weight associated with their edges.
    These types of graphs are commonly used in situations where the relationships
    between nodes are binary, and the edges simply indicate the presence or absence
    of a connection between them.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在交通网络中，边的权重可能代表不同城市之间的距离或旅行所需的时间。相比之下，无加权图的边没有权重与之关联。这些类型的图通常用于节点之间关系是二元的情况，其中边仅表示它们之间连接的存在与否。
- en: 'We can modify the previous undirected graph to add weights to our edges. In
    `networkx`, the edges of the graph are defined with a tuple containing the start
    and end nodes and a dictionary specifying the edge’s weight:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改之前的无向图，给边添加权重。在`networkx`中，图的边是通过包含起始节点和结束节点的元组以及指定边权重的字典来定义的：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `WG` graph corresponds to the following figure:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`WG`图对应以下图示：'
- en: '![Figure 2.3 – Example of a weighted graph](img/B19153_02_003.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 加权图示例](img/B19153_02_003.jpg)'
- en: Figure 2.3 – Example of a weighted graph
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 加权图示例
- en: Connected graphs
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连通图
- en: Graph connectivity is a fundamental concept in graph theory that is closely
    related to the graph’s structure and function.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图的连通性是图论中的一个基本概念，与图的结构和功能密切相关。
- en: In a **connected graph**, there is a path between any two vertices in the graph.
    Formally, a ![](img/Formula_B19153_02_005.png) graph is connected if, and only
    if, for every pair of ![](img/Formula_B19153_02_006.png) and ![](img/Formula_B19153_02_007.png)
    vertices in ![](img/Formula_B19153_02_008.png), there exists a path from ![](img/Formula_B19153_02_009.png)
    to ![](img/Formula_B19153_02_010.png). In contrast, a graph is disconnected if
    it is not connected, which means that at least two vertices are not connected
    by a path.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在**连通图**中，图中任意两个顶点之间都有一条路径。形式上，图是连通的，当且仅当，对于每一对![](img/Formula_B19153_02_006.png)和![](img/Formula_B19153_02_007.png)顶点，图中存在从![](img/Formula_B19153_02_009.png)到![](img/Formula_B19153_02_010.png)的路径。相反，图是不连通的，如果它不是连通的，这意味着至少有两个顶点之间没有路径连接。
- en: 'The `networkx` library provides a built-in function for verifying whether a
    graph is connected or not. In the following example, the first graph contains
    isolated nodes (`4` and `5`), unlike the second graph. This is visualized in *Figure
    2**.4*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`networkx`库提供了一个内置函数来验证图是否连通。在下面的例子中，第一个图包含孤立节点（`4`和`5`），与第二个图不同。这个特性在*图 2.4*中得到了可视化：'
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This code prints the following output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会输出以下内容：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first graph is disconnected because of nodes `4` and `5`. On the other
    hand, the second graph is connected. This property is easy to visualize with small
    graphs, as in the following figure:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个图是断开的，因为存在节点`4`和`5`。另一方面，第二个图是连通的。这个性质在小图中很容易可视化，如下图所示：
- en: '![Figure 2.4 – Left: graph 1 with isolated nodes (disconnected graph); right:
    graph 2 where each node is connected to at least another one (connected graph)](img/B19153_02_004.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 左：图 1 含有孤立节点（断开图）；右：图 2 中每个节点至少与另一个节点相连（连通图)](img/B19153_02_004.jpg)'
- en: 'Figure 2.4 – Left: graph 1 with isolated nodes (disconnected graph); right:
    graph 2 where each node is connected to at least another one (connected graph)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 左：图 1 含有孤立节点（断开图）；右：图 2 中每个节点至少与另一个节点相连（连通图）
- en: Connected graphs have several interesting properties and applications. For example,
    in a communication network, a connected graph ensures that any two nodes can communicate
    with each other through a path. In contrast, disconnected graphs can have isolated
    nodes that cannot communicate with other nodes in the network, making it challenging
    to design efficient routing algorithms.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 连通图具有一些有趣的属性和应用。例如，在通信网络中，连通图确保任何两个节点都可以通过路径相互通信。相比之下，断开图可能会包含无法与其他节点通信的孤立节点，这使得设计高效的路由算法变得更加困难。
- en: There are different ways to measure the connectivity of a graph. One of the
    most common measures is the minimum number of edges that need to be removed to
    disconnect the graph, which is known as the graph’s minimum cut. The minimum cut
    problem has several applications in network flow optimization, clustering, and
    community detection.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 测量图的连通性有多种方法。最常见的测量方法之一是最小割，即需要删除的最小边数，以使图断开。最小割问题在网络流优化、聚类和社区检测中有着广泛的应用。
- en: Types of graphs
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图的类型
- en: 'In addition to the commonly used graph types, there are some special types
    of graphs that have unique properties and characteristics:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常见的图类型外，还有一些特殊类型的图具有独特的属性和特点：
- en: A **tree** is a connected, undirected graph with no cycles (like the graph in
    *Figure 2**.1*). Since there is only one path between any two nodes in a tree,
    a tree is a special case of a graph. Trees are often used to model hierarchical
    structures, such as family trees, organizational structures, or classification
    trees.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**树** 是一种连通的无向图，没有环路（如*图 2.1*所示）。由于树中任意两节点之间只有一条路径，树实际上是图的一种特殊情况。树常用于建模层次结构，如家谱、组织结构或分类树。'
- en: A **rooted tree** is a tree in which one node is designated as the root, and
    all other vertices are connected to it by a unique path. Rooted trees are often
    used in computer science to represent hierarchical data structures, such as filesystems
    or the structure of XML documents.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有根树** 是一种树，其中一个节点被指定为根，所有其他顶点通过唯一路径与根相连。根树常用于计算机科学中表示层次数据结构，如文件系统或XML文档的结构。'
- en: A **directed acyclic graph** (**DAG**) is a directed graph that has no cycles
    (like the graph in *Figure 2**.2*). This means that the edges can only be traversed
    in a particular direction, and there are no loops or cycles. DAGs are often used
    to model dependencies between tasks or events – for example, in project management
    or in computing the critical path of a job.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有向无环图** (**DAG**) 是一种没有环路的有向图（如*图 2.2*所示）。这意味着边只能按照特定方向遍历，并且没有环路或回路。DAG通常用于建模任务或事件之间的依赖关系——例如，在项目管理中或计算作业的关键路径时。'
- en: A **bipartite graph** is a graph in which the vertices can be divided into two
    disjoint sets, such that all edges connect vertices in different sets. Bipartite
    graphs are often used in mathematics and computer science to model relationships
    between two different types of objects, such as buyers and sellers, or employees
    and projects.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二分图** 是一种图，其中顶点可以分为两个互不相交的集合，且所有边都连接不同集合中的顶点。二分图常用于数学和计算机科学中建模两种不同对象之间的关系，例如买家与卖家、员工与项目。'
- en: A **complete graph** is a graph in which every pair of vertices is connected
    by an edge. Complete graphs are often used in combinatorics to model problems
    involving all possible pairwise connections, and in computer networks to model
    fully connected networks.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完全图**是每对顶点之间都有一条边相连的图。完全图常用于组合学中模拟涉及所有可能的配对连接的问题，也用于计算机网络中模拟完全连接的网络。'
- en: '*Figure 2**.5* illustrates these different types of graphs:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2.5* 展示了这些不同类型的图：'
- en: '![Figure 2.5 – Common types of graphs](img/B19153_02_005.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 常见图类型](img/B19153_02_005.jpg)'
- en: Figure 2.5 – Common types of graphs
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 常见图类型
- en: Now that we have reviewed essential types of graphs, let’s move on to exploring
    some of the most important graph objects. Understanding these concepts will help
    us analyze and manipulate graphs effectively.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了基本的图类型，接下来让我们探索一些最重要的图对象。理解这些概念将帮助我们更有效地分析和操作图。
- en: Discovering graph concepts
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索图概念
- en: In this section, we will explore some of the essential concepts in graph theory,
    including graph objects (such as degree and neighbors), graph measures (such as
    centrality and density), and the adjacency matrix representation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨图论中的一些基本概念，包括图对象（如度数和邻居）、图度量（如中心性和密度），以及邻接矩阵表示法。
- en: Fundamental objects
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本对象
- en: 'One of the key concepts in graph theory is the **degree** of a node, which
    is the number of edges **incident** to this node. An edge is said to be incident
    on a node if that node is one of the edge’s endpoints. The degree of a node ![](img/Formula_B19153_02_011.png)
    is often denoted by ![](img/Formula_B19153_02_012.png). It can be defined for
    both directed and undirected graphs:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图论中的一个关键概念是节点的**度数**，即与该节点相连的边的数量。如果一条边的端点之一是该节点，则称这条边与该节点相交。节点的度数 ![](img/Formula_B19153_02_011.png)
    通常用 ![](img/Formula_B19153_02_012.png) 表示。它可以在有向图和无向图中定义：
- en: In an undirected graph, the degree of a vertex is the number of edges that are
    connected to it. Note that if the node is connected to itself (called a **loop**,
    or **self-loop**), it adds two to the degree.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在无向图中，顶点的度数是与之相连的边的数量。需要注意的是，如果节点与自身相连（称为**环**或**自环**），则它会将度数加二。
- en: 'In a directed graph, the degree is divided into two types: **indegree** and
    **outdegree**. The indegree (denoted by ![](img/Formula_B19153_02_013.png)) of
    a node represents the number of edges that point towards that node, while the
    outdegree (denoted by ![](img/Formula_B19153_02_014.png)) represents the number
    of edges that start from that node. In this case, a self-loop adds one to the
    indegree and to the outdegree.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在有向图中，度数分为两种类型：**入度**和**出度**。节点的入度（由 ![](img/Formula_B19153_02_013.png) 表示）表示指向该节点的边的数量，而出度（由
    ![](img/Formula_B19153_02_014.png) 表示）表示从该节点出发的边的数量。在这种情况下，自环会将入度和出度都加一。
- en: Indegree and outdegree are essential for analyzing and understanding directed
    graphs, as they provide insight into how information or resources are distributed
    within the graph. For example, nodes with high indegree are likely to be important
    sources of information or resources. In contrast, nodes with high outdegree are
    likely to be important destinations or consumers of information or resources.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 入度和出度对于分析和理解有向图至关重要，因为它们提供了关于图中信息或资源分布的洞察。例如，入度较高的节点可能是重要的信息或资源来源。相反，出度较高的节点可能是重要的信息或资源的目的地或消费者。
- en: 'In `networkx`, we can simply calculate the node degree, indegree, or outdegree
    using built-in methods. Let’s do it for the undirected graph from *Figure 2**.1*
    and the directed graph from *Figure 2**.2*:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`networkx`中，我们可以通过内置方法简单地计算节点的度数、入度或出度。让我们对*图 2.1*中的无向图和*图 2.2*中的有向图进行计算：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code prints the following output:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码输出如下结果：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can compare it to the graphs from *Figures 2.1* and *2.2*: node ![](img/Formula_B19153_02_015.png)
    is connected to two edges (![](img/Formula_B19153_02_016.png)), but is not the
    destination of any of them (![](img/Formula_B19153_02_017.png)).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其与*图 2.1*和*图 2.2*中的图进行比较：节点 ![](img/Formula_B19153_02_015.png) 连接到两条边 (![](img/Formula_B19153_02_016.png))，但不是它们的目的地
    (![](img/Formula_B19153_02_017.png))。
- en: The concept of node degree is related to that of **neighbors**. Neighbors refer
    to the nodes directly connected to a particular node through an edge. Moreover,
    two nodes are said to be **adjacent** if they share at least one common neighbor.
    The concepts of neighbors and adjacency are fundamental to many graph algorithms
    and applications, such as searching for a **path** between two nodes or identifying
    clusters in a network.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 节点度的概念与**邻居**的概念相关。邻居是通过一条边直接连接到特定节点的节点。此外，如果两个节点共享至少一个共同的邻居，则称它们为**相邻**。邻居和相邻的概念对于许多图算法和应用非常基础，例如在两个节点之间寻找**路径**或识别网络中的簇。
- en: 'In graph theory, a path is a sequence of edges that connect two nodes (or more)
    in a graph. The length of a path is the number of edges that are traversed along
    the path. There are different types of paths, but two of them are particularly
    important:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在图论中，路径是连接图中两个（或更多）节点的边的序列。路径的长度是沿路径遍历的边的数量。路径有不同的类型，但其中有两种特别重要：
- en: A **simple path** is a path that does not visit any node more than once, except
    for the start and end vertices
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单路径**是指一个路径，在此路径中，除了起始和结束顶点外，不访问任何节点超过一次。'
- en: A **cycle** is a path in which the first and last vertices are the same. A graph
    is said to be acyclic if it contains no cycles (such as trees and DAGs)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环路**是一个路径，其中第一个和最后一个顶点是相同的。如果图中没有环路（例如树和有向无环图），则称该图为无环图。'
- en: Degrees and paths can be used to determine the importance of a node in a network.
    This measure is referred to as **centrality**.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 度和路径可以用来确定节点在网络中的重要性。这个度量被称为**中心性**。
- en: Graph measures
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图度量
- en: 'Centrality quantifies the importance of a vertex or node in a network. It helps
    us to identify key nodes in a graph based on their connectivity and influence
    on the flow of information or interactions within the network. There are several
    measures of centrality, each providing a different perspective on the importance
    of a node:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 中心性量化了图中一个顶点或节点的重要性。它帮助我们基于节点的连接性和对信息或交互流动的影响，识别图中的关键节点。中心性有几种度量方式，每种度量方式从不同的角度衡量节点的重要性：
- en: '**Degree centrality** is one of the simplest and most commonly used measures
    of centrality. It is simply defined as the degree of the node. A high degree centrality
    indicates that a vertex is highly connected to other vertices in the graph, and
    thus significantly influences the network.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**度中心性**是最简单且最常用的中心性度量之一。它被简单地定义为节点的度数。高度中心性表示一个顶点与图中其他顶点的连接非常紧密，因此对网络有着重要的影响。'
- en: '**Closeness centrality** measures how close a node is to all other nodes in
    the graph. It corresponds to the average length of the shortest path between the
    target node and all other nodes in the graph. A node with high closeness centrality
    can quickly reach all other vertices in the network.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接近中心性**衡量一个节点与图中所有其他节点的接近程度。它对应于目标节点与图中所有其他节点之间最短路径的平均长度。具有高接近中心性的节点能够迅速到达网络中的所有其他顶点。'
- en: '**Betweenness centrality** measures the number of times a node lies on the
    shortest path between pairs of other nodes in the graph. A node with high betweenness
    centrality acts as a bottleneck or bridge between different parts of the graph.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**介数中心性**衡量一个节点在图中两个其他节点之间的最短路径上出现的次数。具有高介数中心性的节点充当图中不同部分之间的瓶颈或桥梁。'
- en: 'Let’s calculate these measures on our previous graphs using the built-in functions
    of `networkx` and analyze the result:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`networkx`的内置函数在我们之前的图中计算这些度量，并分析结果：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The previous code prints the dictionaries, containing a score for each node:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码会打印包含每个节点得分的字典：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The importance of nodes ![](img/Formula_B19153_02_018.png), ![](img/Formula_B19153_02_019.png),
    and ![](img/Formula_B19153_02_020.png) in a graph depends on the type of centrality
    used. Degree centrality considers nodes ![](img/Formula_B19153_02_021.png) and
    ![](img/Formula_B19153_02_022.png) to be more important because they have more
    neighbors than node ![](img/Formula_B19153_02_023.png). However, in closeness
    centrality, node ![](img/Formula_B19153_02_024.png) is the most important as it
    can reach any other node in the graph in the shortest possible path. On the other
    hand, nodes ![](img/Formula_B19153_02_025.png), ![](img/Formula_B19153_02_026.png)
    and ![](img/Formula_B19153_02_027.png) have equal betweenness centrality, as they
    all lie on a large number of shortest paths between other nodes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图中节点![](img/Formula_B19153_02_018.png)、![](img/Formula_B19153_02_019.png)和![](img/Formula_B19153_02_020.png)的重要性取决于使用的中心性类型。度中心性认为节点![](img/Formula_B19153_02_021.png)和![](img/Formula_B19153_02_022.png)更重要，因为它们有比节点![](img/Formula_B19153_02_023.png)更多的邻居。然而，在接近中心性中，节点![](img/Formula_B19153_02_024.png)最为重要，因为它可以通过最短路径到达图中的任何其他节点。另一方面，节点![](img/Formula_B19153_02_025.png)、![](img/Formula_B19153_02_026.png)和![](img/Formula_B19153_02_027.png)具有相同的介数中心性，因为它们都位于其他节点之间许多最短路径上。
- en: In addition to these measures, we will see how to calculate the importance of
    a node using machine learning techniques in the next chapters. However, it is
    not the only measure we will cover.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些措施，我们将在接下来的章节中看到如何使用机器学习技术计算一个节点的重要性。然而，这并不是我们将要讨论的唯一指标。
- en: Indeed, **density** is another important measure, indicating how connected a
    graph is. It is a ratio between the actual number of edges and the maximum possible
    number of edges in the graph. A graph with high density is considered more connected
    and has more information flow compared to a graph with low density.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，**密度**是另一个重要的度量，表示图的连通性。它是图中实际边数与最大可能边数的比率。一个高密度的图被认为更为连通，并且比低密度图有更多的信息流动。
- en: The formula to calculate density depends on whether the graph is directed or
    undirected. For an undirected graph with ![](img/Formula_B19153_02_028.png) nodes,
    the maximum possible number of edges is ![](img/Formula_B19153_02_029.png). For
    a directed graph with ![](img/Formula_B19153_02_030.png) nodes, the maximum number
    of edges is ![](img/Formula_B19153_02_031.png).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 计算密度的公式取决于图是否是有向图或无向图。对于一个包含![](img/Formula_B19153_02_028.png)个节点的无向图，最大可能的边数是![](img/Formula_B19153_02_029.png)。对于一个包含![](img/Formula_B19153_02_030.png)个节点的有向图，最大边数是![](img/Formula_B19153_02_031.png)。
- en: The density of a graph is calculated as the number of edges divided by the maximum
    number of edges. For example, the graph in *Figure 2**.1* has ![](img/Formula_B19153_02_032.png)
    edges and the maximum possible number of ![](img/Formula_B19153_02_033.png) edges.
    Therefore, it has a density of ![](img/Formula_B19153_02_034.png).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图的密度是通过边的数量除以最大边数来计算的。例如，*图 2**.1*中的图有![](img/Formula_B19153_02_032.png)条边，最大可能的边数为![](img/Formula_B19153_02_033.png)。因此，其密度为![](img/Formula_B19153_02_034.png)。
- en: 'A dense graph has a density closer to 1, while a sparse graph has a density
    closer to 0\. There is no strict rule for what constitutes a dense or sparse graph,
    but generally, a graph is considered dense if its density is greater than 0.5
    and sparse if its density is less than 0.1\. This measure is directly connected
    to a fundamental problem with graphs: how to represent the **adjacency matrix**.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一个密集的图的密度接近1，而一个稀疏的图的密度接近0。对于密集图或稀疏图没有严格的定义，但一般来说，如果图的密度大于0.5，则认为它是密集的；如果密度小于0.1，则认为它是稀疏的。这个指标直接与图的一个基本问题相关：如何表示**邻接矩阵**。
- en: Adjacency matrix representation
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 邻接矩阵表示法
- en: An adjacency matrix is a matrix that represents the edges in a graph, where
    each cell indicates whether there is an edge between two nodes. The matrix is
    a square matrix of size ![](img/Formula_B19153_02_035.png), where ![](img/Formula_B19153_02_036.png)
    is the number of nodes in the graph. A value of ![](img/Formula_B19153_02_037.png)
    in the cell ![](img/Formula_B19153_02_038.png) indicates that there is an edge
    between node ![](img/Formula_B19153_02_039.png) and node ![](img/Formula_B19153_02_040.png),
    while a value of ![](img/Formula_B19153_02_041.png) indicates that there is no
    edge. For an undirected graph, the matrix is symmetric, while for a directed graph,
    the matrix is not necessarily symmetric.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 邻接矩阵是表示图中边的矩阵，其中每个单元格指示两个节点之间是否有边。该矩阵是一个大小为![](img/Formula_B19153_02_035.png)的方阵，其中![](img/Formula_B19153_02_036.png)是图中节点的数量。单元格![](img/Formula_B19153_02_038.png)中的值![](img/Formula_B19153_02_037.png)表示节点![](img/Formula_B19153_02_039.png)和节点![](img/Formula_B19153_02_040.png)之间有边，而值![](img/Formula_B19153_02_041.png)表示没有边。对于无向图，矩阵是对称的，而对于有向图，矩阵不一定是对称的。
- en: 'The following figure indicates the adjacency matrix associated with the graph:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下图表示与图相关的邻接矩阵：
- en: '![Figure 2.6 – Example of the adjacency matrix](img/B19153_02_006.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 邻接矩阵示例](img/B19153_02_006.jpg)'
- en: Figure 2.6 – Example of the adjacency matrix
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 邻接矩阵示例
- en: 'In Python, it can be implemented as a list of lists, as shown in this example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，它可以实现为一个列表的列表，如下面的示例所示：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The adjacency matrix is a straightforward representation that can be easily
    visualized as a 2D array. One of the key advantages of using an adjacency matrix
    is that checking whether two nodes are connected is a constant time operation.
    This makes it an efficient way to test the existence of an edge in the graph.
    Moreover, it is used to perform matrix operations, which are useful for certain
    graph algorithms, such as calculating the shortest path between two nodes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 邻接矩阵是一种简单直观的表示方式，可以轻松地将其可视化为二维数组。使用邻接矩阵的一个主要优点是检查两个节点是否连接是一个常数时间操作。这使得它成为测试图中边存在与否的高效方式。此外，它还用于执行矩阵操作，这对于某些图算法很有用，例如计算两个节点之间的最短路径。
- en: 'However, adding or removing nodes can be costly, as the matrix needs to be
    resized or shifted. One of the main drawbacks of using an adjacency matrix is
    its space complexity: as the number of nodes in the graph grows, the space required
    to store the adjacency matrix increases exponentially. Formally, we say that the
    adjacency matrix has a space complexity of ![](img/Formula_B19153_02_042.png),
    where ![](img/Formula_B19153_02_043.png) represents the number of nodes in the
    graph.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，添加或删除节点可能会很昂贵，因为矩阵需要调整大小或移动。使用邻接矩阵的主要缺点之一是其空间复杂度：随着图中节点数量的增加，存储邻接矩阵所需的空间呈指数增长。形式上，我们说邻接矩阵的空间复杂度为![](img/Formula_B19153_02_042.png)，其中![](img/Formula_B19153_02_043.png)表示图中节点的数量。
- en: Overall, while the adjacency matrix is a useful data structure for representing
    small graphs, it may not be practical for larger ones due to its space complexity.
    Additionally, the overhead of adding or removing nodes can make it inefficient
    for dynamically changing graphs.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，虽然邻接矩阵是表示小型图的有用数据结构，但由于其空间复杂度，对于较大的图来说可能不太实际。此外，添加或删除节点的开销可能使其在动态变化的图中效率低下。
- en: 'This is why other representations can be helpful. For example, another popular
    way to store graphs is the `networkx`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么其他表示方式可能会很有帮助的原因。例如，存储图的另一种流行方式是`networkx`：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When we compare both data structures applied to our graph, it is clear that
    the edge list is less verbose. This is the case because our graph is fairly sparse.
    On the other hand, if our graph was complete, we would require 21 tuples instead
    of 6\. This is explained by a space complexity of ![](img/Formula_B19153_02_044.png),
    where ![](img/Formula_B19153_02_045.png) is the number of edges. Edge lists are
    more efficient for storing sparse graphs, where the number of edges is much smaller
    than the number of nodes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们比较两种数据结构在我们的图中的应用时，很明显边列表更简洁。这是因为我们的图是相对稀疏的。另一方面，如果我们的图是完全图，我们将需要21个元组，而不是6个。这是由空间复杂度![](img/Formula_B19153_02_044.png)解释的，其中![](img/Formula_B19153_02_045.png)是边的数量。边列表在存储稀疏图时更为高效，在这种情况下，边的数量远小于节点的数量。
- en: However, checking whether two vertices are connected in an edge list requires
    iterating through the entire list, which can be time-consuming for large graphs
    with many edges. Therefore, edge lists are more commonly used in applications
    where space is a concern.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在边表中检查两个顶点是否相连，需要遍历整个列表，对于拥有大量边的大型图，这也是耗时的。因此，边表更常用于空间有限的应用中。
- en: 'A third and popular representation is the **adjacency list**. It consists of
    a list of pairs, where each pair represents a node in the graph and its adjacent
    nodes. The pairs can be stored in a linked list, dictionary, or other data structures,
    depending on the implementation. For example, an adjacency list for our graph
    might look like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种也是常用的表示方式是**邻接表**。它由一系列对组成，其中每对表示图中的一个节点及其相邻的节点。根据实现方式，节点对可以存储在链表、字典或其他数据结构中。例如，我们图的邻接表可能如下所示：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: An adjacency list has several advantages over an adjacency matrix or an edge
    list. First, the space complexity is ![](img/Formula_B19153_02_046.png), where
    ![](img/Formula_B19153_02_047.png) is the number of nodes and ![](img/Formula_B19153_02_048.png)
    is the number of edges. This is more efficient than the ![](img/Formula_B19153_02_049.png)
    space complexity of an adjacency matrix for sparse graphs. Second, it allows for
    efficient iteration through the adjacent vertices of a node, which is useful in
    many graph algorithms. Finally, adding a node or an edge can be done in constant
    time.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 相比邻接矩阵或边表，邻接表有几个优点。首先，空间复杂度是 ![](img/Formula_B19153_02_046.png)，其中 ![](img/Formula_B19153_02_047.png)
    是节点数，![](img/Formula_B19153_02_048.png) 是边数。对于稀疏图，这比邻接矩阵的空间复杂度 ![](img/Formula_B19153_02_049.png)
    更高效。其次，它允许高效地迭代节点的相邻顶点，这在许多图算法中非常有用。最后，添加节点或边可以在常数时间内完成。
- en: However, checking whether two vertices are connected can be slower than with
    an adjacency matrix. This is because it requires iterating through the adjacency
    list of one of the vertices, which can be time-consuming for large graphs.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，检查两个顶点是否相连可能比邻接矩阵慢。这是因为它需要遍历其中一个顶点的邻接表，而对于大型图来说，这可能会非常耗时。
- en: Each data structure has its own advantages and disadvantages that depend on
    the specific application and requirements. In the next section, we will process
    graphs and introduce the two most fundamental graph algorithms.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 每种数据结构都有其自身的优缺点，这取决于具体的应用和需求。在下一节中，我们将处理图，并介绍两种最基础的图算法。
- en: Exploring graph algorithms
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索图算法
- en: 'Graph algorithms are critical in solving problems related to graphs, such as
    finding the shortest path between two nodes or detecting cycles. This section
    will discuss two graph traversal algorithms: BFS and DFS.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图算法在解决与图相关的问题时至关重要，比如寻找两个节点之间的最短路径或检测环路。本节将讨论两种图遍历算法：BFS和DFS。
- en: Breadth-first search
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 广度优先搜索
- en: BFS is a graph traversal algorithm that starts at the root node and explores
    all the neighboring nodes at a particular level before moving to the next level
    of nodes. It works by maintaining a queue of nodes to visit and marking each visited
    node as it is added to the queue. The algorithm then dequeues the next node in
    the queue and explores all its neighbors, adding them to the queue if they haven’t
    been visited yet.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: BFS是一种图遍历算法，它从根节点开始，首先探索特定层次的所有相邻节点，然后再进入下一层的节点。它通过维护一个待访问节点的队列来工作，并在节点被加入队列时标记该节点已访问。然后，算法出队队列中的下一个节点，并探索其所有相邻节点，如果这些节点还没有被访问过，就将它们加入队列。
- en: 'The behavior of a BFS is illustrated in *Figure 2**.7*:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: BFS的行为如*图 2.7*所示：
- en: '![Figure 2.7 – Example of graph traversal made by a breadth-first search](img/B19153_02_007.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – 广度优先搜索遍历图的示例](img/B19153_02_007.jpg)'
- en: Figure 2.7 – Example of graph traversal made by a breadth-first search
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 广度优先搜索遍历图的示例
- en: 'Let’s now see how we can implement it in Python:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何在Python中实现它：
- en: 'We create an empty graph and add edges with the `add_edges_from()` method:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个空图并使用`add_edges_from()`方法添加边：
- en: '[PRE12]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We define a function called `bfs()` that implements the BFS algorithm on a
    graph. The function takes two arguments: the `graph` object and the starting node
    for the search:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`bfs()`的函数，来实现图的BFS算法。该函数接受两个参数：`graph`对象和搜索的起始节点：
- en: '[PRE13]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We initialize two lists (`visited` and `queue`) and add the starting node.
    The `visited` list keeps track of the nodes that have been visited during the
    search, while the `queue` list stores the nodes that need to be visited:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们初始化两个列表（`visited`和`queue`），并添加起始节点。`visited`列表用于跟踪在搜索过程中已经访问过的节点，而`queue`列表则存储需要访问的节点：
- en: '[PRE14]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We enter a `while` loop that continues until the `queue` list is empty. Inside
    the loop, we remove the first node in the `queue` list using the `pop(0)` method
    and store the result in the `node` variable:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们进入一个`while`循环，直到`queue`列表为空。在循环内部，我们使用`pop(0)`方法删除`queue`列表中的第一个节点，并将结果存储在`node`变量中：
- en: '[PRE15]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We iterate through the neighbors of the node using a `for` loop. For each neighbor
    that has not been visited yet, we add it to the `visited` list and to the end
    of the `queue` list using the `append()` method. When it’s complete, we return
    the `visited` list:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`for`循环遍历该节点的邻居。对于每个尚未访问的邻居，我们将其添加到`visited`列表，并将其添加到`queue`列表的末尾，使用`append()`方法。当完成后，我们返回`visited`列表：
- en: '[PRE16]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We call the `bfs()` function with the `G` argument and the `''A''` starting
    node:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用`bfs()`函数，并传入`G`参数和`'A'`起始节点：
- en: '[PRE17]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The function returns the list of visited nodes in the order in which they were
    visited:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数返回按访问顺序排列的已访问节点列表：
- en: '[PRE18]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The order we obtained is the one we anticipated in *Figure 2**.7*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的顺序是我们在*图 2.7*中预期的顺序。
- en: BFS is particularly useful in finding the shortest path between two nodes in
    an unweighted graph. This is because the algorithm visits nodes in order of their
    distance from the starting node, so the first time the target node is visited,
    it must be along the shortest path from the starting node.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: BFS在无权图中寻找两个节点之间最短路径时特别有用。因为该算法按照节点与起始节点的距离顺序访问节点，所以当目标节点第一次被访问时，必定是沿着从起始节点到目标节点的最短路径。
- en: In addition to finding the shortest path, BFS can also be used to check whether
    a graph is connected or to find all connected components of a graph. It is also
    used in applications such as web crawlers, social network analysis, and shortest
    path routing in networks.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 除了寻找最短路径，BFS还可以用来检查图是否连通，或寻找图的所有连通分量。它还被应用于诸如网页爬虫、社交网络分析和网络中的最短路径路由等场景。
- en: The time complexity of BFS is ![](img/Formula_B19153_02_050.png), where ![](img/Formula_B19153_02_051.png)
    is the number of nodes and ![](img/Formula_B19153_02_052.png) is the number of
    edges in the graph. This can be a significant issue for graphs with a high degree
    of connectivity or for graphs that are sparse. Several variants of BFS have been
    developed to mitigate this issue, such as **bidirectional BFS** and **A*** search,
    which use heuristics to reduce the number of nodes that need to be explored.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: BFS的时间复杂度是![](img/Formula_B19153_02_050.png)，其中![](img/Formula_B19153_02_051.png)是节点数，![](img/Formula_B19153_02_052.png)是图中的边数。这对于高连接度图或者稀疏图来说可能是一个显著的问题。为了解决这个问题，已经开发了几种BFS的变体，如**双向BFS**和**A***搜索，这些变体使用启发式方法来减少需要探索的节点数。
- en: Depth-first search
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深度优先搜索
- en: DFS is a recursive algorithm that starts at the root node and explores as far
    as possible along each branch before backtracking.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: DFS是一种递归算法，它从根节点开始，在每个分支上尽可能深入，直到无法再深入，然后回溯。
- en: It chooses a node and explores all of its unvisited neighbors, visiting the
    first neighbor that has not been explored and backtracking only when all the neighbors
    have been visited. By doing so, it explores the graph by following as deep a path
    from the starting node as possible before backtracking to explore other branches.
    This continues until all nodes have been explored.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 它选择一个节点，探索所有未访问的邻居，访问第一个未被探索的邻居，只有在所有邻居都已被访问过时才回溯。这样，它通过尽可能深入地沿着从起始节点出发的路径进行图的探索，然后再回溯去探索其他分支。这个过程会一直持续，直到所有节点都被探索过。
- en: 'The behavior of a DFS is illustrated in *Figure 2**.8*:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: DFS的行为如*图 2.8*所示：
- en: '![Figure 2.8 – Example of graph traversal made by a depth-first search](img/B19153_02_008.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – 深度优先搜索的图遍历示例](img/B19153_02_008.jpg)'
- en: Figure 2.8 – Example of graph traversal made by a depth-first search
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 深度优先搜索的图遍历示例
- en: 'Let’s implement DFS in Python:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Python中实现DFS：
- en: 'We first initialize an empty list called `visited`:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先初始化一个空的列表`visited`：
- en: '[PRE19]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We define a function called `dfs()` that takes in `visited`, `graph`, and `node`
    as arguments:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`dfs()`的函数，该函数接受`visited`、`graph`和`node`作为参数：
- en: '[PRE20]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If the current `node` is not in the `visited` list, we append it to the list:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前的`node`不在`visited`列表中，我们将其添加到该列表：
- en: '[PRE21]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We then iterate through each neighbor of the current `node`. For each neighbor,
    we recursively call the `dfs()` function passing in `visited`, `graph`, and the
    neighbor as arguments:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们遍历当前`node`的每一个邻居。对于每个邻居，我们递归调用`dfs()`函数，传入`visited`、`graph`和邻居作为参数：
- en: '[PRE22]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `dfs()` function continues to explore the graph depth-first, visiting all
    the neighbors of each node until there are no more unvisited neighbors. Finally,
    the `visited` list is returned:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dfs()`函数继续深度优先地遍历图，访问每个节点的所有邻居，直到没有更多未访问的邻居。最后，返回`visited`列表：'
- en: '[PRE23]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We call the `dfs()` function with `visited` set to an empty list, `G` as the
    graph, and `''A''` as the starting node:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用`dfs()`函数，`visited`设置为空列表，`G`作为图，`'A'`作为起始节点：
- en: '[PRE24]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The function returns the list of visited nodes in the order in which they were
    visited:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数返回按访问顺序排列的访问节点列表：
- en: '[PRE25]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once again, the order we obtained is the one we anticipated in *Figure 2**.8*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 再次地，我们得到的顺序与*图2**.8*中的预期顺序一致。
- en: DFS is useful in solving various problems, such as finding connected components,
    topological sorting, and solving maze problems. It is particularly useful in finding
    cycles in a graph since it traverses the graph in a depth-first order, and a cycle
    exists if, and only if, a node is visited twice during the traversal.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: DFS在解决各种问题时非常有用，例如查找连通分量、拓扑排序和解决迷宫问题。它特别适用于在图中查找环，因为它以深度优先的顺序遍历图，只有在遍历过程中某个节点被访问两次时，才说明图中存在环。
- en: Like BFS, it has a time complexity of ![](img/Formula_B19153_02_053.png), where
    ![](img/Formula_B19153_02_054.png) is the number of nodes and ![](img/Formula_B19153_02_055.png)
    is the number of edges in the graph. It requires less memory but doesn’t guarantee
    the shallowest path solution. Finally, unlike BFS, you can be trapped in infinite
    loops using DFS.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 和BFS一样，它的时间复杂度是![](img/Formula_B19153_02_053.png)，其中![](img/Formula_B19153_02_054.png)是节点的数量，![](img/Formula_B19153_02_055.png)是图中的边的数量。它需要的内存较少，但不能保证最短路径解。最后，与BFS不同的是，使用DFS时可能会陷入无限循环。
- en: Additionally, many other algorithms in graph theory build upon BFS and DFS,
    such as Dijkstra’s shortest path algorithm, Kruskal’s minimum spanning tree algorithm,
    and Tarjan’s strongly connected components algorithm. Therefore, a solid understanding
    of BFS and DFS is essential for anyone who wants to work with graphs and develop
    more advanced graph algorithms.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，图论中的许多其他算法都基于BFS和DFS，例如Dijkstra最短路径算法、Kruskal最小生成树算法和Tarjan强连通分量算法。因此，深入理解BFS和DFS对于任何想从事图相关工作并开发更高级图算法的人来说，都是至关重要的。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the essentials of graph theory, a branch of mathematics
    that studies graphs and networks. We began by defining what a graph is and explained
    the different types of graphs, such as directed, weighted, and connected graphs.
    We then introduced fundamental graph objects (including neighbors) and measures
    (such as centrality and density), which are used to understand and analyze graph
    structures.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了图论的基本知识，图论是研究图和网络的数学分支。我们首先定义了图的概念，并解释了不同类型的图，如有向图、加权图和连通图。然后我们介绍了基本的图对象（包括邻居）和度量（如中心性和密度），这些概念用于理解和分析图结构。
- en: Additionally, we discussed the adjacency matrix and its different representations.
    Finally, we explored the two fundamental graph algorithms, BFS and DFS, which
    form the foundation for developing more complex graph algorithms.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们讨论了邻接矩阵及其不同的表示方法。最后，我们探讨了两个基础的图算法，BFS和DFS，它们构成了开发更复杂图算法的基础。
- en: 'In [*Chapter 3*](B19153_03.xhtml#_idTextAnchor041), *Creating Node Representations
    with DeepWalk*, we will explore the DeepWalk architecture and its two components:
    Word2Vec and random walks. We will start by understanding the Word2Vec architecture
    and then implement it using a specialized library. Then, we will delve into the
    DeepWalk algorithm and implement random walks on a graph.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B19153_03.xhtml#_idTextAnchor041)，*使用DeepWalk创建节点表示*中，我们将探讨DeepWalk架构及其两个组成部分：Word2Vec和随机游走。我们将首先了解Word2Vec架构，然后使用专门的库实现它。接着，我们将深入研究DeepWalk算法，并在图上实现随机游走。
