- en: Detecting and Translating Text with Amazon Rekognition and Translate
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Amazon Rekognition和Translate检测与翻译文本
- en: In this chapter, we will build our first **Artificial Intelligence** (**AI**)
    application that solves a real-world problem, as opposed to a theoretical demonstration.
    We will build an application that can translate foreign texts appearing in pictures.
    We will do this by combining two AWS AI services, Amazon Rekognition and Amazon
    Translate. The application will use the reference architecture introduced in the
    previous chapter. In this hands-on project, not only will we be building intelligent
    capabilities for the current application, we will also be designing them to be
    reusable components that we can leverage in future hands-on projects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建第一个**人工智能**（**AI**）应用程序，它解决一个现实问题，而不是一个理论展示。我们将构建一个可以翻译出现在图片中的外文文本的应用程序。我们将通过结合两个AWS
    AI服务——Amazon Rekognition和Amazon Translate来实现这一目标。该应用程序将使用上一章介绍的参考架构。在这个实际项目中，我们不仅会为当前应用程序构建智能功能，还会将它们设计为可重用的组件，以便在未来的实际项目中利用。
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Detecting text in images with Amazon Rekognition
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Amazon Rekognition检测图像中的文本
- en: Translating text using Amazon Translate
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Amazon Translate进行文本翻译
- en: Embedding intelligent capabilities into applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将智能功能嵌入应用程序
- en: Building serverless AI applications with AWS services, RESTful APIs, and web
    user interface
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AWS服务、RESTful API和Web用户界面构建无服务器AI应用程序
- en: Discussing good design practices and build intelligent capabilities as reusable
    components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论良好的设计实践，并将智能功能构建为可重用组件
- en: Making the world smaller
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让世界更小
- en: In this section of the book, we will start building intelligence-enabled solutions
    through hands-on projects. These projects will not only get you familiar with
    Amazon's AI services, they will also help you to strengthen your intuition on
    how to embed intelligent capabilities into applications to solve real-world problems.
    We'll start with an application that can make the world smaller.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，我们将通过实际项目开始构建智能化解决方案。这些项目不仅能让你熟悉亚马逊的AI服务，还将帮助你加强如何将智能功能嵌入应用程序，解决实际问题的直觉。我们将从一个可以让世界更小的应用程序开始。
- en: When Google revealed a new feature in its Google Lens mobile app, users could
    just point their phones at something around their environment and get more information
    about it. Google Lens essentially brought search capabilities into the real world.
    One particular use case of this app was the real-time language translation of
    text. Users can point their camera at a street sign or a restaurant menu and get
    the translation back as an augmented reality camera feed on the phone's display.
    This feature alone can make the world more accessible to everyone.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当谷歌在其Google Lens移动应用中发布新功能时，用户只需将手机指向周围的物体，就能获取更多信息。Google Lens本质上将搜索功能带入了现实世界。这个应用的一个特别用例是实时语言翻译文本。用户可以将相机对准街头标牌或餐厅菜单，并将翻译结果以增强现实摄像头的形式呈现在手机屏幕上。仅凭这一功能，就能让世界变得更加可接近。
- en: We will be implementing this pictorial translation feature for our hands-on
    project with AWS AI services. Our application, we'll call it Pictorial Translator,
    will provide similar translation capabilities, albeit with a much less embellished
    user interface than Google Lens.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在实际项目中实现这一图像翻译功能，使用的是AWS AI服务。我们的应用程序，暂时称之为图像翻译器，将提供类似的翻译功能，尽管其用户界面比谷歌镜头简洁得多。
- en: Understanding the architecture of Pictorial Translator
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解图像翻译器的架构
- en: 'Following the architecture template defined in [Chapter 2](042787e6-6f54-4728-8354-e22d87be0460.xhtml),
    *Anatomy of a Modern AI Application*, here is the architectural design for Pictorial
    Translator:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[第二章](042787e6-6f54-4728-8354-e22d87be0460.xhtml)《现代AI应用程序的结构》定义的架构模板，以下是图像翻译器的架构设计：
- en: '![](img/7d934292-18c1-4c23-a2c5-20e0aa1a2c89.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d934292-18c1-4c23-a2c5-20e0aa1a2c89.png)'
- en: 'We will provide a web user interface for users to upload photos containing
    foreign text and then view the translation of the foreign text. The web user interface
    will interact with the **Orchestration Layer** containing two RESTful endpoints
    to handle the image upload and translation:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为用户提供一个Web用户界面，用户可以上传包含外文文本的照片，然后查看该外文文本的翻译。Web用户界面将与包含两个RESTful端点的**编排层**进行交互，用于处理图片上传和翻译：
- en: '**Upload Image Endpoint** will delegate the image upload to our **Storage Service**:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上传图片端点**将把图片上传委托给我们的**存储服务**：'
- en: '**Storage Service** provides an abstraction layer to **AWS S3**, where the
    uploaded photos will be stored, processed, and displayed from.'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储服务**为**AWS S3**提供了一个抽象层，上传的照片将存储在其中，进行处理并从中显示。'
- en: '**Translate Image Text Endpoint** will delegate the detection of text within
    the photos to our **Recognition Service** and the translation of the detected
    text to our **Translation Service**:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像文本翻译端点**将把照片中文本的检测委托给我们的**识别服务**，并将检测到的文本翻译交给我们的**翻译服务**：'
- en: The **Recognition Service** provides an abstraction layer to the Amazon Rekognition
    service, more specifically, the text detection capability of Rekognition. We named
    our service **Recognition**, which is more generic and doesn't directly tie us
    in with **AWS Rekognition**.
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**识别服务**为亚马逊Rekognition服务提供了一个抽象层，更具体地说，是Rekognition的文本检测功能。我们将我们的服务命名为**识别**，它更为通用，并且不会直接与**AWS
    Rekognition**绑定。'
- en: The **Translation Service** provides an abstraction layer to the Amazon Translate
    service to perform the language translation.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**翻译服务**为亚马逊Translate服务提供了一个抽象层，用于执行语言翻译。'
- en: 'The **Service Implememntation** might seem redundant to some readers. Why not
    just have the endpoints talk to the AWS services directly instead of talking through
    another layer of abstraction? There are many benefits to architecting the application
    this way. Here are a few examples:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务实现**对一些读者来说可能显得有些多余。为什么不直接让端点与AWS服务通信，而是通过另一个抽象层进行通信呢？这种架构方式有许多好处。以下是一些示例：'
- en: During development time, we can more easily build and test the application without
    dependency on AWS services. Any stub or mock implementation of these services
    can be used during development for speed, cost, and experimentation reasons. This
    lets us develop and iterate the application faster.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发阶段，我们可以更轻松地构建和测试应用，而无需依赖AWS服务。在开发过程中，任何这些服务的存根或模拟实现都可以用于提高速度、降低成本和进行实验。这使我们能够更快地开发和迭代应用。
- en: When other services that provide better storage, recognition, or translation
    capabilities come along, our application can switch to those capabilities by swapping
    to a new service implementation with the same abstraction interface. The user
    interface and the endpoints will not need to be modified to leverage these better
    capabilities. This gives our application more flexibility to adapt to changes.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当其他提供更好存储、识别或翻译能力的服务出现时，我们的应用可以通过切换到具有相同抽象接口的新服务实现来使用这些能力。用户界面和端点无需修改即可利用这些更好的功能。这为我们的应用提供了更多的灵活性，以适应变化。
- en: This makes our code base more composable and reusable. The capabilities provided
    by these AWS services can be reused by other applications. These services are
    modular packages that can be more easily reused than the orchestration endpoints.
    The orchestration endpoints usually contain application-specific business logic
    that limits reuse.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使我们的代码库更具可组合性和可重用性。这些AWS服务提供的能力可以被其他应用重用。这些服务是模块化的包，比起协调端点，它们更容易重用。协调端点通常包含特定于应用的业务逻辑，限制了重用性。
- en: Component interactions of Pictorial Translator
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 《图像翻译器组件交互》
- en: 'It''s important to think through how the components of an application interact
    with each other and how the user experience will be influenced by our design choices
    before we dive into the implementation:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入实现之前，思考应用各个组件如何相互交互，以及我们的设计选择如何影响用户体验是非常重要的：
- en: '![](img/96e42da4-7c2f-4a83-8e00-2f4beff34319.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/96e42da4-7c2f-4a83-8e00-2f4beff34319.png)'
- en: From the user's perspective, the application provides a sequential experience
    for uploading the image, viewing the uploaded images, and seeing the translated
    text. We made the design decision to ensure the user waits for each photo to be
    uploaded and processed (as opposed to bulk uploading many photos at once). This
    design decision is fine for our application, given our use case assumes that the
    users are at the physical locations waiting to see the translations before making
    decisions or taking actions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的角度来看，应用提供了一个顺序的体验，包括上传图像、查看已上传图像和查看翻译文本。我们做出了设计决策，确保用户等待每张照片上传并处理完毕（而不是一次性批量上传多张照片）。考虑到我们的使用案例假设用户在物理位置等待翻译结果，以便做出决策或采取行动，这个设计决策对于我们的应用来说是合理的。
- en: Our Pictorial Translator application's interaction with the Upload Image Endpoint
    and `StorageService` is straightforward. The users' requests is essentially passed
    through to AWS S3 and back in a chain. Of course, the fact that the storage capability
    is provided by AWS S3 is shielded from both the endpoint and the application through
    the layers of abstraction. The photos will be stored in an S3 bucket, and the
    text detection and translation will be performed from the S3 bucket.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Pictorial Translator应用与上传图像端点和`StorageService`的交互是直接的。用户的请求本质上会通过链条传递到AWS
    S3并返回。当然，存储能力由AWS S3提供，这一点在端点和应用程序之间通过抽象层进行了屏蔽。照片将存储在S3桶中，文本检测和翻译将在S3桶中执行。
- en: The translate image text endpoint simplifies some business logic from the Pictorial
    Translator application. Pictorial Translator is only sending the image ID to the
    translate image text endpoint and then receiving the translation for every line
    of text in the image. The translate image text endpoint does a couple of things
    behind the scenes. This endpoint is calling `detect_text()` in `RecognitionService`
    on the entire image, and then calling `translate_text()` in Translation Service
    multiple times for the lines of detected text. The endpoint will only call the
    Translation Service if the detected line of text meets a minimum confidence threshold.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译图像文本的端点简化了Pictorial Translator应用程序中的一些业务逻辑。Pictorial Translator只是将图像ID发送到翻译图像文本的端点，然后接收图像中每一行文本的翻译。该端点在后台执行了几项操作。这个端点调用了`RecognitionService`中的`detect_text()`，对整个图像进行处理，然后多次调用翻译服务中的`translate_text()`，对检测到的每一行文本进行翻译。只有当检测到的文本行达到最低置信度阈值时，端点才会调用翻译服务。
- en: 'Here, we made two design decisions:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们做出了两个设计决策：
- en: First, we translate text at the line level. The thinking is that the text we
    see in the real world is not always in the same context (for example, multiple
    street signs in the same photo) or even in the same language. The real-world results
    of this design decision need to be closely monitored in order to validate its
    user experience.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们在行级别进行文本翻译。这个想法是，现实世界中的文本并不总是处于相同的上下文中（例如，同一张照片中的多个街道标志），甚至可能不在同一种语言中。这个设计决策在现实世界中的结果需要被密切监控，以验证其用户体验。
- en: Second, we only translate a line of text that `RecognitionService` is very confident
    about. The real world is messy, the user might upload photos containing text that's
    not relevant to the translation task (for example, street signs in a distance),
    or the user might upload photos not fit for quality text detection (for example,
    poor lighting and bad focus). We don't want to inundate the user with inaccurate
    translations, so our application took the approach to only translate high-quality
    text in the photos.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们只翻译`RecognitionService`非常有信心的文本行。现实世界是复杂的，用户可能会上传包含与翻译任务无关的文本的照片（例如，远处的街道标志），或者上传不适合进行高质量文本检测的照片（例如，光线较差或焦距不清晰的照片）。我们不希望给用户带来不准确的翻译，因此我们的应用程序采取了仅翻译照片中高质量文本的做法。
- en: These are examples of design decisions AI practitioners should evaluate and
    validate when developing an intelligence-enabled application. Having a flexible
    architecture allows you to move through the iterations much faster.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是AI从业人员在开发智能应用程序时应该评估和验证的设计决策示例。拥有灵活的架构可以让你更快地进行迭代。
- en: Setting up the project structure
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目结构
- en: 'Let''s create a similar base project structure with the steps outlined in [Chapter
    2](https://cdp.packtpub.com/hands_on_artificial_intelligence_on_amazon_web_services/wp-admin/post.php?post=298&action=edit#post_299),
    *Anatomy of a Modern AI Application*, including `pipenv`, `chalice`, and the web
    files:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个类似的基础项目结构，按照[第二章](https://cdp.packtpub.com/hands_on_artificial_intelligence_on_amazon_web_services/wp-admin/post.php?post=298&action=edit#post_299)中概述的步骤进行，*现代AI应用的结构*，包括`pipenv`、`chalice`和网页文件：
- en: 'In the terminal, we will create the `root` project directory and enter the
    following commands:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，我们将创建`root`项目目录并输入以下命令：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will create placeholders for the web frontend by creating a directory named
    `Website` and, within this directory, create two files `index.html` and `scripts.js`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过创建一个名为`Website`的目录来为网页前端创建占位符，并在该目录下创建两个文件`index.html`和`scripts.js`：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will create a Python 3 virtual environment with `pipenv` in the project''s
    `root` directory. Our Python portion of the project needs two packages, `boto3`
    and `chalice`. We can install them with the following commands:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在项目的 `root` 目录下使用 `pipenv` 创建一个 Python 3 虚拟环境。项目的 Python 部分需要两个包，`boto3`
    和 `chalice`。我们可以通过以下命令安装它们：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Remember that the Python packages installed via `pipenv` are only available
    if we activate the virtual environment. One way to do this is with the following
    command:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请记住，通过 `pipenv` 安装的 Python 包只有在激活虚拟环境时才能使用。激活虚拟环境的一种方法是使用以下命令：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, while still in the virtual environment, we will create the orchestration
    layer as an AWS `chalice` project named `Capabilities` with the following commands:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在仍处于虚拟环境中时，我们将创建一个名为 `Capabilities` 的 AWS `chalice` 项目，并使用以下命令：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To create the `chalicelib` Python package, issue the following commands:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建 `chalicelib` Python 包，请执行以下命令：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The project structure for Pictorial Translator should look like the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Pictorial Translator 项目的结构应如下所示：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is the project structure for Pictorial Translator. It contains the user
    interface, orchestration, and service implementation layers of the AI application
    architecture that we defined in [Chapter 2](https://cdp.packtpub.com/hands_on_artificial_intelligence_on_amazon_web_services/wp-admin/post.php?post=298&action=edit#post_299),
    *Anatomy of a Modern AI Application*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Pictorial Translator 项目的结构。它包含了我们在 [第二章](https://cdp.packtpub.com/hands_on_artificial_intelligence_on_amazon_web_services/wp-admin/post.php?post=298&action=edit#post_299)
    中定义的 AI 应用架构的用户界面、编排和服务实现层，*现代 AI 应用的结构*。
- en: Implementing services
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现服务
- en: Now that we know what we are building, let's implement this application layer
    by layer, starting with the service implementations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道要构建什么，让我们逐层实现这个应用程序，从服务实现开始。
- en: Recognition service – text detection
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别服务 – 文本检测
- en: 'We are going to leverage the Amazon Rekognition service to provide the capability
    to detect text in an image. Let''s first take a test drive of this capability
    using the AWS CLI. We will use a photo of a German street sign:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用 Amazon Rekognition 服务提供图像文本检测的功能。首先，让我们使用 AWS CLI 进行此功能的测试。我们将使用一张德国街道标志的照片：
- en: '![](img/cf161f5f-4879-4913-8785-0e7ec81542c0.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf161f5f-4879-4913-8785-0e7ec81542c0.png)'
- en: The source of the preceding photo is [https://www.freeimages.com/photo/german-one-way-street-sign-3-1446112](https://www.freeimages.com/photo/german-one-way-street-sign-3-1446112).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上述照片的来源是 [https://www.freeimages.com/photo/german-one-way-street-sign-3-1446112](https://www.freeimages.com/photo/german-one-way-street-sign-3-1446112)。
- en: 'Since we will be using S3 to hold the photos, let''s first upload this photo
    to an S3 bucket we created in [Chapter 1](606f673e-f72c-43ed-9a1e-fc06796b1303.xhtml),
    *Introduction to Artificial Intelligence on Amazon Web Services*. For instance,
    we will be uploading the image to our `contents.aws.ai` bucket. Once uploaded,
    to perform text detection on a photo with the name `german_street_sign.jpg` with
    the AWS CLI, issue the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用 S3 存储照片，首先让我们将这张照片上传到 [第一章](606f673e-f72c-43ed-9a1e-fc06796b1303.xhtml)
    中创建的 S3 桶中，*Amazon Web Services 上的人工智能简介*。例如，我们将图片上传到 `contents.aws.ai` 桶。一旦上传，要使用
    AWS CLI 对名为 `german_street_sign.jpg` 的照片执行文本检测，执行以下命令：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'AWS CLI is a handy tool for examining the output formats of AWS services:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CLI 是一个便捷的工具，用于检查 AWS 服务的输出格式：
- en: Here, we see a JSON output from the text detection, with portions of the output
    truncated here for brevity.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，我们看到了来自文本检测的 JSON 输出，部分输出在此为了简洁而被截断。
- en: At the top level, we have an object surrounded by curly brackets, **{** and
    **}**. Within this top level object, we have a name-value pair with the name being
    `TextDetections` and the value being an array surrounded by square brackets, **[**
    and **]**.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最顶层，我们有一个由花括号 **{** 和 **}** 包围的对象。在这个顶层对象中，我们有一个名称-值对，名称为 `TextDetections`，值是一个由方括号
    **[** 和 **]** 包围的数组。
- en: Within this array are zero or more objects describing the detected texts. Looking
    at the detected text objects within the array, we see information such as `DetectedText`,
    `Type`, `Id`, `Confidence`, and `Geometry`.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个数组中，有零个或多个描述检测到的文本的对象。查看数组中的检测文本对象时，我们可以看到诸如 `DetectedText`、`Type`、`Id`、`Confidence`
    和 `Geometry` 等信息。
- en: In our photo, we have only one word. However, Rekognition returned two objects
    in the `TextDetections` array. That's because Rekognition returns two types of
    `DetectedText` as objects, `LINE` of text as well as all the `WORD` objects in
    that `LINE` of text as separate objects. The two objects we got back represent
    the `LINE` as well as the single `WORD` in that line. Notice the types of the
    two objects are different, and the ParentId of the second object (`WORD`) refers
    to `Id` of the first object (`LINE`), showing the parent/child relationship between
    lines and words.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的照片中，只有一个单词。然而，Rekognition在`TextDetections`数组中返回了两个对象。这是因为Rekognition返回了两种类型的`DetectedText`对象，分别是文本的`LINE`（行）和该行中的所有`WORD`（单词）对象。我们返回的两个对象分别表示`LINE`和该行中的单个`WORD`。注意这两个对象的类型不同，第二个对象（`WORD`）的ParentId引用了第一个对象（`LINE`）的Id，显示了行与单词之间的父子关系。
- en: We also see the `Confidence` level of the text detection we will use this later
    to filter which lines of text to translate. Rekognition is very confident with
    the word `Einbahnstrabe`, which has a `Confidence` score of `99.16583251953125`,
    with 100 being the maximum.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到文本检测的`Confidence`级别，稍后我们将使用它来筛选哪些文本行需要翻译。Rekognition对单词`Einbahnstrabe`非常有信心，其`Confidence`得分为`99.16583251953125`，最高分为100。
- en: 'The `Geometry` name/value pair contains two systems to describe the location
    of the detected text in the image:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Geometry`名称/值对包含两个系统，用于描述检测到的文本在图像中的位置：'
- en: '![](img/2a286409-cbf0-4a81-9091-d4ad785900a6.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a286409-cbf0-4a81-9091-d4ad785900a6.png)'
- en: 'The previous diagrams explained the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表解释了以下内容：
- en: '`BoundingBox` describes a coarse rectangle where the text is located. This
    system describes the `BoundingBox` with the coordinates of the top-left point
    of the rectangle, and the width and the height of the rectangle.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BoundingBox`描述了一个粗略的矩形，表示文本所在的位置。该系统通过矩形左上角的坐标以及矩形的宽度和高度来描述`BoundingBox`。'
- en: These coordinates and measurements are all given in ratios for the image. For
    example, if the image is 700 x 200 pixels and the service returned left == 0.5
    and top == 0.25, then the top-left point of the rectangle is at pixels (350, 50);
    700 x 0.5 = 350 and 200 x 0.25 = 50.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些坐标和测量值都以图像的比例表示。例如，如果图像的尺寸是700 x 200像素，并且服务返回了left == 0.5和top == 0.25，那么矩形的左上角坐标为像素（350，50）；700
    x 0.5 = 350，200 x 0.25 = 50。
- en: '`Polygon` describes a set of points within the `BoundingBox` that gives a fine-grained
    polygon around the detected text. The *x* and y coordinates of each point are
    also using the same ratio system of the `BoundingBox` coordinates.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Polygon`描述了`BoundingBox`内的一组点，形成一个精细的多边形，围绕检测到的文本。每个点的*x*和y坐标也使用与`BoundingBox`坐标相同的比例系统。'
- en: The information provided in `Geometry` is useful for tasks such as highlighting
    the text in the image or even overlaying other information on top of the image.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Geometry`中提供的信息对于执行如在图像中突出显示文本或在图像上叠加其他信息等任务非常有用。'
- en: Rekognition text detection seems to work well with alphabet-based languages
    such as English, German, and French, but doesn't work as well with character-based
    languages such as Chinese, Korean, and Japanese. This definitely limits the use
    cases of the application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Rekognition文本检测在基于字母的语言（如英语、德语和法语）中表现良好，但在基于字符的语言（如中文、韩文和日文）中效果较差。这无疑限制了应用程序的使用场景。
- en: 'With these insights to the text detection output, let''s implement our `RecognitionService`.
    Let''s create a Python class named `RecognitionService` as shown in the following
    `recognition_service.py` file located in the `chalicelib` directory:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些对文本检测输出的洞察，让我们实现我们的`RecognitionService`。让我们创建一个名为`RecognitionService`的Python类，如以下位于`chalicelib`目录中的`recognition_service.py`文件所示：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, the following applies:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下内容适用：
- en: The constructor, `__init__()`, creates a `boto3` client for the Rekognition
    service. The constructor also takes in a parameter for `storage_location` as the
    S3 bucket name in our implementation.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数`__init__()`为Rekognition服务创建一个`boto3`客户端。构造函数还接受一个`storage_location`参数，作为我们实现中的S3桶名称。
- en: 'The `detect_text()` method calls the `boto3` Rekognition client''s `detect_text()`
    function and passes in the S3 bucket name and file key for the image. The `detect_text()`
    method then processes the output in the `TextDetections` array:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detect_text()`方法调用`boto3` Rekognition客户端的`detect_text()`函数，并传入S3桶名称和图像的文件键。然后，`detect_text()`方法处理`TextDetections`数组中的输出：'
- en: Here, we are only keeping the `LINE` detected text type and for each line we
    are storing the `DetectedText`, Confidence objects, and the `BoundingBox` coordinates.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，我们只保留了 `LINE` 检测到的文本类型，对于每一行，我们存储 `DetectedText`、Confidence 对象以及 `BoundingBox`
    坐标。
- en: Any client using the `detect_text()` method of the RecognitionService's will
    expect these pieces of information to be returned as a Python list with dictionaries
    (a key-value mapping) as `text`, `confidence`, and `boundingBox`.
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何使用 `detect_text()` 方法的 `RecognitionService` 客户端都将期望返回这些信息，作为一个包含字典（键值对映射）的
    Python 列表，其中包含 `text`、`confidence` 和 `boundingBox`。
- en: Here, we adapted the AWS SDK input and output formats to our own `RecognitionService`
    interface contract. The rest of our application will expect the method parameters
    and return type of our `RecognitionService`. We essentially implemented the adapter
    design pattern. Even if we swap the AWS Rekognition service for a different one,
    as long as we adapt the new service to our interface contract, our application
    can interact with the new service without further modifications.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 AWS SDK 的输入和输出格式适配为我们自己的 `RecognitionService` 接口契约。我们应用程序的其余部分将期望我们的
    `RecognitionService` 方法参数和返回类型。我们本质上实现了适配器设计模式。即使我们将 AWS Rekognition 服务替换为其他服务，只要我们将新服务适配到我们的接口契约，我们的应用程序仍然可以与新服务交互，无需进一步修改。
- en: 'There are two ways to specify the image for text detection:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式可以指定用于文本检测的图像：
- en: One way is to provide an `S3Object` with the bucket name and object key.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种方式是提供带有存储桶名称和对象键的 `S3Object`。
- en: The other way is to provide the raw bits of the image.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种方式是提供图像的原始位数据。
- en: For our application, the `S3Object` way works better.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，`S3Object` 方式效果更好。
- en: Translation service – translating text
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 翻译服务 – 翻译文本
- en: 'We are going to leverage the Amazon Translate service to provide the language
    translation capability. Again, let''s take a test drive with this capability using
    the AWS CLI first. To perform a quick translation, let''s copy the detected text
    from the previous section, `Einbahnstrabe` and issue the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用 Amazon Translate 服务提供语言翻译功能。再一次，让我们先通过 AWS CLI 进行一次测试体验。为了快速翻译，让我们复制上一节中检测到的文本
    `Einbahnstrabe`，并执行以下命令：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We used `auto` as the source language; this tells Amazon Translate to automatically
    determine the language of the text. For the target language, we selected `en`
    for English.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `auto` 作为源语言，这意味着 Amazon Translate 会自动检测文本的语言。对于目标语言，我们选择了 `en` 表示英语。
- en: The output of the Amazon Translate service is quite simple, it's just a JSON
    object with three name/value pairs. As we can see, Amazon Translate correctly
    determined `Einbahnstrabe` is a German word and its English translation is One
    way. This must be a photo of a `One Way` traffic sign.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon Translate 服务的输出非常简单，它只是一个包含三个名称/值对的 JSON 对象。如我们所见，Amazon Translate 正确地判断出
    `Einbahnstrabe` 是一个德语单词，它的英文翻译是 One way。这一定是一个 `One Way` 交通标志的照片。
- en: The `auto` value for the source language is handy. However, there are situations
    where the source language cannot be determined with a high level of confidence.
    In those situations, AWS will throw a `DetectedLanguageLowConfidenceException`.
    This exception will contain the most likely source language. If your application
    can tolerate this low confidence, you can issue the translation request again
    with the source language specified in the exception.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于源语言，`auto` 值非常方便。然而，存在一些情况，源语言无法以很高的置信度被确定。在这种情况下，AWS 会抛出 `DetectedLanguageLowConfidenceException`
    异常。这个异常会包含最可能的源语言。如果您的应用程序可以容忍这种低置信度，您可以再次发起翻译请求，并在异常中指定源语言。
- en: Amazon Translate supports translation between numerous languages, and the list
    is growing. However, at the time of writing this book, there are still language
    pairs that are not supported. Check the AWS document on supported language pairs
    ([https://docs.aws.amazon.com/translate/latest/dg/pairs.html](https://docs.aws.amazon.com/translate/latest/dg/pairs.html))
    for the latest. If a request is issued to translate a language pair that's not
    supported, the AWS will throw an `UnsupportedLanguagePairException`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon Translate 支持多种语言之间的翻译，并且语言对的数量还在不断增加。然而，在撰写本书时，仍然存在一些不支持的语言对。请查看 AWS
    文档中支持的语言对列表（[https://docs.aws.amazon.com/translate/latest/dg/pairs.html](https://docs.aws.amazon.com/translate/latest/dg/pairs.html)）以获取最新信息。如果发出翻译一个不受支持的语言对的请求，AWS
    将抛出 `UnsupportedLanguagePairException` 异常。
- en: 'Let''s create a Python class named `TranslationService` as shown in the following,
    `translation_service.py` file located in the `chalicelib` directory:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`TranslationService`的Python类，如下所示，文件位于`chalicelib`目录中的`translation_service.py`文件中：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code, the following applies:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下内容适用：
- en: The constructor, `__init__()`, creates a `boto3` client or is being sent to
    the Translate service.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数`__init__()`创建一个`boto3`客户端，或者被发送到翻译服务。
- en: The `translate_text()` method calls the `boto3` Translate client's `translate_text()`
    function and passes in the text, source language, and target language. This method's
    `source_language` and `target_language` parameters have default values of `auto`
    and `en`, respectively.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`translate_text()`方法调用`boto3`翻译客户端的`translate_text()`函数，并传入文本、源语言和目标语言。此方法的`source_language`和`target_language`参数默认值分别为`auto`和`en`。'
- en: The `translate_text()` function then processes the output from the AWS SDK and
    returns as a Python dictionary with the `translatedText`, `sourceLanguage`, and
    `targetLanguage` keys. Once again, we adapted the AWS SDK input and output formats
    to our own *X* interface contract.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`translate_text()`函数随后处理来自AWS SDK的输出，并将其返回为一个包含`translatedText`、`sourceLanguage`和`targetLanguage`键的Python字典。我们再次调整了AWS
    SDK的输入输出格式，以适应我们自己的*X*接口契约。'
- en: 'Amazon Translate service supports the concept of custom terminology. This feature
    allows developers to set up custom terminology to use during translation. This
    is useful for use cases where words and phrases in the source text are not part
    of the standard language such as company names, brands, and products. For example,
    "Packt" does not get translated correctly. To correct the translation, we can
    create a custom terminology in our AWS account by uploading a **Comma-Separated
    Values** (**CSV**) file with a mapping of "Packt" and to how it should be translated
    in various languages, as shown in the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊翻译服务支持自定义术语的概念。此功能允许开发人员在翻译过程中设置自定义术语。这对于源文本中包含非标准语言的单词和短语的使用场景非常有用，比如公司名称、品牌和产品。例如，“Packt”不会被正确翻译。为纠正翻译，我们可以通过上传一个**逗号分隔值**（**CSV**）文件，在AWS账户中创建一个自定义术语映射，将“Packt”映射为在不同语言中的正确翻译，具体如下所示：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: During translation, we can specify one or more of these custom terminologies
    with the TerminologyNames parameter. See the AWS documentation, [https://docs.aws.amazon.com/translate/latest/dg/how-custom-terminology.html](https://docs.aws.amazon.com/translate/latest/dg/how-custom-terminology.html),
    [for more details.](https://docs.aws.amazon.com/translate/latest/dg/how-custom-terminology.html)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在翻译过程中，我们可以使用TerminologyNames参数指定一个或多个自定义术语。请参阅AWS文档，[https://docs.aws.amazon.com/translate/latest/dg/how-custom-terminology.html](https://docs.aws.amazon.com/translate/latest/dg/how-custom-terminology.html)，[了解更多详情。](https://docs.aws.amazon.com/translate/latest/dg/how-custom-terminology.html)
- en: Storage service – uploading files
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储服务 – 上传文件
- en: 'Let''s create a Python class named `StorageService` as shown in the following,
    in the `storage_service.py` file located in the `chalicelib` directory:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`StorageService`的Python类，如下所示，文件位于`chalicelib`目录中的`storage_service.py`文件中：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding code, the following applies:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下内容适用：
- en: The constructor, `__init__()`, creates a `boto3` client or is being sent to
    the S3 service. The constructor also takes in a parameter for `storage_location`
    as the S3 bucket name in our implementation.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数`__init__()`创建一个`boto3`客户端，或者被发送到S3服务。构造函数还接收一个`storage_location`参数，作为我们实现中的S3桶名称。
- en: The `get_storage_location()` method returns the S3 bucket name as the `storage_location`.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_storage_location()`方法返回S3桶的名称作为`storage_location`。'
- en: The `upload_file()` method takes in the raw bytes of the file to be uploaded
    and the filename. This method then calls the `boto3` S3 client's `put_object()`
    function and passes in the bucket name, the raw bytes, key, and **Access Control
    List** (**ACL**) parameter.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upload_file()`方法接收待上传文件的原始字节和文件名。该方法随后调用`boto3` S3客户端的`put_object()`函数，传入桶名称、原始字节、密钥和**访问控制列表**（**ACL**）参数。'
- en: The first three parameters of `upload_file()` are self-explanatory. The ACL
    parameter specifies that the file will be publicly readable after it has been
    uploaded to the S3 bucket. Since the S3 bucket can serve static assets such as
    images and files, we will use S3 to serve the image in our web user interface.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upload_file()`的前三个参数不言自明。ACL参数指定文件上传到S3桶后将是公开可读的。由于S3桶可以提供静态资源，例如图像和文件，因此我们将使用S3在Web用户界面中提供该图像。'
- en: Our `upload_file()` method then returns the filename along with a URL to the
    uploaded file in S3\. Since the ACL is set to `public-read`, anyone with this
    URL can see this file on the internet.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的`upload_file()`方法返回文件名以及上传到S3的文件的URL。由于ACL设置为`public-read`，任何拥有该URL的人都可以在互联网上查看此文件。
- en: This class and its first two methods are exactly the same as `StorageService`
    we implemented in [Chapter 2](https://cdp.packtpub.com/hands_on_artificial_intelligence_on_amazon_web_services/wp-admin/post.php?post=298&action=edit#post_299),
    *Anatomy of a Modern AI Application*. We are duplicating them here to make each
    hands-on project self-contained, but we are essentially just adding the `upload_file()`
    method to the [Chapter 2](https://cdp.packtpub.com/hands_on_artificial_intelligence_on_amazon_web_services/wp-admin/post.php?post=298&action=edit#post_299),
    *Anatomy of a Modern AI Application*, `StorageService` implementation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类及其前两个方法与我们在[第2章](https://cdp.packtpub.com/hands_on_artificial_intelligence_on_amazon_web_services/wp-admin/post.php?post=298&action=edit#post_299)《现代AI应用程序解剖》中实现的`StorageService`完全相同。我们在这里复制它们，是为了让每个动手项目都能独立运行，但本质上，我们只是向[第2章](https://cdp.packtpub.com/hands_on_artificial_intelligence_on_amazon_web_services/wp-admin/post.php?post=298&action=edit#post_299)《现代AI应用程序解剖》的`StorageService`实现中添加了`upload_file()`方法。
- en: A recommendation on unit testing
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于单元测试的建议
- en: 'Even though unit testing is beyond the scope of this book, we want to make
    a strong recommendation that you make writing unit tests a habit when developing
    applications that are intelligence-enabled or otherwise. Unit tests should be
    written for every layer of the application. Unit tests should be run often to
    execute functionalities and to catch bugs. Testing the application layer by layer
    will reduce the debugging time and effort by limiting the search space for the
    bugs. We wrote unit tests throughout the development of all hands-on projects
    in this book. As an example, the following is a unit test we wrote for `TranslationService`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管单元测试超出了本书的范围，我们还是强烈建议，在开发智能化或其他类型的应用程序时，将编写单元测试作为一种习惯。每一层的应用程序都应该编写单元测试。单元测试应该经常运行，以执行功能并捕捉错误。逐层测试应用程序将通过缩小错误的搜索范围来减少调试的时间和精力。在本书的所有动手项目的开发过程中，我们编写了单元测试。作为示例，以下是我们为`TranslationService`编写的单元测试：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is a simple unit test, but it allowed us to ensure the text translation
    is working before moving to the next layer. If something doesn't work in the application,
    we have some assurance that it is not caused by this service implementation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的单元测试，但它确保了文本翻译在进入下一层之前能够正常工作。如果应用程序中的某些功能不正常，我们有理由相信，这不是由该服务实现引起的。
- en: Implementing RESTful endpoints
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现RESTful端点
- en: Now that the services are implemented, let's move to the orchestration layer
    with the RESTful endpoints.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务已经实现，让我们进入编排层，使用RESTful端点。
- en: 'Replace the contents of `app.py` in the `Chalice` project with the following
    code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换`Chalice`项目中的`app.py`文件内容：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code, the following applies:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下内容适用：
- en: The first four lines of code handle the imports for `chalice` as well as our
    three services.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前四行代码处理了`chalice`以及我们三个服务的导入。
- en: The next two lines of code declare the `chalice` app with the name `Capabilities`,
    and turn on the debug flag. The `debug` flag tells chalice to output more useful
    information, which is helpful during development. You can turn this flag to `False`
    when deploying the application to production.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的两行代码声明了名称为`Capabilities`的`chalice`应用，并开启了调试标志。`debug`标志告诉chalice输出更多有用的信息，这在开发过程中很有帮助。当将应用程序部署到生产环境时，你可以将此标志设置为`False`。
- en: The next four lines of code define the `storage_location` parameter as our S3
    bucket, and then instantiate our storage, recognition, and translation services.
    The `storage_location` parameter should be replaced with your S3 bucket name.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的四行代码定义了`storage_location`参数，指定为我们的S3桶，然后实例化我们的存储、识别和翻译服务。`storage_location`参数应替换为你的S3桶名称。
- en: 'Keep in mind that the `storage_location` parameter is more generic than an
    S3 bucket name. This parameter for both `StorageService` and `RecognitionService`
    can represent storage locations other than S3 buckets, for example, the NFS path
    or resource URI depending on the service implementation. This allows `StorageService`
    and `RecognitionService` to change the underlying storage technologies. However,
    in this design, `StorageService` and `RecognitionService` are coupled to use the
    same storage technology. There is an inherent assumption that `RecognitionService`
    can access the file uploaded through `StorageService` when performing the text
    detection task. We could have designed `StorageService` to return the raw bytes
    of the image and then pass it to the `RecognitionService`. This design would remove
    the same storage technology restriction, but it adds complexity and performance
    overhead. There are always trade-offs when it comes to design: you as an AI practitioner
    have to make the decisions on the trade-offs for your specific applications.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`storage_location` 参数比 S3 存储桶名称更具通用性。对于 `StorageService` 和 `RecognitionService`，该参数可以表示除
    S3 存储桶之外的其他存储位置，例如 NFS 路径或资源 URI，具体取决于服务实现。这使得 `StorageService` 和 `RecognitionService`
    可以更换底层的存储技术。然而，在此设计中，`StorageService` 和 `RecognitionService` 被耦合使用相同的存储技术。假设 `RecognitionService`
    在执行文本检测任务时可以访问通过 `StorageService` 上传的文件。我们本可以设计 `StorageService` 返回图像的原始字节，然后将其传递给
    `RecognitionService`。这种设计可以移除相同存储技术的限制，但它增加了复杂性和性能开销。设计时总是有取舍：作为 AI 从业者，你必须为你的具体应用做出取舍决策。
- en: Translate the image text endpoint
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 翻译图像文本端点
- en: 'We will start with the translate image text endpoint. The following code will
    continue with the Python code of `app.py`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从翻译图像文本端点开始。以下代码将继续 `app.py` 中的 Python 代码：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding code, the following applies:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下内容适用：
- en: The `translate_image_text()` function implements the `RESTful` endpoint.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`translate_image_text()` 函数实现了 `RESTful` 端点。'
- en: The annotation right above this function describes the HTTP request that can
    access this endpoint.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在该函数上方的注释描述了可以访问此端点的 HTTP 请求。
- en: In the `translate_image_text()` function, we first get the request data that
    contains the source language, `fromLang`, and target language, `toLang`, for the
    translation.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `translate_image_text()` 函数中，我们首先获取包含源语言 `fromLang` 和目标语言 `toLang` 的请求数据，以进行翻译。
- en: Next, we call `RecognitionService` to detect text in the image and store the
    detected lines of text in `text_lines`.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们调用 `RecognitionService` 来检测图像中的文本，并将检测到的文本行存储在 `text_lines` 中。
- en: Then, for each line of text in `text_lines`, we check the confidence level of
    the detection. If the confidence level is above `MIN_CONFIDENCE`, which is set
    to `80.0`, then we perform the translation on that line of text.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，对于 `text_lines` 中的每一行文本，我们检查检测的置信度。如果置信度高于 `MIN_CONFIDENCE`（设置为 `80.0`），我们就会对该文本行进行翻译。
- en: We then return the `text`, `translation`, and `boundingBox` to the caller as
    JSON (chalice automatically formats the contents in `translated_line` to JSON).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将 `text`、`translation` 和 `boundingBox` 作为 JSON 返回给调用者（chalice 会自动将 `translated_line`
    中的内容格式化为 JSON）。
- en: 'The following is an HTTP request to this RESTful endpoint. The `/images` path
    is treated as a collection resource in the RESTful convention, and `image_id`
    specifies a specific image within this collection:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个针对该 RESTful 端点的 HTTP 请求。按照 RESTful 约定，`/images` 路径被视为集合资源，而 `image_id`
    指定了该集合中的某个特定图像：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To perform an action on the specific image specified by the `/images/{image_id}`
    URL, we use a `POST` HTTP request to a custom `translate-text` action. We have
    additional parameters as the JSON payload in the request body, `fromLang` and
    `toLang`, to specify the language codes of the translation. To read this RESTful
    HTTP request, we are performing `translate-text` action for an image in the `images`
    collection on `<server url>` with the specified `image_id`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对 `/images/{image_id}` URL 中指定的特定图像执行操作，我们使用 `POST` HTTP 请求发起一个自定义的 `translate-text`
    操作。请求体中作为 JSON 载荷的额外参数 `fromLang` 和 `toLang` 用来指定翻译的语言代码。为了读取这个 RESTful HTTP 请求，我们在
    `<server url>` 上为 `images` 集合中的图像执行 `translate-text` 操作，并指定了 `image_id`。
- en: 'Let''s test this endpoint out by running `chalice local` in the Python virtual
    environment as shown in the following, and then issue the following `curl` command
    and specify an image that has already been uploaded to our S3 bucket:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在 Python 虚拟环境中运行 `chalice local` 来测试此端点，如下所示，然后发出以下 `curl` 命令，并指定一个已经上传到我们
    S3 存储桶中的图像：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is the JSON that our web user interface will receive and use to display
    the translations to the user.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的 Web 用户界面将接收的 JSON，并用于向用户显示翻译结果。
- en: Upload the image endpoint
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传图像端点
- en: We are going to allow the clients of this endpoint to upload images using Base64
    encoding. With Base64 encoding, we can translate binary data, such as image and
    audio, into ASCII string format and back. This method allows our application to
    upload images using the JSON payload in the HTTP request. Don't worry, you don't
    need to be familiar with Base64 to continue with the project implementation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将允许此端点的客户端使用 Base64 编码上传图像。通过 Base64 编码，我们可以将二进制数据（如图像和音频）转换为 ASCII 字符串格式，并进行反向转换。这种方法允许我们的应用程序使用
    HTTP 请求中的 JSON 负载上传图像。别担心，你不需要了解 Base64 就能继续进行项目实现。
- en: 'Let''s have a look at the code of our endpoint function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下端点函数的代码：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding code, the following applies:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，以下内容适用：
- en: The `upload_image()` function implements the RESTful endpoint. The annotation
    right above it describes the HTTP request that can access this endpoint.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upload_image()` 函数实现了 RESTful 端点。它上面的注解描述了可以访问此端点的 HTTP 请求。'
- en: In the `upload_image()` function, we use Base64 to decode the uploaded file
    in the JSON payload in the HTTP request and then upload it through our `StorageService`.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `upload_image()` 函数中，我们使用 Base64 解码 HTTP 请求中的 JSON 负载中的上传文件，然后通过我们的 `StorageService`
    进行上传。
- en: In this function, we return to the caller the output of `StorageService.upload_file()`
    in JSON format.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个函数中，我们将 `StorageService.upload_file()` 的输出以 JSON 格式返回给调用者。
- en: 'The following is an HTTP request to this RESTful endpoint. Again, as shown
    in the following code block, `/images` is treated as a collection resource in
    the RESTful convention:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对该 RESTful 端点的 HTTP 请求。再次如下面的代码块所示，`/images` 在 RESTful 规范中被视为一个集合资源：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To create a new resource within the collection, the RESTful convention uses
    the `POST` method to the `/images` collection resource.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要在该集合中创建一个新资源，RESTful 规范使用 `POST` 方法向 `/images` 集合资源发送请求。
- en: 'With `chalice local` running, issue the following `curl` command to test the
    upload endpoint. We are using the `echo` command to send the JSON payload, including
    the Base64 encoding, to our endpoint. The file specified in the command must be
    on your local filesystem:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `chalice local` 运行时，使用以下 `curl` 命令来测试上传端点。我们通过 `echo` 命令将包括 Base64 编码的 JSON
    负载发送到我们的端点。命令中指定的文件必须位于本地文件系统中：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding code, the following applies:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，以下内容适用：
- en: This is the JSON that our web user interface will receive. We get a `fileId`
    back; this ID can be used to specify the upload image in the `/images` collection
    resource.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是我们的 Web 用户界面将接收到的 JSON。我们会收到一个 `fileId`；此 ID 可以用来指定 `/images` 集合资源中的上传图像。
- en: We also get a `fileUrl`, and the current `StorageService` implementation returns
    the S3 URL to the file, but this `fileUrl` is generic and not tied to any particular
    service.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还会得到一个 `fileUrl`，当前的 `StorageService` 实现返回文件的 S3 URL，但这个 `fileUrl` 是通用的，并未绑定到特定的服务。
- en: We will use this `fileUrl` to display the image in the web user interface.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用这个 `fileUrl` 在 Web 用户界面中显示图像。
- en: At this point, you can go to your S3 bucket and see whether the file has been
    uploaded successfully.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可以去 S3 存储桶查看文件是否已经成功上传。
- en: Implementing the web user interface
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 Web 用户界面
- en: Next, let's create a simple web user interface with HTML and JavaScript in the
    `index.html` and `script.js` files in the `Website` directory.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在 `Website` 目录中的 `index.html` 和 `script.js` 文件里创建一个简单的 Web 用户界面，使用 HTML
    和 JavaScript。
- en: 'This is what the final web interface looks like:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是最终的 Web 界面样式：
- en: '![](img/b67dafa3-4a37-448f-91dc-b0869f64d972.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b67dafa3-4a37-448f-91dc-b0869f64d972.png)'
- en: index.html
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: index.html
- en: 'Let''s create the web user interface with the `index.html` file, as shown in
    the following code block:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 Web 用户界面，使用 `index.html` 文件，如下面的代码块所示：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We are using standard HTML tags here, so the code of the web page should be
    easy to follow. Here are a few things to point out:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了标准的 HTML 标签，因此网页代码应该很容易理解。这里有一些要点：
- en: We are using two `<input>` tags for the file chooser and the upload button.
    Typically, `<input>` tags are used inside HTML forms, but instead, we are running
    a JavaScript function, `uploadAndTranslate()`, when the upload button is clicked.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了两个 `<input>` 标签，一个用于选择文件，另一个用于上传按钮。通常，`<input>` 标签用于 HTML 表单中，但我们在这里使用
    JavaScript 函数 `uploadAndTranslate()`，当点击上传按钮时触发。
- en: The `<img>` tag, with the `image` ID, will be used to display the uploaded image.
    This ID will be used by JavaScript to add the image dynamically.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有`image` ID的`<img>`标签将用于显示上传的图像。JavaScript将使用此ID动态添加图像。
- en: The `<div>` tag, with the `translations` ID, will be used to display lines of
    detected text and their translations. This `id` will also be used by JavaScript
    to add the text and translation dynamically.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有`translations` ID的`<div>`标签将用于显示检测到的文本行及其翻译。JavaScript将使用此`id`动态添加文本和翻译。
- en: scripts.js
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: scripts.js
- en: 'Let''s create `scripts.js` as shown in the following. The JavaScript function
    is interacting with the endpoints and stitching together the overall user experience
    of the Pictorial Translator. Let''s have a look at the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下示例创建`scripts.js`。JavaScript函数与端点进行交互，构建了Pictorial Translator的整体用户体验。让我们看一下以下代码：
- en: First, define `serverUrl` as the address of `chalice local`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将`serverUrl`定义为`chalice local`的地址。
- en: We will also define a new `HttpError` to handle the exceptions that might occur
    during the HTTP requests.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将定义一个新的`HttpError`来处理在HTTP请求过程中可能发生的异常。
- en: 'Add this JavaScript class at the end of the `scripts.js` file:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此JavaScript类添加到`scripts.js`文件的末尾：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we will define four functions in `scripts.js`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在`scripts.js`中定义四个函数：
- en: '`uploadImage()`: This uploads the image via Base64 encoding to our `UploadImage()`
    endpoint.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uploadImage()`：该函数通过Base64编码上传图像到我们的`UploadImage()`端点。'
- en: '`updateImage()`: This updates the user interface to display the uploaded image
    using the S3 URL.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateImage()`：该函数更新用户界面，使用S3 URL显示上传的图像。'
- en: '`translateImage()`: This calls the translate image text endpoint to translate
    the text detected in the image.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`translateImage()`：该函数调用翻译图片文本的端点，将图像中检测到的文本进行翻译。'
- en: '`updateTranslations()`: This updates the user interface to display the translated
    texts.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateTranslations()`：该函数更新用户界面，显示翻译后的文本。'
- en: These are sequential steps of the user experience. We broke them into individual
    functions to make the JavaScript code more modular and readable. Each function
    performs a specific task.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是用户体验的顺序步骤。我们将它们拆分为单独的函数，以使JavaScript代码更加模块化和易于阅读。每个函数执行特定任务。
- en: 'Let''s have a look at the `uploadImage()` function, as shown in the following
    code block:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`uploadImage()`函数，如下代码块所示：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding code, the following applies:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下内容适用：
- en: The `uploadImage()` function is creating a Base64-encoded string from the file
    input field in `index.html`.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uploadImage()`函数正在从`index.html`中的文件输入字段创建一个Base64编码的字符串。'
- en: This function is declared as async because we need to wait for the file to be
    read and encoded.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个函数被声明为异步函数，因为我们需要等待文件被读取并编码。
- en: This function creates a JavaScript `Promise` function that uses a `FileReader`
    to read the file, and then converts the file content as Base64 with the `readAsDataURL()`
    function.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个函数创建了一个JavaScript `Promise`函数，使用`FileReader`来读取文件，然后通过`readAsDataURL()`函数将文件内容转换为Base64。
- en: This function clears the file input field after each upload, so the user can
    more easily upload another image.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个函数在每次上传后清空文件输入字段，以便用户可以更轻松地上传另一张图片。
- en: This function then sends the POST HTTP request with the JSON payload to our
    Upload Image Endpoint URL and returns `response.json`.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个函数然后发送带有JSON负载的POST HTTP请求到我们的上传图片端点URL，并返回`response.json`。
- en: 'Let''s have a look at the `updateImage()` function, as shown in the following
    code block:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`updateImage()`函数，如下代码块所示：
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding code, the following applies:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下内容适用：
- en: The `updateImage()` function makes the `<div>` tag with the `view` ID visible
    to display the image.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateImage()`函数使得具有`view` ID的`<div>`标签可见，以显示图片。'
- en: This function finds the `<img>` tag with the `image` ID and sets the `src` attribute
    to the URL of the image file stored in S3.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个函数查找具有`image` ID的`<img>`标签，并将`src`属性设置为存储在S3中的图像文件的URL。
- en: The `<img>` tag's `alt` attribute is set to the filename in case the image cannot
    be loaded for some reason.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<img>`标签的`alt`属性设置为文件名，以防图像因某些原因无法加载。'
- en: The `alt` attribute makes web pages more accessible for more users, including
    the visually impaired. For more information on web page accessibility, search
    for `508 compliance`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`alt`属性使网页对更多用户更具可访问性，包括视力障碍者。有关网页可访问性的更多信息，请搜索`508合规性`。'
- en: 'Lets, have a look at the `translateImage()` function, as shown in the following
    code block:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`translateImage()`函数，如下代码块所示：
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding code, the following applies:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下内容适用：
- en: The `translateImage()` function sends the HTTP POST request, along with the
    JSON body, to our **Translate Image Text Endpoint** URL.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`translateImage()` 函数向我们的 **Translate Image Text Endpoint** URL 发送 HTTP POST
    请求，并附带 JSON 请求体。'
- en: The function then returns the response JSON with the translation texts.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，函数返回包含翻译文本的响应 JSON。
- en: 'Let''s have a look at the `annotateImage()` function, as shown in the following
    code block:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 `annotateImage()` 函数，如下所示的代码块：
- en: '[PRE26]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding code, the following applies:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，以下内容适用：
- en: The `updateTranslations()` function finds the `<div>` tag with the `translations`
    ID and removes any existing translations from the previous image.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateTranslations()` 函数找到 `translations` ID 的 `<div>` 标签，并删除先前图像中的任何现有翻译。'
- en: Then, it adds to the `<div>` tag for each line of text, a new `<h6>` tag to
    display the detected text as well as its translation.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，为每一行文本的 `<div>` 标签添加一个新的 `<h6>` 标签，用于显示检测到的文本及其翻译。
- en: 'All four functions are stitched together by the following `uploadAndTranslate()`
    function:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个函数通过以下的 `uploadAndTranslate()` 函数组合在一起：
- en: '[PRE27]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Notice how clear the sequence of events are in the `uploadAndTranslate()` function:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意观察 `uploadAndTranslate()` 函数中事件的执行顺序：
- en: If the `updateImage()` function is successful, then run `updateImage()` with
    the image information.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `updateImage()` 函数成功，则使用图像信息运行 `updateImage()`。
- en: Then, run the `translateImage()` function with the image information. If the
    `translateImage()` function is successful, then run `updateTranslations()`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用图像信息运行 `translateImage()` 函数。如果 `translateImage()` 函数成功，则运行 `updateTranslations()`。
- en: Catch any errors in this chain and display it in a pop-up modal.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获链中的任何错误并在弹出框中显示。
- en: 'The final project structure for the Pictorial Translator application should
    be as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Pictorial Translator 应用程序的最终项目结构应如下所示：
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, we have completed the implementation of the Pictorial Translator application.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了 Pictorial Translator 应用程序的实现。
- en: Deploying Pictorial Translator to AWS
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Pictorial Translator 部署到 AWS
- en: 'The deployment steps for the Pictorial Translator application are the same
    as the deployment steps of the Rekognition demonstration in [Chapter 2](042787e6-6f54-4728-8354-e22d87be0460.xhtml),
    *Anatomy of a Modern AI Application*; we have included the steps here for completion:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Pictorial Translator 应用程序的部署步骤与 [第 2 章](042787e6-6f54-4728-8354-e22d87be0460.xhtml)
    中 Rekognition 演示的部署步骤相同，*现代 AI 应用程序的结构*；我们已经在此处包含了这些步骤以供完成：
- en: 'First, let''s tell `chalice` to perform policy analysis for us by setting `autogen_policy`
    to `false` in the `config.json` file in the `.chalice` directory of the project
    structure:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们告诉 `chalice` 执行策略分析，通过在项目结构的 `.chalice` 目录中的 `config.json` 文件中将 `autogen_policy`
    设置为 `false`：
- en: '[PRE29]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we create a new `policy-dev.json` file in the `.chalice` directory to
    manually specify the AWS services the project needs:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在 `.chalice` 目录中创建一个新的 `policy-dev.json` 文件，手动指定项目所需的 AWS 服务：
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we deploy the `chalice` backend to AWS by running the following command
    within the `Capabilities` directory:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们通过在 `Capabilities` 目录下运行以下命令，将 `chalice` 后端部署到 AWS：
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When the deployment is complete, `chalice` will output a RESTful API URL that
    looks similar to `https://<UID>.execute-api.us-east-1.amazonaws.com/api/`, where
    the `<UID>` tag is a unique identifier string. This is the server URL your frontend
    app should hit to access the application backend running on AWS.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 部署完成后，`chalice` 将输出一个类似 `https://<UID>.execute-api.us-east-1.amazonaws.com/api/`
    的 RESTful API URL，其中 `<UID>` 标签是一个唯一标识符字符串。这是前端应用程序应访问的服务器 URL，以便连接运行在 AWS 上的应用程序后端。
- en: 'Next, we will upload the `index.html` and `scripts.js` files to this S3 bucket,
    and then set the permissions to publicly readable. Before we do that, we need
    to make a change in `scripts.js`, as shown in the following. Remember, the website
    will be running in the cloud now, and won''t have access to our local HTTP server.
    Replace the local server URL with the one from our backend deployment:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将把 `index.html` 和 `scripts.js` 文件上传到这个 S3 存储桶，并将权限设置为公开可读。在此之前，我们需要在 `scripts.js`
    中进行以下更改。记住，网站现在将在云端运行，无法访问我们的本地 HTTP 服务器。将本地服务器的 URL 替换为来自后端部署的 URL：
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now the Pictorial Translator application is accessible for everyone on the internet
    to make our world smaller!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Pictorial Translator 应用程序已经可以让互联网中的所有人访问，缩小了我们的世界！
- en: Discussing project enhancement ideas
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论项目增强的想法
- en: 'At the end of each hands-on project in Part 2, we provide you with a few ideas
    to extend the intelligence-enabled application. Here are a couple of ideas to
    enhance the Pictorial Translator:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分的每个动手项目结束时，我们提供了一些扩展智能应用的想法。以下是几个增强“图像翻译器”的想法：
- en: Add voice read back for both original and translated texts. Voice read back
    for the original text will help users learn a foreign language. Voice read back
    of the translated text will help visually impaired users. AWS provides voice-generation
    capabilities with the Amazon Polly service.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为原文和翻译后的文本添加语音朗读功能。对原文进行语音朗读有助于用户学习外语；对翻译文本进行语音朗读可以帮助视障用户。AWS提供了通过Amazon Polly服务生成语音的能力。
- en: Create a native mobile app for better user experience. For example, a continuous
    camera scan for real-time pictorial translation. The mobile app can leverage the
    same two endpoints we created. The mobile app is just another frontend to the
    Pictorial Translator application.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个原生移动应用以提供更好的用户体验。例如，提供连续的相机扫描以实现实时的图像翻译。移动应用可以利用我们创建的相同两个端点。这个移动应用只是“图像翻译器”应用程序的另一个前端。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we built a Pictorial Translator application to translate texts
    appearing in pictures. We leveraged Amazon Rekognition to first detect lines of
    text in pictures and then leveraged Amazon Translate to translate the detected
    texts. This is our first intelligence-enabled solution that solves a real-world
    problem. Building these solutions through hands-on projects helps to build your
    intuition for solving problems with AI capabilities. Along the way, we also discussed
    solution design decisions and trade-offs that must be validated against the real-world
    usages of our application. From an architectural perspective, not only did we
    build a working application, we architected it in a way that allows for reusable
    components that we can leverage in future hands-on projects.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们构建了一个“图像翻译器”应用，用于翻译出现在图片中的文本。我们利用Amazon Rekognition首先检测图片中的文本行，然后利用Amazon
    Translate进行翻译。这是我们第一个智能应用解决方案，它解决了一个实际问题。通过动手项目构建这些解决方案有助于培养你用AI能力解决问题的直觉。在这个过程中，我们还讨论了必须根据应用的实际使用情况进行验证的解决方案设计决策和权衡。从架构的角度来看，我们不仅构建了一个可运行的应用，还以一种允许未来复用的方式构建了它，可以在以后的动手项目中加以利用。
- en: In the next chapter, we will build more intelligence-enabled applications using
    additional AWS AI services. As we gain more experience building hands-on projects,
    pay close attention to the reusable opportunities created by our architecture
    design decisions.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用更多的AWS AI服务构建更多的智能应用。在积累了更多动手项目的经验之后，要特别注意我们架构设计决策所创造的复用机会。
- en: Further reading
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information on detecting and translating text with Amazon Rekognition
    and Amazon Translate, please refer to the following links:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多有关使用Amazon Rekognition和Amazon Translate检测和翻译文本的信息，请参考以下链接：
- en: '[https://www.androidauthority.com/google-lens-augmented-reality-785836/](https://www.androidauthority.com/google-lens-augmented-reality-785836/)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.androidauthority.com/google-lens-augmented-reality-785836/](https://www.androidauthority.com/google-lens-augmented-reality-785836/)'
- en: '[https://docs.aws.amazon.com/rekognition/latest/dg/API_DetectText.html](https://docs.aws.amazon.com/rekognition/latest/dg/API_DetectText.html)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.aws.amazon.com/rekognition/latest/dg/API_DetectText.html](https://docs.aws.amazon.com/rekognition/latest/dg/API_DetectText.html)'
- en: '[https://www.cs.vu.nl/~eliens/assets/flex3/langref/flash/geom/Rectangle.html](https://www.cs.vu.nl/~eliens/assets/flex3/langref/flash/geom/Rectangle.html)
    (rectangle image)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.cs.vu.nl/~eliens/assets/flex3/langref/flash/geom/Rectangle.html](https://www.cs.vu.nl/~eliens/assets/flex3/langref/flash/geom/Rectangle.html)（矩形图像）'
- en: '[https://en.wikipedia.org/wiki/Base64](https://en.wikipedia.org/wiki/Base64)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Base64](https://en.wikipedia.org/wiki/Base64)'
