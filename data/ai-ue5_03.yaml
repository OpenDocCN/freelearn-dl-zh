- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Presenting the Unreal Engine Navigation System
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示虚幻引擎导航系统
- en: The Unreal Engine **Navigation System** is a sophisticated framework that enables
    AI-controlled entities to navigate and interact seamlessly within game levels.
    It provides a set of tools and algorithms that allow game developers to define
    and create paths, obstacles, and movement behaviors. By using the Navigation System,
    you will be able to simulate realistic movement and behavior patterns of AI-controlled
    entities, enhancing the immersion and believability of your virtual environments.
    As this system incorporates advanced features such as **pathfinding algorithms**
    , **collision avoidance** , and **dynamic obstacle handling** , understanding
    its full potential is a crucial skill for aspiring AI programmers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻引擎**导航系统**是一个复杂的框架，它使受人工智能控制的实体能够在游戏关卡中无缝导航和交互。它提供了一套工具和算法，允许游戏开发者定义和创建路径、障碍物和移动行为。通过使用导航系统，您将能够模拟受人工智能控制的实体的真实移动和行为模式，增强虚拟环境的沉浸感和可信度。由于该系统集成了诸如**路径查找算法**、**碰撞避免**和**动态障碍物处理**等高级功能，因此理解其全部潜力对于有抱负的人工智能程序员来说是一项关键技能。
- en: By the time you reach the end of this chapter, you will possess a strong comprehension
    of how this specific part of the Gameplay Framework operates. Equipped with this
    knowledge, you will be fully prepared to embark on your journey of actively working
    with the system itself.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到你读完本章的时候，你将深刻理解这个特定部分的游戏框架是如何运作的。有了这些知识，你将完全准备好开始与系统本身进行积极的工作。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing AI movement
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍人工智能移动
- en: Understanding pathfinding
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解路径查找
- en: Testing the Navigation System with a project template
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用项目模板测试导航系统
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: There are no technical requirements to follow for this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有技术要求需要遵循。
- en: Introducing AI movement
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍人工智能移动
- en: When it comes to moving AI entities in a virtual environment, we face numerous
    challenges, and there is no universal solution. The approach to solving each problem
    depends on each unique characteristic that will be faced in the type of game being
    developed. For example, is the AI’s destination something stationary – for instance,
    a pickup – or is it something that is moving unpredictably, such as the player
    character? Furthermore, will the AI just need to wander around without a specific
    destination, or will it have a pre-defined pattern – for instance, as a patrolling
    sentinel?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到在虚拟环境中移动人工智能实体时，我们面临着众多挑战，并且没有通用的解决方案。解决每个问题的方法取决于将要面对的每种独特特征，这取决于正在开发的游戏类型。例如，人工智能的目标是一个静止的物体——比如一个拾取物——还是它是一个不可预测移动的物体，比如玩家角色？此外，人工智能是否只需要在没有特定目的地的情况下四处游荡，或者它是否有一个预定义的模式——比如作为巡逻哨兵？
- en: Also, as a developer, you will need to consider factors such as different terrains,
    obstacles, and dangerous zones. Deciding between an easier or a more dangerous
    – but quicker – path can have a significant impact at runtime. These are just
    a few of the considerations involved in moving AIs within a level and, as you
    encounter different scenarios, you will be likely to face different issues. Understanding
    and properly addressing all pertinent variables is essential for an optimal player
    experience.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，作为一名开发者，你还需要考虑不同的地形、障碍物和危险区域等因素。在更容易和更危险——但更快捷——的路径之间做出选择，在运行时可能会产生重大影响。这些只是涉及在关卡内移动人工智能所涉及的一些考虑因素，随着你遇到不同的场景，你可能会面临不同的问题。理解和正确处理所有相关变量对于提供最佳玩家体验至关重要。
- en: So, what are the main entities involved in AI movement and, specifically, in
    pathfinding? How do they cooperate to make a player’s experience flawless? I will
    tell you all about it in a few seconds!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在人工智能运动中，特别是路径查找中，涉及的主要实体有哪些？它们如何合作以使玩家的体验完美无瑕？我将在几秒钟内告诉你所有关于它的事情！
- en: Understanding the Navigation Mesh
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解导航网格
- en: 'In Unreal Engine, the Navigation System is based on a **navigation mesh** –
    or **nav mesh** – that works by dividing the navigable space into polygons, which
    are subsequently divided into triangles for efficiency. Each triangle is then
    considered a node of a graph to reach a specific location and when two triangles
    are adjacent, their respective nodes are connected. *Figure 3* *.1* depicts a
    game level with the aforementioned mesh, divided by triangles:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，导航系统基于**导航网格**——或**nav mesh**——通过将可导航空间划分为多边形来实现，这些多边形随后被划分为三角形以提高效率。每个三角形随后被视为到达特定位置的图的一个节点，当两个三角形相邻时，它们的相应节点相连。*图3*
    *.1* 描述了一个带有上述网格的游戏关卡，该网格由三角形划分：
- en: '![Figure 3.1 – A nav mesh example](img/B31016_03_1.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 导航网格示例](img/B31016_03_1.jpg)'
- en: Figure 3.1 – A nav mesh example
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 导航网格示例
- en: Using this graph, you can apply any type of pathfinding algorithm – such as
    **A-star** ( **A*** ), which I will explain later in this chapter – and the resulting
    process will generate a path among these triangles that the AI character can traverse.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此图表，您可以应用任何类型的路径查找算法——例如**A星**（**A***），我将在本章后面解释——并且生成的过程将在这些三角形之间生成一条路径，AI角色可以穿越。
- en: Fortunately, unless you truly need to delve into the intricacies of altering
    the core structure of the Navigation System, there is no immediate need to venture
    into such detail. Understanding that the collection of generated triangles forms
    a cohesive graph, which serves as the foundation for pathfinding algorithms, is
    sufficient for getting the best out of the Navigation System.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，除非您真正需要深入了解修改导航系统核心结构的复杂性，否则没有必要立即深入这种细节。了解生成的三角形集合形成一个连贯的图，该图是路径查找算法的基础，就足以充分利用导航系统。
- en: To generate a nav mesh in Unreal Engine, all you have to do is add one or more
    **Nav Mesh Bounds Volume** actors in the level and change their size to suit your
    own needs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要在虚幻引擎中生成导航网格，您只需在关卡中添加一个或多个**导航网格边界体积**演员，并更改其大小以适应您的需求。
- en: Note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In Unreal Engine, a **Volume** class refers to a special type of actor that
    can influence the behavior of other actors within its area of effect. Volumes
    are used to define various effects, such as lighting, and can modify how players
    or other objects interact with the game world. Some common types of volumes in
    Unreal Engine include Trigger Volumes, Lightmass Importance Volumes, Post-Processing
    Volumes, and, obviously, Nav Mesh Bounds Volumes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，**体积**类指的是一种可以影响其作用区域内其他演员行为的特殊演员。体积用于定义各种效果，如照明，并可以修改玩家或其他对象与游戏世界的交互方式。虚幻引擎中常见的体积类型包括触发体积、光子重要性体积、后期处理体积，以及显然的导航网格边界体积。
- en: '*Figure 3* *.2* shows a **Nav Mesh Bounds Volume** actor added to a level;
    the yellow lines mark the volume itself.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3* *.2* 展示了一个添加到关卡中的**导航网格边界体积**演员；黄色线条标记了该体积本身。'
- en: '![Figure 3.2 – A Nav Mesh Bounds Volume](img/B31016_03_2.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 导航网格边界体积](img/B31016_03_2.jpg)'
- en: Figure 3.2 – A Nav Mesh Bounds Volume
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 导航网格边界体积
- en: 'This actor is pretty straightforward, and the only possible action you can
    take with it is to adjust its extension. From the previous image, you may have
    noticed a green mesh, made of two triangles; this fairly simple shape has been
    generated by another actor: the **Recast Nav Mesh** one, which is usually auto-generated
    the very first time Nav Mesh Bounds Volume is added to the level.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此演员相当简单，您唯一可以采取的操作是调整其扩展。从上一张图片中，您可能已经注意到一个由两个三角形组成的绿色网格；这个相当简单的形状是由另一个演员生成的：**Recast
    Nav Mesh**，通常在第一次将导航网格边界体积添加到关卡时自动生成。
- en: This actor oversees the walkable area generation for AI entities that will use
    it to make their own efficient and accurate calculations on pathfinding; an instance
    of it is usually auto-generated once you add a Nav Mesh Bounds Volume in your
    level.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此演员负责生成AI实体可使用的可通行区域，它将使用此区域进行自己的高效和准确的路径查找计算；通常，一旦您在关卡中添加导航网格边界体积，就会自动生成其实例。
- en: 'It should be noted that most of the settings available for the **RecastNavMesh**
    actor can be set with predefined values in your editor’s **Project Settings**
    – this can be opened from the **File** menu – by selecting the **Engine - Navigation
    Mesh** section, as depicted in *Figure 3* *.3* :'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，大多数可用的**RecastNavMesh**演员设置都可以在您的编辑器**项目设置**中使用预定义值设置——这可以通过**文件**菜单打开——通过选择**引擎
    - 导航网格**部分，如图*图3* *.3* 所示：
- en: '![Figure 3.3 – The Navigation Mesh settings section](img/B31016_03_3.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 导航网格设置部分](img/B31016_03_3.jpg)'
- en: Figure 3.3 – The Navigation Mesh settings section
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 导航网格设置部分
- en: Now that you understand how a nav mesh is created in Unreal Engine, it is important
    to know that you can adjust it to enhance its interest and realism using navigation
    modifiers by using the available modifier system.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了在虚幻引擎中创建导航网格的方法，重要的是要知道你可以通过使用可用的修改器系统来调整它，以增强其趣味性和现实感。
- en: Modifying the nav mesh
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改导航网格
- en: The Navigation System comprises various actors and components that alter the
    generation of the nav mesh, such as the cost of traversing a polygon. These adjustments
    influence how AI agents move through your level.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 导航系统由各种演员和组件组成，这些组件会改变导航网格的生成，例如穿越多边形的成本。这些调整会影响AI代理在你的级别中的移动方式。
- en: The Nav Modifier Volume
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导航修改器体积
- en: 'The simplest one is the **Nav Modifier Volume** actor, whose task is… well,
    to modify a nav mesh! Once you have positioned this volume in your level, you
    will have the choice to modify how an AI agent will perceive it for pathfinding
    – you can designate it as an impassable terrain, a difficult terrain, or even
    an obstacle. *Figure 3* *.4* shows three modifier volumes set with the three different
    cost settings:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的一个是**导航修改器体积**演员，其任务是……好吧，就是修改导航网格！一旦你在你的级别中定位了这个体积，你将可以选择如何修改AI代理对其路径搜索的感知
    – 你可以将其指定为不可通行的地形、困难地形，甚至障碍物。*图 3.4* 显示了设置了三种不同成本设置的三个修改器体积：
- en: '![Figure 3.4 – Three navigation modifiers in action](img/B31016_03_4.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 三个导航修改器在行动](img/B31016_03_4.jpg)'
- en: Figure 3.4 – Three navigation modifiers in action
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 三个导航修改器在行动
- en: If you are thinking about creating your own nav mesh modifiers, well, that’s
    possible; you will just need to extend the **UNavArea** class, set its parameters,
    and you are ready to go!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在考虑创建自己的导航网格修改器，那么，这是可能的；你只需要扩展**UNavArea**类，设置其参数，然后你就可以出发了！
- en: Navigation Query Filters
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导航查询过滤器
- en: As an additional method for tailoring the behavior of the Navigation System
    when generating paths for AI agents, you can take advantage of **Navigation Query
    Filters** . This method encompasses information pertaining to one or more specific
    areas and provides the flexibility to override the cost values assigned to the
    areas themselves, if necessary. By implementing query filters, you will gain the
    ability to customize the navigation patterns of AI agents as they traverse various
    regions within your game world, and this will let you fine-tune and optimize the
    movement of AI entities.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '作为调整AI代理生成路径时导航系统行为的额外方法，你可以利用**导航查询过滤器**。这种方法包括与一个或多个特定区域相关的信息，并提供覆盖分配给这些区域的成本值的灵活性。通过实现查询过滤器，你将能够根据AI代理在游戏世界中穿越各个区域时的导航模式进行定制，这将让你能够微调和优化AI实体的移动。 '
- en: Navigation Link Proxies
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导航链接代理
- en: 'When you begin designing your walkable terrain, you will most probably be introducing
    gaps or areas with varying altitudes; and I guess you’ll need your AI character
    to jump from one side to the other. That’s exactly why the Nav Link Proxy has
    been created; this actor will connect two areas of the nav mesh that lack a direct
    navigation path. *Figure 3* *.5* shows such a link, connecting two zones at different
    heights:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始设计可通行地形时，你很可能会引入缺口或不同海拔的区域；我想你可能需要你的AI角色从一个侧面跳到另一个侧面。这正是导航链接代理被创建的原因；这个演员将连接导航网格中缺少直接导航路径的两个区域。*图
    3.5* 显示了这样一个链接，连接了两个不同高度的区域：
- en: '![Figure 3.5 – Nav link proxy](img/B31016_03_5.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 导航链接代理](img/B31016_03_5.jpg)'
- en: Figure 3.5 – Nav link proxy
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 导航链接代理
- en: With such a useful tool at your disposal, you will be able to make your character
    jump, fall down, and execute breathtaking acrobatics, seamlessly transitioning
    from one gravity-defying move to another.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的工具箱中有这样一款有用的工具，你将能够让你的角色跳跃、坠落，并执行令人叹为观止的杂技，无缝地从一种违反重力的动作过渡到另一种。
- en: Runtime nav mesh generation
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行时导航网格生成
- en: 'By default, Unreal Engine is set to generate nav meshes statically – this means
    that the mesh is generated offline and cannot be changed at runtime. However,
    if you need a more flexible way of generating a nav mesh, you can opt for the
    **dynamic mesh generation** system that will let you update the mesh under different
    circumstances – for example, by adding moving entities. The runtime generation
    can be enabled for the whole project by opening **Project Settings** , and then
    going to the **Engine - Navigation Mesh** section, and selecting the **Runtime
    Generation** option in the **Runtime** category:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，虚幻引擎设置为静态生成导航网格 – 这意味着网格是在离线生成的，无法在运行时更改。然而，如果你需要一个更灵活的生成导航网格的方式，你可以选择**动态网格生成**系统，这将允许你在不同情况下更新网格
    – 例如，通过添加移动实体。可以通过打开**项目设置**，然后转到**引擎 - 导航网格**部分，并在**运行时**类别中选择**运行时生成**选项来为整个项目启用运行时生成：
- en: '![Figure 3.6 – Enabling Runtime Generation](img/B31016_03_6.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 启用运行时生成](img/B31016_03_6.jpg)'
- en: Figure 3.6 – Enabling Runtime Generation
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 启用运行时生成
- en: Alternatively, you can enable it for just a single level, by changing the **Runtime
    Generation** attribute in the **Recast Nav** **Mesh** actor.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以只为单个关卡启用它，通过在**Recast Nav** **网格**演员中更改**运行时生成**属性。
- en: Invokers
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用者
- en: A **Navigation Invoker** is an actor component that will generate the nav mesh
    around an AI agent at runtime. It is used to remove the need for pre-computing
    the mesh, and it allows for dynamic navigation in the game world. This feature
    is particularly useful when you have extensive terrains – for instance, an open
    world – that will take a huge amount of time to generate the nav mesh; through
    an Invoker, the system will generate the mesh itself at runtime, but just in a
    limited space, around the actor.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**导航调用者**是一个演员组件，它将在运行时为人工智能代理生成导航网格。它用于消除预先计算网格的需求，并允许在游戏世界中动态导航。这个特性在拥有广阔地形
    – 例如，一个开放世界 – 需要大量时间来生成导航网格时特别有用；通过调用者，系统将在运行时自行生成网格，但仅限于演员周围的一小片区域。'
- en: You now have a grasp of how a nav mesh is created and tweaked, so let’s explore
    who – or what – will be moving through it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了导航网格的创建和调整方法，那么让我们来探索谁或什么会通过它移动。
- en: AI agents
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 人工智能代理
- en: In Unreal Engine’s Navigation System, an **agent** is an AI character or entity
    that is capable of navigating the game world by means of the nav mesh. An agent
    will use the nav mesh data to compute paths, avoid obstacles, and move around
    the environment intelligently. Each agent in a level typically represents a specific
    type of character, such as a player character – for instance, in a point-and-click
    game – an enemy AI, or any other entity that needs to move within the game world.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎的导航系统中，**代理**是一个能够通过导航网格在游戏世界中导航的人工智能角色或实体。代理将使用导航网格数据来计算路径、避开障碍物，并在环境中智能地移动。一个关卡中的每个代理通常代表一种特定的角色类型，例如玩家角色
    – 例如，在一个点击式游戏中 – 敌人 AI，或任何需要在游戏世界中移动的实体。
- en: To move an agent within a level, you will typically be using a **Pawn** or a
    **Character** actor.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要在关卡内移动一个代理，你通常会使用**Pawn**或**Character**演员。
- en: One of the easiest ways to move an agent toward a location or an actor is by
    using the **Simple Move to Location** or **Simple Move to Actor** Blueprint nodes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将代理移动到位置或演员的最简单方法之一是使用**简单移动到位置**或**简单移动到演员**蓝图节点。
- en: '![Figure 3.7 – The Simple Move nodes](img/B31016_03_7.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 简单移动节点](img/B31016_03_7.jpg)'
- en: Figure 3.7 – The Simple Move nodes
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 简单移动节点
- en: Alternatively, you can use the corresponding C++ methods called, respectively,
    **SimpleMoveToLocation()** and **SimpleMovetoActor()** .
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用相应的 C++ 方法，分别称为**SimpleMoveToLocation()**和**SimpleMovetoActor()**。
- en: Obviously, in Unreal Engine, you can create more complex behaviors than just
    moving an agent to a single point; this is something we will explore starting
    from [*Chapter 8*](B31016_08.xhtml#_idTextAnchor148) , *Setting Up a* *Behavior
    Tree* .
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在虚幻引擎中，你可以创建比仅仅将代理移动到单个点更复杂的动作；这一点我们将在从[*第 8 章*](B31016_08.xhtml#_idTextAnchor148)，“设置行为树”开始时进行探讨。
- en: Avoidance
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免碰撞
- en: 'Basic pathfinding algorithms are effective for finding routes around stationary
    objects; however, when it comes to moving obstacles – such as player characters
    or other AI agents – a more suitable system is needed. That’s why Unreal Engine
    provides two **avoidance** systems, to prevent collision between moving entities:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 基本路径查找算法对于寻找绕过静止物体的路线是有效的；然而，当涉及到移动障碍物——如玩家角色或其他AI代理——时，需要一个更合适的系统。这就是为什么虚幻引擎提供了两个**避免**系统，以防止移动实体之间的碰撞：
- en: The **Reciprocal Velocity Obstacles** ( **RVO** ) system computes the velocity
    vectors for each agent, considering nearby agents and assuming they are moving
    at a constant velocity in each time step of the calculation. The chosen optimal
    velocity vector is the closest match to the agent’s desired velocity in the direction
    of its destination. This system is included in the character movement component.
    RVO does not use the nav mesh for avoidance, so it can be used separately from
    the Navigation System for any character.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互逆速度障碍**（**RVO**）系统计算每个代理的速度向量，考虑附近的代理，并假设它们在计算的每个时间步中以恒定速度移动。选择的最优速度向量是与代理期望速度方向上最接近的代理速度。此系统包含在角色移动组件中。RVO不使用导航网格进行避免，因此它可以与导航系统分开用于任何角色。'
- en: The **Detour Crowd Manager** computes a rough sample of velocities that lean
    toward the agent’s direction, resulting in a substantial enhancement in avoidance
    quality compared to the standard RVO approach. This system can be used by any
    actor extending the **Pawn** class by using the **ADetourCrowdAIController** class.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绕路人群管理器**计算一个倾向于代理方向的粗略速度样本，与标准RVO方法相比，在避免质量上有了显著提升。任何通过**ADetourCrowdAIController**类扩展**Pawn**类的演员都可以使用此系统。'
- en: You will be introduced to avoidance in [*Chapter 5*](B31016_05.xhtml#_idTextAnchor099)
    , *Improving* *Agent Navigation* .
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[*第五章*](B31016_05.xhtml#_idTextAnchor099)中了解到避免，*提高* *代理导航*。
- en: In this section, you have been introduced to the main elements involved in pathfinding
    and how they interact with the environment.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你已经了解了路径查找中涉及的主要元素以及它们与环境之间的交互。
- en: In the following section, I will provide you with further details on how pathfinding
    works.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将提供有关路径查找工作原理的更多详细信息。
- en: Understanding pathfinding
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解路径查找
- en: As you are aware, Unreal Engine uses **pathfinding** for moving an agent around
    a level; in this section, I will go a bit deeper into detail on how things work
    under the hood. Unreal Engine takes advantage of a generalized version of the
    A* algorithm, a widely employed graph traversal and pathfinding algorithm in computer
    science. Known for its completeness, optimality, and efficiency, its main goal
    is to determine the shortest path between a designated source node and a specified
    goal node in a weighted graph.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，虚幻引擎使用**路径查找**在级别中移动代理；在本节中，我将深入探讨内部的工作原理。虚幻引擎利用了A*算法的通用版本，这是计算机科学中广泛使用的图遍历和路径查找算法。以其完备性、最优性和效率而闻名，其主要目标是确定加权图中指定源节点和指定目标节点之间的最短路径。
- en: This graph is a node-based representation of the level, where nodes represent
    walkable areas that are interconnected and have information on neighbor nodes
    and traversal costs to reach them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此图是级别的基于节点的表示，其中节点代表相互连接并可通行的区域，并且包含有关相邻节点和到达它们的通行成本的信息。
- en: A* uses a heuristic function to estimate the cost from each node to the target
    location; this trial-by-error system helps guide the search toward the most promising
    paths, improving efficiency.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: A*使用启发式函数来估计从每个节点到目标位置的成本；这种试错系统有助于引导搜索走向最有希望的路径，提高效率。
- en: 'During the pathfinding process, the algorithm maintains two lists: one of them
    contains nodes that are yet to be evaluated, while the other contains nodes that
    have already been evaluated. The algorithm evaluates each node by considering
    its cost, and the cost of reaching it from the previous node. It selects the node
    with the lowest total cost from the open list for further evaluation. Once the
    target node is reached, the algorithm reconstructs the path by backtracking from
    the target node to the start node, following the connections between nodes.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在路径查找过程中，算法维护两个列表：其中一个包含尚未评估的节点，而另一个包含已经评估过的节点。算法通过考虑其成本以及从上一个节点到达它的成本来评估每个节点。它从开放列表中选择总成本最低的节点进行进一步评估。一旦到达目标节点，算法通过从目标节点回溯到起始节点，沿着节点之间的连接重建路径。
- en: Unreal Engine’s version often includes post-smoothing operations to improve
    the quality of the generated path. Post-smoothing adjusts the path to make it
    more natural and avoid obstacles more effectively.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻引擎的版本通常包括后平滑操作，以提高生成路径的质量。后平滑调整路径，使其更加自然，并更有效地避开障碍。
- en: If you want to take a deep dive into how the nav mesh generation works and how
    pathfinding is computed, my suggestion is to check the Unreal Engine source code
    available on GitHub ( [https://github.com/EpicGames/UnrealEngine](https://github.com/EpicGames/UnrealEngine)
    ); in particular, you should look for the **NavigationSystem** and **NavMesh**
    modules, which are located in the **Engine/Source/Runtime** folder.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要深入了解导航网格生成的工作原理以及路径搜索是如何计算的，我的建议是查看 GitHub 上可用的虚幻引擎源代码（[https://github.com/EpicGames/UnrealEngine](https://github.com/EpicGames/UnrealEngine)）；特别是，你应该查找位于**Engine/Source/Runtime**文件夹中的**NavigationSystem**和**NavMesh**模块。
- en: Note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the Unreal Engine source code, you will need to be part of the Epic
    Games GitHub organization. Subscription is free and there’s no reason why you
    shouldn’t take part in it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问虚幻引擎源代码，你需要成为 Epic Games GitHub 组织的一部分。订阅是免费的，没有理由你不应该参与其中。
- en: As an example, by checking the **DetourNavMeshQuery** class in the Unreal Engine
    source code, you will get an insight into how the A* pathfinding algorithm is
    used and how cost is computed or how to find a tile on a path.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，通过检查虚幻引擎源代码中的**DetourNavMeshQuery**类，你可以了解 A* 寻路算法的使用方式以及成本是如何计算的，或者如何在路径上找到一个瓦片。
- en: It seems you have gained some insight into how pathfinding is handled within
    Unreal Engine, so I guess it’s time to delve into a practical example by exploring
    a real case scenario; we will begin by creating a project from a template.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 看来你已经对在虚幻引擎中如何处理路径搜索有了一些了解，所以我认为是时候通过探索一个真实案例场景来深入一个实际示例了；我们将从创建一个基于模板的项目开始。
- en: Testing the Navigation System with a project template
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用项目模板测试导航系统
- en: In this section, we will look at a project that uses the Unreal Engine Navigation
    System and do it with a project template – using a pre-made project such as a
    template presents a valuable chance for you to acquire practical experience on
    a particular topic, saving you the time and effort required to build a project
    from the ground up.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看一个使用虚幻引擎导航系统的项目，并使用项目模板来完成它——使用预制的项目，如模板，为你提供了一个在特定主题上获得实践经验的有价值的机会，节省了你从头开始构建项目所需的时间和精力。
- en: Once the project has been created, we will quickly analyze the nav mesh generation
    system and how the template handles the character movement at runtime.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目创建完成，我们将快速分析导航网格生成系统以及模板如何处理运行时的人物移动。
- en: Here, you will start by creating a game prototype by using the **Top Down**
    project, one of the templates available in the **GAMES** category of **Unreal**
    **Project Browser** .
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将开始通过使用**俯视**项目，这是在**Unreal** **项目浏览器** **GAMES**类别中可用的模板之一，来创建一个游戏原型。
- en: Setting up the project
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置项目
- en: 'Once you are ready, you can fire up the Epic Games Launcher and follow these
    steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你准备好了，你可以启动 Epic Games Launcher 并按照以下步骤操作：
- en: Select **GAMES** | **Top Down** from the available templates.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从可用的模板中选择**GAMES** | **Top Down**。
- en: Set the project to **Blueprint** or **C++** depending on your personal preferences.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据个人喜好将项目设置为**蓝图**或**C++**。
- en: Name your project – any name will do.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的项目命名——任何名字都可以。
- en: Leave the other settings with their default values.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其他设置保留为默认值。
- en: Click the **Create** button.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建**按钮。
- en: '![Figure 3.8 – Project setup](img/B31016_03_8.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 项目设置](img/B31016_03_8.jpg)'
- en: Figure 3.8 – Project setup
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 项目设置
- en: Once the project has been created and opened, you are ready to analyze it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目创建并打开，你就可以开始分析它了。
- en: Analyzing the nav mesh
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析导航网格
- en: We are now going to get a brief tour of the generated level and of the actors
    that contribute to the nav mesh generation.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将简要浏览生成的关卡以及有助于导航网格生成的演员。
- en: 'In the **Outliner** view, you will notice that there is a folder named **Navigation**
    , including three actors:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在**大纲**视图中，你会注意到有一个名为**导航**的文件夹，包括三个演员：
- en: '**NavMesh** **Bounds Volume**'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航网格** **边界体积**'
- en: '**Recast** **Nav Mesh**'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构** **导航网格**'
- en: '**Nav** **Link Proxy**'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航** **链接代理**'
- en: Let’s analyze each element in detail.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析每个元素。
- en: Nav Mesh Bounds Volume
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导航网格边界体积
- en: 'As you already know from the previous sections in this chapter, the **NavMeshBoundsVolume**
    actor is responsible for defining the area where the nav mesh will be computed.
    By selecting it, you will notice that a yellow-edged area is shown, wrapping all
    the game levels, as shown in *Figure 3* *.9* :'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从本章前面的部分中已经了解的那样，**NavMeshBoundsVolume** 实体负责定义导航网格将被计算的区域。通过选择它，您将注意到一个黄色边缘的区域被显示出来，包围了所有游戏级别，如图
    3.9* 所示：
- en: '![Figure 3.9 – Nav Mesh Bounds Volume](img/B31016_03_9.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – 导航网格边界体积](img/B31016_03_9.jpg)'
- en: Figure 3.9 – Nav Mesh Bounds Volume
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 导航网格边界体积
- en: You cannot do much with this actor; just resize it and the nav mesh will be
    recomputed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您无法对此实体做太多；只需调整其大小，导航网格将重新计算。
- en: Recast Nav Mesh
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新构建导航网格
- en: 'The **RecastNavMesh** actor will take care of the nav mesh generation; by default,
    it does not have a visible representation within the Unreal Engine Editor. However,
    if you press the *P* key on your keyboard, the nav mesh will become visible and
    accessible within the editor interface. *Figure 3* *.10* shows the level once
    this actor has been made visible:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**RecastNavMesh** 实体将负责导航网格的生成；默认情况下，它在 Unreal Engine 编辑器中没有可见的表示。但是，如果您按键盘上的
    *P* 键，导航网格将在编辑器界面中变得可见并可访问。图 3.10* 显示了在此实体可见后级别的样子：'
- en: '![Figure 3.10 – Recast Nav Mesh](img/B31016_03_10.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – 重新构建的导航网格](img/B31016_03_10.jpg)'
- en: Figure 3.10 – Recast Nav Mesh
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 重新构建导航网格
- en: 'In [*Chapter 6*](B31016_06.xhtml#_idTextAnchor116) , *Optimizing the Navigation
    System* , I will be presenting you some techniques on how to optimize mesh generation
    with this actor. For now, you can just check the **Display** category in the **Details**
    window; here, you will have access to a plethora of visualization utilities that
    will come in handy later in this book. As an example, in *Figure 3* *.11* , I
    am showing the sections of the level – named **tiles** – along with their labels
    and the generated polygons:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 6 章*](B31016_06.xhtml#_idTextAnchor116)，“优化导航系统”中，我将向您展示一些使用此实体优化网格生成的技术。现在，您只需检查**详细信息**窗口中的**显示**类别；在这里，您将能够访问一系列可视化工具，这些工具将在本书后面的内容中非常有用。例如，在图
    3.11* 中，我展示了级别的各个部分——称为**瓦片**——以及它们的标签和生成的多边形：
- en: '![Figure 3.11 – Some display settings for the Recast Nav Mesh actor](img/B31016_03_11.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.11 – Recast Nav Mesh 实体的某些显示设置](img/B31016_03_11.jpg)'
- en: Figure 3.11 – Some display settings for the Recast Nav Mesh actor
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – Recast Nav Mesh 实体的某些显示设置
- en: You may have observed that the blue cube actors on the level are not affecting
    the nav mesh in any way. This is because they have been configured not to impact
    the navigation; since they are movable objects, we do not intend for them to create
    non-navigable areas around them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，级别上的蓝色立方体实体以任何方式都没有影响导航网格。这是因为它们已被配置为不会影响导航；由于它们是可移动对象，我们不希望它们在周围创建不可导航区域。
- en: 'As a simple test, in the **Details** panel, you can look for the **Can Ever
    Affect Navigation** property and enable it; the nav mesh will be immediately recomputed
    and the cube will carve a hole in it, as depicted in *Figure 3* *.12* :'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 作为简单的测试，在**详细信息**面板中，您可以查找**始终影响导航**属性并启用它；导航网格将立即重新计算，立方体将在其中挖一个洞，如图 3.12*
    所示：
- en: '![Figure 3.12 – The blue cube actor carving the nav mesh](img/B31016_03_12.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.12 – 蓝色立方体实体雕刻导航网格](img/B31016_03_12.jpg)'
- en: Figure 3.12 – The blue cube actor carving the nav mesh
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – 蓝色立方体实体雕刻导航网格
- en: The aforementioned property states that the object will be an obstruction in
    the navigation area and that the generated hole will be a non-navigable area in
    the mesh.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上述属性表示该对象将是导航区域中的障碍物，并且生成的洞将是网格中的不可导航区域。
- en: Please note that letting such a movable object carve the nav mesh may produce
    undesired results; by default, the nav mesh is static and cannot be altered at
    runtime. This implies that even if the object is moved, the non-navigable area
    will remain fixed and – though unseen – will hinder the player character from
    moving into or through it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，让这样的可移动对象雕刻导航网格可能会产生不期望的结果；默认情况下，导航网格是静态的，无法在运行时进行更改。这意味着即使对象被移动，不可导航区域也将保持固定，尽管看不见，但会阻碍玩家角色进入或穿越它。
- en: Nav Link Proxy
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导航链接代理
- en: The last nav mesh entity in this example is a **NavLinkProxy** actor that, in
    our level, will let the player character jump down from a platform.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，最后一个导航网格实体是一个 **NavLinkProxy** 实体，在我们的级别中，它将允许玩家角色从平台上跳下来。
- en: '![Figure 3.13 – The Nav Link Proxy in the level](img/B31016_03_13.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图3.13 – 级别中的导航链接代理](img/B31016_03_13.jpg)'
- en: Figure 3.13 – The Nav Link Proxy in the level
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 – 级别中的导航链接代理
- en: Now that you comprehend how the nav mesh is structured, let’s examine the character
    controller to understand how the player character is maneuvered.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经理解了导航网格的结构，让我们来检查角色控制器，以了解玩家角色是如何操纵的。
- en: Analyzing the character controller
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析角色控制器
- en: Depending on your choice in creating the project – Blueprints or C++ – you will
    have two slightly different versions of the character controller.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您在创建项目时的选择——蓝图或C++——您将拥有两种略有不同的角色控制器版本。
- en: The Blueprint character controller
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 蓝图角色控制器
- en: The code for moving the controller character is pretty straightforward and can
    be found in **BP_TopDownController** – located in the **Content/TopDown/Blueprints**
    folder.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 移动控制器角色的代码相当简单，可以在**BP_TopDownController**中找到——位于**Content/TopDown/Blueprints**文件夹中。
- en: Once the Blueprint class is opened, locate the **MoveTo** function in the **Functions**
    tab and open it; you will find the **Simple Move to Location** node that is used
    to make the player character move through the nav mesh.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦打开蓝图类，在**函数**选项卡中找到**MoveTo**函数并打开它；您将找到用于使玩家角色通过导航网格移动的**简单移动到位置**节点。
- en: '![Figure 3.14 – The MoveTo function](img/B31016_03_14.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图3.14 – MoveTo函数](img/B31016_03_14.jpg)'
- en: Figure 3.14 – The MoveTo function
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 – MoveTo函数
- en: This is all you need to use to move your player character to a predefined location
    in the level.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您需要用来将玩家角色移动到级别中预定义位置的所有内容。
- en: The C++ character controller
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C++角色控制器
- en: 'The same logic can be found inside a C++-generated project; just open the generated
    **.cpp** class for the player controller and look for the **OnSetDestinationReleased()**
    method; you will find this line of code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的逻辑可以在C++生成的项目中找到；只需打开为玩家控制器生成的**.cpp**类，查找**OnSetDestinationReleased()**方法；您将找到以下代码行：
- en: '[PRE0]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This helper function will start the navigation process for your agent.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个辅助函数将启动您的代理的导航过程。
- en: Testing the project
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试项目
- en: Now that you know all the actors involved in this project, you can simply hit
    the **Play** button and start testing how the Navigation System works. In particular,
    you will notice that the character will move to the destination point by selecting
    the shortest path.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了参与此项目的所有演员，您可以简单地按**播放**按钮开始测试导航系统的工作方式。特别是，您会注意到角色将通过选择最短路径移动到目标点。
- en: Additionally, once on the raised platform on the left, it will be able to jump
    down thanks to the Nav Link Proxy that has been added at that location.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一旦在左侧的升高平台上，它将能够跳下，这要归功于在该位置添加的导航链接代理。
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, I introduced you to the key components of the Unreal Engine
    Navigation System. We started by discussing the process of generating the nav
    mesh, which is essential for AI agents to navigate the environment. Then, I provided
    a brief explanation of how the pathfinding algorithm works, enabling AI characters
    to find their way efficiently. Lastly, I highlighted the benefits of using the
    **Top Down** project template, which effectively utilizes the Navigation System.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我向您介绍了虚幻引擎导航系统的关键组件。我们首先讨论了生成导航网格的过程，这对于AI代理在环境中导航至关重要。然后，我简要解释了路径查找算法的工作原理，使AI角色能够高效地找到路径。最后，我强调了使用**自上而下**项目模板的好处，该模板有效地利用了导航系统。
- en: By now, you should have a good understanding of the capabilities offered by
    the Unreal Engine AI Navigation System. I imagine you are eager to dive in and
    start coding on your keyboard, and that is exactly what we will be doing in the
    next chapter!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，您应该已经很好地理解了虚幻引擎AI导航系统提供的功能。我想您一定渴望开始编码，这正是我们在下一章将要做的！
