- en: Understanding the Breadth-First Search Algorithm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解广度优先搜索算法
- en: The **breadth-first search** (**BFS**) algorithm is a traversing algorithm where
    you start at a selected node (the source or starting node) and traverse the graph
    layer-wise, exploring the neighboring nodes (nodes that are directly connected
    to the source node). You then move towards the neighboring nodes in the next level.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**广度优先搜索**（**BFS**）算法是一种遍历算法，首先从选定的节点（源节点或起始节点）开始，按层次遍历图，探索相邻节点（与源节点直接连接的节点）。然后，继续向下一层的相邻节点移动。'
- en: In this chapter, you will learn about BFS while developing LinkedIn's connection
    feature. You will learn how second-degree connections can be computed by using
    the BFS algorithm.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习 BFS 算法，并开发 LinkedIn 的连接功能。你将学习如何通过 BFS 算法计算二度连接。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Understanding the LinkedIn connection feature
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 LinkedIn 的连接功能
- en: Graph data structure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图数据结构
- en: Queue data structure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列数据结构
- en: The BFS algorithm
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BFS 算法
- en: DFS versus BFS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DFS 与 BFS
- en: Understanding the LinkedIn connection feature
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 LinkedIn 的连接功能
- en: 'As you know, LinkedIn is a social network, and users are connected to one another
    through first- or second-degree connections. In order to better understand this
    concept, use the following diagram as a reference:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，LinkedIn 是一个社交网络，用户通过一度或二度连接与他人建立联系。为了更好地理解这个概念，可以参考以下图示：
- en: '![](img/a9d1c864-52d8-40ab-9b41-b62fa17a5c7d.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9d1c864-52d8-40ab-9b41-b62fa17a5c7d.png)'
- en: Figure 1
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1
- en: 'Suppose that I want to find an acquaintance named **Jill **and connect with
    her. When I go to her profile, I find that she is a second-degree connection,
    which means that we have a mutual colleague. Let''s look at how this degree is
    computed. To do so, we will create a connection tree:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我想找到一个名为**Jill**的熟人并与她建立连接。当我查看她的个人资料时，我发现她是二度连接，这意味着我们有一个共同的同事。让我们来看看这个度数是如何计算的。为此，我们将创建一个连接树：
- en: 'We start with the profile node, **Dev**, and add it to the connection tree:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从个人资料节点**Dev**开始，并将其添加到连接树中：
- en: '![](img/05a0cb02-1efe-4b1c-a906-0561b07010d8.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05a0cb02-1efe-4b1c-a906-0561b07010d8.png)'
- en: Figure 2
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2
- en: 'Now, I will find my colleagues and add them beneath my node. So, I add **Ali**
    and **Tom** beneath the **Dev** node:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我将找到我的同事并把他们添加到我的节点下。因此，我将**Ali**和**Tom**添加到**Dev**节点下：
- en: '![](img/7a569634-9366-42e6-aa28-95a997a6c16f.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a569634-9366-42e6-aa28-95a997a6c16f.png)'
- en: Figure 3
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3
- en: 'Now, for both **Ali** and **Tom**, I find their colleagues and add them beneath
    their nodes. So, under **Ali, **I add **Dev**, **Seth**, and **Ram**, and under
    **Tom,** I add **Dev**, **Seth**, **Kai**, and **Jill**:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，对于**Ali**和**Tom**，我找到他们的同事并把他们添加到各自的节点下。因此，在**Ali**节点下，我添加了**Dev**、**Seth**和**Ram**；在**Tom**节点下，我添加了**Dev**、**Seth**、**Kai**和**Jill**：
- en: '![](img/624c3eaa-ebbc-46e9-8199-d7dc39417e90.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/624c3eaa-ebbc-46e9-8199-d7dc39417e90.png)'
- en: Figure 4
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4
- en: 'Now, for each of these nodes, we find their connections and add those as well:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，对于这些节点，我们找到它们的连接并将其添加进去：
- en: '![](img/a7bd3a9e-f2f4-4ece-a11d-74a8955c5625.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7bd3a9e-f2f4-4ece-a11d-74a8955c5625.png)'
- en: Figure 5
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5
- en: In the preceding diagram, the connections to **Dev** have been added (due to
    space constraints, this is not shown). For **Seth**, we find his connections (**Ali**,
    **Tom**, and **Harry**) and add them underneath his name. For **Ram**, we add
    **Ali** and **Jill**. Similarly, due to space constraints, we are not showing
    the connections for **Dev** and **Seth**, as they are already shown in the diagram.
    Under **Kai**, we add his connection, **Tom**. Finally, when we come to the node
    for **Jill (**to add her connections), we find that this node has the goal state,
    so we end our search.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的图中，已经添加了与**Dev**的连接（由于空间限制，未显示）。对于**Seth**，我们找到他的连接（**Ali**、**Tom**和**Harry**），并将它们添加到他的名字下。对于**Ram**，我们添加了**Ali**和**Jill**。类似地，由于空间限制，未显示**Dev**和**Seth**的连接，因为它们已经在图中显示。对于**Kai**，我们添加了他的连接**Tom**。最后，当我们到达**Jill**节点（以添加她的连接）时，我们发现这个节点已经到达目标状态，因此我们结束了搜索。
- en: You may have noticed that **Jill** appears as a connection to **Ram** at the
    bottom of the tree; but, if you consider the bottom node, then the connection
    degree is **3**, which is not the least value. However, because a BFS search processes
    the search tree level by level, we're able to find the least path solution. We
    can also see that there are people that appear multiple times in this connection
    tree. For example, **Dev**, **Ali**, and **Tom** appear three times each, while
    **Seth** and **Jill** each appear twice.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到**Jill**作为与**Ram**的连接出现在树的底部；但是，如果你考虑底部节点，连接度为**3**，这不是最小值。然而，由于BFS搜索按层次逐级处理搜索树，我们能够找到最短路径解决方案。我们还可以看到在这个连接树中，有些人出现了多次。例如，**Dev**、**Ali**和**Tom**每个人都出现了三次，而**Seth**和**Jill**每个人出现了两次。
- en: 'So, we''ll keep the first entry of the node in the connection tree, and we
    will remove the other instances; the following diagram shows how the search tree
    should look:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们将保留连接树中的节点的第一个条目，并移除其他实例；下图展示了搜索树的样子：
- en: '![](img/989bb140-e37c-4877-8bfb-7f9c2584edec.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/989bb140-e37c-4877-8bfb-7f9c2584edec.png)'
- en: Figure 6
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图6
- en: When we add the node to the search tree, we should check whether it already
    exists in the search tree.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将节点添加到搜索树时，我们应该检查它是否已经存在于搜索树中。
- en: In [Chapter 1](50419d40-ab0f-4d63-9447-295dc802574c.xhtml), *Understanding the
    Depth-First Search Algorithm,* you learned that the `State` class indicates the
    condition of the search process. You also learned that the `State` class has to
    be changed for every application, even though the search algorithm is the same.
    Now, let's look at the changes that we need to make to the `State` class for this
    application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](50419d40-ab0f-4d63-9447-295dc802574c.xhtml)，*理解深度优先搜索算法*中，您学到了`State`类表示搜索过程的状态。您还学到了，即使搜索算法相同，`State`类也需要针对每个应用进行更改。现在，让我们看看为了这个应用，我们需要对`State`类进行的更改。
- en: First, we need a property to track the condition of the search. In this case,
    the property is the person under consideration. Then, we have the same four methods—`constructor()`,
    `getInitialState()`, `successorFunction()`, and `checkGoalState()`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个属性来追踪搜索的状态。在这个应用中，该属性是当前正在考虑的人。然后，我们有四个相同的方法——`constructor()`、`getInitialState()`、`successorFunction()`和`checkGoalState()`。
- en: Let's look at each of these three ingredients in detail. To find the initial
    state, we should ask ourselves the question, *where do we start searching from?*
    In this application, we start searching from my profile. To find the successor
    function, we should ask ourselves, *how do we explore from the current state?*
    In this application, the function should return the people connected to the person
    under consideration. So, for **Ali **it should return all of his colleagues. Finally,
    to find the goal function, we should ask the question, *how will we know when
    we have found the solution?* The goal function should return true if the person
    is `Jill`. So, if the current person is Harry, the function should return false,
    and if the current person is `Jill`, it should return true.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细查看这三种成分。为了找到初始状态，我们应该问自己一个问题，*我们从哪里开始搜索？* 在这个应用中，我们从我的个人资料开始搜索。为了找到后继函数，我们应该问自己，*我们如何从当前状态进行探索？*
    在这个应用中，函数应该返回与当前人相关联的人员。因此，对于**Ali**，它应该返回他的所有同事。最后，为了找到目标函数，我们应该问一个问题，*我们如何知道何时找到了解决方案？*
    如果当前人是`Jill`，目标函数应该返回true。如果当前人是Harry，函数应该返回false，如果当前人是`Jill`，则返回true。
- en: 'Let''s look at the `State` class code for this application, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个应用中的`State`类代码，如下所示：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As shown in the preceding code, in this module, `State.py`, we are importing
    all of the variables from `GraphData`. The purpose of `GraphData` will be explained
    in the *Graph data structure* section. In the constructor, the `name` argument is
    passed. If the argument `name` is `None`, then the initial state is created, and
    if the name is provided, that name is assigned to the name property. The `initialState` property
    holds the value `Dev`, and the `successorFunction` method returns all of the people
    connected to the current person. To get the people connected to the person, we
    use connections from GraphData:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，在这个模块`State.py`中，我们从`GraphData`导入了所有变量。`GraphData`的作用将在*图形数据结构*部分中进行解释。在构造函数中，传递了`name`参数。如果`name`参数为`None`，则会创建初始状态；如果提供了名称，则该名称将赋值给名称属性。`initialState`属性的值为`Dev`，而`successorFunction`方法返回与当前人相关联的所有人员。为了获取与该人相关联的人员，我们使用来自GraphData的连接：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `checkGoalState` function returns if the current person's name is `Jill`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkGoalState`函数返回当前人的名字是否是`Jill`。'
- en: Now, you should understand how the degree of connection is computed and how
    the `State` class has changed for this application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该了解了连接度是如何计算的，以及`State`类在这个应用中的变化。
- en: In the next section, we'll look at how to represent social network data as a
    graph.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将看看如何将社交网络数据表示为图。
- en: Graph data structure
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图数据结构
- en: 'A **graph** is a non-linear data structure containing a set of points known
    as **nodes** (or vertices) and a set of links known as **edges**, as illustrated
    in the following diagram:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**图**是一种非线性数据结构，包含一组称为**节点**（或顶点）的点，以及一组称为**边**的连接，如下图所示：'
- en: '![](img/f4a7c5fa-9513-4a4c-8d90-45f222707e44.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4a7c5fa-9513-4a4c-8d90-45f222707e44.png)'
- en: Figure 7
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7
- en: An edge that connects to the same node is called a **cycle**. As shown in the
    preceding diagram, nodes **a** and **b** are connected by two paths; one is through
    edge **a-b**, and the other is through edges **a-d** and **d-b**. A **tree** is
    a special type of graph, in which there are no cycles, and two nodes are connected
    by one path.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到同一个节点的边被称为**循环**。如前面的图示所示，节点**a**和**b**通过两条路径连接；一条是通过边**a-b**，另一条是通过边**a-d**和**d-b**。**树**是一种特殊的图形，在这种图形中没有循环，且两个节点之间只有一条路径。
- en: 'In Python, we can use a dictionary structure to represent a graph. A **dictionary**
    is a data structure where many keys are mapped to values. For a dictionary that
    represents a graph, the keys are the nodes, and the values of those nodes are
    the nodes that they are connected to:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以使用字典结构来表示图。**字典**是一种数据结构，其中许多键映射到值。对于表示图的字典，键是节点，而这些节点的值是它们连接的节点：
- en: '![](img/1dbe59aa-ca3f-420c-83d2-aa88e455b6dd.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1dbe59aa-ca3f-420c-83d2-aa88e455b6dd.png)'
- en: Figure 8
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8
- en: 'In the preceding diagram, we can see that the following applies:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图示中，我们可以看到以下内容：
- en: '**For key a**, the values are **b** and **c**'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于键 a**，值是**b**和**c**'
- en: '**For key b**, the values are **c** and **a**'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于键 b**，值是**c**和**a**'
- en: '**For key c**, the values are **a** and **b**'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于键 c**，值是**a**和**b**'
- en: 'Now, let''s create a dictionary to show the graph structure of the social network
    that we saw in the previous topic:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个字典来展示上一节中提到的社交网络的图结构：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the Python module `GraphData.py`, we have created a dictionary called `connections`.
    The keys are the people in the social network, and the corresponding values are
    the people that they are connected to. Now, the `connections` dictionary is used
    in `State.py`. It is used in the  `successorFunction` function, as shown in the
    following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python模块`GraphData.py`中，我们创建了一个名为`connections`的字典。字典的键是社交网络中的人物，值则是他们连接的人。现在，`connections`字典在`State.py`中使用。它在`successorFunction`函数中使用，如以下代码所示：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we can get the people that the person is connected to by using the `connections`
    dictionary, with the person's name as the key. We can get the people that are
    connected to that person by using the `connections` object.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以通过使用`connections`字典来获取与某人连接的其他人，以此人的名字作为键。我们可以通过使用`connections`对象来获取与该人连接的其他人。
- en: 'Now, let''s look at how to traverse this graph data structure, in order to
    create a search tree:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下如何遍历这个图数据结构，以便创建一个搜索树：
- en: We will start with my profile in the graph, and add the **Dev** node to the
    search tree and the visited nodes list.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从我在图中的个人资料开始，并将**Dev**节点添加到搜索树和已访问节点列表中。
- en: From my node in the graph, we can find the connected people, **Ali** and **Tom**;
    we add these nodes to the search tree and the visited nodes list.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我在图中的节点出发，我们可以找到连接的人员，**Ali**和**Tom**；我们将这些节点添加到搜索树和已访问节点列表中。
- en: For **Ali** and **Tom**, we find who they're connected to by using the graph
    data structure, and we add these nodes to the search tree and the visited nodes
    list, if they have not been visited before. **Ali** is connected to **Dev**, **Seth**,
    and **Ram**. **Dev** has already been visited, so we ignore this node. **Seth**
    and **Ram** have not been visited before, so we add these nodes to the search
    tree and the visited nodes list. **Tom** is connected to **Dev**, **Seth**, **Kai**,
    and **Jill**. **Dev** and **Seth** have already been visited, so we ignore these
    nodes, and we add the nodes **Kai** and **Jill** to the list, because they have
    not been visited before.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**Ali**和**Tom**，我们通过使用图形数据结构找出他们连接的节点，并将这些节点添加到搜索树和访问节点列表中，如果它们之前没有被访问过。**Ali**与**Dev**、**Seth**和**Ram**连接。**Dev**已经被访问过，所以我们忽略这个节点。**Seth**和**Ram**没有被访问过，所以我们将这些节点添加到搜索树和访问节点列表中。**Tom**与**Dev**、**Seth**、**Kai**和**Jill**连接。**Dev**和**Seth**已经被访问过，所以我们忽略这些节点，添加**Kai**和**Jill**到列表中，因为它们之前没有被访问过。
- en: We repeat the process of adding the children to the search tree and the visited
    nodes list (if they have not been visited before). **Seth** is connected to **Ali**,
    **Tom**, and **Harry**. **Ali** and **Tom** have already been visited, so we ignore
    them, and we add **Harry** to the search tree and the visited nodes list. **Ram**
    is connected to **Ali** and **Jill**, and both of them have been visited before.
    Moving forward, **Kai** is connected to **Tom**, and he's already been visited,
    as well. When we process the **Jill** node, we find that it has the goal state,
    and we end our search.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重复将子节点添加到搜索树和访问节点列表的过程（如果它们之前没有被访问过）。**Seth**与**Ali**、**Tom**和**Harry**连接。**Ali**和**Tom**已经被访问过，所以我们忽略它们，添加**Harry**到搜索树和访问节点列表中。**Ram**与**Ali**和**Jill**连接，而这两个节点之前都已经被访问过。接下来，**Kai**与**Tom**连接，而他也已经被访问过。当我们处理**Jill**节点时，发现它具有目标状态，搜索结束。
- en: 'You have now learned how to use a list of visited nodes to explore a graph
    as a tree, which will look like the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经学会了如何使用访问节点的列表将图形作为树进行探索，结果将如下所示：
- en: '![](img/e97fd7e7-f8ae-4bf3-98dc-53c3e001cfa7.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e97fd7e7-f8ae-4bf3-98dc-53c3e001cfa7.png)'
- en: Figure 9
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9
- en: In the next section, you'll learn about the queue data structure, which forms
    the basis of node reversal, just like a stack in the DFS method.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将学习队列数据结构，它与深度优先搜索（DFS）方法中的栈类似，是节点反转的基础。
- en: Queue data structure
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列数据结构
- en: 'A **queue** is a sequence of people or objects waiting to be attended to. Some
    examples include a queue of people waiting at a counter, a queue of swimmers that
    are ready to dive in to a pool, and a queue of songs in a playlist:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**队列**是一系列等待处理的人或物体。举几个例子，包括排队等候在柜台前的人们，准备跳入游泳池的游泳者队列，以及播放列表中的歌曲队列：'
- en: '![](img/6e7fa6ab-615b-44e4-92bf-e084c5e9204e.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e7fa6ab-615b-44e4-92bf-e084c5e9204e.png)'
- en: Figure 10
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10
- en: 'Just like in a stack, there are two types of operations—one for inserting items
    into a queue, and one for removing items from a queue. When a person joins a queue,
    he or she must stand behind the last person. The operation of adding an item to
    a queue is called **enqueue**. The first person to be attended to in a queue is
    the person standing in the front. The operation to remove an item from a queue
    is called **dequeue**. Queue operations can be seen in the following diagram:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 就像栈一样，队列也有两种操作——一种是将项目插入队列，另一种是从队列中移除项目。当一个人排队时，他或她必须站在最后一个人后面。向队列添加项目的操作称为**入队**。队列中第一个被处理的人是站在前面的人。从队列中移除项目的操作称为**出队**。队列操作可以通过以下图示表示：
- en: '![](img/7681900b-ad36-463c-a701-fa4a225ed277.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7681900b-ad36-463c-a701-fa4a225ed277.png)'
- en: Figure 11
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11
- en: 'Since the first object inserted is the first one to be removed, this data structure
    is called **first in first out** (**FIFO**). In Python, we can use the `deque`
    class to create `queue` objects. The `deque` class provides two methods—one method,
    `append`, for inserting items, and a method called `popleft` for removing items:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第一个插入的对象是第一个被移除的，这种数据结构称为**先进先出**（**FIFO**）。在 Python 中，我们可以使用`deque`类来创建`queue`对象。`deque`类提供了两种方法——一种方法是`append`，用于插入项目，另一种方法是`popleft`，用于移除项目：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code, we have created an empty queue, to which we will add
    the items `1`, `2`, `3`, and `4`; later, we will delete these items from the queue
    one by one. Upon successful execution of the code, we will get the following output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们创建了一个空队列，并向其中添加了 `1`、`2`、`3` 和 `4`，随后我们将逐一从队列中删除这些项目。代码成功执行后，我们将得到以下输出：
- en: '![](img/8484ed2f-aece-4384-8dd1-6da565c1e9e9.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8484ed2f-aece-4384-8dd1-6da565c1e9e9.png)'
- en: Figure 12
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12
- en: As shown in the preceding screenshot, we initially have an empty queue, and,
    after adding items `1`, `2`, `3`, and `4`, you can see that the items are in the
    queue, with `1` at the front and `4` at the back. When we remove an item from
    the queue, the first one to be removed is `1`, because it is at the front, and
    then `2`, `3`, and `4` are removed. At the end, we have an empty queue.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，我们最初有一个空队列，添加了 `1`、`2`、`3` 和 `4` 后，你可以看到这些项目在队列中，`1` 在前，`4` 在后。当我们从队列中移除一个项目时，第一个被移除的是
    `1`，因为它在前，接着是 `2`、`3` 和 `4`，最后队列为空。
- en: Now that you understand how a queue works, we'll look at the steps in a BFS
    algorithm and how the graph and queue data structures are used.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了队列的工作原理，我们将查看 BFS 算法中的步骤，以及图和队列数据结构是如何使用的。
- en: The BFS algorithm
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BFS 算法
- en: In this section, we'll look at the flow of the BFS algorithm, how a queue is
    used, and how graph data affects the algorithm. The flow of the BFS algorithm
    is similar to that of DFS, but instead of using a stack data structure, a queue
    data structure is used.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解 BFS 算法的流程，队列如何使用，以及图数据如何影响算法。BFS 算法的流程与 DFS 类似，但不同之处在于，BFS 使用的是队列数据结构，而不是栈数据结构。
- en: 'A flowchart of the BFS algorithm can be illustrated as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: BFS 算法的流程图可以如下所示：
- en: '![](img/0b4087b1-79bb-4692-a691-d0131dbc9b2e.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b4087b1-79bb-4692-a691-d0131dbc9b2e.png)'
- en: Figure 13
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13
- en: We initially create a root node with an initial state, and add it to a queue
    and tree.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个具有初始状态的根节点，并将其添加到队列和树中。
- en: A node is dequeued from the queue, and we check whether it has the goal state.
    If it does, we end our search. If it doesn't, we find the child nodes of the dequeued
    node and add them to the queue entry.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个节点从队列中出队，我们检查它是否具有目标状态。如果有，我们结束搜索。如果没有，我们找到该节点的子节点并将它们添加到队列中。
- en: This process is repeated until we either find the goal state or have exhausted
    all of the nodes in our search tree.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个过程会一直重复，直到我们找到目标状态或者所有节点都已被搜索完。
- en: Since our connection data is in a graph structure, we have to check whether
    each node has been visited before.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的连接数据采用图结构，因此我们必须检查每个节点是否已被访问过。
- en: So, we add the root node to a list of visited nodes, and the child node is added
    to the queue, tree, and visited list (if the child node has not been visited previously).
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们将根节点添加到已访问节点列表中，子节点被添加到队列、树和已访问列表中（如果子节点之前未被访问）。
- en: 'Let''s look at these steps in detail by implementing them in our graph diagram,
    which we covered in the *Understanding the LinkedIn connection feature* section:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在图形图示中实现这些步骤来详细了解它们，这是我们在 *理解 LinkedIn 连接功能* 部分中讨论的内容：
- en: We start by adding my profile node to the search tree, queue, and visited nodes
    list. We dequeue the **Dev** node from the queue.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将我的个人资料节点添加到搜索树、队列和已访问节点列表中。然后我们将 **Dev** 节点从队列中出队。
- en: Since the **Ali** node has not been visited, we add this node to the search
    tree, queue, and visited nodes list. Similarly, since **Tom** has not been visited,
    we add this node to the search tree, queue, and visited nodes list.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 **Ali** 节点尚未被访问，我们将这个节点添加到搜索树、队列和已访问节点列表中。同样，由于 **Tom** 节点未被访问，我们也将它添加到搜索树、队列和已访问节点列表中。
- en: 'We dequeue the **Ali **node from the queue, and, since it doesn''t have the
    goal state, we find its child nodes: **Dev**, **Seth,** and **Ram**. The **Dev**
    node has been visited, so we ignore that node. The **Seth** node has not been
    visited, so we add that node to the search tree, queue, and visited nodes list.
    Similarly, we add **Ram** to the search tree, queue, and visited nodes list.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从队列中出队 **Ali** 节点，并且由于它没有目标状态，我们找到它的子节点：**Dev**、**Seth** 和 **Ram**。**Dev**
    节点已被访问，因此我们忽略该节点。**Seth** 节点未被访问，因此我们将该节点添加到搜索树、队列和已访问节点列表中。同样，我们将 **Ram** 节点添加到搜索树、队列和已访问节点列表中。
- en: 'We dequeue the **Tom** node from the queue, and we find its children nodes: **Dev**,
    **Seth**, **Kai,** and **Jill**. The **Dev** node has been visited, so we ignore
    that node, and the same goes for the **Seth** node. The **Kai** node has not been
    visited, so we add that node to the search tree, queue, and visited nodes list;
    the same goes for the **Jill** node. We dequeue the **Seth** node from the queue,
    and we find its child nodes: **Ali**, **Tom**, and **Harry**. The **Ali** and
    **Tom** nodes have been visited, so we ignore these nodes. We add the node **Harry**
    to the search tree, queue, and visited nodes list.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从队列中出队**Tom**节点，并找到它的子节点：**Dev**、**Seth**、**Kai**和**Jill**。**Dev**节点已经被访问过，因此我们忽略该节点，**Seth**节点也是如此。**Kai**节点尚未被访问，因此我们将该节点添加到搜索树、队列和已访问节点列表中；**Jill**节点也同样处理。我们从队列中出队**Seth**节点，并找到它的子节点：**Ali**、**Tom**和**Harry**。**Ali**和**Tom**节点已经被访问，因此我们忽略这些节点。我们将**Harry**节点添加到搜索树、队列和已访问节点列表中。
- en: We dequeue the **Ram **node from the queue, and we find its child nodes, **Ali**
    and **Jill**, which have both been visited; so, we carry on.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从队列中出队**Ram**节点，并找到它的子节点，**Ali**和**Jill**，这两个节点都已被访问；因此，我们继续。
- en: We dequeue the **Kai **node, and we find its child node, **Tom**, which has
    been visited; so, we carry on again.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从队列中出队**Kai**节点，并找到它的子节点**Tom**，该节点已被访问，因此我们继续。
- en: We dequeue the **Jill** node from the queue, and we find that it has the goal
    state, so we end our search.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从队列中出队**Jill**节点，发现它是目标状态，因此我们结束搜索。
- en: 'Once we have completed the preceding steps, we will have the following tree:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成上述步骤，我们将得到以下树形结构：
- en: '![](img/888f7612-2134-4edf-95ea-36aea1f073c2.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888f7612-2134-4edf-95ea-36aea1f073c2.png)'
- en: Figure 14
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图14
- en: 'Let''s implement the preceding algorithm with the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用以下代码实现上述算法：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the Python module `QueueBFS.py`, we have created a method called `performQueueBFS`,
    in which we have an empty queue that will hold the nodes and a list of visited
    nodes. We create the root node with `initialState`, and we add this root node
    to the queue, along with a list of visited nodes. One by one, we dequeue elements
    from the queue; we call the dequeued node the `currentNode`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python模块`QueueBFS.py`中，我们创建了一个名为`performQueueBFS`的方法，其中有一个空队列用于存放节点，并有一个已访问节点的列表。我们使用`initialState`创建根节点，并将该根节点和已访问节点列表一起添加到队列中。我们逐个从队列中出队元素；我们将出队的节点称为`currentNode`：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We print the name of the current node and check whether it has the goal state.
    If it does, we print the path from the root node to the current node and break
    the loop. If it doesn't have the goal state, we find the child states of the current
    state, and for each higher state, we construct the child node and check whether
    that node has been visited.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印当前节点的名称，并检查它是否具有目标状态。如果是，我们打印从根节点到当前节点的路径并跳出循环。如果没有目标状态，我们找到当前状态的子状态，对于每个更高的状态，我们构建子节点并检查该节点是否已被访问。
- en: 'The list of visited nodes now holds the names of the nodes. So, in the following
    code, we have added the name of the root node:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，已访问节点的列表中保存了节点的名称。因此，在下面的代码中，我们已经添加了根节点的名称：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We have done the same in the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在下面的代码中做了同样的事情：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we check whether the name of the node has not been visited.
    Because we're checking for unique names, if the node has not been visited, we
    add the name of the child node to the list of visited nodes, and we add the child
    node to the search tree and the queue. Finally, we print the queue.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们检查节点名称是否未被访问。因为我们在检查唯一的名称，如果节点没有被访问，我们就将该子节点的名称添加到已访问节点列表中，并将该子节点添加到搜索树和队列中。最后，我们打印队列。
- en: 'Let''s run the code and see what happens:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行代码，看看会发生什么：
- en: '![](img/f4b02ccc-942e-4e42-b23e-79c553aaf212.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4b02ccc-942e-4e42-b23e-79c553aaf212.png)'
- en: Figure 15
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图15
- en: In the preceding screenshot, we can see the order in which the nodes are processed.
    We start off with the `Dev` node, and then we process the connections, `Ali` and `Tom`,
    and then the connections of `Ali`, `Ram`, and `Seth`, and the connections of `Tom`, `Kai`
    and `Jill`. When we process the `Jill` node, we find that we have reached the
    goal state and we end our search.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，我们可以看到节点处理的顺序。我们从`Dev`节点开始，然后处理连接的`Ali`和`Tom`，接着是`Ali`、`Ram`和`Seth`的连接，再然后是`Tom`、`Kai`和`Jill`的连接。当我们处理到`Jill`节点时，发现已经达到了目标状态，我们结束了搜索。
- en: In the preceding screenshot, we can see the path printed from the initial state
    to the goal state through the `Tom` node . From this, we can see that `Jill` is
    a second-level connection. We can also see the search tree that has been constructed
    so far.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们可以看到从初始状态到目标状态的路径通过`Tom`节点打印出来。从中可以看到`Jill`是二级连接。我们还可以看到到目前为止构建的搜索树。
- en: Now that you are aware of the steps involved in BFS, we'll compare the BFS and
    DFS algorithms.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了BFS的步骤，我们将对比BFS和DFS算法。
- en: BFS versus DFS
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BFS与DFS
- en: In this section, we'll look at the differences between the DFS and BFS algorithms.
    We will compare these differences in terms of various factors.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究DFS和BFS算法之间的区别。我们将从多个因素来比较这些差异。
- en: Order of traversal
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历顺序
- en: In DFS, preference is given to child nodes, which means that after node **a** and
    node **b** are explored, and after node **b** and node **c** are explored, we
    hit a dead end and we backtrack to the previous level. This means that we go back
    to node **b,** and then to its next child, which is node **c**.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在DFS中，优先考虑子节点，这意味着在探索完节点**a**和节点**b**后，接着探索完节点**b**和节点**c**，当遇到死胡同时，我们会回溯到上一级。这意味着我们回到节点**b**，然后继续探索它的下一个子节点，即节点**c**。
- en: 'In BFS, the nodes are covered level by level, and preference is given to siblings.
    This means that after node **a**, nodes **b** and **e** are explored, and after
    that, nodes **c**, **d**, and **f** are explored, as indicated by the following
    diagram:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在BFS中，节点按层级覆盖，优先考虑兄弟节点。这意味着在探索完节点**a**后，接着探索节点**b**和**e**，然后再探索节点**c**、**d**和**f**，如下面的图所示：
- en: '![](img/48b567e6-fc7c-457b-86a8-39a1bb338a01.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48b567e6-fc7c-457b-86a8-39a1bb338a01.png)'
- en: Figure 16
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图16
- en: Data structures
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构
- en: 'In DFS, a stack data structure is used, while in BFS, a queue is used, as shown
    in the following diagram:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在DFS中，使用栈数据结构，而在BFS中，使用队列，如下图所示：
- en: '![](img/92e48e65-c300-4948-bf75-3c159d62630e.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92e48e65-c300-4948-bf75-3c159d62630e.png)'
- en: Figure 17
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图17
- en: Memory
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存
- en: When recursive DFS is called on node **c**, the implicit stack stores two entries—one
    for node **e**, and one for nodes **c** and **d**. So, the memory used is in the
    order of **d**, where **d** is the depth of the search tree.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当递归调用DFS时，节点**c**的隐式栈会存储两个条目——一个是节点**e**，另一个是节点**c**和**d**。因此，所使用的内存是按**d**的顺序，其中**d**是搜索树的深度。
- en: 'When the BFS method is called on node **c**, the queue contains four entries—nodes
    **c**, **d**, **f**, and **g**. So, the memory used is in the order of *b^d*,
    where **b** is the branching factor and **d** is the depth of the search tree.
    Here, the branching factor is **2**, because each internal node has two children:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当BFS方法被调用在节点**c**时，队列包含四个条目——节点**c**、**d**、**f**和**g**。因此，所使用的内存是按*b^d*的顺序，其中**b**是分支因子，**d**是搜索树的深度。这里，分支因子为**2**，因为每个内部节点有两个子节点：
- en: '![](img/fc83fa38-2bdb-4941-a803-d1b53100c105.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc83fa38-2bdb-4941-a803-d1b53100c105.png)'
- en: Figure 18
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图18
- en: Optimal solution
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最优解
- en: 'Suppose that there are two possible solutions—nodes **d** and **e**. In this
    case, **e** is the optimal solution, because it has the shortest path from root
    node **a**. Here, DFS finds the sub-optimal solution, **d**, before it finds the
    optimal solution, **e**. BFS finds the optimal solution, **e,** before it encounters
    node **d**:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有两个可能的解决方案——节点**d**和**e**。在这种情况下，**e**是最优解，因为它从根节点**a**到达的路径最短。这里，DFS首先找到子最优解**d**，然后才找到最优解**e**。BFS在遇到节点**d**之前，先找到了最优解**e**：
- en: '![](img/c62bb3fa-1473-4c2f-a281-9dc4773ce14c.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c62bb3fa-1473-4c2f-a281-9dc4773ce14c.png)'
- en: Figure 19
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图19
- en: We already saw that DFS uses less memory than BFS, and BFS finds the optimal
    solution. So, the choice of algorithm depends on how big the search space is (in
    this case, you will go for DFS), and whether finding the optimal solution is important
    (in this case, BFS is preferred).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到DFS使用的内存比BFS少，而BFS能找到最优解。所以，算法的选择取决于搜索空间的大小（在这种情况下，你会选择DFS），以及是否需要找到最优解（在这种情况下，BFS更为合适）。
- en: Next, we will look at an application that you can try to develop yourself.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看一个你可以尝试自己开发的应用程序。
- en: Do it yourself
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自己动手试试
- en: In the previous section, we discussed the differences between the DFS and BFS
    algorithms. In this section, we'll look at an application that you can try to
    develop yourself. We'll go over the application that you'll try to develop, and
    the changes that are required for the application.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了 DFS 和 BFS 算法的区别。在本节中，我们将介绍一个应用程序，你可以尝试自己开发。我们将讲解你需要开发的应用程序以及为此所需的更改。
- en: 'Your aim will be to develop a university navigation application, as shown in
    the following diagram:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你的目标是开发一个大学导航应用程序，如下图所示：
- en: '![](img/ff8166a6-adaa-4993-8633-24baefbd0683.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff8166a6-adaa-4993-8633-24baefbd0683.png)'
- en: Figure 20
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20
- en: Suppose that this is the layout of the university, and people can travel along
    horizontal or vertical lines. In this application, the user has to enter the source
    and destination places. For this specific case, we'll assume that a new student
    wants to find his way from the **Bus Stop** to the **AI Lab**.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这是大学的布局，学生可以沿着水平或垂直线路行走。在这个应用程序中，用户需要输入起点和终点。对于这个具体的情况，我们假设一名新生想要从 **公交车站**
    找到 **人工智能实验室**。
- en: 'You can refer to the classes that we developed for the LinkedIn connection
    feature, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考我们为 LinkedIn 连接功能开发的类，具体如下：
- en: '![](img/7c8c3593-77a2-44f7-ba14-16cef6cbfddb.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c8c3593-77a2-44f7-ba14-16cef6cbfddb.png)'
- en: Figure 21
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21
- en: 'To adapt that code for this application, we need to change the `State` class
    and the graph data. In the `State` class, the `name` property is replaced with
    the `place` property, and `NavigationData` contains the connections between places:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将代码适配到这个应用程序，我们需要修改 `State` 类和图数据。在 `State` 类中，`name` 属性被替换为 `place` 属性，`NavigationData`
    包含地点之间的连接：
- en: '![](img/e415b6cb-1a0c-41a9-bb3b-38742ec27c74.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e415b6cb-1a0c-41a9-bb3b-38742ec27c74.png)'
- en: Figure 22
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 22
- en: Let's look at the three ingredients of the search in detail. To get the answer
    for the initial state, we can ask ourselves the question, *where do we start searching
    from?* In this case, it's the **Bus Stop**. So, `successorFunction` should return
    all of the connected places. For example, if the current place is **Car Park**,
    then this function should return the **Library**, the **Store**, and the **Maths
    Building**. To get the answer for the goal function, we should ask ourselves the
    question, *how will we know when we have found the solution?* For this application,
    the function should return true if the place is the **AI Lab**; for example, if
    the current place is the **Canteen**, then it should return false, and if the
    current place is the **AI Lab**, then it should return true.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看搜索的三个要素。为了得到初始状态的答案，我们可以问自己一个问题，*我们从哪里开始搜索？* 在这个例子中，是 **公交车站**。因此，`successorFunction`
    应该返回所有连接的地点。例如，如果当前地点是 **停车场**，那么该函数应该返回 **图书馆**、**商店** 和 **数学楼**。为了得到目标函数的答案，我们应该问自己一个问题，*我们怎么知道何时找到了解决方案？*
    对于这个应用程序，如果地点是 **人工智能实验室**，函数应该返回 true；例如，如果当前地点是 **餐厅**，则返回 false；如果当前地点是 **人工智能实验室**，则返回
    true。
- en: Go ahead and try it out for yourself!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 去试试看吧！
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, to help you understand the BFS algorithm, we revisited the
    concepts of state and node. You learned about the graph and queue data structures,
    and we discussed the differences between the DFS and BFS algorithms.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，为了帮助你理解 BFS 算法，我们重新回顾了状态和节点的概念。你了解了图和队列数据结构，并且我们讨论了 DFS 和 BFS 算法的区别。
- en: In the next chapter, you'll be learning about the heuristic search algorithm.
    Instead of giving preference to child or sibling nodes, this method gives preference
    to the nodes that are closest to the goal state; the term **heuristic** refers
    to the measure of how close the nodes are to the goal state.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习启发式搜索算法。与优先考虑子节点或兄弟节点不同，这种方法优先考虑距离目标状态最近的节点；术语 **启发式** 指的是衡量节点与目标状态之间距离的度量。
- en: Please refer to the link [https://www.packtpub.com/sites/default/files/downloads/HandsOnArtificialIntelligenceforSearch_ColorImages.pdf](https://www.packtpub.com/sites/default/files/downloads/HandsOnArtificialIntelligenceforSearch_ColorImages.pdf) for
    the colored images of this chapter.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考链接 [https://www.packtpub.com/sites/default/files/downloads/HandsOnArtificialIntelligenceforSearch_ColorImages.pdf](https://www.packtpub.com/sites/default/files/downloads/HandsOnArtificialIntelligenceforSearch_ColorImages.pdf)
    获取本章的彩色图片。
