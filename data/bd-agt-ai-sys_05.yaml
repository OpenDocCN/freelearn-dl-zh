- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Enabling Tool Use and Planning in Agents
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在智能体中启用工具使用和规划
- en: In the previous chapter, we looked into the intricate concepts of reflection
    and introspection in intelligent agents. These capabilities empower agents to
    reason about their own cognitive processes, learn from experiences, and dynamically
    modify their behaviors.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了智能体中反思和内省的复杂概念。这些能力使智能体能够对自己的认知过程进行推理，从经验中学习，并动态地修改它们的行为。
- en: A significant step forward in AI agents comes from combining how agents plan
    and use tools. This chapter looks at how tools work, different planning algorithms,
    how they fit together, and real examples showing how useful they are in practice.
    We will explore the concept of tool use by intelligent agents that extend their
    capabilities beyond decision-making and problem-solving. We will look at different
    types of tools that agents can utilize, such as APIs, databases, and software
    functions. We will then delve into planning algorithms essential for agents, including
    state-space search, reinforcement learning, and hierarchical task network planning.
    We will discuss integrating tool use and planning by reasoning about available
    tools, assessing their suitability based on goals, selecting appropriate tools,
    and generating efficient action sequences that leverage those tools.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 智能体的一大进步来自于结合智能体规划和工具使用的方法。本章将探讨工具如何工作，不同的规划算法，它们如何相互配合，以及实际例子展示了它们在实际中的有用性。我们将探讨智能体通过扩展其能力超越决策和问题解决来使用工具的概念。我们将研究智能体可以利用的不同类型的工具，例如API、数据库和软件功能。然后我们将深入研究对智能体至关重要的规划算法，包括状态空间搜索、强化学习和分层任务网络规划。我们将讨论通过推理可用工具、根据目标评估其适用性、选择适当的工具以及生成利用这些工具的有效动作序列来整合工具使用和规划。
- en: 'This chapter is divided into the following main sections:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为以下主要部分：
- en: Understanding the concept of tool use in agents
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解智能体工具使用概念
- en: Planning algorithms for agents
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能体规划算法
- en: Integrating tool use and planning
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整合工具使用和规划
- en: Exploring practical implementations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索实际实现
- en: By the end of this chapter, you will know what tools are, how they can be used
    to power your agentic systems, and how they work in conjunction with planning
    algorithms.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将了解工具是什么，它们如何被用来为你的智能体系统提供动力，以及它们如何与规划算法协同工作。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code file for this chapter on GitHub at [https://github.com/PacktPublishing/Building-Agentic-AI-Systems](https://github.com/PacktPublishing/Building-Agentic-AI-Systems)
    . In this chapter, we will also use agentic Python frameworks such as CrewAI,
    AutoGen, and LangChain to demonstrate the various aspects of AI agents.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章的代码文件，链接为[https://github.com/PacktPublishing/Building-Agentic-AI-Systems](https://github.com/PacktPublishing/Building-Agentic-AI-Systems)。在本章中，我们还将使用智能体Python框架，如CrewAI、AutoGen和LangChain，来展示AI智能体的各个方面。
- en: Understanding the concept of tool use in agents
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解智能体工具使用概念
- en: At its core, tool usage by an intelligent agent refers to the LLM agent’s capability
    of leveraging external resources or instrumentation to augment the agent’s inherent
    functionality and decision-making processes. This concept extends beyond the traditional
    notion of an agent as a self-contained (isolated) entity, relying solely on its
    internal knowledge (training data) and algorithms. Instead, it acknowledges the
    potential for agents to transcend their intrinsic limitations by strategically
    harnessing the power of external tools and systems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，智能体使用工具指的是LLM智能体利用外部资源或工具来增强智能体的固有功能性和决策过程的 capability。这个概念超越了传统智能体作为一个自包含（隔离）实体的概念，它仅依赖于其内部知识（训练数据）和算法。相反，它承认智能体通过战略性地利用外部工具和系统的力量来超越其内在限制的潜力。
- en: 'For example, when you send a query (“ *What’s the weather?* ”) to an agent
    in isolation, the model is free to either respond with any made-up answer or it
    may respond that it doesn’t know how to find the weather. In this case, the agent
    will rely on the LLM’s training data, which will not have up-to-date information
    about real-time weather data. On the other hand, if the LLM agent has access to
    a real-time weather lookup tool, it may be able to answer the question accurately.
    Tool usage enables agents to access real-time data, execute specialized tasks,
    and manage complex workflows that go beyond their built-in knowledge and algorithms.
    *Figure 5* *.1* shows this isolated versus tool-powered behavior:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你向隔离状态下的代理发送查询（“*天气怎么样？*”）时，模型可以自由地给出任何虚构的答案，或者它可能回答它不知道如何找到天气。在这种情况下，代理将依赖于LLM的训练数据，这些数据将不会有关于实时天气数据的最新信息。另一方面，如果LLM代理能够访问实时天气查找工具，它可能能够准确地回答问题。工具使用使代理能够访问实时数据，执行专业任务，并管理超出其内置知识和算法的复杂工作流程。*图
    5.1* 显示了这种隔离状态与工具驱动行为的对比：
- en: '![img](img/B31483_05_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31483_05_01.jpg)'
- en: Figure 5.1 – Agent behavior in isolation versus with access to a tool
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 代理在隔离状态下的行为与使用工具时的行为
- en: The significance of tool use lies in its ability to broaden the scope of an
    agent’s (and, in turn, the LLM that powers the agent’s) competencies, enabling
    it to tackle complex, real-world challenges that may be beyond the reach of its
    native problem-solving capabilities. By integrating and orchestrating the use
    of various tools, an agent can effectively offload specific tasks or access supplementary
    data and functionalities, thereby enhancing its overall performance and expanding
    its scope of achievable objectives. Before we go into the details of tools, let’s
    first understand how LLM tool calling works.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 工具使用的重要性在于其能够拓宽代理（以及，反过来，驱动代理的LLM）的能力范围，使其能够应对复杂、现实世界的挑战，这些挑战可能超出了其原生问题解决能力。通过整合和协调使用各种工具，代理可以有效地卸载特定任务或访问补充数据和功能，从而提高其整体性能并扩大其可达成目标的范围。在我们深入工具的细节之前，让我们首先了解LLM工具调用是如何工作的。
- en: Tool and function calling
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具和函数调用
- en: While *tool calling* and *function calling* are often used interchangeably in
    the context of LLMs, they have distinct technical differences. **Function calling**
    refers to an LLM generating structured calls to predefined functions within the
    same runtime, typically executing internal tasks such as database lookups or calculations.
    **Tool calling** , on the other hand, enables LLMs to interact with external APIs,
    services, or systems, allowing them to access real-time data and perform specialized
    tasks beyond their intrinsic capabilities. For example, an LLM using function
    calling might retrieve a user’s profile from a local database, while tool calling
    would involve querying a weather API for live updates. Understanding this distinction
    is crucial for designing AI agents that seamlessly integrate internal logic with
    external systems to enhance functionality.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然*工具调用*和*函数调用*在LLM的上下文中经常被互换使用，但它们有明显的技术差异。**函数调用**指的是LLM生成结构化调用同一运行时内的预定义函数，通常执行内部任务，如数据库查询或计算。另一方面，**工具调用**使LLM能够与外部API、服务或系统交互，允许它们访问实时数据并执行超出其固有能力的专业任务。例如，使用函数调用的LLM可能会从本地数据库检索用户的配置文件，而工具调用则可能涉及查询天气API以获取实时更新。理解这种区别对于设计能够无缝整合内部逻辑与外部系统以增强功能的AI代理至关重要。
- en: 'When an LLM invokes a tool or function, it doesn’t actually execute any code.
    Instead, it generates a structured response indicating the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个LLM调用一个工具或函数时，它实际上并没有执行任何代码。相反，它生成一个结构化响应，表明以下内容：
- en: Which tool/function it wants to use
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它想使用哪个工具/函数
- en: What parameters should be passed to that tool/function
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该传递给该工具/函数哪些参数
- en: How those parameters should be formatted
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些参数应该如何格式化
- en: 'Think of it like writing a detailed instruction rather than performing the
    action itself. The LLM acts as a sophisticated dispatcher, determining what needs
    to be done and how, but the actual execution of the tool or function must be handled
    by an external runtime environment or an *Agent Controller* . For example, when
    asked about the weather in Boston, an LLM might recognize the need for the weather
    lookup function and respond with a structured call such as the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，这就像编写详细的指令而不是执行动作本身。LLM 充当一个复杂的调度器，确定需要做什么以及如何做，但工具或函数的实际执行必须由外部运行环境或 *代理控制器*
    处理。例如，当询问波士顿的天气时，LLM 可能会识别出需要天气查找函数，并以如下结构化的调用进行响应：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This structured response is then interpreted and executed by the Agent Controller
    that actually has the capability to run the specified function with the provided
    parameters. The **weather_lookup** tool (or function) may look something like
    this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此结构化响应随后被代理控制器解释并执行，该控制器实际上具有运行指定函数并提供参数的能力。**weather_lookup** 工具（或函数）可能看起来像这样：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'At the minimum, the LLM agent requires the tool’s description of what the tool
    does and what input it expects. You can also specify which parameters (in this
    case, **location** and **date** ) are mandatory and which ones are optional. *Figure
    5* *.2* demonstrates the flow between an LLM agent, tool, and the Agent Controller:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，LLM 代理需要工具的功能描述以及它期望的输入。您还可以指定哪些参数（在这种情况下，**location** 和 **date**）是必需的，哪些是可选的。*图
    5* *.2* 展示了 LLM 代理、工具和代理控制器之间的流程：
- en: '![img](img/B31483_05_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31483_05_02.jpg)'
- en: Figure 5.2 – LLM agent tool calling and tool execution by the Agent Controller
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – LLM 代理工具调用和代理控制器执行工具
- en: It is worth noting that not all LLMs are capable or efficient (or rather accurate)
    in tool/function calling. While larger models are more capable of tool calling,
    some larger models (such as OpenAI’s GPT-4 and -4o, Anthropic’s Claude Sonnet,
    Haiku, Opus, and Meta’s Llama 3 models) are explicitly trained for tool calling
    behavior. While other models are not explicitly trained on tool calling, they
    may still be able to achieve similar functionality with aggressive prompt engineering,
    but with varying degrees of success.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，并非所有 LLM 都能够或高效（或更准确地说，准确）地调用工具/函数。虽然较大的模型在工具调用方面更有能力，但一些较大的模型（如 OpenAI
    的 GPT-4 和 -4o、Anthropic 的 Claude Sonnet、Haiku、Opus 以及 Meta 的 Llama 3 模型）是专门为工具调用行为进行训练的。而其他模型虽然没有专门针对工具调用进行训练，但它们可能仍然能够通过积极的提示工程实现类似的功能，但成功率各不相同。
- en: Defining tools for agents
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为代理定义工具
- en: Tools are defined with clear descriptions, typically using docstrings or a JSON
    schema, to communicate their purpose, required inputs, and expected outputs to
    the agent. There are two main approaches to defining tools, depending on whether
    you’re using a framework or working directly with LLM APIs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 工具通过清晰的描述来定义，通常使用文档字符串或 JSON 模式，以将目的、所需输入和预期输出传达给代理。根据是否使用框架或直接与 LLM API 交互，定义工具主要有两种方法。
- en: Framework approach – using docstrings
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 框架方法 - 使用文档字符串
- en: 'In frameworks such as CrewAI or LangGraph, tools are defined using docstrings
    – descriptive text that appears at the beginning of a function. Here’s an example
    of a weather lookup tool:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在如 CrewAI 或 LangGraph 这样的框架中，工具是通过文档字符串定义的 - 出现在函数开头处的描述性文本。以下是一个天气查找工具的示例：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The docstring, enclosed within triple quotes ( **"""** ), provides crucial
    information about the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 三重引号（**"""**）内的文档字符串提供了关于以下内容的 crucial 信息：
- en: The tool’s purpose
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具的目的
- en: Required and optional arguments
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必需和可选参数
- en: Expected return values
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期返回值
- en: This approach makes tool creation intuitive for developers, as it uses standard
    programming practices. While Python uses triple quotes for docstrings, other programming
    languages may have different conventions for defining such documentation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使开发者创建工具变得直观，因为它使用了标准的编程实践。虽然 Python 使用三重引号来表示文档字符串，但其他编程语言可能有不同的约定来定义此类文档。
- en: Direct LLM integration
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接 LLM 集成
- en: 'When working directly with LLM APIs (such as Anthropic’s Claude or OpenAI’s
    GPT) without a framework, tools must be defined using a specific JSON schema format:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当在没有框架的情况下直接与 LLM API（如 Anthropic 的 Claude 或 OpenAI 的 GPT）交互时，必须使用特定的 JSON 模式格式来定义工具：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Multiple tools can be used as a list (or array) of JSON schema objects with
    the tool definition when invoking the model, such as the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用多个工具作为调用模型时工具定义的 JSON 模式对象的列表（或数组），例如以下所示：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that this is model-dependent, so you must refer to the model’s documentation
    to learn more about how its APIs require you to specify tools. If your project
    uses multiple models that have different ways of defining tools, then it can quickly
    become cumbersome to define, manage, and maintain tool definitions. This is one
    of the reasons why there is an increase in affinity toward using libraries or
    frameworks such as CrewAI, LangGraph, and AutoGen, which provide a simplified
    way of defining tools regardless of the LLM being used for the agents.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这取决于模型，因此您必须参考模型的文档以了解更多关于如何指定工具的信息。如果您的项目使用多个模型，这些模型以不同的方式定义工具，那么定义、管理和维护工具定义可能会变得非常繁琐。这也是为什么越来越多的人倾向于使用如
    CrewAI、LangGraph 和 AutoGen 等库或框架的原因，这些库或框架为定义工具提供了一种简化的方式，无论使用的 LLM 是什么。
- en: Types of tools
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具类型
- en: 'LLM agents can leverage various types of toolkits to enhance their capabilities
    and perform complex tasks. Here are the main categories:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: LLM 代理可以利用各种类型的工具包来增强其功能并执行复杂任务。以下是主要类别：
- en: '**Application programming interfaces** ( **APIs** ): APIs serve as the primary
    gateway for agents to access external services and data in real time. They provide
    standardized methods for interacting with third-party systems, enabling agents
    to seamlessly integrate with various services. For instance, in a travel planning
    context, APIs allow agents to access weather services, payment processing systems,
    navigation and mapping services, and flight and hotel booking systems. This real-time
    connectivity ensures agents can provide up-to-date information and services to
    users.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序编程接口**（**APIs**）：APIs 是代理访问外部服务和数据的实时主要门户。它们提供与第三方系统交互的标准方法，使代理能够无缝集成到各种服务中。例如，在旅行规划场景中，APIs
    允许代理访问天气服务、支付处理系统、导航和地图服务以及航班和酒店预订系统。这种实时连接确保代理可以向用户提供最新信息和服务的。'
- en: '**Database tools** : Database tools enable agents to store, retrieve, and manage
    structured (or semi-structured) data efficiently. These tools support both reading
    and writing operations, allowing agents to maintain persistent information across
    sessions. Agents commonly use databases to store customer profiles and preferences,
    maintain historical transaction records, manage product catalogs, and access domain-specific
    knowledge bases. This persistent storage capability enables agents to learn from
    past interactions and provide personalized services.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库工具**：数据库工具使代理能够高效地存储、检索和管理结构化（或半结构化）数据。这些工具支持读写操作，允许代理在会话之间维护持久信息。代理通常使用数据库来存储客户资料和偏好、维护历史交易记录、管理产品目录和访问特定领域的知识库。这种持久存储能力使代理能够从过去的交互中学习并提供个性化服务。'
- en: '**Utility functions** : Utility functions are custom software components designed
    for specialized tasks that run locally within the agent’s environment. These functions
    handle essential operations such as data processing and analysis, format conversion,
    mathematical calculations, and natural language processing tasks. They serve as
    the building blocks for more complex operations and help agents process information
    efficiently. Utility functions are particularly valuable for tasks that require
    consistent, repeatable operations.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实用函数**：实用函数是为在代理环境中本地运行的特定任务而设计的定制软件组件。这些函数处理基本操作，如数据处理和分析、格式转换、数学计算和自然语言处理任务。它们是更复杂操作的基础，并帮助代理高效地处理信息。实用函数对于需要一致、可重复操作的任务尤其有价值。'
- en: '**Integration tools** : Integration tools specialize in connecting different
    systems and services, enabling seamless workflow automation. These tools handle
    crucial tasks such as calendar synchronization, document processing, file management,
    and communication systems integration. They act as bridges between different platforms
    and services, allowing agents to orchestrate complex workflows that span multiple
    systems and data sources.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成工具**：集成工具专门用于连接不同的系统和服务，实现无缝的工作流程自动化。这些工具处理关键任务，如日历同步、文档处理、文件管理和通信系统集成。它们作为不同平台和服务之间的桥梁，允许代理编排跨越多个系统和数据源的复杂工作流程。'
- en: '**Hardware interface tools** : Hardware interface tools enable agents to interact
    with physical devices and systems, bridging the gap between digital and physical
    worlds. These tools are essential for controlling IoT devices, integrating with
    robotics systems, processing sensor data, and managing physical automation systems.
    Through hardware interface tools, agents can extend their influence beyond digital
    interactions to affect real-world changes and monitor physical environments.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件接口工具**：硬件接口工具使代理能够与物理设备和系统交互，架起数字世界和物理世界之间的桥梁。这些工具对于控制物联网设备、与机器人系统集成、处理传感器数据和管理物理自动化系统至关重要。通过硬件接口工具，代理可以将其影响力扩展到数字交互之外，影响现实世界的变化并监控物理环境。'
- en: Each tool type serves specific purposes and can be combined to create powerful
    agent capabilities. The choice of tools depends on the agent’s role, requirements,
    and the complexity of tasks it needs to perform.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每种工具类型都有其特定的用途，可以组合使用以创建强大的代理能力。工具的选择取决于代理的角色、需求以及它需要执行的任务的复杂性。
- en: 'Understanding how agents work with these tools involves the following several
    key considerations that affect their effectiveness and reliability. These aspects
    are crucial for developing robust agent systems that can handle complex real-world
    tasks while maintaining security, handling errors gracefully, and adapting to
    changing requirements:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 理解代理如何使用这些工具涉及以下几个关键考虑因素，这些因素影响其有效性和可靠性。这些方面对于开发能够处理复杂现实世界任务、同时保持安全性、优雅处理错误和适应变化需求的强大代理系统至关重要：
- en: '**Tool composition and chaining** : Agents often need to combine multiple tools
    to accomplish complex tasks. Tool composition allows agents to create sophisticated
    workflows by chaining tools together. For example, a travel planning agent might
    first use an API to check flight availability, then a database tool to retrieve
    user preferences, and, finally, a utility function to calculate optimal itineraries.
    This chaining capability significantly extends what agents can accomplish beyond
    using tools in isolation.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具组合和链式操作**：代理经常需要组合多个工具来完成复杂任务。工具组合允许代理通过链式操作创建复杂的流程。例如，一个旅行规划代理可能会首先使用API检查航班可用性，然后使用数据库工具检索用户偏好，最后使用实用函数计算最佳行程。这种链式操作能力显著扩展了代理使用工具所能完成的任务范围。'
- en: '**Tool selection and decision-making** : One of the most critical aspects of
    tool usage is the agent’s ability to select the appropriate tool for a given task.
    Agents must evaluate the context, understand the requirements, and choose the
    most suitable tool or combination of tools. This involves considering factors
    such as tool capabilities, reliability, performance, and cost. The agent must
    also handle cases where multiple tools could solve the same problem, selecting
    the most efficient option.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具选择和决策**：工具使用中最关键的方面之一是代理选择适合特定任务的适当工具的能力。代理必须评估环境、理解需求，并选择最合适的工具或工具组合。这涉及到考虑工具功能、可靠性、性能和成本等因素。代理还必须处理多个工具可以解决同一问题的情况，选择最有效的选项。'
- en: '**Error handling and fallbacks** : When working with tools, agents must be
    prepared for potential failures and have strategies to handle them. This includes
    detecting failed API calls, managing database connection issues, or handling incorrect
    function outputs. Robust error handling often involves implementing fallback mechanisms,
    where agents can switch to alternative tools or approaches if the primary method
    fails.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理和回退机制**：在使用工具时，代理必须准备好应对潜在的错误，并制定相应的处理策略。这包括检测失败的API调用、管理数据库连接问题或处理错误的函数输出。健壮的错误处理通常涉及实现回退机制，当主要方法失败时，代理可以切换到替代工具或方法。'
- en: '**Tool state management** : Many tools maintain state or require specific initialization
    and cleanup procedures. Agents need to manage these tool states effectively, ensuring
    proper resource allocation and release. This includes managing database connections,
    maintaining API authentication tokens, and handling session states for various
    services.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具状态管理**：许多工具维护状态或需要特定的初始化和清理程序。代理需要有效地管理这些工具状态，确保适当的资源分配和释放。这包括管理数据库连接、维护API身份验证令牌和处理各种服务的会话状态。'
- en: '**Tool updates and versioning** : Tools evolve over time with new versions
    and capabilities. Agents need strategies to handle tool updates, version compatibility,
    and deprecated features. This might involve maintaining compatibility with multiple
    versions of a tool, gracefully handling deprecated features, and adapting to new
    tool interfaces.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具更新和版本控制**：工具随着时间的推移通过新版本和功能而演变。代理需要策略来处理工具更新、版本兼容性和已弃用功能。这可能涉及与工具的多个版本保持兼容、优雅地处理已弃用功能，以及适应新的工具接口。'
- en: '**Tool security and access control** : Security considerations are crucial
    when agents interact with tools, especially those accessing sensitive data or
    critical systems. This includes managing authentication credentials, implementing
    proper authorization checks, and ensuring secure communication channels. Agents
    must also respect rate limits and usage quotas imposed by various tools.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具安全和访问控制**：当代理与工具交互时，尤其是访问敏感数据或关键系统时，安全考虑至关重要。这包括管理身份验证凭据、实施适当的授权检查，并确保安全的通信渠道。代理还必须遵守各种工具施加的速率限制和用量配额。'
- en: Consider a practical example of interaction between a user and our AI travel
    agent using tools effectively.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个用户与我们的AI旅行代理有效使用工具的互动的实际例子。
- en: '*User* : “I need flight and hotel options for Rome for 2 adults, June 15–22,
    2024, with a total budget of $3,000.”'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户**：“我需要为2位成人提供2024年6月15日至22日罗马的航班和酒店选项，总预算为3,000美元。”'
- en: 'Using the CrewAI framework in the following code snippet, we will demonstrate
    how agents use tools in this focused travel planning scenario:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们将使用CrewAI框架演示代理如何在专注于旅行规划的场景中使用工具：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this example, we can see several key concepts in action:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到几个关键概念的实际应用：
- en: '**Tool definition** : The **TravelTools** class implements focused tools for
    specific travel-related tasks'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具定义**：**TravelTools**类实现了针对特定旅行相关任务的专注工具'
- en: '**Agent configuration** : The travel agent is configured with appropriate tools
    and a clear goal'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理配置**：旅行代理配置了适当的工具和明确的目标'
- en: '**Task specification** : The task is defined with precise parameters for the
    agent to work with'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务规范**：任务使用精确的参数定义，以便代理可以工作'
- en: '**Tool integration** : The agent seamlessly integrates multiple tools (flight
    and hotel search) to accomplish its task'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具集成**：代理无缝集成多个工具（航班和酒店搜索）以完成其任务'
- en: '**Execution flow** : The CrewAI framework manages the overall execution and
    coordination of the agent and its tools'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行流程**：CrewAI框架管理代理及其工具的整体执行和协调'
- en: This streamlined implementation demonstrates how agents can effectively use
    tools while maintaining clarity and purpose in their operations. In our example,
    the **TravelTools** class uses simplified JSON responses for clarity. However,
    in a real-world implementation, these tools would interact with actual external
    services and handle much more complex data.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简化的实现展示了代理如何在保持操作清晰和目的的同时有效地使用工具。在我们的例子中，**TravelTools**类使用简化的JSON响应以提高清晰度。然而，在实际应用中，这些工具将与实际的外部服务交互并处理更复杂的数据。
- en: Note that this is a rather simple implementation, and the actual implementation
    would involve integrating with various APIs, databases, and software tools specific
    to the travel domain. Additionally, advanced AI planning algorithms could be employed
    to optimize the itinerary construction and activity planning steps. This comprehensive
    tool usage allows the AI travel agent to provide a seamless, end-to-end, trip-planning
    experience far beyond just searching flights and hotels. You can find the full
    code in the Python notebook ( **Chapter_05.ipynb** ) in the GitHub repository.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是一个相当简单的实现，实际实现将涉及与各种API、数据库和特定于旅行领域的软件工具的集成。此外，可以采用先进的AI规划算法来优化行程构建和活动规划步骤。这种综合的工具使用使AI旅行代理能够提供无缝、端到端、的旅行规划体验，远不止于搜索航班和酒店。您可以在GitHub仓库中的Python笔记本（**Chapter_05.ipynb**）中找到完整的代码。
- en: The significance of tools in agentic systems
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具在代理系统中的重要性
- en: The paradigm shift toward tool use is driven by the recognition that many complex
    problems demand a diverse array of specialized tools and resources, each contributing
    a unique set of capabilities. Rather than attempting to encapsulate all requisite
    knowledge and functionalities within the agent itself, a more efficient and scalable
    approach involves intelligently leveraging the appropriate tools as needed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 向工具使用的范式转变是由对许多复杂问题需要各种专业工具和资源的认识所驱动的，每个都贡献了独特的能力集。而不是试图在代理本身中封装所有必需的知识和功能，一个更有效和可扩展的方法是智能地根据需要利用适当的工具。
- en: For instance, an agent tasked with providing personalized healthcare recommendations
    could exploit tools such as medical databases, clinical decision support systems,
    and advanced diagnostic algorithms. By judiciously combining these external resources
    with its own reasoning capabilities, the agent can deliver more accurate and comprehensive
    guidance, tailored to individual patient profiles and conditions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个被分配提供个性化医疗建议的代理可以利用诸如医疗数据库、临床决策支持系统和高级诊断算法等工具。通过明智地将这些外部资源与其自身的推理能力相结合，代理可以提供更准确、更全面的指导，针对个别患者的档案和状况进行定制。
- en: The concept of tool use in intelligent agents is not limited to software-based
    tools alone. In certain domains, such as robotics and automation, agents may interact
    with physical tools, machinery, or specialized equipment to extend their capabilities
    into the physical realm. For example, a robotic agent in a manufacturing plant
    could leverage various tools and machinery to perform intricate assembly tasks,
    quality inspections, or material handling operations.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 智能代理使用工具的概念并不仅限于基于软件的工具。在某些领域，例如机器人和自动化，代理可能需要与物理工具、机械或专用设备互动，以将它们的能力扩展到物理领域。例如，在制造工厂中的机器人代理可以利用各种工具和机械来完成复杂的组装任务、质量检查或物料处理操作。
- en: Ultimately, the ability to effectively utilize external tools and resources
    is a hallmark of truly intelligent agents, capable of adapting and thriving in
    dynamic, complex environments. By going beyond the limitations of their native
    capabilities, these agents can continually evolve, leveraging the collective power
    of diverse tools and systems to achieve ambitious objectives.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，有效利用外部工具和资源的能力是真正智能代理的标志，它们能够在动态、复杂的环境中适应和繁荣。通过超越其原生能力的限制，这些代理可以不断进化，利用各种工具和系统的集体力量来实现雄心勃勃的目标。
- en: Another good example is that of a virtual travel agent that has the capability
    to access multiple APIs, databases, and software tools to plan and book complete
    travel itineraries for users. Such a travel agent could leverage APIs from airlines,
    hotels, rental car companies, and travel review sites to gather real-time data
    on flight schedules, availability, pricing, and customer ratings. It could also
    tap into databases of travel advisories, travel document requirements, and destination
    information. By integrating and reasoning over all this data from various tools,
    the agent can provide personalized recommendations, make intelligent trade-offs,
    and seamlessly book and coordinate all aspects of a trip tailored to the user’s
    preferences and constraints. Naturally, the set of tools used in such a case is
    diverse and they all operate in their unique ways.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的例子是虚拟旅行代理，它具有访问多个API、数据库和软件工具的能力，为用户规划并预订完整的旅行行程。这样的旅行代理可以利用来自航空公司、酒店、租车公司和旅行评论网站的API，收集有关航班时刻表、可用性、定价和客户评价的实时数据。它还可以访问有关旅行警告、旅行文件要求和目的地信息的数据库。通过整合并推理来自各种工具的所有这些数据，代理可以提供个性化的建议，做出明智的权衡，并无缝预订和协调所有符合用户偏好和限制的旅行方面。当然，在这种情况下使用的工具集是多样化的，并且它们都以独特的方式运行。
- en: We’ve looked at what tools are and how they work. Next, we will explore another
    critical aspect of agentic systems – planning – and some of the planning algorithms.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了工具是什么以及它们是如何工作的。接下来，我们将探讨代理系统的一个关键方面——规划——以及一些规划算法。
- en: Planning algorithms for agents
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理的规划算法
- en: Planning is a fundamental capability of intelligent agents, enabling them to
    reason about their actions and devise strategies to achieve their objectives effectively.
    Planning algorithms form the backbone of how LLM agents determine and sequence
    their actions. An algorithm is a step-by-step set of instructions or rules designed
    to solve a specific problem or complete a task. It is a sequence of unambiguous
    and finite steps that takes inputs and produces an expected output in a finite
    amount of time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 规划是智能代理的基本能力，使他们能够对其行为进行推理并制定有效实现目标的策略。规划算法构成了LLM代理确定和排序其行动的基础。算法是一系列旨在解决特定问题或完成任务的步骤或规则。它是一系列明确且有限的步骤，在有限的时间内接受输入并产生预期的输出。
- en: There are several planning algorithms in AI, each with its own strengths and
    approaches. However, when working with LLM agents, we need to consider their practicality
    in handling natural language, uncertainty, and large state spaces (all possible
    situations or configurations that an agent might encounter during its task). For
    example, in a simple robot navigation task, state spaces might include all possible
    positions and orientations, but in LLM agents, state spaces become vastly more
    complex as they include all possible conversation states, knowledge contexts,
    and potential responses.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能中有几种规划算法，每种都有自己的优势和途径。然而，当与LLM代理一起工作时，我们需要考虑它们在处理自然语言、不确定性和大状态空间（代理在其任务期间可能遇到的所有可能情况或配置）方面的实用性。例如，在简单的机器人导航任务中，状态空间可能包括所有可能的位置和方向，但在LLM代理中，状态空间变得极其复杂，因为它们包括所有可能的对话状态、知识背景和潜在响应。
- en: Among the known planning algorithms – **Stanford Research Institute Problem
    Solver** ( **STRIPS** ), **hierarchical task network** ( **HTN** ), **A* planning**
    , **Monte Carlo Tree Search** ( **MCTS** ), **GraphPlan** , **Fast Forward** (
    **FF** ), and **LLM-based planning** – they can be categorized by their practicality
    for LLM agents.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在已知的规划算法中——**斯坦福研究学院问题求解器**（**STRIPS**）、**分层任务网络**（**HTN**）、**A*规划**、**蒙特卡洛树搜索**（**MCTS**）、**GraphPlan**、**快速前进**（**FF**）和**基于LLM的规划**——可以根据它们对LLM代理的实用性进行分类。
- en: STRIPS, A* planning, GraphPlan, and MCTS, while powerful in traditional AI,
    are less practical for LLM agents due to their rigid structure and difficulty
    handling natural language. FF shows moderate potential but requires significant
    adaptation. The most practical approaches are LLM-based planning and HTN, as they
    naturally align with how language models process and decompose tasks. Let’s discuss
    them in detail.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: STRIPS、A*规划、GraphPlan和MCTS虽然在传统人工智能中功能强大，但由于其僵化的结构和处理自然语言的困难，对于LLM代理来说不太实用。FF显示出一定的潜力，但需要重大的调整。最实用的方法是基于LLM的规划和HTN，因为它们与语言模型处理和分解任务的方式自然一致。让我们详细讨论它们。
- en: Less practical planning algorithms
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 较不实用的规划算法
- en: As mentioned earlier, less practical planning algorithms include STRIPS, A*
    planning, GraphPlan, and MCTS. Here’s a detailed overview.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，较不实用的规划算法包括STRIPS、A*规划、GraphPlan和MCTS。以下是详细概述。
- en: STRIPS
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: STRIPS
- en: '**STRIPS** works with states and actions defined by logical predicates, making
    it effective for clear, binary conditions. However, it’s unsuitable for LLM agents
    because natural language interactions can’t be effectively reduced to simple **true**
    / **false** conditions. For example, while STRIPS can easily model **true** /
    **false** states, it struggles with nuanced language states such as *partially
    understanding a concept* or *somewhat satisfied with a response* , making it too
    rigid for language-based planning.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**STRIPS** 使用由逻辑谓词定义的状态和动作，使其对清晰的二元条件有效。然而，它不适合LLM代理，因为自然语言交互无法有效地简化为简单的**真**/**假**条件。例如，虽然STRIPS可以轻松地模拟**真**/**假**状态，但它难以处理细微的语言状态，如*部分理解一个概念*或*对响应有些满意*，这使得它在基于语言规划方面过于僵化。'
- en: A* planning
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A*规划
- en: '**A* planning** , while powerful for pathfinding problems, faces fundamental
    challenges with LLM agents. The algorithm requires a clear way to calculate both
    the cost of actions taken and a heuristic estimate of the remaining cost to reach
    a goal. In language-based interactions, defining these costs becomes highly problematic
    – how do you quantify the “distance” between different conversation states or
    estimate the “cost” of reaching a particular understanding? These mathematical
    requirements make A* impractical for natural language planning.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**A*规划**虽然对于路径查找问题非常强大，但在LLM智能体面前面临根本性的挑战。该算法需要一种明确的方式来计算采取行动的成本以及到达目标剩余成本的启发式估计。在基于语言的交互中，定义这些成本变得非常困难——如何量化不同对话状态之间的“距离”或估计达到特定理解的成本？这些数学要求使得A*在自然语言规划中不切实际。'
- en: GraphPlan
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GraphPlan
- en: '**GraphPlan** builds a layered graph structure representing possible actions
    and their effects at each time step. When applied to LLM agents, this approach
    breaks down because language interactions don’t fit neatly into discrete layers
    with clear cause-and-effect relationships. The combinatorial explosion of possible
    language states and the difficulty in determining mutual exclusion relationships
    between different conversational actions make GraphPlan computationally intractable
    for language-based planning.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**GraphPlan**构建了一个表示每个时间步可能行动及其效果的分层图结构。当应用于LLM智能体时，这种方法因为语言交互不适合整齐地分为具有明确因果关系离散层而失效。可能的语言状态组合爆炸和确定不同对话行动之间互斥关系的困难使得GraphPlan在基于语言的规划中计算上不可行。'
- en: MCTS
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MCTS
- en: For LLM agents, **MCTS** becomes impractical for two main reasons. First, each
    “simulation” would require actual LLM calls, making it prohibitively expensive
    in terms of computation and cost; second, the vast space of possible language
    interactions makes random sampling inefficient for finding meaningful patterns
    or strategies. The algorithm’s strength in game-like scenarios becomes a weakness
    in open-ended language interactions.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于LLM智能体来说，**MCTS**由于两个主要原因变得不切实际。首先，每一次“模拟”都需要实际的LLM调用，这在计算和成本上变得过于昂贵；其次，可能的语言交互空间巨大，随机采样对于寻找有意义的模式或策略效率低下。该算法在游戏场景中的优势在开放式的语言交互中变成了弱点。
- en: Moderately practical planning algorithm – FF
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适度实用的规划算法——FF
- en: '**FF** planning is considered to be a moderately practical planning algorithm
    that can be used in LLM agents. It uses a heuristic search with a simplified version
    of the planning problem to guide its search. Its focus on goal-oriented planning
    could be adapted for LLM agents, though it would require modifications to handle
    natural language effectively. FF planning uses heuristic search with a simplified
    version of the planning problem to guide its search.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**FF**规划被认为是一种适度实用的规划算法，可以用于LLM智能体。它使用启发式搜索和简化版的规划问题来引导搜索。它对目标导向规划的关注可以适应LLM智能体，尽管它需要修改以有效地处理自然语言。FF规划使用启发式搜索和简化版的规划问题来引导搜索。'
- en: For LLM agents, FF planning offers several compelling advantages that make it
    worth considering. Its goal-oriented approach naturally aligns with how LLMs handle
    task completion, while its relaxed planning mechanism provides useful approximations
    for complex language tasks. The heuristic guidance helps manage the vast search
    space inherent in language-based planning, and its flexibility allows modification
    to work with partial state descriptions, which is particularly valuable in natural
    language contexts.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于LLM智能体来说，FF规划提供了几个令人信服的优势，使其值得考虑。其以目标为导向的方法自然地与LLM处理任务完成的方式相一致，同时其宽松的规划机制为复杂语言任务提供了有用的近似。启发式指导有助于管理基于语言规划的固有庞大搜索空间，其灵活性允许对部分状态描述进行修改，这在自然语言环境中尤其有价值。
- en: 'However, FF planning also faces significant challenges when applied to LLM
    agents. The original numeric heuristics that make FF effective in traditional
    planning don’t translate smoothly to language states, and relaxed plans risk oversimplifying
    the rich context present in language interactions. There’s also considerable difficulty
    in defining clear delete effects – what aspects of a conversation state are removed
    or changed by an action – in language-based planning. Perhaps most challengingly,
    the fundamental state representation requires substantial adaptation to work effectively
    with natural language. In practice, FF could be adapted for LLM agents as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当将FF规划应用于LLM代理时，也面临着重大的挑战。使FF在传统规划中有效的原始数值启发式方法在语言状态中无法顺利转换，并且放宽的计划可能会过度简化语言交互中存在的丰富上下文。在基于语言的规划中，定义清晰的删除效果——动作如何删除或改变会话状态中的哪些方面——也存在相当大的困难。也许最具挑战性的是，基本状态表示需要大量调整才能有效地与自然语言一起工作。在实践中，FF可以按以下方式为LLM代理进行适配：
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This code demonstrates a simplified adaptation of FF planning for LLM agents.
    Let me explain its key components. The **LLMFastForward** class has two main methods:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了FF规划对LLM代理的简化适配。让我解释其关键组件。**LLMFastForward**类有两个主要方法：
- en: '**create_relaxed_plan** : This method takes the current state and goal as text
    strings and uses an LLM to generate a simplified plan. Think of it as asking the
    LLM, “ *Given where we are now, and where we want to go, what are the main steps
    we should take?* ”. It ignores many complexities, similar to how traditional FF
    planning ignores delete effects.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**create_relaxed_plan**：此方法将当前状态和目标作为文本字符串，并使用LLM生成一个简化计划。想象一下，这是向LLM提问：“*鉴于我们现在在哪里，以及我们想去哪里，我们应该采取哪些主要步骤？*”。它忽略了许多复杂性，类似于传统FF规划忽略删除效果的方式。'
- en: '**select_next_action** : This method chooses the next action from the relaxed
    plan. In this simplified version, it just takes the first action from the plan
    ( **relaxed_plan[0]** ). In a more sophisticated implementation, it would use
    additional logic to select the most appropriate next action.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**select_next_action**：此方法从放宽计划中选择下一个动作。在这个简化版本中，它只是从计划中取出第一个动作（**relaxed_plan[0]**）。在更复杂的实现中，它将使用额外的逻辑来选择最合适的下一个动作。'
- en: In essence, this code shows how FF planning’s core concept of using simplified
    plans to guide decision-making can be adapted to work with language models, even
    though it’s a significant simplification of both FF planning and LLM capabilities.
    While this adaptation shows potential, implementing FF for LLM agents requires
    careful consideration of how to represent states, actions, and relaxed problems
    in a language-model context. This makes it moderately practical – possible but
    requiring significant modifications from its original form.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，这段代码展示了FF规划的核心概念，即使用简化计划来指导决策，如何适应与语言模型一起工作，尽管这显著简化了FF规划和LLM能力。虽然这种适应显示出潜力，但为LLM代理实现FF规划需要仔细考虑如何在语言模型环境中表示状态、动作和放宽问题。这使得它在实际应用中具有一定的实用性——可能但需要对其原始形式进行重大修改。
- en: Most practical planning algorithms
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大多数实用的规划算法
- en: 'When it comes to planning algorithms for LLM agents, two approaches stand out
    as particularly effective: LLM-based planning and HTN planning. These algorithms
    have proven especially suitable for language models because they naturally align
    with how LLMs process information and handle complex tasks. While traditional
    planning algorithms often struggle with the ambiguity and complexity of natural
    language, these approaches embrace the fluid, contextual nature of language-based
    planning. Let’s explore each of these algorithms and understand why they’ve become
    the preferred choices for modern AI agent frameworks.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到LLM代理的规划算法时，两种方法特别有效：基于LLM的规划和HTN规划。这些算法已被证明特别适合语言模型，因为它们自然地与LLM处理信息和处理复杂任务的方式相一致。虽然传统的规划算法往往难以处理自然语言的模糊性和复杂性，但这些方法接受了基于语言规划的流动性和上下文性质。让我们探索这些算法，并了解为什么它们已成为现代AI代理框架的首选选择。
- en: LLM-based planning
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于LLM的规划
- en: 'Modern approaches leverage LLMs to generate plans in a more flexible and natural
    way. This approach can handle complex, real-world scenarios and understand context
    better than traditional planning algorithms. LLM-based planning operates on the
    principle that language models can understand complex goals, generate appropriate
    steps to achieve them, and adapt these steps based on changing contexts. Unlike
    traditional planners that require explicit state representations, LLM planners
    work with natural language descriptions of states and actions, making them inherently
    more flexible and expressive. Let’s visualize the planning process using *Figure
    5* *.3* :'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现代方法利用大型语言模型（LLMs）以更灵活和自然的方式生成计划。这种方法可以处理复杂、现实世界的场景，并且比传统的规划算法更好地理解上下文。基于LLM的规划基于这样一个原则：语言模型可以理解复杂的目标，生成实现这些目标的适当步骤，并根据不断变化的环境调整这些步骤。与传统规划器需要显式状态表示不同，LLM规划器使用自然语言描述状态和动作，这使得它们本质上更加灵活和表达性强。让我们通过*图5.3*来可视化规划过程：
- en: '![img](img/B31483_05_03.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31483_05_03.jpg)'
- en: Figure 5.3 – LLM-based planning algorithm flow
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 基于LLM的规划算法流程
- en: 'Let’s examine a practical implementation using CrewAI that demonstrates this
    planning approach. In this example, we’ll create a travel planning system with
    two specialized agents: a *Travel Planning Strategist* who breaks down travel
    requests into manageable steps, and a *Travel Researcher* who validates and finds
    specific options. The system processes natural language travel requests and generates
    comprehensive travel plans through collaborative agent interaction. Here’s the
    implementation:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用CrewAI的实际实现来检验这种规划方法。在这个例子中，我们将创建一个包含两个专业代理的旅行规划系统：一个*旅行规划策略师*，它将旅行请求分解为可管理的步骤，以及一个*旅行研究员*，它验证并找到特定的选项。系统通过协同代理交互处理自然语言旅行请求，并生成全面的旅行计划。以下是实现方式：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This implementation demonstrates several key advantages of LLM-based planning.
    The planner can understand complex natural language requests, dynamically generate
    appropriate steps, and adapt to different types of travel planning scenarios.
    The agents can work together, sharing context and building upon each other’s outputs.
    The system’s sophistication comes from its ability to handle nuanced requirements.
    For instance, when a user requests “ *a relaxing beach vacation with some cultural
    activities* ,” the planner understands these abstract concepts and can translate
    them into concrete recommendations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现展示了基于LLM的规划的关键优势。规划器可以理解复杂的自然语言请求，动态生成适当的步骤，并适应不同类型的旅行规划场景。代理可以协同工作，共享上下文并建立在彼此的输出之上。系统的复杂性来自于其处理细微要求的能力。例如，当用户请求“*一个放松的海滩度假，附带一些文化活动*”时，规划器理解这些抽象概念，并将它们转化为具体的建议。
- en: However, developers should be mindful of certain caveats. LLM-based planning
    systems can sometimes generate overly optimistic or impractical plans if not properly
    constrained. They may also struggle with highly specific numerical constraints
    or strict timing requirements unless these are explicitly handled in the implementation.
    A significant advantage of LLM-based planning over traditional algorithms lies
    in the system’s adaptability. While STRIPS or A* planning would require explicit
    state representations for every possible travel scenario, LLM-based planning can
    handle novel situations by leveraging its understanding of language and context.
    This makes it particularly suitable for domains where requirements are often ambiguous
    or evolving. This planning approach also excels at handling uncertainty and partial
    information, something traditional planners struggle with. When information is
    missing or ambiguous, the system can generate reasonable assumptions and include
    contingency steps in its plans.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，开发者应该注意某些注意事项。如果未适当约束，基于LLM的规划系统有时可能会生成过于乐观或不切实际的计划。除非在实现中明确处理，否则它们可能难以处理高度具体的数值约束或严格的时序要求。与传统的算法相比，基于LLM的规划的一个显著优势在于系统的适应性。虽然STRIPS或A*规划需要为每个可能的旅行场景提供显式状态表示，但基于LLM的规划可以通过利用其对语言和上下文的理解来处理新情况。这使得它特别适合那些要求通常模糊或不断变化的应用领域。这种规划方法在处理不确定性和部分信息方面也表现出色，这是传统规划器难以处理的。当信息缺失或模糊时，系统可以生成合理的假设，并在其计划中包括应急步骤。
- en: HTN
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTN
- en: '**HTN** planning breaks down complex tasks into simpler subtasks, creating
    a hierarchy of actions. Unlike STRIPS, which works with primitive actions, HTN
    can work with abstract tasks and decompose them into more concrete steps. This
    makes it particularly well-suited for real-world planning problems where tasks
    naturally decompose into subtasks. HTN planning works by breaking down high-level
    tasks into progressively smaller subtasks. Consider the following example code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTN** 规划将复杂任务分解为更简单的子任务，创建一个动作的层次结构。与使用原始动作的 STRIPS 不同，HTN 可以处理抽象任务并将它们分解为更具体的步骤。这使得它特别适合于现实世界的规划问题，其中任务自然分解为子任务。HTN
    规划通过将高级任务分解为越来越小的子任务来工作。考虑以下示例代码：'
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'HTN planning operates on the principle of task decomposition, where high-level
    tasks (compound tasks) are broken down into smaller, more manageable subtasks
    until reaching primitive tasks that can be directly executed. This hierarchical
    structure allows for intuitive problem representation and efficient solution finding.
    In our example, **buy_groceries_task** is a high-level task broken down into four
    subtasks. One of these subtasks, **select_items** , is further decomposed into
    three more specific actions, and so on. In the context of our travel agent example,
    we can use a similar hierarchical breakdown of complex tasks decomposed into smaller
    tasks. Visually, *Figure 5* *.4* shows how this may look:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: HTN 规划基于任务分解的原则，其中高级任务（复合任务）被分解为更小、更易于管理的子任务，直到达到可以直接执行的原始任务。这种层次结构允许直观地表示问题和高效地找到解决方案。在我们的例子中，**buy_groceries_task**
    是一个高级任务，分解为四个子任务。其中这些子任务之一，**select_items**，进一步分解为三个更具体的行为，依此类推。在我们的旅行代理示例中，我们可以使用类似的方法将复杂任务分解为更小的任务。从视觉上看，*图
    5.4* 显示了这可能看起来是什么样子：
- en: '![img](img/B31483_05_04.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31483_05_04.jpg)'
- en: Figure 5.4 – HTN decomposition
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – HTN 分解
- en: 'To implement this with CrewAI, we can use CrewAI’s *hierarchical* processing,
    where tasks are broken down into a hierarchical manner as explained using the
    HTN planning algorithm. With the CrewAI framework, the hierarchical method requires
    a m **anager** unit, which would be responsible for breaking down the tasks and
    *delegating* individual tasks to the agents. The Manager can either be an agent
    or it can be the LLM itself. If the Manager is an agent, then you can control
    how the manager breaks down the tasks to *n* -level tasks as per the workflow’s
    needs. If the Manager is an LLM, then it will use the arbitrary plan generated
    by the LLM itself based on the user’s query. With a Manager LLM, you may be able
    to control how the task breakdown works and how the delegation works using some
    prompt engineering; however, it is generally less flexible and is meant for simpler
    workflows. Here’s a sample code for an HTN-like workflow for the travel planner:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 CrewAI 实现这一点，我们可以使用 CrewAI 的 *分层* 处理，其中任务以 HTN 规划算法中解释的方式分层分解。在 CrewAI 框架中，分层方法需要一个
    **管理器** 单元，该单元将负责分解任务并将单个任务 *委派* 给代理。管理器可以是代理，也可以是 LLM 本身。如果管理器是代理，那么您可以控制管理器如何根据工作流程的需求将任务分解为
    *n* 级任务。如果管理器是 LLM，那么它将使用 LLM 根据用户的查询生成的任意计划。使用管理器 LLM，您可能能够通过一些提示工程来控制任务分解和委派的方式；然而，它通常不太灵活，适用于更简单的工作流程。以下是为旅行规划器提供的类似
    HTN 的工作流程的示例代码：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output of this execution may look as shown (output has been trimmed for
    brevity):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此执行的输出可能看起来如下（输出已缩减以节省空间）：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that, in this case, the agentic system has no access to external tools
    or lookup, so whatever response it generates is going to be completely fictional
    and non-factual. This underscores the importance of tools, which we will look
    at in the next section. For now, the previous example shows how you can use the
    framework for task breakdown and have a Manager manage several agents to perform
    decomposed simplified tasks from a user’s request. You can see the full code in
    the Python notebook ( **Chapter_05.ipynb** ) in the GitHub repository.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，代理系统无法访问外部工具或查找，因此它生成的任何响应都将完全是虚构的和非事实性的。这强调了工具的重要性，我们将在下一节中探讨。目前，前面的例子展示了如何使用框架进行任务分解，并让管理器管理多个代理执行从用户请求分解的简化任务。您可以在
    GitHub 仓库中的 Python 笔记本（**Chapter_05.ipynb**）中看到完整的代码。
- en: HTN planning offers several significant advantages that make it particularly
    effective for complex planning scenarios. Its natural problem representation mirrors
    human thinking patterns, making it intuitive to understand and maintain. The hierarchical
    approach enables better scalability by breaking down complex problems into manageable
    subtasks, effectively reducing the search space. HTN’s structure excels at encoding
    expert knowledge through its task hierarchies, allowing for reusable patterns
    across similar problems. Additionally, its flexibility in handling both abstract
    and primitive tasks makes it adaptable to various planning situations, enabling
    planners to work at different levels of abstraction as needed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: HTN规划提供了几个显著的优点，使其特别适用于复杂的规划场景。它自然的问题表示与人类思维模式相呼应，使得理解和维护变得直观。分层方法通过将复杂问题分解为可管理的子任务，从而提高了可扩展性，有效地减少了搜索空间。HTN的结构在通过任务层次结构编码专家知识方面表现出色，允许在类似问题之间重用模式。此外，它在处理抽象和原始任务方面的灵活性使其能够适应各种规划情况，使规划者能够根据需要在不同抽象级别上工作。
- en: So far, we’ve learned about tools and several planning algorithms, but together
    they can enable LLM agents to perform more complex, multi-step tasks by combining
    strategic planning with effective tool use. Let’s further explore how we can effectively
    integrate tool use with planning within agentic systems.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了工具和几种规划算法，但将战略规划与有效工具使用相结合，它们可以使得LLM智能体执行更复杂、多步骤的任务。让我们进一步探讨如何在智能体系统中有效地整合工具使用与规划。
- en: Integrating tool use and planning
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整合工具使用与规划
- en: Most of the earlier work in AI planning and tool usage was done in isolation,
    focusing on either planning algorithms or tool capabilities separately. However,
    to achieve truly intelligent agents, there is a need to integrate tool use with
    planning effectively. As we already saw in the previous section, our travel planner
    gave us a detailed travel plan but none of the details were factual – that is,
    it contained information that the LLM simply made up. In order to infuse our system
    with actual flight, hotel, and activity data so that the travel plan is grounded
    in facts, we will need to utilize tools along with the planning algorithm. This
    section will discuss how to combine these two aspects to generate relevant responses
    and complete tasks accurately.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在人工智能规划和工具使用方面的大部分早期工作都是独立进行的，分别关注规划算法或工具能力。然而，为了实现真正智能的智能体，需要有效地整合工具使用与规划。正如我们在上一节中已经看到的，我们的旅行规划器为我们提供了一个详细的旅行计划，但没有一个细节是真实的——也就是说，它包含了LLM随意编造的信息。为了使我们的系统注入实际的航班、酒店和活动数据，从而使旅行计划建立在事实基础上，我们需要利用工具以及规划算法。本节将讨论如何结合这两个方面来生成相关响应并准确完成任务。
- en: Reasoning about tools
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具推理
- en: Agents need the ability to reason about the available tools at their disposal,
    understanding the functionality, capabilities, and limitations of each tool, as
    well as the contexts and conditions under which they can be applied effectively.
    The reasoning process involves assessing the available tools based on the current
    goals and objectives, and then choosing the most appropriate ones that can be
    utilized in the given situation or problem domain.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 智能体需要具备对可用的工具进行推理的能力，理解每个工具的功能、能力和局限性，以及它们可以有效地应用的环境和条件。推理过程涉及根据当前目标和目标评估可用的工具，然后选择在给定情况或问题域中可以使用的最合适的工具。
- en: For example, in the case of our travel planner, the agent will have access to
    various tools such as flight booking APIs, hotel reservation systems, and activity
    planning software. The agent needs to reason about the capabilities of each tool,
    such as which tools can be used for booking flights or book hotels, and which
    ones can provide information about local attractions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的旅行规划器案例中，智能体将能够访问各种工具，如航班预订API、酒店预订系统以及活动规划软件。智能体需要推理每个工具的能力，例如哪些工具可以用于预订航班或预订酒店，以及哪些可以提供关于当地景点的信息。
- en: 'When working with LLM agents, reasoning about tools is largely handled by the
    language model’s inherent capabilities. Modern LLMs are trained to understand
    tool descriptions, purposes, and appropriate usage contexts. This means we don’t
    need to explicitly program complex reasoning mechanisms – instead, we provide
    clear tool descriptions and let the LLM determine when and how to use them. For
    example, let’s look at our travel planner agent scenario:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当与LLM代理一起工作时，关于工具的推理主要是由语言模型固有的能力处理的。现代LLM被训练来理解工具描述、目的和适当的用法上下文。这意味着我们不需要明确编程复杂的推理机制——相反，我们提供清晰的工具描述，让LLM决定何时以及如何使用它们。例如，让我们看看我们的旅行规划代理场景：
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The LLM agent can naturally understand the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: LLM代理可以自然理解以下内容：
- en: Which tool to use for each task (for example, **flight_search_tool** for air
    travel)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每项任务使用哪个工具（例如，**flight_search_tool** 用于航空旅行）
- en: When to use tools in combination (for example, coordinating flight and hotel
    dates)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时组合使用工具（例如，协调航班和酒店日期）
- en: How to adapt tool usage based on user requirements (for example, budget constraints)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何根据用户需求（例如，预算限制）调整工具使用
- en: 'This built-in reasoning capability means we can focus on providing well-defined
    tools with clear descriptions, rather than implementing complex reasoning mechanisms.
    The LLM will handle the decision-making process of tool selection and application
    based on the context and requirements of each situation. However, not all language
    models are equally capable of effective tool reasoning. This capability typically
    requires models that have been specifically trained or fine-tuned for tool use
    and function calling. Smaller models or those without tool-use training may have
    the following issues:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这种内置的推理能力意味着我们可以专注于提供定义明确的工具和清晰的描述，而不是实现复杂的推理机制。LLM将根据每个情境的上下文和要求处理工具选择和应用的决策过程。然而，并非所有语言模型都同样擅长有效的工具推理。这种能力通常需要经过专门训练或微调以用于工具使用和功能调用的模型。较小的模型或未进行工具使用训练的模型可能存在以下问题：
- en: Failing to understand when a tool is needed
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未能理解何时需要使用工具
- en: Making incorrect assumptions about tool capabilities
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对工具能力做出错误的假设
- en: Using tools in the wrong sequences
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误地使用工具的顺序
- en: Missing opportunities to use available tools
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错过使用可用工具的机会
- en: Ignoring tool constraints or requirements
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略工具约束或要求
- en: 'Even capable models can face limitations such as the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是能力较强的模型也可能面临以下限制：
- en: Difficulty with complex tool combinations requiring many steps
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂工具组合的步骤繁多带来的困难
- en: Inconsistency in tool selection across similar scenarios
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类似场景中工具选择的矛盾性
- en: Challenges with tools that have subtle differences in functionality
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能上有细微差别的工具带来的挑战
- en: Struggles with error recovery when tools fail
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具失效时的错误恢复问题
- en: This is why frameworks such as CrewAI, LangGraph, and AutoGen often work best
    with more advanced models that have demonstrated strong tool reasoning capabilities,
    and why it’s important to test your agent’s tool usage patterns before deployment.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么CrewAI、LangGraph和AutoGen等框架通常与具有强大工具推理能力的更高级模型配合得最好，以及为什么在部署前测试代理的工具使用模式很重要。
- en: Planning for tool use
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具使用的规划
- en: 'The planning process in modern AI agents is fundamentally driven by LLM capabilities,
    building upon the principles we discussed in LLM-based planning and HTN approaches.
    Rather than following rigid planning algorithms, agents leverage their language
    model’s understanding to create flexible, context-aware plans for tool usage.
    *Figure 5* *.5* depicts this process:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现代人工智能代理的规划过程从根本上是由大型语言模型（LLM）的能力驱动的，这些能力基于我们在基于LLM的规划和HTN方法中讨论的原则。代理不是遵循严格的规划算法，而是利用其语言模型的理解来创建灵活的、上下文感知的工具使用计划。*图
    5.5* 描述了这一过程：
- en: '![img](img/B31483_05_05.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31483_05_05.jpg)'
- en: Figure 5.5 – Tool planning flow
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 工具规划流程
- en: When an agent receives a request, it first understands the goals through natural
    language processing. For a travel agent, this might mean comprehending that a
    family vacation request requires not just flight bookings but also family-friendly
    accommodation and activities. This goal-understanding phase draws directly from
    the LLM’s trained comprehension abilities.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当代理收到请求时，它首先通过自然语言处理理解目标。对于一个旅行代理来说，这可能意味着理解家庭度假请求不仅需要航班预订，还需要适合家庭的住宿和活动。这一目标理解阶段直接来源于LLM的训练理解能力。
- en: The planning process then shifts to identifying which tools are needed and in
    what sequence they should be used. This mirrors the hierarchical decomposition
    we saw in HTN planning but with the flexibility of LLM-based decision-making.
    The agent doesn’t just follow predefined decomposition rules; it adapts its planning
    based on the specific context and requirements of each request.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，规划过程转向确定所需的工具及其使用顺序。这类似于我们在HTN规划中看到的分层分解，但具有基于LLM决策的灵活性。代理不仅遵循预定义的分解规则，而且根据每个请求的具体情境和要求调整其规划。
- en: Tool integration into the plan happens naturally as part of this process. The
    agent understands tool capabilities through their descriptions and can sequence
    them appropriately. For instance, when planning a vacation, the agent knows that
    flight dates need to be confirmed before booking hotels, and that activity planning
    should consider the location and timing of both.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 工具集成到计划中是作为此过程自然发生的一部分。代理通过其描述了解工具的能力，并可以适当地对它们进行排序。例如，在规划假期时，代理知道在预订酒店之前需要确认航班日期，并且活动规划应考虑地点和时间。
- en: This planning approach combines the structured nature of traditional planning
    algorithms with the adaptability of language models. The agent can adjust its
    plans based on new information or changing circumstances, much like a human travel
    agent would modify their approach based on client feedback or availability changes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这种规划方法结合了传统规划算法的结构化特性与语言模型的可适应性。代理可以根据新信息或变化的情况调整其计划，就像一个旅行代理根据客户反馈或可用性变化修改其方法一样。
- en: The success of this planning process relies heavily on the LLM’s ability to
    understand context and generate appropriate sequences of actions. This is why
    frameworks such as CrewAI often implement this type of planning, allowing agents
    to leverage their language understanding capabilities while maintaining the systematic
    approach needed for complex task completion.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此规划过程的成功在很大程度上依赖于LLM理解情境并生成适当动作序列的能力。这就是为什么CrewAI等框架通常实现此类规划，允许代理利用其语言理解能力，同时保持完成复杂任务所需的系统方法。
- en: Exploring practical implementations
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索实际实施
- en: To demonstrate how various AI/ML frameworks can be used to create intelligent
    agents capable of executing complex tasks through tool use and planning, let’s
    explore examples using CrewAI, AutoGen, and LangGraph (the agentic framework of
    LangChain). You can find the full code for each of the framework examples in the
    **Chapter_05.ipynb** Python notebook in the GitHub repository.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示如何使用各种AI/ML框架创建能够通过工具使用和规划执行复杂任务的智能代理，让我们通过使用CrewAI、AutoGen和LangGraph（LangChain的代理框架）的示例来探索。您可以在GitHub仓库中找到每个框架示例的完整代码，位于**Chapter_05.ipynb**
    Python笔记本中。
- en: CrewAI example
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CrewAI示例
- en: 'Let’s examine how CrewAI implements tool-based reasoning through a practical
    travel planning example. The framework’s Python library provides a **@tool** decorator
    that allows us to define tools with clear descriptions and documentation. Here’s
    how we can create a set of travel-related tools:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个实际的旅行规划示例来考察CrewAI如何通过工具推理实现。该框架的Python库提供了一个**@tool**装饰器，允许我们定义具有清晰描述和文档的工具。以下是我们可以创建一组与旅行相关的工具的方法：
- en: '[PRE12]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The tools are then assigned to an agent that understands how to use them in
    context. The agent is created with a specific role, goal, and backstory that helps
    guide its decision-making:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 工具随后被分配给一个理解如何在特定情境中使用它们的代理。代理被创建时具有特定的角色、目标和背景故事，这些有助于指导其决策过程：
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When given a task, the agent uses these tools based on the context and requirements:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当分配任务时，代理根据情境和要求使用这些工具：
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When **crew.kickoff()** is called, CrewAI orchestrates the tool usage in the
    following ways:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用**crew.kickoff()**时，CrewAI以以下方式协调工具的使用：
- en: Understanding the task requirements through the task description
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过任务描述理解任务要求
- en: Identifying which tools are needed based on the agent’s role and the task goals
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据代理的角色和任务目标确定所需的工具
- en: Using the tools in a logical sequence to build the travel plan
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用逻辑顺序的工具构建旅行计划
- en: Processing tool outputs and incorporating them into the final response
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理工具输出并将它们纳入最终响应
- en: This implementation demonstrates how CrewAI combines tool definitions, agent
    capabilities, and task specifications to create a coherent planning system. The
    framework handles the complexity of tool reasoning while allowing developers to
    focus on defining clear tool interfaces and agent behaviors.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现展示了CrewAI如何结合工具定义、代理能力和任务规范来创建一个连贯的规划系统。该框架处理工具推理的复杂性，同时允许开发者专注于定义清晰的工具接口和代理行为。
- en: AutoGen example
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AutoGen示例
- en: 'AutoGen provides a platform for developing AI agents that can engage in conversations
    and, through these interactions, arrive at solutions for given tasks. AutoGen
    approaches multi-agent collaboration through a RoundRobinGroupChat system where
    specialized agents interact to create a comprehensive travel plan. The implementation
    defines four key agents: a flight planner, a hotel planner, an activities planner,
    and a summary agent, each with specific responsibilities and tools.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: AutoGen提供了一个平台，用于开发能够参与对话并通过对这些交互的AI代理，为给定任务找到解决方案。AutoGen通过循环轮询群聊系统来处理多代理协作，其中专业代理互动以创建全面的旅行计划。该实现定义了四个关键代理：一个航班规划者、一个酒店规划者、一个活动规划者和一个总结代理，每个代理都有特定的职责和工具。
- en: 'Each agent is initialized with the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 每个代理初始化时具有以下内容：
- en: A name and description
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名称和描述
- en: A model client (in this case, OpenAI’s GPT-4o-mini)
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个模型客户端（在这种情况下，OpenAI的GPT-4o-mini）
- en: Specific tools they can access
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们可以访问的特定工具
- en: A system message defining their role and responsibilities
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义他们角色和职责的系统消息
- en: 'The key differentiators from CrewAI lie in the execution model:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 与CrewAI的关键区别在于执行模型：
- en: '**Agent communication** : While CrewAI uses a hierarchical task-based approach,
    AutoGen implements a round-robin group chat where agents take turns contributing
    to the solution. The **RoundRobinGroupChat** class orchestrates this conversation
    flow, allowing agents to build upon each other’s suggestions.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理通信**：虽然CrewAI使用基于任务的分层方法，但AutoGen实现了一个循环轮询群聊，其中代理轮流贡献解决方案。**RoundRobinGroupChat**类协调这种对话流程，允许代理基于彼此的建议进行构建。'
- en: '**Termination handling** : AutoGen uses an explicit termination condition through
    the **TextMentionTermination** class. The travel summary agent can end the conversation
    by mentioning **"TERMINATE"** when a complete plan is ready. This differs from
    CrewAI’s task-completion-based termination. Here are the parameters of **TextMentionTermination**
    :'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终止处理**：AutoGen通过**TextMentionTermination**类使用显式的终止条件。当完成完整的计划时，旅行总结代理可以通过提及**"TERMINATE"**来结束对话。这与CrewAI基于任务完成的终止不同。以下是**TextMentionTermination**的参数：'
- en: '**mention_text(str)** : The keyword or phrase that triggers termination ( e.g.,
    **"TERMINATE"** )'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mention_text(str)**：触发终止的关键词或短语（例如，**"TERMINATE"**）'
- en: '**case_sensitive (bool, optional)** : Whether the keyword matching should be
    case-sensitive'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**case_sensitive (bool, optional)**：关键词匹配是否应区分大小写'
- en: '**strip_whitespace (bool, optional)** : Whether to ignore leading/trailing
    spaces in the detected text'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**strip_whitespace (bool, optional)**：是否忽略检测到的文本中的前导/尾随空格'
- en: '**regex_match (bool, optional)** : Allows for using regular expressions for
    more flexible termination triggers'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**regex_match (bool, optional)**：允许使用正则表达式进行更灵活的终止触发'
- en: '**Tool integration** : Instead of CrewAI’s decorator-based tool definition,
    AutoGen associates tools directly with agents during initialization. Each agent
    has access to specific tools relevant to their role.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具集成**：与CrewAI基于装饰器的工具定义不同，AutoGen在初始化期间直接将工具与代理关联。每个代理都可以访问与其角色相关的特定工具。'
- en: '**Coordination pattern** : While CrewAI often uses a manager-worker pattern,
    AutoGen’s round-robin approach creates a more collaborative environment where
    agents contribute equally to the solution, with the summary agent responsible
    for creating the final integrated plan.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协调模式**：虽然CrewAI经常使用管理者-工人模式，但AutoGen的循环轮询方法创造了一个更具协作性的环境，其中代理平等地贡献于解决方案，总结代理负责创建最终的综合计划。'
- en: 'This implementation showcases AutoGen’s strength in handling complex multi-agent
    conversations while maintaining clear role separation and specialized tool usage
    for each agent. The following is how you define agents with AutoGen:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现展示了AutoGen在处理复杂的多代理对话的同时，保持清晰的职责分离和每个代理的专业工具使用的优势。以下是如何使用AutoGen定义代理：
- en: '[PRE15]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once agents are defined, a **RoundRobinGroupChat** class can be defined using
    the agents and a conversation with the multi-agent system can be invoked:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了代理，就可以使用代理和与多代理系统的对话来定义**RoundRobinGroupChat**类：
- en: '[PRE16]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: LangGraph example
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LangGraph示例
- en: LangChain provides a framework for developing applications that can leverage
    LLMs alongside other tools and data sources. In the context of agentic systems,
    LangChain provides a sub-framework known as LangGraph that is used to build powerful
    LLM agent-based workflows. LangGraph approaches agent-based travel planning through
    a workflow graph system, offering a different paradigm from both CrewAI and AutoGen.
    Let’s examine how this implementation works and its distinguishing characteristics.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: LangChain提供了一个框架，用于开发能够利用LLMs（大型语言模型）以及其他工具和数据源的应用程序。在代理系统的背景下，LangChain提供了一个名为LangGraph的子框架，用于构建基于LLM的强大工作流程。LangGraph通过工作流程图系统来处理基于代理的旅行规划，提供了与CrewAI和AutoGen不同的范式。让我们来探讨这种实现的工作原理及其独特的特点。
- en: 'LangGraph uses a state machine approach where the workflow is defined as a
    graph with nodes and edges. The implementation centers around two main nodes:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: LangGraph采用状态机方法，其中工作流程被定义为具有节点和边的图。实现主要集中在两个主要节点上：
- en: An agent node that processes messages and makes decisions
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个处理消息并做出决策的代理节点
- en: A tool node that executes the requested tools (flight search, hotel booking,
    and activity planning)
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行请求的工具（航班搜索、酒店预订和活动规划）的工具节点
- en: 'The workflow follows a cycle where the agent node evaluates the current state
    and either makes tool calls or provides a final response. This is controlled through
    a function that interprets the model’s next move (that is, call a tool or end
    the response), which determines whether to route to the tools node or end the
    conversation. Just like CrewAI, LangGraph also uses the **@tool** decorator (for
    Python) with which the tool functions can be defined:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程遵循一个循环，其中代理节点评估当前状态，并决定是调用工具还是提供最终响应。这是通过一个解释模型下一步动作（即调用工具或结束响应）的函数来控制的，该函数确定是否路由到工具节点或结束对话。就像CrewAI一样，LangGraph也使用（Python中的）**@tool**装饰器，通过它可以定义工具函数：
- en: '[PRE17]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once nodes are defined with or without tools, they can be connected to each
    other to build a full graph structure of the workflow. For example, in our case,
    the following code defines a state graph-based workflow using LangGraph, where
    a task cycles between two nodes: agent and tools. The graph starts at the agent
    node (defined as the entry point), which calls a function ( **call_model** ) to
    process input. After the agent runs, a conditional function ( **should_continue**
    ) determines the next node – either looping back to the tools node or ending the
    workflow. The tools node ( **tool_node** ) processes intermediate tasks and always
    transitions back to the **agent** node, creating a repetitive cycle until the
    conditional function decides to stop. A **MemorySaver** checkpoint is used to
    persist the state across runs, and the graph is compiled into a LangChain-compatible
    runnable. Finally, the workflow is invoked with an initial input message about
    planning a trip, and the final message content is printed after the graph execution
    concludes:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了带有或没有工具的节点，它们就可以相互连接，构建工作流程的完整图结构。例如，在我们的案例中，以下代码使用LangGraph定义了一个基于状态图的流程，其中任务在代理节点和工具节点之间循环：代理节点调用一个函数（**call_model**）来处理输入。代理运行后，一个条件函数（**should_continue**）确定下一个节点——要么循环回工具节点，要么结束工作流程。工具节点（**tool_node**）处理中间任务，并始终过渡回**代理**节点，创建一个重复循环，直到条件函数决定停止。使用**MemorySaver**检查点来持久化状态，并将图编译成LangChain兼容的可运行版本。最后，使用关于规划旅行的初始输入消息调用工作流程，并在图执行结束后打印最终消息内容：
- en: '[PRE18]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: LangGraph’s approach offers several notable advantages. For example, its graph
    structure provides explicit flow control, making workflows easy to visualize and
    understand, while built-in state management with checkpointing capabilities ensures
    robust handling of the application state. However, these benefits come with certain
    trade-offs. The framework requires a solid understanding of graph-based programming
    concepts, and its initial setup involves more overhead compared to CrewAI’s more
    straightforward agent definition. The full code implementation can be found in
    the **Chapter_05.ipynb** Python notebook in the GitHub repository.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: LangGraph的方法提供了几个显著的优点。例如，其图结构提供了明确的流程控制，使得工作流程易于可视化和理解，而内置的状态管理以及检查点功能确保了对应用程序状态的稳健处理。然而，这些好处也伴随着某些权衡。该框架需要深入了解基于图编程的概念，并且其初始设置比CrewAI更直接的代理定义涉及更多的开销。完整的代码实现可以在GitHub仓库中的**Chapter_05.ipynb**
    Python笔记本中找到。
- en: '*Table 5.1* illustrates some key differences between LangGraph, CrewAI, and
    AutoGen:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 5.1* 展示了 LangGraph、CrewAI 和 AutoGen 之间的一些关键差异：'
- en: '|  | **LangGraph** | **CrewAI** | **AutoGen** |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '|  | **LangGraph** | **CrewAI** | **AutoGen** |'
- en: '| State management | Uses explicit state management | Manages state through
    agent instances and their task context | Handles state through group chat message
    history |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 状态管理 | 使用显式状态管理 | 通过代理实例及其任务上下文管理状态 | 通过群聊消息历史记录处理状态 |'
- en: '| Tool integration | Tools are managed through a dedicated tool node | Uses
    a decorator-based tool definition with direct agent association | Associates tools
    directly with specific agents |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 工具集成 | 通过专用工具节点管理工具 | 使用基于装饰器的工具定义，直接关联代理 | 将工具直接关联到特定代理 |'
- en: '| Flow control | Uses a graph-based workflow | Uses hierarchical task decomposition
    or sequential flow | Implements round-robin turn-taking between agents |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 流程控制 | 使用基于图的流程控制 | 使用分层任务分解或顺序流程 | 实现代理之间的循环轮询轮流 |'
- en: Table 5.1 – Comparison of LangGraph, CrewAI, and AutoGen implementation approaches
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1 – LangGraph、CrewAI 和 AutoGen 实现方法的比较
- en: The preceding table shows the differences between LangGraph, CrewAI, and AutoGen
    based on our implementation.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表格展示了 LangGraph、CrewAI 和 AutoGen 在我们的实现中的差异。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the crucial role of tools and planning in
    AI agent systems. We discussed what tool/function calling is and how LLM agents
    exhibit this property. We also learned about various tool types and saw examples
    of how to use tools with frameworks or natively with an LLM. Subsequently, we
    explored various planning algorithms, from traditional approaches such as STRIPS
    and HTN to modern LLM-based planning methods, understanding their relative practicality
    in the context of language models. Through a practical travel planning example,
    we saw how tools can be defined, integrated, and utilized within each framework
    to create sophisticated planning systems.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了工具和规划在 AI 代理系统中的关键作用。我们讨论了工具/函数调用的概念以及 LLM 代理如何表现出这种特性。我们还了解了各种工具类型，并看到了如何使用框架或原生方式与
    LLM 一起使用工具的示例。随后，我们探讨了各种规划算法，从传统的 STRIPS 和 HTN 到现代基于 LLM 的规划方法，理解了它们在语言模型背景下的相对实用性。通过一个实际的旅行规划示例，我们看到了如何在每个框架中定义、集成和使用工具，以创建复杂的规划系统。
- en: We learned how integrating tool calling with planning can supercharge agentic
    systems by making them more capable of handling complex tasks. We also reviewed
    the implementation patterns across three frameworks (CrewAI, AutoGen, and LangGraph),
    which revealed distinct approaches to agent coordination and tool usage.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到，通过将工具调用与规划集成，可以极大地增强代理系统，使它们能够更好地处理复杂任务。我们还回顾了三个框架（CrewAI、AutoGen 和 LangGraph）中的实现模式，揭示了代理协调和工具使用的不同方法。
- en: In the next chapter, we will dive into the concepts of the coordinator, worker,
    and delegator approach in agentic systems, and learn how they can help with completing
    complex real-world tasks.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨代理系统中协调者、工作者和委托者方法的概念，并了解它们如何帮助完成复杂的现实世界任务。
- en: Questions
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the purpose of tools in AI agents, and how do docstrings help in tool
    definition?
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AI 代理中工具的目的是什么，文档字符串如何帮助工具定义？
- en: Explain the difference between traditional planning algorithms (such as STRIPS)
    and modern LLM-based planning. Why are traditional algorithms less practical for
    LLM agents?
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释传统规划算法（如 STRIPS）与现代基于 LLM 的规划之间的区别。为什么传统算法对 LLM 代理来说不太实用？
- en: How does HTN planning work, and why is it considered one of the more practical
    approaches for LLM agents?
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTN 规划是如何工作的，为什么它被认为是 LLM 代理更实用的方法之一？
- en: What role does reasoning play in tool selection for LLM agents, and what are
    its limitations?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工具选择中，推理在 LLM 代理中扮演什么角色，它有什么局限性？
- en: When comparing frameworks (CrewAI, AutoGen, and LangGraph), what are the key
    factors to consider for an AI agent implementation?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当比较框架（CrewAI、AutoGen 和 LangGraph）时，对于 AI 代理实现，需要考虑哪些关键因素？
- en: Answers
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Tools in AI agents are functions that enable agents to perform specific tasks
    or access external services. Docstrings provide crucial information about the
    tool’s purpose, expected parameters, and return values, helping the LLM understand
    when and how to use each tool effectively. This documentation serves as the context
    that guides the model’s decision-making process.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AI 代理中的工具是使代理能够执行特定任务或访问外部服务的功能。文档字符串提供了关于工具目的、预期参数和返回值的关键信息，帮助大型语言模型理解何时以及如何有效地使用每个工具。本文档作为指导模型决策过程的背景。
- en: Traditional planning algorithms such as STRIPS rely on explicit state representations
    and predefined action sets, working with binary conditions and clear state transitions.
    LLM-based planning, however, operates with natural language understanding and
    can handle ambiguous states and actions. Traditional algorithms struggle with
    LLMs because they can’t effectively represent the nuanced, contextual nature of
    language-based tasks.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传统的规划算法，如 STRIPS，依赖于显式的状态表示和预定义的动作集，使用二元条件和清晰的状态转换。然而，基于 LLM 的规划操作使用自然语言理解，可以处理模糊的状态和动作。传统算法在
    LLM 上遇到困难，因为它们无法有效地表示基于语言的任务的细微和情境性质。
- en: HTN planning works by breaking down complex tasks into progressively simpler
    subtasks in a hierarchical structure. It’s practical for LLM agents because this
    hierarchical decomposition mirrors how language models naturally process and understand
    tasks. The approach allows for both structured planning and the flexibility needed
    for language-based interactions.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTN 规划通过将复杂任务分解为层次结构中的逐步更简单的子任务来工作。它对 LLM 代理来说是实用的，因为这种层次分解反映了语言模型自然处理和理解任务的方式。这种方法允许进行结构化规划，同时也提供了基于语言交互所需的灵活性。
- en: Reasoning in LLM agents is largely handled by the model’s built-in capabilities
    to understand context and make decisions. While this makes tool selection more
    natural, not all models are equally capable. Limitations include potential inconsistencies
    in tool selection, difficulties with complex tool combinations, and challenges
    in error recovery when tools fail.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 LLM 代理中的推理主要是由模型内置的能力来理解和做出决策。虽然这使得工具选择更加自然，但并非所有模型都同样具备这种能力。局限性包括工具选择可能存在的不一致性、复杂工具组合的困难以及在工具失败时的错误恢复挑战。
- en: Key factors for framework selection include the complexity of the workflow (structured
    versus conversational), the need for state management, multi-agent collaboration
    requirements, and development complexity. CrewAI offers straightforward implementation,
    AutoGen excels at multi-agent interaction, and LangGraph provides robust workflow
    control but requires more setup.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择框架的关键因素包括工作流程的复杂性（结构化与对话式）、状态管理的需求、多代理协作要求以及开发复杂性。CrewAI 提供了直接的实现，AutoGen
    在多代理交互方面表现出色，而 LangGraph 提供了强大的工作流程控制，但需要更多的设置。
- en: Join our communities on Discord and Reddit
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 和 Reddit 社区
- en: Have questions about the book or want to contribute to discussions on Generative
    AI and LLMs? Join our Discord server at [https://packt.link/I1tSU](https://packt.link/I1tSU)
    and our Reddit channel at [https://packt.link/ugMW0](https://packt.link/ugMW0)
    to connect, share, and collaborate with like-minded enthusiasts.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对本书有任何疑问或想参与关于生成式 AI 和 LLM 的讨论？加入我们的 Discord 服务器[https://packt.link/I1tSU](https://packt.link/I1tSU)和
    Reddit 频道[https://packt.link/ugMW0](https://packt.link/ugMW0)，与志同道合的爱好者建立联系、分享和协作。
- en: '![img](img/B31483_Discord_QR_new.jpg)![img](img/qrcode_Reddit_Channel.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31483_Discord_QR_new.jpg)![img](img/qrcode_Reddit_Channel.jpg)'
