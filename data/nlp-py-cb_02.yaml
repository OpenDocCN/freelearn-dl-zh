- en: Raw Text, Sourcing, and Normalization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始文本、来源和规范化
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The importance of string operations
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串操作的重要性
- en: Getting deeper with string operations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解字符串操作
- en: Reading a PDF file in Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中读取PDF文件
- en: Reading Word documents in Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中读取Word文档
- en: Taking  PDF, DOCX, and plain text files and creating a user-defined corpus from
    them
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理PDF、DOCX和纯文本文件，并从中创建用户定义的语料库
- en: Reading contents from an RSS feed
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从RSS源读取内容
- en: HTML parsing using BeautifulSoup
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用BeautifulSoup解析HTML
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'In the previous chapter, we looked at NLTK inbuilt corpora. The corpora are
    very well organized and normalized for usage, but that will not always be the
    case when you work on your industry problems. Let alone normalization and organization,
    we may not even get the data we need in a uniform format. The goal of this chapter
    is to introduce some Python libraries that will help you extract data from binary
    formats: PDF and Word DOCX files. We will also look at libraries that can fetch
    data from web feeds such as RSS and a library that will help you parse HTML and
    extract the raw text out of the documents. We will also learn to extract raw text
    from heterogeneous sources, normalize it, and create a user-defined corpus from
    it.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们探讨了NLTK内建语料库。这些语料库的组织和规范化非常好，适合使用，但在你处理行业问题时，情况并不总是如此。更不用说规范化和组织了，甚至我们可能根本得不到需要的统一格式的数据。本章的目标是介绍一些Python库，帮助你从二进制格式中提取数据：PDF和Word
    DOCX文件。我们还将看一些可以从Web源（如RSS）提取数据的库，以及一个帮助你解析HTML并提取文档原始文本的库。我们还将学习如何从异构来源提取原始文本、对其进行规范化，并从中创建用户定义的语料库。
- en: In this chapter, you will learn seven different recipes. As the name of the
    chapter suggests, we will be learning to source data from PDF files, Word documents,
    and the Web. PDFs and Word documents are binary, and over the Web, you will get
    data in the form of HTML. For this reason, we will also perform normalization and
    raw text conversion tasks on this data.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习七个不同的示例。正如章节名称所示，我们将学习如何从PDF文件、Word文档和Web中获取数据。PDF和Word文档是二进制文件，而在Web上，你将以HTML格式获得数据。因此，我们还将对这些数据进行规范化和原始文本转换任务。
- en: The importance of string operations
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串操作的重要性
- en: As an NLP expert, you are going to work on a lot of textual content. And when
    you are working with text, you must know string operations. We are going to start
    with a couple of short and crisp recipes that will help you understand the `str`
    class and operations with it in Python.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名NLP专家，你将处理大量文本内容。当你处理文本时，必须了解字符串操作。我们将从几个简短而精炼的示例开始，帮助你理解Python中的`str`类及其操作。
- en: Getting ready…
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备开始…
- en: For this recipe, you will just need the Python interpreter and a text editor,
    nothing more. We will see `join`, `split`, `addition`, and `multiplication` operators
    and indices.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，你只需要Python解释器和一个文本编辑器，其他的都不需要。我们将查看`join`、`split`、加法、乘法操作符和索引。
- en: How to do it…
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: Create a new Python file named `StringOps1.py`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`StringOps1.py`的新Python文件。
- en: 'Define two objects:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个对象：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first object, `nameList`, is a list of `str` objects containing some names
    as implied, and the second object, `sentence`, is a sentence that is an `str`
    object.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个对象`nameList`是一个包含一些名称的`str`对象的列表，第二个对象`sentence`是一个`str`类型的句子。
- en: 'First, we will see the join functionality and what it does:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将了解`join`功能及其作用：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `join()` function can be called on any `string` object. It accepts a list
    of `str` objects as argument and concatenates all the star objects into a single
    `str` object, with the calling string object''s contents as the joining delimiter.
    It returns that object. Run these two lines and your output should look like:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`join()`函数可以在任何`string`对象上调用。它接受一个`str`对象的列表作为参数，并将所有的`str`对象连接成一个单一的`str`对象，调用字符串对象的内容作为连接分隔符。它返回这个对象。运行这两行代码后，你的输出应该如下：'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we will check out the `split` method:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将查看`split`方法：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `split` function called on a string will split its contents into multiple
    `str` objects, create a list of the same, and return that list. The function accepts
    a single `str` argument, which is used as the splitting criterion. Run the code
    and you will see the following output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对字符串调用的`split`函数会将其内容分割成多个`str`对象，创建一个包含这些对象的列表，并返回该列表。该函数接受一个`str`参数，作为分割的标准。运行代码后，你将看到以下输出：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The arithmetic operators `+` and `*` can also be used with strings. Add the
    following lines and see the output:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 算术运算符 `+` 和 `*` 也可以与字符串一起使用。添加以下代码行并查看输出：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This time we will first see the output and then discuss how it works:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们将首先看到输出，然后讨论它是如何工作的：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `+` operator is known as concatenation. It produces a new string, concatenating
    the strings into a single `str` object. Using the `*` operator, we can multiply
    the strings too, as shown previously in the output. Also, please note that these
    operations don't add anything extra, such as insert a space between the strings.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`+` 运算符被称为连接操作。它会生成一个新的字符串，将多个字符串连接成一个单一的 `str` 对象。使用 `*` 运算符，我们也可以对字符串进行乘法操作，如前面的输出所示。此外，请注意，这些操作不会添加任何额外的内容，例如在字符串之间插入空格。'
- en: 'Let''s look at the indices of the characters in the strings. Add the following
    lines of code:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来看看字符串中字符的索引。添加以下代码行：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'First, we declare a new `string` object. Then we access the second character
    (`y`) in the string, which just shows that it is straightforward. Now comes the
    tricky part; Python allows you to use negative indexes when accessing any list
    object; `-1` means the last member, `-2` is the second last, and so on. For example,
    in the preceding `str` object, index `7` and `-4` are the same character, `N`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明一个新的 `string` 对象。然后我们访问字符串中的第二个字符（`y`），这表明它是直接的。接下来是有点棘手的部分；Python 允许你在访问任何列表对象时使用负索引；`-1`
    表示最后一个元素，`-2` 表示倒数第二个，依此类推。例如，在前面的 `str` 对象中，索引 `7` 和 `-4` 是相同的字符，`N`：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works…
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We created a list of strings from a string and a string from a list of strings
    using the `split()` and `join()` functions, respectively. Then we saw the use
    of some arithmetic operators with strings. Please note that we can't use the "`-`"(negation)
    and the "`/`"(division) operators with strings. In the end, we saw how to access
    individual characters in any string, in which peculiarly, we can use negative
    index numbers while accessing strings.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `split()` 和 `join()` 函数分别从字符串中创建字符串列表，并从字符串列表中创建字符串。然后我们看到了如何使用一些算术运算符与字符串进行操作。请注意，我们不能对字符串使用
    "`-`"（取反）和 "`/`"（除法）运算符。最后，我们看到了如何访问字符串中的单个字符，特别是我们可以在访问字符串时使用负索引。
- en: This recipe is pretty simple and straightforward, in that the objective was
    to introduce some common and uncommon string operations that Python allows. Up
    next, we will continue where we left off and do some more string operations.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤相当简单直接，目的是介绍一些 Python 允许的常见和不常见的字符串操作。接下来，我们将从中断处继续，进行更多字符串操作。
- en: Getting deeper with string operations
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解字符串操作
- en: Moving ahead from the previous recipe, we will see substrings, string replacements,
    and how to access all the characters of a string.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个步骤的基础上，我们将看到子字符串、字符串替换以及如何访问字符串的所有字符。
- en: Let's get started.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: How to do it…
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Create a new Python file named `StringOps2.py` and define the following string
    object `str`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`StringOps2.py`的新 Python 文件，并定义以下字符串对象 `str`：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's access the substring that ends at the fourth character from the `str` object.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们访问 `str` 对象中以第四个字符结尾的子字符串。
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As we know the index starts at zero, this will return the substring containing
    characters from zero to three. When you run, the output will be:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们知道索引从零开始，这将返回包含从零到三的字符的子字符串。当你运行时，输出将是：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we will access the substring that starts at a certain point until the end
    in object `str`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将访问从某个位置开始直到结尾的 `str` 对象的子字符串：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This tells the interpreter to return a substring of object `str` from index
    `11` to the end. When you run this, the following output will be visible:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉解释器返回从索引 `11` 到字符串结尾的子字符串。当你运行时，以下输出将显示：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s access the `Dolly` substring from the `str` object. Add the following
    line:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从 `str` 对象中访问 `Dolly` 子字符串。添加以下一行：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding syntax returns characters from index `5` to `10`, excluding the
    10th character. The output is:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的语法返回从索引 `5` 到 `10` 的字符，不包括第 10 个字符。输出为：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, it''s time for a fancy trick. We have already seen how negative indices
    work for string operations. Let''s try the following and see how it works:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候展示一个花式技巧了。我们已经看到负索引如何在字符串操作中工作。让我们尝试以下操作，看看它是如何工作的：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Exactly similar to the previous step! Go ahead and do the back calculations: `-1`
    as the last character, `-2` as the last but one, and so and so forth. Thus, you
    will get the index values.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 完全类似于上一步！继续做回溯计算：`-1` 为最后一个字符，`-2` 为倒数第二个，以此类推。这样，你就会得到索引值。
- en: 'Let''s check the `in` operator with `if`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查一下带有`if`的`in`操作符：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the preceding code and check the output; it will be:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码并检查输出；它将是：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As elaborate as it looks, the `in` operator simply checks whether the left-hand
    side string is a substring of the right-hand side string.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管看起来很复杂，`in`操作符实际上只是检查左侧的字符串是否为右侧字符串的子串。
- en: 'We will use the simple `replace` function on an `str` object:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在一个`str`对象上使用简单的`replace`函数：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `replace` function simply takes two arguments. The first is the substring
    that needs to be replaced and the second is the new substring that will come in
    place of it. It returns a new `string` object and doesn''t modify the object it
    was called upon. Run and see the following output:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`replace`函数只需要两个参数。第一个是需要被替换的子字符串，第二个是将替换它的新子字符串。它返回一个新的`string`对象，并且不会修改它所调用的对象。运行并查看以下输出：'
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Last but not least, we will iterate over the `replaced` object and access every
    character:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们将遍历`replaced`对象并访问每个字符：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will print each character from the replaced object on a new line. Let''s
    see the final output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把替换对象中的每个字符打印到新的一行。让我们看看最终的输出：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works…
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: A `string` object is nothing but a list of characters. As we saw in the first
    step we can access every character from the string using the `for` syntax for
    accessing a list. The character `:` inside square brackets for any list denotes
    that we want a piece of the list; `:` followed by a number means we want the sublist
    starting at zero and ending at the index minus 1\. Similarly, a number followed
    by `a :` means we want a sublist from the given number to the end.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`string`对象实际上就是一组字符。正如我们在第一步中看到的，我们可以使用`for`语法来访问字符串中的每个字符，正如我们访问列表一样。在方括号中的字符`:`表示我们想要获取列表的一部分；`:`后跟数字表示我们想要从零开始并结束于该索引减去1的子列表。类似地，数字后面跟`:`表示我们想要从给定的数字开始，直到列表的末尾。
- en: This ends our brief journey of exploring string operations with Python. After
    this, we will move on to files, online resources, HTML, and more.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们简短的探索字符串操作的旅程。接下来，我们将进入文件、在线资源、HTML等内容。
- en: Reading a PDF file in Python
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中读取PDF文件
- en: We start off with a small recipe for accessing PDF files from Python. For this,
    you need to install the `PyPDF2` library.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个简单的教程开始，教你如何从Python访问PDF文件。为此，你需要安装`PyPDF2`库。
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We assume you have `pip` installed. Then, to install the `PyPDF2` library with
    `pip` on Python 2 and 3, you only need to run the following command from the command
    line:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设你已经安装了`pip`。然后，要在Python 2和3中使用`pip`安装`PyPDF2`库，你只需从命令行运行以下命令：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you successfully install the library, we are ready to go ahead. Along with
    that, I also that request you to download some test documents that we will be
    using during this chapter from this link: [https://www.dropbox.com/sh/bk18dizhsu1p534/AABEuJw4TArUbzJf4Aa8gp5Wa?dl=0](https://www.dropbox.com/sh/bk18dizhsu1p534/AABEuJw4TArUbzJf4Aa8gp5Wa?dl=0).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你成功安装了库，那么我们可以继续进行。除此之外，我还请求你从这个链接下载一些测试文档，我们将在本章中使用它们：[https://www.dropbox.com/sh/bk18dizhsu1p534/AABEuJw4TArUbzJf4Aa8gp5Wa?dl=0](https://www.dropbox.com/sh/bk18dizhsu1p534/AABEuJw4TArUbzJf4Aa8gp5Wa?dl=0)。
- en: How to do it…
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'Create a file named `pdf.py` and add the following import line to it:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pdf.py`的文件，并向其中添加以下导入语句：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It imports the `PdfFlleReader` class from the lib `PyPDF2`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 它从`PyPDF2`库中导入`PdfFileReader`类。
- en: 'Add this Python function in the file that is supposed to read the file and
    return the full text from the PDF file:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此Python函数添加到应读取文件并返回PDF文件中所有文本的文件中：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This function accepts two arguments, the path to the PDF file you want to read
    and the password (if any) for the PDF file. As you can see, the `password` parameter
    is optional.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受两个参数，一个是你想要读取的PDF文件的路径，另一个是PDF文件的密码（如果有的话）。如你所见，`password`参数是可选的。
- en: 'Now let''s define the function. Add the following lines under the function:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们定义这个函数。在函数下方添加以下几行：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first line opens the file in read and backwards seek mode. The first line
    is essentially the Python open file command/function that will only open a file
    that is non-text in binary mode. The second line will pass this opened file to
    the `PdfFileReader` class, which will consume the PDF document.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行以读取和向后查找模式打开文件。第一行实际上是Python的打开文件命令/函数，它仅以二进制模式打开非文本文件。第二行会将打开的文件传递给`PdfFileReader`类，该类将处理PDF文档。
- en: 'The next step is to decrypt password-protected files, if any:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是解密受密码保护的文件（如果有的话）：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If a password is provided with the function call, then we will try to decrypt
    the file using the same.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在函数调用中提供了密码，我们将尝试使用该密码解密文件。
- en: 'Now we will read the text from the file:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将从文件中读取文本：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We create a list of strings and append text from each page to that list of strings.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个字符串列表，并将每一页的文本添加到该列表中。
- en: 'Return the final output:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回最终输出：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We return the single `string` object by joining the contents of all the string
    objects inside the list with a new line.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将列表中所有字符串对象的内容连接成一个新行来返回单个 `string` 对象。
- en: 'Create another file named `TestPDFs.py` in the same folder as `pdf.py`, and
    add the following import statement:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与 `pdf.py` 同一文件夹中创建另一个名为 `TestPDFs.py` 的文件，并添加以下导入语句：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we''ll just print out the text from a couple of documents, one password
    protected and one plain:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将打印出来自几个文档的文本，其中一个有密码保护，另一个是普通文档：
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**Output**: The first six steps of the recipe only create a Python function
    and no output will be generated on the console. The seventh and eighth steps will
    output the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**：食谱的前六个步骤仅创建一个 Python 函数，并且在控制台上不会生成任何输出。第七和第八个步骤将输出以下内容：'
- en: '[PRE32]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works…
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '`PyPDF2` is a pure Python library that we use to extract content from PDFs.
    The library has many more functionalities to crop pages, superimpose images for
    digital signatures, create new PDF files, and much more. However, your purpose
    as an NLP engineer or in any text analytics task would only be to read the contents.
    In step *2*, it''s important to open the file in backwards seek mode since the
    `PyPDF2` module tries to read files from the end when loading the file contents.
    Also, if any PDF file is password protected and you do not decrypt it before accessing
    its contents, the Python interpreter will throw a `PdfReadError`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`PyPDF2` 是一个纯 Python 库，我们用它来从 PDF 中提取内容。该库有更多的功能，例如裁剪页面、叠加图像以进行数字签名、创建新的 PDF
    文件等等。然而，作为 NLP 工程师或进行任何文本分析任务时，你的目的是读取文件内容。在第 *2* 步中，重要的是以反向查找模式打开文件，因为 `PyPDF2`
    模块尝试从文件的末尾读取内容。此外，如果 PDF 文件受到密码保护且未解密，Python 解释器将抛出 `PdfReadError` 错误。'
- en: Reading Word documents in Python
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Python 中读取 Word 文档
- en: In this recipe, we will see how to load and read Word/DOCX documents. The libraries
    available for reading DOCX word documents are more comprehensive, in that we can
    also see paragraph boundaries, text styles, and do what are called runs. We will
    see all of this as it can prove vital in your text analytics tasks.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将看到如何加载和读取 Word/DOCX 文档。用于读取 DOCX 文档的库更为全面，因为我们还可以查看段落边界、文本样式，并执行所谓的“运行”。我们将看到所有这些内容，因为它们在文本分析任务中非常重要。
- en: If you do not have access to Microsoft Word, you can always use open source
    versions of Liber Office and Open Office to create and edit `.docx` files.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有 Microsoft Word，你可以始终使用开源版本的 LibreOffice 和 OpenOffice 来创建和编辑 `.docx` 文件。
- en: Getting ready…
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正在准备…
- en: 'Assuming you already have `pip` installed on your machine, we will use pip
    to install a module named `python-docx`. Do not confuse this with another library
    named `docx`, which is a different module altogether. We will be importing the
    `docx` object from the `python-docx` library. The following command, when fired
    on your command line, will install the library:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经在机器上安装了 `pip`，我们将使用 pip 安装一个名为 `python-docx` 的模块。不要将其与名为 `docx` 的另一个库混淆，它是完全不同的模块。我们将从
    `python-docx` 库中导入 `docx` 对象。以下命令在命令行中执行时，将安装该库：
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After having successfully installed the library, we are ready to go ahead. We
    will be using a test document in this recipe, and if you have already downloaded
    all the documents from the link shared in the first recipe in this chapter, you
    should have the relevant document. If not, then please download the `sample-one-line.docx`
    document from [https://www.dropbox.com/sh/bk18dizhsu1p534/AABEuJw4TArUbzJf4Aa8gp5Wa?dl=0](https://www.dropbox.com/sh/bk18dizhsu1p534/AABEuJw4TArUbzJf4Aa8gp5Wa?dl=0).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 成功安装库后，我们可以继续操作。在本食谱中，我们将使用一个测试文档，如果你已经下载了本章第一个食谱中提供的所有文档，你应该拥有相关文档。如果没有，请从
    [https://www.dropbox.com/sh/bk18dizhsu1p534/AABEuJw4TArUbzJf4Aa8gp5Wa?dl=0](https://www.dropbox.com/sh/bk18dizhsu1p534/AABEuJw4TArUbzJf4Aa8gp5Wa?dl=0)
    下载 `sample-one-line.docx` 文档。
- en: Now we are good to go.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始了。
- en: How to do it…
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Create a new Python file named `word.py` and add the following `import` line:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `word.py` 的新 Python 文件，并添加以下 `import` 行：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Simply import the `docx` object of the `python-docx` module.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地导入 `python-docx` 模块中的 `docx` 对象。
- en: 'Define the function `getTextWord`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义函数 `getTextWord`：
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The function accepts one `string` parameter, `wordFileName`, which should contain
    the absolute path to the Word file you are interested in reading.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个`string`类型的参数，`wordFileName`，它应该包含你想读取的Word文件的绝对路径。
- en: 'Initialize the `doc` object:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化`doc`对象：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `doc` object is now loaded with the word file you want to read.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`doc`对象现在已加载你想要读取的Word文件。'
- en: 'We will read the text from the document loaded inside the `doc` object. Add
    the following lines for that:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从`doc`对象加载的文档中读取文本。为此，添加以下几行代码：
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: First, we initialized a string array, `fullText`. The `for` loop reads the text
    from the document paragraph by paragraph and goes on appending to the list `fullText`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们初始化了一个字符串数组`fullText`。`for`循环按段落读取文档的文本，并将其附加到列表`fullText`中。
- en: 'Now we will join all the fragments/paras in a single string object and return
    it as the final output of the function:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将把所有片段/段落合并成一个字符串对象，并将其作为函数的最终输出返回：
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We joined all the constituents of the `fullText` array with the delimited `\n` and
    returned the resultant object. Save the file and exit.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用分隔符`\n`将`fullText`数组中的所有元素连接起来，并返回结果对象。保存文件并退出。
- en: 'Create another file, name it `TestDocX.py`, and add the following import statements:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个文件，命名为`TestDocX.py`，并添加以下导入语句：
- en: '[PRE39]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Simply import the `docx` library and the `word.py` that we wrote in the first
    five steps.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 只需导入`docx`库和我们在前五个步骤中编写的`word.py`文件。
- en: 'Now we will read a DOCX document and print the full contents using the API
    we wrote on `word.py.` Write down the following two lines:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将读取一个DOCX文档，并使用我们在`word.py`中编写的API打印出完整内容。写下以下两行：
- en: '[PRE40]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Initialize the document path in the first line, and then, using the API print
    out the full document. When you run this part, you should get an output that looks
    something similar to:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行初始化文档路径，然后，使用API打印出完整文档。当你运行这部分时，应该会得到类似以下的输出：
- en: '[PRE41]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is a sample PDF document with some text in bold, some in italic, and some
    underlined. We are also embedding a title shown as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例PDF文档，包含一些加粗文本、斜体文本和一些下划线文本。我们还嵌入了一个如下所示的标题：
- en: '[PRE42]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As already discussed, Word/DOCX documents are a much richer source of information
    and the libraries will give us much more than text. Now let us look at the paragraph
    information. Add the following four lines of code:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，Word/DOCX文档是信息来源更加丰富的格式，相关库将提供比文本更多的信息。现在让我们看看段落信息。添加以下四行代码：
- en: '[PRE43]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The second line in the previous snippet gives us the number of paragraphs in
    the given document. The third line returns only the second paragraph from the
    document and the fourth line will analyze the style of the second paragraph, which
    is `Title` in this case. When you run, the output for these four lines will be:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段中的第二行给出了文档中段落的数量。第三行仅返回文档中的第二个段落，第四行将分析第二个段落的样式，在本例中是`Title`。当你运行时，这四行的输出将是：
- en: '[PRE44]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It is quite self-explanatory.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易理解。
- en: 'Next, we will see what a run is. Add the following lines:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将了解什么是run。添加以下几行代码：
- en: '[PRE45]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, we are first returning the first paragraph; next we are returning the
    number of runs in the paragraph. Later we are printing out every run.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先返回第一个段落；接着返回段落中的run数量。然后我们打印出每个run。
- en: 'And now to identify the styling of each run, write the following lines of code:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了识别每个run的样式，编写以下几行代码：
- en: '[PRE46]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Each line in the previous snippet is checking for underline, bold, and italic
    styling respectively. In the following section, we will see the final output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段中的每一行分别检查下划线、加粗和斜体样式。在接下来的部分中，我们将看到最终的输出：
- en: '[PRE47]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works…
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: First, we wrote a function in the `word.py` file that will read any given DOCX
    file and return to us the full contents in a `string` object. The preceding output
    text you see is fairly self-explanatory though some things I would like to elaborate
    are `Paragraph` and `Run` lines. The structure of a `.docx` document is represented
    by three data types in the `python-docx` library. At the highest level is the
    `Document` object. Inside each document, we have multiple paragraphs.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`word.py`文件中编写了一个函数，该函数将读取任何给定的DOCX文件，并将其完整内容返回为一个`string`对象。你看到的输出文本已经相当自解释了，但我想详细说明的是`Paragraph`和`Run`行。`.docx`文档的结构由`python-docx`库中的三种数据类型表示。最高级别是`Document`对象。每个文档内部都有多个段落。
- en: Every time we see a new line or a carriage return, it signifies the start of
    a new paragraph. Every paragraph contains multiple `Runs` , which denotes a change
    in word styling. By styling, we mean the possibilities of different fonts, sizes,
    colors, and other styling elements such as bold, italic, underline, and so on.
    Each time any of these elements vary, a new run is started.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们看到新的一行或换行符时，它表示一个新段落的开始。每个段落包含多个`Run`，表示单词样式的变化。这里的样式指的是字体、大小、颜色以及其他样式元素，如粗体、斜体、下划线等。每当这些元素发生变化时，便开始一个新的运行。
- en: Taking PDF, DOCX, and plain text files and creating a user-defined corpus from
    them
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从PDF、DOCX和纯文本文件中创建一个用户定义的语料库
- en: For this recipe, we are not going to use anything new in terms of libraries
    or concepts. We are reinvoking the concept of corpus from the first chapter. Just
    that we are now going to create our own corpus here instead of using what we got
    from the Internet.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们不会使用任何新的库或概念。我们将重新调用第一章中的语料库概念。只不过这次我们将创建自己的语料库，而不是使用从互联网上获得的语料库。
- en: Getting ready
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In terms of getting ready, we are going to use a few files from the Dropbox
    folder introduced in the first recipe of this chapter. If you''ve downloaded all
    the files from the folder, you should be good. If not, please download the following
    files from [https://www.dropbox.com/sh/bk18dizhsu1p534/AABEuJw4TArUbzJf4Aa8gp5Wa?dl=0](https://www.dropbox.com/sh/bk18dizhsu1p534/AABEuJw4TArUbzJf4Aa8gp5Wa?dl=0):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备工作方面，我们将使用本章第一部分介绍的Dropbox文件夹中的一些文件。如果你已经下载了该文件夹中的所有文件，那么就没问题了。如果没有，请从[https://www.dropbox.com/sh/bk18dizhsu1p534/AABEuJw4TArUbzJf4Aa8gp5Wa?dl=0](https://www.dropbox.com/sh/bk18dizhsu1p534/AABEuJw4TArUbzJf4Aa8gp5Wa?dl=0)下载以下文件：
- en: '`sample_feed.txt`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sample_feed.txt`'
- en: '`sample-pdf.pdf`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sample-pdf.pdf`'
- en: '`sample-one-line.docx`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sample-one-line.docx`'
- en: If you haven't followed the order of this chapter, you will have to go back
    and look at the first two recipes in this chapter. We are going to reuse two modules
    we wrote in the previous two recipes, `word.py` and `pdf.py`. This recipe is more
    about an application of what we did in the first two recipes and the corpus from
    the first chapter than introducing a new concept. Let's get on with the actual
    code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有按照本章的顺序进行操作，你需要回到本章的前两部分查看。我们将重用之前编写的两个模块`word.py`和`pdf.py`。本例更多的是应用我们在前两部分中做过的工作，以及来自第一章的语料库，而不是引入新概念。让我们继续实际的代码部分。
- en: How to do it…
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Create a new Python file named `createCorpus.py` and add the following import
    lines to start off:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Python文件，命名为`createCorpus.py`，并添加以下导入行开始：
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We have imported the `os` library for use with file operations, the `word` and
    `pdf` modules we wrote in the first two recipes of this chapter, and the `PlaintextCorpusReader`,
    which is our final objective of this recipe.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经导入了`os`库来进行文件操作，以及我们在本章前两部分编写的`word`和`pdf`模块，还有`PlaintextCorpusReader`，这是本例的最终目标。
- en: 'Now let''s write a little function that will take as input the path of a plain
    text file and return the full text as a `string` object. Add the following lines:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们编写一个小函数，它将接受一个纯文本文件的路径作为输入，并将文件的完整文本返回为一个`string`对象。请添加以下几行：
- en: '[PRE49]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The first line defines the function and input parameter. The second line opens
    the given file in reading mode (the second parameter of the open function `r`
    denotes read mode). The third line reads the content of the file and returns it
    into a `string` object, all at once in a single statement.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义了函数和输入参数。第二行以读取模式打开给定的文件（`open`函数的第二个参数`r`表示读取模式）。第三行读取文件的内容，并一次性将其返回为`string`对象。
- en: 'We will create the new `corpus` folder now on the disk/filesystem. Add the
    following three lines:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将在磁盘/文件系统上创建新的`corpus`文件夹。请添加以下三行：
- en: '[PRE50]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The first line is a simple `string` object with the name of the new folder.
    The second line checks whether a directory/folder of the same name already exists
    on the disk. The third line instructs the `os.mkdir()` function to create the
    directory on the disk with the specified name. As the outcome, a new directory
    with the name `mycorpus` would be created in the working directory where your
    Python file is placed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是一个简单的`string`对象，包含新文件夹的名称。第二行检查磁盘上是否已存在同名的目录/文件夹。第三行指示`os.mkdir()`函数在磁盘上创建具有指定名称的目录。结果，在你的Python文件所在的工作目录中将创建一个名为`mycorpus`的新目录。
- en: 'Now we will read the three files one by one. Starting with the plain text file,
    add the following line:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将逐个读取这三个文件。首先是纯文本文件，添加以下行：
- en: '[PRE51]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Calling the `getText()` function written earlier, it will read the `sample_feed.txt`
    file and return the output in the `txt1` string object.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 调用之前编写的`getText()`函数，它将读取`sample_feed.txt`文件，并将输出返回到`txt1`字符串对象。
- en: 'Now we will read the PDF file. Add the following line:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将读取PDF文件。添加以下行：
- en: '[PRE52]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Using the `pdf.py` module's `getTextPDF()` function, we are retrieving the contents
    of the `sample-pdf.pdf` file into the `txt2` string object.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pdf.py`模块的`getTextPDF()`函数，我们正在将`sample-pdf.pdf`文件的内容检索到`txt2`字符串对象中。
- en: 'Finally, we will read the DOCX file by adding the following line:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将通过添加以下行来读取DOCX文件：
- en: '[PRE53]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Using the `word.py` module's `getTextWord()` function, we are retrieving the
    contents of the `sample-one-line.docx` file into the `txt3` string object.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`word.py`模块的`getTextWord()`函数，我们正在将`sample-one-line.docx`文件的内容检索到`txt3`字符串对象中。
- en: 'The next step is to write the contents of these three string objects on the
    disk, in files. Write the following lines of code for that:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将这三个字符串对象的内容写入磁盘文件。为此，请编写以下代码行：
- en: '[PRE54]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '**First line**: Creates an array from the string objects so as to use it in
    the upcoming for loop'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一行**：从字符串对象创建一个数组，以便在接下来的`for`循环中使用'
- en: '**Second line**: A `for` loop with index on the files array'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二行**：带有索引的`for`循环，遍历文件数组'
- en: '**Third line**: This opens a new file in write mode (the `w` option in the
    open function call)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三行**：这将以写模式（在`open`函数调用中的`w`选项）打开一个新文件'
- en: '**Fourth line**: Writes the contents of the string object in the file'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第四行**：将字符串对象的内容写入文件'
- en: 'Now we will create a `PlainTextCorpus` object from the `mycorpus` directory,
    where we have stored our files:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将从`mycorpus`目录创建一个`PlainTextCorpus`对象，我们将文件存储在该目录中：
- en: '[PRE55]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: A simple one-line instruction but internally it does a lot of text processing,
    identifying paragraphs, sentences, words, and much more. The two parameters are
    the path to the corpus directory and the pattern of the filenames to consider
    (here we have asked the corpus reader to consider all files in the directory).
    We have created a user-defined corpus. As simple as that!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的单行指令，但在内部它执行了大量的文本处理，识别段落、句子、单词等等。两个参数是语料库目录的路径和要考虑的文件名模式（在这里我们要求语料库读取器考虑目录中的所有文件）。我们创建了一个用户定义的语料库。就这么简单！
- en: 'Let us see whether the our `PlainTextCorpusReader` is loaded correctly. Add
    the following lines of code to test it:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看我们的`PlainTextCorpusReader`是否正确加载。添加以下代码行进行测试：
- en: '[PRE56]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The first line will print the array containing all the words in the corpus
    (curtailed). The second line will print the sentences in file `1.txt`. The third
    line will print the paragraphs in file `0.txt`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将打印包含语料库中所有单词的数组（已截断）。第二行将打印文件`1.txt`中的句子。第三行将打印文件`0.txt`中的段落：
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works…
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The output is fairly straightforward and as explained in the last step of the
    recipe. What is peculiar is the characteristics of each of objects on show. The
    first line is the list of all words in the new corpus; it doesn't have anything
    to do with higher level structures like sentences/paragrpahs/files and so on.
    The second line is the list of all sentences in the file `1.txt`, of which each
    sentence is a list of words inside each of the sentences. The third line is a
    list of paragraphs, of which each paragraph object is in turn a list of sentences,
    of which each sentence is in turn a list of words in that sentence, all from the
    file `0.txt`. As you can see, a lot of structure is maintained in paragraphs and
    sentences.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 输出相当直接，并且如食谱的最后一步所解释的那样。特别的是，每个展示对象的特点。第一行是新语料库中所有单词的列表；它与句子/段落/文件等高级结构无关。第二行是文件`1.txt`中所有句子的列表，每个句子是该句子中单词的列表。第三行是段落的列表，每个段落对象又是一个句子的列表，而每个句子又是该句子中单词的列表，所有这些都来自文件`0.txt`。如你所见，在段落和句子中保持了大量的结构信息。
- en: Read contents from an RSS feed
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从RSS源中读取内容
- en: A **Rich Site Summary** (**RSS**) feed is a computer-readable format in which
    regularly changing content on the Internet is delivered. Most of the websites
    that provide information in this format give updates, for example, news articles,
    online publishing and so on. It gives the listeners access to the updated feed
    at regular intervals in a standardized format.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**富网站摘要**（**RSS**）源是一种计算机可读格式，用于传输互联网上定期更新的内容。大多数提供这种格式信息的网站会提供更新内容，例如新闻文章、在线出版物等等。它以标准化格式让听众可以定期访问更新的源。'
- en: Getting ready
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The objective of this recipe is to read such an RSS feed and access content
    of one of the posts from that feed. For this purpose, we will be using the RSS
    feed of Mashable. Mashable is a digital media website, in short a tech and social
    media blog listing. The URL of the website's RS feed is [http://feeds.mashable.com/Mashable](http://feeds.mashable.com/Mashable).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的目标是读取这样的RSS源，并访问该源中某篇帖子的内容。为此，我们将使用Mashable的RSS源。Mashable是一个数字媒体网站，简而言之，它是一个科技和社交媒体博客列表。该网站的RSS源地址是[http://feeds.mashable.com/Mashable](http://feeds.mashable.com/Mashable)。
- en: 'Also, we need the `feedparser` library to be able to read an RSS feed. To install
    this library on your computer, simply open the terminal and run the following
    command:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要`feedparser`库才能读取RSS源。要在计算机上安装此库，只需打开终端并运行以下命令：
- en: '[PRE58]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Armed with this module and the useful information, we can begin to write our
    first RSS feed reader in Python.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这个模块和有用的信息后，我们可以开始编写我们的第一个Python RSS源阅读器。
- en: How to do it…
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create a new file named `rssReader.py` and add the following import:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`rssReader.py`的新文件，并添加以下导入：
- en: '[PRE59]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now we will load the Mashable feed into our memory. Add the following line:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将Mashable的源加载到内存中。添加以下行：
- en: '[PRE60]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `myFeed` object contains the first page of the RSS feed of Mashable. The
    feed will be downloaded and parsed to fill all the appropriate fields by the `feedparser`.
    Each post will be part of the entry list in to the `myFeed` object.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`myFeed`对象包含Mashable的RSS源的第一页。该源将被下载并通过`feedparser`解析，以填充所有适当的字段。每篇帖子都将作为`myFeed`对象中`entries`列表的一部分。'
- en: 'Let''s check the title and count the number of posts in the current feed:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查标题并计算当前源中的帖子数：
- en: '[PRE61]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In the first line, we are fetching the feed title from the `myFeed` object,
    and in the second line, we are counting the length of the `entries` object inside
    the `myFeed` object. The `entries` object is nothing but a list of all the posts
    from the parsed feed as mentioned previously. When you run, the output is something
    similar to:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们从`myFeed`对象中获取源的标题，在第二行，我们计算`myFeed`对象中`entries`对象的长度。`entries`对象其实就是从解析的源中获取的所有帖子列表。运行时，输出类似于：
- en: '[PRE62]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`Title` will always be Mashable, and at the time of writing this chapter, the
    Mashable folks were putting a maximum of 30 posts in the feed at a time.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`Title`将始终是Mashable，并且在写这章时，Mashable团队在源中最多放入30篇帖子。'
- en: 'Now we will fetch the very first `post` from the entries list and print it''s
    title on the console:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将从`entries`列表中获取第一个`post`并将其标题打印到控制台：
- en: '[PRE63]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In the first line, we are physically accessing the zeroth element in the entries
    list and loading it in the `post` object. The second line prints the title of
    that post. Upon running, you should get an output similar to the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们物理地访问`entries`列表中的第一个元素，并将其加载到`post`对象中。第二行打印该帖子的标题。运行后，你应该得到类似以下的输出：
- en: '[PRE64]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: I say something similar and not exactly the same as the feed keeps updating
    itself.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我说的是类似的内容，而不是完全相同，因为源会不断更新。
- en: 'Now we will access the raw HTML content of the post and print it on the console:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将访问帖子的原始HTML内容，并将其打印到控制台：
- en: '[PRE65]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'First we access the content object from the post and the actual value of the
    same. And then we print it on the console:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们访问帖子的内容对象及其实际值。然后，我们将其打印到控制台：
- en: '[PRE66]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: How it works…
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Most of the RSS feeds you will get on the Internet will follow a chronological
    order, with the latest post on top. Hence, the post we accessed in the recipe
    will be always be the most recent post the feed is offering. The feed itself is
    ever-changing. So every time you run the program, the format of the output will
    the remain same, but the content of the post on the console may differ depending
    upon how fast the feed updates. Also, here we are directly displaying the raw
    HTML on the console and not the clean content. Up next, we are going to look at
    parsing HTML and getting only the information we need from a page. Again, a further
    addendum to this recipe could be to read any feed of your choice, store all the
    posts from the feed on disk, and create a plain text corpus using it. Needless
    to say, you can take inspiration from the previous and the next recipes.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数你在互联网上获取的RSS订阅源会遵循时间顺序排列，最新的帖子位于最上面。因此，在本食谱中访问的帖子将始终是订阅源提供的最新帖子。订阅源本身是不断变化的。所以，每次运行程序时，输出的格式将保持不变，但控制台上的帖子内容可能会有所不同，具体取决于订阅源更新的速度。此外，这里我们直接在控制台上显示的是原始HTML，而不是清理后的内容。接下来，我们将查看如何解析HTML并仅从页面中提取我们需要的信息。再进一步，本食谱的附加内容可以是读取你选择的任何订阅源，将所有帖子存储到磁盘，并使用它创建一个纯文本语料库。不用说，你可以从前一个和下一个食谱中获取灵感。
- en: HTML parsing using BeautifulSoup
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用BeautifulSoup进行HTML解析
- en: Most of the times when you have to deal with data on the Web, it will be in
    the form of HTML pages. For this purpose, we thought it is necessary to introduce
    you to HTML parsing in Python. There are many Python modules available to do this,
    but in this recipe, we will see how to parse HTML using the library `BoutifulSoup4`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，当你需要处理网页上的数据时，它会以HTML页面的形式存在。为此，我们认为有必要向你介绍Python中的HTML解析。虽然有许多Python模块可以完成这个任务，但在本食谱中，我们将演示如何使用`BeautifulSoup4`库进行HTML解析。
- en: Getting ready
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: 'The package `BeautifulSoup4` will work for Python 2 and Python 3\. We will
    have to download and install this package on our interpreter before we can start
    using it. In tune with what we have been doing throughout, we will use the pip
    install utility for it. Run the following command from the command line:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`BeautifulSoup4`包支持Python 2和Python 3。我们需要在解释器中下载并安装这个包，才能开始使用它。和我们一直以来的做法一样，我们将使用pip安装工具来进行安装。运行以下命令：'
- en: '[PRE67]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Along with this module, you will also need the `sample-html.html` file from
    the chapter''s Dropbox location. In case you haven''t downloaded the files already,
    here''s the link again:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个模块，你还需要从本章的Dropbox位置获取`sample-html.html`文件。如果你还没有下载这些文件，这里再给你链接：
- en: '[https://www.dropbox.com/sh/bk18dizhsu1p534/AABEuJw4TArUbzJf4Aa8gp5Wa?dl=0](https://www.dropbox.com/sh/bk18dizhsu1p534/AABEuJw4TArUbzJf4Aa8gp5Wa?dl=0)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.dropbox.com/sh/bk18dizhsu1p534/AABEuJw4TArUbzJf4Aa8gp5Wa?dl=0](https://www.dropbox.com/sh/bk18dizhsu1p534/AABEuJw4TArUbzJf4Aa8gp5Wa?dl=0)'
- en: How to do it…
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Assuming you have already installed the required package, start with the following
    import statement:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你已经安装了所需的包，开始时使用以下导入语句：
- en: '[PRE68]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We have imported the `BeautifulSoup` class from the module `bs4`, which we will
    be using to parse the HTML.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从`bs4`模块中导入了`BeautifulSoup`类，接下来我们将使用它来解析HTML。
- en: 'Let''s load the HTML file into the `BeautifulSoup` object:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将HTML文件加载到`BeautifulSoup`对象中：
- en: '[PRE69]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In the first line, we load the `sample-html.html` file's content into the `str`
    object `html_doc`. Next we create a `BeautifulSoup` object, passing to it the
    contents of our HTML file as the first argument and `html.parser` as the second
    argument. We instruct it to parse the document using the `html` parser. This will
    load the document into the `soup` object, parsed and ready to use.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们将`sample-html.html`文件的内容加载到`str`对象`html_doc`中。接着我们创建一个`BeautifulSoup`对象，将HTML文件的内容作为第一个参数传入，将`html.parser`作为第二个参数传入。我们指示它使用`html`解析器解析文档。这样，文档就会被加载到`soup`对象中，已解析并准备好使用。
- en: 'The first, simplest, and most useful task on this `soup` object will be to
    strip all the HTML tags and get the text content. Add the following lines of code:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个` soup`对象上，第一个最简单且最有用的任务就是去除所有HTML标签，获取文本内容。添加以下代码行：
- en: '[PRE70]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `get_text()` method called on the `soup` object will fetch us the HTML
    stripped content of the file. If you run the code written so far, you will get
    this output:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在`soup`对象上调用`get_text()`方法将提取文件中去除HTML标签的内容。如果你运行到目前为止编写的代码，你将得到以下输出：
- en: '[PRE71]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Sometimes, it''s not enough to have pure HTML stripped content. You may also
    need specific tag contents. Let''s access one of the tags:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时候，仅仅拥有纯粹的 HTML 去除内容是不够的。你可能还需要特定标签的内容。让我们来访问其中一个标签：
- en: '[PRE72]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `soup.title` will return the first title tag it encounters in the file.
    Output of these lines will look like:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`soup.title` 将返回文件中遇到的第一个 title 标签。以下行的输出将是：'
- en: '[PRE73]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Let us get only the HTML stripped text from a tag now. We will grab the text
    of the `<h1>` tag with the following piece of code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们只从标签中获取去除 HTML 的文本。我们将使用以下代码抓取 `<h1>` 标签的文本：
- en: '[PRE74]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The command `soup.h1.string` will return the text surrounded by the first `<h1>`
    tag encountered. The output of this line will be:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 命令 `soup.h1.string` 将返回被第一个 `<h1>` 标签包围的文本。该行的输出将是：
- en: '[PRE75]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now we will access attributes of a tag. In this case, we will access the `alt`
    attribute of the `img` tag; add the following lines of code:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将访问标签的属性。在这个例子中，我们将访问 `img` 标签的 `alt` 属性；添加以下代码行：
- en: '[PRE76]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Look carefully; the syntax to access attributes of a tag is different than
    accessing the text. When you run this piece of code, you will get this output:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察；访问标签属性的语法与访问文本是不同的。当你运行这段代码时，你会得到以下输出：
- en: '[PRE77]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Finally, there can be multiple occurrences of any type of tag in an HTML file.
    Simply using the `.` syntax will only fetch you the first instance. To fetch all
    instances, we use the `find_all()` functionality, shown as follows:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 HTML 文件中可能会有多个相同类型的标签。仅使用 `.` 语法将只会获取到第一个实例。要获取所有实例，我们使用 `find_all()` 功能，如下所示：
- en: '[PRE78]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The `find_all()` function called on a `BeautifulSoup` object will take as an
    argument the name of the tag, search through the entire HTML tree, and return
    all occurrences of that tag as a list. We are accessing that list in the `for`
    loop and printing the content/text of all the `<p>` tags in the given `BeautifulSoup`
    object:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `BeautifulSoup` 对象调用的 `find_all()` 函数将接受标签名作为参数，遍历整个 HTML 树，并返回该标签的所有实例作为一个列表。我们在
    `for` 循环中访问该列表并打印给定 `BeautifulSoup` 对象中所有 `<p>` 标签的内容/文本：
- en: '[PRE79]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: How it works…
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: BeautifulSoup 4 is a very handy library used to parse any HTML and XML content.
    It supports Python's inbuilt HTML parser, but you can also use other third-party
    parsers with it, for example, the `lxml` parser and the pure-Python `html5lib`
    parser. In this recipe, we used the Python inbuilt HTML parser. The output generated
    is pretty much self-explanatory, and of course, the assumption is that you do
    know what HTML is and how to write simple HTML.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: BeautifulSoup 4 是一个非常方便的库，用于解析任何 HTML 和 XML 内容。它支持 Python 内建的 HTML 解析器，但你也可以使用其他第三方解析器，比如
    `lxml` 解析器和纯 Python `html5lib` 解析器。在这个示例中，我们使用了 Python 内建的 HTML 解析器。生成的输出几乎是自解释的，当然，前提是你知道
    HTML 是什么以及如何编写简单的 HTML。
