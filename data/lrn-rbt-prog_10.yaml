- en: '*Chapter 8*: Programming Distance Sensors with Python'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 8 章*：使用 Python 编程距离传感器'
- en: In this chapter, we look at distance sensors and how to use them to avoid objects.
    Avoiding obstacles is a key feature in mobile robots, as bumping into stuff is
    generally not good. It is also a behavior that starts to make a robot appear smart,
    as if it is behaving intelligently.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究距离传感器及其如何用于避免物体。避免障碍物是移动机器人的一项关键特性，因为撞到东西通常不是好事。它也是一种使机器人看起来更智能的行为，好像它正在智能地行动。
- en: In this chapter, we find out about the different types of sensors and choose
    a suitable type. We then build a layer in our robot object to access them and,
    in addition to this, we create a behavior to avoid walls and objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解不同类型的传感器，并选择一个合适的类型。然后我们在机器人对象中构建一个层来访问它们，此外，我们创建了一个避免墙壁和物体的行为。
- en: 'You will learn about the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解以下主题：
- en: Choosing between optical and ultrasonic sensors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在光学传感器和超声波传感器之间进行选择
- en: Attaching and reading an ultrasonic sensor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和读取超声波传感器
- en: Avoiding walls – writing a script to avoid obstacles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免碰撞 – 编写避免障碍物的脚本
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete the hands-on experiments in this chapter, you will require the
    following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的动手实验，你需要以下设备：
- en: The Raspberry Pi robot and the code from the previous chapters.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi 机器人和前几章中的代码。
- en: Two HC-SR04P, RCWL-1601, or Adafruit 4007 ultrasonic sensors. They must have
    a 3.3 V output.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要两个 HC-SR04P、RCWL-1601 或 Adafruit 4007 超声波传感器。它们必须具有 3.3 V 的输出。
- en: A breadboard.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个面包板。
- en: 22 AWG single-core wire or a pre-cut breadboard jumper wire kit.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 22 AWG 单芯线或预切割的面包板跳线套件。
- en: A breadboard-friendly **single pole, double toggle (SPDT**) slide switch.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板友好的**单刀双掷（SPDT**）滑动开关。
- en: Male-to-female jumpers, preferably of the joined-up jumper jerky type.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阳性到阴性的跳线，最好是连接在一起的跳线套件。
- en: Two brackets for the sensor.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个用于传感器的支架。
- en: A crosshead screwdriver.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一把十字螺丝刀。
- en: Miniature spanners or small pliers.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型扳手或小钳子。
- en: The code for this chapter is available on GitHub at [https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter8](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter8).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在 GitHub 上找到：[https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter8](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter8)。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2KfCkZM](https://bit.ly/2KfCkZM)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://bit.ly/2KfCkZM](https://bit.ly/2KfCkZM)
- en: Choosing between optical and ultrasonic sensors
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在光学传感器和超声波传感器之间进行选择
- en: Before we start to use distance sensors, let's find out what these sensors actually
    are, how they work, and some of the different types available.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用距离传感器之前，让我们了解一下这些传感器实际上是什么，它们是如何工作的，以及一些不同类型的传感器。
- en: 'The most common ways in which to sense distance are to use ultrasound or light.
    The principle of both of these mechanisms is to fire off a pulse and then sense
    its reflected return, using either its timing or angle to measure a distance,
    as can be seen in the following diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 感测距离最常见的方法是使用超声波或光。这两种机制的原则是发射一个脉冲，然后感应其反射回波，使用其时间或角度来测量距离，如下面的图所示：
- en: '![Figure 8.1 – Using pulse timing in a distance sensor'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1 – 在距离传感器中使用脉冲定时'
- en: '](img/B15660_08_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15660_08_01.jpg)'
- en: Figure 8.1 – Using pulse timing in a distance sensor
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 在距离传感器中使用脉冲定时
- en: We focus on the sensors that measure the response time, otherwise known as the
    **time of flight**. *Figure 8.1* shows how these sensors use reflection time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们专注于测量响应时间，也就是所谓的**飞行时间**的传感器。*图 8.1* 展示了这些传感器如何使用反射时间。
- en: With this basic understanding of how sensors work, we'll now take a closer look
    at optical sensors and ultrasonic sensors.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对传感器工作原理的基本理解，我们现在将更深入地研究光学传感器和超声波传感器。
- en: Optical sensors
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 光学传感器
- en: 'Light-based sensors, like the one in *Figure 8.2*, use infrared laser light
    that we cannot see. These devices can be tiny; however, they can suffer in strong
    sunlight and fluorescent light, making them misbehave. Some objects reflect light
    poorly or are transparent and are undetectable by these sensors:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 基于光的传感器，如 *图 8.2* 中的传感器，使用我们看不见的红外激光光。这些设备可以非常小；然而，在强烈的阳光和荧光灯下，它们可能会表现不佳，导致它们行为异常。一些物体反射光线不好或透明，这些传感器无法检测到：
- en: '![Figure 8.2 – A VL530LOx on a carrier board'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – VL530LOx 在载板上的应用'
- en: '](img/B15660_08_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15660_08_02.jpg)'
- en: Figure 8.2 – A VL530LOx on a carrier board
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – VL530LOx在载板上的应用
- en: In competitions where infrared beams detect course times, the beams and these
    sensors can interfere with each other. However, unlike ultrasonic sensors, these
    are unlikely to cause false detections when placed on different sides of a robot.
    Optical distance sensors can have higher accuracy, but over a more limited range.
    They can be expensive, although there are cheaper fixed range types of light sensors
    out there.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用红外光束检测比赛时间的比赛中，光束和这些传感器可能会相互干扰。然而，与超声波传感器不同，当放置在机器人不同侧面时，这些不太可能导致错误检测。光学距离传感器可以具有更高的精度，但范围更有限。它们可能很昂贵，尽管市场上也有更便宜的固定范围类型的光传感器。
- en: Ultrasonic sensors
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超声波传感器
- en: Many sound-based distance measuring devices use ultrasonic sound with frequencies
    beyond human hearing limits, although they can annoy some animals, including dogs.
    Mobile phone microphones and some cameras pick up their pulses as clicks. Ultrasonic
    devices tend to be larger than optical ones, but cheaper since sound travels slower
    than light and is easier to measure. Soft objects that do not reflect sound, such
    as fabrics, can be harder for these to detect.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 许多基于声音的距离测量设备使用超声波，其频率超出人类听觉范围，尽管它们可能会打扰一些动物，包括狗。移动电话麦克风和一些相机会将它们的脉冲作为点击声捕捉。超声波设备通常比光学设备大，但由于声音传播速度比光慢且更容易测量，因此它们通常更便宜。对于不反射声音的柔软物体，如织物，这些设备可能更难检测。
- en: '*Figure 8.3* shows the HC-SR04, a common and inexpensive sound-based distance
    sensor:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.3*展示了HC-SR04，这是一种常见且价格低廉的基于声音的距离传感器：'
- en: '![Figure 8.3 – The HC-SR04'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3 – HC-SR04'
- en: '](img/B15660_08_03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图B15660_08_03.jpg]'
- en: Figure 8.3 – The HC-SR04
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – HC-SR04
- en: They have a range of up to 4 meters from a minimum of about 2 cm.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的范围从大约2厘米的最小值延伸到4米。
- en: There are a number of ultrasonic-based devices, including the common HC-SR04,
    but not all of them are suitable. We'll look at logic levels as this is an important
    factor in choosing which sensor to buy.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多基于超声波的设备，包括常见的HC-SR04，但并非所有都适合。我们将探讨逻辑水平，因为这是选择购买哪种传感器的一个重要因素。
- en: Logic levels and shifting
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑水平和移位
- en: The I/O pins on the Raspberry Pi are only suitable for inputs of 3.3 V. Many
    devices in the market have a 5 V logic, either for their inputs when controlling
    them, or from their outputs. Let's dig into what I mean by logic levels, and why
    it is sensible to try and stick to the native voltage level when possible.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派上的I/O引脚仅适用于3.3 V的输入。市场上许多设备具有5 V的逻辑，无论是控制它们的输入还是它们的输出。让我们深入探讨我所说的逻辑水平，以及为什么在可能的情况下坚持使用原生电压水平是有意义的。
- en: '**Voltage** is a measure of how much pushing energy there is on an electrical
    flow. Different electronics are built to tolerate or to respond to different voltage
    levels. Putting too high a voltage through a device can damage it. On the other
    hand, putting too low a voltage can cause your sensors or outputs to simply not
    respond or behave strangely. We are dealing with logic devices that output a high
    or low voltage to represent a true/false value. These voltages must be above a
    threshold to be true, and below it to be false. We must be aware of these electrical
    properties, or we will destroy things and fail to get them to communicate.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**电压**是衡量电流量中推动能量的度量。不同的电子设备被设计成能够承受或响应不同的电压水平。通过设备传递过高的电压可能会损坏它。另一方面，传递过低的电压可能导致你的传感器或输出简单地不响应或行为异常。我们处理的是输出高或低电压以表示真/假值的逻辑设备。这些电压必须高于阈值才能为真，低于阈值才能为假。我们必须了解这些电气特性，否则我们可能会损坏设备并无法使它们进行通信。'
- en: 'The graph in *Figure 8.4* shows the effects that different levels have:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.4*中的图表显示了不同级别的影响：'
- en: '![Figure 8.4 – Voltages and logic levels'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4 – 电压和逻辑水平'
- en: '](img/B15660_08_04.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图B15660_08_04.jpg]'
- en: Figure 8.4 – Voltages and logic levels
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 电压和逻辑水平
- en: In *Figure 8.4*, we show a graph. On the *y*-axis (left), it shows voltage labels
    from 0 to 5 V. The *y*-axis shows different operating conditions. There are 4
    dashed lines running through the graph. The lowest dashed line is at 0.8 V; below
    this, an input will consider it as logic 0\. The next line, at around 2.3 V, is
    where many 3.3 V devices consider things at logic 1\. The line at 3.3 V shows
    the expected input and output level for logic 1 on a Raspberry Pi. Above this
    line, damage may occur to a Raspberry Pi. At around 4.2 V is what some 5 V devices
    expect for logic 1 (although some will allow as low as 2 V for this) – the Raspberry
    Pi needs help to talk to those.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图8.4* 中，我们展示了一个图表。在 *y* 轴（左侧），它显示了从0到5 V的电压标签。*y* 轴显示了不同的操作条件。图表中有4条虚线穿过。最低的虚线在0.8
    V处；低于这个值，输入将被视为逻辑0。下一个线，大约在2.3 V处，是许多3.3 V设备认为逻辑1的地方。3.3 V的线显示了树莓派上逻辑1的预期输入和输出电平。在这条线以上，可能会损坏树莓派。大约在4.2
    V处是某些5 V设备期望的逻辑1（尽管一些设备可能允许低至2 V） – 树莓派需要帮助才能与这些设备通信。
- en: Along the graph are 5 bars. The first labeled bar is at 0 – meaning a clear
    logic 0 to all devices. The next bar is a clear logic 1 for the Raspberry Pi at
    3.3 V, but it is also below 4.2 V, so some 5 V devices won't recognize this. The
    bar labelled unclear is at 1.8 V – in this region, between the low and the high
    thresholds, the logic might not be clear, and this should be avoided. The bar
    labeled **Vague logic 1** is above the threshold, but only just, and could be
    misinterpreted or cause odd results on 3.3 V devices. The last bar is at 5 V,
    which 5 V devices output. This must not go to the Raspberry Pi without a level
    shifter or it will destroy that Raspberry Pi.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着图表有5个条形。第一个标记的条形在0处 – 意味着对所有设备都是清晰的逻辑0。下一个条形是树莓派的3.3 V清晰的逻辑1，但它也低于4.2 V，因此一些5
    V设备可能不会识别这一点。标记为不清晰的条形在1.8 V处 – 在这个低和高阈值之间的区域，逻辑可能不清晰，应该避免。标记为**模糊逻辑1**的条形高于阈值，但仅略高于，可能会被误解或导致3.3
    V设备出现异常结果。最后一个条形在5 V处，这是5 V设备输出的。如果没有电平转换器直接连接到树莓派，这将损坏树莓派。
- en: There are bars in *Figure 8.4* at 1.7 V and 2.3 V. These voltages are very close
    to the logic threshold and can result in random data coming from the input. Avoid
    intermediate voltages between the required logic levels. 3 V is OK, but avoid
    1.5 V as this is ambiguous.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图8.4* 中，有1.7 V和2.3 V的条形。这些电压非常接近逻辑阈值，可能导致从输入随机数据。避免在所需逻辑电平之间的中间电压。3 V是可以的，但避免1.5
    V，因为这可能是模糊的。
- en: Important note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Putting more than 3.3 V into a Raspberry Pi pin damages the Raspberry Pi. Do
    not use 5 V devices without logic level shifters.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 将超过3.3 V的电压放入树莓派引脚会损坏树莓派。不要在没有逻辑电平转换器的情况下使用5 V设备。
- en: 'If you use devices that are 5 V, you require extra electronics to interface
    them. The electronics come with further wiring and parts, thereby increasing the
    cost, complexity, or size of the robot''s electronics:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用5 V的设备，你需要额外的电子设备来接口它们。这些电子设备包含更多的布线和部件，从而增加了机器人的电子成本、复杂度或尺寸：
- en: '![](img/B15660_08_05.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15660_08_05.jpg)'
- en: Figure 8.5 – Wiring the HC-SR04 sensors into the level shifters
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 将HC-SR04传感器连接到电平转换器
- en: '*Figure 8.5* shows a wiring diagram for a robot that uses HC-SR04 5v sensors
    that require logic level shifting. This circuit diagram shows the Raspberry Pi
    GPIO pins at the top. Coming from 3 pins to the left are the 5 V, 3.3 V (written
    as 3v3), and ground (GND) lines. Below the GPIO pins are the 3.3 V and 5 V lines.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.5* 展示了一个使用需要逻辑电平转换的HC-SR04 5v传感器的机器人布线图。此电路图显示了顶部的树莓派GPIO引脚。从左边的3个引脚来的分别是5
    V、3.3 V（写作3v3）和地（GND）线。GPIO引脚下方是3.3 V和5 V线。'
- en: Below the power lines (or rails) are two level shifters. Going into the right
    of the level shifters are connections from the Raspberry Pi GPIO pins 5, 6, 17,
    and 27\. In this style of diagram, a black dot shows a connection, and lines that
    do not connect are shown with a bridge.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在电源线（或轨道）下方是两个电平转换器。进入电平转换器右边的是来自树莓派GPIO引脚5、6、17和27的连接。在这种图表风格中，一个黑点表示一个连接，没有连接的线用桥表示。
- en: The bottom of the diagram has a ground line from the ground pin. This is shown
    as it's normal that additional electronics will require access to a ground line.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图表底部有一条从地线来的地线。这显示为正常，因为额外的电子设备将需要访问地线。
- en: The left of the diagram has the two distance sensors, with connections to 5
    V and GND. Each sensor has the **trig** and **echo** pins wired to the level shifters.
    It's not hard to see how adding more sensors that also require level shifters
    to this would further increase complexity.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图表的左侧有两个距离传感器，连接到5 V和GND。每个传感器的**触发**和**回声**引脚都连接到电平转换器。不难看出，添加更多需要电平转换器的传感器将使复杂性进一步增加。
- en: Thankfully, other options are now available. Where it is possible to use a 3.3
    V native device or a device that uses its supply voltage for logic high, it is
    worth choosing these devices. When buying electronics for a robot, consider carefully
    what voltage the robot's main controller uses (like the Raspberry Pi), and check
    that the electronics work with the controller's voltages.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，现在有其他选项可供选择。在可以使用3.3 V原生设备或使用其供电电压作为逻辑高电平的设备的情况下，选择这些设备是值得的。在为机器人购买电子产品时，仔细考虑机器人主控制器使用的电压（如树莓派），并确认这些电子产品与控制器的电压兼容。
- en: The HC-SR04 has several replacement parts that have this ability. The HC-SR04P,
    the RCWL-1601, and Adafruit 4007 models output 3.3 V and can connect directly
    to the Raspberry Pi.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: HC-SR04有几个具有这种能力的替代部件。HC-SR04P、RCWL-1601和Adafruit 4007型号输出3.3 V，可以直接连接到树莓派。
- en: Why use two sensors?
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么使用两个传感器？
- en: 'Having two sensors allows a behavior to detect which side is closer. With this,
    the robot can detect where open spaces are and move toward them. *Figure 8.6*
    shows how this works:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 两个传感器允许行为检测哪一侧更近。有了这个，机器人可以检测开放空间的位置并朝它们移动。*图8.6*显示了这是如何工作的：
- en: '![Figure 8.6 – Using two sensors'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.6 – 使用两个传感器'
- en: '](img/B15660_08_06.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15660_08_06.jpg)'
- en: Figure 8.6 – Using two sensors
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 使用两个传感器
- en: In *Figure 8.6*, the second robot can make more interesting decisions because
    it has more data from the world with which to make those decisions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图8.6*中，第二个机器人可以做出更有趣的决定，因为它有更多来自世界的数据来做出这些决定。
- en: Considering all of these options, I recommend you use a 3.3 V variant like the
    HC-SR04P/RCWL-1601 or Adafruit 4007 because they are cheap and because it is easy
    to add two or more of these sensors.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑所有这些选项，我建议你使用3.3 V变体，如HC-SR04P/RCWL-1601或Adafruit 4007，因为它们便宜，而且很容易添加两个或更多这样的传感器。
- en: We've seen some distance sensor types and discussed the trade-offs and choices
    for this robot. You've learned about voltage levels, and why this is a crucial
    consideration for robot electronics. We've also looked at how many sensors we
    could use and where we could put them. Now let's look at how to add them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些距离传感器的类型，并讨论了为这个机器人所做的权衡和选择。你已经了解了电压级别，以及为什么这是机器人电子设备的一个关键考虑因素。我们还探讨了我们可以使用多少传感器以及我们可以将它们放在哪里。现在让我们看看如何添加它们。
- en: Attaching and reading an ultrasonic sensor
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接和读取超声波传感器
- en: 'First, we should wire in and secure these sensors to the robot. We then write
    some simple test code that we can use to base our behavior code on in the next
    section. After completing this section, the robot block diagram should look like
    *Figure 8.7*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该将这些传感器连接到机器人并固定好。然后，我们编写一些简单的测试代码，我们可以在下一节的行为代码上基于这些代码。完成本节后，机器人框图应该看起来像*图8.7*：
- en: '![Figure 8.7 – Robot block diagram with ultrasonic sensors'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7 – 带超声波传感器的机器人框图'
- en: '](img/B15660_08_07.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15660_08_07.jpg)'
- en: Figure 8.7 – Robot block diagram with ultrasonic sensors
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 带超声波传感器的机器人框图
- en: This diagram builds on the block diagram in *Figure 6.33* from [*Chapter 6*](B15660_06_Final_ASB_ePub.xhtml#_idTextAnchor096)*,
    Building Robot Basics – Wheels, Power, and Wiring* by adding left and right ultrasonic
    sensors. Both have bi-directional arrows to the Raspberry Pi, since, being an
    active sensor, the Raspberry Pi triggers a sensor measurement and then reads back
    the result. Let's attach the sensors to the robot chassis.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此图基于*图6.33*的框图，来自[*第6章*](B15660_06_Final_ASB_ePub.xhtml#_idTextAnchor096)*，构建机器人基础
    – 轮子、电源和布线*，通过添加左右超声波传感器。它们都有双向箭头指向树莓派，因为作为主动传感器，树莓派触发传感器测量并读取结果。让我们将传感器连接到机器人底盘。
- en: Securing the sensors to the robot
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将传感器固定到机器人上
- en: 'In the *Technical requirements* section, I added an HC-SR04 bracket. Although
    it is possible to make a custom bracket with CAD and other part making skills,
    it is more sensible to use one of the stock designs. *Figure 8.8* shows the bracket
    I''m using:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在*技术要求*部分，我添加了一个HC-SR04支架。虽然可以使用CAD和其他零件制造技能制作定制的支架，但使用库存设计更为合理。*图8.8*显示了我在使用的支架：
- en: '![Figure 8.8 – Ultrasonic HC-SR04 sensor brackets with the screws and hardware'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8 – 带有螺丝和硬件的超声波HC-SR04传感器支架'
- en: '](img/B15660_08_08.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15660_08_08.jpg)'
- en: Figure 8.8 – Ultrasonic HC-SR04 sensor brackets with the screws and hardware
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – 带有螺丝和硬件的超声波HC-SR04传感器支架
- en: 'These are easy to attach to your robot, assuming that your chassis is similar
    enough to mine, in that it has mounting holes or a slot to attach this bracket:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的底盘足够像我的一样，有安装孔或槽来安装这个支架，那么这些很容易附着到你的机器人上：
- en: '![Figure 8.9 – Steps for mounting the sensor bracket'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9 – 安装传感器支架的步骤'
- en: '](img/B15660_08_09.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15660_08_09.jpg)'
- en: Figure 8.9 – Steps for mounting the sensor bracket
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – 安装传感器支架的步骤
- en: 'To mount the sensor bracket, use *Figure 8.9* as a guide for the following
    steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装传感器支架，请使用*图8.9*作为以下步骤的指南：
- en: Push the two bolts into the holes on the bracket.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个螺栓推入支架上的孔中。
- en: Push the bracket screws through the holes at the front of the robot.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将支架螺丝从机器人前部的孔中穿过。
- en: Thread a nut from underneath the robot on each and tighten. Repeat this for
    the other side.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从机器人下方穿过一个螺母并拧紧。对另一侧重复此操作。
- en: The robot should look like this with the two brackets mounted.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装两个支架后，机器人应该看起来像这样。
- en: '*Figure 8.10* shows how to push the sensors into the brackets:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图8.10*展示了如何将传感器推入支架：'
- en: '![Figure 8.10 – Pushing the sensors into the brackets'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.10 – 将传感器推入支架'
- en: '](img/B15660_08_10.jpg)'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15660_08_10.jpg)'
- en: Figure 8.10 – Pushing the sensors into the brackets
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.10 – 将传感器推入支架
- en: Look at the sensor. The two transducer elements, the round cans with a gauze
    on top, will fit well in the holes in the brackets.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看传感器。两个换能器元件，顶部有网布的圆形罐，将很好地适合支架上的孔。
- en: The distance sensors can simply be pushed into the brackets, since they have
    a friction fit. The electrical connector for the sensor should be facing upward.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 距离传感器可以直接推入支架，因为它们有摩擦配合。传感器的电气连接器应朝上。
- en: After putting in both sensors, the robot should look like panel 7 of *Figure
    8.10*.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 放入两个传感器后，机器人应该看起来像*图8.10*的7号面板。
- en: You've now attached the sensors to the chassis. Before we wire them, we'll take
    a slight detour and add a helpful power switch.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经将传感器附着到底盘上了。在我们给它们接电线之前，我们将稍微偏离一下，添加一个有用的电源开关。
- en: Adding a power switch
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加电源开关
- en: 'Before we turn on the robot again, let''s add a switch for the motor power.
    This switch is more convenient than screwing the ground wire from the battery
    into the terminal repeatedly. We''ll see how to do this in three simple steps.
    Follow along:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们再次打开机器人之前，让我们为电机电源添加一个开关。这个开关比反复将电池的接地线拧入端子更方便。我们将看到如何用三个简单步骤来完成这个操作。请跟随：
- en: 'Make sure you have the following equipment ready, as shown in *Figure 8.11*:
    a breadboard, some velcro, a mini breadboard-friendly SPDT switch, and one length
    of single-core 22 AWG wire:![Figure 8.11 – Items needed to add a power switch'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你准备好了以下设备，如图*图8.11*所示：一个面包板，一些魔术贴，一个迷你面包板兼容的SPDT开关，以及一根单芯22 AWG线：![图8.11 –
    添加电源开关所需的物品
- en: '](img/B15660_08_11.jpg)'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15660_08_11.jpg)'
- en: Figure 8.11 – Items needed to add a power switch
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.11 – 添加电源开关所需的物品
- en: 'Now use two strips of Velcro to stick the breadboard on top of the robot''s
    battery, as shown in *Figure 8.12*. The velcro holds firm but is easy to remove
    if you need to disassemble the robot:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用两块魔术贴将面包板粘贴在机器人电池的顶部，如图*图8.12*所示。魔术贴固定牢固，但需要拆卸机器人时容易移除：
- en: '![Figure 8.12 – Adding velcro strips'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.12 – 添加魔术贴条'
- en: '](img/B15660_08_12.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15660_08_12.jpg)'
- en: Figure 8.12 – Adding velcro strips
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 – 添加魔术贴条
- en: With the breadboard in place, we can now add a switch.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 面包板就位后，我们现在可以添加一个开关。
- en: 'Take a look at *Figure 8.13* for details on how the switch is connected:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看*图8.13*，了解开关的连接细节：
- en: '![Figure 8.13 – Wiring the switch'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.13 – 连接开关'
- en: '](img/B15660_08_13.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15660_08_13.jpg)'
- en: Figure 8.13 – Wiring the switch
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 – 连接开关
- en: '*Figure 8.13* shows a circuit diagram, a close-up of a breadboard, and a suggested
    way to wire the physical connections on the robot. Let''s look at this in detail:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.13*显示了一个电路图，面包板的特写，以及如何在机器人上物理连接的推荐方式。让我们详细看看：'
- en: This is a circuit diagram showing the batteries, switch, and motor power input
    connectors. At the top is the *motor power in* terminal. From the positive (+)
    side of that terminal, a wire goes down the left to the batteries, shown as alternating
    thick and thin bars. From the batteries, the bottom terminal is their negative
    side. A wire goes from this around to the switch on the right of the diagram.
    The top of the switch is then connected via a wire to the negative (-) side of
    the *motor power in terminal*. This is the important diagram for making the connections.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个电路图，显示了电池、开关和电机电源输入连接器。顶部是*电机电源输入*端子。从该端子的正极（+）侧，一根电线沿着左侧下降到电池，显示为交替的粗细条。从电池出发，底部端子是它们的负极。一根电线从这绕到图右侧的开关上。开关的顶部通过一根电线连接到*电机电源输入端子*的负极（-）。这是制作连接的重要图。
- en: Before we physically wire the switch, it's worth talking about the rows of the
    breadboard. This panel shows a close-up of a breadboard, with 2 of the rows highlighted
    in green lines. The green lines show that the rows are connected in groups of
    5\. The arrangement of a breadboard has two wired groups of 5 holes (tie-points)
    for each of the rows (numbered 1 to 30). It has a groove in the middle separating
    the groups.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们实际连接开关之前，值得讨论一下面包板的行列。这个面板显示了面包板的一个特写，其中2行用绿色线条突出显示。绿色线条表明这些行列以5个一组连接。面包板的排列有两个5孔（连接点）的连线组，每个行列（编号1至30）都有一个。中间有一个凹槽将它们分开。
- en: The physical wiring uses the breadboard to make connections from wires to devices.
    It won't match the diagram precisely. The left shows the motor board, with a red
    wire from the batteries, their positive side, going into the positive (+ or VIN)
    terminal on the *motor power in terminal*. The batteries are in the middle. A
    black wire goes from the batteries into the breadboard in row 3, column *d*. In
    column *e*, a switch is plugged into the breadboard going across rows 1, 2, and
    3\. An orange precut 22 AWG wire goes from row 2 to the GND terminal, where it
    is screwed in. Sliding this switch turns on the power to the robot motors.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 物理布线使用面包板将电线连接到设备。它不会与图精确匹配。左侧显示电机板，从电池的正极（+或VIN）引脚进入，电池位于中间。一根黑色电线从电池进入面包板第3行第*d*列。在第*e*列，一个开关插入面包板，跨越第1、2和3行。一根橙色预切割的22
    AWG电线从第2行连接到GND端子，并拧紧。滑动这个开关打开机器人电机的电源。
- en: We've now given our robot a power switch for its motor batteries, so we can
    turn the motor power on without needing a screwdriver. Next, we will use the same
    breadboard to wire up the distance sensors.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的机器人提供了电机电池的电源开关，因此我们可以打开电机电源而无需螺丝刀。接下来，我们将使用相同的面包板来布线距离传感器。
- en: Wiring the distance sensors
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布线距离传感器
- en: 'Each ultrasonic sensor has four connections:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 每个超声波传感器有四个连接：
- en: A trigger pin to ask for a reading
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个触发引脚以请求读取
- en: An echo pin to sense the return
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于检测返回的回声引脚
- en: A VCC/voltage pin that should be 3.3 V
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个VCC/电压引脚，应为3.3 V
- en: A GND or ground pin
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个GND或地线引脚
- en: Ensure that the whole robot is switched off before proceeding any further. The
    trigger and echo pins need to go to GPIO pins on the Raspberry Pi.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行任何进一步操作之前，请确保整个机器人已经关闭。触发和回声引脚需要连接到树莓派的GPIO引脚。
- en: '*Figure 8.14* shows a close-up of the Raspberry Pi GPIO port to assist in making
    connections:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.14*显示了树莓派GPIO端口的特写，以帮助进行连接：'
- en: '![Figure 8.14 – Raspberry Pi connections'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.14 – 树莓派连接'
- en: '](img/B15660_08_14.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15660_08_14.jpg)'
- en: Figure 8.14 – Raspberry Pi connections
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 – 树莓派连接
- en: '*Figure 8.14* is a diagram view of the GPIO connector on the Raspberry Pi.
    This connector is the 40 pins set in two rows at the top of the Pi. Many robots
    and gadgets use them. The pin numbers/names are not printed on the Raspberry Pi,
    but this diagram should assist in finding them.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.14*是树莓派GPIO连接器的图视图。这个连接器是位于Pi顶部的两行40个引脚集。许多机器人和小工具都使用它们。引脚编号/名称没有打印在树莓派上，但这个图应该有助于找到它们。'
- en: 'We use a breadboard for this wiring. *Figure 8.15* shows the connections needed
    for these:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用面包板进行这项布线。*图8.15*显示了所需的连接：
- en: '![](img/B15660_08_15.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_08_15.jpg)'
- en: Figure 8.15 – Sensor wiring diagram
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 – 传感器布线图
- en: Wires from the Raspberry Pi to the breadboard, and from the sensor to the breadboard,
    need male-to-female jumper wires. Wires on the breadboard (there are only 4 of
    these) use short pre-cut wires. *Figure 8.15* shows a circuit diagram above, and
    a breadboard wiring suggestion below.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从树莓派到面包板，以及从传感器到面包板的线需要公对母跳线。面包板上的线（只有4根）使用短预切割线。*图8.15* 显示了上面的电路图，下面的面包板布线建议。
- en: 'To wire the sensors, use *Figure 8.15* as a guide, along with these steps:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要布线传感器，请以*图8.15* 为指导，并按照以下步骤操作：
- en: Start with the power connections. A wire goes from the 3.3 V (often written
    as 3v3 on diagrams) pin on the Raspberry Pi to the top, red-marked rail on the
    breadboard. We can use this red *rail* for other connections needing 3.3 V.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从电源连接开始。一根线从树莓派的3.3 V（通常在图表上写作3v3）引脚连接到面包板上的顶部红色标记轨道。我们可以使用这个红色 *轨道* 进行需要3.3
    V的其他连接。
- en: A wire from one of the GND pins on the Pi goes to the black- or blue-marked
    rail on the breadboard. We can use this blue *rail* for connections requiring
    GND.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 树莓派上的一根线连接到面包板上的黑色或蓝色标记的轨道。我们可以使用这个蓝色 *轨道* 进行需要GND的连接。
- en: Pull off a strip of 4 from the male-to-female jumper wires for each side.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从每侧的公对母跳线中拉出一条4芯的线。
- en: For the left-hand sensor, identify the four pins—VCC, trig, echo, and GND. For
    the connection from this to the breadboard, it's useful to keep the 4 wires together.
    Take 4 male-to-female connectors (in a joined strip if possible), from this sensor,
    and plug them into the board.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于左侧的传感器，识别四个引脚——VCC、trig、echo和GND。从这个到面包板的连接中，保持4根线在一起很有用。从这个传感器取4个公对母连接器（如果可能的话，在一个连接条中），并将它们插入到板上。
- en: On the breadboard, use the precut wires to make a connection from ground to
    the blue rail, and from VCC to the red rail.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在面包板上，使用预先切割的线将地线连接到蓝色轨道，并将VCC连接到红色轨道。
- en: Now use some jumper wires to make the signal connections from the trig/echo
    pins to the Raspberry Pi GPIO pins.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在请使用一些跳线将信号连接从trig/echo引脚到树莓派GPIO引脚。
- en: Important note
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: Depending on where you've placed your breadboard, the distance sensor wires
    may not reach. If this is the case, join two male-to-female wires back to back,
    and use some electrical tape to bind them together.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据您放置面包板的位置，距离传感器的线可能无法到达。如果是这种情况，将两个公对母线并排放置，并使用一些电工胶带将它们绑在一起。
- en: For neatness, I like to wrap wires in spiral wrap; this is entirely optional
    but can reduce the clutter on the robot.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了整洁，我喜欢用螺旋线包裹电线；这完全是可选的，但可以减少机器人上的杂乱。
- en: Please double-check your connections before you continue. You have now installed
    the distance sensors into your robot's hardware, but in order to test and use
    them, we need to prepare the software components.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请务必仔细检查您的连接。您已经将距离传感器安装到机器人的硬件中，但为了测试和使用它们，我们需要准备软件组件。
- en: Installing Python libraries to communicate with the sensor
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Python库以与传感器通信
- en: 'To work with the GPIO sensor, and some other hardware, you need a Python library.
    Let''s use the `GPIOZero` library, designed to help interface with hardware like
    this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要与GPIO传感器和一些其他硬件一起工作，您需要一个Python库。让我们使用`GPIOZero`库，该库旨在帮助与这种硬件进行接口：
- en: '[PRE0]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With the library now installed, we can write our test code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在库已经安装，我们可以编写测试代码。
- en: Reading an ultrasonic distance sensor
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取超声波距离传感器
- en: To write code for distance sensors, it helps to understand how they work. As
    suggested previously, this system works by bouncing sound pulses off of objects
    and measuring the pulse return times.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要为距离传感器编写代码，了解它们的工作原理很有帮助。如前所述，该系统通过从物体上反射声脉冲并测量脉冲返回时间来工作。
- en: The code on the Raspberry Pi sends an electronic pulse to the **trigger** pin
    to ask for a reading. In response to this pulse, the device makes a sound pulse
    and times its return. The **echo** pin responds using a pulse too. The length
    of this pulse corresponds to the sound travel time.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派上的代码向**触发**引脚发送电子脉冲以请求读取。作为对此脉冲的响应，设备发出声脉冲并测量其返回时间。**回声**引脚也使用脉冲进行响应。这个脉冲的长度对应于声音的传播时间。
- en: 'The graph in *Figure 8.16* shows the timing of these:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.16* 中的图表显示了这些的时序：'
- en: '![Figure 8.16 – Timing of a pulse and the response for an ultrasonic distance
    sensor'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.16 – 超声波距离传感器的脉冲时序和响应'
- en: '](img/B15660_08_16.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15660_08_16.jpg]'
- en: Figure 8.16 – Timing of a pulse and the response for an ultrasonic distance
    sensor
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 8.16 – 超声波距离传感器的脉冲时序和响应
- en: The `GPIOZero` library can time this pulse, and convert it into a distance,
    which we can use in our code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`GPIOZero` 库可以测量这个脉冲，并将其转换为距离，我们可以在代码中使用它。'
- en: The device might fail to get a return response in time if the sound didn't echo
    back soon enough. Perhaps the object was outside the sensor's range, or something
    dampened the sound.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果声音没有很快回声，设备可能无法及时获得返回响应。也许物体超出了传感器的范围，或者有什么东西减弱了声音。
- en: 'As we did with our servo motor control class previously, we should use comments
    and descriptive names to help us explain this part of the code. I''ve called this
    file `test_distance_sensors.py`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在之前的伺服电机控制类中所做的那样，我们应该使用注释和描述性名称来帮助我们解释这部分代码。我已经将这个文件命名为 `test_distance_sensors.py`：
- en: 'Begin by importing `time` and the `DistanceSensor` library:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入 `time` 和 `DistanceSensor` 库：
- en: '[PRE1]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we set up the sensors. I''ve used `print` statements to show what is
    going on. In these lines, we create library objects for each distance sensor,
    registering the pins we have connected them on. Try to make sure these match your
    wiring:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们设置传感器。我使用了 `print` 语句来显示正在发生的事情。在这些行中，我们为每个距离传感器创建库对象，注册我们连接它们的引脚。确保这些与你的接线匹配：
- en: '[PRE2]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This test then runs in a loop until we cancel it:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个测试将在我们取消它之前循环运行：
- en: '[PRE3]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We then print the distance from our sensors. `.distance` is a property, as
    we saw with the `.count` property on our LED system earlier in the book. The sensors
    are continuously updating it. We multiply it by 100 since `GPIOZero` distance
    is in terms of a meter:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们然后打印出传感器的距离。`.distance` 是一个属性，就像我们在书中早些时候在LED系统上的 `.count` 属性所看到的那样。传感器会持续更新它。我们将其乘以100，因为
    `GPIOZero` 的距离是以米为单位的：
- en: '[PRE4]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A little sleep in the loop stops it flooding the output too much and prevents
    tight looping:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环中稍微休息一下可以防止输出过多，并防止紧密循环：
- en: '[PRE5]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, you can turn on your Raspberry Pi and upload this code.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以打开你的Raspberry Pi并上传这段代码。
- en: Put an object anywhere between 4 centimeters and 1 meter away from the sensor,
    as demonstrated in the following image:![](img/B15660_08_17.jpg)
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将物体放在距离传感器4厘米到1米之间的任何地方，如下面的图片所示！[](img/B15660_08_17.jpg)
- en: Figure 8.17 – Distance sensor with object
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.17 – 带有物体的距离传感器
- en: '*Figure 8.17* shows an item roughly 10.5 cm from a sensor. The object is a
    small toolbox. Importantly it is rigid and not fabric.'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图8.17* 显示了一个大约10.5厘米远处的传感器上的物体。这个物体是一个小工具箱。重要的是它很坚固，不是布制品。'
- en: 'Start the code on the Pi with `python3 test_distance_sensors.py`. As you move
    around the object, your Pi should start outputting distances:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `python3 test_distance_sensors.py` 在Pi上启动代码。当你移动物体时，你的Pi应该开始输出距离：
- en: '[PRE6]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Because it is in a loop, you need to press *Ctrl* + *C* to stop the program
    running.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为它在循环中，你需要按 *Ctrl* + *C* 来停止程序运行。
- en: 'You''ll see here that there are many decimal places, which isn''t too helpful
    here. First, the devices are unlikely to be that accurate, and second, our robot
    does not need sub-centimeter accuracy to make decisions. We can modify the print
    statement in the loop to be more helpful:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到这里有很多小数位，这在这里并不太有帮助。首先，设备不太可能那么精确，其次，我们的机器人不需要亚厘米级的精度来做出决策。我们可以在循环中修改打印语句，使其更有帮助：
- en: '[PRE7]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Running the code with this change gives the following output:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个更改运行代码会得到以下输出：
- en: '[PRE8]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You've demonstrated that the distance sensor is working. Added to this is exploring
    how you can tune the output from a sensor for debugging, something you'll do a
    lot more when making robots. To make sure you're on track, let's troubleshoot
    anything that has gone wrong.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经证明了距离传感器正在工作。除此之外，我们还探索了如何调整传感器的输出以进行调试，这在制作机器人时你会做得多得多。为了确保你走在正确的道路上，让我们排除任何出现的问题。
- en: Troubleshooting
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'If this sensor isn''t working as expected, try the following troubleshooting
    steps:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个传感器没有按预期工作，请尝试以下故障排除步骤：
- en: Is anything hot in the wiring? Hold the wires to the sensor between the thumb
    and forefinger. *Nothing should be hot or even warming*! If so, remove the batteries,
    turn off the Raspberry Pi, and thoroughly check all wiring against *Figure 8.12*.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线路中有什么东西热吗？用拇指和食指捏住线，将其夹在传感器之间。*不应该有任何东西是热的，甚至温暖*！如果是这样，请取出电池，关闭Raspberry Pi，并彻底检查所有线路与
    *图8.12* 的对比。
- en: If there are syntax errors, please check the code against the examples. You
    should have installed Python libraries with `pip3` and be running with `python3`.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有语法错误，请将代码与示例进行对比。你应该已经使用 `pip3` 安装了Python库，并且正在使用 `python3` 运行。
- en: If you are still getting errors, or invalid values, please check the code and
    indentation.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你仍然收到错误或无效的值，请检查代码和缩进。
- en: If the values are always `0`, or the sensor isn't returning any values, then
    you may have swapped trigger and echo pins. Try swapping the trigger/echo pin
    numbers in the code and testing it again. *Don't* swap the cables on a live Pi!
    Do this one device at a time.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果值始终为`0`，或者传感器没有返回任何值，那么您可能已经交换了触发和回声引脚。尝试在代码中交换触发/回声引脚编号并再次测试。*不要*在实时 Pi 上交换电缆！一次只对一个设备这样做。
- en: If you are still getting no values, ensure you have purchased 3.3 V-compatible
    systems. The HC-SR04 model will not work with the bare Raspberry Pi.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您仍然没有获取到任何值，请确保您已经购买了 3.3 V 兼容的系统。HC-SR04 模型与裸 Raspberry Pi 不兼容。
- en: If values are way out or drifting, then ensure that the surface you are testing
    on is hard. Soft surfaces, such as clothes, curtains, or your hand, do not respond
    as well as glass, wood, metal, or plastic. A wall works well!
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果值偏离太远或漂移，请确保您正在测试的表面是坚硬的。柔软的表面，如衣物、窗帘或您的手，不如玻璃、木材、金属或塑料反应灵敏。墙壁效果很好！
- en: Another reason for incorrect values is the surface may be too small. Make sure
    that your surface is quite wide. Anything smaller than about 5 cm square may be
    harder to measure.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不正确值的另一个原因是表面可能太小。确保您的表面相当宽。任何小于约 5 平方厘米的物体可能更难测量。
- en: As a last resort, if one sensor seems fine, and the other wrong, it's possible
    that a device is faulty. Try swapping the sensors to check this. If the result
    is different, then a sensor may be wrong. If the result is the same, it is the
    wiring or code that is wrong.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为最后的手段，如果其中一个传感器看起来正常，而另一个传感器有问题，那么可能是一个设备出现了故障。尝试交换传感器来检查这一点。如果结果不同，那么可能是一个传感器出现了问题。如果结果相同，那么可能是接线或代码出现了问题。
- en: You have now troubleshooted your distance sensor and made sure that it works.
    You have seen it output values to show that it is working and tested it with objects
    to see its response. Now, let's step up and write a script to avoid obstacles.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经对距离传感器进行了故障排除，并确保它正常工作。您已经看到它输出值以表明它正在工作，并使用物体测试了它的响应。现在，让我们提高一步，编写一个避免障碍的脚本。
- en: Avoiding walls – writing a script to avoid obstacles
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免墙壁 – 编写避免障碍的脚本
- en: Now that we have tested both sensors, we can integrate them with our robot class
    and make obstacle avoidance behavior for them. This behavior loop reads the sensors
    and then chooses behavior accordingly.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经测试了两个传感器，我们可以将它们集成到我们的机器人类中，并为它们制作避障行为。这个行为循环读取传感器，然后根据结果选择相应的行为。
- en: Adding the sensors to the robot class
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将传感器添加到机器人类中
- en: 'So, before we can use the sensors in a behavior, we need to add them to the
    `Robot` class, assigning the correct pin numbers for each side. This way, if pin
    numbers change or even the interface to a sensor changes, behaviors will not need
    to change:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们可以在行为中使用传感器之前，我们需要将它们添加到`Robot`类中，为每个侧面分配正确的引脚编号。这样，如果引脚编号更改或传感器的接口更改，行为就不需要更改：
- en: 'To use the `DistanceSensor` object, we need to import it from `gpiozero`; the
    new code is in bold:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用`DistanceSensor`对象，我们需要从`gpiozero`导入它；新的代码以粗体显示：
- en: '[PRE9]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We create an instance of one of these `DistanceSensor` objects for each side
    in the robot class. We need to set these up in the constructor for our robot.
    We use the same pin numbers and queue length as in our test:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在机器人类中为每个侧面创建一个`DistanceSensor`对象的实例。我们需要在机器人的构造函数中设置这些。我们使用与测试中相同的引脚编号和队列长度：
- en: '[PRE10]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Adding this to our robot layer makes it available to behaviors. When we create
    our robot, the sensors will be sampling distances. Let's make a behavior that
    uses them.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将此添加到我们的机器人层中，使其对行为可用。当我们创建我们的机器人时，传感器将测量距离。让我们创建一个使用它们的动作。
- en: Making the obstacle avoid behaviors
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作避障行为
- en: 'This chapter is all about getting a behavior; how can a robot drive and avoid
    (most) obstacles? The sensor''s specifications limit it, with smaller objects
    or objects with a soft/fuzzy shell, such as upholstered items, not being detected.
    Let''s start by drawing what we mean in *Figure 8.18*:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于获取行为；机器人如何驾驶和避免（大多数）障碍？传感器的规格限制了它，对于较小的物体或外壳柔软/毛茸茸的物体，如家具，可能无法检测到。让我们先从我们在*图
    8.18*中想要表达的意思开始画起：
- en: '![Figure 8.18 – Obstacle avoidance basics'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.18 – 避障基础知识'
- en: '](img/B15660_08_18.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15660_08_18.jpg)'
- en: Figure 8.18 – Obstacle avoidance basics
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.18 – 避障基础知识
- en: In our example (*Figure 8.18*), a basic robot detects a wall, turns away, keeps
    driving until another wall is detected, and then turns away from that. We can
    use this to make our first attempt at wall-avoiding behavior.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子（*图8.18*）中，一个基本的机器人检测到墙壁，转向避开，直到检测到另一面墙壁，然后再次避开。我们可以利用这一点来尝试制作我们的第一次避障行为尝试。
- en: First attempt at obstacle avoidance
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 首次尝试避障
- en: 'To help us understand this task, the following diagram shows a flow diagram
    for the behavior:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们理解这个任务，以下图表显示了该行为的流程图：
- en: '![Figure 8.19 – Obstacle avoidance flowchart'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.19 – 避障流程图'
- en: '](img/B15660_08_19.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15660_08_19.jpg](img/B15660_08_19.jpg)'
- en: Figure 8.19 – Obstacle avoidance flowchart
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19 – 避障流程图
- en: The flow diagram in *Figure 8.19* starts at the top.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.19*中的流程图从顶部开始。'
- en: 'This diagram describes a loop that does the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表描述了一个循环，执行以下操作：
- en: The **Start** box goes into a **Get Distances** box, which gets the distances
    from each sensor.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**开始**框进入**获取距离**框，该框获取每个传感器的距离。'
- en: 'We test whether the left sensor reads less than 20 cm (a reasonable threshold):'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们测试左侧传感器是否读取的距离小于20厘米（一个合理的阈值）：
- en: a) If so, we set the left motor in reverse to turn the robot away from the obstacle.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 如果是，我们将左侧电机设置为反向，使机器人避开障碍物。
- en: b) Otherwise, we drive the left motor forward.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 否则，我们驱动左侧电机向前。
- en: We now check the right sensor, setting it backward if closer than 20 cm, or
    forward if not.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在检查右侧传感器，如果距离小于20厘米，则将其向后设置，否则向前设置。
- en: The program waits a short time and loops around again.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序等待一小段时间，然后再次循环。
- en: 'We put this loop in a `run` method. There›s a small bit of setup required in
    relation to this. We need to set the pan and tilt to `0` so that it won''t obstruct
    the sensors. I''ve put this code in `simple_avoid_behavior.py`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将此循环放在`run`方法中。与此相关需要一些小的设置。我们需要将俯仰和倾斜设置为`0`，以免遮挡传感器。我已经将此代码放在`simple_avoid_behavior.py`中：
- en: 'Start by importing the robot, and `sleep` for timing:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先导入机器人，并使用`sleep`进行计时：
- en: '[PRE11]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following class is the basis of our behavior. There is a robot object stored
    in the behavior. A speed is set, which can be adjusted to make the robot go faster
    or slower. Too fast, and it has less time to react:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下类是我们行为的基础。在行为中存储了一个机器人对象。设置了一个速度，可以调整以使机器人行驶更快或更慢。太快，它反应的时间就会减少：
- en: '[PRE12]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now the following method chooses a speed for each motor, depending on the distance
    detected by the sensor. A nearer sensor distance turns away from the obstacle:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在以下方法根据传感器检测到的距离为每个电机选择速度。较近的传感器距离会避开障碍物：
- en: '[PRE13]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `run` method is the core, since it has the main loop. We put the pan and
    tilt mechanism in the middle so that it doesn''t obstruct the sensors:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`run`方法是核心，因为它包含主循环。我们将俯仰和倾斜机构放在中间，以免遮挡传感器：'
- en: '[PRE14]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we start the main loop:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们开始主循环：
- en: '[PRE15]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We then print out our readings on the console:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后在控制台打印出我们的读数：
- en: '[PRE16]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we use the distances with our `get_motor_speed` method and send this to
    each motor:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用`get_motor_speed`方法中的距离，并将其发送到每个电机：
- en: '[PRE17]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since this is our main loop, we wait a short while before we loop again. Under
    this is the setup and starting behavior:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是我们主要的循环，我们在再次循环之前会等待一小段时间。下面是设置和起始行为：
- en: '[PRE18]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The code for this behavior is now completed and ready to run. It's time to try
    it out. To test this, set up a test space to be a few square meters wide. Avoid
    obstacles that the sensor misses, such as upholstered furniture or thin obstacles
    such as chair legs. I've used folders and plastic toy boxes to make courses for
    these.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个行为的代码现在已经完成，可以运行。是时候尝试一下了。为了测试，设置一个测试空间，宽度为几平方米。避免传感器无法检测到的障碍物，如软垫家具或细小的障碍物，如椅子腿。我使用了文件夹和塑料玩具箱来制作这些课程。
- en: Send the code to the robot and try it out. It drives until it encounters an
    obstacle, and then turns away. This kind of works; you can tweak the speeds and
    thresholds, but the behavior gets stuck in corners and gets confused.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码发送到机器人并尝试运行。它会行驶直到遇到障碍物，然后转向避开。这有点效果；你可以调整速度和阈值，但行为会在角落里卡住，并且会感到困惑。
- en: Perhaps it's time to consider a better strategy.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 也许现在是考虑更好的策略的时候了。
- en: More sophisticated object avoidance
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更复杂的物体避障
- en: The previous behavior can leave the robot stuck. It appears to be indecisive
    with some obstacles and occasionally ends up ramming others. It may not stop in
    time or turn into things. Let's make a better one that drives more smoothly.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的行为可能会让机器人陷入停滞。它面对一些障碍物时显得犹豫不决，偶尔还会撞到其他物体。它可能无法及时停止或转向避开物体。让我们制作一个行驶更平稳的更好版本。
- en: 'So, what is our strategy? Well, let''s think in terms of the sensor nearest
    to an obstacle, and the furthest. We can work out the speeds of the motor nearest
    to it, the motor further from it, and a time delay. Our code uses the time delay
    to be decisive about turning away from a wall, with the time factor controlling
    how far we turn. This reduces any jitter. Let''s make some changes to the last
    behavior for this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们的策略是什么呢？好吧，让我们从最靠近障碍物的传感器和最远的传感器来思考。我们可以计算出最靠近它的电机的速度，远离它的电机的速度，以及一个时间延迟。我们的代码使用时间延迟来决定是否从墙上转向，时间因素控制我们转多远。这减少了任何抖动。让我们对最后的行为做一些修改：
- en: First, copy the `simple_avoid_behavior.py` file into a new file called `avoid_behavior.py`.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将`simple_avoid_behavior.py`文件复制到一个名为`avoid_behavior.py`的新文件中。
- en: 'We won''t be needing `get_motor_speed`, so remove that. We replace it with
    a function called `get_speeds`. This takes one parameter, `nearest_distance`,
    which should always be the distance sensor with the lower reading:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将不再需要`get_motor_speed`，所以将其删除。我们用名为`get_speeds`的函数来替换它。这个函数接受一个参数，`nearest_distance`，它应该是读数较低的距离传感器：
- en: '[PRE19]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These numbers are all for fine-tuning. The essential factor is that depending
    on the distance, we slow down the motor further from the obstacle, and if we get
    too close, it drives away. Based on the time delay, and knowing which motor is
    which, we can drive our robot.
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些数字都是为了微调。关键因素是，根据距离，我们让远离障碍物的电机减速，如果我们太靠近，它会驶离。基于时间延迟，并且知道哪个电机是哪个，我们可以控制我们的机器人。
- en: 'Most of the remaining code stays the same. This is the `run` function you''ve
    already seen:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大部分剩余的代码保持不变。这是你之前已经见过的`run`函数：
- en: '[PRE20]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It now uses the `get_speeds` method to determine a nearest and furthest distance.
    Notice that we take the `min`, or minimum, of the two distances. We get back the
    speeds for both motors and a delay, and then print out the variables so we can
    see what''s going on:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在它使用`get_speeds`方法来确定最近和最远的距离。注意，我们取两个距离中的`min`，即最小值。我们得到两个电机的速度和一个延迟，然后打印出变量，这样我们就可以看到发生了什么：
- en: '[PRE21]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we check which side is nearer, left or right, and set up the correct motors:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们检查哪一侧更近，左边还是右边，并设置正确的电机：
- en: '[PRE22]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Instead of sleeping a fixed amount of time, we sleep for the amount of time
    in the `delay` variable. The delay is in milliseconds, so we need to multiply
    it to get seconds:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不是固定睡眠一段时间，而是根据`delay`变量中的时间睡眠。延迟是以毫秒为单位的，所以我们需要将其乘以得到秒数：
- en: '[PRE23]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The rest of the code remains the same. You can find the full code for this file
    at [https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter8](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter8).
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的其他部分保持不变。你可以在[https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter8](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter8)找到这个文件的完整代码。
- en: When you run this code, you should see smoother avoidance. You may need to tweak
    the timings and values. The bottom two conditions, reversing and reverse turning,
    might need to be tuned. Set the timings higher if the robot isn't quite pulling
    back enough, or lower if it turns away too far.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你应该看到更平滑的避开行为。你可能需要调整时间和值。最后两个条件，反转和反转转向，可能需要调整。如果机器人拉回不够，则将时间设置得更高，如果它转得太远，则设置得更低。
- en: There are still flaws in this behavior, though. It does not construct a map
    at all and has no reverse sensors, so while avoiding objects in front, it can
    quite quickly reverse into objects behind it. Adding more sensors could resolve
    some of these problems. Still, we cannot construct a map just yet as our robot
    does not have the sensors to determine how far it has turned or traveled accurately.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这种行为仍然存在缺陷。它根本不会构建地图，也没有反向传感器，所以当它避开前面的物体时，它可以相当快地反向撞到后面的物体。增加更多的传感器可以解决一些这些问题。然而，我们仍然不能构建地图，因为我们的机器人没有传感器来准确确定它转了多少圈或行驶了多少距离。
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have added sensors to our robot. This is a major step as
    it makes the robot autonomous, behaving on its own and responding in some way
    to its environment. You've learned how to add distance sensing to our robots,
    along with the different kinds of sensors that are available. We've seen code
    to make it work and test these sensors. We then created behaviors to avoid walls
    and looked at how to make a simplified but flawed behavior, and how a more sophisticated
    and smoother behavior would make for a better system.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为我们的机器人添加了传感器。这是一个重要的步骤，因为它使机器人能够自主行动，独立行为并对其环境做出某种反应。你已经学会了如何为我们的机器人添加距离感应，以及可用的不同类型的传感器。我们看到了使它工作并测试这些传感器的代码。然后我们创建了避免墙壁的行为，并研究了如何制作一个简化但存在缺陷的行为，以及一个更复杂、更平滑的行为将如何使系统更好。
- en: With this experience, you can consider how other sensors could be interfaced
    with your robot, and some simple code to interact with them. You can output data
    from sensors so you can debug their behavior and create a behavior to make a robot
    perform some simple navigation on its own.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这次经验，你可以考虑如何将其他传感器与你的机器人接口，以及一些简单的代码来与之交互。你可以从传感器输出数据，以便调试其行为并创建一个行为，使机器人能够自行进行简单的导航。
- en: In the next chapter, we look further into driving predetermined paths and straight
    lines using an encoder to make sure that the robot moves far more accurately.
    We use an encoder to compare our motor's output with our expected goals and get
    more accurate turns.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步探讨使用编码器驱动预定路径和直线，以确保机器人移动得更加准确。我们使用编码器来比较电机的输出与预期的目标，以获得更精确的转向。
- en: Exercises
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Some robots get by with just a single sensor. Can you think of a way of avoiding
    obstacles reliably with a single sensor?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些机器人只需要一个传感器就能应对。你能想到一种只用一个传感器可靠地避开障碍物的方法吗？
- en: We have a pan/tilt mechanism, which we use later for a camera. Consider putting
    a sensor on this, and how to incorporate this into a behavior.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个俯仰/倾斜机构，我们稍后会用它来安装摄像头。考虑在这个机构上放置一个传感器，以及如何将其整合到行为中。
- en: The robot behavior we created in this chapter can reverse into things. How could
    you remedy this? Perhaps make a plan and try to build it.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章中，我们创建的机器人行为可以反向变成其他事物。你该如何解决这个问题呢？或许可以制定一个计划并尝试去构建它。
- en: Further reading
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Please refer to the following links for more information:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下链接获取更多信息：
- en: The RCWL-1601 is still quite similar to the HC-SR04\. The HC-SR04 data sheet
    has useful information about its range. You can find the data sheet at [https://www.mouser.com/ds/2/813/HCSR04-1022824.pdf](https://www.mouser.com/ds/2/813/HCSR04-1022824.pdf).
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RCWL-1601 与 HC-SR04 非常相似。HC-SR04 数据表提供了关于其范围的 useful 信息。你可以在 [https://www.mouser.com/ds/2/813/HCSR04-1022824.pdf](https://www.mouser.com/ds/2/813/HCSR04-1022824.pdf)
    找到数据表。
- en: 'ModMyPi has a tutorial with an alternative way to wire the original HC-SR04
    types, and level shift their IO: [https://www.modmypi.com/blog/hc-sr04-ultrasonic-range-sensor-on-the-raspberry-pi](https://www.modmypi.com/blog/hc-sr04-ultrasonic-range-sensor-on-the-raspberry-pi).'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ModMyPi 有一个教程，介绍了另一种连接原始 HC-SR04 类型传感器的方法，以及如何进行电平转换其 IO：[https://www.modmypi.com/blog/hc-sr04-ultrasonic-range-sensor-on-the-raspberry-pi](https://www.modmypi.com/blog/hc-sr04-ultrasonic-range-sensor-on-the-raspberry-pi)。
- en: Raspberry Pi Tutorials also has a breadboard layout and Python script, using
    `RPi.GPIO` instead of `gpiozero`, at [https://tutorials-raspberrypi.com/raspberry-pi-ultrasonic-sensor-hc-sr04/](https://tutorials-raspberrypi.com/raspberry-pi-ultrasonic-sensor-hc-sr04/).
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi Tutorials 还提供了一个面包板布局和 Python 脚本，使用 `RPi.GPIO` 而不是 `gpiozero`，请参阅
    [https://tutorials-raspberrypi.com/raspberry-pi-ultrasonic-sensor-hc-sr04/](https://tutorials-raspberrypi.com/raspberry-pi-ultrasonic-sensor-hc-sr04/)。
- en: We've started to use many pins on the Raspberry Pi. When trying to ascertain
    which pins to use, I highly recommend visiting the Raspberry Pi GPIO at [https://pinout.xyz/](https://pinout.xyz/).
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经开始在 Raspberry Pi 上使用许多引脚。在尝试确定使用哪些引脚时，我强烈建议访问 Raspberry Pi GPIO [https://pinout.xyz/](https://pinout.xyz/)。
- en: We briefly mentioned debug output and refining it. W3schools has an interactive
    guide to Python format strings at [https://www.w3schools.com/python/ref_string_format.asp](https://www.w3schools.com/python/ref_string_format.asp).
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们简要提到了调试输出和改进它。W3schools 提供了一个关于 Python 格式字符串的交互式指南 [https://www.w3schools.com/python/ref_string_format.asp](https://www.w3schools.com/python/ref_string_format.asp)。
- en: There are many scholarly articles available on more interesting or sophisticated
    object behavior. I recommend reading *Simple, Real-Time Obstacle Avoidance Algorithm*
    ([https://pdfs.semanticscholar.org/519e/790c8477cfb1d1a176e220f010d5ec5b1481.pdf](https://pdfs.semanticscholar.org/519e/790c8477cfb1d1a176e220f010d5ec5b1481.pdf))
    for mobile robots for a more in-depth look at these behaviors.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在更多有趣或复杂的对象行为方面，有许多学术文章可供参考。我建议阅读*简单、实时障碍物避障算法*([https://pdfs.semanticscholar.org/519e/790c8477cfb1d1a176e220f010d5ec5b1481.pdf](https://pdfs.semanticscholar.org/519e/790c8477cfb1d1a176e220f010d5ec5b1481.pdf))，以深入了解这些行为。
