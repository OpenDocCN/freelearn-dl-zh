- en: Regular Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下实例：
- en: Regular expression – learning to use *, +, and ?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式——学习使用 `*`、`+` 和 `?`
- en: Regular expression – learning to use $ and ^, and the non-start and non-end
    of a word
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式——学习使用 `$` 和 `^`，以及单词的非开始和非结束匹配
- en: Searching multiple literal strings and substring occurrence
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索多个字面字符串和子字符串出现位置
- en: Learning to create date regex and a set of characters or ranges of character
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习创建日期正则表达式和字符集或字符范围
- en: Finding all five character words and making abbreviations in some sentences
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找所有五个字符的单词，并在某些句子中创建缩写
- en: Learning to write your own regex tokenizer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习编写你自己的正则表达式分词器
- en: Learning to write your own regex stemmer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习编写你自己的正则表达式词干提取器
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we saw what preprocessing tasks you would want to perform
    on your raw data. This chapter, immediately after, provides an excellent opportunity
    to introduce regular expressions. Regular expressions are one of the most simple
    and basic, yet most important and powerful, tools that you will learn. More commonly
    known as regex, they are used to match patterns in text. We will learn exactly
    how powerful this is in this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了你在处理原始数据时可能需要执行的预处理任务。本章紧接着提供了一个很好的机会来介绍正则表达式。正则表达式是最简单和基础的工具之一，但也是最重要和强大的工具之一，它们用于在文本中匹配模式。在本章中，我们将学习它到底有多强大。
- en: We do not claim that you will be an expert in writing regular expressions after
    this chapter and that is perhaps not the goal of this book or this chapter. The
    aim of this chapter is to introduce you to the concept of pattern matching as
    a way to do text analysis and for this, there is no better tool to start with
    than regex. By the time you finish the recipes, you shall feel fairly confident
    of performing any text match, text split, text search, or text extraction operation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不声称在本章结束后你会成为正则表达式编写的专家，这也许不是本书或本章的目标。本章的目的是介绍模式匹配的概念，作为文本分析的一种方式，而要开始学习，正则表达式是最好的工具。通过完成这些实例，你应该会对执行任何文本匹配、文本分割、文本搜索或文本提取操作充满信心。
- en: Let's look at the aforementioned recipes in detail.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看一下前面提到的实例。
- en: Regular expression – learning to use *, +, and ?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式——学习使用 `*`、`+` 和 `?`
- en: We start off with a recipe that will elaborate the use of the , `+`, and `?` operators in
    regular expressions. These short-hand operators are more commonly known as wild
    cards, but I prefer to call them zero or more (`*`) one or more (`+`), and zero
    or one (`?`) for distinction. These names are much more intuitive if you think
    about them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个例子开始，详细说明如何在正则表达式中使用 `+` 和 `?` 操作符。这些简写操作符通常被称为通配符，但我更喜欢将它们称为零个或多个（`*`）、一个或多个（`+`）、以及零个或一个（`?`），以便区分。如果你从这个角度思考，它们的名称会更加直观。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The regular expressions library is a part of the Python package and no additional
    packages need to be installed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式库是 Python 包的一部分，无需安装额外的包。
- en: How to do it…
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到……
- en: 'Create a file named `regex1.py` and add the following `import` line to it:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `regex1.py` 的文件，并在其中添加以下 `import` 语句：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This imports the `re` object, which allows processing and implementation of
    regular expressions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码导入了 `re` 模块，它允许我们处理和应用正则表达式。
- en: 'Add the following Python function in the file that is supposed to apply the
    given patterns for matching:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在要应用给定模式进行匹配的文件中添加以下 Python 函数：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function accepts two arguments; `text` is the input text on which the `patterns`
    will be applied for match.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受两个参数；`text` 是输入的文本，`patterns` 是将在其上应用的匹配模式。
- en: 'Now, let''s define the function. Add the following lines under the function:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义函数。在函数下方添加以下几行代码：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `re.search()` method applies the given pattern to the `text` object and
    returns true or false depending on the outcome after applying the method. That
    is the end of our function.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`re.search()` 方法将给定模式应用于 `text` 对象，并根据应用结果返回真或假。到此为止，函数结束。'
- en: 'Let''s apply the wild card patterns one by one. We start with zero or one:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们逐个应用这些通配符模式。我们从零个或一个开始：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s look at this pattern `ab?`. What this means is a followed by zero or
    one `b`. Let''s see what the output will be when we execute these three lines:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们来看这个模式 `ab?`。它的意思是一个 `a` 后面跟零个或一个 `b`。我们来看一下当我们执行这三行代码时输出会是什么：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, all of them found a match. These patterns are trying to match a part of
    the input and not the entire input; hence, they find a match with all three inputs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有的模式都找到了匹配。这些模式尝试匹配输入的一部分，而不是整个输入；因此，它们在所有三个输入中都找到了匹配。
- en: 'On to the next one, zero or more! Add the following three lines:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，来看零个或多个！添加以下三行：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The same set of inputs but a different string. The pattern says, `a` followed
    by zero or more `b`. Let''s see the output of these three lines:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相同的输入集，但不同的字符串。模式表示，`a` 后面跟着零个或多个 `b`。让我们看看这三行的输出：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, all the texts find a match. As rule of thumb, whatever matches
    zero or one wild card will also match zero or more. The `?` wildcard is a subset
    of `*`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，所有文本都找到了匹配项。通常来说，任何匹配零个或一个通配符的也会匹配零个或多个。`?` 通配符是 `*` 的一个子集。
- en: 'Now, the one or more wild card. Add the following lines:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，来看一下一个或多个的通配符。添加以下几行：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The same input! Just that the pattern contains the `+` one or more wild card.
    Let''s see the output:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相同的输入！只是模式中包含了 `+`（一个或多个通配符）。让我们看看输出：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, the first input string couldn't find the match. The rest did
    as expected.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，第一个输入字符串没有找到匹配项。其余的都按预期找到了匹配。
- en: 'Now, being more specific in the number of repetitions, add the following line:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更具体地指定重复次数，添加以下这一行：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The pattern says `a` followed by exactly two `b`. Needless to say, the pattern
    will find a match in the input text.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 模式表示 `a` 后面跟着正好两个 `b`。不用说，这个模式将在输入文本中找到匹配项。
- en: 'Time for a range of repetitions! Add the following line:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候来进行一系列重复操作了！添加以下这一行：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will also be a match as we have as a substring `a` followed by four `b`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这也会匹配，因为我们有一个子串 `a` 后跟四个 `b`。
- en: The output of the program won't really make much sense in full. We have already
    `ana.ysed` the output of each and every step; hence, we won't be printing it down
    here again.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出完全没有什么意义。我们已经 `ana.ysed` 了每一个步骤的输出；因此，我们在这里不会再次打印出来。
- en: How it works…
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `re.search()` function is a function that will only apply the given pattern
    as a test and will return true or false as the result of the test. It won't return
    the matching value. For that, there are other re functions that we shall learn
    in later recipes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`re.search()` 函数是一个只会将给定模式作为测试应用的函数，并会返回测试结果的真或假。它不会返回匹配的值。对于这个，还有其他 `re` 函数，我们将在后续的食谱中学习。'
- en: Regular expression – learning to use $ and ^, and the non-start and non-end
    of a word
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式 – 学习如何使用 $ 和 ^，以及单词的非开始和非结束
- en: The starts with (^) and ends with ($) operators are indicators used to match
    the given patterns at the start or end of an input text.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以 (^) 开头并以 ($) 结尾的操作符是用于匹配输入文本开头或结尾的指示符。
- en: Getting ready
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We could have reused the `text_match()` function from the previous recipe, but
    instead of importing an external file, we shall rewrite it. Let's look at the
    recipe implementation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以重用之前食谱中的 `text_match()` 函数，但我们不打算导入外部文件，而是重新编写它。让我们看看食谱的实现。
- en: How to do it…
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Create a file named `regex2.py` and add the following `import` line to it:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `regex2.py` 的文件，并添加以下 `import` 语句：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add this Python function in the file that is supposed to apply the given patterns
    for matching:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个 Python 函数添加到应该应用给定模式进行匹配的文件中：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This function accepts two arguments; `text` is the input text on which `patterns`
    will be applied for matching and will return whether the match was found or not.
    The function is exactly what we wrote in the previous recipe.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受两个参数；`text` 是输入文本，`patterns` 将应用于该文本以进行匹配，并返回是否找到匹配项。这个函数正是我们在之前食谱中编写的。
- en: 'Let''s apply the following pattern. We start with a simple starts with ends
    with:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们应用以下模式。我们从一个简单的以“开始于”和“结束于”开始：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s look at this pattern, `^a.*c$`. This means: start with `a`, followed
    by zero or more of any characters, and end with `c`. Let''s see the output when
    we execute these three lines:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看这个模式，`^a.*c$`。这意味着：以 `a` 开头，后跟零个或多个任意字符，并以 `c` 结尾。让我们看看执行这三行时的输出：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It found a match for the input text, of course. What we introduced here is a
    new `.` wildcard. The dot matches any character except a newline in default mode;
    that is, when you say `.*`, it means zero or more occurrences of any character.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 它当然找到了输入文本的匹配项。我们在这里介绍了一个新的 `.` 通配符。默认模式下，点号匹配除了换行符以外的任何字符；也就是说，当你说 `.*` 时，它意味着零个或多个任意字符。
- en: 'On to the next one, to find a pattern that looks for an input text that begins
    with a word. Add the following two lines:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，寻找一个模式，检查输入文本是否以一个单词开始。添加以下两行代码：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`\w` stands for any alphanumeric character and underscore. The pattern says:
    start with (`^`) any alphanumeric character (`\w`) and one or more occurrences
    of it (`+`). The output:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`\w`表示任何字母数字字符和下划线。模式表示：以（`^`）任何字母数字字符（`\w`）开始，且它出现一次或多次（`+`）。输出结果：'
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As expected, the pattern finds a match.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，模式找到了匹配。
- en: 'Next, we check for an ends with a word and optional punctuation. Add the following
    lines:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们检查以某个单词和可选标点符号结尾的情况。添加以下几行代码：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The pattern means one or more occurrences of `\w`, followed by zero or more
    occurrences of `\S`, and that should be falling towards the end of the input text.
    To understand `\S` (capital `S`), we must first understand `\s`, which is all
    whitespace characters. `\S` is the reverse or the anti-set of `\s`, which when
    followed by `\w` translates to looking for a punctuation:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该模式表示一个或多个`\w`字符，后面跟着零个或多个`\S`字符，且应该接近输入文本的末尾。为了理解`\S`（大写`S`），我们必须先了解`\s`，它代表所有的空白字符。`\S`是`\s`的反集，当它后面跟着`\w`时表示查找一个标点符号：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We found the match with peas! at the end of the input text.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在输入文本的末尾找到了与豌豆匹配的内容！
- en: 'Next, find a word that contains a specific character. Add the following lines:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，找一个包含特定字符的单词。添加以下几行代码：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For decoding this pattern, `\B` is a anti-set or reverse of `\b`. The `\b`
    matches an empty string at the beginning or end of a word, and we have already
    seen what a word is. Hence, `\B` will match inside the word and it will match
    any word in our input string that contains character `u`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于解码这个模式，`\B`是`\b`的反集或反向模式。`\b`匹配一个空字符串，位于单词的开始或结束，我们已经知道什么是单词。因此，`\B`会匹配单词内部，它将匹配输入字符串中包含字符`u`的任何单词：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We find the match in the first word, `Tuffy`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第一个单词`Tuffy`中找到了匹配。
- en: 'Here''s the output of the program in full. We have already seen it in detail,
    so I will not go into it again:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的完整输出。我们已经详细查看过，所以我不再重复讲解：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works…
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Along with starts with and ends with, we also learned the wild card character
    `.` and some other special sequences such as, `\w`, `\s`, `\b`, and so on.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 除了“开始”和“结束”模式，我们还学习了通配符字符`.`和一些其他特殊序列，比如`\w`、`\s`、`\b`等。
- en: Searching multiple literal strings and substring occurrences
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索多个字面量字符串和子字符串出现位置
- en: In this recipe, we shall run some iterative functions with regular expressions.
    More specifically, we shall run multiple patterns on an input string with a `for`
    loop and we shall also run a single pattern for multiple matches on the input.
    Let's directly see how to do it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将运行一些带有正则表达式的迭代函数。更具体地说，我们将在输入字符串上运行多个模式，使用`for`循环，还将对单个模式进行多次匹配。让我们直接看看如何做。
- en: Getting ready
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备好
- en: Open your PyCharm editor or any other Python editor that you use, and you are
    ready to go.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的PyCharm编辑器或任何你使用的Python编辑器，准备好开始吧。
- en: How to do it…
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: 'Create a file named `regex3.py` and add the following `import` line to it:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`regex3.py`的文件，并在其中添加以下`import`语句：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following two Python lines to declare and define our patterns and the
    input text:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下两行Python代码来声明和定义我们的模式和输入文本：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let us write our first for loop. Add these lines:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写第一个`for`循环。添加以下几行代码：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is a simple for loop, iterating on the list of patterns one by one and
    calling the search function of `re`. Run this piece and you shall find a match
    for two of the three words in the input string. Also, do note that these patterns
    are case sensitive; the capitalized word `Tuffy`! We will discuss the output in
    the output section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的`for`循环，逐个遍历模式列表，并调用`re`的搜索函数。运行这段代码，你会发现输入字符串中的三个单词中有两个匹配成功。另外请注意，这些模式是区分大小写的；大写单词`Tuffy`！我们将在输出部分讨论结果。
- en: 'On to the next one, to search a substring and find its location too. Let''s
    define the pattern and the input text first:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，搜索一个子字符串并找到其位置。首先定义模式和输入文本：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding two lines define the input text and the pattern to search for
    respectively.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行分别定义了输入文本和要搜索的模式。
- en: 'Now, the `for` loop that will iterate over the input text and fetch all occurrences
    of the given pattern:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的`for`循环将遍历输入文本并获取给定模式的所有出现位置：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `finditer` function takes as input the pattern and the input text on which
    to apply that pattern. On the returned list, we shall iterate. For every object,
    we will call the `start` and `end` methods to know the exact location where we
    found a match for the pattern. We will discuss the output of this block here.
    The output of this little block will look like:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`finditer` 函数接收模式和输入文本作为参数，用来匹配该模式。在返回的列表中，我们将进行迭代。对于每个对象，我们将调用 `start` 和 `end`
    方法，确定我们在哪个位置找到了匹配的模式。我们将在这里讨论这个代码块的输出。这个小代码块的输出将如下所示：'
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Two lines of output! Which suggests that we found the pattern at two places
    in the input. The first was at position `12:20` and the second was at `42:50`
    as displayed in the output text lines.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 两行输出！这表明我们在输入的两个地方找到了匹配的模式。第一次是在位置 `12:20`，第二次是在 `42:50`，如输出文本行所示。
- en: 'Here''s the output of the program in full. We have already seen some parts
    in detail but we will go through it again:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的完整输出。我们已经详细查看过其中的一些部分，但我们将再次逐步查看：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The output is quite intuitive, or at least the first six lines are. We searched
    for the word `Tuffy` and it was found. The word `Pie` wasn't found (the `re.search()`
    function is case sensitive) and then the word `Loki` was found. The last two lines
    we've already discussed, in the sixth step. We didn't just search the string but
    also pointed out the index where we found them in the given input.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 输出非常直观，至少前六行是这样的。我们搜索了单词 `Tuffy` 并找到了它。单词 `Pie` 没有找到（`re.search()` 函数是区分大小写的），然后找到了单词
    `Loki`。最后两行我们在第六步中已经讨论过。我们不仅搜索了字符串，还指出了在给定输入中找到它们的索引。
- en: How it works...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Let's discuss some more things about the `re.search()` function we have used
    quite heavily so far. As you can see in the preceding output, the word `pie` is
    part of the input text but we search for the capitalized word `Pie` and we can't
    seem to locate it. If you add a flag in the search function call `re.IGNORECASE`,
    only then will it be a case-insensitive search. The syntax will be `re.search(pattern,
    string, flags=re.IGNORECASE)`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再讨论一下我们到目前为止使用得非常频繁的 `re.search()` 函数。如你所见，在前面的输出中，单词 `pie` 是输入文本的一部分，但我们搜索的是大写单词
    `Pie`，并且似乎找不到它。如果你在搜索函数调用中添加一个标志 `re.IGNORECASE`，那么它才会进行不区分大小写的搜索。语法将是 `re.search(pattern,
    string, flags=re.IGNORECASE)`。
- en: Now, the `re.finditer()` function. The syntax of the function is `re.finditer(pattern,
    string, flags=0)`. It returns an iterator containing `MatchObject` instances over
    all the non-overlapping matches found the in the input string.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来看 `re.finditer()` 函数。函数的语法是 `re.finditer(pattern, string, flags=0)`。它返回一个迭代器，包含输入字符串中所有不重叠匹配的
    `MatchObject` 实例。
- en: Learning to create date regex and a set of characters or ranges of character
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习创建日期正则表达式和字符集或字符范围
- en: In this recipe, we shall first run a simple date regex. Along with that, we
    will learn the significance of the () groups. Since that's too less to include
    in a recipe, we shall also throw in some more things like the squared brackets
    [], which indicate a set (we will see in detail what a set is).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将首先运行一个简单的日期正则表达式。与此同时，我们将学习 () 分组的意义。由于这对于一个教程来说内容太少，我们还将介绍一些其他内容，如方括号
    []，它表示一个集合（我们将详细了解集合的定义）。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现它…
- en: 'Create a file named `regex4.py` and add the following `import` line to it:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `regex4.py` 的文件，并添加以下 `import` 行：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s declare a `url` object and write a simple date finder regular expression
    to start:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们声明一个 `url` 对象，并编写一个简单的日期查找正则表达式来开始：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `url` is a simple string object. The `date_regex` is also a simple string
    object but it contains a regex that will match a date with format *YYYY/DD/MM*
    or *YYYY/MM/DD* type of dates. `\d` denotes digits starting from 0 to 9\. We've
    already learned the notation {}.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`url` 是一个简单的字符串对象。`date_regex` 也是一个简单的字符串对象，但它包含一个正则表达式，该正则表达式可以匹配格式为 *YYYY/DD/MM*
    或 *YYYY/MM/DD* 类型的日期。`\d` 表示从 0 到 9 的数字。我们已经学过了符号 {} 的用法。'
- en: 'Let''s apply `date_regex` to `url` and see the output. Add the following line:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将 `date_regex` 应用到 `url` 并查看输出。添加以下行：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'A new `re` function, `re.findall(pattern, input, flags=0)`, which again accepts
    the pattern, the input text, and optionally flags (we learned case sensitive flag
    in the previous recipe). Let''s see the output:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个新的 `re` 函数，`re.findall(pattern, input, flags=0)`，它同样接受模式、输入文本，并可选地接受标志（我们在之前的教程中学过区分大小写的标志）。让我们看看输出：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: So, we've found the date 28 October 2017 in the given input string object.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们在给定的输入字符串对象中找到了日期2017年10月28日。
- en: 'Now comes the next part, where we will learn about the set of characters notation
    `[]`. Add the following function in the code:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是下一部分，我们将学习字符集符号`[]`。在代码中添加以下函数：
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The purpose here is to check whether the input string contains a specific set
    of characters or others. Here, we are going with a slightly different approach;
    first, we `re.compile` the pattern, which returns a `RegexObject`. Then, we call
    the `search` method of `RegexObject` on the already compiled pattern. If a match
    is found, the `search` method returns a `MatchObject`, and `None` otherwise. Now,
    turning our attention to the set notation `[]`. The pattern enclosed inside the
    squared brackets means: not (`^`) the range of characters `a-z`, `A-Z`, `0-9`,
    or `.`. Effectively, this is an OR operation of all things enclosed by the squared
    brackets.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目的是检查输入字符串是否包含特定的一组字符或其他字符。在这里，我们采用了一种稍微不同的方法；首先，我们使用`re.compile`编译模式，这将返回一个`RegexObject`。然后，我们调用`RegexObject`的`search`方法来匹配已编译的模式。如果找到匹配项，`search`方法将返回一个`MatchObject`，否则返回`None`。现在，我们将注意力转向符号集`[]`。方括号内的模式意味着：不（`^`）是字符范围`a-z`、`A-Z`、`0-9`或`.`。实际上，这是方括号内所有内容的或操作。
- en: 'Now the test for the pattern. Let''s call the function on two different types
    of inputs, one that matches and one that doesn''t:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在测试模式。我们在两种不同类型的输入上调用这个函数，一种是匹配的，一种是没有匹配的：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The first set of characters contains all of the allowed list of characters,
    whereas the second set contains all of the disallowed set of characters. As expected,
    the output of these two lines will be:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个字符集包含了所有允许的字符，而第二个字符集包含了所有不允许的字符。正如预期的那样，这两行的输出将是：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The pattern will iterate through each and every character of the input string
    and see if there is any disallowed character, and it will flag it out. You can
    try adding any of the disallowed set of characters in the first call of `is_allwoed_specific_char()` and
    check for yourself.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 模式将遍历输入字符串中的每一个字符，检查是否存在任何不允许的字符，如果找到，它将标记出来。你可以尝试在第一次调用`is_allwoed_specific_char()`时添加任何不允许的字符集，并自行检查结果。
- en: 'Here''s the output of the program in full. We have already seen it in detail,
    so we shall not go through it again:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的完整输出。我们已经详细查看过，因此不再重复。
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Let's first discuss what a group is. A group in any regular expression is what
    is enclosed inside the brackets `()` inside the pattern declaration. If you see
    the output of the date match, you will see a set notation, inside which you have
    three string objects: `[('2017', '10', '28')]`. Now, look at the pattern declared
    carefully, `/(\d{4})/(\d{1,2})/(\d{1,2})/`. All the three components of the date
    are marked inside the group notation `()`, and hence all three are identified
    separately.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们讨论一下什么是“分组”。在任何正则表达式中，分组是指在模式声明中的括号`()`内所包含的内容。如果你查看日期匹配的输出，你会看到一个集合表示法，里面包含了三个字符串对象：`[('2017',
    '10', '28')]`。现在，仔细看一下声明的模式`/(\d{4})/(\d{1,2})/(\d{1,2})/`。日期的三个组件都被标记在分组表示法`()`内，因此这三个部分被单独识别出来。
- en: Now, the `re.findall()` method will find all the matches in the given input.
    This means that if there were more dates inside the give input text, the output
    would've looked like `[('2017', '10', '28'), ('2015', '05', '12')]`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`re.findall()`方法将在给定的输入中查找所有匹配项。这意味着，如果输入文本中有更多日期，输出将是类似于`[('2017', '10',
    '28'), ('2015', '05', '12')]`的形式。
- en: 'The `[]` notation that is set essentially means: match either of the characters
    enclosed inside the set notation. If any single match is found, the pattern is
    true.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`[]`符号集本质上意味着：匹配集合表示法中所包含的任意字符。如果找到任何单一匹配项，模式就成立。'
- en: Find all five-character words and make abbreviations in some sentences
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在一些句子中查找所有五个字符的单词并进行缩写。
- en: We have covered all the important notations that I wanted to cover with examples
    in the previous recipes. Now, going forward, we will look at a few small recipes
    that are geared more towards accomplishing a certain task using regular expressions
    than explaining any notations. Needless to say, we will still learn some more
    notations.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过之前的示例覆盖了所有我想要讲解的重要符号。接下来，我们将讨论一些较小的示例，这些示例更侧重于使用正则表达式完成特定任务，而不是解释符号。话虽如此，我们仍然会学习一些其他的符号。
- en: How to do it…
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'Create a file named `regex_assignment1.py` and add the following `import` line
    to it:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`regex_assignment1.py`的文件，并在其中添加以下`import`行：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the following two Python lines to define the input string and apply the
    substitution pattern for abbreviation:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下两行 Python 代码来定义输入字符串，并应用缩写的替代模式：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'First, we are going to do the abbreviation, for which we use the `re.sub()`
    method. The pattern to look for is `Road`, the string to replace it with `Rd`,
    and the input is the string object `street`. Let''s look at the output:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们要做的是缩写处理，为此我们使用 `re.sub()` 方法。要查找的模式是 `Road`，替换成的字符串是 `Rd`，输入字符串是 `street`。让我们看看输出：
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Clearly, it works as expected.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，它按预期工作。
- en: 'Now, let us find all five-character words inside any given sentence. Add these
    two lines of code for that:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在任何给定的句子中找到所有五个字符的单词。为此，添加这两行代码：
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Declare a string object `text` and put the sentence side it. Next, create a
    pattern and apply it using the `re.findall()` function. We are using the `\b`
    boundary set to identify the boundary between words and the `{}` notation to make
    sure we are only shortlisting five-character words. Run this and you shall see
    the list of words matched as expected:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个字符串对象 `text`，并将句子放入其中。接下来，创建一个模式并使用 `re.findall()` 函数应用它。我们使用 `\b` 边界集来识别单词之间的边界，并使用
    `{}` 符号来确保我们仅列出五个字符的单词。运行此程序，你将看到按预期匹配的单词列表：
- en: '[PRE41]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here''s the output of the program in full. We have already seen it in detail,
    so we will not go through it again:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的完整输出。我们已经详细查看过它，所以我们不再重复：
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How it works...
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By now, I assume you have a good understanding of the regular expression notations
    and syntax. Hence, the explanations given when we wrote the recipe are quite enough.
    Instead, let us look at something more interesting. Look at the `findall()` method;
    you will see a notation like `r&lt;pattern&gt;`. This is called the raw string
    notation; it helps keep the regular expression sane looking. If you don't do it,
    you will have to provide an escape sequence to all the backslashes in your regular
    expression. For example, patterns `r"\b\w{5}\b"` and `"\\b\\w{5}\\b"` do the exact
    same job functionality wise.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我相信你已经对正则表达式的符号和语法有了很好的理解。因此，在我们编写本配方时给出的解释已经足够了。接下来，让我们看一些更有趣的东西。看看 `findall()`
    方法，你会看到像 `r&lt;pattern&gt;` 的符号。这叫做原始字符串符号；它有助于保持正则表达式的可读性。如果你不使用它，你必须为正则表达式中的所有反斜杠提供转义序列。例如，`r"\b\w{5}\b"`
    和 `"\\b\\w{5}\\b"` 的功能完全相同。
- en: Learning to write your own regex tokenizer
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习编写你自己的正则表达式分词器
- en: We already know the concepts of tokens, tokenizers, and why we need them from
    the previous chapter. We have also seen how to use the inbuilt tokenizers of the
    NLTK module. In this recipe, we will write our own tokenizer; it will evolve to
    mimic the behavior of `nltk.word_tokenize()`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从上一章了解了令牌、分词器的概念以及为什么需要它们。我们还看到了如何使用 NLTK 模块的内置分词器。在这个配方中，我们将编写我们自己的分词器；它将逐步发展，模拟
    `nltk.word_tokenize()` 的行为。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: If you have your Python interpreter and editor ready, you are as ready as you
    can ever be.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经准备好 Python 解释器和编辑器，那么你就已经准备好了。
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Create a file named `regex_tokenizer.py` and add the following `import` line
    to it:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `regex_tokenizer.py` 的文件，并在其中添加以下 `import` 行：
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let''s define our raw sentence to tokenize and the first pattern:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义要分词的原始句子和第一个模式：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This pattern will perform the same as the space tokenizer we saw in previous
    chapter. Let''s look at the output:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个模式将执行与前一章中看到的空格分词器相同的功能。让我们看一下输出：
- en: '[PRE45]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As we can see, our little pattern works exactly as expected.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们的小模式完全按预期工作。
- en: 'Now, this is not enough, is it? We want to split the tokens on anything non-word
    and not the `'' ''` characters alone. Let''s try the following pattern:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，这还不够，对吧？我们希望将令牌分割成任何非单词字符，而不仅仅是 `' '` 字符。让我们尝试以下模式：
- en: '[PRE46]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We are splitting on all non-word characters, that is, `\W`. Let''s see the
    output:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在对所有非单词字符进行分割，即 `\W`。让我们看看输出：
- en: '[PRE47]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We did split out on all the non-word characters (`' '`, `,`, `!`, and so on),
    but we seem to have removed them from the result altogether. Looks like we need
    to do something more and different.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实已经分割了所有非单词字符（`' '`、`,`、`!` 等），但似乎它们已经完全从结果中删除了。看起来我们需要做一些额外的事情，且有所不同。
- en: 'Split doesn''t seem to be doing the job; let''s try a different `re` function,
    `re.findall()`. Add the following line:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`split` 似乎没有完成任务；让我们尝试一个不同的 `re` 函数，`re.findall()`。添加以下行：'
- en: '[PRE48]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let''s run and see the output:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行并查看输出：
- en: '[PRE49]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Looks like we hit the jackpot.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们中奖了。
- en: 'Here''s the output of the program in full. We have already discussed it; let''s
    print it out:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的完整输出。我们已经讨论过它了；让我们打印出来：
- en: '[PRE50]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As you can see, we have gradually improved upon our pattern and approach to
    achieve the best possible outcome in the end.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们逐步改进了我们的模式和方法，最终达到了最佳的结果。
- en: How it works...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We started with a simple `re.split` on space characters and improvised it using
    the non-word character. Finally, we changed our approach; instead of trying to
    split, we went about matching what we wanted by using `re.findall`, which did
    the job.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从对空格字符的简单`re.split`开始，然后通过非字母字符进行改进。最后，我们改变了方法；我们不再尝试分割，而是通过使用`re.findall`来匹配我们想要的内容，这完成了任务。
- en: Learning to write your own regex stemmer
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学会编写自己的正则表达式词干提取器
- en: We already know the concept of stems/lemmas, stemmer, and why we need them from
    the previous chapter. We have seen how to use the inbuilt porter stemmer and Lancaster
    stemmer of the NLTK module. In this recipe, we will write our own regular expression
    stemmer that will get rid of the trailing unwanted suffixes to find the correct
    stems.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一章了解了词干/词形、词干提取器及其必要性。我们已经看到了如何使用NLTK模块的内置Porter词干提取器和Lancaster词干提取器。在这个示例中，我们将编写自己的正则表达式词干提取器，去除不需要的后缀，以找到正确的词干。
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: As we did in previous stemmer and lemmatizer recipes, we will need to tokenize
    the text before we apply the stemmer. That's exactly what we are going to do.
    We will reuse the final tokenizer pattern from the last recipe. If you haven't
    checked out the previous recipe, please do so and you are ready set to start this
    one.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的词干提取器和词形还原器示例中所做的那样，我们需要先对文本进行标记化处理，然后再应用词干提取器。这正是我们将要做的。我们将重新使用上一个示例中的最终标记化模式。如果你还没有查看之前的示例，请先查看一下，然后你就可以开始这个示例了。
- en: How to do it…
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create a file named `regex_tokenizer.py` and add the following `import` line
    to it:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`regex_tokenizer.py`的文件，并在其中添加以下`import`语句：
- en: '[PRE51]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We will write a function that will do the job of stemming for us. Let''s first
    declare the syntax of the function in this step and we will define it in the next
    step:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将编写一个函数来完成词干提取的工作。让我们首先在这一步声明函数的语法，接下来我们会在下一步定义它：
- en: '[PRE52]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This function shall accept a string object as parameter and is supposed to return
    a string object as the outcome. Word in stem out!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数应该接受一个字符串对象作为参数，并且返回一个字符串对象作为结果。词根提取，输出！
- en: 'Let''s define the `stem()` function:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义`stem()`函数：
- en: '[PRE53]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We are applying the `re.findall()` function to the input word to return two
    groups as output. First is the stem and then it's any possible suffix. We return
    the first group as our result from the function call.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在对输入的单词应用`re.findall()`函数，返回两个组作为输出。第一个是词根，第二个是可能的后缀。我们从函数调用中返回第一个组作为结果。
- en: 'Let''s define our input sentence and tokenize it. Add the following lines:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义输入句子并进行标记化。添加以下几行：
- en: '[PRE54]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s run and see the output:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行并查看输出：
- en: '[PRE55]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Looks like we got our tokens to do stemming.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们已经得到了可以进行词干提取的标记。
- en: 'Let''s apply our `stem()` method to the list of tokens we just generated. Add
    the following `for` loop:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`stem()`方法应用于我们刚刚生成的标记列表。添加以下`for`循环：
- en: '[PRE56]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We are just looping over all tokens and printing the returned stem one by one.
    We will see the output in the upcoming output section and discuss it there.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是遍历所有的标记，并逐一打印返回的词干。我们将在接下来的输出部分看到结果并进行讨论。
- en: 'Let''s see the output of the entire code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看整个代码的输出：
- en: '[PRE57]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Our stemmer seems to be doing a pretty decent job. However, I reckon I have
    passed an easy-looking sentence for the stemmer.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的词干提取器似乎做得相当不错。然而，我认为我给词干提取器提供的是一个看起来简单的句子。
- en: How it works…
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Again, we are using the `re.findall()` function to get the desired output, though
    you might want to look closely at the first group's regex pattern. We are using
    a non-greedy wildcard match (`.*?`); otherwise, it will greedily gobble up the
    entire word and there will be no suffixes identified. Also, the start and end
    of the input are mandatory to match the entire input word and split it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用`re.findall()`函数来获取所需的输出，尽管你可能需要仔细查看第一个组的正则表达式模式。我们使用了一个非贪婪的通配符匹配（`.*?`），否则它会贪婪地吞噬整个单词，导致无法识别后缀。此外，输入的开始和结束是必须的，以匹配整个输入单词并进行分割。
