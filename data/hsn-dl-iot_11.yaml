- en: Predictive Maintenance for IoT
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物联网的预测性维护
- en: In **Internet of Things** (**IoT**) devices, streaming data is generated for
    one event at a time. DL-based approaches can examine this data in order to diagnose
    the problem across the fleet in real time, and the future health of individual
    units can be predicted in order to enable on-demand maintenance. This strategy
    is known as **predictive** (or **condition-based**) **maintenance**. This approach
    is now emerging as one of the most promising and lucrative industrial applications
    of the IoT.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在**物联网**（**IoT**）设备中，数据流是为每次事件生成的。基于深度学习的方法可以实时检查这些数据，以诊断整个设备群体的问题，并预测单个设备的未来健康状况，从而实现按需维护。这种策略被称为**预测性**（或**基于状态**）**维护**。这种方法现在已经成为物联网最有前景和最有利可图的工业应用之一。
- en: 'Considering these motivations, in this chapter, we will look at how to develop
    a DL solution for predictive maintenance for IoT using the **Turbofan Engine Degradation
    Simulation** dataset. The idea behind predictive maintenance is to determine whether
    the failure patterns of various types can be predictable. Furthermore, we will
    discuss how to collect data from IoT-enabled devices for the predictive maintenance.
    In a nutshell, the following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些动机，在本章中，我们将探讨如何使用**涡扇发动机退化仿真**数据集开发物联网的深度学习解决方案。预测性维护的核心思想是确定各种类型的故障模式是否可以预测。此外，我们还将讨论如何从物联网设备收集数据以进行预测性维护。简而言之，本章将涉及以下内容：
- en: Predictive maintenance for IoT
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物联网的预测性维护
- en: Developing a predictive maintenance application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发预测性维护应用程序
- en: Preparing the data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备数据
- en: Training ML baselines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练机器学习基准模型
- en: Training the LSTM model
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练LSTM模型
- en: Evaluating the model
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估模型
- en: FAQs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见问题解答
- en: Predictive maintenance for IoT
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物联网的预测性维护
- en: With advances in real-time data capture and streaming architecture, it is now
    possible to have real-time data monitoring, where an organization can gain real-time
    insight into individual components and all processes. Monitoring still requires
    active involvement and quick responses—for example, an oil well sensor that is
    indicating increased temperature or volume or a network traffic for bot-net activity
    or insider threats.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 随着实时数据捕获和流处理架构的进步，现在可以进行实时数据监控，组织可以实时了解单个组件和所有流程的情况。监控仍然需要积极参与和快速反应——例如，一个石油井传感器指示温度或体积增加，或者网络流量中出现了僵尸网络活动或内部威胁。
- en: Let's consider a real-world example called **equipment failures in industrial
    engineering**, which is always considered a costly issue. Conducting preventative
    maintenance at regular intervals has always been the conventional strategy. Consequently,
    the schedules tend to be very unadventurous, which is often based on operator
    experience. This manual intervention has several downsides. Firstly, it tends
    to increase maintenance costs. Secondly, it's impossible to adapt such a setting
    to a highly complex or changing industrial scenario.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个真实世界的例子，叫做**工业工程中的设备故障**，这一直被认为是一个高成本问题。定期进行预防性维护一直是传统策略。因此，维护计划往往非常保守，通常基于操作员的经验。这种人工干预有几个缺点。首先，它往往会增加维护成本。其次，无法将这种设置适应高度复杂或不断变化的工业场景。
- en: Collecting IoT data in an industrial setting
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在工业环境中收集物联网数据
- en: According to **RT Insights**, a single jet engine could cost $16 million, and
    on a transatlantic flight it can consume 36,000 gallons of fuel. Today's airline
    fuel prices come to around $54,000 per trip, or more than $5,000 an hour. The
    majority of jet engines are gas turbine engines in which the thermal energy is
    converted into kinetic energy by expanding through nozzles, then into rotational
    mechanical energy in a spinning rotor. Such engines produce huge amounts of IoT
    data. Let's try to perceive how predictive maintenance with ML could help us to
    reduce the maintenance costs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 根据**RT Insights**，单个喷气发动机可能价值1600万美元，在跨大西洋航班中，它可能消耗36,000加仑的燃料。今天的航空燃料价格约为每次航程54,000美元，或者每小时超过5,000美元。大多数喷气发动机都是燃气涡轮发动机，在这些发动机中，热能通过喷嘴膨胀转化为动能，然后转化为旋转的机械能。这种发动机产生大量的物联网数据。让我们尝试理解，机器学习驱动的预测性维护如何帮助我们降低维护成本。
- en: The first step is to collect the sensor data representing healthy and faulty
    operations under different operating conditions, for example, temperature, flow,
    and pressure. In a real-life scenario, those might be deployed in different environments
    and locations (suppose you are in Siberia at an operating temperature of -20 degree
    Celsius with high fluid viscosity, and another one in a Middle Eastern country
    with a temperature of 45 degree Celsius with high fluid viscosity).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是收集代表健康和故障操作的传感器数据，涵盖不同的操作条件，例如温度、流量和压力。在实际场景中，这些数据可能在不同的环境和地点进行部署（假设你在西伯利亚，操作温度为-20摄氏度，流体粘度较高，另一个则在中东国家，温度为45摄氏度，流体粘度也较高）。
- en: 'Even though both of them are supposed to work normally, one of the engines
    might fail sooner because of different operating conditions. Unfortunately, without
    having enough data, there''s no further way to investigate the root cause of the
    failure. Once such a jet turbine engine is deployed, sensor data can be collected
    using streaming technologies in the following settings:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两个引擎都应正常运行，但由于不同的操作条件，其中一个引擎可能会更早发生故障。遗憾的是，若没有足够的数据，就无法进一步调查故障的根本原因。一旦这类喷气涡轮发动机投入使用，可以通过流媒体技术在以下环境中收集传感器数据：
- en: Real sensor data from normal system operations
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常系统操作中的真实传感器数据
- en: Real sensor data from a system operating in a faulty condition
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在故障条件下运行的系统中的真实传感器数据
- en: Real sensor data from system failures (*run-to-failure* data)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统故障中的真实传感器数据（*从运行到故障*数据）
- en: 'However, if we don''t have many such engines deployed, we won''t have much
    data, which would represent both healthy and faulty conditions and operations.
    There are two workarounds to overcome this data scarcity:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们没有部署很多这类引擎，就没有足够的数据来代表健康和故障状态下的操作。有两种解决方法可以克服这种数据稀缺问题：
- en: Using historical data from similar/ the same engine, which might resemble the
    currently-deployed engines.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用来自相似/相同引擎的历史数据，这些引擎可能与当前部署的引擎相似。
- en: Secondly, we can build a mathematical model of the engines and estimate their
    parameters from the available sensor data. Based on the statistical distribution
    and operating conditions, we can then generate failure data.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们可以建立引擎的数学模型，并根据可用的传感器数据估算其参数。基于统计分布和操作条件，我们可以生成故障数据。
- en: 'If we go with the second option, after generating the sensor data, we can combine
    them with the real sensor data to generate large-scale sensor data for the developing
    predictive maintenance model, as shown in the following diagram:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择第二种方法，在生成传感器数据后，我们可以将其与真实传感器数据结合，生成大规模的传感器数据，以用于开发预测性维护模型，如下图所示：
- en: '![](img/f4910870-43c7-4ad2-86a0-fc496bcb2aa0.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4910870-43c7-4ad2-86a0-fc496bcb2aa0.png)'
- en: ML techniques for predictive maintenance
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于预测性维护的机器学习（ML）技术
- en: '**Deep learning** (**DL**) techniques can be applied to process the massive
    amount of IoT data and can be an appealing emerging alternative to classical machine
    learning algorithms. The idea is that when equipment is given with sensors and
    networked, a huge amount of sensor data is produced. In a more complex industrial
    setting, data from the sensor channels is quite noisy and fluctuates over time,
    but some of the data does not seem to change at all. This is more-or-less true
    for every industrial setting because the data produced in an IoT setting is a
    multivariate series of sensor measurements each with its own amount of noise containing
    many missing or uninformative values.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**深度学习**（**DL**）技术可以应用于处理大量的物联网数据，并且可能成为经典机器学习算法的有力替代方案。其理念是，当设备配备传感器并联网时，会产生大量的传感器数据。在更复杂的工业环境中，传感器通道的数据通常非常嘈杂，并随着时间波动，但有些数据似乎根本没有变化。这几乎适用于每一个工业环境，因为在物联网环境下产生的数据是一系列多变量的传感器测量，每个数据都有自己的噪声，并包含许多缺失或无意义的值。'
- en: A key step in predictive maintenance application development is identifying
    the **Condition Indicators** (**CIs**) and features from the collected sensor
    data, inspecting the behavior changes of CIs in a predictable way as the system
    degrades. Usually, CIs contain features that help distinguish normal and faulty
    operations and predict **Remaining Useful Life** (**RUL**).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 预测性维护应用开发中的关键步骤是识别**状态指标**（**CIs**）和从收集的传感器数据中提取特征，检查CIs在系统退化过程中可预测的行为变化。通常，CIs包含帮助区分正常与故障操作的特征，并预测**剩余使用寿命**（**RUL**）。
- en: 'The RUL of an engine or machine is the expected life or usage time remaining
    before the engine requires repair or replacement. Consequently, predicting RUL
    from sensor data is key in many predictive-maintenance applications. In the following
    diagram, we can see that the peaks in the frequency data shifts to the left as
    the turbine engine degrades. Therefore, the peak frequency can serve as condition
    indicators:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 发动机或机器的剩余使用寿命（RUL）是指在发动机需要修理或更换之前预期的剩余使用时间。因此，从传感器数据中预测RUL是许多预测性维护应用中的关键。在下图中，我们可以看到，随着涡轮发动机的退化，频率数据中的峰值向左移动。因此，峰值频率可以作为状态指示器：
- en: '![](img/39ae6a54-b44e-4921-92c5-96cb0a42c3f0.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39ae6a54-b44e-4921-92c5-96cb0a42c3f0.png)'
- en: 'CIs can help us understand healthy and faulty operation in the turbine engine.
    However, they don''t tell us what parts need to be repaired or how much time remains
    until the failure occurs. We either identify the fault types before fixing or
    predict the RUL before the scheduled maintenance. For the former option, use the
    extracted CIs features to train an ML or DL model and identify the fault types,
    such as seal leakage, blocked inlet, or worn bearing, as shown in the following
    diagram:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: CI可以帮助我们理解涡轮发动机的健康状态和故障状态。然而，它们并不能告诉我们哪些部件需要修理，或者在故障发生之前还有多少时间。我们可以在修理之前识别故障类型，或在计划维护之前预测RUL。对于前者选项，使用提取的CI特征来训练ML或DL模型，并识别故障类型，如密封泄漏、进气阻塞或轴承磨损，如下图所示：
- en: '![](img/cd8200d6-66a0-4393-b77d-bac7fb44f88b.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd8200d6-66a0-4393-b77d-bac7fb44f88b.png)'
- en: 'For the latter strategy, we can also train the ML/DL model to predict the trend
    that the pumps will continue to transition between these two states (current condition
    and the failure). A DL model can capture the relationships between CI features,
    and the degradation path of the turbine engine will help us to predict how much
    time we have until the next failure or when we should schedule maintenance, as
    depicted in the following diagram:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于后一种策略，我们还可以训练ML/DL模型，预测泵在这两种状态（当前状态和故障状态）之间继续转换的趋势。DL模型可以捕捉CI特征之间的关系，而涡轮发动机的退化路径将帮助我们预测距离下次故障还有多长时间，或者何时应安排维护，如下图所示：
- en: '![](img/e543f232-57e9-49d5-9d28-cbc13f1dfcd0.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e543f232-57e9-49d5-9d28-cbc13f1dfcd0.png)'
- en: 'Finally, a stable model can be deployed in an industrial setting. The preceding
    steps can be summarized in the following diagram:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，稳定的模型可以在工业环境中部署。前述步骤可以通过以下图表进行总结：
- en: '![](img/f413846e-0190-45cc-b5e9-346f65906fa6.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f413846e-0190-45cc-b5e9-346f65906fa6.png)'
- en: Unfortunately, due to the lack of sensor data for predicting fault types, in
    the next section, we will see a hands-on example on predicting RUL using both
    ML and DL techniques.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，由于缺乏用于预测故障类型的传感器数据，在下一节中，我们将通过实际示例展示如何使用ML和DL技术预测RUL。
- en: Example – PM for an aircraft gas turbine engine
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 – 飞机燃气涡轮发动机的预测性维护
- en: 'To give a real-life glimpse into predictive maintenance, we will use the open
    source **Turbofan Engine Degradation Simulation** dataset, which was released
    in 2008 by the **Prognostics Center of Excellence** at NASA''s Ames research centre.
    The dataset can be downloaded from [https://ti.arc.nasa.gov/c/6/](https://ti.arc.nasa.gov/c/6/).
    We''re thankful to the authors of the following research for providing this dataset:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让大家更直观地了解预测性维护，我们将使用2008年由**NASA Ames研究中心的预测卓越中心**发布的开源**涡扇发动机退化仿真**数据集。该数据集可以从[https://ti.arc.nasa.gov/c/6/](https://ti.arc.nasa.gov/c/6/)下载。我们感谢以下研究的作者提供此数据集：
- en: Turbofan Engine Degradation Simulation Data Set, A Saxena and K Goebel (2008), NASA
    Ames Prognostics Data Repository ([https://ti.arc.nasa.gov/tech/dash/groups/pcoe/prognostic-data-repository/](https://ti.arc.nasa.gov/tech/dash/groups/pcoe/prognostic-data-repository/)),
    NASA Ames Research Center, Moffett Field, CA.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 涡扇发动机退化仿真数据集，A. Saxena 和 K. Goebel（2008），NASA Ames预测数据存储库（[https://ti.arc.nasa.gov/tech/dash/groups/pcoe/prognostic-data-repository/](https://ti.arc.nasa.gov/tech/dash/groups/pcoe/prognostic-data-repository/)），NASA
    Ames研究中心，莫菲特场，加利福尼亚州。
- en: Describing the dataset
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述数据集
- en: 'The dataset consists of sensor readings from a fleet of simulated aircraft
    gas turbine engines operating conditions as a multiple multivariate time series.
    The dataset consists of separate training and test sets. The testset is similar
    to the training set, except that each engine''s measurements are truncated some
    (unknown) amount of time before it fails. The data is provided as a ZIP-compressed
    text file with 26 columns of numbers. Each row represents a snapshot of data taken
    during a single operational cycle and each column represents a different variable.
    The columns correspond to the following attributes:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集由模拟的飞机燃气涡轮发动机的传感器读取数据组成，数据表示多元时间序列的多种操作条件。数据集包括单独的训练集和测试集。测试集与训练集相似，不同之处在于，每个引擎的测量值会在其故障前被截断一段（未知）时间。数据以ZIP压缩的文本文件形式提供，包含26列数字。每一行表示在单次操作周期内获取的数据快照，每一列代表不同的变量。列名对应以下属性：
- en: Unit number
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元号
- en: Time, in cycles
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间，以循环为单位
- en: Operational setting 1
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作设置 1
- en: Operational setting 2
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作设置 2
- en: Operational setting 3
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作设置 3
- en: Sensor measurement 1
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传感器测量 1
- en: Sensor measurement 2
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传感器测量 2
- en: Sensor measurement 26
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传感器测量 26
- en: In addition, the dataset has a vector of true RUL values for the data, which
    will be used as the ground truths for training the models.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，数据集还包含一组真实的RUL（剩余使用寿命）值，作为训练模型时的真实标签。
- en: Exploratory analysis
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索性分析
- en: 'To give an idea of the sensor readings in areas such as the physical state
    of the engine (for example, with regard to the temperature of a component, the
    fan speed of the turbine, and so on) we decided to extract the first unit from
    the first dataset for all the sensors on a single engine. For this, we have written
    a script (see `make_dataset.py`) that gets all of the data files from the input
    directory. Then it parses a set of raw data files into a single DataFrame object
    and returns an aggregated representation of all files with the appropriate column
    names:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示传感器读取值在引擎的物理状态方面的表现（例如，组件的温度、涡轮风扇的转速等），我们决定从第一个数据集中提取一个引擎的所有传感器数据。为此，我们编写了一个脚本（请参见`make_dataset.py`），它会从输入目录获取所有数据文件。然后，解析一组原始数据文件为一个单一的DataFrame对象，并返回所有文件的聚合表示，带有适当的列名：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To use this script, first copy all the files in the `data/raw/` directory,
    and then execute the following command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个脚本，首先复制`data/raw/`目录下的所有文件，然后执行以下命令：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This command will generate three files—`train.csv`, `test.csv`, and `RUL.csv`—for
    the training set, testset, and labels, respectively. Now that our dataset is ready
    for exploratory analysis, we can now read each CSV file as a pandas DataFrame:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将生成三个文件——`train.csv`、`test.csv`和`RUL.csv`——分别对应训练集、测试集和标签。现在我们的数据集已经准备好进行探索性分析，我们可以将每个CSV文件作为pandas
    DataFrame读取：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, extract the first unit from the first dataset:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从第一个数据集中提取第一个单元：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we plot its sensor traces over time on a 7 * 3 = 21 plots grid to see
    all sensor channels. We have to plot the channel corresponding to this position:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们将其传感器数据随时间变化的轨迹绘制在一个7 * 3 = 21个图的网格中，以查看所有传感器通道。我们需要绘制与该位置相对应的通道：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As seen in the following diagram, data from the sensor channels is quite noisy
    and fluctuates over time, while other data does not seem to change at all. Each
    sensor''s life cycle is different in terms of the starting and ending value on
    the *x* axis:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，传感器通道的数据相当嘈杂，并随着时间波动，而其他数据似乎完全没有变化。每个传感器的生命周期在*X*轴上的起始值和结束值都不同：
- en: '![](img/bb6ee94c-00be-4c6d-8df2-d6ca8e001d0b.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb6ee94c-00be-4c6d-8df2-d6ca8e001d0b.png)'
- en: 'We can see that each engine has a slightly different lifetime and failure pattern.
    Next, we can visualize the data from all the sensor channels against time for
    a random sample of 10 engines from the training set:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，每个引擎的生命周期和故障模式略有不同。接下来，我们可以将所有传感器通道的数据与时间进行可视化，选取训练集中的10个引擎作为随机样本：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code segment shows the following graph of random samples of 10
    units from the sensor reading from dataset 1:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码段展示了从数据集1中提取的10个随机样本的传感器读取图：
- en: '![](img/aadcd010-d6a2-44dd-9850-d26e05de78e2.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aadcd010-d6a2-44dd-9850-d26e05de78e2.png)'
- en: From the preceding graph, we can inspect that an engine's progress with respect
    to time is not quite aligned with the others. This is an impedance that does not
    allow us to compare the fifth cycle of one engine to the fifth cycle of another,
    for example.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中，我们可以观察到，一台发动机的进展与时间的关系与其他发动机并不完全一致。这种阻碍使得我们无法将一台发动机的第五周期与另一台发动机的第五周期进行比较。
- en: Inspecting failure modes
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查故障模式
- en: 'Since it is already known when each engine in the training set will fail, we
    can compute a **time before failure** value at each time step, which can be defined
    as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在训练集中已经知道每台发动机的故障时间，我们可以在每个时间步计算一个**故障前的时间**值，该值可以定义如下：
- en: '*Time before failure (TBF) = engine elapsed life at failure time (EEL) - total
    operating lifetime (TOL)*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*故障前的时间（TBF） = 故障时的发动机经过使用的时间（EEL） - 总使用寿命（TOL）*'
- en: 'This number can be considered as the countdown to failure for each engine,
    which allows us to align different engines'' data to a common end:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字可以视为每台发动机的倒计时，允许我们将不同发动机的数据对齐到一个共同的结束点：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The following shows the sensor channels in the same engines. The only difference
    is that the previous graph is plotted against the time before failure, where each
    engine ends at the same instant (*t=0*). It also gives us a common pattern across
    different engines, which shows that some sensor readings consistently rise or
    fall right before a failure, while others—for example, sensor 14—exhibit different
    failure behaviors<q>:</q>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了相同发动机的传感器通道。唯一的不同是，前图是以故障前的时间为横轴绘制的，其中每台发动机的故障时间都在同一时刻结束（*t=0*）。它还为我们提供了不同发动机之间的共同模式，显示出在故障前，某些传感器读数始终上升或下降，而其他传感器——例如传感器14——则表现出不同的故障行为<q>：</q>
- en: '![](img/f855574e-b052-403b-9850-f700f005902c.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f855574e-b052-403b-9850-f700f005902c.png)'
- en: 'This pattern is very common in many predictive maintenance problems: failure
    is often a confluence of different processes, and as a result, things in the real
    world are likely to exhibit multiple failure modes. Due to this unpredictable
    pattern of data, predicting the RUL is very challenging.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在许多预测性维护问题中非常常见：故障通常是多种不同过程的交汇，因此，现实世界中的事物可能表现出多种故障模式。由于这种数据的不可预测模式，预测RUL非常具有挑战性。
- en: Prediction challenges
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预测挑战
- en: 'As shown in the following diagram, after observing the engine''s sensor measurements
    and operating conditions for a certain amount of time (133 cycles in the diagram),
    the challenge is to predict the amount of time (in other words, the RUL) that
    the engine will continue to function before it fails:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，在观察了发动机的传感器数据和操作条件一段时间（图中的133个周期）后，挑战在于预测发动机在故障之前还能继续运行多长时间（即RUL）：
- en: '![](img/a8291ed7-5473-4b7f-bd0a-29eb8e31a583.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8291ed7-5473-4b7f-bd0a-29eb8e31a583.png)'
- en: However, making an incorrect prediction for an ML/DL model is basically underestimating
    the true RUL of a particular engine. This can bring the turbine engine to maintenance
    too early, when it could have operated for a bit longer without any issues arising.
    So, what would happen if our model were to overestimate the true RUL instead?
    In that case, we might allow a degrading aircraft to keep flying, and risk catastrophic
    engine failure. Clearly, the costs of these two outcomes would not be the same.
    Considering these challenges, in the next section, we will focus on using DL-based
    techniques for predicting RUL.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于一个机器学习/深度学习模型来说，做出错误的预测基本上是低估了某个发动机的真实剩余使用寿命（RUL）。这可能导致涡轮发动机过早进行维护，而实际上它还可以在没有出现问题的情况下运行一段时间。那么，如果我们的模型高估了真实的RUL，会发生什么呢？在这种情况下，我们可能会允许一台性能下降的飞机继续飞行，进而冒着发生灾难性发动机故障的风险。显然，这两种结果的成本是不同的。考虑到这些挑战，在下一部分中，我们将重点讨论基于深度学习的RUL预测技术。
- en: DL for predicting RLU
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度学习用于RUL预测
- en: As we have discussed, we are trying to calculate the amount of time before an
    engine needs maintenance. What makes this dataset special is that the engines
    run all the way until failure, giving us the precise RLU information for every
    engine at every point in time.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所讨论的，我们正尝试计算发动机需要进行维护前的时间。这个数据集的特别之处在于，发动机一直运行到故障，这为我们提供了每台发动机在每个时间点的准确RUL信息。
- en: Calculating cut-off times
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算截止时间
- en: 'Let''s consider the `FD004` dataset, that contains as much as 249 engines (`engine_no`)
    monitored over time (`time_in_cycles`). Each engine has `operational_settings`
    and `sensor_measurements` recorded for each cycle:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下`FD004`数据集，它包含了最多249台发动机（`engine_no`），并在不同时间（`time_in_cycles`）进行监控。每台发动机都有每个周期的`operational_settings`和`sensor_measurements`数据记录：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To train a model that will predict RUL, we can simulate real predictions by
    choosing a random point in the life of the engine and only using the data from
    before that point. We can create features with that restriction easily by using
    cut-off times:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了训练一个预测RUL的模型，我们可以通过选择引擎寿命中的一个随机点，并只使用该点之前的数据来模拟实际预测。我们可以通过使用截止时间轻松地创建带有此限制的特征：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding function generates the cut-off times by sampling for both `cutoff_time`
    and `label`, which can be called as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的函数通过对`cutoff_time`和`label`进行采样来生成截止时间，可以按如下方式调用：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding lines of code show the following RUL and cut-off time for five
    engines only:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码行只显示了五个引擎的RUL和截止时间：
- en: '![](img/2e644b28-8122-42c1-be67-27fa8e49a973.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e644b28-8122-42c1-be67-27fa8e49a973.png)'
- en: Deep feature synthesis
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度特征合成
- en: 'Then, we generate the features using **Deep Feature Synthesis** (**DFS**).
    For this, we need to establish an entity set structure for our data. We can create
    an engines entity by normalizing the `engine_no` column in the raw data:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用**深度特征合成**（**DFS**）生成特征。为此，我们需要为数据建立实体集结构。我们可以通过标准化原始数据中的`engine_no`列来创建引擎实体：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code block will generate the following statistics of the entity
    set:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码块将生成实体集的以下统计信息：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `ft.dfs` function takes an entity set and stacks primitives such as `max`,
    `min`, and `last` exhaustively across entities:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`ft.dfs`函数接受一个实体集，并通过实体之间的原始操作（如`max`、`min`和`last`）进行穷举堆叠：'
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ML baselines
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器学习基准
- en: 'Now that we have generated the features, we can start training a first ML model
    called `RandomForestRegressor`. Then, we will gradually move to using DL using **Long
    Short-Term Memory** (**LSTM**) network. **Random forest** (**RF**) is an ensemble
    technique that builds several decision trees and integrates them together to get
    a more accurate and stable prediction. In general, a deeper tree signifies more
    complex decision rules and a better-fitted model for example the following image
    shows Decision tree for university admission data:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经生成了特征，可以开始训练第一个机器学习模型，称为`RandomForestRegressor`。然后，我们将逐步转向使用深度学习（DL），例如**长短期记忆**（**LSTM**）网络。**随机森林**（**RF**）是一种集成技术，通过构建多个决策树并将其整合在一起，来获得更准确、更稳定的预测。通常，较深的树表示更复杂的决策规则和更好的模型拟合，例如以下图像显示了大学录取数据的决策树：
- en: '![](img/4dfcb6f0-e778-4951-b1a7-df7b0f07c401.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4dfcb6f0-e778-4951-b1a7-df7b0f07c401.png)'
- en: 'Consequently, the deeper the tree, the more complex the decision rules and
    the better fitted the model is. This is a direct consequence of Random Forest.
    In other words, the final prediction based on the majority vote from a panel of
    independent juries is always better and more reliable than the best jury. The
    following diagram shows random forest and its assembling technique:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，树的深度越深，决策规则越复杂，模型拟合得越好。这是随机森林的直接结果。换句话说，基于独立评审团的多数投票的最终预测，总是比最佳评审团更好、更可靠。下图显示了随机森林及其集成技术：
- en: '![](img/18820971-61e8-437d-bef1-7aab87e7e702.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18820971-61e8-437d-bef1-7aab87e7e702.png)'
- en: 'So, let''s get started by preparing the separate training set and test set:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们通过准备单独的训练集和测试集开始：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, using the training set, we will check the following baselines:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用训练集，我们将检查以下基准：
- en: Always predict the median value of `y_train`.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终预测`y_train`的中位数值。
- en: Always predict the RUL as if every engine has the median lifespan in `X_train`.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终将RUL预测为每个引擎在`X_train`中具有中位数寿命的情况。
- en: 'We will check those predictions by finding the mean of the absolute value of
    the errors called the **Mean Absolute Error** (**MAE**) using `RandomForestRegressor`
    from scikit-learn:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过计算绝对误差的平均值，即**平均绝对误差**（**MAE**），来检查这些预测，使用来自scikit-learn的`RandomForestRegressor`：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code block should produce the following output showing the baseline
    `MAE` values:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码块应产生以下输出，显示基准`MAE`值：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Making predictions
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行预测
- en: 'Now we can use our created features to fit `RandomForestRegressor` to our data
    and see whether we can improve on the previous scores:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用我们创建的特征来拟合`RandomForestRegressor`模型，看看是否能够提高之前的分数：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code block should produce the following output showing the baseline
    MAE values and statistics about the engine recording cycles:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码块应产生以下输出，显示基准MAE值和引擎记录周期的统计信息：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we have to prepare both the features and label, which we can do using
    the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要准备特征和标签，可以使用以下代码完成：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The loaded data should have 41,214 recordings from 249 engines in which 21
    sensor measurements are used under three operational settings. Then, we have to
    prepare both the features and labels using the loaded data, which we can do using
    the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 加载的数据应包含来自249个引擎的41,214条记录，其中使用了21个传感器测量值，涵盖了三种操作设置。然后，我们需要使用加载的数据准备特征和标签，以下是我们可以使用的代码：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code block should produce the following output showing the prediced
    MAE and baseline MEA values:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码块应该生成以下输出，显示预测的MAE和基线MAE值：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As seen, the predicted MAE value is lower than both baseline MAE values. Next,
    we try to improve the MAE even more using the LSTM network.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，预测的MAE值低于基线的MAE值。接下来，我们尝试进一步使用LSTM网络改善MAE。
- en: Improving MAE with LSTM
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LSTM改进MAE
- en: 'We will use the Keras-based LSTM network to predict RUL. However, for this,
    we first need to convert the data so that the LSTM model, which expects data in
    three-dimensional format, can consume it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用基于Keras的LSTM网络来预测剩余使用寿命（RUL）。不过，为此，我们首先需要将数据转换成LSTM模型可以使用的三维格式：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that we have the data appropriate for the LSTM model, we can construct
    the LSTM network. For this, we have a fancy LSTM network that has only an LSTM
    layer followed by a dense layer, before we apply a dropout layer for better regularization.
    Then, we have another dense layer, before we project the output from this dense
    layer through to the activation layer using the linear activation function so
    that it outputs real-value outputs. We then use the SGD version, called `RMSProp`,
    which tries to optimize the **Mean Square Error** (**MSE**):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们拥有适合LSTM模型的数据，我们可以构建LSTM网络。为此，我们有一个简化的LSTM网络，只有一个LSTM层，接着是一个全连接层，在应用掉出层以进行更好的正则化之后。然后，我们再加一个全连接层，最后通过线性激活函数将这个全连接层的输出投射到激活层，以便输出实值结果。然后，我们使用SGD版本的`RMSProp`，它尝试优化**均方误差**（**MSE**）：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we train the LSTM model with the training set:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用训练集来训练LSTM模型：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding lines of code should produce some logs, which give us an idea
    of whether the training and the validation losses are getting reduced across iterations:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码行应该生成一些日志，帮助我们了解训练和验证损失是否在迭代过程中减少：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now that the training has been finished, we can plot the training and validation
    loss:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在训练已经完成，我们可以绘制训练和验证损失图：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding code block should produce the following graph, in which we can
    see that the validation loss drops below the training loss:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码块应该生成以下图表，我们可以看到验证损失低于训练损失：
- en: '![](img/ea2b8246-0002-4817-9bda-7e6507f9b7a0.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea2b8246-0002-4817-9bda-7e6507f9b7a0.png)'
- en: 'The model may be overfitting the training data. Measuring and plotting MAE
    during training may shed more light on this. Let''s take a look at the MAE on
    the testset:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型可能存在过拟合训练数据的情况。在训练过程中测量并绘制MAE可能会对此提供更多的线索。让我们来看一下测试集上的MAE：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We should get an MAE of 38.32, which means the MAE error has been reduced a
    bit (whereas RF gave an MAE of 40.33), which is, however, still not convincing.
    There could be several reasons behind such a high MAE. For example, we do not
    have sufficient training data. Secondly, we used an inefficient method for generating
    the entity set. For the first problem, we can use all the dataset to train the
    model. However, we can also use other regularization techniques, such as a Gaussian
    Noise layer, by specifying the noise threshold:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该得到一个MAE为38.32，这意味着MAE误差有所降低（而RF模型的MAE为40.33），但仍然不令人信服。造成这种较高MAE的原因可能有多个。例如，我们可能没有足够的训练数据；其次，我们在生成实体集时使用了一种低效的方法。对于第一个问题，我们可以使用整个数据集来训练模型。我们还可以使用其他正则化技术，如高斯噪声层，并指定噪声阈值：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The Gaussian noise layer can be used as an input layer to add noise directly to
    input variables. This is the traditional use of noise as a regularization method
    in neural networks, which states that the noise can be added before or after the
    use of the activation function. It may make more sense to add this before activation,
    but, nevertheless, both options are possible. In our case, we added a Gaussian
    noise layer with a dropout of 0.2 after the LSTM layer and before the dense layer.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯噪声层可以作为输入层直接向输入变量添加噪声。这是神经网络中使用噪声作为正则化方法的传统方式，噪声可以在激活函数使用之前或之后添加。尽管将噪声添加到激活函数之前可能更有意义，但两种方式都是可能的。在我们的案例中，我们在LSTM层后、全连接层前添加了一个掉出率为0.2的高斯噪声层。
- en: 'Then, we have another Gaussian noise layer that adds noise to the linear output
    of a dense layer before a rectified linear activation function. Then, training
    the LSTM model with the same data with noise introduced should produce a slightly
    lower MAE value of around 35.25\. We can even inspect the plot showing the training
    and validation loss:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有另一个高斯噪声层，将噪声添加到密集层的线性输出之前，再使用修正线性激活函数。然后，使用引入噪声的相同数据训练LSTM模型应该产生略低的MAE值，约为35.25。我们甚至可以检查显示训练和验证损失的图表：
- en: '![](img/bfbbf5d2-4100-4d57-b233-eac0fea3614e.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bfbbf5d2-4100-4d57-b233-eac0fea3614e.png)'
- en: The preceding diagram shows that the training loss and test loss are more or
    less the same, which indicates a better regularization of the model. Hence, the
    model performed better on the testset as well. However, the MAE can still be reduced
    using better quality features, perhaps. Let's explore this with a better feature
    generation technique.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示训练损失和测试损失几乎相同，这表明模型的正则化效果更好。因此，模型在测试集上的表现也更好。然而，通过改进质量更好的特征，MAE仍然可以降低。让我们探索一下使用更好的特征生成技术。
- en: Unsupervised deep feature synthesis
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无监督深度特征合成
- en: 'We will see how the entity set structures can contribute to improve the predictive
    accuracy. We will build custom primitives using time-series functions from the
    `tsfresh` library. Before that, we will make cut-off times by selecting a random
    one from the life of each engine. We are going to make five sets of cut-off times
    to use for cross-validation:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到实体集结构如何有助于提高预测准确性。我们将使用`tsfresh`库中的时间序列函数构建自定义原始功能。在此之前，我们将通过从每个引擎的生命周期中随机选择一个来制定截止时间。我们将制定五组截止时间用于交叉验证：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding code block should show the cut-off time and the RUL values for
    five engines, as shown here:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块应显示五个引擎的截止时间和RUL值，如下所示：
- en: '![](img/4a06a9b2-7315-49ae-9a54-cc2bb226f2b7.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a06a9b2-7315-49ae-9a54-cc2bb226f2b7.png)'
- en: 'Then, we will use an unsupervised way of generating the entity set. As we can
    see, the values of operational settings `1`—`3` are continuous, but they create
    an implicit relation between different engines. Consequently, if two engines have
    a similar operational setting, the sensor measurements give a similar value. The
    idea is to apply the clustering technique through k-means to those settings. Then,
    we create a new entity from clusters with similar values:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用一种无监督的方式生成实体集。正如我们所见，操作设置`1`—`3`的值是连续的，但它们在不同引擎之间创建了隐含的关系。因此，如果两个引擎具有相似的操作设置，则传感器测量结果会给出相似的值。这个想法是通过k-means技术将这些设置进行聚类。然后，我们从具有相似值的簇中创建一个新的实体：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding code segment generates an entity set showing the following relations:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码段生成一个实体集，显示以下关系：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In addition to changing our entity set structure, we are also going to use
    the complexity time-series primitive from the `tsfresh` package. Any function
    that takes in a pandas series and outputs a float can be converted into an aggregation
    primitive using the `make_agg_primitive` function, as shown here:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了改变我们的实体集结构外，我们还将使用`tsfresh`包中的复杂时间序列原始功能。任何接收Pandas系列并输出浮点数的函数都可以使用`make_agg_primitive`函数转换为聚合原始功能，如下所示：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Using this approach, we managed to generate 12 more features (previously, we
    had 290). Then, we built four more feature matrices with the same feature set
    but different cut-off times. This lets us test the pipeline multiple times before
    using it on test data:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们成功生成了额外的12个特征（之前有290个）。然后，我们用相同的特征集构建了另外四个特征矩阵，但使用了不同的截止时间。这使我们能够在将其用于测试数据之前多次测试管道：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, using the recursive feature elimination, we again model RF regressors
    so that the model picks only important features, so it makes better predictions:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用递归特征消除，我们再次对RF回归器建模，以便模型仅选择重要特征，从而进行更好的预测：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding code block should produce the following output showing predicted
    MAE in each iteration and their average. Additionally, it shows the baseline MAE
    values and statistics about the engine recording cycles:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块应生成以下输出，显示每次迭代中的预测MAE及其平均值。此外，它显示了基线MAE值和有关引擎记录周期的统计信息：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now let''s again try using LSTM to see whether we can reduce the MAE error:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再次尝试使用LSTM，看看是否可以减少MAE误差：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding lines of code should produce the following diagram, in which
    the validation loss drops below the training loss:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码行应生成以下图表，其中验证损失低于训练损失：
- en: '![](img/63d36ef1-c495-4102-b75f-98b71db81b04.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/63d36ef1-c495-4102-b75f-98b71db81b04.png)'
- en: 'Finally, we can evaluate the model''s performance based on the MAE:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以根据MAE评估模型的表现：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding code block should produce an MAE of 52.40, which is lower than
    we experienced in the previous section.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码块应该产生一个MAE为52.40的结果，低于我们在前一节中得到的结果。
- en: FAQs
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题解答
- en: 'In this section, we will cover some **frequently asked questions** (**FAQs**),
    which will help you to extend this application:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖一些**常见问题**（**FAQ**），这些问题将帮助你扩展这个应用：
- en: '**Can we use other deep architectures to make predictions in similar IoT settings?**'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们可以使用其他深度架构在类似的物联网环境中进行预测吗？**'
- en: '**Answer**: Yes, using other deep architectures could be a viable option. For
    example, creating a convolutional-LSTM network by combining the predictive power
    of both CNN and LSTM layers has proven to be effective in many use cases, such
    as audio classification, **natural language processing** (**NLP**), and time-series
    forecasting.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**回答**：是的，使用其他深度架构可能是一个可行的选项。例如，通过结合CNN和LSTM层的预测能力，创建一个卷积-LSTM网络，已经在许多应用场景中证明是有效的，如音频分类、**自然语言处理**（**NLP**）和时间序列预测。'
- en: '**Sometimes we do not have enough IoT data to train the model flexibly. How
    can we increase the amount of training data?**'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**有时我们没有足够的物联网数据来灵活地训练模型。我们如何增加训练数据的数量？**'
- en: '**Answer**: There are many ways to do this. For example, we can try to generate
    the training set by combining all the engines data. For this, the generated CSV
    files for both training, testing, and RUL would be helpful. Another example might
    be to try to extend the dataset by adding more samples.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**回答**：有很多方法可以做到这一点。例如，我们可以尝试通过将所有发动机数据结合起来生成训练集。为此，生成的训练、测试和RUL的CSV文件会很有帮助。另一个例子是尝试通过添加更多的样本来扩展数据集。'
- en: '**Can I perform anomaly detection in an industrial setting?**'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我可以在工业环境中进行异常检测吗？**'
- en: '**Answer**: Yes, you can. In fact, this is very common in an industrial setting
    such as production fault identification, real-time time-series anomaly detection,
    predictive monitoring, and so on.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**回答**：是的，你可以。实际上，在工业环境中，这种做法非常常见，例如生产故障识别、实时时间序列异常检测、预测监控等。'
- en: '**Where can I get data to perform other analytics in an IoT setting?**'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我在哪里可以获得数据以在物联网环境中进行其他分析？**'
- en: '**Answer**: Time-series data from some nominal state to a failed state from
    the **Prognostics Data Repository** can be used for the development of prognostic
    algorithms. See the following link to learn more about the dataset: [https://ti.arc.nasa.gov/tech/dash/groups/pcoe/prognostic-data-repository/](https://ti.arc.nasa.gov/tech/dash/groups/pcoe/prognostic-data-repository/).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**回答**：来自**预测数据仓库**的时间序列数据，从某一正常状态到失败状态，可以用于预测算法的开发。请参阅以下链接了解更多关于数据集的信息：[https://ti.arc.nasa.gov/tech/dash/groups/pcoe/prognostic-data-repository/](https://ti.arc.nasa.gov/tech/dash/groups/pcoe/prognostic-data-repository/)。'
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have looked at how to develop a DL solution for predictive
    maintenance using IoT and the Turbofan Engine Degradation Simulation dataset.
    We started by discussing the exploratory analysis of the dataset before we modeled
    the predictive maintenance using one of the most popular tree-based ensemble techniques
    called **RF**, which uses features from the turbine engines as it is. Then, we
    saw how to improve the predictive accuracy using an LSTM network. The LSTM network
    indeed helps to reduce network errors. Nevertheless, we saw how to add a Gaussian
    noise layer to achieve generalization in the LSTM network, along with dropout.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何使用物联网和涡扇发动机退化仿真数据集开发用于预测性维护的深度学习解决方案。我们首先讨论了数据集的探索性分析，然后使用一种非常流行的基于树的集成技术——**随机森林**（RF）来建模预测性维护，RF使用的是涡轮发动机的特征。接着，我们看到如何通过使用LSTM网络提高预测准确性。LSTM网络确实有助于减少网络错误。尽管如此，我们仍然看到如何在LSTM网络中加入高斯噪声层，以实现泛化，同时进行dropout操作。
- en: Understanding the potential of DL techniques in all layers of IoT (including
    the sensors/sensing, gateway, and cloud layer) is important. Consequently, developing
    scalable and efficient solutions for IoT-enabled healthcare devices is no exception.
    In the next chapter, we will present a use case that exploits DL for data analysis
    in all potential stages of its life cycle.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 了解深度学习技术在物联网各层（包括传感器/感知层、网关层和云层）的潜力非常重要。因此，为物联网健康设备开发可扩展且高效的解决方案也不例外。在下一章中，我们将展示一个利用深度学习在生命周期各阶段进行数据分析的应用案例。
