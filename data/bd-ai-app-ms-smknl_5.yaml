- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Programming with Planners
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用规划器进行编程
- en: In the previous chapter, we learned how to chain functions manually to perform
    complex tasks. In this chapter, we will learn how to use **planners** to chain
    functions automatically. Chaining functions automatically can give your users
    a lot of flexibility, allowing them to use your application in ways that you don’t
    have to write code for.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何手动链式调用函数以执行复杂任务。在本章中，我们将学习如何使用 **规划器** 自动链式调用函数。自动链式调用函数可以为用户提供更多灵活性，让他们以你不需要编写代码的方式使用你的应用程序。
- en: In this chapter, we will learn how planners work, when to use them, and what
    to be careful about. We will also learn how to write functions and build a kernel
    that helps planners build good plans.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习规划器是如何工作的，何时使用它们，以及需要注意什么。我们还将学习如何编写函数并构建一个内核，帮助规划器构建良好的计划。
- en: 'In this chapter, we’ll be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What a planner is and when to use one
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划器是什么以及何时使用它
- en: Creating and using a planner to run a simple function
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用规划器来运行简单函数
- en: Designing functions to help a planner decide the best way to combine them
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计函数以帮助规划器决定最佳的组合方式
- en: Using a planner to allow users combine functions in complex ways without having
    to write code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用规划器允许用户以复杂的方式组合函数，而无需编写代码
- en: By the end of the chapter, you will have learned how to empower users by giving
    them the ability to make requests in natural language, allowing them to solve
    complex problems that you didn’t have to write code for.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何通过赋予用户使用自然语言进行请求的能力，让他们解决那些你不需要编写代码的复杂问题。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you will need to have a recent, supported version
    of your preferred Python or C# development environment:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，你需要拥有你首选的 Python 或 C# 开发环境的最新、受支持的版本：
- en: For Python, the minimum supported version is Python 3.10, and the recommended
    version is Python 3.11
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Python，最低支持的版本是 Python 3.10，推荐版本是 Python 3.11
- en: For C#, the minimum supported version is .NET 8
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 C#，最低支持的版本是 .NET 8
- en: In this chapter, we will call OpenAI services. Given the amount that companies
    spend on training these LLMs, it’s no surprise that using these services is not
    free. You will need an **OpenAI API** key, either directly through **OpenAI**
    or **Microsoft**, via the **Azure** **OpenAI** service.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将调用 OpenAI 服务。鉴于公司在训练这些大型语言模型（LLM）上花费的金额，使用这些服务不是免费的。你需要一个 **OpenAI API**
    密钥，无论是直接通过 **OpenAI** 还是 **Microsoft**，通过 **Azure** **OpenAI** 服务。
- en: If you are using .NET, the code for this chapter is at [https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/dotnet/ch5](https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/dotnet/ch5).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 .NET，本章的代码位于 [https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/dotnet/ch5](https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/dotnet/ch5)。
- en: If you are using Python, the code for this chapter is at [https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/python/ch5](https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/python/ch5).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Python，本章的代码位于 [https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/python/ch5](https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/python/ch5)。
- en: 'You can install the required packages by going to the GitHub repository and
    using the following: `pip install -``r requirements.txt`.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问 GitHub 仓库并使用以下命令安装所需的包：`pip install -r requirements.txt`。
- en: What is a planner?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是规划器？
- en: So far, we have been performing complex requests by performing the function
    calls ourselves. This, however, requires you to restrict the kind of requests
    that your users can make to what you can predict and write ahead of time. It also
    restricts your users to only generating one output at a time. Sometimes, you may
    want to give them the ability to do more.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过自己执行函数调用来执行复杂请求。然而，这要求你限制用户可以提出的请求类型，使其符合你能够预测并在事先编写的范围内。这也限制了用户一次只能生成一个输出。有时，你可能希望赋予他们做更多事情的能力。
- en: For example, if you have a semantic function that allows users to request jokes
    (as we built in [*Chapter 1*](B21826_01.xhtml#_idTextAnchor014)) and a user requests
    “*tell me a knock-knock joke*,” you can simply call the semantic function that
    tells knock-knock jokes. But if the user requests three knock-knock jokes, the
    function wouldn’t know how to handle it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您有一个语义功能允许用户请求笑话（正如我们在[*第一章*](B21826_01.xhtml#_idTextAnchor014)中构建的）并且用户请求“*讲一个敲门笑话*”，您可以简单地调用讲敲门笑话的语义功能。但如果用户请求三个敲门笑话，该功能将不知道如何处理。
- en: A planner is a built-in function from Semantic Kernel that receives a user request
    and then goes through the descriptions of all the functions, parameters, and outputs
    of the functions you loaded in your kernel and decides the best way to combine
    them, generating a **plan**.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 规划器是语义内核的一个内置功能，它接收用户请求，然后遍历您在内核中加载的所有功能的描述、参数和输出，并决定最佳组合方式，生成一个**计划**。
- en: At the time of writing, there are two planners – a **Handlebars planner** and
    a **Function Calling Stepwise planner**, which we will call a Stepwise planner
    for short. Both are used in the same way, but internally, they work in different
    ways. When Semantic Kernel uses the Handlebars planner, it asks the AI service
    (for example, GPT-3.5 or GPT-4) to write code that will call the functions you
    loaded into the kernel in a scripting language called Handlebars. The Handlebars
    planner is very new and still experimental. It is expected to consume fewer tokens
    than the Stepwise planner, as programming languages can be more efficient in expressing
    complex ideas such as conditionals and loops. The Stepwise planner generates a
    plan that is a dialog with a chat service, which can be longer than the plan generated
    by the Handlebars planner and consume more tokens. Currently, one of the major
    limitations of the Handlebars planner is that it is only available in C#, although
    a Python version is likely to be released in 2024.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，有两个规划器——一个**Handlebars规划器**和一个**函数调用逐步规划器**，我们将简称为逐步规划器。它们的使用方式相同，但内部工作方式不同。当语义内核使用Handlebars规划器时，它会请求AI服务（例如，GPT-3.5或GPT-4）编写代码，以脚本语言Handlebars调用您加载到内核中的函数。Handlebars规划器非常新，仍在实验阶段。预计它比逐步规划器消耗更少的令牌，因为编程语言在表达复杂概念（如条件语句和循环）方面可能更有效率。逐步规划器生成的计划是一个与聊天服务的对话，可能比Handlebars规划器生成的计划更长，并消耗更多令牌。目前，Handlebars规划器的一个主要限制是它仅适用于C#，尽管预计2024年可能会发布Python版本。
- en: 'To understand better how a planner works, assume you have a plugin that generates
    stories, a plugin that breaks stories into small parts, and a plugin that generates
    images. You load all these plugins into the kernel. The user submits a request:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解规划器的工作原理，假设您有一个生成故事的插件、一个将故事分解成小部分的插件和一个生成图像的插件。您将这些插件全部加载到内核中。用户提交一个请求：
- en: “*Create a two-page story about a data scientist that solves crimes with his
    faithful canine companion, break it into small parts, and generate an image in
    the style of Frank Miller for each part*.”
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: “*编写一个关于数据科学家和他的忠实犬伴解决犯罪的两页故事，将其分解成小部分，并为每一部分生成弗兰克·米勒风格的图像*。”
- en: The planner will go through the functions you loaded in the kernel and determine
    the best order to call them, automatically producing a storyboard without you
    having to write any additional code other than the initial plugins.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 规划器将遍历您在内核中加载的功能，并确定调用它们的最佳顺序，自动生成故事板，而无需您编写任何额外的代码，除了初始插件之外。
- en: Planners can enable your users to execute complex tasks with minimal effort
    from your side. Let’s see when to use them.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 规划器可以使您的用户在您的最小努力下执行复杂任务。让我们看看何时使用它们。
- en: When to use a planner
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用规划器
- en: 'Planners can help you as a developer in two ways:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 规划器以两种方式帮助您作为开发者：
- en: Users can combine functions of your application in ways that you didn’t think
    of. If you make the functions of your application available as atomic functions
    inside plugins and give the users the ability to make requests to a planner, then
    the planner can combine these atomic functions in workflows without you having
    to write any code.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以以您未曾想到的方式组合您应用程序的功能。如果您将应用程序的功能作为原子功能嵌入插件中，并赋予用户向规划器发送请求的能力，那么规划器可以在不要求您编写任何代码的情况下，将这些原子功能组合到工作流程中。
- en: As AI models improve, planners get better without you having to write any additional
    code. When Semantic Kernel was initially designed, the best AI model available
    was GPT-3.5 Turbo. Since then, we have had the releases of GPT-4 and GPT-4 Turbo,
    both with more capabilities. An application built with Semantic Kernel that used
    GPT-3.5 Turbo can now use GPT-4 Turbo with a minor configuration change.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着人工智能模型的改进，规划器会变得更好，而无需您编写任何额外的代码。当语义内核最初设计时，最好的 AI 模型是 GPT-3.5 Turbo。从那时起，我们已经发布了
    GPT-4 和 GPT-4 Turbo，它们都具有更多的功能。使用语义内核构建的应用程序现在可以使用 GPT-4 Turbo，只需进行一些小的配置更改。
- en: 'There are, however, some considerations when using planners:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用规划器时，有一些考虑因素：
- en: '**Performance**: Planners need to read all the functions in your kernel and
    combine them with the user request. The richer your kernel is, the more functionality
    you can give to your users, but it will take longer for the planner to go through
    all the descriptions and combine them. In addition, newer models such as GPT-4
    generate better plans, but they are slower, and future models could be even slower.
    You need to find a good balance between the number of functions you make available
    to your users and the models you use. When testing your application, if you find
    that the planner delay is noticeable, you will also need to incorporate UI cues
    into your application so that users know that something is happening.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：规划器需要读取您内核中的所有函数，并将它们与用户请求结合起来。您的内核越丰富，您可以提供给用户的函数功能就越多，但规划器遍历所有描述并组合它们所需的时间会更长。此外，像
    GPT-4 这样的新模型可以生成更好的计划，但它们运行速度较慢，未来的模型可能会更快。您需要在提供给用户的函数数量和您使用的模型之间找到一个良好的平衡。在测试您的应用程序时，如果您发现规划器延迟明显，您还需要将
    UI 提示集成到您的应用程序中，以便用户知道正在发生某些事情。'
- en: '**Cost**: Generating a plan can consume many tokens. If you have lots of functions,
    and the user request is complex, Semantic Kernel will need to submit a very long
    prompt to the AI service containing the descriptions of the functions available
    in your kernel, their inputs, and their outputs to the AI service, in addition
    to the user request. The generated plan may also be long, and the AI service will
    bill you for the cost of both the submitted prompt and the output. One way to
    avoid this is monitoring which requests users create frequently and saving plans
    for those so that they don’t have to be regenerated every time. Note, however,
    that if you save plans and there’s an upgrade in the backend model (for example,
    GPT-5 is launched), you have to remember to re-generate these plans to take advantage
    of the new model’s capabilities.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本**：生成一个计划可能会消耗许多令牌。如果您有很多函数，并且用户请求很复杂，语义内核将需要向 AI 服务提交一个非常长的提示，其中包含您内核中可用的函数的描述、它们的输入和输出，以及用户请求。生成的计划也可能很长，AI
    服务将向您收取提交的提示和输出的费用。避免这种情况的一种方法是通过监控用户频繁创建的请求并保存这些计划，这样就不必每次都重新生成。请注意，然而，如果您保存了计划，并且后端模型（例如，GPT-5
    发布）进行了升级，您必须记得重新生成这些计划以利用新模型的功能。'
- en: '**Testing**: Using a planner makes testing your application a lot harder. For
    example, it’s possible that your kernel has so many functions and that the user
    requests can be so complex that the planner will exceed the context window of
    the model you are using. You will need to do something to handle this runtime
    error, such as limiting the size of the user requests or the number of functions
    available in your kernel. In addition, while the planner works most of the time,
    it’s possible that the planner will occasionally produce faulty plans, such as
    plans that hallucinate functions. You will need to provide error handling for
    that. Interestingly, in practice, the simple error-handling technique of just
    resubmitting the failed plan, telling the AI service that the plan didn’t work,
    and asking “*can you fix it?*” usually works.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：使用规划器会使测试您的应用程序变得更加困难。例如，您的内核可能有如此多的函数，用户请求可能如此复杂，以至于规划器会超出您所使用的模型的上下文窗口。您需要做一些事情来处理这种运行时错误，例如限制用户请求的大小或您内核中可用的函数数量。此外，虽然规划器大多数时候都能正常工作，但偶尔规划器可能会生成错误的计划，例如产生幻觉功能的计划。您需要为此提供错误处理。有趣的是，在实践中，简单地重新提交失败的计划，告诉
    AI 服务该计划不起作用，并询问“*你能修复它吗？*”通常有效。'
- en: With all that in mind, let’s see how to use the planner. The first step is to
    instantiate a planner.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，让我们看看如何使用规划器。第一步是实例化一个规划器。
- en: Instantiating a planner
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例化一个规划器
- en: Instantiating and using a planner is straightforward. In C#, we are going to
    use the Handlebars planner, and in Python, we will use the Stepwise planner.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化和使用规划器很简单。在C#中，我们将使用Handlebars规划器，而在Python中，我们将使用Stepwise规划器。
- en: C#
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: C#
- en: 'C# includes the new `HandlebarsPlanner`, which allows you to create plans that
    include loops, making them shorter. Before using the Handlebars planner in C#,
    you need to install it with the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: C# 包含了新的 `HandlebarsPlanner`，它允许你创建包含循环的计划，使它们更短。在使用C#中的Handlebars规划器之前，你需要使用以下命令安装它：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To configure your Handlebars planner, you will also need to install the OpenAI
    planner connector with the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置你的Handlebars规划器，你还需要安装OpenAI规划器连接器，如下所示：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note that the planner is experimental, and C# will give you an error unless
    you let it know that you are OK with using experimental code, by adding a `pragma`
    directive to your code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，规划器是实验性的，除非你通过在你的代码中添加`pragma`指令来告知C#你同意使用实验性代码，否则C#会给你一个错误：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To create a planner, we execute the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建规划器，我们执行以下代码：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Microsoft recommends using a low `Temperature` and `TopP` for your planners,
    minimizing the chance of the planner creating non-existent functions. Planners
    may consume lots of tokens; therefore, we usually set `MaxTokens` to a high value
    to avoid having a runtime error.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 微软建议为你的规划器使用较低的 `Temperature` 和 `TopP`，以最大限度地减少规划器创建不存在函数的可能性。规划器可能会消耗大量标记；因此，我们通常将
    `MaxTokens` 设置为一个较高的值，以避免运行时错误。
- en: Now, let’s see how to create a planner in Python.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在Python中创建规划器。
- en: Python
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: 'In Python, the Handlebar planner is not available yet, so we need to instantiate
    the Stepwise planner. Plans created by the Stepwise planner tend to be longer
    than Handlebars plans. To add the Stepwise planner to your Python project, you
    need to import the `FunctionCallingStepwisePlanner` and `FunctionCallingStepwisePlannerOptions`
    classes from the `semantic_kernel.planners` package:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，Handlebars规划器尚未提供，因此我们需要实例化Stepwise规划器。Stepwise规划器创建的计划通常比Handlebars计划长。要将Stepwise规划器添加到你的Python项目中，你需要从
    `semantic_kernel.planners` 包中导入 `FunctionCallingStepwisePlanner` 和 `FunctionCallingStepwisePlannerOptions`
    类：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It’s usually a good idea to give planners plenty of tokens. The following is
    a sample command to create a planner, assuming you loaded a service with `service_id`
    set to `gpt4` in your semantic kernel:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通常给规划器提供足够的标记是个好主意。以下是一个创建规划器的示例命令，假设你在你的语义内核中加载了一个服务，并将 `service_id` 设置为 `gpt4`：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, let’s create and run a plan for a user request.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为用户请求创建并运行一个计划。
- en: Creating and running a plan
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和运行计划
- en: Now that we have a planner, we can use it to create a plan for a user’s request
    and then invoke the plan to get a result. In both languages, we use two steps,
    one to create the plan and another one to execute it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了规划器，我们可以用它来为用户的请求创建一个计划，然后调用该计划以获得结果。在两种语言中，我们使用两个步骤，一个用于创建计划，另一个用于执行它。
- en: 'For the next two code snippets, assume you have the user’s request loaded into
    the `ask` string. Let’s see how to call the planner:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接下来的两个代码片段，假设你已经将用户的请求加载到了 `ask` 字符串中。让我们看看如何调用规划器：
- en: C#
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: C#
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Python
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You may remember from [*Chapter 1*](B21826_01.xhtml#_idTextAnchor014) that in
    Python, the result variable contains all the steps to create the plan, so in order
    to see the plan’s results, you need to print `result.final_answer`. If you print
    the `result` variable, you’ll get a large JSON object.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，从 [*第1章*](B21826_01.xhtml#_idTextAnchor014) 中，在Python中，结果变量包含创建计划的所有步骤，因此为了查看计划的结果，你需要打印
    `result.final_answer`。如果你打印 `result` 变量，你会得到一个大的JSON对象。
- en: An example of how a planner can help
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规划器如何帮助的一个例子
- en: Let’s see a simple example that already shows how a planner can help. Let’s
    say you create an application that helps aspiring comedians create jokes. You
    create and connect it to the `jokes` semantic plugin that we created in [*Chapter
    1*](B21826_01.xhtml#_idTextAnchor014). That plugin contains a semantic function
    that creates knock-knock jokes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子，它已经展示了规划器如何帮助。假设你创建了一个帮助有抱负的喜剧演员创作笑话的应用程序。你创建并连接到我们在 [*第1章*](B21826_01.xhtml#_idTextAnchor014)
    中创建的 `jokes` 语义插件。该插件包含一个创建敲门笑话的语义函数。
- en: You can create a UI that allows users to enter a theme (say, “*dog*”) and call
    that function to create a knock-knock joke. If the user wants to create 100 jokes,
    they’ll need to use that UI 100 times. You can work around that problem by creating
    yet another UI that asks for the number of jokes the user wants to create. However,
    if the user wants to create multiple jokes for multiple themes, then they must
    use your two UIs for each theme they want to create a joke for.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建一个 UI，允许用户输入一个主题（例如，“*狗*”），并调用该函数来创建敲门笑话。如果用户想要创建 100 个笑话，他们需要使用该 UI 100
    次。您可以通过创建另一个 UI 来解决这个问题，该 UI 会询问用户想要创建多少个笑话。然而，如果用户想要为多个主题创建多个笑话，那么他们必须为每个想要创建笑话的主题使用您的两个
    UI。
- en: 'Conversely, with just the semantic function and the planner, you can allow
    your user to describe what they want in natural language, such as the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，仅使用语义函数和计划者，您可以允许用户用自然语言描述他们想要的内容，如下所示：
- en: “*Create four knock-knock jokes – two about dogs, one about cats, and one* *about
    ducks*.”
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: “*编四个敲门笑话 - 两个关于狗，一个关于猫，一个关于鸭子。”
- en: 'The complete code is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码如下：
- en: C#
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: C#
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Python
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, we created our kernel and added our jokes plugin to it.
    Now, let’s create the planner.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了我们的内核并将其中的笑话插件添加到其中。现在，让我们创建计划者。
- en: Results
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 结果
- en: 'You will get the following results for both Python and C#:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到以下 Python 和 C# 的结果：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that with a single user request and a single call to `invoke`, Semantic
    Kernel generated several responses, without you having to write any loop, create
    any additional UIs, or chain any functions yourself.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用单个用户请求和单个对 `invoke` 的调用，语义内核生成了多个响应，而无需您编写任何循环，创建任何额外的 UI，或自己链式调用任何函数。
- en: Let’s see what happens behind the scenes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看幕后发生了什么。
- en: How do planners work?
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计划者是如何工作的？
- en: Behind the scenes, the planner uses an LLM prompt to generate a plan. As an
    example, you can see the prompt that is used by `HandlebarsPlanner` by navigating
    to its prompt file in the Semantic Kernel repository, located at [https://github.com/microsoft/semantic-kernel/blob/7c3a01c1b6a810677d871a36a9211cca0ed7fc4d/dotnet/src/Planners/Planners.Handlebars/Handlebars/CreatePlanPrompt.handlebars](https://github.com/microsoft/semantic-kernel/blob/7c3a01c1b6a810677d871a36a9211cca0ed7fc4d/dotnet/src/Planners/Planners.Handlebars/Handlebars/CreatePlanPrompt.handlebars).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，计划者使用 LLM 提示来生成计划。例如，您可以通过导航到位于 [https://github.com/microsoft/semantic-kernel/blob/7c3a01c1b6a810677d871a36a9211cca0ed7fc4d/dotnet/src/Planners/Planners.Handlebars/Handlebars/CreatePlanPrompt.handlebars](https://github.com/microsoft/semantic-kernel/blob/7c3a01c1b6a810677d871a36a9211cca0ed7fc4d/dotnet/src/Planners/Planners.Handlebars/Handlebars/CreatePlanPrompt.handlebars)
    的 Semantic Kernel 存储库中的提示文件来查看 `HandlebarsPlanner` 所使用的提示。
- en: 'The last few lines of the prompt are the most important to understand how the
    planner works:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 提示的最后几行对于理解计划者的工作方式至关重要：
- en: '[PRE11] handlebars block until you''re done with all the steps.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE11] handlebars block until you''re done with all the steps.'
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '{{#each functions}}'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '{{#each functions}}'
- en: '`{{doubleOpen}}{{PluginName}}{{../nameDelimiter}}{{Name}}{{doubleClose}}`'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`{{doubleOpen}}{{PluginName}}{{../nameDelimiter}}{{Name}}{{doubleClose}}`'
- en: 'Description: {{Description}}'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 'Description: {{Description}}'
- en: 'Inputs:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 输入：
- en: '{{#each Parameters}}'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '{{#each Parameters}}'
- en: '- {{Name}}:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '- {{Name}}:'
- en: '{{~#if ParameterType}} {{ParameterType.Name}} -'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '{{~#if ParameterType}} {{ParameterType.Name}} -'
- en: '{{~else}}'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '{{~else}}'
- en: '{{~#if Schema}} {{getSchemaTypeName this}} -{{/if}}'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '{{~#if Schema}} {{getSchemaTypeName this}} -{{/if}}'
- en: '{{~/if}}'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '{{~/if}}'
- en: '{{~#if Description}} {{Description}}{{/if}}'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '{{~#if Description}} {{Description}}{{/if}}'
- en: '{{~#if IsRequired}} (required){{else}} (optional){{/if}}'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '{{~#if IsRequired}} (required){{else}} (optional){{/if}}'
- en: '{{/each}}'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '{{/each}}'
- en: 'Output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '{{~#if ReturnParameter}}'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '{{~#if ReturnParameter}}'
- en: '{{~#if ReturnParameter.ParameterType}} {{ReturnParameter.ParameterType.Name}}'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '{{~#if ReturnParameter.ParameterType}} {{ReturnParameter.ParameterType.Name}}'
- en: '{{~else}}'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '{{~else}}'
- en: '{{~#if ReturnParameter.Schema}} {{getSchemaReturnTypeName ReturnParameter}}'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '{{~#if ReturnParameter.Schema}} {{getSchemaReturnTypeName ReturnParameter}}'
- en: '{{else}} string{{/if}}'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '{{else}} string{{/if}}'
- en: '{{~/if}}'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '{{~/if}}'
- en: '{{~#if ReturnParameter.Description}} - {{ReturnParameter.Description}}{{/if}}'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '{{~#if ReturnParameter.Description}} - {{ReturnParameter.Description}}{{/if}}'
- en: '{{/if}}'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '{{/if}}'
- en: '{{/each}}'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '{{/each}}'
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: using System.ComponentModel;
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: using System.ComponentModel;
- en: using Microsoft.SemanticKernel;
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: using Microsoft.SemanticKernel;
- en: public class HomeAutomation
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: public class HomeAutomation
- en: '{'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '[KernelFunction, Description("Turns the lights of the living room, kitchen,
    bedroom or garage on or off.")]'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[KernelFunction, Description("打开或关闭客厅、厨房、卧室或车库里电灯。")]'
- en: public string OperateLight(
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: public string OperateLight(
- en: '[Description("Whether to turn the lights on or off. Must be either ''on'' or
    ''off''")] string action,'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[Description("是否打开或关闭电灯。必须是 ''on'' 或 ''off''")] string action,'
- en: '[Description("The location where the lights must be turned on or off. Must
    be ''living room'', ''bedroom'', ''kitchen'' or ''garage''")] string location)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[描述("必须打开或关闭灯光的位置。必须是 ''living room'', ''bedroom'', ''kitchen'' 或 ''garage''")]
    string location)'
- en: '{'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: string[] validLocations = {"kitchen", "living room", "bedroom", "garage" };
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: string[] validLocations = {"living room", "bedroom"};
- en: if (validLocations.Contains(location))
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: if (validLocations.Contains(location))
- en: '{'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: string exAction = $"Changed status of the {location} lights to {action}.";
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: string exAction = $"将 {location} 的灯光状态更改为 {action}。";
- en: Console.WriteLine(exAction);
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine(exAction);
- en: return exAction;
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: return exAction;
- en: '}'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: else
- en: '{'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: string error = $"Invalid location {location} specified.";
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: string error = $"指定的位置无效 {location}。";
- en: return error;
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: return error;
- en: '}'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[KernelFunction, Description("Opens or closes the windows of the living room
    or bedroom.")]'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[内核函数, 描述("打开或关闭客厅或卧室的窗户。")]'
- en: public string OperateWindow(
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: public string OperateWindow(
- en: '[Description("Whether to open or close the windows. Must be either ''open''
    or ''close''")] string action,'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[描述("是否打开或关闭窗户。必须是 ''open'' 或 ''close''")] string action,'
- en: '[Description("The location where the windows are to be opened or closed. Must
    be either ''living room'' or ''bedroom''")] string location)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[描述("要打开或关闭窗户的位置。必须是 ''living room'' 或 ''bedroom''")] string location)'
- en: '{'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: string[] validLocations = {"living room", "bedroom"};
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: string[] validLocations = {"living room", "bedroom"};
- en: if (validLocations.Contains(location))
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: if (validLocations.Contains(location))
- en: '{'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: string exAction = $"Changed status of the {location} windows to {action}.";
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: string exAction = $"将 {location} 的窗户状态更改为 {action}。";
- en: Console.WriteLine(exAction);
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine(exAction);
- en: return exAction;
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: return exAction;
- en: '}'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: else
- en: '{'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: string error = $"Invalid location {location} specified.";
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: string error = $"指定的位置无效 {location}。";
- en: return error;
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: return error;
- en: '}'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[KernelFunction, Description("Puts a movie on the TV in the living room or
    bedroom.")]'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[内核函数, 描述("在客厅或卧室的电视上放电影。")]'
- en: public string OperateTV(
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: public string OperateTV(
- en: '[Description("The movie to play on the TV.")] string movie,'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[描述("要在电视上播放的电影。")] string movie,'
- en: '[Description("The location where the movie should be played on. Must be ''living
    room'' or ''bedroom''")] string location)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[描述("电影应播放的位置。必须是 ''living room'' 或 ''bedroom''")] string location)'
- en: '{'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: string[] validLocations = {"living room", "bedroom"};
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: string[] validLocations = {"kitchen", "living room", "bedroom", "garage" };
- en: if (validLocations.Contains(location))
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: if (validLocations.Contains(location))
- en: '{'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: string exAction = $"Playing {movie} on the TV in the {location}.";
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: string exAction = $"在 {location} 的电视上播放 {movie}。";
- en: Console.WriteLine(exAction);
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine(exAction);
- en: return exAction;
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: return exAction;
- en: '}'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: else
- en: '{'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: string error = $"Invalid location {location} specified.";
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: string error = $"指定的位置无效 {location}。";
- en: return error;
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: return error;
- en: '}'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[KernelFunction, Description("Opens or closes the garage door.")]'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[内核函数, 描述("打开或关闭车库门。")]'
- en: public string OperateGarageDoor(
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: public string OperateGarageDoor(
- en: '[Description("The action to perform on the garage door. Must be either ''open''
    or ''close''")] string action)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[描述("对车库门执行的操作。必须是 ''open'' 或 ''close''")] string action)'
- en: '{'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: string exAction = $"Changed status of the garage door to {action}.";
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: string exAction = $"将车库门的状态更改为 {action}。";
- en: Console.WriteLine(exAction);
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine(exAction);
- en: return exAction;
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: return exAction;
- en: '}'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: from typing_extensions import Annotated
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: from typing_extensions import Annotated
- en: from semantic_kernel.functions.kernel_function_decorator import kernel_function
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: from semantic_kernel.functions.kernel_function_decorator import kernel_function
- en: 'class HomeAutomation:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 'class HomeAutomation:'
- en: 'def __init__(self):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self):'
- en: pass
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: '@kernel_function('
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '@kernel_function('
- en: description="Opens or closes the windows of the living room or bedroom.",
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: description="打开或关闭客厅或卧室的窗户。",
- en: name="OperateWindow",
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: name="OperateWindow",
- en: )
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: def OperateWindow(self,
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: def OperateWindow(self,
- en: 'location: Annotated[str, "The location where the windows are to be opened or
    closed. Must be either ''living room'' or ''bedroom''"],'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 'location: Annotated[str, "要打开或关闭窗户的位置。必须是 ''living room'' 或 ''bedroom''"],'
- en: 'action: Annotated[str, "Whether to open or close the windows. Must be either
    ''open'' or ''close''"]) \'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 'action: Annotated[str, "是否打开或关闭窗户。必须是 ''open'' 或 ''close''"]) \'
- en: '-> Annotated[str, "The action that was performed on the windows."]:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '-> Annotated[str, "对窗户执行的操作。"]]:'
- en: 'if location in ["living room", "bedroom"]:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 'if location in ["living room", "bedroom"]:'
- en: action = f"Changed status of the {location} windows to {action}."
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: action = f"将 {location} 的窗户状态更改为 {action}。"
- en: print(action)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: print(action)
- en: return action
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: return action
- en: 'else:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: error = f"Invalid location {location} specified."
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: error = f"指定的位置无效 {location}。"
- en: return error
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: return error
- en: '[PRE16]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '@kernel_function('
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '@kernel_function('
- en: description="Turns the lights of the living room, kitchen, bedroom or garage
    on or off.",
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: description="打开或关闭客厅、厨房、卧室或车库里的大灯。",
- en: name="OperateLight",
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: name="OperateLight",
- en: )
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: def OperateLight(self,
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: def OperateLight(self,
- en: 'location: Annotated[str, "The location where the lights are to be turned on
    or off. Must be either ''living room'', ''kitchen'', ''bedroom'' or ''garage''"],'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 'location: Annotated[str, "要打开或关闭灯光的位置。必须是 ''living room'', ''kitchen'', ''bedroom''
    或 ''garage''"],'
- en: 'action: Annotated[str, "Whether to turn the lights on or off. Must be either
    ''on'' or ''off''"])\'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: "action: Annotated[str, \"是否打开或关闭灯光。必须是 'on' 或 'off'\"]\\\r"
- en: '-> Annotated[str, "The action that was performed on the lights."]:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '-> Annotated[str, "在灯光上执行的动作。"]:'
- en: 'if location in ["kitchen", "living room", "bedroom", "garage"]:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 'if location in ["kitchen", "living room", "bedroom", "garage"]:'
- en: action = f"Changed status of the {location} lights to {action}."
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: action = f"{location} 灯光的状态已更改为 {action}。"
- en: print(action)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: print(action)
- en: return action
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: return action
- en: 'else:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: error = f"Invalid location {location} specified."
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: error = f"指定的位置 {location} 无效。"
- en: return error
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: return error
- en: '@kernel_function('
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '@kernel_function('
- en: description="Puts a movie on the TV in the living room or bedroom.",
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: description="在客厅或卧室的电视上播放电影。",
- en: name="OperateTV",
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: name="OperateTV",
- en: )
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: def OperateTV(self,
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: def OperateTV(self,
- en: 'movie: Annotated[str, "The movie to play on the TV."],'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 'movie: Annotated[str, "要在电视上播放的电影。"],'
- en: 'location: Annotated[str, "The location where the movie should be played on.
    Must be ''living room'' or ''bedroom''"]'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 'location: Annotated[str, "电影应播放的位置。必须是 ''living room'' 或 ''bedroom''"]'
- en: )\
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ")\\\r"
- en: '-> Annotated[str, "The action that was performed on the TV."]:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '-> Annotated[str, "在电视上执行的动作。"]:'
- en: 'if location in ["living room", "bedroom"]:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 'if location in ["living room", "bedroom"]:'
- en: action = f"Playing {movie} on the TV in the {location}."
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: action = f"在 {location} 的电视上播放 {movie}。"
- en: print(action)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: print(action)
- en: return action
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: return action
- en: 'else:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: error = f"Invalid location {location} specified."
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: error = f"指定的位置 {location} 无效。"
- en: return error
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: return error
- en: '@kernel_function('
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '@kernel_function('
- en: description="Opens or closes the garage door.",
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: description="打开或关闭车库门。",
- en: name="OperateGarageDoor"
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: name="OperateGarageDoor"
- en: )
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: def OperateGarageDoor(self,
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: def OperateGarageDoor(self,
- en: 'action: Annotated[str, "The action to perform on the garage door. Must be either
    ''open'' or ''close''"])\'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: "action: Annotated[str, \"对车库门执行的动作。必须是 'open' 或 'close'\"]\\\r"
- en: '-> Annotated[str, "The action that was performed on the garage door."]:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '-> Annotated[str, "在车库门上执行的动作。"]:'
- en: action = f"Changed the status of the garage door to {action}."
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: action = f"将车库门的状态更改为 {action}。"
- en: print(action)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: print(action)
- en: return action
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: return action
- en: '[PRE17]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Given the request below, suggest exactly one movie that you think the requestor
    is going to like. If the request is already a movie title, just return that movie
    title.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下请求，建议一个你认为请求者可能会喜欢的电影。如果请求已经是电影标题，只需返回该电影标题。
- en: Respond only with the title of the movie, nothing else.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 仅响应电影标题，不要包含其他内容。
- en: 'Request:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 'Request:'
- en: '{{ $input }}'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ $input }}'
- en: '[PRE18]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '{'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"schema": 1,'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '"schema": 1,'
- en: '"name": "RecommendMovie",'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '"name": "RecommendMovie",'
- en: '"type": "completion",'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '"type": "completion",'
- en: '"execution_settings": {'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '"execution_settings": {'
- en: '"default": {'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '"default": {'
- en: '"temperature": 0.8,'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '"temperature": 0.8,'
- en: '"number_of_responses": 1,'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '"number_of_responses": 1,'
- en: '"top_p": 1,'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '"top_p": 1,'
- en: '"max_tokens": 4000,'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '"max_tokens": 4000,'
- en: '"presence_penalty": 0.0,'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '"presence_penalty": 0.0,'
- en: '"frequency_penalty": 0.0'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '"frequency_penalty": 0.0'
- en: '}'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '},'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '"input_variables": ['
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '"input_variables": ['
- en: '{'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"name": "input",'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '"name": "input",'
- en: '"description": "name or description of a movie that the user wants to see.
    ",'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '"description": "用户想要观看的电影的名称或描述。",'
- en: '"required": true'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '"required": true'
- en: '}'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ']'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: '}'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE19]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: from semantic_kernel.connectors.ai.open_ai import OpenAIChatCompletion
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: from semantic_kernel.connectors.ai.open_ai import OpenAIChatCompletion
- en: from semantic_kernel.planning.stepwise_planner import StepwisePlanner
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: from semantic_kernel.planning.stepwise_planner import StepwisePlanner
- en: import semantic_kernel as sk
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: import semantic_kernel as sk
- en: from HomeAutomation import HomeAutomation
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: from HomeAutomation import HomeAutomation
- en: from dotenv import load_dotenv
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: from dotenv import load_dotenv
- en: import asyncio
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: import asyncio
- en: 'async def fulfill_request(planner: StepwisePlanner, request):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 'async def fulfill_request(planner: StepwisePlanner, request):'
- en: 'print("Fulfilling request: " + request)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: print("正在满足请求：" + request)
- en: variables = sk.ContextVariables()
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: variables = sk.ContextVariables()
- en: plan = planner.create_plan(request)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: plan = planner.create_plan(request)
- en: result = await plan.invoke_async(variables)
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: result = await plan.invoke_async(variables)
- en: print(result)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: print(result)
- en: print("Request completed.\n\n")
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: print("请求完成。\n\n")
- en: '[PRE20]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'async def main():'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 'async def main():'
- en: kernel = sk.Kernel()
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: kernel = sk.Kernel()
- en: api_key, org_id = sk.openai_settings_from_dot_env()
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: api_key, org_id = sk.openai_settings_from_dot_env()
- en: gpt4 = OpenAIChatCompletion("gpt-4", api_key, org_id)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: gpt4 = OpenAIChatCompletion("gpt-4", api_key, org_id)
- en: kernel.add_chat_service("gpt4", gpt4)
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: kernel.add_chat_service("gpt4", gpt4)
- en: planner = StepwisePlanner(kernel)
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: planner = StepwisePlanner(kernel)
- en: kernel.import_skill(HomeAutomation())
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: kernel.import_skill(HomeAutomation())
- en: kernel.import_semantic_skill_from_directory("../plugins/MovieRecommender", "RecommendMovie")
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: kernel.import_semantic_skill_from_directory("../plugins/MovieRecommender", "RecommendMovie")
- en: '[PRE21]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: await fulfill_request(kernel, planner, "Turn on the lights in the kitchen")
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: await fulfill_request(kernel, planner, "Turn on the lights in the kitchen")
- en: await fulfill_request(kernel, planner, "Open the windows of the bedroom, turn
    the lights off and put on Shawshank Redemption on the TV.")
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: await fulfill_request(kernel, planner, "Open the windows of the bedroom, turn
    the lights off and put on Shawshank Redemption on the TV.")
- en: await fulfill_request(kernel, planner, "Close the garage door and turn off the
    lights in all rooms.")
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: await fulfill_request(kernel, planner, "Close the garage door and turn off the
    lights in all rooms.")
- en: await fulfill_request(kernel, planner, "Turn off the lights in all rooms and
    play a movie in which Tom Cruise is a lawyer in the living room.")
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: await fulfill_request(kernel, planner, "Turn off the lights in all rooms and
    play a movie in which Tom Cruise is a lawyer in the living room.")
- en: 'if __name__ == "__main__":'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: load_dotenv()
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: load_dotenv()
- en: asyncio.run(main())
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: asyncio.run(main())
- en: '[PRE22]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: using Microsoft.SemanticKernel;
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: using Microsoft.SemanticKernel;
- en: using Microsoft.SemanticKernel.Planning.Handlebars;
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: using Microsoft.SemanticKernel.Planning.Handlebars;
- en: '#pragma warning disable SKEXP0060'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '#pragma warning disable SKEXP0060'
- en: var (apiKey, orgId) = Settings.LoadFromFile();
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: var (apiKey, orgId) = Settings.LoadFromFile();
- en: var builder = Kernel.CreateBuilder();
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: var builder = Kernel.CreateBuilder();
- en: builder.AddOpenAIChatCompletion("gpt-4", apiKey, orgId);
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: builder.AddOpenAIChatCompletion("gpt-4", apiKey, orgId);
- en: builder.Plugins.AddFromType<HomeAutomation>();
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: builder.Plugins.AddFromType<HomeAutomation>();
- en: builder.Plugins.AddFromPromptDirectory("../../../plugins/MovieRecommender");
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: builder.Plugins.AddFromPromptDirectory("../../../plugins/MovieRecommender");
- en: var kernel = builder.Build();
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: var kernel = builder.Build();
- en: '[PRE23]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: void FulfillRequest(HandlebarsPlanner planner, string ask)
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: void FulfillRequest(HandlebarsPlanner planner, string ask)
- en: '{'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: 'Console.WriteLine($"Fulfilling request: {ask}");'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 'Console.WriteLine($"Fulfilling request: {ask}");'
- en: var plan = planner.CreatePlanAsync(kernel, ask).Result;
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: var plan = planner.CreatePlanAsync(kernel, ask).Result;
- en: var result = plan.InvokeAsync(kernel, []).Result;
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: var result = plan.InvokeAsync(kernel, []).Result;
- en: Console.WriteLine("Request complete.");
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine("Request complete.");
- en: '}'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE24]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: var plannerOptions = new HandlebarsPlannerOptions()
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: var plannerOptions = new HandlebarsPlannerOptions()
- en: '{'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: ExecutionSettings = new OpenAIPromptExecutionSettings()
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ExecutionSettings = new OpenAIPromptExecutionSettings()
- en: '{'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Temperature = 0.0,
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Temperature = 0.0,
- en: TopP = 0.1,
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: TopP = 0.1,
- en: MaxTokens = 4000
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: MaxTokens = 4000
- en: '},'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: AllowLoops = true
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: AllowLoops = true
- en: '};'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: var planner = new HandlebarsPlanner(plannerOptions);
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: var planner = new HandlebarsPlanner(plannerOptions);
- en: FulfillRequest(planner, "Turn on the lights in the kitchen");
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: FulfillRequest(planner, "Turn on the lights in the kitchen");
- en: FulfillRequest(planner, "Open the windows of the bedroom, turn the lights off
    and put on Shawshank Redemption on the TV.");
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: FulfillRequest(planner, "Open the windows of the bedroom, turn the lights off
    and put on Shawshank Redemption on the TV.");
- en: FulfillRequest(planner, "Close the garage door and turn off the lights in all
    rooms.");
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: FulfillRequest(planner, "Close the garage door and turn off the lights in all
    rooms.");
- en: FulfillRequest(planner, "Turn off the lights in all rooms and play a movie in
    which Tom Cruise is a lawyer in the living room.");
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: FulfillRequest(planner, "Turn off the lights in all rooms and play a movie in
    which Tom Cruise is a lawyer in the living room.");
- en: '[PRE25]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Fulfilling request: Turn on the lights in the kitchen'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 'Fulfilling request: Turn on the lights in the kitchen'
- en: Changed status of the kitchen lights to on.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 将厨房灯的状态更改为开启。
- en: Request complete.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Request complete.
- en: 'Fulfilling request: Open the windows of the bedroom, turn the lights off and
    put on Shawshank Redemption on the TV.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 'Fulfilling request: Open the windows of the bedroom, turn the lights off and
    put on Shawshank Redemption on the TV.'
- en: Changed status of the bedroom windows to open.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 将卧室窗户的状态更改为开启。
- en: Changed status of the bedroom lights to off.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 将卧室灯的状态更改为关闭。
- en: Playing Shawshank Redemption on the TV in the bedroom.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在卧室的电视上播放《肖申克的救赎》。
- en: Request complete.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Request complete.
- en: 'Fulfilling request: Close the garage door and turn off the lights in all rooms.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 'Fulfilling request: Close the garage door and turn off the lights in all rooms.'
- en: Changed status of the garage door to close.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 将车库门的状态更改为关闭。
- en: Changed status of the living room lights to off.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 将客厅灯的状态更改为关闭。
- en: Changed status of the bedroom lights to off.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 将卧室灯的状态更改为关闭。
- en: Changed status of the kitchen lights to off.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 将厨房灯的状态更改为关闭。
- en: Changed status of the garage lights to off.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 将车库灯的状态更改为关闭。
- en: Request complete.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: Request complete.
- en: 'Fulfilling request: Turn off the lights in all rooms and play a movie in which
    Tom Cruise is a lawyer in the living room.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 'Fulfilling request: Turn off the lights in all rooms and play a movie in which
    Tom Cruise is a lawyer in the living room.'
- en: Changed status of the living room lights to off.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 将客厅灯的状态更改为关闭。
- en: Changed status of the bedroom lights to off.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 将卧室灯的状态更改为关闭。
- en: Changed status of the kitchen lights to off.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 将厨房灯的状态更改为关闭。
- en: Changed status of the garage lights to off.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 将车库灯的状态更改为关闭。
- en: Playing A Few Good Men on the TV in the living room.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在客厅的电视上播放《非常嫌疑犯》。
- en: Request complete.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Request complete.
- en: '```'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The planner executed each request flawlessly, and you didn’t have to write any
    code. When the user asks something such as “*turn off the lights in all rooms*,”
    the planner realizes that it needs to call the function for the kitchen, the bedroom,
    the living room, and the garage.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 规划器完美地执行了每个请求，而你无需编写任何代码。当用户询问诸如“*关闭所有房间的灯光*”之类的事情时，规划器意识到需要调用厨房、卧室、客厅和车库里面的函数。
- en: When the user asks for a movie with Tom Cruise as a lawyer, the planner realizes
    that it needs to call a semantic function to find the name of the movie before
    calling the `OperateTV` function to put the movie on the TV, again without you
    having to write code for this explicitly.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户请求一部由汤姆·克鲁斯扮演律师的电影时，规划器意识到在调用`OperateTV`函数将电影放到电视上之前，需要调用一个语义函数来找到电影的名字，而你无需为此显式地编写代码。
- en: Summary
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the planner, a powerful function that allows
    users to execute very complex workflows with minimal effort on the developer’s
    part. We learned when to use the planner and what the potential issues are. We
    also learned how to use the planner, as well as how to write descriptions for
    the functions in our plugins in a way that makes it easier for the planner to
    combine them. We then saw a longer example of how to use the planner to let a
    user combine native and semantic functions.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了规划器，这是一个强大的功能，允许用户以最小的开发人员努力执行非常复杂的流程。我们学习了何时使用规划器以及可能存在的问题。我们还学习了如何使用规划器，以及如何编写插件中函数的描述，以便规划器更容易地将它们组合起来。然后我们看到了一个更长的示例，展示了如何使用规划器让用户结合原生和语义函数。
- en: In the next chapter, we will explore ways to make external data available to
    Semantic Kernel. Later we will pair search with external data to allow models
    to use large amounts of data that exceed models’ context windows.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨将外部数据提供给语义内核的方法。稍后，我们将搜索与外部数据配对，以便模型可以使用超出模型上下文窗口的大量数据。
