- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Extending Behavior Trees
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展行为树
- en: Understanding the nuances of behavior trees is crucial for game developers,
    as they enable them to have a firm grasp on creating responsive and more engaging
    AI characters. This is why, in this chapter, we will embark on a deep dive into
    the inner workings and best practices of the behavior tree system for Unreal Engine;
    we will go through a thorough explanation of their functionality, most notably
    on how to create more complex custom tasks, services, and decorators for our AI
    agents. Additionally, we will go back to the debugging tools and see how to analyze
    behavior trees at runtime.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 理解行为树细微差别对于游戏开发者至关重要，因为它们使他们能够牢固掌握创建响应性和更具吸引力的AI角色。这就是为什么在本章中，我们将深入探讨Unreal
    Engine行为树系统的内部运作和最佳实践；我们将详细解释其功能，特别是如何为我们的AI代理创建更复杂的自定义任务、服务和装饰器。此外，我们还将回顾调试工具，看看如何在运行时分析行为树。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Presenting best practices for authoring behavior trees
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示编写行为树的最佳实践
- en: Understanding decorators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解装饰器
- en: Understanding services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解服务
- en: Understanding tasks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解任务
- en: Debugging behavior trees
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试行为树
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the topics presented in this chapter, you should have completed the
    previous ones and understood their content.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章介绍的主题，你应该已经完成了前面的章节，并理解了它们的内容。
- en: 'Additionally, if you would prefer to begin with code from the companion repository
    for this book, you can download the **.zip** project files provided in this book’s
    companion project repository: [https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5](https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5)
    .'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你希望从本书的配套仓库开始编写代码，你可以下载本书配套项目仓库中提供的**.zip**项目文件：[https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5](https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5)。
- en: To download the files from the end of the last chapter, click the **Unreal Agility
    Arena –** **Chapter 08** **-** **End** link.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载最后一章末尾的文件，请点击**Unreal Agility Arena –** **第08章** **-** **结束**链接。
- en: Presenting best practices for authoring behavior trees
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示编写行为树的最佳实践
- en: 'It seems our little novel has a new chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 看来我们的小小说有了新的一章：
- en: '*In their quest to test the capabilities of their AI puppets, Dr. Markus and
    Professor Viktoria decided to equip them with Nerf guns. The idea was to create
    a fun and engaging scenario where the puppets could showcase their newfound* *shooting
    skills.*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在他们测试AI木偶能力的过程中，马克斯博士和维克托利亚教授决定给他们配备飞镖枪。这个想法是创造一个有趣且引人入胜的场景，让木偶能够展示他们新获得*的射击技巧*。
- en: '*In the secret lab, the atmosphere buzzed with excitement as the puppets, now
    armed and ready with non-lethal weapons, were going to take on the challenge.
    With their advanced AI programming and sensor systems, the puppets were able to
    analyze the environment, calculate trajectories, and take aim at the targets with*
    *remarkable accuracy.*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在秘密实验室里，气氛充满了兴奋，因为木偶现在装备了非致命武器，准备接受挑战。凭借他们先进的AI编程和传感器系统，木偶能够分析环境，计算弹道，并以*惊人的准确性*瞄准目标。
- en: When designing a behavior tree for your AI agents, it is crucial to possess
    a thorough understanding of the best practices to consider. Additionally, staying
    up to date with the latest advancements and research in the field of AI in the
    video game industry will provide valuable insights and inform your decision-making
    process when designing better behavior trees.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当为你的AI代理设计行为树时，掌握最佳实践至关重要。此外，了解视频游戏行业中AI领域的最新进展和研究将提供有价值的见解，并指导你在设计更好的行为树时的决策过程。
- en: Listing best practices
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出最佳实践
- en: In this subsection, I will provide you with some valuable advice to optimize
    and enhance the engagement of your AIs; some of them come from well-known patterns,
    while some originate from my own personal experience – most of the time, acquired
    by a trial-and-error process.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我将为你提供一些宝贵的建议来优化和增强你AI的参与度；其中一些来自知名模式，而另一些则源于我个人的经验——大多数情况下是通过试错过程获得的。
- en: Use proper naming conventions
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用适当的命名约定
- en: 'It is good practice to properly name any newly created tasks, decorators, or
    services in the behavior tree. Use naming conventions that indicate the type of
    asset, be it a task, decorator, or service. As a rule of thumb, you should use
    the following prefixes:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在行为树中为新创建的任务、装饰器或服务正确命名是一种良好的做法。使用表明资产类型的命名约定，无论是任务、装饰器还是服务。作为一个经验法则，你应该使用以下前缀：
- en: '**BTTask_** for tasks'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BTTask_** 用于任务'
- en: '**BTDecorator_** for decorators'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BTDecorator_** 用于装饰器'
- en: '**BTService_** for services'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BTService_** 用于服务'
- en: This will not only help you in making it clear the type of asset you have created
    but you will also get a beneficial side effect; in the behavior tree graph, the
    system will recognize the type of class and will remove the prefix by showing
    just the node name. The use of improper naming conventions would result in erratic
    behaviors when trying to select the nodes in the node graph.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅可以帮助你清楚地了解你创建的资产类型，你还会得到一个有益的副作用；在行为树图中，系统将识别类类型，并将前缀移除，仅显示节点名称。使用不正确的命名约定会导致在尝试选择节点图中的节点时出现不规律的行为。
- en: As an example, in [*Chapter 8*](B31016_08.xhtml#_idTextAnchor148) , *Setting
    Up a Behavior Tree* , you may have noticed that we named the battery check service
    **BTService_BatteryCheck** , but in the behavior tree graph, it is shown just
    as **Battery Check** .
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在[*第8章*](B31016_08.xhtml#_idTextAnchor148)，“设置行为树”中，你可能已经注意到我们给电池检查服务命名为**BTService_BatteryCheck**，但在行为树图中，它仅显示为**电池检查**。
- en: Give your nodes a meaningful name
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 给你的节点一个有意义的名称
- en: Behavior tree tasks, decorators, and services all have a property named **NodeName**
    that will be used to display the node name in the graph; use it if you want to
    give your nodes a different name than the class name.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树任务、装饰器和服务都有一个名为**NodeName**的属性，它将用于在图中显示节点名称；如果你想给你的节点一个不同于类名的名称，请使用它。
- en: Avoid directly changing node properties
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免直接更改节点属性
- en: Instead of directly changing the properties of nodes within the behavior tree,
    you should leverage the power of Blackboards and change its keys. Alternatively,
    you may call a function inside the character that makes the necessary modifications
    to keys. This will help maintain a cleaner and more organized structure.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是直接更改行为树中节点的属性，你应该利用黑板的力量并更改其键。或者，你也可以调用角色内的函数，对键进行必要的修改。这将有助于保持更干净、更有组织的结构。
- en: As an example, our previously created dummy puppet handles the battery logic
    through the character and some dedicated Blackboard keys.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们之前创建的虚拟木偶通过角色和一些专门的黑板键处理电池逻辑。
- en: Consider performance optimization
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 考虑性能优化
- en: The behavior tree system in Unreal Engine is fundamentally optimized, as it
    avoids evaluating the entire tree at every frame and instead relies on success
    and fail notifications to determine the next node to execute. However, it is important
    to exercise caution and not rely too heavily on certain features with the assumption
    that they will automatically function as intended.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine中的行为树系统在本质上进行了优化，因为它避免在每一帧评估整个树，而是依赖于成功和失败通知来确定下一个要执行的节点。然而，重要的是要谨慎行事，不要过度依赖某些功能，假设它们会自动按预期工作。
- en: As an example, in the *Battery Check* service we previously created, we disabled
    the tick interval, leveraging the power of delegates instead.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们之前创建的**电池检查**服务中，我们禁用了tick间隔，利用了代理的力量。
- en: Use modular design
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用模块化设计
- en: Try breaking down complex behaviors into smaller, reusable modules such as tasks,
    services, and decorators. This modular approach will make it easier to maintain
    and update the behavior tree.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将复杂的行为分解成更小、可重用的模块，如任务、服务和装饰器。这种模块化方法将使维护和更新行为树变得更加容易。
- en: As an example of small tasks creating a more complex behavior, try checking
    the **Roam Sequence** from the behavior tree implemented in [*Chapter 8*](B31016_08.xhtml#_idTextAnchor148)
    , *Setting Up a* *Behavior Tree* .
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了创建更复杂的行为，尝试检查[*第8章*](B31016_08.xhtml#_idTextAnchor148)，“设置行为树”中实现的小任务**Roam
    Sequence**。
- en: Do not assume your character is going to be an AI agent
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要假设你的角色将是一个AI代理
- en: When developing an AI character, you may be tempted to add AI logic directly
    into the **Character** class. However, it is generally advisable to avoid this
    practice. The **AI Controller** class has been specifically designed to serve
    a purpose, offering a more structured and modular method for overseeing the AI
    behavior of characters. By leveraging the **AI Controller** class, you can effectively
    separate the AI logic from the character itself, resulting in enhanced maintainability
    and the ability to update the AI behavior independently.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发AI角色时，你可能倾向于直接在**Character**类中添加AI逻辑。然而，通常建议避免这种做法。**AI Controller**类已被专门设计来服务于特定目的，提供了一种更结构化和模块化的方法来监督角色的AI行为。通过利用**AI
    Controller**类，你可以有效地将AI逻辑与角色本身分离，从而提高可维护性并能够独立更新AI行为。
- en: As an example, having the capability of switching between an AI controller and
    a player controller at runtime can provide several advantages such as allowing
    a player to take control of an AI character.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在运行时能够在AI控制器和玩家控制器之间切换的能力可以提供几个优势，例如允许玩家控制AI角色。
- en: As a rule of thumb, it is recommended to create your **Pawn** and **Character**
    classes in a way that allows them to be controlled by both players and AI interchangeably.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，建议以允许玩家和AI可以相互切换控制的方式创建你的**Pawn**和**Character**类。
- en: Later in this chapter, we will be creating a brand-new AI agent with this in
    mind.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将考虑到这一点创建一个新的AI代理。
- en: Debug and test often
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 经常调试和测试
- en: Regularly test and debug your behavior tree to ensure it functions as intended.
    Use debugging tools provided by Unreal Engine to identify and resolve any issues.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 定期测试和调试你的行为树以确保其按预期工作。使用由虚幻引擎提供的调试工具来识别和解决任何问题。
- en: By the end of this chapter, I will be showing you how to properly use the debugging
    tools with your behavior trees.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我将向你展示如何正确使用调试工具与你的行为树。
- en: Now that you have some additional information on how to create an AI agent effectively,
    it’s time to dive back into our project and begin crafting a brand-new character!
    Let’s get started!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了一些关于如何有效地创建AI代理的信息，是时候回到我们的项目并开始制作一个新的角色了！让我们开始吧！
- en: Implementing a gunner character logic
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现枪手角色逻辑
- en: As a starting point, we will be creating a new AI character with some extra
    features; in particular, it will have some nice gunning capabilities to shoot
    at targets – by means of a non-lethal Nerf gun. As mentioned earlier, it’s important
    to prioritize simplicity and modularity when working on your characters. In this
    particular scenario, it doesn’t make sense to have the shooting logic integrated
    within the base character. Instead, it would be more effective to take advantage
    of the capabilities provided by Unreal Engine components. By doing so, you can
    keep the shooting functionality separate and modular, allowing for better organization
    and flexibility in your project. As a final result, the AI agent will be capable
    of shooting at targets, by using AI behaviors.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 作为起点，我们将创建一个新的AI角色，并添加一些额外功能；特别是，它将具有一些射击目标的能力——通过非致命的Nerf枪。如前所述，当你在角色上工作时，优先考虑简单性和模块化是很重要的。在这种情况下，将射击逻辑集成到基础角色中是没有意义的。相反，利用虚幻引擎组件提供的功能将更为有效。这样做可以将射击功能保持为独立和模块化，从而在项目中提供更好的组织和灵活性。最终结果，AI代理将能够通过使用AI行为射击目标。
- en: Creating the BaseWeaponComponent class
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建BaseWeaponComponent类
- en: To create a weapon component for our dummy character, we will start by extending
    a **StaticMeshComponent** class; this will give a good starting point – the mesh
    – and we will just need to add the socket attaching logic and the shooting logic.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们的虚拟角色创建武器组件，我们首先将扩展**StaticMeshComponent**类；这将提供一个良好的起点——网格——我们只需要添加附加逻辑和射击逻辑。
- en: To start creating this component, from Unreal Engine, create a new C++ class
    extending from **StaticMeshComponent** and name it **BaseWeaponComponent** .
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始创建此组件，从虚幻引擎中创建一个新的C++类，从**StaticMeshComponent**扩展，并将其命名为**BaseWeaponComponent**。
- en: 'Once the class has been created, open the **BaseWeaponComponent.h** file and
    change the **UCLASS()** macro with this line of code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了类，打开**BaseWeaponComponent.h**文件，并用以下代码行替换**UCLASS()**宏：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will make the component accessible to Blueprints, and you can attach it
    directly to a Blueprint class.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使组件对蓝图可用，并且你可以直接将其附加到蓝图类。
- en: 'Now, inside the class, just after the **GENERATED_BODY()** macro, add the following
    declarations:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在类内部，就在**GENERATED_BODY()**宏之后，添加以下声明：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we are declaring the constructor, a **Shoot()** function that will spawn
    a bullet; then, we declare the **BulletClass** property for the spawned bullet
    and **MuzzleOffset** to precisely place the bullet spawn point. Finally, in the
    **protected** section, we will need the **BeginPlay()** declaration to add some
    initialization.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了构造函数，一个名为**Shoot()**的函数，它将生成子弹；然后，我们声明了生成的子弹的**BulletClass**属性和**MuzzleOffset**以精确放置子弹生成点。最后，在**protected**部分，我们需要**BeginPlay()**声明来添加一些初始化。
- en: 'We are now ready to implement the component, so open the **BaseWeaponComponent.cpp**
    file and, at the very top of it, add this line of code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好实现组件，所以打开**BaseWeaponComponent.cpp**文件，并在它的最顶部添加此行代码：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Immediately after that, add the class constructor:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着，添加类构造函数：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This function is quite easy and straightforward as we are just declaring a default
    mesh – a Nerf gun pistol – for the component; you will be free to change it later
    on when extending this class with a Blueprint.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数相当简单直接，因为我们只是为组件声明了一个默认网格——一个Nerf手枪手枪；你将在以后使用蓝图扩展此类时可以自由更改它；
- en: 'After that, add the **BeginPlay()** implementation:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，添加**BeginPlay()**实现：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This function tries to cast the owner of the component to a **Character** object,
    and if the cast is successful, it attaches the component to the mesh of the character
    at the **hand_right** socket so that the gun will stay in the character’s right
    hand; I have already provided such a socket for you in the **Dummy** skeletal
    mesh, as shown in *Figure 9* *.1* :'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数尝试将组件的所有者转换为**Character**对象，如果转换成功，则将组件附加到**hand_right**插座上的角色网格，以便枪保持在角色的右手；我已经在**Dummy**骨骼网格中为你提供了这样的插座，如图*图9*
    *.1* 所示：
- en: '![Figure 9.1 – Hand socket](img/B31016_figure_09.01.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 手柄插座](img/B31016_figure_09.01.jpg)'
- en: Figure 9.1 – Hand socket
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 手柄插座
- en: 'As a final step, it’s time to implement the **Shoot()** function logic, so
    add the following lines of code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，现在是时候实现**Shoot()**函数逻辑了，所以添加以下代码行：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This function checks whether **BulletClass** is valid, gets the reference to
    **World** – the top-level object that represents a map reference – then calculates
    the spawn location and rotation based on the owner’s position, and finally, spawns
    an actor using **BulletClass** at the calculated location and rotation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数检查**BulletClass**是否有效，获取**World**的引用——代表地图引用的最高级对象——然后根据所有者的位置计算生成位置和旋转，最后使用**BulletClass**在计算的位置和旋转处生成一个actor。
- en: The component is now ready; the next step will be to create a proper bullet
    to shoot at the right time.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 组件现在已准备就绪；下一步将是创建合适的子弹以在正确的时间射击。
- en: Creating the BaseBullet class
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建BaseBullet类
- en: 'Having created a weapon component that spawns bullets, the next logical step
    is to create a spawnable bullet. This is going to be quite straightforward; we
    will be creating an object with a mesh that will move forward, doing damage to
    anything that it will hit. Let’s start by creating a new C++ class extending **Actor**
    and calling it **BaseGunBullet** ; after the class has been created, open the
    **BaseGunBullet.h** header file and, just after the **#include** section, add
    the following forward declarations:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了生成子弹的武器组件之后，下一步的逻辑步骤是创建一个可生成的子弹。这将非常直接；我们将创建一个带有网格的对象，它会向前移动，对它所击中的任何东西造成伤害。让我们先创建一个新的C++类，扩展**Actor**并命名为**BaseGunBullet**；在类创建完成后，打开**BaseGunBullet.h**头文件，并在**#include**部分之后添加以下前置声明：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After that, change the **UCLASS()** macro so that this class is an acceptable
    base for creating Blueprints:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，更改**UCLASS()**宏，使这个类成为创建蓝图的可接受基类：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, just after the **GENERATED_BODY()** macro, add the needed component declarations:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就在**GENERATED_BODY()**宏之后，添加所需组件声明：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The next step is to declare the **public** functions – that is, the constructor
    and the getters for the components – so add the following lines of code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是声明**public**函数——即构造函数和组件的获取器——所以添加以下代码行：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the **protected** section, remove the **BeginPlay()** declaration as it
    won’t be needed. Instead, we will need the **OnHit()** handler for bullet collision
    events:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在**protected**部分，移除**BeginPlay()**声明，因为它将不再需要。相反，我们需要子弹碰撞事件的**OnHit()**处理程序：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now that the header is complete, it’s time to start implementing the class,
    so open up **BaseGunBullet.cpp** . As a first step, add the needed **#include**
    declarations at the top of the file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在头文件已经完成，是时候开始实现类了，所以打开**BaseGunBullet.cpp**。作为第一步，在文件顶部添加所需的**#include**声明：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, remove the **BeginPlay()** implementation, which, as I previously said,
    won’t be needed. After that, add the constructor implementation:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，移除**BeginPlay()**实现，正如我之前所说的，它将不再需要。之后，添加构造函数实现：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Most of the aforementioned code has been addressed previously or is self-explanatory,
    although there are some important things to mention. The **CollisionComponent**
    collision profile name has been set to **BlockAll** , in order to get proper collisions;
    additionally, we have bound the **OnComponentHit** delegate to the **OnHit()**
    method, in order to react to any bullet collisions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 上述大部分代码之前已经讨论过或已解释清楚，尽管还有一些重要的事情需要说明。**CollisionComponent**的碰撞配置文件名称已被设置为**BlockAll**，以便获得适当的碰撞；此外，我们将**OnComponentHit**委托绑定到**OnHit()**方法，以便对任何子弹碰撞做出反应。
- en: 'We can now add the final method implementation, which will handle the bullet
    hitting any object:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加最终的方法实现，它将处理子弹击中任何对象的情况：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, we just call the **TakeDamage()** method to the **Actor** object
    that has been hit and then we destroy the bullet. No need to worry about damage
    parameters in this game! They aren’t the focus of this book, so you have the freedom
    to add your own damage logic and stick to it if you’d like. Feel free to customize
    the game to your heart’s content!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只是调用被击中的**Actor**对象的**TakeDamage()**方法，然后销毁子弹。在这个游戏中，不需要担心伤害参数！它们不是本书的重点，所以您可以自由添加自己的伤害逻辑并坚持使用。请随意根据您的喜好定制游戏！
- en: Now that we’ve finalized the bullet class, it’s time to create a suitable target
    for it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了子弹类的最终版本，是时候为它创建一个合适的靶子了。
- en: Implementing a Target class
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现目标类
- en: We now need to create a base actor that we will be using to implement a target
    for our shooting AI agent. So, let’s start by creating a new C++ class extending
    from **Actor** and call it **BaseTarget** . Once the class has been created, open
    up the **BaseTarget.h** header file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要创建一个基类actor，我们将用它来实现射击AI代理的目标。所以，让我们首先创建一个新的C++类，从**Actor**扩展，并命名为**BaseTarget**。一旦创建了类，就打开**BaseTarget.h**头文件。
- en: 'As a first step, add this forward declaration just after the **#** **include**
    section:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，在**#include**部分之后添加以下前置声明：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, remove the **BeginPlay()** and **Tick()** functions as they won’t be
    needed, and add the following declarations just after the **ABaseTarget()** constructor:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，移除**BeginPlay()**和**Tick()**函数，因为它们将不再需要，并在**ABaseTarget()**构造函数之后添加以下声明：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Apart from the **StaticMeshComponent** property that will be used to show the
    target mesh, we have added the **TakeDamage()** declaration that will be used
    to handle hits from bullets.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将用于显示目标网格的**StaticMeshComponent**属性外，我们还添加了用于处理子弹击中的**TakeDamage()**声明。
- en: 'Now, open the **BaseTarget.cpp** file and, after removing the **BeginPlay()**
    and **Tick()** function implementations, change the constructor with the following
    code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开**BaseTarget.cpp**文件，在移除**BeginPlay()**和**Tick()**函数实现后，用以下代码替换构造函数：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By now, you should already be familiar with the previous code; after disabling
    the tick functionality for this actor, we proceeded to add and initialize a **StaticMesh**
    component, which will serve the purpose of displaying a target in our project.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，您应该已经熟悉了之前的代码；在禁用此actor的tick功能后，我们继续添加并初始化一个**StaticMesh**组件，它将在我们的项目中用于显示目标。
- en: 'Now, add the **TakeDamage()** implementation to your file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将**TakeDamage()**实现添加到您的文件中：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, the approach here is quite simple; we are merely using the **Untagged**
    keyword, which will invalidate the tag assigned to the parent object. This effectively
    renders it invisible to the behavior tree task we will be constructing later in
    this chapter. We don’t need to worry about damage logic; once a target has been
    it, it will just be invalidated.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里的方法相当简单；我们只是使用了**未标记**关键字，这将使分配给父对象的标签失效。这实际上使得它对我们将在本章后面构建的行为树任务不可见。我们不需要担心伤害逻辑；一旦目标被标记，它就会失效。
- en: Now that all the base classes have been created, we are ready to implement the
    needed Blueprints, including a brand-new gunner character.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有基类都已创建，我们准备实现所需的蓝图，包括一个全新的枪手角色。
- en: Creating the Blueprints
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建蓝图
- en: 'We will proceed with the creation of the Blueprints that will be instrumental
    in generating the new AI gunner agent. Specifically, we will be working on the
    following components:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续创建将有助于生成新AI枪手代理的蓝图。具体来说，我们将专注于以下组件：
- en: The spawnable bullet
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可生成的子弹
- en: The target
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标
- en: The gunner character itself
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枪手角色本身
- en: Let’s start by creating the bullet Blueprint.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建子弹蓝图开始。
- en: Implementing the bullet Blueprint
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现子弹蓝图
- en: 'The creation of the bullet Blueprint is quite straightforward. Just follow
    these steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 创建枪弹蓝图的过程相当直接。只需遵循以下步骤：
- en: Open the **Blueprints** folder in the Unreal Engine **Content Drawer** .
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在虚幻引擎**内容抽屉**中打开**蓝图**文件夹。
- en: Right-click on it and select **Blueprint Class** .
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击并选择**蓝图类**。
- en: From the **All Classes** section, select **BaseGunBullet** .
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**所有类**部分，选择**BaseGunBullet**。
- en: 'Name the new asset **BP_GunBullet** . *Figure 9* *.2* shows the final Blueprint
    class:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新资产命名为**BP_GunBullet**。*图9.2*显示了最终的蓝图类：
- en: '![Figure 9.2 – Gun bullet Blueprint](img/B31016_figure_09.02.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 枪弹蓝图](img/B31016_figure_09.02.jpg)'
- en: Figure 9.2 – Gun bullet Blueprint
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 枪弹蓝图
- en: Implementing the target Blueprint
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现目标蓝图
- en: 'The creation of the target Blueprint is almost identical to the bullet one;
    we just need to add a tag to the object. Do the following steps:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 目标蓝图创建几乎与子弹蓝图相同；我们只需向对象添加一个标签。执行以下步骤：
- en: Open the **Blueprints** folder in the Unreal Engine **Content Drawer** .
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在虚幻引擎**内容抽屉**中打开**蓝图**文件夹。
- en: Right-click on it and select **Blueprint Class** .
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击并选择**蓝图类**。
- en: From the **All Classes** section, select **BaseTarget** .
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**所有类**部分，选择**BaseTarget**。
- en: Name the new asset **BP_Target** .
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新资产命名为**BP_Target**。
- en: In the **Details** panel, look for the **Tags** property in the **Actor** |
    **Advanced** category and hit the **+** button to create a new tag.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**细节**面板中，查找**Actor** | **高级**类别中的**Tags**属性，并点击**+**按钮创建一个新的标签。
- en: 'Name the tag **ShootingTarget** , as shown in *Figure 9* *.3* :'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标签命名为**ShootingTarget**，如图*图9.3*所示：
- en: '![Figure 9.3 – Target tag](img/B31016_figure_09.03.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 目标标签](img/B31016_figure_09.03.jpg)'
- en: Figure 9.3 – Target tag
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 目标标签
- en: '*Figure 9* *.4* shows the final Blueprint class:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.4*显示了最终的蓝图类：'
- en: '![Figure 9.4 – Target Blueprint](img/B31016_figure_09.04.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 目标蓝图](img/B31016_figure_09.04.jpg)'
- en: Figure 9.4 – Target Blueprint
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 目标蓝图
- en: Implementing the gunner character Blueprint
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现枪手角色蓝图
- en: 'It’s now time to create the gunner character as a Blueprint. You are already
    familiar with the process, but here are the steps to follow:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是创建枪手角色蓝图的时候了。您已经熟悉这个过程，但以下是需要遵循的步骤：
- en: Open the **Blueprints** folder in the Unreal Engine **Content Drawer** .
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在虚幻引擎**内容抽屉**中打开**蓝图**文件夹。
- en: Right-click on it and select **Blueprint Class** .
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击并选择**蓝图类**。
- en: From the **All Classes** section, select **BaseDummyCharacter** .
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**所有类**部分，选择**BaseDummyCharacter**。
- en: Name the new asset **BP_GunnerDummy** .
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新资产命名为**BP_GunnerDummy**。
- en: 'We’ll add the AI controller later in this chapter, but we need to change a
    value in the Blueprint class in order to make our character properly work. So,
    open this Blueprint and, in the **Details** panel, locate the **Use Controller
    Rotation Yaw** attribute in the **Pawn** category; this will allow rotation of
    the character correctly when using AI logic later on. Tick the value, as depicted
    in *Figure 9* *.5* :'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面添加AI控制器，但我们需要在蓝图类中更改一个值，以便我们的角色能够正确工作。因此，打开此蓝图，在**细节**面板中，定位到**Pawn**类别中的**Use
    Controller Rotation Yaw**属性；这将允许在稍后使用AI逻辑时正确旋转角色。勾选该值，如图*图9.5*所示：
- en: '![Figure 9.5 – Use Controller Rotation Yaw ticked](img/B31016_figure_09.05.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 使用控制器偏航旋转已勾选](img/B31016_figure_09.05.jpg)'
- en: Figure 9.5 – Use Controller Rotation Yaw ticked
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 使用控制器偏航旋转已勾选
- en: This value will allow us to rotate the character through a task when shooting
    at a target.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此值将允许我们在射击目标时通过任务旋转角色。
- en: 'Now, it’s time to add a proper weapon to the character. To do this, follow
    these steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候为角色添加合适的武器了。为此，请按照以下步骤操作：
- en: With the Blueprint character class open, locate the **Components** panel and
    click the **+** **Add** button.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的蓝图角色类中，定位到**组件**面板，并点击**+** **添加**按钮。
- en: Select **UnrealAgilityArena** | **Base Weapon** to add this component to the
    Blueprint class.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**UnrealAgilityArena** | **基础武器**以将此组件添加到蓝图类中。
- en: Select this newly added component and, in the **Bullet** category of the **Details**
    panel, locate the **Bullet Class** attribute; from its dropdown, select **BP_GunBullet**
    .
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择这个新添加的组件，在**细节**面板的**子弹**类别中，找到**子弹类**属性；从下拉菜单中选择**BP_GunBullet**。
- en: Now that we’ve got our character all primed and ready, it’s time to unleash
    its shooting prowess at our command!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将角色调整得完美无缺，是时候让它在我们指挥下展示其射击能力了！
- en: Making the weapon shoot
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使武器射击
- en: To make the shooting phase work properly, we will be using **Anim Notify** –
    an event that can be synchronized with animation sequences – so that we can call
    the **Shoot()** function at a specific point along the animation timeline.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使射击阶段正常工作，我们将使用**动画通知**——一个可以与动画序列同步的事件——这样我们就可以在动画时间轴的特定点调用**Shoot()**函数。
- en: Note
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You might be curious about why we’re implementing this particular system instead
    of directly calling the **Shoot()** function from any part of our code. Well,
    here’s the thing: the shoot animation has a duration, and the moment when the
    bullet should be spawned occurs somewhere within the animation. This is where
    an Anim Notify comes into play. By using **Anim Notify** , we can specify the
    exact moment within the animation when the bullet should be spawned.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能好奇为什么我们要实现这个特定的系统，而不是直接从代码的任何部分调用**Shoot()**函数。好吧，是这样的：射击动画有一个持续时间，子弹应该生成的时刻就在动画的某个地方。这就是动画通知发挥作用的地方。通过使用**动画通知**，我们可以在动画中指定子弹应该生成的确切时刻。
- en: 'An Anim Notify is created by extending the **AnimNotify** class, so start by
    creating a new C++ class that extends **AnimNotify** and call it **AnimNotify_Shoot**
    . Once the files have been created, open the **AnimNotify_Shoot.h** header file
    and, as a first step, change the **UCLASS()** macro declaration to the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展**AnimNotify**类创建动画通知，所以首先创建一个新的C++类，扩展**AnimNotify**，并将其命名为**AnimNotify_Shoot**。一旦创建了文件，打开**AnimNotify_Shoot.h**头文件，作为第一步，将**UCLASS()**宏声明更改为以下内容：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Without delving too deeply into the specifics, it is sufficient to say that
    these initialization settings are necessary for the class to function correctly.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入具体细节，只需说这些初始化设置对于类正确运行是必要的。
- en: 'After that, add the following **public** declarations to the class:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，将以下**public**声明添加到类中：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The **UAnimNotify_Shoot()** declaration is the constructor, which is quite self-explanatory,
    while the **Notify()** declaration will be called when an Anim Notify is triggered.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**UAnimNotify_Shoot()**声明是构造函数，相当直观，而**Notify()**声明将在动画通知被触发时调用。'
- en: 'Now, open the **AnimNotify_Shoot.cpp** file and add the needed **#include**
    declarations at its top:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开**AnimNotify_Shoot.cpp**文件，并在其顶部添加所需的**#include**声明：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After that, add the constructor implementation:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加构造函数实现：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: While not mandatory, this function allows you to customize the color of the
    notify label within the Unreal Engine Editor. It’s quite handy, isn’t it?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是强制性的，但这个功能允许你在虚幻引擎编辑器中自定义通知标签的颜色。这非常方便，不是吗？
- en: 'On the other hand, the **Notify()** function holds significant importance for
    gameplay-related reasons, so add the following lines of code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**Notify()**函数对于游戏玩法相关的理由具有重要意义，因此添加以下代码行：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This function looks for a **BaseWeaponComponent** instance, if any, and calls
    the **Shoot()** function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会查找**BaseWeaponComponent**实例（如果有的话），并调用**Shoot()**函数。
- en: Before adding this Anim Notify to the shoot animation, you will need to compile
    your project. Once the new class is available, look for the **AM_1H_Shoot** montage,
    which can be found in the **Content/KayKit/PrototypeBits/Character/Animations**
    folder.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在将此动画通知添加到射击动画之前，你需要编译你的项目。一旦新的类可用，查找位于**Content/KayKit/PrototypeBits/Character/Animations**文件夹中的**AM_1H_Shoot**蒙太奇。
- en: Note
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In Unreal Engine, a **montage** refers to a specialized asset that allows you
    to create complex animations for characters or objects. Montages are commonly
    used for defining sequences of related animation. As montages are not part of
    this book’s focus, I have provided the needed ones for you.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，**montage**指的是一种专门资产，允许你为角色或对象创建复杂的动画。蒙太奇通常用于定义相关动画序列。由于蒙太奇不是本书的重点，我已经为你提供了所需的蒙太奇。
- en: Once you have opened the asset by double-clicking on it, you will notice that,
    in the asset timeline, there is a **ShootNotify_C** label; this is an empty placeholder
    I have provided for you to let you know where the notify should be placed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你通过双击打开资产，你将注意到在资产时间轴中有一个**ShootNotify_C**标签；这是一个空占位符，我为你提供，以便让你知道通知应该放置的位置。
- en: '![Figure 9.6 – Animation montage](img/B31016_figure_09.06.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – Animation montage](img/B31016_figure_09.06.jpg)'
- en: Figure 9.6 – Animation montage
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 动画蒙太奇
- en: Right-click on that label and select **Replace** with **Notify** | **Shoot**
    to add an **AnimNotify_Shoot** instance.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击该标签，选择**Replace** with **Notify** | **Shoot**以添加**AnimNotify_Shoot**实例。
- en: '![Figure 9.7 – Shoot notify](img/B31016_figure_09.07.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – Shoot notify](img/B31016_figure_09.07.jpg)'
- en: Figure 9.7 – Shoot notify
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – Shoot notify
- en: 'Now, whenever your AI agent plays this montage, it will get a notification
    from the montage itself that will call the **Shoot()** function. Later in this
    chapter, we will be creating a dedicated task for our AI agent behavior tree,
    in order to play the montage but, if you want to test things out, you can simply
    use the **Play Montage** node in the Event Graph of **BP_GunnerDummyCharacter**
    , as shown in *Figure 9* *.8* :'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论你的AI代理何时播放这个蒙太奇，它都会从蒙太奇本身收到通知，调用**Shoot()**函数。在本章的后面部分，我们将为我们的AI代理行为树创建一个专用任务，以便播放蒙太奇，但如果你想测试一下，你可以简单地使用**BP_GunnerDummyCharacter**的事件图中的**Play
    Montage**节点，如图*图9* *.8* 所示：
- en: '![Figure 9.8 – Montage test](img/B31016_figure_09.08.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图9.8 – Montage test](img/B31016_figure_09.08.jpg)'
- en: Figure 9.8 – Montage test
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – Montage test
- en: Just ensure to remove this node after completing your testing to prevent your
    AI agent from exhibiting seemingly erratic behaviors.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在测试完成后删除此节点，以防止你的AI代理表现出看似混乱的行为。
- en: In this section, I have provided insights on enhancing AI agents and behavior
    trees through best practices and tips from my own experience. Following that,
    we established the foundation for a more advanced AI agent capable of shooting.
    The upcoming section will focus on developing a custom decorator, adding a new
    layer of complexity to our project. Exciting developments lie ahead for our endeavor!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我提供了一些关于通过最佳实践和我的个人经验来增强AI代理和行为树的见解。在此之后，我们为能够射击的更高级AI代理奠定了基础。接下来的章节将专注于开发自定义修饰器，为我们的项目增加一层复杂性。我们的事业即将迎来令人兴奋的发展！
- en: Understanding decorators
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解修饰器
- en: Decorators provide a way to add additional functionality or conditions to the
    execution of a portion of a behavior tree. As you already know from previous chapters,
    decorators are attached to either a composite or a task node and determine whether
    a branch in the tree (or even a single node) can be executed. By combining decorators
    with composite nodes, you can create behavior trees with prioritized behavior
    allowing for powerful logic capable of handling intricate scenarios. In [*Chapter
    8*](B31016_08.xhtml#_idTextAnchor148) , *Setting Up a Behavior Tree* , we used
    some built-in decorators but, in this section, I will give you more detailed information
    about creating your own custom decorators.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰器提供了一种向行为树的一部分执行添加额外功能或条件的方法。正如你从之前的章节中已经知道的那样，修饰器附加到组合节点或任务节点上，并确定树中的分支（甚至单个节点）是否可以执行。通过将修饰器与组合节点结合使用，你可以创建具有优先行为的行为树，允许处理复杂场景的强大逻辑。在[*第8章*](B31016_08.xhtml#_idTextAnchor148)，“设置行为树”中，我们使用了一些内置修饰器，但在本节中，我将为你提供更多关于创建自己的自定义修饰器的详细信息。
- en: Explaining the BTAuxiliaryNode class
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释BTAuxiliaryNode类
- en: 'Both decorators and services inherit from the **BTAuxiliaryNode** class, which
    will let you implement the following functions:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰器和服务都继承自**BTAuxiliaryNode**类，这将允许你实现以下功能：
- en: '**OnBecomeRelevant()** : This will be called when the auxiliary node – the
    one the decorator or service is attached to – becomes active'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OnBecomeRelevant()**：当辅助节点（装饰器或服务附加到的节点）变为活动时将被调用'
- en: '**OnCeaseRelevant()** : This will be executed when the auxiliary node becomes
    inactive'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OnCeaseRelevant()**：当辅助节点变为不活动时将执行'
- en: '**TickNode()** : This will be executed at each auxiliary node tick'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TickNode()**：这将在每个辅助节点计时器执行时执行'
- en: In [*Chapter 8*](B31016_08.xhtml#_idTextAnchor148) , *Setting Up a Behavior
    Tree* , I presented you with some of these functions, so it’s good to know where
    they come from.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B31016_08.xhtml#_idTextAnchor148)，“设置行为树”中，我向你介绍了一些这些函数，所以了解它们的来源是很好的。
- en: Creating C++ decorators
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建C++修饰器
- en: 'A decorator extends from the **BTDecorator** class, and in C++, its main implementable
    functions are as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器从**BTDecorator**类扩展，在C++中，其主要可实现的函数如下：
- en: '**OnNodeActivation()** : This is called when the underlying node is activated'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OnNodeActivation()**：当底层节点被激活时调用此函数'
- en: '**OnNodeDeactivation()** : This is called when the underlying node is deactivated'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OnNodeDeactivation()**：当底层节点被停用时调用此函数'
- en: '**OnNodeProcessed()** : This is called when the underlying node is deactivated
    or fails to activate'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OnNodeProcessed()**：当底层节点被停用或未能激活时调用此函数'
- en: '**CalculateRawConditionalValue()** : This computes the value of the decorator
    condition without considering the inverse condition'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CalculateRawConditionalValue()**：计算装饰器条件值，不考虑逆条件'
- en: Additionally, you can use the **IsInversed()** function to check whether the
    decorator will handle the inversed conditional value.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以使用**IsInversed()**函数来检查装饰器是否会处理逆条件值。
- en: Creating Blueprint decorators
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建蓝图装饰器
- en: 'Whenever creating a decorator with Blueprints Visual Scripting, you should
    extend from the **BTDecorator_BlueprintBase** class, which includes some additional
    code logic and events, in order to better manage it. You can create a decorator
    in the usual way – from **Content Drawer** – or you can select the **New Decorator**
    button from the behavior tree graph, as shown in *Figure 9* *.9* :'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 每次使用蓝图可视化脚本创建装饰器时，您应该从**BTDecorator_BlueprintBase**类扩展，它包含一些额外的代码逻辑和事件，以便更好地管理它。您可以通过通常的方式创建装饰器
    – 从**内容抽屉** – 或者您可以从行为树图中选择**新装饰器**按钮，如图 9.9* 所示：
- en: '![Figure 9.9 – Decorator creation](img/B31016_figure_09.09.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 创建装饰器](img/B31016_figure_09.09.jpg)'
- en: Figure 9.9 – Decorator creation
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 创建装饰器
- en: 'The main events you will have at your disposal when working with Blueprint-generated
    decorators are as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用由蓝图生成的装饰器工作时，您将可用的主要事件如下：
- en: '**Receive Execution Start AI** : This is called when the underlying node is
    activated'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Receive Execution Start AI**：当底层节点被激活时调用此函数'
- en: '**Receive Execution Finish AI** : This is called when the underlying node has
    finished executing its logic'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Receive Execution Finish AI**：当底层节点完成执行其逻辑时调用此函数'
- en: '**Receive Tick AI** : This is called on each tick'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Receive Tick AI**：在每次tick时调用此函数'
- en: '![Figure 9.10 – Decorator nodes](img/B31016_figure_09.10.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.10 – 装饰器节点](img/B31016_figure_09.10.jpg)'
- en: Figure 9.10 – Decorator nodes
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – 装饰器节点
- en: By keeping this in mind, you will have the ability to implement your own Blueprint
    decorators for your AI agents.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过记住这一点，您将能够为您的AI代理实现自己的蓝图装饰器。
- en: We are now going to implement our own decorator, one that will be checking a
    tag on an actor.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现我们自己的装饰器，一个将检查演员上的标签的装饰器。
- en: Implementing the CheckTagOnActor decorator
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现检查演员标签的装饰器
- en: Now is the perfect time to create our first decorator. As you may recall, while
    implementing the **BaseTarget** class, we ensured that whenever a target gets
    hit, its tag is set to an undefined value. By implementing a decorator that checks
    an actor instance tag, we can determine whether the actor itself is a viable target.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是创建我们第一个装饰器的最佳时机。如您所回忆的那样，在实现**BaseTarget**类时，我们确保每当目标被击中时，其标签被设置为未定义值。通过实现一个检查演员实例标签的装饰器，我们可以确定演员本身是否是一个可行的目标。
- en: 'So, let’s start by creating a new C++ class extending **BTDecorator** , and
    let’s call it **BTDecorator_CheckTagOnActor** . Once the class has been created,
    open the **BTDecorator_CheckTagOnActor.h** file and add the following declarations:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们先创建一个新的从**BTDecorator**扩展的C++类，并将其命名为**BTDecorator_CheckTagOnActor**。一旦创建了类，打开**BTDecorator_CheckTagOnActor.h**文件并添加以下声明：
- en: '[PRE23]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, we will be using a Blackboard key value – the **ActorToCheck**
    one – to check whether its referred value has a tag equal to **TagName** . This
    check will be handled by the **CalculateRawConditionValue()** function. Additionally,
    we will need to initialize any asset-related data, and this is usually done in
    the **InitializeFromAsset()** function, which is inherited by the **BTNode** superclass.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们将使用一个黑板键值 – **ActorToCheck** – 来检查其引用的值是否具有等于**TagName**的标签。这个检查将由**CalculateRawConditionValue()**函数处理。此外，我们还需要初始化任何与资产相关的数据，这通常在继承自**BTNode**超类的**InitializeFromAsset()**函数中完成。
- en: 'Now, open the **BTDecorator_CheckTagOnActor.cpp** file to start implementing
    the functions. Let’s start by adding the needed **#** **include** files:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开**BTDecorator_CheckTagOnActor.cpp**文件以开始实现函数。让我们先添加所需的**#** **include**文件：
- en: '[PRE24]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, let’s implement the constructor:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实现构造函数：
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: What we are doing here, immediately after naming the node, holds significant
    importance. We are filtering key values to only allow **Actor** classes. This
    step ensures that only valid Blackboard keys related to actors will be accepted,
    maintaining the integrity and appropriateness of the inputs.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的事情，即在命名节点之后，具有重大意义。我们正在过滤键值，仅允许 **Actor** 类。这一步骤确保只有与演员相关的有效黑板键将被接受，保持输入的完整性和适当性。
- en: 'The **CalculateRawConditionValue()** function is going to be pretty straightforward:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**CalculateRawConditionValue()** 函数将会相当直接：'
- en: '[PRE26]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, we retrieve the Blackboard component and get the **ActorToCheck**
    key in order to check whether there is a valid **Actor** instance and whether
    it is tagged as a target.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们检索了黑板组件，并获取了 **ActorToCheck** 键，以检查是否存在有效的 **Actor** 实例，以及它是否被标记为目标。
- en: 'Now, implement the last required function:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，实现最后一个必需的函数：
- en: '[PRE27]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This function retrieves the **BlackboardData** asset and resolves the selected
    key for **ActorToCheck** from that asset.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数检索 **BlackboardData** 资产，并从该资产中解析出 **ActorToCheck** 的选定键。
- en: In this section, you have been provided with more advanced information about
    decorators, including specific considerations for implementing them in C++ or
    Blueprints. Additionally, you have successfully created a custom decorator that
    will be utilized by our upcoming gunner AI agent. This custom decorator will play
    a crucial role in creating the behavior and decision-making capabilities of the
    AI gunner agent, further improving its performance and effectiveness.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您已经获得了有关装饰器的更高级信息，包括在 C++ 或蓝图中实现时的具体考虑。此外，您已成功创建了一个自定义装饰器，该装饰器将被我们即将推出的枪炮
    AI 代理使用。这个自定义装饰器将在创建 AI 枪炮代理的行为和决策能力中发挥关键作用，进一步提高其性能和有效性。
- en: In the next section, I will be presenting you with some detailed information
    on how to implement services.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将向您展示有关如何实现服务的详细信息。
- en: Understanding services
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解服务
- en: Since you are already acquainted with services from previous chapters, I will
    now provide you with additional information to further enrich your understanding
    of this topic. Let’s explore these details to enhance your expertise in services
    within behavior trees.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您已经熟悉了前几章中的服务，我现在将为您提供更多相关信息，以进一步丰富您对该主题的理解。让我们探讨这些细节，以增强您在行为树中关于服务的专业知识。
- en: Creating C++ services
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 C++ 服务
- en: A service extends from the **BTService** class, and its main implementable function
    is **OnSearchStart()** , which is executed when the behavior tree search enters
    the underlying branch. You can use this to create some kind of initialization
    if needed.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 服务扩展自 **BTService** 类，其主要可实现函数是 **OnSearchStart()**，它在行为树搜索进入底层分支时执行。您可以使用此功能在需要时创建某种初始化。
- en: Furthermore, it is important to remember that services extend the **BTAuxiliaryNode**
    class, thereby inheriting all of its functions. One particularly crucial function
    inherited by services is the **TickNode()** function, which plays a vital role
    in the implementation of services, as it governs the execution and periodic updating
    of the service node within the behavior tree.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，重要的是要记住，服务扩展了 **BTAuxiliaryNode** 类，从而继承其所有功能。服务继承的一个特别关键的功能是 **TickNode()**
    函数，它在服务的实现中起着至关重要的作用，因为它控制着行为树中服务节点的执行和定期更新。
- en: Creating Blueprint services
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建蓝图服务
- en: 'When creating a service using Blueprints Visual Scripting, it is advisable
    to extend from the **BTService_BlueprintBase** class as it provides additional
    code logic and events that facilitate better management of the service itself.
    Similar to decorators, there are two ways to create a service: the conventional
    method, which involves using **Content Drawer** , or selecting the **New Service**
    button directly from the behavior tree graph, as shown in *Figure 9* *.11* :'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用蓝图可视化脚本创建服务时，建议从 **BTService_BlueprintBase** 类扩展，因为它提供了额外的代码逻辑和事件，有助于更好地管理服务本身。类似于装饰器，创建服务有两种方式：传统方法，涉及使用
    **内容抽屉**，或者直接从行为树图中选择 **新建服务** 按钮，如图 *图 9* *.11* 所示：
- en: '![Figure 9.11 – Service creation](img/B31016_figure_09.11.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – 服务创建](img/B31016_figure_09.11.jpg)'
- en: Figure 9.11 – Service creation
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 服务创建
- en: 'The main events you will have at your disposal when working with Blueprint-generated
    services are as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用蓝图生成的服务时，您将可用的主要事件如下：
- en: '**Receive Activation AI** : This is called when the service becomes active'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收激活 AI**：当服务激活时被调用'
- en: '**Receive Deactivation AI** : This is called when the service becomes inactive'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收去激活 AI**：当服务变为非活动状态时被调用'
- en: '**Receive Search Start AI** : This is called when the behavior tree search
    enters the underlying branch'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收搜索开始 AI**：当行为树搜索进入底层分支时被调用'
- en: '**Receive Tick AI** : This is called on each tick'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收节拍 AI**：在每次节拍时被调用'
- en: '![Figure 9.12 – Service nodes](img/B31016_figure_09.12.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12 – 服务节点](img/B31016_figure_09.12.jpg)'
- en: Figure 9.12 – Service nodes
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – 服务节点
- en: With this in mind, you will have the ability to implement your own Blueprint
    services for your behavior trees.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，您将能够实现自己的蓝图服务以用于行为树。
- en: With this new knowledge at our disposal, let’s implement a new service that
    will let us handle the ammo state.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这些新知识，让我们实现一个新的服务，它将允许我们处理弹药状态。
- en: Implementing the SetAmmo service
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现设置弹药服务
- en: We are now ready to start implementing our own service; you already have created
    a couple of them in [*Chapter 8*](B31016_08.xhtml#_idTextAnchor148) , *Setting
    Up a Behavior Tree* , so you should be already familiar with some of the presented
    steps.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好开始实现自己的服务；您已经在 [*第 8 章*](B31016_08.xhtml#_idTextAnchor148) *设置行为树* 中创建了一些服务，因此您应该已经熟悉一些展示的步骤。
- en: 'In this case, we will need a service that will allow us to tell the Blackboard
    when a weapon has fired – and so needs reloading – or is ready to shoot. As usual,
    let’s start by creating a new C++ class extending from **BT_Service** and call
    it **BTService_SetAmmo** . Once it has been created, open the **BTService_SetAmmo.h**
    file and add the following declarations:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要一个服务，它将允许我们告诉黑板何时武器已发射——因此需要重新装填——或者何时准备射击。像往常一样，让我们先创建一个新的从 **BT_Service**
    继承的 C++ 类，并将其命名为 **BTService_SetAmmo**。一旦创建完成，打开 **BTService_SetAmmo.h** 文件，并添加以下声明：
- en: '[PRE28]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You should already be familiar with most of the code here; let’s just say that
    we will be using a **NeedsReload** Blackboard key as a **bool** value to see whether
    the weapon ammo is depleted or not. Now, open the **BTService_SetAmmo.cpp** file
    and add the following **#include** declaration at the top of it:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该已经熟悉这里的大多数代码；让我们只说我们将使用一个 **NeedsReload** 黑板键作为 **bool** 值来查看武器弹药是否耗尽。现在，打开
    **BTService_SetAmmo.cpp** 文件，并在顶部添加以下 **#include** 声明：
- en: '[PRE29]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The constructor is going to be pretty straightforward as we want the service
    tick to be disabled and we want to execute it just when it becomes relevant:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将非常直接，因为我们希望服务节拍被禁用，并且我们只想在它变得相关时执行它：
- en: '[PRE30]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The **OnBecomeRelevant()** function will serve us just to set the Blackboard
    key value:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**OnBecomeRelevant()** 函数将为我们设置黑板键值：'
- en: '[PRE31]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this section, you have been provided with additional information about services,
    including specific considerations for implementing them in C++ or Blueprints.
    Additionally, you have successfully created another custom service that will be
    used to handle your AI agent’s gun ammo.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您已经获得了有关服务的额外信息，包括在 C++ 或蓝图实现时的具体考虑。此外，您已成功创建了一个自定义服务，该服务将用于处理您的 AI 代理的枪械弹药。
- en: In the next section, I will be presenting you with detailed information on how
    to implement tasks as we will be creating a couple more for our soon-to-be gunner
    agent.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将向您提供有关如何实现任务的详细信息，因为我们将为即将到来的枪手代理创建更多任务。
- en: Understanding tasks
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解任务
- en: In this section, I will provide you with additional information to enhance your
    understanding of tasks. Let’s explore these details together to further strengthen
    your grasp of tasks within the context of behavior trees.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将提供额外信息以增强您对任务的理解。让我们一起探讨这些细节，以进一步巩固您对行为树中任务的理解。
- en: Creating C++ tasks
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 C++ 任务
- en: 'A task extends from the **BTTask** class, and its main implementable functions
    are as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 任务从 **BTTask** 类扩展，其主要可实现的函数如下：
- en: '**ExecuteTask()** : This will start the task execution and will return the
    task result'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ExecuteTask()**：这将启动任务执行并返回任务结果'
- en: '**AbortTask()** : This will let you handle events where a task should be stopped'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AbortTask()**：这将让您处理应该停止任务的事件'
- en: This is usually all you need to create even a simple yet fully working task.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常就足够创建一个简单但功能齐全的任务。
- en: Creating Blueprint tasks
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建蓝图任务
- en: 'When creating a task using Blueprints Visual Scripting, you will be extending
    from the **BTTask_BlueprintBase** class as it provides additional code logic to
    facilitate its implementation. As you may have guessed, there are two ways to
    create a task: the usual creation from **Content Drawer** , and the **New Task**
    selection button directly from the behavior tree graph, as shown in *Figure 9*
    *.13* :'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用蓝图视觉脚本创建任务时，你将扩展**BTTask_BlueprintBase**类，因为它提供了额外的代码逻辑以方便其实现。正如你可能已经猜到的，有两种创建任务的方式：从**内容抽屉**的常规创建，以及从行为树图直接选择**新任务**按钮，如图*图9*.*13*所示：
- en: '![Figure 9.13 – Task creation](img/B31016_figure_09.13.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图9.13 – 任务创建](img/B31016_figure_09.13.jpg)'
- en: Figure 9.13 – Task creation
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 – 任务创建
- en: 'The main events you will have available when working with Blueprint-generated
    tasks are as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用蓝图生成的任务工作时，你将可用的主要事件如下：
- en: '**Receive Execute AI** : This is called when the task is executed'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收执行AI**：当任务执行时调用'
- en: '**Receive Abort AI** : This is called when the task is aborted'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收中止AI**：当任务被中止时调用'
- en: '**Receive Tick AI** : This is called on each tick'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收每帧AI**：在每一帧调用'
- en: '![Figure 9.14 – Task nodes](img/B31016_figure_09.14.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图9.14 – 任务节点](img/B31016_figure_09.14.jpg)'
- en: Figure 9.14 – Task nodes
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 – 任务节点
- en: Keeping this in mind, you will possess the capability to implement your own
    Blueprint tasks for your behavior trees, and that’s exactly what we are going
    to do in the next steps.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这一点，你将具备为你的行为树实现自己的蓝图任务的能力，这正是我们在接下来的步骤中将要做的。
- en: Implementing the PlayMontage task
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现PlayMontage任务
- en: 'As you already know, the shooting command for our AI agent is going to be controlled
    by an Anim Notify from an animation montage. Unfortunately, there is no out-of-the-box
    task for executing montages from a behavior tree; a **PlayAnimation** task is
    present, but it will not serve our purposes as it won’t handle montages really
    well. Fortunately, with our existing strong understanding of tasks, implementing
    the code logic will be relatively straightforward. Furthermore, having a task
    that plays montages will prove highly beneficial when handling other animation
    sequences, such as reloading bullets or celebrating when all targets have been
    successfully hit. So, start by creating a new C++ class that extends **BTTask**
    and call it **BTTask_PlayMontage** . Inside the **BTTask_PlayMontage.h** file,
    add the following self-explanatory declarations:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，我们AI代理的射击命令将由动画蒙太奇中的动画通知控制。不幸的是，没有现成的从行为树执行蒙太奇的任务；存在一个**PlayAnimation**任务，但它不会很好地处理蒙太奇，所以它不能满足我们的需求。幸运的是，由于我们对任务有现有的深入了解，实现代码逻辑将相对简单。此外，拥有一个可以播放蒙太奇的任务，在处理其他动画序列时将非常有用，例如装弹或当所有目标都被成功击中时的庆祝。因此，首先创建一个新的C++类，扩展**BTTask**，并将其命名为**BTTask_PlayMontage**。在**BTTask_PlayMontage.h**文件中，添加以下自解释声明：
- en: '[PRE32]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Inside the **BTTask_PlayMontage.cpp** file, add the following implementation:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在**BTTask_PlayMontage.cpp**文件中，添加以下实现：
- en: '[PRE33]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This function simply executes the **PlayAnimMontage()** function on the character,
    returning a **Succeeded** result. If any of the needed references are not found,
    a **Failed** result is returned.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数简单地执行角色上的**PlayAnimMontage()**函数，并返回**成功**的结果。如果找不到任何所需的引用，则返回**失败**的结果。
- en: With this task ready to go, we can implement a second one, the last one we will
    be needing in this chapter.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务准备好之后，我们可以实现第二个任务，这是本章我们将需要的最后一个任务。
- en: Implementing the FindAvailableTarget task
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现FindAvailableTarget任务
- en: 'This task will have the sole aim of finding an available target by checking
    all actors with a predefined tag. There is nothing fancy here, but we will be
    needing it, so create a new C++ class inheriting from **BBTask** and call it **BTTask_FindAvailableTarget**
    . In the **BTTask_FindAvailableTarget.h** header file, add the following declarations:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 此任务将只有一个目标，即通过检查所有具有预定义标记的演员来找到一个可用的目标。这里没有什么花哨的，但我们将会需要它，因此创建一个新的C++类，从**BBTask**继承，并将其命名为**BTTask_FindAvailableTarget**。在**BTTask_FindAvailableTarget.h**头文件中，添加以下声明：
- en: '[PRE34]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'No need to add explanations here, so let’s open the **BTTask_FindAvailableTarget.cpp**
    file and add the needed **#** **include** declarations:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这里不需要添加解释，让我们打开**BTTask_FindAvailableTarget.cpp**文件并添加所需的**#** **include**声明：
- en: '[PRE35]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The constructor is just going to filter the type entries for the **TargetValue**
    key:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将仅过滤**TargetValue**键的类型条目：
- en: '[PRE36]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The **ExecuteTask()** function will search through the level in order to find
    all **Actor** instances correctly tagged and return a random element from the
    list. Just add this piece of code:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**ExecuteTask()**函数将遍历层级以找到所有正确标记的**Actor**实例，并从列表中返回一个随机元素。只需添加以下代码：'
- en: '[PRE37]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, a **Succeeded** result is returned if at least one **Actor**
    instance has been found.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果至少找到一个**Actor**实例，将返回**成功**的结果。
- en: In this section, we took a brief look at some of the key features of tasks and
    even added a couple more to our arsenal. It seems like we are now well-prepared
    to embark on our journey with the gunner AI character. While we are discussing
    this topic, it’s a great opportunity to explain the proper techniques for debugging
    a behavior tree. So, let’s dive in and get started with it!
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要地查看了一些任务的关键特性，甚至在我们的工具库中添加了更多。现在，我们似乎已经为与枪手AI角色一起踏上旅程做好了充分的准备。在讨论这个话题的同时，这是一个很好的机会来解释调试行为树的正确技术。那么，让我们深入探讨并开始吧！
- en: Debugging behavior trees
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试行为树
- en: Debugging behavior trees with Unreal Engine is essential for ensuring the smooth
    and efficient functioning of your AI-driven games. By carefully examining and
    analyzing the behavior tree’s execution, you can identify and resolve any issues
    or glitches that may arise during gameplay. You already have some understanding
    of how to enable the debugging tools in Unreal Engine. In this section, we will
    take a deep dive into the debugging feature specifically designed for behavior
    trees; before starting with the debugging tools, we’ll need to create a proper
    – and moderately complex – behavior tree.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 使用虚幻引擎调试行为树对于确保你的AI驱动游戏平稳高效运行至关重要。通过仔细检查和分析行为树的执行情况，你可以识别并解决游戏过程中可能出现的任何问题或错误。你已经对如何在虚幻引擎中启用调试工具有所了解。在本节中，我们将深入探讨专为行为树设计的调试功能；在开始使用调试工具之前，我们需要创建一个适当且适度复杂的行为树。
- en: Creating the Blackboard
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建黑板
- en: 'The Blackboard for the behavior tree is going to be straightforward; we need
    a couple of keys to keep a reference of the target and a flag to check whether
    the weapon needs reloading. So, let’s start by doing the following:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树的黑板将会很简单；我们需要几个键来保持对目标的引用，以及一个标志来检查武器是否需要重新装填。因此，让我们先做以下操作：
- en: Open **Content Drawer** and create a Blackboard asset in the **Content/AI**
    folder.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**内容抽屉**并在**内容/AI**文件夹中创建一个黑板资产。
- en: Name the asset **BB_GunnerDummy** and open it.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将资产命名为**BB_GunnerDummy**并打开它。
- en: Create a new key of the **bool** type and name it **NeedsReload** .
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**bool**类型的键，并将其命名为**NeedsReload**。
- en: Create a new key of the **Object** type and call it **TargetActor** .
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**Object**类型的键，并将其命名为**TargetActor**。
- en: 'You may remember that while creating the **BTTask_FindAvailableTarget** class,
    we decided to filter this key so that it will accept only the **Actor** type and
    not a generic **Object** one; this means you will need to set the base class for
    this key to an **Actor** type. To do this, follow these steps:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，在创建**BTTask_FindAvailableTarget**类时，我们决定过滤这个键，使其只接受**Actor**类型而不是通用的**Object**类型；这意味着你需要将这个键的基类设置为**Actor**类型。为此，请按照以下步骤操作：
- en: Select the **TargetActor** key and, in the **Blackboard Details** panel, open
    the **Key Type** option to show the **Base** **Class** attribute.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**TargetActor**键，在**黑板详情**面板中打开**键类型**选项以显示**基** **类**属性。
- en: 'From the **Base Class** dropdown, select **Actor** , as shown in *Figure 9*
    *.15* :'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**基类**下拉菜单中选择**Actor**，如图*图9* *.15* 所示：
- en: '![Figure 9.15 – Target Actor key](img/B31016_figure_09.15.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图9.15 – 目标演员键](img/B31016_figure_09.15.jpg)'
- en: Figure 9.15 – Target Actor key
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15 – 目标演员键
- en: Creating the behavior tree
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建行为树
- en: 'The behavior tree we are going to implement is going to have the following
    logic:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的行为树将具有以下逻辑：
- en: If the AI character has a valid target, it will shoot at it and then reload
    the weapon
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果AI角色有一个有效的目标，它将射击该目标然后重新装填武器
- en: If no target is set, it will try to find one in the level and set the proper
    key
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有设置目标，它将尝试在当前层级中找到一个目标并设置正确的键
- en: If no target is available in the level, it means all targets have been hit and
    the AI character will cheer with happiness
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在层级中没有可用的目标，这意味着所有目标都已命中，AI角色将快乐地欢呼
- en: 'Start by doing the following:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 首先做以下操作：
- en: In the **Content/AI** folder, create a new **Behavior Tree** asset and call
    it **BT_GunnerDummy** .
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**内容/AI**文件夹中创建一个新的**行为树**资产，并将其命名为**BT_GunnerDummy**。
- en: In the **Details** panel, set the **Blackboard Asset** attribute to **BB_GunnerDummy**
    .
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**详细信息**面板中，将**黑板资产**属性设置为**BB_GunnerDummy**。
- en: 'Connect a **Selector** node to the **Root** node and call it **Root Selector**
    , as shown in *Figure 9* *.16* :'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个**选择器**节点连接到**根**节点，并将其命名为**根选择器**，如图*图9.16*所示*.16*：
- en: '![Figure 9.16 – The Root Selector node](img/B31016_figure_09.16.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图9.16 – 根选择器节点](img/B31016_figure_09.16.jpg)'
- en: Figure 9.16 – The Root Selector node
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16 – 根选择器节点
- en: As you may remember, a selector node will execute the subtrees in sequence until
    one of them succeeds; this is exactly what we need to do in order to create our
    gunner AI logic.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所记得，选择器节点将按顺序执行子树，直到其中一个成功；这正是我们需要做的，以便创建我们的枪手AI逻辑。
- en: Adding the shooting logic
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加射击逻辑
- en: 'The shooting logic is going to be subdivided into two phases – shooting and
    reloading – so we are going to use another selector node. Let’s do the following:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 射击逻辑将被细分为两个阶段 – 射击和装弹 – 因此我们将使用另一个选择器节点。让我们做以下操作：
- en: From **Root Selector** , add another selector node and name it **Shoot Selector**
    .
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**根选择器**中添加另一个选择器节点，并将其命名为**射击选择器**。
- en: Right-click on it, add a **CheckTagOnTarget** decorator, and name it **Is Actor**
    **a Target?** .
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击它，添加一个**检查目标上的标签**装饰器，并将其命名为**演员是否为目标？**。
- en: 'Select this decorator and, in the **Details** panel, do the following:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择此装饰器，在**详细信息**面板中执行以下操作：
- en: Set the **Actor to Check** attribute to **TargetActor**
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**要检查的演员**属性设置为**TargetActor**
- en: Set the **Tag Name** attribute to **ShootingTarget**
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**标签名称**属性设置为**ShootingTarget**
- en: 'Basically, this selector will be executed only if there is a valid target in
    the **TargetActor** key of the Blackboard; if not, **Root Selector** will try
    executing the next subtree available. We need now to create the actual shooting
    logic, so start doing the following steps:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这个选择器只有在黑板的**TargetActor**键中有一个有效的目标时才会执行；如果没有，**根选择器**将尝试执行下一个可用的子树。我们现在需要创建实际的射击逻辑，所以开始执行以下步骤：
- en: Add a sequence node to **Shoot Selector** and name it **Shoot Sequence** .
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**射击选择器**中添加一个序列节点，并将其命名为**射击序列**。
- en: Right-click on it, add a **Blackboard** decorator, and name it **Has Ammo?**
    .
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击它，添加一个**黑板**装饰器，并将其命名为**是否有弹药？**。
- en: 'Select the decorator and, in the **Details** panel, do the following:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择装饰器，在**详细信息**面板中执行以下操作：
- en: Set the **Notify Observers** attribute to **On** **Value Change**
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**通知观察者**属性设置为**On** **Value Change**
- en: Set the **Key Query** attribute to **Is** **Not Set**
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**键查询**属性设置为**Is** **Not Set**
- en: Set the **Blackboard Key** attribute to **NeedsReload**
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**黑板键**属性设置为**NeedsReload**
- en: 'This part of the tree will execute only when the **NeedsReload** key is set
    to **true** ; otherwise, it will try to execute the next subtree. This portion
    of the tree graph should look like the one depicted in *Figure 9* *.17* :'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这部分树将在**NeedsReload**键设置为**true**时执行；否则，它将尝试执行下一个子树。这部分树图应该看起来像*图9.17*中描述的那样：
- en: '![Figure 9.17 – Starting shoot sequence](img/B31016_figure_09.17.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图9.17 – 开始射击序列](img/B31016_figure_09.17.jpg)'
- en: Figure 9.17 – Starting shoot sequence
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17 – 开始射击序列
- en: 'Let’s add some nodes to **Shoot Sequence** :'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在**射击序列**中添加一些节点：
- en: Add a **Rotate to Face BBEntry** task and name it **Rotate** **Towards Target**
    .
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**旋转面向BBEntry**任务，并将其命名为**朝向目标旋转**。
- en: Select this node and, in the **Details** panel, set the **Blackboard Key** attribute
    to **TargetActor** .
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择此节点，并在**详细信息**面板中设置**黑板键**属性为**TargetActor**。
- en: From **Shoot Sequence** , add a **Play Montage** task and name it **Shoot Montage**
    . Make sure that this task is at the right of the **Rotate Towards Target** task.
    In the **Details** panel, set the **Anim Montage** attribute to **AM_1H_Shoot**
    .
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**射击序列**中添加一个**播放蒙太奇**任务，并将其命名为**射击蒙太奇**。确保这个任务位于**朝向目标旋转**任务的右侧。在**详细信息**面板中，将**动画蒙太奇**属性设置为**AM_1H_Shoot**。
- en: Right-click on this task node, add a **Set Ammo** service, and name it **Deplete
    Ammo** .
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击此任务节点，添加一个**设置弹药**服务，并将其命名为**耗尽弹药**。
- en: 'Select this service and do the following:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择此服务并执行以下操作：
- en: Set the **Needs Reload** attribute to **NeedsReload**
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**需要重新加载**属性设置为**NeedsReload**
- en: Check the **Key** **Value** attribute
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查**键****值**属性
- en: 'From **Shoot Sequence** , add a **Wait** node and make sure that this task
    is at the right of the **Shoot Montage** task. Select the **Wait** node and do
    the following:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**射击序列**中添加一个**等待**节点，并确保这个任务位于**射击蒙太奇**任务的右侧。选择**等待**节点并执行以下操作：
- en: Set the **Wait Time** attribute to **2.0**
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**等待时间**属性设置为**2.0**
- en: Set the **Random Deviation** attribute to **0.5**
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**随机偏差**属性设置为**0.5**
- en: 'This portion of the behavior tree can be seen in *Figure 9* *.18* :'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分行为树可以在*图9.18*中看到：
- en: '![Figure 9.18 – Finished shoot sequence](img/B31016_figure_09.18.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图9.18 – 完成的射击序列](img/B31016_figure_09.18.jpg)'
- en: Figure 9.18 – Finished shoot sequence
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18 – 完成的射击序列
- en: One of the great things about behavior trees is that when you give descriptive
    names to your nodes, you can quickly understand what’s happening at a glance.
    By naming your nodes in a way that accurately reflects their purpose or function,
    you create a clear and intuitive visual representation of your AI.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树的一个优点是，当你给你的节点命名描述性名称时，你可以迅速地一眼看出正在发生什么。通过以准确反映其目的或功能的方式命名你的节点，你创建了一个清晰直观的AI视觉表示。
- en: 'We can now start creating the reload sequence for the gun. Let’s start by following
    these steps:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始创建枪的重新装填序列。让我们先按照以下步骤操作：
- en: From **Shoot Selector** , add a new sequence node to the right of **Shoot Sequence**
    and name it **Reload Sequence** .
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**射击选择器**，在**射击序列**右侧添加一个新的序列节点，并将其命名为**重新装填序列**。
- en: From **Reload Sequence** , add a **Play Montage** task and name it **Reload
    Montage** . In the **Details** panel, set the **Anim Montage** attribute to **AM_1H_Reload**
    .
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**重新装填序列**，添加一个**播放剪辑**任务并将其命名为**重新装填剪辑**。在**详细信息**面板中，将**动画剪辑**属性设置为**AM_1H_Reload**。
- en: Right-click on this task node, add a **Set Ammo** service, and name it **Refill
    Ammo** .
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击此任务节点，添加一个**设置弹药**服务，并将其命名为**补充弹药**。
- en: 'Select this service and do the following:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择此服务并执行以下操作：
- en: Set the **Needs Reload** attribute to **NeedsReload**
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**需要重新装填**属性设置为**NeedsReload**
- en: Leave the **Key Value** attribute unchecked
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持**键值**属性未勾选
- en: 'From **Reload Sequence** , add a **Wait** node and make sure that this task
    is at the right of the **Reload Montage** task. Select the **Wait** node and do
    the following:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**重新装填序列**，添加一个**等待**节点，并确保此任务位于**重新装填剪辑**任务右侧。选择**等待**节点并执行以下操作：
- en: Set the **Wait Time** attribute to **3.0** .
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**等待时间**属性设置为**3.0**。
- en: 'Set the **Random Deviation** attribute to **0.5** . This portion of the behavior
    tree can be seen in *Figure 9.19* :'
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**随机偏差**属性设置为**0.5**。这部分行为树可以在*图9.19*中看到：
- en: '![Figure 9.19 – Reload sequence](img/B31016_figure_09.19.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![图9.19 – 重新装填序列](img/B31016_figure_09.19.jpg)'
- en: Figure 9.19 – Reload sequence
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19 – 重新装填序列
- en: Whenever we enter this portion of the tree, start the reload animation while
    setting the **NeedsReload** key to **false** , and we wait a bit before going
    on with the execution. With this portion of the behavior tree complete, we can
    implement the target search portion.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们进入树的这部分时，将**需要重新装填**键设置为**false**，然后我们稍等片刻再继续执行。完成这部分行为树后，我们可以实现目标搜索部分。
- en: Finding an available target
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找可用目标
- en: 'Whenever there is no available target to shoot at, **Root Selector** will execute
    the next subtree; in this case, we will be looking for a new viable target. To
    do this, follow these steps:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 每当没有可射击的目标时，**根选择器**将执行下一个子树；在这种情况下，我们将寻找一个新的可行目标。为此，请按照以下步骤操作：
- en: From **Root Selector** , add a **FindAvailableTarget** task at the right of
    the **Shoot** **Selector** node.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**根选择器**，在**射击选择器**节点右侧添加一个**FindAvailableTarget**任务。
- en: 'Select the task and do the following:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择任务并执行以下操作：
- en: Set the **Target Actor** attribute to **TargetActor**
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**目标演员**属性设置为**TargetActor**
- en: Set the **Target Tag** attribute to **ShootingTarget**
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**目标标签**属性设置为**ShootingTarget**
- en: '*Figure 9* *.20* shows this portion of the behavior tree:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.20*显示了这部分行为树：'
- en: '![Figure 9.20 – Find target task](img/B31016_figure_09.20.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![图9.20 – 查找目标任务](img/B31016_figure_09.20.jpg)'
- en: Figure 9.20 – Find target task
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20 – 查找目标任务
- en: It’s now time to add the third and last part of the behavior tree logic.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候添加行为树逻辑的第三和最后一部分了。
- en: Finishing the AI logic
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完成AI逻辑
- en: 'The last portion of the code will be to make the AI character cheer when all
    targets have been hit. To do so, follow these steps:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后部分将是使AI角色在所有目标被击中时欢呼。为此，请按照以下步骤操作：
- en: From **Root Selector** , add a sequence node at the right of the **Find Available
    Target** task and name it **Cheer Sequence** .
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**根选择器**，在**查找可用目标**任务右侧添加一个序列节点，并将其命名为**欢呼序列**。
- en: From **Cheer Sequence** , add a **Play Montage** task and name it **Cheer Montage**
    . In the **Details** panel, set the **Anim Montage** attribute to **AM_Cheer**
    .
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**欢呼序列**，添加一个**播放剪辑**任务并将其命名为**欢呼剪辑**。在**详细信息**面板中，将**动画剪辑**属性设置为**AM_Cheer**。
- en: 'From **Cheer Sequence** , add a **Wait** node and make sure that this task
    is at the right of the **Cheer Montage** task. Select the **Wait** node and do
    the following:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**欢呼序列**中添加一个**等待**节点，并确保这个任务位于**欢呼蒙太奇**任务的右侧。选择**等待**节点并执行以下操作：
- en: Set the **Wait Time** attribute to **3.0**
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**等待时间**属性设置为**3.0**
- en: Set the **Random Deviation** attribute to **0.5**
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**随机偏差**属性设置为**0.5**
- en: 'This part of the graph should look like *Figure 9* *.21* :'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图表的这部分应该看起来像*图 9* *.21*：
- en: '![Figure 9.21 – Cheer sequence](img/B31016_figure_09.21.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.21 – 欢呼序列](img/B31016_figure_09.21.jpg)'
- en: Figure 9.21 – Cheer sequence
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.21 – 欢呼序列
- en: Now that the behavior tree is finally complete, we can move forward by creating
    a dedicated AI controller.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在行为树终于完成了，我们可以通过创建一个专门的 AI 控制器来继续前进。
- en: Creating the AI controller
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 AI 控制器
- en: 'The AI controller is going to be pretty simple; you’ll just need to do the
    following:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: AI 控制器将会非常简单；你只需要做以下几步：
- en: Open **Content Drawer** and, in the **Content/Blueprints** folder, add a new
    Blueprint class extending **BaseDummyAIController** and name it **AIGunnerDummyController**
    .
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**内容抽屉**，在**内容/蓝图**文件夹中，添加一个新的蓝图类，扩展**BaseDummyAIController**，并将其命名为**AIGunnerDummyController**。
- en: Open it and, in the **Details** panel, locate the **Behavior Tree** property
    and set its value to **BT_GunnerDummy** .
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开它，在**详细信息**面板中，找到**行为树**属性并将其值设置为**BT_GunnerDummy**。
- en: Open **BP_GunnerDummyCharacter** and, in the **Details** panel, set the **AI
    Controller Class** attribute to **AIDummyGunnerController** .
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**BP_GunnerDummyCharacter**，在**详细信息**面板中，将**AI 控制器类**属性设置为**AIDummyGunnerController**。
- en: Now that we have the controller ready and the character all set up, it’s time
    to test and debug its behavior.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了控制器并且角色已经设置好，是时候测试和调试其行为。
- en: Debugging the behavior tree on a gym
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在健身房上调试行为树
- en: 'To start debugging the newly created behavior tree, let’s start by creating
    a new level. Let’s follow these steps:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始调试新创建的行为树，让我们先创建一个新的关卡。让我们按照以下步骤进行：
- en: Create a level of your choice, starting from the Level Instances and Packed
    Level Actors I provided in the project template.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个你选择的关卡，从我在项目模板中提供的关卡实例和打包关卡演员开始。
- en: Add a **BP_GunnerDummyCharacter** instance.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**BP_GunnerDummyCharacter**实例。
- en: 'Add one or more **BP_Target** instances so that your AI character will have
    a line of sight to them. My gym level is shown in *Figure 9* *.22* :'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个或多个**BP_Target**实例，以便你的 AI 角色能够看到它们。我的健身房关卡如图*图 9* *.22*所示：
- en: '![Figure 9.22 – Gym level](img/B31016_figure_09.22.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.22 – 健身房关卡](img/B31016_figure_09.22.jpg)'
- en: Figure 9.22 – Gym level
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.22 – 健身房关卡
- en: Once you test the level, the expected behavior is for the character to shoot
    at each target, reload after each shot, and cheer once all targets have been successfully
    hit.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦测试了关卡，预期的行为是角色向每个目标射击，每次射击后重新装填，并在所有目标成功命中后欢呼。
- en: Adding breakpoints
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加断点
- en: 'To test your behavior tree, you can open it up and start the level simulation;
    you will see the active part of the tree, with nodes highlighted in yellow, as
    shown in *Figure 9* *.23* :'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试你的行为树，你可以打开它并开始关卡模拟；你将看到树的活动部分，节点以黄色突出显示，如图*图 9* *.23*所示：
- en: '![Figure 9.23 – Testing the tree](img/B31016_figure_09.23.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.23 – 测试树](img/B31016_figure_09.23.jpg)'
- en: Figure 9.23 – Testing the tree
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.23 – 测试树
- en: 'Sometimes, portions of the graph will be executed really fast and you may not
    see whether a particular portion of the tree has been executed. To get a better
    understanding of what’s happening, you may add a breakpoint by right-clicking
    on a node and selecting **Add Breakpoint** , as shown in *Figure 9* *.24* :'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，图表的一部分会执行得非常快，你可能看不到树的一部分是否已经执行。为了更好地理解发生了什么，你可以在节点上右键单击并选择**添加断点**，如图*图
    9* *.24*所示：
- en: '![Figure 9.24 – Adding a breakpoint](img/B31016_figure_09.24.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.24 – 添加断点](img/B31016_figure_09.24.jpg)'
- en: Figure 9.24 – Adding a breakpoint
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.24 – 添加断点
- en: Note
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In Unreal Engine’s behavior tree, a **breakpoint** is a debugging feature that
    allows you to pause the execution of the behavior tree at a specific node. When
    the execution reaches the breakpoint, the behavior tree execution is temporarily
    halted, giving you the opportunity to inspect the state of the AI character and
    analyze the flow of the behavior tree. Execution can be resumed at any time to
    get on with the behavior tree execution.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎的行为树中，**断点**是一个调试功能，允许您在特定的节点处暂停行为树的执行。当执行达到断点时，行为树执行将暂时停止，给您提供检查AI角色状态和分析行为树流程的机会。执行可以在任何时候恢复，以继续行为树的执行。
- en: 'When the behavior tree is executed, it will pause at the breakpoint, providing
    a clear view of what is happening at that moment. By pausing the execution at
    specific breakpoints, you can gain valuable insights into the inner workings of
    the AI behavior and identify any issues or unexpected behaviors that need to be
    addressed. *Figure 9* *.25* shows a breakpoint positioned on the **Find Available
    Target** node, showing that the previous subtree failed while checking the **Is
    Actor a** **Target?** decorator:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 当行为树执行时，它将在断点处暂停，提供对该时刻发生情况的清晰视图。通过在特定的断点暂停执行，您可以获得关于AI行为内部运作的宝贵见解，并识别任何需要解决的问题或意外行为。*图
    9* *.25*显示了断点位于**查找可用目标**节点上，表明在检查**是否为** **目标**装饰器时，之前的子树失败了：
- en: '![Figure 9.25 – Active breakpoint](img/B31016_figure_09.25.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.25 – 激活断点](img/B31016_figure_09.25.jpg)'
- en: Figure 9.25 – Active breakpoint
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.25 – 激活断点
- en: Using the debugging tools
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用调试工具
- en: 'As you may recall from [*Chapter 6*](B31016_06.xhtml#_idTextAnchor116) , *Optimizing
    the Navigation System* , Unreal Engine offers a range of debugging tools for the
    AI system. Behavior trees are no exception, and once you enable these tools, you
    will have the ability to analyze the situation by pressing the number *2* on your
    keyboard’s numpad. This feature allows you to gain insights into the behavior
    of the AI character and evaluate the execution of the behavior tree in real time.
    In *Figure 9* *.26* , we can observe a specific situation where the behavior tree
    is displayed on the screen:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从[*第 6 章*](B31016_06.xhtml#_idTextAnchor116)，“优化导航系统”中回忆的那样，虚幻引擎为AI系统提供了一系列调试工具。行为树也不例外，一旦您启用这些工具，您就可以通过按键盘数字键盘上的数字
    *2* 来分析情况。此功能允许您深入了解AI角色的行为并实时评估行为树的执行情况。在*图 9* *.26*中，我们可以观察到行为树显示在屏幕上的特定情况：
- en: '![Figure 9.26 – Debugging tools](img/B31016_figure_09.26.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.26 – 调试工具](img/B31016_figure_09.26.jpg)'
- en: Figure 9.26 – Debugging tools
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.26 – 调试工具
- en: This visual representation provides a clear view of the structure and flow of
    the behavior tree, allowing us to analyze and understand its organization.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这种视觉表示提供了对行为树结构和流程的清晰视图，使我们能够分析和理解其组织结构。
- en: Summary
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this comprehensive chapter, I have provided you with additional information
    on creating more effective and efficient behavior trees. We began by discussing
    some best practices and then delved into the key features of decorators, services,
    and tasks. Furthermore, we explored the implementation of custom nodes tailored
    to specific requirements, culminating in the creation of a fully functional AI
    agent. To validate our work and take advantage of Unreal Engine’s robust debugging
    tools, we also developed a gym environment for thorough testing.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一全面章节中，我为您提供了有关创建更有效和高效行为树的信息。我们首先讨论了一些最佳实践，然后深入探讨了装饰器、服务和任务的关键特性。此外，我们探讨了针对特定要求的自定义节点的实现，最终创建了一个完全功能化的AI代理。为了验证我们的工作并利用虚幻引擎强大的调试工具，我们还开发了一个健身房环境进行彻底测试。
- en: Get ready for the next chapter because things are about to get even more packed
    with excitement! In this upcoming chapter, I’ll be unveiling the Unreal Perception
    System, where your AI agents will sharpen their senses and become more attentive
    than ever before!
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 准备进入下一章，因为接下来将会有更多的激动人心的内容！在即将到来的这一章中，我将揭晓虚幻感知系统，你的AI代理将提升他们的感官，比以往任何时候都要更加警觉！
