- en: '*Chapter 9*: Deploying Deep RL Agents on Multiple Platforms'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：在多个平台上部署深度强化学习代理'
- en: This chapter provides recipes to deploy your Deep RL agent models in applications
    targeting desktop, web, mobile, and beyond. The recipes serve as customizable
    templates that you can utilize to build and deploy your own Deep RL applications
    for your use cases. You will also learn how to export RL agent models for serving/deployment
    in various production-ready formats, such as **TensorFlow Lite**, **TensorFlow.js**,
    and **ONNX**, and learn how to leverage Nvidia **Triton** to launch production-ready
    RL-based AI services.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了将深度强化学习代理模型部署到桌面、Web、移动设备等应用中的教程。每个教程都是可定制的模板，你可以根据自己的用例构建和部署自己的深度强化学习应用。你还将学习如何导出强化学习代理模型，以便在各种生产环境中进行部署，支持的格式包括**TensorFlow
    Lite**、**TensorFlow.js**和**ONNX**，并了解如何利用 Nvidia **Triton** 启动生产就绪的基于强化学习的 AI
    服务。
- en: 'Specifically, the following recipes are covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下教程：
- en: Packaging Deep RL agents for mobile and IoT devices using TensorFlow Lite
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 TensorFlow Lite 打包深度强化学习代理以便在移动设备和物联网设备上部署
- en: Deploying RL agents on mobile devices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在移动设备上部署强化学习代理
- en: Packaging Deep RL agents for the web and Node.js using TensorFlow.js
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 TensorFlow.js 为 Web 和 Node.js 打包深度强化学习代理
- en: Deploying a Deep RL agent as a service
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将深度强化学习代理作为服务进行部署
- en: Packaging Deep RL agents for cross-platform deployments
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为跨平台部署打包深度强化学习代理
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code in the book is extensively tested on Ubuntu 18.04 and Ubuntu 20.04
    and should work with later versions of Ubuntu if Python 3.6+ is available. With
    Python 3.6+ installed along with the necessary Python packages, as listed before
    the start of each of the recipes, the code should run fine on Windows and Mac
    OSX too. It is advised to create and use a Python virtual environment named `tf2rl-cookbook`
    to install the packages and run the code in this book. Miniconda or Anaconda installation
    for Python virtual environment management is recommended.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 书中的代码在 Ubuntu 18.04 和 Ubuntu 20.04 上进行了广泛的测试，如果安装了 Python 3.6+，则应适用于更高版本的 Ubuntu。安装了
    Python 3.6+ 以及必要的 Python 包（这些包在每个教程开始前都会列出）后，代码也应能在 Windows 和 Mac OSX 上运行。建议创建并使用名为
    `tf2rl-cookbook` 的 Python 虚拟环境来安装包并运行本书中的代码。推荐使用 Miniconda 或 Anaconda 进行 Python
    虚拟环境管理。
- en: 'The complete code for each recipe in each chapter will be available here: [https://github.com/PacktPublishing/Tensorflow-2-Reinforcement-Learning-Cookbook](https://github.com/PacktPublishing/Tensorflow-2-Reinforcement-Learning-Cookbook).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每章中的完整代码可以在此处找到：[https://github.com/PacktPublishing/Tensorflow-2-Reinforcement-Learning-Cookbook](https://github.com/PacktPublishing/Tensorflow-2-Reinforcement-Learning-Cookbook)。
- en: Packaging Deep RL agents for mobile and IoT devices using TensorFlow Lite
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TensorFlow Lite 打包深度强化学习代理以便在移动设备和物联网设备上部署
- en: This recipe will show how you can leverage the open source **TensorFlow Lite**
    (**TFLite**) framework for serving your Deep RL agents on mobile, IoT, and embedded
    devices. We will implement a complete script to build, train, and export an agent
    model that you can load into a mobile or embedded device. We will explore two
    methods to generate the TFLite model for our agent. The first method involves
    saving and exporting the agent models in TensorFlow's SavedModel file format and
    then using a command-line converter. The second method leverages the Python API
    to directly generate the TFLite models.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将展示如何利用开源的**TensorFlow Lite**（**TFLite**）框架，在移动设备、物联网设备和嵌入式设备上部署深度强化学习代理。我们将实现一个完整的脚本，用于构建、训练和导出代理模型，你可以将其加载到移动设备或嵌入式设备中。我们将探索两种方法来生成
    TFLite 模型。第一种方法是将代理模型保存并导出为 TensorFlow 的 SavedModel 文件格式，然后使用命令行转换器。第二种方法是通过 Python
    API 直接生成 TFLite 模型。
- en: Let's get started!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To complete this recipe, you will first need to activate the `tf2rl-cookbook`
    Python/conda virtual environment. Make sure to update the environment to match
    the latest conda environment specification file (`tfrl-cookbook.yml`) in the cookbook''s
    code repo. If the following imports work without issues, you are ready to get
    started:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本教程，你需要首先激活 `tf2rl-cookbook` Python/conda 虚拟环境。确保更新环境以匹配最新的 conda 环境规范文件（`tfrl-cookbook.yml`），该文件位于本书代码库中。如果以下导入没有问题，那么你已经准备好开始了：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, let's begin!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始吧！
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In the following steps, we will save space by focusing on the new and important
    pieces that are unique to this recipe. We will go through the model saving and
    export functionality and the different ways you can do that and keep the Actor,
    Critic, and Agent model definitions out of the following steps to save space.
    Please refer to the book's code repository for a complete implementation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，为了节省空间，我们将重点介绍本食谱中特有的新功能。我们将展示模型保存和导出功能以及你可以采用的不同方式，并将`Actor`、`Critic`和`Agent`模型的定义从以下步骤中省略，以节省空间。完整实现请参考书籍的代码仓库。
- en: 'Let''s get started:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'First, it is important to set TensorFlow Keras''s backend to use `float32`
    as the default representation for float values instead of the default `float64`:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，重要的是将TensorFlow Keras的后端设置为使用`float32`作为浮动值的默认表示，而不是默认的`float64`：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, let''s create a handler for arguments passed to the script. We will also
    define a list of options for the training environments that can be chosen from
    for the `--env` flag:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们为传递给脚本的参数创建一个处理程序。我们还将为`--env`标志定义一个可供选择的训练环境选项列表：
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will add a few other arguments to ease the training and logging configuration
    of the agent:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加一些其他参数，以便简化代理的训练和日志配置：
- en: '[PRE3]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s also set up logging so that we can visualize the agent''s learning progress
    using TensorBoard:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也设置日志记录，这样我们就可以使用TensorBoard可视化代理的学习进度：
- en: '[PRE4]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For the first export approach, we will define save methods for the `Actor`,
    `Critic`, and `Agent` classes in the following steps. We will start with the implementation
    of the `save` method in the `Actor` class to export the Actor model to TensorFlow''s
    `SavedModel` format:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第一种导出方法，我们将在以下步骤中为`Actor`、`Critic`和`Agent`类定义保存方法。我们将从`Actor`类中的`save`方法的实现开始，将Actor模型导出为TensorFlow的`SavedModel`格式：
- en: '[PRE5]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Similarly, we will implement a `save` method for the `Critic` class to export
    the Critic model to TensorFlow''s `SavedModel` format:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们将为`Critic`类实现`save`方法，将Critic模型导出为TensorFlow的`SavedModel`格式：
- en: '[PRE6]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can now add a `save` method for the `Agent` class that will utilize the
    `Actor` and `Critic` `save` method to save both the models needed by the Agent:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以为`Agent`类添加一个`save`方法，该方法将利用`Actor`和`Critic`的`save`方法来保存Agent所需的两个模型：
- en: '[PRE7]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once the `save()` method is executed, it will generate two models (one for the
    Actor and one for the Critic) and save them in the specified directory on the
    filesystem with the directory structure and files similar to the one shown in
    the following figure:![Figure 9.1 – TensorFlow SavedModel directory structure
    and file contents for the PPO RL agent ](img/B15074_09_01.jpg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦执行了`save()`方法，它将生成两个模型（一个用于Actor，一个用于Critic），并将它们保存在文件系统中指定的目录里，目录结构和文件内容类似于下图所示：![图9.1
    – PPO RL代理的TensorFlow SavedModel目录结构和文件内容](img/B15074_09_01.jpg)
- en: Figure 9.1 – TensorFlow SavedModel directory structure and file contents for
    the PPO RL agent
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.1 – PPO RL代理的TensorFlow SavedModel目录结构和文件内容
- en: 'Once the `SavedModel` files are generated, we can use the `tflite_convert`
    command-line tool and specify the location of the Actor model''s save directory.
    Refer to the following command for an example:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦生成了`SavedModel`文件，我们可以使用`tflite_convert`命令行工具，并指定Actor模型保存目录的位置。参考以下命令的示例：
- en: '[PRE8]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Similarly, we can convert the Critic model using the following command:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，我们可以使用以下命令转换Critic模型：
- en: '[PRE9]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Hooray! We now have both the Actor and Critic models in TFLite format, which
    we can ship with our mobile applications. We will look at another approach that
    doesn't need us to (manually) switch to the command line to convert the model.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 万岁！现在我们有了TFLite格式的Actor和Critic模型，可以将它们与我们的移动应用一起发布。接下来，我们将看另一种方法，这种方法不需要我们（手动）切换到命令行来转换模型。
- en: 'There''s another approach to export the Agent model to the TFLite format. We
    will be implementing it in the following steps, starting with the `save_tflite`
    method for the `Actor` class:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有另一种方法可以将Agent模型导出为TFLite格式。我们将在以下步骤中实现这一方法，从`Actor`类的`save_tflite`方法开始：
- en: '[PRE10]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Similarly, we will implement the `save_tflite` method for the `Critic` class:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样地，我们将为`Critic`类实现`save_tflite`方法：
- en: '[PRE11]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The Agent''s class can then call the `save_tflite` method on the Actor and
    Critic using its own `save_tflite` method, as shown in the following code snippet:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，Agent类可以调用`save_tflite`方法，通过它自己的`save_tflite`方法，像以下代码片段所示那样调用Actor和Critic：
- en: '[PRE12]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that we added the `bin` directory of the current (`tfrl-cookbook`) Python
    environment to the system's `PATH` environment variable to make sure the `toco_from_protos`
    binary is found when the TFLite converter invokes the model conversion.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，我们将当前（`tfrl-cookbook`）Python环境的`bin`目录添加到了系统的`PATH`环境变量中，以确保TFLite转换器调用模型转换时能够找到`toco_from_protos`二进制文件。
- en: 'To sum up, we can finalize the `main` function to instantiate the agent and
    train and save the model in TFLite model file format:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总结一下，我们可以最终确定`main`函数，实例化代理，并训练和保存模型为TFLite模型文件格式：
- en: '[PRE13]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That completes our recipe. Let's recap with some important details to understand
    the recipe better.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们本次的示例。让我们回顾一下其中的一些重要细节，以便更好地理解这个示例。
- en: How it works...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We first set TensorFlow Keras's backend to use `float32` as the default representation
    for float values. This is because, otherwise, TensorFlow would use the default
    `float64` representation, which is not supported by TFLite (for performance reasons)
    as it is targeted towards running on embedded and mobile devices.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将TensorFlow Keras的后端设置为使用`float32`作为浮动值的默认表示。这是因为否则TensorFlow将使用默认的`float64`表示，而TFLite不支持这种表示（出于性能考虑），因为TFLite主要针对嵌入式和移动设备的运行。
- en: Then, we defined a list of choices for the `--env` argument. This is important
    to make sure that the environment's observation and action spaces are compatible
    with the agent's model. In this recipe, we used a PPO agent with Actor and Critic
    networks that expect image observations and produce actions in discrete space.
    You can swap the agent code with the PPO implementations from one of the earlier
    chapters that use different state/observation spaces and action spaces. You could
    also replace the agent with a different agent algorithm altogether. You will find
    a bonus recipe that exports a DDPG agent TFLite model in the book's code repository
    for this chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为`--env`参数定义了一个选择列表。这一点非常重要，以确保环境的观察和动作空间与代理模型兼容。在这个示例中，我们使用了一个PPO代理，配有Actor和Critic网络，期望图像观察并在离散空间中产生动作。你可以将代理代码替换为之前章节中的PPO实现，这些实现使用不同的状态/观察空间和动作空间。你还可以完全替换成其他代理算法。你将在本章的代码库中找到一个附加示例，它导出了一个DDPG代理的TFLite模型。
- en: 'We discussed two approaches to save and convert our Agent models to TFLite
    format. The first approach allowed us to generate a TensorFlow SavedModel file
    format first and then convert it to the TFLite model file format using the `tflite_convert`
    command-line tool. In the second approach, we used TFLite''s Python API to directly
    (in-memory) convert and save the agent''s models in TFLite (Flatbuffer) format.
    We made use of the `TFLiteConverter` module, which ships with the official TensorFlow
    2.x Python package. A summary of different ways to export the RL agent''s model
    using the API is provided in the following figure:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了两种保存并转换代理模型为TFLite格式的方法。第一种方法是先生成一个TensorFlow的SavedModel文件格式，然后使用`tflite_convert`命令行工具将其转换为TFLite模型文件格式。第二种方法，我们使用了TFLite的Python
    API，直接（在内存中）将代理的模型转换并保存为TFLite（Flatbuffer）格式。我们利用了官方TensorFlow 2.x Python包中的`TFLiteConverter`模块。下面的图示总结了通过API导出RL代理模型的不同方法：
- en: '![Figure 9.2 – Converting TensorFlow 2.x models to TensorFlow Lite Flatbuffer
    format ](img/B15074_09_02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 将TensorFlow 2.x模型转换为TensorFlow Lite Flatbuffer格式](img/B15074_09_02.jpg)'
- en: Figure 9.2 – Converting TensorFlow 2.x models to TensorFlow Lite Flatbuffer
    format
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 将TensorFlow 2.x模型转换为TensorFlow Lite Flatbuffer格式
- en: 'You can learn more about the TFLite model format here: [https://www.tensorflow.org/lite](https://www.tensorflow.org/lite).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于TFLite模型格式的信息：[https://www.tensorflow.org/lite](https://www.tensorflow.org/lite)。
- en: It's time to hop on to the next recipe!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候进入下一个示例了！
- en: Deploying RL agents on mobile devices
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在移动设备上部署RL代理
- en: Mobile is the most-targeted platform due to its high customer reach compared
    to other platforms. The global mobile application market size is projected to
    reach USD 407.32 billion by 2026 according to [https://www.alliedmarketresearch.com/mobile-application-market](https://www.alliedmarketresearch.com/mobile-application-market).
    Such a huge market opens several opportunities for infusing RL-based Artificial
    Intelligence. Android and iOS are the two main OS platforms in this space. While
    IOS is a popular platform, building apps for iOS requires a Mac to develop the
    apps. We will therefore develop an Android app using the Android SDK, which is
    more widely accessible. If you are an iOS app developer, you may be able to adapt
    parts of this recipe to your app.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备是最具目标性的应用平台，因为它的用户覆盖面远远超过其他平台。根据[https://www.alliedmarketresearch.com/mobile-application-market](https://www.alliedmarketresearch.com/mobile-application-market)，全球移动应用市场预计到
    2026 年将达到 4073.2 亿美元。如此庞大的市场为基于 RL 的人工智能提供了许多机会。Android 和 iOS 是该领域的两大操作系统平台。虽然
    iOS 是一个流行的平台，但开发 iOS 应用需要使用 Mac 电脑。因此，我们将使用 Android SDK 开发 Android 应用，这对于大多数人来说更容易访问。如果你是
    iOS 应用开发者，可能可以将本教程的部分内容适配到你的应用中。
- en: 'This recipe provides ways for you to deploy trained RL agent models on mobile
    and/or IoT devices using the TensorFLow Lite framework. You will also have access
    to a sample RL Table Tennis Android app that you can use as a testbed to deploy
    your RL agent or develop your own ideas and apps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程提供了通过 TensorFlow Lite 框架将训练好的 RL 智能体模型部署到移动设备和/或物联网设备的方法。你还将获得一个示例 RL 乒乓球
    Android 应用，可以将其作为测试平台来部署 RL 智能体，或开发你自己的创意和应用：
- en: '![Figure 9.3 – A screenshot of the RL Table Tennis app running on an Android
    device ](img/B15074_09_03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – RL 乒乓球应用在 Android 设备上的运行截图](img/B15074_09_03.jpg)'
- en: Figure 9.3 – A screenshot of the RL Table Tennis app running on an Android device
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – RL 乒乓球应用在 Android 设备上的运行截图
- en: Let's get started!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We will be using Android Studio to set up and develop the sample RL Android
    app. Download and install Android Studio from the official website: [https://developer.android.com/studio](https://developer.android.com/studio).
    Using the default install location is recommended. Once installed, run Android
    Studio to start the **Android Studio Setup Wizard**. Follow through the setup
    process and make sure the latest Android SDK, Android SDK command-line tools,
    and the Android SDK build tools are marked for installation.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Android Studio 设置并开发示例 RL Android 应用程序。从官方网站下载并安装 Android Studio：[https://developer.android.com/studio](https://developer.android.com/studio)。推荐使用默认安装位置。安装完成后，运行
    Android Studio 启动**Android Studio 设置向导**。按照设置过程进行操作，并确保安装了最新的 Android SDK、Android
    SDK 命令行工具和 Android SDK 构建工具。
- en: 'To run the application once complete, you have two options: 1\. Run it on your
    Android phone 2\. Run it in the Android virtual device emulator. Follow the setup
    instructions depending on your choice:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后运行应用程序时，你有两个选择：1. 在 Android 手机上运行 2. 在 Android 虚拟设备模拟器中运行。根据你的选择，按照以下设置说明操作：
- en: 'Running it on your Android phone:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Android 手机上运行：
- en: 'a) Enable developer options and USB debugging in Android settings. Detailed
    instructions are available here: [https://developer.android.com/studio/debug/dev-options](https://developer.android.com/studio/debug/dev-options).'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 在 Android 设置中启用开发者选项和 USB 调试。详细操作说明请参阅：[https://developer.android.com/studio/debug/dev-options](https://developer.android.com/studio/debug/dev-options)。
- en: 'b) If you are on Windows, install the Google USB driver: [https://developer.android.com/studio/run/win-usb](https://developer.android.com/studio/run/win-usb).'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 如果你使用的是 Windows 系统，安装 Google USB 驱动程序：[https://developer.android.com/studio/run/win-usb](https://developer.android.com/studio/run/win-usb)。
- en: c) Connect your phone to your computer using a USB cable and, if prompted, allow
    your computer to access your phone.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) 使用 USB 数据线将手机连接到计算机，如果出现提示，允许计算机访问你的手机。
- en: 'd) Run `adb devices` to make sure your phone is detected. If your phone is
    not detected, make sure the drivers are installed and ADB debugging is enabled
    on your phone. You can follow the Android official guide here for detailed instructions:
    [https://developer.android.com/studio/run/device#setting-up](https://developer.android.com/studio/run/device#setting-up).'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d) 运行 `adb devices` 确保手机已被检测到。如果手机没有被检测到，确保驱动程序已安装并且手机上已启用 ADB 调试。你可以参考 Android
    官方指南获取详细的操作说明：[https://developer.android.com/studio/run/device#setting-up](https://developer.android.com/studio/run/device#setting-up)。
- en: 'Running it in the Android emulator:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Android 模拟器中运行：
- en: a) Launch Android Studio, click on the **AVD Manager** icon and select **Create
    Virtual Device**.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 启动 Android Studio，点击 **AVD Manager** 图标并选择 **Create Virtual Device**。
- en: b) Choose a device and select **Next**.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 选择一个设备并点击 **Next**。
- en: c) Choose an x86 or x86_64 image for the Android version you want to emulate
    and complete the process.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) 选择一个 x86 或 x86_64 镜像，用于你想要模拟的 Android 版本，并完成过程。
- en: d) Click **Run** in the AVD Manager toolbar to launch the emulator.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d) 点击 **Run**，在 AVD Manager 工具栏中启动模拟器。
- en: 'Once you have the device set up, navigate to the code directory for this recipe
    under the `src/ch9-cross-platform-deployment` directory. You will find a sample
    Android application with a directory structure and contents like the one shown
    in the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在你设置好设备后，进入 `src/ch9-cross-platform-deployment` 目录中的代码目录。你将看到一个示例 Android 应用，其目录结构和内容如下面的截图所示：
- en: '![Figure 9.4 – Directory structure and contents of the sample Android app ](img/B15074_09_04.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 示例 Android 应用的目录结构和内容](img/B15074_09_04.jpg)'
- en: Figure 9.4 – Directory structure and contents of the sample Android app
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 示例 Android 应用的目录结构和内容
- en: Once you have the sample code base to work with, move on to the next section
    to see how to prepare our RL agent model and build the app.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了示例代码库，继续阅读下一部分，看看如何准备我们的 RL agent 模型并构建应用。
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We''ll start with the RL agent model preparation and then build a simple, two-player
    Table Tennis app where you can play against the agent. Follow the steps listed
    here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 RL agent 模型的准备工作开始，然后构建一个简单的双人乒乓球应用，你可以与 agent 对战。按照这里列出的步骤操作：
- en: Export your RL agent's (Actor) model to TFLite format using the previous recipe
    discussed in this chapter. For example, you can run the previous recipe to train
    a PPO agent for the `Pong-v4` environment and use the generated `model.tflite`
    file in the `trained_models/actor/1/` directory. Place the model in the Android
    app's `app/src/assets/` directory as highlighted in the figure here:![Figure 9.5
    – RL agent model.tflite location in Android app src ](img/B15074_09_05.jpg)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用本章前面讨论的食谱，将 RL agent（Actor）的模型导出为 TFLite 格式。例如，你可以运行前面的食谱来训练一个 PPO agent，用于
    `Pong-v4` 环境，并使用生成的 `model.tflite` 文件，位于 `trained_models/actor/1/` 目录下。将模型文件放置在
    Android 应用的 `app/src/assets/` 目录下，如下图所示：![图 9.5 – RL agent model.tflite 在 Android
    应用 src 中的位置](img/B15074_09_05.jpg)
- en: Figure 9.5 – RL agent model.tflite location in Android app src
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.5 – RL agent model.tflite 在 Android 应用 src 中的位置
- en: 'Edit the app''s `dependencies` section in the `build.gradle` file to include
    the `tensorflow-lite` dependency:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑应用的 `build.gradle` 文件中的 `dependencies` 部分，加入 `tensorflow-lite` 依赖：
- en: '[PRE14]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add a member method to load the `agent/model.tflite` from the `assets` folder
    and return a `MappedByteBuffer`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个成员方法，从 `assets` 文件夹加载 `agent/model.tflite` 并返回一个 `MappedByteBuffer`：
- en: '[PRE15]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can now create a new TFLite interpreter like so:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以像这样创建一个新的 TFLite 解释器：
- en: '[PRE16]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The interpreter is ready. Let''s prepare the input. First, let''s define some
    constants based on what we know from our agent training:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释器已准备好。让我们准备输入数据。首先，根据我们从 agent 训练中了解的信息，定义一些常量：
- en: '[PRE17]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s now implement a method to convert image data in `BitMap` format to `ByteArray`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现一个方法，将 `BitMap` 格式的图像数据转换为 `ByteArray`：
- en: '[PRE18]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can now run the image observations from the Table Tennis game through the
    Agent model to get the action:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以将乒乓球游戏中的图像观察数据传入 Agent 模型，以获取动作：
- en: '[PRE19]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Those are all the main ingredients for this recipe! You can run them in a loop
    to generate actions per observation/game frame or customize them however you like!
    Let's look at how to run the app on an Android device using Android Studio in
    the following steps.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些就是本教程的所有主要成分！你可以将它们循环运行，以根据每个观察/游戏帧生成动作，或者根据你的需求进行定制！接下来，让我们看看如何使用 Android
    Studio 在 Android 设备上运行该应用。
- en: Launch Android Studio. You will see a screen like this:![Figure 9.6 – Android
    Studio welcome screen ](img/B15074_09_06.jpg)
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Android Studio。你将看到类似于下图的屏幕：![图 9.6 – Android Studio 欢迎屏幕](img/B15074_09_06.jpg)
- en: Figure 9.6 – Android Studio welcome screen
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.6 – Android Studio 欢迎屏幕
- en: Let's proceed to the next step.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们继续进行下一步。
- en: Click on the **Open an Existing Project** option and you will see a popup asking
    you to choose the directory on your filesystem. Navigate to the folder where you
    have cloned the book's code repo or your fork, and browse to this recipe's folder
    under [*Chapter 9*](#_idTextAnchor244) as shown in the figure here:![Figure 9.7
    – File/project picker interface to choose the RL Android app ](img/B15074_09_07.jpg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**打开现有项目**选项，弹出窗口会要求你选择文件系统中的目录。导航到你克隆的书籍代码仓库或你的分支文件夹，然后浏览到[*第 9 章*](#_idTextAnchor244)中的这个配方文件夹，正如图示所示：![图
    9.7 – 选择文件/项目界面以选择 RL Android 应用 ](img/B15074_09_07.jpg)
- en: Figure 9.7 – File/project picker interface to choose the RL Android app
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.7 – 选择文件/项目界面以选择 RL Android 应用
- en: You will notice that Android Studio has already identified our app and shows
    the directory with an Android symbol.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到 Android Studio 已经识别出我们的应用，并显示带有 Android 图标的目录。
- en: Once you click **OK**, Android Studio will open with the app's code and will
    look like the following figure:![Figure 9.8 – Android Studio with the TFRL-Cookbook's
    RL app loaded ](img/B15074_09_08.jpg)
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你点击**确定**，Android Studio 将会打开并加载应用的代码，界面如下图所示：![图 9.8 – Android Studio 中加载
    TFRL-Cookbook 的 RL 应用 ](img/B15074_09_08.jpg)
- en: Figure 9.8 – Android Studio with the TFRL-Cookbook's RL app loaded
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.8 – Android Studio 中加载 TFRL-Cookbook 的 RL 应用
- en: So far, so good!
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利！
- en: Let's build the project by clicking on the **Build** menu and choosing **Make
    Project**, as shown in the following figure (or by simply pressing *Ctrl* + *F9*):![Figure
    9.9 – Building the RL Android app using the Make Project option ](img/B15074_09_09.jpg)
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过点击**构建**菜单并选择**构建项目**来构建项目，如下图所示（或者直接按 *Ctrl* + *F9*）：![图 9.9 – 使用 Make
    Project 选项构建 RL Android 应用 ](img/B15074_09_09.jpg)
- en: Figure 9.9 – Building the RL Android app using the Make Project option
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.9 – 使用 Make Project 选项构建 RL Android 应用
- en: This process may take some time to complete and you may see useful status messages
    in the **Build** information tab.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个过程可能需要一些时间，你可能会在**构建**信息标签中看到有用的状态消息。
- en: Once the build process completes, you will see `.apk` file, which can be run
    on an Android device.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦构建过程完成，你会看到 `.apk` 文件，可以在 Android 设备上运行。
- en: Let's go ahead and run the app by using the **Run** menu, as shown in the following
    figure:![Figure 9.11 – The Run menu option to run the RL app in Android Studio
    ](img/B15074_09_011.jpg)
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续使用**运行**菜单来运行应用，如下图所示：![图 9.11 – 在 Android Studio 中运行 RL 应用的 Run 菜单选项 ](img/B15074_09_011.jpg)
- en: Figure 9.11 – The Run menu option to run the RL app in Android Studio
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.11 – 在 Android Studio 中运行 RL 应用的 Run 菜单选项
- en: At this point, if you have your Android device/phone connected to the machine,
    you can launch that app on your phone. Otherwise, you can use the AVD to emulate
    an Android device.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此时，如果你已经将 Android 设备/手机连接到计算机，你可以在手机上启动该应用。否则，你可以使用 AVD 来模拟 Android 设备。
- en: Let's choose an AVD device to emulate from the device menu, as shown in the
    following figure:![Figure 9.12 – Choose the AVD to emulate an Android device ](img/B15074_09_012.jpg)
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从设备菜单中选择一个 AVD 设备来模拟，如下图所示：![图 9.12 – 选择 AVD 来模拟 Android 设备 ](img/B15074_09_012.jpg)
- en: Figure 9.12 – Choose the AVD to emulate an Android device
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.12 – 选择 AVD 来模拟 Android 设备
- en: We are now ready with the device to run the app.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在已经准备好设备来运行这个应用。
- en: Let's go ahead and launch/run the app! You can use the **Run 'app'** button
    from the **Run** menu, as shown in the following figure:![Figure 9.13 – Run 'app'
    command to launch the app ](img/B15074_09_013.jpg)
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续并启动/运行应用！你可以使用**运行 'app'**按钮，在**运行**菜单中，如下图所示：![图 9.13 – 运行 'app' 命令来启动应用
    ](img/B15074_09_013.jpg)
- en: Figure 9.13 – Run 'app' command to launch the app
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.13 – 运行 'app' 命令来启动应用
- en: That should launch the app on the AVD emulator (or on your phone if you chose
    it).
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会在 AVD 模拟器上启动应用（如果你选择了手机，则会在手机上启动）。
- en: 'The app should launch on the Android device and should look something like
    the following figure:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用应该会在 Android 设备上启动，界面应该像下面的图示：
- en: '![Figure 9.14 – The TFRL-Cookbook RL app running on an Android (emulated) device
    ](img/B15074_09_014.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.14 – TFRL-Cookbook RL 应用在 Android（模拟）设备上运行 ](img/B15074_09_014.jpg)'
- en: Figure 9.14 – The TFRL-Cookbook RL app running on an Android (emulated) device
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14 – TFRL-Cookbook RL 应用在 Android（模拟）设备上运行
- en: Congratulations!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！
- en: That completes our recipe. Head to the next section to learn more about the
    recipe.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的配方。前往下一节以了解更多关于该配方的内容。
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the previous recipe, we saw how you can export your Deep RL agent''s model
    to the TFLite format. The previous recipe generated two `model.tflite` files:
    one for the Actor and another for the Critic.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个配方中，我们看到如何将深度强化学习智能体的模型导出为 TFLite 格式。前一个配方生成了两个 `model.tflite` 文件，一个用于演员（Actor），另一个用于评论员（Critic）。
- en: Note
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can train any agent algorithm of your choice following the recipes previously
    discussed in this book and use the recipe titled *Packaging Deep RL agents for
    mobile and IoT devices using TensorFlow Lite* in this chapter to obtain the Actor
    `model.tflite` file used in this recipe.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照本书中之前讨论的配方，训练任何你选择的智能体算法，并使用本章中的配方 *使用 TensorFlow Lite 为移动设备和物联网设备打包深度强化学习智能体*
    来获取在此配方中使用的演员 `model.tflite` 文件。
- en: As you may recall from [*Chapter 3*](B15074_03_ePub_AM.xhtml#_idTextAnchor090),
    *Implementing Advanced Deep RL Algorithms on Deep RL Agents*, the Actor component
    is responsible for generating actions according to the learned policy and the
    Critic component estimates the state or state-action value. When it comes to deploying
    RL agents, we are more interested in the action generated by the agent than the
    predicted state or state-action values. Therefore, we only used the agent's Actor
    model for deployment purposes in this recipe.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能记得在[*第3章*](B15074_03_ePub_AM.xhtml#_idTextAnchor090)中所提到的，*在深度强化学习智能体上实现高级深度强化学习算法*，演员组件负责根据学习到的策略生成动作，而评论员组件估计状态或状态-动作值。在部署强化学习智能体时，我们更关心的是智能体生成的动作，而不是预测的状态或状态-动作值。因此，在此配方中，我们仅使用智能体的演员模型进行部署。
- en: We first included the TFLite dependency by updating the app's `gradle.build`
    file. We then added a method named `loadModelFile` to load the agent's model (`model.tflite`).
    This returns a `MappedByteBuffer` object, which is needed to initialize a TFLite
    interpreter instance. Once the agent's model is loaded and a TFLite interpreter
    instance is created, we can run the interpreter with valid inputs to get the agent's
    actions. In order to make sure the inputs are in a valid format, we converted
    the image data from `BitMap` format to `ByteBuffer` format. We also defined the
    image observation width, height, number of channels, and so on based on the observation
    space of the environment we used to train the RL agent.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过更新应用的 `gradle.build` 文件来包含 TFLite 依赖项。接着我们添加了一个名为 `loadModelFile` 的方法来加载智能体的模型（`model.tflite`）。此方法返回一个
    `MappedByteBuffer` 对象，这是初始化 TFLite 解释器实例所需的。模型加载完成并且创建了 TFLite 解释器实例后，我们可以用有效的输入运行解释器来获得智能体的动作。为了确保输入的格式有效，我们将图像数据从
    `BitMap` 格式转换为 `ByteBuffer` 格式。我们还根据用于训练强化学习智能体的环境的观察空间定义了图像观察的宽度、高度、通道数等。
- en: The action returned by the agent's model in *Step 7* can be used to actuate/move,
    say, the red paddle in the Table Tennis game and repeat the preceding steps for
    each new observation in a loop to make the agent play against itself or a human!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤7*中，智能体模型返回的动作可以用来驱动/移动，例如乒乓球游戏中的红色球拍，并且可以在循环中对每个新的观察重复之前的步骤，让智能体与自己或人类对战！
- en: We then saw how to launch the app using Android Studio and then concluded the
    recipe. Hope you had fun!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接着我们看到如何使用 Android Studio 启动应用，并最终完成该配方。希望你玩得开心！
- en: Let's march on to the next recipe whenever you are ready.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好时，我们可以继续进行下一个配方。
- en: Packaging Deep RL agents for the web and Node.js using TensorFlow.js
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TensorFlow.js 打包深度强化学习（Deep RL）智能体以供网页和 Node.js 使用
- en: JavaScript is the language of choice when it comes to developing web applications
    due to its versatility both as a frontend as well as a backend programming language
    that can be executed by a web browser or using Node.js. The ability to run out
    RL agents on the web will unlock several new pathways for deploying RL agents
    in web apps. This recipe will show how you can train and export RL agent models
    into a format that you can then use in your JavaScript applications that can be
    run directly in the browser or in a Node.js environment. The TensorFlow.js (TF.js)
    library allows us to use JavaScript to run existing models or even train/retrain
    new models. We will use the `tensorflowjs` Python module to export our agent's
    model to a supported format that can be imported into JavaScript-based web or
    desktop (Node.js/Electron) apps. We will explore two approaches to export the
    Agent model to the TF.js layers format.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是开发 Web 应用程序时的首选语言，因为它在前端和后端编程语言中都具有多功能性，可以通过 Web 浏览器或 Node.js 执行。能够在
    Web 上运行 RL 智能体将为在 Web 应用程序中部署 RL 智能体开辟多个新路径。本示例将展示如何训练并导出 RL 智能体模型，将其转换为可以在 JavaScript
    应用程序中使用的格式，这些应用程序可以直接在浏览器中运行或在 Node.js 环境中运行。TensorFlow.js (TF.js) 库允许我们使用 JavaScript
    运行现有模型，甚至训练/重训新模型。我们将使用 `tensorflowjs` Python 模块将我们的智能体模型导出为支持的格式，然后可以将其导入到基于
    JavaScript 的 Web 或桌面（Node.js/Electron）应用中。我们将探讨两种将智能体模型导出为 TF.js 层格式的方法。
- en: Let's get started!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始！
- en: Getting ready
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To complete this recipe, you will first need to activate the `tf2rl-cookbook`
    Python/conda virtual environment. Make sure to update the environment to match
    the latest conda environment specification file (`tfrl-cookbook.yml`) in the cookbook''s
    code repo. If the following imports work without issues, you are ready to get
    started:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此食谱，您首先需要激活 `tf2rl-cookbook` Python/conda 虚拟环境。确保更新环境以匹配食谱代码库中的最新 conda 环境规范文件（`tfrl-cookbook.yml`）。如果以下导入没有问题，则可以开始：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, let's begin!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始吧！
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: In the following text, we will save space by focusing on the new and important
    pieces that are unique to this recipe. We will go through the model saving and
    export functionality and the different ways you can do that and keep the Actor,
    Critic, and Agent model definitions out of the following steps to save space.
    Please refer to the book's code repository for a complete implementation, including
    the training and logging methods.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的文本中，我们将通过专注于此食谱中特有的新增和重要部分来节省空间。我们将讲解模型保存和导出功能，以及如何通过不同方式实现，并将演员、评论员和智能体模型定义从以下步骤中省略，以节省空间。请参阅书中的代码库以获取完整的实现，包括训练和日志记录方法。
- en: 'Let''s get started:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'Let''s first set up a command-line argument parser to allow easy customization
    of the script:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先设置一个命令行参数解析器，方便自定义脚本：
- en: '[PRE21]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s also set up logging so that we can visualize the agent''s learning progress
    using TensorBoard:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将设置日志记录，以便使用 TensorBoard 可视化智能体的学习进度：
- en: '[PRE22]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For the first export approach, we will define `save_h5` methods for the `Actor`,
    `Critic`, and `Agent` classes in the following steps. We will start with the implementation
    of the `save_h5` method in the `Actor` class to export the Actor model to Keras''s
    `h5` format:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第一个导出方法，我们将在接下来的步骤中为 `Actor`、`Critic` 和 `Agent` 类定义 `save_h5` 方法。我们将从实现 `Actor`
    类中的 `save_h5` 方法开始，将演员模型导出为 Keras 的 `h5` 格式：
- en: '[PRE23]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Similarly, we will implement a `save` method for the `Critic` class to export
    the Critic model to Keras''s `h5` format:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们将为 `Critic` 类实现一个 `save` 方法，将评论员模型导出为 Keras 的 `h5` 格式：
- en: '[PRE24]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can now add a `save` method for the `Agent` class that will utilize the
    Actor and Critic `save` method to save both the models needed by the agent:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以为 `Agent` 类添加一个 `save` 方法，该方法将利用演员和评论员的 `save` 方法来保存智能体所需的两个模型：
- en: '[PRE25]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once the `save_h5()` method is executed, the `save` method will generate two
    models (one for the Actor and one for the Critic) and save them in the specified
    directory on the filesystem with a directory structure and files like the one
    shown in the following figure:![Figure 9.15 – Directory structure and file contents
    for the DDPG RL agent with the save_h5 model export ](img/B15074_09_015.jpg)
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦执行了 `save_h5()` 方法，`save` 方法将生成两个模型（一个用于演员，另一个用于评论员），并将它们保存在文件系统中指定的目录下，目录结构和文件内容如下图所示：![图
    9.15 – DDPG RL 智能体保存 `save_h5` 模型导出的目录结构和文件内容](img/B15074_09_015.jpg)
- en: Figure 9.15 – Directory structure and file contents for the DDPG RL agent with
    the save_h5 model export
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.15 – DDPG RL 代理的目录结构和文件内容，使用 `save_h5` 模型导出
- en: 'Once the `.h5` files are generated, we can use the `tensorflowjs_converter`
    command-line tool and specify the location of the Actor model''s `save` directory.
    Refer to the following command for an example:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦生成 `.h5` 文件，我们可以使用 `tensorflowjs_converter` 命令行工具，并指定 Actor 模型的 `save` 目录的位置。请参考以下命令作为示例：
- en: '[PRE26]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Similarly, we can convert the Critic model using the following command:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，我们可以使用以下命令转换 Critic 模型：
- en: '[PRE27]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Hooray! We now have both the Actor and Critic models in the TF.js layers format.
    We will look at another approach that doesn't need us to (manually) switch to
    the command line to convert the model.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 太好了！我们现在拥有了 TF.js 层格式的 Actor 和 Critic 模型。我们将查看另一种方法，它不需要我们（手动）切换到命令行来转换模型。
- en: 'There''s another approach to export the Agent model to the TF.js layers format.
    We will be implementing it in the following steps, starting with the `save_tfjs`
    method for the `Actor` class:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有另一种方法可以将代理模型导出为 TF.js 层格式。我们将在接下来的步骤中实现这一方法，从 `Actor` 类的 `save_tfjs` 方法开始：
- en: '[PRE28]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Similarly, we will implement the `save_tfjs` method for the `Critic` class:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，我们将实现 `Critic` 类的 `save_tfjs` 方法：
- en: '[PRE29]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `Agent` class can then call the `save_tfjs` method on the Actor and Critic
    using its own `save_tfjs` method, as shown in the following code snippet:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`Agent` 类可以通过其自己的 `save_tfjs` 方法调用 Actor 和 Critic 的 `save_tfjs` 方法，如下方代码片段所示：
- en: '[PRE30]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When the Agent's `save_tfjs` method gets executed, the Actor and Critic models
    in the TF.js layers format will be generated and will have a directory structure
    and file contents like the one shown in the following figure:![Figure 9.16 – Directory
    structure and file contents for the DDPG RL agent with the save_tfjs model export
    ](img/B15074_09_016.jpg)
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当执行代理的 `save_tfjs` 方法时，将生成 Actor 和 Critic 模型的 TF.js 层格式，并将具有如图所示的目录结构和文件内容：![图
    9.16 – DDPG RL 代理的目录结构和文件内容，使用 `save_tfjs` 模型导出](img/B15074_09_016.jpg)
- en: Figure 9.16 – Directory structure and file contents for the DDPG RL agent with
    the save_tfjs model export
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.16 – DDPG RL 代理的目录结构和文件内容，使用 `save_tfjs` 模型导出
- en: 'To sum up, we can finalize the `main` function to instantiate the agent and
    train and save the model in the TF.js layers format directly using the Python
    API:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总结一下，我们可以最终确定 `main` 函数来实例化代理，并直接使用 Python API 在 TF.js 层格式中训练并保存模型：
- en: '[PRE31]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can now take the TF.js model and deploy it in your web app, Node.js app,
    Electron app, or any other JavaScript/TypeScript-based applications. Let's recap
    some of the key items we used in this recipe in the next section.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以将 TF.js 模型部署到你的 web 应用、Node.js 应用、Electron 应用或任何其他基于 JavaScript/TypeScript
    的应用中。让我们在下一部分回顾一下我们在这个配方中使用的一些关键项。
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we used a DDPG agent with Actor and Critic networks that expect
    image observations and produce actions in continuous space. You can swap the agent
    code with the DDPG implementations from one of the earlier chapters that use different
    state/observation spaces and action spaces. You could also replace the agent with
    a different agent algorithm altogether. You will find a bonus recipe that exports
    a PPO agent TF.js model in the book's code repository for this chapter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使用了一个 DDPG 代理，其中包含期望图像观察并在连续空间中产生动作的 Actor 和 Critic 网络。你可以用本书前几章中使用不同状态/观察空间和动作空间的
    DDPG 实现来替换代理代码。你也可以完全用不同的代理算法替换它。你会在本章的代码库中找到一个额外的配方，用于导出 PPO 代理的 TF.js 模型。
- en: We discussed two approaches to save and convert our agent models to TF.js format.
    The first approach allowed us to generate a Keras model in H5 format, which is
    a short form of HDF5, which is an acronym for Hierarchical Data Format version
    5 file format. We then converted it to the TF.js model using the `tensorflowjs_converter`
    command-line tool. While it is lightweight and easy to handle a single file per
    model, the Keras HDF5 model has limitations compared to the SavedModel file format.
    Specifically, the Keras HDF5 models do not contain the computation graphs of custom
    objects/layers and therefore will require the Python class/function definitions
    for these custom objects to reconstruct the model during runtime. Moreover, in
    the cases when we add loss terms and metrics outside the model class definition
    (using `model.add_loss()` or `model.add_metric()`), these are not exported in
    the HDF5 model file.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了两种方法来保存和转换我们的代理模型为 TF.js 格式。第一种方法允许我们生成一个 Keras 模型，其格式为 H5，这是 HDF5 的缩写，全称是“层次化数据格式第五版文件格式”。然后我们使用
    `tensorflowjs_converter` 命令行工具将其转换为 TF.js 模型。尽管每个模型仅需处理单个文件而且轻量化且易于处理，但与 SavedModel
    文件格式相比，Keras HDF5 模型存在一些限制。具体来说，Keras HDF5 模型不包含自定义对象/层的计算图，因此在运行时需要这些自定义对象的 Python
    类/函数定义来重建模型。此外，在我们在模型类定义之外添加损失项和指标的情况下（使用 `model.add_loss()` 或 `model.add_metric()`），这些内容不会导出到
    HDF5 模型文件中。
- en: In the second approach, we used the `tensorflowjs` Python module to directly
    (in memory) convert and save the agent's models in the TF.js layers format.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种方法中，我们使用 `tensorflowjs` Python 模块直接（内存中）将代理模型转换并保存为 TF.js 层格式。
- en: 'You can learn more about TF.js here: [https://www.tensorflow.org/js](https://www.tensorflow.org/js).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处了解有关 TF.js 的更多信息：[https://www.tensorflow.org/js](https://www.tensorflow.org/js)。
- en: It's time for the next recipe!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是下一个食谱的时间！
- en: Deploying a Deep RL agent as a service
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将深度 RL 代理部署为服务
- en: Once you train your RL agent to solve a problem or business need, you will want
    to deploy it as a service – more likely than offering the trained agent model
    as a product due to several reasons, including scalability and model-staleness
    limitations. You will want to have a way to update the agent model with new versions
    and you will not want to maintain or offer support for multiple versions or older
    versions of your agent if you sell it as a product. You will need a solid and
    well-tested mechanism to offer your RL agent as an AI service that allows customizable
    runtimes (different frameworks, and CPU/GPU support), easy model upgrades, logging,
    performance monitoring, and so on.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您训练好您的 RL 代理来解决问题或业务需求，您将希望将其部署为一个服务 – 与将训练好的代理模型作为产品提供相比更为可能，这是因为包括可伸缩性和模型陈旧性限制在内的多种原因。如果您将其作为产品销售，您将希望有一种方法来更新代理模型的新版本，并且您不希望维护或支持多个版本或旧版本的代理。您将需要一个坚固且经过充分测试的机制，来将您的
    RL 代理作为 AI 服务提供，允许可定制的运行时（不同的框架和 CPU/GPU 支持），轻松的模型升级，日志记录，性能监控等等。
- en: To serve all such needs, we will be using NVIDIA's Triton server as the backend
    for serving our agent as a service. Triton serves as a unifying inference framework
    for the deployment of AI models at scale in production. It supports a wide variety
    of deep learning frameworks including TensorFlow2, PyTorch, ONNX, Caffe2, and
    others, including custom frameworks, and offers several other production-quality
    features and optimizations, such as concurrent model execution, dynamic batching,
    logging, and performance and health monitoring.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足所有这些需求，我们将使用 NVIDIA 的 Triton 服务器作为后端，为我们的代理提供服务。Triton 作为一个统一的推断框架，在生产中支持大规模部署的
    AI 模型。它支持多种深度学习框架，包括 TensorFlow2、PyTorch、ONNX、Caffe2 等，还包括自定义框架，并提供了其他多个生产质量的功能和优化，如并发模型执行，动态批处理，日志记录，性能和健康监控等。
- en: Let's get started with our recipe!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始我们的食谱！
- en: Getting ready
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To complete this recipe, you will first need to activate the `tf2rl-cookbook`
    Python/conda virtual environment. Make sure to update the environment to match
    the latest conda environment specification file (`tfrl-cookbook.yml`) in the cookbook''s
    code repo. You will also need to make sure you have the latest NVIDIA GPU drivers
    installed on your machine that supports the GPU you have. You will also need Docker
    set up on your machine. If you haven''t installed Docker, you can follow the official
    instructions here to set up Docker for your OS: [https://docs.docker.com/get-started/](https://docs.docker.com/get-started/).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个步骤，你首先需要激活`tf2rl-cookbook` Python/conda虚拟环境。确保更新该环境，以匹配本书代码仓库中最新的conda环境规范文件(`tfrl-cookbook.yml`)。你还需要确保你的机器上安装了支持你GPU的最新NVIDIA驱动程序。你还需要在机器上安装Docker。如果尚未安装Docker，你可以按照官方说明在此链接进行安装：[https://docs.docker.com/get-started/](https://docs.docker.com/get-started/)。
- en: Now, let's begin!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始吧！
- en: How to do it...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: In the following text, we will save space by focusing on the service we will
    be building. We will keep the contents of the agent training scripts out of the
    text, but you will find the scripts in the book's code repository under `ch9-cross-platform-deployment`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的文字中，我们将节省篇幅，专注于我们将要构建的服务。我们将省略智能体训练脚本的内容，但你可以在本书的代码仓库中的`ch9-cross-platform-deployment`找到这些脚本。
- en: 'Let''s get started:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'First, you will want to train, save, and export the agent that you want to
    host as a service. You can use the sample `agent_trainer_saver.py` script to train
    a PPO agent for one of the tasks in the Webgym suite of environments using the
    following command:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要训练、保存并导出你希望作为服务托管的智能体。你可以使用示例脚本`agent_trainer_saver.py`来训练Webgym环境套件中的一个任务的PPO智能体，使用以下命令：
- en: '[PRE32]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once you have identified the suitable container version, say `yy.mm`, you can
    use Docker to pull the NVIDIA Triton server image using the following command:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你确定了合适的容器版本，例如`yy.mm`，你可以使用Docker通过以下命令拉取NVIDIA Triton服务器镜像：
- en: '[PRE33]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Change the `yy.mm` placeholder to the version you have identified. For example,
    to pull the container version 20.09, you would run the following command:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`yy.mm`占位符更改为你所确定的版本。例如，要拉取容器版本20.09，你需要运行以下命令：
- en: '[PRE34]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When you run the `agent_trainer_saver` script, the trained models are stored
    in the `trained_models` directory with the following directory structure and contents:![Figure
    9.17 – Directory structure and contents of the exported trained models ](img/B15074_09_017.jpg)
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行`agent_trainer_saver`脚本时，训练好的模型将存储在`trained_models`目录中，目录结构和内容如下所示：![图 9.17
    – 导出训练模型的目录结构和内容](img/B15074_09_017.jpg)
- en: Figure 9.17 – Directory structure and contents of the exported trained models
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.17 – 导出训练模型的目录结构和内容
- en: The `trained_models/actor` directory will be the root directory for our model
    repository store when serving with Triton.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`trained_models/actor`目录将是我们在Triton中提供服务时的模型仓库根目录。'
- en: 'We are now ready to serve our agent''s actions as a service! To launch the
    service, run the following command:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备好将智能体的动作作为服务进行提供了！要启动服务，请运行以下命令：
- en: '[PRE35]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you want to serve the agent model from a machine that does not have a GPU
    (not recommended), you can simply omit the `–gpus=1` flag to instruct the Triton
    server to serve using CPUs only. The command will look like this:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想从没有GPU的机器上提供智能体模型（不推荐），你可以简单地省略`–gpus=1`标志，指示Triton服务器仅使用CPU进行服务。命令将如下所示：
- en: '[PRE36]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you run into issues serving your agent models, check the `trained_models/actor/config.pbtxt`
    file, which describes the model configuration. While Triton can automatically
    generate the `config.pbtxt` file from TensorFlow SavedModels, it may not work
    well for all, especially a custom policy network implementation. If you are using
    the `agent_trainer_saver` script to export a trained PPO agent, you can use the
    following `config.pbtxt`. We will discuss the model config in the next few steps:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在提供智能体模型时遇到问题，请检查`trained_models/actor/config.pbtxt`文件，该文件描述了模型配置。虽然Triton可以自动从TensorFlow的SavedModels生成`config.pbtxt`文件，但对于所有模型来说，它可能并不总是有效，尤其是自定义策略网络实现。如果你使用`agent_trainer_saver`脚本导出训练好的PPO智能体，可以使用以下`config.pbtxt`。我们将在接下来的几步中讨论模型配置：
- en: '[PRE37]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We will continue to specify the input (state/observation) space/dimension configuration:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将继续指定输入（状态/观察）空间/维度配置：
- en: '[PRE38]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we will specify the output (action space):'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将指定输出（动作空间）：
- en: '[PRE39]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s also specify the instance group, optimization parameters, and so on:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们还指定实例组、优化参数等：
- en: '[PRE40]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The final set of config parameters required for the `config.pbtxt` file is
    listed here:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`config.pbtxt` 文件所需的最终配置参数列表如下：'
- en: '[PRE41]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Hooray! Our agent as a service is live. At this point, you can run the same
    commands we discussed above on a cloud/remote server/VPS if you would like to
    offer this service on the public web/a network. Let''s quickly send a query to
    the server to make sure everything went as expected:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好极了！我们的代理服务已上线。此时，如果你希望将此服务提供给公共网络或网络上的用户，你可以在云端/远程服务器/VPS 上运行我们之前讨论的相同命令。让我们快速向服务器发送查询，以确保一切正常：
- en: '[PRE42]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If the agent model is being served without issues, you will see an output similar
    to the following:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果代理模型没有问题地提供服务，你将看到类似以下的输出：
- en: '[PRE43]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can also use a full-fledged sample client app to query the agent service
    to get the prescribed action. Let''s quickly set up the tools and libraries we
    need for running a Triton client. You can use Python pip to install the dependencies,
    as shown in the following command snippet:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以使用一个完整的示例客户端应用程序查询代理服务，以获取指定的动作。让我们快速设置运行 Triton 客户端所需的工具和库。你可以使用 Python
    pip 来安装依赖项，如下所示的命令片段：
- en: '[PRE44]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Optionally, to be able to run the performance analyzer (`perf_analyzer`), you
    will need to install the libb64-dev system package using the following command:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，为了能够运行性能分析器（`perf_analyzer`），你需要使用以下命令安装 libb64-dev 系统软件包：
- en: '[PRE45]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You now have all the dependencies to run the sample Triton client app:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经具备了运行示例 Triton 客户端应用程序所需的所有依赖项：
- en: '[PRE46]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: That completes our recipe! Let's look into some of the details of what we accomplished
    in this recipe in the next section.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的食谱！接下来，我们将进入下一部分，详细回顾我们在本食谱中完成的一些细节。
- en: How it works...
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'Our recipe had three sections:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的食谱包含三个部分：
- en: Train, save, and export;
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 训练、保存和导出；
- en: Deploy;
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署；
- en: Launch client.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动客户端。
- en: The first section covered the agent training, saving, and exporting routine.
    In this section, we first picked the RL environment and agent algorithm we wanted
    to train. We then utilized one of the many training strategies we discussed earlier
    in this book to train the agent model. We then used the model saving and export
    methods we discussed in the previous recipes of this chapter to export the trained
    agent model in TensorFlow's SavedModel file format. As you may recall, we followed
    a specific directory structure and file naming convention when we saved and exported
    our agent model. This convention aligns with the model repository conventions
    used by the NVIDIA Triton server and thus allows the models we export to be easily
    served with the production-ready Triton server. Moreover, the organization allows
    us to manage multiple versions of the agent model concurrently easily.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分涵盖了代理的训练、保存和导出流程。在这一部分，我们首先选择了要训练的 RL 环境和代理算法。然后，我们利用本书前面讨论的多种训练策略之一来训练代理模型。接着，我们使用本章前面讨论的模型保存和导出方法，将训练好的代理模型导出为
    TensorFlow 的 SavedModel 文件格式。如你所记，我们在保存和导出代理模型时遵循了特定的目录结构和文件命名规范。这一规范与 NVIDIA
    Triton 服务器所使用的模型仓库规范一致，因此我们导出的模型可以轻松地通过生产级 Triton 服务器提供服务。此外，这一组织方式还使得我们能够轻松地同时管理多个版本的代理模型。
- en: 'In the second section, we saw how we can deploy the exported agent model using
    NVIDIA''s Triton server. You can learn more about NVIDIA''s Triton here: [https://developer.nvidia.com/nvidia-triton-inference-server](https://developer.nvidia.com/nvidia-triton-inference-server).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分，我们看到如何使用 NVIDIA 的 Triton 服务器部署导出的代理模型。你可以在此了解更多关于 NVIDIA Triton 的信息：[https://developer.nvidia.com/nvidia-triton-inference-server](https://developer.nvidia.com/nvidia-triton-inference-server)。
- en: We saw how easy it is to serve our agent using a production-grade serving backend.
    We can easily run the Docker container on a remote/cloud server or VPS to deploy
    this service out on the web.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到使用生产级后端来提供代理服务是多么简单。我们可以轻松地在远程/云服务器或 VPS 上运行 Docker 容器，将此服务部署到网上。
- en: Finally, once the service was launched, we saw how a client can avail of the
    service by sending action requests with appropriate input/observation data from
    a test environment.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦服务启动，我们看到客户端如何通过向服务发送包含适当输入/观察数据的动作请求来使用该服务，数据来自测试环境。
- en: That's it for this recipe! Let's move on to the final recipe of this chapter
    to wrap things up.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的内容到此为止！让我们进入本章的最后一个食谱，以总结全文。
- en: Packaging Deep RL agents for cross-platform deployment
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为跨平台部署打包深度强化学习（Deep RL）代理
- en: Although the grandest success of Deep RL has been in the domain of game playing
    (Atari, Chess, Go, Shogi) and simulated robotics, real-world applications are
    starting to emerge where Deep RL agents show a lot of promise and value. Deploying
    Deep RL agents to a variety of physical form factors such as embedded controllers,
    computers, autonomous cars, drones, and other robots, and so on is expected soon.
    Differences in hardware processors (CPU, GPU, TPU, FPGA, ASIC), operating systems
    (Linux, Windows, OSX, Android), architectures (x86, ARM), and form factors (server,
    desktop, mobile, IoT, embedded systems, and so on) make the deployment process
    challenging. This recipe includes guidelines around how you can leverage the TensorFlow
    2.x framework's ecosystem of libraries, tools, and utilities to package Deep RL
    agent models suitable for deployments to the web, mobile, IoT, embedded systems,
    robots, and desktop platforms.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管深度强化学习（Deep RL）在游戏领域（如 Atari、象棋、围棋、将棋）和模拟机器人方面取得了最大的成功，但现实世界中的应用正逐渐显现，其中深度强化学习代理显示出很大的潜力和价值。预计很快就会将深度强化学习代理部署到各种物理形式因素中，如嵌入式控制器、计算机、自动驾驶汽车、无人机以及其他机器人等。硬件处理器（如
    CPU、GPU、TPU、FPGA、ASIC）、操作系统（如 Linux、Windows、OSX、Android）、架构（如 x86、ARM）和形式因素（如服务器、桌面、移动设备、物联网、嵌入式系统等）之间的差异使得部署过程充满挑战。本教程提供了如何利用
    TensorFlow 2.x 框架的库、工具和实用程序的生态系统来打包适合部署到 Web、移动设备、物联网、嵌入式系统、机器人和桌面平台的深度强化学习代理模型的指南。
- en: This recipe provides a complete script to build, train, and package a Deep RL
    agent in multiple formats that can be used to deploy/serve using TensorFlow Serving,
    TensorFlow Hub, TensorFlow.js, TensorFlow Lite, NVIDIA Triton, ONNX, ONNX.js,
    Clipper, and most other serving frameworks built for deep learning models.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程提供了一个完整的脚本，用于构建、训练和打包一个深度强化学习代理，支持多种格式，可以使用 TensorFlow Serving、TensorFlow
    Hub、TensorFlow.js、TensorFlow Lite、NVIDIA Triton、ONNX、ONNX.js、Clipper 以及大多数为深度学习模型构建的服务框架进行部署/服务。
- en: Let's get started!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 开始吧！
- en: Getting ready
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'To complete this recipe, you will first need to activate the `tf2rl-cookbook`
    Python/conda virtual environment. Make sure to update the environment to match
    the latest conda environment specification file (`tfrl-cookbook.yml`) in the cookbook''s
    code repo. If the following imports work without issues, you are ready to get
    started:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本教程，首先需要激活 `tf2rl-cookbook` Python/conda 虚拟环境。确保更新该环境，以匹配食谱代码仓库中的最新 conda
    环境规范文件（`tfrl-cookbook.yml`）。如果以下导入没有问题，说明你已经准备好开始了：
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now, let's begin!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，开始吧！
- en: How to do it...
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In the following text, we will save space by focusing on the new and important
    pieces that are unique to this recipe. We will focus on the various model saving
    and export functionalities and keep the Actor, Critic, and Agent model definitions
    out of the following steps to save space. Please refer to the book's code repository
    for a complete implementation. We will start implementing the model's save/export
    methods one after the other for the Actor first and then repeat the steps for
    the Critic in the subsequent steps, and finally complete the agent implementation.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中，我们将通过专注于本教程中独特的新功能来节省空间。我们将重点关注各种模型保存和导出功能，而将 Actor、Critic 和 Agent
    的模型定义从以下步骤中省略，以节省空间。完整的实现可以参考书籍的代码仓库。我们将首先为 Actor 实现模型的保存/导出方法，然后在后续步骤中为 Critic
    重复这些步骤，最后完成代理的实现。
- en: 'Let''s get started:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 开始吧：
- en: 'First, it is important to set TensorFlow Keras''s backend to use `float32`
    as the default representation for float values instead of the default `float64`:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，重要的是将 TensorFlow Keras 的后端设置为使用 `float32` 作为默认的浮动值表示，而不是默认的 `float64`：
- en: '[PRE48]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We will begin with the various save/export method implementations for the Actor
    in the following few steps. Let''s implement the `save` method to save and export
    the Actor model to TensorFlow''s `SavedModel` format:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从以下几个步骤开始，逐步实现 `Actor` 的各种保存/导出方法。首先，我们将实现 `save` 方法，将 Actor 模型保存并导出为 TensorFlow
    的 `SavedModel` 格式：
- en: '[PRE49]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we will add the `save_tflite` method to the `Actor` class to save and
    export the Actor model in TFLite format:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将向 `Actor` 类添加 `save_tflite` 方法，以保存和导出 Actor 模型为 TFLite 格式：
- en: '[PRE50]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, let''s implement the `save_h5` method and add it to the `Actor` class
    to save and export the Actor model in HDF5 format:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现 `save_h5` 方法并将其添加到 `Actor` 类中，以将 Actor 模型保存并导出为 HDF5 格式：
- en: '[PRE51]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, we will add the `save_tfjs` method to the `Actor` class to save and export
    the Actor model in TF.js format:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将向 `Actor` 类添加 `save_tfjs` 方法，以保存和导出 Actor 模型为 TF.js 格式：
- en: '[PRE52]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As the final variant, we will add the `save_onnx` method to the `Actor` class
    to save and export the Actor model in ONNX format:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最终变体，我们将向 `Actor` 类添加 `save_onnx` 方法，用于以 ONNX 格式保存和导出 Actor 模型：
- en: '[PRE53]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'That completes the save/export methods for the `Actor` class! In a similar
    way, let''s add the `save` methods to the `Critic` class for completeness. Starting
    with the `save` method, and then the other methods in the later steps:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就完成了 `Actor` 类的保存/导出方法！以类似的方式，让我们向 `Critic` 类添加 `save` 方法，以确保完整性。首先是 `save`
    方法，然后是后续步骤中的其他方法：
- en: '[PRE54]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The next method in the sequence is the `save_tflite` method to save and export
    the Critic model in TFLite format:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 序列中的下一个方法是 `save_tflite` 方法，用于以 TFLite 格式保存和导出 Critic 模型：
- en: '[PRE55]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s implement the `save_h5` add to the `Critic` class to save and export
    the Critic model in HDF5 format:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `Critic` 类中实现 `save_h5` 方法，以保存和导出 Critic 模型为 HDF5 格式：
- en: '[PRE56]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, we will add the `save_tfjs` method to the `Critic` class to save and
    export the Critic model in TF.js format:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在 `Critic` 类中添加 `save_tfjs` 方法，用于以 TF.js 格式保存和导出 Critic 模型：
- en: '[PRE57]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The final variant is the `save_onnx` method, which saves and exports the Critic
    model in ONNX format:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终变体是 `save_onnx` 方法，它用于以 ONNX 格式保存和导出 Critic 模型：
- en: '[PRE58]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'That completes the save/export method additions to our agent''s `Critic` class.
    We now can add the corresponding `save` methods to the `Agent` class that will
    simply call the corresponding `save` methods on the Actor and Critic objects.
    Let''s complete the implementation in the following two steps:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这完成了对智能体 `Critic` 类的保存/导出方法的添加。接下来，我们可以向 `Agent` 类添加相应的 `save` 方法，这些方法将简单地调用
    `Actor` 和 `Critic` 对象上的相应 `save` 方法。让我们在接下来的两步中完成实现：
- en: '[PRE59]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The remaining methods on the `PPOAgent` class are straightforward as well:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PPOAgent` 类中的其余方法也很简单：'
- en: '[PRE60]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'That completes our implementation for the `Agent` class! We are now ready to
    run the script to build, train, and export the Deep RL agent model! Let''s implement
    the `main` function and call all the `save` methods that we have implemented in
    the previous steps:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这完成了我们对 `Agent` 类的实现！我们现在准备运行脚本来构建、训练和导出深度强化学习智能体模型！让我们实现 `main` 函数，并调用我们在之前步骤中实现的所有
    `save` 方法：
- en: '[PRE61]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'It''s time to execute our script! Please pull the latest copy of the recipe
    from the book''s code repository and just run it! By default, the script will
    train the agent for one episode, save the agent models, and export the model in
    various formats ready for deployment. Once the script finishes, you will see the
    exported models with the directory structure and contents similar to the one shown
    in the following figure:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是执行我们的脚本的时候了！请从书籍的代码库中拉取最新版本的配方，然后直接运行它！默认情况下，脚本将训练智能体一个回合，保存智能体模型，并将模型以多种格式导出，准备部署。脚本完成后，你将看到导出的模型及其目录结构和内容，类似于下图所示：
- en: '![Figure 9.18 – PPO Deep RL agent model exported to various formats for deployment
    ](img/B15074_09_018.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.18 – PPO 深度强化学习智能体模型以各种格式导出，准备部署](img/B15074_09_018.jpg)'
- en: Figure 9.18 – PPO Deep RL agent model exported to various formats for deployment
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.18 – PPO 深度强化学习智能体模型以各种格式导出，准备部署
- en: That completes our final recipe for this chapter! Let's quickly revisit some
    of the key items we covered in this recipe in the following section.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们本章的最终配方！接下来，让我们快速回顾一下我们在此配方中涵盖的一些关键内容。
- en: How it works...
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We first set TensorFlow Keras's backend to use `float32` as the default representation
    for float values. This is because, otherwise, TensorFlow would use the default
    `float64` representation, which is not supported by TensorFlow Lite (for performance
    reasons) as it is targeted towards running on embedded and mobile devices.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置 TensorFlow Keras 的后端，使用 `float32` 作为浮动值的默认表示。这是因为否则 TensorFlow 会使用默认的
    `float64` 表示，而 TensorFlow Lite 不支持 `float64`（出于性能原因），因为它面向嵌入式和移动设备运行。
- en: In this recipe, we used a PPO agent with Actor and Critic networks that expect
    image observations and produce actions in discrete space, designed for RL environments
    such as the procedurally generated procgen environment from OpenAI. You can swap
    the agent code with the PPO implementations from one of the earlier chapters that
    use different state/observation spaces and action spaces depending on your need/application.
    You could also replace the agent with a different agent algorithm altogether.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们使用了一个PPO代理，配备了期望图像观测并在离散空间中产生动作的Actor和Critic网络，专为RL环境设计，如OpenAI的程序化生成的procgen环境。你可以根据需要/应用，替换代理代码为前面章节中的PPO实现，这些实现使用不同的状态/观测空间和动作空间。你也可以完全替换代理，使用其他代理算法。
- en: 'We discussed several approaches to save and export your agent models, leveraging
    the whole suite of tools and libraries offered by the TensorFlow 2.x ecosystem.
    A summary of the various export options that we implemented as part of this recipe
    is provided in the following figure:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了几种保存和导出代理模型的方法，利用TensorFlow 2.x生态系统提供的完整工具和库。以下图表总结了我们在本食谱中实现的各种导出选项：
- en: '![Figure 9.19 – Summary of various RL agent model export options discussed
    in this recipe ](img/B15074_09_019.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.19 – 本食谱中讨论的各种RL代理模型导出选项总结](img/B15074_09_019.jpg)'
- en: Figure 9.19 – Summary of various RL agent model export options discussed in
    this recipe
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.19 – 本食谱中讨论的各种RL代理模型导出选项总结
- en: That concludes this recipe, the chapter, and – more dramatically – the book!
    We covered a lot of different topics in this cookbook to leverage the TensorFlow
    2.x framework and the ecosystem of tools and libraries built around it to build
    RL building blocks, environments, algorithms, agents, and applications. I hope
    you had an exciting journey with the book.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本食谱、这一章，乃至——更戏剧性地说——整本书的结束！在这本食谱中，我们讨论了如何利用TensorFlow 2.x框架和围绕它构建的工具和库生态系统，来构建RL的基础模块、环境、算法、代理和应用。我希望你在阅读这本书时有一段激动人心的旅程。
- en: I can't wait to see what you build/cook with the recipes we discussed in the
    book. I will look forward to hearing about your journey with the book on the discussion
    page at [https://github.com/PacktPublishing/Tensorflow-2-Reinforcement-Learning-Cookbook/discussions](https://github.com/PacktPublishing/Tensorflow-2-Reinforcement-Learning-Cookbook/discussions).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我迫不及待想看到你用本书中讨论的食谱构建/创造的内容。期待在[https://github.com/PacktPublishing/Tensorflow-2-Reinforcement-Learning-Cookbook/discussions](https://github.com/PacktPublishing/Tensorflow-2-Reinforcement-Learning-Cookbook/discussions)的讨论页面上听到你的反馈。
- en: Looking forward to getting in touch with you on the discussion/issues page.
    All the best for your future endeavors!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 期待在讨论/问题页面与你取得联系。祝你未来一切顺利！
