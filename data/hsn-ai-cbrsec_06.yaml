- en: Malware Threat Detection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恶意软件威胁检测
- en: The high diffusion of malware and ransomware codes, together with the rapid
    polymorphic mutation in the different variants (polymorphic and metamorphic malware)
    of the same threats, has made traditional detection solutions based on signatures
    and hashing of image files obsolete, on which most common antivirus software is
    based.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件和勒索软件代码的广泛传播，加上同一威胁的不同变种（多态和变形恶意软件）中的快速多态变异，已使得基于图像文件签名和哈希的传统检测方案过时，而这些传统方案是大多数常见杀毒软件所依赖的。
- en: It is therefore increasingly necessary to resort to **machine learning** (**ML**)
    solutions that allow a rapid screening (**triage**) of threats, focusing attention
    on not wasting scarce resources such as a malware analyst's skills and efforts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，越来越有必要采用**机器学习**（**ML**）解决方案，这些方案可以快速筛选（**分诊**）威胁，集中精力避免浪费稀缺资源，比如恶意软件分析师的技能和精力。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing the malware analysis methodology
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍恶意软件分析方法
- en: How to tell different malware families apart
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何区分不同的恶意软件家族
- en: Decision tree malware detectors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决策树恶意软件检测器
- en: Detecting metamorphic malware with **Hidden Markov Models** (**HMMs**)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**隐马尔可夫模型**（**HMMs**）检测变种恶意软件
- en: Advanced malware detection with deep learning
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于深度学习的高级恶意软件检测
- en: Malware analysis at a glance
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恶意软件分析一瞥
- en: One of the most interesting aspects for those approaching malware analysis,
    is learning to distinguish, for example, legitimate binary files from those that
    are potentially dangerous for the integrity of the machines and the data they
    contain. We refer generically to **binary** files rather than to **executable**
    files (that is, files with extensions such as `.exe` or `.dll`), since malware
    can even hide in apparently innocuous files such as image files (files with extensions
    such as `.jpg` or `.png`).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些接触恶意软件分析的人员来说，一个最有趣的方面是学会区分，例如，合法的二进制文件与那些可能危害计算机及其数据完整性的文件。我们泛指**二进制**文件，而非**可执行**文件（即扩展名为
    `.exe` 或 `.dll` 的文件），因为恶意软件甚至可以隐藏在看似无害的文件中，如图像文件（扩展名为 `.jpg` 或 `.png` 的文件）。
- en: In the same way, even text documents (such as `.docx` or `.pdf`) can turn out
    to be **healthy carriers** or vehicles of software infections, despite their **non-executable**
    file format. Moreover, the first stage of the spread of a malware (in both the
    cases of a home PC and a company LAN) often happens by compromising the integrity
    of the files residing within the machines being attacked.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，文本文件（例如 `.docx` 或 `.pdf`）也可能成为**健康载体**或软件感染的传播媒介，尽管它们的**非可执行**文件格式。此外，恶意软件传播的第一阶段（无论是在家庭PC还是公司局域网中）通常通过破坏被攻击计算机内部文件的完整性来实现。
- en: Therefore, it is of fundamental importance to be able to effectively identify
    the presence of malicious software, in order to prevent, or at least limit, its
    dissemination within an organization.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，能够有效地识别恶意软件的存在至关重要，以便预防或至少限制其在组织内的传播。
- en: The following are the analysis strategies (and related tools) that are commonly
    used to conduct a preliminary survey of files and software disseminated *in the
    wild* (via counterfeit links, spam emails, phishing, and others), in order to
    identify those that are potentially dangerous.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是常用的分析策略（及相关工具），用于对通过假冒链接、垃圾邮件、钓鱼等方式传播的文件和软件进行初步调查，以识别那些潜在危险的文件。
- en: To achieve this goal, we will have to examine the traditional methods of static
    and dynamic malware analysis more closely.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一目标，我们需要更深入地审视传统的静态和动态恶意软件分析方法。
- en: Artificial intelligence for malware detection
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于恶意软件检测的人工智能
- en: With the almost exponential increase in the number of threats associated with
    the daily spread of new malware, it is practically impossible to think of dealing
    with these threats effectively using only the analysis conducted by **human**
    operators.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 随着与新恶意软件每日传播相关的威胁数量几乎呈指数级增长，单纯依靠**人工**操作员进行分析，几乎不可能有效应对这些威胁。
- en: Therefore, it is necessary to introduce algorithms that allow us to at least
    automate the preparatory phase of malware analysis (known as triage, deriving
    from the same practice adopted by doctors during the First World War, and consists
    of selecting for treatment the wounded that are most likely to survive). That
    is to say, conducting a preliminary screening of the malware to be analyzed by
    the malware analyst allows them to respond in a timely and effective manner to
    real cyber threats.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有必要引入一些算法，至少能够自动化恶意软件分析的准备阶段（称为分诊，源自第一次世界大战中医生采用的相同实践，目的是选择最有可能生还的伤员进行治疗）。也就是说，通过对待分析的恶意软件进行初步筛选，可以使恶意软件分析师及时有效地应对真实的网络威胁。
- en: These algorithms actually take the form of the adoption of AI tools, given the
    dynamism that—by definition—characterizes cybersecurity. In fact, it is necessary
    that the machines can respond effectively, adapting themselves to the contextual
    changes related to the spread of unprecedented threats.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算法实际上是采用AI工具的形式，考虑到网络安全的动态性，AI工具被定义为具备适应能力。事实上，机器需要能够有效应对，并适应与前所未有的威胁传播相关的上下文变化。
- en: This not only implies that the analyst manipulates the tools and methods of
    malware analysis (which is obvious), but that they can also interpret the behavior
    of the algorithms, being aware of the choices that the machine has adopted.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅意味着分析师操作恶意软件分析的工具和方法（这显而易见），还意味着他们能够解读算法的行为，并意识到机器所做的选择。
- en: The malware analyst is, therefore, called to understand the logic followed by
    ML, intervening (directly or indirectly) in the **fine-tuning** (refined adjustment)
    of the relevant learning procedures, based on the results obtained from the automated
    analysis.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，恶意软件分析师需要理解机器学习所遵循的逻辑，并在自动化分析结果的基础上（直接或间接地）参与**微调**（精细调整）相关的学习过程。
- en: Malware goes by many names
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恶意软件有许多不同的名称
- en: There are many types of malware, and every day new forms of threat arise that
    creatively reutilize previous forms of attack, or adopt radically new compromising
    strategies that exploit specific characteristics of the target organization (in
    the case of **Advanced Persistent Threats** (**APTs**), these are tailored forms
    of attack that perfectly adapt themselves to the target victim). This is only
    limited to the imagination of the attacker.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件的类型繁多，每天都有新的威胁形式出现，这些新威胁巧妙地重新利用了以往的攻击方式，或者采用了完全新的危害策略，利用目标组织的特定特点（在**高级持续性威胁**（**APTs**）中，这些是量身定制的攻击形式，完美地适应目标受害者）。这一切仅受攻击者想象力的限制。
- en: 'However, it is possible to compile a classification of the most common types
    of malware, in order to understand which are the most effective measures of prevention,
    and contrast their effectiveness for dealing with each malware species:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可以编制出最常见恶意软件类型的分类，以便了解哪些是最有效的预防措施，并对它们在应对每种恶意软件时的有效性进行对比：
- en: '**Trojans**: Executables that appear as legitimate and harmless, but once they
    are launched, they execute malicious instructions in the background'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Trojans**：看似合法且无害的可执行文件，但一旦启动，它们会在后台执行恶意指令'
- en: '**Botnets**: Malware that has the goal of compromising as many possible hosts
    of a network, in order to put their computational capacity at the service of the
    attacker'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Botnets**：一种旨在危害尽可能多主机的恶意软件，通过控制网络中的主机，将其计算能力服务于攻击者'
- en: '**Downloaders**: Malware that downloads malicious libraries or portions of
    code from the network and executes them on victim hosts'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Downloaders**：恶意软件，从网络上下载恶意库或代码片段，并在受害者主机上执行它们'
- en: '**Rootkits**: Malware that compromises the hosts at the operating system level
    and, therefore, often come in the form of device drivers, making the various countermeasures
    (such as antiviruses installed on the endpoints) ineffective'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rootkits**：一种在操作系统层面危害主机的恶意软件，因此通常以设备驱动程序的形式出现，使得各种反制措施（例如安装在终端上的杀毒软件）变得无效'
- en: '**Ransomwares**: Malware that proceeds to encrypt files stored inside the host
    machines, asking for a ransom from the victim (often to be paid in Bitcoin) to
    obtain the decryption key which is used for recovering the original files'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ransomwares**：恶意软件，它会加密存储在主机机器上的文件，并要求受害者支付赎金（通常是比特币）以获取解密密钥，用于恢复原始文件'
- en: '**APTs**: APTs are forms of tailored attacks that exploit specific vulnerabilities
    on the victimized hosts'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**APT（高级持续性威胁）**：APT是利用受害主机上特定漏洞进行定制化攻击的一种形式。'
- en: '**Zero days (0 days)**: Malware that exploits vulnerabilities not yet disclosed
    to the community of researchers and analysts, whose characteristics and impacts
    in terms of security are not yet known, and therefore go undetected by antivirus
    software'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**零日（0天）**：利用尚未公开给研究人员和分析师社区的漏洞的恶意软件，其特征和安全影响尚未为人所知，因此无法被杀毒软件检测到。'
- en: Obviously, these different types of threats can be amplified by the fact that
    they can mix together in the same malicious file (for example, a seemingly harmless
    Trojan becomes a real threat, as it behaves like a downloader once executed, connecting
    to the network and downloading malicious software, such as rootkits, which compromises
    the local network and turns it into a botnet).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这些不同类型的威胁可能会因为它们能在同一个恶意文件中混合在一起而被放大（例如，一个看似无害的木马一旦执行后变成真正的威胁，它作为下载程序连接到网络并下载恶意软件，如rootkit，进而危害本地网络并将其转化为僵尸网络）。
- en: Malware analysis tools of the trade
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行业内的恶意软件分析工具
- en: 'Many of the tools commonly used for conducting malware analysis can be categorized
    as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 常用的恶意软件分析工具可以按以下方式分类：
- en: Disassemblers (such as Disasm and IDA)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反汇编工具（如Disasm和IDA）
- en: Debuggers (such as OllyDbg, WinDbg, and IDA)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试工具（如OllyDbg、WinDbg和IDA）
- en: System monitors (such as Process Monitor and Process Explorer)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统监控工具（如Process Monitor和Process Explorer）
- en: Network monitors (such as TCP View, Wireshark, and tcpdump)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络监控工具（如TCP View、Wireshark和tcpdump）
- en: Unpacking tools and Packer Identifiers (such as PEiD)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解包工具和打包器识别工具（如PEiD）
- en: Binary and code analysis tools (such as PEView, PE Explorer, LordPE, and ImpREC)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制和代码分析工具（如PEView、PE Explorer、LordPE和ImpREC）
- en: Malware detection strategies
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恶意软件检测策略
- en: Obviously, every type of threat requires a specific detection strategy. In this
    section, we will see the analysis methods traditionally used in malware detection
    that are conducted manually by malware analysts. They provide a more detailed
    understanding of the phases of the analysis that can be improved and made more
    efficient by the introduction of AI algorithms, thus freeing the human analyst
    from the most repetitive or overwhelming tasks and allowing them to concentrate
    on the most peculiar or unusual aspects of the analysis.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，每种类型的威胁都需要特定的检测策略。在本节中，我们将介绍传统上由恶意软件分析师手动执行的恶意软件检测分析方法。这些方法提供了对分析阶段的更详细理解，可以通过引入AI算法来提高效率，进而减轻人工分析师的重复性或繁重任务，让他们专注于分析中最特殊或最不寻常的方面。
- en: It should be emphasized that the development of malware software is the result
    of a creative activity carried out by the attacker, and as such is not easily
    ascribable to preestablished schemes or prefixed modalities. In the same way,
    the malware analyst must resort to all their imaginative resources, as well as
    developing unconventional procedures, in order to be able to stay in front of
    the attacker in a sort of *cat and mouse game*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 应当强调的是，恶意软件的开发是攻击者进行的创造性活动的结果，因此，难以归类为预设的模式或固定的方式。同样，恶意软件分析师必须依靠所有的创造性资源，并开发非常规程序，以便在一种*猫鼠游戏*中始终领先于攻击者。
- en: Malware analysis should therefore be regarded more as an art than a science,
    and as such, it demands the analyst's ability to always imagine new ways of detection
    to identify future threats on time. Consequently, the malware analyst is called
    to continually update not only their technical skills, but also their investigation
    methods.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，恶意软件分析应被视为一种艺术而非科学，因此，它要求分析师能够不断地想出新的检测方法，以便及时识别未来的威胁。因此，恶意软件分析师需要不断更新他们的技术技能，并改进他们的调查方法。
- en: The fact remains that it is possible to start the detection activity by resorting
    to common practices of analysis, especially to detect the presence of known threats.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，确实可以通过采取常见的分析方法来启动检测活动，特别是用于检测已知威胁的存在。
- en: 'To this end, among the most common malware detection activities, we can include
    the following malware detection activities:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，在最常见的恶意软件检测活动中，我们可以包括以下恶意软件检测活动：
- en: '**Hashes file calculation**: To identify known threats already present in the
    knowledge base'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**哈希文件计算**：用于识别已经存在于知识库中的已知威胁'
- en: '**System monitoring**: To identify anomalous behavior of both the hardware
    and the operating system (such as an unusual increase in CPU cycles, a particularly
    heavy disk writing activity, changes to the registry keys, and the creation of
    new and unsolicited processes in the system)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统监控**：识别硬件和操作系统的异常行为（例如，CPU周期的异常增加、特别大的磁盘写入活动、注册表项的变化，以及在系统中创建新的和未经请求的进程）'
- en: '**Network monitoring**: To identify anomalous connections established by host
    machines to remote destinations'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络监控**：识别主机机器与远程目的地之间建立的异常连接'
- en: These detection activities can be easily automated by using specific algorithms,
    as we will see shortly after having examined malware analysis methodologies.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些检测活动可以通过使用特定的算法轻松实现自动化，正如我们将在稍后讨论恶意软件分析方法时所看到的。
- en: Static malware analysis
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态恶意软件分析
- en: The first step in malware analysis begins with the evaluation of the presence
    of suspect artifacts in binary files, without actually running (executing) the
    code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件分析的第一步是评估二进制文件中可疑构件的存在，而无需实际运行（执行）代码。
- en: The complexity of techniques used in this phase goes under the name of **static
    malware analysis**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该阶段使用的技术的复杂性被称为**静态恶意软件分析**。
- en: 'Static malware analysis consists of the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 静态恶意软件分析包括以下内容：
- en: Identifying the objectives considered of interest for the analysis
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别被认为对分析有价值的目标
- en: Understanding the flow of executable instructions
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解可执行指令的流
- en: Identifying known patterns and associating them to possible malware (also known
    as **malware detection**)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别已知的模式并将其与可能的恶意软件关联（也称为**恶意软件检测**）
- en: 'To this end, analysis tools and procedures are used in order to perform the
    following functions:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，分析工具和程序被用于执行以下功能：
- en: Identifying calls to system APIs
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别对系统API的调用
- en: Decoding and manipulating string data for obtaining sensitive information (for
    example, domain names and IP addresses)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解码和操作字符串数据以获取敏感信息（例如，域名和IP地址）
- en: Detecting the presence and invocation by downloading other malware codes (for
    example, **Command and Control** (**C2**), backdoors, and reverse shells)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过下载其他恶意代码检测恶意软件的存在和调用（例如，**命令与控制**（**C2**）、后门和反向Shell）
- en: Static analysis methodology
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态分析方法
- en: The methodology used by static malware analysis consists of the examination
    of the machine instructions (assembly instructions) present in the disassembled
    binary image of the malware (malware disassembly), in order to identify its harmful
    potentialities and evaluate the external characteristics of the binary code, before
    proceeding with its execution.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 静态恶意软件分析采用的方法是检查恶意软件反汇编二进制镜像中的机器指令（汇编指令），以识别其潜在危害，并评估二进制代码的外部特征，然后再进行执行。
- en: Difficulties of static malware analysis
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态恶意软件分析的难点
- en: Among the most insidious aspects of static malware analysis are the difficulties
    in determining the correctness of the malware disassembly. Given the increasingly
    widespread presence of anti-analysis techniques, it is not always possible to
    assume that the disassembled binary image produced by the disassembler is reliable.
    Therefore, the analyst must conduct a preliminary analysis, in order to detect,
    for example, the presence of packers that encrypt portions of executable code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 静态恶意软件分析中最狡猾的方面之一是确定恶意软件反汇编的正确性存在困难。鉴于反分析技术的日益普及，不能总是假设反汇编器生成的反汇编二进制镜像是可靠的。因此，分析员必须进行初步分析，以检测例如，存在加密可执行代码部分的打包器。
- en: Such preliminary analysis procedures are often overlooked by analysts because
    they are expensive in terms of time required; nevertheless, they are indispensable
    for circumscribing relevant goals to be carried out.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些初步分析程序常常被分析员忽视，因为它们在所需时间上非常昂贵；然而，它们对于限定需要执行的相关目标是不可或缺的。
- en: In addition, if the presence of portions of executable code is not correctly
    detected (perhaps because they are hidden within data that is considered **harmless**,
    such as resources representing images), this deficiency can undermine the subsequent
    phases of dynamic analysis, making it impossible to identify the exact type of
    malware being investigated.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果无法正确检测到可执行代码的部分（可能是因为它们隐藏在被认为是**无害**的数据中，例如表示图像的资源），这一缺陷可能会破坏后续的动态分析阶段，使得无法识别正在调查的恶意软件的确切类型。
- en: How to perform static analysis
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何进行静态分析
- en: 'Once you have verified that the disassembled malware is reliable, it is possible
    to proceed in different ways: each analyst, in fact, follows their own preferred
    strategy, which is based on the experience and objectives they intend to pursue.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦验证反汇编后的恶意软件是可靠的，就可以采用不同的方式继续：每个分析员实际上都遵循自己首选的策略，这些策略基于他们的经验和他们打算追求的目标。
- en: 'In principle, the adoptable strategies are as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，可采纳的策略如下：
- en: Analyze the binary instructions in a systematic way, without executing them.
    It is an effective technique for limited portions of code that become complicated
    in cases of large malware, as the analyst must a keep trace of the status of the
    data for each instruction analyzed.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以系统化的方式分析二进制指令，而不执行它们。这是一种有效的技术，适用于代码的有限部分，在大规模恶意软件的情况下变得复杂，因为分析员必须跟踪每条指令分析时的数据状态。
- en: Scan the instructions to look for sequences that are considered to be of interest,
    setting breakpoints and partially executing the program up to the breakpoint,
    and then examining the status of the program at that point. This approach is often
    used to determine the presence of system calls deemed dangerous, based on the
    sequence in which these calls are invoked (for example, the sequence consisting
    of connecting to the network, creating a file, and modifying the system registry
    is one of the most common sequences of invocations of system APIs used by malware
    downloaders).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描指令，寻找被认为有意义的序列，设置断点并部分执行程序直到断点，然后检查此时程序的状态。这种方法通常用于确定被认为危险的系统调用的存在，基于这些调用的调用顺序（例如，连接到网络、创建文件和修改系统注册表的序列是恶意软件下载程序最常见的系统
    API 调用序列之一）。
- en: In the same way, it is possible to detect the absence of certain API calls.
    A code that does not present invocations to the system calls (for example, network-related
    calls), which is necessary for issuing network connections, cannot obviously represent
    a backdoor (but it could act, for example, as a keylogger, because it calls the
    sequence of system APIs to detect the keys pressed on the keyboard and write to
    disk).
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，也可以检测某些 API 调用的缺失。一个没有调用系统函数（例如与网络相关的函数）的代码，显然无法代表一个后门（但它可能充当键盘记录器，例如，它调用系统
    API 序列来检测按下的键，并将其写入磁盘）。
- en: Search for sensitive information (such as domain names and IP addresses) in
    a string format inside the disassembled image. Also, in this case, it is possible
    to set debugger breakpoints in correspondence with the network calls and detect
    any domain names or remote IP addresses that get contacted by the malware when
    connecting to the internet.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在反汇编图像中查找敏感信息（如域名和 IP 地址）字符串格式。同样，在这种情况下，可以在与网络调用对应的位置设置调试器断点，并检测恶意软件连接到互联网时所联系的任何域名或远程
    IP 地址。
- en: Hardware requirements for static analysis
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态分析的硬件要求
- en: Unlike dynamic analysis, static analysis usually requires fewer specific resources
    in terms of hardware, since, in principle, the analyst does not execute the malicious
    code under analysis.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与动态分析不同，静态分析通常在硬件方面需要较少的特定资源，因为原则上分析员不会执行正在分析的恶意代码。
- en: As we will see, in the case of dynamic malware analysis, non-trivial hardware
    requirements may be required, and in some cases it is not enough to use virtual
    machines. This is due to the presence of countermeasures (anti-analysis tricks)
    implemented by the malware, which prevent the execution of the code if the presence
    of a virtual machine is detected.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，在动态恶意软件分析的情况下，可能需要非凡的硬件要求，有时仅使用虚拟机是不够的。这是由于恶意软件实施的反分析措施（反分析技巧），如果检测到虚拟机的存在，就会阻止代码的执行。
- en: Dynamic malware analysis
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态恶意软件分析
- en: 'As we have seen, the specific features of static malware analysis consist of
    the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，静态恶意软件分析的具体特征包括以下几点：
- en: Verify that a given binary file is actually malicious.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证给定的二进制文件是否真的具有恶意性质。
- en: Identify as much information as possible about the binary file, without launching
    the execution and conducting the analysis on the basis of the characteristics
    that can be retracted, such as characteristics from the file format or from the
    resources stored in it.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不启动执行的情况下，尽可能识别二进制文件的更多信息，并基于可以回溯的特征（如文件格式特征或存储在其中的资源特征）进行分析。
- en: Catalog the suspicious binary file by calculating its hash, which constitutes
    its signature (this signature can also be shared within the malware analysts community,
    in order to update the overall knowledge base of malware threats).
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过计算可疑二进制文件的哈希值来对其进行目录编制，哈希值即该文件的签名（这个签名也可以在恶意软件分析师社区中共享，以便更新恶意软件威胁的整体知识库）。
- en: Without a doubt, static malware analysis, although rapid to conduct, presents
    a series of methodological limitations, especially when it comes to analyzing
    sophisticated types of malware (such as APT and polymorphic malware). One of the
    remedies to these methodological limits consists of combining it with dynamic
    malware analysis, in an attempt to understand the nature and type of malware being
    analyzed in more depth.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 毫无疑问，静态恶意软件分析虽然快速，但存在一系列方法学上的局限性，特别是在分析复杂类型的恶意软件（如APT攻击和变种恶意软件）时。这些方法学上的局限性的一种解决方法是将其与动态恶意软件分析结合，以期更深入地理解所分析的恶意软件的性质和类型。
- en: The distinctive character of the dynamic malware analysis is the fact that,
    unlike the static malware analysis, the binary file gets executed (often in isolated
    and protected environments, known as **malware analysis labs**, which make use
    of sandboxes and virtual machines to prevent the wide spread of malware in the
    corporate network).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 动态恶意软件分析的独特之处在于，与静态恶意软件分析不同，二进制文件需要被执行（通常是在隔离和保护的环境中进行，称为**恶意软件分析实验室**，这些环境利用沙箱和虚拟机来防止恶意软件在企业网络中广泛传播）。
- en: Therefore, this strategy entails analyzing the **dynamic** behavior, that is,
    verifying, for example, that the malicious executable does not download malicious
    libraries or portions of code (payloads) from the internet, or proceeds to modify
    its own executable instructions at each execution, thus making the signature-based
    detection procedures (used by the antiviruses) ineffective.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这一策略涉及到分析**动态**行为，也就是说，例如验证恶意可执行文件是否从互联网下载恶意库或代码片段（有效载荷），或者是否每次执行时都会修改自身的可执行指令，从而使基于签名的检测程序（例如杀毒软件使用的方式）失效。
- en: Anti-analysis tricks
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反分析技巧
- en: The countermeasures usually adopted by malware developers, which prevent malware
    analysis or make it more difficult, rely on encryption of the payloads, the use
    of packers, of downloaders, and others.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件开发者通常采取的对策是加密有效载荷，使用加壳工具、下载器等，这些措施可以防止恶意软件分析或使其变得更加困难。
- en: 'These tricks are normally detectable with dynamic malware analysis; however,
    even dynamic malware analysis suffers from limitations related to the use of virtual
    machines—for example—whose presence can be easily detected by malware by exploiting
    some execution tricks, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技巧通常可以通过动态恶意软件分析来检测；然而，即使是动态恶意软件分析，也存在一些局限性，尤其是当使用虚拟机时——例如，恶意软件可以通过利用某些执行技巧轻松检测虚拟机的存在，具体如下：
- en: 'Execution of instructions that expect a default behavior: The malware can calculate
    the time that elapses in the execution of certain operations, and if these were
    performed more slowly than expected, it can deduce consequently that the execution
    takes place on a virtual machine.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行期望默认行为的指令：恶意软件可以计算执行某些操作时所花费的时间，如果这些操作执行得比预期的慢，它可以推断执行环境为虚拟机。
- en: 'Hardware-based virtual machine detection: Through the execution of some specific
    instructions at the hardware level (for example, the instructions that access
    CPU-protected registers, such as `sldt`*,* `sgdt`*,* and`sidt`).'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于硬件的虚拟机检测：通过执行一些特定的硬件级别指令（例如，访问CPU保护寄存器的指令，如`sldt`*、`sgdt`*和`sidt`）。
- en: Accessing certain registry keys such as `HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Disk\Enum`.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问某些注册表键值，如`HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Disk\Enum`。
- en: When the malware detects the presence of a virtual machine, it stops working
    in the expected way, evading attempts for it to be detected by analysts.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当恶意软件检测到虚拟机的存在时，它会停止按预期的方式工作，从而逃避分析人员的检测。
- en: Getting malware samples
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取恶意软件样本
- en: In the course of our analysis, we will refer mainly to the malware codes developed
    for the Microsoft Windows platform, as we have a considerable amount of examples
    available, given the popularity of this platform.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的分析过程中，我们主要参考为微软Windows平台开发的恶意软件代码，因为考虑到该平台的普及，我们有大量的样本可以使用。
- en: 'Anyway, a question often asked is: where can we get malware samples from?'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，一个常见的问题是：我们可以从哪里获得恶意软件样本？
- en: 'There are several sources available online from which to download malware examples,
    include the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个在线资源可以下载恶意软件样本，包括以下几个：
- en: '*MALWARE-TRAFFIC-ANALYSIS.NET*: [https://www.malware-traffic-analysis.net/](https://www.malware-traffic-analysis.net/)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*MALWARE-TRAFFIC-ANALYSIS.NET*: [https://www.malware-traffic-analysis.net/](https://www.malware-traffic-analysis.net/)'
- en: '*VIRUSTOTAL*: [https://www.virustotal.com](https://www.virustotal.com)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*VIRUSTOTAL*: [https://www.virustotal.com](https://www.virustotal.com)'
- en: '*VirusShare*: [https://virusshare.com](https://virusshare.com)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*VirusShare*: [https://virusshare.com](https://virusshare.com)'
- en: '*theZoo*: [https://github.com/ytisf/theZoo](https://github.com/ytisf/theZoo)
    (defined by the authors as *a repository of live malware for your own joy and
    pleasure*)'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*theZoo*: [https://github.com/ytisf/theZoo](https://github.com/ytisf/theZoo)（作者定义为*为您的乐趣和享受提供的活跃恶意软件库*）'
- en: It is also possible to create your own sample datasets, by acquiring malware
    samples in the wild through the configuration of a honeypot (or even simply collecting
    the spam messages received in your own email accounts).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过配置蜜罐（甚至只是收集自己电子邮件账户中收到的垃圾邮件）来获取恶意软件样本，进而创建自己的样本数据集。
- en: Once we have our malware dataset, it will be necessary to proceed to the preliminary
    analysis of their characteristics, taking advantage of the scripts that automate
    the activities of malware analysis.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了恶意软件数据集，就有必要进行初步的特征分析，利用自动化恶意软件分析活动的脚本。
- en: As we anticipated, in our analysis, we will focus on malware codes developed
    for the Microsoft Windows platform. To proceed further in our analysis, we need
    to understand the executable file format adopted by this platform, which is known
    as the **Portable Executable** (**PE**) file format.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们预期的，在我们的分析中，我们将重点关注为微软Windows平台开发的恶意软件代码。为了进一步进行分析，我们需要了解该平台采用的可执行文件格式，这就是所谓的**便携式可执行文件**（**PE**）格式。
- en: Every executable file of the Microsoft platform, whether it is a file with the `.exe`,
    `.dll`, or `.sys` extension (in the case of device drives), in order to be loaded
    into runtime memory and then executed by the Windows OS, must comply with the
    necessary specification contained in the PE file format.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个微软平台的可执行文件，无论是`.exe`、`.dll`还是`.sys`扩展名的文件（在设备驱动程序的情况下），为了能够加载到运行时内存中并由Windows操作系统执行，必须遵循PE文件格式中包含的必要规范。
- en: We will examine this file format shortly, illustrating how to extract the features
    stored in the PE file format from the executable files, in order to create a dataset
    of **artifacts** that will be used to train our AI algorithms.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快检查这一文件格式，演示如何从可执行文件中提取存储在PE文件格式中的特征，以便创建一个**数据集**，该数据集将用于训练我们的AI算法。
- en: Hacking the PE file format
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 破解PE文件格式
- en: In our analysis of the PE file format, we will make use of **PEView** (available
    online at [http://wjradburn.com/software/PEview.zip](http://wjradburn.com/software/PEview.zip)),
    which is a very simple but effective tool for visualizing **PE structures**. As
    we said, PE is the standard file format of binary images that get executed on
    a Windows OS.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对PE文件格式的分析中，我们将使用**PEView**（在线提供，网址为[http://wjradburn.com/software/PEview.zip](http://wjradburn.com/software/PEview.zip)），这是一个非常简单但有效的工具，用于可视化**PE结构**。正如我们所说，PE是Windows操作系统上执行的二进制镜像的标准文件格式。
- en: In fact, when the **Windows OS loader** loads executables (not limited to `.exe`,
    but also including `.dll` and `.sys`) in runtime memory, it executes the loading
    directives found in the **PE sections** for the binary image to be loaded.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当**Windows操作系统加载程序**将可执行文件（不仅限于`.exe`，还包括`.dll`和`.sys`）加载到运行时内存中时，它会执行PE部分中找到的加载指令，以便加载二进制镜像。
- en: As such, PE file format artifacts remain one of the **main targets** for malware
    developers and virus writers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，PE文件格式的工件仍然是恶意软件开发人员和病毒编写者的**主要目标**之一。
- en: The PE file format as a potential vector of infection
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PE文件格式作为潜在的感染向量
- en: As we will see, PE executables have multiple sections included in the binary
    file image, and this characteristic can be exploited to hide malicious software.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，PE可执行文件在二进制文件镜像中包含多个部分，这一特性可以被利用来隐藏恶意软件。
- en: In fact, each of the PE sections can be thought of as a folder, hosting various
    binary objects (ranging from graphics files to encrypted libraries), that gets
    executed and/or decrypted at runtime, potentially infecting other executables
    on the same machine or remote machines on the network.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，每个 PE 段可以被视为一个文件夹，托管各种二进制对象（从图形文件到加密库），这些对象会在运行时执行和/或解密，可能感染同一台计算机上的其他可执行文件或网络上的远程计算机。
- en: For instance, a PE section may contain a `.sys` (malicious driver) file that
    is aimed at compromising the kernel, along with a startup file containing configuration
    parameters, or remote links the binary can connect to, in order to download other
    activation artifacts, C2 backdoors, and others.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，PE 段可能包含一个 `.sys`（恶意驱动程序）文件，旨在危害内核，以及一个包含配置参数的启动文件，或二进制文件可以连接的远程链接，以便下载其他激活工件、C2
    后门等。
- en: Overview of the PE file format
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PE 文件格式概述
- en: PE specification is derived from the Unix **Common Object File Format** (**COFF**)
    and it is basically a **data structure** that covers the information necessary
    for the Windows **OS loader** to manage the executable image, that is, when its
    structures get mapped into runtime memory before getting executed by the OS.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: PE 规范源自于 Unix **通用对象文件格式** (**COFF**)，它基本上是一个 **数据结构**，涵盖了 Windows **操作系统加载器**
    管理可执行映像所需的信息，也就是说，当其结构映射到运行时内存中并被操作系统执行时。
- en: Simply put, a PE file consists of a **PE file header** and a **section table**
    (section headers), followed by the **sections' data**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，PE 文件由 **PE 文件头** 和 **段表**（段头）组成，接着是 **段数据**。
- en: 'The **PE file header** is encapsulated in the Windows **NT header** structure
    (defined in the `winnt.h` header file, along with other C structures) and is composed
    of the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**PE 文件头** 被封装在 Windows **NT 头** 结构中（在 `winnt.h` 头文件中定义，连同其他 C 结构），并由以下内容组成：'
- en: MS DOS header
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MS DOS 头
- en: The PE signature
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PE 签名
- en: The image file header
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映像文件头
- en: An optional header
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选头
- en: 'The **file headers** are followed by **section headers**:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件头** 后面跟着 **段头**：'
- en: '![](img/791469ac-0935-42cf-bbdf-8b74aa71845b.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/791469ac-0935-42cf-bbdf-8b74aa71845b.png)'
- en: 'Image credits: https://commons.wikimedia.org/wiki/File:RevEngPEFile.JPG'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来源：https://commons.wikimedia.org/wiki/File:RevEngPEFile.JPG
- en: The **section header** provides information about its associated section, including
    location, length, and characteristics. A section is the basic unit of code or
    data within a PE file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**段头** 提供有关其关联段的信息，包括位置、长度和特性。一个段是 PE 文件中代码或数据的基本单位。'
- en: Different functional areas, such as code and data areas, are logically separated
    into sections.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的功能区域，如代码区和数据区，逻辑上被分隔成多个段。
- en: In addition, an image file can contain a number of sections, such as `.tls`
    and `.reloc`, which have special purposes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个映像文件可以包含多个段，如 `.tls` 和 `.reloc`，这些段有特殊用途。
- en: The section header provides information about its associated section. The most
    common sections in executables are text, data, RSRC, RData, and RELOC.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 段头提供有关其关联段的信息。可执行文件中最常见的段包括文本、数据、RSRC、RData 和 RELOC。
- en: 'Most Windows executables contain resources: a general term that refers to objects
    such as cursors, icons, bitmaps, menus, and fonts. A PE file can contain a resource
    directory for all of the resources that the program code in that file uses.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Windows 可执行文件包含资源：这是一个通用术语，指代像光标、图标、位图、菜单和字体等对象。PE 文件可以包含一个资源目录，包含该文件中的程序代码所使用的所有资源。
- en: Malware rarely uses graphical resources, so the total number of their resources
    is relatively fewer than that of benign software.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件很少使用图形资源，因此它们的资源总数相对于良性软件较少。
- en: Many fields of PE file have no mandatory constraint. There are a number of redundant
    fields and spaces in PE files that could create opportunities for malware hiding.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: PE 文件的许多字段没有强制约束。PE 文件中有许多冗余字段和空白，这可能为恶意软件隐藏创造机会。
- en: In the following screenshot, we execute PEView and load its `.exe` image into
    memory; the Tools section shows the various sections of its PE format.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下截图中，我们执行 PEView 并将其 `.exe` 映像加载到内存中；工具部分显示了其 PE 格式的各个段。
- en: 'We have also outlined the special `e_magic` field of the DOS header, which
    usually contains the MZ character sequence (corresponding to the byte sequence
    `"0x4D 0x5A"`), and the special `Signature` field of the PE header (defined as the `IMAGE_NT_HEADERS`
    structure), which contains the **PE** character sequence, and states that that
    the binary file is a native Windows executable:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还概述了DOS头的特殊`e_magic`字段，通常包含MZ字符序列（对应的字节序列是`"0x4D 0x5A"`），以及PE头的特殊`Signature`字段（定义为`IMAGE_NT_HEADERS`结构），其中包含**PE**字符序列，表示该二进制文件是一个原生Windows可执行文件：
- en: '![](img/1f23d73c-333e-4b11-ba01-1a0d52b93cd0.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f23d73c-333e-4b11-ba01-1a0d52b93cd0.png)'
- en: The DOS header and DOS stub
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DOS头和DOS存根
- en: The DOS header is only used for backward compatibility, and precedes the DOS
    stub that displays an error message stating that the program might not run in
    DOS mode.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: DOS头仅用于向后兼容，并且位于显示错误信息的DOS存根之前，提示程序可能无法在DOS模式下运行。
- en: As per the official PE documentation (available at [https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format#ms-dos-stub-image-only](https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format#ms-dos-stub-image-only)),
    the MS-DOS stub enables Windows to properly execute the image file, even though
    it has an MS-DOS stub.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方PE文档（可在[https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format#ms-dos-stub-image-only](https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format#ms-dos-stub-image-only)查看），MS-DOS存根使得Windows能够正确执行该镜像文件，即使它包含一个MS-DOS存根。
- en: It is placed at the front of the `EXE` image and prints out the message, `This
    program cannot be run in DOS mode`, when the image is run in MS-DOS.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 它位于`EXE`镜像的前面，并在镜像以MS-DOS模式运行时显示消息`该程序无法在DOS模式下运行`。
- en: 'The DOS header includes some fields for backward compatibility, and is defined
    as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: DOS头包括一些用于向后兼容的字段，定义如下：
- en: '[PRE0]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The PE header structure
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PE头结构
- en: After the DOS header and DOS stub, we find the PE header.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在DOS头和DOS存根之后，我们会找到PE头。
- en: 'The PE header contains information about different sections used to store code
    and data, along with the requested imports from other libraries (DLLs) or the
    exports provided, in case the module is actually a library. Take a look at the
    following structure of the PE header:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: PE头包含关于不同部分的信息，这些部分用于存储代码和数据，以及请求的其他库（DLL）中的导入项或提供的导出项，以防该模块实际上是一个库。请查看以下PE头结构：
- en: '[PRE1]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `FileHeader` structure field describes the format of the file (that is,
    contents, symbols, and more), and its type is defined in the following structure:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileHeader`结构字段描述文件的格式（即内容、符号等），其类型在以下结构中定义：'
- en: '[PRE2]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `OptionalHeader` field contains information about the executable module,
    including the required OS version, memory requirements, and the `itsentry` point
    (that is, the relative memory address where the actual execution starts from):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`OptionalHeader`字段包含有关可执行模块的信息，包括所需的操作系统版本、内存要求和`itsentry`点（即实际执行开始的相对内存地址）：'
- en: '[PRE3]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The special `AddressOfEntryPoint` field included in `OptionalHeader` states
    the executable entry point, which is usually set at the relative memory address
    of `0x1000`, as we can see outlined in the following screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`OptionalHeader`中包含的特殊`AddressOfEntryPoint`字段指定了可执行文件的入口点，通常设置为`0x1000`的相对内存地址，如下截图所示：'
- en: '![](img/d337fac7-7e73-4713-9f78-d871b7a008d6.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d337fac7-7e73-4713-9f78-d871b7a008d6.png)'
- en: The data directory
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据目录
- en: 'The `DataDirectory` structure field contains `IMAGE_NUMBEROF_DIRECTORY_ENTRIES`
    entries that define the logical components of the module. The relative entries
    are numbered and defined as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataDirectory`结构字段包含`IMAGE_NUMBEROF_DIRECTORY_ENTRIES`条目，定义了模块的逻辑组件。相对条目按编号并定义如下：'
- en: '![](img/0348d00d-a9ec-4d0f-a320-2cba59b8e3ed.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0348d00d-a9ec-4d0f-a320-2cba59b8e3ed.png)'
- en: Import and export tables
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入和导出表
- en: 'The import table lists all of the symbols that need to be resolved and imported
    at load time from other DLLs:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 导入表列出了所有需要在加载时从其他DLL中解析和导入的符号：
- en: '![](img/3821aa0d-c2c5-4234-8752-0f224f4175eb.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3821aa0d-c2c5-4234-8752-0f224f4175eb.png)'
- en: 'Most types of benign software have a large number of entries in the import
    address table, because they have complex functions and import different Windows
    API functions from the import address table:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数类型的良性软件在导入地址表中有大量条目，因为它们有复杂的功能，并从导入地址表中导入不同的Windows API函数：
- en: '![](img/a6edc288-6116-4010-ae2c-a480ee3e42f8.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6edc288-6116-4010-ae2c-a480ee3e42f8.png)'
- en: Windows also allows programs to load and unload DLLs explicitly using `LoadLibrary`
    and `FreeLibrary`, as well as to find the addresses of symbols using `GetProcAddress`
    (exposed by `kernel32.dll`).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 还允许程序通过 `LoadLibrary` 和 `FreeLibrary` 显式加载和卸载 DLL，以及使用 `GetProcAddress`（由
    `kernel32.dll` 提供）查找符号的地址。
- en: Most types of malware use the latter approach, so that the number of symbols
    in their imports table is relatively fewer than that of benign software.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数类型的恶意软件使用后者的方法，因此它们的导入表中的符号数量比良性软件少。
- en: The exports table contains information about symbols that other PE files can
    access through dynamic linking. Exported symbols are generally found in DLL files
    and most types of malware do not have exported symbols.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 导出表包含关于其他 PE 文件可以通过动态链接访问的符号的信息。导出的符号通常位于 DLL 文件中，而大多数类型的恶意软件没有导出符号。
- en: Most types of malware load and unload DLLs explicitly using `LoadLibrary` and
    `FreeLibrary` in order to hide their malicious purposes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数类型的恶意软件通过 `LoadLibrary` 和 `FreeLibrary` 显式加载和卸载 DLL，以隐藏其恶意目的。
- en: 'However, there is one notable exception: malware usually imports `wsock32.dll`,
    while benign software rarely imports this DLL, and that explains how malware carries
    out propagation and damage through network connections.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个显著的例外：恶意软件通常会导入 `wsock32.dll`，而良性软件则很少导入这个 DLL，这解释了恶意软件如何通过网络连接进行传播和破坏。
- en: Extracting malware artifacts in a dataset
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取数据集中的恶意软件痕迹
- en: After having analyzed the PE file format, we are now ready to extract the characteristics
    of the binary files (whether legitimate or suspect), and store them in a dataset
    of artifacts with which to train our algorithms.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析完 PE 文件格式后，我们现在可以提取二进制文件（无论是合法的还是可疑的）的特征，并将它们存储在一个痕迹数据集中，用于训练我们的算法。
- en: For this purpose, we will develop Python scripts to automate the extraction
    of PE file format fields for each single file we analyze.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将开发 Python 脚本，以自动化提取我们分析的每个文件的 PE 文件格式字段。
- en: The Python library that we will use in our scripts is the famous `pefile` library,
    which was developed by Ero Carrera and is available at [https://github.com/erocarrera/pefile](https://github.com/erocarrera/pefile).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在脚本中使用的 Python 库是著名的 `pefile` 库，该库由 Ero Carrera 开发，并可在 [https://github.com/erocarrera/pefile](https://github.com/erocarrera/pefile)
    上获取。
- en: 'Once the archive containing the library has been downloaded and unpacked locally,
    we can proceed with the installation by executing the following command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦包含库的压缩包下载并解压到本地，我们可以执行以下命令来进行安装：
- en: '[PRE4]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If, instead, we have created an environment in Anaconda following the instructions
    of the previous chapters, we can install the `pefile` library with the following
    command (assuming that the environment is called `py35`):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按照前几章的说明在 Anaconda 中创建了一个环境，那么我们可以通过以下命令安装 `pefile` 库（假设环境名为 `py35`）：
- en: '[PRE5]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this way, we will be able to recall the functions of the library, even inside
    our Jupyter Notebooks.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们将能够在 Jupyter Notebooks 中调用该库的函数。
- en: 'After having fed our malware dataset, as previously discussed, we can proceed
    to extract the artifacts from each single file, reading the corresponding `pefile`
    format fields using the `pefile` Python library, as shown in the following script:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入我们的恶意软件数据集之后，正如之前讨论的那样，我们可以继续从每个文件中提取痕迹，使用 `pefile` Python 库读取相应的 `pefile`
    格式字段，如以下脚本所示：
- en: '[PRE6]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we uploaded the local `suspect.exe` file, which is part of our malware
    dataset.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们上传了本地的 `suspect.exe` 文件，这是我们恶意软件数据集的一部分。
- en: At this point, we are able to extract the individual fields of the PE file format
    belonging to the `suspect.exe` file, by simply dereferencing the `suspect_pe`
    object.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们能够通过简单地解除引用 `suspect_pe` 对象来提取 `suspect.exe` 文件所属的 PE 文件格式的各个字段。
- en: 'Using the following script, we will extract the main fields of the PE file
    format, recalling them directly to the previously defined object:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下脚本，我们将提取 PE 文件格式的主要字段，并直接将其调用到之前定义的对象中：
- en: '[PRE7]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can then proceed to extract the artifacts from every single file contained
    within our dataset, exporting the fields into a `.csv` file.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以继续从数据集中每个文件中提取痕迹，并将字段导出到`.csv`文件中。
- en: 'The final version of our extraction script will therefore be as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终提取脚本版本将如下所示：
- en: '[PRE8]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can also extract the artifacts related to legitimate files inside our `.csv` file,
    by storing them together with malware samples, in order to be able to carry out
    the training by comparing the two types of files.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以提取与合法文件相关的工件，将它们与恶意软件样本一起存储在`.csv`文件中，以便通过比较这两种类型的文件来进行训练。
- en: Obviously, we will have to add an additional column to the `.csv` file specifying
    whether the file is legitimate or not, valuing the field with the value `1` (legitimate)
    or with the value `0` (suspect), respectively.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们需要向`.csv`文件中添加一个额外的列，指定该文件是否为合法文件，分别用`1`（合法）或`0`（可疑）表示该字段的值。
- en: Telling different malware families apart
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区分不同的恶意软件家族
- en: We have seen the advantages and limitations associated with traditional malware
    analysis methodologies, and we have understood why—in light of the high prevalence
    of malware threats—it is necessary to introduce algorithmic automation methods
    for malware detection.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了传统恶意软件分析方法的优缺点，并且明白了为什么—鉴于恶意软件威胁的高发—我们需要引入算法自动化方法来进行恶意软件检测。
- en: In particular, it is increasingly important that the similarities in malware
    behavior are correctly identified, which means that malware samples must be associated
    to classes or families of the same type, even if the individual malware signatures
    are not comparable to each other, due to, for example, the presence of polymorphic
    codes that alter the hash checksums accordingly.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，正确识别恶意软件行为中的相似性变得越来越重要，这意味着即使恶意软件签名由于例如变形代码的存在而无法互相比对（这会相应地改变哈希校验和），恶意软件样本也必须与同类型的类或家族关联。
- en: The analysis of similarities can be carried out in an automated form, by using
    **clustering algorithms**.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 相似性的分析可以通过使用**聚类算法**以自动化的方式进行。
- en: Understanding clustering algorithms
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解聚类算法
- en: The intuition underlying clustering algorithms consists of identifying and exploiting
    the similarities that characterize certain types of phenomena.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类算法背后的直觉是识别并利用表征某些现象类型的相似性。
- en: In technical terms, it is a matter of distinguishing and recognizing, within
    a dataset, the features whose values ​​change with high frequency, from those
    features whose values are shown to remain systematically stable ​​instead. Only
    these latter features are taken into consideration for the detection of phenomena
    characterized by similarity.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来看，这是在数据集中区分和识别那些值变化频繁的特征与那些值系统性稳定的特征。只有这些后者的特征会被考虑用于检测具有相似性特征的现象。
- en: 'We can follow these two types of approaches in identifying similarities:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过这两种方法来识别相似性：
- en: '**Supervised**: The similarities are identified on the basis of previously
    categorized samples (for example, the **k-Nearest Neighbors** (**k-NNs**) algorithms).'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有监督**：相似性是基于先前分类的样本来识别的（例如，**k近邻**（**k-NNs**）算法）。'
- en: '**Unsupervised**: Similarities are identified independently by the algorithm
    itself (for example, the **K-Means** algorithm).'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无监督**：相似性是由算法本身独立识别的（例如，**K均值**算法）。'
- en: The estimate of the similarity between the features is carried out by associating
    them with a definition of **distance**.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 特征间相似性的估算是通过将其与**距离**的定义相联系来进行的。
- en: If we consider the individual features as points in an *n*-dimensional space
    (in association with the number of analyzed features), we can choose a suitable
    mathematical criterion to estimate the distance existing between single points
    (which individually identify an algebraic vector).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将各个特征看作是* n *维空间中的点（与分析的特征数量相关），我们可以选择一个合适的数学准则来估算单个点之间的距离（每个点单独标识一个代数向量）。
- en: 'Some of the measures that can be selected to identify the distances between
    numerical vectors are as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 可以选择的用于识别数值向量之间距离的度量方法如下：
- en: '**Euclidean distance**: This feature identifies the shortest path (the straight
    line) that unites two points in the Cartesian space, and is calculated with the
    following mathematical formula:'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**欧几里得距离**：该特征识别连接两个点的最短路径（即直线），并通过以下数学公式计算：'
- en: '![](img/33692b1d-932e-44a8-ba04-068ed929d14d.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33692b1d-932e-44a8-ba04-068ed929d14d.png)'
- en: '**Manhattan distance**: This feature is obtained from the sum of the absolute
    values of the differences calculated on the elements of the vectors. Unlike the
    Euclidean distance, the Manhattan distance identifies the longest route that joins
    the two points; in formulas, it is equivalent to the following:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**曼哈顿距离**：这个特性通过计算向量元素间差异的绝对值之和得到。与欧几里得距离不同，曼哈顿距离识别连接两点的最长路径；在公式中，它等价于以下内容：'
- en: '![](img/e49a8733-2abb-4858-8057-140cac0c8be3.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e49a8733-2abb-4858-8057-140cac0c8be3.png)'
- en: '**Chebyshev distance**: This is obtained by calculating the maximum value of
    the absolute differences between the elements of the vectors; in formulas, it
    is equivalent to the following:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切比雪夫距离**：通过计算向量元素之间差异的绝对值的最大值来获得；在公式中，它等价于以下内容：'
- en: '![](img/e2b14b0f-2b5d-451d-af51-cbfa417e1fab.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2b14b0f-2b5d-451d-af51-cbfa417e1fab.png)'
- en: The use of the Chebyshev distance is particularly useful if the number of dimensions
    to be taken into account is particularly high, although most of them are irrelevant
    for analysis purposes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用切比雪夫距离在需要考虑的维度数量特别高时尤其有用，尽管其中大多数对分析目的而言是无关的。
- en: From distances to clusters
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从距离到聚类
- en: The clustering process therefore consists of classifying together elements that
    show certain similarities between them.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，聚类过程本质上是将表现出某些相似性的元素归类在一起。
- en: Having defined the concept of similarity using some mathematical definitions
    of distance, the clustering process is thus reduced in the exploration of the
    various dimensions of a given data space in every direction, starting from a given
    point, and then aggregating together the samples that fall into a certain distance.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用某些数学定义的距离来定义相似度概念，聚类过程因此被简化为在给定数据空间的各个方向上从某一点开始，探索不同维度，然后将落在某一特定距离范围内的样本聚集在一起。
- en: Clustering algorithms
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚类算法
- en: Different types of clustering algorithms are conceivable, from the simplest
    and most intuitive, to the most complex and abstract ones.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 可以设想不同类型的聚类算法，从最简单和最直观的到最复杂和最抽象的。
- en: 'Some of the most commonly used algorithms are listed as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最常用的算法如下所列：
- en: '**K-Means**: One of the most widespread among the unsupervised clustering algorithms.
    K-Means can enlist among its strengths the simplicity of implementation and the
    capability of unveiling hidden patterns within the data. This can be achieved
    by proceeding to the independent identification of possible labels.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**K-Means**：在无监督聚类算法中最为广泛使用的一种。K-Means的优势之一是其实现简单，并且能够揭示数据中隐藏的模式。这可以通过独立识别可能的标签来实现。'
- en: '**K-NNs**: This is an example of a lazy learning model. The K-NN algorithm
    only starts working in the evaluation phase, while in the training phase it simply
    limits itself to memorizing the observational data. Due to these characteristics,
    the use of k-NN is inefficient in the presence of large datasets.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**K-NN算法**：这是一个懒惰学习模型的例子。K-NN算法仅在评估阶段开始工作，而在训练阶段，它仅限于记忆观测数据。由于这些特性，K-NN在大数据集下的使用效率较低。'
- en: '**Density-Based Spatial Clustering of Applications with Noise** (**DBSCAN**):
    Unlike K-Means, which is a distance-based algorithm, DBSCAN is an example of a
    density-based algorithm. As such, the algorithm tries to classify data by identifying
    high-density regions.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于密度的空间聚类应用与噪声**（**DBSCAN**）：与基于距离的算法K-Means不同，DBSCAN是一个基于密度的算法示例。因此，该算法通过识别高密度区域来尝试对数据进行分类。'
- en: Evaluating clustering with the Silhouette coefficient
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用轮廓系数评估聚类
- en: One of the recurring problems with clustering algorithms is the evaluation of
    the results.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类算法的一个反复出现的问题是结果的评估。
- en: While in the case of supervised algorithms, by already knowing the classification
    labels, we are able to evaluate the results obtained by the algorithm simply by
    counting out the number of samples incorrectly classified and comparing them with
    those correctly classified. In the case of unsupervised algorithms, the evaluation
    of results is less intuitive.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 而对于监督算法，通过已经知道分类标签的情况下，我们可以通过简单地计算错误分类样本的数量，并将其与正确分类样本进行比较，来评估算法获得的结果。在无监督算法的情况下，结果的评估则不那么直观。
- en: Not having the classification labels available beforehand, we will have to evaluate
    the results by analyzing the behavior of the algorithm itself, only considering
    the clustering process as successful if the samples classified in the same cluster
    are all actually similar.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于事先没有分类标签可用，我们将通过分析算法本身的行为来评估结果，只有在同一聚类中分类的样本确实都相似时，我们才认为聚类过程成功。
- en: 'For the distance-based clustering algorithms, we can use as a metric of evaluation
    called the **Silhouette coefficient**, which takes the following mathematical
    formula:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于距离的聚类算法，我们可以使用称为**轮廓系数**的评估指标，其采用以下数学公式：
- en: '![](img/c457bc07-df77-4dab-80d8-53126453c120.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c457bc07-df77-4dab-80d8-53126453c120.png)'
- en: Here, *m* represents the average distance existing between each single sample
    and all the other samples of the **nearest** cluster, while *n *represents the
    average distance existing between each single sample and all the other samples
    of the **same** cluster.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*m*代表每个单独样本与**最近**聚类的所有其他样本之间的平均距离，而*n*代表每个单独样本与**相同**聚类的所有其他样本之间的平均距离。
- en: The Silhouette coefficient is calculated for each single sample (as such, the
    calculation process becomes particularly slow when dealing with large datasets),
    and the estimate of the distance is determined by the particular metric we chose
    (such as the Euclidean distance or the Manhattan distance).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个单独的样本，计算轮廓系数（Silhouette coefficient）（因此，当处理大型数据集时，计算过程会变得特别缓慢），并且距离的估计是由我们选择的特定度量（如欧几里得距离或曼哈顿距离）决定的。
- en: 'The main features of the Silhouette coefficient are the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 轮廓系数的主要特点如下：
- en: The value of *Sc* can vary between `-1` and `+1`, depending on the goodness
    of the clustering process
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Sc*的值可以在`-1`和`+1`之间变化，这取决于聚类过程的优劣。'
- en: The value of *Sc* will tend toward `+1` in the case of optimal clustering, while
    it will tend toward `-1` in the opposite case of non optimal clustering
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当最佳聚类时，*Sc*的值将趋向于`+1`，而在非最佳聚类的情况下，它将趋向于`-1`。
- en: If the value of *Sc* is close to `0`, we will be in the presence of clusters
    that overlap each other
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*Sc*的值接近`0`，则我们将会遇到重叠的聚类。
- en: K-Means in depth
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解K均值
- en: We will now deal with the K-Means clustering algorithm in more depth.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将更深入地讨论K均值聚类算法。
- en: As previously stated, K-Means is an unsupervised algorithm, that is, it does
    not presuppose the prior knowledge of the labels associated with the data.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，K均值是一种无监督算法，即不预设与数据关联的标签的先验知识。
- en: The algorithm takes its name from the fact that its final purpose is to divide
    the data into k different subgroups. Being a clustering algorithm, it proceeds
    to the subdivision of the data into different subgroups on the basis of a chosen
    measure to represent the distance of the single samples (usually, this measure
    is the Euclidean distance) from the center of the respective cluster (also known
    as **centroid**).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 算法以其最终目的将数据分成k个不同的子组而得名。作为聚类算法，它基于所选择的度量来表示单个样本（通常，这个度量是欧几里得距离）与其所属聚类的中心点（也称为**质心**）之间的距离进行数据的分割。
- en: In other words, the K-Means algorithm proceeds to group the data into distinct
    clusters, **minimizing a cost function** represented by the Euclidean distance
    calculated between the data (considered as points in space) and the respective
    centroids.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，K均值算法通过最小化由计算数据（被视为空间中的点）与各自质心之间的欧几里得距离所代表的成本函数，将数据分组成不同的聚类。
- en: At the end of its elaboration, the algorithm returns the individual samples
    grouped in correspondence of each cluster, whose centroids constitute the set
    of distinctive features identified by the algorithm as representative of the different
    categories that can be identified within the dataset.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在其处理结束时，算法会返回个别样本，这些样本被分组对应于每个聚类，其质心构成算法识别出的不同类别的特征集。
- en: K-Means steps
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: K均值步骤
- en: 'The K-Means algorithm is characterized by the following steps:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: K均值算法的特点如下：
- en: '**Initialization**: This is the phase in which the centroids are identified on
    the basis of the number of clusters defined by the analyst (usually, we are not
    able to know the number of **real** clusters in advance, so it is often necessary
    to proceed by trial and error when defining the number of clusters).'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初始化**：这是根据分析人员定义的聚类数量来识别质心的阶段（通常情况下，我们无法提前知道**真实**的聚类数量，因此在定义聚类数量时，经常需要通过试错法来进行）。'
- en: '**Data assignment to the clusters**: Based on the definition of the centroids
    carried out in the initialization phase, the data is assigned to the closest cluster,
    on the basis of the minimum Euclidean distance calculated between the data and
    their respective centroids.'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据分配到聚类**：根据初始化阶段定义的质心，数据会被分配到最接近的聚类，依据的是计算出的数据与各自质心之间的最小欧几里得距离。'
- en: '**Centroids update**: Being an iterative process, the K-Means algorithm proceeds
    again to the estimation of the centroids by estimating the average of the data
    included in the single clusters. Then the algorithm proceeds to the reassignment
    of the average, until the Euclidean distance between the data and the respective
    centroids is not minimized, or the number of iterations defined by the analyst
    as an input parameter has not been exceeded.'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**质心更新**：作为一个迭代过程，K-Means算法会再次估计质心，通过计算单个聚类中数据的平均值。然后，算法会继续重新分配平均值，直到数据与相应质心之间的欧几里得距离最小化，或者分析人员定义的迭代次数输入参数已被超过。'
- en: To use the implementation of the K-Means algorithm that comes with the `scikit-learn`
    library, we must appropriately choose a series of input parameters in order to
    define the phases of the algorithm iterative process, as identified previously.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`scikit-learn`库中提供的K-Means算法实现，我们必须适当地选择一系列输入参数，以便定义算法迭代过程的各个阶段，如前所述。
- en: In particular, it will be necessary to identify the number of clusters (representative
    of the parameter `k`) and the mode of initialization of the centroids.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，需要确定聚类的数量（代表`k`参数）和质心初始化的方式。
- en: 'The choice of the number of clusters by the analyst has consequences on the
    result obtained by the algorithm: if the number of clusters set as an initialization
    parameter is excessive, the purpose of clustering is disregarded (algorithm behavior
    at the limit will tend to identify a different cluster for each single data).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 分析人员选择聚类数量对算法得到的结果有影响：如果作为初始化参数的聚类数量过多，则聚类的目的就被忽视了（算法在极限情况下将倾向于为每个数据点识别一个不同的聚类）。
- en: To this end, it may be useful to conduct a preliminary phase of **exploratory
    data analysis** (**EDA**)—performed with the aid of data plotting—by visually
    identifying the number of possible distinct subgroups into which the data can
    be distributed.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，进行一次**探索性数据分析**（**EDA**）的初步阶段可能会有所帮助——通过数据绘图帮助，视觉上识别数据可以分布成的可能不同子群的数量。
- en: K-Means pros and cons
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: K-Means的优缺点
- en: Among the advantages of the K-Means algorithm we can remember, in addition to
    its simplicity of use, its high scalability makes it preferable in the presence
    of large datasets.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: K-Means算法的优点之一，除了其简单易用外，它的高可扩展性使其在大规模数据集面前更具优势。
- en: The disadvantages instead are essentially due to the inappropriate choice of
    the `k` parameter, representative of the number of clusters, which, as we have
    seen, requires particular attention on behalf of the analyst, who will be called
    to carefully evaluate this choice on the basis of an EDA, or proceeding by trial
    and error.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，缺点主要由于`k`参数的选择不当，`k`代表聚类的数量，正如我们所见，它需要分析人员特别注意，分析人员必须基于EDA小心评估该选择，或者通过试错法来进行。
- en: Another disadvantage associated with the using the K-Means algorithm is determined
    by the fact that it provides poorly representative results in the presence of
    datasets characterized by high dimensions.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用K-Means算法的另一个缺点是，由于高维数据集的存在，它会提供代表性较差的结果。
- en: As a result, the phenomenon known as the **curse of dimensionality** takes place,
    in which this is in **sparse** form in the n-dimensional space.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，**维度灾难**现象就会发生，其中在n维空间中呈现出**稀疏**的形式。
- en: This entails that the cost function of distance minimization (used as a selective
    criterion for the clusters) is not very representative (in fact, the data may
    lie equidistant from each other in the n-dimensional space).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着距离最小化的成本函数（用作聚类的选择标准）并不具有很好的代表性（事实上，数据可能在n维空间中彼此等距分布）。
- en: Clustering malware with K-Means
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用K-Means聚类恶意软件
- en: In the following example, we will see the K-Means clustering algorithm applied
    to our previously created dataset of artifacts.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将看到K-Means聚类算法应用于我们之前创建的工件数据集。
- en: Remember that our dataset of artifacts contains the fields extracted from the
    PE file format of the individual samples, consisting of the `.exe` files previously
    stored, including both the legitimate and the suspect files.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们的工件数据集包含从各个样本的PE文件格式中提取的字段，包括之前存储的`.exe`文件，涵盖了合法和可疑文件。
- en: 'The number of clusters that we will assign to the `k` parameter in the algorithm
    initialization phase will therefore be `2`, while the features that we will select
    as distinctive criteria of the possible malware correspond to the `MajorLinkerVersion`,
    `MajorImageVersion`, `MajorOperatingSystemVersion`, and `DllCharacteristics` fields:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将在算法初始化阶段为`k`参数分配的聚类数为`2`，而我们选择作为可能恶意软件的区分标准的特征对应于`MajorLinkerVersion`、`MajorImageVersion`、`MajorOperatingSystemVersion`和`DllCharacteristics`字段：
- en: '[PRE9]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once the fields of interest from our dataset are selected, we can proceed to
    instantiate the `KMeans` class of `scikit-learn`, passing the `k` value as an
    input parameters representing the number of clusters, equal to `2` (`n_clusters
    = 2`), and defining the maximum **number of iterations**that the algorithm can
    execute, equal to `300` (`max_iter = 300`) in our case:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从我们的数据集中选择了感兴趣的字段，我们就可以开始实例化`scikit-learn`的`KMeans`类，将`k`值作为输入参数，表示聚类的数量，为`2`（`n_clusters
    = 2`），并定义算法可以执行的最大**迭代次数**，在我们的例子中为`300`（`max_iter = 300`）：
- en: '[PRE10]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can then invoke the `fit()` method on the `k_means` object, thus proceeding
    to start the iterative algorithm process:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以调用`k_means`对象上的`fit()`方法，从而开始迭代算法过程：
- en: '[PRE11]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We just have to evaluate the results obtained by the algorithm. To this end,
    we will use the Silhouette coefficient we introduced previously, calculated by
    using the Euclidean distance as a metric, together with the **confusion matrix**
    of the results. This will show us a table with the respective clustering results,
    divided between correct and incorrect forecasts:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需评估算法获得的结果。为此，我们将使用我们之前介绍的轮廓系数，采用欧几里得距离作为度量标准，并结合**混淆矩阵**来显示结果。这将为我们提供一张表，显示各自的聚类结果，分为正确预测和错误预测：
- en: '[PRE12]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The results of the process are as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程的结果如下：
- en: '[PRE13]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can see how the clustering algorithm was able to successfully identify the
    labels corresponding to the clusters to be associated with the individual samples,
    and from the confusion matrix, it is possible to detect how `83419` samples (out
    of a total of 96,526) belonging to the suspect category have been correctly identified
    (having being classified under label `0`), while only `13107` (13.58% of the total)
    were mistakenly considered as **legitimate**.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到聚类算法成功地识别了与个体样本关联的聚类标签，并且从混淆矩阵中可以看出，共有`83419`个样本（总数为96,526）属于可疑类别并被正确识别（已被归类为标签`0`），而只有`13107`个（占总数的13.58%）被错误地认为是**合法的**。
- en: In the same way, only `7995` samples (out of a total of 40,918) were classified
    as suspect (equal to 19.54% of the total), despite being truly legitimate instead, compared
    to `32923` samples correctly classified as legitimate.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以同样的方式，尽管这些样本实际上是合法的，但仍有`7995`个样本（总数为40,918）被错误地分类为可疑（占总数的19.54%），相比之下，有`32923`个样本被正确分类为合法。
- en: The `Silhouette coefficient` is equal to `0.975`, which is very close to 1,
    reflecting the goodness of the results obtained by the clustering algorithm.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`Silhouette系数`为`0.975`，接近1，反映了聚类算法获得结果的良好性。'
- en: Decision tree malware detectors
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决策树恶意软件检测器
- en: In addition to clustering algorithms, it is possible to use classification algorithms
    for the detection of malware threats. Of particular importance is the classification
    of the malware carried out by using *decision trees*.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 除了聚类算法，还可以使用分类算法来检测恶意软件威胁。特别重要的是使用*决策树*进行的恶意软件分类。
- en: We have already met decision trees in [Chapter 3](aaf59353-00b3-4625-8732-63aad02cc8e5.xhtml), *Ham
    or Spam? Detecting Email Cybersecurity Threats with AI*, when we discussed the
    problem of **spam detection**. Now, we will deal with the classification problems
    solved by decision trees in the context of detecting malware threats.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](aaf59353-00b3-4625-8732-63aad02cc8e5.xhtml)《*垃圾邮件还是正常邮件？使用AI检测电子邮件网络安全威胁*》中已经接触过决策树，当时讨论的是**垃圾邮件检测**的问题。现在，我们将讨论决策树在检测恶意软件威胁时解决的分类问题。
- en: The distinctive feature of decision trees is that these algorithms achieve the
    goal of classifying data in certain classes by modeling the learning process based
    on a sequence of if-then-else decisions.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 决策树的独特特征是，这些算法通过基于一系列 if-then-else 决策建模学习过程，达到了将数据分类到特定类别的目标。
- en: For this characteristic, decision trees represent a type of non-linear classifier,
    whose decision boundaries are not reducible to straight lines or hyperplanes in
    space.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一特征，决策树代表了一种非线性分类器，其决策边界不能简化为空间中的直线或超平面。
- en: Decision trees classification strategy
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决策树分类策略
- en: Decision trees, therefore, shape their learning process based on a tree structure.
    Starting from a root node, subsequent decisions branch into various branches of
    different depths.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，决策树根据树形结构塑造其学习过程。从根节点开始，随后的决策分支成不同深度的分支。
- en: In essence, the samples dataset is divided by the algorithm in an iterative
    way, based on the decisions that are taken at each node, thus giving rise to the
    various branches. Branches, on the other hand, represent nothing more than the
    various ways in which data can be classified, based on the possible choices made
    at the various decision nodes.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，算法以迭代的方式将样本数据集划分，基于每个节点做出的决策，从而产生不同的分支。另一方面，分支不过是根据在各个决策节点做出的可能选择，对数据进行分类的不同方式。
- en: 'This iterative process of subdividing the dataset is determined by a predefined
    measure of the quality of the subdivision conditions. The most commonly used metrics
    for measuring the quality of subdivision are the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个迭代的子集划分过程是由预定义的子集划分质量度量来决定的。最常用的划分质量度量标准如下：
- en: Gini impurity
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基尼不纯度
- en: Variance reduction
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方差减少
- en: Information gain
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息增益
- en: 'Despite their high explanatory capacity, decision trees do, however, suffer
    from some important limitations:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管决策树具有较高的解释能力，但它们仍然存在一些重要的局限性：
- en: As the number of features considered increases, the complexity of the structure
    representing the associated decision tree grows accordingly, translating this
    complexity into the phenomenon known as **overfitting** (that is, the algorithm
    tends to model the **noise** in the data, rather than the **signal**, leading
    to less precise forecasts on the test data)
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着考虑的特征数量增加，表示相关决策树的结构复杂度也随之增加，将这种复杂性转化为我们所说的**过拟合**现象（即，算法倾向于拟合数据中的**噪声**，而不是**信号**，导致在测试数据上的预测精度降低）
- en: Decision trees are particularly sensitive to even small variations in sample
    data, making forecasts unstable
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决策树对样本数据的微小变化特别敏感，这使得预测不稳定
- en: One way to overcome these limitations is to create tree ensembles, associating
    a **vote** to each tree. The mechanism for assigning samples to the respective
    classes is therefore reduced to counting the votes assigned by the various trees;
    an example of a tree ensemble is the **random forest** algorithm.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 克服这些局限性的一种方法是创建树集成，将**投票**分配给每棵树。因此，将样本分配到各个类别的机制简化为计数各棵树分配的投票；树集成的一个例子是**随机森林**算法。
- en: Detecting malwares with decision trees
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用决策树检测恶意软件
- en: We have already met decision trees before, when we addressed the topic of *phishing*
    detection. Obviously, we can also use decision trees to perform malware detection.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经遇到过决策树，当时我们讨论了*钓鱼攻击*检测的话题。显然，我们也可以使用决策树来进行恶意软件检测。
- en: 'In our example, we will use the `AddressOfEntryPoint` and `DllCharacteristics`
    fields as potentially distinctive features for detecting the suspect `.exe`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将使用`AddressOfEntryPoint`和`DllCharacteristics`字段作为潜在的独特特征来检测可疑的`.exe`文件：
- en: '[PRE14]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we can see from the results obtained, the accuracy of the forecasts made
    by selecting the `AddressOfEntryPoint` and `DllCharacteristics` fields proves
    particularly effective, being higher than 96%.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 从所获得的结果来看，选择`AddressOfEntryPoint`和`DllCharacteristics`字段所做的预测准确度特别高，超过了96%。
- en: We can try to select different fields as characterizing features, and evaluate
    the results obtained by comparing them.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试选择不同的字段作为特征进行描述，并通过比较它们来评估所得到的结果。
- en: Decision trees on steroids – random forests
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激动的决策树——随机森林
- en: We have seen that decision trees suffer from some important limitations, which
    can lead to unstable results that are caused even by small variations in the training
    data. To improve forecasts, you can use **ensemble** algorithms, such as **random
    forest**.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到决策树存在一些重要的局限性，这些局限性可能导致即便是训练数据的微小变化也会导致不稳定的结果。为了提高预测精度，可以使用**集成**算法，例如**随机森林**。
- en: 'Random forest is nothing but a decision tree ensemble in which each tree is
    given a vote. The improvement in forecasts is consequently determined by the count
    of the votes attributed to them: the forecasts that obtain the highest number
    of votes are those that are selected to achieve the final result of the algorithm.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 随机森林其实就是一个决策树集成，其中每棵树都有一个投票。预测的改进因此取决于赋予它们的投票数：获得最高票数的预测将被选择作为算法的最终结果。
- en: The creator of the Random Forest algorithm, Leo Breiman, noted that the results
    obtained by an ensemble of trees improved if the trees were **statistically uncorrelated**
    and **independent** of each other. Next, we will see an example of the **Random
    Forest Malware Classifier**, implemented using the `scikit-learn` library.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 随机森林算法的创始人莱奥·布雷曼（Leo Breiman）指出，如果树之间是**统计上不相关**且**相互独立**的，那么通过一组树所获得的结果会得到改进。接下来，我们将看到使用`scikit-learn`库实现的**随机森林恶意软件分类器**的示例。
- en: Random Forest Malware Classifier
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机森林恶意软件分类器
- en: 'The following is an example of the Random Forest Malware Classifier implemented
    with the `scikit-learn` library:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`scikit-learn`库实现的随机森林恶意软件分类器的示例：
- en: '[PRE15]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As we can see from the results, the random forest classifier improves the performances
    obtained by the decision tree; to check this, just compare the accuracy of the
    respective algorithms:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从结果中看到的，随机森林分类器改善了决策树的性能；要验证这一点，只需比较各自算法的准确性：
- en: '[PRE16]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Detecting metamorphic malware with HMMs
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用隐马尔可夫模型（HMM）检测变形恶意软件
- en: The examples of algorithms applied to malware detection that have been shown
    so far were intended to automate some of the routine activities performed by malware
    analysts.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，应用于恶意软件检测的算法示例旨在自动化恶意软件分析师执行的一些常规活动。
- en: However, the analysis methodology on which they are based is essentially static
    malware analysis.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它们所依赖的分析方法本质上是静态恶意软件分析。
- en: Many of the concrete cases of malware threats, however, are not easily identifiable
    with this method of analysis, as the malware developers have learned how to work
    around the detection techniques based on signatures.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多具体的恶意软件威胁实例并不能通过这种分析方法轻易识别，因为恶意软件开发者已经学会了绕过基于签名的检测技术。
- en: It will therefore be necessary to adopt a different methodology to identify
    the malicious behavior of more advanced malware, and to this end, we will have
    to move to an approach based on dynamic malware analysis, combining it with the
    appropriate algorithms.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须采用不同的方法来识别更先进恶意软件的恶意行为，为此我们需要转向基于动态恶意软件分析的方法，并将其与适当的算法结合使用。
- en: But to adequately address the problem, it is necessary to understand in detail
    the limits of traditional detection strategies based on signatures.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 但要充分解决这个问题，需要详细了解基于签名的传统检测策略的局限性。
- en: How malware circumvents detection?
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恶意软件如何绕过检测？
- en: The most commonly used detection strategy is the one that uses signatures associated
    with executable files recognized as malicious.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的检测策略是利用与被识别为恶意的可执行文件相关联的签名。
- en: This strategy offers undoubted advantages, and is widely implemented by antivirus
    software.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略具有无可争议的优势，并且被广泛应用于杀毒软件中。
- en: It is based on the search for specific patterns (consisting of sequences of
    bits considered representative of the malicious executable), conducting the search
    of these patterns on each of the files stored in the system, and carrying out
    the systematic scanning of the resources (including the runtime memory) of the
    system.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 它基于寻找特定模式（由一系列位组成，这些位被认为是恶意可执行文件的代表），对存储在系统中的每个文件进行这些模式的搜索，并对系统资源（包括运行时内存）进行系统扫描。
- en: The search for patterns takes place on the basis of a database, which contains
    the signatures of malicious files. These must be updated promptly and constantly,
    in order to be able to search and compare files in the system, thus preventing
    threats from going undetected.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 模式搜索是基于一个数据库进行的，数据库中包含了恶意文件的签名。这些签名必须及时且不断地更新，以便能够在系统中搜索和比较文件，从而防止威胁被忽视。
- en: 'The advantages associated with the signature-based detection strategy are essentially
    the following:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 基于签名的检测策略所带来的优势基本如下：
- en: Efficiency in identifying threats already known and present in the signatures
    database
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效地识别数据库中已知的威胁和存在的签名。
- en: Low frequency of false positives, which together with false negatives, is the
    main weakness of malware detection software
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低频率的误报，连同误报一起，是恶意软件检测软件的主要弱点。
- en: 'Instead, the limits of this detection strategy are substantially represented
    by the basic assumption: that is to say that malicious software, once identified,
    does not change its binary representation, so it is therefore considered to be
    adequately photographed by the corresponding signature.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，这种检测策略的局限性实质上体现在其基本假设上：即恶意软件一旦被识别，它的二进制表示就不会改变，因此被认为通过相应的签名得到了充分的“拍照”。
- en: In reality, these assumptions have quickly proved unrealistic. Over time, in
    fact, we have witnessed the creativity effort by malware developers to try to
    create software that was able to change its shape, thus targeting the detection
    mechanism based on signatures, while maintaining its own offensive potential.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这些假设很快就被证明是不现实的。随着时间的推移，恶意软件开发者的创意努力也逐渐显现，他们试图创造能够改变自身形态的软件，从而避免基于签名的检测机制，同时保持自身的攻击潜力。
- en: One of the first countermeasures adopted by the authors of malware was obfuscation. To
    this end, it is possible to perform the encryption of the executable portions
    of a malware, each time using different encryption keys to alter the signatures
    associated by the antivirus software to the payload of the malware, while the
    executable instructions remain unaltered and are decrypted before being sent to
    execution.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者采用的最初防范措施之一是混淆技术。为此，可以对恶意软件的可执行部分进行加密，每次使用不同的加密密钥来改变与恶意软件载荷相关的杀毒软件签名，而可执行指令保持不变，并在执行前解密。
- en: A more sophisticated variant of obfuscation is the creation of polymorphic malware,
    in which not only the malware encryption key is constantly changed, but also the
    malware decryption instructions themselves are changed.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更复杂的混淆变种是创建多态恶意软件，在这种恶意软件中，不仅恶意软件的加密密钥不断变化，而且恶意软件的解密指令本身也在变化。
- en: The subsequent evolution of polymorphic malware leads to metamorphic malware,
    in which even the executable instructions of the payload are modified at each
    execution, thus preventing the most advanced antiviruses from identifying the
    malicious payload by scanning the runtime memory, once the payload has been decrypted.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 多态恶意软件的后续演变导致了变形恶意软件，其中即使是载荷的可执行指令在每次执行时也会被修改，从而防止最先进的杀毒软件通过扫描运行时内存来识别恶意载荷，一旦载荷被解密。
- en: 'In order to alter the payload executable instructions, metamorphic malware
    implements a **mutation engine** by adopting the following methods:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改变载荷的可执行指令，变形恶意软件通过采用以下方法实现**变异引擎**：
- en: Inserting additional instructions (dead code) that do not alter the logic and
    operation of the malware.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入额外的指令（死代码），这些指令不会改变恶意软件的逻辑和操作。
- en: Changing the order of the instructions, without altering the logic and overall
    functionality. This technique is particularly effective in generating many **variations
    on the theme**.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变指令的顺序，而不改变逻辑和整体功能。这种技术在生成许多**主题变体**方面特别有效。
- en: Replacement of some instructions with other equivalent instructions.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用其他等效指令替换一些指令。
- en: Polymorphic malware detection strategies
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态恶意软件检测策略。
- en: In the constant *cat and mouse game* established between malware developers
    and antivirus software producers, the latter have tried to keep up the pace, adapting
    their detection strategies to the different forms of polymorphism.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在恶意软件开发者和杀毒软件生产商之间的不断*猫鼠游戏*中，后者试图跟上步伐，调整其检测策略以应对不同形式的多态性。
- en: 'In the case of polymorphic malware, one of the strategies adopted consists
    of code emulation: the execution of the malware inside a controlled environment
    (such as the sandbox), allowing the malware to carry out the decrypt phase of
    the payload, to which the traditional signature-based detection performed by the
    antivirus software follows.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在多态恶意软件的情况下，采取的一种策略是代码仿真：在受控环境（如沙箱）中执行恶意软件，允许恶意软件进行有效负载的解密阶段，之后传统的基于签名的杀毒软件检测会随之进行。
- en: In the case of metamorphic malware, as well as zero days, the detection activity
    carried out by the most sophisticated antivirus software tries to analyze the
    behavior of the suspect file, making sense of the logic of the instructions that
    get executed.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在变异性恶意软件以及零日漏洞的情况下，最先进的杀毒软件执行的检测活动试图分析可疑文件的行为，理解执行的指令的逻辑。
- en: 'However, this detection strategy suffers from some of the following important
    limitations:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种检测策略存在一些以下重要的限制：
- en: It leads to a high rate of false positives
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这会导致较高的误报率。
- en: The analysis of the instructions being executed is carried out on the fly, which
    can lead to significant impacts in computational terms
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对执行中的指令的分析是动态进行的，这可能会在计算上产生显著影响。
- en: An alternative strategy in the detection of metamorphic malwares (as well as
    of zero days) is the one that uses ML algorithms based on HMMs.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在变异性恶意软件（以及零日漏洞）检测中，另一种策略是使用基于HMM（隐马尔可夫模型）的机器学习算法。
- en: To understand what these are, we will first have to introduce these types of
    algorithms.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这些限制是什么，我们首先需要介绍这些类型的算法。
- en: HMM fundamentals
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HMM基础
- en: To understand what an HMM is, we need to introduce Markov processes.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解HMM是什么，我们需要引入马尔可夫过程。
- en: A Markov process (or Markov chain) is a stochastic model that changes its status
    based on a predefined set of probabilities.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 马尔可夫过程（或马尔可夫链）是一种随机模型，它根据预定义的概率集改变其状态。
- en: One of the assumptions of the Markov process prescribes that the **probability
    distribution** of **future states** depends exclusively on the **current state**.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 马尔可夫过程的一个假设规定了**未来状态**的**概率分布**完全依赖于**当前状态**。
- en: 'Therefore, an HMM is a Markov process of which it is **not** possible to **directly
    observe** the state of the system: the only observable elements are the events
    and secondary effects associated with the state of the system; however, the probabilities
    of the events being determined by each state of the system are fixed.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，HMM是一个马尔可夫过程，其中**不能**直接**观察**系统的状态：唯一可观察的元素是与系统状态相关的事件和二次效应；然而，事件的概率由系统的每个状态决定，并且是固定的。
- en: 'Consequently, the **observations** on each state of the system are made **indirectly**
    on the basis of the events determined by such hidden states, to which probability
    estimates can be associated:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，系统每个状态的**观察值**是**间接**通过由这些隐藏状态决定的事件来进行的，并且可以与这些事件的概率估计相关联：
- en: '![](img/1351bb6c-8eb2-4bb1-8189-7740455a6c8c.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1351bb6c-8eb2-4bb1-8189-7740455a6c8c.png)'
- en: '(Image credits: https://en.wikipedia.org/wiki/File:HiddenMarkovModel.svg)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: （图片来源：https://en.wikipedia.org/wiki/File:HiddenMarkovModel.svg）
- en: 'To intuitively understand how HMMs work, we present the following example:
    imagine an executable that is launched on a host machine. At a given time, the
    machine can continue to function properly, or stop working properly; this behavior
    represents the observable event.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 为了直观地理解HMM是如何工作的，我们展示以下示例：假设一个可执行文件在主机上运行。在某一时刻，机器可以继续正常工作，或者停止正常工作；这种行为代表了可观察事件。
- en: 'Let''s assume for simplicity that the reasons why the machine stops working
    regularly can be reduced to the following:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，假设机器定期停止工作的原因可以归结为以下几点：
- en: The executable executed a **malicious** instruction
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可执行文件执行了**恶意**的指令。
- en: The executable executed a **legitimate** instruction
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可执行文件执行了**合法**的指令。
- en: The information relating to the specific reason why the machine stops working
    properly is the entity unknown to us, which we can only infer based on observable
    events.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 与机器停止正常工作相关的具体原因是我们无法直接得知的实体，我们只能基于可观察的事件进行推测。
- en: 'These observable events, in our example, are reduced to the following:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，这些可观察的事件被归结为以下几点：
- en: The machine works regularly (working)
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器正常工作（工作）
- en: The machine stops working (not working)
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器停止工作（不工作）
- en: 'Similarly, the hidden entities of our example are represented by the instructions
    executed by the program:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们示例中的隐藏实体由程序执行的指令表示：
- en: '**Malicious** instruction'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恶意**指令'
- en: '**Legitimate** instruction'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合法**指令'
- en: 'Finally, imagine assigning the probability estimates to the various events
    and states of the system. We summarize this in the following table, also known
    as the **emission matrix**, which summarizes the probabilities that a given observation
    is associated with a particular observable state (remember that the sum of the
    probabilities associated to each hidden entity, subdivided according to the possible
    events, must account to 1):'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，假设为系统的各种事件和状态分配概率估计。我们将此总结在下表中，也称为**发射矩阵**，它总结了给定观察结果与特定可观察状态相关的概率（记住，每个隐藏实体相关的概率之和，按可能事件细分，必须等于1）：
- en: '[PRE17]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'At this point, we must estimate the probabilities associated with the **next
    instruction** executed by the program, which can be summarized in the **transition
    matrix**:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们必须估计程序执行的**下一条指令**的概率，这可以通过**转移矩阵**进行总结：
- en: 'Therefore, if the program has previously executed a malicious (instead of a
    legitimate) instruction, the probability that the next instruction executed is
    malicious (rather than legitimate) is equal to the following:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果程序之前执行了恶意（而非合法）指令，则下一条指令是恶意（而非合法）的概率为：
- en: '[PRE18]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we must assign the probability associated with the starting state
    of the HMM; in other words, the probability associated with the first hidden state
    corresponds to the probability that the first instruction executed by the program
    is **malicious** or **legitimate**:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须分配与HMM起始状态相关的概率；换句话说，第一个隐藏状态的概率对应于程序执行的第一条指令是**恶意**还是**合法**的概率：
- en: '[PRE19]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: At this point, the task of our HMM is to identify hidden entities (in our example,
    if the instructions executed by the program are malicious or legitimate) based
    on the observation of the behavior of the machine.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们HMM的任务是基于机器行为的观察来识别隐藏实体（在我们的例子中，判断程序执行的指令是恶意还是合法）。
- en: HMM example
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HMM 示例
- en: 'In our example, the possible observations are as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，可能的观察结果如下：
- en: '[PRE20]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, `W` stands for Working and `N` for Not Working, while the hidden states are
    as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`W` 代表工作（Working），`N` 代表不工作（Not Working），而隐藏状态如下：
- en: '[PRE21]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, `M` corresponds to Malicious and `L` corresponds to Legitimate.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`M` 对应恶意（Malicious），`L` 对应合法（Legitimate）。
- en: 'The sequence of observations comes next, which is associated to the single
    instructions that get executed by the program:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是观察序列，这与程序执行的单条指令相关：
- en: '[PRE22]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This sequence of observations tells us that after the execution of the first
    three instructions of the program, the machine worked properly, while it stopped
    working only after executing the fourth instruction.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这一系列观察结果告诉我们，在执行程序的前三条指令之后，机器正常工作，而只有在执行第四条指令后才停止工作。
- en: 'On the basis of this sequence of observable events, we must proceed with the
    training of the HMM. To this end, we will pass our probability matrices (as defined
    previously) to the algorithm, corresponding to the `start` matrix:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这一系列可观察事件，我们必须继续训练HMM。为此，我们将把我们的概率矩阵（如前所定义）传递给算法，对应于`开始`矩阵：
- en: '[PRE23]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `transition` matrix is as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`转移`矩阵如下：'
- en: '[PRE24]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `emission` matrix is as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`发射`矩阵如下：'
- en: '[PRE25]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following code uses the Hidden Markov library, which is available at [https://github.com/rahul13ramesh/hidden_markov](https://github.com/rahul13ramesh/hidden_markov):'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用了隐藏马尔可夫（Hidden Markov）库，可以在[https://github.com/rahul13ramesh/hidden_markov](https://github.com/rahul13ramesh/hidden_markov)找到：
- en: '[PRE26]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'These are the results of the script:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是脚本的结果：
- en: '[PRE27]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`Forward algorithm` gives us the probability of an observed sequence in the
    HMM, while `Viterbi algorithm` is used to find out the most likely sequence of
    hidden states that can generate the given set of observations.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`前向算法（Forward algorithm）`给我们提供了HMM中观察序列的概率，而`维特比算法（Viterbi algorithm）`则用于找出能够生成给定观察序列的最可能的隐藏状态序列。'
- en: For more information about the Hidden Markov library, please refer to the documentation
    available at [http://hidden-markov.readthedocs.io/en/latest/](http://hidden-markov.readthedocs.io/en/latest/).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 有关隐藏马尔可夫库的更多信息，请参见[http://hidden-markov.readthedocs.io/en/latest/](http://hidden-markov.readthedocs.io/en/latest/)的文档。
- en: Advanced malware detection with deep learning
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度学习在恶意软件检测中的应用
- en: In the last part of the chapter, we will introduce—for the sake of completeness—some
    solutions of malware detection that make use of experimental methodologies based
    on neural networks.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，为了完整性，我们将介绍一些利用基于神经网络的实验方法进行恶意软件检测的解决方案。
- en: We will have a more in-depth look at the topic of deep learning techniques later
    on in [Chapter 8](18f56dc2-fd40-4669-bef1-0b594d9e1572.xhtml), GANS – Attacks
    and Defenses (especially when we will talk about **Generative Adversarial Networks**
    (**GANs**)).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续的[第8章](18f56dc2-fd40-4669-bef1-0b594d9e1572.xhtml)中更深入地探讨深度学习技术，尤其是在讨论**生成对抗网络**（**GANs**）时，关于攻击与防御的内容。
- en: Here, we will introduce the topic to show an innovative and unconventional approach
    to the problem of the classification of different families of malware, which makes
    use of deep learning algorithms developed in a completely different field of research,
    such as that of image recognition using **Convolutional Neural Networks** (**CNNs**).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将介绍一种创新且非传统的方法来解决不同恶意软件家族分类的问题，该方法利用了在图像识别领域开发的深度学习算法，如**卷积神经网络**（**CNNs**）。
- en: But before going into that, let's briefly introduce **Neural Networks** (**NNs**)
    and their main features in the field of malware detection.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨之前，让我们简要介绍一下**神经网络**（**NNs**）及其在恶意软件检测中的主要特征。
- en: NNs in a nutshell
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 神经网络简述
- en: NNs constitute a category of algorithms that try to imitate the learning mechanisms
    typical of the human brain, artificially reproducing its substrate, which is constituted
    by neurons.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 神经网络（NNs）是一类试图模仿人脑学习机制的算法，通过人工再现大脑的神经元结构。
- en: 'There are different types of neural networks, but here we focus on two types
    in particular: the CNN, and the **Feedforward Networks** (**FFN**), which are
    the basis of CNNs; we start by describing FFNs.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 神经网络有不同类型，但在这里我们特别关注两种类型：CNN和**前馈网络**（**FFN**），后者是CNN的基础；我们从描述FFN开始。
- en: 'The FFN is composed of at least three layers of neurons, divided as follows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 前馈神经网络（FFN）由至少三层神经元组成，具体分布如下：
- en: Input layer
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入层
- en: Output layer
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出层
- en: Hidden layer (one or more)
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 隐藏层（一层或多层）
- en: This layered organization of the FFN allows us to have a first layer for the
    management of input data, and a layer that returns the output results.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: FFN的层次结构使我们能够拥有第一层来管理输入数据，以及一层返回输出结果。
- en: The individual neurons in the various layers connect directly to the adjacent
    layers, while there are no connections between the neurons belonging to the same
    layer.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 各层中的单个神经元直接连接到相邻的层，而同一层中的神经元之间没有连接。
- en: CNNs
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CNN（卷积神经网络）
- en: A CNN is a particular type of FFN, characterized by the fact that the organization
    of the neuronal layers follows the same organization of the existing visual apparatus
    in the biological world, with the superposition of regions of neurons within the
    visual field.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: CNN是一种特定类型的前馈神经网络（FFN），其特点是神经层的组织方式遵循生物学世界中现有视觉系统的组织方式，并且神经元区域在视觉场中重叠。
- en: As we have said, in CNNs, each neuron is connected to a contiguous region of
    input neurons, in order to map the corresponding regions of pixels of an image.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在CNN中，每个神经元都连接到一片相邻的输入神经元区域，以便映射图像的像素区域。
- en: In this way, it is possible to identify the spatial correlations through local
    connectivity schemes between neurons lying on adjacent layers, which allow, for
    example, the identification of objects.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，可以通过相邻层之间的局部连接方案识别空间相关性，这使得例如识别物体成为可能。
- en: In the CNNs, the contiguous regions of neurons are in fact organized by emulating
    the three-dimensional quantities of width, height, and depth, which map the corresponding
    characteristics of c width and height of the images, while the depth is constituted
    by the RGB channels.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在CNN中，相邻的神经元区域实际上是通过模拟宽度、高度和深度的三维量来组织的，这些量映射到图像的宽度和高度特征，而深度则由RGB通道组成。
- en: Therefore, CNNs are optimized for image recognition thanks to the convolutional
    layer (which, together with the pooling layer and the fully-connected layer, constitutes
    the three characteristic layers of such neural networks).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，CNN因其卷积层（与池化层和全连接层一起构成了这种神经网络的三大特征层）而在图像识别方面得到了优化。
- en: In particular, the convolutional layer allows us to extract the relevant features
    of the input images through the convolution operations, which create a new image
    starting from the original image, by highlighting the most relevant features,
    and by blurring the less relevant ones; in so doing, the convolutional layer can
    spot similar images in spite of their actual position or orientation.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，卷积层通过卷积操作提取输入图像的相关特征，这些卷积操作从原始图像中创建一幅新图像，通过突出最相关的特征，并模糊较不相关的特征；通过这种方式，卷积层能够发现相似的图像，而不考虑它们的实际位置或方向。
- en: From images to malware
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从图像到恶意软件
- en: In the description that follows, we will show an alternative approach to malware
    detection that takes advantage of the typical skills of CNNs in image recognition.
    But in order to do this, it is first necessary to represent the executable code
    of the malware in the form of an image to be fed to the CNN.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的描述中，我们将展示一种利用CNN在图像识别中的典型技能来进行恶意软件检测的替代方法。但要做到这一点，首先需要将恶意软件的可执行代码表示为图像，并将其输入到CNN中。
- en: 'This approach was described in the paper entitled *Towards Building an Intelligent
    Anti-Malware System: A Deep Learning Approach using Support Vector Machine (SVM)
    for Malware Classification* by Abien Fred M. Agarap, in which each executable
    malware is treated as a binary sequence of zeros and ones, which is then translated
    into a gray-scale image.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在《构建智能反恶意软件系统：一种使用支持向量机（SVM）进行恶意软件分类的深度学习方法》一文中有所描述，作者：Abien Fred M. Agarap，其中每个可执行恶意软件被视为一个由零和一组成的二进制序列，然后将其转换为灰度图像。
- en: In this way, it is possible to recognize the malware families based on the similarities
    in terms of layouts and textures existing in the images that represent them.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，可以根据图像中布局和纹理的相似性识别恶意软件家族。
- en: To perform the classification of the images, a k-NN clustering algorithm was
    used, in which the Euclidean distance was adopted as the metric used to represent
    the distance.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对图像进行分类，使用了k-NN聚类算法，其中采用欧几里得距离作为度量标准来表示距离。
- en: 'The experimental results obtained showed a classification rate of 99.29%, with
    extremely reduced computational loads:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 实验结果显示，分类率为99.29%，并且计算负载极低：
- en: '![](img/e55d81ff-5eac-4f88-914c-712b3ffc21ab.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e55d81ff-5eac-4f88-914c-712b3ffc21ab.png)'
- en: 'Image credits: Towards Building an Intelligent Anti-Malware System: A Deep
    Learning Approach using Support Vector Machine (SVM) for Malware Classification
    by Abien Fred M. Agarap'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 图像来源：《构建智能反恶意软件系统：一种使用支持向量机（SVM）进行恶意软件分类的深度学习方法》，作者：Abien Fred M. Agarap
- en: Why should we use images for malware detection?
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么我们要使用图像来进行恶意软件检测？
- en: 'The advantages of representing malware as images are follow ass:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 将恶意软件表示为图像的优点如下：
- en: The ability to recognize specific sections of the malware code, such as those
    modified by malware developers in an attempt to create different variants of the
    original code.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别恶意软件代码特定部分的能力，例如那些被恶意软件开发者修改的部分，目的是为了创建原始代码的不同变种。
- en: Through the images, it is possible to identify the minor modifications intervened
    in the code, while preserving the overall structure of the malware image.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过图像，可以识别出代码中微小的修改，同时保持恶意软件图像的整体结构。
- en: These characteristics have the consequence that the different variants of the
    malware belonging to the same family are easily recognizable on the basis of the
    similarity of the respective images that represent them. This is because different
    types of images correspond to different families of malware.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些特征使得属于同一家族的不同恶意软件变种能够通过其表示它们的图像相似性轻松识别。这是因为不同类型的图像对应着不同的恶意软件家族。
- en: Detecting malware from images with CNNs
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CNN进行图像中的恶意软件检测
- en: From the original paper described previously, a tool was developed that leverages
    CNNs to recognize and classify the images that represent malware codes.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 从前述的原始论文中，开发了一个工具，利用CNN识别和分类表示恶意软件代码的图像。
- en: 'The tool can be downloaded from the GitHub repository, by executing the following
    command:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过执行以下命令，从GitHub仓库下载该工具：
- en: '[PRE28]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Inside the archive, there is also a dataset of images of malware codes (`malimg.npz`).
    To convert your malware codes to grayscale images, you can also use the Python
    script developed by Chiheb Chebbi, which is available at [https://github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/blob/master/Chapter04/MalwareConvert.py](https://github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/blob/master/Chapter04/MalwareConvert.py).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在档案内还有一组恶意软件代码图像的数据集（`malimg.npz`）。要将您的恶意软件代码转换为灰度图像，还可以使用Chiheb Chebbi开发的Python脚本，该脚本可在[https://github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/blob/master/Chapter04/MalwareConvert.py](https://github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/blob/master/Chapter04/MalwareConvert.py)上找到。
- en: 'We show some examples of the tool''s usage as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了工具的一些使用示例如下：
- en: '[PRE29]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To use the CNN-SVM model, set the `-model` parameter to `1`, as in the following
    example:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用CNN-SVM模型，请将`-model`参数设置为`1`，如下例所示：
- en: '[PRE30]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Summary
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we addressed the different strategies of malware threats detection,
    making use of various AI algorithms.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了恶意软件威胁检测的不同策略，利用了各种AI算法。
- en: We saw how malwares can trick the analyst, using advanced techniques such as
    polymorphism, forcing the adoption of algorithmic-based detection tools.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到恶意软件如何欺骗分析师，使用诸如多态性之类的高级技术，迫使采用基于算法的检测工具。
- en: Therefore, we introduced the clustering and classification algorithms, up to
    the more advanced ones, which are based on HMMs and neural networks, in the form
    of CNNs, in order to deal with such advanced threats.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们介绍了聚类和分类算法，从基于HMMs和神经网络的高级算法，如CNNs，以处理此类高级威胁。
- en: In the next chapter, we will deal with Network Anomalies Detection techniques
    that leverage Artificial Intelligence.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论利用人工智能的网络异常检测技术。
