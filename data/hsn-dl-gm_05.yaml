- en: Building a Deep Learning Gaming Chatbot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建深度学习游戏聊天机器人
- en: '**Chatbots**, or conversational agents, are an exploding trend in AI and are
    seen as the next human interface with the computer. From Siri, Alexa, and Google
    Home, there has been an explosion of commercial growth in this area, and you most
    likely already have interfaced with a computer in this manner. Therefore, it only
    seems natural that we cover how to build conversational agents for games. For
    our purposes, however, we are going to look at the class of bots called **neural
    conversational agents**. Their name follows from the fact that they are developed
    with neural networks. Now, chatbots don''t have to just chat; we will also look
    at other ways conversational bots can be used in gaming.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**聊天机器人**，或称对话代理，是人工智能领域一个迅速发展的趋势，被视为与计算机互动的下一个人类界面。从Siri、Alexa到Google Home，这一领域的商业增长势不可挡，你很可能已经以这种方式与计算机进行了互动。因此，讨论如何为游戏构建对话代理似乎是理所当然的。然而，出于我们的目的，我们将关注一类被称为**神经对话代理**的机器人。它们的名字来源于它们是通过神经网络开发的。现在，聊天机器人不仅仅是聊天；我们还将探讨对话机器人在游戏中可以采取的其他应用方式。'
- en: 'In this chapter, we learn how to build neural conversational agents and how
    to apply these techniques to games. The following is a summary of the main topics
    we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何构建神经对话代理，并将这些技术应用于游戏中。以下是我们将讨论的主要内容摘要：
- en: Neural conversational agents
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 神经对话代理
- en: Sequence-to-sequence learning
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列到序列学习
- en: DeepPavlov
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DeepPavlov
- en: Building the bot server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建机器人服务器
- en: Running the bot in Unity
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity中运行机器人
- en: Exercises
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习
- en: We will now start building more practical real-world working examples of the
    projects. While not all of your training is complete, it is time we started to
    build pieces you can use. This means we will begin working with Unity in this
    chapter and things may start to get complicated quickly. Just remember to take
    your time and, if you need to, go over the material a few times. Again, the exercises
    at the end of the chapter are an excellent resource for additional learning.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将开始构建更实际的、能够在现实中工作的项目示例。虽然并非所有的训练都已完成，但现在是时候开始构建你可以使用的部分了。这意味着我们将在本章开始使用Unity，事情可能很快变得复杂。只要记得慢慢来，如果需要的话，可以多看几遍材料。同样，本章末尾的练习是一个非常好的额外学习资源。
- en: In the next section, we explore the basics of neural conversational agents.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨神经对话代理的基础知识。
- en: Neural conversational agents
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 神经对话代理
- en: The concept of communicating with a computer via natural language first became
    popular as far back as Star Trek (1966 to 1969). In the series, we can often see
    Kirk, Scotty, and the gang issuing commands to the computer. Since then, many
    attempts have been made to build chatbots that can converse naturally with a human.
    During this often unsuccessful journey over the years, several linguistic methods
    have been developed. These methods are often grouped together and referred to
    as **natural language processing**, or **NLP**. Now, NLP still is the foundation
    for most chatbots, including the deep learning variety we will get to shortly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过自然语言与计算机进行交流的概念早在《星际迷航》（1966至1969年）时期就已流行。在该系列中，我们经常看到柯克、斯科蒂（Scotty）等人向计算机发出指令。从那时起，许多人试图构建能够与人类自然对话的聊天机器人。在这条常常不成功的道路上，几种语言学方法被开发了出来。这些方法通常被归类为**自然语言处理**，或称**NLP**。现在，NLP仍然是大多数聊天机器人的基础，包括我们稍后将介绍的深度学习类型。
- en: 'We often group conversational agents by purpose or task. Currently, we categorize
    chatbots into two main types:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常根据目的或任务将对话代理分组。目前，我们将聊天机器人分为两种主要类型：
- en: '**Goal-oriented**:These bots are the kind Kirk would use or the ones you likely
    communicate with on a daily basis, and a good example is Siri or Alexa.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标导向**：这些机器人是柯克（Kirk）可能使用的那种，或者是你每天可能与之沟通的机器人，一个很好的例子是Siri或Alexa。'
- en: '**General conversationalist**: These chatbots are designed to converse with
    people regarding a wide range of topics, and a good example would be **Microsoft
    Tay**. Unfortunately, the Tay bot was perhaps a little too impressionable and
    picked up bad language, much like a two-year-old does.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用对话者**：这些聊天机器人旨在与人类就广泛的话题进行对话，一个好的例子是**微软Tay**。不幸的是，Tay机器人可能有些太容易受影响，学会了不良语言，类似于一个两岁孩子的行为。'
- en: Gaming is certainly no stranger to chatbots, and attempts have been made to
    use both forms with varying success. While you may think goal-oriented bots make
    perfect sense, in reality the vocal/text is too slow and tedious for most repetitive
    gaming tasks. Even simple vocal commands (grunts or groans) are just too slow,
    at least currently. Therefore, we will look at the often under utilized conversational
    chatbots and how they can be used in gaming.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏与聊天机器人并不陌生，已经尝试使用这两种形式，并取得了不同程度的成功。虽然你可能认为目标导向型的机器人非常合适，但实际上，语音/文本对于大多数重复性的游戏任务来说，速度太慢且枯燥。即使是简单的语音命令（咕哝或呻吟）也太慢了，至少现在是这样。因此，我们将探讨那些经常未被充分利用的对话型聊天机器人，以及它们如何在游戏中发挥作用。
- en: 'The following is a summary of the gaming tasks these bots could undertake:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这些机器人可以承担的游戏任务总结：
- en: '**Non-player characters** (**NPCs**): This is an obvious first choice. NPCs
    are often scripted and become repetitive. How about an NPC that can converse naturally
    about a topic, perhaps revealing information when the right combination of words
    or phrases are used? The possibilities are endless here, and some NLP is already
    used in gaming for this matter.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非玩家角色**（**NPCs**）：这是一个显而易见的首选。NPC通常是预设脚本，容易变得单调重复。那么，如何设计一个能够自然对话的NPC呢？也许在使用正确的词语或短语组合时，它能透露信息？这里的可能性是无穷的，实际上，游戏中已经开始使用一些自然语言处理（NLP）技术来实现这一点。'
- en: '**Player character**: How about a game where you could converse with yourself?
    Perhaps the character has amnesia and is trying to remember information or learn
    a backstory.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家角色**：如果有一个游戏，你可以和自己对话怎么样？也许角色失去了记忆，正在努力回忆信息或了解背景故事。'
- en: '**Promotion**/**hints**: Perhaps as a way to promote your game, you build a
    bot that can hint at how to complete some difficult tasks or just as a way to
    talk about your game.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推广**/**提示**：也许作为推广你的游戏的一种方式，你可以创建一个机器人，提示如何完成一些困难任务，或者仅仅作为一种谈论游戏的方式。'
- en: '**MMO virtual character**: What if, while you were away from your favorite
    MMO game, your character stayed in the game, unable to do actions, but still able
    to converse as you? This is the example we will look at in this chapter, and we
    will get to the action part later, when we explore **reinforcement learning**.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MMO虚拟角色**：如果在你离开你最喜欢的MMO游戏时，你的角色依然留在游戏中，无法进行任何操作，但仍能像你一样与人对话，那会怎么样？这是我们将在本章讨论的示例，我们稍后会介绍如何实现动作部分，当我们探讨**强化学习**时。'
- en: There are likely dozens more uses that will evolve over time, but for now the
    preceding list should give you some great ideas regarding how to use chatbots
    in gaming. In the next section, we get into the background of what makes a conversationalist
    bot.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，可能会出现更多的用途，但现在前面的列表应该能给你一些关于如何在游戏中使用聊天机器人的好点子。在下一部分，我们将讨论构建对话型机器人背后的背景。
- en: General conversational models
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般的对话模型
- en: 'Conversational chatbots can be broken down further into two main forms: **generative**
    and **selective**. The method we will look at is called generative. Generative
    models learn by being fed a sequence of words and dialog in context/reply pairs.
    Internally, these models use RNN (LSTM) layers to learn and predict those sequences
    back to the conversant. An example of how this system works is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对话型聊天机器人可以进一步分为两种主要形式：**生成型**和**选择型**。我们将要讨论的方法是生成型。生成型模型通过输入一系列带有上下文和回复的词语和对话来学习。内部，这些模型使用RNN（LSTM）层来学习并预测这些序列，并将它们返回给对话者。以下是该系统如何工作的一个示例：
- en: '![](img/79642a34-900d-4645-8724-247d67950d08.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79642a34-900d-4645-8724-247d67950d08.png)'
- en: Example of the generative conversational model
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 生成型对话模型的示例
- en: Note that each block in the diagram represents one LSTM cell. Each cell then
    remembers the sequence that text was part of. What may not be clear from the preceding
    diagram is that both sides of the conversation text were fed into the model before
    training. Thus, this model is not unlike the GANs we covered in [Chapter 3](cb51d15b-9855-47e2-8e45-f74a115ebfa8.xhtml)*, GAN
    for Games*. In the next section, we will get into the details of setting up this
    type of model.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，图示中的每个块代表一个LSTM单元。每个单元会记住文本所在的序列。前面图示中可能不太清楚的是，对话文本的双方在训练前都被输入到模型中。因此，这个模型与我们在[第3章](cb51d15b-9855-47e2-8e45-f74a115ebfa8.xhtml)*《游戏中的GAN》*中讨论的GAN有些相似。在下一部分，我们将深入讨论如何搭建这种类型的模型。
- en: Sequence-to-sequence learning
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列到序列学习
- en: In the previous section, we saw a high-level overview of our network model.
    In this section, we want to look at a Keras implementation of a generative conversational
    model that uses sequence-to-sequence learning. Before we get into the theory of
    this form of generative model, let's get the sample running, since it can take
    a while. The sample we will explore is the Keras reference sample for sequence-to-sequence
    machine translation. It is currently configured to do English-to-French translation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到我们的网络模型的概述。在这一节中，我们将介绍一个使用序列到序列学习的生成式对话模型的 Keras 实现。在我们深入探讨这种生成模型的理论之前，让我们先运行一个示例，因为这可能需要一些时间。我们将探索的示例是
    Keras 提供的序列到序列机器翻译的参考示例。它当前配置为执行英法翻译。
- en: 'Open up the `Chapter_4_1.py` sample code listing and get it running using these
    steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Chapter_4_1.py` 示例代码并按照以下步骤运行：
- en: 'Open up a shell or Anaconda window. Then run the following command:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个 shell 或 Anaconda 窗口。然后运行以下命令：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will run the sample, and it may take several hours to run. The sample
    can also consume a substantial amount of memory and this may force memory paging
    on lower memory systems. Paging memory to disk will take additional time to train,
    especially if you are not running an SSD. If you find that you are unable to complete
    training on this sample, reduce the number of `epochs` and/or `num_samples` parameters
    as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将运行示例，可能需要几个小时才能完成。该示例还可能消耗大量内存，这可能会导致低内存系统进行内存分页。将内存分页到磁盘将花费额外的训练时间，特别是如果你没有使用
    SSD。如果你发现无法完成这个示例的训练，可以减少 `epochs` 和/或 `num_samples` 参数，如下所示：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Decrease the `epochs` or `num_samples` parameters if you are unable to train
    on the original values.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你无法使用原始值进行训练，可以减少 `epochs` 或 `num_samples` 参数。
- en: After the sample has completed training, it will run through a test set of data.
    As it does so, it will output the results and you can see how well it is translating
    from English to French.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当示例完成训练后，它将运行一个测试数据集。在此过程中，它会输出结果，你可以看到它从英语翻译到法语的效果如何。
- en: Open the `fra-eng` folder located in the chapter source code.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于章节源代码中的 `fra-eng` 文件夹。
- en: 'Open the `fra.txt` file and the top few lines are as follows:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `fra.txt` 文件，前几行如下：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice how the training text (English/French) is split on punctuation and spaces.
    Also, note how the sequences vary in length. The sequences we input do not have
    to match the length of the output, and vice versa.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意训练文本（英语/法语）是如何根据标点符号和空格进行拆分的。同时，也要注意序列的长度是如何变化的。我们输入的序列不必与输出的长度匹配，反之亦然。
- en: The sample we just looked at uses sequence-to-sequence character encoding to
    translate text from English to French. Typically, chat generation is done with
    word-to-word encoding, but this sample uses a finer-grained character-to-character
    model. This has an advantage in games because the language we attempt to generate
    may not always be human. Keep in mind that while we are only generating translated
    text in this sample, the text paired with an input could be any response you deem
    appropriate. In the next section, we will break down the code and understand in
    some detail how this sample works.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看的示例使用了序列到序列字符编码将文本从英语翻译成法语。通常，聊天生成是通过逐词编码完成的，但这个示例使用了更细粒度的字符到字符模型。这在游戏中有一个优势，因为我们尝试生成的语言不一定总是人类语言。请记住，尽管在这个示例中我们只是生成翻译文本，任何与输入配对的文本都可以是你认为合适的任何响应。在下一节中，我们将逐步解析代码，深入理解这个示例的工作原理。
- en: Breaking down the code
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐步解析代码
- en: 'As we progress through the book, we will begin to only focus on important sections
    of code, sections that help us understand a concept or how a method is implemented.
    This will make it more important for you to open up the code and at least pursue
    it on your own. In the next exercise, we take a look at the important sections
    of the sample code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续深入本书，我们将开始只专注于重要的代码部分，这些部分有助于我们理解一个概念或方法是如何实现的。这样，你需要更重视自己打开代码并至少独立进行探索。在下一个练习中，我们将关注示例代码中的重要部分：
- en: 'Open `Chapter_4_1.py` and scroll down to the comment `Vectorize the data`,
    as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Chapter_4_1.py` 并向下滚动到注释 `Vectorize the data`，如下所示：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This section of code inputs the training data and encodes it into the character
    sequences it uses to vectorize. Note how the `num_encoder_tokens` and `num_decoder_tokens`
    parameters being set here are dependent on the number of characters in each set
    and not the number of samples. Finally, the maximum length of the encoding and
    decoding sequences are set on the maximum length of the encoded characters in
    both.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一部分代码输入训练数据，并将其编码成用于向量化的字符序列。请注意，这里设置的`num_encoder_tokens`和`num_decoder_tokens`参数依赖于每个字符集中的字符数，而非样本数。最后，编码和解码序列的最大长度是根据这两者中编码字符的最大长度来设置的。
- en: 'Next, we want to take a look at the vectorization of the input data. Vectorization
    of the data reduces the number of characters for each response match and is also
    the memory-intensive part, except, when we align this data, we want to keep the
    responses or targets to be one step ahead of the original input. This subtle difference
    allows our sequence-learning LSTM layers to predict the next patterns in the sequence.
    A diagram of how this works follows:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们要看看输入数据的向量化。数据的向量化减少了每个响应匹配的字符数量，同时也是内存密集型的部分，但当我们对齐这些数据时，我们希望保持响应或目标比原始输入提前一步。这一微妙的差异使得我们的序列学习LSTM层能够预测序列中的下一个模式。接下来是这一过程如何运作的示意图：
- en: '![](img/24d3cbdd-04c1-443a-899b-083e3443bd54.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/24d3cbdd-04c1-443a-899b-083e3443bd54.png)'
- en: Sequence-to-sequence model
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 序列到序列模型
- en: In the diagram, we can see how the start of the text **HELLO** is being translated
    one step behind the response phrase **SALUT** (*hello* in French). Pay attention
    to how this works in the preceding code.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图示中，我们可以看到**HELLO**的开始是如何被翻译为与响应短语**SALUT**（法语中的*hello*）相对应的，这一步是在响应短语之前发生的。请注意在前面的代码中这如何实现。
- en: 'We then build the layers that will map to our network model with the code as
    follows:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们构建将映射到我们网络模型的层，代码如下：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note how we are creating encoder and decoder inputs along with decoder outputs.
    This code builds and trains the `model` and then saves it for later use in inference.
    We use the term *inference* to mean that a model is inferring or generating an
    answer or response to some input. A diagram of this sequence-to-sequence model
    in layer architecture follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意我们是如何创建编码器和解码器输入以及解码器输出的。此代码构建并训练了`model`，然后将其保存以供后续推理使用。我们使用术语*推理*来表示模型正在推断或生成对某些输入的答案或响应。接下来是该序列到序列模型在层级结构中的示意图：
- en: '![](img/12795ffb-7a9e-46ca-a40a-668fcc1467e3.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12795ffb-7a9e-46ca-a40a-668fcc1467e3.png)'
- en: Encoder/decoder inference model
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 编码器/解码器推理模型
- en: 'This model is quite complex and there is a lot going on here. We have just
    covered the first part of the model. Next, we need to cover the building of the
    thought vector and generating the sampling models. The final code to do this follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个模型相当复杂，涉及了许多内容。我们刚刚讲解了模型的第一部分。接下来，我们需要讲解构建思维向量和生成采样模型。生成这部分代码如下：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Look over this code and see whether you can understand the structure. We are
    still missing a critical piece of the puzzle and we will cover that in the next
    section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这段代码，看看你是否能理解其结构。我们仍然缺少一个关键部分，接下来将在下一节中讨论。
- en: Thought vectors
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思维向量
- en: At the middle of the encoding and decoding text process is the generation of
    a thought vector. The **thought vector**, popularized by the godfather himself,
    Dr. Geoffrey Hinton, represents a vector that shows the context of one element
    in relation to many other elements.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码和解码文本处理的中间部分是生成思维向量。**思维向量**由“教父”Geoffrey Hinton博士推广，代表了一个向量，显示了一个元素与许多其他元素之间的上下文关系。
- en: For instance, the word *hello *could have a high relational context to many
    words or phrases, such as *hi*, *how are you?*, *hey*, *goodbye*, and so on. Likewise,
    words such as* red, blue, fire,* and *old* would have a low context when associated
    with the word *hello*, *at* least in regular day-to-day speech. The word or character
    contexts are based on the pairings we have in the machine translation file. In
    this example, we are using the French translation pairings, but the pairings could
    be anything.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，单词*hello*可能与许多单词或短语有较高的关联上下文，比如*hi*、*how are you?*、*hey*、*goodbye*等等。同样，单词如*red*、*blue*、*fire*和*old*在与单词*hello*关联时的上下文会较低，*至少*在日常口语中是如此。单词或字符的上下文是基于我们在机器翻译文件中的配对。在这个例子中，我们使用的是法语翻译配对，但这些配对可以是任何语言的。
- en: 'This process takes place as part of the first encoding model into the thought
    vector or, in this case, a vector of probabilities. The LSTM layer calculates
    the probability or context of how the words/characters are related. You will often
    come across the following equation, which describes this transformation:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程是将第一个编码模型转换为思维向量的一部分，或者在这个例子中是一个概率向量。LSTM 层计算单词/字符之间如何关联的概率或上下文。你将经常遇到以下方程，它描述了这个转换过程：
- en: '![](img/bdbd394e-5e98-4223-9edf-54a2cce63f6d.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bdbd394e-5e98-4223-9edf-54a2cce63f6d.png)'
- en: 'Consider the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下内容：
- en: '![](img/25c0b6a5-acb5-430e-99f6-5fd59f56313c.png)= output sequence'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](img/25c0b6a5-acb5-430e-99f6-5fd59f56313c.png) = 输出序列'
- en: '![](img/3d1c7405-9215-42e5-90fc-ae7c618d0549.png) = input sequence'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](img/3d1c7405-9215-42e5-90fc-ae7c618d0549.png) = 输入序列'
- en: '![](img/c3d20d3e-814a-4d58-baa8-d853a83e2572.png)= Vector representation'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](img/c3d20d3e-814a-4d58-baa8-d853a83e2572.png) = 向量表示'
- en: The ![](img/63dfa677-e45e-441c-a9ea-28c0a85f887b.png) represents the multiplication
    form of sigma (![](img/b107c7b6-9f98-40a1-b8c9-ebe14b24cffd.png)) and is used
    to pool the probabilities into the thought vector. This is a big simplification
    of the whole process, and the interested reader is encouraged to Google more about
    sequence-to-sequence learning on their own. For our purposes, the critical thing
    to remember is that each word/character has a probability or context that relates
    it to another. Generating this thought vector can be time consuming and memory-intensive,
    as you may have already noticed. Therefore, for our purposes, we will look at
    a more comprehensive set of natural language tools in order to create a neural
    conversational bot in the next section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 ![](img/63dfa677-e45e-441c-a9ea-28c0a85f887b.png) 表示 sigma 的乘法形式 (![](img/b107c7b6-9f98-40a1-b8c9-ebe14b24cffd.png))，并用于将概率汇聚成思维向量。这是对整个过程的一个大大简化，感兴趣的读者可以自行在
    Google 上查找更多关于序列到序列学习的资料。对于我们的目的，关键是要记住，每个词/字符都有一个概率或上下文，将其与另一个词/字符关联起来。生成这个思维向量可能会非常耗时且占用大量内存，正如你可能已经注意到的那样。因此，在我们的应用中，我们将查看一组更全面的自然语言工具，以便在接下来的章节中创建一个神经对话机器人。
- en: DeepPavlov
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DeepPavlov
- en: '**DeepPavlov** is a comprehensive open source framework for building chatbots
    and other conversational agents for a variety of purposes and tasks. While this
    bot is designed for more goal-oriented bots, it will suit us well, as it is full-featured
    and includes several sequence-to-sequence model variations. Let''s take a look
    at how to build a simple pattern (sequence-to-sequence) recognition model in the
    following steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**DeepPavlov** 是一个全面的开源框架，用于构建聊天机器人和其他对话代理，适用于各种目的和任务。虽然这个机器人是为目标导向型的机器人设计的，但它非常适合我们，因为它功能全面，并且包含几种序列到序列模型的变体。接下来让我们看看如何在以下步骤中构建一个简单的模式（序列到序列）识别模型：'
- en: 'Up until now, we have kept our Python environment loose, but that has to change.
    We now want to isolate our development environment so that we can easily replicate
    it to other systems later. The best way to do this is working with Python virtual
    environments. Create a new environment and then activate it with the following
    commands at an Anaconda window:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直保持 Python 环境比较宽松，但这必须改变。我们现在想要隔离我们的开发环境，以便稍后可以轻松地将其复制到其他系统。做到这一点的最佳方式是使用
    Python 虚拟环境。创建一个新环境，然后在 Anaconda 窗口中使用以下命令激活它：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you don''t use Anaconda, the process is a bit more involved, as follows:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你没有使用 Anaconda，过程就会稍微复杂一些，步骤如下：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then we need to install DeepPavlov with the following command at a shell or
    an Anaconda window:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要在 shell 或 Anaconda 窗口中使用以下命令安装 DeepPavlov：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This framework will attempt to install several libraries and may disrupt any
    existing Python environments. This is the other reason we are now using virtual
    environments.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个框架将尝试安装几个库，并可能会干扰现有的 Python 环境。这也是我们现在使用虚拟环境的另一个原因。
- en: 'For our purposes, we are just going to look at the basic `Hello World` sample
    that is very simple to follow now that we have covered the background. We first
    do our imports as per standard as follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们将只查看基本的 `Hello World` 示例，现在我们已经涵盖了背景知识，它非常容易理解。我们首先按照标准导入库，代码如下：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, DeepPavlov is based on Keras, but as you can see, the types we are using
    here wrap the functionality of a sequence-to-sequence pattern-matching model.
    The `PatternMatchingSkill` represents the sequence-to-sequence model we want to
    give our chatbot agent. Next, we import the `DefaultAgent` type, which is just
    the basic agent. After that, we introduce a confidence selector called `HighestConfidenceSelector`.
    Remember that the thought vector we generate is a vector of probabilities. The
    `HighestConfidenceSelector` selector always chooses the highest value relation
    or context that matches the corresponding word.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，DeepPavlov 是基于 Keras 的，但正如你所见，我们在这里使用的类型包装了一个序列到序列的模式匹配模型的功能。`PatternMatchingSkill`
    代表了我们想要赋予聊天机器人代理的序列到序列模型。接下来，我们导入 `DefaultAgent` 类型，它是一个基本代理。之后，我们引入一个名为 `HighestConfidenceSelector`
    的置信度选择器。记住，我们生成的思维向量是一个概率向量。`HighestConfidenceSelector` 选择器始终选择与相应词匹配的最高值关系或上下文。
- en: 'Next, we generate three sets of patterns with corresponding responses, shown
    in the following code:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们生成三组模式和对应的响应，如下代码所示：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Each `PatternMatchingSkill` represents a set of pattern/response-contextual
    pairs. Note how there may be multiple responses and patterns for each. The other
    great thing about this framework is the ability to interchange and add skills.
    In this case, we are using just pattern matching, but there are plenty of other
    skills the reader is encouraged to explore.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个 `PatternMatchingSkill` 代表一组模式/响应上下文对。注意，每个模式可能对应多个响应和模式。这个框架的另一个优点是可以互换和添加技能。在这个例子中，我们只使用了模式匹配，但读者可以探索更多其他技能。
- en: 'Finally, we build the agent and run it by simply printing the results with
    the final bit of code:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过简单地打印结果来构建代理并运行它，代码如下：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This last section of code creates a `DefaultAgent` with the three skills (`hello`,
    `bye`, and `fallback`) using the `HighestConfidenceSelector`. Then it runs the
    agent by feeding a set of three inputs nested inside the `print` statement.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码的最后部分创建了一个 `DefaultAgent`，包含了三个技能（`hello`、`bye` 和 `fallback`），并使用 `HighestConfidenceSelector`。然后，通过将三组输入嵌套在
    `print` 语句中，运行该代理。
- en: Run the code as you normally would and look at the output. Is it what you expected?
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样运行代码并查看输出结果。它是你预期的结果吗？
- en: The simplicity of DeepPavlov makes it an excellent tool to build up various
    conversational chatbots for your games or other purposes if you so choose. The
    framework itself is very broad-featured and provides multiple natural language
    processing tools for a variety of tasks, including goal-oriented chatbots. Whole
    books could and probably should be written about Pavlov; if you have an interest
    in this, look more for NLP and DeepPavlov.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: DeepPavlov 的简洁性使它成为构建各种对话聊天机器人（用于游戏或其他目的）的一款优秀工具。该框架本身功能非常强大，并提供了多种自然语言处理工具，适用于多种任务，包括面向目标的聊天机器人。整个书籍可能会、也应该会围绕
    Pavlov 写；如果你对此感兴趣，可以进一步查找 NLP 和 DeepPavlov 相关的资料。
- en: With our new tool in hand, we now need a platform in which to serve up our bots
    with great conversational abilities. In the next section, we explore how to build
    a server for our bot.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有了新的工具，我们现在需要一个平台来提供具有出色对话能力的机器人。在接下来的部分，我们将探讨如何为我们的机器人构建一个服务器。
- en: Building the chatbot server
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建聊天机器人服务器
- en: Python is a great framework and it provides a number of great tools for game
    development. However, we are going to focus on using Unity for our purposes. Unity
    is an excellent and very user-friendly game engine that will make setting up complex
    examples in later chapters a breeze. Don't worry if you don't know C#, the language
    of Unity, since we will be manipulating the engine through Python in many cases.
    This means we want the ability to run our Python code outside Unity and we want
    to do it on a server.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一个很棒的框架，提供了许多用于游戏开发的优秀工具。然而，我们将专注于使用 Unity 来满足我们的需求。Unity 是一个出色且非常用户友好的游戏引擎，它将使得在后续章节中设置复杂的示例变得轻松。即使你不懂
    C#（Unity 的语言），也不用担心，因为我们在很多情况下将通过 Python 来操作引擎。这意味着我们希望能够在 Unity 之外运行我们的 Python
    代码，并且希望能够在服务器上执行。
- en: If you are developing your game in Python, using a server then becomes optional,
    except that there are very compelling reasons to set up your AI bots as services
    or microservices. Microservices are self-contained succinct applications or services
    that only interface through some form of well-known communication protocol. **AI
    Microservices** or **AI as a Service** (**AIaaS**) are quickly outpacing other
    forms of SaaS, and it will only be a matter of time untill this same business
    model converts to gaming as well. In any case, for now, the benefit we gain from
    creating our chatbot as a microservice is **decoupling**. Decoupling will allow
    you to easily convert this bot to other platforms in the future.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在用 Python 开发游戏，那么是否使用服务器变得可选，除非有非常强烈的理由将你的 AI 机器人设置为服务或微服务。微服务是自包含的简洁应用或服务，通常通过一些知名的通信协议进行交互。**AI
    微服务** 或 **AI 即服务**（**AIaaS**）正在迅速超过其他形式的 SaaS，并且这一商业模式迟早会扩展到游戏领域。无论如何，目前我们从将聊天机器人创建为微服务中获得的好处是
    **解耦**。解耦将使你未来能够轻松地将这个机器人迁移到其他平台。
- en: Microservices also introduce a new communication pattern into the mix. Typically,
    when a client app connects to a server, the communication is direct and immediate.
    But what if your connection is broken or the communication needs to be filtered,
    duplicated, or stored for later analysis or reuse? Then using a direct communication
    protocol becomes burdened by adding these additional functions, when it doesn't
    need to be. Instead, microservices introduce the concept of a **message hub**.
    This is essentially a container or post office where all the message traffic passes
    through. This allows for incredible flexibility and offlines the need for our
    communication protocol to manage extra tasks. We will take a look at how to install
    a very easy-to-use message hub in the next section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务还引入了一种新的通信模式。通常，当客户端应用连接到服务器时，通信是直接且即时的。但如果你的连接中断，或者需要对通信进行筛选、复制或存储以便以后分析或重用呢？这时，使用直接的通信协议就会被附加的功能所拖累，实际上这些功能本不需要在直接协议中实现。相反，微服务引入了
    **消息中心** 的概念。它本质上是一个容器或邮局，所有的消息流量都通过这里。这带来了极大的灵活性，并将我们的通信协议从管理额外任务的负担中解放出来。接下来的部分，我们将看看如何安装一个非常易用的消息中心。
- en: Message hubs (RabbitMQ)
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息中心（RabbitMQ）
- en: 'If you have never come across the concept of microservices or message hubs
    before, you may be somewhat daunted by what is coming next. Don''t be. Message
    hubs and microservices are designed to make it easier to connect, route, and troubleshoot
    issues with multiple services that need to talk to one another. As such, these
    systems are designed to be easy to set up, and easier to use. Let''s see how easy
    it is to set up an excellent message queue platform called RabbitMQ in the next
    exercise:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前从未接触过微服务或消息中心的概念，接下来的内容可能会让你有些担忧。但不必担心。消息中心和微服务的设计目的是使多个需要互相通信的服务更容易连接、路由和排除故障。因此，这些系统的设计是易于设置和使用的。让我们看看接下来的练习中，如何轻松地设置一个叫做
    RabbitMQ 的优秀消息队列平台：
- en: Navigate your browser over to [https://www.rabbitmq.com/#getstarted](https://www.rabbitmq.com/#getstarted).
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器访问 [https://www.rabbitmq.com/#getstarted](https://www.rabbitmq.com/#getstarted)。
- en: 'Download and install RabbitMQ for your platform. There is typically a download
    button near the top of the page. You may be prompted to install Erlang, as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并为你的平台安装 RabbitMQ。通常，页面顶部会有一个下载按钮。你可能会被提示安装 Erlang，如下所示：
- en: '![](img/fd935c3c-eba2-4cd0-bb68-5ba1c950a390.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd935c3c-eba2-4cd0-bb68-5ba1c950a390.png)'
- en: Erlang warning dialog
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Erlang 警告对话框
- en: Erlang is a concurrent functional programming language and perfect for writing
    messaging hubs. If you don't have it on your system, just download and install
    it, again for your platform; next, restart the RabbitMQ installation.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Erlang 是一种并发函数式编程语言，非常适合编写消息中心。如果你的系统没有安装它，只需下载并安装适合你平台的版本；接下来，重新启动 RabbitMQ
    的安装。
- en: 'For the most part, follow the installation choosing the defaults, except for
    the installation path. Make sure to keep the installation path short and memorable,
    as we will want to find it later. An example of setting the path in the installer
    for Windows as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大部分情况下，按照默认选项进行安装，除了安装路径。确保将安装路径设置得简短且易于记忆，因为稍后我们需要找到它。以下是在 Windows 上的安装程序中设置路径的示例：
- en: '![](img/a76e19d5-3010-4f8f-bb1f-adb38f4e34f6.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a76e19d5-3010-4f8f-bb1f-adb38f4e34f6.png)'
- en: Example of setting the installation path on Windows
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上设置安装路径的示例
- en: RabbitMQ will install itself as a service on your platform. Depending on your
    system, you may get a number of security prompts requesting firewall or admin
    access. Just allow all these exceptions, as the hub needs full access. When the
    installation completes, RabbitMQ should be running on your system. Be sure to
    check the documentation for your platform if you have any concerns on the configuration
    or setup. RabbitMQ is designed to use secure communication but keeps itself fairly
    open for development. Please avoid installing the hub in a production system,
    and expect to do some security configuration.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RabbitMQ将作为一个服务安装在您的平台上。根据您的系统，您可能会收到一些安全提示，要求防火墙或管理员权限。只需允许所有这些例外，因为该中心需要完全访问权限。当安装完成后，RabbitMQ应当在您的系统上运行。如果您对配置或设置有任何疑问，请务必查看您平台的文档。RabbitMQ设计为使用安全通信，但为了开发目的，它保持了相当开放的状态。请避免在生产系统中安装该中心，并准备进行一些安全配置。
- en: 'Next, we want to activate the RabbitMQ management tool so that we can get a
    good overview of how the hub works. Open up a Command Prompt and navigate to the
    `RabbitMQ` installation server folder (the one marked server). Then navigate to
    the `sbin` folder. When you are there, run the following command to install the
    management plugin (Windows or macOS):'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要激活RabbitMQ管理工具，以便我们能全面了解该中心的工作方式。打开命令提示符，导航到`RabbitMQ`安装服务器文件夹（标记为server）。然后导航到`sbin`文件夹。当您到达那里时，运行以下命令以安装管理插件（Windows或macOS）：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'An example of how this looks in a Windows Command Prompt follows:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是Windows命令提示符中显示的示例：
- en: '![](img/1293acf7-062f-45f3-8703-9d4fdb597da8.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1293acf7-062f-45f3-8703-9d4fdb597da8.png)'
- en: Installing the RabbitMQ management plugin
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 安装RabbitMQ管理插件
- en: That completes the installation of the hub on your system. In the next section,
    we will see how to inspect the hub with the management interface.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了您系统上中心的安装。在下一部分中，我们将看到如何使用管理界面检查该中心。
- en: Managing RabbitMQ
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理RabbitMQ
- en: RabbitMQ is a full-featured message hub that is very powerful and flexible in
    what it can do. There is a lot to RabbitMQ and it may be intimidating to some
    users less familiar with networking. Fortunately, we only need to use a few pieces
    right now, and in the future we will explore more functionality.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ是一个功能齐全的消息中心，具有非常强大和灵活的功能。RabbitMQ有很多特性，可能会让一些对网络不太熟悉的用户感到有些畏惧。幸运的是，我们现在只需要使用其中的一些功能，未来我们将探索更多的功能。
- en: 'For now, though, open up a browser and follow along these steps to explore
    the hub''s management interface:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，请打开浏览器，并按照以下步骤探索该中心的管理界面：
- en: Navigate your browser to `http://localhost:15672/` and you should see a login
    dialog.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中导航到`http://localhost:15672/`，您应该能看到一个登录对话框。
- en: Enter the username as `guest` and the password as `guest`. These are the default
    credentials and should work unless you've configured it otherwise.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入用户名`guest`和密码`guest`。这些是默认的凭据，除非您做了其他配置，否则应该有效。
- en: 'After you log in, you will see the RabbitMQ interface:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，您将看到RabbitMQ界面：
- en: '![](img/143641f0-db67-4da2-bb79-7fd03f000024.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/143641f0-db67-4da2-bb79-7fd03f000024.png)'
- en: RabbitMQ management interface
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ管理界面
- en: There is a lot going on here, so for now just click around and explore the various
    options. Avoid changing any settings, at least for now and until requested to
    do so. RabbitMQ is very powerful, but we all know that with great power comes
    great responsibility.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里有很多内容要了解，所以现在只需点击并探索各种选项。避免更改任何设置，至少在现在和未被要求之前不要更改。RabbitMQ非常强大，但我们都知道，强大的能力伴随着巨大的责任。
- en: Now, currently, your message queue is empty, so you won't see a lot of activity,
    but we will soon resolve that in the next section, where we learn how to send
    and receive messages to and from the queue.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，您的消息队列是空的，因此不会看到很多活动，但我们很快将在下一部分解决这个问题，届时我们将学习如何向队列发送和接收消息。
- en: Sending and receiving to/from the MQ
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向MQ发送和接收消息
- en: RabbitMQ uses a protocol called **Advanced Message Queuing Protocol** (**AMQP**)for
    communication, which is a standard for all messaging middleware. This means that
    we can effectively swap out RabbitMQ for a more robust system, such as Kafka,
    in the future. This also means that, for the most part, all of the concepts we
    cover here will likely apply to similar messaging systems.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ使用一种名为**高级消息队列协议**（**AMQP**）的协议进行通信，这是一种所有消息中间件的标准。这意味着我们可以在未来有效地将RabbitMQ替换为更强大的系统，例如Kafka。也就是说，大部分我们在这里讲解的概念也适用于类似的消息系统。
- en: 'The first thing we will do is put a message on the queue from a very simple
    Python client. Open up the source file `Chapter_4_3.py` and follow these steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是通过一个非常简单的Python客户端将一条消息放到队列中。打开源文件`Chapter_4_3.py`，并按照以下步骤操作：
- en: 'Open the source code file and take a look:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开源代码文件并查看：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code is taken from the RabbitMQ reference tutorial and shows how to connect.
    It first connects to the hub and opens a `queue` called `hello`. A queue is like
    a mailbox or stack of messages. A hub may have several different queues. Then
    the code publishes a message to the `hello` queue with the body of `Hello World!`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码来自RabbitMQ参考教程，展示了如何进行连接。它首先连接到中心并打开一个名为`hello`的`queue`（队列）。队列就像一个邮箱或一堆消息。一个中心可以有多个不同的队列。然后，代码将一条消息发布到`hello`队列，并且消息内容为`Hello
    World!`。
- en: 'Before we can run the sample, we first need to install `Pika`. Pika is an AMQP
    connection library and can be installed with the following command:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们运行示例之前，首先需要安装`Pika`。Pika是一个AMQP连接库，可以使用以下命令进行安装：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then run the code file as you normally would and watch the output. It's not
    very exciting, is it?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后像平常一样运行代码文件，并观察输出结果。其实并不是很激动人心，是吗？
- en: 'Go to the RabbitMQ management interface again at `http://localhost:15672/`
    and see that we now have a single message in the hub, as follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次访问RabbitMQ管理界面，地址为`http://localhost:15672/`，你会看到现在中心有一个消息，如下所示：
- en: '![](img/d9bffaeb-5bcf-47ac-bedf-9795061ae826.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9bffaeb-5bcf-47ac-bedf-9795061ae826.png)'
- en: RabbitMQ interface showing the addition of a message
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ界面，显示添加了一条消息
- en: The message we just sent will stay on the hub until we collect it later. This
    single feature will allow us to run individual services and make sure they are
    communicating correctly without having to worry about other consumers or publishers.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们刚刚发送的消息会留在中心，直到我们稍后取回。这一单一特性将使我们能够运行独立的服务，并确保它们能正确地进行通信，而无需担心其他消费者或发布者。
- en: 'For the purposes of RabbitMQ, we just wrote a publisher. In some cases, you
    many want a service or app to just publish messages, while in others you may want
    them to consume them. In the next exercise, `Chapter_4_4_py`, we will write a
    hub consumer or client:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于RabbitMQ而言，我们刚刚写了一个发布者。在某些情况下，你可能只希望某个服务或应用发布消息，而在其他情况下，你可能希望它们去消费消息。在接下来的练习中，`Chapter_4_4_py`，我们将编写一个中心消费者或客户端：
- en: 'Open the source file `Chapter_4_4.py` and look at the code:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开源文件`Chapter_4_4.py`，查看代码：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code is almost identical to the previous example, except that
    this time it only consumes from the queue using an internal `callback` function
    to receive the response. In this example, also note how the script blocks itself
    and waits for the message. In most cases, the client will register a callback
    with the queue in order to register an event. That event is triggered when a new
    message enters the particular queue.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上面的代码几乎与之前的示例相同，不同之处在于这次它仅通过内部的`callback`函数来接收响应并消费队列中的消息。在这个示例中，还可以注意到脚本如何阻塞自身并等待消息。在大多数情况下，客户端会注册一个回调函数到队列中，以注册一个事件。当新消息进入特定队列时，该事件会被触发。
- en: Run the code as you normally would and watch the first `Hello World` message
    get pulled from the queue and output on the client window.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像平常一样运行代码，观察到第一个`Hello World`消息从队列中被取出并在客户端窗口输出。
- en: Keep the client running and run another instance of the `Chapter_4_3.py` (publish)
    script and note how the client quickly consumes it and outputs it to the window.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持客户端运行，并运行另一个`Chapter_4_3.py`（发布）脚本，注意到客户端如何迅速消费并将其输出到窗口。
- en: This completes the simple send and receive communication to/from the message
    hub. As you can see, the code is fairly straightforward and the configuration
    works out of the box, for the most part. If you do experience any issues with
    this setup, be sure to consult the RabbitMQ tutorials, which are an additional
    excellent resource for extra help. In the next section, we look at how to build
    the working chatbot server example.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了与消息中心的简单发送和接收通信。正如你所看到的，代码相当简单，大多数配置开箱即用。如果在此设置过程中遇到任何问题，请务必查阅RabbitMQ教程，这是另一个极好的额外帮助资源。在下一部分，我们将学习如何构建一个工作的聊天机器人服务器示例。
- en: Writing the message queue chatbot
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写消息队列聊天机器人
- en: 'The chatbot server we want to create is essentially a combination of the three
    previous examples. Open up `Chapter_4_5.py` and follow the next exercise:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要创建的聊天机器人服务器本质上是前面三个示例的结合体。打开`Chapter_4_5.py`，并按照接下来的练习进行操作：
- en: 'The complete server code as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完整的服务器代码如下：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We essentially have a complete working `Hello World` chatbot server in fewer
    than 25 lines of code. Of course, the functionality is still limited, but by now
    you can certainly understand how to add other pattern-matching skills to the bot.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们基本上在不到 25 行代码的情况下完成了一个完整的 `Hello World` 聊天机器人服务器。当然，功能仍然有限，但到现在你肯定能理解如何为机器人添加其他模式匹配功能。
- en: 'The important thing to note here is that we are consuming from a queue called
    `chatin` and publishing to a queue called `chatout`. These queues are now wrapped
    in an exchange called `chat`. You can think of an exchange as a routing service.
    Exchanges provide for additional functionality around queues, and the great thing
    is that they are optional. For use, though, we want to use exchanges, because
    they provide us with better global control of our services. There are four types
    of exchanges used in RabbitMQ and they are summarized here:'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里需要注意的重点是，我们正在从一个名为`chatin`的队列中消费消息，并将其发布到一个名为`chatout`的队列中。这些队列现在被包装在一个名为`chat`的交换机中。你可以把交换机看作是一个路由服务。交换机为队列提供了额外的功能，最棒的是，它们是可选的。不过，出于使用上的考虑，我们希望使用交换机，因为它们提供了更好的全局控制。RabbitMQ
    中有四种类型的交换机，下面总结了它们：
- en: '**Direct**: Messages are sent directly to the queue marked in the message transmission.'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Direct**：消息直接发送到消息传输中标记的队列。'
- en: '**Fanout**: Duplicate the message to all queues wrapped by the exchange. This
    is great when you want to add logging or historical archiving.'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fanout**：将消息复制到交换机所包装的所有队列。这在你想添加日志记录或历史归档时非常有用。'
- en: '**Topic**: This allows you to send messages to queues identified by matching
    the message queue. For instance, you could send a message to the queue `chat`
    and any queue wrapped in the same exchange containing the word *chat* receives
    the message. The topic exchange allows you to group like messages.'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题**：这允许你将消息发送到通过匹配消息队列标识的队列。例如，你可以将消息发送到`chat`队列，任何包含*chat*单词的队列都能收到这条消息。主题交换允许你将类似的消息分组。'
- en: '**Headers**: This works similar to the topic exchange but instead filters based
    on the headers in the message itself. This is a great exchange to use for dynamic
    routing of messages with the appropriate headers.'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部**：这与主题交换类似，但它是基于消息本身的头部进行过滤。这是一个很好的交换方式，用于动态路由带有适当头部的消息。'
- en: Run the `Chapter_4_5.py` server example and keep it running.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`Chapter_4_5.py`服务器示例并保持它在运行。
- en: 'Next, open the `Chapter_4_6.py` file and look at the code shown:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`Chapter_4_6.py`文件并查看显示的代码：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code is just a sample client we can use to test the chatbot server.
    Note how the message variable `chat` is set to `'boo'`. When you run the code,
    check the output window of the chatbot server; this is the `Chapter_4_5.py` file
    we ran earlier. You should see a response message logged in the window that is
    appropriate to the chat message we just sent.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上面的代码只是一个示例客户端，我们可以用它来测试聊天机器人服务器。注意变量`chat`被设置为`'boo'`。当你运行代码时，检查聊天机器人服务器的输出窗口；这就是我们之前运行的`Chapter_4_5.py`文件。你应该能在窗口中看到一个响应消息，它与我们刚发送的聊天消息相匹配。
- en: At this point, you could write a full chat client that could communicate with
    our chatbot in Python. However, we want to connect our bot up to Unity and see
    how we can use our bot as a microservice in the next section.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可以编写一个完整的聊天客户端，使用 Python 与我们的聊天机器人进行通信。然而，我们想将我们的机器人连接到 Unity，并在下一节中看看如何将我们的机器人作为微服务使用。
- en: Running the chatbot in Unity
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Unity 中运行聊天机器人
- en: '**Unity** is quickly becoming the standard game engine for learning to develop
    games, virtual reality, and augmented reality applications. Now it is quickly
    becoming the standard platform for developing AI and ML applications as well,
    partly due to the excellent reinforcement learning platform the team at Unity
    has built. This Unity ML platform is a key component in our desire to use the
    tool, since it currently is at the cutting edge of advanced AI for games.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**Unity**正迅速成为学习开发游戏、虚拟现实和增强现实应用的标准游戏引擎。现在，它也正在迅速成为开发 AI 和 ML 应用的标准平台，部分原因是
    Unity 团队构建了出色的强化学习平台。这个 Unity ML 平台是我们希望使用该工具的关键组成部分，因为它目前处于游戏领域的先进 AI 技术前沿。'
- en: The AI team at Unity, led by Dr. Danny Lange and their senior developer Dr.
    Arthur Juliani, have made numerous suggestions and contributions to ideas for
    content in this book, both directly and indirectly. This, of course, has had a
    huge impact on using Unity for major portions of this book.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 的 AI 团队，由丹尼·兰奇博士和高级开发者阿瑟·朱利安尼博士领导，直接和间接地为本书的内容创意提供了许多建议和贡献。当然，这对本书中大量使用
    Unity 的部分产生了巨大影响。
- en: 'Installing Unity is quite straightforward, but we want to make sure we get
    the installation just right the first time. Therefore, follow these steps to install
    a version of Unity on your system:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Unity 相当简单，但我们希望确保第一次安装时就能正确完成。因此，请按照以下步骤在系统上安装 Unity 版本：
- en: Navigate your browser to [https://store.unity.com/download](https://store.unity.com/download)
    and accept the terms, and then download the Unity Download Assistant. This is
    the tool that downloads and installs the pieces we need.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中访问 [https://store.unity.com/download](https://store.unity.com/download)，接受条款后，下载
    Unity 下载助手。这是用于下载和安装所需组件的工具。
- en: 'Run the Download Assistant and select the following minimum components to install,
    as shown in the dialog as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行下载助手并选择以下最低配置组件进行安装，如下图所示：
- en: '![](img/a18fa234-6ec2-42f3-98e2-702f88ccff5a.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a18fa234-6ec2-42f3-98e2-702f88ccff5a.png)'
- en: Selecting the installation components for Unity
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 Unity 安装组件
- en: Just be sure to install the latest version of Unity and select the components
    that match your preferred OS, as shown in the preceding screenshot. You may, of
    course, select other components at your discretion, but those are the minimum
    you will need for this book.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需确保安装最新版本的 Unity，并选择与你的操作系统相匹配的组件，如前述截图所示。当然，你可以根据自己的需求选择其他组件，但这些是本书所需的最低配置。
- en: 'Next, set the path to install Unity to a well-known folder. A good choice is
    to set the folder name equal to the version. This allows you to have multiple
    versions of Unity on the same system that you can easily find. The following screenshot
    shows how you may do this on Windows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将 Unity 安装路径设置为一个众所周知的文件夹。一个不错的选择是将文件夹名称设置为版本号。这样，你可以在同一系统上安装多个版本的 Unity，且能够轻松找到它们。以下截图展示了在
    Windows 上如何操作：
- en: '![](img/56789132-7359-4d00-90b2-3fd856a3199b.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56789132-7359-4d00-90b2-3fd856a3199b.png)'
- en: Setting the installation path to Unity
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Unity 安装路径
- en: Those are the only critical parts to the installation and you can continue installing
    the software using the defaults.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些就是安装过程中的关键部分，之后你可以使用默认设置继续安装软件。
- en: Launch the Unity editor after it installs and you will be prompted to log in.
    Unity requires you to have an account, regardless of whether you are using the
    free version. Go back to [unity.com](http://unity.com) and just create an account.
    After you are done setting up the account, go back in and log in to the editor.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完后启动 Unity 编辑器，你将被提示登录。无论你使用的是免费版本，Unity 都要求你有一个账户。返回 [unity.com](http://unity.com)，创建一个账户。完成账户设置后，返回并登录编辑器。
- en: After you log in, create a empty project called `Chatbot` and let the editor
    open to a blank scene.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，创建一个名为 `Chatbot` 的空项目，并让编辑器打开一个空白场景。
- en: Unity is a full-featured game engine and may be intimidating if this is your
    first visit. There are plenty of online tutorials and videos that can get you
    up to speed on the interface. We will do our best to demonstrate concepts simply,
    but if you get lost, just take your time and work through the exercise a few times.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 是一个功能齐全的游戏引擎，如果这是你第一次使用，可能会让你感到有些不知所措。网上有许多教程和视频，可以帮助你快速掌握界面。我们会尽量简单地演示概念，但如果你迷茫了，可以放慢节奏，反复练习几次。
- en: With Unity installed, we now have to install the components or assets that will
    allow us to easily connect to the chatbot server we just created. In the next
    section, we install the AMQP asset for Unity.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完 Unity 后，我们需要安装一些组件或资源，以便轻松连接到刚才创建的聊天机器人服务器。在下一节中，我们将为 Unity 安装 AMQP 资源。
- en: Installing AMQP for Unity
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Unity 安装 AMQP
- en: 'RabbitMQ has an excellent resource for plenty of cross-platform libraries that
    allow you to connect to the hub with ease. The library for C# does work well outside
    Unity but is problematic to set up. Fortunately, the good folks at Cymantic Labs
    have built and open sourced a version for Unity on GitHub. Let''s see how to install
    this code in the next exercise:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ 提供了丰富的跨平台库资源，允许您轻松连接到中心。C# 库在 Unity 外部运行良好，但设置起来有些问题。幸运的是，Cymantic
    Labs 的开发者们在 GitHub 上构建并开源了适用于 Unity 的版本。让我们在下一个练习中学习如何安装这段代码：
- en: 'Download and unpack the code using `git` or as a ZIP file from [https://github.com/CymaticLabs/Unity3D.Amqp](https://github.com/CymaticLabs/Unity3D.Amqp.git):'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `git` 或 ZIP 文件下载并解压代码，地址为 [https://github.com/CymaticLabs/Unity3D.Amqp](https://github.com/CymaticLabs/Unity3D.Amqp.git)：
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Switch to Unity from the menu, and select File | Open Project and navigate to
    the `Unity3D.Amqp\unity\CymaticLabs.UnityAmqp` folder where you installed the
    code. This will open the asset in its own project. Wait for the project to load.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单切换到 Unity，选择 文件 | 打开项目，并导航到您安装代码的 `Unity3D.Amqp\unity\CymaticLabs.UnityAmqp`
    文件夹。这将打开该资源的独立项目。等待项目加载。
- en: Open the `Assets/CymanticLabs/Amqp/Scenes` folder in the Project window (typically
    at the bottom).
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目窗口中打开 `Assets/CymanticLabs/Amqp/Scenes` 文件夹（通常位于底部）。
- en: Double-click on the **AmqpDemo** scene to open it in the editor.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 **AmqpDemo** 场景以在编辑器中打开它。
- en: 'Press the Play button at the top of the editor to run the scene. After you
    run the scene, you should see the following:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器顶部按下播放按钮运行场景。运行场景后，您应该会看到以下内容：
- en: '![](img/0f86dbe5-62dd-4302-8d5d-6fbce169709a.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f86dbe5-62dd-4302-8d5d-6fbce169709a.png)'
- en: Setting the Amqp connection and sending a message
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Amqp 连接并发送消息
- en: Press the Connect button to connect to the local RabbitMQ.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下连接按钮以连接到本地 RabbitMQ。
- en: Next, under Subscriptions, set the exchange to chat, and the queue to chatout,
    and click Subscribe. This will subscribe to the queue so we can see any return
    message in the Unity console window.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在订阅下，将交换设置为 chat，将队列设置为 chatout，并点击订阅。这将订阅队列，以便我们可以在 Unity 控制台窗口中看到任何返回的消息。
- en: Finally, under Publish, set the exchange to chat, and the queue to chatin, and
    type a message such as `hello`. Click the Send button and you should see a response
    from the bot in the console window.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在发布下，将交换设置为 chat，将队列设置为 chatin，并输入一条消息，例如 `hello`。点击发送按钮，您应该会在控制台窗口中看到机器人的回应。
- en: That sets up our working chatbot. Of course, this is just the start of what
    is possible and the reader is certainly encouraged to explore further, but keep
    in mind we will revisit this code later and make use of it in a later section
    of the book.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们的聊天机器人设置了工作环境。当然，这仅仅是可能性的开始，读者也应鼓励进行更深入的探索，但请记住，我们将在后续部分重新访问这段代码并加以利用。
- en: That completes this chapter, and now you can take advantage of it for further
    learning in the next section.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容已完成，现在您可以在下一部分继续学习并充分利用它。
- en: Exercises
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Use the following exercises to expand your learning and get more confident
    with the material in this chapter:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下练习来扩展您的学习，并在本章中更加自信地掌握内容：
- en: Go back to the first exercise and load another set of translations. Train the
    bot on those and see what responses are generated after training. There are plenty
    of other language files available for training.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到第一个练习并加载另一组翻译。对这些翻译进行训练，并查看训练后生成的回应。还有很多其他语言文件可以用来进行训练。
- en: Set up your own conversational training file using the English/French translation
    one as an example. Remember, the matching responses can be anything and not just
    translated text.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用英文/法文翻译文件作为示例，设置您自己的对话训练文件。记住，匹配的回应可以是任何内容，而不仅仅是翻译文本。
- en: Add additional pattern-matching skills to the DeepPavlov bot. Either the simple
    test one and/or the chatbot server.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 DeepPavlov 机器人添加额外的模式匹配技能。可以选择简单的测试技能或聊天机器人服务器技能。
- en: The DeepPavlov chatbot uses a highest-value selection criteria for selecting
    a response. DeepPavlov does have a random selector as well. Change the response
    selector on the chatbot to use random.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DeepPavlov 聊天机器人使用最高价值选择标准来选择回应。DeepPavlov 也有一个随机选择器。将聊天机器人的回应选择器更改为使用随机选择。
- en: Change the exchange type in the example to use Fanout and create a log queue
    to log messages.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将示例中的交换类型更改为使用 Fanout，并创建一个日志队列来记录消息。
- en: 'Change the exchange type to Topic and see how you can group messages. Warning:
    this will likely break the example; see whether you can fix it.'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将交换类型更改为Topic，并查看如何对消息进行分组。警告：这可能会导致示例出现问题；看看你是否能够修复它。
- en: Write a RabbitMQ publisher in Python that publishes to one or more different
    types of queues.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个Python的RabbitMQ发布者，向一个或多个不同类型的队列发布消息。
- en: Create an entire set of conversation skills using the pattern-matching skill.
    Then, see how well your bot converses with you.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用模式匹配技能创建一整套对话技能。然后，看看你的机器人与您对话的表现如何。
- en: Add additional skills of other types to the chatbot server. This may require
    some additional homework on your part.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为聊天机器人服务器添加其他类型的技能。这可能需要你做一些额外的功课。
- en: Write or run two chatbots over RabbitMQ and watch them converse with each other.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在RabbitMQ上编写或运行两个聊天机器人，并观察它们如何相互对话。
- en: Work through at least two or three of these exercises.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 至少完成其中两个或三个练习。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at building chatbots or neural conversational agents
    using neural networks and deep learning. We first saw what makes a chatbot and
    the main forms in use today: goal-oriented and conversational bots. Then we looked
    at how to build a basic machine translation conversational chatbot that used sequence-to-sequence
    learning.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用神经网络和深度学习构建聊天机器人或神经对话代理。我们首先了解了什么构成了聊天机器人以及当前使用的主要形式：目标导向型和对话型机器人。然后，我们研究了如何构建一个基本的机器翻译对话聊天机器人，使用了序列到序列学习。
- en: After getting a background in sequence learning, we looked at the open source
    tool DeepPavlov. DeepPavlov is a powerful chat platform built on top of Keras
    and designed for many forms of neural agent conversation and tasks. This made
    it ideal for us to use the chatbot server as a base. Then we installed RabbitMQ,
    a microservices message hub platform that will allow our bot and all manner of
    other services to talk together later on.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了序列学习的背景后，我们研究了开源工具DeepPavlov。DeepPavlov是一个强大的聊天平台，基于Keras构建，旨在处理多种形式的神经网络代理对话和任务。这使得它成为我们使用聊天机器人服务器作为基础的理想选择。接着，我们安装了RabbitMQ，这是一种微服务消息中心平台，未来将允许我们的机器人和其他各种服务进行交互。
- en: Finally, we installed Unity and then quickly installed the AMQP plugin asset
    and connected to our chatbot server.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们安装了Unity，并迅速安装了AMQP插件资源，并连接到我们的聊天机器人服务器。
- en: This completes our introductory section to deep learning, and, in the next section,
    we begin to get more into game AI by diving into **deep reinforcement learning**.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们关于深度学习的介绍部分，在下一部分，我们将通过深入探讨**深度强化学习**，开始更加专注于游戏 AI。
