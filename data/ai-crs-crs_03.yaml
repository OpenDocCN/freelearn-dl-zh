- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Python Fundamentals – Learn How to Code in Python
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python基础 – 学习如何编写Python代码
- en: This chapter is for people who have little or no experience with the Python
    programming language. If you already know how to use `for`/`while` loops, methods, and
    classes in Python, you can skip this chapter and you shouldn't have any problems
    later on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章适合那些对Python编程语言几乎没有或完全没有经验的人。如果你已经知道如何使用`for`/`while`循环、方法和类，你可以跳过本章，之后也不会遇到问题。
- en: If, however, you have not used Python before, or have only barely used it, I
    strongly recommend that you follow this guide. You'll learn how to code the elements
    of Python I mentioned in the previous paragraph, you'll fully understand the codes
    included in this book and you'll be able to code in Python on your own. I'll also
    give you some additional exercises, called "homework" throughout the chapter,
    which I strongly recommend that you do.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你以前没有使用过Python，或者只是稍微用过一点，我强烈建议你按照本指南进行学习。你将学习到我在上一段中提到的Python元素，完全理解本书中的代码，并能够独立编写Python代码。我还会在本章中提供一些额外的练习，叫做“作业”，我强烈建议你完成它们。
- en: 'Before you begin, open your Python editor. I recommend using the Google Colab
    notebook, introduced to you as part of your AI Toolkit in the previous chapter.
    All the code, along with homework solutions, are provided on the GitHub page of
    this book in `Chapter 3` in their corresponding section folders. Inside them,
    you will find two Python files: one (named the same as the section) is the code
    used in this book, while the `homework.py` file is the solution to the exercise.
    Instructions for each homework exercise will be provided at the end of each section.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始之前，打开你的Python编辑器。我推荐使用Google Colab笔记本，它在上一章的AI工具包中已介绍给你。所有代码和作业解答都可以在本书GitHub页面的`Chapter
    3`中找到，对应的部分文件夹里。里面有两个Python文件：一个（与章节同名）是本书中使用的代码，而`homework.py`文件是练习的解决方案。每个作业的指示将在每节的末尾提供。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Displaying text
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示文本
- en: Variables and operations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量和运算
- en: Lists and arrays
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表和数组
- en: '`if` statements and conditions'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`语句和条件'
- en: '`for` and `while` loops'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`和`while`循环'
- en: Functions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Classes and objects
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和对象
- en: Especially if you're starting from scratch, cover each section in the order
    they're presented here, and remember to try your hand at the homework. Let's get
    started!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是如果你是从零开始，按顺序覆盖每一部分，并记得尝试做作业。让我们开始吧！
- en: Displaying text
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示文本
- en: We'll begin with the most popular way of introducing any programming language;
    you'll learn how to display some text in the Python console. The console is a
    tool that's part of every Python editor, which shows the information we want or
    displays any errors that occurred (let's hope not to get any!).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从介绍任何编程语言的最常见方法开始；你将学会如何在Python控制台中显示一些文本。控制台是每个Python编辑器的一部分，它显示我们想要的信息或任何发生的错误（让我们希望没有错误！）。
- en: 'The easiest way to show something in our console is to use the `print()` method,
    just like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中显示内容的最简单方法是使用`print()`方法，就像这样：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The text above `print`, starting with `#`, is called a comment. Comments are
    excluded when executing code and are only visible to you.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`print`上面的文本，从`#`开始，是注释。执行代码时，注释会被忽略，只对你可见。'
- en: 'After running this short code in Google Colab, you''ll see this displayed:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Google Colab中运行这段简短的代码后，你将看到如下输出：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In conclusion, just put what you want to display into the brackets of the `print`
    method – text surrounded by quotes, as in this example, or variables.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，只需将你想显示的内容放入`print`方法的括号中——用引号括起来的文本，像这个例子一样，或者变量。
- en: If you're curious about what variables are, that's great – you'll learn about
    them after this exercise.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对变量是什么感到好奇，那太好了——你将在这个练习之后学习它们。
- en: Exercise
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: Using only one `print()` method, try to display two or more lines.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 只使用一个`print()`方法，尝试显示两行或更多行内容。
- en: '**Hint**: Try using the `\n` symbol.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：试试使用`\n`符号。'
- en: The solution is provided in the `Chapter 03/Displaying Text/homework.py` file
    on the GitHub page.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案可以在GitHub页面上的`Chapter 03/Displaying Text/homework.py`文件中找到。
- en: Variables and operations
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量和运算
- en: 'Variables are simply values that are allocated somewhere in the memory of our
    computer. They are similar to variables in mathematics. They can be anything:
    text, integers, or floats (a number with precision after the decimal point, such
    as 2.33).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 变量只是分配在计算机内存中某个地方的值。它们类似于数学中的变量。它们可以是任何东西：文本，整数或浮点数（小数点后带有精度的数字，例如2.33）。
- en: 'To create a new variable, you only need to write this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新变量，你只需要写这个：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, we have named a variable `x` and set its value to `2`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们命名了一个变量`x`并将其值设置为`2`。
- en: 'As in mathematics, you can perform some operations on these variables. The
    most common operations are addition, subtraction, multiplication, and division.
    The way to write them in Python is like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数学中一样，你可以对这些变量执行一些操作。最常见的操作是加法，减法，乘法和除法。在Python中，写法如下：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you look at it for the first time, it doesn't make much sense—how can we
    write that `x = x + 5`?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你第一次看到它，它可能没有太多意义 - 我们怎么能写出`x = x + 5`呢？
- en: In Python, and in most code, the "=" notation doesn't mean the two terms are
    equal. It means that we associate the new `x` value with the value of the old
    `x`, plus 5\. It is crucial to understand that this is not an equation, but rather
    the creation of a new variable with the same name as the previous one.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，以及大多数编程语言中，“=”符号并不意味着两个术语相等。它意味着我们将新的`x`值与旧的`x`值相关联，加上5。理解这一点非常重要，这不是一个等式，而是创建一个与之前同名的新变量。
- en: You can also write these operations as shown on the right side, in the comments.
    You'll usually see them written in this way, since it's more space efficient.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将这些操作写在右侧的注释中显示。通常你会看到它们以这种方式编写，因为这样更节省空间。
- en: 'You can also perform these operations on other variables, for example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以对其他变量执行这些操作，例如：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we created a new variable `y` and set it to `3`. Then, we added it to
    our existing `x`. Also, `x` will be displayed when you run this code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个新变量`y`并将其设置为`3`。然后，我们将它添加到我们现有的`x`中。当你运行这段代码时，也会显示`x`的值。
- en: 'So, what does `x` turn out to be after all these operations? If you run the
    code, you''ll get this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，经过所有这些操作后，`x`的结果是什么？如果你运行这段代码，你会得到这个结果：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you calculate these operations by hand, you will see that `x` does indeed
    equal `6.33`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你手工计算这些操作，你会发现`x`确实等于`6.33`。
- en: Exercise
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: Try to find a way to raise one number to the power of another.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试找到一种方法来将一个数的幂提高到另一个数。
- en: '**Hint**: Try using the `pow()` built-in function for Python.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：尝试使用Python的`pow()`内置函数。'
- en: The solution is provided in the `Chapter 03/Variables/homework.py` file on the
    GitHub page.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案可以在GitHub页面上的`Chapter 03/Variables/homework.py`文件中找到。
- en: Lists and arrays
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表和数组
- en: Lists and arrays can be represented with a table. Imagine a **one-dimensional**
    (**1D**) vector or a matrix, and you have just imagined a list/array.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和数组可以用表格表示。想象一下**一维**（1D）向量或矩阵，你刚刚想象到了一个列表/数组。
- en: Lists and arrays can contain data in them. Data can be anything – variables,
    other lists or arrays (these are called multi-dimensional lists/arrays), or objects
    of some classes (we will learn about them later).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和数组可以包含数据。数据可以是任何东西 - 变量，其他列表或数组（这些称为多维列表/数组），或者某些类的对象（我们稍后会学习它们）。
- en: 'For example, this is a 1D list/array containing integers:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个包含整数的一维列表/数组：
- en: '![](img/B14110_03_01.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14110_03_01.png)'
- en: 'And this is an example of a **two-dimensional** (**2D**) list/array, also containing
    integers:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个**二维**（2D）列表/数组的示例，也包含整数：
- en: '![](img/B14110_03_02.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14110_03_02.png)'
- en: 'In order to create a 2D list, you have to create a list of lists. Creating
    a list is very simple, just like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个二维列表，你必须创建一个列表的列表。创建列表非常简单，就像这样：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here we create four lists: `L1`, `L2`, `L3` and `L4`. The first two lists are
    empty – they have zero elements. The two subsequent lists have some predefined
    values in them. `L3` is a one-dimensional list, same as the one in the first image.
    `L4` is a two-dimensional list, the same as in the second image. As you can see,
    `L4` actually consists of three smaller 1D lists.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了四个列表：`L1`，`L2`，`L3`和`L4`。前两个列表是空的 - 它们没有任何元素。后两个列表中有一些预定义的值。`L3`是一个一维列表，与第一张图片中的相同。`L4`是一个二维列表，与第二张图片中的相同。正如你所看到的，`L4`实际上由三个较小的1D列表组成。
- en: Whenever I mention an array, I usually mean a "NumPy" array. NumPy is a Python
    library (a library is a collection of pre-coded programs that allows you to perform
    many actions without writing your code from scratch), widely used for list/array
    operations. You can think of a NumPy array as a special kind of list, with lots
    of additional functions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我提到数组时，我通常指的是"NumPy"数组。NumPy是一个Python库（库是一个包含预先编写的程序的集合，允许你在不编写代码的情况下执行很多操作），广泛用于列表/数组操作。你可以将NumPy数组视为一种特殊类型的列表，具有许多附加的功能。
- en: 'To create a NumPy array, you have to specify a size and use an initialization
    method. Here''s an example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个NumPy数组，你需要指定大小并使用初始化方法。下面是一个例子：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the first line, we import the NumPy library (as you can see, to import a
    library, you need to write `import`) and by using `as,` we give NumPy the abbreviation
    `np` to make it easier to use. Then, we create a new array that we call `nparray`,
    which is a 2D array of size 5 x 5, full of zeros. The initialization method is
    the part after the `.`; in this case, we initialize this array as full of zeros,
    by using the function `zeros`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们导入了NumPy库（正如你所看到的，要导入库，必须写`import`），然后通过使用`as`，我们给NumPy取了一个缩写`np`，以便于使用。接着，我们创建了一个新数组，命名为`nparray`，这是一个5
    x 5的二维数组，全部元素为零。初始化方法是`.`后面的部分；在这个例子中，我们通过`zeros`函数将数组初始化为零。
- en: In order to get access to the values in a list or array, you need to give the
    index of this value. For example, if you wanted to change the first element in
    the `L3` list, you would have to get its index. In Python, indexes start at `0`,
    so you would need to write `L3[0]`. In fact, you can write `print(L3[0])`and execute
    it, and you will see that, as you might hope, the number `3` will be displayed.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问列表或数组中的值，你需要提供该值的索引。例如，如果你想更改`L3`列表中的第一个元素，你必须找到它的索引。在Python中，索引从`0`开始，所以你需要写`L3[0]`。实际上，你可以写`print(L3[0])`并执行，它会显示你期望的数字`3`。
- en: Accessing a single value in a multi-dimensional list/array requires you to input
    as many indexes as there are dimensions. For example, to get `0` from our `L4`
    list, we would have to write `L4[1][1]`. `L4[1]` would return the entire second
    row, which is a list.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 访问多维列表/数组中的单个值时，你需要输入与维度数目相同的索引。例如，要从`L4`列表中获取`0`，你需要写`L4[1][1]`。`L4[1]`会返回整个第二行，它是一个列表。
- en: Exercise
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: Try to find the mean of all the numbers in the `L4` list. There are multiple
    solutions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试找出`L4`列表中所有数字的平均值。这里有多种解法。
- en: '**Hint**: The simplest solution makes use of the NumPy library. Check out some
    of its functions here: [https://docs.scipy.org/doc/numpy/reference/](https://docs.scipy.org/doc/numpy/reference/)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：最简单的解决方案是使用NumPy库。你可以在这里查看它的一些函数：[https://docs.scipy.org/doc/numpy/reference/](https://docs.scipy.org/doc/numpy/reference/)'
- en: The solution is provided in the `Chapter 03/Lists and Arrays/homework.py` file
    on the GitHub page.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案已提供在GitHub页面的`Chapter 03/Lists and Arrays/homework.py`文件中。
- en: if statements and conditions
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if语句和条件
- en: Now I would like to introduce you to a very useful tool in programming – `if` conditions!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我想向你介绍编程中一个非常有用的工具——`if`条件语句！
- en: They are widely used to check whether a statement is true or not. If the given
    statement is true, then some instructions for our code are followed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它们广泛用于检查一个语句是否为真。如果给定的语句为真，则会执行一些代码中的指令。
- en: 'I''ll present this subject to you with some simple code that will tell us whether
    a number is positive, negative, or equal to 0\. The code''s very short, so I''ll
    show you all of it at once:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过一些简单的代码向你展示这个主题，这段代码可以判断一个数字是正数、负数还是零。代码非常简短，所以我会一次性展示全部内容：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the first line, we introduce a new variable called `a` and we give it a value
    of `5`. This is the variable whose value we are going to check.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们引入了一个新变量`a`，并将其值设为`5`。这就是我们要检查值的变量。
- en: In the next line we check if this variable is greater than `0`. We do this by
    using an `if` condition. If `a` is greater than `0`, then we follow the instructions
    written in the indented block; in this case, it is only displaying the message
    `a is greater than 0`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行中，我们检查这个变量是否大于`0`。我们通过使用`if`条件语句来做到这一点。如果`a`大于`0`，则执行缩进块中的指令；在这个例子中，只有一条指令，就是显示消息`a
    is greater than 0`。
- en: 'Then, if the first condition fails, that is, if `a` is lower than or equal
    to `0`, we go to the next condition, which is introduced with `elif` (which is
    short for `else if`). This statement will check whether `a` is equal to zero or
    not. If it is, we follow the indented instruction, which will display a message
    displaying: `a is equal to 0`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果第一个条件失败，即`a`小于或等于`0`，我们将进入下一个条件，后者通过`elif`引入（`elif`是`else if`的缩写）。此语句将检查`a`是否等于零。如果是，我们执行缩进的指令，显示一条消息：`a
    等于 0`。
- en: The final condition is introduced via `else`. Instructions included in an `else`
    condition will always be followed when all other conditions fail. In this case,
    failing both conditions would mean that `a` < `0`, and therefore we would display
    `a is lower than 0`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最终条件通过`else`引入。`else`条件中的指令会在其他条件都失败时执行。在这种情况下，两个条件都失败意味着`a` < `0`，因此我们将显示`a
    小于 0`。
- en: 'It''s easy to predict what our code will return. It will be the first instruction,
    `print(''a is greater than 0'')`. And, in fact, once you run this code, this is
    what you will get:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易预测我们的代码将返回什么。它将是第一条指令，`print('a is greater than 0')`。事实上，一旦运行这段代码，你会得到如下输出：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In brief, `if` is used to introduce statement checking and the first condition,
    `elif` is used to check as many further conditions as we want, and `else` is a
    true statement when all other statements fail.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`if`用于引入语句检查和第一个条件，`elif`用于检查我们想要的多个进一步条件，而`else`是当所有其他语句都失败时的真语句。
- en: It's also important to know that once one condition is true, no other conditions
    are checked. So, in this case, once we enter the first condition and we see that
    it is true, we no longer check other statements. If you would like to check other
    conditions, you would need to replace the `elif` and `else` statements with new
    `if` statements. A new `if` always checks a new condition; therefore, a condition
    included in an `if` is always checked.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，一旦一个条件为真，其他条件将不再检查。所以，在这种情况下，一旦我们进入第一个条件并且发现它为真，我们就不再检查其他语句。如果你想检查其他条件，你需要将`elif`和`else`语句替换为新的`if`语句。新的`if`会检查新的条件；因此，`if`中的条件总是会被检查。
- en: Exercise
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: Build a condition that will check if a number is divisible by 3 or not.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个条件，检查一个数字是否能被 3 整除。
- en: '**Hint**: You can use a mathematical expression called modulo, which when used,
    returns the remainder from the division between two numbers. In Python, modulo
    is represented by `%`. For example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：你可以使用一种称为模运算的数学表达式，它在使用时返回两个数字相除后的余数。在 Python 中，模运算用`%`表示。例如：'
- en: 5 % 3 = 2
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 5 % 3 = 2
- en: 71 % 5 = 1
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 71 % 5 = 1
- en: The solution is provided in the `Chapter 03/If Statements/homework.py` file
    on the GitHub page.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案可以在 GitHub 页面上的`Chapter 03/If Statements/homework.py`文件中找到。
- en: for and while loops
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`for` 和 `while` 循环'
- en: You can think of a loop as continuously repeating the same instructions over
    and over until some condition is satisfied that breaks this loop. For example,
    the previous code was not a loop; since it was only executed once, we only checked
    `a` once.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把循环看作是不断重复相同的指令，直到满足某个条件打破循环。例如，之前的代码不是一个循环；因为它只执行了一次，所以我们只检查了一次`a`。
- en: 'There are two types of loops in Python:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中有两种循环类型：
- en: '`for` loops'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环'
- en: '`while` loops'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while` 循环'
- en: '`for` loops have a specific number of iterations. You can think of an iteration
    as a single execution of the specific instructions included in the `for` loop.
    The number of iterations tells the program how many times the instruction inside
    the loop should be performed.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环有一个特定的迭代次数。你可以将一次迭代看作是`for`循环中指定指令的单次执行。迭代次数告诉程序循环内的指令应该执行多少次。'
- en: 'So, how do you create a for loop? Simply, just like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何创建一个`for`循环呢？很简单，就像这样：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We initialize this loop by writing `for` to specify the type of loop. Then we
    create a variable `i,` that will be associated with integer values from `range
    (1,20)`. This means that when we enter this loop for the first time, `i` will
    be equal to `1`, the second time it will be equal to `2`, and so on, all the way
    to `19`. Why `19`? That's because in Python, upper bounds are excluded, so at
    the final iteration `i` will be equal to `19`. As for our instruction, in this
    case it's just showing the current `i` in our console by using the `print()` method.
    It's also important to understand that the main code does not progress until the
    for loop is finished.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过编写`for`来初始化这个循环，以指定循环类型。然后，我们创建一个变量`i,`，它将与`range(1,20)`中的整数值关联。这意味着当我们第一次进入这个循环时，`i`将等于`1`，第二次时将等于`2`，以此类推，一直到`19`。为什么是`19`？这是因为在Python中，区间的上界是排除的，因此在最后一次迭代时，`i`将等于`19`。至于我们的指令，在这种情况下，它只是通过使用`print()`方法在控制台显示当前的`i`。还需要理解的是，主代码在`for`循环完成之前不会继续执行。
- en: 'This is what we get once we execute our code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们执行代码后得到的结果：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can see that our code displayed every integer higher than 0 and lower than
    20.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们的代码显示了所有大于0且小于20的整数。
- en: 'You can also use a `for` loop to iterate through elements of a list, in the
    following way:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`for`循环按以下方式遍历列表中的元素：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we come back to our `L3` 1D list. This code iterates through every element
    in the `L3` list and displays it. If you run it, you will see all the elements
    of this array from `3` to `5`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们回到我们的`L3`一维列表。该代码会遍历`L3`列表中的每个元素并显示它。如果你运行它，你将看到从`3`到`5`的所有元素。
- en: '`while` loops, on the other hand, need a condition to stop. They go on as long
    as the given condition is satisfied. Take this `while` loop, for example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`while`循环需要一个停止条件。它会继续执行，直到给定的条件满足为止。以这个`while`循环为例：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we create a new variable called `stop`. This type of variable is called
    a bool, since it can be assigned only two values – `True` or `False`. Then, we
    create a variable called `i` that we'll use to count how many times our `while`
    loop is executed. Next, we create a `while` loop that will go on as long as the
    variable `stop` is `False`; only once `stop` is changed to `True` will the loop
    stop.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`stop`的新变量。这种类型的变量叫做布尔变量，因为它只能赋值为`True`或`False`。然后，我们创建了一个名为`i`的变量，来计算我们的`while`循环执行了多少次。接下来，我们创建了一个`while`循环，只有当变量`stop`为`False`时它才会继续执行；只有当`stop`被更改为`True`时，循环才会停止。
- en: In the loop, we increase `i` by 1, display it, and check if it is greater or
    equal to `19`. If it is greater or equal to `19`, we change `stop` to `True`;
    and as soon as we change `stop` to `True`, the loop will break!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中，我们将`i`增加1，显示它，并检查它是否大于或等于`19`。如果大于或等于`19`，我们将`stop`设置为`True`；一旦我们将`stop`设置为`True`，循环将中断！
- en: 'After executing this code, you will see the exact same output as in the `for`
    loop example, that is:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这段代码后，你将看到与`for`循环示例完全相同的输出，即：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It''s also very important to know that you can stack `for` and `while` loops
    inside each other. For example, to display all the elements from the 2D list `L4`
    we created previously, one after another, you would have to make one `for` loop
    that iterates through every row, and then another `for` loop (inside the previous
    one) that iterates through every value in this row. Something like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，非常重要的一点是你可以将`for`和`while`循环嵌套使用。例如，为了显示我们之前创建的2D列表`L4`中的所有元素，你需要创建一个`for`循环来遍历每一行，然后在这个循环内再创建一个`for`循环来遍历每一行中的每个值。像这样：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And running this yields the following output:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这段代码会得到以下输出：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This matches the `L4` list.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`L4`列表相匹配。
- en: In conclusion, `for` and `while` loops let us perform repetitive tasks with
    ease. `for` loops always work on a predefined range; you know exactly when they
    will stop. `while` loops work on an undefined range; just by looking at their
    `stop` condition, you may not be able to judge how many iterations will happen.
    `while` loops work as long as their particular condition is satisfied.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，`for`和`while`循环使我们能够轻松地执行重复任务。`for`循环总是作用于一个预定义的范围；你可以准确知道它们什么时候停止。`while`循环作用于一个未定义的范围；仅凭它们的`stop`条件，你可能无法判断会执行多少次迭代。`while`循环会一直执行，直到满足特定条件为止。
- en: Exercise
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: Build both `for` and `while` loops that can calculate the factorial of a positive
    integer variable.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 编写能够计算正整数变量阶乘的`for`和`while`循环。
- en: '**Hint**: Factorial is a mathematical function that returns the product of
    all positive integers lower or equal to the argument of this function. This is
    the equation:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：阶乘是一个数学函数，返回所有小于或等于该函数参数的正整数的乘积。这个公式是：'
- en: '*f*(*n*) = *n* * (*n* – 1) * (*n* – 2) *...* 1'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*(*n*) = *n* * (*n* – 1) * (*n* – 2) *...* 1'
- en: 'Where:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '*f*(*n*) – the factorial function'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*f*(*n*) – 阶乘函数'
- en: '*n* – the integer in question, the factorial of which we are searching for'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* – 目标整数，我们要计算该整数的阶乘'
- en: 'This function is represented by `!` in mathematics, for example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数在数学中由`!`表示，例如：
- en: 5! = 5 * 4 * 3 * 2 * 1 = 120
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 5! = 5 * 4 * 3 * 2 * 1 = 120
- en: 4! = 4 * 3 * 2 * 1 = 24
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 4! = 4 * 3 * 2 * 1 = 24
- en: The solution is provided in the `Chapter 03/For and While Loops/homework.py`
    file on the GitHub page.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案可以在GitHub页面的`Chapter 03/For and While Loops/homework.py`文件中找到。
- en: Functions
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: Functions are incredibly useful when you want to increase code readability.
    You can think of them as blocks of code outside the main flow of code. Functions
    are executed once they are called in the main code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在你想要提高代码可读性时非常有用。你可以把它们看作是主代码流程外的代码块。函数会在被主代码调用时执行。
- en: 'You write a function like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样写一个函数：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first three lines are a newly created function called `division`, and the
    last two lines are part of the main code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前三行是新创建的一个名为`division`的函数，后两行是主代码的一部分。
- en: 'You can create a function by writing `def` and then writing the function''s
    name. After the name, you put brackets and within them write the arguments of
    the function; these are some variables that you will be able to use inside of
    your function and are a part of the connection between the main code and the function.
    In this case, our function takes two arguments: `a` and `b`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过编写`def`来创建一个函数，然后写下函数的名称。名称后面加上括号，并在其中写下函数的参数；这些是你可以在函数内使用的变量，是主代码与函数之间的连接部分。在这个例子中，我们的函数接受两个参数：`a`和`b`。
- en: Then, once we enter our function, what we do is calculate `a` divided by `b`
    and call this division `result`. Then, in the last line of our function, we say
    `return` so that when we call this function in code, it will return a value. In
    this case, the returned value is `result`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们调用我们的函数时，我们做的就是计算`a`除以`b`并将这个除法结果称为`result`。接着，在函数的最后一行，我们说`return`，这样当我们在代码中调用这个函数时，它就会返回一个值。在这种情况下，返回的值是`result`。
- en: 'Next, we go back to our main code and call our function. We do that by writing
    `division` and then in the brackets we input two numbers that we would like to
    divide. Remember, the `division` function returns a `result` of this division;
    therefore, we create a variable, `d`, that will hold this returned value. In the
    last line, we simply display `d` to see whether this code really works. If you
    run it, you''ll get the output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们回到主代码中并调用我们的函数。我们通过写`division`来做到这一点，然后在括号内输入我们想要除的两个数字。记住，`division`函数返回的是这次除法的`result`；因此，我们创建了一个变量`d`来保存这个返回值。在最后一行，我们简单地显示`d`来检查这段代码是否真的有效。如果你运行它，你将看到输出：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can confirm by hand, 3 divided by 5 is indeed 0.6; you can test it on
    other numbers as well.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你手动验证的那样，3除以5的确是0.6；你也可以用其他数字进行测试。
- en: In real-world code, functions can be much longer, and sometimes even call other
    functions. You will see them used a lot, even in the other chapters of this book.
    They also increase code readability, as you will see later; the code I've provided
    would be impossible to understand without functions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的代码中，函数可能会更长，有时甚至会调用其他函数。你会在本书的其他章节中看到它们的广泛应用。它们还提高了代码的可读性，正如你稍后会看到的那样；如果没有函数，我提供的代码将无法理解。
- en: Exercise
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 'Build a function to calculate the distance between two points on an *x,y* plane:
    one with coordinates `x1` and `y1`, and the other with coordinates `x2` and `y2`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个函数来计算二维平面上两点之间的距离：一个点的坐标为`x1`和`y1`，另一个点的坐标为`x2`和`y2`。
- en: '**Hint**: You can use the following formula:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：你可以使用以下公式：'
- en: '![](img/B14110_03_001.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14110_03_001.png)'
- en: The solution is provided in the `Chapter 03/Functions/homework.py` file on the
    GitHub page.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案可以在GitHub页面的`Chapter 03/Functions/homework.py`文件中找到。
- en: Classes and objects
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和对象
- en: Classes, like functions, are another part of code that sits outside of the main
    code, executed only when called in the main flow of code. Objects are instances
    of a corresponding class, existing within the main flow of our code. To better
    understand it, think of a class as a plan of something, for example, a plan of
    a car. It contains information on how certain components look and work with each
    other. A class in Python is a general plan of something.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 类和函数一样，都是位于主代码之外的另一部分代码，只有在主代码中调用时才会执行。对象是相应类的实例，存在于我们代码的主流程中。为了更好地理解它，可以将类视为某物的计划，例如一辆车的计划。它包含了某些组件的外观以及它们如何相互协作。Python中的类是某物的一种通用计划。
- en: You can think of objects as real-life constructions based on the plan. For example,
    a real, working, and self-driving car would be an example of an object. You create
    a plan of a car (which is a class) and then you build a car based on this plan
    (which is an object). And of course, when you have a plan of something, you can create
    as many copies as you want; for example, you can run a production line to produce cars.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将对象视为基于计划构建的现实世界中的构造物。例如，一辆真实、可工作的自动驾驶汽车就是一个对象的例子。你创建了一个车的计划（即类），然后你根据这个计划建造一辆车（即对象）。当然，当你有了某物的计划时，你可以根据这个计划创建任意多个副本；例如，你可以运行一个生产线来生产汽车。
- en: 'To give you more insight into classes, we will create a simple bot. We begin
    with writing a class, like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你对类有更深入的了解，我们将创建一个简单的`bot`。我们从编写一个类开始，像这样：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We write `class` to specify that we are creating a new class, which we name
    `Bot`. Then, a very important step is to write an `__init__()` method, which is
    a necessity when creating a class. This function is called automatically whenever
    an object of this class is created in the main flow of the code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们写`class`来指定我们正在创建一个新的类，我们将其命名为`Bot`。然后，一个非常重要的步骤是编写`__init__()`方法，这是创建类时的必要步骤。每当在代码的主流程中创建该类的对象时，这个函数会自动调用。
- en: All functions in a class need to take `self` as one argument. So, what is `self`?
    This parameter specifies that this function and its variables, whose names are
    preceded by `self`, are a part of this class. We will be able to call the `self`
    variables once we have an object of this class. Our bot's `__init__()` method
    also takes two arguments, `posx` and `posy`, which will be the initial position
    of our bot.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的所有函数都需要接受`self`作为一个参数。那么，`self`是什么？这个参数指定了这个函数及其变量（变量名以`self`为前缀）是这个类的一部分。只有在我们拥有该类的对象时，才能调用`self`变量。我们的`bot`的`__init__()`方法同样接受两个参数，`posx`和`posy`，这将是我们`bot`的初始位置。
- en: We have also created a method that will move our bot, by increasing or decreasing
    its `posx` and `posy`. A method is a function tucked inside a class. You can think
    of it as an instruction on how something has to work when we have a plan. For
    example, going back to the example of a car, a method could define the way our
    engine or gearbox works.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个方法，它将通过增加或减少`posx`和`posy`来移动我们的`bot`。方法是一个嵌入类中的函数。你可以将其视为一种说明，描述当我们拥有一个计划时，某个事物应该如何工作。例如，回到汽车的例子，方法可以定义我们的发动机或变速箱的工作方式。
- en: 'Now, you can create an object of this class. Remember, this will be a real-life
    object, constructed on the basis of a plan (`class`). Before, the class was predefined
    and didn''t work along with your code. After you create an object, the class becomes
    an integral part of your main code. We can achieve this by doing:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以创建该类的一个对象了。记住，这将是一个基于计划（`class`）构建的现实世界中的对象。之前，类是预定义的，并未与代码一起工作。创建对象后，类便成为了你主代码的一部分。我们可以通过如下方式实现：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will create a new object of class `Bot`; we called this object `bot`. We
    also need to specify the two arguments that the `__init__()` method of class `Bot`
    takes, which are `posx` and `posy`. This isn't optional; when creating an object,
    you always have to specify all the arguments given in the `__init__()` method.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个`Bot`类的新对象；我们将这个对象命名为`bot`。我们还需要指定`Bot`类的`__init__()`方法所接受的两个参数，分别是`posx`和`posy`。这不是可选的；在创建对象时，你必须始终指定`__init__()`方法中给出的所有参数。
- en: 'Now, in the main code, you can move the bot and display its new position, like
    this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在主代码中，你可以移动`bot`并显示它的新位置，像这样：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the first line, we use the `move` method from our `Bot` class. As you can
    see in its definition, `move` takes two arguments. These two arguments specify,
    respectively, by how much we will increase `posx` and `posy`. Then we just display
    the new `posx` and `posy`. This is where `self` comes into action; if the variables
    `posx` and `posy` were not preceded by `self` in our `Bot` class, we wouldn''t
    have access to them via the method. Running this code gives us this result:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们使用了 `Bot` 类中的 `move` 方法。如你所见，在其定义中，`move` 需要两个参数。这两个参数分别指定了我们将增加 `posx`
    和 `posy` 的量。然后我们只需显示新的 `posx` 和 `posy`。这就是 `self` 起作用的地方；如果在我们的 `Bot` 类中，`posx`
    和 `posy` 前面没有加上 `self`，我们就无法通过该方法访问它们。运行此代码会得到如下结果：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see from the result, our bot moved two units forward on the *x* axis
    and one unit backward on the *y* axis. Remember, `posx` was set to `3` initially
    and has now been increased by `2` using the `move` method from the `Bot` class;
    `posy` was set to `4` initially and has now been decreased by `1`, with the use
    of the same `move` method.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，结果显示我们的机器人在 *x* 轴上向前移动了两个单位，在 *y* 轴上向后移动了一个单位。记住，`posx` 最初设置为 `3`，并且通过
    `Bot` 类的 `move` 方法增加了 `2`；`posy` 最初设置为 `4`，并通过相同的 `move` 方法减少了 `1`。
- en: One great advantage of taking the time to code a `Bot` class is that now we
    are able to create as many bots as we want without making our code any longer.
    Simply put, objects are copies of a class and we can create as many of them as
    we want.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 `Bot` 类的一个巨大优势是，现在我们可以创建任意数量的机器人，而无需增加任何代码。简而言之，**对象是类的副本，我们可以创建任意数量的对象。**
- en: In conclusion, you can think of a class as a collection of predefined instructions
    and closed in methods, and you can think of an object as an instance of this class
    that is accessible in our code and that runs along with it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，你可以把类看作是一个包含预定义指令并封装在方法中的集合，而对象可以看作是类的一个实例，它在我们的代码中是可访问的，并与代码一同运行。
- en: Exercise
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: Your final challenge will be to build a very simple car class. As arguments,
    a car object should take the maximum velocity at which the car can move (unit
    in m/s), as well as the acceleration at which the car is accelerating (unit in
    m/s²). I also challenge you to build a method that will calculate the time it
    will take for the car to accelerate from the current speed to the maximum speed,
    knowing the acceleration (use the current speed as the argument of this method).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你的最终挑战是构建一个非常简单的汽车类。作为参数，汽车对象应该接收汽车能达到的最高速度（单位为 m/s），以及汽车的加速度（单位为 m/s²）。我还挑战你构建一个方法，计算汽车从当前速度加速到最高速度所需的时间，已知加速度（使用当前速度作为该方法的参数）。
- en: '**Hint**: To calculate the time required, you can use the following equation:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：要计算所需时间，你可以使用以下公式：'
- en: '![](img/B14110_03_002.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14110_03_002.png)'
- en: 'Where:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '![](img/B14110_03_003.png) – time required to achieve the top speed'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](img/B14110_03_003.png) – 达到最高速度所需的时间'
- en: '![](img/B14110_03_004.png) – maximum speed'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](img/B14110_03_004.png) – 最高速度'
- en: '![](img/B14110_03_005.png) – current speed'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](img/B14110_03_005.png) – 当前速度'
- en: '![](img/B14110_03_006.png) – acceleration'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](img/B14110_03_006.png) – 加速度'
- en: The solution is provided in the `Chapter 03/Classes/homework.py` file on the
    GitHub page.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案在 GitHub 页面上的 `Chapter 03/Classes/homework.py` 文件中提供。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the Python fundamentals that you'll need to keep
    up with the code presented in this book, from sending a simple text display to
    the console to writing your very first class in Python. You've now got all the
    skills you need to continue on your AI journey; in *Chapter 4*, *AI Foundation
    Techniques*, we will begin to study the foundational techniques of AI.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了学习 Python 基础知识所需的内容，帮助你跟上本书中的代码，从向控制台发送简单的文本显示，到编写你的第一个 Python 类。现在，你已经具备了继续你人工智能之旅所需的所有技能；在*第
    4 章*，*人工智能基础技术*中，我们将开始研究人工智能的基础技术。
