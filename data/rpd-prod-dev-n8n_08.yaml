- en: '*Chapter 6*: Powering Your API with a No Code Database'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：用无代码数据库为您的API供电'
- en: In this chapter, you will learn to work with no code databases for data storage.
    You will learn about no code databases, selecting a database for your project,
    and reading and writing to **Airtable**. You will also learn about some of the
    best practices when working with these databases. The concepts learned in this
    chapter will help you to use a data store for your projects to store user-generated
    data and build a complete product.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用无代码数据库进行数据存储。您将了解无代码数据库、为您的项目选择数据库以及如何向**Airtable**读写。您还将了解在处理这些数据库时的一些最佳实践。本章中学习到的概念将帮助您使用数据存储来存储用户生成数据并构建完整的产品。
- en: 'This chapter will cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: Learning about no code databases
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解无代码数据库
- en: Selecting a database for your project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的项目选择数据库
- en: Using **Airtable** for reading and writing data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Airtable**读写数据
- en: Best practices for working with databases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与数据库一起工作的最佳实践
- en: Optimizing your **application programming interface** (**API**) for production
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化您的**应用程序编程接口**（**API**）以用于生产
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here is a list of technical requirements that you''ll need to prepare before
    continuing with the chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本章之前，您需要准备以下技术要求列表：
- en: You have created an account on **Airtable**
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您已在**Airtable**上创建了一个账户
- en: n8n is running and the Editor **user interface** (**UI**) is open
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: n8n正在运行，并且编辑**用户界面**（**UI**）已打开
- en: Learning about no code databases
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解无代码数据库
- en: Databases often form the backbone of products. Databases are generally systems
    that store large amounts of data. The user can add, delete, or modify data while
    also viewing and performing calculations on that data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库通常是产品的骨架。数据库通常是存储大量数据的系统。用户可以在查看和执行数据计算的同时添加、删除或修改数据。
- en: 'Databases come in many different forms, such as **Structured Query Language**
    (**SQL**) databases, NoSQL databases, and time series databases. Depending on
    the use cases, it often makes sense to choose one over the other. A lot of these
    databases use query languages to be able to interact with the database to conduct
    basic queries such as inserting, reading, updating, and deleting data. You can
    see some database examples in the following screenshot:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库有多种形式，例如**结构化查询语言**（**SQL**）数据库、NoSQL数据库和时间序列数据库。根据用例，通常选择其中一种而不是另一种是有意义的。许多这些数据库使用查询语言来与数据库交互，以执行基本查询，如插入、读取、更新和删除数据。您可以在以下屏幕截图中看到一些数据库示例：
- en: '![Figure 6.1 – Historical trend chart from db-engines.com'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.1 – Historical trend chart from db-engines.com](img/Figure_6.01_B17493.jpg)'
- en: '](img/Figure_6.01_B17493.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.01_B17493.jpg](img/Figure_6.01_B17493.jpg)'
- en: Figure 6.1 – Historical trend chart from db-engines.com
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 来自db-engines.com的历史趋势图
- en: Since we are focusing on building a product with no code tools and we don't
    have the time to learn these query languages quickly, we'll have to look for some
    alternatives. Luckily, there are already a number of great alternatives that we
    can choose from. Two of the most popular ones are **Airtable** and **Google Sheets**.
    These tools are easier to use as compared to traditional databases as they employ
    a familiar spreadsheet-like design that is easier to comprehend than database
    models. Since these tools are rather robust as well, more and more people have
    started using them in their projects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们专注于使用无代码工具构建产品，而且我们没有时间快速学习这些查询语言，因此我们需要寻找一些替代方案。幸运的是，已经有一些非常好的替代方案可供选择。其中最受欢迎的两个是**Airtable**和**Google
    Sheets**。与传统的数据库相比，这些工具更容易使用，因为它们采用了熟悉的类似电子表格的设计，比数据库模型更容易理解。由于这些工具也非常强大，越来越多的人开始在他们的项目中使用它们。
- en: Both **Airtable** and **Google Sheets** have an n8n node, and we can use these
    nodes to perform **create, read, update, and delete** (**CRUD**) actions to power
    our API and application. Now that we have an idea about what no code databases
    are, let's think about how we can choose one that we can use during the duration
    of this book.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**Airtable**和**Google Sheets**都有一个n8n节点，我们可以使用这些节点来执行**创建、读取、更新和删除**（**CRUD**）操作，以为我们的API和应用提供动力。现在我们已经了解了无代码数据库是什么，让我们考虑一下我们如何在本书的持续时间中选择一个可以使用的产品。'
- en: Selecting a database for your project
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的项目选择数据库
- en: 'Apart from **Google Sheets** and **Airtable**, there are a number of really
    cool no code databases such as **Baserow**, **Supabase**, **SeaTable**, and **NocoDB**.
    How do we select the right database for our product? There are a couple of questions
    that you can ask yourself that might help in making this decision easier:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了**Google Sheets**和**Airtable**之外，还有许多真正酷的无代码数据库，如**Baserow**、**Supabase**、**SeaTable**和**NocoDB**。我们如何选择适合我们产品的正确数据库？你可以问自己一些问题，这些问题可能会帮助你更容易地做出这个决定：
- en: What do I want the database to do for my project?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我希望数据库为我的项目做什么？
- en: Does this tool have an n8n node or at least an API?
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个工具是否有n8n节点或至少一个API？
- en: How active is the community and support ecosystem for this tool?
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个工具的社区和支持生态系统有多活跃？
- en: What's the level of maturity of the product? Is it stable? Has it been in the
    market long enough to be battle-tested by users?
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品的成熟度水平如何？它是否稳定？它是否在市场上存在足够长的时间，以至于用户已经对其进行了实战测试？
- en: Are educational resources about the tool widely available? What's the learning
    curve like?
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于这个工具的教育资源是否广泛可用？学习曲线是什么样的？
- en: 'While choosing the no code database to include in this book, we asked ourselves
    the same questions. We decided to go with **Airtable** because of the following
    reasons:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择要包含在这本书中的无代码数据库时，我们问了自己同样的问题。我们决定选择**Airtable**，原因如下：
- en: '**Airtable** has a large community and an incredible support system.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Airtable**有一个庞大的社区和令人难以置信的支持系统。'
- en: '**Airtable** has a decent API with an easy authentication system. n8n has a
    well-documented **Airtable** node too!'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Airtable**有一个相当不错的API，并且有一个简单的身份验证系统。n8n也有一个很好的文档**Airtable**节点！'
- en: '**Airtable** has been around for a bit, and a lot of makers use it to build
    their projects.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Airtable**已经存在一段时间了，许多制造商都使用它来构建他们的项目。'
- en: '**Airtable** puts out a lot of educational content regularly and it''s straightforward
    to get started with.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Airtable**定期发布大量的教育资源，并且入门非常简单。'
- en: 'The following screenshot provides an overview of the **Airtable** database:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图提供了**Airtable**数据库的概述：
- en: '![Figure 6.2 – Airtable has a lot of educational resources and a strong community'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 – Airtable拥有大量的教育资源和一个强大的社区'
- en: '](img/Figure_6.02_B17493.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 – Airtable拥有大量的教育资源和一个强大的社区'
- en: Figure 6.2 – Airtable has a lot of educational resources and a strong community
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – Airtable拥有大量的教育资源和一个强大的社区
- en: While you are asking yourselves these questions, it is quite possible that your
    answers might be different depending on the project that you are planning to work
    on. That's okay! Each tool has its own niche and superpowers that might make it
    more suitable for a certain type of project.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你问自己这些问题时，你的答案可能会根据你计划工作的项目而有所不同。这是完全可以的！每个工具都有自己的利基和超级能力，这可能使它更适合某种类型的项目。
- en: Now that we've made sure that **Airtable** is the correct choice for us right
    now, let's take a look at how we can use it from n8n workflows.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定**Airtable**是我们目前正确的选择，让我们看看我们如何可以从n8n工作流中使用它。
- en: Using Airtable for reading and writing data
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Airtable读取和写入数据
- en: 'Let''s start off by creating a new base from scratch in `The n8n book`. Edit
    all the existing fields so that we have the following four fields with the single-line
    text field type:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`The n8n book`中从头创建一个新的基础开始。编辑所有现有的字段，以便我们有以下四个字段，字段类型为单行文本：
- en: '**UserID**'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户ID**'
- en: '**First Name**'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名字**'
- en: '**Last Name**'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**姓氏**'
- en: '**Email**'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电子邮件**'
- en: 'This is very similar to the table into which data was being inserted in the
    previous chapter. For the sake of brevity, we have taken out the **Password Hash**
    field. Your table should now look like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这与上一章中数据被插入的表格非常相似。为了简洁起见，我们移除了**密码哈希**字段。你的表格现在应该看起来像这样：
- en: '![Figure 6.3 – This is what your Airtable table should look like'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 – 这是你Airtable表格应该看起来的样子'
- en: '](img/Figure_6.03_B17493.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 – 这是你Airtable表格应该看起来的样子'
- en: Figure 6.3 – This is what your Airtable table should look like
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 这是你Airtable表格应该看起来的样子
- en: 'Now that we have prepared our table, let''s pop over to n8n''s Editor UI and
    follow these next steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了我们的表格，让我们转到n8n的编辑器UI，并遵循以下步骤：
- en: Create a new workflow and add a **Set** node to it. We'll need the **Set** node
    to make sure that we send well-formatted data to the **Airtable** node.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的工作流，并向其中添加一个**设置**节点。我们需要**设置**节点来确保我们向**Airtable**节点发送格式良好的数据。
- en: Open the `String type`. For each of these four values, do the following. In
    the `true` (green). In the **Value** field, enter anything you like.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`字符串类型`。对于这四个值中的每一个，执行以下操作。在`true`（绿色）中。在**值**字段中，输入任何你喜欢的。
- en: 'Click on the **Execute Node** button, and your **Set** node should look like
    this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**执行节点**按钮，你的**Set**节点应该看起来像这样：
- en: '![Figure 6.4 – Output from the Set node after following the aforementioned
    steps'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4 – 执行上述步骤后的Set节点输出'
- en: '](img/Figure_6.04_B17493.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.04_B17493.jpg)'
- en: Figure 6.4 – Output from the Set node after following the aforementioned steps
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 执行上述步骤后的Set节点输出
- en: 'Now that we have structured the data in a way that would correspond to the
    columns in **Airtable**, let''s add the **Airtable** node and connect it with
    the **Set** node. Here''s what your Editor UI should look like at this point:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经以与**Airtable**列相对应的方式结构化了数据，让我们添加**Airtable**节点并将其与**Set**节点连接起来。此时，你的编辑器UI应该看起来像这样：
- en: '![Figure 6.5 – The workflow should look like this at this point'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5 – 在这个阶段工作流程应该看起来像这样'
- en: '](img/Figure_6.05_B17493.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.05_B17493.jpg)'
- en: Figure 6.5 – The workflow should look like this at this point
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 在这个阶段工作流程应该看起来像这样
- en: 'Open the **Airtable** node and enter your credentials. You can find the API
    key by following the steps mentioned on this page: [https://docs.n8n.io/credentials/airtable/](https://docs.n8n.io/credentials/airtable/).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 打开**Airtable**节点并输入你的凭据。你可以通过遵循本页上提到的步骤找到API密钥：[https://docs.n8n.io/credentials/airtable/](https://docs.n8n.io/credentials/airtable/).
- en: 'Change the `Append`, since we want to insert the data from the `Table 1` in
    the **Table** field and click on the **Execute Node** button. It should now look
    like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`Append`，因为我们想从**Table 1**的**Table**字段插入数据，然后点击**执行节点**按钮。现在它应该看起来像这样：
- en: '![Figure 6.6 – Output from the Airtable node after following the aforementioned
    steps'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.6 – 执行上述步骤后的Airtable节点输出'
- en: '](img/Figure_6.06_B17493.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.06_B17493.jpg)'
- en: Figure 6.6 – Output from the Airtable node after following the aforementioned
    steps
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – 执行上述步骤后的Airtable节点输出
- en: 'If you go back to your **Airtable** base, you''ll notice that the record has
    been added to the table by this n8n workflow. Congratulations—you''ve just added
    your first record to **Airtable** using n8n! Here''s a screenshot that showcases
    how your **Airtable** table should look at this point and how it relates to the
    data that we structured in the **Set** node:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回到你的**Airtable**基础，你会注意到记录已经被这个n8n工作流程添加到表中。恭喜你——你刚刚使用n8n在**Airtable**中添加了你的第一条记录！以下是展示你的**Airtable**表在这个阶段应该看起来什么样以及它与我们在**Set**节点中结构化的数据之间关系的截图：
- en: '![Figure 6.7 – Record inserted into the Airtable table and how it related to
    the data from the Set node'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.7 – 插入到Airtable表中的记录以及它与Set节点中的数据的关系'
- en: '](img/Figure_6.07_B17493.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.07_B17493.jpg)'
- en: Figure 6.7 – Record inserted into the Airtable table and how it related to the
    data from the Set node
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – 插入到Airtable表中的记录以及它与Set节点中的数据的关系
- en: You can replace the **Start** node with other nodes to source the data that
    you want to add to **Airtable** and make the appropriate changes to the **Set**
    node. You might remember from the last chapter that we got the data from the API
    that we created using the **Webhook** node.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用其他节点替换**开始**节点来获取你想要添加到**Airtable**的数据，并对**Set**节点进行适当的更改。你可能还记得上一章中，我们使用**Webhook**节点从我们创建的API中获取数据。
- en: This combination of the **Set** node (to structure the data in a form expected
    by the database) and the **Airtable** node (to insert the data into **Airtable**)
    will remain the same across workflows. In case you want to use another database
    for some other project, you'd replace the **Airtable** node with that node.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种**Set**节点（用于以数据库期望的格式结构化数据）和**Airtable**节点（用于将数据插入到**Airtable**）的组合将在工作流程中保持不变。如果你想在某个其他项目中使用另一个数据库，你将用那个节点替换**Airtable**节点。
- en: 'Here are some key things to keep in mind about inserting data into databases:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中插入数据时，以下是一些需要记住的关键事项：
- en: Spreadsheets and databases have columns, such as **First Name** and **Last Name**.
    The data you send to a database node needs to match these column names for each
    row of data that you want to insert.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子表格和数据库都有列，例如**名字**和**姓氏**。你发送到数据库节点的数据需要与每行数据的这些列名相匹配。
- en: A lot of times, you might not get data from APIs in a form that works best for
    you. In those cases, the **Set** node can help you remodel the data that you need
    according to your database's columns and discard the data that you don't need.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很多次，你可能无法从API中获得最适合你的数据格式。在这种情况下，**Set**节点可以帮助你根据数据库的列重新建模你需要的数据，并丢弃你不需要的数据。
- en: Spreadsheet and database nodes in n8n perform their configured action (such
    as `Append`) on each item of input data.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: n8n中的电子表格和数据库节点会对输入数据的每个项目执行其配置的操作（例如`Append`）。
- en: Reading data from an `List` as the operation and enter the same credentials
    and **Base ID** value as the previous workflow.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将操作作为`List`读取数据并输入与上一个工作流程相同的凭据和**Base ID**值。
- en: 'Click on the **Execute Node** button, and the output should look like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**执行节点**按钮，输出应如下所示：
- en: '![Figure 6.8 – Output of the List operation of the Airtable node'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.8 – Output of the List operation of the Airtable node](img/Figure_6.8_B17493.jpg)'
- en: '](img/Figure_6.08_B17493.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_6.08_B17493.jpg](img/Figure_6.08_B17493.jpg)'
- en: Figure 6.8 – Output of the List operation of the Airtable node
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – Airtable节点列表操作的输出
- en: Now that we have listing data from `List` operation of the `Update` and `Delete`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从`Update`和`Delete`的`List`操作中列出数据。
- en: 'Consider this scenario: You need to find a record where the first name is `Nathan`
    and update the last name of the person to `Automaton`.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下场景：你需要找到一个名为`Nathan`的记录，并将该人的姓氏更新为`Automaton`。
- en: 'You can then build a workflow like the one shown in the following screenshot
    to update the particular record in the **Airtable** table:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以构建一个类似于以下截图所示的流程来更新**Airtable**表中的特定记录：
- en: '![Figure 6.9 – Updating a particular record in Airtable using an n8n workflow'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.9 – Updating a particular record in Airtable using an n8n workflow](img/Figure_6.09_B17493.jpg)'
- en: '](img/Figure_6.09_B17493.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_6.09_B17493.jpg](img/Figure_6.09_B17493.jpg)'
- en: Figure 6.9 – Updating a particular record in Airtable using an n8n workflow
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 – 使用n8n工作流程在Airtable中更新特定记录
- en: 'The first `Nathan`. If it isn''t, n8n goes to the `Nathan`, we use a **Set**
    node to add the new value for the **Last Name** field. Here''s what the **Set**
    node looks like after configuration and execution:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`Nathan`。如果不是，n8n将转到`Nathan`，我们使用**Set**节点添加**姓氏**字段的新值。以下是配置和执行后的**Set**节点的外观：
- en: '![Figure 6.10 – Configuring the Last Name field for updating the record with
    Nathan as the first name'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.10 – Configuring the Last Name field for updating the record with
    Nathan as the first name](img/Figure_6.10_B17493.jpg)'
- en: '](img/Figure_6.10_B17493.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_6.10_B17493.jpg](img/Figure_6.10_B17493.jpg)'
- en: Figure 6.10 – Configuring the Last Name field for updating the record with Nathan
    as the first name
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 – 配置以Nathan为名的记录更新姓氏字段
- en: 'And finally, we have the **Airtable1** node, which will update the record.
    We have used the ID of the record to be updated from the first **Set** node (we
    originally got it from the **Airtable** node) as well as specifying that only
    the **Last Name** field should be updated. You can see the **Airtable1** node
    here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有**Airtable1**节点，它将更新记录。我们使用了来自第一个**Set**节点的记录ID（我们最初从**Airtable**节点获取）以及指定只更新**姓氏**字段。你可以在以下位置看到**Airtable1**节点：
- en: '![Figure 6.11 – Configuring the Airtable1 node for updating the Last Name field
    of the record'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.11 – Configuring the Airtable1 node for updating the Last Name field
    of the record](img/Figure_6.11_B17493.jpg)'
- en: '](img/Figure_6.11_B17493.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_6.11_B17493.jpg](img/Figure_6.11_B17493.jpg)'
- en: Figure 6.11 – Configuring the Airtable1 node for updating the Last Name field
    of the record
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 – 配置Airtable1节点以更新记录的姓氏字段
- en: And voilà! The workflow has updated the **Last Name** column for the specified
    record in **Airtable**. You can use a similar workflow to delete records as well.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！该工作流程已更新**Airtable**中指定记录的**姓氏**列。你可以使用类似的工作流程来删除记录。
- en: When using this workflow as part of an API, you can get values such as the text
    for which to perform a lookup and which column to look in, as well as the updated
    record using the **Webhook** node. You can then use expressions to make sure that
    the API endpoint with this workflow can handle dynamic requests without having
    to create specific workflows for different columns. Now that we know how to work
    with no code databases using n8n, let's learn about some best practices for working
    with databases.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当将此流程作为API的一部分使用时，你可以获取要执行查找的文本以及要查找的列，以及使用**Webhook**节点更新的记录。然后，你可以使用表达式确保具有此工作流程的API端点可以处理动态请求，而无需为不同的列创建特定的流程。现在我们知道了如何使用n8n与无代码数据库一起工作，让我们来了解一下与数据库工作的最佳实践。
- en: Best practices for working with databases
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与数据库工作的最佳实践
- en: There are a lot of different aspects that go into working with databases that
    you will generally use in an enterprise environment, but things can be a bit different
    with no code databases. Because of how these databases are designed, built, and
    hosted, we need to think a bit differently when we use them.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业环境中使用数据库时，涉及到的不同方面有很多，但在无代码数据库中，情况可能略有不同。因为这些数据库的设计、构建和托管方式，我们在使用它们时需要稍微不同地思考。
- en: Let's take a look at some of the best practices around working with databases
    and how you can use them in a way that is both effective and efficient.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一些关于数据库操作的最佳实践，以及你如何以既有效又高效的方式使用它们。
- en: Minimizing bandwidth
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小化带宽
- en: While it is not always the case, no code databases are generally hosted somewhere
    on the internet. This means that you do not have as much bandwidth available between
    you and the database that you would use if the database were hosted on the same
    network, which is the case for traditional databases.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然并非总是如此，但无代码数据库通常托管在互联网上的某个地方。这意味着你与数据库之间的可用带宽不如数据库托管在同一网络上的传统数据库那样多。
- en: Because this bandwidth is now at a premium (and, depending upon how your database
    is hosted/priced, you may literally be paying for every byte that you send and/or
    receive from the database), it is very important that you make sure you use it
    wisely.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种带宽现在非常宝贵（并且，根据你的数据库是如何托管/定价的，你可能真的在为发送和/或从数据库接收的每个字节付费），确保你明智地使用它非常重要。
- en: Compressing data
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 压缩数据
- en: Often, the data that is stored in databases is text-based. Text data has a very
    high compression ratio, which reduces how much information needs to be sent or
    received between you and your database.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，存储在数据库中的数据是文本形式的。文本数据具有非常高的压缩率，这减少了你与数据库之间需要发送或接收的信息量。
- en: If you have the ability to compress data between the two systems, this will
    increase the speed of your transactions and reduce your bandwidth.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够在两个系统之间压缩数据，这将提高你事务的速度并减少你的带宽。
- en: However, keep in mind that this will also increase the **central processing
    unit** (**CPU**) utilization on both n8n and your database as the compression
    needs to be calculated on both sides.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，这也会增加n8n和你的数据库上的**中央处理单元**（**CPU**）利用率，因为压缩需要在双方进行计算。
- en: Minimizing API calls
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小化API调用
- en: API calls to your database, such as bandwidth, can be expensive (literally,
    if you are paying per API request). They take up resources, slow down your application
    (as the application needs to wait for the call to complete or time out), and increase
    dependencies on the database.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对你的数据库的API调用，如带宽，可能很昂贵（如果你按API请求付费，实际上是这样）。它们占用资源，减慢你的应用程序（因为应用程序需要等待调用完成或超时），并增加对数据库的依赖性。
- en: If you do everything you can to reduce API calls, these issues can be minimized
    or, in some cases, avoided altogether.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尽一切可能减少API调用，这些问题可以最小化，在某些情况下，甚至可以完全避免。
- en: Minimizing database queries
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小化数据库查询
- en: Because databases generally work very quickly, it is easy for us as developers
    to become lazy when accessing a database. Why bother modifying the code to write
    three records to the database with a single query when it is easier to write each
    record on its own in three separate queries?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据库通常运行非常快，我们作为开发者很容易在访问数据库时变得懒惰。为什么还要修改代码，用单个查询写入数据库中的三条记录，而直接在三个单独的查询中写入每条记录要容易得多呢？
- en: This type of programming may work with large databases that are sitting on the
    same network as you, but when they can be located on the other side of the planet
    over a fluctuating internet connection, these queries must be optimized and minimized.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的编程可能适用于位于你所在网络上的大型数据库，但当它们可以位于地球的另一端，通过波动互联网连接时，这些查询必须进行优化和最小化。
- en: Minimizing database writes
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小化数据库写入
- en: While it is one thing to read data from a database, it is a completely different
    thing to write data to a database. Write operations tend to consume significantly
    more resources than read operations on a database. Plus, they take longer to execute,
    often because data needs to move around in memory, or even sometimes on disk.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从数据库读取数据是一回事，但向数据库写入数据则是完全不同的事情。写入操作通常比数据库上的读取操作消耗更多的资源，并且执行时间更长，这通常是因为数据需要在内存中移动，有时甚至在磁盘上。
- en: Because the cost of writing to your database is relatively expensive, only write
    data when you absolutely have to and write as much data as possible each time
    you do write. This will give you the most bang for your buck for each database
    write.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于写入你数据库的成本相对较高，只有在你绝对需要时才写入数据，并且每次写入尽可能多的数据。这将使每次数据库写入都物有所值。
- en: Enabling data caching
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用数据缓存
- en: If we are truly serious about minimizing the amount of data we read and write
    between n8n and the database, a great strategy is to store a copy of select database
    tables locally in n8n, either in memory or in a local **JavaScript Object Notation**
    (**JSON**) file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们真正致力于最小化n8n和数据库之间读取和写入的数据量，一个很好的策略是将选定的数据库表的一个副本存储在n8n本地，无论是存储在内存中还是在本地**JavaScript对象表示法**（**JSON**）文件中。
- en: Then, each time a request needs to be made to the database, you can first ask
    whether the database has changed since the last time the cache was updated. If
    it has, then n8n should pull down just the changes that were made to the database
    and write those to the cached data. If there were no changes, then updating the
    cache can be skipped and the query can be executed locally.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每次需要向数据库发出请求时，您可以先询问数据库自上次缓存更新以来是否已更改。如果已更改，则n8n应仅拉取对数据库所做的更改，并将这些更改写入缓存数据。如果没有更改，则可以跳过更新缓存，并可以在本地执行查询。
- en: This can be a significantly more efficient way of looking at the data in a database
    than querying the database each time. It not only speeds up your database lookups
    but also reduces the number of calls to the database in the long run as well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是在数据库中查看数据的一种更有效的方式，而不是每次都查询数据库。这不仅加快了您的数据库查找速度，而且在长期内也减少了数据库调用次数。
- en: Backing up the database
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备份数据库
- en: Your database is the core of your application. The database must be available
    as much as possible and, if the database is lost, you have a way to recover it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您的数据库是您应用程序的核心。数据库必须尽可能可用，如果数据库丢失，您有方法可以恢复它。
- en: Your best line of defense is to back up your database as often as possible.
    This way, you will minimize the amount of data loss and reduce the amount of time
    it takes to recover.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您最好的防御措施是尽可能频繁地备份您的数据库。这样，您将最小化数据丢失量并减少恢复所需的时间。
- en: Recording transactions
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录交易
- en: Another way to ensure that you can recover from not only data loss but also
    data overwrite is to record every transaction that occurs on the database to a
    separate transaction table. This way, if there is a gap between the time your
    database became unavailable and the time of the last backup, you can recreate
    those transactions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种确保您可以从数据丢失和数据覆盖中恢复的方法是记录数据库上发生的每笔交易到一个单独的交易表中。这样，如果您的数据库不可用的时间与最后备份的时间之间有差距，您可以重新创建那些交易。
- en: Also, if your database backup is completely lost, you can still recover from
    the data loss by executing the transactions again. This is significantly slower
    than recovering from backup but infinitely better than losing all of the data.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您的数据库备份完全丢失，您仍然可以通过再次执行交易来从数据丢失中恢复。这比从备份中恢复要慢得多，但比丢失所有数据要好得多。
- en: Using record references and table views
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用记录引用和表视图
- en: When you are using data that needs to be entered several times, it is more efficient
    to create a separate record in a different database table with a unique record
    ID rather than repeatedly writing the same data each time.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用需要多次输入的数据时，在另一个数据库表中创建一个具有唯一记录ID的单独记录比每次都重复写入相同的数据更有效。
- en: For example, if I was creating a database that needed to refer to user information
    such as first name, last name, and address, I could just write all this information
    to the database table each time it was needed. But if we were to write this information
    to a user table, we could then just reference the **UserID** value stored in the
    table and write that rather than the entire record.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我在创建一个需要引用用户信息（如姓名、姓氏和地址）的数据库，我可以在每次需要时将所有这些信息写入数据库表。但如果我们将这些信息写入用户表，我们就可以仅引用存储在表中的**UserID**值，而不是整个记录。
- en: This allows you to reduce the amount of information that gets transferred and
    minimizes the size of the write.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许您减少需要传输的信息量，并最小化写入的大小。
- en: Securing your database
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护您的数据库
- en: Because these databases are hosted on the internet and can generally be accessed
    from anywhere on the internet, it is extremely important that they be properly
    secured. Ensure that all credentials and API keys are stored securely and are
    not hardcoded into your applications.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些数据库托管在互联网上，并且通常可以从互联网上的任何地方访问，因此它们得到适当的保护至关重要。确保所有凭证和API密钥都安全存储，并且没有硬编码到您的应用程序中。
- en: Also, make sure all transactions are over an encrypted (**HyperText Transfer
    Protocol Secure**, or **HTTPS** for short) connection and, if possible, only allow
    specific **Internet Protocol** (**IP**) addresses to talk with the database.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，确保所有事务都通过加密的连接（即**超文本传输协议安全**，简称**HTTPS**）进行，如果可能的话，只允许特定的**互联网协议**（**IP**）地址与数据库通信。
- en: Performing calculations on the database
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在数据库上执行计算
- en: Your database will most likely be a lot more powerful than the system you are
    using to host n8n. Because of that, if it is possible, get the database to perform
    calculations, especially if the goal is to provide summary statistics of the data
    that is already on the database.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您的数据库可能比您用于托管n8n的系统强大得多。因此，如果可能的话，让数据库执行计算，特别是如果目标是提供数据库上已有数据的汇总统计信息。
- en: Rather than sending all of the data to n8n for processing, perform the processing
    on the database using query functions such as `COUNT`, `MIN`, and `MAX`. This
    moves the calculations (that is, CPU load) over to the database and reduces the
    amount of information that needs to be transmitted between the database and your
    application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是将所有数据发送到n8n进行处理，使用查询函数（如`COUNT`、`MIN`和`MAX`）在数据库上执行处理。这会将计算（即CPU负载）转移到数据库上，并减少需要在数据库和您的应用程序之间传输的信息量。
- en: Load testing the database
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对数据库进行负载测试
- en: It is not uncommon for developers to build an application and it runs just fine
    in both development and testing, but once it goes into production, the database
    cannot handle the load due to resource constraints (for example, CPU maxed out;
    storage too slow; bandwidth constraints).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者构建的应用程序在开发和测试中运行良好，但一旦投入生产，由于资源限制（例如，CPU达到最大值；存储太慢；带宽限制），数据库无法处理负载的情况并不少见。
- en: Make sure that you have a way of load testing the database before it goes into
    production. This way, you will be able to ensure that the database has all of
    the necessary resources before it becomes a problem.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您在数据库投入生产之前有负载测试数据库的方法。这样，您将能够确保在成为问题之前数据库拥有所有必要的资源。
- en: Now that our database is ready to go, let's take a look at how we can design
    and build the API to provide the best performance to users.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们数据库已准备就绪，让我们看看如何设计和构建API，以向用户提供最佳性能。
- en: Optimizing your API for production
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化您的API以投入生产
- en: Your API can be one of the most important parts of your application since it
    is one of the primary ways that your clients read and write data. Because of this
    importance, it is vital that your API is ready for production right from the start.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您的API可能是您应用程序最重要的部分之一，因为它通常是您的客户读取和写入数据的主要方式。鉴于这种重要性，您的API从一开始就准备好投入生产至关重要。
- en: Here are some of the ways you can make sure your API is production-ready.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些确保您的API准备好投入生产的方法。
- en: Reducing database calls
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少数据库调用
- en: Very much in line with the best practices for databases, the fewer times you
    need to read and write to the database, the better your application will perform.
    Use many of the strategies mentioned in the previous section to accomplish this.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库的最佳实践非常一致，您需要读取和写入数据库的次数越少，您的应用程序性能越好。使用上一节中提到的许多策略来完成此操作。
- en: Caching data before the API
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在API之前缓存数据
- en: If you have relatively static data behind your API, one of the tricks you can
    use is to put a caching system in front of your API, which will allow you to give
    out the information requested by the users without actually touching the API itself.
    The caching system updates itself with information from the API on a regular basis,
    and if it determines that there has been no change in the data given out by that
    API based on the same call being made to the API, the caching system will just
    send back the data that it has stored locally without bothering the API.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的API背后有相对静态的数据，您可以使用的技巧之一是在API前面放置一个缓存系统，这样您就可以在不实际接触API的情况下向用户提供用户请求的信息。缓存系统会定期用来自API的信息更新自己，如果它确定基于对API的相同调用，API提供的数据没有发生变化，缓存系统将仅发送它已存储在本地的数据，而不会打扰API。
- en: Minimizing API calls
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小化API调用
- en: Some APIs require you to have information that is in the database to make another
    query to the database. A good example of this is user accounts. Generally, you
    would use the API to query the user table to find the user that you need. Then,
    you would query the API again, looking for specific information for that user.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一些API要求你必须拥有数据库中的信息才能进行数据库查询。一个很好的例子是用户账户。通常，你会使用API查询用户表以找到所需的用户。然后，你会再次查询API，寻找该用户的具体信息。
- en: What you could do instead is to keep a local copy of the user table in your
    application and use that to look up user IDs. Then, with that information already
    in hand, you can query your API only once to get the information you need.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择在应用程序中保留用户表的本地副本，并使用它来查找用户ID。然后，有了这些信息在手，你只需查询一次API就能获取所需的信息。
- en: Requiring authentication
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 要求身份验证
- en: While there are a lot of open APIs out there on the internet, it is very important
    to require authentication, even if you are giving the API service away for free.
    This increases the level of responsibility that the user has and reduces the likelihood
    that the API will be abused.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然互联网上有许多公开的API，但即使你免费提供API服务，也非常重要要求进行身份验证。这增加了用户的责任感，并减少了API被滥用的可能性。
- en: In the event that someone is abusing your API, authentication can make it easier
    to track down that individual and resolve the issue with their system or stop
    them from interfering with your API.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人滥用你的API，身份验证可以使其更容易追踪该个人，并解决他们系统的问题或阻止他们干扰你的API。
- en: Encrypting API data on the wire
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在传输过程中加密API数据
- en: Unless your data is encrypted on the wire (that is, when it is being transmitted
    between the application and the database), API keys, credentials, and sensitive
    data are susceptible to being eavesdropped upon.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你的数据在传输过程中被加密（即，当它在应用程序和数据库之间传输时），否则API密钥、凭证和敏感数据容易受到窃听的威胁。
- en: The easiest way to secure this data while in transit is to have a **Secure Sockets
    Layer** (**SSL**) certificate installed on the server that is providing the API.
    This encrypts the data and greatly reduces the possibility of someone listening
    to your API's conversations.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在传输过程中保护这些数据的最简单方法是，在提供API的服务器上安装**安全套接字层**（**SSL**）证书。这加密了数据，大大减少了有人监听你的API对话的可能性。
- en: Tracking API requests
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪API请求
- en: It is guaranteed that if you make an API available on the internet, there will
    be someone out there who is looking to abuse that API. This is why it is critical
    to keep a log of all API transactions in the event that you need to deal with
    one of these abusers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 确保如果你在互联网上提供API，肯定会有一些人试图滥用该API。这就是为什么在需要处理这些滥用者时，记录所有API交易日志至关重要。
- en: 'Ensure you track, at a minimum, the following information:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你至少跟踪以下信息：
- en: Timestamp
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间戳
- en: API call
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API调用
- en: Parameters
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数
- en: IP address
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP地址
- en: Authentication key
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证密钥
- en: This will provide you with the base information to perform some analytics on
    the data and determine who the abuser is and where they may be working from.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为你提供进行数据分析的基础信息，以确定滥用者是谁以及他们可能在何处工作。
- en: Tying API users to IP addresses
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将API用户与IP地址关联
- en: In line with the previous item, if you can get your API to only allow a user
    to access it from a specific IP or IP range, this can reduce the likelihood that
    your API will be abused and will allow you to help your users in the event that
    their information has been compromised.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一项一致，如果你能让你的API只允许用户从特定的IP或IP范围内访问，这可以减少API被滥用的可能性，并在用户信息被泄露的情况下帮助他们。
- en: Limiting the number of API calls per user per second
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制每个用户每秒的API调用次数
- en: If you put limits on how quickly users can access the API, this will help to
    distribute resources more evenly to all your users, along with reducing the likelihood
    that a user will inadvertently perform a **denial-of-service** (**DoS**) attack
    on your API.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你限制用户访问API的速度，这将有助于更均匀地分配资源给所有用户，同时减少用户意外对API进行**拒绝服务**（**DoS**）攻击的可能性。
- en: Properly documenting the API
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正确记录API
- en: If you have proper API documentation available for your users and developers,
    it will be easier for them to use your API properly and keep your error logs clean.
    This will increase customer satisfaction and reduce the stress on your support
    team, who need to help these people.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为您的用户和开发者提供了适当的 API 文档，他们将更容易正确使用您的 API，并保持错误日志的清洁。这将提高客户满意度，并减轻需要帮助这些人的支持团队的压力。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about no code databases, choosing a no code database
    for your project, reading and writing to **Airtable**, as well as some best practices
    when it comes to working with databases and optimizing APIs for production. The
    concepts learned in this chapter will help you to use a data store for your projects
    to store user-generated data and build a complete product.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于无代码数据库的知识，为您的项目选择无代码数据库，如何向 **Airtable** 读写数据，以及在与数据库工作以及优化生产环境中的
    API 时的一些最佳实践。本章学到的概念将帮助您在项目中使用数据存储来存储用户生成数据并构建完整的产品。
- en: In the next chapter, we examine how you can transform your data inside n8n workflows.
    We will do some hands-on exercises on sharing data between different n8n workflows,
    merge datasets from different tables, and also perform some analytics and calculations
    on these datasets.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何在 n8n 工作流中转换您的数据。我们将进行一些实际操作练习，包括在不同 n8n 工作流之间共享数据，合并来自不同表格的数据集，以及在这些数据集上执行一些分析和计算。
