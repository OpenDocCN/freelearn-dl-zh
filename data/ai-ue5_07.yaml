- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Introducing Behavior Trees
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍行为树
- en: In the universe of game development, **behavior trees** are hierarchical structures
    that govern the decision-making processes of AI characters, determining their
    actions and reactions during gameplay. As a game programmer, delving into the
    intricacies of behavior trees is crucial, as it will empower you with the ability
    to craft dynamic, intelligent, and engaging virtual entities that enhance the
    player’s game experience.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发的世界里，**行为树**是控制AI角色决策过程的分层结构，决定他们在游戏中的行动和反应。作为一名游戏程序员，深入研究行为树的复杂性至关重要，因为它将赋予你制作动态、智能和吸引人的虚拟实体的能力，从而增强玩家的游戏体验。
- en: This chapter aims to provide a gentle introduction to behavior trees and Blackboards,
    as well as their application within the Unreal Engine.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在提供对行为树和黑板以及它们在虚幻引擎中的应用的温和介绍。
- en: In this chapter, we will be covering the following topics
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题
- en: Explaining behavior trees
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释行为树
- en: Understanding behavior trees in Unreal Engine
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解虚幻引擎中的行为树
- en: Understanding the Blackboard
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解黑板
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: There are no technical requirements to follow this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循本章没有技术要求。
- en: Explaining behavior trees
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释行为树
- en: In its broader sense, a behavior tree is a mathematical model used in many fields
    of computer science, including video games. It outlines the transition between
    a finite set of tasks in a modular manner. The power of behavior trees lies in
    their ability to create intricate tasks from simple components, without going
    into the details of how each component is implemented. While behavior trees share
    some similarities with hierarchical state machines – where states are organized
    in a hierarchy, allowing for better reuse of behaviors – the primary distinction
    lies in the fact that tasks, not states, serve as the fundamental elements of
    behavior. The main advantage is their intuitive nature, making them less prone
    to errors; this is why they are highly favored within the game development industry.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在更广泛的意义上，行为树是一种在计算机科学的许多领域使用的数学模型，包括视频游戏。它以模块化的方式概述了有限任务集之间的转换。行为树的力量在于它们能够从简单的组件中创建复杂的任务，而不必深入了解每个组件的实现细节。虽然行为树与分层状态机有一些相似之处——状态以分层组织，允许更好地重用行为——但主要区别在于任务，而不是状态，是行为的基本元素。主要优势在于它们的直观性，使得它们更不容易出错；这就是为什么它们在游戏开发行业中非常受欢迎。
- en: Today’s video games are increasingly intricate, leading to a proportional complexity
    in AI characters. Hence, the maintenance of these characters – or agents – is
    crucial. Unlike systems such as finite state machines, which become difficult
    to maintain as the number of states increases, behavior trees offer a practical
    and scalable solution for decision-making processes. When an agent executes a
    behavior tree, it conducts a **depth-first search** to locate and execute the
    lowest-level leaf node.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的视频游戏越来越复杂，导致AI角色的复杂性成比例增加。因此，这些角色或代理的维护至关重要。与状态数量增加时难以维护的有限状态机系统不同，行为树为决策过程提供了实际且可扩展的解决方案。当代理执行行为树时，它会进行**深度优先搜索**以定位和执行最低级别的叶节点。
- en: The key advantages of behavior trees over other systems lie in their scalability,
    expressiveness, and extensibility. Unlike other systems, behavior trees do not
    involve explicit transitions between states; instead, each node in the tree specifies
    how to run its children. This stateless nature eliminates the need to track previously
    executed nodes to determine the next set of behaviors. The expressiveness of behavior
    trees stems from the use of various levels of abstraction, implicit transitions,
    and complex control structures for composite nodes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树相较于其他系统的关键优势在于它们的可扩展性、表达性和可扩展性。与其他系统不同，行为树不涉及状态之间的显式转换；相反，树中的每个节点都指定如何运行其子节点。这种无状态的性质消除了跟踪先前执行节点以确定下一组行为的需求。行为树的表达性源于对各种抽象级别、隐式转换和复合节点复杂控制结构的运用。
- en: Furthermore, in behavior trees, transitions occur through calls and return values
    exchanged between tree nodes, facilitating a two-way control transfer mechanism.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在行为树中，转换是通过树节点之间交换的调用和返回值发生的，促进了双向控制转移机制。
- en: Behavior tree structure
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为树结构
- en: 'A behavior tree is visually depicted as a tree structure with nodes categorized
    as **root** , **control flow** , and **execution** – or **tasks** . In this representation,
    each node may have a parent node and one or more children. In particular, the
    following is worth noting:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树以树结构的形式直观表示，节点分为**根节点**、**控制流**和**执行**——或**任务**。在这个表示中，每个节点可能有一个父节点和一个或多个子节点。特别是以下几点值得注意：
- en: The root node has no parents and only one child
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根节点没有父节点，只有一个子节点
- en: Control flow nodes have one parent and at least one child
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制流节点有一个父节点和至少一个子节点
- en: Execution nodes have one parent and no children
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行节点有一个父节点，没有子节点
- en: A behavior tree is executed starting from the root, which sends execution triggers
    to its child nodes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树的执行从根节点开始，它向其子节点发送执行触发器。
- en: Whenever a control flow node is reached, it will control the execution and flow
    of decision-making within the tree, determining which tasks or sub-trees should
    be executed based on certain conditions or rules.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每当达到控制流节点时，它将控制树内的执行和决策流程，根据某些条件或规则确定应该执行哪些任务或子树。
- en: Every time an execution node is triggered, it will execute a specific task,
    reporting back to its parent with a status of *running* if the task is ongoing,
    *success* if the objective is accomplished, or *failure* if the task is unsuccessful.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每次触发执行节点时，它将执行一个特定的任务，如果任务正在进行，则向其父节点报告状态为*运行*，如果目标实现，则报告状态为*成功*，如果任务未成功，则报告状态为*失败*。
- en: '*Figure 7* *.1* shows an example of a behavior tree execution, starting from
    the root, going to a control flow node, and finally executing a task:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.1* 显示了一个行为树执行示例，从根节点开始，到控制流节点，最后执行一个任务：'
- en: '![Figure 7.1 – Behavior tree example](img/Figure_7.1_B31016.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 行为树示例](img/Figure_7.1_B31016.jpg)'
- en: Figure 7.1 – Behavior tree example
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 行为树示例
- en: Note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Behavior tree nodes are executed from top to bottom and left to right; this
    is also the way they are usually numbered.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树节点从上到下、从左到右执行；这也是它们通常编号的方式。
- en: It goes without saying that there isn’t just one way to implement behavior trees.
    That’s why in the next section, I’ll dive into all the nitty-gritty details about
    the Unreal Engine system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，实现行为树的方式不止一种。这就是为什么在下一节中，我将深入探讨虚幻引擎系统的所有细节。
- en: What is a behavior tree in Unreal Engine?
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚幻引擎中的行为树是什么？
- en: In Unreal Engine, behavior trees are assets that are edited in a similar way
    to Blueprints – that is, visually – by adding and linking a set of nodes with
    specific functionalities to form a **behavior tree graph** . During the execution
    of logic in a behavior tree, a separate asset known as a Blackboard – further
    details on this will be provided later in this chapter – is used to retain information
    that the behavior tree requires to make well-informed decisions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，行为树是类似蓝图——即，通过添加和链接具有特定功能的节点集来形成**行为树图**的资产。在行为树中执行逻辑时，使用一个称为黑板的单独资产——关于这一点将在本章后面提供更多详细信息——来保留行为树需要做出明智决策的信息。
- en: A behavior tree is handled by a **BehaviorTreeComponent** instance that is held
    by the **AIController** instance. It should be noted that the component is not
    automatically attached to the controller; you will need to add it through C++
    or Blueprints. If no component is present, it will automatically be created at
    runtime.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树由一个**BehaviorTreeComponent**实例处理，该实例由**AIController**实例持有。需要注意的是，组件不是自动附加到控制器上的；您需要通过C++或蓝图来添加它。如果没有组件，它将在运行时自动创建。
- en: When comparing Unreal Engine behavior trees with other behavior tree systems,
    one key distinction to keep in mind is their event-driven nature, which prevents
    constant code execution. Instead of continuously checking for relevant changes,
    an Unreal Engine behavior tree listens for events that can prompt tree modifications.
    Using an event-driven architecture provides performance enhancements and debugging
    capabilities benefits – this is something I will show in the upcoming chapters.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当比较虚幻引擎的行为树与其他行为树系统时，需要记住的一个关键区别是它们的事件驱动特性，这防止了代码的持续执行。而不是持续检查相关变化，虚幻引擎的行为树会监听可以触发树修改的事件。使用事件驱动架构提供了性能提升和调试能力的好处——这一点我将在接下来的章节中展示。
- en: Behavior tree node instancing
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为树节点实例化
- en: It needs to be noted that behavior trees exist as **shared objects** in your
    project; this means that all agents using a behavior tree will share the same
    instance, and all shared objects will be unable to store agent-specific data.
    The main advantages of using shared nodes are CPU speed improvement and reduced
    memory usage.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，行为树在您的项目中作为**共享对象**存在；这意味着所有使用行为树的代理将共享相同的实例，并且所有共享对象都无法存储特定于代理的数据。使用共享节点的主要优势是提高CPU速度和减少内存使用。
- en: Agent-specific data can be leveraged in many ways – one being the Blackboard
    that we will see later in this chapter – to give you more flexibility on how to
    use your behavior tree.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过多种方式利用特定于代理的数据 – 其中一种是我们将在本章后面看到的黑板 – 以提供更多关于如何使用行为树的灵活性。
- en: Another such method is instancing single nodes; this will grant each AI agent
    using a behavior tree a unique instance of the node at the cost of higher performance
    and memory usage. An example of a node using such a method is the **PlayAnimation**
    task.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是实例化单个节点；这将使每个使用行为树的AI代理获得节点的唯一实例，但代价是更高的性能和内存使用。使用此方法的一个节点示例是**播放动画**任务。
- en: Order of execution
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行顺序
- en: 'As previously mentioned, behavior tree nodes are executed from top to bottom
    and left to right and Unreal Engine is no exception. Nodes are numbered following
    this convention to easily track the execution order. *Figure 7* *.2* shows a behavior
    tree from the **Lyra Starter Game** project, showing the nodes with their corresponding
    sequence numbers:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，行为树节点是从上到下、从左到右执行的，虚幻引擎也不例外。节点按照此惯例编号，以便轻松跟踪执行顺序。*图7.2*展示了来自**Lyra入门游戏**项目的行为树，显示了带有相应序列号的节点：
- en: '![Figure 7.2 – Behavior tree sequence](img/Figure_7.2_B31016.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 行为树序列](img/Figure_7.2_B31016.jpg)'
- en: Figure 7.2 – Behavior tree sequence
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 行为树序列
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: In Unreal Engine, a root node is never numbered because it is not considered
    part of the sequence.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，根节点不会被编号，因为它不被视为序列的一部分。
- en: In this section, you have received a gentle introduction to behavior trees and
    how they are executed. The next section will delve deeper into the Unreal Engine
    system to help you better understand how to incorporate behavior trees effectively
    into your games.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您已经得到了对行为树及其执行方式的温和介绍。下一节将深入探讨虚幻引擎系统，帮助您更好地理解如何有效地将行为树融入您的游戏中。
- en: Understanding behavior trees in Unreal Engine
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解虚幻引擎中的行为树
- en: Understanding behavior trees and what they are made of is essential for designing
    effective AI systems in Unreal Engine; in this section, I will be presenting you
    with the key concepts associated with behavior trees to help you start developing
    your own AI characters.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 理解行为树及其构成对于在虚幻引擎中设计有效的AI系统至关重要；在本节中，我将向您介绍与行为树相关的关键概念，以帮助您开始开发自己的AI角色。
- en: 'In Unreal Engine, there are five types of elements in behavior trees:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，行为树有五种类型的元素：
- en: Root node
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根节点
- en: Task nodes
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务节点
- en: Composite nodes
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合节点
- en: Decorators
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器
- en: Services
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: To provide you with a comprehensive understanding of each type, I will present
    them individually, ensuring a clear depiction of their respective functions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您对每种类型有一个全面的理解，我将分别介绍它们，确保清晰地展示它们各自的功能。
- en: The root node
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根节点
- en: 'The root node functions as the initial point for a behavior tree; it holds
    a distinct position within the tree and is governed by a set of special rules:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 根节点作为行为树的起始点；它在树中占据一个独特的位置，并受一套特殊规则的约束：
- en: There can be only one such node in the tree structure
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树结构中只能有一个此类节点
- en: It can have only one connection, and if this connection is removed, then the
    entire tree is disabled
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只能有一个连接，如果此连接被移除，则整个树将禁用
- en: It does not support the attachment of decorator or service nodes
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不支持附加装饰器或服务节点
- en: '![Figure 7.3 – Root node](img/Figure_7.3_B31016.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 根节点](img/Figure_7.3_B31016.jpg)'
- en: Figure 7.3 – Root node
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 根节点
- en: Task nodes
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务节点
- en: Task nodes are responsible for performing actions such as moving an AI or adjusting
    Blackboard values. A task will not stop its execution until a failure or success
    result is reported.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 任务节点负责执行诸如移动AI或调整黑板值等操作。任务将不会停止其执行，直到报告失败或成功的结果。
- en: A task node can also have one or more decorators or services attached, allowing
    for more complex behaviors and interactions within the game environment.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 任务节点也可以附加一个或多个装饰器或服务，允许在游戏环境中实现更复杂的行为和交互。
- en: Task nodes
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 任务节点
- en: Tasks are identified by a purple color.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 任务以紫色标识。
- en: '![Figure 7.4 – Task examples](img/Figure_7.4_B31016.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 任务示例](img/Figure_7.4_B31016.jpg)'
- en: Figure 7.4 – Task examples
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 任务示例
- en: Unreal Engine includes a set of pre-built tasks that are readily available for
    use. These tasks address the most generic scenarios that developers are likely
    to require. However, tasks can be extended to allow you to create your own custom
    nodes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine包含一组预构建的任务，这些任务可供使用。这些任务解决了开发者可能需要的大多数通用场景。然而，任务可以被扩展，以便您创建自己的自定义节点。
- en: 'Here is a partial list of some of the tasks that will be available to you as
    standard features:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是部分任务列表，这些任务将作为标准功能提供：
- en: '**Finish With Result** : Once executed, this node will instantly finish with
    a defined result – **Succeeded** , **Failed** , **Aborted** , or **In Progress**'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完成结果**：一旦执行，此节点将立即以定义的结果完成 - **成功**、**失败**、**中止**或**进行中**'
- en: '**Move To** : Once executed, it will move the AI agent to a target location
    by using the Navigation System'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动到**：一旦执行，它将通过使用导航系统将AI代理移动到目标位置'
- en: '**Move Directly Toward** : Once executed, it will move the AI agent to a target
    location without using the Navigation System'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直接移动**：一旦执行，它将不使用导航系统将AI代理移动到目标位置'
- en: '**Wait** : Once executed, it will cause the behavior tree to wait on this node
    until a specified time has passed'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**等待**：一旦执行，它将使行为树在此节点上等待，直到经过指定的时间'
- en: '**Play Animation** : Once executed, this node will play a specified animation
    asset'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**播放动画**：一旦执行，此节点将播放指定的动画资源'
- en: '**Play Sound** : Once executed, this node will play a specified sound'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**播放声音**：一旦执行，此节点将播放指定的声音'
- en: As you can see, tasks represent individual actions or operations that an AI
    agent can perform; you can use them to create simple actions or combine several
    to create more complex behaviors.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，任务代表AI代理可以执行的单个动作或操作；您可以使用它们创建简单的动作，或将多个任务组合以创建更复杂的行为。
- en: Composite nodes
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复合节点
- en: Composite nodes define the root of a branch and set the rules for its execution;
    additionally, they are the only nodes that can be applied to the root node of
    a behavior tree.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 复合节点定义了分支的根并设置其执行规则；此外，它们是唯一可以应用于行为树根节点的节点。
- en: A composite node can also have decorators and services applied, enabling more
    complex logic in it. Once a service is applied, it will be active while the children
    of the composite are executed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 复合节点也可以应用装饰器和服务，从而使其逻辑更加复杂。一旦应用了服务，它将在复合节点的子节点执行期间保持活跃。
- en: Composite nodes
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 复合节点
- en: Composites are identified by a grey color.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 复合节点以灰色标识。
- en: 'There are three composite nodes available:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种复合节点可用：
- en: '**Selectors**'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择器**'
- en: '**Simple parallels**'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单并行**'
- en: '**Sequences**'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列**'
- en: Let’s examine them one by one.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一检查它们。
- en: Selectors
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择器
- en: Selector nodes execute their children sequentially from left to right, and they
    will halt execution as soon as one of them succeeds. When a child of a selector
    node succeeds, the selector itself is considered successful. On the other hand,
    if all the selector’s children fail, the selector node itself is marked as failed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器节点按从左到右的顺序执行其子节点，并且它们会在任何一个子节点成功时立即停止执行。当一个选择器节点的子节点成功时，选择器本身被认为是成功的。另一方面，如果选择器的所有子节点都失败，选择器节点本身将被标记为失败。
- en: '![Figure 7.5 – Selector node](img/Figure_7.5_B31016.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 选择器节点](img/Figure_7.5_B31016.jpg)'
- en: Figure 7.5 – Selector node
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 选择器节点
- en: Simple parallels
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单并行
- en: Simple parallel nodes enable the execution of a single main task node concurrently
    with a complete tree. After the main task is completed, you may decide – through
    the **Finish Mode** attribute – whether the node should immediately finish, halting
    the secondary tree, or whether it should wait for the secondary tree to finish
    before completing.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 简单并行节点允许在完整树的同时执行单个主任务节点。主任务完成后，您可以通过**完成模式**属性决定节点是否应立即完成，停止次要树，还是等待次要树完成后再完成。
- en: '![Figure 7.6 – Simple Parallel node](img/Figure_7.6_B31016.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6 – 简单并行节点](img/Figure_7.6_B31016.jpg)'
- en: Figure 7.6 – Simple Parallel node
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 简单并行节点
- en: Sequences
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列
- en: Sequence nodes run their children sequentially from left to right. They halt
    execution when a child fails. If a child fails, the sequence also fails. Unlike
    selectors, the success of the sequence is achieved only when all its children
    succeed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 序列节点从左到右依次运行其子节点。当子节点失败时，将停止执行。如果子节点失败，序列也会失败。与选择器不同，序列的成功只有在所有子节点都成功时才会实现。
- en: '![Figure 7.7 – Sequence node](img/Figure_7.7_B31016.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7 – 序列节点](img/Figure_7.7_B31016.jpg)'
- en: Figure 7.7 – Sequence node
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 序列节点
- en: Decorators
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器
- en: Decorators – sometimes also referred to as conditionals – are used to determine
    whether a branch in the tree, or even a single node, can be executed. They must
    be attached to either a composite or a task node.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器——有时也被称为条件——用于确定树中的分支，甚至单个节点是否可以执行。它们必须附加到复合节点或任务节点上。
- en: Decorators play a crucial role in determining the execution path of branches
    within the behavior tree; they essentially act as decision-makers, evaluating
    whether a specific branch or individual node should proceed with execution. They
    serve as a condition, assessing the viability of continuing down a particular
    branch, signaling a precautionary failure if the task – or a sub-tree – is destined
    to fail. This preemptive action helps prevent the decorator from attempting to
    carry out a task – or sub-tree – that is bound to fail due to various reasons
    such as insufficient information or outdated objectives.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器在确定行为树中分支的执行路径方面起着至关重要的作用；它们本质上充当决策者，评估特定分支或单个节点是否应该继续执行。它们作为条件，评估继续沿着特定分支前进的可行性，如果任务——或子树——注定要失败，则发出预防性失败的信号。这种预防性操作有助于防止装饰器尝试执行注定要失败的任务——或子树——这可能由于各种原因（如信息不足或目标过时）而失败。
- en: Decorators
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器
- en: Decorators are identified by a blue color.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器以蓝色标识。
- en: '![Figure 7.8 – Decorator applied to a Selector](img/Figure_7.8_B31016.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图7.8 – 应用到选择器的装饰器](img/Figure_7.8_B31016.jpg)'
- en: Figure 7.8 – Decorator applied to a Selector
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – 应用到选择器的装饰器
- en: Unreal Engine includes a set of pre-built decorators that are readily available
    for use, but they can be extended to allow you to create your own custom ones.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine 包含一组预构建的装饰器，这些装饰器可以随时使用，但可以扩展以允许您创建自己的自定义装饰器。
- en: 'Here is a partial list of some of the tasks that will be available to you as
    standard features:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个部分列表，列出了一些您将作为标准功能可用的任务：
- en: '**Blackboard** : Will check whether a value has been set – or not set – on
    a given Blackboard key'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**黑板**：将检查在给定的黑板键上是否设置了值——或者没有设置值'
- en: '**Composite** : Will let you create some more advanced logic than built-in
    nodes by using **AND** , **OR** , and **NOT** nodes'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复合**：通过使用**AND**、**OR**和**NOT**节点，可以创建比内置节点更高级的逻辑'
- en: '**Cooldown** : Will lock the execution of a node or a branch until a predefined
    time has passed'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冷却**：将锁定节点或分支的执行，直到经过预定义的时间'
- en: '**Does Path Exists** : Will check whether a path is found between two points'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路径存在**：将检查两点之间是否存在路径'
- en: '**Loop** : Will loop a node or a branch indefinitely – or a number of times,
    if set'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环**：将无限期地循环节点或分支——或者如果设置了次数，则循环指定次数'
- en: Most decorators include an **Inverse Condition** property, that will let you,
    well... invert the condition, giving you more flexibility. As an example, you
    may use the same decorator in a behavior tree to execute different tasks under
    opposite conditions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数装饰器都包括一个**逆条件**属性，这将让您……反转条件，从而提供更多灵活性。例如，您可以在行为树中使用相同的装饰器，在相反的条件下执行不同的任务。
- en: For instance, you may use **Does Path Exist** to move an AI agent to a target
    point and use **Inverse Condition** on another instance of **Does Path Exist**
    to look for an alternative target point.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以使用**路径存在**将AI代理移动到目标点，并在另一个**路径存在**实例上使用**逆条件**来寻找替代目标点。
- en: In conclusion, decorators serve as decision points that determine whether a
    certain action or branch within the behavior tree should be executed or not.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，装饰器作为决策点，确定行为树中的特定动作或分支是否应该执行。
- en: Services
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务
- en: Services can be attached to composite or task nodes and run at specific intervals
    – defined in the **Interval** attribute – while their branch is active. They are
    commonly employed for conducting checks and updating the Blackboard.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 服务可以附加到复合节点或任务节点上，并在其分支活动时以特定间隔运行——在**间隔**属性中定义。它们通常用于执行检查和更新黑板。
- en: Once triggered by a task or a composite, a service will keep executing regardless
    of the number of parent-child levels being executed below the owing node.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦由任务或组合触发，服务将保持执行，无论在所属节点下执行的父级-子级级别数量如何。
- en: Services
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 服务
- en: Services are identified by a green color.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 服务以绿色标识。
- en: '![Figure 7.9 – Service applied to a Selector](img/Figure_7.9_B31016.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图7.9 – 应用到选择器的服务](img/Figure_7.9_B31016.jpg)'
- en: Figure 7.9 – Service applied to a Selector
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 – 应用到选择器的服务
- en: 'Services are very specific to the behavior tree you are developing; this means
    that, most probably, you will have to create your own custom ones. However, Unreal
    Engine provides two pre-built services that are readily available for use:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 服务对于您正在开发的行为树非常具体；这意味着，很可能会需要创建自己的自定义服务。然而，虚幻引擎提供了两个预先构建的服务，它们可以随时使用：
- en: '**Default Focus** : This enables quick access to an actor from the AI controller
    instead of using a Blackboard key.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认焦点**：这允许从AI控制器快速访问一个演员，而不是使用黑板键。'
- en: '**Run EQS** : This can be used to regularly execute an EQS – more on this in
    [*Chapter 11*](B31016_11.xhtml#_idTextAnchor218) , *Understanding the Environment
    Query System* – at assigned intervals. It can also update a specified Blackboard
    key.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行EQS**：这可以用来定期执行EQS – 更多内容请参阅[*第11章*](B31016_11.xhtml#_idTextAnchor218)
    ，*理解环境查询系统* – 在指定的间隔。它还可以更新指定的黑板键。'
- en: Having covered the various types of nodes that make up a behavior tree, it’s
    now time to get into the next section in order to delve into Blackboard assets.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了构成行为树的各种节点类型之后，现在是时候进入下一节，以便深入了解黑板资产。
- en: Understanding the Blackboard
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解黑板
- en: In Unreal Engine, the Blackboard is a crucial component of behavior trees; it
    acts as a memory space – some sort of brain – where AI agents can read and write
    data during their decision-making process. This means that developers will be
    able to query and update information stored within it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，黑板是行为树的关键组件；它充当一个内存空间 – 类似于大脑 – AI代理可以在其决策过程中读取和写入数据。这意味着开发者将能够查询和更新其中存储的信息。
- en: The Blackboard is created as a **Blackboard Data** asset, which will be assigned
    to a behavior tree, and it contains a set of variables – named keys – that store
    specific information of predefined types. These keys can be accessed and manipulated
    during runtime to influence the decision-making of AI characters.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 黑板作为**黑板数据**资产创建，将被分配给行为树，并包含一组变量 – 命名为键 – 存储预定义类型的特定信息。这些键可以在运行时访问和操作，以影响AI角色的决策。
- en: '![Figure 7.10 – Blackboard example](img/Figure_7.10_B31016.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图7.10 – 黑板示例](img/Figure_7.10_B31016.jpg)'
- en: Figure 7.10 – Blackboard example
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 – 黑板示例
- en: A key can be set to **Instance Synced** ; in this case, the key itself will
    be synchronized across all instances of the Blackboard. This synchronization ensures
    that any changes made to the value of the key will be reflected consistently across
    all instances of the AI agents sharing the same behavior tree and Blackboard.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 键可以设置为**实例同步**；在这种情况下，键本身将在所有黑板实例之间同步。这种同步确保对键值的任何更改都将一致地反映在共享相同行为树和黑板的AI代理的所有实例中。
- en: '![Figure 7.11 – The Instance Synced property](img/Figure_7.11_B31016.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图7.11 – 实例同步属性](img/Figure_7.11_B31016.jpg)'
- en: Figure 7.11 – The Instance Synced property
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 – 实例同步属性
- en: 'A Blackboard can store up to 255 keys and it supports the following data types:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 黑板可以存储多达255个键，并支持以下数据类型：
- en: '**FVector**'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FVector**'
- en: '**FRotator**'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FRotator**'
- en: '**Bool**'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布尔值**'
- en: '**Int32**'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Int32**'
- en: '**Float**'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浮点数**'
- en: '**UClass**'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UClass**'
- en: '**UObject**'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UObject**'
- en: '**FName**'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FName**'
- en: '**UEnum**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UEnum**'
- en: '**FString**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FString**'
- en: Note
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A Blackboard cannot store arrays.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 黑板不能存储数组。
- en: The **BlackboardComponent** instance will allow you to query data from a Blackboard
    and store data in the Blackboard itself. The creation system follows a similar
    pattern to the **BehaviorTreeComponent** , as explained previously in this chapter.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**BlackboardComponent**实例将允许您从黑板查询数据并将数据存储在黑板本身中。创建系统遵循与**BehaviorTreeComponent**类似的模式，如本章前面所述。'
- en: Despite its apparent simplicity, understanding how a Blackboard works is crucial
    for ensuring the effective functioning of your AI agents.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它表面上看起来很简单，但理解黑板的工作原理对于确保您的AI代理有效运行至关重要。
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we were introduced to the behavior tree system. Beginning with
    a brief theoretical overview, we saw how behavior trees function in Unreal Engine
    and learned about the key components that constitute the entire system. Finally,
    we discussed the Blackboard asset, a crucial element for the effective operation
    of behavior trees.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了行为树系统。从简要的理论概述开始，我们了解了行为树在虚幻引擎中的工作方式，并学习了构成整个系统的关键组件。最后，我们讨论了黑板资产，这是行为树有效运行的关键元素。
- en: Get ready for the upcoming chapter, where we will guide you back into action
    and make you craft a behavior tree for our very own dummy character. Specifically,
    you will be creating your own custom services and tasks in order to give our soon-to-be
    AI agent a proper AI brain. Brace yourself, because things are about to get intriguingly
    wild and – sometimes – delightfully chaotic!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 准备迎接下一章，我们将引导你重新投入行动，并为你制作一个专门为我们的虚拟角色构建的行为树。具体来说，你将创建自己的自定义服务和任务，以便为即将到来的AI代理提供一个合适的AI大脑。做好准备吧，因为事情即将变得有趣而狂野——有时甚至令人愉快地混乱！
