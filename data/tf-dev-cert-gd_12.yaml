- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Introduction to Time Series, Sequences, and Predictions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列、序列与预测概述
- en: '**Time series** cut across various industries, sectors, and aspects of our
    lives. Finance, healthcare, social sciences, physics – you name it, time series
    data is there. It’s in sensors monitoring our environment, social media platforms
    tracking our digital footprint, online transactions recording our financial behavior,
    and many more avenues. This sequential data represents dynamic processes that
    evolve over time, and as we increasingly digitize our planet, the volume, and
    thereby the importance, of this data type is set to grow exponentially.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间序列**横跨各行各业，涉及我们生活的方方面面。金融、医疗、社会科学、物理学——你说得出，时间序列数据就存在。它出现在监测我们环境的传感器中，社交媒体平台追踪我们的数字足迹，在线交易记录我们的财务行为，等等。这种按时间顺序排列的数据代表着随时间变化的动态过程，随着我们逐步数字化地球，这类数据的量和其重要性将呈指数级增长。'
- en: Time series follow a chronological order, capturing events as they occur in
    time. This temporal nature of time series bestows a unique quality that differentiates
    it from cross-sectional data. When we turn on the searchlight on time series data,
    we can observe attributes such as trends, seasonality, noise, cyclicity, and autocorrelations.
    These unique characteristics endow time series data with rich information, but
    they also present us with a unique set of challenges that we must overcome to
    harness the gains inherent in this data type. With frameworks such as **TensorFlow**,
    we can leverage patterns from the past to make informed decisions about the future.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列遵循时间顺序，捕捉事件的发生。时间序列的这种时间特性赋予了它与横截面数据的独特区别。当我们聚焦于时间序列数据时，可以观察到如趋势、季节性、噪声、周期性和自相关等特征。这些独特的特性使得时间序列数据蕴含丰富的信息，但也为我们带来了一系列独特的挑战，我们必须克服这些挑战，以充分利用这种数据类型的潜力。借助**TensorFlow**等框架，我们可以利用过去的模式做出关于未来的明智决策。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Time series analysis – characteristics, applications, and forecasting techniques
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间序列分析——特征、应用与预测技术
- en: Statistical techniques for forecasting time series
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间序列预测的统计学技术
- en: Preparing data for forecasting with neural networks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用神经网络为预测准备数据
- en: Sales forecasting with neural networks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用神经网络进行销售预测
- en: By the end of this chapter, you will have gained theoretical insight and hands-on
    experience in building, training, and evaluating time series forecasting models
    using statistical and deep learning techniques.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，你将获得理论上的见解和实际操作经验，学习如何使用统计学和深度学习技术构建、训练和评估时间序列预测模型。
- en: Time series analysis – characteristics, applications, and forecasting techniques
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列分析——特征、应用与预测技术
- en: We know time series data is defined by the ordering of data points in a sequence
    over time. Imagine we are forecasting energy consumption patterns in London. Over
    the years, there has been a growing increase in energy consumption, perhaps due
    to urbanization – this signifies a positive upward trend. During winter each year,
    we expect energy consumption to rise as more people will need to heat up their
    homes and offices to stay warm. This seasonal change in the weather also accounts
    for seasonality in energy utilization. Again, we could also witness an unusual
    surge in energy consumption due to a major sporting event, leading to a large
    influx of guests during the period. This causes noise in the data as such events
    are one-offs or occur at irregular intervals.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，时间序列数据是由数据点在时间序列中的顺序定义的。想象我们正在预测伦敦的能耗模式。多年来，由于城市化，能源消耗逐年增加——这表示一个正向上升的趋势。每年冬天，我们预期能源消耗会增加，因为更多的人需要为保持温暖而加热家中和办公室的空间。季节性的天气变化也导致了能源利用的季节性波动。此外，我们还可能因为一次重大体育赛事，看到能源消耗的异常激增，这可能是因为赛事期间大量客人的涌入。这种情况会在数据中产生噪声，因为这些事件通常是一次性的或不规律发生的。
- en: In the following sections, let us explore the characteristics of time series,
    types, applications, and techniques for modeling time series data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，让我们一起探索时间序列的特征、类型、应用以及建模时间序列数据的技术。
- en: Characteristics of time series
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间序列的特征
- en: To effectively build efficient forecasting models, we need to gain a clear understanding
    of the underlying nature of time series data. We may find ourselves working with
    time series data that has a positive upward trend, monthly seasonality, noise,
    and autocorrelation, while the next time series we work on may have yearly seasonality
    and noise but no visible sign of autocorrelation or trends in the data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地构建高效的预测模型，我们需要清楚地理解时间序列数据的基本性质。我们可能会遇到具有正向上升趋势、月度季节性、噪声和自相关性的时间序列数据，而下一个我们处理的时间序列可能具有年度季节性和噪声，但数据中没有明显的自相关性或趋势。
- en: 'Understanding these data properties of time series data arms us with the requisite
    details to make informed preprocessing decisions. For example, if we are working
    with a dataset with high volatility, our knowledge of this may inform our decision
    to apply smoothing during our preprocessing steps. Later in this chapter, where
    we will be building statistical and deep learning models for forecasting time
    series, we will see how our understanding of the properties of time series data
    will guide our decisions with respect to engineering new features, choosing optimal
    hyperparameter values, and making model selection decisions. Let us examine the
    characteristics of time series:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 了解时间序列数据的这些数据特性，使我们能够具备必要的细节来做出明智的预处理决策。例如，如果我们处理的数据集波动性较大，我们对这一点的了解可能会促使我们在预处理步骤中应用平滑技术。在本章后面，我们将构建用于预测时间序列的统计学和深度学习模型，我们将看到对时间序列数据特性的理解如何指导我们在新特征工程、选择最优超参数值以及模型选择决策方面的判断。让我们来审视时间序列的特点：
- en: '**Trend**: Trends refer to the general direction in which a time series is
    moving over the long term. We could look at a trend as the overall big picture
    of our time series data. Trends can be linear, as shown in *Figure 12**.1*, or
    nonlinear (quadratic and exponential); they can also be in a positive (upward)
    or negative (downward) direction:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**趋势**：趋势是指时间序列在长期内所呈现的总体方向。我们可以将趋势视为时间序列数据的整体大局。趋势可以是线性的，如*图 12**.1*所示，或者是非线性的（如二次型和指数型）；它们也可以是正向（上升）或负向（下降）的：'
- en: '![Figure 12.1 – A plot showing a positive stock price trend over time](img/B18118_12_001.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – 显示股票价格随时间变化的正向趋势的图表](img/B18118_12_001.jpg)'
- en: Figure 12.1 – A plot showing a positive stock price trend over time
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – 显示股票价格随时间变化的正向趋势的图表
- en: Trend analysis empowers data professionals, businesses, and policymakers to
    make informed decisions about the future.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 趋势分析使数据专业人员、企业和决策者能够做出关于未来的明智决策。
- en: '**Seasonality**: Seasonality refers to repetitive cycles occurring at regular
    intervals over a specific period, such as on a daily, weekly, monthly, or yearly
    basis. These variations are often byproducts of seasonal fluctuations; for example,
    a retail store in a residential area might get higher sales on weekends compared
    to weekdays (weekly seasonality). The same store could also witness a surge in
    sales during the holiday season in December and a drop in sales shortly after
    the festive period (annual seasonality), as illustrated by *Figure 12**.2*:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**季节性**：季节性是指在特定周期内（如日、周、月或年）定期发生的重复性周期。这些变化通常是季节性波动的副产品；例如，位于居民区的零售商店可能在周末的销售量比工作日更高（每周季节性）。同一家商店在12月的假期季节可能会见证销售激增，并在节庆过后不久出现销售下降（年度季节性），如*图
    12**.2*所示：'
- en: '![Figure 12.2 – A plot showing annual seasonality for a retail store](img/B18118_12_002.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – 显示零售商店的年度季节性的图表](img/B18118_12_002.jpg)'
- en: Figure 12.2 – A plot showing annual seasonality for a retail store
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 显示零售商店的年度季节性的图表
- en: '**Cyclicality**: Cyclicality refers to irregular cycles that occur in a time
    series over a long period of time. Unlike seasonality, these cycles are long-term
    in nature and their duration and magnitude are irregular, making them harder to
    predict when compared to seasonality. Economic cycles are a good example of cyclicity.
    These cycles are influenced by several factors such as inflation, interest rates,
    and government policies. Due to its irregular nature, predicting the timing, duration,
    and magnitude of cycles can be quite challenging. Advanced statistical and machine
    learning models are often required to model and forecast cyclic patterns accurately.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**周期性**：周期性指的是在较长时间内，时间序列中发生的不规则周期性波动。与季节性不同，这些周期具有长期性质，其持续时间和幅度不规律，因此相比季节性，它们更难预测。经济周期是周期性的一个典型例子。这些周期受到通货膨胀、利率和政府政策等多种因素的影响。由于周期性的不规则性，预测周期的时机、持续时间和幅度是相当具有挑战性的。通常需要先进的统计学和机器学习模型来准确建模和预测周期模式。'
- en: '**Autocorrelation**: Autocorrelation is a statistical concept that refers to
    the correlation between a time series and the lagged version of itself, as shown
    in *Figure 12**.3*.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自相关**：自相关是一个统计概念，指的是时间序列与其滞后版本之间的相关性，如*图 12.3*所示。'
- en: '![Figure 12.3 – A plot showing autocorrelation](img/B18118_12_003.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3 – 显示自相关的图表](img/B18118_12_003.jpg)'
- en: Figure 12.3 – A plot showing autocorrelation
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – 显示自相关的图表
- en: It is often referred to as serial correlation and measures the degree to which
    a data point is related to its past values. Autocorrelations can be positive or
    negative, with values ranging from -1 to 1.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常被称为序列相关，衡量数据点与其过去值之间的关联程度。自相关可以是正相关或负相关，值的范围从 -1 到 1。
- en: '**Noise**: Noise is an inherent part of any real-world data. It refers to the
    random fluctuations in data that cannot be explained by the model, nor can it
    be explained by any known underlying factors, patterns, or structural influences.
    These fluctuations can result from various sources such as measurement errors
    or unexpected events. For example, in the financial markets, an unpredicted event
    such as a political announcement can create noise that deviates stock prices from
    their underlying trends. Noise displays randomness and unexplained variations
    that we may have to smooth out when forecasting time series data.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**噪声**：噪声是任何现实世界数据中的固有部分。它指的是数据中无法通过模型解释的随机波动，也无法通过任何已知的潜在因素、模式或结构性影响解释。这些波动可能来自各种来源，如测量误差或意外事件。例如，在金融市场中，政治公告等未预测到的事件可能会产生噪声，导致股价偏离其潜在趋势。噪声呈现出随机性和无法解释的变化，预测时间序列数据时可能需要平滑这些波动。'
- en: We have discussed some important characteristics that can occur individually
    or together in time series data. Next, let us look at the types of time series
    data.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了一些可能单独或共同出现在时间序列数据中的重要特征。接下来，让我们看看时间序列数据的类型。
- en: Types of time series data
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间序列数据的类型
- en: 'Time series can be classified as the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列可以分为以下几类：
- en: Stationary and non-stationary
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平稳与非平稳
- en: Univariate and multivariate
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单变量和多变量
- en: Stationary and non-stationary time series
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平稳与非平稳时间序列
- en: A stationary time series is a time series whose statistical properties (mean,
    variance, and autocorrelation) remain constant over time. It is a series that
    displays recurring patterns and behaviors that are likely to replicate themselves
    in the future. A non-stationary time series is the opposite. It is not stationary,
    and we typically find these types of time series in many real-world scenarios
    where the series may display trends or seasonality. For example, we will expect
    the monthly sales of a ski resort to reach their peak during winter and dip during
    off-seasons. This seasonal component has an impact on the statistical properties
    of the series.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 平稳时间序列是指其统计特性（均值、方差和自相关）随时间保持恒定的时间序列。这种序列展示出周期性的模式和行为，未来很可能会重复出现。非平稳时间序列则相反。它不是平稳的，我们通常在许多现实场景中发现这类时间序列，其中序列可能会展示趋势或季节性。例如，我们可以预期滑雪度假村的月度销售在冬季达到峰值，而在淡季下滑。这个季节性成分会影响序列的统计特性。
- en: Univariate and multivariate time series
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单变量和多变量时间序列
- en: 'A univariate time series is a type of time series where we track just one metric
    over time. For example, we could use a smartwatch to track the number of steps
    we take on a daily basis. On the other hand, when we track more than one metric
    over time, we have a multivariate time series, as shown in *Figure 12**.4*. In
    the chart, we see the interaction between inflation and wage growth in the UK.
    Over time, we see that inflation persistently outpaces wage growth, leaving everyday
    people with lowered real income and purchasing power:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 单变量时间序列是一种只跟踪单一指标随时间变化的时间序列。例如，我们可以使用智能手表来跟踪我们每天步数的变化。另一方面，当我们跟踪多个指标随时间变化时，就会有多变量时间序列，如*图
    12.4*所示。在这张图表中，我们看到通货膨胀和工资增长之间的相互关系。随着时间的推移，我们可以看到通货膨胀持续超过工资增长，使得普通人的实际收入和购买力下降：
- en: '![Figure 12.4 – A multivariate time series showing the relationship between
    inflation and wage growth](img/B18118_12_004.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.4 – 多变量时间序列展示通货膨胀与工资增长的关系](img/B18118_12_004.jpg)'
- en: Figure 12.4 – A multivariate time series showing the relationship between inflation
    and wage growth
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 – 多变量时间序列展示通货膨胀与工资增长的关系
- en: Multivariate time series analysis lets us account for the dependencies and interactions
    between several variables over time. Next, let us delve into the importance of
    time series data and various applications of time series.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 多变量时间序列分析可以帮助我们考虑多个变量之间随时间变化的依赖关系和相互作用。接下来，让我们深入了解时间序列数据的重要性及其各种应用。
- en: Applications of time series
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间序列的应用
- en: 'We have discussed the types and properties of time series data. By applying
    machine learning techniques, we can leverage the wealth of information in these
    data types. Let us examine some of the important applications of machine learning
    in time series:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了时间序列数据的类型和属性。通过应用机器学习技术，我们可以利用这些数据类型中蕴含的大量信息。接下来，让我们来看一些机器学习在时间序列中的重要应用：
- en: '**Forecasting**: We can apply machine learning models to forecast time series;
    for instance, we may want to forecast the future sales of a retail store to inform
    our inventory decisions. If we analyze the sales record of the business, we may
    find some patterns, such as increased sales during holiday seasons or lowered
    sales during specific months. We can train our models with these patterns to make
    informed predictions about the future sales of the store, allowing key stakeholders
    to effectively plan for the expected demand.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预测**：我们可以应用机器学习模型来预测时间序列；例如，我们可能希望预测零售商店未来的销售情况，从而指导库存决策。如果我们分析商店的销售记录，可能会发现一些规律，比如在假期季节销售增加，或者在特定月份销售下降。我们可以利用这些规律来训练模型，从而做出关于商店未来销售的预测，帮助相关利益方有效规划预期需求。'
- en: '**Imputed data**: Missing values can pose a significant challenge when we are
    working on analyzing or forecasting time series data. A good solution is the application
    of imputation, allowing us to fill the missing data points with substitute values.
    For example, in *Figure 12**.5 (a)*, we see a plot of temperature values over
    a year. We quickly notice that some temperature recordings are missing. With the
    aid of imputation, we can estimate those values using adjacent days, as shown
    in *Figure* *12**.5 (b)*:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插补数据**：缺失值在分析或预测时间序列数据时可能会带来重大挑战。一个有效的解决方案是应用插补方法，允许我们使用替代值填补缺失的数据点。例如，在*图
    12.5 (a)*中，我们看到了一张展示一年温度值的图。我们很快注意到一些温度记录缺失了。在插补方法的帮助下，我们可以利用相邻天的数据来估算这些缺失值，如*图
    12.5 (b)*所示：'
- en: '![Figure 12.5 – A plot displaying temperature over time (a) with missing values
    (b) with no missing values](img/B18118_12_005.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.5 – 展示随时间变化的温度图（a）有缺失值（b）没有缺失值](img/B18118_12_005.jpg)'
- en: Figure 12.5 – A plot displaying temperature over time (a) with missing values
    (b) with no missing values
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5 – 展示随时间变化的温度图（a）有缺失值（b）没有缺失值
- en: By filling in the gaps, we now have a complete dataset that can be better utilized
    for analysis and prediction.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过填补缺失值，我们现在拥有了一个完整的数据集，可以更好地用于分析和预测。
- en: '**Anomaly detection**: Anomalies are data points that deviate significantly
    from the general norm. We can apply time series analysis to detect anomalies and
    potentially identify significant issues. For example, in credit card transactions,
    as illustrated in *Figure 12**.6*, an unusually large transaction might indicate
    fraudulent activity:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常检测**：异常是指显著偏离常规的数据点。我们可以应用时间序列分析来检测异常并潜在地识别出重要问题。例如，在信用卡交易中，如*图12.6*所示，一笔异常大的交易可能表示欺诈活动：'
- en: '![Figure 12.6 – A plot showing spikes in transaction values](img/B18118_12_006.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6 – 交易金额激增的图示](img/B18118_12_006.jpg)'
- en: Figure 12.6 – A plot showing spikes in transaction values
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – 交易金额激增的图示
- en: By using time series analysis to identify such anomalies, the bank can swiftly
    take action to mitigate potential damages.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用时间序列分析来识别这些异常，银行可以迅速采取措施，减少潜在损失。
- en: '**Trend analysis**: Understanding trends can provide valuable insights into
    the underlying phenomena. For example, the international energy agencies show
    that 14% of all new cars sold in 2022 were electric vehicles. This trend could
    indicate that people are moving toward a more sustainable option of transportation
    (see [https://www.iea.org/reports/global-ev-outlook-2023/executive-summary](https://www.iea.org/reports/global-ev-outlook-2023/executive-summary)).'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**趋势分析**：了解趋势可以为潜在现象提供宝贵的洞察。例如，国际能源机构显示，2022年所有新售汽车中有14%是电动汽车。这个趋势可能表明人们正在转向更加可持续的交通方式（见[https://www.iea.org/reports/global-ev-outlook-2023/executive-summary](https://www.iea.org/reports/global-ev-outlook-2023/executive-summary)）。'
- en: '**Seasonality analysis**: Another useful application of time series is in seasonality
    analysis. This could prove useful in guiding energy consumption planning and infrastructural
    expansion needs.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**季节性分析**：时间序列的另一个有用应用是季节性分析。这对于指导能源消耗规划和基础设施扩展需求可能非常有用。'
- en: We have now looked at some important applications of time series data. Next,
    let us take a look at some important techniques for forecasting time series.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经了解了一些时间序列数据的重要应用。接下来，让我们看看一些重要的时间序列预测技术。
- en: Techniques for forecasting time series
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间序列预测技术
- en: 'In this book, we will examine two main techniques for forecasting time series:
    statistical methods and machine learning methods. Statistical methods use mathematical
    models to capture the trend, seasonality, and other components of the time series
    data, with popular models being **autoregressive integrated moving average** (**ARIMA**)
    and **seasonal and trend decomposition using LOESS** (**STL**). However, these
    methods are beyond the scope of this book. Here, we will be using simpler statistical
    methods such as **naïve forecasting** and **moving averages** to establish our
    baseline, after which we will apply different machine learning methods. In this
    chapter, we will focus on using **deep neural networks** (**DNNs**), and in the
    next chapter, we will apply **recurrent neural networks** (**RNNs**) and **long
    short-term memory** **networks** (**LSTMs**).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将探讨两种主要的时间序列预测技术：统计方法和机器学习方法。统计方法通过使用数学模型来捕捉时间序列数据的趋势、季节性和其他组成部分，常见的模型包括**自回归综合滑动平均**（**ARIMA**）和**季节性与趋势分解使用LOESS**（**STL**）。然而，这些方法超出了本书的范围。在这里，我们将使用更简单的统计方法，如**朴素预测**和**移动平均**来建立我们的基准，然后再应用不同的机器学习方法。在本章中，我们将重点使用**深度神经网络**（**DNNs**），而在下一章中，我们将应用**递归神经网络**（**RNNs**）和**长短期记忆网络**（**LSTMs**）。
- en: Each approach has its pros and cons, and the best approach to forecasting time
    series is largely dependent on the specific characteristics of the data and the
    problem at hand. It is important thatwe highlight here that time series forecasting
    is a broad field, and there are other methods that fall outside the scope of this
    book that you may explore at a later stage. Before we move into modeling time
    series problems, let us examine how we can evaluate this type of data.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法都有其优缺点，最佳的时间序列预测方法在很大程度上取决于数据的具体特征和当前的问题。值得强调的是，时间序列预测是一个广泛的领域，仍有其他方法超出了本书的范围，您可以在以后的阶段进行探索。在我们开始建模时间序列问题之前，让我们先看看如何评估这种数据。
- en: Evaluating time series forecasting techniques
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估时间序列预测技术
- en: To effectively evaluate a time series forecasting model, we must gauge its performance
    with appropriate metrics. In [*Chapter 3*](B18118_03.xhtml#_idTextAnchor065),
    *Linear Regression with TensorFlow,* we explored several regression metrics such
    as MAE, MSE, RMSE, and MAPE. We can apply these metrics to evaluate time series
    forecasting models. However, in this chapter, we will concentrate on the application
    of MAE and MSE in line with the exam requirements. We use MAE to compute the average
    of the absolute difference between the predicted and true values. This way, we
    have a sense of how wrong our predictions are. A smaller MAE indicates a better
    model fit. Imagine you are a stock market analyst trying to forecast the future
    price of a specific stock. Using MAE as your evaluation metric, you would get
    a clear understanding of how much, on average, your forecasts differ from the
    actual stock prices. This information can help you refine your model to make more
    accurate predictions, minimizing potential financial risks.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效评估时间序列预测模型，我们必须使用适当的指标来衡量其表现。在[*第3章*](B18118_03.xhtml#_idTextAnchor065)《使用TensorFlow的线性回归》中，我们探讨了几种回归指标，如MAE、MSE、RMSE和MAPE。我们可以使用这些指标来评估时间序列预测模型。然而，在本章中，我们将重点应用MAE和MSE，以符合考试要求。我们使用MAE计算预测值与真实值之间绝对差异的平均值。通过这种方式，我们可以了解预测结果有多偏差。较小的MAE表示模型拟合较好。想象你是一名股票市场分析师，试图预测某只特定股票的未来价格。使用MAE作为评估指标，你可以清楚地了解你的预测与实际股票价格之间的平均差异。这些信息可以帮助你调整模型，做出更准确的预测，降低潜在的财务风险。
- en: On the other hand, MSE takes the average of squared discrepancies between predictions
    and actuals. By squaring the errors, MSE is more sensitive to large errors compared
    to MAE, making it useful where large discrepancies are unfavorable, such as when
    working with a power grid where precise load forecasting is of top priority. With
    this in mind, let’s now turn our attention to a sales use case and apply our learnings
    to forecast future sales.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，MSE计算的是预测值与实际值之间差异的平方平均值。通过对误差进行平方处理，MSE比MAE对较大误差更加敏感，因此在误差较大的情况不利时，MSE更为有用。例如，在处理电网时，精确的负荷预测至关重要，因此MSE尤为重要。考虑到这一点，现在让我们转向一个销售的使用案例，并应用我们的学习来预测未来的销售额。
- en: Retail store forecasting
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 零售店预测
- en: Imagine you are working as a machine learning engineer and your company just
    landed a new project. A rapidly growing superstore in Florida wants your help.
    They want to predict future reviews, as this will serve as a guide in planning
    the expansion of their stores to meet the expected demand. You have been saddled
    with the responsibility of building a forecasting model with the available historical
    data provided by the Tensor superstore. Let’s jump in and see how you can solve
    this problem, as your company is counting on you. Let’s get started!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你作为一名机器学习工程师，刚刚接到一个新项目。佛罗里达州的一家快速增长的大型超市请求你的帮助。他们希望预测未来的评论，这将为他们扩展商店并满足预期需求提供指导。你负责根据Tensor超市提供的历史数据构建一个预测模型。让我们一起看看你如何解决这个问题，因为公司正指望你。我们开始吧！
- en: 'We begin by importing the necessary libraries for our project:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先导入项目所需的库：
- en: '[PRE0]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we import `numpy` and `matplotlib` for numerical analysis and visualization
    purposes and `pandas` for data transformations.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们导入`numpy`和`matplotlib`用于数值分析和可视化，`pandas`用于数据转换。
- en: 'Next, we load the time series data:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们加载时间序列数据：
- en: '[PRE3]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we load the data and use the `head` function to get a snapshot of the
    first five rows of the data. When we run the code, we see that the first day of
    sales from the data given to us is `2013-01-01`. Next, let us look at some statistics
    to get a sense of the data we have in hand.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们加载数据并使用`head`函数查看数据的前五行。当我们运行代码时，看到给定数据中的销售第一天是`2013-01-01`。接下来，让我们查看一些统计信息，以便了解我们手头的数据。
- en: 'Use the following code to check the data type and summary statistics:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码检查数据类型和汇总统计信息：
- en: '[PRE5]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When we run the code, it returns the data type as `float64` and key summary
    statistics for our sales data. Using the `describe` function, we get a count of
    3,653 data points. This points to daily data over a 10-year period. We also see
    the mean sales per day come to around $75, giving us a sense of the central tendency.
    We see decent variability in the daily sales with a standard deviation of `20.2`.
    The minimum and maximum values reveal a range from $22 to $128 in sales, signaling
    some significant fluctuations occurring. The 25th and 75th percentiles are `60.27`
    and `89.18`, respectively, showing that lower-volume days see sales ofaround $60
    while higher-volume days see around $90\. Let us continue to explore the data
    by looking at it on a plot.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们运行代码时，它返回的数据类型为`float64`，并显示我们销售数据的关键汇总统计信息。使用`describe`函数，我们得到了3,653个数据点的计数。这指示了一个10年的每日数据周期。我们还看到每日的平均销售额大约为75美元，这给了我们一个关于数据集中趋势的直观感受。每日销售额有着相当的波动，标准差为`20.2`。最小值和最大值显示销售额的范围从22美元到128美元，表明存在显著的波动。第25和第75百分位数分别为`60.27`和`89.18`，显示低销售量的日子销售额大约为60美元，而高销售量的日子销售额则大约为90美元。接下来，我们通过绘图进一步探索数据。
- en: 'Let’s visualize our data:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们可视化数据：
- en: '[PRE9]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The code returns the plot shown in *Figure 12**.7*, which represents the company’s
    sales over a 10-year period:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码返回了如*图 12.7*所示的图表，表示公司在10年期间的销售情况：
- en: '![Figure 12.7 – A plot showing sales over time](img/B18118_12_007.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.7 – 显示销售随时间变化的图表](img/B18118_12_007.jpg)'
- en: Figure 12.7 – A plot showing sales over time
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 – 显示销售随时间变化的图表
- en: From the plot in *Figure 12**.7*, we can observe an overall positive upward
    trend, potentially indicative of economic growth or successful business strategies,
    such as new product releases and effective marketing. A clear yearly seasonality
    also emerges; this may suggest that the company deals in seasonal goods with annual
    demand fluctuations. Also, we observe some noise exists. This could be a result
    of weather variability, random events, or the entry of competitors. The upward
    trend in the data demonstrates promising performance and growth in sales over
    time. However, the seasonal effects and noise elements showcase complex dynamics
    underneath the aggregate trend. Next, let’s explore how to data partition the
    data.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从*图 12.7*中的图表中，我们可以观察到一个整体的积极上升趋势，这可能表明经济增长或成功的商业策略，如新产品发布和有效的市场营销。一个明显的年度季节性波动也浮现出来；这可能表明公司销售的是季节性商品，且有着每年波动的需求。同时，我们也观察到存在一些噪声。这可能是由于天气变化、随机事件或竞争对手的进入所导致。数据中的上升趋势显示了销售额随着时间的推移表现出良好的增长。然而，季节性效应和噪声因素揭示了总体趋势下更为复杂的动态。接下来，让我们探索如何对数据进行分区。
- en: Data partitioning
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据分区
- en: 'In time series forecasting, we typically divide our dataset into distinct sections:
    a training period for training our machine learning models, a validation period
    for model tuning and evaluation, and a test period for assessing performance on
    unseen data. This process is known as fixed partitioning. An alternate method
    is roll-forward partitioning, which we will be discussing shortly.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间序列预测中，我们通常将数据集分成不同的部分：用于训练机器学习模型的训练期、用于模型调优和评估的验证期，以及用于评估未见数据性能的测试期。这个过程被称为固定分区。另一种方法是滚动前进分区，我们将在接下来的部分讨论这一方法。
- en: Our sales data demonstrates seasonality; hence, we have to split the data in
    such a way that each partition captures entire seasonal cycles. We do this to
    ensure we do not omit important seasonal patterns in one or more of our partitions.
    While this method diverges from typical data partitioning, we see that when working
    with other machine learning problems where random samples are taken to form training,
    validation, and testing sets, the fundamental purpose remains the same. We train
    our model on the training data, fine-tune it using the validation data, and evaluate
    it on the test data. We can then incorporate the validation data into the training
    data to benefit from the most recent information and forecast future data.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的销售数据展示了季节性波动，因此，我们必须将数据按方式划分，以确保每个分区都包含完整的季节周期。我们这样做是为了确保不会遗漏一个或多个分区中的重要季节性模式。虽然这种方法与典型的数据分区方法有所不同，但我们看到在处理其他机器学习问题时，通常是通过随机抽样来形成训练集、验证集和测试集，基本目标保持一致。我们在训练数据上训练模型，使用验证数据进行调优，并在测试数据上评估模型。然后，我们可以将验证数据合并到训练数据中，以便利用最新的信息来预测未来的数据。
- en: 'It is generally a good idea to ensure that your training set is large enough
    to capture all relevant patterns in the data, including any seasonal behavior
    of the data. When setting the size of your validation set, you must strike a balance.
    While a larger validation set gives a more reliable estimate of model performance,
    it also reduces the size of the training set. You should also remember to retrain
    your final model on the entire dataset (combining the training and validation
    sets) before making final predictions. This strategy maximizes the amount of data
    the model learns from, likely improving its predictive performance on future unseen
    data. Again, avoid shuffling the data before splitting, as it would disrupt the
    temporal order, leading to misleading results. In fixed partitioning, we usually
    use a chronological split such that the training data should be from the earliest
    timestamps, followed sequentially by the validation set, and finally, the test
    set containing the latest timestamps. Let’s split our sales data into training
    and validation sets:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，确保训练集足够大以捕捉数据中所有相关模式是一个好主意，包括数据的季节性行为。在设置验证集的大小时，必须找到平衡点。虽然更大的验证集能够提供更可靠的模型性能估计，但它也会减少训练集的大小。你还应该记得在做出最终预测之前，使用整个数据集（将训练集和验证集合并）重新训练最终模型。这种策略最大化了模型从数据中学习的量，可能提高其对未来未见数据的预测性能。同样，避免在分割数据之前打乱数据，因为这会破坏时间顺序，导致误导性结果。在固定划分中，我们通常使用按时间顺序划分的方法，训练数据应该来自最早的时间戳，接着是验证集，最后是包含最新时间戳的测试集。让我们将销售数据分为训练集和验证集：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we split the data into training and validation sets. We take 80% of the
    data (`len(df) * 0.8`), which, in this case, is 8 years of data for training and
    the last 2 years for validation. We use the `int` function to ensure that the
    split time is an integer for indexing purposes. We set up our training and validation
    sets, using everything before the split time for training and everything after
    the split time for validation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将数据分为训练集和验证集。我们取80%的数据（`len(df) * 0.8`），在这个例子中是8年的数据用于训练，最后2年的数据用于验证。我们使用`int`函数确保分割时间是整数，以便进行索引操作。我们设置了训练集和验证集，使用分割时间之前的所有数据作为训练集，分割时间之后的所有数据作为验证集。
- en: 'Next, let us plot our training and validation data:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们绘制训练集和验证集的数据：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This code displays the partitioning of sales data into a training set and a
    validation set, marking them in green and blue colors respectively, with dates
    along the *x* axis and sales along the *y* axis. For readability, we set our *x*
    ticks marks to every 180 days:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了销售数据的划分，将训练集和验证集分别用绿色和蓝色标记，*x*轴表示日期，*y*轴表示销售额。为了提高可读性，我们将*x*轴的刻度设置为每180天一次：
- en: '![Figure 12.8 – A plot showing fixed partitioning](img/B18118_12_008.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图12.8 – 显示固定划分的图表](img/B18118_12_008.jpg)'
- en: Figure 12.8 – A plot showing fixed partitioning
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 – 显示固定划分的图表
- en: In *Figure 12**.8*, we split our sales data into 8 years for training and 2
    years for validation. In this scenario, our test set will be data from the future.
    This is done to ensure that the model is trained on the earliest part of our series,
    validated on the recent past, and tested on the future. Another method of partitioning
    time series data is called roll-forward partitioning, or “walk-forward” validation.
    In this method, we start with a short training period and gradually increase it.
    For each training period, the following period is used as the validation set.
    This mirrors a real-life situation where we continually retrain our model as new
    data comes in and use it to predict the next period. Let’s discuss our first method
    of forecasting, called naïve forecasting.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图12.8*中，我们将销售数据划分为8年的训练数据和2年的验证数据。在这种情况下，我们的测试集将是来自未来的数据。这是为了确保模型在时间序列的最早部分进行训练，在最近的过去进行验证，并在未来进行测试。另一种划分时间序列数据的方法被称为滚动前移划分或“前行”验证。在这种方法中，我们从一个较短的训练期开始，并逐渐增加训练期的长度。对于每个训练期，接下来的时间段作为验证集。这种方法模拟了现实生活中的情况，我们会随着新数据的到来不断重新训练模型，并利用它来预测下一时期。让我们讨论一下我们的第一种预测方法，叫做天真预测。
- en: Naïve forecasting
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 天真预测
- en: Naïve forecasting is one of the simplest methods for forecasting in time series
    analysis. The principle behind naïve forecasting is to simply set all forecasts
    to be the value of the last observed point. This is why it’s referred to as “naïve.”
    It is a method that assumes that the future value is likely to be the same as
    the current one. Despite its simplicity, naïve forecasting can often serve as
    a good baseline for time series forecasting; however, its performance can vary
    depending on the characteristics of the time series.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 朴素预测是时间序列分析中最简单的方法之一。朴素预测的原理是将所有预测值设为最后一个观察点的值。这就是为什么它被称为“朴素”的原因。它是一种假设未来值可能与当前值相同的方法。尽管其简单，但朴素预测通常可以作为时间序列预测的一个良好基准；然而，它的表现可能会根据时间序列的特征有所不同。
- en: 'Let us see how to implement this in code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在代码中实现这个：
- en: 'Let’s implement naïve forecasting:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现朴素预测：
- en: '[PRE17]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To implement the naïve forecasting method, each forecasted value is simply
    set to the actual observed value from the previous time step, achieved by shifting
    the `Sales` column by one unit. We use `df.head()` to display the first five rows
    of the DataFrame, providing a quick overview of the sales data and the naïve forecast:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了实现朴素预测方法，每个预测值仅设置为前一个时间步的实际观察值，通过将`Sales`列向前移动一个单位来实现。我们使用`df.head()`来显示 DataFrame
    的前五行，以快速概览销售数据和朴素预测：
- en: '![Figure 12.9 – A snapshot of the DataFrame showing the sales and naïve forecasts](img/B18118_12_009.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.9 – 显示销售和朴素预测的 DataFrame 快照](img/B18118_12_009.jpg)'
- en: Figure 12.9 – A snapshot of the DataFrame showing the sales and naïve forecasts
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9 – 显示销售和朴素预测的 DataFrame 快照
- en: From the table in *Figure 12**.9*, we see that the first forecast is not available.
    This is because this method simply takes all the values in the series starting
    from one step before the validation data until the second-last value of the series.
    This effectively shifts the time series by one time step into the future.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从*图 12.9*中的表格来看，我们看到第一个预测值是不可用的。这是因为该方法仅仅取从验证数据前一步开始，直到序列倒数第二个值的所有值。这实际上将时间序列向未来移动了一个时间步长。
- en: 'Let us create a function for plotting purposes:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个用于绘图的函数：
- en: '[PRE20]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We construct a utility plot to generate the graph of the true and predicted
    validation values. This function takes in the predicted and true values of our
    validation data along with the start date, end date, plot title, and plot label.
    This function gives us the flexibility to drill down into different areas of interest
    in the plot.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们构建一个实用的图表来生成真实和预测验证值的图形。该函数接受我们的验证数据的预测值和真实值，并包括开始日期、结束日期、图表标题和标签。该函数为我们提供了灵活性，可以深入探讨图表中的不同兴趣区域。
- en: 'Next, let’s plot the naïve forecast:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们绘制朴素预测：
- en: '[PRE52]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We pass in the required parameters and run the code to generate the following
    plot:'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们传入所需的参数并运行代码，生成以下图表：
- en: '![Figure 12.10 – A time series forecast using the naïve method](img/B18118_12_010.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.10 – 使用朴素方法的时间序列预测](img/B18118_12_010.jpg)'
- en: Figure 12.10 – A time series forecast using the naïve method
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.10 – 使用朴素方法的时间序列预测
- en: The plot in *Figure 12**.10* displays the forecasted values and the true values
    for the validation data. Because the plot looks a bit clustered due to the closeness
    in values, let us zoom in to help us visually investigate how our forecasting
    is doing.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12.10*中的图表显示了预测值和验证数据的真实值。由于值接近，图表看起来有点密集，因此让我们放大，以帮助我们在视觉上检查预测的效果。'
- en: 'Let’s look at a specific time range:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看一下特定的时间范围：
- en: '[PRE55]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We set the start date and end date parameters to `2022-01-01` and `2022-06-30`,
    respectively. The resulting plot is as follows:'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将开始日期和结束日期参数设置为`2022-01-01`和`2022-06-30`，得到的图表如下：
- en: '![Figure 12.11 – Zoomed-in time series forecasting using the naïve method](img/B18118_12_011.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.11 – 使用朴素方法的放大时间序列预测](img/B18118_12_011.jpg)'
- en: Figure 12.11 – Zoomed-in time series forecasting using the naïve method
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.11 – 使用朴素方法的放大时间序列预测
- en: From the plot in *Figure 12**.11*, we can see that it starts the forecast one
    step later because the naïve forecast is shifted one step into the future.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从*图 12.11*中的图表可以看出，预测开始得晚了一步，因为朴素预测向未来移动了一个时间步。
- en: 'Next, let us evaluate the performance of the naïve method:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们评估朴素方法的表现：
- en: '[PRE57]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We use the `metrics` functions provided by the `.numpy()` to convert the result
    from a TensorFlow tensor to a NumPy array. When we run the code, we get an MSE
    for the naïve forecast as `45.22` and an MAE for the naïve forecast as `5.43`.
    Recall that for the MSE and MAE values, lower values are always better.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用`.numpy()`提供的`metrics`函数，将TensorFlow张量的结果转换为NumPy数组。当我们运行代码时，得到朴素预测的均方误差（MSE）为`45.22`，朴素预测的平均绝对误差（MAE）为`5.43`。回想一下，对于MSE和MAE值，较低的值总是更好。
- en: Let’s keep this in mind as we explore other forecasting techniques. Naïve forecasting
    can serve as a baseline to compare the performance of more complex models. Next,
    let’s examine another statistical method, called moving average.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索其他预测技术时，记住这一点。朴素预测可以作为基准，用于比较更复杂模型的表现。接下来，我们将研究另一种统计方法，称为移动平均。
- en: Moving average
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动平均
- en: Moving average is a technique for smoothing time series data by replacing each
    point with an average of the neighboring points. In this process, we generate
    a new series in which the data points are averages of the raw data in our original
    series. The key parameter in this method is the **window width**; this determines
    the number of consecutive raw data points included in the average calculation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 移动平均是一种通过将每个数据点替换为邻近数据点的平均值来平滑时间序列数据的技术。在此过程中，我们生成一个新的序列，其中的数据点是原始数据序列中的数据点的平均值。此方法中的关键参数是**窗口宽度**，它决定了计算平均值时包括的连续原始数据点的数量。
- en: The term “moving” refers to the sliding of the window along the time series
    to compute average values, thereby generating a new series.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: “移动”一词指的是沿时间序列滑动窗口来计算平均值，从而生成一个新的序列。
- en: Types of moving averages
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动平均的类型
- en: 'Two main types of moving averages are commonly used in time series analysis
    – the centered moving average and the trailing moving average:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列分析中常用的两种主要移动平均类型是中心移动平均和滞后移动平均：
- en: '**Centered moving average**: A centered moving average calculates the average
    around a central point (*t*). It uses data from both before and after the time
    of interest for visualization, as illustrated in *Figure 12**.12*. Centered moving
    averages can give a well-balanced view of data trends, but since they require
    future data, they’re not suitable for forecasting as we do not have access to
    future values when making forecasts. Centered moving averages are good for visualization
    and time series analysis.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中心移动平均**：中心移动平均围绕中心点（*t*）计算平均值。它使用兴趣时间点前后的数据进行可视化，如*图12.12*所示。中心移动平均能够提供数据趋势的均衡视图，但由于它需要未来数据，因此不适用于预测，因为在进行预测时我们无法获得未来的值。中心移动平均适用于可视化和时间序列分析。'
- en: '![Figure 12.12 – A plot showing acentered moving average](img/B18118_12_012.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图12.12 – 显示中心移动平均的图形](img/B18118_12_012.jpg)'
- en: Figure 12.12 – A plot showing acentered moving average
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12 – 显示中心移动平均的图形
- en: Centered moving averages can give a well-balanced view of data trends, but since
    they require future data, they’re not suitable for forecasting as we do not have
    access to future values when making forecasts. Centered moving averages are good
    for visualization and time series analysis.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 中心移动平均能够提供数据趋势的均衡视图，但由于它需要未来数据，因此不适用于预测，因为在进行预测时我们无法获得未来的值。中心移动平均适用于可视化和时间序列分析。
- en: '**Trailing moving average**: A trailing moving average, also known as a rolling
    or running average, calculates the average using the most recent *n* data points.
    This method solely requires past data points, as illustrated in *Figure 12**.13*,
    making it ideal for forecasting.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滞后移动平均**：滞后移动平均，也称为滚动平均或运行平均，通过使用最近的*n*个数据点来计算平均值。此方法仅需要过去的数据点，如*图12.13*所示，非常适合用于预测。'
- en: '![Figure 12.13 – A plot showing atrailing moving average](img/B18118_12_013.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图12.13 – 显示滞后移动平均的图形](img/B18118_12_013.jpg)'
- en: Figure 12.13 – A plot showing atrailing moving average
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13 – 显示滞后移动平均的图形
- en: To compute a trailing moving average, the first step is choosing the window
    width (*W*). This selection can depend on various factors such as the series’
    patterns and how much smoothing you want to achieve. A smaller window width will
    track quick changes closely, but this will happen at the risk of including more
    noise. On the other hand, a larger window width will provide a smoother line but
    might miss out on some short-term fluctuations.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 计算滞后移动平均的第一步是选择窗口宽度 (*W*)。这个选择可以依赖于各种因素，例如序列的模式和你希望实现的平滑程度。较小的窗口宽度能够更紧密地跟踪快速变化，但这也可能会带来更多噪音。另一方面，较大的窗口宽度能够提供更平滑的曲线，但可能会错过一些短期波动。
- en: 'Let’s see how to implement moving averages:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现移动平均：
- en: '[PRE67]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The code uses pandas’ `rolling` function to calculate the moving average of
    the `Sales` data over a 30-day window, then shifts the outcome one step forward
    to simulate a forecast for the subsequent time step, storing the result in a new
    `Moving_Average_Forecast` column. You can think of it as using a window of 30
    days of sales to predict the sales on the 31st day.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用 pandas 的`rolling`函数来计算 `Sales` 数据的 30 天窗口移动平均，然后将结果向前移动一步，以模拟下一时间步的预测，并将结果存储在新的
    `Moving_Average_Forecast` 列中。你可以将其视为使用 30 天的销售数据来预测第 31 天的销售。
- en: 'We call the `plot_forecast` function to plot both the validation data and the
    moving average forecast data. We can see the resulting plot in *Figure 12**.14*:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 `plot_forecast` 函数来绘制验证数据和移动平均预测数据。我们可以在*图 12.14*中看到结果图：
- en: '![Figure 12.14 – A time series forecast using the moving average method](img/B18118_12_014.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.14 – 使用移动平均法进行时间序列预测](img/B18118_12_014.jpg)'
- en: Figure 12.14 – A time series forecast using the moving average method
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.14 – 使用移动平均法进行时间序列预测
- en: In the plot in *Figure 12**.14*, the moving average forecast is computed using
    the past 30 days of sales data. A smaller window size, such as a 7-day window,
    will follow the actual sales more closely than the 30-day moving average, but
    it might also capture more of the noise in the data.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 12.14*中，移动平均预测是使用过去 30 天的销售数据计算出来的。较小的窗口大小，例如 7 天的窗口，将比 30 天的移动平均更加贴近实际销售，但也可能会捕捉到数据中的更多噪音。
- en: 'The next logical step will be to evaluate our model by using the `metric` function
    again. This time, we pass in the moving average forecast against the true validation
    values:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步逻辑就是再次使用`metric`函数评估我们的模型。这次，我们将移动平均预测与真实的验证值进行对比：
- en: '[PRE68]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: When we run the code, we achieve an MSE of `55.55` and an MAE of `6.05` for
    the moving average forecast. The MAE and MSE are much worse than our baseline.
    If you change the window size to 7 days, we end up with a much lower MSE and MAE
    of `48.57` and `5.61,` respectively. This is a much better result, but slightly
    worse than our naïve approach. You could experiment with a smaller window size
    and see whether your results will surpass the baseline.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行代码时，移动平均预测的 MSE 为 `55.55`，MAE 为 `6.05`。这两个值比我们的基准结果要差得多。如果你将窗口大小改为 7 天，我们最终得到的
    MSE 和 MAE 分别为 `48.57` 和 `5.61`，这是一个更好的结果，但比我们天真的方法稍差。你可以尝试更小的窗口大小，看看结果是否能够超过基准值。
- en: However, we need to note that the underlying assumption when using moving average
    is stationarity. And we know that our time series has both trend and seasonality,
    so how do we achieve stationarity with this data? And will this help us to achieve
    a much lower MAE? To achieve stationarity, we use a concept called **differencing**.
    Let us discuss differencing next, and see how to apply it and whether it will
    help us achieve a much lower MAE and MSE.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要注意的是，使用移动平均法的前提假设是平稳性。我们知道我们的时间序列同时包含趋势和季节性，那么我们该如何在这些数据上实现平稳性呢？这是否能帮助我们实现更低的
    MAE？为了实现平稳性，我们使用一个叫做**差分**的概念。接下来让我们讨论差分，并看看如何应用它，以及它是否能帮助我们实现更低的 MAE 和 MSE。
- en: Differencing
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 差分
- en: 'Differencing is a method used to achieve stationarity in our time series. It
    works by calculating the difference between consecutive observations. The logic
    here is that, though the original series may have a trend and is non-stationary,
    the difference between the values of the series can be stationary. By differencing
    the data, we can remove the trend and seasonality, making the series stationary
    and thus suitable for a moving average forecast model. This can significantly
    improve the accuracy of the model and, therefore, the reliability of the forecast.
    Let us see this in the following code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 差分是用于实现时间序列平稳性的一种方法。它通过计算连续观测值之间的差异来工作。其逻辑是，尽管原始序列可能存在趋势并且非平稳，但序列值之间的差异可能是平稳的。通过对数据进行差分，我们可以去除趋势和季节性，从而使序列平稳，并使其适合用于移动平均预测模型。这可以显著提高模型的准确性，从而提高预测的可靠性。让我们在以下代码中查看这一点：
- en: '[PRE69]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The preceding code block applies differencing to our time series data. We begin
    by generating a new series where each value is different between a value and the
    value 365 days earlier. We do this because we know our data has yearly seasonality.
    Next, we plot our data:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块对我们的时间序列数据应用了差分。我们首先生成一个新序列，其中每个值与365天前的值之间存在差异。我们这样做是因为我们知道数据具有年度季节性。接下来，我们绘制我们的数据：
- en: '![Figure 12.15 – A plot showing the sales time series after differencing](img/B18118_12_015.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.15 – 显示差分后销售时间序列的图表](img/B18118_12_015.jpg)'
- en: Figure 12.15 – A plot showing the sales time series after differencing
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.15 – 显示差分后销售时间序列的图表
- en: We can see that the plot in *Figure 12**.15* has no trend or seasonality. Hence,
    we have achieved the stationarity required in the underlying assumption when using
    moving averages.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，*图 12.15* 中的图表没有趋势或季节性。因此，我们已经实现了使用移动平均法时所需的平稳性假设。
- en: 'Let’s now restore the trend and seasonality:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们恢复趋势和季节性：
- en: '[PRE70]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here, we incorporate seasonality back into our time series data after it has
    been differenced, then apply moving average forecasting on this restored data.
    We use a 7-day window for the moving average computation. After restoring the
    trend and seasonality by adding the shifted sales data to the differenced sales
    data, we compute a moving average of these restored sales over our chosen window
    size, and then shift the resulting series one step ahead for forecasting. We then
    split the data again into training and validation sets. The same split time is
    used to ensure consistency with the earlier split. This is crucial to ensure we
    are evaluating our model correctly. Finally, we prepare our forecasted and true
    sales values for evaluation by extracting the `Restored_Moving_Average_Forecast`
    and `Sales` values from the validation set:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将季节性重新融入到经过差分的时间序列数据中，然后对这个恢复的数据应用移动平均预测。我们使用一个7天窗口进行移动平均计算。通过将平移后的销售数据添加到差分后的销售数据中恢复趋势和季节性后，我们计算这些恢复的销售数据在所选窗口大小上的移动平均值，然后将结果序列向前移动一步进行预测。然后，我们再次将数据拆分为训练集和验证集。使用相同的拆分时间，以确保与之前的拆分一致。这对于确保我们正确评估模型至关重要。最后，我们通过从验证集中提取`Restored_Moving_Average_Forecast`和`Sales`值，准备进行预测值和真实销售值的评估：
- en: '![Figure 12.16 – A sales forecast after restoring seasonality and trend](img/B18118_12_016.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.16 – 恢复季节性和趋势后的销售预测](img/B18118_12_016.jpg)'
- en: Figure 12.16 – A sales forecast after restoring seasonality and trend
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.16 – 恢复季节性和趋势后的销售预测
- en: In the plot in *Figure 12**.16*, the orange line represents the forecasts after
    we’ve added the past values back in to restore the trend and seasonality. Recall
    that we are using a window size of `7` with which we achieved lower MAE and MSE
    values. Now, we have essentially used the forecasts from the differenced series
    to forecast the changes from one year to the next and then added these changes
    onto the values from a year ago to get our final forecasts.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 12.16*中的图表中，橙色线表示我们将过去的值重新加入以恢复趋势和季节性后的预测结果。回想一下，我们使用了一个大小为`7`的窗口，这使得我们得到了更低的MAE和MSE值。现在，我们本质上是利用差分序列的预测来预测从一年到下一年的变化，然后将这些变化加到一年前的值上，从而得到最终的预测值。
- en: When we compute the MSE for forecasting with restored seasonality and trend,
    we get `48.57`, and for theMAE for forecast with restored seasonality and trend,
    we get `5.61`, both of which are significantly lower than without using differencing.
    We can also try to smooth out the noise in the data to improve our MAE and MSE
    scores. Next, let us see how we can perform forecasting with machine learning,
    and in particular, with neural networks with TensorFlow.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们计算恢复季节性和趋势的预测的 MSE 时，结果是 `48.57`，而恢复季节性和趋势的 MAE 为 `5.61`，这两个值明显低于未使用差分时的结果。我们还可以尝试平滑数据中的噪声，以提高
    MAE 和 MSE 的得分。接下来，让我们看看如何使用机器学习，特别是使用 TensorFlow 的神经网络进行预测。
- en: Time series forecasting with machine learning
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用机器学习进行时间序列预测
- en: 'So far, we have examined statistical methods with reasonable success. Now,
    we will proceed with modeling time series data using deep learning techniques.
    We will begin with mastering how to set up a window dataset. We will also cover
    ideas such as shuffling and batching, and see how we can build and train a neural
    network for our sales forecasting problem. Let’s begin by mastering how we can
    prepare time series data for modeling using the windowed dataset method with the
    aid of TensorFlow utilities:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用统计方法取得了相当不错的结果。接下来，我们将使用深度学习技术对时间序列数据进行建模。我们将从掌握如何设置窗口数据集开始。我们还将讨论一些概念，如洗牌和批处理，并看看如何构建和训练一个神经网络来解决我们的销售预测问题。让我们首先掌握如何使用
    TensorFlow 工具准备时间序列数据，以便使用窗口数据集方法进行建模：
- en: 'We begin by importing the libraries required:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从导入所需的库开始：
- en: '[PRE71]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Here, we will be using NumPy and TensorFlow to prepare and manipulate our data
    into the required structure for modeling.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将使用 NumPy 和 TensorFlow 准备并处理我们的数据，使其符合建模所需的结构。
- en: 'Let us create a simple dataset. Here, we are assuming the data consists of
    temperature values for two weeks:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的数据集。这里我们假设数据由两周的温度值组成：
- en: '[PRE73]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'When we print out the temperature, we get the following:'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们打印温度数据时，得到以下内容：
- en: '[PRE76]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We get an array of values 1-14, where we are assuming the temperature rises
    from 1 on the first day to 14 on the 14th day. Odd, but let’s assume this is the
    case.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们得到一个从 1 到 14 的数值数组，其中我们假设温度从第一天的 1 上升到第 14 天的 14。虽然有些奇怪，但我们就假设是这样。
- en: 'Let’s create windowed data. Now that we have our data, we need to make a “window”
    of data points:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建窗口化数据。现在我们有了数据，接下来需要创建一个数据点的“窗口”：
- en: '[PRE77]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The `window_size` parameter refers to the window of data under consideration.
    If we set the window size to `3`, this means we will use 3 consecutive days’ temperature
    values to predict the next day’s temperature. The batch size determines how many
    samples are processed in each iteration during training, and `shuffle_buffer`
    specifies the number of elements from which TensorFlow randomly samples when shuffling
    the data. We shuffle to avoid sequential bias; we will expand on this in the next
    chapter.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`window_size` 参数指的是正在考虑的数据窗口。如果我们将窗口大小设置为 `3`，这意味着我们将使用连续 3 天的温度值来预测下一天的温度。批量大小决定了在每次训练迭代中处理的样本数量，而
    `shuffle_buffer` 指定了在洗牌数据时，TensorFlow 从多少个元素中随机采样。我们洗牌是为了避免顺序偏差；我们将在下一章进一步讨论这一点。'
- en: 'Creating a dataset works as follows:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建数据集的过程如下：
- en: '[PRE80]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This line of code is used to create a TensorFlow `Dataset` object from our temperature
    data. This `Dataset` API is a high-level TensorFlow API for reading data and transforming
    it into a form that a machine learning model can use. Next, we iterate over the
    dataset and print each element. We use `numpy()` to convert a TensorFlow object
    into a NumPy array. When we run the code, we get the numbers 1-14; however, they
    are now ready to be windowed.
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这行代码用于从我们的温度数据创建一个 TensorFlow `Dataset` 对象。这个 `Dataset` API 是一个高层次的 TensorFlow
    API，用于读取数据并将其转换为机器学习模型可以使用的形式。接下来，我们遍历数据集并打印每个元素。我们使用 `numpy()` 将 TensorFlow 对象转换为
    NumPy 数组。当我们运行代码时，我们得到数字 1-14；然而，现在它们已经准备好进行窗口化处理了。
- en: 'Next, let’s transform our temperature data into a “windowed” dataset:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们将温度数据转换成一个“窗口化”的数据集：
- en: '[PRE83]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: We apply the `window` method to create a dataset of windows, where each window
    is a dataset itself. The `window_size + 1` parameter means that we are considering
    the `window_size` elements as input and the next one as a label. The `shift=1`
    parameter means that the window moves one step at a time. The `drop_remainder=True`
    parameter means that we will drop the last few elements if they can’t form a complete
    window.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用`window`方法来创建一个窗口数据集，其中每个窗口本身也是一个数据集。`window_size + 1`参数意味着我们将`window_size`个元素作为输入，接下来的一个元素作为标签。`shift=1`参数表示窗口每次移动一步。`drop_remainder=True`参数表示如果最后几个元素无法形成完整窗口，我们将丢弃它们。
- en: 'When we print out our `window_data`, we get the following output:'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们打印出我们的`window_data`时，得到如下输出：
- en: '[PRE89]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: We see that we now have the window size that we set to 3 values and the (`+1`)
    that will serve as our label. Because we set the shift value to `1`, the next
    window starts from the second value in our series, which in this case is `2`.
    Next, the window will move one more step until we make all the windowed data.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们看到现在窗口大小被设置为3，`+1`部分将作为标签。由于我们将`shift`值设置为`1`，下一个窗口将从序列中的第二个值开始，在这个例子中是`2`。接下来，窗口将继续移动一步，直到我们处理完所有窗口数据。
- en: 'Flattening the data works as follows:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展平数据的过程如下：
- en: '[PRE101]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'It’s easy to view each window created in the last step as a separate dataset.
    With this code, we flatten the data so that each window of data is packaged as
    a single batch in the main dataset. We use `flat_map` to flatten it back into
    a dataset of tensors and `window.batch(window_size + 1)` to convert each window
    dataset into a batched tensor. When we run the code, we get the following:'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 很容易将上一阶段创建的每个窗口视为一个单独的数据集。通过这段代码，我们将数据展平，使得每个窗口的数据作为主数据集中的一个单独批次打包。我们使用`flat_map`将其展平回张量数据集，并使用`window.batch(window_size
    + 1)`将每个窗口数据集转换为批次张量。当我们运行代码时，得到如下结果：
- en: '[PRE105]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: We can see the windowed data is now put into batched tensors.
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到，窗口数据现在已被放入批次张量中。
- en: 'Shuffle the data as follows:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打乱数据的过程如下：
- en: '[PRE117]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'In this code block, we shuffle the data. This is an important step as shuffling
    is used to ensure that the model doesn’t accidentally learn patterns from the
    order in which examples are presented during training. When we run the code block,
    we get the following:'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这段代码中，我们对数据进行了打乱。这是一个重要步骤，因为打乱用于确保模型在训练过程中不会错误地学习到数据呈现顺序中的模式。当我们运行代码时，得到如下结果：
- en: '[PRE121]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: We can see that the mini datasets in the main dataset have been shuffled. However,
    take note that the features (window) and the label are unchanged in the shuffled
    dataset.
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到主数据集中的小型数据集已被打乱。但是，请注意，打乱后的数据集中，特征（窗口）和标签保持不变。
- en: 'Mapping features and labels works as follows:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特征和标签映射的过程如下：
- en: '[PRE133]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The `map` method applies a function to each element of the dataset. Here, we
    are splitting each window into features and labels. The features are all but the
    last element of the `(window[:-1])` window, and the label is the last element
    of the `(window[-1])` window. When we run the code block, we see the following:'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`map`方法对数据集的每个元素应用一个函数。在这里，我们将每个窗口分割成特征和标签。特征是窗口中的所有元素（除了最后一个元素，`window[:-1]`），标签是窗口中的最后一个元素，`window[-1]`。当我们运行代码时，看到如下结果：'
- en: '[PRE138]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: From our print result, we see the features are made up of three observations
    in an order and the next value is our label.
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从打印结果来看，我们可以看到特征由三次观察值组成，并且下一个值是我们的标签。
- en: 'Batching and prefetching the data works as follows:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 批次处理和预取数据的过程如下：
- en: '[PRE150]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'The `batch()` function groups the dataset into batches of `batch_size`. In
    this case, we’re creating batches of size `2`. The `prefetch(1)` performance optimization
    function makes sure that TensorFlow always has one batch ready to go while it’s
    processing the current one. After these transformations, the dataset is ready
    to be used for training a machine learning model. Let’s print out the batch:'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`batch()`函数将数据集分成大小为`batch_size`的批次。在这里，我们创建了大小为`2`的批次。`prefetch(1)`性能优化函数确保TensorFlow在处理当前批次时，总是有一个批次已准备好。在进行这些转换后，数据集准备好用于训练机器学习模型。让我们打印出批次数据：'
- en: '[PRE154]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: We see that each element of the dataset is a batch of features and label pairs,
    where the features are arrays of the `window_size` values from the original series,
    and the label is the next value that we want to predict. We have seen how to prepare
    our time series data for modeling; we have sliced, windowed, batched, shuffled,
    and split it into features and labels for this purpose.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到数据集中的每个元素是一个特征和标签对的批次，其中特征是原始序列中`window_size`个值的数组，而标签是我们想要预测的下一个值。我们已经看到如何准备我们的时间序列数据进行建模；我们已经将其切片、窗口化、批处理、打乱，并将其拆分成特征和标签以供使用。
- en: Next, let us use what we have learned here on our synthetic sales data to forecast
    future sales values.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将利用在合成销售数据上学到的内容，来预测未来的销售值。
- en: Sales forecasting using neural networks
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用神经网络进行销售预测
- en: 'Let’s return to the sales data that we created to forecast sales using both
    naïve and moving average methods. Let us now use a neural network; here, we will
    use a DNN:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们创建的销售数据，用于通过天真方法和移动平均方法预测销售。现在我们使用一个神经网络；在这里，我们将使用一个DNN：
- en: 'Extracting the data works as follows:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取数据的过程如下：
- en: '[PRE178]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: In this code, we extract the `Date` and `Sales` data from the `Sales` DataFrame.
    `Date` is converted into datetime format and `Sales` is converted into a NumPy
    array.
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这段代码中，我们从`Sales`数据框中提取`Date`和`Sales`数据。`Date`被转换为日期时间格式，`Sales`被转换为NumPy数组。
- en: 'Splitting the data works as follows:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据拆分的过程如下：
- en: '[PRE180]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: For uniformity, we split data into a training set and a validation set using
    the same 80:20 split by using `split_time` of 80%.
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了统一性，我们使用80%的`split_time`将数据分为训练集和验证集，采用相同的80:20分割方式。
- en: 'Creating the windowed dataset works as follows:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建窗口化数据集的过程如下：
- en: '[PRE185]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: We create the `windowed_dataset` function; this function takes in a series,
    a window size, a batch size, and a shuffle buffer. It creates windows of data
    for training, with each window containing a `window_size + 1` data point. These
    windows are then shuffled and mapped to features and labels, where the features
    are all data points in a window, except the last one, and the label is the last
    data point. The windows are then batched and prefetched for efficient data loading.
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们创建了`windowed_dataset`函数；该函数接收一个序列、一个窗口大小、一个批量大小和一个随机缓冲区。它为训练创建数据窗口，每个窗口包含`window_size
    + 1`个数据点。这些窗口随后被打乱并映射到特征和标签，其中特征是窗口中的所有数据点（除了最后一个），标签是最后一个数据点。然后，这些窗口被批处理并预取，以提高数据加载效率。
- en: 'Building the model works as follows:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建模型的过程如下：
- en: '[PRE200]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: Next, we use a simple **feedforward neural network** (**FFN**) for modeling.
    This model contains two dense layers with ReLU activation, followed by a dense
    output layer with a single neuron. The model is compiled with MSE loss and **stochastic
    gradient descent** (**SGD**) as the optimizer.
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们使用一个简单的**前馈神经网络**（**FFN**）进行建模。该模型包含两个具有ReLU激活函数的全连接层，随后是一个具有单个神经元的全连接输出层。模型使用MSE损失函数，并以**随机梯度下降**（**SGD**）作为优化器进行编译。
- en: 'Training the model works as follows:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 训练模型的过程如下：
- en: '[PRE209]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: The model is trained on the windowed dataset for 100 epochs.
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模型在窗口化的数据集上训练100个周期。
- en: 'Generating predictions works as follows:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成预测的过程如下：
- en: '[PRE210]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: Here, we generate predictions in batches to improve computational efficiency.
    Only the predictions for the validation period are kept.
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们批量生成预测结果以提高计算效率。只保留验证期的预测结果。
- en: 'Evaluating the model works as follows:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估模型的过程如下：
- en: '[PRE216]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE219]'
- en: The MSE and MAE between the true validation data and the predicted data are
    calculated. Here, we achieved an MSE of `34.51` and an MAE of `4.72`, which surpasses
    all our simple statistical methods.
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算真实验证数据和预测数据之间的MSE和MAE。在这里，我们得到了MSE为`34.51`，MAE为`4.72`，这超越了我们所有的简单统计方法。
- en: 'Visualizing the results works as follows. The true validation data and the
    predicted data are plotted over time to visualize the model’s performance:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可视化结果的过程如下。将真实验证数据和预测数据随时间绘制，以可视化模型的表现：
- en: '![Figure 12.17 – A time series forecast using a simple FFN](img/B18118_12_017.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.17 – 使用简单FFN的时间序列预测](img/B18118_12_017.jpg)'
- en: Figure 12.17 – A time series forecast using a simple FFN
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.17 – 使用简单FFN的时间序列预测
- en: From the plot in *Figure 12**.17*, we see that our forecasted values map closely
    to the ground truth on the validation set, less the noisy spikes. Our FFN has
    demonstrated notable achievements in this experiment. Compared to the traditional
    statistical methods, our model exhibits a significant improvement in performance.
    You could tune the hyperparameters as well as implement callbacks to improve performance.
    However, our job is done here.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 从*图12.17*中的图表来看，我们可以看到我们的预测值与验证集上的真实值高度吻合，只有少量噪声波动。我们的FFN在这次实验中表现出了显著的成就。与传统的统计方法相比，我们的模型在性能上有了显著的提升。你可以调整超参数并实现回调来提高性能。但我们的工作在这里已经完成。
- en: Let’s meet in the final chapter, where we will be predicting app stock prices.
    See you there.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在最后一章见面，那时我们将预测应用股票价格。到时候见。
- en: Summary
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the concept of time series, examined the core characteristics
    and types of time series, and looked at some well-known applications of time series
    in machine learning. We also covered concepts such as trailing and centered windows
    and examined how to prepare time series for modeling with neural networks with
    the aid of utilities from TensorFlow. In our case study, we applied both statistical
    and deep learning techniques in order to build a sales forecasting model for a
    fictional company.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了时间序列的概念，研究了时间序列的核心特征和类型，并了解了时间序列在机器学习中的一些著名应用。我们还介绍了如滞后窗口和居中窗口等概念，并研究了如何借助TensorFlow的工具准备时间序列数据，以便用于神经网络建模。在我们的案例研究中，我们结合统计学方法和深度学习技术，为一家虚拟公司构建了一个销售预测模型。
- en: In the next chapter, we will extend our modeling using more complex architectures
    such as RNNs, CNNs, and CNN-LSTM architecture in forecasting time series data.
    Also, we will explore concepts such as learning rate scheduler and Lambda layers.
    To conclude the final chapter of this book, we will build a forecasting model
    for Apple’s closing stock price.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用更复杂的架构，如RNN、CNN和CNN-LSTM架构，来扩展我们的建模，进行时间序列数据预测。同时，我们还将探索学习率调度器和Lambda层等概念。为了结束本书的最后一章，我们将构建一个苹果公司收盘股票价格的预测模型。
- en: Questions
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Apply the principle of naïve forecasting to the “*Air Passenger*” dataset using
    the exercise notebook provided.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用提供的练习笔记本，将天真预测原理应用于“*航空乘客*”数据集。
- en: Implement the moving average technique on the same dataset and evaluate its
    performance by calculating the MAE and MSE values.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一数据集上实现移动平均技术，并通过计算MAE和MSE值来评估其性能。
- en: Next, introduce the method of differencing to your moving average model. Again,
    assess the accuracy of your forecast by determining the MAE and MSE values.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将差分方法引入到你的移动平均模型中。再次，通过确定MAE和MSE值来评估你的预测准确性。
- en: With the sample temperature dataset at hand, demonstrate how to create meaningful
    features and labels from this data.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手头有样本温度数据集，演示如何从这些数据中创建有意义的特征和标签。
- en: Lastly, experiment with the simple FFN model on the dataset and observe its
    performance.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在数据集上尝试简单的FFN模型，并观察其性能。
