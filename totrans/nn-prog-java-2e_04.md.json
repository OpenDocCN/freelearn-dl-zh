["```py\npublic class CompetitiveLayer extends OutputLayer {\n    public Neuron winnerNeuron;\n    public int[] winnerIndex;\n//…\n}\n```", "```py\n@Override\npublic void calc(){\n  if(input!=null && neuron!=null){\n    double[] result = new double[numberOfNeuronsInLayer];\n    for(int i=0;i<numberOfNeuronsInLayer;i++){\n      neuron.get(i).setInputs(this.input);\n     //perform the normal calculation\n      neuron.get(i).calc();\n      //calculate the distance and store in a vector\n      result[i]=getWeightDistance(i);\n      //sets all outputs to zero\n      try{\n        output.set(i,0.0);\n      }\n      catch(IndexOutOfBoundsException iobe){\n        output.add(0.0);\n      }\n    }\n    //determine the index and the neuron that was the winner\n    winnerIndex[0]=ArrayOperations.indexmin(result);\n    winnerNeuron=neuron.get(winnerIndex[0]);\n    // sets the output of this particular neuron to 1.0\n    output.set(winnerIndex[0], 1.0);\n  }\n}\n```", "```py\npublic double getWeightDistance(int neuron){\n  double[] inputs = this.getInputs();\n  double[] weights = this.getNeuronWeights(neuron);\n  int n=this.numberOfInputs;\n  double result=0.0;\n  switch(distanceCalculation){\n    case EUCLIDIAN:\n    //for simplicity, let's consider only the euclidian distance\n    default:\n      for(int i=0;i<n;i++){\n        result+=Math.pow(inputs[i]-weights[i],2);\n      }\n      result=Math.sqrt(result);\n  }\n  return result;\n}\n```", "```py\npublic enum MapDimension {ZERO,ONE_DIMENSION,TWO_DIMENSION};\n```", "```py\npublic Kohonen(int numberofinputs, int numberofoutputs, WeightInitialization _weightInitialization, int dim){\n  weightInitialization=_weightInitialization;\n  activeBias=false;\n  numberOfHiddenLayers=0; //no hidden layers\n//…\n  numberOfInputs=numberofinputs;\n  numberOfOutputs=numberofoutputs;\n  input=new ArrayList<>(numberofinputs);\n  inputLayer=new InputLayer(this,numberofinputs);\n// the competitive layer will be defined according to the dimension passed in the argument dim\n  outputLayer=new CompetitiveLayer(this,numberofoutputs, numberofinputs,dim);\n  inputLayer.setNextLayer(outputLayer);\n  setNeuralNetMode(NeuralNetMode.RUN);       \n  deactivateBias();\n}\n```", "```py\nint numberOfInputs=2;\nint numberOfNeurons=10;\nKohonen kn0 = new Kohonen(numberOfInputs,numberOfNeurons,new UniformInitialization(-1.0,1.0),0);\n```", "```py\nKohonen kn1 = new Kohonen(numberOfInputs,numberOfNeurons,new UniformInitialization(-1.0,1.0),1);\n```", "```py\npublic class CompetitiveLayer2D extends CompetitiveLayer {\n\n    protected int sizeMapX; // neurons in dimension X\n    protected int sizeMapY; // neurons in dimension Y\n\n    protected int[] winner2DIndex;// position of the neuron in grid\n\n    public CompetitiveLayer2D(NeuralNet _neuralNet,int numberOfNeuronsX,int numberOfNeuronsY,int numberOfInputs){\n        super(_neuralNet,numberOfNeuronsX*numberOfNeuronsY,\nnumberOfInputs);\n        this.dimension=Kohonen.MapDimension.TWO_DIMENSION;\n        this.winnerIndex=new int[1];\n        this.winner2DIndex=new int[2];\n        this.coordNeuron=new int[numberOfNeuronsX*numberOfNeuronsY][2];\n        this.sizeMapX=numberOfNeuronsX;\n        this.sizeMapY=numberOfNeuronsY;\n        //each neuron is assigned a coordinate in the grid\n        for(int i=0;i<numberOfNeuronsY;i++){\n            for(int j=0;j<numberOfNeuronsX;j++){\n                coordNeuron[i*numberOfNeuronsX+j][0]=i;\n                coordNeuron[i*numberOfNeuronsX+j][1]=j;\n            }\n        }\n    }\n```", "```py\npublic double[] getNeuronWeights(int x, int y){\n  double[] nweights = neuron.get(x*sizeMapX+y).getWeights();\n  double[] result = new double[nweights.length-1];\n  for(int i=0;i<result.length;i++){\n    result[i]=nweights[i];\n  }\n  return result;\n}\n\npublic double[][] getNeuronWeightsColumnGrid(int y){\n  double[][] result = new double[sizeMapY][numberOfInputs];\n  for(int i=0;i<sizeMapY;i++){\n    result[i]=getNeuronWeights(i,y);\n  }\n  return result;\n}\n\npublic double[][] getNeuronWeightsRowGrid(int x){\n  double[][] result = new double[sizeMapX][numberOfInputs];\n  for(int i=0;i<sizeMapX;i++){\n    result[i]=getNeuronWeights(x,i);\n  }\n  return result;\n}\n```", "```py\npublic double neighborhood(int u, int v, int s,int t){\n  double result;\n  switch(dimension){\ncase ZERO:\n  if(u==v) result=1.0;\n  else result=0.0;\n  break;\ncase ONE_DIMENSION:\ndefault:\n  double exponent=-(neuronDistance(u,v)\n/neighborhoodRadius(s,t));\n  result=Math.exp(exponent);\n  }\n  return result;\n}\n```", "```py\n@Override\npublic double neighborhood(int u, int v, int s,int t){\n  double result;\n  double exponent=-(neuronDistance(u,v)\n/neighborhoodRadius(s,t));\n  result=Math.exp(exponent);\n  return result;\n}\n```", "```py\npublic double neuronDistance(int u,int v){\n  return Math.abs(coordNeuron[u][0]-coordNeuron[v][0]);\n}\n```", "```py\n@Override\npublic double neuronDistance(int u,int v){\n  double distance=\nMath.pow(coordNeuron[u][0]\n-coordNeuron[v][0],2);\n  distance+=\nMath.pow(coordNeuron[u][1]-coordNeuron[v][1],2);\n  return Math.sqrt(distance);\n}\n```", "```py\npublic double neighborhoodRadius(int s,int t){\n  return this.initialRadius*Math.exp(-((double)s/(double)t));\n}\n```", "```py\npublic class CompetitiveLearning extends LearningAlgorithm {\n    // indicates the index of the current record of the training dataset  \n    private int currentRecord=0;\n    //stores the new weights until they will be applied\n    private ArrayList<ArrayList<Double>> newWeights;\n    //saves the current weights for update\n    private ArrayList<ArrayList<Double>> currWeights;\n    // initial learning rate\n    private double initialLearningRate = 0.3;\n    //default reference epoch\n    private int referenceEpoch = 30;\n    //saves the index of winner neurons for each training record\n    private int[] indexWinnerNeuronTrain;\n//…\n}\n```", "```py\npublic double getLearningRate(int epoch){\n  double exponent=(double)(epoch)/(double)(referenceEpoch);\n  return initialLearningRate*Math.exp(-exponent);\n}\n```", "```py\n@Override\npublic double calcNewWeight(int layer,int input,int neuron)\n            throws NeuralException{\n//…\n  Double deltaWeight=getLearningRate(epoch);\n  double xi=neuralNet.getInput(input);\n  double wi=neuralNet.getOutputLayer().getWeight(input, neuron);\n  int wn = indexWinnerNeuronTrain[currentRecord];\n  CompetitiveLayer cl = ((CompetitiveLayer)(((Kohonen)(neuralNet))\n                   .getOutputLayer()));\n  switch(learningMode){\n    case BATCH:\n    case ONLINE: //The same rule for batch and online modes\n      deltaWeight*=cl.neighborhood(wn, neuron, epoch, referenceEpoch) *(xi-wi);\n      break;\n  }\n  return deltaWeight;\n}\n```", "```py\n@Override\npublic void train() throws NeuralException{\n//…\n  epoch=0;\n  int k=0;\n  forward();\n//…\n  currentRecord=0;\n  forward(currentRecord);\n  while(!stopCriteria()){\n    // first it calculates the new weights for each neuron and input\n    for(int j=0;j<neuralNet.getNumberOfOutputs();j++){\n      for(int i=0;i<neuralNet.getNumberOfInputs();i++){\n        double newWeight=newWeights.get(j).get(i);\n        newWeights.get(j).set(i,newWeight+calcNewWeight(0,i,j));\n      }\n    }   \n    //the weights are promptly updated in the online mode\n    switch(learningMode){\n      case BATCH:\n        break;\n      case ONLINE:\n      default:\n        applyNewWeights();\n    }\n    currentRecord=++k;\n    if(k>=trainingDataSet.numberOfRecords){\n      //for the batch mode, the new weights are applied once an epoch\n      if(learningMode==LearningAlgorithm.LearningMode.BATCH){\n        applyNewWeights();\n      }\n      k=0;\n      currentRecord=0;\n      epoch++;\n      forward(k);\n//…\n    }\n  }\n}\n```", "```py\npublic class Chart {\n  //title of the chart\n  private String chartTitle;\n  //datasets to be rendered in the chart\n  private ArrayList<XYDataset> dataset = new ArrayList<XYDataset>();\n  //the chart object\n  private JFreeChart jfChart;\n  //colors of each dataseries\n  private ArrayList<Paint> seriesColor = new ArrayList<>();\n  //types of series (dots or lines for now)    \n  public enum SeriesType {DOTS,LINES};\n  //collections of types for each series\n  public ArrayList<SeriesType> seriesTypes = new ArrayList<SeriesType>();\n\n//…\n}\n```", "```py\nint numberOfPoints=10;\n\ndouble[][] dataSet = {\n{1.0, 1.0},{2.0,2.0}, {3.0,4.0}, {4+.0, 8.0},{5.0,16.0}, {6.0,32.0},\n{7.0,64.0},{8.0,128.0}};\n\nString[] seriesNames = {\"Line Plot\"};\nPaint[] seriesColor = {Color.BLACK};\n\nChart chart = new Chart(\"Line Plot\", dataSet, seriesNames, 0, seriesColor, Chart.SeriesType.LINE);\n\nChartFrame frame = new ChartFrame(\"Line Plot\", chart.linePlot(\"X Axis\", \"Y Axis\"));\n\nframe.pack();\nframe.setVisibile(true);\n```", "```py\nint numberOfInputs=2;\nint numberOfPoints=100;\n\ndouble[][] rndDataSet =\nRandomNumberGenerator\n.GenerateMatrixBetween\n(numberOfPoints\n, numberOfInputs, -10.0, 10.0);\nString[] seriesNames = {\"Scatter Plot\"};\nPaint[] seriesColor = {Color.WHITE};\n\nChart chart = new Chart(\"Scatter Plot\", rndDataSet, seriesNames, 0, seriesColor, Chart.SeriesType.DOTS);\n\nChartFrame frame = new ChartFrame(\"Scatter Plot\", chart.scatterPlot(\"X Axis\", \"Y Axis\"));\n\nframe.pack();\n```", "```py\nCompetitiveLayer cl = ((CompetitiveLayer)(neuralNet.getOutputLayer()));\ndouble[][] neuronsWeights = cl.getWeights();\n```", "```py\nprotected ChartFrame plot2DData;\n\npublic boolean show2DData=false;\n\npublic void showPlot2DData(){\n  double[][] data= ArrayOperations. arrayListToDoubleMatrix( trainingDataSet.inputData.data);\n  String[] seriesNames = {\"Training Data\"};\n  Paint[] seriesColor = {Color.WHITE};\n\n  Chart chart = new Chart(\"Training epoch n°\"+String.valueOf(epoch)+\" \",data,seriesNames,0,seriesColor,Chart.SeriesType.DOTS);\n  if(plot2DData ==null){\n    plot2DData = new ChartFrame(\"Training\",chart.scatterPlot(\"X\",\"Y\"));\n  }\n\n  Paint[] newColor={Color.BLUE};\n  String[] neuronsNames={\"\"};\n  CompetitiveLayer cl = ((CompetitiveLayer)(neuralNet.getOutputLayer()));\n  double[][] neuronsWeights = cl.getWeights();\n  switch(cl.dimension){\n    case TWO_DIMENSION:\n      ArrayList<double[][]> gridWeights = ((CompetitiveLayer2D)(cl)). getGridWeights();\n      for(int i=0;i<gridWeights.size();i++){\n        chart.addSeries(gridWeights.get(i),neuronsNames, 0,newColor, Chart.SeriesType.LINES);\n      }\n      break;\n    case ONE_DIMENSION:\n      neuronsNames[0]=\"Neurons Weights\";\n      chart.addSeries(neuronsWeights, neuronsNames, 0, newColor, Chart.SeriesType.LINES);\n      break;\n    case ZERO:\n      neuronsNames[0]=\"Neurons Weights\";\n    default:\n      chart.addSeries(neuronsWeights, neuronsNames, 0,newColor, Chart.SeriesType.DOTS);\n  }\n  plot2DData.getChartPanel().setChart(chart.scatterPlot(\"X\", \"Y\"));\n}\n```", "```py\nif(show2DData){\n  showPlot2DData();\n  if(sleep!=-1)\n    try{ Thread.sleep(sleep); }\n    catch(Exception e){}\n}\n```", "```py\nRandomNumberGenerator.seed=0;\nint numberOfInputs=2;\nint numberOfNeurons=10;\nint numberOfPoints=100;\n\n// create a random dataset between -10.0 and 10.0   \ndouble[][] rndDataSet = RandomNumberGenerator. GenerateMatrixBetween(numberOfPoints, numberOfInputs, -10.0, 10.0);\n\n// create the Kohonen with uniform initialization of weights        \nKohonen kn0 = new Kohonen(numberOfInputs,numberOfNeurons,new UniformInitialization(-1.0,1.0),0);\n\n//add the dataset to the neural dataset\nNeuralDataSet neuralDataSet = new NeuralDataSet(rndDataSet,2);\n\n//create an instance of competitive learning in the online mode\nCompetitiveLearning complrn=new CompetitiveLearning(kn0,neuralDataSet, LearningAlgorithm.LearningMode.ONLINE);\n\n//sets the flag to show the plot\ncomplrn.show2DData=true;\n\ntry{\n// give names and colors for the dataset\n  String[] seriesNames = {\"Training Data\"};\n  Paint[] seriesColor = {Color.WHITE};\n  //this instance will create the plot with the random series\n  Chart chart = new Chart(\"Training\",rndDataSet,seriesNames,0, seriesColor);\n  ChartFrame frame = new ChartFrame(\"Training\", chart.scatterPlot(\"X\", \"Y\"));\n  frame.pack();\n  frame.setVisible(true);\n\n  // we pass the reference of the frame to the complrn object\n  complrn.setPlot2DFrame(frame);\n  // show the first epoch\n  complrn.showPlot2DData();\n//wait for the user to hit an enter\n  System.in.read();\n//training begins, and for each epoch a new plot will be shown\n  complrn.train();\n}\ncatch(Exception ne){\n\n}\n```", "```py\nint numberOfPoints=1000;\nint numberOfInputs=2;\nint numberOfNeurons=20;\ndouble[][] rndDataSet;\n\nfor (int i=0;i<numberOfPoints;i++){\n  rndDataSet[i][0]=i;            \n  rndDataSet[i][0]+=RandomNumberGenerator.GenerateNext();\n  rndDataSet[i][1]=Math.cos(i/100.0)*1000;            \n  rndDataSet[i][1]+=RandomNumberGenerator.GenerateNext()*400;\n}\nKohonen kn1 = new Kohonen(numberOfInputs,numberOfNeurons,new UniformInitialization(0.0,1000.0),1);\n```", "```py\nint numberOfPoints=1000;\nfor (int i=0;i<numberOfPoints;i++){\n  rndDataSet[i][0]*=Math.sin(i);            \n  rndDataSet[i][0]+=RandomNumberGenerator.GenerateNext()*50;\n  rndDataSet[i][1]*=Math.cos(i);            \n  rndDataSet[i][1]+=RandomNumberGenerator.GenerateNext()*50;\n}\n```", "```py\nint numberOfInputs=2;\nint neuronsGridX=12;\nint neuronsGridY=12;\nKohonen kn2 = new Kohonen(numberOfInputs,neuronsGridX,neuronsGridY,new GaussianInitialization(500.0,20.0));\n```"]