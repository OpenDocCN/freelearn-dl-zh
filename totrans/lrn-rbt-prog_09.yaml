- en: '*Chapter 7*: Drive and Turn – Moving Motors with Python'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will take the robot we started building in the last chapter,
    connect the motors to the Raspberry Pi, and build the Python code to make them
    move. We will cover programming techniques to create a layer between the physical
    robot and its behavior code, to reduce the impact of hardware changes. Our code
    and build will get the robot moving! We finish by programming the robot to drive
    a small set path. The robot code layer will serve as a foundation for all our
    robot behaviors, and the set path will demonstrate how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing code to test your motors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Steering a robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a `Robot` object—code for our experiments to talk to the robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a script to follow a predetermined path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete the experiments in this chapter, you will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A computer with access to the internet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chassis built in the [*Chapter 6*](B15660_06_Final_ASB_ePub.xhtml#_idTextAnchor096),
    *Building Robot Basics – Wheels, Power, and Wiring*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The motor controller bought in [*Chapter 6*](B15660_06_Final_ASB_ePub.xhtml#_idTextAnchor096),
    *Building Robot Basics – Wheels, Power, and Wiring*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 2-meter by 2-meter flat space for the robot to drive on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Be prepared to stop your robot from driving over the edges if you use a table!
    It's best to use the floor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action: [https://bit.ly/39sHxWL](https://bit.ly/39sHxWL)'
  prefs: []
  type: TYPE_NORMAL
- en: Writing code to test your motors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get stuck in and do fancy things with the motors, we need to get them
    set up and test them. This way, we can make sure they work and iron out any problems.
  prefs: []
  type: TYPE_NORMAL
- en: We need to download the library to work with the motor board we have chosen.
    Many robot parts, apart from the simplest ones, have an interface library to control
    the motors and other devices on the board. It's time to log in to your Pi using
    PuTTY again.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We download this code from a project on GitHub using Git on the Raspberry Pi.
    So, we need to install Git on the Pi; we also need I2C (`i2c-tools` and `python3-smbus`)
    and `pip` to install things into Python. Type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the library for the motor board, `Raspi_MotorHAT`, we use Git and download
    it from GitHub, installing it for use in any of your scripts with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We now have the libraries prepared for starting the robot. Documentation for
    the `Raspi_MotorHAT` library is sparse but is at [https://github.com/orionrobots/Raspi_MotorHAT](https://github.com/orionrobots/Raspi_MotorHAT),
    along with examples of using it.
  prefs: []
  type: TYPE_NORMAL
- en: Test – finding the Motor HAT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Raspberry Pi uses I2C to connect to this Motor HAT. `raspi-config` again.
    We also enable the **Serial Peripheral Interface** (**SPI**) while we are here.
    We may need this to connect other boards and sensors. Type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we use interfacing settings on this. *Figure 7.1* shows how, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Using raspi-config to enable SPI and I2C'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_07_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Using raspi-config to enable SPI and I2C
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the screenshots in *Figure 7.1* and perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, select **Interfacing Options**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, select **I2C**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Pi asks if you want this interface to be enabled. Select **<Yes>**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You are then taken back to the initial screen and need to navigate again to
    the **Interfacing Options** screen. From there, select **SPI** and **<Yes>** again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A confirmation screen tells you now that SPI is enabled. Select **<Ok>**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, press *Esc* twice to finish `raspi-config`. It asks if you want to
    reboot. Select `sudo reboot` to reboot it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With I2C, we need a way to choose which device we are talking with. Just as
    with houses along a road, an address allows us to say which one we specifically
    want.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should check that the Raspberry Pi can see the Motor HAT with `sudo i2cdetect
    -y 1` by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This scans the I2C bus `1` for devices attached to our Raspberry Pi. It shows
    numbers at the addresses if something is found. The device found at addresses
    `6f` and `70` is our motor controller. If you cannot see this, power down the
    Raspberry Pi and carefully check that the Motor HAT has been plugged in, then
    try again.
  prefs: []
  type: TYPE_NORMAL
- en: The addresses are hexadecimal, where each digit counts to 16, using the digits
    `0`-`9`, then letters `A`-`F` instead of counting only 10\. When used in code,
    these get a `0x` prefix. This is a *zero* and then a lowercase x.
  prefs: []
  type: TYPE_NORMAL
- en: We have enabled the I2C (and SPI) bus, and we then used the `i2cdetect` tool
    to find our motor device. This confirms first that it is connected and responding,
    and secondly that we have the right address—`0x6f`—for it. We can now start to
    send commands to it.
  prefs: []
  type: TYPE_NORMAL
- en: Test – demonstrating that the motors move
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need a test file to demonstrate that the motors work. Carry out the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following file, called `test_motors.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Upload this file to your Raspberry Pi using the methods found in [*Chapter 5*](B15660_05_Final_ASB_ePub.xhtml#_idTextAnchor081),
    *Backing Up the Code with Git and SD Card Copies*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Move your robot from your desk and down to the floor for this next step, as
    when it moves, it might not go in the direction you expect!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To run this code, through PuTTY on the Pi, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your robot should now drive roughly forward. It may move slightly to the side,
    but it should not be turning or going backward, and both motors should be moving.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you see any problems, try this troubleshooting chart and go back:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table7.1(new).jpg)'
  prefs: []
  type: TYPE_IMG
- en: By this point, you should have a robot that will drive forward, have seen it
    move, and dealt with the preceding troubleshooting issues.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how the code works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, our motors are moving and the robot drives using the `test_motors.py` code.
    But how does our motor test code really work? In this section, let's take a closer
    look and understand this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first few lines of code here are imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Imports are how Python code *pulls in* other libraries of code to use them.
    The `Raspi_MotorHAT` library is the one we installed for interacting with our
    motors. The `time` library allows us to work with time; in this case, we use it
    for a delay between starting and stopping motors. The `atexit` library allows
    us to run code when this file exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following lines, we connect the library to the Motor HAT and the two
    motors we have connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first line here makes a `Raspi_MotorHAT` object with the I2C address `0x6f`
    passed in as `addr`, which we saw in the scan. We call the returned object `mh`
    as an abbreviation for the connected `Raspi_MotorHAT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then create shortcuts to access the motors: `lm` for the left motor and
    `rm` for the right motor. We get these motor controls from the `mh` object, using
    the motor number shown on the board. Motor 1 is left, and motor 2 is right.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now define a function, `turn_off_motors`, which runs `Raspi_MotorHAT.RELEASE`
    on each motor on this board—an instruction to make the motors stop, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We pass that into `atexit.register(turn_off_motors)`, a command that runs when
    this file finishes—when Python exits. `atexit` runs even when there are errors.
    Without this, the code could break in some interesting way, and the robot keeps
    driving. Robots without this kind of safeguard have a habit of driving off tables
    and into walls. If they carry on trying to drive when their motors are stuck,
    it can damage the motors, motor controllers, and batteries, so it's better to
    stop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The speed of the motors for this controller/library ranges from `0` to `255`.
    Our code sets the speed of each motor to just above half speed and then runs the
    `Raspi_MotorHAT.FORWARD` mode, which makes each motor drive forward, as illustrated
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we ask the code to wait for 1 second, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The sleep allows the motors to run in their forward-drive mode for 1 second.
    The program then exits. Since we told it to stop motors when the code exits, the
    motors stop.
  prefs: []
  type: TYPE_NORMAL
- en: We've now written and understood the code to test the motors. You've also seen
    it running. This confirms that you have a viable robot, and you have also started
    using Python imports. You've learned the `atexit` trick to turn things off and
    about using a timer so that the robot has some time to run before exiting. Now,
    we look at how we can steer the robot.
  prefs: []
  type: TYPE_NORMAL
- en: Steering a robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we've made a robot drive forward. But how do we steer it? How does it turn
    left or right? In order to understand this, we need to first learn about a few
    significant forms of steering that exist. Let's take a look at some, settle on
    the one our robot uses, and write some test code to demonstrate it.
  prefs: []
  type: TYPE_NORMAL
- en: Types of steering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common techniques for steering a wheeled vehicle (including a robot)
    fall into two major categories—steerable wheels and fixed wheels, as discussed
    in the following subsections. Each of them comes with a couple of slightly unusual
    variants.
  prefs: []
  type: TYPE_NORMAL
- en: Steerable wheels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In movable wheel designs, one or more wheels in a robot face in a different
    direction from the others. When the robot drives, the differently positioned wheel
    makes the robot turn. There are two common styles of movable wheel steering on
    a robot, as shown here in *Figure 7.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Steerable wheel types'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_07_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – Steerable wheel types
  prefs: []
  type: TYPE_NORMAL
- en: 'The green arrows show the direction of movement. The white arrows show changes
    to the shape of the robot and the angle of the wheels. Going through *Figure 7.2*,
    we can note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Cars typically use **rack and pinion steering**. When straight, the car goes
    forward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the lower bar is moved, shown by the white arrows, the car turns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The other common type is **wagon-style steering**, used in homemade racing karts.
    When straight, it goes forward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By turning the front bar, you can steer the vehicle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are also other variants besides the ones we discussed previously. They
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Robots with the ability to independently reorient each wheel and drive sideways
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ackerman steering, where the amount each wheel rotates is different
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rear steering, where a front set of wheels and a rear set of wheels steer—used
    in long vehicles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A good example of wagon-style steering is the Unotron robot, shown here in
    *Figure 7.3*. This was built by my son from the Unotron chassis by 4tronix, with
    an Arduino Nano controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Wagon-style steering Unotron robot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_07_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – Wagon-style steering Unotron robot
  prefs: []
  type: TYPE_NORMAL
- en: In the Unotron design, there is a single motor-driven wheel at the back (under
    the motor controller). A servo motor turns the whole front plate, steering the
    two front wheels.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantages of this type of steering are related to space, weight, and
    complexity. A chassis set up for movable wheel steering requires more moving parts
    and space to house them. Unotron is as simple as it gets. There is more complexity
    in other designs, which can lead to required maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: The distance needed to make a turn (known as the turning circle) or for robots
    with steerable wheel systems is longer, as these must drive forward/backward to
    steer.
  prefs: []
  type: TYPE_NORMAL
- en: You require one large motor for the fixed axle, as you cannot distribute power
    across two motors, or you need complex mechanisms to balance the input. If the
    mechanism does not center after steering, then the robot veers.
  prefs: []
  type: TYPE_NORMAL
- en: Fixed wheels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Fixed-wheel steering is used frequently in robots, whereby the wheels'' axes
    are fixed in relation to the chassis. The relative speed of each wheel or set
    of wheels sets the direction of the robot. That is, the wheels do not turn from
    side to side; however, by one side going faster than the other, the robot can
    make turns. A typical use of this is known as skid steering, which is illustrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Fixed-wheel steering or skid steering'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_07_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – Fixed-wheel steering or skid steering
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7.4* shows this in action. The white arrows show the relative speed
    of the motors. The green arrows show the direction of the robot.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding figure, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The motors are going at the same speed, so the robot is driving straight forward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The motors on the right are going fast; the motors on the left are going slow.
    This robot is driving forward and left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This has several advantages. If you intend to use tank tracks, you need this
    type of drive system. It is mechanically simple in that a drive motor per wheel
    is all that is needed to make turns. Skid steering allows a robot to turn on the
    spot, doing a full 360 degrees in a turning circle the width of the widest/longest
    part of the robot.
  prefs: []
  type: TYPE_NORMAL
- en: There are some disadvantages to using this. When turning, a skid-steer system
    may drag wheels sideways, causing friction. Also, any minor differences in the
    motors, their gearing, or the controller output can result in a veer.
  prefs: []
  type: TYPE_NORMAL
- en: Other steering systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The controller we are using on our robot allows us to control four motor channels.
    A builder can use four motors for special wheel types, known as Mecanum wheels.
    These wheels allow skid-steering style motions along with crabbing motions so
    that a robot can drive left or right without turning. Technically, this is still
    fixed-wheel steering. *Figure 7.5* here shows a base with Mecanum wheels:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Mecanum wheels on the Uranus Pod by Gwpcmu [CC BY 3.0'
  prefs: []
  type: TYPE_NORMAL
- en: (https://creativecommons.org/licenses/by/3.0)]
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_07_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – Mecanum wheels on the Uranus Pod by Gwpcmu [CC BY 3.0 (https://creativecommons.org/licenses/by/3.0)]
  prefs: []
  type: TYPE_NORMAL
- en: These are amazingly flexible but mechanically complex, high maintenance, heavy,
    and a bit pricier than normal wheels. They are fun, however.
  prefs: []
  type: TYPE_NORMAL
- en: Steering the robot we are building
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Based on the three-wheel chassis we have chosen, with one castor wheel and then
    a driven wheel on each side, independently controlled, we are using skid steering.
    By varying the speed and direction of these wheels, we steer our robot. We can
    also spin 360 degrees with it. The castor wheel negates the problem mentioned
    with the drag seen on four- and six-wheel skid-steer robots.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make the robot spin on the spot with one change to the previous code.
    Making one motor go back while the other goes forward spins the robot. Let''s
    see how to do this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the following lines in `test_motors.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify this as follows so that one motor goes `BACKWARD`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run this on the Pi with `python3 turn_motors.py`, and your robot now spins to
    the right. Swap them so left (`lm`) is `BACKWARD`, and right (`rm`) is `FORWARD`,
    and it spins the other way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What about less aggressive turns? In the previous code, before the direction
    lines, we also set the speed of each motor, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: lm.setSpeed(100)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rm.setSpeed(150)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: lm.run(Raspi_MotorHAT.FORWARD)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rm.run(Raspi_MotorHAT.FORWARD)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You've now seen a few ways to steer robots. Based on the design our robot has,
    you've then put one of them into practice, making a robot spin on the spot, and
    also drive forward and turn too. In the next section, we'll turn this into a layer
    for different behaviors to use the robot.
  prefs: []
  type: TYPE_NORMAL
- en: Making a Robot object – code for our experiments to talk to the robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have seen how to move and turn our robot, we come on to a layer of software
    to group up some of the hardware functions and isolate them from **behaviors**.
    By behaviors, I mean code to make a robot behave a certain way, for example following
    a line or avoiding walls. Why would we want that isolation?
  prefs: []
  type: TYPE_NORMAL
- en: When we chose our motor controller, we made many trade-offs to find what works
    for our project. Motor controllers can change when the considerations change or
    when we simply want to build our next robot. Although controlling the speed and
    direction of two motors is the same kind of operation, each controller does it
    slightly differently. Creating a layer in front of a controller lets us use the
    same commands for it, even if it changes. This layer acts as a façade or interface
    to robot functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Each controller has quirks. With this one, we set a run mode and speed. Many
    controllers use 0 to mean stop, but this one uses a `RELEASE` mode, which is slightly
    different from speed 0, which holds the motors. Controllers often use negative
    numbers to mean go backward; this one has a `BACKWARD` mode. The speed values
    on this controller go from 0-255\. Some go from -128-128, or 0-10\. What we can
    do is to create an object with an interface to hide quirks specific to this controller.
  prefs: []
  type: TYPE_NORMAL
- en: Why make this object?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You design an interface to give you a way to interact with some other code.
    It can simplify, or make more consistent, different underlying systems to make
    them behave the same way, as with all the types of motor controller mentioned.
    It also provides a way to cleanly separate parts of code into layers. Different
    layers mean that you can change one part of some code without it making considerable
    changes in another, as illustrated in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Software layers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_07_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – Software layers
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 7.6*, panel 1 shows a block of code that has different systems mixed.
    It's hard to change; adding a new behavior or swapping the motor controller in
    this code would be quite tricky. It's good to avoid mixing responsibilities in
    this way.
  prefs: []
  type: TYPE_NORMAL
- en: The code represented by panel 2 shows two separate systems interacting. They
    have a relationship where the *path-following behavior* is in control of the *robot
    hardware setup and control* code.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the book we write many behaviors, and we can reuse the hardware control
    library, perhaps extending it occasionally. After all, who wants to keep writing
    the same code? When you extend and make new behaviors, you can use this layer
    again too.
  prefs: []
  type: TYPE_NORMAL
- en: The robot hardware setup/control block in the second panel of *Figure 7.6* is
    our `Robot` object. It is an interface to hide the quirks of the *Full Function
    Stepper HAT* board.
  prefs: []
  type: TYPE_NORMAL
- en: This standard interface means we could make an object that looks the same from
    the outside on other robots, and our behaviors still work. Some serious robot
    builders use interfaces to swap real controllers for simulations of robots, to
    test complex behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: What do we put in the robot object?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An object is a building block to make interfaces in Python. Objects have methods—things
    we can call on it to perform tasks. Objects also have members, bits of data, or
    references to other objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next section builds code in the `Robot` object to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up the Motor HAT and store its motors as members: `left_motor` and `right_motor`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deal with the `exit` state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop motors with a `stop_motors` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us use percentages to mean speeds—values of 0 to 100\. We map this to what
    the controller wants.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modes are particular to this controller. Our interface uses negative values
    to mean going backward.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At a later stage, the `Robot` object can act as a gatekeeper to data buses that
    require code to hold exclusive locks on them and some of the hardware.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our interface (and therefore our object) does not contain behavior, other than
    the stopping-on-exit safeguard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We put it in a file named `robot.py`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This `class` has a `__init__` method, a special one that sets this layer up.
    The `__init__` method stores the output of the `getMotor` methods from the `Raspi_MotorHat`
    library in the `left_motor` and `right_motor` members. This method also registers
    a stop system. I have added some comments to state what the fragments of code
    do.
  prefs: []
  type: TYPE_NORMAL
- en: So far, our `Robot` object has set up our Motor HAT and has a way to stop the
    motors. The code is the same setup code we have seen before but is structured
    slightly differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test this in another file named `behavior_line.py`, as illustrated in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This starts by pulling in the `robot.py` file we just created with an import.
    It goes forward for 1 second and stops. Run with `python3 behavior_line.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We still have to set speeds specific to this board (not out of 100). Let''s
    fix that in `robot.py` (new code is in bold), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can now use `convert_speed`, to use speeds from 0 to 100\. This returns speeds
    from 0 to 255 for this Motor HAT. For other motor boards, this returns something
    else.
  prefs: []
  type: TYPE_NORMAL
- en: We multiply the speed by 255 and divide that by 100\. This formula is a way
    of turning a percentage into a fraction of 255\. We multiply first because we
    are doing integer (whole number) math, and dividing 80/100 with whole numbers
    gives 0, but dividing (80*255) by 100 returns 204\.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code is still unwieldy, though—to use it, we need the following in `behavior_line.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This still uses the `run` and `setSpeed` methods of the `Raspi_MotorHAT` library,
    which are specific to this control board. Other boards don't work the same way.
    We can also collect up the cumbersome conversion a little.
  prefs: []
  type: TYPE_NORMAL
- en: We start by modifying the `convert_speed` method. It can be convenient for robots
    to use negative values to mean the motor goes backward. We still need to scale
    the speed, but we need to determine the run mode too.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to do the following two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Determine if the speed is above, below, or equal to zero, and set the mode for
    the `run` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the sign from the speed for `setSpeed`, so it's always a positive value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default mode that we get at speed zero is `RELEASE` or stop. If the speed
    is above 0, we return the `FORWARD` mode, and if it's below 0, we return `BACKWARD`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a simple `if` statement to get the correct `mode`. Let''s replace
    the `convert_speed` method in the class to return the mode and positive value.
    I''ve used comments to show the two sections to this function. Modify this in
    `robot.py`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve added one more operation to our speed calculation: `abs(speed)`. This
    operation returns the absolute value, which removes the sign from a number. For
    example, -80 and 80 both come out as 80, which means there is always a positive
    output from the method.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add some methods to directly set the speed and direction of the left
    and right motors in the robot. These call `convert_speed` and use the mode and
    output speed from it to make calls to the `Raspi_MotorHAT` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then need to change our motor movement methods to use this speed conversion,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: So, for each motor, we get the mode and output speed from the passed-in speed,
    then call `setSpeed` and `run`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole of `robot.py` should now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Our simple behavior in `behavior_line.py` is now only a few lines, as can be
    seen in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This simplification means we can build on this code to create more behaviors.
    I have a common interface, and versions of the `Robot` object for my other robots.
    An exciting outcome is I can run this `behavior_lines.py` code on ArmBot (the
    robot seen at the end of [*Chapter 1*](B15660_01_Final_ASB_ePub.xhtml#_idTextAnchor019),
    *Introduction to Robotics*) or my other Raspberry Pi robots. They all go forward
    for 1 second at 80% of their motor speed.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a script to follow a predetermined path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, we now get to the first behavior that feels like a robot. Let''s make a
    quick sketch of a path for us to get our robot to follow. For an example, see
    *Figure 7.7* here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Path for our robot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15660_07_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 – Path for our robot
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 7.7*, I've drawn a path. The straight lines are for driving forward;
    the **1**s mean 1 second. We don't yet have a way to consider distance traveled,
    only time. We may be able to guess at times relative to distances, but this isn't
    very precise or repeatable. The gentle curves are a turn where we slow one motor
    down more than the other.
  prefs: []
  type: TYPE_NORMAL
- en: The final spiral means a victory spin on the spot when the path is complete—we
    can do this by putting one motor in reverse while the other drives forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write this code. First, we want the imports: `sleep` and `robot`. But
    before we do anything, let''s make some helper functions for this behavior. I
    called my file `behavior_path.py`, and the code is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The helpers use the same language we used to describe the behavior. We have
    `straight`, `turn_left`, `turn_right`, and `spin_left`. These are not in the `Robot`
    object because other behaviors may use more continuous behavior than this. I've
    called the `Robot` object `bot` now because one-letter variable names such as
    `r` become less easy to find, read, or reason about when there is more code.
  prefs: []
  type: TYPE_NORMAL
- en: 'These helpers each set the motor speeds, and then sleep for a determined number
    of seconds. We can then create the `Robot` object and sequence them by adding
    the following code to `behavior_path.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can upload this to the Raspberry Pi, and run it via PuTTY with the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if your robot is anything like mine, you saw it drive and make turns,
    but the turns have overshot in some way, and the robot may be veering to one side.
    We can fix the overshoot here by reducing the amount of time in the turn steps,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to tweak these values to get close to 90-degree turns. This tweaking
    takes patience: change them and upload them. Tweaking values in code is a crude
    form of calibration to match the quirks of our robot. If you move between surfaces
    (for example, from a wooden floor to a carpet), then the timings will change.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be able to account for some of the veering by tuning one motor to be
    slower in the `straight` function (adjust for your own robot''s veer), like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This code holds up for a while but may be hard to fine-tune. Why do we get this
    veer?
  prefs: []
  type: TYPE_NORMAL
- en: Motor speeds can vary, even those from the same manufacturer. Other causes of
    minor variations are wheel diameters, axle positioning, weight distribution, slippery
    or uneven surfaces, wiring resistance, and motor controller variations. This variation
    makes it unlikely that you'd get a perfectly straight line from a robot this way.
    Depending on which sensors we are using, this may or may not be a problem. To
    account for this problem, we introduce encoders/speed sensors in a later chapter
    and calibrate those sensors to get a more accurate version of a path behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Without sensors, a robot is not able to determine where it is or if it has bumped
    into anything. If the robot ran into a wall, you'd probably have to go and move
    it to where it had room to move.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've learned how to install the libraries for the motor board
    and demonstrate that our motors work. We then started building the first layer
    of code for our behaviors to use, while noting how we could make a layer like
    that for other robots. We saw our robot move in a path and tuned it, while finding
    out some of the shortcomings of using motors without any sensors.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now use this when starting any hardware project: get the motors/output
    devices tested first, then create a layer for a behavior to use them, such that
    if their hardware later changes, you only need to change the motor code.'
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapters, we start adding sensors and building behaviors using
    these sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try these further ideas to enhance your learning from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Sketch out another simple path and write code for the robot to follow it. For
    example, try to follow a figure-of-8 shape using your experience.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which methods would you add to the `Robot` object if you had an additional output
    to control, perhaps a single **light-emitting diode** (**LED**)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider how you would lay out a `Robot` object for a robot with kart-style
    steering. Which methods would it have? You don't need to write the code yet, but
    having an interface in mind is a good start. Hint—it probably has one motor speed
    for the drive and a motor position for the steering.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please refer to the following for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the style used for the `Robot` object, along with the
    use of similar interfaces and classes, I recommend *Learning Object-Oriented Programming*,
    *Gastón C. Hillar*, *Packt Publishing*. This book not only works through these
    concepts in Python but takes them more generally and shows how **object-oriented**
    (**OO**) concepts also apply to the C# and JavaScript languages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
