- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integrating spaCy with Third-Party Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll explore how to integrate spaCy with third-party libraries,
    focusing on building web applications and APIs for NLP tasks. We will start with
    **Streamlit** , a Python framework that simplifies the creation of web applications
    without needing extensive front-end knowledge. We’ll demonstrate how to create
    a simple **Named Entity Recognition** ( **NER** ) app using Streamlit and **spacy-streamlit**
    . Following this, we’ll dive into **FastAPI** , a modern framework for building
    APIs, known for its speed and use of Python type hints. We’ll learn how to create
    an API that extracts entities from text using a spaCy model, showcasing the ease
    with which you can build NLP-powered services.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building spaCy-powered Apps with Streamlit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building APIs for NLP models using FastAPI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the data and the code for this Chapter can be found at [https://github.com/PacktPublishing/Mastering-spaCy-Second-Edition](https://github.com/PacktPublishing/Mastering-spaCy-Second-Edition)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Building spaCy-powered Apps with Streamlit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As data scientists and NLP engineers, the main programming language we use in
    our day-to-day is Python. If you don’t have a background in front-end development
    and have ever tried to build a web application or had to deal with CSS, you know
    how hard and frustrating it can be to work developing applications to work in
    the browser. Streamlit is a framework in Python designed to help us create web
    applications in a simple and fast way using pure Python. It is built on top of
    the **Tornado** Python web server framework ( [https://www.tornadoweb.org/en/stable/index.html](https://www.tornadoweb.org/en/stable/index.html)
    ) and uses **React** in the frontend. Luckily, we don’t need to know how to use
    any of these technologies to create our web apps, since with Streamlit, we can
    create widgets on the page by simply declaring some Python variables. We can also
    smoothly deploy, manage, and share Streamlit Web Apps by using the *community
    cloud* feature ( [https://streamlit.io/cloud](https://streamlit.io/cloud) ). The
    deployment can be done in one click and is free.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will first learn the basics of Streamlit and then how to
    use the **spacy-streamlit** package to use spaCy visualizations as the building
    blocks of the web apps.
  prefs: []
  type: TYPE_NORMAL
- en: Building NLP apps with spacy-streamlit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start using Streamlit the first step is to install the library using **pip
    install streamlit** . We create the web applications using a Python script. The
    **streamlit run app.py** command runs a local server on the machine. To check
    whether everything is okay with the installation, let’s run the **streamlit hello**
    command. *Figure 11* *.1* shows this demo page in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Streamlit hello page](img/B22441_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Streamlit hello page
  prefs: []
  type: TYPE_NORMAL
- en: 'As we were talking about in the introduction section, creating widgets and
    visual components with Streamlit can be done by simply declaring a variable. We
    can also add interactivity to the apps using Streamlit input widgets. The main
    ones are **st.text_input** , **st.button** , and **st.slider** . The library has
    a large list of page elements. Here are some of the main ones and their descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**st.write** : This writes the content on the page and automatically detects
    the type of the content to present it properly. If you write **st.write(''hi friends'')**
    , it will display the text; if you provide a dataframe instead of a string, it
    will present the dataframe with the proper formatting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**st.title** : This will display the text in the title formatting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**st.markdown** : This will display the text formatted in Markdown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**st.dataframe** : This will display a dataframe as an interactive table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **spacy-streamlit** package provides tools for visualizing spaCy models
    and developing interactive apps. It features various components that you can integrate
    into your own Streamlit applications, including visualizers for syntactic dependencies,
    named entities, text classification, token attributes, and more. Let’s build an
    app to get a glimpse of how Streamlit and **spacy-streamlit** work together. First,
    you need to install the package with **pip install spacy-streamlit** . With the
    library installed, let’s go ahead and build an app to display the entities of
    the model we trained in [*Chapter 8*](B22441_08.xhtml#_idTextAnchor109) :'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import both packages, **Streamlit** and **spacy_streamlit** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s define a default text to the **st.text_input** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we define the path to the [*Chapter 8*](B22441_08.xhtml#_idTextAnchor109)
    final model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s add a title and the text input. The content of **text_input** will be
    saved on the **text** variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We still have some work to do, but first, let’s see what the app looks like
    with only this code. Save the code to an **app.py** script and run **streamlit
    run app.py** to serve it on our local machine. *Figure 11* *.2* shows what we
    have so far.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – The Streamlit app with the text_area component](img/B22441_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – The Streamlit app with the text_area component
  prefs: []
  type: TYPE_NORMAL
- en: 'When building apps with Streamlit, every time the user interacts with an input
    widget, the library *reruns the entire Python script from top to bottom* . Our
    app needs to load the model before processing the text, so this could mean that
    every time a user types another text in the **st.text_area** widget, they would
    have to wait for the model to load again. To handle this, Streamlit has the cache
    feature ( [https://docs.streamlit.io/get-started/fundamentals/advanced-concepts#caching](https://docs.streamlit.io/get-started/fundamentals/advanced-concepts#caching)
    ) and **spacy-streamlit** implements the **process_text()** method. It caches
    loaded models and creates **Doc** objects. Let’s use the method to process the
    text of our app, continuing the list we’ve started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **process_text ()** method expects the path to the model and the text that
    will be processed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, to display the entities, we will use the **visualize_ner()** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Figure 11* *.3* shows the final app.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – NER app built with Streamlit](img/B22441_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – NER app built with Streamlit
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to add a button so the users can type their own text and see the entities.
    Since Streamlit re-runs all the script code every time we interact with a widget,
    we cannot use the **st.button** widget. What we’ll do is use the **st.form** widget,
    which sends all widget values inside the form to Streamlit in a batch. We will
    use the **with** context manager to create the form. Let’s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will put all the elements that should be reloaded inside the form context
    manager. So, when the user presses the submit button, we will process the doc
    and display it using the visualizer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Figure 11* *.4* shows the app, now with the **Submit** button.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Streamlit app with form and Submit button](img/B22441_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Streamlit app with form and Submit button
  prefs: []
  type: TYPE_NORMAL
- en: 'The next list has the full code of the web app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We were able to build a beautiful NLP app with just some lines of code by using
    both the **streamlit** and **spacy-streamlit** libraries. Other **spacy-streamlit**
    visualizers are **visualize_parser()** , **visualize_spans()** , **visualize_textcat()**
    , **visualize_similarity()** , and **visualize_tokens()** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we need to build APIs for our NLP projects instead of interactive
    web applications. For this scenario, we can use another cool library: **FastAPI**
    . Let’s learn more about it in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Building APIs for NLP models using FastAPI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**FastAPI** is a Python web framework for building APIs. It’s built on top
    of another two Python libraries, **Starlette** and **Pydantic** , making it one
    of the fastest Python frameworks available. FastAPI is based on standard Python
    type hints. With type hinting, we can specify the expected type of a variable,
    function parameter, or return value. This feature helps us catch bugs earlier
    in the development process, so let’s learn how to use type hints before heading
    to FastAPI usage.'
  prefs: []
  type: TYPE_NORMAL
- en: Python type hinting 101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python is a dynamically typed language, meaning it performs the type checks
    of the variables at runtime. For example, if we run this code, it does not throw
    any errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This runs smoothly because the Python interpreter handles the transition of
    **string_or_int** from **String** to **int** . This can lead to bugs because of
    silent errors. **Type hinting** provides a way to specify the expected types in
    our code, so it reduces our chances of creating bugs. Let’s see an example of
    a simple function without it first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine this function is in a code base and you just import it to use in your
    code. There is no way to see what the writer of the function was expecting as
    the type of the **name** parameter and no information about the return type. To
    get this information, we need to read to check the code of the function. The situation
    changes if we use type hints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now with these type hints, your code editor can help you and show the types.
    *Figure 11* *.5* shows what happens in *Visual Studio Code* , for example.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Type hinting in Visual Studio Code](img/B22441_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Type hinting in Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI uses type hints to offer type checks, leading to fewer bugs and developer-induced
    errors. Now that we know what type hinting is, let’s create an API for our spaCy
    model using FastAPI.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an API for the spaCy model with FastAPI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two main HTTP methods we use to build APIs are **GET** and **POST** . **GET**
    is used when the request does not change any state and **POST** is usually used
    when the action can alter the state (add an element to the dataset, edit a value,
    etc.). In other words, **GET** is used to *read data* and **POST** is used to
    *create data* . When using the **GET** requests, we pass the parameters in the
    URL address. With **POST** requests, we can pass the parameters in the request
    body. FastAPI allows us to choose which request type we want by using the methods
    with the **@app.get()** or **@app.post()** Python decorators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create an API with the **GET** method that returns a **json** object.
    First, you need to install FastAPI with the **pip install fastapi[standard]**
    command. Now create a **main.py** file with these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the library and create the **app** object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let’s create the **GET** method. We will add the **@app.get("/")** decorator.
    The **"/"** means the URL path to call this method will be the root of our site:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To run the server locally go to the command line and type **fastapi dev** **main.py**
    . *Figure 11* *.6* shows what you should see if you open your browser and go to
    the **http://127.0.0.1:8000/** URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.6 – The response of the GET endpoint](img/B22441_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – The response of the GET endpoint
  prefs: []
  type: TYPE_NORMAL
- en: One of the nice things about FastAPI is that it creates docs for the APIs automatically.
    By default, it uses **Swagger UI** ( [https://github.com/swagger-api/swagger-ui](https://github.com/swagger-api/swagger-ui)
    ). Go to **http://127.0.0.1:8000/docs** to check it out. *Figure 11* *.7* shows
    the documentation docs of our FastAPI .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.7 – The documentation of our API created automatically by FastAPI](img/B22441_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – The documentation of our API created automatically by FastAPI
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create an API in the same style we’ve used to create the Streamlit
    web app. The API should receive a list of texts and return a JSON response with
    the entities. Here is an example of a request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The response of the API for this request should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'FastAPI uses the **Pydantic** models to validate the data and build the API
    documentation. Let’s create some Pydantic models to specify the **POST** request
    of our API. We do that by creating Python classes that are inherited from Pydantic’s
    **BaseModel** class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract the entities, the API will need to know the record identifier and
    the text, so let’s create a class for it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The API can work with a batch of texts, so the body parameter of the request
    can have many items. Let’s create this class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now it’s time to use spaCy to extract the entities to generate the response.
    We will create a class very similar to the one used in this Cookiecutter by Microsoft:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/microsoft/cookiecutter-spacy-fastapi](https://github.com/microsoft/cookiecutter-spacy-fastapi)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We should initiate the **EntityExtractor** class providing an **nlp** model
    and the key values for the record identifier and the record text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let’s create the method to extract the entities. The method will loop through
    the docs created by **nlp.pipe()** and create a list with the entities’ names,
    labels, and start and end characters for the entity in the text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To test whether this code is working, let’s save it to an **extractor.py**
    script and import the class like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’re using the model trained in [*Chapter 8*](B22441_08.xhtml#_idTextAnchor109)
    to extract the entities. The response should this dictionary with the entity’s
    names, labels, and matches:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we are ready to finish our API. The **/entities** path will be the **POST**
    endpoint to send the texts for extraction. Let’s get back to the FastAPI code
    to create this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **POST** request is defined using the **@app.post()** decorator. First,
    we will need to parse the received data to a list of dictionaries with the **record_id**
    and **text** keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we will call the **EntityExtractor** class, send the docs, and return the
    entities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you add this code to the **main.py** file, run **fastapi run main.py** in
    the terminal, and go to the **/docs** URL, you should now see the **POST /entities**
    endpoint specification.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another cool thing about Swagger UI is that we can test the endpoint directly
    in the browser. Click on the **POST /entities** down arrow button and then the
    **Try it out** button on the right. Now you can paste our example request and
    click on the blue **Execute** button. *Figure 11* *.8* shows the **POST /entities**
    arrow button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.8 – The button to send data to the entities endpoint](img/B22441_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – The button to send data to the entities endpoint
  prefs: []
  type: TYPE_NORMAL
- en: 'The next list has the full code of our API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It’s pretty cool to get all these functionalities with just some lines of code,
    right? This is just the basics of how to use FastAPI. You can check a lot of more
    advanced stuff in the library’s documentation at [https://fastapi.tiangolo.com/learn/](https://fastapi.tiangolo.com/learn/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter introduced two powerful tools for integrating spaCy with third-party
    libraries: Streamlit for building interactive web applications and FastAPI for
    creating fast, type-safe APIs. We demonstrated how to build an NER web app using
    Streamlit and the spacy-streamlit package, leveraging Streamlit’s simplicity and
    interactivity. We then transitioned to building an API with FastAPI, emphasizing
    the importance of type hints in reducing bugs and improving code reliability.
    By combining spaCy with these frameworks, you learned that you could create effective,
    user-friendly NLP applications and services with minimal effort.'
  prefs: []
  type: TYPE_NORMAL
- en: With this last chapter, we close out the book. It was quite a journey! I hope
    you’ve gained some ground knowledge of the main spaCy’s functionalities, but most
    importantly, I hope you can now create solutions with spaCy that follow some of
    the main software engineering principles for writing good code. I can’t wait to
    see what you’ll build next!
  prefs: []
  type: TYPE_NORMAL
