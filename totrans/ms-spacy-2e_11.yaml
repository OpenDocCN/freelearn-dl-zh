- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integrating spaCy with Third-Party Libraries
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll explore how to integrate spaCy with third-party libraries,
    focusing on building web applications and APIs for NLP tasks. We will start with
    **Streamlit** , a Python framework that simplifies the creation of web applications
    without needing extensive front-end knowledge. We’ll demonstrate how to create
    a simple **Named Entity Recognition** ( **NER** ) app using Streamlit and **spacy-streamlit**
    . Following this, we’ll dive into **FastAPI** , a modern framework for building
    APIs, known for its speed and use of Python type hints. We’ll learn how to create
    an API that extracts entities from text using a spaCy model, showcasing the ease
    with which you can build NLP-powered services.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Building spaCy-powered Apps with Streamlit
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building APIs for NLP models using FastAPI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the data and the code for this Chapter can be found at [https://github.com/PacktPublishing/Mastering-spaCy-Second-Edition](https://github.com/PacktPublishing/Mastering-spaCy-Second-Edition)
    .
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Building spaCy-powered Apps with Streamlit
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As data scientists and NLP engineers, the main programming language we use in
    our day-to-day is Python. If you don’t have a background in front-end development
    and have ever tried to build a web application or had to deal with CSS, you know
    how hard and frustrating it can be to work developing applications to work in
    the browser. Streamlit is a framework in Python designed to help us create web
    applications in a simple and fast way using pure Python. It is built on top of
    the **Tornado** Python web server framework ( [https://www.tornadoweb.org/en/stable/index.html](https://www.tornadoweb.org/en/stable/index.html)
    ) and uses **React** in the frontend. Luckily, we don’t need to know how to use
    any of these technologies to create our web apps, since with Streamlit, we can
    create widgets on the page by simply declaring some Python variables. We can also
    smoothly deploy, manage, and share Streamlit Web Apps by using the *community
    cloud* feature ( [https://streamlit.io/cloud](https://streamlit.io/cloud) ). The
    deployment can be done in one click and is free.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will first learn the basics of Streamlit and then how to
    use the **spacy-streamlit** package to use spaCy visualizations as the building
    blocks of the web apps.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Building NLP apps with spacy-streamlit
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start using Streamlit the first step is to install the library using **pip
    install streamlit** . We create the web applications using a Python script. The
    **streamlit run app.py** command runs a local server on the machine. To check
    whether everything is okay with the installation, let’s run the **streamlit hello**
    command. *Figure 11* *.1* shows this demo page in the browser.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Streamlit hello page](img/B22441_11_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Streamlit hello page
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'As we were talking about in the introduction section, creating widgets and
    visual components with Streamlit can be done by simply declaring a variable. We
    can also add interactivity to the apps using Streamlit input widgets. The main
    ones are **st.text_input** , **st.button** , and **st.slider** . The library has
    a large list of page elements. Here are some of the main ones and their descriptions:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在引言部分所讨论的，使用Streamlit创建小部件和视觉组件可以通过简单地声明一个变量来完成。我们还可以通过使用Streamlit输入小部件来为应用程序添加交互性。主要的小部件有**st.text_input**、**st.button**和**st.slider**。该库有一个长长的页面元素列表。以下是一些主要元素及其描述：
- en: '**st.write** : This writes the content on the page and automatically detects
    the type of the content to present it properly. If you write **st.write(''hi friends'')**
    , it will display the text; if you provide a dataframe instead of a string, it
    will present the dataframe with the proper formatting.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**st.write**：这将内容写入页面，并自动检测内容的类型以正确呈现。如果您写入**st.write(''hi friends'')**，它将显示文本；如果您提供数据框而不是字符串，它将以适当的格式呈现数据框。'
- en: '**st.title** : This will display the text in the title formatting.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**st.title**：这将显示以标题格式化的文本。'
- en: '**st.markdown** : This will display the text formatted in Markdown.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**st.markdown**：这将显示以Markdown格式化的文本。'
- en: '**st.dataframe** : This will display a dataframe as an interactive table.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**st.dataframe**：这将以交互式表格的形式显示数据框。'
- en: 'The **spacy-streamlit** package provides tools for visualizing spaCy models
    and developing interactive apps. It features various components that you can integrate
    into your own Streamlit applications, including visualizers for syntactic dependencies,
    named entities, text classification, token attributes, and more. Let’s build an
    app to get a glimpse of how Streamlit and **spacy-streamlit** work together. First,
    you need to install the package with **pip install spacy-streamlit** . With the
    library installed, let’s go ahead and build an app to display the entities of
    the model we trained in [*Chapter 8*](B22441_08.xhtml#_idTextAnchor109) :'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**spacy-streamlit**包提供了可视化spaCy模型和开发交互式应用程序的工具。它具有各种组件，可以集成到您自己的Streamlit应用程序中，包括句法依存关系、命名实体、文本分类、标记属性等的可视化器。让我们构建一个应用程序，以了解Streamlit和**spacy-streamlit**是如何协同工作的。首先，您需要使用**pip
    install spacy-streamlit**安装该包。安装了库之后，让我们继续构建一个应用程序来显示我们在[*第8章*](B22441_08.xhtml#_idTextAnchor109)中训练的模型中的实体：'
- en: 'First, we import both packages, **Streamlit** and **spacy_streamlit** :'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入两个包，**Streamlit**和**spacy_streamlit**：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s define a default text to the **st.text_input** component:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为**st.text_input**组件定义一个默认文本：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we define the path to the [*Chapter 8*](B22441_08.xhtml#_idTextAnchor109)
    final model:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们定义[*第8章*](B22441_08.xhtml#_idTextAnchor109)最终模型的路径：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s add a title and the text input. The content of **text_input** will be
    saved on the **text** variable:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个标题和文本输入。**text_input**的内容将被保存在**text**变量中：
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We still have some work to do, but first, let’s see what the app looks like
    with only this code. Save the code to an **app.py** script and run **streamlit
    run app.py** to serve it on our local machine. *Figure 11* *.2* shows what we
    have so far.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些工作要做，但首先，让我们看看只有这段代码时应用程序的样子。将代码保存到**app.py**脚本中，然后运行**streamlit run app.py**以在本地机器上提供服务。*图11.2*展示了我们目前所拥有的内容。
- en: '![Figure 11.2 – The Streamlit app with the text_area component](img/B22441_11_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – 带有text_area组件的Streamlit应用程序](img/B22441_11_02.jpg)'
- en: Figure 11.2 – The Streamlit app with the text_area component
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 带有text_area组件的Streamlit应用程序
- en: 'When building apps with Streamlit, every time the user interacts with an input
    widget, the library *reruns the entire Python script from top to bottom* . Our
    app needs to load the model before processing the text, so this could mean that
    every time a user types another text in the **st.text_area** widget, they would
    have to wait for the model to load again. To handle this, Streamlit has the cache
    feature ( [https://docs.streamlit.io/get-started/fundamentals/advanced-concepts#caching](https://docs.streamlit.io/get-started/fundamentals/advanced-concepts#caching)
    ) and **spacy-streamlit** implements the **process_text()** method. It caches
    loaded models and creates **Doc** objects. Let’s use the method to process the
    text of our app, continuing the list we’ve started:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'The **process_text ()** method expects the path to the model and the text that
    will be processed:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, to display the entities, we will use the **visualize_ner()** function:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Figure 11* *.3* shows the final app.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – NER app built with Streamlit](img/B22441_11_03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – NER app built with Streamlit
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to add a button so the users can type their own text and see the entities.
    Since Streamlit re-runs all the script code every time we interact with a widget,
    we cannot use the **st.button** widget. What we’ll do is use the **st.form** widget,
    which sends all widget values inside the form to Streamlit in a batch. We will
    use the **with** context manager to create the form. Let’s do it:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'We will put all the elements that should be reloaded inside the form context
    manager. So, when the user presses the submit button, we will process the doc
    and display it using the visualizer:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Figure 11* *.4* shows the app, now with the **Submit** button.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Streamlit app with form and Submit button](img/B22441_11_04.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Streamlit app with form and Submit button
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'The next list has the full code of the web app:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We were able to build a beautiful NLP app with just some lines of code by using
    both the **streamlit** and **spacy-streamlit** libraries. Other **spacy-streamlit**
    visualizers are **visualize_parser()** , **visualize_spans()** , **visualize_textcat()**
    , **visualize_similarity()** , and **visualize_tokens()** .
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we need to build APIs for our NLP projects instead of interactive
    web applications. For this scenario, we can use another cool library: **FastAPI**
    . Let’s learn more about it in the next section.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Building APIs for NLP models using FastAPI
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**FastAPI** is a Python web framework for building APIs. It’s built on top
    of another two Python libraries, **Starlette** and **Pydantic** , making it one
    of the fastest Python frameworks available. FastAPI is based on standard Python
    type hints. With type hinting, we can specify the expected type of a variable,
    function parameter, or return value. This feature helps us catch bugs earlier
    in the development process, so let’s learn how to use type hints before heading
    to FastAPI usage.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Python type hinting 101
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python is a dynamically typed language, meaning it performs the type checks
    of the variables at runtime. For example, if we run this code, it does not throw
    any errors:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This runs smoothly because the Python interpreter handles the transition of
    **string_or_int** from **String** to **int** . This can lead to bugs because of
    silent errors. **Type hinting** provides a way to specify the expected types in
    our code, so it reduces our chances of creating bugs. Let’s see an example of
    a simple function without it first:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Imagine this function is in a code base and you just import it to use in your
    code. There is no way to see what the writer of the function was expecting as
    the type of the **name** parameter and no information about the return type. To
    get this information, we need to read to check the code of the function. The situation
    changes if we use type hints:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now with these type hints, your code editor can help you and show the types.
    *Figure 11* *.5* shows what happens in *Visual Studio Code* , for example.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Type hinting in Visual Studio Code](img/B22441_11_05.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Type hinting in Visual Studio Code
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI uses type hints to offer type checks, leading to fewer bugs and developer-induced
    errors. Now that we know what type hinting is, let’s create an API for our spaCy
    model using FastAPI.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Creating an API for the spaCy model with FastAPI
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two main HTTP methods we use to build APIs are **GET** and **POST** . **GET**
    is used when the request does not change any state and **POST** is usually used
    when the action can alter the state (add an element to the dataset, edit a value,
    etc.). In other words, **GET** is used to *read data* and **POST** is used to
    *create data* . When using the **GET** requests, we pass the parameters in the
    URL address. With **POST** requests, we can pass the parameters in the request
    body. FastAPI allows us to choose which request type we want by using the methods
    with the **@app.get()** or **@app.post()** Python decorators.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create an API with the **GET** method that returns a **json** object.
    First, you need to install FastAPI with the **pip install fastapi[standard]**
    command. Now create a **main.py** file with these commands:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the library and create the **app** object:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now let’s create the **GET** method. We will add the **@app.get("/")** decorator.
    The **"/"** means the URL path to call this method will be the root of our site:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To run the server locally go to the command line and type **fastapi dev** **main.py**
    . *Figure 11* *.6* shows what you should see if you open your browser and go to
    the **http://127.0.0.1:8000/** URL.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.6 – The response of the GET endpoint](img/B22441_11_06.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – The response of the GET endpoint
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: One of the nice things about FastAPI is that it creates docs for the APIs automatically.
    By default, it uses **Swagger UI** ( [https://github.com/swagger-api/swagger-ui](https://github.com/swagger-api/swagger-ui)
    ). Go to **http://127.0.0.1:8000/docs** to check it out. *Figure 11* *.7* shows
    the documentation docs of our FastAPI .
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.7 – The documentation of our API created automatically by FastAPI](img/B22441_11_07.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – The documentation of our API created automatically by FastAPI
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create an API in the same style we’ve used to create the Streamlit
    web app. The API should receive a list of texts and return a JSON response with
    the entities. Here is an example of a request:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The response of the API for this request should be as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'FastAPI uses the **Pydantic** models to validate the data and build the API
    documentation. Let’s create some Pydantic models to specify the **POST** request
    of our API. We do that by creating Python classes that are inherited from Pydantic’s
    **BaseModel** class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract the entities, the API will need to know the record identifier and
    the text, so let’s create a class for it:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The API can work with a batch of texts, so the body parameter of the request
    can have many items. Let’s create this class:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now it’s time to use spaCy to extract the entities to generate the response.
    We will create a class very similar to the one used in this Cookiecutter by Microsoft:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/microsoft/cookiecutter-spacy-fastapi](https://github.com/microsoft/cookiecutter-spacy-fastapi)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do it:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'We should initiate the **EntityExtractor** class providing an **nlp** model
    and the key values for the record identifier and the record text:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now let’s create the method to extract the entities. The method will loop through
    the docs created by **nlp.pipe()** and create a list with the entities’ names,
    labels, and start and end characters for the entity in the text:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To test whether this code is working, let’s save it to an **extractor.py**
    script and import the class like this:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We’re using the model trained in [*Chapter 8*](B22441_08.xhtml#_idTextAnchor109)
    to extract the entities. The response should this dictionary with the entity’s
    names, labels, and matches:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now we are ready to finish our API. The **/entities** path will be the **POST**
    endpoint to send the texts for extraction. Let’s get back to the FastAPI code
    to create this method.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'The **POST** request is defined using the **@app.post()** decorator. First,
    we will need to parse the received data to a list of dictionaries with the **record_id**
    and **text** keys:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we will call the **EntityExtractor** class, send the docs, and return the
    entities:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you add this code to the **main.py** file, run **fastapi run main.py** in
    the terminal, and go to the **/docs** URL, you should now see the **POST /entities**
    endpoint specification.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another cool thing about Swagger UI is that we can test the endpoint directly
    in the browser. Click on the **POST /entities** down arrow button and then the
    **Try it out** button on the right. Now you can paste our example request and
    click on the blue **Execute** button. *Figure 11* *.8* shows the **POST /entities**
    arrow button.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于 Swagger UI 的另一个酷点是，我们可以在浏览器中直接测试端点。点击 **POST /entities** 向下的箭头按钮，然后点击右侧的
    **Try it out** 按钮。现在你可以粘贴我们的示例请求，然后点击蓝色的 **Execute** 按钮。*图 11.8* 显示了 **POST /entities**
    的箭头按钮。
- en: '![Figure 11.8 – The button to send data to the entities endpoint](img/B22441_11_08.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.8 – 发送数据到实体端点的按钮](img/B22441_11_08.jpg)'
- en: Figure 11.8 – The button to send data to the entities endpoint
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 – 发送数据到实体端点的按钮
- en: 'The next list has the full code of our API:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表包含了我们 API 的完整代码：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It’s pretty cool to get all these functionalities with just some lines of code,
    right? This is just the basics of how to use FastAPI. You can check a lot of more
    advanced stuff in the library’s documentation at [https://fastapi.tiangolo.com/learn/](https://fastapi.tiangolo.com/learn/)
    .
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 只用几行代码就能获得所有这些功能，这真是太酷了，对吧？这仅仅是使用 FastAPI 的基础知识。你可以在库的文档中查看更多高级内容，请访问 [https://fastapi.tiangolo.com/learn/](https://fastapi.tiangolo.com/learn/)。
- en: Summary
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter introduced two powerful tools for integrating spaCy with third-party
    libraries: Streamlit for building interactive web applications and FastAPI for
    creating fast, type-safe APIs. We demonstrated how to build an NER web app using
    Streamlit and the spacy-streamlit package, leveraging Streamlit’s simplicity and
    interactivity. We then transitioned to building an API with FastAPI, emphasizing
    the importance of type hints in reducing bugs and improving code reliability.
    By combining spaCy with these frameworks, you learned that you could create effective,
    user-friendly NLP applications and services with minimal effort.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了将 spaCy 与第三方库集成的两个强大工具：用于构建交互式网络应用的 Streamlit 和用于创建快速、类型安全的 API 的 FastAPI。我们展示了如何使用
    Streamlit 和 spacy-streamlit 包构建一个 NER 网络应用，利用 Streamlit 的简洁性和交互性。然后我们转向使用 FastAPI
    构建API，强调类型提示在减少错误和提高代码可靠性方面的重要性。通过将 spaCy 与这些框架结合，你了解到你可以以最小的努力创建有效的、用户友好的 NLP
    应用和服务。
- en: With this last chapter, we close out the book. It was quite a journey! I hope
    you’ve gained some ground knowledge of the main spaCy’s functionalities, but most
    importantly, I hope you can now create solutions with spaCy that follow some of
    the main software engineering principles for writing good code. I can’t wait to
    see what you’ll build next!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章的最后，我们结束了这本书。这是一段相当精彩的旅程！我希望你已经对 spaCy 的主要功能有了基本的了解，但更重要的是，我希望你现在能够使用 spaCy
    创建遵循一些主要软件工程原则编写良好代码的解决方案。我迫不及待地想看看你接下来会构建什么！
