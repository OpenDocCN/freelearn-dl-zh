<html><head></head><body><html:html>&#13;
 <html:head>&#13;
  <html:title>&#13;
   Kickstarting Your Journey with LlamaIndex&#13;
  </html:title>&#13;
 </html:head>&#13;
 <html:body>&#13;
  <html:div class="epub-source">&#13;
   <html:h1 class="H1---Chapter" id="_idParaDest-47">&#13;
    Kickstarting Your Journey with LlamaIndex&#13;
   </html:h1>&#13;
   <html:div id="_idContainer034">&#13;
    <html:p style="font-style:italic;">&#13;
     As this ebook edition doesn't have fixed pagination, the page numbers below are hyperlinked for reference only, based on the printed edition of this book.&#13;
    </html:p>&#13;
    <html:p>&#13;
     It’s time to dive deeper and gain a more technical understanding of how LlamaIndex works its magic under the hood. In this chapter, we’ll explore some of the key concepts and components that make up LlamaIndex’s architecture. We’ll learn about the core building blocks used by the framework to ingest, structure, and query our data. Understanding these fundamentals will provide a solid foundation before we start applying them hands-on. We’ll go through the theoretical aspects of each concept and then connect the dots between the theory and&#13;
     <html:span class="No-Break">&#13;
      practical application.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Here are the main topics covered in&#13;
     <html:span class="No-Break">&#13;
      this chapter:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:ul>&#13;
     <html:li>&#13;
      Uncovering the essential building blocks of LlamaIndex –&#13;
      <html:strong class="bold">&#13;
       Documents&#13;
      </html:strong>&#13;
      ,&#13;
      <html:strong class="bold">&#13;
       Nodes&#13;
      </html:strong>&#13;
      ,&#13;
      <html:span class="No-Break">&#13;
       and&#13;
      </html:span>&#13;
      <html:span class="No-Break">&#13;
       <html:strong class="bold">&#13;
        indexes&#13;
       </html:strong>&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      Building our first interactive, augmented&#13;
      <html:strong class="bold">&#13;
       large language model&#13;
      </html:strong>&#13;
      (&#13;
      <html:span class="No-Break">&#13;
       <html:strong class="bold">&#13;
        LLM&#13;
       </html:strong>&#13;
      </html:span>&#13;
      <html:span class="No-Break">&#13;
       ) application&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      Starting our&#13;
      <html:strong class="bold">&#13;
       personalized intelligent tutoring system&#13;
      </html:strong>&#13;
      (&#13;
      <html:strong class="bold">&#13;
       PITS&#13;
      </html:strong>&#13;
      ) project – a&#13;
      <html:span class="No-Break">&#13;
       hands-on exercise&#13;
      </html:span>&#13;
     </html:li>&#13;
    </html:ul>&#13;
    <html:a id="_idTextAnchor047">&#13;
    </html:a>&#13;
   </html:div>&#13;
  </html:div>&#13;
 </html:body>&#13;
</html:html>
<html:html>&#13;
 <html:head>&#13;
  <html:title>&#13;
   Technical requirements&#13;
  </html:title>&#13;
 </html:head>&#13;
 <html:body>&#13;
  <html:div class="epub-source">&#13;
   <html:h1 id="_idParaDest-48">&#13;
    Technical requirements&#13;
   </html:h1>&#13;
   <html:div id="_idContainer034">&#13;
    <html:p>&#13;
     You will need to install the following Python libraries in your environment to be able to run the examples included in&#13;
     <html:span class="No-Break">&#13;
      this chapter:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:ul>&#13;
     <html:li>&#13;
      <html:span class="No-Break">&#13;
       <html:em class="italic">&#13;
        PYYAML&#13;
       </html:em>&#13;
      </html:span>&#13;
      <html:span class="No-Break">&#13;
       (&#13;
      </html:span>&#13;
      <html:a>&#13;
       <html:span class="No-Break">&#13;
        https://pyyaml.org/wiki/PyYAMLDocumentation&#13;
       </html:span>&#13;
      </html:a>&#13;
      <html:span class="No-Break">&#13;
       )&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:span class="No-Break">&#13;
       <html:em class="italic">&#13;
        Wikipedia&#13;
       </html:em>&#13;
      </html:span>&#13;
      <html:span class="No-Break">&#13;
       (&#13;
      </html:span>&#13;
      <html:a>&#13;
       <html:span class="No-Break">&#13;
        https://wikipedia.readthedocs.io/en/latest/&#13;
       </html:span>&#13;
      </html:a>&#13;
      <html:span class="No-Break">&#13;
       )&#13;
      </html:span>&#13;
     </html:li>&#13;
    </html:ul>&#13;
    <html:p>&#13;
     Two LlamaIndex integration packages will also&#13;
     <html:span class="No-Break">&#13;
      be required:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:ul>&#13;
     <html:li>&#13;
      <html:em class="italic">&#13;
       Wikipedia&#13;
      </html:em>&#13;
      <html:span class="No-Break">&#13;
       <html:em class="italic">&#13;
        reader&#13;
       </html:em>&#13;
      </html:span>&#13;
      <html:span class="No-Break">&#13;
       (&#13;
      </html:span>&#13;
      <html:a>&#13;
       <html:span class="No-Break">&#13;
        https://pypi.org/project/llama-index-readers-wikipedia/&#13;
       </html:span>&#13;
      </html:a>&#13;
      <html:span class="No-Break">&#13;
       )&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:em class="italic">&#13;
       OpenAI&#13;
      </html:em>&#13;
      <html:span class="No-Break">&#13;
       <html:em class="italic">&#13;
        LLMs&#13;
       </html:em>&#13;
      </html:span>&#13;
      <html:span class="No-Break">&#13;
       (&#13;
      </html:span>&#13;
      <html:a>&#13;
       <html:span class="No-Break">&#13;
        https://pypi.org/project/llama-index-llms-openai/&#13;
       </html:span>&#13;
      </html:a>&#13;
      <html:span class="No-Break">&#13;
       )&#13;
      </html:span>&#13;
     </html:li>&#13;
    </html:ul>&#13;
    <html:p>&#13;
     All code samples from this chapter can be found in the&#13;
     <html:code class="literal">&#13;
      ch3&#13;
     </html:code>&#13;
     subfolder of the book’s GitHub&#13;
     <html:span class="No-Break">&#13;
      repository:&#13;
     </html:span>&#13;
     <html:a>&#13;
      <html:span class="No-Break">&#13;
       https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-LlamaIndex&#13;
      </html:span>&#13;
     </html:a>&#13;
     <html:span class="No-Break">&#13;
      .&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:a id="_idTextAnchor048">&#13;
    </html:a>&#13;
   </html:div>&#13;
  </html:div>&#13;
 </html:body>&#13;
</html:html>
<html:html>&#13;
 <html:head>&#13;
  <html:title>&#13;
   Uncovering the essential building blocks of LlamaIndex – documents, nodes, and indexes&#13;
  </html:title>&#13;
 </html:head>&#13;
 <html:body>&#13;
  <html:div class="epub-source">&#13;
   <html:h1 id="_idParaDest-49">&#13;
    Uncovering the essential building blocks of LlamaIndex – documents, nodes, and indexes&#13;
   </html:h1>&#13;
   <html:div id="_idContainer034">&#13;
    from llama_index.core import Document&#13;
text = "The quick brown fox jumps over the lazy dog."&#13;
doc = Document(&#13;
    text=text,&#13;
    metadata={'author': 'John Doe','category': 'others'},&#13;
    id_='1'&#13;
)&#13;
print(doc)&#13;
    pip install wikipedia&#13;
pip install llama-index-readers-wikipedia&#13;
    from llama_index.readers.wikipedia import WikipediaReader&#13;
loader = WikipediaReader()&#13;
documents = loader.load_data(&#13;
    pages=['Pythagorean theorem','General relativity']&#13;
)&#13;
print(f"loaded {len(documents)} documents")&#13;
    from llama_index.core import Document&#13;
from llama_index.core.schema import TextNode&#13;
doc = Document(text="This is a sample document text")&#13;
n1 = TextNode(text=doc.text[0:16], doc_id=doc.id_)&#13;
n2 = TextNode(text=doc.text[17:30], doc_id=doc.id_)&#13;
print(n1)&#13;
print(n2)&#13;
    Node ID: 102b570f-5b22-48b5-b9b6-6378597e920d&#13;
Text: This is a sample&#13;
Node ID: 0ad81b09-bf12-4063-bfe4-6c5fd3c36cd4&#13;
Text: document text&#13;
    from llama_index.core import Document&#13;
from llama_index.core.node_parser import TokenTextSplitter&#13;
doc = Document(&#13;
    text=(&#13;
    "This is sentence 1. This is sentence 2. "&#13;
    "Sentence 3 here."&#13;
    ),&#13;
    metadata={"author": "John Smith"}&#13;
)&#13;
splitter = TokenTextSplitter(&#13;
    chunk_size=12,&#13;
    chunk_overlap=0,&#13;
    separator=" "&#13;
)&#13;
nodes = splitter.get_nodes_from_documents([doc])&#13;
for node in nodes:&#13;
    print(node.text)&#13;
    print(node.metadata)&#13;
    Metadata length (6) is close to chunk size (12). Resulting chunks are less than 50 tokens. Consider increasing the chunk size or decreasing the size of your metadata to avoid this.&#13;
This is sentence 1.&#13;
{'author': 'John Smith'}&#13;
This is sentence 2.&#13;
{'author': 'John Smith'}&#13;
Sentence 3 here.&#13;
{'author': 'John Smith'}&#13;
    from llama_index.core import Document&#13;
from llama_index.core.schema import (&#13;
    TextNode,&#13;
    NodeRelationship,&#13;
    RelatedNodeInfo&#13;
)&#13;
doc = Document(text="First sentence. Second Sentence")&#13;
n1 = TextNode(text="First sentence", node_id=doc.doc_id)&#13;
n2 = TextNode(text="Second sentence", node_id=doc.doc_id)&#13;
n1.relationships[NodeRelationship.NEXT] = n2.node_id&#13;
n2.relationships[NodeRelationship.PREVIOUS] = n1.node_id&#13;
print(n1.relationships)&#13;
print(n2.relationships)&#13;
    from llama_index.core import SummaryIndex, Document&#13;
from llama_index.core.schema import TextNode&#13;
nodes = [&#13;
    TextNode(&#13;
        text="Lionel Messi is a football player from Argentina."&#13;
    ),&#13;
    TextNode(&#13;
        text="He has won the Ballon d'Or trophy 7 times."&#13;
    ),&#13;
    TextNode(text="Lionel Messi's hometown is Rosario."),&#13;
    TextNode(text="He was born on June 24, 1987.")&#13;
]&#13;
index = SummaryIndex(nodes)&#13;
    query_engine = index.as_query_engine()&#13;
response = query_engine.query("What is Messi's hometown?")&#13;
print(response)&#13;
    Messi's hometown is Rosario.&#13;
    <html:p>&#13;
     As we’re getting started with&#13;
     <html:a id="_idIndexMarker089">&#13;
     </html:a>&#13;
     LlamaIndex, it’s time to understand some of the key concepts and components that make up its architecture. You may consider this chapter as a quick introduction to the&#13;
     <html:a id="_idIndexMarker090">&#13;
     </html:a>&#13;
     typical&#13;
     <html:strong class="bold">&#13;
      retrieval-augmented generation&#13;
     </html:strong>&#13;
     (&#13;
     <html:strong class="bold">&#13;
      RAG&#13;
     </html:strong>&#13;
     ) architecture with LlamaIndex and an overview of the most important tools provided by this framework. It should give you a basic understanding of how to build a simple RAG application. In the next chapters, we’ll take it step by step and explore in detail each one of the components&#13;
     <html:span class="No-Break">&#13;
      presented here.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     At a high level, LlamaIndex helps connect external data sources to LLMs. To do this effectively, it needs to ingest, structure, and organize your data in a way that allows for efficient retrieval and querying. In this first part of our chapter, we’ll explore the core elements that enable LlamaIndex to augment LLMs – Documents, Nodes,&#13;
     <html:span class="No-Break">&#13;
      and indexes.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:a id="_idTextAnchor049">&#13;
    </html:a>&#13;
    <html:h2 id="_idParaDest-50">&#13;
     Documents&#13;
    </html:h2>&#13;
    <html:p>&#13;
     It all begins with&#13;
     <html:span class="No-Break">&#13;
      the data.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Now, trying to handle&#13;
     <html:a id="_idIndexMarker091">&#13;
     </html:a>&#13;
     raw data directly can be as tricky as holding water in your hands. It’s often all over the place without any set structure. This is where we need to step in and give it some shape. That’s exactly what we do in LlamaIndex with something called Documents. A Document&#13;
     <html:a id="_idIndexMarker092">&#13;
     </html:a>&#13;
     is how we capture and contain any kind of data, whether you enter it manually or load it over from an external source. It’s like putting the data in a nice bottle so it’s easier&#13;
     <html:span class="No-Break">&#13;
      to handle.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Imagine&#13;
     <html:a id="_idIndexMarker093">&#13;
     </html:a>&#13;
     you’ve got a bunch of your company’s procedures saved as PDFs and you want to make sense of them using a powerful language model such as GPT-4. In LlamaIndex, each of these procedures would be turned into its&#13;
     <html:code class="literal">&#13;
      Document&#13;
     </html:code>&#13;
     object – and it’s&#13;
     <html:a id="_idIndexMarker094">&#13;
     </html:a>&#13;
     not just about files. Say you have data sitting in a database or coming through an API – those can be Documents, too. Check out&#13;
     <html:span class="No-Break">&#13;
      <html:em class="italic">&#13;
       Figure 3&#13;
      </html:em>&#13;
     </html:span>&#13;
     <html:em class="italic">&#13;
      .1&#13;
     </html:em>&#13;
     for a&#13;
     <html:span class="No-Break">&#13;
      visual overview:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:div>&#13;
     <html:div class="IMG---Figure" id="_idContainer028">&#13;
      <html:img src="img/B21861_03_1.jpg"/>&#13;
     </html:div>&#13;
    </html:div>&#13;
    <html:p class="IMG---Caption" lang="en-US">&#13;
     Figure 3.1 – Documents can come from multiple sources&#13;
    </html:p>&#13;
    <html:p>&#13;
     Think of the&#13;
     <html:code class="literal">&#13;
      Document&#13;
     </html:code>&#13;
     class as a container. It holds not just the raw text or data from wherever it originated but also any extra bits of information you decide to tag along. This&#13;
     <html:a id="_idIndexMarker095">&#13;
     </html:a>&#13;
     extra info, called&#13;
     <html:strong class="bold">&#13;
      metadata&#13;
     </html:strong>&#13;
     , is a game changer when you start searching through your Documents because it lets you get really specific with&#13;
     <html:span class="No-Break">&#13;
      your queries.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Here is a basic example of how a Document can be&#13;
     <html:span class="No-Break">&#13;
      created manually:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     In this&#13;
     <html:a id="_idIndexMarker096">&#13;
     </html:a>&#13;
     example, after importing the&#13;
     <html:code class="literal">&#13;
      Document&#13;
     </html:code>&#13;
     class, we create a&#13;
     <html:code class="literal">&#13;
      Document&#13;
     </html:code>&#13;
     object called&#13;
     <html:code class="literal">&#13;
      doc&#13;
     </html:code>&#13;
     . The object contains the actual text, a document ID, and&#13;
     <html:a id="_idIndexMarker097">&#13;
     </html:a>&#13;
     some additional metadata of our choice that is provided as&#13;
     <html:span class="No-Break">&#13;
      a dictionary.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Here are some of the most important attributes of a&#13;
     <html:span class="No-Break">&#13;
      <html:code class="literal">&#13;
       Document&#13;
      </html:code>&#13;
     </html:span>&#13;
     <html:span class="No-Break">&#13;
      object:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:ul>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       text&#13;
      </html:code>&#13;
      : This attribute stores the text content of&#13;
      <html:span class="No-Break">&#13;
       the document&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       metadata&#13;
      </html:code>&#13;
      : This attribute is a dictionary that can be used to include additional information about the document, such as the file name or categories. The keys in the metadata dictionary must be strings and the values can be strings, floats,&#13;
      <html:span class="No-Break">&#13;
       or integers&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       id_&#13;
      </html:code>&#13;
      : This is a unique ID for each Document. You can set this manually if you want, but if you don’t specify an ID, LlamaIndex will automatically generate one&#13;
      <html:span class="No-Break">&#13;
       for you&#13;
      </html:span>&#13;
     </html:li>&#13;
    </html:ul>&#13;
    <html:p>&#13;
     There are also other attributes that you can find by consulting the GitHub repository of LlamaIndex. However, to keep things simple, at this moment we will only focus on these three. These attributes provide various ways to customize and enhance the functionality of the&#13;
     <html:code class="literal">&#13;
      Document&#13;
     </html:code>&#13;
     class&#13;
     <html:span class="No-Break">&#13;
      in LlamaIndex.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     <html:span class="No-Break">&#13;
      <html:em class="italic">&#13;
       Figure 3&#13;
      </html:em>&#13;
     </html:span>&#13;
     <html:em class="italic">&#13;
      .2&#13;
     </html:em>&#13;
     presents the basic structure of a&#13;
     <html:span class="No-Break">&#13;
      LlamaIndex Document.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:div>&#13;
     <html:div class="IMG---Figure" id="_idContainer029">&#13;
      <html:img src="img/B21861_03_2.jpg"/>&#13;
     </html:div>&#13;
    </html:div>&#13;
    <html:p class="IMG---Caption" lang="en-US">&#13;
     Figure 3.2 – The basic structure of a document&#13;
    </html:p>&#13;
    <html:p>&#13;
     The LlamaIndex Documents contain data in its unprocessed, or&#13;
     <html:strong class="bold">&#13;
      raw&#13;
     </html:strong>&#13;
     , form. Although the given example illustrates how we can manually create one, typically, in practical applications, these Documents are generated in bulk by sourcing them from various data sources. This bulk ingestion of data uses&#13;
     <html:a id="_idIndexMarker098">&#13;
     </html:a>&#13;
     predefined&#13;
     <html:strong class="bold">&#13;
      data loaders&#13;
     </html:strong>&#13;
     – sometimes&#13;
     <html:a id="_idIndexMarker099">&#13;
     </html:a>&#13;
     called&#13;
     <html:strong class="bold">&#13;
      connectors&#13;
     </html:strong>&#13;
     or&#13;
     <html:a id="_idIndexMarker100">&#13;
     </html:a>&#13;
     simply&#13;
     <html:strong class="bold">&#13;
      readers&#13;
     </html:strong>&#13;
     – from an extensive library&#13;
     <html:a id="_idIndexMarker101">&#13;
     </html:a>&#13;
     known as&#13;
     <html:span class="No-Break">&#13;
      <html:strong class="bold">&#13;
       LlamaHub&#13;
      </html:strong>&#13;
     </html:span>&#13;
     <html:span class="No-Break">&#13;
      (&#13;
     </html:span>&#13;
     <html:a>&#13;
      <html:span class="No-Break">&#13;
       https://llamahub.ai/&#13;
      </html:span>&#13;
     </html:a>&#13;
     <html:span class="No-Break">&#13;
      ).&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p class="callout-heading">&#13;
     Note&#13;
    </html:p>&#13;
    <html:p class="callout">&#13;
     Developed primarily by the LlamaIndex community, these plug-and-play packages extend the functionality of the core components of the framework. They provide different LLMs, agent tools, embedding models, vector stores, and data loaders. These data ingestion tools offer compatibility with a wide range of data file formats, databases, and API endpoints. There are more than 130 different data readers in LlamaHub already and the list keeps growing. We’ll cover the topic of LlamaHub in much more detail in the next chapter. For now, we’ll focus on the&#13;
     <html:span class="No-Break">&#13;
      data loaders.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Here is a basic example of automated data ingestion using one of the predefined LlamaHub data loaders. Before you can run the example, make sure you install the libraries mentioned in the&#13;
     <html:em class="italic">&#13;
      technical requirements&#13;
     </html:em>&#13;
     section and complete all the necessary environment preparations mentioned in&#13;
     <html:a>&#13;
      <html:span class="No-Break">&#13;
       <html:em class="italic">&#13;
        Chapter 2&#13;
       </html:em>&#13;
      </html:span>&#13;
     </html:a>&#13;
     if you&#13;
     <html:span class="No-Break">&#13;
      haven’t already:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     The first&#13;
     <html:a id="_idIndexMarker102">&#13;
     </html:a>&#13;
     library&#13;
     <html:a id="_idIndexMarker103">&#13;
     </html:a>&#13;
     allows for easy access and parsing of data from Wikipedia while the second one is the LlamaIndex integration for the Wikipedia&#13;
     <html:span class="No-Break">&#13;
      data loader.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Once you have installed the two libraries, you’ll be able to run the&#13;
     <html:span class="No-Break">&#13;
      following example:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     The&#13;
     <html:code class="literal">&#13;
      WikpediaReader&#13;
     </html:code>&#13;
     loader&#13;
     <html:a id="_idIndexMarker104">&#13;
     </html:a>&#13;
     extracts the text from Wikipedia articles using the Wikipedia Python package. Apart from&#13;
     <html:code class="literal">&#13;
      WikipediaReader&#13;
     </html:code>&#13;
     , there are many more specialized data connectors available in&#13;
     <html:span class="No-Break">&#13;
      the LlamaHub.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     So, creating&#13;
     <html:a id="_idIndexMarker105">&#13;
     </html:a>&#13;
     Documents is a very straightforward process. But how do&#13;
     <html:a id="_idIndexMarker106">&#13;
     </html:a>&#13;
     the raw&#13;
     <html:code class="literal">&#13;
      Document&#13;
     </html:code>&#13;
     objects get converted into a format that LLMs can efficiently process and reason over? This is where Nodes&#13;
     <html:span class="No-Break">&#13;
      come in.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:a id="_idTextAnchor050">&#13;
    </html:a>&#13;
    <html:h2 id="_idParaDest-51">&#13;
     Nodes&#13;
    </html:h2>&#13;
    <html:p>&#13;
     While&#13;
     <html:a id="_idIndexMarker107">&#13;
     </html:a>&#13;
     Documents represent the raw data and can be used as such, Nodes&#13;
     <html:a id="_idIndexMarker108">&#13;
     </html:a>&#13;
     are smaller chunks of content extracted from the Documents. The goal is to break down Documents into smaller, more manageable pieces of text. This serves a&#13;
     <html:span class="No-Break">&#13;
      few purposes:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:ul>&#13;
     <html:li>&#13;
      <html:strong class="bold">&#13;
       Allows our proprietary knowledge to fit within the model’s prompt limits&#13;
      </html:strong>&#13;
      : Imagine that if we had an internal procedure that is 50 pages long, we would definitely run into size limit problems when trying to feed that in the context of our prompt. However, most likely, in practice, we wouldn’t need to feed the entire procedure in one prompt. Therefore, selecting just the relevant Nodes can solve&#13;
      <html:span class="No-Break">&#13;
       this problem.&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:strong class="bold">&#13;
       Creates semantic units of data centered around specific information&#13;
      </html:strong>&#13;
      : This can make it easier to work with and analyze the data, as it is organized into smaller, more&#13;
      <html:span class="No-Break">&#13;
       focused units.&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:strong class="bold">&#13;
       Allows the creation of relationships between Nodes&#13;
      </html:strong>&#13;
      : This means that Nodes can be linked together based on their relationships, creating a network of interconnected data. This can be useful for understanding the connections and dependencies between different pieces of information within&#13;
      <html:span class="No-Break">&#13;
       the Documents.&#13;
      </html:span>&#13;
     </html:li>&#13;
    </html:ul>&#13;
    <html:p>&#13;
     Take a look at&#13;
     <html:span class="No-Break">&#13;
      <html:em class="italic">&#13;
       Figure 3&#13;
      </html:em>&#13;
     </html:span>&#13;
     <html:em class="italic">&#13;
      .3&#13;
     </html:em>&#13;
     for a visual representation of&#13;
     <html:span class="No-Break">&#13;
      this concept:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:div>&#13;
     <html:div class="IMG---Figure" id="_idContainer030">&#13;
      <html:img src="img/B21861_03_3.jpg"/>&#13;
     </html:div>&#13;
    </html:div>&#13;
    <html:p class="IMG---Caption" lang="en-US">&#13;
     Figure 3.3 – Relationships between Nodes extracted from a Document&#13;
    </html:p>&#13;
    <html:p>&#13;
     In LlamaIndex, Nodes&#13;
     <html:a id="_idIndexMarker109">&#13;
     </html:a>&#13;
     can also store images but we won’t focus on that functionality&#13;
     <html:a id="_idIndexMarker110">&#13;
     </html:a>&#13;
     in this book. Our main protagonist from now on will be the&#13;
     <html:span class="No-Break">&#13;
      <html:code class="literal">&#13;
       TextNode&#13;
      </html:code>&#13;
     </html:span>&#13;
     <html:span class="No-Break">&#13;
      class.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Here’s a list&#13;
     <html:a id="_idIndexMarker111">&#13;
     </html:a>&#13;
     of some important attributes of the&#13;
     <html:span class="No-Break">&#13;
      <html:code class="literal">&#13;
       TextNode&#13;
      </html:code>&#13;
     </html:span>&#13;
     <html:span class="No-Break">&#13;
      class:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:ul>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       text&#13;
      </html:code>&#13;
      : The chunk of text derived from an&#13;
      <html:span class="No-Break">&#13;
       original Document.&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       start_char_idx&#13;
      </html:code>&#13;
      and&#13;
      <html:code class="literal">&#13;
       end_char_idx&#13;
      </html:code>&#13;
      are optional integer values that can store the starting and ending character positions of the text within the Document. This could be helpful when the text is part of a larger Document, and you need to pinpoint the&#13;
      <html:span class="No-Break">&#13;
       exact location.&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       text_template&#13;
      </html:code>&#13;
      and&#13;
      <html:code class="literal">&#13;
       metadata_template&#13;
      </html:code>&#13;
      are template fields that define how the text and metadata are formatted. They help produce a more structured and readable representation&#13;
      <html:span class="No-Break">&#13;
       of&#13;
      </html:span>&#13;
      <html:span class="No-Break">&#13;
       <html:code class="literal">&#13;
        TextNode&#13;
       </html:code>&#13;
      </html:span>&#13;
      <html:span class="No-Break">&#13;
       .&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       metadata_seperator&#13;
      </html:code>&#13;
      : This is a string field that defines the separator between metadata fields. When multiple metadata items are included, this separator is used to maintain readability&#13;
      <html:span class="No-Break">&#13;
       and structure.&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      Any useful&#13;
      <html:code class="literal">&#13;
       metadata&#13;
      </html:code>&#13;
      such as the parent Document ID, relationships to other Nodes, and optional tags. This metadata can be used for storing additional context when necessary. We’ll talk about it in more detail in&#13;
      <html:a>&#13;
       <html:span class="No-Break">&#13;
        <html:em class="italic">&#13;
         Chapter 4&#13;
        </html:em>&#13;
       </html:span>&#13;
      </html:a>&#13;
      ,&#13;
      <html:em class="italic">&#13;
       Ingesting Data into Our&#13;
      </html:em>&#13;
      <html:span class="No-Break">&#13;
       <html:em class="italic">&#13;
        RAG Workflow&#13;
       </html:em>&#13;
      </html:span>&#13;
      <html:span class="No-Break">&#13;
       .&#13;
      </html:span>&#13;
     </html:li>&#13;
    </html:ul>&#13;
    <html:p>&#13;
     Just like in the case of Documents, if you want to see a full list of the&#13;
     <html:code class="literal">&#13;
      TextNode&#13;
     </html:code>&#13;
     attributes, you can find them described on the LlamaIndex GitHub&#13;
     <html:span class="No-Break">&#13;
      repository:&#13;
     </html:span>&#13;
     <html:a>&#13;
      <html:span class="No-Break">&#13;
       https://github.com/run-llama/llama_index/blob/main/llama-index-core/llama_index/core/schema.py&#13;
      </html:span>&#13;
     </html:a>&#13;
     <html:span class="No-Break">&#13;
      .&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     You should know&#13;
     <html:a id="_idIndexMarker112">&#13;
     </html:a>&#13;
     that the Nodes will automatically inherit any&#13;
     <html:a id="_idIndexMarker113">&#13;
     </html:a>&#13;
     metadata already present at the Document level but their metadata can also be&#13;
     <html:span class="No-Break">&#13;
      individually customized.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     There are several ways in which Nodes can be created in LlamaIndex, which we will discuss in upcoming subsections. Let’s start with the manual creation&#13;
     <html:span class="No-Break">&#13;
      of Nodes.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:a id="_idTextAnchor051">&#13;
    </html:a>&#13;
    <html:h2 id="_idParaDest-52">&#13;
     Manually creating the Node objects&#13;
    </html:h2>&#13;
    <html:p>&#13;
     Here is a simple example of how&#13;
     <html:a id="_idIndexMarker114">&#13;
     </html:a>&#13;
     we can manually create&#13;
     <html:span class="No-Break">&#13;
      <html:code class="literal">&#13;
       Node&#13;
      </html:code>&#13;
     </html:span>&#13;
     <html:span class="No-Break">&#13;
      objects:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     In this example, we’re using the text-slicing capabilities of Python to manually extract the text for the two Nodes. This manual approach can be very handy when you really want to have full control of both the text of the Nodes and the&#13;
     <html:span class="No-Break">&#13;
      accompanying metadata.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     To understand what’s happening backstage, let’s have a look at the output of&#13;
     <html:span class="No-Break">&#13;
      this code:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p class="callout-heading">&#13;
     Note&#13;
    </html:p>&#13;
    <html:p class="callout">&#13;
     As you can see, the two Nodes contain a randomly generated ID and the segments of text that we have sliced from the original Document. The&#13;
     <html:code class="literal">&#13;
      TextNode&#13;
     </html:code>&#13;
     constructor automatically generated an ID for each node using the Python UUID module. But we can customize that identifier after creating the Nodes if we want to employ a different&#13;
     <html:span class="No-Break">&#13;
      identification scheme.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:a id="_idTextAnchor052">&#13;
    </html:a>&#13;
    <html:h2 id="_idParaDest-53">&#13;
     Automatically extracting Nodes from Documents using splitters&#13;
    </html:h2>&#13;
    <html:p>&#13;
     Because&#13;
     <html:strong class="bold">&#13;
      Document chunking&#13;
     </html:strong>&#13;
     is&#13;
     <html:a id="_idIndexMarker115">&#13;
     </html:a>&#13;
     very important in an RAG workflow, LlamaIndex comes&#13;
     <html:a id="_idIndexMarker116">&#13;
     </html:a>&#13;
     with built-in tools for this&#13;
     <html:a id="_idIndexMarker117">&#13;
     </html:a>&#13;
     purpose. One such&#13;
     <html:a id="_idIndexMarker118">&#13;
     </html:a>&#13;
     tool&#13;
     <html:span class="No-Break">&#13;
      is&#13;
     </html:span>&#13;
     <html:span class="No-Break">&#13;
      <html:code class="literal">&#13;
       TokenTextSplitter&#13;
      </html:code>&#13;
     </html:span>&#13;
     <html:span class="No-Break">&#13;
      .&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     As an example of how we can automatically generate Nodes,&#13;
     <html:code class="literal">&#13;
      TokenTextSplitter&#13;
     </html:code>&#13;
     attempts to split the&#13;
     <html:a id="_idIndexMarker119">&#13;
     </html:a>&#13;
     Document text into chunks that contain whole sentences. Each chunk will include one or more sentences and there’s also a default overlap between the chunks to maintain&#13;
     <html:span class="No-Break">&#13;
      more context.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Under the hood, there are a number of parameters that we can customize on&#13;
     <html:code class="literal">&#13;
      SimpleNodeParser&#13;
     </html:code>&#13;
     such as&#13;
     <html:code class="literal">&#13;
      chunk_size&#13;
     </html:code>&#13;
     and&#13;
     <html:code class="literal">&#13;
      chunk_overlap&#13;
     </html:code>&#13;
     but we will talk about them more and how this text splitter works in the next chapter. For now, let’s have a look at a simple example of how to use&#13;
     <html:code class="literal">&#13;
      TokenTextSplitter&#13;
     </html:code>&#13;
     with its default settings on a&#13;
     <html:span class="No-Break">&#13;
      <html:code class="literal">&#13;
       Document&#13;
      </html:code>&#13;
     </html:span>&#13;
     <html:span class="No-Break">&#13;
      object:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Here&#13;
     <html:a id="_idIndexMarker120">&#13;
     </html:a>&#13;
     is the&#13;
     <html:a id="_idIndexMarker121">&#13;
     </html:a>&#13;
     code&#13;
     <html:a id="_idIndexMarker122">&#13;
     </html:a>&#13;
     output&#13;
     <html:span class="No-Break">&#13;
      this time:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p class="callout-heading">&#13;
     Note&#13;
    </html:p>&#13;
    <html:p class="callout">&#13;
     Given that chunk size is how much content can be processed at a time, if the metadata is too large, it will take up most of the space in each chunk, leaving less room for the actual content text. This can lead to chunks that are mostly metadata with very little actual content. In our example, the warning is triggered because the effective chunk size (the chunk size minus the space taken up by the metadata) results in chunks that would be less than 50 tokens. This is considered too small for&#13;
     <html:span class="No-Break">&#13;
      efficient processing.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     This&#13;
     <html:a id="_idIndexMarker123">&#13;
     </html:a>&#13;
     was just a basic example meant to&#13;
     <html:a id="_idIndexMarker124">&#13;
     </html:a>&#13;
     illustrate an automatic method for&#13;
     <html:a id="_idIndexMarker125">&#13;
     </html:a>&#13;
     chunking the data in separated Nodes. If you look at the metadata of each node, you’ll also notice that it was automatically inherited from the&#13;
     <html:span class="No-Break">&#13;
      originating Document.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p class="callout-heading">&#13;
     Are there any other ways to create Nodes?&#13;
    </html:p>&#13;
    <html:p class="callout">&#13;
     Yes, there are a few other methods. In the next chapter, we’ll go more in-depth with the text-splitting and node-parsing techniques available in LlamaIndex. You will also have the opportunity to understand how they work under the hood and what kind of customization options&#13;
     <html:span class="No-Break">&#13;
      they provide.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     But wait, there’s more to understand&#13;
     <html:span class="No-Break">&#13;
      about Nodes.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:a id="_idTextAnchor053">&#13;
    </html:a>&#13;
    <html:h2 id="_idParaDest-54">&#13;
     Nodes don’t like to be alone – they crave relationships&#13;
    </html:h2>&#13;
    <html:p>&#13;
     Now that&#13;
     <html:a id="_idIndexMarker126">&#13;
     </html:a>&#13;
     we’ve covered some basic examples of how to create&#13;
     <html:a id="_idIndexMarker127">&#13;
     </html:a>&#13;
     simple Nodes, how about adding some relationships&#13;
     <html:span class="No-Break">&#13;
      between them?&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Here’s an example that manually creates a simple relationship between&#13;
     <html:span class="No-Break">&#13;
      two Nodes:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     In this example, we’ve&#13;
     <html:a id="_idIndexMarker128">&#13;
     </html:a>&#13;
     manually created two Nodes and defined a&#13;
     <html:strong class="bold">&#13;
      previous&#13;
     </html:strong>&#13;
     or&#13;
     <html:strong class="bold">&#13;
      next&#13;
     </html:strong>&#13;
     relationship&#13;
     <html:a id="_idIndexMarker129">&#13;
     </html:a>&#13;
     between them. The relationship tracks the order of Nodes within the original Document. This code tells LlamaIndex that the two Nodes belong to the initial Document and they also come in a&#13;
     <html:span class="No-Break">&#13;
      particular order.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     <html:span class="No-Break">&#13;
      <html:em class="italic">&#13;
       Figure 3&#13;
      </html:em>&#13;
     </html:span>&#13;
     <html:em class="italic">&#13;
      .4&#13;
     </html:em>&#13;
     shows exactly what LlamaIndex understands now after we ran&#13;
     <html:span class="No-Break">&#13;
      the code:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:div>&#13;
     <html:div class="IMG---Figure" id="_idContainer031">&#13;
      <html:img src="img/B21861_03_4.jpg"/>&#13;
     </html:div>&#13;
    </html:div>&#13;
    <html:p class="IMG---Caption" lang="en-US">&#13;
     Figure 3.4 – Previous or next relationship between two Nodes&#13;
    </html:p>&#13;
    <html:p class="callout-heading">&#13;
     Note&#13;
    </html:p>&#13;
    <html:p class="callout">&#13;
     You should know that LlamaIndex contains the necessary tools to&#13;
     <html:em class="italic">&#13;
      automatically&#13;
     </html:em>&#13;
     create relationships between the Nodes. For example, when using the automated node parsers discussed previously, in their default configuration, LlamaIndex will automatically create previous or next relationships between the Nodes&#13;
     <html:span class="No-Break">&#13;
      it generates.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     There are other types of relationships that we could define. In addition to simple relationships such as previous or next, Nodes can be connected using&#13;
     <html:span class="No-Break">&#13;
      the following:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:ul>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       SOURCE&#13;
      </html:code>&#13;
      : The&#13;
      <html:strong class="bold">&#13;
       source relationship&#13;
      </html:strong>&#13;
      represents&#13;
      <html:a id="_idIndexMarker130">&#13;
      </html:a>&#13;
      the original source Document that a node was extracted or parsed from. When you parse a Document into multiple Nodes, you can track which Document each node originated from using the&#13;
      <html:span class="No-Break">&#13;
       source relationship.&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       PARENT&#13;
      </html:code>&#13;
      : The&#13;
      <html:strong class="bold">&#13;
       parent relationship&#13;
      </html:strong>&#13;
      indicates a hierarchical structure where the node with this relationship is one level&#13;
      <html:a id="_idIndexMarker131">&#13;
      </html:a>&#13;
      higher than the associated node. In a tree structure, a parent node would have one or more children. This relationship is used to navigate or manage nested data structures where you might have a main node and subordinate Nodes representing sections, paragraphs, or other subdivisions of the&#13;
      <html:span class="No-Break">&#13;
       main node.&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       CHILD&#13;
      </html:code>&#13;
      : This is the opposite of&#13;
      <html:code class="literal">&#13;
       PARENT&#13;
      </html:code>&#13;
      . A node with the&#13;
      <html:strong class="bold">&#13;
       child relationship&#13;
      </html:strong>&#13;
      is a subordinate of another node – the&#13;
      <html:a id="_idIndexMarker132">&#13;
      </html:a>&#13;
      parent. Child Nodes can be&#13;
      <html:a id="_idIndexMarker133">&#13;
      </html:a>&#13;
      seen as the leaves or branches in&#13;
      <html:a id="_idIndexMarker134">&#13;
      </html:a>&#13;
      a tree structure stemming from their&#13;
      <html:span class="No-Break">&#13;
       parent node.&#13;
      </html:span>&#13;
     </html:li>&#13;
    </html:ul>&#13;
    <html:p>&#13;
     But why are relationships important? Let’s discuss why they&#13;
     <html:span class="No-Break">&#13;
      are useful.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:a id="_idTextAnchor054">&#13;
    </html:a>&#13;
    <html:h2 id="_idParaDest-55">&#13;
     Why are relationships important?&#13;
    </html:h2>&#13;
    <html:p>&#13;
     Creating&#13;
     <html:a id="_idIndexMarker135">&#13;
     </html:a>&#13;
     relationships between Nodes in LlamaIndex can be useful for&#13;
     <html:span class="No-Break">&#13;
      several reasons:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:ul>&#13;
     <html:li>&#13;
      <html:strong class="bold">&#13;
       Enables more contextual querying&#13;
      </html:strong>&#13;
      : By linking Nodes together, you can leverage their relationships during querying to retrieve additional relevant context. For example, when querying a node, you could also return the previous or next Nodes to provide&#13;
      <html:span class="No-Break">&#13;
       more context.&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:strong class="bold">&#13;
       Allows tracking provenance&#13;
      </html:strong>&#13;
      : Relationships encode provenance – where source Nodes originated and how they are connected. This is useful when you need to identify the original source of a node&#13;
      <html:span class="No-Break">&#13;
       for example.&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:strong class="bold">&#13;
       Enables navigation through nodes&#13;
      </html:strong>&#13;
      : Traversing Nodes by their relationships enables new types of queries. For example, finding the next node that contains some keyword. Navigation along relationships provides another dimension&#13;
      <html:span class="No-Break">&#13;
       for searching.&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:strong class="bold">&#13;
       Supports the construction of knowledge graphs&#13;
      </html:strong>&#13;
      : Nodes and relationships are the building blocks of knowledge graphs. Linking Nodes into a graph structure allows for constructing knowledge graphs from text using LlamaIndex. We’ll talk more about knowledge graphs during&#13;
      <html:a>&#13;
       <html:span class="No-Break">&#13;
        <html:em class="italic">&#13;
         Chapter 5&#13;
        </html:em>&#13;
       </html:span>&#13;
      </html:a>&#13;
      ,&#13;
      <html:em class="italic">&#13;
       Indexing&#13;
      </html:em>&#13;
      <html:span class="No-Break">&#13;
       <html:em class="italic">&#13;
        with LlamaIndex.&#13;
       </html:em>&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:strong class="bold">&#13;
       Improves the index structure&#13;
      </html:strong>&#13;
      : Some LlamaIndex indexes, such as trees and graphs, utilize node relationships to build their internal structure. Relationships allow the construction of more complex and expressive index topologies. We will discuss this more in&#13;
      <html:a>&#13;
       <html:span class="No-Break">&#13;
        <html:em class="italic">&#13;
         Chapter 5&#13;
        </html:em>&#13;
       </html:span>&#13;
      </html:a>&#13;
      ,&#13;
      <html:em class="italic">&#13;
       Indexing&#13;
      </html:em>&#13;
      <html:span class="No-Break">&#13;
       <html:em class="italic">&#13;
        with LlamaIndex.&#13;
       </html:em>&#13;
      </html:span>&#13;
     </html:li>&#13;
    </html:ul>&#13;
    <html:p>&#13;
     In summary, relationships&#13;
     <html:a id="_idIndexMarker136">&#13;
     </html:a>&#13;
     augment the Nodes with additional contextual connections. This supports more expressive querying, source-tracking knowledge graph construction, and complex&#13;
     <html:span class="No-Break">&#13;
      index structures.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     With raw data ingested as Documents and structured into Nodes that can be queried, the last step is to organize Nodes into&#13;
     <html:span class="No-Break">&#13;
      efficient indexes.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:a id="_idTextAnchor055">&#13;
    </html:a>&#13;
    <html:h2 id="_idParaDest-56">&#13;
     Indexes&#13;
    </html:h2>&#13;
    <html:p>&#13;
     Our third important concept – the&#13;
     <html:a id="_idIndexMarker137">&#13;
     </html:a>&#13;
     index – refers to a specific data structure used to organize a&#13;
     <html:a id="_idIndexMarker138">&#13;
     </html:a>&#13;
     collection of Nodes for optimized storage&#13;
     <html:span class="No-Break">&#13;
      and retrieval.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p class="callout-heading">&#13;
     A simplified analogy&#13;
    </html:p>&#13;
    <html:p class="callout">&#13;
     Getting your data into shape for RAG is kind of like getting your clothes ready for a big trip – you have to make sure everything is organized and accessible! Let’s say you’re packing for an important business trip. You could just throw everything into your suitcase, but your shirts, socks, pants, and other stuff would get mixed up! The problem is that when you want to grab what you need quickly, you may pull out the wrong item and end up inventing an entirely new&#13;
     <html:span class="No-Break">&#13;
      dress code.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     That’s exactly why indexing your data is so crucial when prepping for LLM augmentation. Without indexing, your data is a messy pile of disorganized facts and files, and it’s like digging through a bursting suitcase for a matching pair&#13;
     <html:span class="No-Break">&#13;
      of socks.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Proper indexing neatly sorts information into categories that make sense. For example, our sales records are in one index, and support tickets in another. It’s just like packing related items together. This transforms messy data into neatly organized knowledge that AI can make use of. You go from randomly hunting through a suitcase to grabbing exactly what you need from&#13;
     <html:span class="No-Break">&#13;
      custom pockets.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     So, remember – to avoid frustration and wasted time down the road, put in the work early to index and structure your data. It will make your job much easier down&#13;
     <html:span class="No-Break">&#13;
      the line.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     LlamaIndex supports different types of&#13;
     <html:a id="_idIndexMarker139">&#13;
     </html:a>&#13;
     indexes, each with its strengths and trade-offs. Here is a list of some of the&#13;
     <html:a id="_idIndexMarker140">&#13;
     </html:a>&#13;
     available&#13;
     <html:span class="No-Break">&#13;
      index types:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:ul>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       SummaryIndex&#13;
      </html:code>&#13;
      : This is&#13;
      <html:a id="_idIndexMarker141">&#13;
      </html:a>&#13;
      very similar to a box for recipes – it&#13;
      <html:a id="_idIndexMarker142">&#13;
      </html:a>&#13;
      keeps your Nodes in order, so you can access them one by one. It takes in a set of documents, chunks them up into Nodes, and then concatenates them into a list. It’s great for reading through a&#13;
      <html:span class="No-Break">&#13;
       big Document.&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       DocumentSummaryIndex&#13;
      </html:code>&#13;
      : This constructs a concise summary for each document, mapping these&#13;
      <html:a id="_idIndexMarker143">&#13;
      </html:a>&#13;
      summaries back to&#13;
      <html:a id="_idIndexMarker144">&#13;
      </html:a>&#13;
      their respective nodes. It facilitates efficient information retrieval by using these summaries to quickly identify&#13;
      <html:span class="No-Break">&#13;
       relevant documents.&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       VectorStoreIndex&#13;
      </html:code>&#13;
      : This is one of the more sophisticated types of indexes and probably the workhorse&#13;
      <html:a id="_idIndexMarker145">&#13;
      </html:a>&#13;
      in most RAG applications. It converts&#13;
      <html:a id="_idIndexMarker146">&#13;
      </html:a>&#13;
      text into vector embeddings and uses math to group similar Nodes, helping locate Nodes that&#13;
      <html:span class="No-Break">&#13;
       are alike.&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       TreeIndex&#13;
      </html:code>&#13;
      : The&#13;
      <html:a id="_idIndexMarker147">&#13;
      </html:a>&#13;
      perfect solution for those who love order. This index&#13;
      <html:a id="_idIndexMarker148">&#13;
      </html:a>&#13;
      behaves similarly to putting smaller boxes inside bigger ones, organizing Nodes by levels in a tree-like structure. Inside, each parent node stores summaries of the children nodes. These are generated by the LLM, using a general summarization prompt. This particular index can be very useful&#13;
      <html:span class="No-Break">&#13;
       for summarization.&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       KeywordTableIndex&#13;
      </html:code>&#13;
      : Imagine you need to find a dish by the ingredients you have. The&#13;
      <html:a id="_idIndexMarker149">&#13;
      </html:a>&#13;
      keyword index&#13;
      <html:a id="_idIndexMarker150">&#13;
      </html:a>&#13;
      connects important words to the Nodes they’re in. It makes finding any node easy by looking&#13;
      <html:span class="No-Break">&#13;
       up keywords.&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       KnowledgeGraphIndex&#13;
      </html:code>&#13;
      : This is useful when you need to link facts in a big network of data stored as a&#13;
      <html:a id="_idIndexMarker151">&#13;
      </html:a>&#13;
      knowledge graph. This&#13;
      <html:a id="_idIndexMarker152">&#13;
      </html:a>&#13;
      one is good for answering tricky questions about lots of&#13;
      <html:span class="No-Break">&#13;
       connected information.&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       ComposableGraph&#13;
      </html:code>&#13;
      : This allows you to&#13;
      <html:a id="_idIndexMarker153">&#13;
      </html:a>&#13;
      create complex index&#13;
      <html:a id="_idIndexMarker154">&#13;
      </html:a>&#13;
      structures in which Document-level indexes are indexed in higher-level collections. That’s right: you can even build an index of indexes if you want to access the data from multiple Documents in a larger collection&#13;
      <html:span class="No-Break">&#13;
       of Documents.&#13;
      </html:span>&#13;
     </html:li>&#13;
    </html:ul>&#13;
    <html:p>&#13;
     We’ll talk more about the inner workings of these&#13;
     <html:a id="_idIndexMarker155">&#13;
     </html:a>&#13;
     indexes and other variations in&#13;
     <html:a>&#13;
      <html:span class="No-Break">&#13;
       <html:em class="italic">&#13;
        Chapter 5&#13;
       </html:em>&#13;
      </html:span>&#13;
     </html:a>&#13;
     ,&#13;
     <html:em class="italic">&#13;
      Indexing with LlamaIndex&#13;
     </html:em>&#13;
     . This is just an overview of&#13;
     <html:span class="No-Break">&#13;
      the topic.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     All the index types&#13;
     <html:a id="_idIndexMarker156">&#13;
     </html:a>&#13;
     in LlamaIndex share some&#13;
     <html:a id="_idIndexMarker157">&#13;
     </html:a>&#13;
     common&#13;
     <html:span class="No-Break">&#13;
      core features:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:ul>&#13;
     <html:li>&#13;
      <html:strong class="bold">&#13;
       Building the index&#13;
      </html:strong>&#13;
      : Each index type can be constructed by passing in a set of Nodes during initialization. This builds the underlying&#13;
      <html:span class="No-Break">&#13;
       index structure.&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:strong class="bold">&#13;
       Inserting new Nodes&#13;
      </html:strong>&#13;
      : After an index is built, new Nodes can be manually inserted. This adds to the existing&#13;
      <html:span class="No-Break">&#13;
       index structure.&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:strong class="bold">&#13;
       Querying the index&#13;
      </html:strong>&#13;
      : Once built, indexes provide a query interface to retrieve relevant Nodes based on a specific query. The retrieval logic varies by&#13;
      <html:span class="No-Break">&#13;
       index type.&#13;
      </html:span>&#13;
     </html:li>&#13;
    </html:ul>&#13;
    <html:p>&#13;
     The specifics of index structure and querying differ across index types. But this building, inserting, and querying pattern is consistent. Understanding the particular features of each index type is really important if you want to exploit their full potential. During&#13;
     <html:a>&#13;
      <html:span class="No-Break">&#13;
       <html:em class="italic">&#13;
        Chapter 5&#13;
       </html:em>&#13;
      </html:span>&#13;
     </html:a>&#13;
     ,&#13;
     <html:em class="italic">&#13;
      Indexing with LlamaIndex&#13;
     </html:em>&#13;
     , we will cover this topic in much more detail and I will give you specific examples for each type&#13;
     <html:span class="No-Break">&#13;
      of index.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     For now, let’s consider a simple example to illustrate the creation&#13;
     <html:span class="No-Break">&#13;
      of&#13;
     </html:span>&#13;
     <html:span class="No-Break">&#13;
      <html:code class="literal">&#13;
       SummaryIndex&#13;
      </html:code>&#13;
     </html:span>&#13;
     <html:span class="No-Break">&#13;
      :&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     This is very&#13;
     <html:a id="_idIndexMarker158">&#13;
     </html:a>&#13;
     simple to follow. We first defined a set of Nodes containing the data and then created&#13;
     <html:code class="literal">&#13;
      SummaryIndex&#13;
     </html:code>&#13;
     based on these Nodes. This index is a simple list-based&#13;
     <html:span class="No-Break">&#13;
      data structure.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Think of&#13;
     <html:code class="literal">&#13;
      SummaryIndex&#13;
     </html:code>&#13;
     as a&#13;
     <html:a id="_idIndexMarker159">&#13;
     </html:a>&#13;
     little notepad where you jot down points from lots of stories. When it’s getting set up, it takes a big bunch of stories, breaks them into smaller bits, and lines them up in a list. The best part? LlamaIndex doesn’t even need to use the LLM when it builds this type&#13;
     <html:span class="No-Break">&#13;
      of index.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:a id="_idTextAnchor056">&#13;
    </html:a>&#13;
    <html:h2 id="_idParaDest-57">&#13;
     Are we there yet?&#13;
    </html:h2>&#13;
    <html:p>&#13;
     Almost. Indexes are&#13;
     <html:a id="_idIndexMarker160">&#13;
     </html:a>&#13;
     great for&#13;
     <html:a id="_idIndexMarker161">&#13;
     </html:a>&#13;
     organizing&#13;
     <html:a id="_idIndexMarker162">&#13;
     </html:a>&#13;
     data, but how do we get answers from them? That’s where&#13;
     <html:strong class="bold">&#13;
      retrievers&#13;
     </html:strong>&#13;
     and&#13;
     <html:strong class="bold">&#13;
      response synthesizers&#13;
     </html:strong>&#13;
     <html:span class="No-Break">&#13;
      come in!&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Let’s use the Lionel Messi index we just created as an example. Say you ask, “What is Messi’s hometown?” See&#13;
     <html:span class="No-Break">&#13;
      the following:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     This is&#13;
     <html:span class="No-Break">&#13;
      the output:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     The summary&#13;
     <html:a id="_idIndexMarker163">&#13;
     </html:a>&#13;
     index organizes all Nodes sequentially in&#13;
     <html:span class="No-Break">&#13;
      a list.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     When queried, it retrieves all Nodes, allowing the synthesis of a response with&#13;
     <html:span class="No-Break">&#13;
      full context.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:a id="_idTextAnchor057">&#13;
    </html:a>&#13;
    <html:h2 id="_idParaDest-58">&#13;
     How does this actually work under the hood?&#13;
    </html:h2>&#13;
    <html:p>&#13;
     <html:code class="literal">&#13;
      QueryEngine&#13;
     </html:code>&#13;
     contains&#13;
     <html:a id="_idIndexMarker164">&#13;
     </html:a>&#13;
     a retriever, which is responsible for retrieving relevant Nodes from the index for the query. The retriever does a lookup to fetch and rank relevant Nodes from the index for that query. It grabs Nodes from the index that are likely to contain information about&#13;
     <html:span class="No-Break">&#13;
      Messi’s hometown.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     But just getting back a list of Nodes isn’t very useful. Another part of&#13;
     <html:code class="literal">&#13;
      QueryEngine&#13;
     </html:code>&#13;
     called&#13;
     <html:a id="_idIndexMarker165">&#13;
     </html:a>&#13;
     the&#13;
     <html:strong class="bold">&#13;
      node postprocessor&#13;
     </html:strong>&#13;
     comes into play at this point. This part enables the transformation, re-ranking, or filtering of Nodes after they’ve been retrieved and before the final response is crafted. There are many types of postprocessors available, and each can be configured and customized depending on the&#13;
     <html:span class="No-Break">&#13;
      use case.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     The&#13;
     <html:code class="literal">&#13;
      QueryEngine&#13;
     </html:code>&#13;
     object also contains a response synthesizer, which takes the retrieved Nodes and crafts the final response using the LLM by performing the&#13;
     <html:span class="No-Break">&#13;
      following steps:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:ol>&#13;
     <html:li>&#13;
      The response synthesizer takes the Nodes selected by the retriever and processed by the node postprocessor and formats them into an&#13;
      <html:span class="No-Break">&#13;
       LLM prompt.&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      The prompt contains the query along with context from&#13;
      <html:span class="No-Break">&#13;
       the Nodes.&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      This prompt is given to the LLM to generate&#13;
      <html:span class="No-Break">&#13;
       a response.&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      Any necessary postprocessing is done on the raw response using the LLM to return the final natural&#13;
      <html:span class="No-Break">&#13;
       language answer.&#13;
      </html:span>&#13;
     </html:li>&#13;
    </html:ol>&#13;
    <html:p>&#13;
     So,&#13;
     <html:code class="literal">&#13;
      index.as_query_engine()&#13;
     </html:code>&#13;
     is creating&#13;
     <html:a id="_idIndexMarker166">&#13;
     </html:a>&#13;
     a full query engine for us, containing a default version of the three elements: retriever, node postprocessor, and&#13;
     <html:span class="No-Break">&#13;
      response synthesizer.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     We’ll get into a lot more detail on these three elements in&#13;
     <html:em class="italic">&#13;
      Chapters 6&#13;
     </html:em>&#13;
     <html:span class="No-Break">&#13;
      and&#13;
     </html:span>&#13;
     <html:span class="No-Break">&#13;
      <html:em class="italic">&#13;
       7&#13;
      </html:em>&#13;
     </html:span>&#13;
     <html:span class="No-Break">&#13;
      .&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     The final result of running this engine will be a natural language answer such as&#13;
     <html:code class="literal">&#13;
      Messi's hometown&#13;
     </html:code>&#13;
     <html:span class="No-Break">&#13;
      <html:code class="literal">&#13;
       is Rosario&#13;
      </html:code>&#13;
     </html:span>&#13;
     <html:span class="No-Break">&#13;
      .&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p class="callout-heading">&#13;
     Remember&#13;
    </html:p>&#13;
    <html:p class="callout">&#13;
     This is just a basic example using a particular type of index called&#13;
     <html:code class="literal">&#13;
      SummaryIndex&#13;
     </html:code>&#13;
     . Each index type behaves differently as we will discuss in&#13;
     <html:a>&#13;
      <html:span class="No-Break">&#13;
       <html:em class="italic">&#13;
        Chapter 5&#13;
       </html:em>&#13;
      </html:span>&#13;
     </html:a>&#13;
     . For example: a&#13;
     <html:code class="literal">&#13;
      TreeIndex&#13;
     </html:code>&#13;
     arranges Nodes in a hierarchy, allowing for summarization and a&#13;
     <html:code class="literal">&#13;
      KeywordIndex&#13;
     </html:code>&#13;
     maps keywords for fast lookup. The index structure impacts performance and determines its best use cases. By itself, the index structure defines the data management logic. As we have seen, the index needs to be combined with a retriever, postprocessor, and response synthesizer to form a complete query pipeline, allowing applications to leverage the&#13;
     <html:span class="No-Break">&#13;
      indexed data.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     More details will be added in the upcoming chapters. But, at this point, you should have a high-level idea of Indexes and&#13;
     <html:span class="No-Break">&#13;
      their role.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Let’s have a look at&#13;
     <html:span class="No-Break">&#13;
      <html:em class="italic">&#13;
       Figure 3&#13;
      </html:em>&#13;
     </html:span>&#13;
     <html:em class="italic">&#13;
      .5&#13;
     </html:em>&#13;
     for an overview of the&#13;
     <html:span class="No-Break">&#13;
      complete flow.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:div>&#13;
     <html:div class="IMG---Figure" id="_idContainer032">&#13;
      <html:img src="img/B21861_03_5.jpg"/>&#13;
     </html:div>&#13;
    </html:div>&#13;
    <html:p class="IMG---Caption" lang="en-US">&#13;
     Figure 3.5 – The complete RAG workflow with LlamaIndex&#13;
    </html:p>&#13;
    <html:p>&#13;
     As shown in&#13;
     <html:span class="No-Break">&#13;
      <html:em class="italic">&#13;
       Figure 3&#13;
      </html:em>&#13;
     </html:span>&#13;
     <html:em class="italic">&#13;
      .5&#13;
     </html:em>&#13;
     , the process&#13;
     <html:a id="_idIndexMarker167">&#13;
     </html:a>&#13;
     involves the&#13;
     <html:span class="No-Break">&#13;
      following steps:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:ol>&#13;
     <html:li>&#13;
      Loading data&#13;
      <html:span class="No-Break">&#13;
       as Documents&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      Parsing Documents into&#13;
      <html:span class="No-Break">&#13;
       coherent Nodes&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      Building an optimized index&#13;
      <html:span class="No-Break">&#13;
       from Nodes&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      Running queries over the index to retrieve&#13;
      <html:span class="No-Break">&#13;
       relevant Nodes&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      Synthesizing the&#13;
      <html:span class="No-Break">&#13;
       final response&#13;
      </html:span>&#13;
     </html:li>&#13;
    </html:ol>&#13;
    <html:p>&#13;
     Too much to remember? Let’s recap the building blocks&#13;
     <html:span class="No-Break">&#13;
      of LlamaIndex.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:a id="_idTextAnchor058">&#13;
    </html:a>&#13;
    <html:h2 id="_idParaDest-59">&#13;
     A quick recap of the key concepts&#13;
    </html:h2>&#13;
    <html:p>&#13;
     Here is a quick rundown of what we have covered&#13;
     <html:span class="No-Break">&#13;
      so far:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:ul>&#13;
     <html:li>&#13;
      <html:strong class="bold">&#13;
       Documents&#13;
      </html:strong>&#13;
      : The&#13;
      <html:a id="_idIndexMarker168">&#13;
      </html:a>&#13;
      raw&#13;
      <html:span class="No-Break">&#13;
       data ingested&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:strong class="bold">&#13;
       Nodes&#13;
      </html:strong>&#13;
      : Logical&#13;
      <html:a id="_idIndexMarker169">&#13;
      </html:a>&#13;
      chunks extracted&#13;
      <html:span class="No-Break">&#13;
       from Documents&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:strong class="bold">&#13;
       Indexes&#13;
      </html:strong>&#13;
      : Data&#13;
      <html:a id="_idIndexMarker170">&#13;
      </html:a>&#13;
      structures organizing Nodes based on&#13;
      <html:span class="No-Break">&#13;
       use case&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:strong class="bold">&#13;
       QueryEngine&#13;
      </html:strong>&#13;
      : This&#13;
      <html:a id="_idIndexMarker171">&#13;
      </html:a>&#13;
      contains a retriever, node postprocessor, and&#13;
      <html:span class="No-Break">&#13;
       response synthesizer&#13;
      </html:span>&#13;
     </html:li>&#13;
    </html:ul>&#13;
    <html:p>&#13;
     Understanding these building blocks is crucial for working with LlamaIndex. They allow you to effectively structure and connect external data&#13;
     <html:span class="No-Break">&#13;
      to LLMs.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Now, you have a conceptual foundation. Next, let’s solidify this knowledge by looking at a simplified workflow model and building an&#13;
     <html:span class="No-Break">&#13;
      actual application.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:a id="_idTextAnchor059">&#13;
    </html:a>&#13;
   </html:div>&#13;
  </html:div>&#13;
 </html:body>&#13;
</html:html>
<html:html>&#13;
 <html:head>&#13;
  <html:title>&#13;
   Building our first interactive, augmented LLM application&#13;
  </html:title>&#13;
 </html:head>&#13;
 <html:body>&#13;
  <html:div class="epub-source">&#13;
   <html:h1 id="_idParaDest-60">&#13;
    Building our first interactive, augmented LLM application&#13;
   </html:h1>&#13;
   <html:div id="_idContainer034">&#13;
    from llama_index.core import Document, SummaryIndex&#13;
from llama_index.core.node_parser import SimpleNodeParser&#13;
from llama_index.readers.wikipedia import WikipediaReader&#13;
loader = WikipediaReader()&#13;
documents = loader.load_data(pages=["Messi Lionel"])&#13;
parser = SimpleNodeParser.from_defaults()&#13;
nodes = parser.get_nodes_from_documents(documents)&#13;
index = SummaryIndex(nodes)&#13;
query_engine = index.as_query_engine()&#13;
print("Ask me anything about Lionel Messi!")&#13;
while True:&#13;
    question = input("Your question: ")&#13;
    if question.lower() == "exit":&#13;
        break&#13;
    response = query_engine.query(question)&#13;
    print(response)&#13;
    import logging&#13;
logging.basicConfig(level=logging.DEBUG)&#13;
    from llama_index.llms.openai import OpenAI&#13;
from llama_index.core.settings import Settings&#13;
Settings.llm = OpenAI(temperature=0.8, model="gpt-4")&#13;
    from llama_index.core.schema import TextNode&#13;
from llama_index.core import SummaryIndex&#13;
nodes = [&#13;
    TextNode(text="Lionel Messi's hometown is Rosario."),&#13;
    TextNode(text="He was born on June 24, 1987.")&#13;
]&#13;
index = SummaryIndex(nodes)&#13;
query_engine = index.as_query_engine()&#13;
response = query_engine.query(&#13;
    "What is Messi's hometown?"&#13;
)&#13;
print(response)&#13;
    from llama_index.llms.openai import OpenAI&#13;
llm = OpenAI(&#13;
    model="gpt-3.5-turbo-1106",&#13;
    temperature=0.2,&#13;
    max_tokens=50,&#13;
    additional_kwargs={&#13;
        "seed": 12345678,&#13;
        "top_p": 0.5&#13;
    }&#13;
)&#13;
response = llm.complete(&#13;
    "Explain the concept of gravity in one sentence"&#13;
)&#13;
print(response)&#13;
    <html:p>&#13;
     It’s time to connect the dots&#13;
     <html:a id="_idIndexMarker172">&#13;
     </html:a>&#13;
     and do something practical with all this knowledge. If we put all the previous code together, we can now build our first&#13;
     <html:span class="No-Break">&#13;
      LlamaIndex application.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     For this next step, make sure you’ve already taken care of the technical requirements mentioned at the beginning of the chapter. For the following code example, we’ll need the Wikipedia package to be able to parse a certain Wikipedia article and extract our sample data&#13;
     <html:span class="No-Break">&#13;
      from there.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Once the Wikipedia package has been successfully installed, the sample app should run without issues. Here is&#13;
     <html:span class="No-Break">&#13;
      the code:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     It should be noted that this&#13;
     <html:a id="_idIndexMarker173">&#13;
     </html:a>&#13;
     does not function as a genuine chat system because it does not retain the context of the conversation. It could be more accurately described as a simple&#13;
     <html:span class="No-Break">&#13;
      Q&amp;A system.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Here’s a quick walk-through for&#13;
     <html:span class="No-Break">&#13;
      the code:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:ol>&#13;
     <html:li>&#13;
      We start by loading a Wikipedia page on Lionel Messi as a Document using the&#13;
      <html:code class="literal">&#13;
       WikipediaReader&#13;
      </html:code>&#13;
      data loader. This ingests the raw&#13;
      <html:span class="No-Break">&#13;
       text data&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      Next, we parse the Document into smaller Node chunks using&#13;
      <html:code class="literal">&#13;
       SimpleNodeParser&#13;
      </html:code>&#13;
      . This splits the text into&#13;
      <html:span class="No-Break">&#13;
       logical segments&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      We then build&#13;
      <html:code class="literal">&#13;
       SummaryIndex&#13;
      </html:code>&#13;
      from the Nodes. This organizes the Nodes sequentially for full&#13;
      <html:span class="No-Break">&#13;
       context retrieval&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      We define&#13;
      <html:code class="literal">&#13;
       QueryEngine&#13;
      </html:code>&#13;
      , forming a complete&#13;
      <html:span class="No-Break">&#13;
       query pipeline&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      Finally, we create a loop that queries the index, passing our question to&#13;
      <html:code class="literal">&#13;
       QueryEngine&#13;
      </html:code>&#13;
      . This handles retrieving relevant Nodes, prompting the LLM, and returning the&#13;
      <html:span class="No-Break">&#13;
       final response&#13;
      </html:span>&#13;
     </html:li>&#13;
    </html:ol>&#13;
    <html:p>&#13;
     Again, you can have a look at&#13;
     <html:span class="No-Break">&#13;
      <html:em class="italic">&#13;
       Figure 3&#13;
      </html:em>&#13;
     </html:span>&#13;
     <html:em class="italic">&#13;
      .5&#13;
     </html:em>&#13;
     to visualize the overall workflow – ingesting data, parsing it into Nodes, building an index, and querying it to retrieve and synthesize the&#13;
     <html:span class="No-Break">&#13;
      final answer.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     But what if we want to know exactly what happens behind&#13;
     <html:span class="No-Break">&#13;
      the scenes?&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:a id="_idTextAnchor060">&#13;
    </html:a>&#13;
    <html:h2 id="_idParaDest-61">&#13;
     Using the logging features of LlamaIndex to understand the logic and debug our applications&#13;
    </html:h2>&#13;
    <html:p>&#13;
     When you run code&#13;
     <html:a id="_idIndexMarker174">&#13;
     </html:a>&#13;
     like in our previous example, you might feel like there’s some&#13;
     <html:em class="italic">&#13;
      magic&#13;
     </html:em>&#13;
     happening behind the scenes. You pass in some text, call a simple indexing method, and boom – you can start querying an AI assistant powered by your&#13;
     <html:span class="No-Break">&#13;
      own data.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     But as your applications get more complex, you’ll want to understand exactly how LlamaIndex is doing its thing under the hood. This is where&#13;
     <html:strong class="bold">&#13;
      logging&#13;
     </html:strong>&#13;
     becomes important. LlamaIndex provides&#13;
     <html:a id="_idIndexMarker175">&#13;
     </html:a>&#13;
     tons of helpful log statements that show you step-by-step what’s going on during indexing and querying. It’s like having a little debug narrator describing&#13;
     <html:span class="No-Break">&#13;
      each action.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Enabling basic logging is as simple as adding&#13;
     <html:span class="No-Break">&#13;
      this code:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     With debug logging enabled, you’ll see how LlamaIndex does things, such as&#13;
     <html:span class="No-Break">&#13;
      the following:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:ul>&#13;
     <html:li>&#13;
      Parses your Documents&#13;
      <html:span class="No-Break">&#13;
       into Nodes&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      Decide which indexing structure&#13;
      <html:span class="No-Break">&#13;
       to use&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      Formats prompts for&#13;
      <html:span class="No-Break">&#13;
       the LLM&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      Retrieves relevant Nodes based on&#13;
      <html:span class="No-Break">&#13;
       your queries&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      Synthesizes a response from&#13;
      <html:span class="No-Break">&#13;
       the Nodes&#13;
      </html:span>&#13;
     </html:li>&#13;
    </html:ul>&#13;
    <html:p>&#13;
     As we’ll see in the next chapters, logging also reveals useful data such as&#13;
     <html:span class="No-Break">&#13;
      the following:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:ul>&#13;
     <html:li>&#13;
      The number of tokens used for&#13;
      <html:span class="No-Break">&#13;
       API calls&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:span class="No-Break">&#13;
       Latency information&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      Any warnings&#13;
      <html:span class="No-Break">&#13;
       or errors&#13;
      </html:span>&#13;
     </html:li>&#13;
    </html:ul>&#13;
    <html:p class="callout-heading">&#13;
     Note&#13;
    </html:p>&#13;
    <html:p class="callout">&#13;
     When things aren’t working as expected, don’t panic! Just check the logs. They provide crucial clues for identifying issues. For now, using the basic logging feature should do fine. With this feature enabled, most of the backstage activities will now be displayed during run time so you’ll be able to monitor the flow of your app step by step. We’ll talk more about advanced debugging during&#13;
     <html:a>&#13;
      <html:span class="No-Break">&#13;
       <html:em class="italic">&#13;
        Chapter 9&#13;
       </html:em>&#13;
      </html:span>&#13;
     </html:a>&#13;
     ,&#13;
     <html:em class="italic">&#13;
      Customizing and Deploying Our&#13;
     </html:em>&#13;
     <html:span class="No-Break">&#13;
      <html:em class="italic">&#13;
       LlamaIndex Project&#13;
      </html:em>&#13;
     </html:span>&#13;
     <html:span class="No-Break">&#13;
      .&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Now, how about&#13;
     <html:span class="No-Break">&#13;
      some tweaking?&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:a id="_idTextAnchor061">&#13;
    </html:a>&#13;
    <html:h2 id="_idParaDest-62">&#13;
     Customizing the LLM used by LlamaIndex&#13;
    </html:h2>&#13;
    <html:p>&#13;
     Let’s say we&#13;
     <html:a id="_idIndexMarker176">&#13;
     </html:a>&#13;
     would like to configure the framework to use another LLM. By default, LlamaIndex uses the OpenAI API with&#13;
     <html:a id="_idIndexMarker177">&#13;
     </html:a>&#13;
     the&#13;
     <html:strong class="bold">&#13;
      GPT-3.5-Turbo&#13;
     </html:strong>&#13;
     model. Here’s an overview&#13;
     <html:a id="_idIndexMarker178">&#13;
     </html:a>&#13;
     of the key features&#13;
     <html:span class="No-Break">&#13;
      of GPT-3.5-Turbo:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:ul>&#13;
     <html:li>&#13;
      It’s faster and cheaper to run compared&#13;
      <html:a id="_idIndexMarker179">&#13;
      </html:a>&#13;
      <html:span class="No-Break">&#13;
       to&#13;
      </html:span>&#13;
      <html:span class="No-Break">&#13;
       <html:strong class="bold">&#13;
        GPT-4&#13;
       </html:strong>&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      While not as advanced as other models, such as GPT-4, it’s still a very capable generative and&#13;
      <html:span class="No-Break">&#13;
       conversational model&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      It can perform very well on a variety&#13;
      <html:a id="_idIndexMarker180">&#13;
      </html:a>&#13;
      of&#13;
      <html:strong class="bold">&#13;
       natural language processing&#13;
      </html:strong>&#13;
      (&#13;
      <html:strong class="bold">&#13;
       NLP&#13;
      </html:strong>&#13;
      ) tasks such as classification, summarization,&#13;
      <html:span class="No-Break">&#13;
       or translation&#13;
      </html:span>&#13;
     </html:li>&#13;
    </html:ul>&#13;
    <html:p>&#13;
     You can see why the creators of LlamaIndex have chosen this model. All things considered, it provides a good balance of performance and cost for most use cases. For most applications, it’s probably sufficient. As you have seen already if you’ve tested the application, it handles the questions about Lionel Messi&#13;
     <html:span class="No-Break">&#13;
      pretty well.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     But what if we need to customize that for a more specific case? Let’s say we need the best possible performance of GPT-4, the larger context provided&#13;
     <html:a id="_idIndexMarker181">&#13;
     </html:a>&#13;
     by&#13;
     <html:strong class="bold">&#13;
      Claude-2&#13;
     </html:strong>&#13;
     , or maybe we want to use an open-source AI for&#13;
     <html:span class="No-Break">&#13;
      our purposes.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:a id="_idTextAnchor062">&#13;
    </html:a>&#13;
    <html:h2 id="_idParaDest-63">&#13;
     Easy as 1-2-3&#13;
    </html:h2>&#13;
    <html:p>&#13;
     We&#13;
     <html:a id="_idIndexMarker182">&#13;
     </html:a>&#13;
     only need to add three lines of code at the beginning of&#13;
     <html:span class="No-Break">&#13;
      our app:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Make sure you add the&#13;
     <html:code class="literal">&#13;
      Settings.llm&#13;
     </html:code>&#13;
     line immediately after your imports so that it applies to all the other operations. Here’s the explanation for&#13;
     <html:span class="No-Break">&#13;
      each step:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:ol>&#13;
     <html:li>&#13;
      The first line imports the OpenAI class from&#13;
      <html:code class="literal">&#13;
       llama_index.llms.openai&#13;
      </html:code>&#13;
      so that we can use it to initialize an&#13;
      <html:span class="No-Break">&#13;
       OpenAI LLM&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      The second import is responsible for the&#13;
      <html:code class="literal">&#13;
       Settings&#13;
      </html:code>&#13;
      class. We’ll use it to customize&#13;
      <html:span class="No-Break">&#13;
       the LLM&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      Next, we configure&#13;
      <html:code class="literal">&#13;
       Settings&#13;
      </html:code>&#13;
      with an OpenAI LLM instance using the GPT-4 model and set the&#13;
      <html:code class="literal">&#13;
       temperature&#13;
      </html:code>&#13;
      to&#13;
      <html:code class="literal">&#13;
       0.8&#13;
      </html:code>&#13;
      , overriding the&#13;
      <html:span class="No-Break">&#13;
       default LLM&#13;
      </html:span>&#13;
     </html:li>&#13;
    </html:ol>&#13;
    <html:p>&#13;
     We just configured LlamaIndex to use GPT-4 for all operations instead of the default GPT-3.5-Turbo model. The next part of the code will build an index and run a simple query&#13;
     <html:a id="_idIndexMarker183">&#13;
     </html:a>&#13;
     using the newly&#13;
     <html:span class="No-Break">&#13;
      configured LLM:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Next, we need to talk about the&#13;
     <html:span class="No-Break">&#13;
      <html:code class="literal">&#13;
       temperature&#13;
      </html:code>&#13;
     </html:span>&#13;
     <html:span class="No-Break">&#13;
      parameter.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:a id="_idTextAnchor063">&#13;
    </html:a>&#13;
    <html:h2 id="_idParaDest-64">&#13;
     The temperature parameter&#13;
    </html:h2>&#13;
    <html:p>&#13;
     On OpenAI models such as&#13;
     <html:a id="_idIndexMarker184">&#13;
     </html:a>&#13;
     GPT-3.5 and GPT-4, this parameter controls the randomness and creativity of the AI’s responses. Check out&#13;
     <html:span class="No-Break">&#13;
      <html:em class="italic">&#13;
       Figure 3&#13;
      </html:em>&#13;
     </html:span>&#13;
     <html:em class="italic">&#13;
      .6&#13;
     </html:em>&#13;
     for&#13;
     <html:span class="No-Break">&#13;
      an overview:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:div>&#13;
     <html:div class="IMG---Figure" id="_idContainer033">&#13;
      <html:img src="img/B21861_03_6.jpg"/>&#13;
     </html:div>&#13;
    </html:div>&#13;
    <html:p class="IMG---Caption" lang="en-US">&#13;
     Figure 3.6 – Effect of temperature on output variability&#13;
    </html:p>&#13;
    <html:p>&#13;
     The&#13;
     <html:code class="literal">&#13;
      temperature&#13;
     </html:code>&#13;
     values for the OpenAI models range from&#13;
     <html:code class="literal">&#13;
      0&#13;
     </html:code>&#13;
     to&#13;
     <html:code class="literal">&#13;
      2&#13;
     </html:code>&#13;
     . Higher values produce more random, creative output. Lower values produce more focused,&#13;
     <html:span class="No-Break">&#13;
      deterministic output.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     A&#13;
     <html:code class="literal">&#13;
      temperature&#13;
     </html:code>&#13;
     value of&#13;
     <html:code class="literal">&#13;
      0&#13;
     </html:code>&#13;
     will produce almost the same output every time for the same input prompt. You noticed that I’ve used the word “almost.” That is because even with the&#13;
     <html:code class="literal">&#13;
      0&#13;
     </html:code>&#13;
     setting, most models will probably still produce slight answer variations given the same prompt. This is caused by inherent randomness in the model’s initialization or subtle variations in the model’s internal state that can occur due to factors such as floating-point precision limitations or the stochastic nature of certain operations within the neural network. Even with a&#13;
     <html:code class="literal">&#13;
      temperature&#13;
     </html:code>&#13;
     value of&#13;
     <html:code class="literal">&#13;
      0&#13;
     </html:code>&#13;
     , which aims to minimize randomness, these small variations can lead to slightly different outputs for&#13;
     <html:span class="No-Break">&#13;
      identical inputs.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Setting the right&#13;
     <html:code class="literal">&#13;
      temperature&#13;
     </html:code>&#13;
     depends on your use case – whether you want responses strongly based on factual data or more imaginative ones. For code generation or data analysis tasks, a&#13;
     <html:code class="literal">&#13;
      temperature&#13;
     </html:code>&#13;
     value of&#13;
     <html:code class="literal">&#13;
      0.2&#13;
     </html:code>&#13;
     would be appropriate, while more creativity-focused tasks such as writing or chatbot responses would benefit from a setting of&#13;
     <html:code class="literal">&#13;
      0.5&#13;
     </html:code>&#13;
     <html:span class="No-Break">&#13;
      and higher.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p class="callout-heading">&#13;
     Note&#13;
    </html:p>&#13;
    <html:p class="callout">&#13;
     If you have a use case that really requires consistent responses for multiple iterations using the same prompt, here’s some practical advice. In my experimental research, I have achieved the most consistent results using the GPT-3.5-Turbo-1106 model with a&#13;
     <html:code class="literal">&#13;
      temperature&#13;
     </html:code>&#13;
     value&#13;
     <html:span class="No-Break">&#13;
      of&#13;
     </html:span>&#13;
     <html:span class="No-Break">&#13;
      <html:code class="literal">&#13;
       0&#13;
      </html:code>&#13;
     </html:span>&#13;
     <html:span class="No-Break">&#13;
      .&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Apart from&#13;
     <html:code class="literal">&#13;
      temperature&#13;
     </html:code>&#13;
     , there are several other parameters you can tune by passing them as a dictionary to the&#13;
     <html:code class="literal">&#13;
      additional_kwargs&#13;
     </html:code>&#13;
     argument. If you plan on using OpenAI models in your RAG workflow, I advise you to familiarize yourself with these LLM settings, as they can be very important in an RAG scenario. Apart from&#13;
     <html:code class="literal">&#13;
      temperature&#13;
     </html:code>&#13;
     , the&#13;
     <html:code class="literal">&#13;
      top_p&#13;
     </html:code>&#13;
     and&#13;
     <html:code class="literal">&#13;
      seed&#13;
     </html:code>&#13;
     parameters are particularly useful as they can be leveraged to control the randomness of the outputs. For a detailed list, you can consult the official OpenAI documentation&#13;
     <html:span class="No-Break">&#13;
      here:&#13;
     </html:span>&#13;
     <html:a>&#13;
      <html:span class="No-Break">&#13;
       https://platform.openai.com/docs/models&#13;
      </html:span>&#13;
     </html:a>&#13;
     <html:span class="No-Break">&#13;
      .&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Here’s a simple&#13;
     <html:a id="_idIndexMarker185">&#13;
     </html:a>&#13;
     playground that you could use for experimenting with different&#13;
     <html:span class="No-Break">&#13;
      LLM settings:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Using the previous code, you can experiment with different settings, examining the output and finding the best configuration for your particular&#13;
     <html:span class="No-Break">&#13;
      use case.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     If you are wondering what different LLMs available right now can do for your RAG purposes, here is a side-by-side comparison extracted from the LlamaIndex documentation. This list&#13;
     <html:a id="_idIndexMarker186">&#13;
     </html:a>&#13;
     was built by the LlamaIndex community by testing various&#13;
     <html:span class="No-Break">&#13;
      LLMs:&#13;
     </html:span>&#13;
     <html:a>&#13;
      <html:span class="No-Break">&#13;
       https://docs.llamaindex.ai/en/stable/module_guides/models/llms.html&#13;
      </html:span>&#13;
     </html:a>&#13;
     <html:span class="No-Break">&#13;
      .&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:a id="_idTextAnchor064">&#13;
    </html:a>&#13;
    <html:h2 id="_idParaDest-65">&#13;
     Understanding how Settings can be used for customization&#13;
    </html:h2>&#13;
    <html:p>&#13;
     You’ve&#13;
     <html:a id="_idIndexMarker187">&#13;
     </html:a>&#13;
     probably noticed that I have used something called&#13;
     <html:code class="literal">&#13;
      Settings&#13;
     </html:code>&#13;
     to customize the AI model in the previous section. A brief explanation is&#13;
     <html:span class="No-Break">&#13;
      in order.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     <html:code class="literal">&#13;
      Settings&#13;
     </html:code>&#13;
     is a key component in LlamaIndex that allows you to customize and configure the&#13;
     <html:em class="italic">&#13;
      elements&#13;
     </html:em>&#13;
     used during indexing and querying. It contains common objects needed across LlamaIndex such as&#13;
     <html:span class="No-Break">&#13;
      the following:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:ul>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       LLM&#13;
      </html:code>&#13;
      : This allows for the overriding of the default LLM with a custom one as we’ve seen in the&#13;
      <html:span class="No-Break">&#13;
       previous example&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       Embedding model&#13;
      </html:code>&#13;
      : This is used for generating vectors for text to enable semantic search. These vectors are&#13;
      <html:a id="_idIndexMarker188">&#13;
      </html:a>&#13;
      called&#13;
      <html:strong class="bold">&#13;
       embeddings&#13;
      </html:strong>&#13;
      and we’ll talk about them in much more detail during&#13;
      <html:a>&#13;
       <html:span class="No-Break">&#13;
        <html:em class="italic">&#13;
         Chapter 5&#13;
        </html:em>&#13;
       </html:span>&#13;
      </html:a>&#13;
      ,&#13;
      <html:em class="italic">&#13;
       Indexing&#13;
      </html:em>&#13;
      <html:span class="No-Break">&#13;
       <html:em class="italic">&#13;
        with LlamaIndex&#13;
       </html:em>&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       NodeParser&#13;
      </html:code>&#13;
      : This is used for setting the default&#13;
      <html:span class="No-Break">&#13;
       node parser&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       CallbackManager&#13;
      </html:code>&#13;
      : This handles callbacks for events within LlamaIndex. As we will see later, this is used for debugging and tracing&#13;
      <html:span class="No-Break">&#13;
       our apps&#13;
      </html:span>&#13;
     </html:li>&#13;
    </html:ul>&#13;
    <html:p>&#13;
     There are also other parameters that can be tweaked in&#13;
     <html:code class="literal">&#13;
      Settings&#13;
     </html:code>&#13;
     . We’ll dive much deeper into different customization options during&#13;
     <html:a>&#13;
      <html:span class="No-Break">&#13;
       <html:em class="italic">&#13;
        Chapter 9&#13;
       </html:em>&#13;
      </html:span>&#13;
     </html:a>&#13;
     ,&#13;
     <html:em class="italic">&#13;
      Customizing and Deploying Our LlamaIndex Project&#13;
     </html:em>&#13;
     . Regardless of what you want to change, the customization&#13;
     <html:a id="_idIndexMarker189">&#13;
     </html:a>&#13;
     will be done like in the previous example. Once you’ve defined your custom&#13;
     <html:code class="literal">&#13;
      Settings&#13;
     </html:code>&#13;
     , all subsequent operations will use&#13;
     <html:span class="No-Break">&#13;
      this configuration.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     OK. We’ve covered enough concepts for one chapter. How about&#13;
     <html:span class="No-Break">&#13;
      some coding?&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:a id="_idTextAnchor065">&#13;
    </html:a>&#13;
   </html:div>&#13;
  </html:div>&#13;
 </html:body>&#13;
</html:html>
<html:html>&#13;
 <html:head>&#13;
  <html:title>&#13;
   Starting our PITS project – hands-on exercise&#13;
  </html:title>&#13;
 </html:head>&#13;
 <html:body>&#13;
  <html:div class="epub-source">&#13;
   <html:h1 id="_idParaDest-66">&#13;
    Starting our PITS project – hands-on exercise&#13;
   </html:h1>&#13;
   <html:div id="_idContainer034">&#13;
    pip install pyyaml&#13;
    LOG_FILE = "session_data/user_actions.log"&#13;
SESSION_FILE = "session_data/user_session_state.yaml"&#13;
CACHE_FILE = "cache/pipeline_cache.json"&#13;
CONVERSATION_FILE = "cache/chat_history.json"&#13;
QUIZ_FILE = "cache/quiz.csv"&#13;
SLIDES_FILE = "cache/slides.json"&#13;
STORAGE_PATH = "ingestion_storage/"&#13;
INDEX_STORAGE = "index_storage"&#13;
QUIZ_SIZE = 5&#13;
ITEMS_ON_SLIDE = 4&#13;
    from global_settings import SESSION_FILE&#13;
import yaml&#13;
import os&#13;
def save_session(state):&#13;
    state_to_save = {key: value for key, value in state.items()}&#13;
    with open(SESSION_FILE, 'w') as file:&#13;
        yaml.dump(state_to_save, file)&#13;
    def load_session(state):&#13;
    if os.path.exists(SESSION_FILE):&#13;
        with open(SESSION_FILE, 'r') as file:&#13;
            try:&#13;
                loaded_state = yaml.safe_load(file) or {}&#13;
                for key, value in loaded_state.items():&#13;
                    state[key] = value&#13;
                return True&#13;
            except yaml.YAMLError:&#13;
                return False&#13;
    return False&#13;
    def delete_session(state):&#13;
    if os.path.exists(SESSION_FILE):&#13;
        os.remove(SESSION_FILE)&#13;
    for key in list(state.keys()):&#13;
        del state[key]&#13;
    from datetime import datetime&#13;
from global_settings import LOG_FILE&#13;
import os&#13;
def log_action(action, action_type):&#13;
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')&#13;
    log_entry = f"{timestamp}: {action_type} : {action}\n"&#13;
    with open(LOG_FILE, 'a') as file:&#13;
        file.write(log_entry)&#13;
def reset_log():&#13;
    with open(LOG_FILE, 'w') as file:&#13;
        file.truncate(0)&#13;
    <html:p>&#13;
     Are&#13;
     <html:a id="_idIndexMarker190">&#13;
     </html:a>&#13;
     you ready for a bit of hands-on practice? It’s time to start building our PITS project. We have enough theoretical groundwork laid out and, in this chapter, we’ll begin the preparation for the more advanced elements&#13;
     <html:span class="No-Break">&#13;
      to come.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     I’ve tried to build the project in a modular structure. I believe it helps a lot with code clarity and will enable us to go through some of the important concepts from LlamaIndex one by one. As I mentioned in the previous chapter, you can either write the code alongside reading the book or download and study it in full using the GitHub repository that I’ve made available&#13;
     <html:span class="No-Break">&#13;
      to you.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p class="callout-heading">&#13;
     Disclaimer&#13;
    </html:p>&#13;
    <html:p class="callout">&#13;
     There are many aspects that can be improved in the existing code base, and quite a few features are missing from it for PITS to be considered a production-ready application. For example, in my implementation, there is no authentication and the application is a single user. Also, to keep the code short, I’ve not dealt much with error handling. But, of course, these are not bugs but features. This way, you can continue the story of PITS, adding the missing elements and transforming it into a commercial-grade application.&#13;
     <html:span class="No-Break">&#13;
      Why not?&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Before we start, I’d like to briefly explain the code structure that will underpin our application. Here’s a list of Python source code files used by our PITS along with brief descriptions&#13;
     <html:span class="No-Break">&#13;
      for each:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:ul>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       app.py&#13;
      </html:code>&#13;
      : The main entry point for the Streamlit app. This handles the initialization of the application and manages the navigation between different screens based on the&#13;
      <html:span class="No-Break">&#13;
       application logic&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       document_uploader.py&#13;
      </html:code>&#13;
      : This interfaces with LlamaIndex to ingest and index&#13;
      <html:span class="No-Break">&#13;
       uploaded Documents&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       training_material_builder.py&#13;
      </html:code>&#13;
      : This constructs the learning materials (slides and narration) based on the user’s current knowledge. It utilizes uploaded and&#13;
      <html:a id="_idIndexMarker191">&#13;
      </html:a>&#13;
      indexed materials to generate the&#13;
      <html:span class="No-Break">&#13;
       learning content&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       training_interface.py&#13;
      </html:code>&#13;
      : This is where the actual teaching will take place. It displays the slides and the tutor narration together with the conversational side panel for&#13;
      <html:span class="No-Break">&#13;
       user interactions&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       quiz_builder.py&#13;
      </html:code>&#13;
      : This generates quizzes based on the ingested materials and the user’s&#13;
      <html:span class="No-Break">&#13;
       current knowledge&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       quiz_interface.py&#13;
      </html:code>&#13;
      : This administers quizzes and evaluates the user’s knowledge level depending on the results – what everyone hated in&#13;
      <html:span class="No-Break">&#13;
       high school&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       conversation_engine.py&#13;
      </html:code>&#13;
      : This manages the conversational side panel, responding to user queries and providing explanations. It also keeps track of the context of conversations with the tutor to avoid repetition and ensure relevant assistance. It also retrieves summaries of previous discussions and ensures the tutor picks up where it&#13;
      <html:span class="No-Break">&#13;
       left off&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       storage_manager.py&#13;
      </html:code>&#13;
      : This handles all file operations, such as saving and loading session states and user uploads. It manages local file storage and can be later adapted for cloud&#13;
      <html:span class="No-Break">&#13;
       storage solutions&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       session_functions.py&#13;
      </html:code>&#13;
      : This handle storing and retrieving session information locally – and eventually in&#13;
      <html:span class="No-Break">&#13;
       the cloud&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       logging_functions.py&#13;
      </html:code>&#13;
      : This handles the logging of all user interactions with the app. Writes descriptive log statements with timestamps to track the user’s actions throughout the app. Stores and retrieves application logs locally – and eventually in&#13;
      <html:span class="No-Break">&#13;
       the cloud&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       global_settings.py&#13;
      </html:code>&#13;
      : This contains application settings, configurations, and eventually&#13;
      <html:a id="_idIndexMarker192">&#13;
      </html:a>&#13;
      Streamlit’s secrets for deployment. It centralizes parameters for easy management&#13;
      <html:span class="No-Break">&#13;
       and updates&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       user_onboarding.py&#13;
      </html:code>&#13;
      : This module takes care of the user&#13;
      <html:span class="No-Break">&#13;
       onboarding steps&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       index_builder.py&#13;
      </html:code>&#13;
      : This module builds the indexes used throughout&#13;
      <html:span class="No-Break">&#13;
       the application&#13;
      </html:span>&#13;
     </html:li>&#13;
    </html:ul>&#13;
    <html:p>&#13;
     Keep in mind that, currently, the application is designed to run locally. During&#13;
     <html:a>&#13;
      <html:span class="No-Break">&#13;
       <html:em class="italic">&#13;
        Chapter 9&#13;
       </html:em>&#13;
      </html:span>&#13;
     </html:a>&#13;
     ,&#13;
     <html:em class="italic">&#13;
      Customizing and Deploying Our LlamaIndex Project&#13;
     </html:em>&#13;
     , we will discuss the deployment options available with Streamlit apps in more detail. Before continuing, make sure you have installed the second package mentioned at the beginning of the chapter – the YAML package&#13;
     <html:span class="No-Break">&#13;
      for Python.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     This one will be required by PITS for its&#13;
     <html:code class="literal">&#13;
      session_functions&#13;
     </html:code>&#13;
     module. I will explain it in a&#13;
     <html:span class="No-Break">&#13;
      few moments.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     To install it, use the&#13;
     <html:span class="No-Break">&#13;
      following code:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     For now, we&#13;
     <html:a id="_idIndexMarker193">&#13;
     </html:a>&#13;
     will focus on three of the&#13;
     <html:span class="No-Break">&#13;
      PITS modules:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:ul>&#13;
     <html:li>&#13;
      <html:span class="No-Break">&#13;
       <html:code class="literal">&#13;
        global_settings.py&#13;
       </html:code>&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:span class="No-Break">&#13;
       <html:code class="literal">&#13;
        session_functions.py&#13;
       </html:code>&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:span class="No-Break">&#13;
       <html:code class="literal">&#13;
        logging_functions.py&#13;
       </html:code>&#13;
      </html:span>&#13;
     </html:li>&#13;
    </html:ul>&#13;
    <html:a id="_idTextAnchor066">&#13;
    </html:a>&#13;
    <html:h2 id="_idParaDest-67">&#13;
     Let’s have a look at the source code&#13;
    </html:h2>&#13;
    <html:p>&#13;
     We will first start with&#13;
     <html:a id="_idIndexMarker194">&#13;
     </html:a>&#13;
     the global settings&#13;
     <html:span class="No-Break">&#13;
      in&#13;
     </html:span>&#13;
     <html:span class="No-Break">&#13;
      <html:code class="literal">&#13;
       global_settings.py&#13;
      </html:code>&#13;
     </html:span>&#13;
     <html:span class="No-Break">&#13;
      :&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     This is where we will store our global configurations. We’ll use the different parameters here to customize the experience of PITS and adjust some of its&#13;
     <html:span class="No-Break">&#13;
      internal settings.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     For now, the only two&#13;
     <html:a id="_idIndexMarker195">&#13;
     </html:a>&#13;
     parameters I would like to emphasize are&#13;
     <html:code class="literal">&#13;
      LOG_FILE&#13;
     </html:code>&#13;
     and&#13;
     <html:code class="literal">&#13;
      SESSION_FILE&#13;
     </html:code>&#13;
     . They are used to define the storage location for “our log file” and session-related data. The&#13;
     <html:code class="literal">&#13;
      log&#13;
     </html:code>&#13;
     file will be used to remember all user interactions and maintain conversational context. The&#13;
     <html:code class="literal">&#13;
      session&#13;
     </html:code>&#13;
     file will allow resuming existing sessions while maintaining the&#13;
     <html:span class="No-Break">&#13;
      session state.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Now, let’s move on&#13;
     <html:span class="No-Break">&#13;
      to&#13;
     </html:span>&#13;
     <html:span class="No-Break">&#13;
      <html:code class="literal">&#13;
       session_functions.py&#13;
      </html:code>&#13;
     </html:span>&#13;
     <html:span class="No-Break">&#13;
      .&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     The&#13;
     <html:code class="literal">&#13;
      session_functions.py&#13;
     </html:code>&#13;
     module contains functions that handle the saving, loading, and deleting of a user’s&#13;
     <html:span class="No-Break">&#13;
      session state:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     The&#13;
     <html:code class="literal">&#13;
      save_session&#13;
     </html:code>&#13;
     function takes the current state as an argument, which includes all the necessary information about the user’s session and writes it to a file named&#13;
     <html:code class="literal">&#13;
      SESSION_FILE&#13;
     </html:code>&#13;
     . The state is converted into YAML format before saving, which ensures that it can be easily&#13;
     <html:span class="No-Break">&#13;
      reloaded later.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     This function attempts&#13;
     <html:a id="_idIndexMarker196">&#13;
     </html:a>&#13;
     to read&#13;
     <html:code class="literal">&#13;
      SESSION_FILE&#13;
     </html:code>&#13;
     , if it exists, and loads the stored session data into the provided state object. If the file is read successfully and the YAML content is correctly parsed, it returns&#13;
     <html:code class="literal">&#13;
      True&#13;
     </html:code>&#13;
     , indicating that the session state has been restored. Otherwise, it&#13;
     <html:span class="No-Break">&#13;
      returns&#13;
     </html:span>&#13;
     <html:span class="No-Break">&#13;
      <html:code class="literal">&#13;
       False&#13;
      </html:code>&#13;
     </html:span>&#13;
     <html:span class="No-Break">&#13;
      .&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     When a session needs to be cleared, this function deletes&#13;
     <html:code class="literal">&#13;
      SESSION_FILE&#13;
     </html:code>&#13;
     and removes all the keys from the passed state object, effectively resetting&#13;
     <html:span class="No-Break">&#13;
      the session.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p class="callout-heading">&#13;
     Why YAML?&#13;
    </html:p>&#13;
    <html:p class="callout">&#13;
     I’ve used YAML as the format for serialization instead of Streamlit own persistence format because it’s human readable and platform independent. YAML works well with hierarchical data structures, making it easy to read and edit outside of the application if necessary. It allows the session state to be stored in a structured, standard format that can easily be transferred or modified as needed. YAML is often used for configuration files, but it’s also suitable for storing simple data structures such as, in our case, the&#13;
     <html:span class="No-Break">&#13;
      session state.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     We also need to create&#13;
     <html:code class="literal">&#13;
      logging_functions.py&#13;
     </html:code>&#13;
     . Here is&#13;
     <html:span class="No-Break">&#13;
      the code:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     The&#13;
     <html:code class="literal">&#13;
      logging_functions.py&#13;
     </html:code>&#13;
     module is responsible for recording events, user actions, and&#13;
     <html:a id="_idIndexMarker197">&#13;
     </html:a>&#13;
     other significant occurrences during the execution of the application into a log file. I’ve designed it to keep track of user actions and system events mainly to provide context for the PITS agent during its interactions with the user but also for monitoring and&#13;
     <html:span class="No-Break">&#13;
      debugging purposes.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     Here’s what the&#13;
     <html:a id="_idIndexMarker198">&#13;
     </html:a>&#13;
     functions in the&#13;
     <html:span class="No-Break">&#13;
      module do:&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:ul>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       log_action(action, action_type)&#13;
      </html:code>&#13;
      : This function records an action or event. It accepts two arguments:&#13;
      <html:code class="literal">&#13;
       action&#13;
      </html:code>&#13;
      , which is a string describing what occurred, and&#13;
      <html:code class="literal">&#13;
       action_type&#13;
      </html:code>&#13;
      , which categorizes the action. The function gets the current&#13;
      <html:code class="literal">&#13;
       timestamp&#13;
      </html:code>&#13;
      , formats it with the action and type, and appends this entry to&#13;
      <html:code class="literal">&#13;
       LOG_FILE&#13;
      </html:code>&#13;
      . This helps maintain a chronological record of actions&#13;
      <html:span class="No-Break">&#13;
       and events&#13;
      </html:span>&#13;
     </html:li>&#13;
     <html:li>&#13;
      <html:code class="literal">&#13;
       reset_log()&#13;
      </html:code>&#13;
      : In the current implementation, when the users return to an existing session, they have the option to start a new one. When that happens, we clear the log file to avoid collecting too much data. This function opens&#13;
      <html:code class="literal">&#13;
       LOG_FILE&#13;
      </html:code>&#13;
      and truncates its content, effectively deleting all the logged entries. This is usually not a common thing to do in production environments, as logs are valuable for historical data analysis, but in our case, it simplifies&#13;
      <html:span class="No-Break">&#13;
       the flow&#13;
      </html:span>&#13;
     </html:li>&#13;
    </html:ul>&#13;
    <html:p>&#13;
     I know I’ve&#13;
     <html:a id="_idIndexMarker199">&#13;
     </html:a>&#13;
     promised we’ll have fun writing the code for PITS, and I am perfectly aware that logging seems less&#13;
     <html:em class="italic">&#13;
      ha-ha&#13;
     </html:em>&#13;
     and more&#13;
     <html:em class="italic">&#13;
      ho-hum&#13;
     </html:em>&#13;
     , but trust me, there’s no fun if you can’t debug your app. We needed to lay the foundations here and we’ll continue with the rest of the modules in the&#13;
     <html:span class="No-Break">&#13;
      next chapters.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:a id="_idTextAnchor067">&#13;
    </html:a>&#13;
   </html:div>&#13;
  </html:div>&#13;
 </html:body>&#13;
</html:html>
<html:html>&#13;
 <html:head>&#13;
  <html:title>&#13;
   Summary&#13;
  </html:title>&#13;
 </html:head>&#13;
 <html:body>&#13;
  <html:div class="epub-source">&#13;
   <html:h1 id="_idParaDest-68">&#13;
    Summary&#13;
   </html:h1>&#13;
   <html:div id="_idContainer034">&#13;
    <html:p>&#13;
     This chapter covered foundational concepts such as Documents, Nodes, and indexes – the core building blocks of LlamaIndex. I’ve demonstrated a simple workflow to load data as Documents, parse it into coherent Nodes using parsers, build an optimized index from the Nodes, and then query the index to retrieve relevant Nodes and synthesize&#13;
     <html:span class="No-Break">&#13;
      a response.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     The logging features of LlamaIndex were introduced as an important tool for understanding the underlying logic and debugging applications. Logs reveal how LlamaIndex parses, indexes, prompts the LLM, retrieves Nodes, and synthesizes responses. Customizing the LLM and other services used by LlamaIndex was shown using the&#13;
     <html:span class="No-Break">&#13;
      <html:code class="literal">&#13;
       Settings&#13;
      </html:code>&#13;
     </html:span>&#13;
     <html:span class="No-Break">&#13;
      class.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     We’ve also started to build our PITS tutoring application, laying the groundwork with session management and logging functions. This modular structure will enable the exploration of LlamaIndex’s capabilities incrementally as the app is&#13;
     <html:span class="No-Break">&#13;
      built up.&#13;
     </html:span>&#13;
    </html:p>&#13;
    <html:p>&#13;
     With the foundational knowledge established, it’s time to move on to more advanced LlamaIndex features. The&#13;
     <html:span class="No-Break">&#13;
      journey continues!&#13;
     </html:span>&#13;
    </html:p>&#13;
   </html:div>&#13;
  </html:div>&#13;
 </html:body>&#13;
</html:html></body></html>