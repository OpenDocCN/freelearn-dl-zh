- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optimizing the Navigation System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a project grows in complexity, ensuring that the nav meshes are finely tuned
    for smooth and efficient AI agent movement becomes crucial. That’s why in this
    chapter, we will delve into the world of optimizing and debugging the Navigation
    System.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we will explore various techniques and strategies to
    optimize nav meshes, and we will discuss ways to streamline the pathfinding calculations,
    reduce computational overhead, and improve overall performance.
  prefs: []
  type: TYPE_NORMAL
- en: You will also acquire the tools and knowledge necessary to effectively debug
    any issues that may arise within the Navigation System. From troubleshooting pathfinding
    errors to identifying nav mesh inconsistencies, we will cover a range of debugging
    techniques to help you conquer any obstacles standing in the way of your agents’
    smooth navigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the nav mesh debugging tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing nav mesh resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refining nav mesh generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making further improvements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the topics presented in this chapter, you should have completed the
    previous ones and understood their content.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, if you would prefer to begin with code from the companion repository
    for this book, you can download the **.zip** project files provided in this book’s
    companion project repository at [https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5](https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: To download the files from the end of the last chapter, click the **Unreal Agility
    Arena –** **Chapter 05** **-** **End** link.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the nav mesh debugging tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Driven by his relentless pursuit of perfection, Dr. Markus delved into the
    task of debugging and improving the artificial intelligence dummy puppets. Armed
    with a tireless spirit and a mind brimming with innovative ideas, he set out to
    fine-tune the puppets’ capabilities and address any glitches or shortcomings they
    encountered during* *their experiments.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*With his trusty assistant, Professor Viktoria, by his side, Dr. Markus meticulously
    analyzed the data collected from the puppets’ previous expeditions, scrutinizing
    every line of code, searching for any potential flaws, and seeking opportunities
    to enhance* *their performance.*'
  prefs: []
  type: TYPE_NORMAL
- en: As a game programmer, you already know that optimizing code in your games and
    hunting down bugs is crucial for creating successful games. The AI system is no
    exception to this. Luckily, Unreal Engine provides a set of features – the **debugging
    tools** – that grant you invaluable insights into the inner workings of the Navigation
    System, allowing you to visualize and analyze the nav mesh in real time. In this
    section, we will start exploring these tools in order to check how the system
    behaves and whether it is working well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to consider just the part of the debugging tools
    that will let you analyze the nav mesh system, but you should be aware that the
    AI debugging system covers all the AI features available in Unreal Engine. That’s
    why I will get back to the debugging tools later in this book, when I will be
    covering other AI topics.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by checking how the AI debugging tools can be enabled and how to
    get started with the nav mesh debugging features.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the AI debugging tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enable the debugging tools, all you need to do is to hit the apostrophe
    key ( *‘* ) on your keyboard. Be aware that on some keyboard layouts – such as
    mine – this key may not be available; you can add your own shortcut by doing the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: From the main menu, select **Edit** | **Editor Preferences** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **General – Keyboard Shortcuts** category and, in the search bar,
    type **show** **ai debug** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Show AI Debug** field, insert your favorite shortcut. In my case, I
    opted for the **/** character from the numpad.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.1 – AI debugger shortcut](img/B31016_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – AI debugger shortcut
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the AI debugging tools are enabled, you can toggle the AI information
    by using the following numpad keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Numpad 0* : Displays or hides information about the currently available nav
    mesh data'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Numpad 1* : Displays or hides general AI debug information'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Numpad 2* : Displays or hides behavior trees debug information'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Numpad 3* : Displays or hides EQS debug information'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Numpad 4* : Displays or hides AI perception debug information'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Numpad 5* : Displays or hides AI perception system debug information'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start checking these tools with the gym levels we have created in the
    previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting the AI debugging tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start using the AI debugging tools, all you need is a level. So, start by
    opening the **Gym_NavMesh_01** level and doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Disable the nav mesh visualization tool – if enabled – by pressing the *P* key;
    this will avoid cluttering the AI information display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the level simulation and immediately pause it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enable the AI debugging tools by pressing the apostrophe key; this will open
    a sidebar and you will get some display messages, as shown in *Figure 6* *.2*
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.2 – AI debugging tools in action](img/B31016_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – AI debugging tools in action
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the debugging tools are enabled, ensure that the **Navmesh** and **AI**
    categories are enabled and that all the other ones are disabled by using the corresponding
    numpad keys. Enabled categories are highlighted in green, as shown in *Figure
    6* *.3* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Enabled categories](img/B31016_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Enabled categories
  prefs: []
  type: TYPE_NORMAL
- en: 'Still with the game paused, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Look for **BP_NavMeshAgent** , and you will notice that it now has a red icon
    associated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the actor to select it; this will show some information on it. The
    most important one is the associated AI controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.4 – AI agent](img/B31016_06_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – AI agent
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, on the display, you will see additional information about the
    AI agent, as shown in *Figure 6* *.5* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – AI agent information](img/B31016_06_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – AI agent information
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the image, this display offers a plethora of information,
    including the controlling pawn, the controller, and the mesh the agent is walking
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you will get probably one of the most interesting pieces of information
    on the nav mesh and the pathfinding system; if you move around the level, you
    will see a highlight of the polygons that make up the path to the target point.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Pathfinding polygons](img/B31016_06_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Pathfinding polygons
  prefs: []
  type: TYPE_NORMAL
- en: As an extra exercise, you can open up all the other levels and see which information
    you can get from the tool. For example, you may look at the **Gym_NavMesh_04**
    level and check what happens when the moving platform moves up and down.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have been introduced to the tools that will provide meaningful
    pieces of information on the AI system; in the next section, I’ll show you how
    to derive insights on nav mesh generation for your levels in order to optimize
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing nav mesh resolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unreal Engine provides a **Navigation Mesh Resolution** system that lets developers
    create mesh tiles at three distinct levels of detail within a single nav mesh.
    This means that you have the flexibility to generate sets of tiles with high,
    medium – the default option – or low precision settings. By opting for different
    precision levels, users can achieve faster generation – in terms of computing
    time – of a dynamic nav mesh while the game is playing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When we speak about **resolution** , we mean the precision and quantity of cells
    produced to map a specific navigation area.
  prefs: []
  type: TYPE_NORMAL
- en: A high-resolution tile may divide a given area into more polygons to closely
    approximate its shape. Conversely, a low-resolution tile will encompass the same
    area but with fewer polygons. This trade-off enables quicker tile generation but
    may sacrifice some accuracy in the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first test, we can start analyzing one of our gyms:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Gym_NavMesh_01** level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a better view of the level, select the **Top** view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Selecting the Top view](img/B31016_06_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – Selecting the Top view
  prefs: []
  type: TYPE_NORMAL
- en: In **Outliner** , select the **Recast Nav** **Mesh** actor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To get the overall information on the cost for your nav mesh, do the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the **Recast Nav Mesh** actor still selected, check the **Draw Tile Bounds**
    property in the **Details** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check the **Draw Tile Bounds Times** property. You should get a view like that
    shown in *Figure 6* *.8* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Tiles and tile generation time](img/B31016_06_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Tiles and tile generation time
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Draw Tile Bounds Time** property shows the time cost of processing a
    specific tile; you will notice that more complex areas will take more time to
    compute. If you want a more visual representation of the cost, you can check **Draw
    Tile Build Times Heat Map** , which will enable a heat map visualization of the
    cost, as shown in *Figure 6* *.9* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Heat map visualization](img/B31016_06_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Heat map visualization
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are not familiar with this feature, a heat map is a visual representation
    of data that employs color-coded systems to display the volume or intensity of
    a specific attribute across a defined area or dataset. Heat maps are adaptable
    and find application in diverse scenarios, including data analysis, user behavior
    analysis, and geographic representation. In our scenario, by associating colors
    with different levels of intensity – with blue being the less costly area and
    lighter colors being the higher costly ones – heat maps illuminate regions of
    increased or decreased traversal cost, enabling observers to discern patterns
    and crucial circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: This view is particularly useful when dealing with large areas and wanting to
    obtain an overview of the more resource-intensive zones. In the preceding figure,
    the red zones are the ones that will cost more in navigation terms.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have grasped the process of analyzing a nav mesh to identify
    potential issues; in the next section, we will explore strategies for addressing
    and enhancing its generation.
  prefs: []
  type: TYPE_NORMAL
- en: Refining nav mesh generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It should come as no surprise that the complexity of an environment directly
    affects the time it takes for the system to generate a nav mesh. Conversely, if
    the generation time is shorter, the resulting nav mesh may be less precise. In
    most cases, your final system will involve a trade-off between computation speed
    and precision. This means it is mandatory, as a game developer, to understand
    how to properly set up your nav mesh generation.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I will provide you with some advice on how to optimize the
    way a nav mesh is generated.
  prefs: []
  type: TYPE_NORMAL
- en: Influencing nav mesh resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next test we will perform involves modifying the resolution of a nav mesh.
    Start by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Gym_NavMesh_02** level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is not already enabled, select the **Top** view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Outliner** panel, select the **Recast Nav** **Mesh** actor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Details** panel, check the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Draw** **Tile Bounds**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Draw Tile** **Bounds Times**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Draw Tile Build Times** **Heat Map**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You should get a view similar to *Figure 6* *.10* :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Heat map visualization](img/B31016_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – Heat map visualization
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the heat map, the central part has a higher cost. However,
    the overall geometry is quite simple; we have the muddy area and a bridge, which
    are basically rectangular, non-rotated areas. Let’s lower the cost for our mesh.
    Start doing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Outliner** panel, select the three **Nav Modifier Volumes** – the two
    muddy areas and the bridge area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Details** panel, search for the **Nav Mesh Resolution** property and,
    in the dropdown menu, select **Low** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will notice that the time cost for the central part of the map will immediately
    drop, as depicted in *Figure 6* *.11* :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Improved nav mesh](img/B31016_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – Improved nav mesh
  prefs: []
  type: TYPE_NORMAL
- en: When you look at the heatmap visualization, you might see some tiles that have
    been left untouched by the previous modification – the ones on the sides – changing
    color and appearing more expensive. However, don’t let this trick you – the system
    will simply highlight areas that will be more costly in terms of the overall nav
    mesh. In fact, if you check those areas, you will see that the cost hasn’t changed
    at all; they have simply become more costly than their central map counterparts.
    This means that the cost for a particular area is relative to all other areas
    analyzed by the system.
  prefs: []
  type: TYPE_NORMAL
- en: As another experiment, you can set the bridge **Nav Mesh Modifier** actor to
    a **Nav Mesh Resolution** value of **High** and see the results. Spoiler alert!
    The tiles, including the bridge, will become the most expensive parts of the level!
  prefs: []
  type: TYPE_NORMAL
- en: Changing nav mesh resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If, at this point, you are wondering whether you can adjust the nav mesh resolution
    for your level, the answer is an unsurprising yes!
  prefs: []
  type: TYPE_NORMAL
- en: By selecting the **Recast Nav Mesh** actor, in the **Detail** panel, you will
    find a **Nav Mesh Resolution Params** option with three fields – **Low** , **Default**
    , and **High** – that will let you decide the cell size for your level.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Nav Mesh Resolution Params](img/B31016_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – Nav Mesh Resolution Params
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, just remember that the higher the cell size, the less costly
    the zone will be.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the tile size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are already aware that the nav mesh is partitioned into tiles, which are
    utilized to reconstruct specific sections of the nav mesh itself. As each tile
    consists of cells, rebuilding tiles entails recreating all its cells with the
    updated information.
  prefs: []
  type: TYPE_NORMAL
- en: Larger tiles encompass more cells, resulting in a higher cost to rebuild than
    smaller tiles. However, when processing a tile, the system also handles the adjacent
    cells along the tile’s edges. It is important to consider this additional overhead
    cost when determining the size of your tiles. In certain scenarios, the cumulative
    overhead cost of processing numerous smaller tiles may exceed the cost of rebuilding
    a single large tile. Therefore, careful consideration should be given when choosing
    the appropriate tile size to optimize performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve optimal performance during tile rebuilding at runtime, Epic Games’
    recommendation is that you set each **Cell Size** property – **Low** , **Default**
    , and **High** – as a multiple of each other and set the **Tile size UU** property
    to a value that is divisible by all **Cell Size** values. For instance, in *Figure
    6* *.13* , I have set the values for the **Gym_NavMesh_02** level as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tile Size UU** as **960.0**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low Cell Size** as **60.0**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Default Cell Size** as **30.0**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High Cell Size** as **15.0**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Cell size example](img/B31016_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – Cell size example
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the **Low Cell Size** value can be divided by **Default Cell
    Size** and **High Cell Size** , giving an integer value. The same can be said
    for **Tile Size UU** , which can be divided by **Low Cell Size** , **Default Cell
    Size** , and **High** **Cell Size** .
  prefs: []
  type: TYPE_NORMAL
- en: 'As an extra example, *Figure 6* *.14* shows the same level with these values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tile Size UU** as **1280.0**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low Cell Size** as **80.0**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Default Cell Size** as **40.0**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High Cell Size** as **20.0**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Cell size alternative example](img/B31016_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – Cell size alternative example
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, a larger tile size is employed. However, it is evident
    that the optimization is not as effective, leading to inefficient utilization
    of space.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I have presented you with some valuable tips on how to analyze
    your nav mesh generation and effectively optimize it by changing cell resolution
    and tile size. In the next section, I will give you some additional advice on
    how to make your navigation even better.
  prefs: []
  type: TYPE_NORMAL
- en: Making further improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tweaking a nav mesh may take a long time – depending on what you want to achieve
    –and sometimes, it’s a matter of trial and error and personal experience. In this
    section, I will give you additional advice on how to improve your maps to make
    them more functional.
  prefs: []
  type: TYPE_NORMAL
- en: Tweaking resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Choosing the right nav mesh resolution is not just a matter of computational
    performance; sometimes it may even affect your agent navigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, take into consideration *Figure 6* *.15* showing a portion of
    the **Gym_NavMesh_07** level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Nav mesh resolution](img/B31016_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – Nav mesh resolution
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the **Default Cell Size** value has been set to **20.0** and,
    as you can see, there’s no walkable area between the obstacles. However, if you
    decrease the value to **5.0** , you will get a totally different scenario, as
    depicted in *Figure 6* *.16* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – Improved nav mesh resolution](img/B31016_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – Improved nav mesh resolution
  prefs: []
  type: TYPE_NORMAL
- en: As you can clearly see, there are now open passages between the obstacles; the
    higher the coin, the finer the wine!
  prefs: []
  type: TYPE_NORMAL
- en: Disabling mesh influence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At times, your nav mesh may become cluttered with meshes that could lead to
    unreachable pathways, yet they are included in the nav mesh generation process.
    In such instances, it is advisable to hide them to prevent them from affecting
    generation time. As an example, consider the situation depicted in *Figure 6*
    *.17* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17 – Unreachable path](img/B31016_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.17 – Unreachable path
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the area in the red rectangle is unreachable, yet the central
    cube will be counted during nav mesh generation. This means that, even though
    it won’t influence any pathfinding resolution, it will have to be computed anyway.
    In this case, you can exclude it by completing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the mesh.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Details** panel, look for the **Can Ever Affect Navigation** property
    and uncheck the checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The mesh will now be excluded from the nav mesh generation, but the overall
    result will remain the same, as you can see from *Figure 6* *.18* :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.18 – The improved area](img/B31016_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.18 – The improved area
  prefs: []
  type: TYPE_NORMAL
- en: 'You can go even further by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the other two boxes and uncheck the **Can Ever Affect Navigation** property
    for both.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Nav Modifier Volume actor and scale it so that it will encompass the whole
    area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the volume **Area Class** property to **NavArea_Null** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 6* *.19* shows the final result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.19 – The optimized area](img/B31016_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.19 – The optimized area
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we are now using a single modifier to avoid the influence of
    three meshes on the final nav mesh generation. Picture all the time you’ll have
    spared once your level is jam-packed with props and obstacles of every kind!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through some more advanced techniques to help improve
    your nav mesh generation. Starting with the debugging tool, we then learned how
    to analyze and tweak the mesh generation process. Finally, we learned a few tricks
    that will help us craft more effective levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, *Part 2* of this book comes to an end; starting from the next chapter,
    get ready to face probably one of the most interesting topics when speaking about
    AI in game development: behavior trees.'
  prefs: []
  type: TYPE_NORMAL
- en: Be prepared. Your AI buddies are about to get a major overhaul and will never
    be the same!
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Working with Decision Making'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the third part of this book, you will get a comprehensive introduction to
    the powerful and versatile behavior tree system within the Unreal Engine framework.
    Additionally, you will be presented with advanced features so that you can implement
    your own complex game AI logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B31016_07.xhtml#_idTextAnchor132) *, Introducing Behavior Trees*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B31016_08.xhtml#_idTextAnchor148) *, Setting Up a Behavior Tree*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B31016_09.xhtml#_idTextAnchor170) *, Extending Behavior Trees*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B31016_10.xhtml#_idTextAnchor198) *, Improving Agents with the
    Perception System*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B31016_11.xhtml#_idTextAnchor218) *, Understanding the Environment
    Query System*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
