<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Production System</h1>
                </header>
            
            <article>
                
<p>In this chapter, we'll be talking about different ways to perfect our AI character and how to adapt the same techniques to work on different types of game that we want to create. We'll also be discussing the following topics:</p>
<ul>
<li>Automated finite-state machines (AFSMs)</li>
<li>Calculating chance</li>
<li>Utility-based functions</li>
<li>Dynamic gaming AI balance</li>
</ul>
<p>After exploring possibility and probability maps, we need to understand how to use them in conjunction with other techniques and strategies to create a well-balanced and human-like AI character. Possibility maps or even probability maps can be used alone to create enjoyable and challenging games; in fact, many video games only relied on maps, and kept with the same approach in order to create their AI enemies, and they became very successful doing it that way. A perfect example would be a generic platform game, such as <em>Super Mario Bros</em> from Nintendo. They don't need to create a complex AI system in order to make enemies challenging and that is why for decades they kept using the same formula for enemies, because it works perfectly for the genre. So it's also important to remember that, depending on the game that we are creating, some techniques could work better than others and it's up to us to decide to use, and when to use it. Now, the same should be applied to the character that we are creating it should know what to do and when to do it at every single second of the game.</p>
<p>Let's continue with the <em>Super Mario Bros</em> example and analyze what some common enemies do:</p>
<div class="CDPAlignCenter CDPAlign"><img height="358" width="599" class=" image-border" src="assets/6da34b24-83ac-4b1a-b1a3-66823cede4e3.jpg"/></div>
<p>The enemy in the screenshot is called Goomba. As soon as he appears in the game, you will notice that he moves from right to left, and only if he hits something (excluding the player) does he change his direction and move from left to right. If he's on a higher platform, he keeps moving from right to left until he falls and on the lower platform he keeps moving from right to left. This enemy never tries to defeat the player and it's very predictable. So we can determine that he only has one goal, that is, moving, and can be placed anywhere on the stage as he will behave in exactly the same way in terms of position that he is in. Now let's MOVE TO our next enemy:</p>
<div class="CDPAlignCenter CDPAlign"><img height="371" width="620" class=" image-border" src="assets/addacce9-51e4-42ac-89b4-d368d1a417eb.jpg"/></div>
<p>In this second example, the enemy is called Hammer Bro and he has a different function from the previous one. This AI can move left or right, always facing the player, and he throws a hammer in the direction of the player. So his main objective in the game is to defeat the player. Exactly the same as the previous enemy, this one can also be placed anywhere in the game and will behave according to his goal. Now, imagine that we picked up the enemy AI that we developed in the previous chapter and we placed him in a different position or stage of the game. He wouldn't react because we haven't supplied directions on what he should do if placed on a different position. Depending on the game that we are creating, we need to develop an AI character that will react as we intended. Sometimes he will be fixed in a single position but most of the time it will be required for the same AI to react the same way in different positions in the game. Imagine if the creators of <em>Super Mario Bros</em> had to redefine their AI character every time they inserted it in the game; it would take a lot of time and work. So let's learn how to use FSMs to make our character adaptable to every situation of the game.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Automated finite-state machines (AFSMs)</h1>
                </header>
            
            <article>
                
<p>As we observed in the <em>Super Mario Bros</em> example, enemies know how to react no matter what position they are placed in. Obviously, it is not required for them to perform complex tasks or plan ahead what they will do, but it served perfectly as an example, especially when compared with other video games with different genres. For example, we can see the same principles being used on Halo with the Grunts (the small enemies). They simply move from one side to another and if they find the player they start shooting at him. It's the same principle, where they simply added a personality to their character that would run away every time they lost the combat against the player. For that, they used a statement where, every time the character is below a certain number of HP, they start running away. FSMs are what we used to create our possibility and probability maps; this is also what the character should do in different situations he is facing at the moment. Now let's create <strong>automated finite-state machines</strong> (<strong>AFSMs</strong>), where the character will choose the best option according to the factors that he will be able to calculate (position, player HP, current weapon, and so on). This method is extremely useful if we plan to use the same character on different stages or in games that involve an open world.</p>
<p>When planning AFSMs, it's a good start if we can break actions into two or three main columns; in one side of the column we put the main information, such as orientation, speed, or goals, and in the other columns we put actions that can be performed over the first column actions, such as moving, shooting, charging, finding cover, hiding, using the object, and so on. Doing that, we can ensure that our character can react according to our first column independently of the position in which he is currently placed. Imagine that the goal assigned to the AI is to guard the position that we defined. That goal is the primary objective so it will be placed on the first column. Now imagine that the character starts the game far away from the position that he should be guarding. At that point, he will be using the second column actions to fulfill the first column objectives. What we should put in the second column to make that possible depends heavily on the type of game that we want to create. So let's create an example and chose the best options for it.</p>
<p>We'll continue using the FPS genre as the main stage for our example, but the same principles can be used on almost any video game. That is why we've chosen <em>Super Mario Bros</em> as a reference, to show that no matter the type of game that we want to create, AI development tends to follow the same process of creation:</p>
<div class="CDPAlignCenter CDPAlign"><img height="318" width="531" class=" image-border" src="assets/2a71c920-aa26-48ec-89b6-dfb8ff443da9.jpg"/></div>
<p>So, in our example, the map will have six buildings and neither the player nor the enemy can get inside them but they are allowed to move anywhere else. The main goal of this game is to defeat the opponent as many times as possible in a limited time; bullets and health points will appear occasionally in the game. Now let's develop an AI that can react the same way on any map. For that, we need to assign the main goal to the character and let him know about the possibilities available in order to fulfill that goal and also ensure that he is doing something every second of the game.</p>
<p>On a basic form, we have two main goals for this AI character: <strong>DEFEAT PLAYER</strong> and <strong>SURVIVE</strong>. We need to make sure that we are able to kill the player when we have the chance and to survive when we don't. For now, let's simplify this formula and define goals by taking into consideration the current HP of our character. If he's above 20% of his total HP, the main goal will be defeating the player and, on the other hand, if he's below 20% of his HP, the main goal switches to surviving:</p>
<div class="CDPAlignCenter CDPAlign"><img height="93" width="309" class=" image-border" src="assets/b84e237e-ae1e-4ce9-b681-0bf2ba0b4847.jpg"/></div>
<p>Once we have defined this, we can MOVE TO the second column and write the secondary goals that our AI will choose in order to complete the first column goals. So for this example, we will give our character three secondary goals: <strong>FIND PLAYER</strong>, <strong>FIND COVER</strong>, and <strong>FIND POINTS</strong>. By using these three objectives, our AI will be able to fulfill the main goals, will always have something to do, and will not wait for the player to do something, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="96" width="319" class=" image-border" src="assets/4c4f203a-0c53-4ec3-844c-6bb6861b39d8.jpg"/></div>
<p>Now that, we have already defined the secondary objectives, we'll write down all the possible actions in the game, such as <strong>MOVE TO</strong>, <strong>FIRE</strong>, <strong>USING OBJECT</strong>, and <strong>CROUCH</strong> as follows. Once again, all of the things that a player or enemy AI is able to do in the game are defined while we think about the game design and all of that should be in this column. This is also an important strategy to analyze whether all the actions available to the characters of the game are relevant or not to the main or secondary goals. This will save us time in the future because there's no point in programming a complex action if that doesn't contribute to the success of the main goal, as with, <em>Super Mario Bros</em>, where they have chosen not to assign complex actions to their enemies because it wasn't necessary for the type of game that they were creating. For this example, the character has the possibility to move freely, fire the weapon, use objects (reload weapon or use health points) and crouch:</p>
<div class="CDPAlignCenter CDPAlign"><img height="90" width="302" class=" image-border" src="assets/ce15685d-d958-4665-abba-c7b4d47fca3f.jpg"/></div>
<p>Now, we have the three columns filled with all of the information needed for our AI to choose the best options according to his current situation. As we'll see in a moment, this is a different method from what we used in the previous chapter, because back then we used the map to give him instructions about what he should do and we assigned him orders according to that position only. In this example, we want our character to decide the best option for himself no matter the map or position that he is placed on. This will move us to the next level of developing an AI character because if we take a look at human behavior, we rarely make a decision according to a single criterion.</p>
<p>The same process will be applied to our current enemy: they will choose the best option according to different criteria and we'll make sure that they choose the best option based on their decision. For example, it is more urgent being at 1% health than being down to only 1% of ammunition or even completing the main goal of the game.</p>
<p>Once we have our three columns ready, we can move on to the next step and link every action in the third column to the second, and all of the behaviors in the second to the first column goals. While doing this, we need to think about what the AI should be doing if he wants to find the player, find cover position, or find points. Also, we need to define when he should be looking for points, cover position, or the player. To find the player, we need to use the MOVE TO action, so our character will be walking around until he finds the player and ultimately fires at him. Then is, finding cover; once again, we'll be using the MOVE TO action, so our character will walk until he is near to a wall that can serve as a cover position, then we can choose whether he is crouching or not depending on what he wants to achieve. Finally, to find points, we'll be using MOVE TO and after that, we'll make the AI decide whether he will be using points or not (USE OBJECT). Now, let's think about what behavior or behaviors he should choose when he is trying to defeat the player and when he is trying to survive. In order to defeat the player, our AI character needs to find him, so we'll use the FIND PLAYER behavior for this goal; also, we'll let him choose the FIND COVER behavior if he has already found the player and they are close to a wall. For the SURVIVE goal, we'll be choosing FIND COVER, in case he's being attacked by the player, and FIND POINTS, to regain more HP points.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Calculating chances</h1>
                </header>
            
            <article>
                
<p>Now that we have everything set, we are ready to input all of this information into our code. We'll be using Booleans to define the main goals and then we'll create statements that will make the character AI choose between all of the other options. We already defined the primary statement that will switch our goal from defeating the player to simply surviving, but now we'll be adding more details to our AI behavior because of this question; What happens if the enemy has enough HP to confront the player but doesn't have enough bullets? What if he has enough bullets but his previous attempts to shoot the target have failed? The character will need to prioritize his choices and for each choice that they will be making, they need to compare it to the other alternatives and choose the one that has more chance of success in that goal.</p>
<p>Let's start with the chances of hitting the player: imagine that our AI already fired ten bullets and only four have hit the player. We can say that he has a 40% chance of hitting the player the next time he shoots. Now imagine that he only has two bullets in his gun; what should he do? Fire against the player with a not so favorable chance of being successful and then remain defenceless? Or run right away toward the point position where he can reload his weapon? To help in deciding this, the character will also be calculating the chance of being hit by the player; if the player has less chance of hitting the character, our AI will take the risk and fire against the player, otherwise it will try to reload its weapon. We'll start adding this information into our code. You can see an example of how it should look as follows:</p>
<pre>Private int currentHealth = 100; <br/>Private int currentBullets = 0; <br/>private int firedBullets = 0; <br/>private int hitBullets = 0; <br/>private int pFireBullets = 0; <br/>private int pHitBullets = 0; <br/>private int chanceFire = 0; <br/>private int chanceHit = 0; <br/>public GameObject Bullet;  <br/>private bool findPlayer;  <br/>private bool findCover;  <br/>private bool findPoints;  </pre>
<p>These are the variables that we'll be using for now. <kbd>firedBullets</kbd> represents how many bullets the character has already fired in the entire game; <kbd>hitBullets</kbd> represents how many of those bullets hit the target; <kbd>pFireBullets</kbd> and <kbd>pHitBullets</kbd> are the same but take player bullets into consideration. We can move on to the calculation of the chances of hitting the target or being hit. <kbd>chanceFire</kbd> will represent the percentage of bullets that hit the target and <kbd>chanceHit</kbd> the percentage of getting hit:</p>
<pre>void Update () <br/>{ <br/> chanceFire = ((hitBullets / firedBullets) * 100) = 0; <br/> chanceHit = ((pHitBullets / pFiredBullets) * 100) = 0; <br/> if(currentHealth &gt; 20 &amp;&amp; currentBullets &gt; 5) <br/> { <br/>  Fire(); <br/> } <br/> if(currentHealth &gt; 20 &amp;&amp; currentBullets &lt; 5 &amp;&amp; chanceFire &lt; 80) <br/> { <br/>  MoveToPoint(); <br/> } <br/> if(currentHealth &gt; 20 &amp;&amp; currentBullets &lt; 5 &amp;&amp;chanceFire&gt;80) <br/> { <br/>  Fire(); <br/> } <br/> if(currentHealth &gt; 20 &amp;&amp; currentBullets &gt; 5 &amp;&amp; chanceFire &lt; 30&amp;&amp;<br/> chanceHit &gt; 30) <br/> { <br/>  MoveToCover(); <br/> } <br/> if(currentHealth &lt; 20 &amp;&amp; currentBullets &gt; 0 &amp;&amp; chanceFire &gt; 90 &amp;&amp; <br/> chanceHit &lt; 50) <br/> { <br/>  Fire(); <br/> } <br/>} </pre>
<p>We have used the chances of hitting or being hit to determine what the AI should do in certain given situations. If he has more than 20 health points and has more than five bullets in his gun, he is free to shoot against the player until one of those two conditions doesn't match. Once when he only has five bullets, is it time to think about the next move, so in this example, if he has less than an 80% chance of being successful and hitting the player, he will decide not to shoot and will move towards the point position where he can reload his weapon. If he has more than an 80% chance, that means that he is being successful and he is free to try his luck. If, in the middle of the combat, the AI has less than a 30% chance of hitting the player and the player has more than a 30% chance, the character should immediately look for cover. Finally, if the AI character has less than 20% of his total health but he has a 90% chance of hitting the player and less than a 50% chance of being hit, he will choose to fire.</p>
<p>If we wanted to be even more precise about the percentages, we could add a time variable into this equation, where the AI will take into consideration the last two minutes or so instead of the whole time, or compare both percentages and analyze whether he has been more or less successful in the last two minutes in comparison with the rest of the game:</p>
<pre>if(recentPercentage &gt; wholePercentage)  </pre>
<p>By calculating chances, we give our AI enough methods to calculate his next step, where he can freely decide which goal has more importance at that specific moment and choose his action according to that. Doing this will also give the AI the ability to choose between two or more options that are available to him. We start developing a more intelligent character, that can think for itself, and we can define personalities by simply changing the percentage values to make him take more risks or carefully choose his possibilities.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Utility-based functions</h1>
                </header>
            
            <article>
                
<p>Now that we know how to calculate chance and use AFSMs, it's time to explore them a little more and make our characters look smart. This time, we'll use an AI character that is set to behave autonomously in a simulation game such as <em>The Sims</em>. This is a perfect environment to test artificial intelligence because it mimics real-life needs and choices.</p>
<p>In the video game <em>The Sims</em>, the player has the opportunity to control a human-like character and the main goal of the game is to make sure that the character is always in good situations and that their personal and professional life is always on a positive note. Meanwhile, time goes by, just like in real life, and the character gets older until he finally dies at the end. The player is responsible for the life of that being but if the player doesn't give any orders to the character, he will react autonomously to fulfill his needs. It was revolutionary the way that an AI character could behave in a video game; people could relate to that virtual character and look at him just as an independent living being. The secret is that we already know what is necessary to create a character that can behave exactly like characters in <em>The Sims</em>.</p>
<p>Without further ado, let's jump to our next example:</p>
<div class="CDPAlignCenter CDPAlign"><img height="250" width="417" class=" image-border" src="assets/d902cab4-afb7-4180-b2c1-119164e5fb5e.jpg"/></div>
<p>Let's give a name to the character in this example and call her Sophie. She is a virtual human being. She has a home with everything necessary to live: sofa, shower, television, bed, oven, and so on. Just like a human being, she has human-like necessities such as hunger, energy, comfort, hygiene, and fun. As time passes, she needs to fulfill her necessities in order to stay healthy. Now that we have the problem, let's work on the solution and make Sophie completely autonomous and able to decide for herself what she needs to do:</p>
<div class="CDPAlignCenter CDPAlign"><img height="72" width="242" class=" image-border" src="assets/a866d7e6-e727-4137-948b-ea61468f8983.jpg"/></div>
<p>We can simplify and divide the objectives into two columns: on the left side, we put the main objectives of the game and on the right side, the actions the character perform. For example, if she is hungry, she needs to move towards the kitchen and interact with the fridge. This is exactly the same principle that we used to create the automated finite-state machines in the FPS example. But this time we'll explore this concept even further.</p>
<p>Let's think for a minute about the hunger feeling. Let's say that when we eat breakfast, we fulfill our hunger need and we don't feel hungry anymore. At this point, we can say that our hunger necessity is at 100%, right? Imagine that a few minutes have passed by and now we are at 98%; why we don't go right on to fulfill the 2% that is missing? We can say that feeling hungry is a state where we are no longer full and not necessarily that we are empty and because of that we switch our priorities towards other necessities. So it's important to remember that when developing an autonomous AI character: he needs to have that thought in mind and not go to eat soon as he loses 1% of food. That would not look like human behavior; we tend to balance everything, otherwise we would sleep five minutes and work five, not so healthy or productive perhaps because it's not enough to fall asleep and isn't enough to start working. So, we sleep a fair number of hours to compensate for the other time that we are awake, and we eat a fair number of food to remain fulfilled for a few hours. We can make judgment decisions and decide that we are a little bit hungry but we need to finish the work first. Also, we make comparative judgments, for example, I'm hungry but I'm tired even more. It is important to understand our behavior when creating a virtual human being like Sophie because otherwise it will act like a robot.</p>
<p>To help Sophie determine what is more important at any specific moment, we'll be using percentages and then she will be able to compare and decide what she wants to do. Before complicating it too much, let's start writing the basic information in our code:</p>
<pre>Private float Hunger = 0f; <br/>Private float Energy = 0f; <br/>Private float Comfort = 0f; <br/>Private float Hygiene = 0f; <br/>Private float Fun = 0f; <br/>private float Overall = 0f; <br/>public Transform Fridge; <br/>public Transform Oven; <br/>public Transform Sofa; <br/>public Transform Bed; <br/>public Transform TV; <br/>public Transform Shower; <br/>public Transform WC; <br/>void Start () <br/>{ <br/>   Hunger = 100f; <br/>   Energy = 100f; <br/>   Comfort = 100f; <br/>   Hygiene = 100f; <br/>   Fun = 100f; <br/>} <br/>void Update () <br/>{ <br/> Overall = ((Hunger + Energy + Comfort + Hygiene + Fun)/5); <br/>   Hunger -= Time.deltaTime / 9; <br/>   Energy -= Time.deltaTime / 20; <br/>   Comfort -= Time.deltaTime / 15; <br/>   Hygiene -= Time.deltaTime / 11; <br/>   Fun -= Time.deltaTime / 12; <br/>}</pre>
<p>We wrote down the basic variables relating to the necessities of the character that we are creating. As time goes by, those values will decrease, with different attributed values depending on necessity. Also we have an <kbd>Overall</kbd> variable that serves to calculate the overall situation of the character and could perfectly represent the mood of our virtual human being. That will be an important factor and will help Sophie to decide what is the best option for her.</p>
<p>Now let's individualize each necessity and create a decision tree for all of them. To do so, we need to plan the process of decision-making that Sophie will think through before choosing any action. Let's start with the hunger necessity:</p>
<div class="CDPAlignCenter CDPAlign"><img height="80" width="268" class=" image-border" src="assets/b695bc1d-e584-408b-9d9c-f7c5eb25f87b.jpg"/></div>
<p>If Sophie feels hungry and she decides that is a priority, these would be the steps that she will follow. First she feels hungry and then asks herself if she has enough food; to answer that, she moves towards the fridge and checks whether she has. If the answer is yes, she moves on, cooks, and finally eats. In the event any of the segments can't be accomplished, the process will be interrupted and she will move on to a different priority. Let's say that she only has food in her fridge if she goes to work and for every day of work she receives, for example, two days of food. So going to work will become a priority very soon if she wants to keep healthy and alive:</p>
<pre>Private float Hunger = 0f; <br/>Private float Energy = 0f; <br/>Private float Comfort = 0f; <br/>Private float Hygiene = 0f; <br/>Private float Fun = 0f; <br/>private float Overall = 0f; <br/>public Transform Fridge; <br/>public Transform Oven; <br/>public Transform Sofa; <br/>public Transform Bed; <br/>public Transform TV; <br/>public Transform Shower; <br/>public Transform WC; <br/>private int foodQuantity; <br/>public float WalkSpeed; <br/>public static bool atFridge; <br/>void Start () <br/>{ <br/>   Hunger = 100f; <br/>   Energy = 100f; <br/>   Comfort = 100f; <br/>   Hygiene = 100f; <br/>   Fun = 100f; <br/>} <br/>void Update () <br/>{ <br/>   Overall = ((Hunger + Energy + Comfort + Hygiene + Fun)/5); <br/>   Hunger -= Time.deltaTime / 9; <br/>   Energy -= Time.deltaTime / 20; <br/>   Comfort -= Time.deltaTime / 15; <br/>   Hygiene -= Time.deltaTime / 11; <br/>   Fun -= Time.deltaTime / 12; <br/>} <br/>void Hungry () <br/>{ <br/>   transform.LookAt(Fridge); // Face the direction of the Fridge<br/>   transform.position vector3.MoveTowards(transform.position.<br/>   Fridge.position, walkSpeed); <br/>   //checks if already triggered the fridge position <br/>   if(atFridge == true) <br/>   { <br/>    //interact with fridge <br/>    if(foodQuantity &gt; 1) <br/>    { <br/>     Cook(); <br/>    } <br/>    else() <br/>    { <br/>     // calculate next priority <br/>    } <br/> } <br/>} </pre>
<p>In the preceding code we have an example of how the decision tree can be represented in our code. We'll continue writing what she will be doing for every necessity, and once we have that done, we can determine how she will prioritize and decide which necessity needs to be taken care of first:</p>
<div class="CDPAlignCenter CDPAlign"><img height="207" width="345" class=" image-border" src="assets/4c324985-1690-403e-ba53-58541902eba8.jpg"/></div>
<p>The next one on the list is energy:</p>
<div class="CDPAlignCenter CDPAlign"><img height="93" width="351" class=" image-border" src="assets/d4cb0c20-d3e8-4651-8678-2f9d478a3f55.jpg"/></div>
<p>If Sophie feels sleepy and she decides that is a priority, these will be the steps that she follows. First, she feels sleepy and then asks herself if she has to work. If she has free time then she will make a final judgment and decide whether she needs to go to the bathroom before sleeping. Once every state is approved, she can finally complete her goal and go to sleep. We can see an example of how it could be represented in the following code:</p>
<pre>void Sleepy () <br/>{ <br/>   if(hoursToWork &gt; 3&amp;&amp;Energy &lt; Hygiene) <br/>{ <br/>       transform.LookAt(Bed); // Face the direction of the Bed <br/>       transform.position = vector3.MoveTowards(transform.position.Bed.<br/>       position, walkSpeed); <br/>         //checks if already triggered the bed position <br/>         if(atBed == true) <br/>          { <br/>          //interact with the bed <br/>          }  <br/><br/> } <br/>if(hoursToWork &gt; 3 &amp;&amp; Energy &gt; Hygiene) <br/>{ <br/>  useWC(); //Go to the bathroom <br/>} <br/> if(hoursToWork &lt; 3) <br/>{ <br/>   //choose another thing to do <br/>} <br/>} </pre>
<p>Let's assume that, for every hour that Sophie sleeps, she gains +10 points of <span class="packt_screen">Energy</span> but loses 10 points of <span class="packt_screen">Hygiene</span>. She'll need to confirm first that she won't need to use the bathroom in the middle of her sleep and for that we compare the number of <span class="packt_screen">Energy</span> points that she needs with the number of <span class="packt_screen">Hygiene</span> points:</p>
<div class="CDPAlignCenter CDPAlign"><img height="254" width="424" class=" image-border" src="assets/b7be3456-8e13-4249-ac9c-46ce09cf374d.jpg"/></div>
<p>Let's move on to the <span class="packt_screen">Comfort</span> necessity. This one is a little bit special because we can assign two objectives at the same time while gaining <span class="packt_screen">Comfort</span> points. For example, she will be capable of deciding whether she wants to eat sitting on a chair or not. The same can be applied when she is watching TV. This is an important example that can be applied in many games, where a character decides to do two things at the same time when he has the opportunity and understands that it is important to do so. In the example that follows, we'll be taking that into consideration:</p>
<div class="CDPAlignCenter CDPAlign"><img height="81" width="306" class=" image-border" src="assets/8b44cb82-c245-4e28-bdbe-30366f45dc26.jpg"/></div>
<p>If Sophie feels uncomfortable, she will check first whether at that moment she is doing something. This question can only have two answers: yes or no. If the answer is yes, she'll need to think whether it is possible for her to keep on doing it seated. Otherwise, she'll finish what she is doing at that moment and then will start asking the same question. If possible or available, she'll finally sit and get comfortable. We can check an example of how it should look in the following code:</p>
<pre>private bool isEating; <br/>private bool isWatchingTV; <br/>private bool Busy; <br/>... <br/>void Uncomfortable () <br/>{ <br/>   if(isEating == true || isWatchingTV == true) <br/>    { <br/>         transform.LookAt(Sofa); // Face the direction of the Sofa <br/>         transform.position = vector3.MoveTowards(transform.position.<br/>         Sofa.position, walkSpeed); <br/>         //checks if already triggered the bed position <br/>         if(atSofa == true) <br/>         {  <br/>         //interact with the sofa <br/>         }  <br/>     } <br/>else <br/>{ <br/>  if(Comfort &lt; Overall&amp;&amp; Busy == false) <br/>{ <br/>    transform.LookAt(Sofa); // Face the direction of the<br/>    Sofa <br/>    transform.position =<br/>    vector3.MoveTowards(transform.position.Sofa.position, walkSpeed); <br/>               //checks if already triggered the bed position <br/><br/>           if(atSofa == true) <br/>           { <br/>           //interact with the sofa <br/>           }  <br/>    } <br/>   if(Busy == true &amp;&amp; isEating == false &amp;&amp; isWatchingTV == false) <br/>    { <br/>     //Keep doing what she is doing at that moment <br/>    } <br/>} <br/>} </pre>
<p>We added three more variables: <kbd>isEating</kbd>, <kbd>isWatchingTV</kbd>, and <kbd>Busy</kbd>. This will help her decide the best option, taking into consideration those three values. In the event that she feels uncomfortable but is eating or watching TV, she can perform both of the actions together. Otherwise, she needs to compare the rest of the necessities and judge whether it's more important to sit instead of doing other things. In the event that she is doing something at that moment and it's not possible for her to sit - let's say, for example, that she is taking a shower or working - she'll ignore the fact that she feels uncomfortable and, as soon as Sophie has the opportunity, she'll sit and gain <span class="packt_screen">Comfort</span> points:</p>
<div class="CDPAlignCenter CDPAlign"><img height="256" width="427" class=" image-border" src="assets/d1477cb1-ea98-4ac2-8be5-acf32e8313fb.jpg"/></div>
<p>There remain two more necessities to finish this example and soon we will have an AI character that could live by itself without the need for someone to control and decide what is best for her. We are developing an AI system that works on a simulation game but this same method can also be used on different genres of game. Imagine a real-time strategy game where the workers make autonomous decisions and, instead of being idle waiting for orders, immediately go to work on what they think is more important at that moment and, as soon as other priorities arrive, switch to another occupation.</p>
<p>Let's move on to the next objective, Hygiene. Just for the sake of simplicity, we will use this necessity as everything related to the bathroom:</p>
<div class="CDPAlignCenter CDPAlign"><img height="80" width="302" class=" image-border" src="assets/9b1cd9c2-d399-4d73-9e60-d073cda1cccf.jpg"/></div>
<p>The hygiene necessity is simpler than the previous ones; it's just a question of whether she is available or not to take a shower. The extra factor that we'll be using on this one is that, no matter the circumstances, going to the bathroom is the most important one and she will immediately pause what she is doing and go straight towards the bathroom.</p>
<p>The only things that she could possibly do while taking a shower are brushing her teeth or any other sub-segment of the hygiene criterion. But for now, let's stick with as few options as possible to test the AI; once we have the basic functions working properly, we then can start adding more actions. For prototype purposes, that is also a good methodology to follow: by first having the basic functions working, we can move on and gradually add more details. Now let's take a look at an example of how the <kbd>Hygiene</kbd> function would look:</p>
<pre>void useBathroom () <br/>{ <br/>if(Hygiene&lt;10) <br/>{<br/>       transform.LookAt(Bathroom); // Face the direction of the<br/>       Bathroom <br/>       transform.position = vector3.MoveTowards(transform.position.<br/>       Bathroom.position, walkSpeed); <br/>       //checks if already triggered the bed position <br/>if(atBathroom == true) <br/><br/>{ <br/><br/>   //choose randomly what to do in the bathroom <br/><br/>}  <br/><br/>} <br/><br/>} </pre>
<p> </p>
<div class="CDPAlignCenter CDPAlign"><img height="183" width="306" class=" image-border" src="assets/b750f69f-6355-489f-a76c-76c563120ff5.jpg"/></div>
<p>Let's jump right away into the next and last necessity, Fun. This one will have the opportunity to be the most flexible of them all, because we can eat and watch TV at the same time, we can sit and watch TV at the same time, and we can eat sitting down while watching TV. We give the option to our AI to be able to do three distinct things at the same time. At first glance, allowing our character to boost her points in three different necessities looks ideal, but we'll be discussing that later on. For now, let's just focus on the Fun factor and plan the steps that she'll be using to determine whether she needs to, and can, watch TV:</p>
<div class="CDPAlignCenter CDPAlign"><img height="81" width="303" class=" image-border" src="assets/a13f5dc9-42e2-410b-8117-d8bbdadbbaf0.jpg"/></div>
<p>If Sophie feels bored, she'll start asking herself whether she can watch TV. First, if she is available, she's free to watch TV and, in the default state, she watches TV seated. But if she is busy at that time, she needs to ask herself whether she can watch TV at the same time that she is doing whatever she's doing (in this example, that represents eating, sitting, or both at the same time). Once again, for the sake of simplicity, let's assume that she doesn't need to reach the television in order to turn it on. We can see an example of how that could be represented in our code as follows:</p>
<pre>private bool isSeat; <br/>private bool televisionOn; <br/>void Bored () <br/>{ <br/>if(Fun&lt;Overall&amp;&amp; Busy == false) <br/>{ <br/>   televisionOn = true; // turns on the television <br/>         transform.LookAt(TV); // Face the direction of the television <br/>         transform.position = vector3.MoveTowards(transform.position.<br/>         Sofa.position, walkSpeed); <br/>         //checks if already triggered the bed position <br/>         if(atSofa == true) <br/>         { <br/>          //interact with the sofa <br/>         } <br/> } <br/>if(Fun &lt; Overall &amp;&amp; Busy == true) <br/>{ <br/>   f(isEating == true) { <br/>         televisionOn = true; // turns on the television <br/>               transform.LookAt(TV); // Face the direction of the<br/>         television <br/><br/>      } <br/>if(isSeat == true) <br/>  { <br/>         televisionOn = true; // turns on the television <br/>         transform.LookAt(TV); // Face the direction of the television <br/><br/>   } <br/>if(isSeat == true &amp;&amp; isEating == true) <br/>{ <br/>         televisionOn = true; // turns on the television <br/>         transform.LookAt(TV); // Face the direction of the television <br/>         } <br/>} <br/>else() <br/>{ <br/>   //continue doing what she is doing <br/>}  <br/>} </pre>
<p>Finally, we conclude the necessity behaviors using different approaches for each one. Doing this, we can ensure that she will know what to do in different situations of the game and will always be looking to do something. There are some flaws in the AI design that we'll need to perfect; for example, she can't decide to continue watching TV even if she is hungry or tired. To make that possible, we would need to simply add a probability map and use the <kbd>Overall</kbd> variable to define whether she is happy or not; let's say that, in the event that she's above 50% for happiness, she can decide to watch TV even if she feels tired. All of those restrictions can now be assigned to the code and we can continuously add more details to the behavior of our character. But, for now, we will just focus on two more details: AI balance and dynamic problem-solving.</p>
<div class="CDPAlignCenter CDPAlign"><img height="195" width="325" class=" image-border" src="assets/4de89310-035c-4ea4-88d8-8545a62796f3.jpg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dynamic game AI balancing</h1>
                </header>
            
            <article>
                
<p>Another interesting and very useful topic to learn about AI development is game difficulty. If we play against a human player, the difficulty of the game will solely depend on the experience of the player that is playing against us. If they are very skillful with that specific video game, obviously they will have a greater advantage against a player who is just starting the game. Usually, video-games tend to increase the difficulty step by step, so the player can adapt to it and doesn't get frustrated too soon or simply bored because the game doesn't offer a challenge. Dynamic game difficulty balancing is used to solve this problem, by creating an interesting experience for each gamer. To balance the AI character using this method, we take into consideration some dynamic game elements that can be adjusted according to player experience; those attributes can be the following:</p>
<ul>
<li>Speed</li>
<li>Health</li>
<li>Magic</li>
<li>Power</li>
</ul>
<p>Usually, we use these attributes to define the difficulty of the AI character, adjusting them to the difficulty desired. Another way to balance the difficulty is by adjusting the quantity of weapons and enemies that the player faces during the game. When adjusting the difficulty, we also need to be careful to not create an enemy that behaves like a rubber band; for example, if the AI car is behind the player, it gets significantly faster in order to keep challenging the player. When the player is behind the opponent car, that car will decrease its speed and this method, if not moderated, can become uninteresting.</p>
<p>In a generic fighting game, developers usually define AI combat like this: if the player is reachable, the AI uses kicks or punches; if not, he goes towards the player. Then the difficulty is adjusted by using percentages and time gaps between attacks.</p>
<p>In an FPS shooter, for example, the game AI is adjusted by taking into consideration the player performance while in the development stage, where the programmers input all the AI stat values and tactics that match the overall performance of the human players. For example, if the shoot rate of the player is about 70%, the AI characters will use that value to stay relatively close to a human performance.</p>
<p><em>Crash Bandicoot</em> used <em>Dynamic Game Difficulty Balancing</em> not directly in the behavior of the AI characters themselves, but rather in the animation speed, making it slower if the player was having difficulty passing the level. This difficulty adjustment takes place according to the players number of deaths. This is a smart and simple way to adjust the difficulty of the AI character, by considering the number of times that the player died trying to beat the game.</p>
<p><em>Resident Evil 4</em>, released in 2005 by Capcom, based the difficulty adjustment on the same principle but employed a more complex system. The adjustment took into consideration player performance and, without notice, the player was rated by the game from one to ten, where one meant that they were not very successful in the game and ten that they were very skillful. Taking those rates into consideration, enemies would behave differently, being more or less aggressive and taking more or less damage. The rating was constantly updated and many things were taken into consideration to determine how good the player was, such as how many bullets he needed to kill a zombie, how many hits he took, and so on.</p>
<p><em>Left 4 Dead</em> also took into consideration how well the player was doing, but instead of only increasing the difficulty of the enemies' AI, they decided to change where the enemies would appear, creating a different challenge every time the player decided to play the same level. If the player just started the game, the enemies would appear in easier places; if the player had already passed that level, the enemies would appear in more difficult positions.</p>
<p>To summarize the choices that game developers are making while adjusting the difficulty of character AI, we need to mention that the difficulty not always is meant to be adjusted or to increase or decrease taking into consideration player performance. One great example is simulation games, where it's crucial to meet real-life difficulties and not make them more difficult or easier, otherwise it won't feel like a simulation. Other examples could be games such as Ghosts'n Goblins or, more recently, Dark Souls, where developers explicitly chose to make the game hard from start to finish without changing the AI behavior regarding the difficulty.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we discovered how to create AI characters that make their own decisions no matter where we place them by using AFSMs. Then we learned how to calculate chance and how to use it in conjunction with the previous techniques to create a character that could calculate a better option for his next step. Using all of the the set techniques, we moved on to how to use utility-based functions to create a human-like character that can behave autonomously. Finally, we talked about different ways of adjusting the values that we input in our characters to make them balanced compared to player performance. In the next chapter, we'll be talking in depth about environment and AI, taking into consideration different genres of video game and different types of AI, how the AI should use the available space on the map to create a challenge for the player, how to interact with the environment, how to use the environment in its favor, and a lot more.</p>


            </article>

            
        </section>
    </body></html>