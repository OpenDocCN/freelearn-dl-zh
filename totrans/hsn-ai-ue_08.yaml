- en: Crowds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to wrap up our talk about what comes built-in
    in terms of Artificial Intelligence in Unreal. Then, we will embark on a journey
    in which we will build an interesting AI Behavior Tree from scratch, before checking
    the huge Debug system (which includes AI Debugging) underneath Unreal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Crowds in Games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RVO avoidance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crowd Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These topics may be short, but that doesn't make them less important or easy
    to implement. So, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Crowds in games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever been stuck in a busy mall at Christmas or surrounded by a large
    crowd during a sporting event? Perhaps you were shopping among the bazaars of
    heavily fragrant spice markets? Now, imagine that all of the people in this environment
    disappeared. How would this change the mood? Quite significantly, I would imagine.
    Regardless of how big or how small a crowd of people is within an environment,
    they definitely add to the overall atmosphere.
  prefs: []
  type: TYPE_NORMAL
- en: Some great examples of crowds in games include the *Assassin's Creed* series*:*
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fccc6dba-124d-44ea-8dd0-250b0171e317.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Crowds in *Assassin''s Creed: Syndicate*'
  prefs: []
  type: TYPE_NORMAL
- en: Crowds can include both interactive NPCs and those that simply just wander around,
    minding their own business. In some cases, like in *Assassin's Creed*, members
    of the crowd will play an important role such as requiring you to protect them,
    offering you protection, or even requiring your resources (e.g. beggars asking
    for money). In other situations, crowds will have no impact on your gameplay other
    than getting in your way!
  prefs: []
  type: TYPE_NORMAL
- en: Building believable crowds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While crowds are large collections of people, usually with a common purpose
    when in a given location, they require a bit of thought behind their creation.
    It's not as simple as dumping a bunch of NPCs, giving them some autonomy (e.g.
    via artificial intelligence), and pressing play. Building a believable crowd requires
    us to consider a few things.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first consideration is the different kinds of people that should be there.
    Going back to our example of spice markets, you''re likely to find shop merchants,
    buyers, beggars, children, and so on. In the following screenshot from the game
    *Stacking*, there are no large crowds or groups of people:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34952a76-1d08-4c60-a5ee-5ce52452a4db.png)'
  prefs: []
  type: TYPE_IMG
- en: A small crowd in *Stacking*
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in *Dead Rising*, as shown in the following screenshot, there is quite
    an extensive crowd of people (zombies, in this case), all trying to attack you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6cc5ae1-2397-4f4e-9dfb-d6230e0dde77.png)'
  prefs: []
  type: TYPE_IMG
- en: A big crowd of zombies attacking the player in *Dead Rising*
  prefs: []
  type: TYPE_NORMAL
- en: The next consideration is more of an aesthetic one. For instance, depending
    on its location in both space and time, the type of movement, clothes, ages, etc.,
    will also vary. It is highly unlikely (unless that is the angle you're going for)
    that you will have characters dressed as if they are going to a 1930s cocktail
    party, if you're attacking templars during the third crusade.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have the aural consideration. What does this crowd sound like? Are
    they loud or are do they speak in soft murmurs? Perhaps there are bikes whizzing
    past with kids ringing their bells. All of these aspects are important in creating
    a convincing crowd.
  prefs: []
  type: TYPE_NORMAL
- en: Last, but not least, we have the crowd's movement. How do they move? Do they
    follow a specific path, are they guided down particular areas, or are they free
    to roam wherever they choose?
  prefs: []
  type: TYPE_NORMAL
- en: Animals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, not all crowds take on human (or part/like human) form. Crowds can also
    exist in terms of groups of animals. As we discussed previously, the same considerations
    also need to be taken into account when developing crowds of animals. You also
    have to pay attention to how animals interact with each other because it is quite
    different from the way humans do. For example, wolves are likely to be in different
    sized crowds, or "packs", than, say, a  flock of vultures or a herd of deer, as
    in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d74ac053-f9eb-4918-87d0-c8e854d85461.png)'
  prefs: []
  type: TYPE_IMG
- en: '(Top): Attacking groups of Vultures in *Assassin''s Creed: Origins*'
  prefs: []
  type: TYPE_NORMAL
- en: '(Bottom): Herd of deer in *Far Cry 4*'
  prefs: []
  type: TYPE_NORMAL
- en: Crowd movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to more technical aspects of a crowd's functionality, we must
    consider the extent of interaction that a crowd has with the player. For example,
    if a player hits them while running past them, do members of the crowd respond?
    If so, how?
  prefs: []
  type: TYPE_NORMAL
- en: 'In games like Pro Evolution Soccer, FIFA, Rocket League, etc., crowds don''t
    interact with the player beyond cheering or booing, depending on the situation.
    Of course, they also add to the atmosphere with inaudible chanting/conversations/cheering:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c833ee5c-e8c1-42d3-9ab0-591e8488f296.png)'
  prefs: []
  type: TYPE_IMG
- en: Crowd in *FIFA 2018*
  prefs: []
  type: TYPE_NORMAL
- en: Often, this behavior is created by using cleverly animated (vertex) materials
    to simulate a large crowd that the player sees only over a distance and doesn't
    interact with.
  prefs: []
  type: TYPE_NORMAL
- en: Crowd dynamics and creating realistic behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have talked about some of the characteristics that help to create realistic
    crowd behavior, let's talk about the ways that we can implement this from a more
    technical standpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Flow-based
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These types of approaches focus on the crowd rather than its components. This
    means that the distinctive behaviors of individuals (within the crowd) occur due
    to input from their surroundings.
  prefs: []
  type: TYPE_NORMAL
- en: Entity-based
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These types of approaches mean that the characters in these crowds do not have
    any autonomy. This is because their behavior is based on a set of predefined rules
    that are meant to simulate social/psychological influences that occur in individuals
    that are a part of a crowd. In this way, all the movements of characters are determined
    by these rules.
  prefs: []
  type: TYPE_NORMAL
- en: Agent-based
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is perhaps the most dynamic and flexible approach to crowds. In agent-based
    approaches, characters are autonomous and can interact with individuals. This
    is to say that each character within a crowd of this type has (to a certain extent)
    a level of intelligence, which allows them to react based on a set of rules that
    are influenced by their surroundings.
  prefs: []
  type: TYPE_NORMAL
- en: This is the kind of approach that we will be using with our AI systems, and,
    in this chapter, we will explore the built-in Unreal systems that handle crowds.
  prefs: []
  type: TYPE_NORMAL
- en: Crowds in Unreal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Unreal, handling a huge crowd might be challenging, especially if you are
    going to have a complicated system. In fact, a crowd system needs to run fast
    and make the crowd behave realistically.
  prefs: []
  type: TYPE_NORMAL
- en: Having a huge crowd that built-in systems don't scale properly means that you
    are probably basing (almost) your entire gameplay on the crowd. In this case,
    you should go for implementing your own Crowd system, even by modifying the built-in
    one. However, for most games, the built-in systems are more than enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Unreal, there are two built-in systems for crowd simulation/management.
    These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: UCharacterMovementComponent's RVO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detour Crowd System
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although it is possible to keep them both running, it is not advisable to do
    so. So, be sure to use the one that suits your needs the best, or create your
    own.
  prefs: []
  type: TYPE_NORMAL
- en: Reciprocal Velocity Obstacles (RVO)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Reciprocal Velocity Obstacles** (**RVO**) is an algorithm that was discovered
    by the three researchers Jur van den Berg, Ming C. Lin, and Dinesh Manocha in
    2008 in their paper "*Reciprocal Velocity Obstacles for Real-Time Multi-Agent
    Navigation*".'
  prefs: []
  type: TYPE_NORMAL
- en: The RVO algorithm is path agnostic, which means that it is not aware of the
    path that the agent is following, nor the navmesh where the agent is navigating.
    Moreover, each agent navigates independently of one another without explicit communication.
    As a result, RVO is very fast to run, even for a large number of agents, and provides
    sufficient realistic behavior if the number of incoming collisions is limited.
  prefs: []
  type: TYPE_NORMAL
- en: RVO in Unreal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The implementation of the RVO algorithm within the Unreal Engine goes way back
    to the Unreal Development Kit, or UDK (UE3). In UE4, you can find the algorithm
    that was implemented within the Character Movement Component.
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate RVO on a specific character, open up its *Character Movement Component*
    and navigate to the *Character Movement: Avoidance* section. Here, you will be
    able to turn on the algorithm and set a few settings, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/812b9af2-4c28-4a59-94ab-faf157ff92b2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following settings are available (you need to click on the little arrow
    at the bottom to expand all the settings):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use RVOAvoidance**: Specifies whether or not the RVO algorithm is used on
    this character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoidance Consideration Radius**: The RVO algorithm will consider only obstacles
    that fall within this radius. Hence, if nothing is within this radius, RVO will
    not change the course of the character. On the other hand, if obstacles (e.g.
    other characters) are present within this radius, RVO will try to avoid them.
    This parameter is really important, and it needs to be tweaked properly (depending
    on what kind of obstacles your character will encounter) when RVO is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoidance Weight**: This indicates how heavily RVO needs to intervene on
    the avoidance of the obstacles. In fact, the algorithm will try to average between
    the direction the character is heading, and a direction to avoid the obstacles.
    This is the strength of the RVO algorithms and determines its behavior. The default
    value is 0.5, which works in the majority of cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoidance UID**: This is an identification number that is automatically generated
    when RVO is used (you cannot set it). It is important when you want to interact
    with the Avoidance Manager (see the *RVO in C++* section for more information).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoidance Group**: This indicates which avoidance group(s) this character
    belongs to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Groups to Avoid**: This indicates which of the avoidance groups this character
    needs to avoid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Groups to ignore**: This indicates which of the avoidance groups this character
    needs to ignore, and thus not take them into consideration when performing RVO
    avoidance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of multiplayer games, the RVO algorithm will only run on the server.
  prefs: []
  type: TYPE_NORMAL
- en: This is enough to use the algorithm and use it in production for your game.
    However, if you are curious and want to dig a little bit deeper, move on to the
    following subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced RVO settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section is divided in two sections: what we can do in a blueprint, and
    what we can do in C++.'
  prefs: []
  type: TYPE_NORMAL
- en: RVO in Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have a reference to the character component, you will notice that you
    can read all of its variables (all of the Get-functions are here), but that you
    cannot set them (there are no Set-functions), as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ae2af71-d930-4de6-adb1-f72b4f3c0587.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It seems like you cannot turn RVO on and off any time you like during gameplay
    in Blueprint, but this is not true. In fact, it is still possible to slightly
    change RVO settings in real-time (at gameplay time). In particular, you can change
    whether RVO is running or not with the following node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7259a3c-19e0-42a4-9db9-62b3d8164b52.png)'
  prefs: []
  type: TYPE_IMG
- en: The reason why you cannot edit the bool variable directly is clear if you look
    at the C++ implementation, in which the character needs to be registered to an
    RVO manager. In fact, it might be the first time that RVO is turned on, and all
    the initialization (e.g. registering to the RVO manager) needs to be handled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, you can also change in which avoidance group(s) the character belongs
    and which ones, instead, should be avoided, by using the following two nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46b8286b-bc65-4980-8b98-bcca6dbf1912.png)'
  prefs: []
  type: TYPE_IMG
- en: Besides these three functions, you are pretty limited in what you can do in
    real-time with RVO, but C++ unlocks new possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: RVO in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, every time you reach the C++ realm in Unreal, your possibilities
    gets really wide in terms of what you can do. In this section, we explore some
    of these possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, you will have direct access to the *UAvoidanceManager*, which
    stores data of all the agents that use RVO.
  prefs: []
  type: TYPE_NORMAL
- en: From a reference of the *Character Movement Component*, you can retrieve the
    ***Avoidance UID***, which can be used to query the Avoidance Manager on getting
    the *FNavAvoidanceData* structure, which holds the specific avoidance data of
    the character. Besides having access to the data in the structure, you can use
    it to further query the *Avoidance Manager* to obtain more grain information.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say you want to do manual velocity planning. You can gain access to the
    current velocity by using the `GetAvoidanceVelocity()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the best way to learn about all of your possibilities is by looking
    at the source code. In particular, you will need to look at the following file:
    `Runtime/Engine/Classes/AI/Navigation/AvoidanceManager.h`.'
  prefs: []
  type: TYPE_NORMAL
- en: RVO observations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some of my observations from using this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Since it is path and navmesh agnostic, the agent could potentially be pushed
    away from the Navmesh. This means that you need to take into consideration this
    possibility (and how often this might happen, e.g. if your maps have wall boundaries,
    then the character cannot be pushed away from the navmesh).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want RVO working on non-character actors, then you will need to reimplement
    the RVO algorithm on your own (or adapt your actors to use the Character Movement
    Component).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RVO might not work well if there are many characters in a very confined space
    (e.g. non-realistic behavior, such as lateral sliding).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the Avoidance Consideration Radius is high and the character needs to position
    itself among other characters, the position might be difficult for the character
    (and thus lead to strange, weird, and unnatural behaviors).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RVO is very fast, even with many characters running RVO at the same level. In
    fact, the overhead cost is almost nothing if there are no obstacles, so by using
    an appropriate Avoidance Consideration Radius, many characters can be handled
    without any issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can implement the father of the RVO algorithm, the VO, which is RVO but
    without weighting. It is even faster if performance is really a concern, but realism
    will decrease. You can gather more information on this by taking a look at the
    references in the next section. For instance, by modifying the avoidance manager
    in the source code of the engine, you will be able to easily implement this algorithm
    (or anything else of your choice).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RVO resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some further RVO resources you can have a look at:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The original RVO paper is available at the following link: [http://gamma.cs.unc.edu/RVO/icra2008.pdf](http://gamma.cs.unc.edu/RVO/icra2008.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information about RVO from the creators: [http://gamma.cs.unc.edu/RVO](http://gamma.cs.unc.edu/RVO)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RVO version 2 (the version that''s implemented within Unreal engine): [http://gamma.cs.unc.edu/RVO2/](http://gamma.cs.unc.edu/RVO2/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detour Crowd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another built-in Unreal system is the ***Detour Crowd***. It is based on the
    *Recats Library*, and in contrast to RVO, it will take into consideration the
    Navmesh on which the agents are moving. The system works pretty much out of the
    box already, but, let's dig deep into how it works and how we can use it.
  prefs: []
  type: TYPE_NORMAL
- en: How the Detour Crowd system works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within your Game World exists an object called **DetourCrowdManager**. It is
    responsible for coordinating crowds in your game. In particular, an agent that
    is registered to the **DetourCrowdManager** will be taken into consideration.
    The **DetourCrowdManager** accepts anything that implements the **ICrowdAgentInterface**,
    which provides data to the Manager about the agent.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, under the hood, the *Detour Crowd Manager* is using the Detour Crowd
    algorithm that was developed by *Mikko Mononen* in the *Recast Library*, which
    has been slightly modified by Epic Games for their needs. Therefore, the Detour
    Crowd Component offers an interface between the *Unreal Framework* and the *Recast
    Detour*. You can find more information about this by reviewing the resources at
    the end of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Potentially, you can create an agent by implementing the **ICrowdAgentInterface**.
    However, Unreal provides you with a special component called **UCrowdFollowingComponent**,
    which implements the **ICrowdAgentInterface**, along with other functionalities.
    As a result, anything that has the **UCrowdFollowingComponent** is eligible to
    be an agent with the Crowd Manager. Actually, the component itself will auto-register
    itself to the Crowd Manager and will activate the *Detour Behaviour*.
  prefs: []
  type: TYPE_NORMAL
- en: To make things easier, the **ADetourCrowdAIController** is a pre-made controller
    that will automatically add the **UCrowdFollowingComponent** to the controller
    itself. Hence, this time, the system is triggered by the AI Controller from the
    **Character Movement Component** directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram helps explain this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ace7f5ee-2899-442d-aee4-ffd57beb66bf.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the Detour Crowd system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest way to use the *Detour Crowd* system is by letting your AI controller
    inheriting from the Detour Crowd AI Controller, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dce536e2-243b-4ed3-aaa2-da50d8d9b7a6.png)'
  prefs: []
  type: TYPE_IMG
- en: In C++, you will need to inherit from **ADetourCrowdAIController **(or add the
    ***UDetourCrowdFollowingComponent*** to your controller).
  prefs: []
  type: TYPE_NORMAL
- en: Once you have done this for all the controllers that you want to use the *Detour
    Crowd*, the system will pretty much work out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Detour Crowd settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are using the **UCrowdFollowingComponent**, this component will implement
    the **ICrowdAgentInterface** by using the **Avoidance Settings** in the **Character
    Movement Component** (if one is available).
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, all the **Avoidance Settings** we saw in the *RVO* section will
    be taken into consideration by the *Detour Crowd*. Therefore, all of the settings
    that are highlighted in the following screenshot will still be valid for our AI
    Character:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48a1a4c1-fc4b-42a3-9881-3535c05cbbac.png)'
  prefs: []
  type: TYPE_IMG
- en: Please note that the **Avoidance Weight** will not be taken into consideration
    by the Detour System since it is an *RVO*-specific parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, all the blueprint functions we have seen (e.g. to change the group
    mask) are also valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'These were specific settings on a per-character basis, but it is possible to
    tweak the overall *Detour Crowd settings*. To do this, navigate into the **Project
    Settings**, and under the **Engine** section, you will find an entry called **Crowd
    Manager**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9679dcc6-72ea-4e63-b614-5da06ba8b31e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From here, we have access to all the ***Detour Crowd Manager settings***. Most
    of these settings are from the original *Recast Crowd algorithm*, and the *Unreal
    Detour Crowd Manager* offers an interface where you can set these variables in
    the algorithm. Let''s start from the easier ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Max Agents**: This is the maximum number of agents that the Crowd Manager
    will handle. Of course, the higher the number, the more agents you can place at
    once, but this will hit performance. You should plan how many agents your game
    needs carefully. Moreover, if you look at the source code, this number will be
    used to allocate the memory that''s necessary for the Crowd Manager to handle
    the agents. This is useful to keep in mind in situations in which memory is low.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max Agent Radius**: This is the maximum size that an agent that has detoured
    from the Crowd Manager can go.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max Avoided Agents**: This is the maximum number of agents that the Detour
    System takes into consideration, and it also called neighbors. In other words,
    this specifies how many neighbor agents (maximum) should be taken into account
    for the avoidance behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max Avoided Walls**: This is the maximum number of walls (in general, obstacle
    segments) that the Detour System should take into consideration. It works in a
    similar fashion to Max Avoided Agents, but asks about how many segments of the
    surrounding obstacles around the system need to be taken into account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Navmesh Check Interval**: This is for implementing how many seconds an agent
    that has gone off the navmesh should check and recalculate its position (the system
    will try to push the agent back onto the navmesh).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path Optimization Interval**: This checks, in seconds, how often an agent
    should try to re-optimize its own path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separation Dir Clamp**: When another agent is behind, this value indicates
    the clamp separation force to left/right (dot product between *forward* and *dirToNei;* thus,
    a value of -1 means that this separation behavior is disabled).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path Offset Radius Multiplier**: When the agent is turning close to a corner,
    an offset to the path is applied. This variable is a multiplier to this offset
    (so that you are free to reduce and increase this offset).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resolve Collisions**: Despite the best efforts of the Detour System, agents
    may still collide. In such an event, the collision should be handled by the Detour
    System (with a value of true for this variable). In this case, this variable is
    set to false and the agents will be using a Character Movement Component. This
    component will take care of resolving the collision.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Avoidance Config** parameter, which is shown in the following screenshot,
    is the heart of how sampling is done within the Detour Crowd Algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a132e02e-9383-4844-b0c3-3aa648b324bf.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Avoidance Config** is an array of different sampling configurations, with
    slightly different parameters set. By default, there are four of them, corresponding
    to different sampling avoidance quality: low, medium, good, and high, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: The quality level is set in the **UCrowdFollowingComponent** with the **AvoidanceQuality**
    variable, which uses the **ECrowdAvoidanceQuality** enum. If you have a reference
    to your **UCrowdFollowingComponent**, you can use the `SetCrowdAvoidanceQuality()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the setting, if you want to add or remove a configuration, you
    will need to create your own version of the **UCrowdFollowingComponent** (alternatively,
    you can inherit from it and override functions), which takes into consideration
    a different number of configurations.
  prefs: []
  type: TYPE_NORMAL
- en: However, changing the number of configuration means that your game/application
    is making particular use of the *Detour System*!
  prefs: []
  type: TYPE_NORMAL
- en: 'Without changing the number of configurations, you can change the settings
    of these four quality configurations. These parameters are shown in the following
    screenshot (this is from the first configuration):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/694621a2-55ad-4a41-a1b1-58aedc32f82d.png)'
  prefs: []
  type: TYPE_IMG
- en: To fully understand these settings, you should get to know how the algorithm
    works, but let's try and get our head around it without this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The part of the algorithm that does the sampling starts by creating a set of
    rings (the number is indicated in the **Adaptive Rings** parameter) around the
    center point (where the agent is initially, with a bias, due to the **Velocity
    Bias** parameter, in the direction of the velocity). Each of these rings is sampled
    (divided) by **Adaptive Division**. Then, the algorithm recursively refines the
    search by using a smaller set of rings, which are centered on the best sample
    of the previous iteration. The algorithm repeats this process **Adaptive Depth**
    times. At each iteration, the best sample is chosen by considering the following,
    and the different parameters determine the weight (how important the consideration
    is with respect to the others):'
  prefs: []
  type: TYPE_NORMAL
- en: Does the direction of the agent match the current velocity? The weight is **DesiredVelocityWeight**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the agent go sideways? The weight is **SideBiasWeight**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the agent collide with any known obstacle? The weight is **ImpactTimeWeight**
    (it scans a range by considering the current velocity of the agent if it collides
    using that velocity within **ImpactTimeRange** seconds).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram should help you understand the different parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb115d43-0ae0-40b4-b1ce-0a47d1a8dee4.png)'
  prefs: []
  type: TYPE_IMG
- en: Debugging the Detour Crowd Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Crowd Manager has an integration with the visual logger, which means that,
    with some work, we can visually debug the Detour Crowd Manager. We will explore
    this in more detail in [Chapter 13](a8cbf52e-71e1-4f9d-a2bd-913a1e8bd8e1.xhtml), *Gameplay
    Debugger*, in which we will learn more about the Visual Logger further.
  prefs: []
  type: TYPE_NORMAL
- en: More crowd resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here some resources if you want to extend your knowledge of the Detour Crowd
    Algorithm and/or explore other alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mikko Mononen''s original Recast Library: [https://github.com/recastnavigation/recastnavigation](https://github.com/recastnavigation/recastnavigation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A collection of many interesting research algorithms for handling crowds: [http://gamma.cs.unc.edu/research/crowds](http://gamma.cs.unc.edu/research/crowds)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, you are welcome to keep exploring on your own!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how the Unreal Engine handles crowds. In particular,
    we have seen two built-in systems. The first one is called ***Reciprocal Velocity
    Obstacles (RVO)***, which is very fast, but not very precise. The second is the
    **Detour Crowd**, which is a bit more expensive, but more precise and realistic.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will move on and learn how to implement our own *Behavior
    Tree* from scratch.
  prefs: []
  type: TYPE_NORMAL
