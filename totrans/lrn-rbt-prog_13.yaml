- en: '*Chapter 11*: Programming Encoders with Python'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：使用Python编程编码器'
- en: It is useful in robotics to sense the movements of motor shafts and wheels.
    We drove a robot along a path back in [*Chapter 7*](B15660_07_Final_ASB_ePub.xhtml#_idTextAnchor131),
    *Drive and Turn – Moving Motors with Python*, but it's unlikely that it has stayed
    on course. Detecting this and traveling a specific distance is useful in creating
    behaviors. This chapter investigates the choice made by the sensor, as well as
    how to program the robot to move in a straight line and for a particular distance.
    We then look at how to make a specific turn. Please note that this chapter does
    contain math. But don't worry, you'll follow along easily.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '在机器人技术中，感知电机轴和轮子的运动是有用的。我们曾在[*第7章*](B15660_07_Final_ASB_ePub.xhtml#_idTextAnchor131)中让机器人沿着路径行驶，*使用Python驱动和转向——移动电机*，但机器人不太可能一直保持在轨道上。检测这一点并行驶特定距离对于创建行为是有用的。本章将探讨传感器的选择，以及如何编程机器人以直线行驶和行驶特定距离。然后我们来看看如何进行特定的转弯。请注意，本章确实包含数学内容。但别担心，你会轻松跟上。 '
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: Measuring the distance traveled with encoders
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用编码器测量行驶的距离
- en: Attaching encoders to the robot
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将编码器连接到机器人上
- en: Detecting the distance traveled in Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中检测行驶的距离
- en: Driving in a straight line
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在直线上驾驶
- en: Driving a specific distance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驾驶特定距离
- en: Making a specific turn
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行特定的转弯
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we get started, make sure you have the following parts:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请确保你拥有以下部件：
- en: 'The Raspberry Pi robot and the code from the previous chapter: [https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter10](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter10).'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi机器人和上一章的代码：[https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter10](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter10)。
- en: Two slotted speed sensor encoders. Search for slotted speed sensor, Arduino
    speed sensor, LM393 speed sensor, or the Photo Interrupter sensor module. Include
    the term *3.3 V* to ensure its compatible. See the *The encoders we are using*
    section for images of these.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个带槽的速度传感器编码器。搜索带槽速度传感器、Arduino速度传感器、LM393速度传感器或光电中断传感器模块。包含术语*3.3 V*以确保其兼容性。参见*我们使用的编码器*部分中的图片。
- en: Long male-to-female jumper cables.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长的公对母跳线。
- en: A ruler to measure the wheels' size on your robot – or better yet, calipers,
    if you can use them.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用直尺来测量你机器人轮子的尺寸——或者更好的是，如果你能使用的话，使用卡尺。
- en: 'The code for this chapter is available on GitHub: [https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter11](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter11).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在GitHub上找到：[https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter11](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter11)。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2XDFae0](https://bit.ly/2XDFae0)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际运行效果：[https://bit.ly/2XDFae0](https://bit.ly/2XDFae0)
- en: Measuring the distance traveled with encoders
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用编码器测量行驶的距离
- en: '**Encoders** are sensors that change value based on the movement of a part.
    They detect where the shaft is or how many times an axle has turned. These can
    be rotating or sensing along a straight-line track.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**编码器**是随部件运动而改变值的传感器。它们检测轴的位置或轴旋转的次数。这些可以是旋转的或沿直线轨道感应的。'
- en: Sensing how far something has traveled is also known as **odometry**, and the
    sensors can also be called **tachometers**, or **tachos** for short. The sensors
    suggested in the *Technical requirements* section may also show up as **Arduino
    tacho** in searches.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 感知某物行驶的距离也被称为**里程计**，这些传感器也可以称为**转速表**，或简称**转速计**。在*技术要求*部分建议的传感器也可能在搜索中显示为**Arduino转速计**。
- en: Where machines use encoders
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机器使用编码器的位置
- en: Our robots use electronic sensors. Cars and large commercial vehicles use electronic
    or mechanical sensors for speedometers and tachos.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的机器人使用电子传感器。汽车和大型商用车辆使用电子或机械传感器作为速度表和转速表。
- en: Printers and scanners combine encoders with DC motors as an alternative to stepper
    motors. Sensing how much of an arc the robot has turned through is an essential
    component of servomechanisms, which we saw in [*Chapter 10*](B15660_10_Final_ASB_ePub.xhtml#_idTextAnchor192),
    *Using Python to Control Servo Motors*. High-end audio or electrical test/measurement
    systems use these in control dials. These are self-contained modules that look
    like volume knobs but users can turn them indefinitely.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 打印机和扫描仪将编码器与直流电机结合使用，作为步进电机的替代品。感应机器人转动过的弧度是伺服机构的一个基本组成部分，我们在[*第10章*](B15660_10_Final_ASB_ePub.xhtml#_idTextAnchor192)中看到了它，*使用Python控制伺服电机*。高端音频或电气测试/测量系统在控制旋钮中使用这些。这些是自包含的模块，看起来像音量旋钮，但用户可以无限旋转它们。
- en: With this basic understanding of what encoders are, let's now look at some of
    their types.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在对编码器有基本了解之后，现在让我们来看看它们的一些类型。
- en: Types of encoders
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码器的类型
- en: '*Figure 11.1* shows four different encoder sensors, each of which uses different
    mechanisms to measure movement (1–3), along with an encoder wheel and strip in
    panel 4:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.1*显示了四种不同的编码器传感器，每个传感器都使用不同的机制来测量运动（1–3），以及面板4中的编码器轮和条：'
- en: '![](img/B15660_11_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_11_01.jpg)'
- en: Figure 11.1 – Encoder sensors
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 编码器传感器
- en: 'These sensors fall into a few categories, as shown in *Figure 11.1*, and correspond
    to the points that follow:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些传感器分为几个类别，如图11.1所示，并对应以下要点：
- en: This is a **variable resistor**. These analog devices can measure a turn but
    don't tend to allow continuous rotation. They have mechanical wipers on a metal
    or resistant track, which can wear down. This is not strictly an encoder but is
    handy. On the Raspberry Pi, they require analog-to-digital conversion, so they
    aren't suitable for this application. Servo motors also use these.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个**可变电阻器**。这些模拟设备可以测量转动，但通常不允许连续旋转。它们在金属或电阻轨道上有机械刷，可能会磨损。这严格来说不是一个编码器，但很方便。在Raspberry
    Pi上，它们需要模拟到数字转换，所以不适合这个应用。伺服电机也使用这些。
- en: This motor includes magnet-sensing encoders, highlighted by the white box, known
    as **hall-effect sensors**. Magnets on a wheel or strip pass next to the sensor,
    causing the sensor values to go high and low.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这台电机包括由白色框突出的磁感应编码器，称为**霍尔效应传感器**。轮或条上的磁铁在传感器旁边通过，导致传感器值高低变化。
- en: This is a standard optical sensor. Using a slot with an IR beam passing through,
    they sense when the beam is interrupted. Computer trackballs, printers, and robotics
    use these. These produce a chain of pulses. Due to the beam being interrupted,
    we call them **photo interrupters**, **optical encoders**, or **opto-interrupters**.
    We will be using this kind.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个标准的光学传感器。使用带有红外光束通过的槽，它们感应光束被中断。计算机轨迹球、打印机和机器人使用这些。这些产生一系列脉冲。由于光束被中断，我们称它们为**光断路器**、**光学编码器**或**光电断路器**。我们将使用这种类型。
- en: This shows a slotted wheel and a slotted strip for use with optical sensors.
    The ribbon is suitable for linear encoding and the wheel for encoding turns. They
    both have transparent and opaque sections. People make a variation using a light
    sensor and light/dark cells, but these are less common.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这显示了用于光学传感器的槽轮和槽条。带状条适合线性编码，而轮适合编码转动。它们都有透明和不透明部分。人们使用光传感器和光/暗单元来制作变体，但这些比较少见。
- en: Having seen some of the types of encoders, let's take a closer look at how they
    represent speed and movement.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 看过一些编码器的类型后，让我们更仔细地看看它们是如何表示速度和运动的。
- en: Encoding absolute or relative position
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码绝对或相对位置
- en: '**Relative encoders** can encode a relative change in position – that we have
    taken a certain number of steps clockwise or anticlockwise, or forward/backward
    along an axis, for example. They can only measure a position relative to the last
    time we measured by counting the number of slots that have passed. These can also
    be called **incremental encoders**. They are inexpensive and straightforward in
    hardware. Relative encoders are limited in that they memorize the previous position
    to create the next and accumulate errors.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**相对编码器**可以编码位置的变化量 – 例如，我们顺时针或逆时针移动了一定数量的步数，或者沿着一个轴向前/向后移动，例如。它们只能通过计数通过的槽的数量来测量相对于上次测量的位置。这些也可以称为**增量编码器**。它们在硬件上既便宜又简单。相对编码器的限制在于它们记住前一个位置以创建下一个，并累积错误。'
- en: Another type is **absolute encoders**. These can encode the position along or
    around an axis to an exact position. Absolute encoders do not need information
    about the previous position but may need calibrating to determine how an encoding
    matches a real-world location.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型是**绝对编码器**。这些可以沿或围绕轴编码位置到精确的位置。绝对编码器不需要有关先前位置的信息，但可能需要校准以确定编码如何与实际世界位置匹配。
- en: 'The following figure shows the types in comparison:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了不同类型之间的比较：
- en: '![](img/B15660_11_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_11_02.jpg)'
- en: Figure 11.2 – Comparing absolute and relative sensing
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 比较绝对和相对传感
- en: The diagrams in *Figure 11.2* illustrate this difference. The circle on the
    left represents a movement *by* 30 degrees, from a memorized position of 30 degrees.
    This
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.2*中的图示说明了这种差异。左边的圆圈代表从记忆中的30度位置移动了30度。这'
- en: works, assuming that the original memorized position is accurate. Every time
    it is measured, a movement is measured. The circle on the right shows a position
    *at* 60 degrees from a zero point. If a sensor can tell you where something is
    *at*, then it is absolute. If you can tell you how much it has moved *by*, it
    is relative.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 的工作原理，假设原始记忆中的位置是准确的。每次测量时，都会测量一个移动。右边的圆圈显示了从零点60度的位置。如果一个传感器可以告诉你某物在哪里，那么它是绝对的。如果你可以告诉你它移动了多少，那么它是相对的。
- en: In a crude form, a variable resistor can also be an absolute encoder, as used
    in servo motors to sense their position. Absolute position encoding can be done
    through optical or magnetic markers on a wheel or strip, allowing great precision
    in absolute positioning. These sensors can be bulky or expensive or require many
    inputs. An absolute encoder strip or wheel is also known as a scale.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在粗略的形式中，可变电阻也可以是绝对编码器，如用于伺服电机以感知其位置的编码器。绝对位置编码可以通过轮或条上的光学或磁性标记来完成，从而实现绝对定位的极高精度。这些传感器可能体积庞大或昂贵，或需要许多输入。绝对编码器条或轮也被称为刻度尺。
- en: Encoding direction and speed
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码方向和速度
- en: 'Basic relative encoding measures how many wheel slots pass the sensor. This
    gives the speed and distance. By using two sensors slightly apart, you can also
    encode the direction. *Figure 11.3* shows how this works:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 基本相对编码衡量传感器通过的轮槽数量。这给出了速度和距离。通过使用稍微分开的两个传感器，你还可以编码方向。*图11.3*展示了这是如何工作的：
- en: '![](img/B15660_11_03.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_11_03.jpg)'
- en: Figure 11.3 – Encoding speed and direction with multiple sensors
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 – 使用多个传感器编码速度和方向
- en: The system on the left encodes the speed. As the slots pass the sensors, they
    generate electronic pulses. Each pulse has a **rising** edge, where it goes up,
    and a **falling** edge, where it goes down. To count the number of pulses, we
    can count these edges. If you drive a motor with a direction, you can use a system
    with a single sensor like this, as we will do in our robot.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 左边的系统编码速度。当槽通过传感器时，它们会产生电子脉冲。每个脉冲都有一个**上升**沿，它上升，以及一个**下降**沿，它下降。为了计数脉冲数，我们可以计数这些边缘。如果你用一个有方向的系统驱动电机，你可以使用像这样的单个传感器系统，正如我们将在我们的机器人中做的那样。
- en: The wheel on the right encodes direction by adding a second sensor. The slot
    edges will make the sensor value change at different points in a cycle, with a
    sequence we've labeled **1**, **2**, **3**, **4**. The direction of the sequence
    indicates the direction of the wheel, along with its speed. As there are four
    phases, this is known as quadrature encoding.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 右边的轮通过添加第二个传感器来编码方向。槽边缘将在周期中的不同点改变传感器值，我们将其标记为**1**、**2**、**3**、**4**。序列的方向指示轮的方向，以及其速度。由于有四个相位，这被称为正交编码。
- en: Industrial robots use a **record-and-replay** interface. The user will hit a
    record button and push a robot, such as an arm, through a set of movements, then
    press a stop button. The user has recorded this set of movements, and they could
    ask the robot to replay them.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 工业机器人使用**记录和回放**接口。用户会按下记录按钮，推动一个机器人，例如一个手臂，通过一系列动作，然后按下停止按钮。用户已经记录了这一系列动作，他们可以要求机器人回放这些动作。
- en: To build a robot with this record-and-replay system, or a mouse/trackball, the
    direction is essential information, so the additional complexity needed to encode
    the directions is required.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建具有这种记录和回放系统的机器人，或鼠标/轨迹球，方向是必要的信息，因此需要额外的复杂性来编码方向。
- en: We will use the cheaper and simpler option in our robot, using a single sensor
    to measure relative speed only. In our code, we will assume that each wheel's
    speed sensor is going in the direction we drive.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的机器人中，我们将使用更便宜、更简单的选项，使用单个传感器仅测量相对速度。在我们的代码中，我们将假设每个车轮的速度传感器是按照我们驾驶的方向移动的。
- en: The encoders we are using
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们使用的编码器
- en: 'We will use optical encoders in a slot shape that fits right above the encoder
    wheels we added in [*Chapter 6*](B15660_06_Final_ASB_ePub.xhtml#_idTextAnchor096),
    *Building Robot Basics – Wheels, Power, and Wiring*. These encoders have digital
    outputs, and we can count the pulses from them in Python to sense how far a wheel
    has turned. *Figure 11.4* shows two types of sensor that I recommend:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第6章*](B15660_06_Final_ASB_ePub.xhtml#_idTextAnchor096)“构建机器人基础 – 轮子、电源和布线”中添加的编码器轮上使用光学编码器，这些编码器轮的形状正好适合我们添加的编码器轮上方。这些编码器有数字输出，我们可以通过Python从它们计数脉冲来感知轮子转动的距离。*图11.4*
    显示了我推荐的两类传感器：
- en: '![](img/B15660_11_04.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_11_04.jpg)'
- en: Figure 11.4 – The types of sensor we recommend
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 – 我们推荐的传感器类型
- en: On the left is the FC-03 photo interrupter module, and on the right is the Waveshare
    photo interrupter module. Modules that have 3.3 V in their supply voltage specification
    are suitable. Using 5 V-only modules will require level shifters and additional
    wiring, as discussed in [*Chapter 8*](B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150),
    *Programming Distance Sensors with Python*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 左边是FC-03光电中断模块，右边是Waveshare光电中断模块。具有3.3 V供电电压规范的模块是合适的。使用仅5 V的模块将需要电平转换器和额外的布线，如[*第8章*](B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150)“使用Python编程距离传感器”中所述。
- en: We are going to use encoder wheels that are attached to the motor shafts. These
    are in line with the wheels. If the encoder wheels are running at a different
    rate from the wheels, we need to account for this. There are conditions that they
    cannot account for, such as slipping, as well as wheel and tire sizes. Encoders
    attached to separate idler wheels give better data, but they are trickier to connect
    to a robot and keep in contact with the floor.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用安装在电机轴上的编码器轮。这些轮子与车轮对齐。如果编码器轮的转速与车轮不同，我们需要考虑这一点。有一些条件它们无法考虑，例如打滑，以及车轮和轮胎的大小。安装在单独的惰轮上的编码器可以提供更好的数据，但它们连接到机器人并保持与地面的接触会更复杂。
- en: Now, you've seen what encoders can do, counting how much a wheel has turned
    to determine how far you've gone, and you've seen some of the types of encoders
    and which type to buy (3.3 V). You've also had a quick overview of how they work,
    by counting pulses. In the next section, we will build them into the robot.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经看到了编码器能做什么，通过计算轮子转动的次数来确定你走了多远，你也看到了一些编码器的类型以及应该购买哪种（3.3 V）。你还快速地了解了它们是如何通过计数脉冲来工作的。在下一节中，我们将把它们集成到机器人中。
- en: Attaching encoders to the robot
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将编码器连接到机器人
- en: Our robot is now getting quite busy, and our Raspberry Pi is above the encoder's
    slots. Due to the slots being under the Raspberry Pi, we should wire them in a
    little before returning the Raspberry Pi. After bolting in the Raspberry Pi, we
    wire the encoders to its GPIO, as well as the power and ground.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的机器人现在变得相当忙碌，我们的树莓派位于编码器槽口之上。由于槽口位于树莓派下方，我们应该在将树莓派放回之前稍微提前布线。在拧紧树莓派后，我们将编码器连接到其GPIO，以及电源和地线。
- en: '*Figure 11.5* shows what the robot block diagram looks like after attaching
    the encoders:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.5* 展示了在连接编码器后机器人的框图：'
- en: '![](img/B15660_11_05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_11_05.jpg)'
- en: Figure 11.5 – Robot block diagram with encoders
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 – 带有编码器的机器人框图
- en: This block diagram adds a left and right encoder, each with an arrow for the
    information flow connecting them to the Raspberry Pi. The highlighted elements
    are the new ones.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个框图添加了一个左编码器和右编码器，每个编码器都有一个箭头表示信息流，将它们连接到树莓派。突出显示的元素是新的。
- en: 'Before we start changing the robot and making it harder to see, we need to
    know the number of slots in the encoder wheel for later:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始更改机器人和使其更难观察之前，我们需要知道编码器轮的槽口数量，以备后用：
- en: '![](img/B15660_11_06.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_11_06.jpg)'
- en: Figure 11.6 – Encoder wheel
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 – 编码器轮
- en: My encoder wheels, shown in *Figure 11.6*, ended up having 20 slots. Ensure
    you use the number of spaces your encoder wheels have.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我展示在 *图11.6* 中的编码器轮最终有20个槽口。确保你使用你的编码器轮的槽口数量。
- en: Preparing the encoders
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备编码器
- en: 'Before we can use the encoder sensors, we need to prepare and fit them. As
    the encoders are going under the Raspberry Pi, we should attach the male-to-female
    jump wires to the sensors now. I suggest covering any electrical contacts that
    are sticking up under the Raspberry Pi with a little insulation tape:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用编码器传感器之前，我们需要准备并安装它们。由于编码器将放在树莓派下方，我们现在应该将公对母跳线连接到传感器上。我建议用一小段绝缘胶带覆盖树莓派下方的任何突出来的电气接触点：
- en: '![](img/B15660_11_07.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_11_07.jpg)'
- en: Figure 11.7 – The sensors with cable connections
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 – 带有电缆连接的传感器
- en: Notably, the cables should be plugged into the ground (**GND**), voltage (**3
    V**, **Vin**, or **VCC**), and digital output (**D0**/**OUT**), as shown in *Figure
    11.7*. If it is present, do not connect the analog output (**A0**) pin. If possible,
    the ground pin should have the darkest color, or the voltage should be the lightest
    color. To help keep this clear, I suggest wrapping a small strip of insulation
    tape around the signal line's end.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 显著的是，电缆应插入到图11.7所示的接地（**GND**）、电压（**3 V**、**Vin**或**VCC**）和数字输出（**D0**/**OUT**）。如果存在，不要连接模拟输出（**A0**）引脚。如果可能，接地引脚应具有最深的颜色，或电压应是最浅的颜色。为了帮助保持清晰，我建议在信号线的末端缠绕一小段绝缘胶带。
- en: Important note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As these sensors' pin configurations can vary, get a reference photo of the
    sensor pin labels before putting it under the Raspberry Pi.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些传感器的引脚配置可能不同，在将传感器放在树莓派下方之前，先拍一张传感器引脚标签的参考照片。
- en: Lifting the Raspberry Pi
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抬起树莓派
- en: 'The encoder sensors need to go underneath the Raspberry Pi, so the Raspberry
    Pi needs to be gently lifted (without disrupting the wires) to accommodate them.
    The sequence of photos in *Figure 11.8* shows how to raise it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 编码器传感器需要放在树莓派下方，因此需要轻轻地抬起树莓派（不要弄断电线）以适应它们。图11.8中的照片序列显示了如何抬起它：
- en: '![](img/B15660_11_08.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_11_08.jpg)'
- en: Figure 11.8 – Unscrewing and lifting off the Raspberry Pi
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 – 拧下并抬起树莓派
- en: 'Refer to *Figure 11.8* and carry out the following steps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 参考图11.8并执行以下步骤：
- en: You need to unscrew the bolts holding the Raspberry Pi to the chassis carefully.
    Put the screws aside for replacing the Raspberry Pi on the robot so that it can
    gently lift away.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要小心地拧下固定树莓派到底盘的螺栓。将螺丝放在一边，以便在机器人上更换树莓派，这样它可以轻轻地抬起。
- en: Gently lift the Raspberry Pi away from the robot without disrupting the cables.
    The photo shows how your robot should look.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 轻轻地将树莓派从机器人上抬起，不要弄断电线。照片显示了您的机器人应有的样子。
- en: Great! Now that the Raspberry Pi is lifted, there is space for fitting the encoders
    under it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在树莓派已经抬起，下面有空间安装编码器。
- en: Fitting the encoders onto the chassis
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将编码器安装到底盘上
- en: 'Now that you have wired the encoders, you can fit them to the robot chassis.
    As a guide, *Figure 11.9* shows a bare chassis with each of the sensor types fitted
    to show you where you push them in:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经连接了编码器，可以将它们安装到机器人底盘上。作为指导，图11.9显示了一个裸露的底盘，每种类型的传感器都已安装到位，以显示您应该将其推入的位置：
- en: '![](img/B15660_11_09.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_11_09.jpg)'
- en: Figure 11.9 – Fitting the encoder sensors
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 – 安装编码器传感器
- en: 'Refer to *Figure 11.9* and complete these steps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 参考图11.9并完成以下步骤：
- en: Gently push the encoders into the slots around the encoder wheel.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 轻轻地将编码器推入编码器轮周围的槽中。
- en: The sensors should friction fit into the slots above the encoder wheels and
    stay in place.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传感器应该摩擦地装入编码器轮子上的槽中，并保持在原位。
- en: Once these are in place, you can replace the screws to attach the Raspberry
    Pi to the chassis. You may need different-sized standoffs to accommodate it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些安装到位，您就可以拧上螺丝，将树莓派固定到底盘上。您可能需要不同尺寸的垫圈来适应它。
- en: Important note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: At this point, check that all your connections are back in place. The motor
    wires are likely to have come loose.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，检查所有连接是否都已恢复原位。电机电线可能已经松动了。
- en: With the encoders attached and the Raspberry Pi back in place, you are ready
    to wire them in.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在将编码器安装好并将树莓派放回原位后，您就可以开始连接电线了。
- en: Wiring the encoders to the Raspberry Pi
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将编码器连接到树莓派的电线
- en: We can now start making wire connections for the sensors using the breadboard.
    We'll use a circuit diagram to guide our connections.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用面包板开始为传感器制作电线连接。我们将使用电路图来指导我们的连接。
- en: '*Figure 11.10* shows the connections for these sensors:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.10*显示了这些传感器的连接：'
- en: '![](img/B15660_11_10.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_11_10.jpg)'
- en: Figure 11.10 – Circuit for connecting the encoders to the Raspberry Pi
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 – 将编码器连接到树莓皮的电路
- en: '*Figure 11.10* shows the circuit for connecting the encoders to the Raspberry
    Pi. This diagram continues from the circuit seen in [*Chapter 8*](B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150),
    *Programming Distance Sensors with Python*. The new connections have thicker wire
    lines.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.10*显示了将编码器连接到树莓派的电路。这个图表是从[*第8章*](B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150)中看到的电路继续的，*使用Python编程距离传感器*。新的连接有更粗的电线。'
- en: On the right of *Figure 11.10* are the right and left encoder modules. The sensor
    will have a **VCC**, **VIN**, **3 V**, or just **V** label. Connect this to the
    3.3 V line. Find the GND pin labeled **GND**, **0V**, or just **G** and connect
    it to the black/blue band on the breadboard. The encoders also have a pin labeled
    **DO** (digital out), **SIG** (signal), or just **S**, connected to a GPIO pin
    for the digital signal. We connect the digital outputs from the sensors to GPIO
    pins 4 for the left encoder and 26 for the right encoder.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图11.10*的右侧是左右编码器模块。传感器将有一个**VCC**、**VIN**、**3 V**或仅**V**标签。将其连接到3.3 V线。找到标记为**GND**、**0V**或仅**G**的GND引脚，并将其连接到面包板上的黑色/蓝色带。编码器还有一个标记为**DO**（数字输出）、**SIG**（信号）或仅**S**的引脚，连接到用于数字信号的GPIO引脚。我们将传感器的数字输出连接到GPIO引脚4（左侧编码器）和26（右侧编码器）。
- en: Some encoder sensors have additional connections, such as **Analog Out** (**AO**),
    which we will not use and will leave unconnected.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编码器传感器有额外的连接，例如**模拟输出**（**AO**），我们不会使用它，并将其保持未连接状态。
- en: 'Let''s perform the following steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: Connect the sensor's pins to the breadboard. Pay attention to the labels on
    the sensor – some have a different pin ordering.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将传感器的引脚连接到面包板上。注意传感器的标签——有些有不同的引脚顺序。
- en: Connect the Raspberry Pi GPIO pins 4 and 26 to the breadboard.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派的GPIO引脚4和26连接到面包板上。
- en: Make the breadboard power connections using precut wires.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用预切割的电线制作面包板的电源连接。
- en: Important note
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: The number of wire-to-wire points on this robot makes it hard to add new connections
    or repair. Although beyond the scope of this book, making custom **Printed Circuit
    Boards** (**PCBs**) makes this thicket of cabling much neater. PCBs are also less
    fragile and takes up less space. Changing it does, however, come with a cost.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个机器人上的线对线点数使得添加新的连接或维修变得困难。尽管这超出了本书的范围，但制作定制的**印刷电路板**（**PCBs**）可以使这堆电缆变得整洁得多。PCBs也更坚固，占用的空间更小。然而，改变它却要付出代价。
- en: It is possible to shortcut the breadboard and wire the sensor into the Raspberry
    Pi; however, the breadboard helps distribute the power connections and groups
    the sensor connections.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能通过跳过面包板，将传感器直接连接到树莓派；然而，面包板有助于分配电源连接并分组传感器连接。
- en: We make this circuit in the context of a busy robot with other connections.
    If the cables from the sensors to the robot are not long enough, use a further
    set of male-to-female cables, using the same technique seen for the sonar scan
    in [*Chapter 10*](B15660_10_Final_ASB_ePub.xhtml#_idTextAnchor192), *Using Python
    to Control Servo Motors*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个繁忙的机器人和其他连接的上下文中制作这个电路。如果传感器到机器人的电缆不够长，请使用一套额外的公对母电缆，使用与[*第10章*](B15660_10_Final_ASB_ePub.xhtml#_idTextAnchor192)中看到的超声波扫描相同的技巧。
- en: In this section, you've learned how to connect the sensors and have made them
    ready to program. In the next section, we will write some code to test these sensors
    and then measure distances.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你已经学会了如何连接传感器，并使它们准备好编程。在下一节中，我们将编写一些代码来测试这些传感器，然后测量距离。
- en: Detecting the distance traveled in Python
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中检测行驶的距离
- en: Using encoder sensor devices requires us to count pulses. In this section, we
    will create code to turn on the motors and count pulses for a while. The code
    validates that the sensors are connected correctly. We then take this code and
    make it part of the robot class as a behavior.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用编码器传感器设备需要我们计数脉冲。在本节中，我们将创建代码来打开电机并计数一段时间内的脉冲。代码验证传感器是否正确连接。然后我们将此代码作为行为集成到机器人类中。
- en: Introducing logging
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍日志记录
- en: So far in our Python code, we have been using `print` to output information
    to see what our robot is doing. This works, but prints can become overwhelming
    if we print everything we might want to inspect. Logging allows us to still display
    information, but we can control how much. By importing the `logging` module, we
    can take advantage of this.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的Python代码中，我们一直在使用`print`来输出信息，以查看我们的机器人正在做什么。这没问题，但如果打印出我们可能想要检查的所有内容，打印可能会变得令人难以承受。日志记录允许我们仍然显示信息，但我们可以控制显示多少。通过导入`logging`模块，我们可以利用这一点。
- en: First, there are logging levels, with `debug`, `info`, `warning`, and `error`.
    While fixing problems or initially developing, `debug` is useful – it can show
    everything – while `info` is used to show a little less than that. The `warning`
    and `error` levels are reserved only for those kinds of problems, so you can filter
    down to only this level when you are reasonably confident with some code. The
    `logging.basicConfig` function allows us to configure a logging level and other
    logging parameters; you need to configure logging to enable `info` and `debug`
    logging.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有日志级别，包括`debug`、`info`、`warning`和`error`。在修复问题或最初开发时，`debug`很有用——它可以显示一切——而`info`则用于显示比这少一点。`warning`和`error`级别仅保留用于那些类型的问题，因此当您对某些代码有相当信心时，您可以仅过滤到这个级别。`logging.basicConfig`函数允许我们配置日志级别和其他日志参数；您需要配置日志记录以启用`info`和`debug`日志。
- en: The other thing you can do with logging is to have differently named loggers
    using the `logging.getLogger` function. This lets you set different levels for
    different modules. Using named loggers helps to enable `debug` from a library
    module you are using while sticking to `info` on the main module.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用日志记录做的另一件事是使用`logging.getLogger`函数使用不同命名的记录器。这允许您为不同的模块设置不同的级别。使用命名记录器有助于在您使用的库模块中启用`debug`，同时在主模块上保持`info`。
- en: In this chapter's code, we will start using logging and controlling logging
    levels to get more detail on what an example is doing, turning the parts on and
    off at will. When we introduce the PID controller later, this will become very
    useful indeed. We can use this logging in the next section to show a sensor pulse
    count.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的代码中，我们将开始使用日志记录和控制日志级别，以获取更多关于示例正在做什么的详细信息，可以随意打开和关闭部分。当我们介绍PID控制器时，这确实非常有用。我们可以在下一节中使用此日志记录来显示传感器脉冲计数。
- en: Simple counting
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单计数
- en: 'This code counts the number of cycles up and down on each wheel''s signal pin,
    printing the count as we test the sensors. Running this verifies that our sensor
    connections are working, letting us troubleshoot and move on. It also lays code
    foundations for tracking wheel movements. We run our motors for about 1 second.
    Note that this code assumes you are starting with the code from [*Chapter 10*](B15660_10_Final_ASB_ePub.xhtml#_idTextAnchor192),
    *Using Python to Control Servo Motors*:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码计算每个轮子的信号引脚上升和下降的周期数，并在测试传感器时打印计数。运行此代码可以验证我们的传感器连接是否正常工作，让我们进行故障排除并继续前进。它还为跟踪轮子运动奠定了代码基础。我们运行电机大约1秒钟。请注意，此代码假设您是从[*第10章*](B15660_10_Final_ASB_ePub.xhtml#_idTextAnchor192)的代码开始的，即*使用Python控制伺服电机*：
- en: Important note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can find the following code at [https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/test_encoders.py](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/test_encoders.py).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/test_encoders.py](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/test_encoders.py)找到以下代码。
- en: 'Let''s make a file called `test_encoders.py`, starting with the usual robot
    classes, `import` and `time`, and adding logging:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`test_encoders.py`的文件，从常用的机器人类、`import`和`time`开始，并添加日志记录：
- en: '[PRE0]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we add an import for a GPIO Zero input device. We can use the pin it
    sets up to count our pulses:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为GPIO Zero输入设备添加一个导入。我们可以使用它设置的引脚来计数脉冲：
- en: '[PRE1]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We've also set up a named logger for our system matching the filename.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还设置了一个与文件名匹配的系统日志记录器。
- en: 'The encoders generate pulses; we want to count them and track their state.
    We use more than one of them. Creating a class from the outset seems like the
    right strategy. From here, we can pass our I/O pin number to the constructor.
    The first thing it needs to do is to set up a pulse counter:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编码器生成脉冲；我们想要计数它们并跟踪它们的状态。我们使用多个它们。从一开始就创建一个类似乎是一个正确的策略。从这里，我们可以将我们的I/O引脚号传递给构造函数。它需要做的第一件事是设置脉冲计数器：
- en: '[PRE2]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Still in the constructor, we need to set up the device and how we count pulses
    with it. The device has a `.pin` object, which we set up using the pin number.`.pin`
    has a `when_changed` event, which we can drop our handler into to be called every
    time the pin changes. The pin changes from up to down (rising and falling) for
    every slot:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在构造函数中，我们需要设置设备和如何使用它来计数脉冲。设备有一个`.pin`对象，我们使用引脚号来设置它。`.pin`有一个`when_changed`事件，我们可以将处理程序放入其中，以便每次引脚改变时都会调用它。对于每个槽，引脚从上到下（上升和下降）变化：
- en: '[PRE3]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We need to define a `when_changed` method for our class to add one to `pulse_count`.
    This method must be as small/quick as possible, as GPIO Zero calls it in the background
    for every pulse change. It takes a `time_ticks` parameter and a `state` parameter.
    We will not use `time_ticks`, so mark this with an underscore:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为我们的类定义一个`when_changed`方法来将一个值添加到`pulse_count`。此方法必须尽可能小/快，因为GPIO Zero在后台为每次脉冲变化调用它。它需要一个`time_ticks`参数和一个`state`参数。我们不会使用`time_ticks`，所以用下划线标记：
- en: '[PRE4]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can set up our `robot` object and create an `EncoderCounter` for each side''s
    sensor. We connected our devices to pins `4` and `26`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以设置我们的`robot`对象并为每侧的传感器创建一个`EncoderCounter`。我们将设备连接到引脚`4`和`26`：
- en: '[PRE5]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To display values, instead of just using `sleep`, we loop, checking against
    an end time. Before we log anything, `logging.basicConfig` sets logging parameters.
    We start the motors and go into the main loop:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示值，而不是仅仅使用`sleep`，我们循环，检查结束时间。在我们记录任何内容之前，`logging.basicConfig`设置日志参数。我们启动电机并进入主循环：
- en: '[PRE6]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this loop, we log the readings on both sensors.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个循环中，我们记录了两个传感器的读数。
- en: 'Since tight loops can cause things to break (such as GPIO Zero calling our
    code from a sensor thread), it should sleep a little too:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于紧密循环可能会导致事物损坏（例如GPIO Zero从传感器线程调用我们的代码），它应该稍微休眠一下：
- en: '[PRE7]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can send this code to the robot and run it. You can now see the robot veering
    through the encoder''s values. The output should look a little like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此代码发送到机器人并运行它。现在您可以看到机器人通过编码器的值偏斜。输出应该看起来有点像这样：
- en: '[PRE8]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The encoders are counting, and it shows that the robot moved less on the left
    wheel and more on the right wheel, and veered left. The `INFO:test_encoders:`
    part is introduced by the logging, showing the logging level and the logger name.
    The distances are in encoder *ticks*, a tick being each counted event.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 编码器正在计数，这表明机器人左轮移动较少，右轮移动较多，并向左偏斜。`INFO:test_encoders:`部分是由日志引入的，显示日志级别和记录器名称。距离是以编码器*脉冲*计算的，每个计数事件为一个脉冲。
- en: You've now tried out this code, but refer to the troubleshooting section if
    you have any problems.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经尝试了这段代码，但如果您有任何问题，请参考故障排除部分。
- en: Troubleshooting
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'If you find problems when running this, try the following steps:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在运行此代码时遇到问题，请尝试以下步骤：
- en: Ensure you started from the [*Chapter 10*](B15660_10_Final_ASB_ePub.xhtml#_idTextAnchor192),
    *Using Python to Control Servo Motors*, code. If you downloaded code from the
    current chapter, you will likely see GPIO conflicts with the code already set
    up for the encoders.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您从[*第10章*](B15660_10_Final_ASB_ePub.xhtml#_idTextAnchor192)，*使用Python控制伺服电机*的代码开始。如果您从当前章节下载了代码，您可能会看到与编码器已设置的代码的GPIO冲突。
- en: If the encoder values stay at zero, turn off the Raspberry Pi, then go back
    and carefully check your wiring and pin number usage.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果编码器值保持在零，请关闭Raspberry Pi，然后返回并仔细检查您的布线和引脚编号使用情况。
- en: Check your wiring – if anything is hot, immediately disconnect the power and
    verify your wiring.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查您的布线 - 如果有任何东西过热，请立即断开电源并验证您的布线。
- en: You have tested the encoders on the robot, seeing feedback on your screen as
    they moved. This demonstrates that they are ready to be used in more interesting
    robot behaviors after adding them to the `Robot` object.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经在机器人上测试了编码器，看到它们移动时屏幕上的反馈。这表明它们在添加到`Robot`对象后可以用于更有趣的机器人行为。
- en: Adding encoders to the Robot object
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将编码器添加到`Robot`对象中
- en: To use this sensor in other code or behaviors, we should move it into the `Robot`
    object. We can then import our code into the `Robot` object and set up the two
    sides with the correct pins. You'll also need to add some cleanup code for the
    handlers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要在其他代码或行为中使用此传感器，我们应该将其移动到`Robot`对象中。然后我们可以将我们的代码导入到`Robot`对象中，并使用正确的引脚设置两个侧面。您还需要添加一些清理代码以处理程序。
- en: Extracting the class
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取类
- en: 'We''ve already made the `EncoderCounter` class, which you can copy from `test_encoders.py`
    to the `encoder_counter.py` ([https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/encoder_counter.py](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/encoder_counter.py))
    file. This code needs the import for `DigitalInputDevice`, the same constructor,
    and the `when_changed` handler:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了`EncoderCounter`类，您可以从`test_encoders.py`复制到`encoder_counter.py`文件中（[https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/encoder_counter.py](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/encoder_counter.py)）。此代码需要导入`DigitalInputDevice`，相同的构造函数，以及`when_changed`处理程序：
- en: 'Let''s start by adding the imports and class declaration. The `EncoderCounter`
    class starts the same way as the last section:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先添加导入和类声明。`EncoderCounter`类与上一节以相同的方式开始：
- en: '[PRE9]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'I''m adding a `direction` member to account for reversing:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我添加了一个`direction`成员来处理反转：
- en: '[PRE10]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The constructor (`__init__`) is finished by setting up the device and assigning
    a `when_changed` handler:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数(`__init__`)通过设置设备和分配`when_changed`处理器来完成：
- en: '[PRE11]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Our `when_changed` handler should add the direction instead of 1, so it can
    count up or down:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`when_changed`处理器应该添加方向而不是1，这样它可以向上或向下计数：
- en: '[PRE12]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We should also have a method to set this direction, so we can assert to validate
    our setting, which throws an exception if it doesn''t meet the condition with
    the given text – a cheap but brutal way of ensuring input values make sense:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还应该有一个设置此方向的方法，这样我们就可以断言以验证我们的设置，如果不满足给定文本中的条件，则抛出异常——这是一种便宜但粗暴的方法，以确保输入值有意义：
- en: '[PRE13]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A reset method means we can handle restarting counters between movements:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个重置方法意味着我们可以处理在运动之间的计数器重启：
- en: '[PRE14]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For cleanup, we need a way to stop the counters so that they don''t call the
    handler again:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了清理，我们需要一种方法来停止计数器，这样它们就不会再次调用处理器：
- en: '[PRE15]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With the encoder library ready, we can use this in our code. The library means
    we can reuse our encoder counter in different places, and also that we can substitute
    a different device with similar properties. To make it available to many behaviors,
    it will be handy to import it into the robot library.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码器库准备就绪后，我们可以在代码中使用它。库意味着我们可以在不同的地方重用我们的编码器计数器，也可以用具有相似属性的另一个设备替换它。为了使它对许多行为可用，将其导入到机器人库中会很有用。
- en: Adding the device to the Robot object
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将设备添加到机器人对象
- en: We've used our `Robot` object as the main interface between code handling the
    hardware and the behavior code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用`Robot`对象作为处理硬件和行为的代码之间的主要接口。
- en: 'We will modify the `robot.py` code from [*Chapter 10*](B15660_10_Final_ASB_ePub.xhtml#_idTextAnchor192),
    *Using Python to Control Servo Motors* ([https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter10/robot.py](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter10/robot.py))
    to add the sensors:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改来自[*第10章*](B15660_10_Final_ASB_ePub.xhtml#_idTextAnchor192)，*使用Python控制伺服电机*的`robot.py`代码([https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter10/robot.py](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter10/robot.py))以添加传感器：
- en: 'Start by importing `EncoderCounter`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先导入`EncoderCounter`：
- en: '[PRE16]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the `__init__` constructor method, we need to set up left and right encoders.
    I did this just after the distance sensors:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`__init__`构造方法中，我们需要设置左右编码器。我就在距离传感器之后做了这件事：
- en: '[PRE17]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To make sure that the code cleans up encoder handlers when our `Robot` object
    has stopped, we call the encoder''s `stop` methods in the `stop_all` method:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保当我们的`Robot`对象停止时，代码清理了编码器处理器，我们在`stop_all`方法中调用编码器的`stop`方法：
- en: '[PRE18]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The finished code for `robot.py` with encoders is on GitHub ([https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/robot.py](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/robot.py)).
    We can now use this to build a behavior to measure the distance in millimeters.
    To do so, we'll understand the relationship between encoder ticks and the distance
    moved in millimeters.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 带有编码器的`robot.py`的完整代码在GitHub上([https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/robot.py](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/robot.py))。我们现在可以使用它来构建一个测量毫米距离的行为。为此，我们将了解编码器脉冲与移动毫米距离之间的关系。
- en: Turning ticks into millimeters
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将脉冲转换为毫米
- en: 'To calculate real distances, we need the sizes of the wheels. We cannot account
    for slipping, but we can find out how much a wheel has turned, which is the same
    as the encoders. Using the wheel''s diameter, we can calculate how far it has
    turned. Using a ruler or caliper, measure the diameter across the wheel, as shown
    in *Figure 11.11*:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算实际距离，我们需要车轮的大小。我们无法计算滑动，但我们可以找出车轮转动了多少，这与编码器相同。使用车轮的直径，我们可以计算出它转动了多远。使用尺子或卡尺，测量车轮的直径，如图*图11.11*所示：
- en: '![](img/B15660_11_11.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15660_11_11.jpg)'
- en: Figure 11.11 – Measuring the wheel
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 – 测量车轮
- en: 'The measurements needed are shown in *Figure 11.11*:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的测量值如图*图11.11*所示：
- en: You will need to measure the wheel's diameter, marked **D** in this figure,
    and the distance between the wheels, **W**. The distance **W** is equivalent to
    the width from midpoint to midpoint of the two motor-driven wheels on the robot.
    It is easier to measure, as shown here, the right side of one wheel, all the way
    across to the right side of the other wheel – which will be the same as midpoint
    to midpoint. Mine came to about 130 mm.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要测量轮子的直径，如图中标记的**D**，以及车轮之间的距离，**W**。距离**W**相当于机器人上两个电机驱动轮的中点到中点的宽度。它更容易测量，如图所示，一个轮子的右侧，一直延伸到另一个轮子的右侧——这将与中点到中点相同。我的测量结果是大约130毫米。
- en: You can measure **D** with calipers, as shown here, by fitting them around the
    widest part of the wheel. My wheel came to 70 mm, to the nearest mm.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用卡尺测量**D**，如图所示，通过将其套在轮子最宽的部分。我的轮子测量结果是70毫米，最接近的毫米。
- en: We know how many slots are on the encoders, and we expect two ticks (the rising
    and falling) per slot, so we can take the number of slots times 2, which is the
    number of ticks per whole-turn of the wheel – in my case, this is 40.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道编码器上有多少个槽，我们预计每个槽有两个脉冲（上升和下降），因此我们可以将槽的数量乘以2，这就是轮子整个转动的刻度数——在我的情况下，这是40。
- en: 'The number pi, or ![](img/Formula_11_001.png), is the ratio of the diameter
    to the circumference of the wheel. To get the circumference, we multiply the diameter
    by pi, giving us ![](img/Formula_11_002.png), where *D* is the diameter. We can
    divide pi by the number of total ticks per revolution, and then when we multiply
    this by the number of ticks counted, *T*, and then the diameter, *D*, and we get
    a number for the distance, *d*, that the wheel has traveled:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 圆周率π，或![公式_11_001.png](img/Formula_11_001.png)，是轮子直径与周长的比值。要得到周长，我们将直径乘以π，得到![公式_11_002.png](img/Formula_11_002.png)，其中*D*是直径。我们可以将π除以每转的总刻度数，然后当我们乘以计数的刻度数*T*，然后是直径*D*，我们得到轮子行驶的距离*d*：
- en: '![](img/Formula_11_003.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![公式_11_003.png](img/Formula_11_003.png)'
- en: 'So, how do we turn this into code? Refer to the following steps:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何将其转换为代码？请参考以下步骤：
- en: 'Make a new file called `test_distance_travelled.py`. At the top of the file,
    we need to import `math` for the calculations, the `Robot` object, and `time`:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`test_distance_travelled.py`的新文件。在文件的顶部，我们需要导入`math`进行计算，`Robot`对象，以及`time`：
- en: '[PRE19]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we define our constants – the wheel''s diameter and the number of ticks
    per revolution. Please use the values you obtained, not the ones that I have shown
    here:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义我们的常数——轮子的直径和每转的刻度数。请使用您获得的数据，而不是我这里显示的值：
- en: '[PRE20]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a function to convert the ticks counted into a distance. It''s converted
    into integers since fractions of a millimeter are just not appropriate for this
    measurement. Since part of the conversion doesn''t change, we make that a constant,
    too:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，将计数的刻度转换为距离。由于毫米的分数不适用于这种测量，因此将其转换为整数。由于转换的一部分不会改变，我们也将其作为常数：
- en: '[PRE21]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we define our robot, set up a stop time, and start the motors:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义我们的机器人，设置停止时间，并启动电机：
- en: '[PRE22]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the loop, we display the distance by calling `ticks_to_mm` on the pulse
    counts:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环中，我们通过调用`ticks_to_mm`函数在脉冲计数上显示距离：
- en: '[PRE23]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When uploaded to the robot and run, the output looks like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当上传到机器人并运行时，输出看起来像这样：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This output has shown a clear difference between the travel on the left and
    the right motors. The right motor is moving slightly quicker than the left. This
    difference accumulates, making the robot turn further. So, in the next section,
    let's use this information to straighten things up.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出显示了左右两侧行驶的明显差异。右侧电机比左侧电机移动得稍快。这种差异会累积，使机器人转向。因此，在下一节中，让我们使用这些信息来调整方向。
- en: Driving in a straight line
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直线行驶
- en: By now, you have seen differences in the outputs – that is, a veer. In only
    400 mm, my left side is around 20 mm behind the right, an error that is climbing.
    Depending on your motors, your robot may have some veer too. It is rare for a
    robot to have driven perfectly straight. We use the sensors to correct this.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，您已经看到了输出中的差异——即，一个偏差。在我的左侧，在400毫米内大约落后于右侧20毫米，这是一个正在上升的错误。根据您的电机，您的机器人可能也有一些偏差。机器人完美直线行驶的情况很少见。我们使用传感器来纠正这一点。
- en: Tip
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: This behavior works better on wooden flooring or MDF boards, and poorly on carpet.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为在木地板或MDF板上效果更好，而在地毯上效果较差。
- en: This correction is still dead reckoning; slipping on surfaces or incorrect measurements
    can still set this off course. How can we use motors and encoders to correct our
    course and drive in a straight line?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这种校正仍然是死计算；在表面上滑动或测量不正确仍然可能导致偏离航向。我们如何使用电机和编码器来纠正航向并直线行驶？
- en: Correcting veer with a PID
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PID 调整偏航
- en: A behavior to self-correct steering and drive in a straight line needs to vary
    motor speeds until the wheels have turned the same amount. If the wheels turn
    the same amount soon enough, then they will account for major course deviations.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于自我校正转向和直线行驶的行为需要调整电机速度，直到车轮转动的量相同。如果车轮很快转动的量相同，那么它们将补偿主要的航向偏差。
- en: Our robot will use the encoder sensor to measure how much each wheel has turned.
    We can then consider the difference between these to adjust the motor control
    and try to keep the motors at the same speed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的机器人将使用编码器传感器来测量每只轮子转过的程度。然后我们可以考虑这些差异来调整电机控制，并尝试保持电机以相同的速度运行。
- en: A trick with this is working out how the difference in measurements relates
    to adjusting motor speeds. This leads us to look at a PID system designed to map
    errors into adjustment and output values.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧是找出测量值差异与调整电机速度之间的关系。这使我们转向查看一个将误差映射到调整和输出值的 PID 系统。
- en: 'Driving in a straight line needs a closed **feedback** loop. *Figure 11.12*
    shows how this loop works:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 直线行驶需要一个闭环 **反馈** 环。*图 11.12* 展示了这个环是如何工作的：
- en: '![](img/B15660_11_12.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15660_11_12.jpg)'
- en: Figure 11.12 – Closed-loop control of a motor's speed
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 – 电机速度的闭环控制
- en: We start with an *expected position* or **set point**. The *encoder position*
    gives feedback data from the real world. We get a difference between the setpoint
    and the encoder position, which we call the *error*. The code feeds this into
    a *controller*, which generates a *speed adjustment*. The system will then apply
    that adjustment to the *motor speed*, making the motor turn more or less, changing
    the encoder's feedback.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个*预期位置*或**设定点**开始。*编码器位置*提供来自现实世界的反馈数据。我们得到设定点和编码器位置之间的差异，我们称之为*误差*。代码将此输入到*控制器*中，生成*速度调整*。然后系统将应用此调整到*电机速度*，使电机转动更多或更少，改变编码器的反馈。
- en: To go straight, we take the left motor's value and subtract the right motor
    to get an encoder difference. Our *expected position* is 0\. Our *error* is then
    the difference between the encoders. We can then adjust the speeds using the controller.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要直线行驶，我们取左电机值并减去右电机以获得编码器差异。我们的*预期位置*是 0。我们的*误差*是编码器之间的差异。然后我们可以使用控制器调整速度。
- en: 'We use a **PID** controller to adjust the speed of the motors; this has three
    components:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 **PID** 控制器来调整电机的速度；这有三个组成部分：
- en: '**Proportional** (**P**): The error value multiplied by a constant. This corrects
    for immediate errors.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**比例**（**P**）：误差值乘以一个常数。这可以纠正即时误差。'
- en: '**Integral** (**I**): The sum of the error values so far, multiplied by a constant.
    This corrects for continuing errors.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**积分**（**I**）：到目前为止误差值的总和，乘以一个常数。这可以纠正持续误差。'
- en: '**Derivative** (**D**): This takes the difference between the last error value
    and now and multiplies by a constant. This is to push back a little against sudden
    changes.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导数**（**D**）：这取最后误差值和现在的差异，并乘以一个常数。这是为了稍微对抗突然的变化。'
- en: By manipulating the constants, we *tune* how much each factor influences the
    outcome of the controller. We won't be using the derivative component for our
    behaviors, which is equivalent to having its constant set to zero.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调整常数，我们可以*调整*每个因素对控制器结果的影响程度。我们不会使用导数组件来调整我们的行为，这相当于将其常数设置为 0。
- en: The integral can give the robot some self-tuning, but it needs to have a very
    small constant, as high values can make the robot start to wobble instead. We
    will add the adjustment onto one motor and subtract it from the other.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 积分可以给机器人一些自调功能，但需要一个非常小的常数，因为高值可能会使机器人开始摇摆。我们将调整加到一个电机的速度上，并从另一个电机中减去。
- en: 'The right motor speed is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 右电机速度如下：
- en: '[PRE25]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We need an unused motor speed capacity to be able to speed up a bit. If the
    speed is too close to 100%, we get clipping. An integral behavior with clipping
    can make the robot behave quite strangely, so watch out for clipping at 100%!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个未使用的电机速度容量，以便能够稍微加速。如果速度太接近 100%，我们会得到剪辑。具有剪辑的积分行为可能会使机器人行为相当奇怪，所以要注意
    100% 的剪辑！
- en: Tip
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Leave headroom for PID adjustments – use no more than 80% of motor speed.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为 PID 调整留出空间 - 不要超过 80% 的电机速度。
- en: Now that we have some idea how a PID controller works, let's build one in code.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 PID 控制器的工作原理有了些了解，让我们在代码中构建一个。
- en: Creating a Python PID controller object
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个 Python PID 控制器对象
- en: 'The PID controller code is a fundamental robotics building block for making
    straight lines and we''ll use it again in later camera-driven chapters. You will
    use the basic concepts here in many robotic systems:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: PID 控制器代码是制作直线的基本机器人构建块，我们将在后续的相机驱动章节中再次使用它。你将在许多机器人系统中使用这里的基本概念：
- en: We use this in a few places, so let's make a simplified PID control object.
    I put this in a file named `pid_controller.py`. Note that this is only a `proportional_constant`
    as `pK` and `integral_constant` as `iK`. You can do so if you wish. I've used
    the longer names in the code examples to make it easier to read.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在几个地方使用这个，所以让我们创建一个简化的 PID 控制对象。我把这个放在一个名为 `pid_controller.py` 的文件中。注意，这只是一个
    `proportional_constant` 作为 `pK` 和 `integral_constant` 作为 `iK`。如果你愿意，你可以这样做。我在代码示例中使用了较长的名称，以便更容易阅读。
- en: 'The following code handles the values for the two components. Handling the
    integral has the effect of increasing the integral sum:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码处理两个组件的值。处理积分的效果是增加积分总和：
- en: '[PRE26]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following bit of code handles the error to generate the adjustment:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块处理误差以生成调整：
- en: '[PRE27]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With the PI code in place, we are ready to make a robot that can combine errors
    with previous values, scaling them to make them useful in the context of some
    movement. We will use this PID controller for our straight line adjusting in the
    next section.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PI 代码就绪后，我们就可以制作一个能够将误差与先前值结合，并按比例缩放以使其在某种运动环境中有用的机器人。我们将在下一节中使用这个 PID 控制器来调整直线。
- en: Writing code to go in a straight line
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写直线行驶的代码
- en: 'I called this `straight_line_drive.py` ([https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/straight_line_drive.py](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/straight_line_drive.py)):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我把这个命名为 `straight_line_drive.py` ([https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/straight_line_drive.py](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/straight_line_drive.py))：
- en: 'Let''s import the `Robot` object, `time`, and our new PI controller. We''ll
    set up logging to get debug from the PID controller. You can tune it back to `INFO`
    or take that line out if it''s too much:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入 `Robot` 对象、`time` 和我们新的 PI 控制器。我们将设置日志记录以获取 PID 控制器的调试信息。你可以将其调整回 `INFO`
    或者在太多的情况下删除该行：
- en: '[PRE28]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Set up the `Robot` object too, and set up a slightly longer `stop_at_time`
    value so that our robot drives a bit further:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也设置 `Robot` 对象，并设置一个稍长的 `stop_at_time` 值，这样我们的机器人可以行驶得更远：
- en: '[PRE29]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Start with a master speed value of `80`, and set both motors to this:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以 `80` 的主速度值开始，并将两个电机都设置为这个值：
- en: '[PRE30]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Before going into our main loop, set up the controller. You may need to tune
    these constants. Note how small the integral constant is:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进入主循环之前，设置控制器。你可能需要调整这些常数。注意积分常数的值有多小：
- en: '[PRE31]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the loop, we `sleep` a little so that our encoders have something to measure.
    It''s also usually a bad idea to have a "tight" loop that doesn''t use `sleep`
    to give other things a chance to run. Get the encoder values and compute the error:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环中，我们稍微 `sleep` 一下，这样我们的编码器就有东西可以测量。通常，不使用 `sleep` 来给其他事物运行机会的“紧密”循环也是一个坏主意。获取编码器值并计算误差：
- en: '[PRE32]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'That error needs to be handled by the controller and used to make `right_speed`:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个误差需要由控制器处理，并用于生成 `right_speed`：
- en: '[PRE33]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can then log debug information here. Notice we have two levels: debug for
    the error and adjustment and info for the speeds. With the current config set
    to `INFO`, we won''t see the debug without modifying it:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在这里记录调试信息。注意我们有两个级别：用于错误和调整的调试，以及用于速度的信息。当前配置设置为 `INFO`，除非修改，否则我们不会看到调试信息：
- en: '[PRE34]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We then set the motor speeds to the adjusted values and finish the loop:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将电机速度设置为调整后的值并完成循环：
- en: '[PRE35]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When we run this, the robot should be following a fairly straight course. It
    may start unstable, but should hone in on a constant adjustment:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序时，机器人应该会沿着一条相当直的路线行驶。它可能一开始不稳定，但应该会逐渐调整到一个恒定的值：
- en: '[PRE36]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The robot starts with no error as the motors engage, but the right goes faster.
    At 13 ticks, the controller pulls the adjustment pretty high. Notice how `P` jumps,
    but `I` settles for a constant value after a while, which will keep the robot
    straight.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人启动时没有误差，因为电机开始工作，但右边速度更快。在 13 个脉冲时，控制器将调整拉得很高。注意 `P` 如何跳跃，但 `I` 在一段时间后会稳定在一个恒定值，这将使机器人保持直线。
- en: Tuning of the `P` and `I` constants and the loop timing may result in earlier
    corrections – the initial encoder values are too small to be useful.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 调整 `P` 和 `I` 常数以及循环时间可能会导致更早的纠正——初始编码器值太小，没有实际用途。
- en: Note that this may still end up off course; it accounts for reducing the veer
    but can adjust too late to stop a small *S* shape or other error. It is, however,
    much straighter than driving without. Adjusting the PID can help with this.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这仍然可能导致偏离正确方向；它考虑了减少偏航，但可能调整得太晚，无法停止小的 *S* 形或其他错误。然而，这比不调整要直得多。调整 PID 可以帮助解决这个问题。
- en: Troubleshooting this behavior
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障排除此行为
- en: 'Here are a few steps to take if the robot is wobbling or doesn''t manage to
    travel in a straight line:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果机器人摇摆或无法直线行驶，以下是一些步骤：
- en: If the robot takes too long to compensate, increase the proportional component.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果机器人补偿得太慢，增加比例组件。
- en: If the robot overshoots massively (that is, it swerves one way, then the other),
    reduce the size of both the proportional and integral PID components.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果机器人大幅超出（即，它先向一个方向偏移，然后向另一个方向偏移），则减少比例和积分 PID 组件的大小。
- en: If the robot is making increasing wobbles, the integral is too high, and the
    right speed may be going above 100\. Bring down the integral component, and perhaps
    the requested speed.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果机器人产生越来越大的摇摆，积分过高，右边的速度可能超过 100。降低积分组件，也许还有请求的速度。
- en: You can set the `straight_line` logger or `basicConfig` to debug to see the
    error value too.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将 `straight_line` 记录器或 `basicConfig` 设置为调试，以查看错误值。
- en: With the straight line working and driving, you have now corrected veer problems
    and differences between the sides. You can now build on this; let's take a known
    distance and drive to it, then stop.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当直线行驶和驾驶工作正常后，你现在已经纠正了偏航问题和两侧的差异。你现在可以在此基础上构建；让我们取一个已知的距离并驾驶到那里，然后停止。
- en: Driving a specific distance
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驾驶特定距离
- en: For driving a specific distance, we use the PI controller again and incorporate
    the distance measurements into our encoder object. We calculate how many ticks
    we want the left wheel to have turned for a given distance, and then use this
    instead of a timeout component.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 对于驾驶特定距离，我们再次使用 PI 控制器，并将距离测量纳入我们的编码器对象。我们计算左轮为了给定距离需要转动的脉冲数，然后使用这个值而不是超时组件。
- en: Refactoring unit conversions into the EncoderCounter class
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将单位转换重构到 EncoderCounter 类
- en: 'We want the conversions for our encoders in the `EncoderCounter` class to use
    them in these behaviors. Refactoring is the process of moving code or improving
    code while retaining its functionality. In this case, converting distances is
    one of the purposes of using encoders, so it makes sense to move this code in
    there:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望 `EncoderCounter` 类中的编码器转换能够用于这些行为。重构是移动代码或改进代码的同时保留其功能的过程。在这种情况下，转换距离是使用编码器的一个目的，因此将此代码移入其中是有意义的：
- en: 'Open up your `encoder_counter.py` class. First, we need the `math` import:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的 `encoder_counter.py` 类。首先，我们需要导入 `math`：
- en: '[PRE37]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'At the top of the class, add `ticks_to_mm_const` as a class variable (not an
    instance variable) to use it without any instances of the class. Set this to none
    initially so that we can calculate it:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类顶部，将 `ticks_to_mm_const` 添加为类变量（而不是实例变量）以使用它而无需任何类的实例。最初将其设置为 none，以便我们可以计算它：
- en: '[PRE38]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In our class, we want to retrieve the distance the wheel has traveled directly
    from the encoder, in mm. Add this to the end of the file:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的类中，我们想要直接从编码器获取车轮行驶的距离，以毫米为单位。将以下内容添加到文件末尾：
- en: '[PRE39]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We also want to calculate the opposite: the number of ticks from a distance
    in mm. To do that, divide the distance in mm by the same constant we multiplied
    by. This is set to `staticmethod` so that it does not require later code to use
    an instance:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还想要计算相反的值：从毫米距离计算出的脉冲数。为此，将毫米距离除以我们乘以的相同常数。这被设置为 `staticmethod`，因此它不需要后续代码使用实例：
- en: '[PRE40]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add a way to set the constants in the file (for different robot configurations):'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中添加设置常数的途径（用于不同的机器人配置）：
- en: '[PRE41]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When you have saved this, `EncoderCounter` can now convert between distance
    and encoder ticks. We now need to set up the wheel diameters for your particular
    robot.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当你保存后，`EncoderCounter`现在可以转换距离和编码器刻度。我们现在需要设置特定机器人的轮子直径。
- en: Setting the constants
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置常数
- en: 'So far, we can use our robot metrics in our behaviors. Now, we want the `Robot`
    object to store our measurements and register them with the encoders. We can do
    this in two simple steps:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以在我们的行为中使用我们的机器人度量。现在，我们想让`Robot`对象存储我们的测量并将它们注册到编码器中。我们可以通过两个简单的步骤来完成：
- en: 'In `robot.py`, just before the constructor, specify some of these numbers:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`robot.py`中，在构造函数之前，指定一些这些数字：
- en: '[PRE42]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Register these with the encoders:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些与编码器注册：
- en: '[PRE43]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With the constants ready, we've primed our encoders to measure distance. We
    can use this to make a behavior to drive a distance.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好常数后，我们已经使编码器准备好测量距离。我们可以使用这一点来创建一个行驶距离的行为。
- en: Creating the drive distance behavior
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建行驶距离行为
- en: 'I''ll put this code into `drive_distance.py`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我会把这段代码放入`drive_distance.py`：
- en: 'Start by importing `EncoderCounter` to use its metrics, `PIController`, and
    the `Robot` object, and set up a logger:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先导入`EncoderCounter`以使用其度量，`PIController`和`Robot`对象，并设置一个记录器：
- en: '[PRE44]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Define the `drive_distance` function, which takes a robot instance, a distance
    in ticks, and an optional speed defaulting to 80\. We start by making a primary
    and secondary motor and controller decision:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`drive_distance`函数，它接受一个机器人实例，一个以刻度为单位的距离，以及一个默认为80的可选速度。我们首先创建一个主电机和副电机以及控制器决策：
- en: '[PRE45]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We now have a well-defined primary and secondary motor. Set up a `PIController`
    and start the two motors:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个明确的主电机和副电机。设置一个`PIController`并启动两个电机：
- en: '[PRE46]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, we are in the driving distance loop. We should continue the loop until
    both encoders reach the right distance. We need to sleep before the rest of the
    loop so that we have some data for our calculations:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们处于驾驶距离循环中。我们应该继续循环，直到两个编码器都达到正确的距离。我们需要在循环的其余部分之前暂停，以便我们有数据用于计算：
- en: '[PRE47]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Get the error and feed it into the controller:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取错误并将其输入控制器：
- en: '[PRE48]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can send this to the motors and debug the data too. Because the adjustment
    is a non-integer, we allow two decimal places by using `{:.2f}`:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将这些发送到电机并调试数据。因为调整是一个非整数，所以我们使用`{:.2f}`允许两位小数：
- en: '[PRE49]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Set up the robot, let it calculate how far you want it to go, and get it moving:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置机器人，让它计算你想让它走多远，然后让它开始移动：
- en: '[PRE50]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We let the robot cleanup (`atexit`) stop the motors.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们让机器人清理（`atexit`）停止电机。
- en: 'When you run this, the robot drives a meter and stops. My robot, when stopping,
    looked like this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，机器人会行驶一米然后停止。我的机器人在停止时看起来是这样的：
- en: '[PRE51]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: There is a 2 mm overshoot, which it can lose in rounding values and detection
    time. We can't make partial ticks.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 有2毫米的超调，这可能在舍入值和检测时间中丢失。我们不能制作部分刻度。
- en: You have now seen how to make the robot drive a specific distance (or pretty
    close to it) while trying to stay in a straight line. You've combined the measuring
    and the PID adjustment tools that you've built throughout this chapter. But what
    if we want to make turns and measure those? We'll cover this in the next section.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了如何使机器人行驶特定的距离（或者非常接近它），同时试图保持直线行驶。你已经结合了你在本章中构建的测量和PID调整工具。但如果我们想转弯并测量这些呢？我们将在下一节中介绍。
- en: Making a specific turn
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行特定转弯
- en: 'The next task we can use our encoders for is to make a specific turn. When
    turning a robot, each wheel is going through an arc. *Figure 11.13* illustrates
    this:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用我们的编码器完成的下一个任务是进行特定的转弯。当机器人转弯时，每个轮子都在通过一个弧线。*图11.13*说明了这一点：
- en: '![](img/B15660_11_13.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_11_13.jpg)'
- en: Figure 11.13 – Illustrating wheel movement when turning through an arc
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13 – 说明通过弧线转弯时的轮子运动
- en: 'The inner wheel drives a shorter distance than the outer wheel, and from the
    basics of differential steering, this is how we make the turn. To make an exact
    turn, we need to calculate these two distances or the ratio between them. *Figure
    11.14* shows how the wheels and the turn relate to each other:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 内轮比外轮行驶的距离短，根据差速转向的基本原理，这就是我们如何转弯。为了进行精确转弯，我们需要计算这两个距离或它们之间的比率。*图11.14*显示了轮子和转弯之间的关系：
- en: '![](img/B15660_11_14.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15660_11_14.jpg)'
- en: Figure 11.14 – Relating wheels to turn radiuses
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14 – 将轮子与转向半径相关联
- en: 'If we consider the turn radius as setting where the middle of the robot is,
    an inner wheel''s turn radius is the *difference* between the turn radius and
    half the distance between the wheels:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将转弯半径视为设置机器人中间的位置，那么内轮的转弯半径是转弯半径与轮距一半的差值：
- en: '![](img/Formula_11_004.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_11_004.png)'
- en: 'The outer wheel''s turn radius is the turn radius *added* to half the distance:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 外轮的转弯半径是转弯半径加上轮距的一半：
- en: '![](img/Formula_11_005.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_11_005.png)'
- en: 'We convert our angle to turn into *radians*, and we can then multiply this
    angle by each wheel radius to get the distances that each wheel needs to move
    through:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的转向角度转换为弧度，然后我们可以将这个角度乘以每个轮子的半径，以得到每个轮子需要移动的距离：
- en: '![](img/Formula_11_006.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_11_006.png)'
- en: '![](img/Formula_11_007.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_11_007.png)'
- en: Python has math functions to convert degrees into radians.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Python有数学函数可以将度数转换为弧度。
- en: 'Let''s turn these functions into some code, demonstrating it by attempting
    to drive in a square, making measured 90-degree turns:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些函数转换为一些代码，通过尝试在正方形内行驶，并测量90度的转弯来演示它：
- en: 'Start with a copy of `drive_distance.py` and call it `drive_square.py`. Add
    the `math` import, like so:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`drive_distance.py`的副本开始，并将其命名为`drive_square.py`。添加`math`导入，如下所示：
- en: '[PRE52]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can modify the end of this file to state what we want to do. It can help
    to name functions that you plan to have, and then implement them to fit. We make
    it a bit smaller than a meter, too. For a radius to test with, I''ve added 100
    mm to the robot''s wheel distance. Anything less than the wheel distance and the
    center of the turn is between the wheels instead of outside of them:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以修改此文件的末尾来声明我们想要做什么。命名你计划拥有的函数，然后实现它们以适应。我们还将其缩小到略小于一米的尺寸。为了测试半径，我在机器人的轮距上增加了100毫米。任何小于轮距和转弯中心的东西都在轮子之间而不是轮子外面：
- en: '[PRE53]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Since we are driving in a square, we want to drive four times. For straight
    lines, drive each wheel the same distance, then make 90-degree arcs of our radius.
    I''ve reduced the speed for the arc so that there is less of a slipping problem:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们在正方形内行驶，我们想要行驶四次。对于直线，让每个轮子行驶相同的距离，然后以半径为圆心画90度的弧。我已经降低了弧的速度，以减少打滑问题：
- en: '[PRE54]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s go back up in the file to upgrade our method for driving a distance
    to one distance to driving two distances, one for each wheel. I''ve renamed the
    `drive_distance` function to `drive_distances`:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到文件顶部，将我们的驱动距离方法升级为一次驱动两个距离，一个用于每个轮子。我已经将`drive_distance`函数重命名为`drive_distances`：
- en: '[PRE55]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Depending on the angle we want to turn, either motor could be the outer motor
    and driving a longer distance. Since there is an upper limit to speed, we choose
    our primary and secondary motors based on the longer distance. Swap the code that
    set up the primary/secondary with this:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据我们想要转向的角度，任一电机都可以作为外电机，驱动更长的距离。由于速度有一个上限，我们根据更长的距离来选择我们的主电机和副电机。将设置主/副电机的代码替换为以下内容：
- en: '[PRE56]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Since we are using this method more than once, reset the encoder counts. I
    put this in before setting up `PIController`:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们多次使用此方法，重置编码器计数。我在设置`PIController`之前放置了这个：
- en: '[PRE57]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Since we can be going in either direction, set the encoder direction. Python
    has a `copysign` method to determine the sign of a value. Then, start the motors:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们可能正在向任何方向行驶，设置编码器方向。Python有一个`copysign`方法来确定值的符号。然后，启动电机：
- en: '[PRE58]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'When we start this loop, we again need to be aware that one or both motors
    could be going backward. We use `abs` again to take off the sign:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们开始这个循环时，我们再次需要意识到一个或两个电机可能正在倒退。我们再次使用`abs`来去除符号：
- en: '[PRE59]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Calculating the error for the secondary depends on the ratio between the two
    distances:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算副电机的误差取决于两个距离之间的比率：
- en: '[PRE60]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This still goes into the same adjustment calculation through `pid`; however,
    this adjustment may also cause a change in direction here. Now, we set the secondary
    motor speed:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这仍然通过`pid`进行相同的调整计算；然而，这种调整也可能导致方向上的变化。现在，我们设置副电机的速度：
- en: '[PRE61]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You could expand the debug that we had to take into account for the secondary
    speed and targets. Now, because we are trying for precision, the primary motor
    may reach its goal before the secondary and isn''t set up to reverse. So, stop
    this motor when it reaches its goal, and set the base speed of the secondary to
    zero, which means only adjustments apply, if any. Note that we still use the absolute
    values here:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以扩展我们为了二级速度和目标必须考虑的调试。现在，因为我们追求精确度，主电机可能会在二级电机之前达到目标，并且没有设置为反向。所以，当它达到目标时停止这个电机，并将二级电机的基准速度设置为零，这意味着只有如果有调整，则适用。注意，我们在这里仍然使用绝对值：
- en: '[PRE62]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: And we are done with the driving distances function. We can use this to drive
    in a straight line or feed it a separate target distance for each wheel and use
    that to drive in an arc. We'll take advantage of that in the next section.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了驾驶距离函数。我们可以使用它来直线行驶，或者为每个轮子提供单独的目标距离，并使用它来弧形行驶。我们将在下一节中利用这一点。
- en: Writing the drive_arc function
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写`drive_arc`函数
- en: 'Here is where we convert to radians, determine the inner radius, and set up
    the distances for each wheel to drive. Add this code in `drive_square_behaviour.py`,
    after the `drive_distances` function:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们将角度转换为弧度，确定内半径，并为每个轮子设置驾驶距离。将此代码添加到`drive_square_behaviour.py`中，在`drive_distances`函数之后：
- en: 'Start with a function definition and a helpful docstring:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从函数定义和有用的文档字符串开始：
- en: '[PRE63]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We turn the robot''s width into ticks, the internal measurement of distance,
    and use half of that to get the wheel radiuses. We also determine which is the
    inner wheel:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将机器人的宽度转换为tick，这是距离的内部测量单位，并使用其中的一半来获取轮子半径。我们还确定哪个是内轮：
- en: '[PRE64]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We display the debug on what the radiuses are. Combine this with the turn in
    radians to get the distances. We convert the absolute value of the turn in degrees.
    We don''t want to reverse into a turn, but to turn the other way:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们显示调试信息，以了解半径是多少。将此与弧度转弯结合，以获取距离。我们将转弯的绝对值转换为度数。我们不想反向进入转弯，而是要向相反方向转弯：
- en: '[PRE65]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Finally, feed these distances into the `drive_distances` function:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将这些距离输入到`drive_distances`函数中：
- en: '[PRE66]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The robot should be able to drive in a square shape. It can still miss due to
    slipping or inaccuracies in the measurements. Tuning of the proportional and integral
    control values is required.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人应该能够以正方形形状行驶。它仍然可能因为打滑或测量不准确而错过目标。需要调整比例和积分控制值。
- en: Examining the full code for `drive_distances` and `drive_arc`, it may become
    apparent that there is some repetition in determining the inner/outer and the
    primary/secondary parts, which you could refactor if you choose.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`drive_distances`和`drive_arc`的完整代码，可能会明显看出在确定内/外和主/次部分方面存在一些重复，如果您选择，可以进行重构。
- en: This code may not behave correctly if reversing through a corner.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过角落反向行驶，此代码可能表现不正确。
- en: Summary
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how to incorporate wheel encoder sensors into our robot
    and used them to determine how far each wheel has turned. We saw how to use this
    to get the robot onto a straighter path using a reduced PID controller and then
    used this to drive a specific distance. We then took the calculations further
    to calculate turning a corner in terms of wheel movements and driving the robot
    in a square.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何将轮编码器传感器集成到我们的机器人中，并使用它们来确定每个轮子转过的距离。我们看到了如何使用这个方法通过使用简化的PID控制器将机器人引导到更直的路径上，然后使用这个方法行驶特定距离。然后我们将计算进一步，以轮子移动来计算转弯，并使用这个方法在正方形中驾驶机器人。
- en: A PID controller can be used in many situations where you need to apply a difference
    between a measurement and expectation, and you have seen how to combine this with
    sensors. You could use the same system to control a heating element connected
    to a thermal sensor. You could also use encoders to move robots with some precision,
    where the restricted range of motion used in servo motors does not make sense.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: PID控制器可以在许多需要应用测量值与期望值之间差异的情况中使用，您已经看到了如何将其与传感器结合使用。您可以使用相同的系统来控制连接到热传感器的加热元件。您还可以使用编码器以一定的精度移动机器人，因为在伺服电机中使用的运动范围有限，这没有意义。
- en: In the next couple of chapters, we will explore giving our robot even more interactive
    and intelligent behaviors, with chapters on visual processing using a Raspberry
    Pi camera, speech processing with Mycroft, and using a smartphone to drive or
    select modes on the robot remotely.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将探索为我们的机器人提供更多交互性和智能行为，包括使用Raspberry Pi摄像头进行视觉处理、使用Mycroft进行语音处理，以及使用智能手机远程驾驶或选择机器人的模式。
- en: Exercises
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Try experimenting with turning on different logging levels and differently named
    loggers, tuning how much output a robot behavior creates.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试调整不同的日志级别和不同命名的记录器，调整机器人行为产生的输出量。
- en: For the PID behaviors, tune the PIDs, try high values for the proportional or
    the integral, and observe how this makes the robot behave. Could you combine this
    with graphing in `matplotlib` to observe the PID behavior?
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 PID 行为，调整 PID 参数，尝试为比例或积分使用高值，并观察这如何影响机器人的行为。你能将这和 `matplotlib` 中的绘图结合起来观察
    PID 行为吗？
- en: There are a few ways that the drive distance code could be improved. Applying
    a **PID** controller to the distance moved by the primary could make it close
    in more precisely on the exact distance to travel. Detecting no movement in either
    encoder could be used to make the code stop after a timeout so that it doesn't
    drive off without stopping. Try this out.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有几种方法可以改进驱动距离代码。将 **PID** 控制器应用于主驱动的移动距离可以使它更精确地接近确切的行驶距离。检测到任一编码器没有移动可以用作在超时后停止代码，这样它就不会在停止前行驶。试试这个。
- en: You could now use this code to make further geometric shapes or to follow paths
    without a line. Try adding high-level left turn/right turn 90-degree functions
    as building blocks for right-angled path construction, then use this to make paths.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以使用这段代码来制作更多的几何形状或跟随没有线的路径。尝试添加高级左转/右转 90 度函数作为直角路径构建的构建块，然后使用这些来制作路径。
- en: Consider combining the encoding sensors here with distance sensors; it may be
    possible to start memorizing distances between walls.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑将这里的编码传感器与距离传感器结合起来；可能开始记住墙壁之间的距离。
- en: Further reading
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Please refer to the following for more information:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下信息获取更多信息：
- en: 'PID control is a deep subject. It is a key area in self-balancing robots, drones,
    and other autonomous control systems. Here is a great video series so that you
    can explore these further:'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PID 控制是一个深奥的主题。它是自平衡机器人、无人机和其他自主控制系统中的关键领域。这里有一系列优秀的视频，你可以进一步探索这些内容：
- en: 'YouTube: Brian Douglas – *PID Control – A brief introduction*: [https://www.youtube.com/watch?v=UR0hOmjaHp0](https://www.youtube.com/watch?v=UR0hOmjaHp0)'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'YouTube: Brian Douglas – *PID 控制 – 简要介绍*: [https://www.youtube.com/watch?v=UR0hOmjaHp0](https://www.youtube.com/watch?v=UR0hOmjaHp0)'
- en: 'I''ve greatly simplified some of the corner-turning algorithms. A very in-depth
    article on how this was used for a competition-winning LEGO Mindstorms robot holds
    a more detailed method:'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我已经大大简化了一些角落转弯算法。一篇关于如何使用这些算法赢得比赛的文章对更详细的方法进行了阐述：
- en: GW Lucas – *Using a PID-based Technique For Competitive Odometry and Dead-Reckoning:*
    [*http*://www.seattlerobotics.org/encoder/200108/using_a_pid.html](http://www.seattlerobotics.org/encoder/200108/using_a_pid.html)
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: GW Lucas – *使用基于 PID 的技术进行竞技里程计和回声定位:* [*http*://www.seattlerobotics.org/encoder/200108/using_a_pid.html](http://www.seattlerobotics.org/encoder/200108/using_a_pid.html)
