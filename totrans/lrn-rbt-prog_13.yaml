- en: '*Chapter 11*: Programming Encoders with Python'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is useful in robotics to sense the movements of motor shafts and wheels.
    We drove a robot along a path back in [*Chapter 7*](B15660_07_Final_ASB_ePub.xhtml#_idTextAnchor131),
    *Drive and Turn – Moving Motors with Python*, but it's unlikely that it has stayed
    on course. Detecting this and traveling a specific distance is useful in creating
    behaviors. This chapter investigates the choice made by the sensor, as well as
    how to program the robot to move in a straight line and for a particular distance.
    We then look at how to make a specific turn. Please note that this chapter does
    contain math. But don't worry, you'll follow along easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Measuring the distance traveled with encoders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching encoders to the robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting the distance traveled in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Driving in a straight line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Driving a specific distance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a specific turn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get started, make sure you have the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Raspberry Pi robot and the code from the previous chapter: [https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter10](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter10).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two slotted speed sensor encoders. Search for slotted speed sensor, Arduino
    speed sensor, LM393 speed sensor, or the Photo Interrupter sensor module. Include
    the term *3.3 V* to ensure its compatible. See the *The encoders we are using*
    section for images of these.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long male-to-female jumper cables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A ruler to measure the wheels' size on your robot – or better yet, calipers,
    if you can use them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this chapter is available on GitHub: [https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter11](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/tree/master/chapter11).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2XDFae0](https://bit.ly/2XDFae0)'
  prefs: []
  type: TYPE_NORMAL
- en: Measuring the distance traveled with encoders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Encoders** are sensors that change value based on the movement of a part.
    They detect where the shaft is or how many times an axle has turned. These can
    be rotating or sensing along a straight-line track.'
  prefs: []
  type: TYPE_NORMAL
- en: Sensing how far something has traveled is also known as **odometry**, and the
    sensors can also be called **tachometers**, or **tachos** for short. The sensors
    suggested in the *Technical requirements* section may also show up as **Arduino
    tacho** in searches.
  prefs: []
  type: TYPE_NORMAL
- en: Where machines use encoders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our robots use electronic sensors. Cars and large commercial vehicles use electronic
    or mechanical sensors for speedometers and tachos.
  prefs: []
  type: TYPE_NORMAL
- en: Printers and scanners combine encoders with DC motors as an alternative to stepper
    motors. Sensing how much of an arc the robot has turned through is an essential
    component of servomechanisms, which we saw in [*Chapter 10*](B15660_10_Final_ASB_ePub.xhtml#_idTextAnchor192),
    *Using Python to Control Servo Motors*. High-end audio or electrical test/measurement
    systems use these in control dials. These are self-contained modules that look
    like volume knobs but users can turn them indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: With this basic understanding of what encoders are, let's now look at some of
    their types.
  prefs: []
  type: TYPE_NORMAL
- en: Types of encoders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Figure 11.1* shows four different encoder sensors, each of which uses different
    mechanisms to measure movement (1–3), along with an encoder wheel and strip in
    panel 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Encoder sensors
  prefs: []
  type: TYPE_NORMAL
- en: 'These sensors fall into a few categories, as shown in *Figure 11.1*, and correspond
    to the points that follow:'
  prefs: []
  type: TYPE_NORMAL
- en: This is a **variable resistor**. These analog devices can measure a turn but
    don't tend to allow continuous rotation. They have mechanical wipers on a metal
    or resistant track, which can wear down. This is not strictly an encoder but is
    handy. On the Raspberry Pi, they require analog-to-digital conversion, so they
    aren't suitable for this application. Servo motors also use these.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This motor includes magnet-sensing encoders, highlighted by the white box, known
    as **hall-effect sensors**. Magnets on a wheel or strip pass next to the sensor,
    causing the sensor values to go high and low.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a standard optical sensor. Using a slot with an IR beam passing through,
    they sense when the beam is interrupted. Computer trackballs, printers, and robotics
    use these. These produce a chain of pulses. Due to the beam being interrupted,
    we call them **photo interrupters**, **optical encoders**, or **opto-interrupters**.
    We will be using this kind.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This shows a slotted wheel and a slotted strip for use with optical sensors.
    The ribbon is suitable for linear encoding and the wheel for encoding turns. They
    both have transparent and opaque sections. People make a variation using a light
    sensor and light/dark cells, but these are less common.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Having seen some of the types of encoders, let's take a closer look at how they
    represent speed and movement.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding absolute or relative position
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Relative encoders** can encode a relative change in position – that we have
    taken a certain number of steps clockwise or anticlockwise, or forward/backward
    along an axis, for example. They can only measure a position relative to the last
    time we measured by counting the number of slots that have passed. These can also
    be called **incremental encoders**. They are inexpensive and straightforward in
    hardware. Relative encoders are limited in that they memorize the previous position
    to create the next and accumulate errors.'
  prefs: []
  type: TYPE_NORMAL
- en: Another type is **absolute encoders**. These can encode the position along or
    around an axis to an exact position. Absolute encoders do not need information
    about the previous position but may need calibrating to determine how an encoding
    matches a real-world location.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the types in comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Comparing absolute and relative sensing
  prefs: []
  type: TYPE_NORMAL
- en: The diagrams in *Figure 11.2* illustrate this difference. The circle on the
    left represents a movement *by* 30 degrees, from a memorized position of 30 degrees.
    This
  prefs: []
  type: TYPE_NORMAL
- en: works, assuming that the original memorized position is accurate. Every time
    it is measured, a movement is measured. The circle on the right shows a position
    *at* 60 degrees from a zero point. If a sensor can tell you where something is
    *at*, then it is absolute. If you can tell you how much it has moved *by*, it
    is relative.
  prefs: []
  type: TYPE_NORMAL
- en: In a crude form, a variable resistor can also be an absolute encoder, as used
    in servo motors to sense their position. Absolute position encoding can be done
    through optical or magnetic markers on a wheel or strip, allowing great precision
    in absolute positioning. These sensors can be bulky or expensive or require many
    inputs. An absolute encoder strip or wheel is also known as a scale.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding direction and speed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Basic relative encoding measures how many wheel slots pass the sensor. This
    gives the speed and distance. By using two sensors slightly apart, you can also
    encode the direction. *Figure 11.3* shows how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Encoding speed and direction with multiple sensors
  prefs: []
  type: TYPE_NORMAL
- en: The system on the left encodes the speed. As the slots pass the sensors, they
    generate electronic pulses. Each pulse has a **rising** edge, where it goes up,
    and a **falling** edge, where it goes down. To count the number of pulses, we
    can count these edges. If you drive a motor with a direction, you can use a system
    with a single sensor like this, as we will do in our robot.
  prefs: []
  type: TYPE_NORMAL
- en: The wheel on the right encodes direction by adding a second sensor. The slot
    edges will make the sensor value change at different points in a cycle, with a
    sequence we've labeled **1**, **2**, **3**, **4**. The direction of the sequence
    indicates the direction of the wheel, along with its speed. As there are four
    phases, this is known as quadrature encoding.
  prefs: []
  type: TYPE_NORMAL
- en: Industrial robots use a **record-and-replay** interface. The user will hit a
    record button and push a robot, such as an arm, through a set of movements, then
    press a stop button. The user has recorded this set of movements, and they could
    ask the robot to replay them.
  prefs: []
  type: TYPE_NORMAL
- en: To build a robot with this record-and-replay system, or a mouse/trackball, the
    direction is essential information, so the additional complexity needed to encode
    the directions is required.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the cheaper and simpler option in our robot, using a single sensor
    to measure relative speed only. In our code, we will assume that each wheel's
    speed sensor is going in the direction we drive.
  prefs: []
  type: TYPE_NORMAL
- en: The encoders we are using
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use optical encoders in a slot shape that fits right above the encoder
    wheels we added in [*Chapter 6*](B15660_06_Final_ASB_ePub.xhtml#_idTextAnchor096),
    *Building Robot Basics – Wheels, Power, and Wiring*. These encoders have digital
    outputs, and we can count the pulses from them in Python to sense how far a wheel
    has turned. *Figure 11.4* shows two types of sensor that I recommend:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – The types of sensor we recommend
  prefs: []
  type: TYPE_NORMAL
- en: On the left is the FC-03 photo interrupter module, and on the right is the Waveshare
    photo interrupter module. Modules that have 3.3 V in their supply voltage specification
    are suitable. Using 5 V-only modules will require level shifters and additional
    wiring, as discussed in [*Chapter 8*](B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150),
    *Programming Distance Sensors with Python*.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use encoder wheels that are attached to the motor shafts. These
    are in line with the wheels. If the encoder wheels are running at a different
    rate from the wheels, we need to account for this. There are conditions that they
    cannot account for, such as slipping, as well as wheel and tire sizes. Encoders
    attached to separate idler wheels give better data, but they are trickier to connect
    to a robot and keep in contact with the floor.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you've seen what encoders can do, counting how much a wheel has turned
    to determine how far you've gone, and you've seen some of the types of encoders
    and which type to buy (3.3 V). You've also had a quick overview of how they work,
    by counting pulses. In the next section, we will build them into the robot.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching encoders to the robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our robot is now getting quite busy, and our Raspberry Pi is above the encoder's
    slots. Due to the slots being under the Raspberry Pi, we should wire them in a
    little before returning the Raspberry Pi. After bolting in the Raspberry Pi, we
    wire the encoders to its GPIO, as well as the power and ground.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11.5* shows what the robot block diagram looks like after attaching
    the encoders:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Robot block diagram with encoders
  prefs: []
  type: TYPE_NORMAL
- en: This block diagram adds a left and right encoder, each with an arrow for the
    information flow connecting them to the Raspberry Pi. The highlighted elements
    are the new ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start changing the robot and making it harder to see, we need to
    know the number of slots in the encoder wheel for later:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Encoder wheel
  prefs: []
  type: TYPE_NORMAL
- en: My encoder wheels, shown in *Figure 11.6*, ended up having 20 slots. Ensure
    you use the number of spaces your encoder wheels have.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the encoders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can use the encoder sensors, we need to prepare and fit them. As
    the encoders are going under the Raspberry Pi, we should attach the male-to-female
    jump wires to the sensors now. I suggest covering any electrical contacts that
    are sticking up under the Raspberry Pi with a little insulation tape:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – The sensors with cable connections
  prefs: []
  type: TYPE_NORMAL
- en: Notably, the cables should be plugged into the ground (**GND**), voltage (**3
    V**, **Vin**, or **VCC**), and digital output (**D0**/**OUT**), as shown in *Figure
    11.7*. If it is present, do not connect the analog output (**A0**) pin. If possible,
    the ground pin should have the darkest color, or the voltage should be the lightest
    color. To help keep this clear, I suggest wrapping a small strip of insulation
    tape around the signal line's end.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: As these sensors' pin configurations can vary, get a reference photo of the
    sensor pin labels before putting it under the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Lifting the Raspberry Pi
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The encoder sensors need to go underneath the Raspberry Pi, so the Raspberry
    Pi needs to be gently lifted (without disrupting the wires) to accommodate them.
    The sequence of photos in *Figure 11.8* shows how to raise it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – Unscrewing and lifting off the Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to *Figure 11.8* and carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to unscrew the bolts holding the Raspberry Pi to the chassis carefully.
    Put the screws aside for replacing the Raspberry Pi on the robot so that it can
    gently lift away.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gently lift the Raspberry Pi away from the robot without disrupting the cables.
    The photo shows how your robot should look.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Great! Now that the Raspberry Pi is lifted, there is space for fitting the encoders
    under it.
  prefs: []
  type: TYPE_NORMAL
- en: Fitting the encoders onto the chassis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you have wired the encoders, you can fit them to the robot chassis.
    As a guide, *Figure 11.9* shows a bare chassis with each of the sensor types fitted
    to show you where you push them in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_11_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – Fitting the encoder sensors
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to *Figure 11.9* and complete these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Gently push the encoders into the slots around the encoder wheel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The sensors should friction fit into the slots above the encoder wheels and
    stay in place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once these are in place, you can replace the screws to attach the Raspberry
    Pi to the chassis. You may need different-sized standoffs to accommodate it.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: At this point, check that all your connections are back in place. The motor
    wires are likely to have come loose.
  prefs: []
  type: TYPE_NORMAL
- en: With the encoders attached and the Raspberry Pi back in place, you are ready
    to wire them in.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring the encoders to the Raspberry Pi
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now start making wire connections for the sensors using the breadboard.
    We'll use a circuit diagram to guide our connections.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11.10* shows the connections for these sensors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_11_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 – Circuit for connecting the encoders to the Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11.10* shows the circuit for connecting the encoders to the Raspberry
    Pi. This diagram continues from the circuit seen in [*Chapter 8*](B15660_08_Final_ASB_ePub.xhtml#_idTextAnchor150),
    *Programming Distance Sensors with Python*. The new connections have thicker wire
    lines.'
  prefs: []
  type: TYPE_NORMAL
- en: On the right of *Figure 11.10* are the right and left encoder modules. The sensor
    will have a **VCC**, **VIN**, **3 V**, or just **V** label. Connect this to the
    3.3 V line. Find the GND pin labeled **GND**, **0V**, or just **G** and connect
    it to the black/blue band on the breadboard. The encoders also have a pin labeled
    **DO** (digital out), **SIG** (signal), or just **S**, connected to a GPIO pin
    for the digital signal. We connect the digital outputs from the sensors to GPIO
    pins 4 for the left encoder and 26 for the right encoder.
  prefs: []
  type: TYPE_NORMAL
- en: Some encoder sensors have additional connections, such as **Analog Out** (**AO**),
    which we will not use and will leave unconnected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the sensor's pins to the breadboard. Pay attention to the labels on
    the sensor – some have a different pin ordering.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Raspberry Pi GPIO pins 4 and 26 to the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the breadboard power connections using precut wires.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The number of wire-to-wire points on this robot makes it hard to add new connections
    or repair. Although beyond the scope of this book, making custom **Printed Circuit
    Boards** (**PCBs**) makes this thicket of cabling much neater. PCBs are also less
    fragile and takes up less space. Changing it does, however, come with a cost.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is possible to shortcut the breadboard and wire the sensor into the Raspberry
    Pi; however, the breadboard helps distribute the power connections and groups
    the sensor connections.
  prefs: []
  type: TYPE_NORMAL
- en: We make this circuit in the context of a busy robot with other connections.
    If the cables from the sensors to the robot are not long enough, use a further
    set of male-to-female cables, using the same technique seen for the sonar scan
    in [*Chapter 10*](B15660_10_Final_ASB_ePub.xhtml#_idTextAnchor192), *Using Python
    to Control Servo Motors*.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you've learned how to connect the sensors and have made them
    ready to program. In the next section, we will write some code to test these sensors
    and then measure distances.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the distance traveled in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using encoder sensor devices requires us to count pulses. In this section, we
    will create code to turn on the motors and count pulses for a while. The code
    validates that the sensors are connected correctly. We then take this code and
    make it part of the robot class as a behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far in our Python code, we have been using `print` to output information
    to see what our robot is doing. This works, but prints can become overwhelming
    if we print everything we might want to inspect. Logging allows us to still display
    information, but we can control how much. By importing the `logging` module, we
    can take advantage of this.
  prefs: []
  type: TYPE_NORMAL
- en: First, there are logging levels, with `debug`, `info`, `warning`, and `error`.
    While fixing problems or initially developing, `debug` is useful – it can show
    everything – while `info` is used to show a little less than that. The `warning`
    and `error` levels are reserved only for those kinds of problems, so you can filter
    down to only this level when you are reasonably confident with some code. The
    `logging.basicConfig` function allows us to configure a logging level and other
    logging parameters; you need to configure logging to enable `info` and `debug`
    logging.
  prefs: []
  type: TYPE_NORMAL
- en: The other thing you can do with logging is to have differently named loggers
    using the `logging.getLogger` function. This lets you set different levels for
    different modules. Using named loggers helps to enable `debug` from a library
    module you are using while sticking to `info` on the main module.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter's code, we will start using logging and controlling logging
    levels to get more detail on what an example is doing, turning the parts on and
    off at will. When we introduce the PID controller later, this will become very
    useful indeed. We can use this logging in the next section to show a sensor pulse
    count.
  prefs: []
  type: TYPE_NORMAL
- en: Simple counting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This code counts the number of cycles up and down on each wheel''s signal pin,
    printing the count as we test the sensors. Running this verifies that our sensor
    connections are working, letting us troubleshoot and move on. It also lays code
    foundations for tracking wheel movements. We run our motors for about 1 second.
    Note that this code assumes you are starting with the code from [*Chapter 10*](B15660_10_Final_ASB_ePub.xhtml#_idTextAnchor192),
    *Using Python to Control Servo Motors*:'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the following code at [https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/test_encoders.py](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/test_encoders.py).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a file called `test_encoders.py`, starting with the usual robot
    classes, `import` and `time`, and adding logging:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we add an import for a GPIO Zero input device. We can use the pin it
    sets up to count our pulses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We've also set up a named logger for our system matching the filename.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The encoders generate pulses; we want to count them and track their state.
    We use more than one of them. Creating a class from the outset seems like the
    right strategy. From here, we can pass our I/O pin number to the constructor.
    The first thing it needs to do is to set up a pulse counter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still in the constructor, we need to set up the device and how we count pulses
    with it. The device has a `.pin` object, which we set up using the pin number.`.pin`
    has a `when_changed` event, which we can drop our handler into to be called every
    time the pin changes. The pin changes from up to down (rising and falling) for
    every slot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to define a `when_changed` method for our class to add one to `pulse_count`.
    This method must be as small/quick as possible, as GPIO Zero calls it in the background
    for every pulse change. It takes a `time_ticks` parameter and a `state` parameter.
    We will not use `time_ticks`, so mark this with an underscore:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can set up our `robot` object and create an `EncoderCounter` for each side''s
    sensor. We connected our devices to pins `4` and `26`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To display values, instead of just using `sleep`, we loop, checking against
    an end time. Before we log anything, `logging.basicConfig` sets logging parameters.
    We start the motors and go into the main loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this loop, we log the readings on both sensors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Since tight loops can cause things to break (such as GPIO Zero calling our
    code from a sensor thread), it should sleep a little too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can send this code to the robot and run it. You can now see the robot veering
    through the encoder''s values. The output should look a little like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The encoders are counting, and it shows that the robot moved less on the left
    wheel and more on the right wheel, and veered left. The `INFO:test_encoders:`
    part is introduced by the logging, showing the logging level and the logger name.
    The distances are in encoder *ticks*, a tick being each counted event.
  prefs: []
  type: TYPE_NORMAL
- en: You've now tried out this code, but refer to the troubleshooting section if
    you have any problems.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you find problems when running this, try the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure you started from the [*Chapter 10*](B15660_10_Final_ASB_ePub.xhtml#_idTextAnchor192),
    *Using Python to Control Servo Motors*, code. If you downloaded code from the
    current chapter, you will likely see GPIO conflicts with the code already set
    up for the encoders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the encoder values stay at zero, turn off the Raspberry Pi, then go back
    and carefully check your wiring and pin number usage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check your wiring – if anything is hot, immediately disconnect the power and
    verify your wiring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have tested the encoders on the robot, seeing feedback on your screen as
    they moved. This demonstrates that they are ready to be used in more interesting
    robot behaviors after adding them to the `Robot` object.
  prefs: []
  type: TYPE_NORMAL
- en: Adding encoders to the Robot object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use this sensor in other code or behaviors, we should move it into the `Robot`
    object. We can then import our code into the `Robot` object and set up the two
    sides with the correct pins. You'll also need to add some cleanup code for the
    handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting the class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ve already made the `EncoderCounter` class, which you can copy from `test_encoders.py`
    to the `encoder_counter.py` ([https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/encoder_counter.py](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/encoder_counter.py))
    file. This code needs the import for `DigitalInputDevice`, the same constructor,
    and the `when_changed` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the imports and class declaration. The `EncoderCounter`
    class starts the same way as the last section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'I''m adding a `direction` member to account for reversing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The constructor (`__init__`) is finished by setting up the device and assigning
    a `when_changed` handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our `when_changed` handler should add the direction instead of 1, so it can
    count up or down:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should also have a method to set this direction, so we can assert to validate
    our setting, which throws an exception if it doesn''t meet the condition with
    the given text – a cheap but brutal way of ensuring input values make sense:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A reset method means we can handle restarting counters between movements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For cleanup, we need a way to stop the counters so that they don''t call the
    handler again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the encoder library ready, we can use this in our code. The library means
    we can reuse our encoder counter in different places, and also that we can substitute
    a different device with similar properties. To make it available to many behaviors,
    it will be handy to import it into the robot library.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the device to the Robot object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've used our `Robot` object as the main interface between code handling the
    hardware and the behavior code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will modify the `robot.py` code from [*Chapter 10*](B15660_10_Final_ASB_ePub.xhtml#_idTextAnchor192),
    *Using Python to Control Servo Motors* ([https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter10/robot.py](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter10/robot.py))
    to add the sensors:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by importing `EncoderCounter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `__init__` constructor method, we need to set up left and right encoders.
    I did this just after the distance sensors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make sure that the code cleans up encoder handlers when our `Robot` object
    has stopped, we call the encoder''s `stop` methods in the `stop_all` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The finished code for `robot.py` with encoders is on GitHub ([https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/robot.py](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/robot.py)).
    We can now use this to build a behavior to measure the distance in millimeters.
    To do so, we'll understand the relationship between encoder ticks and the distance
    moved in millimeters.
  prefs: []
  type: TYPE_NORMAL
- en: Turning ticks into millimeters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To calculate real distances, we need the sizes of the wheels. We cannot account
    for slipping, but we can find out how much a wheel has turned, which is the same
    as the encoders. Using the wheel''s diameter, we can calculate how far it has
    turned. Using a ruler or caliper, measure the diameter across the wheel, as shown
    in *Figure 11.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_11_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.11 – Measuring the wheel
  prefs: []
  type: TYPE_NORMAL
- en: 'The measurements needed are shown in *Figure 11.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: You will need to measure the wheel's diameter, marked **D** in this figure,
    and the distance between the wheels, **W**. The distance **W** is equivalent to
    the width from midpoint to midpoint of the two motor-driven wheels on the robot.
    It is easier to measure, as shown here, the right side of one wheel, all the way
    across to the right side of the other wheel – which will be the same as midpoint
    to midpoint. Mine came to about 130 mm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can measure **D** with calipers, as shown here, by fitting them around the
    widest part of the wheel. My wheel came to 70 mm, to the nearest mm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We know how many slots are on the encoders, and we expect two ticks (the rising
    and falling) per slot, so we can take the number of slots times 2, which is the
    number of ticks per whole-turn of the wheel – in my case, this is 40.
  prefs: []
  type: TYPE_NORMAL
- en: 'The number pi, or ![](img/Formula_11_001.png), is the ratio of the diameter
    to the circumference of the wheel. To get the circumference, we multiply the diameter
    by pi, giving us ![](img/Formula_11_002.png), where *D* is the diameter. We can
    divide pi by the number of total ticks per revolution, and then when we multiply
    this by the number of ticks counted, *T*, and then the diameter, *D*, and we get
    a number for the distance, *d*, that the wheel has traveled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_11_003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, how do we turn this into code? Refer to the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a new file called `test_distance_travelled.py`. At the top of the file,
    we need to import `math` for the calculations, the `Robot` object, and `time`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we define our constants – the wheel''s diameter and the number of ticks
    per revolution. Please use the values you obtained, not the ones that I have shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to convert the ticks counted into a distance. It''s converted
    into integers since fractions of a millimeter are just not appropriate for this
    measurement. Since part of the conversion doesn''t change, we make that a constant,
    too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we define our robot, set up a stop time, and start the motors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the loop, we display the distance by calling `ticks_to_mm` on the pulse
    counts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When uploaded to the robot and run, the output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This output has shown a clear difference between the travel on the left and
    the right motors. The right motor is moving slightly quicker than the left. This
    difference accumulates, making the robot turn further. So, in the next section,
    let's use this information to straighten things up.
  prefs: []
  type: TYPE_NORMAL
- en: Driving in a straight line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you have seen differences in the outputs – that is, a veer. In only
    400 mm, my left side is around 20 mm behind the right, an error that is climbing.
    Depending on your motors, your robot may have some veer too. It is rare for a
    robot to have driven perfectly straight. We use the sensors to correct this.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: This behavior works better on wooden flooring or MDF boards, and poorly on carpet.
  prefs: []
  type: TYPE_NORMAL
- en: This correction is still dead reckoning; slipping on surfaces or incorrect measurements
    can still set this off course. How can we use motors and encoders to correct our
    course and drive in a straight line?
  prefs: []
  type: TYPE_NORMAL
- en: Correcting veer with a PID
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A behavior to self-correct steering and drive in a straight line needs to vary
    motor speeds until the wheels have turned the same amount. If the wheels turn
    the same amount soon enough, then they will account for major course deviations.
  prefs: []
  type: TYPE_NORMAL
- en: Our robot will use the encoder sensor to measure how much each wheel has turned.
    We can then consider the difference between these to adjust the motor control
    and try to keep the motors at the same speed.
  prefs: []
  type: TYPE_NORMAL
- en: A trick with this is working out how the difference in measurements relates
    to adjusting motor speeds. This leads us to look at a PID system designed to map
    errors into adjustment and output values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Driving in a straight line needs a closed **feedback** loop. *Figure 11.12*
    shows how this loop works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_11_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.12 – Closed-loop control of a motor's speed
  prefs: []
  type: TYPE_NORMAL
- en: We start with an *expected position* or **set point**. The *encoder position*
    gives feedback data from the real world. We get a difference between the setpoint
    and the encoder position, which we call the *error*. The code feeds this into
    a *controller*, which generates a *speed adjustment*. The system will then apply
    that adjustment to the *motor speed*, making the motor turn more or less, changing
    the encoder's feedback.
  prefs: []
  type: TYPE_NORMAL
- en: To go straight, we take the left motor's value and subtract the right motor
    to get an encoder difference. Our *expected position* is 0\. Our *error* is then
    the difference between the encoders. We can then adjust the speeds using the controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use a **PID** controller to adjust the speed of the motors; this has three
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Proportional** (**P**): The error value multiplied by a constant. This corrects
    for immediate errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integral** (**I**): The sum of the error values so far, multiplied by a constant.
    This corrects for continuing errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Derivative** (**D**): This takes the difference between the last error value
    and now and multiplies by a constant. This is to push back a little against sudden
    changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By manipulating the constants, we *tune* how much each factor influences the
    outcome of the controller. We won't be using the derivative component for our
    behaviors, which is equivalent to having its constant set to zero.
  prefs: []
  type: TYPE_NORMAL
- en: The integral can give the robot some self-tuning, but it needs to have a very
    small constant, as high values can make the robot start to wobble instead. We
    will add the adjustment onto one motor and subtract it from the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'The right motor speed is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We need an unused motor speed capacity to be able to speed up a bit. If the
    speed is too close to 100%, we get clipping. An integral behavior with clipping
    can make the robot behave quite strangely, so watch out for clipping at 100%!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Leave headroom for PID adjustments – use no more than 80% of motor speed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have some idea how a PID controller works, let's build one in code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Python PID controller object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The PID controller code is a fundamental robotics building block for making
    straight lines and we''ll use it again in later camera-driven chapters. You will
    use the basic concepts here in many robotic systems:'
  prefs: []
  type: TYPE_NORMAL
- en: We use this in a few places, so let's make a simplified PID control object.
    I put this in a file named `pid_controller.py`. Note that this is only a `proportional_constant`
    as `pK` and `integral_constant` as `iK`. You can do so if you wish. I've used
    the longer names in the code examples to make it easier to read.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code handles the values for the two components. Handling the
    integral has the effect of increasing the integral sum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following bit of code handles the error to generate the adjustment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the PI code in place, we are ready to make a robot that can combine errors
    with previous values, scaling them to make them useful in the context of some
    movement. We will use this PID controller for our straight line adjusting in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Writing code to go in a straight line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I called this `straight_line_drive.py` ([https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/straight_line_drive.py](https://github.com/PacktPublishing/Learn-Robotics-Programming-Second-Edition/blob/master/chapter11/straight_line_drive.py)):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s import the `Robot` object, `time`, and our new PI controller. We''ll
    set up logging to get debug from the PID controller. You can tune it back to `INFO`
    or take that line out if it''s too much:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up the `Robot` object too, and set up a slightly longer `stop_at_time`
    value so that our robot drives a bit further:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start with a master speed value of `80`, and set both motors to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before going into our main loop, set up the controller. You may need to tune
    these constants. Note how small the integral constant is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the loop, we `sleep` a little so that our encoders have something to measure.
    It''s also usually a bad idea to have a "tight" loop that doesn''t use `sleep`
    to give other things a chance to run. Get the encoder values and compute the error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That error needs to be handled by the controller and used to make `right_speed`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then log debug information here. Notice we have two levels: debug for
    the error and adjustment and info for the speeds. With the current config set
    to `INFO`, we won''t see the debug without modifying it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then set the motor speeds to the adjusted values and finish the loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we run this, the robot should be following a fairly straight course. It
    may start unstable, but should hone in on a constant adjustment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The robot starts with no error as the motors engage, but the right goes faster.
    At 13 ticks, the controller pulls the adjustment pretty high. Notice how `P` jumps,
    but `I` settles for a constant value after a while, which will keep the robot
    straight.
  prefs: []
  type: TYPE_NORMAL
- en: Tuning of the `P` and `I` constants and the loop timing may result in earlier
    corrections – the initial encoder values are too small to be useful.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this may still end up off course; it accounts for reducing the veer
    but can adjust too late to stop a small *S* shape or other error. It is, however,
    much straighter than driving without. Adjusting the PID can help with this.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting this behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few steps to take if the robot is wobbling or doesn''t manage to
    travel in a straight line:'
  prefs: []
  type: TYPE_NORMAL
- en: If the robot takes too long to compensate, increase the proportional component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the robot overshoots massively (that is, it swerves one way, then the other),
    reduce the size of both the proportional and integral PID components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the robot is making increasing wobbles, the integral is too high, and the
    right speed may be going above 100\. Bring down the integral component, and perhaps
    the requested speed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can set the `straight_line` logger or `basicConfig` to debug to see the
    error value too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the straight line working and driving, you have now corrected veer problems
    and differences between the sides. You can now build on this; let's take a known
    distance and drive to it, then stop.
  prefs: []
  type: TYPE_NORMAL
- en: Driving a specific distance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For driving a specific distance, we use the PI controller again and incorporate
    the distance measurements into our encoder object. We calculate how many ticks
    we want the left wheel to have turned for a given distance, and then use this
    instead of a timeout component.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring unit conversions into the EncoderCounter class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want the conversions for our encoders in the `EncoderCounter` class to use
    them in these behaviors. Refactoring is the process of moving code or improving
    code while retaining its functionality. In this case, converting distances is
    one of the purposes of using encoders, so it makes sense to move this code in
    there:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up your `encoder_counter.py` class. First, we need the `math` import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the top of the class, add `ticks_to_mm_const` as a class variable (not an
    instance variable) to use it without any instances of the class. Set this to none
    initially so that we can calculate it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our class, we want to retrieve the distance the wheel has traveled directly
    from the encoder, in mm. Add this to the end of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also want to calculate the opposite: the number of ticks from a distance
    in mm. To do that, divide the distance in mm by the same constant we multiplied
    by. This is set to `staticmethod` so that it does not require later code to use
    an instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a way to set the constants in the file (for different robot configurations):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you have saved this, `EncoderCounter` can now convert between distance
    and encoder ticks. We now need to set up the wheel diameters for your particular
    robot.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we can use our robot metrics in our behaviors. Now, we want the `Robot`
    object to store our measurements and register them with the encoders. We can do
    this in two simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `robot.py`, just before the constructor, specify some of these numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Register these with the encoders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the constants ready, we've primed our encoders to measure distance. We
    can use this to make a behavior to drive a distance.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the drive distance behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I''ll put this code into `drive_distance.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by importing `EncoderCounter` to use its metrics, `PIController`, and
    the `Robot` object, and set up a logger:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `drive_distance` function, which takes a robot instance, a distance
    in ticks, and an optional speed defaulting to 80\. We start by making a primary
    and secondary motor and controller decision:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now have a well-defined primary and secondary motor. Set up a `PIController`
    and start the two motors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we are in the driving distance loop. We should continue the loop until
    both encoders reach the right distance. We need to sleep before the rest of the
    loop so that we have some data for our calculations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the error and feed it into the controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can send this to the motors and debug the data too. Because the adjustment
    is a non-integer, we allow two decimal places by using `{:.2f}`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up the robot, let it calculate how far you want it to go, and get it moving:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We let the robot cleanup (`atexit`) stop the motors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you run this, the robot drives a meter and stops. My robot, when stopping,
    looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: There is a 2 mm overshoot, which it can lose in rounding values and detection
    time. We can't make partial ticks.
  prefs: []
  type: TYPE_NORMAL
- en: You have now seen how to make the robot drive a specific distance (or pretty
    close to it) while trying to stay in a straight line. You've combined the measuring
    and the PID adjustment tools that you've built throughout this chapter. But what
    if we want to make turns and measure those? We'll cover this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Making a specific turn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next task we can use our encoders for is to make a specific turn. When
    turning a robot, each wheel is going through an arc. *Figure 11.13* illustrates
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_11_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.13 – Illustrating wheel movement when turning through an arc
  prefs: []
  type: TYPE_NORMAL
- en: 'The inner wheel drives a shorter distance than the outer wheel, and from the
    basics of differential steering, this is how we make the turn. To make an exact
    turn, we need to calculate these two distances or the ratio between them. *Figure
    11.14* shows how the wheels and the turn relate to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15660_11_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.14 – Relating wheels to turn radiuses
  prefs: []
  type: TYPE_NORMAL
- en: 'If we consider the turn radius as setting where the middle of the robot is,
    an inner wheel''s turn radius is the *difference* between the turn radius and
    half the distance between the wheels:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_11_004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The outer wheel''s turn radius is the turn radius *added* to half the distance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_11_005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We convert our angle to turn into *radians*, and we can then multiply this
    angle by each wheel radius to get the distances that each wheel needs to move
    through:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_11_006.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_11_007.png)'
  prefs: []
  type: TYPE_IMG
- en: Python has math functions to convert degrees into radians.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s turn these functions into some code, demonstrating it by attempting
    to drive in a square, making measured 90-degree turns:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with a copy of `drive_distance.py` and call it `drive_square.py`. Add
    the `math` import, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can modify the end of this file to state what we want to do. It can help
    to name functions that you plan to have, and then implement them to fit. We make
    it a bit smaller than a meter, too. For a radius to test with, I''ve added 100
    mm to the robot''s wheel distance. Anything less than the wheel distance and the
    center of the turn is between the wheels instead of outside of them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we are driving in a square, we want to drive four times. For straight
    lines, drive each wheel the same distance, then make 90-degree arcs of our radius.
    I''ve reduced the speed for the arc so that there is less of a slipping problem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s go back up in the file to upgrade our method for driving a distance
    to one distance to driving two distances, one for each wheel. I''ve renamed the
    `drive_distance` function to `drive_distances`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Depending on the angle we want to turn, either motor could be the outer motor
    and driving a longer distance. Since there is an upper limit to speed, we choose
    our primary and secondary motors based on the longer distance. Swap the code that
    set up the primary/secondary with this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we are using this method more than once, reset the encoder counts. I
    put this in before setting up `PIController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we can be going in either direction, set the encoder direction. Python
    has a `copysign` method to determine the sign of a value. Then, start the motors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we start this loop, we again need to be aware that one or both motors
    could be going backward. We use `abs` again to take off the sign:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calculating the error for the secondary depends on the ratio between the two
    distances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This still goes into the same adjustment calculation through `pid`; however,
    this adjustment may also cause a change in direction here. Now, we set the secondary
    motor speed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You could expand the debug that we had to take into account for the secondary
    speed and targets. Now, because we are trying for precision, the primary motor
    may reach its goal before the secondary and isn''t set up to reverse. So, stop
    this motor when it reaches its goal, and set the base speed of the secondary to
    zero, which means only adjustments apply, if any. Note that we still use the absolute
    values here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And we are done with the driving distances function. We can use this to drive
    in a straight line or feed it a separate target distance for each wheel and use
    that to drive in an arc. We'll take advantage of that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the drive_arc function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is where we convert to radians, determine the inner radius, and set up
    the distances for each wheel to drive. Add this code in `drive_square_behaviour.py`,
    after the `drive_distances` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with a function definition and a helpful docstring:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We turn the robot''s width into ticks, the internal measurement of distance,
    and use half of that to get the wheel radiuses. We also determine which is the
    inner wheel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We display the debug on what the radiuses are. Combine this with the turn in
    radians to get the distances. We convert the absolute value of the turn in degrees.
    We don''t want to reverse into a turn, but to turn the other way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, feed these distances into the `drive_distances` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The robot should be able to drive in a square shape. It can still miss due to
    slipping or inaccuracies in the measurements. Tuning of the proportional and integral
    control values is required.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the full code for `drive_distances` and `drive_arc`, it may become
    apparent that there is some repetition in determining the inner/outer and the
    primary/secondary parts, which you could refactor if you choose.
  prefs: []
  type: TYPE_NORMAL
- en: This code may not behave correctly if reversing through a corner.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to incorporate wheel encoder sensors into our robot
    and used them to determine how far each wheel has turned. We saw how to use this
    to get the robot onto a straighter path using a reduced PID controller and then
    used this to drive a specific distance. We then took the calculations further
    to calculate turning a corner in terms of wheel movements and driving the robot
    in a square.
  prefs: []
  type: TYPE_NORMAL
- en: A PID controller can be used in many situations where you need to apply a difference
    between a measurement and expectation, and you have seen how to combine this with
    sensors. You could use the same system to control a heating element connected
    to a thermal sensor. You could also use encoders to move robots with some precision,
    where the restricted range of motion used in servo motors does not make sense.
  prefs: []
  type: TYPE_NORMAL
- en: In the next couple of chapters, we will explore giving our robot even more interactive
    and intelligent behaviors, with chapters on visual processing using a Raspberry
    Pi camera, speech processing with Mycroft, and using a smartphone to drive or
    select modes on the robot remotely.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try experimenting with turning on different logging levels and differently named
    loggers, tuning how much output a robot behavior creates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the PID behaviors, tune the PIDs, try high values for the proportional or
    the integral, and observe how this makes the robot behave. Could you combine this
    with graphing in `matplotlib` to observe the PID behavior?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are a few ways that the drive distance code could be improved. Applying
    a **PID** controller to the distance moved by the primary could make it close
    in more precisely on the exact distance to travel. Detecting no movement in either
    encoder could be used to make the code stop after a timeout so that it doesn't
    drive off without stopping. Try this out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You could now use this code to make further geometric shapes or to follow paths
    without a line. Try adding high-level left turn/right turn 90-degree functions
    as building blocks for right-angled path construction, then use this to make paths.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider combining the encoding sensors here with distance sensors; it may be
    possible to start memorizing distances between walls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please refer to the following for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'PID control is a deep subject. It is a key area in self-balancing robots, drones,
    and other autonomous control systems. Here is a great video series so that you
    can explore these further:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'YouTube: Brian Douglas – *PID Control – A brief introduction*: [https://www.youtube.com/watch?v=UR0hOmjaHp0](https://www.youtube.com/watch?v=UR0hOmjaHp0)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'I''ve greatly simplified some of the corner-turning algorithms. A very in-depth
    article on how this was used for a competition-winning LEGO Mindstorms robot holds
    a more detailed method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GW Lucas – *Using a PID-based Technique For Competitive Odometry and Dead-Reckoning:*
    [*http*://www.seattlerobotics.org/encoder/200108/using_a_pid.html](http://www.seattlerobotics.org/encoder/200108/using_a_pid.html)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
