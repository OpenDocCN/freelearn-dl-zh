- en: Replacing Back Propagation with PSO
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将反向传播替换为PSO
- en: One of the latest examples of success with neural networks is the field of study
    known as **Swarm Intelligence**. Even though this field of study has been around
    for many years, advances in computer hardware combined with our understanding
    of studying animals has helped us to take this fascinating field out of the laboratory
    and into many different directions and real-world scenarios.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 神经网络领域最新的成功案例之一是被称为**群智能**的研究领域。尽管这个研究领域已经存在多年，但计算机硬件的进步以及我们对动物研究的理解帮助我们把这个迷人的领域从实验室带到了许多不同的方向和现实世界场景中。
- en: 'In this chapter, we are going to cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Basic theory on Particle Swarm Optimization, or PSO for short
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子群优化（PSO）的基本理论
- en: The open-source machine-learning framework Encog
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开源机器学习框架Encog
- en: Replacing the conventional back propagation with PSO
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将传统的反向传播替换为PSO
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will require Microsoft Visual Studio and also might want refer [https://github.com/encog](https://github.com/encog).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要Microsoft Visual Studio，也可能需要参考 [https://github.com/encog](https://github.com/encog)。
- en: Check out the following video to see Code in Action: [http://bit.ly/2QPd6Qo](http://bit.ly/2QPd6Qo).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用： [http://bit.ly/2QPd6Qo](http://bit.ly/2QPd6Qo)。
- en: Basic theory
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本理论
- en: OK, pop quiz time. What do a flock of birds, a school of fish, and a swarm of
    bees all have in common? Swarm intelligence—knowing how to cooperatively live
    and work near each other while optimally achieving the same objective. It's not
    about the intelligence of the individual, but rather the achievements of the group.
    No one individual has a clear path or directive, no one is at the top shouting
    orders, yet the optimal goal is always accomplished. Swarms of bees find new nests
    by doing waggle dances. Birds fly in great harmony, each taking turns being the
    leader. Fish swim collectively in beautiful architectures we call schools. But
    if we as humans always need someone at the top giving orders, and we still collectively
    don't always agree, how is it that millions of these little creatures have been
    doing it for years and we can't? Oops, going off on a tangent there, sorry!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在进行一个小测验时间。一群鸟、一群鱼和一群蜜蜂有什么共同之处？群智能——知道如何合作地生活和工作在一起，同时最优地实现相同的目标。这并不是关于个体的智能，而是群体的成就。没有哪个个体有明确的路径或指令，没有人处于最高层下达命令，然而最优目标总是能够实现。蜜蜂通过摇摆舞找到新的巢穴。鸟儿以极大的和谐飞行，轮流担任领导者。鱼儿以我们称之为鱼群的美丽架构集体游泳。但如果我们作为人类总是需要有人处于最高层下达命令，而我们集体又并不总是意见一致，那么这些小小的生物是如何年复一年地做到这一点的，而我们却做不到呢？哎呀，我跑题了，抱歉！
- en: Let's start off with a few quick definitions that will be used throughout to
    ensure we are all on the same page going forward.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些快速的定义开始，这些定义将在整个过程中使用，以确保我们都在同一页面上继续前进。
- en: Swarm intelligence
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 群智能
- en: Swarm intelligence is the collective behavior of self-organizing systems, decentralized
    in nature. The swarm itself exhibits social cognitive behavior and achieves a
    goal that individual contributors would not achieve by themselves. The collective
    achieves the goals rather than the efforts of any individual contributor. This
    leads us to PSO itself.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 群智能是自组织系统的集体行为，本质上具有去中心化的特点。群体本身表现出社会认知行为，并实现单个贡献者无法单独实现的目标。集体实现目标，而不是任何单个贡献者的努力。这引导我们到PSO本身。
- en: Particle Swarm Optimization
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子群优化
- en: '**Particle Swarm Optimization** is a method (a population-based algorithm)
    that solves a problem by optimizing it iteratively while trying to improve a potential
    solution regarding its optimal quality. Every individual particle in the PSO algorithm
    learns from itself and another particle with a good fitness value. Each particle,
    which represents a solution, flies through the search space with a velocity that
    is dynamically adjusted according to its own and its companion''s historical behaviors.
    The particles tend to fly toward better search areas over the course of the search
    process.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**粒子群优化**是一种方法（一种基于群体的算法），通过迭代优化问题，同时尝试改进关于其最优质量的潜在解决方案。PSO算法中的每一个粒子都会从自身和另一个具有良好适应度的粒子那里学习。每个粒子，代表一个解决方案，以动态调整的速度在搜索空间中飞行，这种速度根据其自身及其伴侣的历史行为进行调整。在搜索过程中，粒子倾向于飞向更好的搜索区域。'
- en: Types of Particle Swarm Optimizations
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子群优化的类型
- en: 'The following is a list of just some of the variants of Particle Swarm Optimization:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些粒子群优化算法的变体：
- en: Traditional Particle Swarm Optimization
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统粒子群优化
- en: Canonical Particle Swarm Optimization
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准粒子群优化
- en: Fully informed Particle Swarm Optimization
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全信息粒子群优化
- en: 'Let''s now talk a little bit about the theory behind swarm intelligence, and
    then we''ll move into two of the more specialized types of study in that field:
    Particle Swarm Optimization and ant swarm optimization, which are both direct
    drop-in replacements for back propagation!'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来简单谈谈群智能背后的理论，然后我们将进入该领域两个更专业的研究类型：粒子群优化和蚂蚁群优化，这两种优化方法都是直接替代反向传播的解决方案！
- en: However fascinating and intriguing you find this, please remember that nothing
    is perfect and there's no single shiny bullet that works for everything. This
    is a fascinating theory of study and entire books have been written on the subject.
    However, we always need to keep in mind the **No Free Lunch Theorem for Optimization**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你发现这多么迷人且引人入胜，请记住，没有什么是完美的，也没有任何一种万能的解决方案适用于所有情况。这是一个迷人的研究领域，关于这个主题已经写出了整本书。然而，我们始终需要牢记**优化中的无免费午餐定理**。
- en: The No Free Lunch Theorem for Optimization states that no one can propose any
    one specific algorithm for solving all optimization problems. The success of an
    algorithm in solving one specific set of problems does not guarantee that it solves
    all optimization problems. More concretely, all optimization techniques perform
    equally well on average if you consider every optimization problem despite the
    performance on a subset of problems.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 优化中的无免费午餐定理指出，没有人可以提出任何一种特定的算法来解决所有优化问题。一个算法在解决某一特定问题上的成功并不能保证它能解决所有优化问题。更具体地说，如果考虑所有优化问题，那么所有优化技术平均表现都相同，尽管在问题子集上的表现可能不同。
- en: 'In a very well written paper titled *A time performance comparison of Particle
    Swarm Optimization in mobile devices*, written by Luis Antonio Beltrán Prieto,
    Zuzana Komínkova-Oplatková, Rubén Torres Frías, and Juan Luis Escoto Hernández,
    Particle Swarm Optimization is described like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在一篇非常优秀的论文《移动设备中粒子群优化的时间性能比较》中，由Luis Antonio Beltrán Prieto、Zuzana Komínkova-Oplatková、Rubén
    Torres Frías和Juan Luis Escoto Hernández撰写，对粒子群优化进行了如下描述：
- en: '"PSO is an optimization technique developed by Kennedy and Eberhart inspired
    by the collective behavior of animal groups, such as swarms of insects, to build
    a swarm of particles, i.e., a set of candidate solutions which flow through the
    parameter space generating trajectories driven by the best individuals. The initial
    population (swarm) consists of random solutions (particles) for the problem and
    is considered as a population of homogeneous agents which interact locally with
    other individuals without any central control. As a result, collective behavior
    is generated, thus evolution relies on cooperation and competition among individuals
    through the different epochs (generations). Each particle defines trajectories
    in the parameter space according to a motion function which is affected by velocity,
    inertia, cognitive coefficient and social coefficient. The objective is to find
    the global best solutions by stochastic weighting of the aforementioned elements.
    The process is iterative until a stopping criterion is met."'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '"PSO是一种由Kennedy和Eberhart开发的优化技术，它受到动物群体集体行为（如昆虫群）的启发，构建了一群粒子，即一组候选解，这些解在参数空间中流动，生成由最佳个体驱动的轨迹。初始种群（群体）由问题的随机解（粒子）组成，被视为一个同质代理种群，它们与其他个体进行局部交互，没有任何中央控制。因此，产生了集体行为，进化依赖于个体之间的合作和竞争，通过不同的时代（代）。每个粒子根据运动函数在参数空间中定义轨迹，该函数受速度、惯性、认知系数和社会系数的影响。目标是通过对上述元素进行随机加权来找到全局最佳解。该过程是迭代的，直到满足停止标准。"'
- en: More intuitive analogies for Particle Swarm Optimization are birds and how they
    behave collaboratively, or a swarm of bees and how they determine which flowers
    to visit or which humans to attack! If you've ever watched a flock of birds flying
    or inadvertently knocked down a bee's nest then you know exactly what I am referring
    to.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子群优化的更直观类比是鸟类如何协同合作，或者蜜蜂群如何决定访问哪些花朵或攻击哪些人类！如果你曾经观察过一群鸟飞翔或者无意中撞倒了一个蜂巢，那么你就知道我指的是什么了。
- en: Now, instead of dealing in just theory, let's take a hypothetical journey, a
    Treasure Hunt. I am intentionally going to make this as verbose as possible to
    ensure the analogy fits the problem space. It goes something like this.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们不再只处理理论，而是进行一次假设的旅行，一次寻宝活动。我将故意使它尽可能详细，以确保类比适合问题空间。它大致是这样的。
- en: You and several of your friends are in a mountainous region trying to find a
    hidden treasure worth a lot of money. We are not quite sure where the treasure
    is located, but we do know that it is in the deepest valley in the region. This
    equates to the minimum elevation in terms of height above sea level.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你和你的几个朋友在一个多山地区试图找到价值连城的隐藏宝藏。我们并不确定宝藏在哪里，但我们知道它在地区的最深处山谷中。这在海拔高度方面等同于最低点。
- en: 'Let us also state that all our friends can communicate with one another using
    their cell phones (let''s assume we have cell service here!). Let''s also assume
    for now that our cell phones have GPS apps on them that tell us the elevation
    we are currently at. We will search each day for the treasure until we find it,
    and at the end of each day we will have either found the treasure and are rich,
    or we need to update our information and try again the next day. So, here''s what
    each person has:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再声明一下，我们所有的朋友都可以使用他们的手机相互通信（让我们假设我们这里有手机信号！）。现在也假设我们的手机上装有GPS应用，告诉我们我们当前所在的高度。我们将每天寻找宝藏，直到找到它，并在每天结束时，我们要么找到了宝藏并且变得富有，要么我们需要更新我们的信息并在第二天再次尝试。所以，每个人都有：
- en: A cell phone with a GPS app to determine elevation.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一部带有GPS应用的手机来确定高度。
- en: Pen and paper to track our information at the end of each day. On this we will
    write the best position we have found (individually), which is our personal best,
    or **PBEST**. We will also write on this paper the best position that the entire
    team has found thus far, being our global best value or **GBEST**.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用笔和纸在每天结束时跟踪我们的信息。在这张纸上，我们将写下我们找到的最佳位置（个人最佳），这是我们个人的最佳，或称为**PBEST**。我们还将写下迄今为止整个团队找到的最佳位置，这是我们全局最佳值或**GBEST**。
- en: 'The following are the rules that we need to follow in our search:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们搜索中需要遵循的规则：
- en: Each person will start in a random location and in a random direction. We determine
    our elevation right away and write it on our paper. It would be best for us if
    each person was spread out as much as possible so that we can be efficient and
    cover more ground, but this is not necessary.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个人将从随机位置和随机方向开始。我们立即确定我们的高度并将它写在我们的纸上。如果每个人尽可能分散，对我们来说会更好，这样我们可以更有效率地覆盖更多地面，但这不是必需的。
- en: Our journey will take *T* number of days, to which at this point we are now
    aware of what that value is or will be.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的旅程将持续*T*天，到目前为止，我们已经知道这个值是什么或将会是什么。
- en: Every morning we will plan our day.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每天早上，我们将计划我们的日程。
- en: Communications can only take place at the end of each day.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信只能在每天结束时进行。
- en: Each morning, everyone compares the elevations they are at and updates **GBEST**
    on their paper.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每天早上，每个人比较他们所在的高度，并在他们的纸上更新**GBEST**。
- en: '**GBEST** is the only piece of information each person can share (location
    and elevation).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GBEST**是每个人可以分享的唯一信息（位置和高度）。'
- en: Each person will update **PBEST** on their paper if they find a better position.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个人如果找到更好的位置，都会更新他们论文上的**PBEST**。
- en: '**PBEST** information is not shared; no one cares about anything but GBEST.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PBEST**信息不共享；没有人关心除了**GBEST**之外的其他任何事情。'
- en: Take notes of this one; to move each day, each person takes (for instance) *x* steps
    in the direction of the last day, *y* steps in the direction towards **PBEST**,
    and *z* steps in the direction of **GBEST**. Confused?
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住这一点；为了每天移动，每个人（例如）在昨天的方向上走*x*步，向**PBEST**的方向走*y*步，以及向**GBEST**的方向走*z*步。困惑了吗？
- en: Steps are random as we need some form of randomness in the search to make a
    stochastic search pattern for everyone as a collective group (that is, a flock
    or swarm of people).
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '步骤是随机的，因为我们需要在搜索中引入某种形式的随机性，以便为每个人作为一个集体群体（即一群人或一群人）形成一个随机搜索模式。 '
- en: With these few rules behind us, we can start our journey to the treasure. The
    team as a collective will keep locating different regions while watching the GBEST
    location found thus far. There is no guarantee of course that we will find the
    treasure, or that we will find it in the minimal number of days, but generally
    our search should be effective. Remember, no individual knows the exact location
    of the treasure, but cooperates with the swarm to develop collective intelligence
    to help find the treasure faster. For sure, it's better than a completely random
    search!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握这些规则之后，我们可以开始我们的寻宝之旅。作为一个集体，团队将不断定位不同的区域，同时观察迄今为止找到的**GBEST**位置。当然，我们无法保证找到宝藏，或者以最少的日期找到它，但一般来说，我们的搜索应该是有效的。记住，没有个人知道宝藏的确切位置，但他们与群体合作，发展集体智慧，以帮助更快地找到宝藏。当然，这比完全随机的搜索要好得多！
- en: 'Let''s try and plot out our steps in pseudo-pseudo-code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用伪代码绘制我们的步骤：
- en: Initialize a population of random solutions. For x number of decision variables,
    we have an x-space in which our solution exists as particles. Each particle has
    n variables and stores the best fitness for itself and the team.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一组随机解。对于x个决策变量，我们有一个x维空间，我们的解作为粒子存在于其中。每个粒子有n个变量，并存储自身和团队的最佳适应度。
- en: For each iteration (either a number or a fitness value), calculate the fitness
    and store the best fitness variable (**PBEST**) and communicate this to the swarm.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个迭代（无论是数字还是适应度值），计算适应度并存储最佳适应度变量（**PBEST**），并将其传达给群体。
- en: Identify **GBEST** by comparing all the information we have received from the
    collective swarm.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过比较我们从集体群体中收到的所有信息来识别**GBEST**。
- en: Identify what will take us in the direction of **GBEST** considering our **PBEST**
    and **GBEST**.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定在考虑我们的**PBEST**和**GBEST**的情况下，将我们引向**GBEST**方向的因素。
- en: Move in a specific time step in the direction of our velocity vector.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在特定的时间步长内向速度向量的方向移动。
- en: Over time, each team member (our particles in the swarm) will identify better
    **GBEST** variables and navigate towards them, thus also improving their **PBEST**
    at the same time.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着时间的推移，每个团队成员（群体中的粒子）将识别更好的**GBEST**变量，并朝着它们导航，从而同时提高他们的**PBEST**。
- en: 'With Particle Swarm Optimization we have three basic components that we should
    briefly discuss. They are, in no particular order:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在粒子群优化中，我们有三个基本组件，我们应该简要讨论。它们没有特定的顺序：
- en: '**Position**: Similar to the location in the preceding analogy, referring to
    the parameter values. This refers to where a particle (bird, bee, fish, and so
    on) is in an x-dimensional search space.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置**：类似于前一个类比中的位置，指的是参数值。这指的是粒子（鸟、蜜蜂、鱼等）在x维搜索空间中的位置。'
- en: '**Velocity**: Similar to the movement direction in the preceding analogy, it
    is used for storing velocity, which will update each particle''s position.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：类似于前一个类比中的移动方向，用于存储速度，这将更新每个粒子的位置。'
- en: '**Fitness**: Similar to the elevation in the preceding analogy, this shows
    how fit the particle is.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适应度**：类似于前一个类比中的海拔，这显示了粒子的适应度。'
- en: 'Velocity is the main part of our Particle Swarm Optimization. It considers
    the current position of the particle, the best position found by the swarm (**GBEST**)
    (all particles), and the best position of the current particle (**PBEST**). Mathematically,
    it breaks down like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 速度是我们粒子群优化算法的主要部分。它考虑了粒子的当前位置、群体找到的最佳位置（**GBEST**）（所有粒子）以及当前粒子的最佳位置（**PBEST**）。从数学上讲，它可以分解如下：
- en: '![](img/c772b9c1-f58f-405b-a68a-af3d00dcf41c.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c772b9c1-f58f-405b-a68a-af3d00dcf41c.png)'
- en: '![](img/dfda3de2-bfd5-4853-8746-103f27d6c048.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dfda3de2-bfd5-4853-8746-103f27d6c048.png)'
- en: There are also three hyperparameters that we should mention as you will be hearing
    about them a lot.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 还有三个超参数我们应该提及，因为你将经常听到它们。
- en: '**Inertia Weight** (**W**): The inertia weight controls the impact of the previous
    historical velocities on the current velocity. It regulates the trade-off between
    the global and local exploration abilities. If the inertia is high, particles
    are constrained in changing their direction and thus turn around much slower.
    This implies a larger exploration area and less possibility of convergence towards
    the optimum.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**惯性权重**（**W**）：惯性权重控制先前历史速度对当前速度的影响。它调节全局和局部探索能力之间的权衡。如果惯性高，粒子在改变方向时受到限制，因此转弯速度较慢。这意味着更大的探索区域和更少的可能性收敛到最优解。'
- en: If inertia is small, then only a small amount of momentum is present from the
    previous time-step; this allows for much faster changes in direction. The problem
    here is that it could take quite a bit longer to converge.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果惯性小，则从上一个时间步中只有少量动量存在；这允许方向发生更快的变化。这里的问题是，它可能需要相当长的时间才能收敛。
- en: By decreasing the inertia weight, it is easier to obtain a better global search
    ability and make the particles enter the optimal value area earlier. This means
    it will then be easier to have a better search ability and optimum value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过降低惯性权重，更容易获得更好的全局搜索能力，并使粒子更早地进入最佳值区域。这意味着它将更容易拥有更好的搜索能力和最佳值。
- en: '**C1**: **Cognitive intelligence**'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C1**: **认知智能**'
- en: '***C2***: **Social intelligence**'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***C2***: **社会智能**'
- en: It should be noted that C1 and C2 are positive constants that control how far
    an individual particle can move within a single iteration. Lower values will allow
    particles to stray further from the targeted regions before being reined in. Higher
    values will result in shorter, more abrupt movements toward, or past, the targeted
    region. By default, we will set both values to 2.0.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，C1和C2是控制单个粒子在单次迭代中可以移动多远的正常数。较低的值将允许粒子在重新控制之前远离目标区域。较高的值将导致向目标区域或超过目标区域的更短、更突然的运动。默认情况下，我们将这两个值都设置为2.0。
- en: You should experiment with the cognitive intelligence and social intelligence
    values, as sometimes different values lead to improved performance.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该尝试实验认知智能和社会智能的值，因为有时不同的值会导致性能提升。
- en: Original Particle Swarm Optimization strategy
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始粒子群优化策略
- en: As the particles (bees, birds, fish, termites) are moving along in the pre-designated
    search space to determine the best position, during each iteration of the cycle
    (where a *cycle* may be referred to as *max iterations*), each particle updates
    its velocity and position. Once the new velocity has been determined, it is used
    to compute the new particle position for the next time step.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 随着粒子（蜜蜂、鸟类、鱼类、白蚁）在预先指定的搜索空间中移动以确定最佳位置，在循环的每次迭代中（其中“循环”可能被称为“最大迭代次数”），每个粒子都会更新其速度和位置。一旦确定了新的速度，它就会用于计算下一个时间步的粒子新位置。
- en: Particle Swarm Optimization search strategy
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子群优化搜索策略
- en: For every particle over time, we will track the inertia (current velocity),
    the personal best (referred to as PBEST) and the global best (referred to as **GBEST**).
    As we mentioned, as we move through time to our global minimum, we will be tracking
    our personal best location, as well as the global best location of the swarm.
    This information will be communicated to the rest of the group so that the swarms'
    best location information can be communicated back to the group after each iteration
    is completed. We need to be either following the swarm or leading it in order
    to achieve our goals.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个粒子随时间的变化，我们将跟踪惯性（当前速度）、个人最佳（称为PBEST）和全局最佳（称为**GBEST**）。正如我们提到的，随着我们通过时间移动到全局最小值，我们将跟踪个人最佳位置以及群体的全局最佳位置。这些信息将被传达给其他成员，以便在每次迭代完成后将群体的最佳位置信息传达回群体。我们需要要么跟随群体，要么领导群体，才能实现我们的目标。
- en: Particle Swarm Optimization search strategy pseudo-code
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子群优化搜索策略伪代码
- en: 'The following is pseudo-code for the logic we will be using to find our global
    minimum (the location of the treasure):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将使用的伪代码逻辑，用于找到我们的全局最小值（宝藏的位置）：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Parameter effects on optimization
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数对优化的影响
- en: There are many varying theories for what each variable in Particle Swarm Optimization
    should look like. There are the theoretically acceptable values, and then there
    are the values determined over time with testing. The following are some of the
    recommendations I am making for your consideration.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于粒子群优化中的每个变量应该是什么样子，有许多不同的理论。有理论上的可接受值，然后有时间测试确定的值。以下是我为你提供的建议中的一些。
- en: The original (canonical) version of the Particle Swarm Optimization algorithm
    used values of 1, 2, and 2 respectively for Inertia, C1, and C2\. These values
    do seem to work quite well. I have also found through testing, as have others,
    that values of 0.5, 1.5, and 1.5 respectively work even better, providing the
    best convergence rate depending upon the function and strategy used. Other values
    lead to slower or complete non-convergence. You, the reader, should perform your
    own testing based upon the strategy and function you prefer and determine which
    values you find suitable for your purpose.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子群优化算法的原始（规范）版本分别使用惯性、C1和C2的值为1、2和2。这些值似乎工作得相当好。我也通过测试发现，其他人也有同样的发现，即使用0.5、1.5和1.5的值效果甚至更好，这取决于所使用的函数和策略，提供了最佳收敛速度。其他值会导致收敛速度变慢或完全无法收敛。您，作为读者，应该根据您喜欢的策略和函数进行自己的测试，并确定哪些值适合您的目的。
- en: Please note that, depending upon the strategy and function you select, your
    values should be different to provide proper convergence. For instance, using
    a minimization strategy and a Step function, I have seen optimal convergence happen
    using a global value of 0.729 for inertia. The cognitive intelligence (C1) is
    usually the same as the social intelligence (C2) with a pre-determined value of
    2\. I should point out however that, as you will see when we get to the chapter
    on building and using the visual workbench, the default value I use for C1 and
    C2 is 1.49445.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，根据您选择的策略和函数，您的值应该不同，以提供适当的收敛。例如，使用最小化策略和步进函数，我观察到使用全局惯性值为0.729时可以实现最佳收敛。认知智能（C1）通常与社交智能（C2）相同，预定的值为2。然而，我应该指出的是，当我们到达构建和使用可视化工作台章节时，我用于C1和C2的默认值是1.49445。
- en: It is important to note that any of the values shown here are not pulled out
    of thin air. They come from a tremendous amount of optimization testing. In addition,
    they closely align with those tested by Clerc and Kennedy (2002) for implementation
    of constriction coefficients. Please feel free to use your own values and always
    keep in mind the No Free Lunch theorem.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这里显示的任何值都不是凭空想出来的。它们来自大量的优化测试。此外，它们与Clerc和Kennedy（2002）为实施收缩系数所测试的值非常接近。请随意使用您自己的值，并始终牢记无免费午餐定理。
- en: 'The following is an example of how swarm optimization is affected by weight,
    social, and cognitive parameters:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，说明群优化如何受到权重、社会和认知参数的影响：
- en: '| ![](img/8bebba5d-9b6d-4822-92af-efba3568a005.png) | ![](img/13400d88-1349-4592-9c6e-ca3224db16a7.png)
    | ![](img/ff8e8709-92ba-416b-a9d6-cbe78668ffff.png) |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/8bebba5d-9b6d-4822-92af-efba3568a005.png) | ![](img/13400d88-1349-4592-9c6e-ca3224db16a7.png)
    | ![](img/ff8e8709-92ba-416b-a9d6-cbe78668ffff.png) |'
- en: '| Iteration=31,w=0,c1=c2=2  | Iteration=31,w=0.59,c1=c2=2 | Iteration=31,w=1,c1=c2=2
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 迭代=31，w=0，c1=c2=2  | 迭代=31，w=0.59，c1=c2=2 | 迭代=31，w=1，c1=c2=2 |'
- en: Replacing back propagation with Particle Swarm Optimization
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用粒子群优化算法替换反向传播
- en: 'And now we come to the moment of truth. How does any of this apply to my code?
    In order to answer this question, we are going to use the open source Encog machine
    learning framework for our next demonstration. You can download our sample project
    following the instructions for the web location of the files for the book. Please
    make sure you have it loaded and open in Visual Studio before proceeding:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了真相的时刻。这一切如何应用到我的代码中呢？为了回答这个问题，我们将使用开源的Encog机器学习框架进行我们的下一个演示。您可以按照书籍中文件的网络位置说明下载我们的示例项目。请确保在继续之前，您已经在Visual
    Studio中加载并打开它：
- en: '![](img/0ad5422d-0e11-4afb-b539-ff935d1bec5b.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ad5422d-0e11-4afb-b539-ff935d1bec5b.png)'
- en: We are going to create a sample application that will demonstrate replacing
    back propagation with Particle Swarm Optimization. If all goes well, from the
    outside looking in you will not notice a difference.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个示例应用程序，演示如何用粒子群优化算法替换反向传播。如果一切顺利，从外部看进来，你不会注意到任何区别。
- en: 'You will be able to run this sample out of the box and follow along. We will
    be using the XOR problem solver, but instead of using back propagation it will
    be using the Particle Swarm Optimization we''ve been discussing. Let''s dig a
    little deeper into the code. The following is the data that we will be using to
    implement this example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您将能够直接运行此示例并跟随。我们将使用XOR问题求解器，但将使用我们一直在讨论的粒子群优化，而不是反向传播。让我们更深入地看看代码。以下是我们将用于实现此示例的数据：
- en: '[PRE1]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Pretty straightforward.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 非常直接。
- en: 'Now let''s look at the sample application itself. The following is how the
    XORPSO implementation is done:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看这个示例应用本身。以下是如何实现 XORPSO 的：
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When we run this sample application here is what it looks like. You will notice
    that it appears exactly like the normal XOR sample from the outside looking in:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这里运行这个示例应用时，看起来是这样的。你会注意到，从外部看，它看起来与正常的 XOR 示例完全一样：
- en: '![](img/584424e8-4d92-497d-a14d-de57a029955e.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/584424e8-4d92-497d-a14d-de57a029955e.png)'
- en: You will notice that, when training is completed, we are very close to our ideal
    scores.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，当训练完成时，我们非常接近我们的理想分数。
- en: Now let's talk about the internals. Let's look at some of the internal variables
    used to make this work. The following is where you will see why we spent time
    early on with our basic theory. It should all be familiar to you now.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈内部结构。让我们看看一些用于使这起作用的内部变量。以下是你将看到我们为什么在早期花费时间在基本理论上的地方。现在所有这些都应该对你很熟悉。
- en: 'Declare the variable `m_populationSize`. A typical range is 20 - 40 for many
    problems. More difficult problems may need a much higher value. It must be low
    enough to keep the training process computationally efficient:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 声明变量 `m_populationSize`。对于许多问题，一个典型的范围是 20 - 40。更困难的问题可能需要一个更高的值。它必须足够低，以保持训练过程计算效率：
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This determines the size of the search space. The positional components of
    particle will be bounded to [-maxPos, maxPos]. A well chosen range can improve
    the performance. `-1` is a special value that represents boundless search space:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这决定了搜索空间的大小。粒子的位置分量将被限制在 [-maxPos, maxPos] 范围内。一个恰当选择的范围可以提高性能。`-1` 是一个特殊值，表示无界搜索空间：
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This maximum change one particle can take during one iteration imposes a limit
    on the maximum absolute value of the velocity components of a particle, and affects
    the granularity of the search. If too high, particles can fly past the optimum
    solution. If too low, particles can get stuck in local minima. It is usually set
    to a fraction of the dynamic range of the search space (10% was shown to be good
    for high dimensional problems). -1 is a special value that represents boundless
    velocities:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个粒子在一次迭代中可以接受的最大变化量限制了粒子速度分量的最大绝对值，并影响了搜索的粒度。如果太高，粒子可能会飞过最佳解。如果太低，粒子可能会陷入局部最小值。它通常设置为搜索空间动态范围的一小部分（10%
    已被证明对于高维问题来说很好）。`-1` 是一个特殊值，表示无界速度：
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For c1, cognitive learning rate >= 0 (the tendency to return to the personal
    best position):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 c1，认知学习率 >= 0（返回到个人最佳位置的趋势）：
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For c2, social learning rate >= 0 (tendency to move towards the swarm best
    position):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 c2，社会学习率 >= 0（趋向于移动到群体最佳位置）：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Inertia weight, w, controls global (higher-value) versus local exploration
    of the search space. It is analogous to temperature in simulated annealing and
    must be chosen carefully or gradually decreased over time. The value is usually
    between 0 and 1:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 惯性权重，w，控制全局（高值）与局部搜索空间的探索。它与模拟退火中的温度类似，必须仔细选择或随时间逐渐减少。值通常在 0 和 1 之间：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'All these variables should be familiar to you. Next, the heart of what we are
    doing involves the `UpdateParticle` function, shown as follows. This function
    is responsible for updating the velocity, position, and personal best position
    of a particle:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些变量都应该对你很熟悉。接下来，我们正在做的事情的核心涉及到 `UpdateParticle` 函数，如下所示。这个函数负责更新粒子的速度、位置和个人最佳位置：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a new particle with random values (except the first particle, which
    has the same value as the network passed to the algorithm):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的粒子，使用随机值（除了第一个粒子，它的值与传递给算法的网络相同）：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Randomize the velocity:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 随机化速度：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Velocity clamping:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 速度钳位：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'New position ![](img/f955e8d5-b0d4-4511-b36a-a2f15a21981e.png):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 新位置 ![图片](img/f955e8d5-b0d4-4511-b36a-a2f15a21981e.png)：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Pin the particle against the boundary of the search space (only for components
    exceeding `maxPosition`):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将粒子固定在搜索空间的边界上（仅对超过 `maxPosition` 的分量）：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Each particle will need to have its velocity updated, as you can see in the
    preceding code. This function will use the inertia weight, cognitive, and social
    terms to compute the velocity of the particle. This function encompasses the standard
    Particle Swarm Optimization formula as we described in the pseudo-code earlier
    in this chapter:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 每个粒子都需要更新其速度，正如你可以在前面的代码中看到的那样。这个函数将使用惯性权重、认知和社会项来计算粒子的速度。这个函数包含了我们在本章前面伪代码中描述的标准粒子群优化公式：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Standard PSO formula for inertia weight:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 惯性权重的标准 PSO 公式：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Standard PSO formula for cognitive term:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 标准PSO公式用于认知术语：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Standard PSO formula for social term:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 标准PSO公式用于社会术语：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: And this is how we substituted Particle Swarm Optimization for the standard
    backward propagation. Simple, right?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将粒子群优化替换为标准反向传播的方式。简单，对吧？
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter we learned some basic theory behind Particle Swarm Optimization.
    We learned how this algorithm applies to, and has been influenced by flocks of
    birds, swarms of bees, schools of fish, and more. We also saw how we could replace
    the standard back propagation formula with Particle Swarm Optimization.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了一些粒子群优化背后的基本理论。我们了解了该算法如何应用于，以及受到鸟群、蜜蜂群、鱼群等的影响。我们还看到了如何用粒子群优化来替换标准的反向传播公式。
- en: In the next chapter, we are going to learn how to delve into function optimization
    and show you how you can find optimal parameters, a process that will save you
    countless hours of testing!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何深入函数优化，并展示你如何找到最优参数，这个过程将为你节省无数小时的测试时间！
