["```py\nInitialize our hyperparameters\nInitialize the population of particles\nDo\nFor each particle\nCalculate the objective\nUpdate PBEST Update GBEST End for\nUpdate Inertia weight\nFor each particle\nUpdate Velocity (V)\nUpdate Position (X)\nEnd for\nWhile the end condition is not satisfied\nReturn GBEST as the best global optimum estimation\n```", "```py\n/// Input for the XOR function.\npublic static double[][] XORInput = {new[] {0.0, 0.0},new[] {1.0, 0.0},new[] {0.0, 1.0},new[] {1.0, 1.0}};\n/// Ideal output for the XOR function.\npublic static double[][] XORIdeal = {new[] {0.0},new[] {1.0},new[] {1.0},new[] {0.0}};\n```", "```py\n///Create a basic training data set using the supplied data shown above\nIMLDataSet trainingSet = new BasicMLDataSet(XORInput, XORIdeal);\n///Create a simple feed forward network\nBasicNetworknetwork = EncogUtility.SimpleFeedForward(2, 2, 0, 1, false);\n///Create a scoring/fitness object\nICalculateScore score = new TrainingSetScore(trainingSet);\n///Create a network weight initializer\nIRandomizer randomizer = new NguyenWidrowRandomizer();\n///Create the NN PSO trainer. This is our replacement function from back prop\nIMLTrain train = new NeuralPSO(network, randomizer, score, 20);\n///Train the application until it reaches an error rate of 0.01\nEncogUtility.TrainToError(train, 0.01);\nnetwork = (BasicNetwork)train.Method;\n///Print out the results\nEncogUtility.Evaluate(network, trainingSet);\n```", "```py\nprotected int m_populationSize = 30;\n```", "```py\nprotected double m_maxPosition = -1;\n```", "```py\nprotected double m_maxVelocity = 2;\n```", "```py\nprotected double m_c1 = 2.0;\n```", "```py\nprotected double m_c2 = 2.0;\n```", "```py\nprotected double m_inertiaWeight = 0.4;\n```", "```py\npublic void UpdateParticle(int particleIndex, bool init)\n{\nint i = particleIndex;\ndouble[] particlePosition = null;\nif (init)\n{\n```", "```py\nif (m_networks[i] == null)\n{\nm_networks[i] = (BasicNetwork)m_bestNetwork.Clone();\nif (i > 0) m_randomizer.Randomize(m_networks[i]);\n}\nparticlePosition = GetNetworkState(i);\nm_bestVectors[i] = particlePosition;\n```", "```py\nm_va.Randomise(m_velocities[i], m_maxVelocity);\n}\nelse\n{\nparticlePosition = GetNetworkState(i);\nUpdateVelocity(i, particlePosition);\n```", "```py\nm_va.ClampComponents(m_velocities[i], m_maxVelocity);\n```", "```py\nm_va.Add(particlePosition, m_velocities[i]);\n```", "```py\nm_va.ClampComponents(particlePosition, m_maxPosition);\nSetNetworkState(i, particlePosition);\n}\nUpdatePersonalBestPosition(i, particlePosition);\n}\n```", "```py\nprotected void UpdateVelocity(int particleIndex, double[] particlePosition)\n{\nint i = particleIndex;\ndouble[] vtmp = new double[particlePosition.Length];\n```", "```py\nm_va.Mul(m_velocities[i], m_inertiaWeight);\n```", "```py\nm_va.Copy(vtmp, m_bestVectors[i])\nm_va.Sub(vtmp, particlePosition);\nm_va.MulRand(vtmp, m_c1);\nm_va.Add(m_velocities[i], vtmp);\n```", "```py\nif (i != m_bestVectorIndex)\n{\nm_va.Copy(vtmp, m_pseudoAsynchronousUpdate ? m_bestVectors[m_bestVectorIndex] : m_bestVector);\nm_va.Sub(vtmp, particlePosition);\nm_va.MulRand(vtmp, m_c2);\nm_va.Add(m_velocities[i], vtmp);\n}\n}\n```"]