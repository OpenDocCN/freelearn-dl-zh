<html><head></head><body>
  <div id="_idContainer119">
   <h1 class="chapter-number" id="_idParaDest-144">
    <a id="_idTextAnchor143">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     11
    </span>
   </h1>
   <h1 id="_idParaDest-145">
    <a id="_idTextAnchor144">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Integrating spaCy with Third-Party Libraries
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     In this chapter, we’ll explore how to integrate spaCy with third-party libraries, focusing on building web applications and APIs for NLP tasks.
    </span>
    <span class="koboSpan" id="kobo.3.2">
     We will start with
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.4.1">
      Streamlit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.5.1">
     , a Python framework that simplifies the creation of web applications without needing extensive front-end knowledge.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     We’ll demonstrate how to create a simple
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.6.1">
      Named Entity Recognition
     </span>
    </strong>
    <span class="koboSpan" id="kobo.7.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.8.1">
      NER
     </span>
    </strong>
    <span class="koboSpan" id="kobo.9.1">
     ) app using Streamlit and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.10.1">
      spacy-streamlit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.11.1">
     .
    </span>
    <span class="koboSpan" id="kobo.11.2">
     Following this, we’ll dive into
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.12.1">
      FastAPI
     </span>
    </strong>
    <span class="koboSpan" id="kobo.13.1">
     , a modern framework for building APIs, known for its speed and use of Python type hints.
    </span>
    <span class="koboSpan" id="kobo.13.2">
     We’ll learn how to create an API that extracts entities from text using a spaCy model, showcasing the ease with which you can build
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.14.1">
      NLP-powered services.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.15.1">
     In this chapter, we’re going to cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.16.1">
      main topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.17.1">
      Building spaCy-powered Apps
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.18.1">
       with Streamlit
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.19.1">
      Building APIs for NLP models
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.20.1">
       using FastAPI
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-146">
    <a id="_idTextAnchor145">
    </a>
    <span class="koboSpan" id="kobo.21.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.22.1">
     All the data and the code for this Chapter can be found
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.23.1">
      at
     </span>
    </span>
    <a href="https://github.com/PacktPublishing/Mastering-spaCy-Second-Edition">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.24.1">
       https://github.com/PacktPublishing/Mastering-spaCy-Second-Edition
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.25.1">
      .
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-147">
    <a id="_idTextAnchor146">
    </a>
    <span class="koboSpan" id="kobo.26.1">
     Building spaCy-powered Apps with Streamlit
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.27.1">
     As data scientists
    </span>
    <a id="_idIndexMarker509">
    </a>
    <span class="koboSpan" id="kobo.28.1">
     and NLP engineers, the
    </span>
    <a id="_idIndexMarker510">
    </a>
    <span class="koboSpan" id="kobo.29.1">
     main programming language we use in our day-to-day is Python.
    </span>
    <span class="koboSpan" id="kobo.29.2">
     If you don’t have a background in front-end development and have ever tried to build a web application or had to deal with CSS, you know how hard and frustrating it can be to work developing applications to work in the browser.
    </span>
    <span class="koboSpan" id="kobo.29.3">
     Streamlit is a framework in Python designed to help us create web applications in a simple and fast way using pure Python.
    </span>
    <span class="koboSpan" id="kobo.29.4">
     It is built on top of the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.30.1">
      Tornado
     </span>
    </strong>
    <span class="koboSpan" id="kobo.31.1">
     Python
    </span>
    <a id="_idIndexMarker511">
    </a>
    <span class="koboSpan" id="kobo.32.1">
     web server framework (
    </span>
    <a href="https://www.tornadoweb.org/en/stable/index.html">
     <span class="koboSpan" id="kobo.33.1">
      https://www.tornadoweb.org/en/stable/index.html
     </span>
    </a>
    <span class="koboSpan" id="kobo.34.1">
     ) and uses
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.35.1">
      React
     </span>
    </strong>
    <span class="koboSpan" id="kobo.36.1">
     in the
    </span>
    <a id="_idIndexMarker512">
    </a>
    <span class="koboSpan" id="kobo.37.1">
     frontend.
    </span>
    <span class="koboSpan" id="kobo.37.2">
     Luckily, we don’t need to know how to use any of these technologies to create our web apps, since with Streamlit, we can create widgets on the page by simply declaring some Python variables.
    </span>
    <span class="koboSpan" id="kobo.37.3">
     We can also smoothly deploy, manage, and share Streamlit Web Apps
    </span>
    <a id="_idIndexMarker513">
    </a>
    <span class="koboSpan" id="kobo.38.1">
     by using the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.39.1">
      community cloud
     </span>
    </em>
    <span class="koboSpan" id="kobo.40.1">
     feature (
    </span>
    <a href="https://streamlit.io/cloud">
     <span class="koboSpan" id="kobo.41.1">
      https://streamlit.io/cloud
     </span>
    </a>
    <span class="koboSpan" id="kobo.42.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.42.2">
     The deployment can be done in one click and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.43.1">
      is free.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.44.1">
     In this section, we will first learn
    </span>
    <a id="_idIndexMarker514">
    </a>
    <span class="koboSpan" id="kobo.45.1">
     the
    </span>
    <a id="_idIndexMarker515">
    </a>
    <span class="koboSpan" id="kobo.46.1">
     basics of Streamlit and then how to use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.47.1">
      spacy-streamlit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.48.1">
     package to use spaCy visualizations as the building blocks of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.49.1">
      web apps.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-148">
    <a id="_idTextAnchor147">
    </a>
    <span class="koboSpan" id="kobo.50.1">
     Building NLP apps with spacy-streamlit
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.51.1">
     To start using Streamlit
    </span>
    <a id="_idIndexMarker516">
    </a>
    <span class="koboSpan" id="kobo.52.1">
     the
    </span>
    <a id="_idIndexMarker517">
    </a>
    <span class="koboSpan" id="kobo.53.1">
     first step is to install the library using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.54.1">
      pip install streamlit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.55.1">
     .
    </span>
    <span class="koboSpan" id="kobo.55.2">
     We create the web applications using a Python script.
    </span>
    <span class="koboSpan" id="kobo.55.3">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.56.1">
      streamlit run app.py
     </span>
    </strong>
    <span class="koboSpan" id="kobo.57.1">
     command runs a local server on the machine.
    </span>
    <span class="koboSpan" id="kobo.57.2">
     To check whether everything is okay with the installation, let’s run the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.58.1">
      streamlit hello
     </span>
    </strong>
    <span class="koboSpan" id="kobo.59.1">
     command.
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.60.1">
       Figure 11
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.61.1">
      .1
     </span>
    </em>
    <span class="koboSpan" id="kobo.62.1">
     shows this demo page in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.63.1">
      the browser.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer111">
     <span class="koboSpan" id="kobo.64.1">
      <img alt="Figure 11.1 – Streamlit hello page" src="image/B22441_11_01.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.65.1">
     Figure 11.1 – Streamlit hello page
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.66.1">
     As we were talking about in the introduction section, creating widgets and visual components with Streamlit can be done by simply declaring a variable.
    </span>
    <span class="koboSpan" id="kobo.66.2">
     We can also add interactivity to the apps using Streamlit input widgets.
    </span>
    <span class="koboSpan" id="kobo.66.3">
     The main ones are
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.67.1">
      st.text_input
     </span>
    </strong>
    <span class="koboSpan" id="kobo.68.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.69.1">
      st.button
     </span>
    </strong>
    <span class="koboSpan" id="kobo.70.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.71.1">
      st.slider
     </span>
    </strong>
    <span class="koboSpan" id="kobo.72.1">
     .
    </span>
    <span class="koboSpan" id="kobo.72.2">
     The library has a large list of page elements.
    </span>
    <span class="koboSpan" id="kobo.72.3">
     Here are some of the main ones and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.73.1">
      their descriptions:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.74.1">
       st.write
      </span>
     </strong>
     <span class="koboSpan" id="kobo.75.1">
      : This writes the content on the page and automatically detects the type of the content to present it properly.
     </span>
     <span class="koboSpan" id="kobo.75.2">
      If you write
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.76.1">
       st.write('hi friends')
      </span>
     </strong>
     <span class="koboSpan" id="kobo.77.1">
      , it will display the text; if you provide a dataframe instead of a string, it will present the dataframe with the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.78.1">
       proper formatting.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.79.1">
       st.title
      </span>
     </strong>
     <span class="koboSpan" id="kobo.80.1">
      : This will display the text in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.81.1">
       title formatting.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.82.1">
       st.markdown
      </span>
     </strong>
     <span class="koboSpan" id="kobo.83.1">
      : This will display the text formatted
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.84.1">
       in Markdown.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.85.1">
       st.dataframe
      </span>
     </strong>
     <span class="koboSpan" id="kobo.86.1">
      : This will display a dataframe as an
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.87.1">
       interactive table.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.88.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.89.1">
      spacy-streamlit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.90.1">
     package provides tools for visualizing spaCy models and developing interactive apps.
    </span>
    <span class="koboSpan" id="kobo.90.2">
     It features various components that you can integrate into your own Streamlit applications, including visualizers for syntactic dependencies, named entities, text
    </span>
    <a id="_idIndexMarker518">
    </a>
    <span class="koboSpan" id="kobo.91.1">
     classification, token
    </span>
    <a id="_idIndexMarker519">
    </a>
    <span class="koboSpan" id="kobo.92.1">
     attributes, and more.
    </span>
    <span class="koboSpan" id="kobo.92.2">
     Let’s build an app to get a glimpse of how Streamlit and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.93.1">
      spacy-streamlit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.94.1">
     work together.
    </span>
    <span class="koboSpan" id="kobo.94.2">
     First, you need to install the package with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.95.1">
      pip install spacy-streamlit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.96.1">
     .
    </span>
    <span class="koboSpan" id="kobo.96.2">
     With the library installed, let’s go ahead and build an app to display the entities of the model we trained in
    </span>
    <a href="B22441_08.xhtml#_idTextAnchor109">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.97.1">
        Chapter 8
       </span>
      </em>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.98.1">
      :
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.99.1">
      First, we import both packages,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.100.1">
       Streamlit
      </span>
     </strong>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.101.1">
       and
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.102.1">
        spacy_streamlit
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.103.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.104.1">
import streamlit as st
import spacy_streamlit</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.105.1">
      Let’s define a default text to the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.106.1">
        st.text_input
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.107.1">
       component:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.108.1">
DEFAULT_TEXT = """Givenchy is looking at buying U.K. </span><span class="koboSpan" id="kobo.108.2">startup for $1 billion"""</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.109.1">
      Now we define the path to the
     </span>
     <a href="B22441_08.xhtml#_idTextAnchor109">
      <span class="No-Break">
       <em class="italic">
        <span class="koboSpan" id="kobo.110.1">
         Chapter 8
        </span>
       </em>
      </span>
     </a>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.111.1">
       final model:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.112.1">
spacy_model = "../chapter_08/pipelines/fashion_ner_with_base_entities"</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.113.1">
      Let’s add a title and the text input.
     </span>
     <span class="koboSpan" id="kobo.113.2">
      The content of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.114.1">
       text_input
      </span>
     </strong>
     <span class="koboSpan" id="kobo.115.1">
      will be saved on the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.116.1">
        text
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.117.1">
       variable:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.118.1">
st.title("NER Fashion Brands App")
text = st.text_area("Text to analyze", DEFAULT_TEXT, height=200)</span></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.119.1">
     We still have some work to do, but first, let’s see what the app looks like with only this code.
    </span>
    <span class="koboSpan" id="kobo.119.2">
     Save the code to an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.120.1">
      app.py
     </span>
    </strong>
    <span class="koboSpan" id="kobo.121.1">
     script and run
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.122.1">
      streamlit run app.py
     </span>
    </strong>
    <span class="koboSpan" id="kobo.123.1">
     to serve it on our
    </span>
    <a id="_idIndexMarker520">
    </a>
    <span class="koboSpan" id="kobo.124.1">
     local
    </span>
    <a id="_idIndexMarker521">
    </a>
    <span class="koboSpan" id="kobo.125.1">
     machine.
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.126.1">
       Figure 11
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.127.1">
      .2
     </span>
    </em>
    <span class="koboSpan" id="kobo.128.1">
     shows what we have
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.129.1">
      so far.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer112">
     <span class="koboSpan" id="kobo.130.1">
      <img alt="Figure 11.2 – The Streamlit app with the text_area component" src="image/B22441_11_02.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.131.1">
     Figure 11.2 – The Streamlit app with the text_area component
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.132.1">
     When building apps with Streamlit, every time the user interacts with an input widget, the library
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.133.1">
      reruns the entire Python script from top to bottom
     </span>
    </em>
    <span class="koboSpan" id="kobo.134.1">
     .
    </span>
    <span class="koboSpan" id="kobo.134.2">
     Our app needs to load the model before processing the text, so this could mean that every time a user types another text in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.135.1">
      st.text_area
     </span>
    </strong>
    <span class="koboSpan" id="kobo.136.1">
     widget, they would have to wait for the model to load again.
    </span>
    <span class="koboSpan" id="kobo.136.2">
     To handle this, Streamlit has the cache feature (
    </span>
    <a href="https://docs.streamlit.io/get-started/fundamentals/advanced-concepts#caching">
     <span class="koboSpan" id="kobo.137.1">
      https://docs.streamlit.io/get-started/fundamentals/advanced-concepts#caching
     </span>
    </a>
    <span class="koboSpan" id="kobo.138.1">
     ) and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.139.1">
      spacy-streamlit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.140.1">
     implements the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.141.1">
      process_text()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.142.1">
     method.
    </span>
    <span class="koboSpan" id="kobo.142.2">
     It caches loaded models and creates
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.143.1">
      Doc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.144.1">
     objects.
    </span>
    <span class="koboSpan" id="kobo.144.2">
     Let’s use the method to process the text of our app, continuing the list
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.145.1">
      we’ve started:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.146.1">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.147.1">
       process_text ()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.148.1">
      method expects the path to the model and the text that will
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.149.1">
       be processed:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.150.1">
doc = spacy_streamlit.process_text(spacy_model, text)</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.151.1">
      Finally, to display the entities, we will use the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.152.1">
        visualize_ner()
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.153.1">
       function:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.154.1">
spacy_streamlit.visualize_ner(
    doc,
    labels=["FASHION_BRAND", "GPE"],
    show_table=False,
    title="Fashion brands and locations",
)</span></pre>
    </li>
   </ol>
   <p>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.155.1">
       Figure 11
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.156.1">
      .3
     </span>
    </em>
    <span class="koboSpan" id="kobo.157.1">
     shows the
    </span>
    <a id="_idIndexMarker522">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.158.1">
      final
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker523">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.159.1">
      app.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer113">
     <span class="koboSpan" id="kobo.160.1">
      <img alt="Figure 11.3 – NER app built with Streamlit" src="image/B22441_11_03.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.161.1">
     Figure 11.3 – NER app built with Streamlit
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.162.1">
     We want to add a button so the users can type their own text and see the entities.
    </span>
    <span class="koboSpan" id="kobo.162.2">
     Since Streamlit re-runs all the script code every time we interact with a widget, we cannot use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.163.1">
      st.button
     </span>
    </strong>
    <span class="koboSpan" id="kobo.164.1">
     widget.
    </span>
    <span class="koboSpan" id="kobo.164.2">
     What we’ll do is use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.165.1">
      st.form
     </span>
    </strong>
    <span class="koboSpan" id="kobo.166.1">
     widget, which sends all widget values inside the form to Streamlit in a batch.
    </span>
    <span class="koboSpan" id="kobo.166.2">
     We will use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.167.1">
      with
     </span>
    </strong>
    <span class="koboSpan" id="kobo.168.1">
     context manager to create the form.
    </span>
    <span class="koboSpan" id="kobo.168.2">
     Let’s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.169.1">
      do it:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.170.1">
      We will put all the elements that should be reloaded inside the form context manager.
     </span>
     <span class="koboSpan" id="kobo.170.2">
      So, when the user presses the submit button, we will process the doc and display it using
     </span>
     <a id="_idIndexMarker524">
     </a>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.171.1">
       the
      </span>
     </span>
     <span class="No-Break">
      <a id="_idIndexMarker525">
      </a>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.172.1">
       visualizer:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.173.1">
with st.form("my_form"):
    text = st.text_area("Text to analyze", DEFAULT_TEXT, 
                        height=200)
    submitted = st.form_submit_button("Submit")
    if submitted:
        doc = spacy_streamlit.process_text(spacy_model, text)
        spacy_streamlit.visualize_ner(
            doc,
            labels=["FASHION_BRAND", "GPE"],
            show_table=False,
            title="Fashion brands and locations",
        )</span></pre>
    </li>
   </ol>
   <p>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.174.1">
       Figure 11
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.175.1">
      .4
     </span>
    </em>
    <span class="koboSpan" id="kobo.176.1">
     shows the app, now with the
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.177.1">
       Submit
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.178.1">
      button.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer114">
     <span class="koboSpan" id="kobo.179.1">
      <img alt="Figure 11.4 – Streamlit app with form and Submit button" src="image/B22441_11_04.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.180.1">
     Figure 11.4 – Streamlit app with form and Submit button
    </span>
   </p>
   <ol>
    <li value="2">
     <span class="koboSpan" id="kobo.181.1">
      The next list has
     </span>
     <a id="_idIndexMarker526">
     </a>
     <span class="koboSpan" id="kobo.182.1">
      the
     </span>
     <a id="_idIndexMarker527">
     </a>
     <span class="koboSpan" id="kobo.183.1">
      full code of the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.184.1">
       web app:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.185.1">
import streamlit as st
import spacy_streamlit
DEFAULT_TEXT = """Givenchy is looking at buying U.K. </span><span class="koboSpan" id="kobo.185.2">startup for $1 billion"""
spacy_model = "../chapter_08/pipelines/fashion_ner_with_base_entities"
st.title("NER Fashion Brands App")
with st.form("my_form"):
    text = st.text_area("Text to analyze", DEFAULT_TEXT, 
                        height=200)
    submitted = st.form_submit_button("Submit")
    if submitted:
        doc = spacy_streamlit.process_text(spacy_model, text)
        spacy_streamlit.visualize_ner(
            doc,
            labels=["FASHION_BRAND", "GPE"],
            show_table=False,
            title="Fashion brands and locations",
        )</span></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.186.1">
     We were able to build a beautiful NLP app with just some lines of code by using both the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.187.1">
      streamlit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.188.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.189.1">
      spacy-streamlit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.190.1">
     libraries.
    </span>
    <span class="koboSpan" id="kobo.190.2">
     Other
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.191.1">
      spacy-streamlit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.192.1">
     visualizers are
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.193.1">
      visualize_parser()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.194.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.195.1">
      visualize_spans()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.196.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.197.1">
      visualize_textcat()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.198.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.199.1">
      visualize_similarity()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.200.1">
     ,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.201.1">
      and
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.202.1">
       visualize_tokens()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.203.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.204.1">
     Sometimes, we need to build APIs for our NLP projects instead of interactive web applications.
    </span>
    <span class="koboSpan" id="kobo.204.2">
     For
    </span>
    <a id="_idIndexMarker528">
    </a>
    <span class="koboSpan" id="kobo.205.1">
     this
    </span>
    <a id="_idIndexMarker529">
    </a>
    <span class="koboSpan" id="kobo.206.1">
     scenario, we can use another cool library:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.207.1">
      FastAPI
     </span>
    </strong>
    <span class="koboSpan" id="kobo.208.1">
     .
    </span>
    <span class="koboSpan" id="kobo.208.2">
     Let’s learn more about it in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.209.1">
      next section.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-149">
    <a id="_idTextAnchor148">
    </a>
    <span class="koboSpan" id="kobo.210.1">
     Building APIs for NLP models using FastAPI
    </span>
   </h1>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.211.1">
      FastAPI
     </span>
    </strong>
    <span class="koboSpan" id="kobo.212.1">
     is a Python
    </span>
    <a id="_idIndexMarker530">
    </a>
    <span class="koboSpan" id="kobo.213.1">
     web framework for
    </span>
    <a id="_idIndexMarker531">
    </a>
    <span class="koboSpan" id="kobo.214.1">
     building APIs.
    </span>
    <span class="koboSpan" id="kobo.214.2">
     It’s built on top of another two Python libraries,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.215.1">
      Starlette
     </span>
    </strong>
    <span class="koboSpan" id="kobo.216.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.217.1">
      Pydantic
     </span>
    </strong>
    <span class="koboSpan" id="kobo.218.1">
     , making it one of the fastest Python frameworks available.
    </span>
    <span class="koboSpan" id="kobo.218.2">
     FastAPI is based on standard Python type hints.
    </span>
    <span class="koboSpan" id="kobo.218.3">
     With type hinting, we can specify the expected type of a variable, function parameter, or return value.
    </span>
    <span class="koboSpan" id="kobo.218.4">
     This feature helps us catch bugs earlier in the development process, so let’s learn how to use type hints before heading to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.219.1">
      FastAPI usage.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-150">
    <a id="_idTextAnchor149">
    </a>
    <span class="koboSpan" id="kobo.220.1">
     Python type hinting 101
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.221.1">
     Python is a dynamically
    </span>
    <a id="_idIndexMarker532">
    </a>
    <span class="koboSpan" id="kobo.222.1">
     typed language, meaning it performs the type checks of the variables at runtime.
    </span>
    <span class="koboSpan" id="kobo.222.2">
     For example, if we run this code, it does not throw
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.223.1">
      any errors:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.224.1">
string_or_int = "Hi friends"
string_or_int = 10</span></pre>
   <p>
    <span class="koboSpan" id="kobo.225.1">
     This runs smoothly because the Python interpreter handles the transition of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.226.1">
      string_or_int
     </span>
    </strong>
    <span class="koboSpan" id="kobo.227.1">
     from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.228.1">
      String
     </span>
    </strong>
    <span class="koboSpan" id="kobo.229.1">
     to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.230.1">
      int
     </span>
    </strong>
    <span class="koboSpan" id="kobo.231.1">
     .
    </span>
    <span class="koboSpan" id="kobo.231.2">
     This can lead to bugs because of silent errors.
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.232.1">
      Type hinting
     </span>
    </strong>
    <span class="koboSpan" id="kobo.233.1">
     provides a way to specify the expected types in our code, so it reduces our chances of creating bugs.
    </span>
    <span class="koboSpan" id="kobo.233.2">
     Let’s see an example of a simple function without
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.234.1">
      it first:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.235.1">
def greeting(name):
    return "Hello" + name</span></pre>
   <p>
    <span class="koboSpan" id="kobo.236.1">
     Imagine this function is in a code base and you just import it to use in your code.
    </span>
    <span class="koboSpan" id="kobo.236.2">
     There is no way to see what the writer of the function was expecting as the type of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.237.1">
      name
     </span>
    </strong>
    <span class="koboSpan" id="kobo.238.1">
     parameter and no information about the return type.
    </span>
    <span class="koboSpan" id="kobo.238.2">
     To get this information, we need to read to check the code of the function.
    </span>
    <span class="koboSpan" id="kobo.238.3">
     The situation changes if we use
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.239.1">
      type hints:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.240.1">
def greeting(name: str) -&gt; str:
    return f"Hello {name}"</span></pre>
   <p>
    <span class="koboSpan" id="kobo.241.1">
     Now with these type hints, your code editor can help you and show the types.
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.242.1">
       Figure 11
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.243.1">
      .5
     </span>
    </em>
    <span class="koboSpan" id="kobo.244.1">
     shows what happens in
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.245.1">
      Visual Studio Code
     </span>
    </em>
    <span class="koboSpan" id="kobo.246.1">
     ,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.247.1">
      for example.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer115">
     <span class="koboSpan" id="kobo.248.1">
      <img alt="Figure 11.5 – Type hinting in Visual Studio Code" src="image/B22441_11_05.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.249.1">
     Figure 11.5 – Type hinting in Visual Studio Code
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.250.1">
     FastAPI uses type hints
    </span>
    <a id="_idIndexMarker533">
    </a>
    <span class="koboSpan" id="kobo.251.1">
     to offer type checks, leading to fewer bugs and developer-induced errors.
    </span>
    <span class="koboSpan" id="kobo.251.2">
     Now that we know what type hinting is, let’s create an API for our spaCy model
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.252.1">
      using FastAPI.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-151">
    <a id="_idTextAnchor150">
    </a>
    <span class="koboSpan" id="kobo.253.1">
     Creating an API for the spaCy model with FastAPI
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.254.1">
     The two main HTTP
    </span>
    <a id="_idIndexMarker534">
    </a>
    <span class="koboSpan" id="kobo.255.1">
     methods we use to build APIs
    </span>
    <a id="_idIndexMarker535">
    </a>
    <span class="koboSpan" id="kobo.256.1">
     are
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.257.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.258.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.259.1">
      POST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.260.1">
     .
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.261.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.262.1">
     is used when the request does not change any state and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.263.1">
      POST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.264.1">
     is usually used when the action can alter the state (add an element to the dataset, edit a value, etc.).
    </span>
    <span class="koboSpan" id="kobo.264.2">
     In other words,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.265.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.266.1">
     is used to
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.267.1">
      read data
     </span>
    </em>
    <span class="koboSpan" id="kobo.268.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.269.1">
      POST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.270.1">
     is used to
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.271.1">
      create data
     </span>
    </em>
    <span class="koboSpan" id="kobo.272.1">
     .
    </span>
    <span class="koboSpan" id="kobo.272.2">
     When using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.273.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.274.1">
     requests, we pass the parameters in the URL address.
    </span>
    <span class="koboSpan" id="kobo.274.2">
     With
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.275.1">
      POST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.276.1">
     requests, we can pass the parameters in the request body.
    </span>
    <span class="koboSpan" id="kobo.276.2">
     FastAPI allows us to choose which request type we want by using the methods with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.277.1">
      @app.get()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.278.1">
     or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.279.1">
      @app.post()
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.280.1">
      Python decorators.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.281.1">
     Let’s create an API with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.282.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.283.1">
     method that returns a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.284.1">
      json
     </span>
    </strong>
    <span class="koboSpan" id="kobo.285.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.285.2">
     First, you need to install FastAPI with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.286.1">
      pip install fastapi[standard]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.287.1">
     command.
    </span>
    <span class="koboSpan" id="kobo.287.2">
     Now create a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.288.1">
      main.py
     </span>
    </strong>
    <span class="koboSpan" id="kobo.289.1">
     file with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.290.1">
      these commands:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.291.1">
      First, import the library and create the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.292.1">
        app
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.293.1">
       object:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.294.1">
from fastapi import FastAPI
app = FastAPI()</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.295.1">
      Now let’s create the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.296.1">
       GET
      </span>
     </strong>
     <span class="koboSpan" id="kobo.297.1">
      method.
     </span>
     <span class="koboSpan" id="kobo.297.2">
      We will add the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.298.1">
       @app.get("/")
      </span>
     </strong>
     <span class="koboSpan" id="kobo.299.1">
      decorator.
     </span>
     <span class="koboSpan" id="kobo.299.2">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.300.1">
       "/"
      </span>
     </strong>
     <span class="koboSpan" id="kobo.301.1">
      means
     </span>
     <a id="_idIndexMarker536">
     </a>
     <span class="koboSpan" id="kobo.302.1">
      the
     </span>
     <a id="_idIndexMarker537">
     </a>
     <span class="koboSpan" id="kobo.303.1">
      URL path to call this method will be the root of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.304.1">
       our site:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.305.1">
@app.get("/")
def root():
    return {"message": "Hello World"}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.306.1">
      To run the server locally go to the command line and type
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.307.1">
       fastapi dev
      </span>
     </strong>
     <strong class="bold">
     </strong>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.308.1">
       main.py
      </span>
     </strong>
     <span class="koboSpan" id="kobo.309.1">
      .
     </span>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.310.1">
        Figure 11
       </span>
      </em>
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.311.1">
       .6
      </span>
     </em>
     <span class="koboSpan" id="kobo.312.1">
      shows what you should see if you open your browser and go to the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.313.1">
        http://127.0.0.1:8000/
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.314.1">
       URL.
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer116">
     <span class="koboSpan" id="kobo.315.1">
      <img alt="Figure 11.6 – The response of the GET endpoint" src="image/B22441_11_06.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.316.1">
     Figure 11.6 – The response of the GET endpoint
    </span>
   </p>
   <ol>
    <li value="4">
     <span class="koboSpan" id="kobo.317.1">
      One of the nice things about FastAPI is that it creates docs for the APIs automatically.
     </span>
     <span class="koboSpan" id="kobo.317.2">
      By default, it
     </span>
     <a id="_idIndexMarker538">
     </a>
     <span class="koboSpan" id="kobo.318.1">
      uses
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.319.1">
       Swagger UI
      </span>
     </strong>
     <span class="koboSpan" id="kobo.320.1">
      (
     </span>
     <a href="https://github.com/swagger-api/swagger-ui">
      <span class="koboSpan" id="kobo.321.1">
       https://github.com/swagger-api/swagger-ui
      </span>
     </a>
     <span class="koboSpan" id="kobo.322.1">
      ).
     </span>
     <span class="koboSpan" id="kobo.322.2">
      Go to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.323.1">
       http://127.0.0.1:8000/docs
      </span>
     </strong>
     <span class="koboSpan" id="kobo.324.1">
      to check it out.
     </span>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.325.1">
        Figure 11
       </span>
      </em>
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.326.1">
       .7
      </span>
     </em>
     <span class="koboSpan" id="kobo.327.1">
      shows the documentation docs of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.328.1">
       our
      </span>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.329.1">
       FastAPI
      </span>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.330.1">
       .
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer117">
     <span class="koboSpan" id="kobo.331.1">
      <img alt="Figure 11.7 – The documentation of our API created automatically by FastAPI" src="image/B22441_11_07.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.332.1">
     Figure 11.7 – The documentation of our API created automatically by FastAPI
    </span>
   </p>
   <ol>
    <li value="5">
     <span class="koboSpan" id="kobo.333.1">
      We will create an API in the same style we’ve used to create the Streamlit web app.
     </span>
     <span class="koboSpan" id="kobo.333.2">
      The API should
     </span>
     <a id="_idIndexMarker539">
     </a>
     <span class="koboSpan" id="kobo.334.1">
      receive
     </span>
     <a id="_idIndexMarker540">
     </a>
     <span class="koboSpan" id="kobo.335.1">
      a list of texts and return a JSON response with the entities.
     </span>
     <span class="koboSpan" id="kobo.335.2">
      Here is an example of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.336.1">
       a request:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.337.1">
{
  "values": [
    {
      "record_id": "1",
      "text": "Givenchy is looking at buying U.K. </span><span class="koboSpan" id="kobo.337.2">startup for $1 billion"
    }
  ]
}</span></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.338.1">
     The response of the API for this request should be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.339.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.340.1">
{
  "values": [
    {
      "record_id": "1",
      "data": {
        "entities": [
          {
            "name": "Givenchy",
            "label": "FASHION_BRAND",
            "matches": [
              {
                "char_start": 0,
                "char_end": 8,
                "text": "Givenchy"
              }
            ]
          },
          // [...]          {
            "name": "$1 billion",
            "label": "MONEY",
            "matches": [
              {
                "char_start": 47,
                "char_end": 57,
                "text": "$1 billion"
              }
            ]
          }
        ]
      }
    }
  ]
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.341.1">
     FastAPI uses the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.342.1">
      Pydantic
     </span>
    </strong>
    <span class="koboSpan" id="kobo.343.1">
     models to
    </span>
    <a id="_idIndexMarker541">
    </a>
    <span class="koboSpan" id="kobo.344.1">
     validate the data and build the API documentation.
    </span>
    <span class="koboSpan" id="kobo.344.2">
     Let’s create some Pydantic models to specify the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.345.1">
      POST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.346.1">
     request of our API.
    </span>
    <span class="koboSpan" id="kobo.346.2">
     We do that by creating Python classes that are inherited from Pydantic’s
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.347.1">
       BaseModel
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.348.1">
      class:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.349.1">
      To extract the
     </span>
     <a id="_idIndexMarker542">
     </a>
     <span class="koboSpan" id="kobo.350.1">
      entities, the
     </span>
     <a id="_idIndexMarker543">
     </a>
     <span class="koboSpan" id="kobo.351.1">
      API will need to know the record identifier and the text, so let’s create a class
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.352.1">
       for it:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.353.1">
from pydantic import BaseModel
from typing import List
class TextToExtractEntities(BaseModel):
    record_id: str
    text: str</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.354.1">
      The API can work with a batch of texts, so the body parameter of the request can have many items.
     </span>
     <span class="koboSpan" id="kobo.354.2">
      Let’s create
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.355.1">
       this class:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.356.1">
class TextsRequest(BaseModel):
    values: List[TextToExtractEntities]</span></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.357.1">
     Now it’s time to use spaCy to extract the entities to generate the response.
    </span>
    <span class="koboSpan" id="kobo.357.2">
     We will create a class very similar to the one used in this Cookiecutter
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.358.1">
      by Microsoft:
     </span>
    </span>
   </p>
   <p>
    <a href="https://github.com/microsoft/cookiecutter-spacy-fastapi">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.359.1">
       https://github.com/microsoft/cookiecutter-spacy-fastapi
      </span>
     </span>
    </a>
   </p>
   <p>
    <span class="koboSpan" id="kobo.360.1">
     Let’s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.361.1">
      do it:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.362.1">
      We should initiate the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.363.1">
       EntityExtractor
      </span>
     </strong>
     <span class="koboSpan" id="kobo.364.1">
      class providing an
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.365.1">
       nlp
      </span>
     </strong>
     <span class="koboSpan" id="kobo.366.1">
      model and the key values for the record identifier and the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.367.1">
       record text:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.368.1">
import spacy
from spacy.language import Language
class EntityExtractor:
    def __init__(self, nlp: Language,
                 record_id_col_key: str = "record_id",
                 record_text_col_key: str = "text"):
        self.nlp = nlp
        self.record_id_col_key = record_id_col_key
        self.record_text_col_key = record_text_col_key</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.369.1">
      Now let’s create the method to extract the entities.
     </span>
     <span class="koboSpan" id="kobo.369.2">
      The method will loop through the docs
     </span>
     <a id="_idIndexMarker544">
     </a>
     <span class="koboSpan" id="kobo.370.1">
      created
     </span>
     <a id="_idIndexMarker545">
     </a>
     <span class="koboSpan" id="kobo.371.1">
      by
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.372.1">
       nlp.pipe()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.373.1">
      and create a list with the entities’ names, labels, and start and end characters for the entity in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.374.1">
       the text:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.375.1">
def extract_entities(self, records: List[Dict[str, str]]):
    ids = (item[self.record_id_col_key] for item in records)
    texts = (item[self.record_text_col_key] for item in records)
    response = []
    for doc_id, spacy_doc in zip(ids, self.nlp.pipe(texts)):
        entities = {}
        for ent in spacy_doc.ents:
            ent_name = ent.text
            if ent_name not in entities:
                entities[ent_name] = {
                    "name": ent_name,
                    "label": ent.label_,
                    "matches": [],
                }
            entities[ent_name]["matches"].append(
                {"char_start": ent.start_char, 
                 "char_end": ent.end_char,
                 "text": ent.text}
            )
        response.append({"id": doc_id, 
                         "entities": list(entities.values())})
    return response</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.376.1">
      To test whether this code
     </span>
     <a id="_idIndexMarker546">
     </a>
     <span class="koboSpan" id="kobo.377.1">
      is
     </span>
     <a id="_idIndexMarker547">
     </a>
     <span class="koboSpan" id="kobo.378.1">
      working, let’s save it to an
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.379.1">
       extractor.py
      </span>
     </strong>
     <span class="koboSpan" id="kobo.380.1">
      script and import the class
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.381.1">
       like this:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.382.1">
import spacy
from pprint import pprint
from extractor import EntityExtractor
nlp = spacy.load("../chapter_08/pipelines/fashion_ner_with_base_entities")
sentence = "Givenchy is looking at buying U.K. </span><span class="koboSpan" id="kobo.382.2">startup for $1 billion"
doc = nlp(sentence)
extractor = EntityExtractor(nlp)
entities = extractor.extract_entities([{"record_id":1,"text":sentence}])
pprint(entities)</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.383.1">
      We’re using the
     </span>
     <a id="_idIndexMarker548">
     </a>
     <span class="koboSpan" id="kobo.384.1">
      model
     </span>
     <a id="_idIndexMarker549">
     </a>
     <span class="koboSpan" id="kobo.385.1">
      trained in
     </span>
     <a href="B22441_08.xhtml#_idTextAnchor109">
      <span class="No-Break">
       <em class="italic">
        <span class="koboSpan" id="kobo.386.1">
         Chapter 8
        </span>
       </em>
      </span>
     </a>
     <span class="koboSpan" id="kobo.387.1">
      to extract the entities.
     </span>
     <span class="koboSpan" id="kobo.387.2">
      The response should this dictionary with the entity’s names, labels,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.388.1">
       and matches:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.389.1">
[{
    'entities': [
        {
            'label': 'FASHION_BRAND',
            'matches': [{
                'char_end': 8,
                'char_start': 0,
                'text': 'Givenchy'
            }],
            'name': 'Givenchy'
        },
        {
            'label': 'GPE',
            'matches': [{
                'char_end': 34,
                'char_start': 30,
                'text': 'U.K.'
</span><span class="koboSpan" id="kobo.389.2">            }],
            'name': 'U.K.'
</span><span class="koboSpan" id="kobo.389.3">        },
        {
            'label': 'MONEY',
            'matches': [{
                'char_end': 57,
                'char_start': 47,
                'text': '$1 billion'
            }],
            'name': '$1 billion'
        }
    ],
    'id': 1
}]</span></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.390.1">
     Now we are ready to finish our API.
    </span>
    <span class="koboSpan" id="kobo.390.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.391.1">
      /entities
     </span>
    </strong>
    <span class="koboSpan" id="kobo.392.1">
     path will be the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.393.1">
      POST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.394.1">
     endpoint to send the texts for extraction.
    </span>
    <span class="koboSpan" id="kobo.394.2">
     Let’s get back to the FastAPI code to create
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.395.1">
      this method.
     </span>
    </span>
   </p>
   <ol>
    <li value="5">
     <span class="koboSpan" id="kobo.396.1">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.397.1">
       POST
      </span>
     </strong>
     <span class="koboSpan" id="kobo.398.1">
      request is defined using the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.399.1">
       @app.post()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.400.1">
      decorator.
     </span>
     <span class="koboSpan" id="kobo.400.2">
      First, we will need to parse the received data to a list of dictionaries with the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.401.1">
       record_id
      </span>
     </strong>
     <span class="koboSpan" id="kobo.402.1">
      and
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.403.1">
        text
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.404.1">
       keys:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.405.1">
@app.post("/entities")
def extract_entities(body: TextsRequest):
    """Extract Named Entities from a batch of Records."""
</span><span class="koboSpan" id="kobo.405.2">    documents = []
    for item in body.values:
        documents.append({"record_id": item.record_id, 
                          "text": item.text})</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.406.1">
      Now we will
     </span>
     <a id="_idIndexMarker550">
     </a>
     <span class="koboSpan" id="kobo.407.1">
      call
     </span>
     <a id="_idIndexMarker551">
     </a>
     <span class="koboSpan" id="kobo.408.1">
      the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.409.1">
       EntityExtractor
      </span>
     </strong>
     <span class="koboSpan" id="kobo.410.1">
      class, send the docs, and return
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.411.1">
       the entities:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.412.1">
    entities_result = extractor.extract_entities(documents)
    response = [
        {"record_id": er["record_id"], 
         "data": {"entities": er["entities"]}}
        for er in entities_result
    ]
    return {"values": response}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.413.1">
      If you add this code to the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.414.1">
       main.py
      </span>
     </strong>
     <span class="koboSpan" id="kobo.415.1">
      file, run
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.416.1">
       fastapi run main.py
      </span>
     </strong>
     <span class="koboSpan" id="kobo.417.1">
      in the terminal, and go to the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.418.1">
       /docs
      </span>
     </strong>
     <span class="koboSpan" id="kobo.419.1">
      URL, you should now see the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.420.1">
       POST /entities
      </span>
     </strong>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.421.1">
       endpoint specification.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.422.1">
      Another cool thing about Swagger UI is that we can test the endpoint directly in the browser.
     </span>
     <span class="koboSpan" id="kobo.422.2">
      Click on the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.423.1">
       POST /entities
      </span>
     </strong>
     <span class="koboSpan" id="kobo.424.1">
      down arrow button and then the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.425.1">
       Try it out
      </span>
     </strong>
     <span class="koboSpan" id="kobo.426.1">
      button on the right.
     </span>
     <span class="koboSpan" id="kobo.426.2">
      Now you can paste our example request and click on
     </span>
     <a id="_idIndexMarker552">
     </a>
     <span class="koboSpan" id="kobo.427.1">
      the blue
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.428.1">
       Execute
      </span>
     </strong>
     <span class="koboSpan" id="kobo.429.1">
      button.
     </span>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.430.1">
        Figure 11
       </span>
      </em>
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.431.1">
       .8
      </span>
     </em>
     <span class="koboSpan" id="kobo.432.1">
      shows the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.433.1">
       POST /entities
      </span>
     </strong>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.434.1">
       arrow
      </span>
     </span>
     <span class="No-Break">
      <a id="_idIndexMarker553">
      </a>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.435.1">
       button.
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer118">
     <span class="koboSpan" id="kobo.436.1">
      <img alt="Figure 11.8 – The button to send data to the entities endpoint" src="image/B22441_11_08.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.437.1">
     Figure 11.8 – The button to send data to the entities endpoint
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.438.1">
     The next list has the full code of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.439.1">
      our API:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.440.1">
from fastapi import FastAPI
from typing import List
from pydantic import BaseModel
import spacy
from extractor import EntityExtractor
app = FastAPI()
nlp = spacy.load("../chapter_08/pipelines/fashion_ner_with_base_entities")
extractor = EntityExtractor(nlp)
class TextToExtractEntities(BaseModel):
    record_id: str
    text: str
class TextsRequest(BaseModel):
    values: List[TextToExtractEntities]
@app.get("/")
def root():
    return {"message": "Hello World"}
@app.post("/entities")
def extract_entities(body: TextsRequest):
    """Extract Named Entities from a batch of Records."""
</span><span class="koboSpan" id="kobo.440.2">    documents = []
    for item in body.values:
        documents.append({"record_id": item.record_id, 
                          "text": item.text})
    entities_result = extractor.extract_entities(documents)
    response = [
        {"record_id": er["record_id"], 
         "data": {"entities": er["entities"]}}
        for er in entities_result
    ]
    return {"values": response}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.441.1">
     It’s pretty cool to get all these functionalities with just some lines of code, right?
    </span>
    <span class="koboSpan" id="kobo.441.2">
     This is just the basics of how
    </span>
    <a id="_idIndexMarker554">
    </a>
    <span class="koboSpan" id="kobo.442.1">
     to use FastAPI.
    </span>
    <span class="koboSpan" id="kobo.442.2">
     You can check a lot of
    </span>
    <a id="_idIndexMarker555">
    </a>
    <span class="koboSpan" id="kobo.443.1">
     more advanced stuff in the library’s documentation
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.444.1">
      at
     </span>
    </span>
    <a href="https://fastapi.tiangolo.com/learn/">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.445.1">
       https://fastapi.tiangolo.com/learn/
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.446.1">
      .
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-152">
    <a id="_idTextAnchor151">
    </a>
    <span class="koboSpan" id="kobo.447.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.448.1">
     This chapter introduced two powerful tools for integrating spaCy with third-party libraries: Streamlit for building interactive web applications and FastAPI for creating fast, type-safe APIs.
    </span>
    <span class="koboSpan" id="kobo.448.2">
     We demonstrated how to build an NER web app using Streamlit and the spacy-streamlit package, leveraging Streamlit’s simplicity and interactivity.
    </span>
    <span class="koboSpan" id="kobo.448.3">
     We then transitioned to building an API with FastAPI, emphasizing the importance of type hints in reducing bugs and improving code reliability.
    </span>
    <span class="koboSpan" id="kobo.448.4">
     By combining spaCy with these frameworks, you learned that you could create effective, user-friendly NLP applications and services with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.449.1">
      minimal effort.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.450.1">
     With this last chapter, we close out the book.
    </span>
    <span class="koboSpan" id="kobo.450.2">
     It was quite a journey!
    </span>
    <span class="koboSpan" id="kobo.450.3">
     I hope you’ve gained some ground knowledge of the main spaCy’s functionalities, but most importantly, I hope you can now create solutions with spaCy that follow some of the main software engineering principles for writing good code.
    </span>
    <span class="koboSpan" id="kobo.450.4">
     I can’t wait to see what you’ll
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.451.1">
      build next!
     </span>
    </span>
   </p>
  </div>
 </body></html>