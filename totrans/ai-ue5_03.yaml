- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Presenting the Unreal Engine Navigation System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Unreal Engine **Navigation System** is a sophisticated framework that enables
    AI-controlled entities to navigate and interact seamlessly within game levels.
    It provides a set of tools and algorithms that allow game developers to define
    and create paths, obstacles, and movement behaviors. By using the Navigation System,
    you will be able to simulate realistic movement and behavior patterns of AI-controlled
    entities, enhancing the immersion and believability of your virtual environments.
    As this system incorporates advanced features such as **pathfinding algorithms**
    , **collision avoidance** , and **dynamic obstacle handling** , understanding
    its full potential is a crucial skill for aspiring AI programmers.
  prefs: []
  type: TYPE_NORMAL
- en: By the time you reach the end of this chapter, you will possess a strong comprehension
    of how this specific part of the Gameplay Framework operates. Equipped with this
    knowledge, you will be fully prepared to embark on your journey of actively working
    with the system itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing AI movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding pathfinding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the Navigation System with a project template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are no technical requirements to follow for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing AI movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to moving AI entities in a virtual environment, we face numerous
    challenges, and there is no universal solution. The approach to solving each problem
    depends on each unique characteristic that will be faced in the type of game being
    developed. For example, is the AI’s destination something stationary – for instance,
    a pickup – or is it something that is moving unpredictably, such as the player
    character? Furthermore, will the AI just need to wander around without a specific
    destination, or will it have a pre-defined pattern – for instance, as a patrolling
    sentinel?
  prefs: []
  type: TYPE_NORMAL
- en: Also, as a developer, you will need to consider factors such as different terrains,
    obstacles, and dangerous zones. Deciding between an easier or a more dangerous
    – but quicker – path can have a significant impact at runtime. These are just
    a few of the considerations involved in moving AIs within a level and, as you
    encounter different scenarios, you will be likely to face different issues. Understanding
    and properly addressing all pertinent variables is essential for an optimal player
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: So, what are the main entities involved in AI movement and, specifically, in
    pathfinding? How do they cooperate to make a player’s experience flawless? I will
    tell you all about it in a few seconds!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Navigation Mesh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Unreal Engine, the Navigation System is based on a **navigation mesh** –
    or **nav mesh** – that works by dividing the navigable space into polygons, which
    are subsequently divided into triangles for efficiency. Each triangle is then
    considered a node of a graph to reach a specific location and when two triangles
    are adjacent, their respective nodes are connected. *Figure 3* *.1* depicts a
    game level with the aforementioned mesh, divided by triangles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – A nav mesh example](img/B31016_03_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – A nav mesh example
  prefs: []
  type: TYPE_NORMAL
- en: Using this graph, you can apply any type of pathfinding algorithm – such as
    **A-star** ( **A*** ), which I will explain later in this chapter – and the resulting
    process will generate a path among these triangles that the AI character can traverse.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, unless you truly need to delve into the intricacies of altering
    the core structure of the Navigation System, there is no immediate need to venture
    into such detail. Understanding that the collection of generated triangles forms
    a cohesive graph, which serves as the foundation for pathfinding algorithms, is
    sufficient for getting the best out of the Navigation System.
  prefs: []
  type: TYPE_NORMAL
- en: To generate a nav mesh in Unreal Engine, all you have to do is add one or more
    **Nav Mesh Bounds Volume** actors in the level and change their size to suit your
    own needs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In Unreal Engine, a **Volume** class refers to a special type of actor that
    can influence the behavior of other actors within its area of effect. Volumes
    are used to define various effects, such as lighting, and can modify how players
    or other objects interact with the game world. Some common types of volumes in
    Unreal Engine include Trigger Volumes, Lightmass Importance Volumes, Post-Processing
    Volumes, and, obviously, Nav Mesh Bounds Volumes.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3* *.2* shows a **Nav Mesh Bounds Volume** actor added to a level;
    the yellow lines mark the volume itself.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – A Nav Mesh Bounds Volume](img/B31016_03_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – A Nav Mesh Bounds Volume
  prefs: []
  type: TYPE_NORMAL
- en: 'This actor is pretty straightforward, and the only possible action you can
    take with it is to adjust its extension. From the previous image, you may have
    noticed a green mesh, made of two triangles; this fairly simple shape has been
    generated by another actor: the **Recast Nav Mesh** one, which is usually auto-generated
    the very first time Nav Mesh Bounds Volume is added to the level.'
  prefs: []
  type: TYPE_NORMAL
- en: This actor oversees the walkable area generation for AI entities that will use
    it to make their own efficient and accurate calculations on pathfinding; an instance
    of it is usually auto-generated once you add a Nav Mesh Bounds Volume in your
    level.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be noted that most of the settings available for the **RecastNavMesh**
    actor can be set with predefined values in your editor’s **Project Settings**
    – this can be opened from the **File** menu – by selecting the **Engine - Navigation
    Mesh** section, as depicted in *Figure 3* *.3* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – The Navigation Mesh settings section](img/B31016_03_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – The Navigation Mesh settings section
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand how a nav mesh is created in Unreal Engine, it is important
    to know that you can adjust it to enhance its interest and realism using navigation
    modifiers by using the available modifier system.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the nav mesh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Navigation System comprises various actors and components that alter the
    generation of the nav mesh, such as the cost of traversing a polygon. These adjustments
    influence how AI agents move through your level.
  prefs: []
  type: TYPE_NORMAL
- en: The Nav Modifier Volume
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The simplest one is the **Nav Modifier Volume** actor, whose task is… well,
    to modify a nav mesh! Once you have positioned this volume in your level, you
    will have the choice to modify how an AI agent will perceive it for pathfinding
    – you can designate it as an impassable terrain, a difficult terrain, or even
    an obstacle. *Figure 3* *.4* shows three modifier volumes set with the three different
    cost settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Three navigation modifiers in action](img/B31016_03_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Three navigation modifiers in action
  prefs: []
  type: TYPE_NORMAL
- en: If you are thinking about creating your own nav mesh modifiers, well, that’s
    possible; you will just need to extend the **UNavArea** class, set its parameters,
    and you are ready to go!
  prefs: []
  type: TYPE_NORMAL
- en: Navigation Query Filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an additional method for tailoring the behavior of the Navigation System
    when generating paths for AI agents, you can take advantage of **Navigation Query
    Filters** . This method encompasses information pertaining to one or more specific
    areas and provides the flexibility to override the cost values assigned to the
    areas themselves, if necessary. By implementing query filters, you will gain the
    ability to customize the navigation patterns of AI agents as they traverse various
    regions within your game world, and this will let you fine-tune and optimize the
    movement of AI entities.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation Link Proxies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you begin designing your walkable terrain, you will most probably be introducing
    gaps or areas with varying altitudes; and I guess you’ll need your AI character
    to jump from one side to the other. That’s exactly why the Nav Link Proxy has
    been created; this actor will connect two areas of the nav mesh that lack a direct
    navigation path. *Figure 3* *.5* shows such a link, connecting two zones at different
    heights:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Nav link proxy](img/B31016_03_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Nav link proxy
  prefs: []
  type: TYPE_NORMAL
- en: With such a useful tool at your disposal, you will be able to make your character
    jump, fall down, and execute breathtaking acrobatics, seamlessly transitioning
    from one gravity-defying move to another.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime nav mesh generation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, Unreal Engine is set to generate nav meshes statically – this means
    that the mesh is generated offline and cannot be changed at runtime. However,
    if you need a more flexible way of generating a nav mesh, you can opt for the
    **dynamic mesh generation** system that will let you update the mesh under different
    circumstances – for example, by adding moving entities. The runtime generation
    can be enabled for the whole project by opening **Project Settings** , and then
    going to the **Engine - Navigation Mesh** section, and selecting the **Runtime
    Generation** option in the **Runtime** category:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Enabling Runtime Generation](img/B31016_03_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Enabling Runtime Generation
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can enable it for just a single level, by changing the **Runtime
    Generation** attribute in the **Recast Nav** **Mesh** actor.
  prefs: []
  type: TYPE_NORMAL
- en: Invokers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **Navigation Invoker** is an actor component that will generate the nav mesh
    around an AI agent at runtime. It is used to remove the need for pre-computing
    the mesh, and it allows for dynamic navigation in the game world. This feature
    is particularly useful when you have extensive terrains – for instance, an open
    world – that will take a huge amount of time to generate the nav mesh; through
    an Invoker, the system will generate the mesh itself at runtime, but just in a
    limited space, around the actor.
  prefs: []
  type: TYPE_NORMAL
- en: You now have a grasp of how a nav mesh is created and tweaked, so let’s explore
    who – or what – will be moving through it.
  prefs: []
  type: TYPE_NORMAL
- en: AI agents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Unreal Engine’s Navigation System, an **agent** is an AI character or entity
    that is capable of navigating the game world by means of the nav mesh. An agent
    will use the nav mesh data to compute paths, avoid obstacles, and move around
    the environment intelligently. Each agent in a level typically represents a specific
    type of character, such as a player character – for instance, in a point-and-click
    game – an enemy AI, or any other entity that needs to move within the game world.
  prefs: []
  type: TYPE_NORMAL
- en: To move an agent within a level, you will typically be using a **Pawn** or a
    **Character** actor.
  prefs: []
  type: TYPE_NORMAL
- en: One of the easiest ways to move an agent toward a location or an actor is by
    using the **Simple Move to Location** or **Simple Move to Actor** Blueprint nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – The Simple Move nodes](img/B31016_03_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – The Simple Move nodes
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can use the corresponding C++ methods called, respectively,
    **SimpleMoveToLocation()** and **SimpleMovetoActor()** .
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, in Unreal Engine, you can create more complex behaviors than just
    moving an agent to a single point; this is something we will explore starting
    from [*Chapter 8*](B31016_08.xhtml#_idTextAnchor148) , *Setting Up a* *Behavior
    Tree* .
  prefs: []
  type: TYPE_NORMAL
- en: Avoidance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Basic pathfinding algorithms are effective for finding routes around stationary
    objects; however, when it comes to moving obstacles – such as player characters
    or other AI agents – a more suitable system is needed. That’s why Unreal Engine
    provides two **avoidance** systems, to prevent collision between moving entities:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Reciprocal Velocity Obstacles** ( **RVO** ) system computes the velocity
    vectors for each agent, considering nearby agents and assuming they are moving
    at a constant velocity in each time step of the calculation. The chosen optimal
    velocity vector is the closest match to the agent’s desired velocity in the direction
    of its destination. This system is included in the character movement component.
    RVO does not use the nav mesh for avoidance, so it can be used separately from
    the Navigation System for any character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Detour Crowd Manager** computes a rough sample of velocities that lean
    toward the agent’s direction, resulting in a substantial enhancement in avoidance
    quality compared to the standard RVO approach. This system can be used by any
    actor extending the **Pawn** class by using the **ADetourCrowdAIController** class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will be introduced to avoidance in [*Chapter 5*](B31016_05.xhtml#_idTextAnchor099)
    , *Improving* *Agent Navigation* .
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have been introduced to the main elements involved in pathfinding
    and how they interact with the environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, I will provide you with further details on how pathfinding
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding pathfinding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you are aware, Unreal Engine uses **pathfinding** for moving an agent around
    a level; in this section, I will go a bit deeper into detail on how things work
    under the hood. Unreal Engine takes advantage of a generalized version of the
    A* algorithm, a widely employed graph traversal and pathfinding algorithm in computer
    science. Known for its completeness, optimality, and efficiency, its main goal
    is to determine the shortest path between a designated source node and a specified
    goal node in a weighted graph.
  prefs: []
  type: TYPE_NORMAL
- en: This graph is a node-based representation of the level, where nodes represent
    walkable areas that are interconnected and have information on neighbor nodes
    and traversal costs to reach them.
  prefs: []
  type: TYPE_NORMAL
- en: A* uses a heuristic function to estimate the cost from each node to the target
    location; this trial-by-error system helps guide the search toward the most promising
    paths, improving efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the pathfinding process, the algorithm maintains two lists: one of them
    contains nodes that are yet to be evaluated, while the other contains nodes that
    have already been evaluated. The algorithm evaluates each node by considering
    its cost, and the cost of reaching it from the previous node. It selects the node
    with the lowest total cost from the open list for further evaluation. Once the
    target node is reached, the algorithm reconstructs the path by backtracking from
    the target node to the start node, following the connections between nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: Unreal Engine’s version often includes post-smoothing operations to improve
    the quality of the generated path. Post-smoothing adjusts the path to make it
    more natural and avoid obstacles more effectively.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to take a deep dive into how the nav mesh generation works and how
    pathfinding is computed, my suggestion is to check the Unreal Engine source code
    available on GitHub ( [https://github.com/EpicGames/UnrealEngine](https://github.com/EpicGames/UnrealEngine)
    ); in particular, you should look for the **NavigationSystem** and **NavMesh**
    modules, which are located in the **Engine/Source/Runtime** folder.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the Unreal Engine source code, you will need to be part of the Epic
    Games GitHub organization. Subscription is free and there’s no reason why you
    shouldn’t take part in it.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, by checking the **DetourNavMeshQuery** class in the Unreal Engine
    source code, you will get an insight into how the A* pathfinding algorithm is
    used and how cost is computed or how to find a tile on a path.
  prefs: []
  type: TYPE_NORMAL
- en: It seems you have gained some insight into how pathfinding is handled within
    Unreal Engine, so I guess it’s time to delve into a practical example by exploring
    a real case scenario; we will begin by creating a project from a template.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Navigation System with a project template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at a project that uses the Unreal Engine Navigation
    System and do it with a project template – using a pre-made project such as a
    template presents a valuable chance for you to acquire practical experience on
    a particular topic, saving you the time and effort required to build a project
    from the ground up.
  prefs: []
  type: TYPE_NORMAL
- en: Once the project has been created, we will quickly analyze the nav mesh generation
    system and how the template handles the character movement at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Here, you will start by creating a game prototype by using the **Top Down**
    project, one of the templates available in the **GAMES** category of **Unreal**
    **Project Browser** .
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you are ready, you can fire up the Epic Games Launcher and follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **GAMES** | **Top Down** from the available templates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the project to **Blueprint** or **C++** depending on your personal preferences.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name your project – any name will do.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the other settings with their default values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Project setup](img/B31016_03_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Project setup
  prefs: []
  type: TYPE_NORMAL
- en: Once the project has been created and opened, you are ready to analyze it.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the nav mesh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now going to get a brief tour of the generated level and of the actors
    that contribute to the nav mesh generation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Outliner** view, you will notice that there is a folder named **Navigation**
    , including three actors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NavMesh** **Bounds Volume**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recast** **Nav Mesh**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nav** **Link Proxy**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s analyze each element in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Nav Mesh Bounds Volume
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you already know from the previous sections in this chapter, the **NavMeshBoundsVolume**
    actor is responsible for defining the area where the nav mesh will be computed.
    By selecting it, you will notice that a yellow-edged area is shown, wrapping all
    the game levels, as shown in *Figure 3* *.9* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Nav Mesh Bounds Volume](img/B31016_03_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Nav Mesh Bounds Volume
  prefs: []
  type: TYPE_NORMAL
- en: You cannot do much with this actor; just resize it and the nav mesh will be
    recomputed.
  prefs: []
  type: TYPE_NORMAL
- en: Recast Nav Mesh
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **RecastNavMesh** actor will take care of the nav mesh generation; by default,
    it does not have a visible representation within the Unreal Engine Editor. However,
    if you press the *P* key on your keyboard, the nav mesh will become visible and
    accessible within the editor interface. *Figure 3* *.10* shows the level once
    this actor has been made visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Recast Nav Mesh](img/B31016_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Recast Nav Mesh
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 6*](B31016_06.xhtml#_idTextAnchor116) , *Optimizing the Navigation
    System* , I will be presenting you some techniques on how to optimize mesh generation
    with this actor. For now, you can just check the **Display** category in the **Details**
    window; here, you will have access to a plethora of visualization utilities that
    will come in handy later in this book. As an example, in *Figure 3* *.11* , I
    am showing the sections of the level – named **tiles** – along with their labels
    and the generated polygons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Some display settings for the Recast Nav Mesh actor](img/B31016_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – Some display settings for the Recast Nav Mesh actor
  prefs: []
  type: TYPE_NORMAL
- en: You may have observed that the blue cube actors on the level are not affecting
    the nav mesh in any way. This is because they have been configured not to impact
    the navigation; since they are movable objects, we do not intend for them to create
    non-navigable areas around them.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a simple test, in the **Details** panel, you can look for the **Can Ever
    Affect Navigation** property and enable it; the nav mesh will be immediately recomputed
    and the cube will carve a hole in it, as depicted in *Figure 3* *.12* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – The blue cube actor carving the nav mesh](img/B31016_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – The blue cube actor carving the nav mesh
  prefs: []
  type: TYPE_NORMAL
- en: The aforementioned property states that the object will be an obstruction in
    the navigation area and that the generated hole will be a non-navigable area in
    the mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that letting such a movable object carve the nav mesh may produce
    undesired results; by default, the nav mesh is static and cannot be altered at
    runtime. This implies that even if the object is moved, the non-navigable area
    will remain fixed and – though unseen – will hinder the player character from
    moving into or through it.
  prefs: []
  type: TYPE_NORMAL
- en: Nav Link Proxy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last nav mesh entity in this example is a **NavLinkProxy** actor that, in
    our level, will let the player character jump down from a platform.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – The Nav Link Proxy in the level](img/B31016_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – The Nav Link Proxy in the level
  prefs: []
  type: TYPE_NORMAL
- en: Now that you comprehend how the nav mesh is structured, let’s examine the character
    controller to understand how the player character is maneuvered.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the character controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Depending on your choice in creating the project – Blueprints or C++ – you will
    have two slightly different versions of the character controller.
  prefs: []
  type: TYPE_NORMAL
- en: The Blueprint character controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code for moving the controller character is pretty straightforward and can
    be found in **BP_TopDownController** – located in the **Content/TopDown/Blueprints**
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Once the Blueprint class is opened, locate the **MoveTo** function in the **Functions**
    tab and open it; you will find the **Simple Move to Location** node that is used
    to make the player character move through the nav mesh.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – The MoveTo function](img/B31016_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – The MoveTo function
  prefs: []
  type: TYPE_NORMAL
- en: This is all you need to use to move your player character to a predefined location
    in the level.
  prefs: []
  type: TYPE_NORMAL
- en: The C++ character controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The same logic can be found inside a C++-generated project; just open the generated
    **.cpp** class for the player controller and look for the **OnSetDestinationReleased()**
    method; you will find this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This helper function will start the navigation process for your agent.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you know all the actors involved in this project, you can simply hit
    the **Play** button and start testing how the Navigation System works. In particular,
    you will notice that the character will move to the destination point by selecting
    the shortest path.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, once on the raised platform on the left, it will be able to jump
    down thanks to the Nav Link Proxy that has been added at that location.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I introduced you to the key components of the Unreal Engine
    Navigation System. We started by discussing the process of generating the nav
    mesh, which is essential for AI agents to navigate the environment. Then, I provided
    a brief explanation of how the pathfinding algorithm works, enabling AI characters
    to find their way efficiently. Lastly, I highlighted the benefits of using the
    **Top Down** project template, which effectively utilizes the Navigation System.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should have a good understanding of the capabilities offered by
    the Unreal Engine AI Navigation System. I imagine you are eager to dive in and
    start coding on your keyboard, and that is exactly what we will be doing in the
    next chapter!
  prefs: []
  type: TYPE_NORMAL
