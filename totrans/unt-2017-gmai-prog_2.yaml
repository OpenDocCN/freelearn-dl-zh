- en: Finite State Machines and You
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll expand our knowledge of the FSM pattern and its uses
    in games and learn how to implement it in a simple Unity game. We will create
    a tank game with the sample code that comes with this book. We''ll be dissecting
    the code and the components in this project. The topics we''ll cover are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Unity's state machine features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our own states and transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a sample scene using examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unity 5 introduced state machine behaviors, which are a generic expansion of
    the Mecanim animation states that were introduced in the 4.x cycle. These new
    state machine behaviors, however, are independent of the animation system, and
    we will learn to leverage these new features to quickly implement a state-based
    AI system.
  prefs: []
  type: TYPE_NORMAL
- en: In our game, the player will be able to control a tank. The enemy tanks will
    be moving around in the scene with reference to four waypoints. Once the player
    tank enters their visible range, they will start chasing us, and once they are
    close enough to attack, they'll start shooting at our tank agent. This simple
    example will be a fun way to get our feet wet in the world of AI and state FSMs.
  prefs: []
  type: TYPE_NORMAL
- en: Finding uses for FSMs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we will primarily focus on using FSMs to implement AI in our game to
    make it more fun and interesting, it is important to point out that FSMs are widely
    used throughout game and software design and programming. In fact, the system
    in Unity 2017 that we'll be using was first introduced in the Mecanim animation
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can categorize many things into states in our daily lives. The most effective
    patterns in programming are those that mimic the simplicity of real-life designs,
    and FSMs are no different. Take a look around and you''ll most likely notice a
    number of things in one of any number of possible states. For example, is there
    a light bulb nearby? A light bulb can be in one of two states—on or off (so long
    as we''re not talking about one of those fancy dimming lights). Let''s go back
    to grade school for a moment and think about the time when we were learning about
    the different states matter can be in. Water, for example, can be solid, liquid,
    or gas. Just as in the FSM pattern in programming where variables can trigger
    a state change, water''s transition from one state to another is caused by heat:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/615ef79f-2b49-427c-8116-66f966d3f081.png)'
  prefs: []
  type: TYPE_IMG
- en: The three distinct states of water
  prefs: []
  type: TYPE_NORMAL
- en: Though there are no hard rules beyond those of our own implementation in programming
    design patterns, it is a characteristic of FSMs to be in one, and only one, state
    at any given time. With that said, transitions allow for a "hand-off", of sorts,
    between two states, just like ice slowly melts into water. Additionally, an agent
    can have multiple FSMs, driving any number of behaviors, and states can even contain
    state machines of their own—think Christopher Nolan's *Inception*, but with state
    machines instead of dreams.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many different implementations and variants of the FSM in C# and
    Unity, many of which can be found in the Unity Asset Store, but they share a few
    key features:'
  prefs: []
  type: TYPE_NORMAL
- en: They define the various states that an object can be in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They provide a mechanism for transitioning from one state to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They provide a way to define the rules that govern transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unity's Mecanim system, though intended originally for driving animations in
    a state-based manner, fits the bill quite well as it provides a lesser-known,
    more generic set of FSM features.
  prefs: []
  type: TYPE_NORMAL
- en: Creating state machine behaviors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we're familiar with the concept of a state machine, let's get our hands
    dirty and start implementing our very own.
  prefs: []
  type: TYPE_NORMAL
- en: As of Unity 2017.1, state machines are still part of the animation system, but
    worry not, they are flexible and no animations are actually required to implement
    them. Don't be alarmed or confused if you see code referencing the `Animator`
    component or the `AnimationController` asset as it's merely a quirk of the current
    implementation. It's possible that Unity will address this in a later version,
    but the concepts will likely not change.
  prefs: []
  type: TYPE_NORMAL
- en: Let's fire up Unity, create a new project, and get to it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the AnimationController asset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `AnimationController` asset is a type of asset within Unity that handles
    states and transitions. It is, in essence, an FSM, but it also does much more.
    We''ll focus on the FSM portion of its functionality. An animator controller can
    be created from the Assets menu, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/588bcc19-3075-49ba-abde-8a43e3bd051b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you create the animator controller, it will pop up in your project assets
    folder, ready to be named. We''ll name it `TankFsm`. When you select the animator
    controller, unlike most other asset types, the hierarchy is blank. That is because
    animation controllers use their own window. You can simply click on Open in the
    hierarchy to open up the Animator window, or open it in the Window menu, as you
    can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cb72492-d7de-491f-9468-8bb415e723f9.png)'
  prefs: []
  type: TYPE_IMG
- en: Be sure to select Animator and not Animation as these are two different windows
    and features entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Let's familiarize ourselves with this window before moving forward.
  prefs: []
  type: TYPE_NORMAL
- en: Layers and parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Layers, as the name implies, allow us to stack different state machine levels
    on top of each other. This panel allows us to organize the layers easily and have
    a visual representation. We will not be doing much in this panel for now as it
    primarily relates to animation, but it''s good to be familiar with it. Refer to
    the following screenshot of the window to find your way around the layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba0ba33e-7b0d-4b0e-a987-305b7d91f85b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is a summary of the items shown in the previous screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Add layer**: The + button creates a new layer at the bottom of the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layer list**: These are the layers currently inside the animator controller.
    You can click to select a layer and drag and drop layers to rearrange them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layer settings**: The gear icon brings up a menu to edit animation-specific
    settings for the layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, we have the Parameters panel, which is far more relevant to our use
    of the animator controller. Parameters are variables that determine when to transition
    between states, and we can access them via scripts to drive our states. There
    are four types of parameters—`float`, `int`, `bool`, and `trigger`. You should
    already be familiar with the first three as they are primitive types in C#, but
    `trigger` is specific to the animator controller, not to be confused with physics
    triggers, which do not apply here. Triggers are just a means to trigger a transition
    between states explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the elements in the Parameters panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b09e53f-d7b2-4e72-ae7c-2cd1688a305d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is a summary of the items depicted in the previous screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Search**: We can quickly search through our parameters here. Simply type
    in the name and the list will populate with the search results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Add parameter**: This button lets you add new parameters. When you click
    on it, you must select the parameter type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameter list**: This is the list of parameters you''ve created. You can
    assign and view their values here. You can also reorder the parameters to your
    liking by dragging and dropping them in the correct order. This is merely for
    organization and does not affect functionality at all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lastly, there is an eyeball icon, which you can click to hide the Layers and
    Parameters panels altogether. When the panels are closed, you can still create
    new layers by clicking on the Layers dropdown and selecting Create New Layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00c538a4-b1c4-493e-9909-7c0d3eb58750.png)'
  prefs: []
  type: TYPE_IMG
- en: The animation controller inspector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The animation controller inspector is slightly different from the regular inspector
    found throughout Unity. While the regular inspector allows you to add components
    to the game objects, the animation controller inspector has a button labeled Add
    Behaviour, which allows you to add a `StateMachineBehaviour` to it. This is the
    main distinction between the two types of inspectors, but apart from this, it
    will display the serialized information for any selected state, substate, transition,
    or blend tree, just as the regular inspector displays the data for the selected
    game object and its components.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing behaviors into the picture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: State machine behaviors are a unique, new concept in Unity 5\. While states
    existed, conceptually, in the original implementation of Mecanim, transitions
    were handled behind the scenes and you did not have much control over what happened
    upon entering, transitioning, or exiting a state. Unity 5 addressed this issue
    by introducing behaviors; they provide the built-in functionality to handle typical
    FSM logic.
  prefs: []
  type: TYPE_NORMAL
- en: Behaviors are sly and tricky. Though their name might lead you to believe they
    are related to `MonoBehaviour`, do not fall for it; if anything, these two are
    distant cousins at best. In fact, behaviors derive from `ScriptableObject`, not
    `MonoBehaviour`, so they exist only as assets, which cannot be placed in a scene
    or added as components to a `GameObject`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our very first state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Okay, so the header is not entirely true since Unity creates a few default
    states for us in our animator controller—New State, Any State, Entry, and Exit—but
    let''s just agree that those don''t count for now, okay? Let''s take a look at
    some of the things we can do in our newly-created animation controller:'
  prefs: []
  type: TYPE_NORMAL
- en: You can select states in this window by clicking on them, and you can move them
    by dragging and dropping them anywhere in the canvas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the state named New State and delete it by either right-clicking and
    then clicking on Delete or simply hitting the *Delete* key on your keyboard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you select the Any State state, you''ll notice that you do not have the
    option to delete it. The same is true for the Entry state. These are required
    states in an animator controller and have unique uses, which we''ll cover up ahead:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/cf416931-af3a-43d0-baa3-d8aa4e90f39c.png)'
  prefs: []
  type: TYPE_IMG
- en: To create our (true) first state, right-click anywhere on the canvas and then
    select Create State, which opens up a few options, from which we'll select Empty.
    The other two options, From Selected Clip and From New Blend Tree, are not immediately
    applicable to our project, so we'll skip these. Now we've officially created our
    first state.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning between states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll notice that upon creating our state, an arrow is created connecting the
    Entry state to it, and that its node is orange. Unity will automatically set default
    states to look orange to differentiate them from other states. When you only have
    one state, it is automatically selected as the default state, and as such, it
    is automatically connected to the entry state. You can manually select which state
    is the default state by right-clicking on it and then clicking on Set as Layer
    Default State. It will then become orange, and the entry state will automatically
    connect itself to it. The connecting arrow is a **transition connector**. Transition
    connectors allow us some control over how and when the transition occurs, but
    the connector from the entry state to the default state is unique in that it does
    not provide us with any options, since this transition happens automatically.
  prefs: []
  type: TYPE_NORMAL
- en: You can manually assign transitions between states by right-clicking on a state
    node and then selecting Make Transition. This will create a transition arrow from
    the state you selected to your mouse cursor. To select the destination of the
    transition, simply click on the destination node and that's it. Note that you
    cannot redirect the transitions though. We can only hope that the kind folks behind
    Unity add that functionality at a later point, but for now, you must remove a
    transition by selecting it and deleting it, and then assigning an all-new transition
    manually.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our player tank
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open up the sample project included with this book for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: It is a good idea to group similar assets together in your project folder to
    keep them organized. For example, you can group your state machines in a folder
    called `StateMachines`. The assets provided for this chapter are grouped for you
    already, so you can drop the assets and scripts you create during this chapter
    into the corresponding folder.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the enemy tank
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's go ahead and create an animator controller in your assets folder. This
    will be your enemy tank's state machine. Call it `EnemyFsm`.
  prefs: []
  type: TYPE_NORMAL
- en: This state machine will drive the tank's basic actions. As described earlier
    in our example, the enemy can patrol, chase, and shoot the player. Let's go ahead
    and set up our state machine. Select the `EnemyFsm` asset and open up the Animator
    window.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll go ahead and create three empty states that will conceptually and
    functionally represent our enemy tank's states. Name them `Patrol`, `Chase`, and
    `Shoot`. Once they are created and named, we'll want to make sure we have the
    correct default state assigned. At the moment, this will vary depending on the
    order in which you created and named the states, but we want the Patrol state
    to be the default state, so right-click on it and select Set as Layer Default
    State. Now it is colored orange and the Entry state is connected to it.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we have to make some design and logic decisions regarding the
    way our states will flow into each other. When we map out these transitions, we
    also want to keep in mind the conditions that trigger the transitions to make
    sure they are logical and work from a design-standpoint. Out in the wild, when
    you''re applying these techniques on your own, different factors will play into
    how these transitions are handled. In order to best illustrate the topic at hand,
    we''ll keep our transitions simple and logical:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Patrol**: From patrol, we can transition into chasing. We will use a chain
    of conditions to choose which state we''ll transition into, if any. Can the enemy
    tank see the player? If yes, we go to the next step; if not, we continue with
    patrolling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chase**: From this state, we''ll want to continue to check whether the player
    is within sight to continue chasing, close enough to shoot, or completely out
    of sight—that would send us back into the Patrol state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shoot**: As earlier, we''ll want to check our range for shooting and then
    the line of sight to determine whether or not we can chase to get within the range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This particular example has a simple and clean set of transition rules. If
    we connect our states accordingly, we''ll end up with a graph looking more or
    less similar to this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1f507f9-25d0-4546-85dc-51f7d35777c2.png)'
  prefs: []
  type: TYPE_IMG
- en: Keep in mind that the placement of the nodes is entirely up to you, and it does
    not affect the functionality of the state machine in any way. You can try to place
    your nodes in a way that keeps them organized so that you can track your transitions
    visually.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our states mapped out, let's assign some behaviors to them.
  prefs: []
  type: TYPE_NORMAL
- en: Making the cogs turn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the part I'm sure you've been waiting for. I know, I've kept you waiting,
    but for good reason. As we now get ready to dive into the coding, we do so with
    a good understanding of the logical connection between the states in our FSM.
    Without further ado, select our Patrol state. In the hierarchy, you'll see a button
    labeled Add Behaviour. Clicking this gives you a context menu very similar to
    the Add Component button on regular game objects, but as we mentioned before,
    this button creates the oh-so-unique state machine behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and name this behavior `TankPatrolState`. Doing so creates a script
    of the same name in your project and attaches it to the state we created it from.
    You can open this script via the project window, or by double-clicking on the
    name of the script in the inspector. What you''ll find inside will look similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Downloading the example code
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Before we begin, uncomment each method. Let's break it down step by step. Unity
    creates this file for you, but all the methods are commented out. Essentially,
    the commented code acts as a guide. Much like the methods provided for you in
    a `MonoBehaviour`, these methods are called for you by the underlying logic. You
    don't need to know what's going on behind the scenes to use them; you simply have
    to know when they are called to leverage them. Luckily, the commented code provides
    a brief description of when each method is called, and the names are fairly descriptive
    themselves. There are two methods here we don't need to worry about, `OnStateIK`
    and `OnStateMove`, which are animation messages, so go ahead and delete them and
    save the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reiterate what''s stated in the code''s comments, the following things happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnStateEnter` is called when you enter the state, as soon as the'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: transition starts
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`OnStateUpdate` is called on each frame, after the `MonoBehaviors` update'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnStateExit` is called after the transition out of the state is finished'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following two states, as we mentioned, are animation-specific, so we do
    not use those for our purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnStateIK` is called just before the IK system gets updated; this is an animation
    and rig-specific concept'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnStateMove` is used on avatars that are set up to use root motion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another important piece of information to note is the parameters passed into
    these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The `animator` parameter is a reference to the animator that contains this animator
    controller, and therefore this state machine. By extension, you can fetch a reference
    to the game object that the animator controller is on, and from there, you can
    grab any other components attached to it. Remember, the state machine behavior
    exists only as an asset, and does not exist in the class, meaning this is the
    best way to get references to runtime classes, such as mono behaviors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The animator state info provides information about the state you're currently
    in; however, the uses for this are primarily focused on animation state information,
    so it's not as useful for our application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we have the layer index, which is an integer telling us which layer
    within the state machine our state is in. The base layer is index zero, and each
    layer above that is a higher number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand the basics of state machine behavior, let's get the rest
    of our components in order. Before we can actually see these behaviors in action,
    we have to go back to our state machine and add some parameters that will drive
    the states.
  prefs: []
  type: TYPE_NORMAL
- en: Setting conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will need to provide our enemy tank with a few conditions to transitions
    states. These are the actual parameters that will drive the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin with the Patrol state. In order for our enemy tank to go from Patrol
    to Shoot, we need to be in range of the player; in other words, we'll be checking
    the distance between the enemy and the player, which is best represented by a
    float value. So, in your Parameters panel, add a float and name it `distanceFromPlayer`.
    We can also use this parameter to determine whether or not to go into the Chase
    state.
  prefs: []
  type: TYPE_NORMAL
- en: The Shoot state and the Chase state will share a common condition, which is
    whether or not the player is visible. We'll determine this via a simple raycast,
    which will, in turn, tell us whether the player was in the line of sight or not.
    The best parameter for this is a Boolean, so create a Boolean and call it `isPlayerVisible`.
    Leave the parameter unchecked, which means false.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ll assign the conditions via the transition connectors'' inspector.
    To do this, simply select a connector. When selected, the inspector will display
    some information about the current transition and, most importantly, the conditions,
    which show up as a list. To add a condition, simply click on the + (plus) sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0cfa3283-8ff5-4cf4-ac4b-27d90596b9ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s tackle each transition one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: Patrol to Chase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: distanceFromPlayer < 5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: isPlayerVisible == true
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/8ba46922-e348-4820-8a22-9a4f0f194a5c.png)'
  prefs: []
  type: TYPE_IMG
- en: The Patrol to Chase transition conditions
  prefs: []
  type: TYPE_NORMAL
- en: 'Chase to patrol gets a bit more interesting as we have two *separate* conditions
    that can trigger a transition. If we were to simply add two conditions to that
    transition, both would have to be evaluated to true in order for the transition
    to occur. But we want to check whether the player is out of range or out of sight.
    Luckily, we can have multiple transitions between the same two states. Simply
    add another transition connection as you normally would. Right-click on the Chase
    state and then make a transition to the Patrol state. You''ll notice that you
    now have two transitions listed at the top of the inspector. In addition, your
    transition connection indicator shows multiple arrows instead of just one to indicate
    that there are multiple transitions between these two states. Selecting each transition
    in the inspector will allow you to give each one separate conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Chase to Patrol (A)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: distanceFromPlayer > 5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Chase to Patrol (B)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: isPlayerVisible == false
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Chase to Shoot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: distanceFromPlayer < 3
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: isPlayerVisible == true
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Shoot to Chase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: distanceFromPlayer > 3
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: distanceFromPlayer < 5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: isPlayerVisible == true
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Shoot to Patrol (A)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: distanceFromPlayer > 6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Shoot to Patrol (B)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: isPlayerVisible == false
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We now have our states and transitions set. Next, we need to create the script
    that will drive these values. All we need to do is set the values, and the state
    machine will handle the rest.
  prefs: []
  type: TYPE_NORMAL
- en: Driving parameters via code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before going any further, we'll need a few things from the assets we imported
    earlier in the chapter. For starters, go ahead and open the `DemoScene` for this
    chapter. You'll notice the scene is fairly stripped down and only contains an
    environment prefab and some waypoint transforms. Go ahead and drop the `EnemyTankPlaceholder`
    prefab into the scene.
  prefs: []
  type: TYPE_NORMAL
- en: You may notice a few components that you may or may not be familiar with on
    the `EnemyTank`. We'll get a chance to thoroughly explore `NavMesh` and `NavMeshAgent`
    in [Chapter 4](503803fe-f343-4a0c-835f-463c98005182.xhtml), *Finding Your Way*,
    but for now, these are necessary components to make the whole thing work. What
    you will want to focus on is the `Animator` component which will house the state
    machine (animator controller) we created earlier. Go ahead and drop the state
    machine into the empty slot before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: We will also need a placeholder for the player. Go ahead and drop in the `PlayerTankPlaceholder`
    prefab as well. We won't be doing much with this for now. As with the enemy tank
    placeholder prefab, the player tank placeholder prefab has a few components that
    we can ignore for now. Simply place it in the scene and continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you''ll want to add a new component to the `EnemyTankPlaceholder` game
    object—the `TankAi.cs` script, which is located in the `Chapter 2` scripts folder.
    If we open up the script, we''ll find this inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a series of variables that are required to run this script, so we''ll
    run through what they''re for in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GameObject player`: This is a reference to the player placeholder prefab we
    dropped in earlier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Animator animator`: This is the animator for our enemy tank, which contains
    the state machine we created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ray ray`: This is simply a declaration for a ray that we''ll use in a raycast
    test on our `FixedUpdate` loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RaycastHit hit`: This is a declaration for the hit information we''ll receive
    from our raycast test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Float maxDistanceToCheck`: This number coincides with the value we set in
    our transitions inside the state machine earlier. Essentially, we are saying that
    we''re only checking as far as this distance for the player. Beyond that, we can
    assume that the player is out of range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Float currentDistance`: This is the current distance between the player and
    the enemy tanks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll notice we skipped a few variables. Don't worry, we'll come back to cover
    these later. These are the variables we'll be using for our Patrol state.
  prefs: []
  type: TYPE_NORMAL
- en: Our `Awake` method handles fetching the references to our player and animator
    variables. You can also declare the preceding variables as public or prefix them
    with the `[SerializeField]` attribute and set them via the inspector.
  prefs: []
  type: TYPE_NORMAL
- en: The `FixedUpdate` method is fairly straightforward; the first part gets the
    distance between the position of the player and the enemy tank. The part to pay
    special attention to is `animator.SetFloat("distanceFromPlayer", currentDistance)`,
    which passes the information from this script into the parameter we defined earlier
    for our state machine. The same is true for the preceding section of the code,
    which passes in the hit result of the raycast as a Boolean. Lastly, it sets the
    `distanceFromTarget` variable, which we'll be using for the Patrol state in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, none of the code concerns itself with how or why the state machine
    will handle transitions; it merely passes in the information the state machine
    needs, and the state machine handles the rest. Pretty cool, right?
  prefs: []
  type: TYPE_NORMAL
- en: Making our enemy tank move
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed in addition to the variables we didn't cover yet, that
    our tank has no logic in place for moving. This can be easily handled with a substate
    machine, which is a state machine within a state. This may sound confusing at
    first, but we can easily break down the Patrol state into substates. In our example,
    the Patrol state will be in one of the two substates—moving to the current waypoint
    or finding the next waypoint. A waypoint is essentially a destination for our
    agent to move toward. In order to make these changes, we'll need to go into our
    state machine again.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a substate by clicking on an empty area on the canvas and then
    selecting Create Sub-State Machine. Since we already have our original Patrol
    state and all the connections that go with it, we can just drag and drop our Patrol
    state into our newly-created substate to merge the two. As you drag the Patrol
    state over the substate, you''ll notice a plus sign appears by your cursor; this
    means you''re adding one state to the other. When you drop the Patrol state in,
    the new substate will absorb it. Substates have a unique look: they are six-sided
    rather than rectangular. Go ahead and rename the substate to `Patrol`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d2fd838-a0e7-48e1-93bc-17bf4dd0ba99.png)'
  prefs: []
  type: TYPE_IMG
- en: To enter a substate, simply double-click on it. Think of it as going a level
    lower into the substate. The window will look fairly similar, but you will notice
    a few things—your Patrol state is connected to a node called (Up) Base Layer,
    which essentially is the connection from this level to the upper level that the
    substate machine sits on. The Entry state connects directly to the Patrol state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, this is not the functionality we want, as it''s a closed loop
    that doesn''t allow us to get in and out of the state into the individual waypoint
    states we need to create; so let''s make some changes. First, we''ll change the
    name of the substate to `PatrolEntry`. Next, we need to assign some transitions.
    When we enter this Entry state, we want to decide whether to continue moving to
    the current waypoint, or to find a new one. We''ll represent each of the outcomes
    as a state, so create two states, `MovingToTarget` and `FindingNewTarget`, then
    create transitions from the PatrolEntry state to each one of the new states. Likewise,
    you''ll want to create a transition between the two new states, meaning a transition
    from the `MovingToTarget` state to the `FindingNewTarget` state and vice versa.
    Now, add a new float parameter called `distanceFromWaypoint` and set up your conditions
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'PatrolEntry to MovingToTarget:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: distanceFromWaypoint > 1
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PatrolEntry to FindingNewTarget:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: distanceFromWaypoint < 1
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MovingToTarget to FindingNewTarget:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: distanceFromWaypoint < 1
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You're probably wondering why we didn't assign the transition rule from the
    FindingNewTarget state to the MovingToTarget state. This is because we'll be executing
    some code via state machine behavior and then automatically going into the MovingToTarget
    state without requiring any conditions. Go ahead and select the FindingNewTarget
    state and add a behavior and call it `SelectWaypointState`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the new script and remove all the methods, except for `OnStateEnter`.
    Add the following functionality to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What we're doing here is getting a reference to our `TankAi` script and calling
    its `SetNextPoint()` method. Simple enough, right?
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need to redo our outgoing connections. Our new states don't have
    transitions out of this level, so we need to add one, using the exact same conditions
    that our PatrolEntry state has, to the (Up) Base Layer state. This is where Any
    State comes in handy—it allows us to transition from any state to another state,
    regardless of individual transition connections, so that we don't have to add
    transitions from each state to the (Up) Base Layer state; we simply add it once
    to the Any State, and we're set! Add a transition from the Any State to the PatrolEntry
    state and use the same conditions the Entry state has to the (Up) Base Layer state.
    This is a workaround for not being able to connect directly from the Any State
    to the (Up) Base Layer state.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re done, your substate machine should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69745fef-cf8a-4666-af80-ad859db55fae.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, all we have to do is hit play and watch our enemy tank patrol back and forth
    between the two provided waypoints. If we place the player in the editor, in the
    enemy tank's path, we'll see the transition happen in the animator, out of the
    Patrol state and into the Chase state, and when we move the player out of range,
    back into the Patrol state. You'll notice our Chase and Shoot states are not fully
    fleshed out yet. This is because we'll be implementing these states via concepts
    we'll cover in [Chapter 3](25db39aa-6768-453c-855d-9f075da0e83e.xhtml), *Implementing
    Sensors*, and [Chapter 4](503803fe-f343-4a0c-835f-463c98005182.xhtml), *Finding
    Your Way*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to implement state machines in Unity 2017 using
    animator and controller-based state machines for what will be our tank game. We
    learned about state machine behaviors and transitions between states. With all
    of these concepts covered, we then applied the simple state machine to an agent,
    thus creating our first artificially intelligent entity!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll continue to build our tank game and give our agent
    more complex methods for sensing the world around it.
  prefs: []
  type: TYPE_NORMAL
