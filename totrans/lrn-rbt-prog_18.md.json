["```py\n    3, to select USB speakers, which sets some basic defaults.\n    ```", "```py\n    $ git clone https://github.com/waveshare/WM8960-Audio-HAT.git\n    $ cd WM8960-Audio-HAT\n    $ sudo ./install.sh\n    ```", "```py\n    card 1: wm8960soundcard [wm8960-soundcard], device 0: bcm2835-i2s-wm8960-hifi wm8960-hifi-0 [bcm2835-i2s-wm8960-hifi wm8960-hifi-0]\n    ```", "```py\ncard 1: wm8960soundcard [wm8960-soundcard], device 0: bcm2835-i2s-wm8960-hifi wm8960-hifi-0 [bcm2835-i2s-wm8960-hifi wm8960-hifi-0]\n```", "```py\n    aplay command on device hardware 0,0 (the Pi headphone jack) – written as hw:0,0. This will be the wrong device. The second specifies it will play mp3 files using the mpg123 command and on the same incorrect device. Using a direct hardware device may make assumptions about the format of the sound being played, so it needs to go through the mixer device. Let's fix these.\n    ```", "```py\n       \"play_wav_cmdline\": \"aplay -Dplayback %1\",\n       \"play_mp3_cmdline\": \"mpg123 -a playback %1\",\n    ```", "```py\n    import subprocess\n    class RobotModes(object):\n    ```", "```py\n        mode_config = {\n            \"avoid_behavior\": \"avoid_with_rainbows.py\",\n            \"circle_head\": \"circle_pan_tilt_behavior.py\",\n            \"test_rainbow\": \"test_rainbow.py\"\n        }\n    ```", "```py\n        def __init__(self):\n            self.current_process = None\n    ```", "```py\n    subprocess is a way of running other processes and apps from within Python. We check whether we have a current process, and if so, whether it is still running. Processes have a return code, usually to say whether they completed or failed. However, if they are still running, it will be None. We can use this to determine that the robot is currently running a process.\n    ```", "```py\n    self.mode_config to map mode_name to a script name. We then use subprocess to start this script with Python. Popen creates a process, and the code stores a handle for it in self.current_process. This method returns True if we started it, and False if one was already running.\n    ```", "```py\n        def stop(self):\n            if self.is_running():\n                self.current_process.send_signal( subprocess.signal.SIGINT)\n                self.current_process = None\n    ```", "```py\n    from flask import Flask\n    from robot_modes import RobotModes\n    ```", "```py\n    app = Flask(__name__)\n    mode_manager = RobotModes()\n    ```", "```py\n    @app.route(\"/run/<mode_name>\", methods=['POST'])\n    def run(mode_name):\n        mode_manager.run(mode_name)\n        return \"%s running\"\n    ```", "```py\n    @app.route(\"/stop\", methods=['POST'])\n    def stop():\n        mode_manager.stop()\n        return \"stopped\"\n    ```", "```py\n    http for a web (hypertext) service. This is followed by a colon (:) and then two slashes // with a hostname or host address—the network address of the Raspberry Pi the resource will be on. As a host can have many services running, we can then have a port number, with a colon as a separator—in our case, :5000. After this, you could add a slash / then select a specific resource in the service.We can test this now:\n    ```", "```py\n    $ python3 control_server.py\n     * Serving Flask app \"control_server\" (lazy loading)\n     * Environment: production\n       WARNING: Do not use the development server in a production environment.\n       Use a production WSGI server instead.\n     * Debug mode: on\n     * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)\n    ```", "```py\n    curl -X POST http://myrobot.local:5000/run/test_rainbow\n    ```", "```py\n    IntentBuilder to build and define intents around vocabulary. MycroftSkill is a base class to plug our code into Mycroft. intent_handler marks which parts of our code are intents, associating the code with IntentBuilder. We import LOG to write information out to the Mycroft console and see problems there.The last import, `requests`, is a tool to talk to our control server in Python remotely.\n    ```", "```py\n    super calls a method from a class we've made our base; in this case, __init__ so we can let it set things up.The only setting we have is a `base_url` member for our control server on the robot. It is consulting a settings file, which we'll see later. It's usually a good idea to separate the configuration from the code.\n    ```", "```py\n    intent_handler decorator takes some parameters to configure the vocabulary we will use. We will define vocabulary in files later. We require a vocabulary matching *robot* first, then another part matching *TestRainbow* – which could match a few phrases.\n    ```", "```py\n    base_url variable, plus the run instruction and the test_rainbow mode.\n    ```", "```py\n    speak_dialog method tells Mycroft to pick something to say from dialog files, which allows it to have variations on things to say.\n    ```", "```py\n    Unable to reach the robot, while not inspecting the result code from the server other than if the voice skill contacted the robot.\n    ```", "```py\n    def create_skill():\n        return MyRobot()\n    ```", "```py\n{\n    \"skillMetadata\": {\n        \"sections\": [\n            {\n                \"name\": \"Robot\",\n                \"fields\": [\n                    {\n                        \"name\": \"base_url\",\n                        \"type\": \"text\",\n                        \"label\": \"Base URL for the robot control server\",\n                        \"value\": \"http://myrobot.local:5000\"\n                    }\n                ]\n            }\n        ]\n    } \n}\n```", "```py\nrequests\n```", "```py\n    robot in the intent handler.\n    ```", "```py\n    test rainbow\n    test the leds\n    deploy rainbows\n    turn on the lights\n    ```", "```py\n    The Robot\n    Robot\n    ```", "```py\n    is testing rainbows.\n    is deploying rainbows.\n    is starting rainbows.\n    is lighting up.\n    ```", "```py\n    Sorry I cannot reach the robot.\n    The robot is unreachable.\n    Have you turned the robot on?\n    Is the control server running on the robot?\n    ```", "```py\n    stop\n    cease\n    turn off\n    stand down\n    ```", "```py\n    is stopping.\n    will stop.\n    ```", "```py\n    stop vocabulary, the handler name (which could be anything – but must not be the same as another handler), and the URL endpoint. Identical code like that is ripe for refactoring. Refactoring is changing the appearance of code without affecting what it does. This is useful for dealing with common/repeating code sections or improving how readable code is. Both the intents have the same try/catch and similar dialog with some small differences. \n    ```", "```py\n    end_point as a parameter and uses that in its request. It takes a dialog_verb parameter to say after the Robot bit. All of the other dialog and error handling we saw before is here. \n    ```", "```py\n        @intent_handler(IntentBuilder(\"\")\n                        .require(\"Robot\")\n                        .require(\"TestRainbow\"))\n        def handle_test_rainbow(self, message):\n            self.handle_control('/run/test_rainbow', 'TestingRainbow')\n        @intent_handler(IntentBuilder(\"\")\n                        .require(\"Robot\")\n                        .require(\"stop\"))\n        def handle_stop(self, message):\n            self.handle_control('/stop', 'stopping')\n    ```"]