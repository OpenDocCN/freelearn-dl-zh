- en: Possibility and Probability Maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll be talking about possibility and probability maps, understanding
    how and where they are used. We'll also be learning the best practices for creating
    an AI that reacts to the player and that also chooses the best options, as we
    look to create a character that can make decisions as a human would.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw previously, video games used to rely heavily on predetermining the
    behavior of what the AI could do in different scenarios that were either created
    by the game itself or by the player's actions. This method has been present since
    day one and is still being used today, making it an extremely valuable method
    for creating quality AI characters. Before explaining, in detail, what each of
    the maps do, and before demonstrating how to create them in order to develop good
    AI behavior, it's always good to have a general idea of what possibility and probability
    maps are and where or when they are applied.
  prefs: []
  type: TYPE_NORMAL
- en: As gamers, we tend to enjoy the product as a whole, experiencing every part
    of the game with enthusiasm and dedication, forgetting about the technical aspects
    of the game. For that reason, we sometimes forget that even simple things that
    happen while we play were already destined to occur that way, and that there is
    a lot of thought and planning behind that moment. Everything happens for a reason,
    as we often hear, and this can also be applied to video games. From the moment
    you clicked the start button to begin the game to the last awesome combo that
    you performed to defeat the final boss of the game, everything was planned to
    happen and it was necessary for a programmer to input all of those possibilities
    within the game. If you clicked the A button and your character jumped, that happened
    because it was determined to be that way. The same thing is valid for AI enemies
    or allies on the game; when they do something to defeat or help you, it was necessary
    for that behavior to be programmed, and to do that we use states.
  prefs: []
  type: TYPE_NORMAL
- en: Game states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand how to create possibility or probability maps we need to first
    acknowledge the principle aspect necessary to create them, which is called game
    states, or simply states. We call game states to the actions that are predetermined
    throughout different occasions in the game, and those actions can be applied to
    both the player or to the enemy character. Some examples can be simple behavior,
    such as run, jump, or attack, and those states can be expanded a little more,
    for example when the character is in the air and cannot attack or if the character
    has low magical energy and cannot perform a magic attack. In these cases, the
    character goes from one state to another or can't perform one if it's doing another.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f20164ce-777f-4a79-b420-8764519d357a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Possibility maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's take a deeper look at the possibility maps that we encountered in
    the examples in the first chapter, from the chess machine to the Metal Gear Solid
    video game. As we can see, it's a technique that is still being used today, and
    it is almost impossible to create a game AI without it.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, possibility maps allow the programmer to define the possibilities
    available to the player or the AI character within the game. Everything that is
    possible inside the game needs to be planned and coded, but what happens when
    you allow the character to do a lot of things can they do them all at the same
    time? If played during different stages of the game, can they react in the same
    way at all of the stages? To allow, and restrain, the possible actions, we also
    need to think about the possible scenarios that can occur in the game, and when
    you put all of that together it's called a possibility map.
  prefs: []
  type: TYPE_NORMAL
- en: How to use possibility maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at a simple example of a common FPS game, and for that we'll
    be using the states demonstrated in the preceding image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we are the enemy character of the game and our goal is to shoot
    and kill the player using only the states walk, run, cover, jump, fire, and defend.
    We need to take into consideration that the player will do his best to kill us,
    and therefore a lot of possible scenarios may arrive. Let''s start with the basics
    we are walking from one point to another while protecting our space and as the
    player goes near that space, our goal changes from protecting our space to the
    definitive goal, that is, killing the player. What should we do next? Fire? Run
    towards the player and fire from close range? Cover and wait until the player
    is nearby? What if the player saw us first and is preparing to fire at us? A lot
    of things could happen, and a lot of things can be done with just a few states.
    So, let''s map every possible situation and plan how we should act or react in
    each individual situation. Examples that I would choose for my game are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Walk slowly to a cover position, wait for the player, and shoot him
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run for cover and then fire from that position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defend (moving away from the bullets) while running to a cover position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fire against the player, running towards him, and keep firing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the type of game that we want to create, we can use the same states
    to shape it into a different genre. We also need to take into consideration the
    personality of the character that we are programming. If it's a robot, it probably
    won't be afraid to keep firing against the player, even if the chances of getting
    destroyed are 99%. On the other hand, if it's an inexperienced soldier, it might
    feel reluctant to get shot and will run for cover instantly. The list goes on
    and on just by changing the personality of the character.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f529c32-3f20-45ac-acc6-e2a21ea8a524.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Preparing a possibility map (FPS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we are able to understand what a possibility map is and how it
    can be used to create an AI character that behaves accordingly to different situations
    in the game. Now that we understand how to use a possibility map, let's create
    a practical example where we programmed our AI character to successfully defeat
    the player. For this example, I'll be using two models, one represents the AI
    enemy that we are programming and the other one represents the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create a common example, where the AI is protecting the entrance of
    a building that the player needs to enter in order to deactivate a bomb and complete
    the level. Let''s imagine that we already have the player fully programmed and
    that we now need to focus on our AI enemy, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24955dfe-2bb8-4c0e-8882-d1bcea3aa25a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before writing any line of code we need to think about the possible situations
    that can occur and how our AI will react to them. First, we'll be simplifying
    the situation by breaking down our stages into a simple 2D visualization that
    will be used as a reference to determinate distances and other relevant parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/149af240-03a2-49ea-a485-6ad61c15d8af.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After simplifying the situation, we are ready to start planning the possibilities.
    The player is allowed to move around the building. Note that there's only one
    entrance, and that entrance is protected by our enemy AI. The arrows represents
    the direction that the characters are facing, and this will be an important aspect
    to our planning.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a possibility map (FPS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll learn how to create an awareness behavior for the AI character later,
    so for now we will just be using simple Boolean variables to determine if the
    player is near our position and what direction it is facing. Taking that into
    consideration, let's break our image into trigger zones to define when our enemy
    AI should react.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01e2e023-d664-4bd9-bbc0-dc7ea838a5b4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The YES zones represents the area that triggers our AI to change its behavior
    from the passive to offensive state. The NO zones represent the area that doesn't
    have an impact on our AI behavior. I've divided the YES zones into three because
    we want our AI character to react differently according to the player's position.
    If the player comes from the right side (YES R), the enemy has a wall that can
    be used for cover; if it comes from the left side (YES L), we can't use that wall
    anymore, and once the player is in the middle (YES M), the AI can only move backwards
    inside of the building.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s prepare our script for the enemy AI. In this example, we will use the
    C# language, but you can adapt the script to any programming language that you
    prefer, as the principles remains the same. The variables that we''ll be using
    for now are `Health`, `statePassive`, `stateAggressive`, and `stateDefensive`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know the basic information required for the AI, we need to think
    about when those states will be used and how the AI will choose between the three
    available options. For this, we'll use a possibility map. We already know the
    areas that trigger our character, and we have already chosen the three behavior
    states, so it's time to plan the transitions and reactions according to the player's
    position and behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/698e2d58-eabe-4ef8-9a74-7cab089b3652.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our enemy AI can go from **PASSIVE** to **DEFENSIVE** or **AGGRESSIVE**, from
    **AGGRESSIVE** to **DEFENSIVE**, and from **DEFENSIVE** to **AGGRESSIVE**, but
    once our AI knows that the player is around, it will never go back to the passive
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s define what triggers each state and how the AI should choose the correct
    state in different scenarios. The PASSIVE state will be the default state, and
    the game will start in that position until the player comes across our character.
    The DEFENSIVE state will be used in two different situations if the player comes
    from the right side and if he has already confronted the player and has low HP.
    Finally, the AGGRESSIVE state will be activated if the player comes from the left
    side or has already arrived at the middle area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We added the trigger variables `triggerL`, `trigger,` and `triggerM` and also
    defined when the AI should change from one behavior state to another. At this
    point, our enemy already knows what to do in different situations that may occur
    during gameplay according to the player's position.
  prefs: []
  type: TYPE_NORMAL
- en: Now we just need to determine what will happen on each state, because that is
    what differentiates a DEFENSIVE state from an AGGRESSIVE one. For this specific
    enemy, where his main function is to protect the entrance of the building, we
    want him to stay put at all times and to never run after the player. This is because
    the AI doesn't know that it is just one person and can't take the risk of going
    after just one soldier if there's a possibility of being greeted by several. This
    will help to give a little realism to the actions of the enemy. We'll also use
    the defensive behavior state for the moment where the enemy feels that it is losing
    the battle and is about to die, or when it has the advantage of using the building
    to protect itself while the player doesn't. Finally, the aggressive state will
    be used when the AI sees a clear advantage to kill or if it doesn't have any other
    options.
  prefs: []
  type: TYPE_NORMAL
- en: DEFENSIVE state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, let's start with the situation where the player comes from the right side
    and our enemy has already spotted him. We want our AI to take advantage of the
    wall that protects him, making it difficult for the player as well as demonstrating
    a human-like intention, rather than simply opening fire. The enemy will move towards
    the wall and stay there firing on the corner until the player arrives to that
    position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3cbaedea-1d79-4feb-846e-a9dcccc70426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The enemy will change from the PASSIVE state into the DEFENSIVE state, instead
    of OFFENSIVE, only because doing that gives him a slightly better advantage over
    the player. Being defensive on the first encounter shows some personality to the
    AI, which is very important when making the behavior of the computer character
    believable. In future chapters we''ll learn how to use the environment to help
    define our AI character in depth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We added the core for the `Defensive` state that we want to implement on our
    enemy AI when the player is coming from the right side. We also added new variables,
    such as `speed`, `cover`, `playerSoldier,` and `coverFire.` First, we need to
    check if the player is currently positioned in the `triggerR` zone; if the result
    is positive, the character should move towards the cover position. Once the enemy
    AI is at the cover position, he can start firing against the player (`coverFire`).
    Now let's input the following situation if the player is still alive, our enemy
    needs to move to another situation, otherwise it will be cornered, which isn't
    a good scenario for the character we are creating. Let's add that situation to
    our script.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want our character to walk back and get inside the building, while always
    facing the player and firing at the same time. We could use another tactic, or
    decide to be more aggressive and confront the player directly, but for now let''s
    stick to a simple strategy. We can add more complex behavior later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/03cc7346-5cc8-4368-af96-0a436bfab0ed.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this part of the code we added a situation where the player comes from the
    right side and is still alive going to the middle, so we needed to change the
    previous behavior to a new one. Our AI character goes from the cover position
    to a newer position that is inside the building, firing at the player the whole
    time. At this point, the enemy will keep getting back until one of the two characters
    die either the player or the AI character. We close the situation where the player
    comes from the right side. Now that we have completed this part, we need to complete
    the scenario and add the last situation, which is where the player goes around
    the building and comes from the left side. Our AI will need to adapt to these
    circumstances and behave differently, so let's work on that part and complete
    the example.
  prefs: []
  type: TYPE_NORMAL
- en: AGGRESSIVE state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we started programming, we defined how many states we would need for
    this enemy AI, and we chose three different states: PASSIVE, DEFENSIVE, and AGGRESSIVE.
    Now that we already have the two behavior states in place (passive and defensive),
    there is just one more needed to complete our enemy AI, that is, to protect the
    building.'
  prefs: []
  type: TYPE_NORMAL
- en: We previously decided that the character would only directly confront the player
    if he couldn't use the wall as cover, and that moment is where the player comes
    from the left and the enemy is surprised with its presence.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7626b687-89fb-4680-8d7b-f657d9c0a1cc.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once again, we need to first check if the player triggered the left area, as
    that will activate our enemy AI from the PASSIVE state into the AGGRESSIVE state
    we intended. Then, we need to define what he should do in that case. Let''s start
    writing it in our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This time we added our two possible situations when attacking a player that
    comes from the left; the first is if the player comes from the left and continues
    towards the enemy, or remains in the same position. The second situation that
    could occur is if the player soon retreats as soon as he sees the enemy, and in
    that scenario we have chosen to make the enemy search for the player, going towards
    the `triggerL` position where initially the player appeared.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the completed script, written using the possibility map example that
    we''ve been working on in this chapter. Let''s take a look at the full script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous block of code, we can see all of the variables that have been
    used in our script so far. The rest of the script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Possibility map conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have finally completed our first possibility map example. The principles
    that were shared in this chapter can be used in a wide range of game genres. In
    fact, almost any game that you plan to create in the future can greatly benefit
    from a possibility map. As we saw, this technique is used to plan every situation
    that the player can create, and how the character AI should behave according to
    that. By planning this carefully we can avoid a lot of issues in gameplay, as
    well as a lack of diversity regarding the character AI behavior. Another interesting
    point that is worth mentioning is to try to create a different Possibility Map
    for different characters of the game, as not all humans react equally. A computer
    AI should follow that same rule.
  prefs: []
  type: TYPE_NORMAL
- en: Probability maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A probability map is a more complex and detailed version of a possibility map
    because it relies on probabilities in order to change the behavior of the character,
    rather than a simple on or off trigger. Its similarity with the possibility map
    is that it's also required for planning ahead the possible states for our character.
    This time, however, we add to it a percentage, using which the AI will calculate
    what behavior he will be using. Imagine the next example using the situation that
    we previously created for the possibility map our enemy AI could be more aggressive
    in the daytime than at night. For that, we create a statement that explains to
    our enemy that if it's night time, there is a lesser chance of seeing the player
    character, and for that reason it will choose a more defensive approach instead
    of an aggressive one. Or, simply, we could define that our enemy calculates the
    probability of killing the player simply based on the distance between the two
    characters. If the player gets closer to the enemy, the probability of the AI
    getting back and surviving are lesser than if he keeps firing against the player,
    so we can add that equation into the AI.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at our human behavior, the choices we make; usually, we make
    our decision by taking into consideration past events and what we've done before.
    When we feel hungry and we decide to go out for dinner, can our friend guess which
    restaurant we have chosen? Our friend may have calculated the probability of our
    choice and given their answer by taking into consideration the higher percentage
    chance. That's exactly what we need to do to our AI friend; we need to assign
    some probabilities to his choices, such as what's the probability of the AI character
    falling asleep while protecting the building during the day and during the night?
    What's the probability of the enemy running if he has low hp? If we apply probability
    to our AI character, it helps to create that unpredictable behavior that humans
    have and makes the game more engaging and natural.
  prefs: []
  type: TYPE_NORMAL
- en: How to use probability maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll continue using the same scenario that we created before,
    where our AI guard is protecting a building that contains an atomic that the player
    needs to deactivate. The only entrance to the building is protected by our AI
    character.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine that we are the guard and we have orders to stay there for 16
    hours straight we would probably need to eat, drink, and move a little bit to
    be able to stay active and alert the whole time. We will therefore add that to
    our character, making it more unpredictable for the player. If the AI decides
    to eat or drink, he will be inside the building, and if he decides to walk a little
    bit he will be patrolling from the `triggerL` to `triggerR` position. Most of
    the time, he will be just standing on his guard position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/152524bc-c191-41d3-878d-bcd6318ef28e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a probability map, and here we define the percentage of each state that
    our character exists in. It means that every time the player sees the enemy AI,
    the enemy can be doing one of those things. This will differ greatly when you
    take into consideration the time of day at which the player decided to appear.
    If the player arrives in the morning, it has an **0.87** chance of finding the
    enemy in a guard position in front of the building, a **0.10** chance of finding
    him eating or drinking inside the building, and finally a **0.03** chance of finding
    him walking outside from one point to another. If the player arrives in the afternoon,
    it has a **0.48** chance of finding the enemy in a guard position in front of
    the building, a **0.32** chance of finding him eating or drinking inside the building,
    and finally a **0.2** chance of finding him walking around from one point to another.
    At night, the player has a **0.35** chance of finding the enemy in the guard position,
    a **0.40** chance of finding him eating or drinking inside the building, and a
    **0.25** chance of finding the enemy walking around.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c25d3452-5650-45ae-9c47-5ce7ca04030c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This will help to create that unpredictable aspect to our character by not making
    it as obvious that he will be in the same position every time you play the level.
    We can also update this probability every five minutes or so, in case the player
    stays still, waiting for our enemy to change position. This technique is used
    in a lot of games, but especially in stealth games, where observation is key.
    This is because the player has the opportunity to stay in a safe position and
    observe the enemy behavior, similar to heist movies, where actors wait for the
    guards to change shifts before getting inside the bank. Because of this popular
    behavior that we're used to seeing in movies, players like to feel that same sensation
    in games, and so probability maps have changed the way how we play.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of how probability can be used in a script is as follows. For this,
    I''ve used the `Passive` state and added the probability that we previously decided
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To calculate the percentage, we first need to create a random number from `0`
    to `100`, and then we create a statement that will use that number to check to
    which statement it belongs. On the first statement, for example, we have an `87%`
    chance of the AI staying in the guard position, so if the random number is higher
    than `13`, it fits within this category and the character is made to stay in the
    guard position. A number higher than `3` and equal or less than `13`, gives us
    a `10%` of chance, and a number equal or less than `3` gives us a `3%` chance.
  prefs: []
  type: TYPE_NORMAL
- en: Where to go from here
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand how to use a probability and possibility map, a pertinent
    question that we might question ourselves is, what can we do with this? Well we
    saw how important is to use a possibility map to define the behaviors of a character
    and how the probability helps to make those behaviors unpredictable, but we can
    do a lot more with what we learned depending on the type of game that we are creating
    or the type of AI that we want. Remember that flaws makes part of what we are
    as humans and we are surrounded by probabilities, even if it's just *0*,*000001%*
    the probability of happening the unexpected exists that's why no one is perfect,
    so it's a fun fact to remember when creating an AI character, giving them some
    probability of human stuff happening, or simply making good or bad decisions,
    that builds a personality to the computer character that you are creating.
  prefs: []
  type: TYPE_NORMAL
- en: Another special thing that we can do with probability maps, is giving the AI
    the opportunity to learn from himself, making him smarter every time the player
    decides to play the game. Both the player and the enemy AI will learn, making
    the challenge always updated according to the hours spent on the game. If the
    player has the tendency to use the same weapon or coming from the same direction,
    the computer should update that information and use it on future events. If the
    player confronted the computer *100* times and *60%* of those times he used a
    grenade, the AI should have that in mind and react according to that probability.
    That will push the player to think in other strategies, also not being so obvious
    exploring other ways of defeating the enemy.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has described possibility and probability maps and we have learned
    how to let the AI make decisions for itself according to the player actions. Possibility
    and probability maps is the foundation of an AI character and now we can explore
    this technique to create new and unique artificial intelligence for our games.
    In the next chapter, we'll learn how the AI should behave according to the different
    options that it has on that moment instead of using a possibility map. We want
    the character to analyze the situation and think about what to do, taking in consideration
    many factors, such as health, distance, weapon, bullets, and any other relevant
    factors.
  prefs: []
  type: TYPE_NORMAL
