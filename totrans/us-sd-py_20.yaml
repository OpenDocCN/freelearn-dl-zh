- en: '20'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Interactive User Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we used only Python code and Jupyter Notebook to achieve
    various tasks using Stable Diffusion. In some scenarios, we need an interactive
    user interface not only for easier testing but also for a better user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine we have built an application using Stable Diffusion. How can we publish
    it to the public or non-technical users to try it out? In this chapter, we are
    going to use an open sourced interactive UI framework, Gradio [1], to encapsulate
    diffusers code and provide a web-based UI, using only Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter won''t delve into every aspect of Gradio usage. Instead, we''ll
    focus on giving you a high-level overview of its fundamental building blocks,
    all with a specific goal in mind: demonstrating how to construct a Stable Diffusion
    text-to-image pipeline using Gradio.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Gradio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gradio fundamentals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a Stable Diffusion text-to-image pipeline with Gradio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Gradio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gradio is a Python library that makes it easy to build beautiful, interactive
    web interfaces for machine learning models and data science workflows. It is a
    high-level library that abstracts away the details of web development so you can
    focus on building your model and interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The A1111 Stable Diffusion Web UI that we mentioned several times in previous
    chapters uses Gradio as the user interface, and many researchers use this framework
    for a quick demo of their most recent work. Here are some reasons why Gradio is
    the prevailing user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Easy to use**: Gradio’s simple API makes it easy to create interactive web
    interfaces in just a few lines of code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexible**: Gradio can be used to create a wide variety of interactive web
    interfaces, from simple sliders to complex chatbots'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensible**: Gradio is extensible, so you can customize the look and feel
    of your interfaces or add new features'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open source**: Gradio is open source, so you can contribute to the project
    or use it in your projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another feature of Gradio that doesn’t exist in other similar frameworks is
    that Gradio interfaces can be embedded in Python notebooks or presented as standalone
    web pages (you will find out why this notebook embedding feature is cool when
    you see it).
  prefs: []
  type: TYPE_NORMAL
- en: If you have been running Stable Diffusion using diffusers, your Python environment
    should be ready for Gradio. In case this is the first chapter of your reading
    journey, make sure you have Python 3.8 or a higher version installed on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what Gradio is, let’s learn how to set it up.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Gradio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn about the bare minimum setup needed to spin
    up a Gradio application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Gradio using `pip`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Please also ensure you update the following two packages to the newest version:
    `click` and `uvicorn`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a Jupyter Notebook cell and write or copy the following code in the
    cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Executing it will not pop out a new web browser window. Instead, the UI will
    be embedded inside the Jupyter Notebook result panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you can copy and paste the local URL – `http: //127.0.0 .1:78 60`
    – to any local browser to view it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Be aware that the next time you execute the code in another Jupyter Notebook''s
    cell, a new server port will be allocated, such as `7861`. Gradio won’t take back
    the assigned server port automatically. We can use one additional line of code
    – `gr.close_all()` – to ensure all liveports are released before the launch. Update
    the code as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Both the code and the embedded Gradio interface will be shown in *Figure 20**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.1: Gradio UI embedded in Jupyter Notebook cell](img/B21263_20_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.1: Gradio UI embedded in Jupyter Notebook cell'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the Jupyter Notebook is running in Visual Studio Code. It also works
    in Google Colab or independently installed Jupyter Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can start a Gradio application from the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a web application in Jupyter Notebook is good for testing and proof
    of concept demonstration. When deploying an application, we’d better start it
    from the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `gradio_app.py`, and use the same code we used in
    *step 2*. Use a new port number, such as `7861`, to avoid conflict with the already
    used `7860`. Then launch the application from the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That is all set. Next, let’s gain some familiarity with the fundamental building
    blocks of Gradio.
  prefs: []
  type: TYPE_NORMAL
- en: Gradio fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding sample code is reformed from the Gradio official quick start tutorial.
    When we look at the code, lots of details are hidden. We don’t know where the
    `Clear` button is, we don’t specify the `Submit` button, and we don’t know what
    the `Flag` button is.
  prefs: []
  type: TYPE_NORMAL
- en: Before using Gradio for any serious applications, we need to understand every
    line of code and ensure every element is under control.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using the `Interface` function to automatically provide the layout,
    `Blocks` may provide a better way for us to add interface elements with explicit
    declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Gradio Blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Interface` function provides an abstraction level to easily create quick
    demos, but there is an abstraction layer. Easy comes with a price. `Blocks`, on
    the other hand, is a low-level approach to lay out elements and define data flows.
    With the help of `Blocks`, we can precisely control the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The layout of components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The events that trigger actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The direction of the data flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example will explain it better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will produce an interface as shown in *Figure 20**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.2: Stack Gradio UI using Blocks](img/B21263_20_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.2: Stack Gradio UI using Blocks'
  prefs: []
  type: TYPE_NORMAL
- en: All elements under `Blocks` will be shown in the UI. The text for the UI elements
    is defined by us too. In the `click` event, we defined the `fn` event function,
    `inputs`, and `outputs`. Finally, launch the application using `demo.launch(server_port
    =` `7860)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In line with one of Python’s guiding principles: “*Explicit is better than
    implicit*”, we strive for clarity and simplicity in our code.'
  prefs: []
  type: TYPE_NORMAL
- en: Inputs and outputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code in the *Gradio Blocks* section uses only one input and one output.
    We can provide multiple inputs and outputs, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown in *Figure 20**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.3: Gradio UI with multiple inputs and outputs](img/B21263_20_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.3: Gradio UI with multiple inputs and outputs'
  prefs: []
  type: TYPE_NORMAL
- en: Simply stack the element under `with gradio.Blocks() as demo:` and provide inputs
    and outputs in `list`. Gradio will automatically take the values from the inputs
    and forward them to the `greet` bind function. The outputs will take the return
    tuple value from the associated function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, replace the elements with a prompt and output image components. This approach
    can be applied to build a web-based Stable Diffusion pipeline. However, before
    proceeding, we need to explore how to integrate a progress bar into our interface.
  prefs: []
  type: TYPE_NORMAL
- en: Building a progress bar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use a progress bar in Gradio, we can add a `progress` argument to the associated
    event function. The `Progress` object will be used to track the progress of the
    function, and it will be displayed to the user as a progress bar.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example of how to use a progress bar in Gradio.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we manually update the progress bar with `progress(i/10,
    desc=f"{i}")`. After each sleep, the progress bar will move forward 10%.
  prefs: []
  type: TYPE_NORMAL
- en: After clicking the **Run** button, the progress bar will appear in the position
    of the output textbox. We will use a similar approach to apply the progress bar
    for the Stable Diffusion pipeline in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Stable Diffusion text-to-image pipeline with Gradio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With all preparations ready, now let’s build a Stable Diffusion text-to-image
    pipeline with Gradio. The UI interface will include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A prompt input box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative prompt input box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A button with the `Generate` label
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A progress bar when the `Generate` button is clicked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An output image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code that implements these five elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we first launch the `text2img_pipe` pipeline to VRAM,
    followed by creating a `text2img` function, which will be called by the Gradio
    event button. Note the `lambda` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We will pass the progress bar into the diffusers denoising loop. Each denoising
    step will then update the progress bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the code is the Gradio elements `Block` stack. The code also
    gives Gradio a new theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now you should be able to run the code and generate some images in both Jupyter
    Notebook and any local web browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The progress bar and the result are shown in *Figure 20**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.4: Gradio UI with progress bar](img/B21263_20_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.4: Gradio UI with progress bar'
  prefs: []
  type: TYPE_NORMAL
- en: You can add more elements and features to this sample application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing this chapter (December 2023), there isn’t much information
    or sample code to help us get started using diffusers with Gradio. We wrote this
    chapter to help quickly build up a Stable Diffusion application in Web UI so that
    we can share the result with others in minutes without touching one line of HTML,
    CSS, or JavaScript, using pure Python throughout the building process.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduced Gradio, what it can do, and why it is popular. We didn’t
    touch on every bit of Gradio; we believe that its official document [1] does this
    job better. Instead, we used a simple example to explain the backbone of Gradio
    and what we need to prepare to build a Stable Diffusion Web UI with Gradio.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we introduced `Blocks`, `inputs`, `outputs`, the progress bar, and
    event bindings all together and built up a tiny but fully functioning Stable Diffusion
    pipeline in Gradio.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will delve into a relatively complex topic: model fine-tuning
    and LoRA training.'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Gradio: Build Machine Learning Web Apps — in Python: [https://github.com/gradio-app/gradio](https://github.com/gradio-app/gradio)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Gradio QuickStart: [https://www.gradio.app/guides/quickstart](https://www.gradio.app/guides/quickstart)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
