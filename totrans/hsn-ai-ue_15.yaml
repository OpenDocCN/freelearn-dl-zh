- en: Debugging Methods for AI - Navigation, EQS, and Profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to [Chapter 12](a60155c1-2bb0-403f-bdcf-dbd6a9c67824.xhtml), *Debugging
    Methods for AI – Navigation, EQS, and Profiling*.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are going to explore some more specific tools for the AI systems that
    are built-in within Unreal Engine. We will focus on **Navigation** and **EQS**,
    covering what we have left out (because it was debugging and/or visualization
    related) respectively from [Chapter 3](fe5b7602-fcb4-4d39-bf8c-e1742909205a.xhtml), *Navigation*
    and [Chapter 4](1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml), *Environment Querying
    System*.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, we will see some more tools for analyzing performance
    related to AI code. In the next chapter, we will complete the discussion by exploring
    the **Gameplay Debugger** as a way to have a quick real-time feedback for our
    AI.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking the execution of a behavior tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing environmental queries with the EQS testing pawn and exploring how
    its settings can help to better understand the query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the EQS profiler to spot queries that have performance issues and
    how to dive deeper to understand what causes the bad performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing the navigation mesh and how it works under the hood
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the navigation test actor to check the path between two points of the
    navigation mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling by using **AI Stat Groups** to gather useful information regarding
    the performance of the AI systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a **Custom Stat Group**, to be able to analyze performance of your
    customized AI systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Debugging behavior trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before jumping into the rest of the chapter, we should learn how to debug behavior
    trees. Actually, there are many methods, and some we will explore later in this
    chapter (with stats) and in the next one (such as the gameplay debugger).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, I wanted to point out that it is possible to see the execution of
    a behavior tree. If you leave the behavior tree editor open while you play the
    game, you will see highlighted the current branch being executed on the behavior
    tree, and which decorators are blocked. Also, in the blackboard panel, it is possible
    to check the current values for each of the blackboard values. Here is an example
    from the designing behavior trees project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42ab7ec3-d0c3-401a-8896-78021f9433e7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, if you have more than one **enemy** running a behavior tree, you can
    change which one to view from the top menu, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/040c6342-c15c-4a20-978e-067a8eb6c95f.png)'
  prefs: []
  type: TYPE_IMG
- en: In the same way, it is possible to see the execution of blueprints as well.
    This is not strictly related to AI, but it was worthwhile mentioning it in an
    infobox.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling and visualizing environmental queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore how to visualize and profile **Environmental
    Queries**. In fact, we will gain a better understanding of how the EQS testing
    pawn can visualize an **Environment Query**, and we will explore the **Profiler**
    tool, which allows us to check the performance for each query.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing environmental queries with the EQS testing pawn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As anticipated back in [Chapter 4](1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml),
    *Environment Querying System*, there is a simple built-in way to visualize environment
    queries within the game world, directly from the viewport; the game doesn't even
    have to be running. In fact, there is a special pawn that it is able to do that.
    However, this pawn cannot be brought directly into the level, because, to ensure
    that it is not misused, it has been declared virtual within the code base. This
    means that in order to use it, we need to create our own blueprint pawn that inherits
    directly from this special pawn.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, after this step, the pawn is fully featured, and it doesn't need
    any more code, just the parameters to work with (for example, the environmental
    query you want to visualize).
  prefs: []
  type: TYPE_NORMAL
- en: You will need the environment-querying system to be enabled, check [Chapter
    4](1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml), Environment Querying System, to
    see how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: If you already have created the EQS testing pawn back in [Chapter 4](1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml),
    *Environment Querying System*, feel free to skip the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the EQS testing pawn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start, create a new blueprint; the class to inherit from is **EQSTestingPawn**,
    as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19340aa3-643f-44ec-99ca-70510d0c24aa.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, you can rename it **MyEQSTestingPawn**, or if you already have done this
    in [Chapter 4](1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml), *Environment Querying
    System*, you can either skip this part, or give it another name.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you just drag it into the map from the **Details** panel, you can change
    the EQS settings, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/daed137f-9ebd-460d-b793-8d9d69e2d505.png)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 4](1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml), *Environment Querying
    System*, we got this far, but now that we have some more time for debugging, let's
    dive in deeper.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test environmental query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need an **Environmental Query** to perform, in order to visualize what''s
    going on with the different settings. As such, we need to prepare a simple query
    that generates points in a grid, and then score them based on the distance from
    the **Querier**. So, let''s build the environmental query, as shown in the following
    screenshot (within the EQS editor):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/767467e2-d6c6-4bf9-bf33-a33f67fefdfa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are going to leave the default settings, but for your convenience, this
    is how a simple grid generator looks in the **Details**panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5ef130e-95d6-4f36-8660-3d6435f8ad1e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the **Distance Test**, instead, we are going to leave mainly the default
    values, but for showcase purposes, we can change the **Filter **settings, so that
    **Float Value Min** and **Float Value Max** are respectively 200 and 1,000\. As
    a result, we will be able to filter out the points that are too close to the querier,
    and see how the EQS testing pawn visualizes these points:'
  prefs: []
  type: TYPE_NORMAL
- en: Settings of the EQS testing pawn to visualize environmental queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s explore the settings we have seen in the **Details**panel of our **MyEQSTestingPawn**.
    For your convenience, here is the screenshot of the settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/acb1aad9-0eb8-4a63-b4c6-2a235497b4b9.png)'
  prefs: []
  type: TYPE_IMG
- en: Remember that you need to select the testing pawn in the level in order to visualize
    the query (and also a query template must be set).
  prefs: []
  type: TYPE_NORMAL
- en: '**Query Template**: As the name suggests, it is the **Environmental Query**
    that we want to visualize.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**QueryParams_DEPRECATED**: (*don''t use this*) This was the old way to set
    parameters for the environmental query; now please use **Query Config**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Query Config**: It is an array that allows you to quickly change the settings
    of the **Environmental Query** for rapidly testing and debugging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Highlight Mode**: It determines which locations (or items) should have a
    visual representation that is highlighted, which means having a big sphere, instead
    of a small one. The possible values that can assume are the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**All**: This means that all the locations or items are highlighted, and it
    is the default option; so it appears exactly as shown in the following screenshot,
    which is also how it appears by default once we set the **Query Template**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/2cb8774a-4889-4385-ae15-703afeaa9609.png)'
  prefs: []
  type: TYPE_IMG
- en: Viewport. This is an image of the viewport. The other (overlapped) information
    is not important here
  prefs: []
  type: TYPE_NORMAL
- en: '**Best 5%**: As the name suggests, it shows just the points that have a score
    so that it is within the best 5% score of all the points. All the other points
    will have a smaller sphere:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/e2e05b1f-7b2d-4c97-bbe1-8c9552936257.png)'
  prefs: []
  type: TYPE_IMG
- en: Viewport. This is an image of the viewport. The other (overlapped) information
    is not important here
  prefs: []
  type: TYPE_NORMAL
- en: '**Best 25%**: As the previous option does, it shows just the points that have
    a score so that it is within the best 25% scores of all the points. All the other
    points will have a smaller sphere:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/643ab23a-c080-4d09-96b7-103976a2babc.png)'
  prefs: []
  type: TYPE_IMG
- en: Viewport. This is an image of the viewport. The other (overlapped) information
    is not important here
  prefs: []
  type: TYPE_NORMAL
- en: '**Draw Labels**: If checked, it shows next to the point its score. If a point
    has been filtered out instead, it shows which test has filtered that point out.
    In our example, the points closer to the querier have been filtered out by the
    **Distance Test**. This option is enabled by default; if we turn it off.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Draw Failed Items**: If checked, it shows also the points that have been
    filtered out. It is enabled by default, and if we turn it off, in our example,
    we would see the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/a33ec4d8-10a2-4eb8-a824-915b17e0ec84.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Rerun Query Only on Finished Move**: If checked, it will perform the query
    only when this testing pawn stops moving, and not all the time. It is enabled
    by default, and for performance reasons, you should keep this on, unless you need
    to visualize the query also when the testing pawn moves:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/d836529e-48c5-47f0-8d11-da79274e0913.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Should Be Visible In Game**: if checked, it will show the testing pawn as
    a small icon in the game, as in this screenshot; it is disabled by default:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/bf91cc9b-7c30-447c-9265-323ef6daa805.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Tick During Game**: As the name suggests, if it is checked, it allows ticking
    during the execution of the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Querying Mode**: Determines which is the final result of the query, and it
    has many possible options:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**All Matching**: This is the default option; it shows all the points that
    match the query (the ones in blue have been filtered out). Moreover, the points
    are color-coded from orange to green based on the score, with green being the
    highest score of 1:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/5e31d31c-0e5a-443b-93d0-07da2c9c51bd.png)'
  prefs: []
  type: TYPE_IMG
- en: Viewport. This is an image of the viewport. The other (overlapped) information
    is not important here
  prefs: []
  type: TYPE_NORMAL
- en: '**Single Best Item**: Shows the point that has the highest score (hence the
    best one) in green, and all the others in a darker shade of green (the ones that
    have been filtered out are still in blue):'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/4666fd57-8cb2-4f83-a53b-18cec5c794cb.png)'
  prefs: []
  type: TYPE_IMG
- en: Viewport. This is an image of the viewport. The other (overlapped) information
    is not important here
  prefs: []
  type: TYPE_NORMAL
- en: '**Single Random Item from Best 5%**: It shows (or returns) a random point among
    the best 5% of the points that have scored the highest. In the next example, a
    random one has been picked:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/beffb16f-3f05-4f6b-b996-558eec866529.png)'
  prefs: []
  type: TYPE_IMG
- en: Viewport. This is an image of the viewport. The other (overlapped) information
    is not important here
  prefs: []
  type: TYPE_NORMAL
- en: '**Single Random Item from Best 25%**: It shows (or returns) a random point
    among the best 25% of the points that have scored the highest. In the next example,
    a random one has been picked:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/e91ebb2f-1b07-49b5-9642-d3fb8bb856d5.png)'
  prefs: []
  type: TYPE_IMG
- en: Viewport. This is an image of the viewport. The other (overlapped) information
    is not important here
  prefs: []
  type: TYPE_NORMAL
- en: '**Nav Agent Properties**: Since some **Environmental Queries** depend on the
    navigation system, as we have seen, then this set of options let you tweak how
    the agent that performs the query appears to the navigation system. We are not
    going into detail regarding those, but here are the possible options:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/916d3bd3-03ec-4fab-bd50-a5abe5621277.png)'
  prefs: []
  type: TYPE_IMG
- en: And that concludes our discussion about visualizing environmental queries with
    the testing pawn. However, there is more about EQS in the next section, where
    we will see how we can profile an environmental query to check its performance,
    and in the next chapter, we will see how to visualize an environmental query at
    run time with the gameplay debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling environmental queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how we can quickly profile environmental queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that in the EQS editor, next to the **Details** panel,
    there is a **Profile** tab, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37808d96-dcc5-41f0-b091-bf6bf0ba457a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we click on it, we will have a whole new section in which we will be able
    to quickly profile environmental queries. At the moment, it is empty, because
    the game is not running, and no environmental query is performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2002efa5-2284-4dad-8b88-eec81cafcdaa.png)'
  prefs: []
  type: TYPE_IMG
- en: If we have already have some queries running in the game, we could just press
    **Play** and come back to this menu with all the queries that are currently running.
    However, if you don't have any in your game, we could quickly create a behavior
    tree to run some queries, making this behavior tree run on an AI controller and
    finally assign this AI controller to some AI agent in the game. Since we have
    done this many times in the book, I'm not going to guide you step by step. However,
    the next section will provide an overview of the process, if you want to follow
    along. Otherwise, feel free to skip the next section, and go directly to the *Environmental
    query profiler* section.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the test assets for EQS profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to create the environmental queries; you should already have
    these in the game since you would have been using them, but if you just want to
    test this profiling tool, create a couple of queries, for instance, **EnvQueryA**
    and **EnvQueryB**. I made the first query heavier than usual (many points generated)
    so that it stood out in the Profiler later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df3b2491-299e-4253-bcff-a63d2369b80e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we need to create a blackboard asset for the behavior tree; we can name
    it **BB_EQSTesting** and we just need a vector key inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7eef7c9a-bc24-41b1-a952-b06f9bd3f7b4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we can create the behavior tree that runs the queries. Name it `BT_EQSTesting`,
    and assign within it the blackboard. Then, we can run the two queries one after
    another with a sequence node (along with a little delay). Remember to assign the
    query to the `Run Query` node, and use the vector key from the blackboard (so
    the query doesn''t fail). The run mode should be by default set to `Single Best
    Item`; be sure that it is the option you have. Here is the behavior tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76c1f3d4-9dae-4798-9bfa-753a2926f473.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we need an AI controller; for simplicity, we can create it in Blueprint
    and name it **B***P_EQSTestingAIController*. Override the **On Possess** function,
    and run the b*ehavior tree*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd15afe8-1463-42ef-baa0-9748355642d7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, create an AI agent in the level (you can duplicate the player if you
    start form the **Third-Person** **Example Map**) and assign the freshly created
    AI controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe4edd70-3fa6-4e88-bcaa-a695837da3d9.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we are ready to see the profiler in action!
  prefs: []
  type: TYPE_NORMAL
- en: The environmental query profiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you reach this far, you should press Play and have an environmental query running
    in your game. If so, when the game is running, the Profiler tab of the EQS editor
    will get filled with all the environmental query  running, and it shows stats
    for them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/029c04ca-1423-48f6-8d7d-8a0eaa212241.png)'
  prefs: []
  type: TYPE_IMG
- en: For each query type, the profiler shows the number of times it got executed,
    the maximum time taken from the worst of these queries, and their average time.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, **EnvQueryA **is very heavy (because I designed it so), and
    the profiler helps you understand which one needs to be changed/improved or even
    removed. Also, we will see red because it's run time is very bad. For **EnvQueryB**,
    we would see any of these things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, the profiler divides the queries based also on the run mode. In the
    following screenshot, **EnvQueryB** has two entries, based on whether the run
    mode was **Single Result** or **All Matching**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/537d7993-557e-4691-bdf2-6160b603cf37.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, when you see the Profiler tab, you have the EQS editor opened on
    a specific query. Thus, at the bottom of the profiler, there is some more information
    about the query whose EQS editor is currently opened. In fact, we can see a graph
    showing the **Load of EQS tick budget** (how heavy was its tick) for the query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, at the top, there is the number of how many types of queries have
    been recorded so far and a checkbox named **Show details for current query**.
    If we check this box, we will be able to see directly on the environmental query
    tree the worst andthe average time for each generator (and its pick rate), and
    for each test, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5887d2de-4d32-4599-a7b1-d5a4aa0f08f0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It is color-coded here as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Red** means a very bad performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Yellow** means an intermediate performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Green** means that the performance is good.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Again, the **EnvQueryA **has been designed to perform badly to showcase the
    profiler*.* If we pick **EnvQueryB**, we see that it performs much better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8fcdf660-d092-41ed-b118-86128ffcd1c5.png)'
  prefs: []
  type: TYPE_IMG
- en: As a result, this peak into each single generator and each test allows you to
    dive deeper into which part of your environmental query is actually performing
    badly. So, you can use the profiler to identify which queries have problems, and
    then dive deeper into those that need to be optimized.
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading EQS stats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another cool feature of profiling environmental queries is that you can save
    your stats and load them again. This gives you powerful and flexible tools to
    share your findings with the rest of your team.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to save an EQS stat, you just need to press the **Save Stats** button
    in the top menu, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/478ac278-3c34-43e6-a7a4-f7b6c93cb47a.png)'
  prefs: []
  type: TYPE_IMG
- en: You will be prompted to choose a location to save the file containing your stats.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading is easy as well. Just press the **Load Stats** button in the top menu,
    as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df3d41fc-2b3e-4280-b688-2dfc43d43ebe.png)'
  prefs: []
  type: TYPE_IMG
- en: You will be prompted to choose a file containing your EQS stats, and after that,
    all your stats will be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and visualizing the navigation mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore some built-in tools to test and visualize the
    **Navigation Mesh**.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, we will see how it is possible to visualize the navigation mesh
    under the hood and how the navigation test actor can quickly show us "the way"
    (the path generated by the pathfinding algorithm).
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing the navigation mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned back in [Chapter 3](fe5b7602-fcb4-4d39-bf8c-e1742909205a.xhtml),
    *Navigation*, when we generated a **Navigation Mesh**, for instance, by bringing
    into the map the **Nav Mesh Bounds Volume**, we also created a **RecastNavMesh-Default**
    actor in the level. If we select it, we can see many options there are to generate
    the navigation mesh, and some of them we already explored. However, we have a
    whole section about **Display Settings** that back in [Chapter 3](fe5b7602-fcb4-4d39-bf8c-e1742909205a.xhtml),
    *Navigation*, we didn''t have the time to explore properly. Thus, let''s quickly
    go through these settings; here, for your convenience, is a screenshot of the
    display settings in the **Details **panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc289894-ff12-4a2f-b1ba-503b765764b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With the default settings, this is how it looks like (in our example map):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea96938b-bbf6-4bc8-87c6-2e5f14011bd2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have a lot of them, so without going too much into the details, let''s dive
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: To fully understand all of the options, you should be familiar with how the
    navigation mesh is generated. However, covering this is outside the scope of this
    book. In any case, you can still play with the settings and learn some more about
    the navigation system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Draw Triangle Edge**: Shows the triangles of which the nav mesh is made.
    Ultimately, the connections of these triangles will generate a graph on which
    **Pathfinding** algorithms will run (actually, it is more complicated than that,
    since the system needs to scale for bigger worlds, and a hierarchical pathfinding
    is used on different graphs at different levels). By enabling this option, you
    can actually see the nodes of this graph:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/0368e37f-5dca-4204-b91e-ba92b472cdf6.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Draw Poly Edges**: Shows the edges of the polygons. In fact, the nav mesh
    is generated starting from sectioning the level in polygons, and if a polygon
    contains complex geometry (for example, there are static meshes), the algorithm
    subdivides the polygon into smaller polygons based on the geometry. Then, these
    polygons get divided into triangles (the one we have seen before). With this option
    enabled, you are able to see which are the polygons for this static mesh, and
    if you leave the previous option on, you can see clearly see how all of these
    polygons have been divided into triangles:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/20598dbc-d040-4005-bb0c-e58d4593a1d9.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Draw Filled Polys**: If checked, it shows the polygon filled with the usual
    green we have already seen; in fact, this option is on by default. However, if
    we disable it, we can have a clearer look at the *bare bones* of the nav mesh:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/98e9b333-1c82-46d4-a3cc-3a321e9b7d3b.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Draw Nav Mesh Edges**: If checked (and it is by default), it shows the edge
    of the nav mesh. In the following screenshot, this is how it looks with this option
    turned off:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/50567abc-8024-4577-ae41-badaef44103e.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Draw Tile Bound**: If enabled, it shows the bounds of the tiles of the navigation
    mesh:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/817941b1-de44-43c3-a49e-4bc339738950.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Draw Path-Colliding Geometry**: By enabling this option, it is possible to
    visualize the geometry that has been passed as input to the** Navigation Mesh
    Generator**, so it is basically all the geometry that the navigation system "is
    aware of." This is useful to check whether something is considered by the navigation
    system, so you can include or exclude what you don''t want (remember that there
    is an option for actors and objects to influence the navigation mesh, and this
    option allows you to spot the one that is currently being considered by the navigation
    system). By checking this option, this is what it is possible to see:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/7b5c80db-ab02-4475-8c6c-2ac09f2d1b55.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, keep in mind that Unreal renders this geometry independently from
    the rest. So, you can also use other views in the engine to isolate this geometry
    to better check what it is like. For instance, you can turn on the Wireframe View*,* and
    it is still possible to see the geometry passed to the navigation mesh generator,
    and this is how it looks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/64878787-d708-4418-bfb8-dc296dbe9145.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Draw Tile Labels**: If enabled, these options show the label (expressed as
    a coordinate) of each tile of the navigation mesh:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/83fd4f02-d462-4a79-ae78-1508d05167eb.png)'
  prefs: []
  type: TYPE_IMG
- en: Viewport. This is a screenshot of the viewport. The other (blurred out) information
    is not important here
  prefs: []
  type: TYPE_NORMAL
- en: '**Draw Polygon Labels**: If enabled, this option shows a label (that also express
    how many iterations that polygon went through before being generated) for each
    polygon generated in the navigation mesh:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/5e4c53c6-d0cf-4a51-a5f2-1ec3d02457b4.png)'
  prefs: []
  type: TYPE_IMG
- en: Viewport. This is a screenshot of the viewport. The other (blurred out) information
    is not important here
  prefs: []
  type: TYPE_NORMAL
- en: '**Draw Default Polygon Cost**: If this option is enabled, it shows all the
    costs for the different parts of the navigation mesh. This is very useful for
    checking which parts are more expensive to traverse. By enabling it in our example,
    this is how it looks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/e5afe432-0b64-432c-b8f6-65fa2b94a072.png)'
  prefs: []
  type: TYPE_IMG
- en: Viewport. This is a screenshot of the viewport. The other (blurred out) information
    is not important here
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, all the costs are just 1, and this is because we don''t have
    any other type of nav areas than the default ones. If we bring a nav modifier
    and we set a custom nav area (different than null), for instance, the **Desert**
    (or **Jungle**) **Area**, as we did back in [Chapter 3](fe5b7602-fcb4-4d39-bf8c-e1742909205a.xhtml),
    *Navigation*, this would be the result (you will notice a change in how the navigation
    mesh is generated, and how in the desert area the cost is higher):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/8bee4bb2-67c9-456f-a191-78561e1af250.png)'
  prefs: []
  type: TYPE_IMG
- en: Viewport. This is a screenshot of the viewport. The other (blurred out) information
    is not important here
  prefs: []
  type: TYPE_NORMAL
- en: '**Draw Labels on Path Nodes**: If this option is on, it will draw labels on
    the path nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Draw Nav Links**: As the name suggests, if the option is on, it will draw
    nav links. It is enabled by default, since usually, you want to be able to see
    the nav links. If we disable it, this is how it would look in our example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/a8981c28-b286-47bb-8941-d38eafd5091b.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Draw Failed Nav Links**: This is the same as the previous option, but on
    **Failed Nav Links**, it is disabled by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Draw Clusters**: If enabled, it allows you to see the clusters. I''m not
    going into detail, but as we mentioned earlier, the pathfinding needs to be optimized
    to scale on large worlds (for example, **Hierarchical Pathfinding**); thus, with
    this option, you can see which regions of the navigation mesh are connected (meaning
    that it is guaranteed that between those two regions a path exists in some way),
    and so the pathfinding can first find the connected region, before refining the
    search of the path. If this option is enabled, here is how it looks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/c9eb6fab-0aed-4344-ad92-ed124f0cdf71.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Draw Octree and Draw Octree Details**: If enabled, it allows you to see the **Octrees**.
    Octrees are mathematical structures (trees with eight children) used to partition
    a 3D space. In fact, the navigation mesh is only on the same surface, but it lives
    in (and needs to work with) a 3D space. Just as in our example map, we have some
    stairs and some regions of the navigation mesh that are not at the same level;
    and also **Nav Links** connects regions from above the stairs to down below. If
    we enable it, here is how it should look (you will be able to notice that the
    octrees are mainly in the parts of the navigation mesh that needs to develop in
    height):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/cd4d33b9-fa61-4be3-b308-2f2fb9974c5d.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Draw Offset**: As you may have already noticed, the navigation mesh is not
    drawn at the same level of the geometry of the level, but there is a small offset.
    The **Draw Offset** parameter controls this offset from the ground where the navigation
    mesh is drawn. The default value is 10 (which means 10 centimeters if we keep
    the convention with the Unreal units). If we change this value (I also enabled **Draw
    Filled Polys** to better see the offset), for example, to a higher value, this
    is what we would end up with:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/2ecfd667-b4ce-4428-a881-84daea0a1086.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Enabling Drawing**: As the name suggests, if this is enabled, it is possible
    to see the navigation mesh along with all the previous settings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, all of these options are better combined when we start playing with
    the other settings that determine how the navigation mesh is generated. In fact,
    by tweaking the display settings, you can better understand how the generation
    settings work, and actually "see" how they affect the generation of the navigation
    mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation test actor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen for the **EQS Testing Pawn**, there is a built-in **Navigation
    Test Actor** that we can use.
  prefs: []
  type: TYPE_NORMAL
- en: 'This actor is not declared virtual (as the EQS counterpart is), so it can be
    directly placed in the map. Actually, we can access it from the **Modes** panel,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2780f85c-e050-4aa8-9493-7acb4e7a5374.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once placed in the level, this is how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e1a5afa-37c6-4be2-bcb5-7da8eae869c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we place another one in the level, then in the **Details** panel, we can
    assign under the Pathfind section the as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aea8c754-f98c-4302-8bed-9899fb8bb16b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will result in a preview of the path between the two navigation test actors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85dbf698-7a97-4fdc-af97-919236733e74.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is a different example from a different viewpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6db189b4-dabf-474a-b724-a5083205803c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, you can "smooth" the edges of the path if we modify the **Offset From
    Corner Distance**, always in the pathfinding section of the navigation test actor.
    For instance, a value of 150 will produce this path:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/720d6b8b-9d62-4f9f-95f0-2d227f37210a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Of course, this pathfinding test can be used with **Nav Areas** as well. If
    we drop a **Desert Area** (created back in [Chapter 3](fe5b7602-fcb4-4d39-bf8c-e1742909205a.xhtml), *Navigation*)
    in the level, the pathfinder will try to avoid it, since it has a higher cost.
    In the following example (the highlighted volume is the desert area), the desert
    area is small, and passing through it is still the shortest path:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66da78af-1dec-4f86-9dd5-2e1882764d58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, if we expand the area, then going from the other side has a cheaper
    cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbb96cb6-0745-47d7-ba9c-29fdd1a48f05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, it''s worthwhile mentioning that we can also use nav filters within
    the navigation test actor, always in the pathfinding section in its **Details**
    panel. For instance, we can place the **NavFilter_DesertAnimal** (that we created
    in [Chapter 3](fe5b7602-fcb4-4d39-bf8c-e1742909205a.xhtml), *Navigation*,), then
    the desert area is even preferred, producing this other path:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91194937-b1b5-4ad5-bd54-07e89fa5d809.png)'
  prefs: []
  type: TYPE_IMG
- en: This navigation test actor has more functionalities, as you can see from its
    **Details** panel, but, unfortunately, they are outside the scope of this book.
    However, we have seen its basic use.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to profiling, Unreal offers many solutions and tools. This section
    explores some that are related to AI.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, we will see how it is possible to visualize stats directly from
    the console and how to create a custom stat group. At the end of this section,
    we will mention the **Session Frontend** tool.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling with the console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most used profiling tool is activating stats through the console, because
    it is very quick and you can track performance in real time. In fact, just typing
    `stats game` into the console makes a whole page of stats appear on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f180301e-7a83-47ad-bb20-232562dec587.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are all the stats that appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20902974-2273-4d27-b2f2-2c53205cc3ca.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, there's a lot of information, but it is quite general, since
    it tracks the general performance of your game. This is a perfect starting point
    to start optimizing your game; however, as an AI Developer, you will need more
    specific tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we start typing just `Stat`, a series of options (as a suggestion) appears
    on the screen (86!):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17f4dddd-3df4-47ce-b441-981f128a7fca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But we can refine our search even more by typing `Stat AI`, and we can have
    the AI-related stats (after all, these options were the first ones on the list,
    since they are in alphabetical order):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce976ad8-7120-4460-ab8a-8a569cc532af.png)'
  prefs: []
  type: TYPE_IMG
- en: These are very useful when it comes down to quickly tracking the performance
    of your AI.
  prefs: []
  type: TYPE_NORMAL
- en: In order to close the stats, just retype the same command as you did when closing
    those specific stats.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we type `Stat AI`, we get a generic AI performance track (it depends also
    on which AI systems you have active). On the right, you are also able to check
    how many AIs there are in the level, and how many are currently rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab6620d3-a996-43af-8a71-2c1758b937cc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Typing `Stat AI_EQS` gives us more information about EQS. Of course, by using
    a level that has five AIs performing the `EnvQueryA` and `EnvQueryB` that we have
    created before, this has a huge impact on how EQS performs in this specific example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6959453f-f7a4-423a-833a-0a98468d410c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Typing `Stat AIBehaviorTree` gives us informational about the behavior trees
    that are running. Currently, in our example, we have very simple behavior trees,
    so performance- and memory-wise they are very easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7536304e-eab7-48c0-825c-d282a0badc38.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, typing `Stat AICrowd` gives us information about the crowd that is
    handled at the current stage. Since we are not using a crowd in this example,
    the category is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70d5f585-581b-47b0-b01e-5c044c8ca169.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Of course, if you need to keep track of more than one category at the time,
    you can do it, just by inserting console commands, and they will stack up together,
    as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bf970f0-ce65-4566-a3ec-6c5b44e21693.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a custom stat group
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are programming a complex AI, you might want to keep track of more specific
    functions and how they perform. Of course, this can be useful not only for AI
    programming, but for any part of your game. Unreal offers some simple Macros to
    add to your C++ code to quickly start outputting stats for those functions to
    check their performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a **Custom Stat Group**, you need to declare this within a header
    file (or if your system uses inheritance, you can declare it at the highest level
    of the headers file, so the same stat group is available for all the classes that
    inherit from this):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, inside the header (`.h`) file of the class that contains the function
    you want to track, we need to add this macro (one for each function we need to
    track):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the implementation (`.cpp`) file, you need to add this macro at
    the beginning of the function we want to track:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let's start with a practical example, so that you can have a better idea of
    how it works. I'm going to create a simple actor, create the stat group within
    this actor, and start tracking the performance of its `tick` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new C++ class that inherits from **Actor**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74d2173e-9157-4d1e-8a34-7f6d321acf07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can rename it ***TestingStatActor*** and place it within the `Chapter12 `folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9fc6faf9-a9ad-4748-9b41-47b11c63dab6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, in its header (`.h`) file, we need to declare the stat group (just below
    the include statements):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, since we want to track a function in this very class, we can declare
    the intention to track a function just below the previous line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the C++ file, we can add the following macro at the beginning of
    the `Tick` function (even before `Super::Tick()` if you want to track that part
    as well), and maybe we can add a log (which is a heavy task, especially for a
    `Tick` function, so we can better see its spike in performance):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now you can compile your code, and when it is finished, you can drag the **TestingStatActor**
    directly into the level (remember that it doesn't have a scene component, so it
    exists in the level, but it cannot be positioned).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we type in the console, we are now able to access our **AI_MyCustomGroup**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b06379f-dc5d-43ef-a53e-973609fda064.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we enable it, we are able to check on screen the performance of our `Tick`
    function for each TestingStatActor in the game (in this case, just one):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/149de11b-c5a7-476e-97b3-b2b8f2eebc4a.png)'
  prefs: []
  type: TYPE_IMG
- en: This concludes how to create a custom stat group. This is indeed a very powerful
    tool that allows you to quickly start profiling your C++ functions.
  prefs: []
  type: TYPE_NORMAL
- en: Session frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Session frontend** is a very powerful profiling tool within Unreal. It allows
    you to check the performance of specific parts of the game, record and save profiling
    sessions, and much, much more (including automatic tests! We will not touch those
    in this book).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can activate it by navigating from the top menu **Window | Developer Tools
    | Session Frontend**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/349b4b2e-7507-42ad-89dd-fa7cc8aeef81.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once opened, this is how it looks (it should be in the **Console** tab):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de93d471-f75e-4d49-8933-2598fbfa5118.png)'
  prefs: []
  type: TYPE_IMG
- en: Console tab. This is an image of Console tab. The other (blurred out) information
    is not important here
  prefs: []
  type: TYPE_NORMAL
- en: In the **Profiler** tab, you will find all of what you need to dive deeper into
    profiling.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you start profiling, here, you will find even more information about AI
    performance (actually, you can find the performance of every part of your game).
    For instance, in the next screenshot, you can see that I''m profiling some AI
    systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7cfd4696-fb1c-48ef-8b0a-2353ee5f8662.png)'
  prefs: []
  type: TYPE_IMG
- en: Profiler tab. This is an image of Profiler tab. The other (blurred out) information
    is not important here
  prefs: []
  type: TYPE_NORMAL
- en: If you have created a custom stat group before, you will be able to profile
    that as well in the session frontend! So, keep in mind that creating a stat group
    is very important, as later on, you will need to check the performance of your
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, we don't have the time to explore the **Session Frontend** tool,
    since it would require a whole chapter and it is outside the scope of this book
    (since it would require digging really deeply into performance profiling). However,
    I mentioned this tool not just because it is very important, but because you should
    definitely be aware of its existence, and it is worthwhile exploring it more on
    your own. In fact, you can find more information about this tool in the official
    documentation here: [https://docs.unrealengine.com/en-us/Engine/Performance/Profiler](https://docs.unrealengine.com/en-us/Engine/Performance/Profiler),
    which provides a good starting point for learning more about this tool.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored some debugging tools for our AI. Of course,
    this was not comprehensive, and there is much more that we haven't covered. However,
    we learned about the most important ones and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, we have further explored the options available to an EQS testing
    pawn, and how they can help us visualize an environmental query running. We also
    learned about using EQS Profiler as a way to identify how our environmental queries
    perform, and we dived deeper into those that need optimization.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at the display settings for the navigation system in more detail,
    to have a better idea of how our navigation mesh is generated. Also, we discussed
    the navigation-testing actor, which is really useful to visually query the navigation
    system and quickly receive feedback regarding how the Pathfinder performs; but
    we didn't have the time to go into detail about the available options.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned more about profiling our game AI, especially with the use
    of `stat` commands in the console. In fact, we have explored what the built-in
    stat groups are and how to create a customized one. We also mentioned the session
    frontend, a powerful tool for profiling our game.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover the gameplay debugger, which is another important
    tool for debugging AI.
  prefs: []
  type: TYPE_NORMAL
