<html><head></head><body>
		<div id="_idContainer037">
			<h1 id="_idParaDest-29"><em class="italic"><a id="_idTextAnchor100"/><a id="_idTextAnchor101"/>Chapter 2</em>: Finite State Machines</h1>
			<p>In this chapter, we'll learn how to implement a <strong class="bold">Finite State Machine</strong> (<strong class="bold">FSM</strong>) in a Unity3D game by studying the simple tank game-mechanic example that comes with this book.</p>
			<p>In our game, the player controls a tank. The enemy tanks move around the scene, following four waypoints. Once the player's tank enters the vision range of the enemy tanks, they start chasing it; then, once they are close enough to attack, they'll start shooting at our player's tank.</p>
			<p>To control the AI of our enemy tanks, we use an FSM. First, we'll use simple <strong class="source-inline">switch</strong> statements to implement our tank AI states. Then, we'll use a more complex and engineered FSM framework that will allow us greater flexibility in designing the character's FSM.</p>
			<p>The topics we will be covering in this chapter are the following: </p>
			<ul>
				<li>Implementing the player's tank</li>
				<li>Implementing a bullet class </li>
				<li>Setting up waypoints</li>
				<li>Creating the abstract FSM class</li>
				<li>Using a simple FSM for the enemy tank AI</li>
				<li>Using an FSM framework</li>
			</ul>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor102"/><a id="_idTextAnchor103"/><a id="_idTextAnchor104"/>Technical requirements</h1>
			<p>For this chapter, you just need Unity3D 2022. You can find the example project described in this chapter in the <strong class="source-inline">Chapter 2</strong> folder in the book repository: <a id="_idTextAnchor105"/><a id="_idTextAnchor106"/><a href="https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter02">https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter02</a>.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor107"/>Implementing the player's tank</h1>
			<p>Before writing <a id="_idIndexMarker086"/>the script for our player's tank, let's look at how we set up the <strong class="bold">PlayerTank</strong> game object. Our <strong class="bold">Tank</strong> object is a simple <strong class="bold">mesh</strong> with the <strong class="source-inline">Rigidbody</strong> and <strong class="source-inline">Box Collider</strong> components.</p>
			<p>The <strong class="bold">Tank</strong> object is composed of two separate meshes, the <strong class="bold">Tank</strong> and <strong class="bold">Turret</strong>, with <strong class="bold">Turret</strong> being a child of <strong class="bold">Tank</strong>. This structure allows for the independent rotation of the <strong class="bold">Turret</strong> object using the mouse movement and, at the same time, automatically following the <strong class="bold">Tank</strong> body wherever it goes. Then, we create an empty game object for our <strong class="bold">SpawnPoint</strong> transform. We use it as a reference position point when shooting a bullet. Finally, we need to assign the <strong class="bold">Player</strong> tag to our <strong class="bold">Tank</strong> object. Now, let's take a look at the <strong class="source-inline">controller</strong> class:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B17984_02_1.jpg" alt="Figure 2.1 – Our tank entity&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – Our tank entity</p>
			<p><a id="_idTextAnchor108"/><a id="_idTextAnchor109"/>The <strong class="source-inline">PlayerTankController</strong> class controls the player's tank. We use the <em class="italic">W</em>, <em class="italic">A</em>, <em class="italic">S</em>, and <em class="italic">D</em> keys to move and steer the tank and the left mouse button to aim and shoot from the <strong class="bold">Turret</strong> object.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">In this book, we assume that you are using a <em class="italic">QWERTY</em> keyboard and a two-button mouse, with the left mouse button set as the primary mouse button. If you are using a different keyboard, all you have to do is pretend that you are using a <em class="italic">QWERTY</em> keyboard or try to <a id="_idTextAnchor110"/><a id="_idTextAnchor111"/>modify the code to adapt it to your keyboard layout. It is pretty easy!</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor112"/><a id="_idTextAnchor113"/>Initializing the Tank object</h2>
			<p>Let's start<a id="_idIndexMarker087"/> creating the <strong class="source-inline">PlayerTankController</strong> class by setting up the <strong class="source-inline">Start</strong> function and the <strong class="source-inline">Update</strong> function in the <strong class="source-inline">PlayerTankController.cs</strong> file:</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code">using System.Collections;</p>
			<p class="source-code">public class PlayerTankController : MonoBehaviour {</p>
			<p class="source-code">    public GameObject Bullet;</p>
			<p class="source-code">    public GameObject Turret;</p>
			<p class="source-code">    public GameObject bulletSpawnPoint;</p>
			<p class="source-code">    public float rotSpeed = 150.0f;</p>
			<p class="source-code">     public float turretRotSpeed = 10.0f;</p>
			<p class="source-code">    public float maxForwardSpeed = 300.0f; </p>
			<p class="source-code">    public float maxBackwardSpeed = -300.0f;</p>
			<p class="source-code">    public float shootRate = 0.5f; </p>
			<p class="source-code">    private float curSpeed, targetSpeed;</p>
			<p class="source-code">    protected float elapsedTime;</p>
			<p class="source-code">    void Start() {</p>
			<p class="source-code">   }</p>
			<p class="source-code">    void Update() {</p>
			<p class="source-code">        UpdateWeapon();</p>
			<p class="source-code">        UpdateControl();<a id="_idTextAnchor114"/></p>
			<p class="source-code">    <a id="_idTextAnchor115"/>}</p>
			<p>We can see in <a id="_idIndexMarker088"/>the hierarchy that the <strong class="bold">PlayerTank</strong> game object has one child called <strong class="bold">Turret</strong>, and in turn, the first child of the <strong class="bold">Turret</strong> object is called <strong class="bold">SpawnPoint</strong>. To set up the controller, we need to link (by dragging and dropping) <strong class="bold">Turret</strong> and <strong class="bold">SpawnPoint</strong> into the corresponding fields in the Inspector:</p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B17984_02_2.jpg" alt="Figure 2.2 – The Player Tank Controller component in the Inspector&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – The Player Tank Controller component in the Inspector</p>
			<p>Later, after creating the <strong class="bold">Bullet</strong> object, we can assign it to the <strong class="source-inline">Bullet</strong> variable using the Inspector. Then, finally, the <strong class="source-inline">Update</strong> function calls the <strong class="source-inline">UpdateControl</strong> and <strong class="source-inline">UpdateWeapon</strong> functions. We will discuss the content of these functions in the following section.<a id="_idTextAnchor116"/><a id="_idTextAnchor117"/><a id="_idTextAnchor118"/><a id="_idTextAnchor119"/></p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor120"/>Shooting the bullet</h2>
			<p>The mechanism for <a id="_idIndexMarker089"/>shooting the bullet is simple. Whenever the player clicks the left mouse button, we check whether the total elapsed time since the last fire is greater than the weapon's fire rate. If it is, then we create a new <strong class="bold">Bullet</strong> object at the <strong class="source-inline">bulletSpawnPoint</strong> transform's position. This check prevents the player from shooting a continuous stream of bullets.</p>
			<p>For this, we add the following function to the <strong class="source-inline">PlayerTankController.cs</strong> file:</p>
			<p class="source-code">void UpdateWeapon() {</p>
			<p class="source-code">    elapsedTime += Time.deltaTime;</p>
			<p class="source-code">    if (Input.GetMouseButtonDown(0)) {</p>
			<p class="source-code">        if (elapsedTime &gt;= shootRate) {</p>
			<p class="source-code">            //Reset the time </p>
			<p class="source-code">            elapsedTime = 0.0f;</p>
			<p class="source-code">            //Instantiate the bullet</p>
			<p class="source-code">            Instantiate(Bullet,</p>
			<p class="source-code">              bulletSpawnPoint.transform.position,</p>
			<p class="source-code">              bulletSpawnPoint.transform.rotation);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Now, we can attach this controller script to the <strong class="bold">PlayerTank</strong> object. If we run the game, we should be able to shoot from our tanks. Now, it is time to implement the tank's movement controls<a id="_idTextAnchor121"/><a id="_idTextAnchor122"/><a id="_idTextAnchor123"/><a id="_idTextAnchor124"/>.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor125"/>Controlling the tank</h2>
			<p>The player can<a id="_idIndexMarker090"/> rotate the <strong class="bold">Turret</strong> object using the mouse. This part may be a little bit tricky because it involves raycasting and 3D rotations. We assume that the camera looks down upon the battlefield. Let's add the <strong class="source-inline">UpdateControl</strong> function to the <strong class="source-inline">PlayerTankController.cs</strong> file:</p>
			<p class="source-code">void UpdateControl() {</p>
			<p class="source-code">    // AIMING WITH THE MOUSE</p>
			<p class="source-code">    // Generate a plane that intersects the Transform's</p>
			<p class="source-code">    // position with an upwards normal.</p>
			<p class="source-code">    Plane playerPlane = new Plane(Vector3.up,</p>
			<p class="source-code">      transform.position + new Vector3(0, 0, 0));</p>
			<p class="source-code">    // Generate a ray from the cursor position </p>
			<p class="source-code">    Ray RayCast =</p>
			<p class="source-code">      Camera.main.ScreenPointToRay(Input.mousePosition);</p>
			<p class="source-code">    // Determine the point where the cursor ray intersects</p>
			<p class="source-code">    // the plane.</p>
			<p class="source-code">    float HitDist = 0;</p>
			<p class="source-code">    // If the ray is parallel to the plane, Raycast will</p>
			<p class="source-code">    // return false.</p>
			<p class="source-code">    if (playerPlane.Raycast(RayCast, out HitDist)) {</p>
			<p class="source-code">        // Get the point along the ray that hits the</p>
			<p class="source-code">        // calculated distance.</p>
			<p class="source-code">        Vector3 RayHitPoint = RayCast.GetPoint(HitDist);</p>
			<p class="source-code">        Quaternion targetRotation = </p>
			<p class="source-code">          Quaternion.LookRotation(RayHitPoint –</p>
			<p class="source-code">                                  transform.position);</p>
			<p class="source-code">        Turret.transform.rotation = Quaternion.Slerp(</p>
			<p class="source-code">          Turret.transform.rotation, targetRotation,</p>
			<p class="source-code">          Time.deltaTime * turretRotSpeed);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We use raycasting to <a id="_idIndexMarker091"/>determine the turning direction by finding the <strong class="source-inline">mousePosition</strong> coordinates on the battlefield:</p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/B17984_02_3.jpg" alt="Figure 2.3 – Raycast to aim with the mouse&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – Raycast to aim with the mouse</p>
			<p class="callout-heading">Information</p>
			<p class="callout"><strong class="bold">Raycasting</strong> is a tool <a id="_idIndexMarker092"/>provided by default in the Unity physics engine. It allows us to find the intersection point between an imaginary line (the <em class="italic">ray</em>) and a collider in the scene. Imagine this as a laser pointer: we can fire our laser in a direction and see the point where it hits. However, this is a relatively expensive operation. While, in general, you can confidently handle 100–200 raycasts per frame, their performance is greatly affected by the length of the ray and the number and types of colliders in the scene. So, as a quick tip, try not to use a lot of raycasts with mesh colliders and use layer masks to filter out unnecessary collide<a id="_idTextAnchor126"/><a id="_idTextAnchor127"/>rs.</p>
			<p>This is how it works:</p>
			<ol>
				<li>Set up a plane that <a id="_idIndexMarker093"/>intersects with the player tank with an upward normal.</li>
				<li>Shoot a ray from screen space with the mouse position (in the preceding diagram, we assume that we're looking down at the tank).</li>
				<li>Find the point where the ray intersects the plane.</li>
				<li>Finally, find the rotation from the current position to that intersection point.</li>
			</ol>
			<p>Then, we check for the key-pressed input and move or rotate the tank accordingly. We add the following code at the end of the <strong class="source-inline">UpdateControl</strong> function:</p>
			<p class="source-code">if (Input.GetKey(KeyCode.W)) {</p>
			<p class="source-code">    targetSpeed = maxForwardSpeed;</p>
			<p class="source-code">} else if (Input.GetKey(KeyCode.S)) {</p>
			<p class="source-code">    targetSpeed = maxBackwardSpeed;</p>
			<p class="source-code">} else {</p>
			<p class="source-code">    targetSpeed = 0;</p>
			<p class="source-code">}</p>
			<p class="source-code">if (Input.GetKey(KeyCode.A)) {</p>
			<p class="source-code">    transform.Rotate(0, -rotSpeed * Time.deltaTime, 0.0f);</p>
			<p class="source-code">} else if (Input.GetKey(KeyCode.D)) {</p>
			<p class="source-code">    transform.Rotate(0, rotSpeed * Time.deltaTime, 0.0f);</p>
			<p class="source-code">}</p>
			<p class="source-code">//Determine current speed</p>
			<p class="source-code">curSpeed = Mathf.Lerp(curSpeed, targetSpeed, 7.0f *</p>
			<p class="source-code">                      Time.deltaTi<a id="_idTextAnchor128"/>me);</p>
			<p class="source-code">transform.Translate(Vector3.forward * Time.deltaTime *</p>
			<p class="source-code">                    curSp<a id="_idTextAnchor129"/>eed);</p>
			<p>The preceding code <a id="_idIndexMarker094"/>represents the classic <em class="italic">WASD</em> control scheme. The tank rotates with the <em class="italic">A</em> and <em class="italic">D</em> keys, and moves forward and backward with <em class="italic">W</em> and <em class="italic">S</em>. </p>
			<p class="callout-heading">Information</p>
			<p class="callout">Depending on your level of Unity expertise, you may wonder what about the <strong class="source-inline">Ler<a id="_idTextAnchor130"/><a id="_idTextAnchor131"/>p</strong> and <strong class="source-inline">Time.deltaTime</strong> multiplications. It may be worth a slight digression. First, <strong class="bold">Lerp</strong> stands for <strong class="bold">Linear Interpolation</strong> and is a way to transition between two values smoothly. In <a id="_idIndexMarker095"/>the preceding code, we use the <strong class="source-inline">Lerp</strong> function to smoothly spread the velocity changes over multiple frames so that the tank's movement doesn't look like it's accelerating and decelerating instantaneously. The <strong class="source-inline">7.0f</strong> value is just a <em class="italic">smoothing factor</em>, and you can play with it to find your favorite value (the bigger the value, the greater the tank's acceleration).</p>
			<p class="callout">Then, we multiply everything by <strong class="source-inline">Time.deltaTime</strong>. This value represents the time in seconds between now and the last frame, and we use it to make our velocity independent from<a id="_idIndexMarker096"/> the frame rate. For more info, refer to <a href="https://learn.unity.com/tutorial/delta-time">https://learn.unity.com/tutorial/delta-time</a>.</p>
			<p>Next, it is time to implement the projectiles fired by the player and enemy<a id="_idTextAnchor132"/><a id="_idTextAnchor133"/><a id="_idTextAnchor134"/><a id="_idTextAnchor135"/> tanks.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor136"/>Implementing a Bullet class</h1>
			<p>Next, we set up <a id="_idIndexMarker097"/>our <strong class="bold">Bullet</strong> prefab with two orthogonal planes and a box collider, using a laser-like material and a <strong class="bold">Particles/Additive-Layer</strong> property in the <strong class="bold">Shader</strong> field:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/B17984_02_4.jpg" alt="Figure 2.4 – Our Bullet prefab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – Our Bullet prefab</p>
			<p>The <a id="_idIndexMarker098"/>code in the <strong class="source-inline">Bullet.cs</strong> file is as follows:</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code">using System.Colle<a id="_idTextAnchor137"/>ctions;</p>
			<p class="source-code">public class Bullet : Mono<a id="_idTextAnchor138"/>Behaviour {</p>
			<p class="source-code">    //Explosion Effect </p>
			<p class="source-code">    [SerializeField] // Used to expose in the inspector private </p>
			<p class="source-code">                     // fields!</p>
			<p class="source-code">    private GameObject Explosion;</p>
			<p class="source-code">    [SerializeField]</p>
			<p class="source-code">    private float Speed = 600.0f;</p>
			<p class="source-code">    [SerializeField]</p>
			<p class="source-code">    private float LifeTime = 3.0f;</p>
			<p class="source-code">    public int damage = 50;</p>
			<p class="source-code">    void Start() {</p>
			<p class="source-code">        Destroy(gameObject, LifeTime);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    void Update() {</p>
			<p class="source-code">        transform.position +=</p>
			<p class="source-code">        transform.forward * Speed * Time.deltaTime;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    void OnCollisionEnter(Collision collision) {</p>
			<p class="source-code">        ContactPoint contact = collision.contacts[0];</p>
			<p class="source-code">        Instantiate(Explosion, contact.point,</p>
			<p class="source-code">                    Quaternion.identity);</p>
			<p class="source-code">        Destroy(gameObject);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">Bullet</strong> class <a id="_idIndexMarker099"/>has three properties: <strong class="source-inline">damage</strong>, <strong class="source-inline">Speed</strong>, and <strong class="source-inline">Lifetime</strong> – the latter so that the bullet is automatically destroyed after a certain amount of time. Note that we use <strong class="source-inline">[SerializeField]</strong> to show the private fields in the Inspector; by default, in fact, Unity only shows public fields. It is a good practice to set fields that we need to access from other classes as public-only. </p>
			<p>As you can see, the <strong class="source-inline">Explosion</strong> property of the bullet is linked to the <strong class="source-inline">ParticleExplosion</strong> prefab, which we're not going to discuss in detail. This prefab is in the <strong class="source-inline">ParticleEffects</strong> folder, so we drop it into the <strong class="bold">Shader</strong> field. Then, when the bullet hits something, we play this particle effect, as described in the <strong class="source-inline">OnCollisionEnter</strong> method. The <strong class="source-inline">ParticleExplosion</strong> prefab uses the <strong class="source-inline">AutoDestruct</strong> script to <a id="_idIndexMarker100"/>automatically destroy the <strong class="source-inline">Explosion</strong> object after a small amount of time:</p>
			<p class="source-code">using Uni<a id="_idTextAnchor139"/>tyEngine;</p>
			<p class="source-code">public class AutoDestruct : Mo<a id="_idTextAnchor140"/>noBehaviour {</p>
			<p class="source-code">    [SerializeField]</p>
			<p class="source-code">    private float DestructTime = 2.0f;</p>
			<p class="source-code">    void Start() {</p>
			<p class="source-code">        Destroy(gameObject, DestructTime);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">AutoDestruct</strong> script is small but convenient. It just destroys the attached object after a certain number of seconds. Many Unity games use a similar script almost every tim<a id="_idTextAnchor141"/><a id="_idTextAnchor142"/>e for many situations.</p>
			<p>Now that we have a tank that can fire and move, we can set up a simple patrolling path for the en<a id="_idTextAnchor143"/><a id="_idTextAnchor144"/>emy tanks.</p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor145"/>Setting up waypoints</h1>
			<p>By default, the enemy tanks<a id="_idIndexMarker101"/> will patrol the game arena. To implement this behavior, we need to specify first the patrolling path. We will explore path following thoroughly in <a href="B17984_06_Epub.xhtml#_idTextAnchor375"><em class="italic">Chapter 6</em></a>, <em class="italic">Path Following and Steering Behaviors</em>. For now, we limit ourselves to a simple <em class="italic">waypoints path</em>.</p>
			<p>To implement it, we put four <strong class="bold">Cube</strong> game objects at random places. They represent <em class="italic">waypoints</em> inside our scene, and therefore, we name each one <strong class="source-inline">WanderPoint</strong>:</p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/B17984_02_5.jpg" alt="Figure 2.5 – WanderPoint&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5 – WanderPoint</p>
			<p>Here is<a id="_idIndexMarker102"/> what our <strong class="bold">WanderPoint</strong> objects look like:</p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/B17984_02_6.jpg" alt="Figure 2.6 – The WanderPoint properties&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.6 – The WanderPoint properties</p>
			<p>Note that <a id="_idIndexMarker103"/>we need to tag these points with a tag called <strong class="bold">WanderPoint</strong>. Later, we will use this tag when we try to find the waypoints from our tank AI. As you can see in its properties, a waypoint is just a <strong class="bold">Cube</strong> game object with the <strong class="bold">Mesh Renderer</strong> checkbox disabled:</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/B17984_02_7.jpg" alt="Figure 2.7 – The gizmo selection panel&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.7 – The gizmo selec<a id="_idTextAnchor146"/><a id="_idTextAnchor147"/>tion panel</p>
			<p>To show these<a id="_idIndexMarker104"/> points in the editor (but not in the game), we use an empty object with a gizmo icon, since all we need from a waypoint is its position and the transformation data. To do that, click the small triangle near the object icon in the Inspector, as shown in<a id="_idTextAnchor148"/><a id="_idTextAnchor149"/> <em class="italic">Figure 2.7</em>.</p>
			<p>We are now ready to give life to the enemy tanks with the power <a id="_idTextAnchor150"/><a id="_idTextAnchor151"/>of the FSM.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor152"/>Creating the abstract FSM class</h1>
			<p>Next, we implement a<a id="_idIndexMarker105"/> generic abstract class to define the enemy tank AI class's methods. This abstract class will be the skeleton of our AI and represent a high-level view of what an enemy tank should do.</p>
			<p>We can see the <a id="_idIndexMarker106"/>code of this class in the <strong class="source-inline">FSM.cs</strong> file:</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code">using System.Collections;</p>
			<p class="source-code">public class FSM : MonoBehaviour {</p>
			<p class="source-code">    protected virtual void Initialize() { } </p>
			<p class="source-code">    </p>
			<p class="source-code">    protected virtual void FSMUpdate() { } </p>
			<p class="source-code">    </p>
			<p class="source-code">    protected virtual void FSMFixedUpdate() { }</p>
			<p class="source-code">    // Use this for initialization </p>
			<p class="source-code">    void Start () {</p>
			<p class="source-code">        Initialize();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Update is called once per frame </p>
			<p class="source-code">    void Update () {</p>
			<p class="source-code">        FSMUpdate();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    void FixedUpdate() {</p>
			<p class="source-code">        FSMFixedUpdate();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The enemy tanks need only to know the position of the player's tank, their next destination point, and the list of waypoints to choose from while they're patrolling. Once the player tank is in range, they rotate their turret object and start shooting from the bullet spawn point at their fire rate.</p>
			<p>As we explained<a id="_idIndexMarker107"/> before, we will extend this class in two ways: using a simple <em class="italic">if-then-else</em>-based FSM (the <strong class="source-inline">SimpleFSM</strong> class) and a more engineered but more flexible FSM (<strong class="source-inline">AdvancedFSM</strong>). These two FSM implementations will inherit the <strong class="source-inline">FSM</strong> abstract class, and they will implement the three abstract methods: <strong class="source-inline">Initialize</strong>, <strong class="source-inline">FSMUpdate</strong>, and <strong class="source-inline">FSMFixedUpdate</strong>.</p>
			<p>We will see the two different ways to implement these three methods in the next sections. For now, let's start with the basic i<a id="_idTextAnchor153"/><a id="_idTextAnchor154"/><a id="_idTextAnchor155"/><a id="_idTextAnchor156"/>mplementation.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor157"/>Using a simple FSM for the enemy tank AI</h1>
			<p>Let's look <a id="_idIndexMarker108"/>at the actual code for our AI tanks. First, let's <a id="_idIndexMarker109"/>create a new class, called <strong class="source-inline">SimpleFSM</strong>, which inherits from our FSM abstract class.</p>
			<p>You can find the source code in the <strong class="source-inline">SimpleFSM.cs</strong> file:</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code">using System.Collections;</p>
			<p class="source-code">public class SimpleFSM : FSM {</p>
			<p class="source-code">    public enum FSMState {</p>
			<p class="source-code">        None, Patrol, Chase, Attack, Dead,</p>
			<p class="source-code">    }</p>
			<p class="source-code">    //Current state that the NPC is reaching</p>
			<p class="source-code">    public FSMState curState = FSMState.Patrol;</p>
			<p class="source-code">    //Speed of the tank</p>
			<p class="source-code">    private float curSpeed = 150.0f;</p>
			<p class="source-code">    //Tank Rotation Speed</p>
			<p class="source-code">    private float curRotSpeed = 2.0f;</p>
			<p class="source-code">    //Bullet</p>
			<p class="source-code">    public GameObject Bullet;</p>
			<p class="source-code">    //Whether the NPC is destroyed or not</p>
			<p class="source-code">    private bool bDead = false;</p>
			<p class="source-code">    private int health = 100;</p>
			<p class="source-code">    // We overwrite the deprecated built-in rigidbody </p>
			<p class="source-code">    // variable.</p>
			<p class="source-code">    new private Rigidbody rigidbody;</p>
			<p class="source-code">    //Player Transform</p>
			<p class="source-code">    protected Transform playerTransform;</p>
			<p class="source-code">    //Next destination position of the NPC Tank</p>
			<p class="source-code">    protected Vector3 destPos;</p>
			<p class="source-code">    //List of points for patrolling</p>
			<p class="source-code">    protected GameObject[] pointList;</p>
			<p class="source-code">    //Bullet shooting rate</p>
			<p class="source-code">    protected float shootRate = 3.0f;</p>
			<p class="source-code">    protected float elapsedTime = 0.0f;</p>
			<p class="source-code">    public float maxFireAimError = 0.001f;</p>
			<p class="source-code">    // Status Radius</p>
			<p class="source-code">    public float patrollingRadius = 100.0f;</p>
			<p class="source-code">    public float attackRadius = 200.0f;</p>
			<p class="source-code">    public float playerNearRadius = 300.0f;</p>
			<p class="source-code">    //Tank Turret</p>
			<p class="source-code">    public Transform turret;</p>
			<p class="source-code">    public Transform bulletSpawnPoint;</p>
			<p>Here, we declare <a id="_idIndexMarker110"/>a few variables. Our tank AI has four different<a id="_idIndexMarker111"/> states: <strong class="bold">Patrol</strong>, <strong class="bold">Chase</strong>, <strong class="bold">Attack</strong>, and <strong class="bold">Dead</strong>. We are implementing the FSM that we described as an example in <a href="B17984_01_Epub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to AI</em>:</p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B17984_02_8.jpg" alt="Figure 2.8 – The enemy tank AI's FSM&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.8 – The enemy tank AI's FSM</p>
			<p>In our <strong class="source-inline">Initialize</strong> method, we set up our AI tank's properties with default values. Then, we<a id="_idIndexMarker112"/> store the positions of waypoints in our local variable. We<a id="_idIndexMarker113"/> get those waypoints from our scene using the <strong class="source-inline">FindGameObjectsWithTag</strong> method, trying to find those objects with t<a id="_idTextAnchor158"/>he <strong class="bold">WandarPoint</strong> tag:</p>
			<p class="source-code">//Initialize the Finite state machine for the NPC tank protected overrid<a id="_idTextAnchor159"/>e void Initialize () {</p>
			<p class="source-code">    // Get the list of points </p>
			<p class="source-code">    pointList = </p>
			<p class="source-code">      GameObject.FindGameObjectsWithTag("WandarPoint");</p>
			<p class="source-code">    // Set Random destination point first </p>
			<p class="source-code">    FindNextPoint();</p>
			<p class="source-code">    // Get the target enemy(Player) </p>
			<p class="source-code">    GameObject objPlayer =</p>
			<p class="source-code">    GameObject.FindGameObjectWithTag("Player");</p>
			<p class="source-code">    // Get the rigidbody</p>
			<p class="source-code">    rigidbody = GetComponent&lt;Rigidbody&gt;();</p>
			<p class="source-code">    playerTransform = objPlayer.transform;</p>
			<p class="source-code">    if (!playerTransform) {</p>
			<p class="source-code">        print("Player doesn't exist. Please add one with</p>
			<p class="source-code">               Tag named 'Player'");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">Update</strong> method<a id="_idIndexMarker114"/> that gets called every frame looks like the<a id="_idIndexMarker115"/> following:</p>
			<p class="source-code">protected override void FSMUpdate() {</p>
			<p class="source-code">    switch (curState) {</p>
			<p class="source-code">        case FSMState.Patrol: </p>
			<p class="source-code">            UpdatePatrolState(); </p>
			<p class="source-code">            break; </p>
			<p class="source-code">        case FSMState.Chase: </p>
			<p class="source-code">            UpdateChaseState(); </p>
			<p class="source-code">            break; </p>
			<p class="source-code">        case FSMState.Attack: </p>
			<p class="source-code">            UpdateAttackState(); </p>
			<p class="source-code">            break; </p>
			<p class="source-code">        case FSMState.Dead: </p>
			<p class="source-code">            UpdateDeadState();</p>
			<p class="source-code">            break;</p>
			<p class="source-code">   }</p>
			<p class="source-code">    // Update the time</p>
			<p class="source-code">    elapsedTime += Time.deltaTime;</p>
			<p class="source-code">    // Go to dead state is no health left </p>
			<p class="source-code">    if (health &lt;= 0) {</p>
			<p class="source-code">        curState = FSMState.Dead;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We check the <a id="_idIndexMarker116"/>current state and then call the appropriate<a id="_idIndexMarker117"/> state method. Once the health object has a value of zero or less, we set the tank to the <strong class="source-inline">Dead</strong> state.</p>
			<p class="callout-heading">Debugging Private Variables</p>
			<p class="callout">A public variable<a id="_idIndexMarker118"/> in the Inspector is not only useful because we can quickly experiment with different values but also because we can quickly look at a glance at their value when debugging. For this reason, you may even be tempted to make public (or expose to the Inspector) variables that should not be changed by the component's user. Don't worry – there is a solution: you can show the Inspector in <strong class="bold">Debug</strong> mode. In <strong class="bold">Debug</strong> mode, the Inspector also shows private fields. To enable Debug mode, click on the three dots at the top right and then click on <strong class="bold">Debug</strong>:</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/B17984_02_9.jpg" alt="Figure 2.9 – Unity's Inspector in Debug mode&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.9 – Unity's Inspector in Debug mode</p>
			<p>Now, let's see how to implement<a id="_idTextAnchor160"/><a id="_idTextAnchor161"/><a id="_idTextAnchor162"/><a id="_idTextAnchor163"/> each state one by one.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor164"/>The Patrol state</h2>
			<p>The <strong class="bold">Patrol</strong> state is <a id="_idIndexMarker119"/>the state in which the tank moves from waypoint to waypoint, looking for <a id="_idIndexMarker120"/>the player. The <strong class="bold">Patrol</strong> state's code is shown here: </p>
			<p class="source-code">protected void UpdatePatrolState() {</p>
			<p class="source-code">    if (Vector3.Distance(transform.position, destPos) &lt;=</p>
			<p class="source-code">        patrollingRadius) {</p>
			<p class="source-code">        print("Reached to the destination point\n </p>
			<p class="source-code">               calculating the next point");</p>
			<p class="source-code">        FindNextPoint();</p>
			<p class="source-code">    } else if (Vector3.Distance(transform.position,</p>
			<p class="source-code">        playerTransform.position) &lt;= playerNearRadius) {</p>
			<p class="source-code">        print("Switch to Chase Position");</p>
			<p class="source-code">        curState = FSMState.Chase;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Rotate to the target point </p>
			<p class="source-code">    Quaternion targetRotation = Quaternion.LookRotation(</p>
			<p class="source-code">      destPos - transform.position);</p>
			<p class="source-code">    transform.rotation = Quaternion.Slerp(</p>
			<p class="source-code">      transform.rotation, targetRotation,</p>
			<p class="source-code">      Time.deltaTime * curRotSpeed);</p>
			<p class="source-code">    // Go Forward</p>
			<p class="source-code">    transform.Translate(Vector3.forward * Time.deltaTime *</p>
			<p class="source-code">                        curSpeed);</p>
			<p class="source-code">}</p>
			<p class="source-code">protected void FindNextPoint() {</p>
			<p class="source-code">    print("Finding next point");</p>
			<p class="source-code">    int rndIndex = Random.Range(0, pointList.Length); </p>
			<p class="source-code">    float rndRadius = 10.0f;</p>
			<p class="source-code">    Vector3 rndPosition = Vector3.zero;</p>
			<p class="source-code">    destPos = pointList[rndIndex].transform.position + </p>
			<p class="source-code">      rndPosition;</p>
			<p class="source-code">    // Check Range to decide the random point as the same</p>
			<p class="source-code">    // as before</p>
			<p class="source-code">    if (IsInCurrentRange(destPos)) {</p>
			<p class="source-code">        rndPosition = new Vector3(Random.Range(-rndRadius,</p>
			<p class="source-code">          rndRadius), 0.0f, Random.Range(-rndRadius,</p>
			<p class="source-code">          rndRadius));</p>
			<p class="source-code">        destPos = pointList[rndIndex].transform.position +</p>
			<p class="source-code">          rndPosition;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">protected bool IsInCurrentRange(Vector3 pos) {</p>
			<p class="source-code">    float xPos = Mathf.Abs(pos.x - transform.position.x);</p>
			<p class="source-code">    float zPos = Mathf.Abs(pos.z - transform.position.z);</p>
			<p class="source-code">    if (xPos &lt;= 50 &amp;&amp; zPos &lt;= 50) return<a id="_idTextAnchor165"/> <a id="_idTextAnchor166"/><a id="_idTextAnchor167"/><a id="_idTextAnchor168"/><a id="_idTextAnchor169"/>true;</p>
			<p class="source-code">    return false;</p>
			<p class="source-code">}</p>
			<p>While our tank <a id="_idIndexMarker121"/>is in the <strong class="bold">Patrol</strong> state, we check whether it has reached the <a id="_idIndexMarker122"/>destination point (that is, if the tank is100 units or less from the destination waypoint). If so, it finds the next point to reach using the <strong class="source-inline">FindNextPoint</strong> method. This method simply chooses a random point from among the waypoints we defined before.</p>
			<p>On the other hand, if the tank has not reached its destination point, it checks the distance to the player's tank. If the player's tank is in range (which, in this example, we choose to be <strong class="source-inline">300</strong> units), the AI switches to the <strong class="bold">Chase</strong> state. Finally, we use the remaining code in the <strong class="source-inline">UpdatePatrolState</strong> function to rotate the tank and move it toward the next waypoint.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor170"/>The Chase state</h2>
			<p>In the <strong class="bold">Chase</strong> state, the<a id="_idIndexMarker123"/> tank actively tries to get near the player's tank. In simple terms, the<a id="_idIndexMarker124"/> destination point becomes the player's tank itself. The <strong class="bold">Chase</strong> state implementation code is shown here:</p>
			<p class="source-code">protected void UpdateChaseState() {</p>
			<p class="source-code">    // Set the target position as the player position </p>
			<p class="source-code">    destPos = playerTransform.position;</p>
			<p class="source-code">    // Check the distance with player tank When</p>
			<p class="source-code">    // the distance is near, transition to attack state </p>
			<p class="source-code">    float dist = Vector3.Distance(transform.position,</p>
			<p class="source-code">      playerTransform.position);</p>
			<p class="source-code">    if (dist &lt;= attackRadius) {</p>
			<p class="source-code">        curState = FSMState.Attack;</p>
			<p class="source-code">    } else if (dist &gt;= playerNearRadius {</p>
			<p class="source-code">        curState = FSMState.Patrol;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    transform.Translate(Vector3.forward * Time.deltaTime *</p>
			<p class="source-code">                        curSpeed);</p>
			<p class="source-code">}</p>
			<p>In this state, we first set the destination point as the player. Then, we continue checking the player's distance from the tank. If the player is close enough, the AI switches to the <strong class="bold">Attack</strong> state. On the other hand, if the player's tank manages to escape and goes too far, the AI goes back to the <strong class="bold">Patrol</strong> state.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor171"/>The Attack state</h2>
			<p>The <strong class="bold">Attack</strong> state is <a id="_idIndexMarker125"/>precisely what you expect: the enemy tank aims and shoots at the player. The <a id="_idIndexMarker126"/>following code block is the implementation code for the <strong class="bold">Attack</strong> state:</p>
			<p class="source-code">protected void UpdateAttackState() {</p>
			<p class="source-code">    destPos = playerTransform.position;</p>
			<p class="source-code">    Vector3 frontVector = Vector3.forward;</p>
			<p class="source-code">    float dist = Vector3.Distance(transform.position,</p>
			<p class="source-code">      playerTransform.position);</p>
			<p class="source-code">    if (dist &gt;= attackRadius &amp;&amp; dist &lt; playerNearRadius {</p>
			<p class="source-code">        Quaternion targetRotation = </p>
			<p class="source-code">          Quaternion. FromToRotation(destPos – </p>
			<p class="source-code">                                     transform.position); </p>
			<p class="source-code">        transform.rotation = Quaternion.Slerp(</p>
			<p class="source-code">          transform.rotation, targetRotation,</p>
			<p class="source-code">          Time.deltaTime * curRotSpeed);</p>
			<p class="source-code">        transform.Translate(Vector3.forward * </p>
			<p class="source-code">                            Time.deltaTime * curSpeed);</p>
			<p class="source-code">        curState = FSMState.Attack;</p>
			<p class="source-code">    } else if (dist &gt;= playerNearRadius) {</p>
			<p class="source-code">        curState = FSMState.Patrol;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Rotate the turret to the target point</p>
			<p class="source-code">    // The rotation is only around the vertical axis of the</p>
			<p class="source-code">    // tank.</p>
			<p class="source-code">    Quaternion targetRotation = Quaternion.FromToRotation(</p>
			<p class="source-code">      frontVector, destPos - transform.position);</p>
			<p class="source-code">    turret.rotation = Quaternion.Slerp(turret.rotation,</p>
			<p class="source-code">      turretRotation, Time.deltaTime * curRotSpeed);</p>
			<p class="source-code">    //Shoot the bullets</p>
			<p class="source-code">    if (Mathf.Abs(Quaternion.Dot(turretRotation,</p>
			<p class="source-code">      turret.rotation)) &gt; 1.0f - maxFireAimError) {</p>
			<p class="source-code">        ShootBullet();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">private void ShootBullet() {</p>
			<p class="source-code">    if (elapsedTime &gt;= shootRate) {</p>
			<p class="source-code">        Instantiate(Bullet, bulletSpawnPoint.position,</p>
			<p class="source-code">                    bulletSpawnPoint.rotation);</p>
			<p class="source-code">    <a id="_idTextAnchor172"/><a id="_idTextAnchor173"/><a id="_idTextAnchor174"/><a id="_idTextAnchor175"/>    elapsedTime = 0.0f;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In the first line, we still set the destination point to the player's position. After all, even when attacking, we need to keep a close distance from the player. Then, if the player tank is close enough, the <a id="_idIndexMarker127"/>AI tank rotates the <strong class="source-inline">turret</strong> object in the direction of the player tank<a id="_idIndexMarker128"/> and then starts shooting. Finally, if the player's tank goes out of range, the tank goes back to the <strong class="bold">Patrol</strong> state.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor176"/>The Dead state</h2>
			<p>The <strong class="bold">Dead</strong> state is <a id="_idIndexMarker129"/>the final state. Once a tank is in the <strong class="bold">Dead</strong> state, it explodes and gets <a id="_idIndexMarker130"/>uninstantiated. The following is the code for the <strong class="bold">Dead</strong> state:</p>
			<p class="source-code">protected void UpdateDeadState() {</p>
			<p class="source-code">    // Show the dead animation with some physics effects </p>
			<p class="source-code">    if (!bDead) {</p>
			<p class="source-code">        bDead = true;</p>
			<p class="source-code">        Explode();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>As you can see, the code is straightforward – if the tank has reached the <strong class="bold">Dead</strong> state, we make it explode:</p>
			<p class="source-code">protected void Explode() {</p>
			<p class="source-code">    float rndX = Random.Range(10.0f, 30.0f); </p>
			<p class="source-code">    float rndZ = Random.Range(10.0f, 30.0f); </p>
			<p class="source-code">    for (int i = 0; i &lt; 3; i++) {</p>
			<p class="source-code">        rigidbody.AddExplosionForce(10000.0f,</p>
			<p class="source-code">          transform.position - new Vector3(rndX, </p>
			<p class="source-code">          10.0f, rndZ), 40.0f, 10.0f);</p>
			<p class="source-code">        rigidbody.velocity = transform.TransformDirection(</p>
			<p class="source-code">          new Vector3(rndX, 20.0f, rndZ));</p>
			<p class="source-code">    <a id="_idTextAnchor177"/><a id="_idTextAnchor178"/><a id="_idTextAnchor179"/><a id="_idTextAnchor180"/>}</p>
			<p class="source-code">    Destroy(gameObject, 1.5f);</p>
			<p class="source-code">}</p>
			<p>Here's a small function that<a id="_idIndexMarker131"/> gives a nice explosion effect. We apply a random <strong class="source-inline">ExplosionForce</strong> function <a id="_idIndexMarker132"/>to the tank's <strong class="source-inline">Rigidbody</strong> component. If everything is correct, you should see the tank flying in the air in a random direction for the player's amusement.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor181"/>Taking damage</h2>
			<p>To complete the<a id="_idIndexMarker133"/> demo, we need to add another small detail: we need the tanks to take damage when they get hit by a bullet. Every time a bullet enters the collision area of the tank, the <strong class="source-inline">health</strong> property's value decreases, according to the <strong class="source-inline">Bullet</strong> object's <strong class="source-inline">damage</strong> value:</p>
			<p class="source-code">void OnCollisionEnter(Collision collision) {</p>
			<p class="source-code">    // Reduce health </p>
			<p class="source-code">    if(collision.gameObject.tag == "Bullet") {</p>
			<p class="source-code">        health -=collision.gameObject.GetComponent</p>
			<p class="source-code">          &lt;Bullet&gt;().damage;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>You can open the <strong class="source-inline">SimpleFSM.scene</strong> file in Unity; you should see the AI tanks patrolling, chasing, and attacking the player. Our player's tank doesn't take damage from AI tanks yet, so it never gets destroyed. But the AI tanks have the health property and take damage from the player's bullets, so you'll see them explode once their health property reaches zero.</p>
			<p>If your demo doesn't work, try playing with different values in the Inspector for the <strong class="bold">SimpleFSM</strong> components. After all, the values may change, depe<a id="_idTextAnchor182"/>nding on the scale of your project:</p>
			<p class="figure-caption"><a id="_idTextAnchor183"/><a id="_idTextAnchor184"/><a id="_idTextAnchor185"/></p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/B17984_02_10.jpg" alt="Figure 2.10 – The AI tanks in action&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.10 – The AI tanks in action</p>
			<p>In this demo, we<a id="_idIndexMarker134"/> used a very simple FSM, but now it's time to step up the challenge and implement a complete FSM framework.</p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor186"/>Using an FSM framework</h1>
			<p>The FSM framework we're<a id="_idIndexMarker135"/> going to use here is adapted from <a id="_idIndexMarker136"/>the <strong class="bold">Deterministic Finite State Machine</strong> framework, based on <a href="B17984_03_Epub.xhtml#_idTextAnchor222"><em class="italic">Chapter 3</em></a><em class="italic">.1</em> of <em class="italic">Game Programming Gems 1</em> by Eric Dybsend. We'll only be looking at the differences between this FSM and the one we made earlier. For this reason, it is important that you follow the example code found in the <strong class="source-inline">Chapter02</strong> folder of the book repository (<a href="https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition">https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition</a>). In particular, we will look at the <strong class="bold">AdvancedFSM</strong> scene. </p>
			<p>In this section, we will study how the framework works and how w<a id="_idTextAnchor187"/>e can use this to implement our tank AI. <strong class="source-inline">AdvancedFSM</strong> and <strong class="source-inline">FSMState</strong> are the two main classes of<a id="_idTextAnchor188"/><a id="_idTextAnchor189"/> our framew<a id="_idTextAnchor190"/>ork. So, let's take a look at them first.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor191"/>The AdvancedFSM class</h2>
			<p>The <strong class="source-inline">AdvancedFSM</strong> class manages<a id="_idIndexMarker137"/> all the <strong class="source-inline">FSMState</strong> classes we've implemented and keeps them updated with the transitions and the current state. So, the first thing to do before using our framework is to declare the transitions and states that we plan to implement for our AI tanks.</p>
			<p>Let's start by <a id="_idIndexMarker138"/>creating <strong class="source-inline">AdvancedFSM.cs</strong>:</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code">using System.Collections;</p>
			<p class="source-code">using System.Collections.Generic;</p>
			<p class="source-code">public enum Transition {</p>
			<p class="source-code">    None = 0, SawPlayer, ReachPlayer, LostPlayer, NoHealth,</p>
			<p class="source-code">}</p>
			<p class="source-code">public enum FSMStateID {</p>
			<p class="source-code">    None = 0, Patrolling, Chasing, Attacking, Dead,</p>
			<p class="source-code">}</p>
			<p>Here, we define two enumerations, one for the set of states and one for the set of transitions. Then, we add a list object to store the <strong class="source-inline">FSMState</strong> objects and two local variables to store the current ID of the <strong class="source-inline">FSMState</strong> class and the current <strong class="source-inline">FSMState</strong> itself.</p>
			<p>The <strong class="source-inline">AddFSMState</strong> and <strong class="source-inline">DeleteState</strong> methods add and delete the instances of the <strong class="source-inline">FSMState</strong> class in our list respectively. When the <strong class="source-inline">PerformTransition</strong> method gets called, it updates the <strong class="source-inline">CurrentState</strong> variable with the new state, according to the transition:</p>
			<p class="source-code">public class AdvancedFSM : FSM {</p>
			<p class="source-code">    private List&lt;FSMState&gt; fsmStates;<a id="_idTextAnchor192"/><a id="_idTextAnchor193"/> </p>
			<p class="source-code">    private FSMStateID currentStateID; </p>
			<p class="source-code">    public FSMStateID CurrentStateID {</p>
			<p class="source-code">        get {</p>
			<p class="source-code">            return currentStateID;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    private FSMState currentState; </p>
			<p class="source-code">    public FSMState CurrentState {</p>
			<p class="source-code">        get {</p>
			<p class="source-code">      <a id="_idTextAnchor194"/><a id="_idTextAnchor195"/><a id="_idTextAnchor196"/><a id="_idTextAnchor197"/>      return currentState;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p>Now that the<a id="_idIndexMarker139"/> data part of the class is ready, we can proceed with the internal logic of the FSM framework.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor198"/>The FSMState class</h2>
			<p><strong class="source-inline">FSMState</strong> manages the <a id="_idIndexMarker140"/>transitions to other states. It has a dictionary object called <strong class="source-inline">map</strong> in which we store the key-value pairs of transitions and states. So, for example, the <strong class="source-inline">SawPlayer</strong> transition maps to the <strong class="source-inline">Chasing</strong> state, <strong class="source-inline">LostPlayer</strong> maps to the <strong class="source-inline">Patrolling</strong> state, and so on.</p>
			<p>Let's create an <strong class="source-inline">FSMState.cs</strong> file:</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code">using System.Collections;</p>
			<p class="source-code">using System.Collections.Generic;</p>
			<p class="source-code">public abstract class FSMState {</p>
			<p class="source-code">    protected Dictionary&lt;Transition, FSMStateID&gt; map = </p>
			<p class="source-code">      new Dictionary&lt;Transition, FSMStateID&gt;();</p>
			<p class="source-code">    // Continue...</p>
			<p>The <strong class="source-inline">AddTransition</strong> and <strong class="source-inline">DeleteTransition</strong> methods add and delete transitions from their state-transition dictionary <strong class="source-inline">map</strong> object. The <strong class="source-inline">GetOutputState</strong> method looks up from the <strong class="source-inline">map</strong> object and returns the state based on the input transition.</p>
			<p>The <strong class="source-inline">FSMState</strong> class <a id="_idIndexMarker141"/>also declares two abstract methods that its child classes need to implement. They are as follows:</p>
			<p class="source-code">...</p>
			<p class="source-code">    public abstract void CheckTransitionRules(Transform </p>
			<p class="source-code">      player, Transform npc);</p>
			<p class="source-code">    public abstract void RunState(Tr<a id="_idTextAnchor199"/><a id="_idTextAnchor200"/>ansform player,</p>
			<p class="source-code">      Transform npc);</p>
			<p class="source-code">...</p>
			<p>The <strong class="source-inline">CheckTransitionRules</strong> method has to check whether the state should carry out <a id="_idTextAnchor201"/><a id="_idTextAnchor202"/>the transition to another state. Instead, the <strong class="source-inline">RunState</strong> method does the actual execution of the tasks for the <strong class="source-inline">currentState</strong> variable, such as moving toward a destination point and chasing or attacking the player. Both methods require transformed data from th<a id="_idTextAnchor203"/><a id="_idTextAnchor204"/>e player and <a id="_idIndexMarker142"/>the <strong class="bold">Non Playable Cha<a id="_idTextAnchor205"/><a id="_idTextAnchor206"/>racter</strong> (<strong class="bold">NPC</strong>) entity obtained using this class.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor207"/>The state classes</h2>
			<p>Unlike the <a id="_idIndexMarker143"/>previous <strong class="source-inline">SimpleFSM</strong> example, we write the states for our tank AI in separate classes that inherit from the <strong class="source-inline">FSMState</strong> class, such as <strong class="source-inline">AttackState</strong>, <strong class="source-inline">ChaseState</strong>, <strong class="source-inline">DeadSt<a id="_idTextAnchor208"/><a id="_idTextAnchor209"/>ate</strong>, and <strong class="source-inline">PatrolState</strong>. All of them implement the <strong class="source-inline">CheckTransitionRules</strong> and <strong class="source-inline">RunState</strong> methods. Let's take<a id="_idTextAnchor210"/><a id="_idTextAnchor211"/><a id="_idTextAnchor212"/><a id="_idTextAnchor213"/> a look at the <strong class="source-inline">PatrolState</strong> class as an example.</p>
			<h3>The PatrolState class</h3>
			<p>This class has three<a id="_idIndexMarker144"/> methods: a constructor, <strong class="source-inline">CheckTransitionRules</strong>, and <strong class="source-inline">RunState</strong>. Let's create the <strong class="source-inline">PatrolState</strong> class in the <strong class="source-inline">PatrolState.cs</strong> file:</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code">using System.Collections;</p>
			<p class="source-code">public class PatrolState : FSMState {</p>
			<p class="source-code">    private Vector3 destPos;</p>
			<p class="source-code">    private Transform[] waypoints;</p>
			<p class="source-code">    private float curRotSpeed = 1.0f;</p>
			<p class="source-code">    private float curSpeed = 100.0f;</p>
			<p class="source-code">    private float playerNearRadius;</p>
			<p class="source-code">    private float patrollRadius;</p>
			<p class="source-code">    public PatrolState(Transform[] wp, float</p>
			<p class="source-code">      playerNearRadius, float patrollRadius) {</p>
			<p class="source-code">        waypoints = wp;</p>
			<p class="source-code">        stateID = FSMStateID.Patrolling;</p>
			<p class="source-code">        this.playerNearRadius = playerNearRadius;</p>
			<p class="source-code">        this.patrollRadius = patrollRadius;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public override void CheckTransitionRules(</p>
			<p class="source-code">      Transform player, Transform npc) {</p>
			<p class="source-code">        // Check the distance with player tank</p>
			<p class="source-code">        // When the distance is near, transition to chase</p>
			<p class="source-code">       // state </p>
			<p class="source-code">        if (Vector3.Distance(npc.position, player.position)</p>
			<p class="source-code">            &lt;= playerNearRadius) {</p>
			<p class="source-code">            Debug.Log("Switch to Chase State");</p>
			<p class="source-code">            NPCTankController npcTankController = </p>
			<p class="source-code">              npc.GetComponent&lt;NPCTankController&gt;();</p>
			<p class="source-code">            if (npcTankController != null) {</p>
			<p class="source-code">                npcTankController.SetTransition(</p>
			<p class="source-code">                Transition.SawPlayer);</p>
			<p class="source-code">            } else {</p>
			<p class="source-code">                Debug.LogError("NPCTankController not found</p>
			<p class="source-code">                                in NPC");</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public override void RunState(Transform player,</p>
			<p class="source-code">      Transform npc) {</p>
			<p class="source-code">        // Find another random patrol point if the current</p>
			<p class="source-code">        // point is reached</p>
			<p class="source-code">        if (Vector3.Distance(npc.position, destPos) &lt;= </p>
			<p class="source-code">            patrollRadius) {</p>
			<p class="source-code">            Debug.Log("Reached to the destination point\n</p>
			<p class="source-code">                       calculating the next point"); </p>
			<p class="source-code">            FindNextPoint();</p>
			<p class="source-code">        }</p>
			<p class="source-code">        // Rotate to the target point</p>
			<p class="source-code">        Quaternion targetRotation =</p>
			<p class="source-code">          Quaternion.FromToRotation(Vector3.forward,</p>
			<p class="source-code">          destPos - npc.position);</p>
			<p class="source-code">        npc.rotation = Quaternion.Slerp(npc.rotation,</p>
			<p class="source-code">          targetRotation, Time.deltaTime * curRotSpeed);</p>
			<p class="source-code">        // Go Forward </p>
			<p class="source-code">        npc.Translate(Vector3.forward * Time.deltaTime * </p>
			<p class="source-code">                      curSpeed);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">constructor</strong> method takes the <strong class="source-inline">waypoints</strong> array, stores them in a local array, and then initializes properties such as movement and rotation speed. The <strong class="source-inline">Reason</strong> method checks the <a id="_idIndexMarker145"/>distance between itself (the AI tank) and the player tank. If the player tank is in range, it sets the transition ID to the <strong class="source-inline">SawPlayer</strong> transition using the <strong class="source-inline">SetTransition</strong> method of the <strong class="source-inline">NPCTankController</strong> class, which looks as follows:</p>
			<p class="source-code">public void SetTransition(Transition t) {</p>
			<p class="source-code">    PerformTransition(t);</p>
			<p class="source-code">}</p>
			<p>The preceding function is just a wrapper method that calls the <strong class="source-inline">PerformTransition</strong> method of the <strong class="source-inline">AdvanceFSM</strong> class. In turn, that method updates the <strong class="source-inline">CurrentState</strong> variable with the one responsible for this transition, using the <strong class="source-inline">Transition</strong> object and the state-transition dictionary map object from the <strong class="source-inline">FSMState</strong> class. The <strong class="source-inline">Act</strong> method updates the AI tank's destination point, rotates the tank in that direction, and moves it forward.</p>
			<p>Other state <a id="_idIndexMarker146"/>classes also follow this template with different reasoning and acting procedures. We've already seen them in our previous simple FSM examples, and therefore, we won't describe them again here. See whether you can figure out how to s<a id="_idTextAnchor214"/><a id="_idTextAnchor215"/>et up these classes on your own. If you get stuck, the assets that come w<a id="_idTextAnchor216"/><a id="_idTextAnchor217"/>ith this book contain the code for you to look at.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor218"/>The NPCTankController class</h2>
			<p>For the tank AI, we <a id="_idIndexMarker147"/>set up the states for our NPC by using the <strong class="source-inline">NPCTankController</strong> class. This class inherits from <strong class="source-inline">AdvanceFSM</strong>:</p>
			<p class="source-code">private void ConstructFSM() {</p>
			<p class="source-code">    PatrolState patrol = new PatrolState(waypoints,</p>
			<p class="source-code">      playerNearRadius, patrollingRadius);</p>
			<p class="source-code">    patrol.AddTransition(Transition.SawPlayer,</p>
			<p class="source-code">                         FSMStateID.Chasing);</p>
			<p class="source-code">    patrol.AddTransition(Transition.NoHealth,</p>
			<p class="source-code">                         FSMStateID.Dead);</p>
			<p class="source-code">    ChaseState chase = new ChaseState(waypoints); </p>
			<p class="source-code">     chase.AddTransition(Transition.LostPlayer,</p>
			<p class="source-code">                         FSMStateID.Patrolling); </p>
			<p class="source-code">    chase.AddTransition(Transition.ReachPlayer,</p>
			<p class="source-code">                        FSMStateID.Attacking); </p>
			<p class="source-code">    chase.AddTransition(Transition.NoHealth,</p>
			<p class="source-code">                        FSMStateID.Dead);</p>
			<p class="source-code">    AttackState attack = new AttackState(waypoints); </p>
			<p class="source-code">   attack.AddTransition(Transition.LostPlayer,</p>
			<p class="source-code">                        FSMStateID.Patrolling); </p>
			<p class="source-code">    attack.AddTransition(Transition.SawPlayer,</p>
			<p class="source-code">                         FSMStateID.Chasing); </p>
			<p class="source-code">    attack.AddTransition(Transition.NoHealth,</p>
			<p class="source-code">                         FSMStateID.Dead);</p>
			<p class="source-code">    DeadState dead = new DeadState(); </p>
			<p class="source-code">    dead.AddTransition(Transition.NoHealth,</p>
			<p class="source-code">                       FSMStateID.Dead);</p>
			<p class="source-code">    AddFSMState(patrol); </p>
			<p class="source-code">    AddFSMState(chase); </p>
			<p class="source-code">    AddFSMState(attack);</p>
			<p class="source-code">    AddFSMState(dead);</p>
			<p class="source-code">}</p>
			<p>Here's the <a id="_idIndexMarker148"/>beauty of using our FSM framework: since the states are self-managed within their respective classes, our <strong class="source-inline">NPCTankController</strong> class only needs to call the <strong class="source-inline">Reason</strong> and <strong class="source-inline">Act</strong> methods of the currently active state.</p>
			<p>This fact eliminates the need to write a long list of the <strong class="source-inline">if</strong>/<strong class="source-inline">else</strong> and <strong class="source-inline">switch</strong> statements. Instead, our states are now nicely packaged in classes of their own, which makes the code more manageable, as the number of states and transitions between them grows more and more in larger projects:</p>
			<p class="source-code">protected override void FSMFixedUpdate() {</p>
			<p class="source-code">    CurrentState.Reason(playerTransform, transform);</p>
			<p class="source-code">    CurrentState.Act(playerTransform, transform);</p>
			<p class="source-code">}</p>
			<p>The main steps to<a id="_idIndexMarker149"/> use this framework can be summarized as follows:</p>
			<ol>
				<li value="1">Declare the transitions and states in the <strong class="source-inline">AdvanceFSM</strong> class.</li>
				<li>Write the state classes inherited from the <strong class="source-inline">FSMState</strong> class, and then implement the <strong class="source-inline">Reason</strong> and <strong class="source-inline">Act</strong> methods.</li>
				<li>Write the custom NPC AI class inherited from <strong class="source-inline">AdvanceFSM</strong>.</li>
				<li>Create states from the state classes, and then add transition and state pairs using the <strong class="source-inline">AddTransition</strong> method of the <strong class="source-inline">FSMState</strong> class.</li>
				<li>Add those states into the state list of the <strong class="source-inline">AdvanceFSM</strong> class, using the <strong class="source-inline">AddFSMState</strong> method.</li>
				<li>Call the <strong class="source-inline">CurrentState</strong> variab<a id="_idTextAnchor219"/>le's <strong class="source-inline">Reason</strong> and <strong class="source-inline">Act</strong> methods in the game update cycle.</li>
			</ol>
			<p>You can play around with the <strong class="source-inline">AdvancedFSM</strong> scene in Unity. It'll run the same way as our previous <strong class="source-inline">SimpleFSM</strong> examp<a id="_idTextAnchor220"/>le, but the code is now more organized and manageable.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor221"/>Summary</h1>
			<p>In this chapter, we learned how to implement state machines in Unity3D based on a simple tank game. We first looked at how to implement FSM by using <strong class="source-inline">switch</strong> statements. Then, we studied how to use a framework to make AI implementation easier to manage and extend.</p>
			<p>In the next chapter, we will look at randomness and probability and see how we can use them to make the outcome of our games more unpredictable.</p>
		</div>
	</body></html>