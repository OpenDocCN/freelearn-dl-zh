<html><head></head><body>
		<div><h1 id="_idParaDest-29"><em class="italic"><a id="_idTextAnchor100"/><a id="_idTextAnchor101"/>Chapter 2</em>: Finite State Machines</h1>
			<p>In this chapter, we'll learn how to implement a <strong class="bold">Finite State Machine</strong> (<strong class="bold">FSM</strong>) in a Unity3D game by studying the simple tank game-mechanic example that comes with this book.</p>
			<p>In our game, the player controls a tank. The enemy tanks move around the scene, following four waypoints. Once the player's tank enters the vision range of the enemy tanks, they start chasing it; then, once they are close enough to attack, they'll start shooting at our player's tank.</p>
			<p>To control the AI of our enemy tanks, we use an FSM. First, we'll use simple <code>switch</code> statements to implement our tank AI states. Then, we'll use a more complex and engineered FSM framework that will allow us greater flexibility in designing the character's FSM.</p>
			<p>The topics we will be covering in this chapter are the following: </p>
			<ul>
				<li>Implementing the player's tank</li>
				<li>Implementing a bullet class </li>
				<li>Setting up waypoints</li>
				<li>Creating the abstract FSM class</li>
				<li>Using a simple FSM for the enemy tank AI</li>
				<li>Using an FSM framework</li>
			</ul>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor102"/><a id="_idTextAnchor103"/><a id="_idTextAnchor104"/>Technical requirements</h1>
			<p>For this chapter, you just need Unity3D 2022. You can find the example project described in this chapter in the <code>Chapter 2</code> folder in the book repository: <a id="_idTextAnchor105"/><a id="_idTextAnchor106"/><a href="https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter02">https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition/tree/main/Chapter02</a>.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor107"/>Implementing the player's tank</h1>
			<p>Before writing <a id="_idIndexMarker086"/>the script for our player's tank, let's look at how we set up the <code>Rigidbody</code> and <code>Box Collider</code> components.</p>
			<p>The <code>controller</code> class:</p>
			<div><div><img src="img/B17984_02_1.jpg" alt="Figure 2.1 – Our tank entity&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – Our tank entity</p>
			<p><a id="_idTextAnchor108"/><a id="_idTextAnchor109"/>The <code>PlayerTankController</code> class controls the player's tank. We use the <em class="italic">W</em>, <em class="italic">A</em>, <em class="italic">S</em>, and <em class="italic">D</em> keys to move and steer the tank and the left mouse button to aim and shoot from the <strong class="bold">Turret</strong> object.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">In this book, we assume that you are using a <em class="italic">QWERTY</em> keyboard and a two-button mouse, with the left mouse button set as the primary mouse button. If you are using a different keyboard, all you have to do is pretend that you are using a <em class="italic">QWERTY</em> keyboard or try to <a id="_idTextAnchor110"/><a id="_idTextAnchor111"/>modify the code to adapt it to your keyboard layout. It is pretty easy!</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor112"/><a id="_idTextAnchor113"/>Initializing the Tank object</h2>
			<p>Let's start<a id="_idIndexMarker087"/> creating the <code>PlayerTankController</code> class by setting up the <code>Start</code> function and the <code>Update</code> function in the <code>PlayerTankController.cs</code> file:</p>
			<pre>using UnityEngine;
using System.Collections;
public class PlayerTankController : MonoBehaviour {
    public GameObject Bullet;
    public GameObject Turret;
    public GameObject bulletSpawnPoint;
    public float rotSpeed = 150.0f;
     public float turretRotSpeed = 10.0f;
    public float maxForwardSpeed = 300.0f; 
    public float maxBackwardSpeed = -300.0f;
    public float shootRate = 0.5f; 
    private float curSpeed, targetSpeed;
    protected float elapsedTime;
    void Start() {
   }
    void Update() {
        UpdateWeapon();
        UpdateControl();<a id="_idTextAnchor114"/>
    <a id="_idTextAnchor115"/>}</pre>
			<p>We can see in <a id="_idIndexMarker088"/>the hierarchy that the <strong class="bold">PlayerTank</strong> game object has one child called <strong class="bold">Turret</strong>, and in turn, the first child of the <strong class="bold">Turret</strong> object is called <strong class="bold">SpawnPoint</strong>. To set up the controller, we need to link (by dragging and dropping) <strong class="bold">Turret</strong> and <strong class="bold">SpawnPoint</strong> into the corresponding fields in the Inspector:</p>
			<div><div><img src="img/B17984_02_2.jpg" alt="Figure 2.2 – The Player Tank Controller component in the Inspector&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – The Player Tank Controller component in the Inspector</p>
			<p>Later, after creating the <code>Bullet</code> variable using the Inspector. Then, finally, the <code>Update</code> function calls the <code>UpdateControl</code> and <code>UpdateWeapon</code> functions. We will discuss the content of these functions in the following section.<a id="_idTextAnchor116"/><a id="_idTextAnchor117"/><a id="_idTextAnchor118"/><a id="_idTextAnchor119"/></p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor120"/>Shooting the bullet</h2>
			<p>The mechanism for <a id="_idIndexMarker089"/>shooting the bullet is simple. Whenever the player clicks the left mouse button, we check whether the total elapsed time since the last fire is greater than the weapon's fire rate. If it is, then we create a new <code>bulletSpawnPoint</code> transform's position. This check prevents the player from shooting a continuous stream of bullets.</p>
			<p>For this, we add the following function to the <code>PlayerTankController.cs</code> file:</p>
			<pre>void UpdateWeapon() {
    elapsedTime += Time.deltaTime;
    if (Input.GetMouseButtonDown(0)) {
        if (elapsedTime &gt;= shootRate) {
            //Reset the time 
            elapsedTime = 0.0f;
            //Instantiate the bullet
            Instantiate(Bullet,
              bulletSpawnPoint.transform.position,
              bulletSpawnPoint.transform.rotation);
        }
    }
}</pre>
			<p>Now, we can attach this controller script to the <strong class="bold">PlayerTank</strong> object. If we run the game, we should be able to shoot from our tanks. Now, it is time to implement the tank's movement controls<a id="_idTextAnchor121"/><a id="_idTextAnchor122"/><a id="_idTextAnchor123"/><a id="_idTextAnchor124"/>.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor125"/>Controlling the tank</h2>
			<p>The player can<a id="_idIndexMarker090"/> rotate the <code>UpdateControl</code> function to the <code>PlayerTankController.cs</code> file:</p>
			<pre>void UpdateControl() {
    // AIMING WITH THE MOUSE
    // Generate a plane that intersects the Transform's
    // position with an upwards normal.
    Plane playerPlane = new Plane(Vector3.up,
      transform.position + new Vector3(0, 0, 0));
    // Generate a ray from the cursor position 
    Ray RayCast =
      Camera.main.ScreenPointToRay(Input.mousePosition);
    // Determine the point where the cursor ray intersects
    // the plane.
    float HitDist = 0;
    // If the ray is parallel to the plane, Raycast will
    // return false.
    if (playerPlane.Raycast(RayCast, out HitDist)) {
        // Get the point along the ray that hits the
        // calculated distance.
        Vector3 RayHitPoint = RayCast.GetPoint(HitDist);
        Quaternion targetRotation = 
          Quaternion.LookRotation(RayHitPoint –
                                  transform.position);
        Turret.transform.rotation = Quaternion.Slerp(
          Turret.transform.rotation, targetRotation,
          Time.deltaTime * turretRotSpeed);
    }
}</pre>
			<p>We use raycasting to <a id="_idIndexMarker091"/>determine the turning direction by finding the <code>mousePosition</code> coordinates on the battlefield:</p>
			<div><div><img src="img/B17984_02_3.jpg" alt="Figure 2.3 – Raycast to aim with the mouse&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – Raycast to aim with the mouse</p>
			<p class="callout-heading">Information</p>
			<p class="callout"><strong class="bold">Raycasting</strong> is a tool <a id="_idIndexMarker092"/>provided by default in the Unity physics engine. It allows us to find the intersection point between an imaginary line (the <em class="italic">ray</em>) and a collider in the scene. Imagine this as a laser pointer: we can fire our laser in a direction and see the point where it hits. However, this is a relatively expensive operation. While, in general, you can confidently handle 100–200 raycasts per frame, their performance is greatly affected by the length of the ray and the number and types of colliders in the scene. So, as a quick tip, try not to use a lot of raycasts with mesh colliders and use layer masks to filter out unnecessary collide<a id="_idTextAnchor126"/><a id="_idTextAnchor127"/>rs.</p>
			<p>This is how it works:</p>
			<ol>
				<li>Set up a plane that <a id="_idIndexMarker093"/>intersects with the player tank with an upward normal.</li>
				<li>Shoot a ray from screen space with the mouse position (in the preceding diagram, we assume that we're looking down at the tank).</li>
				<li>Find the point where the ray intersects the plane.</li>
				<li>Finally, find the rotation from the current position to that intersection point.</li>
			</ol>
			<p>Then, we check for the key-pressed input and move or rotate the tank accordingly. We add the following code at the end of the <code>UpdateControl</code> function:</p>
			<pre>if (Input.GetKey(KeyCode.W)) {
    targetSpeed = maxForwardSpeed;
} else if (Input.GetKey(KeyCode.S)) {
    targetSpeed = maxBackwardSpeed;
} else {
    targetSpeed = 0;
}
if (Input.GetKey(KeyCode.A)) {
    transform.Rotate(0, -rotSpeed * Time.deltaTime, 0.0f);
} else if (Input.GetKey(KeyCode.D)) {
    transform.Rotate(0, rotSpeed * Time.deltaTime, 0.0f);
}
//Determine current speed
curSpeed = Mathf.Lerp(curSpeed, targetSpeed, 7.0f *
                      Time.deltaTi<a id="_idTextAnchor128"/>me);
transform.Translate(Vector3.forward * Time.deltaTime *
                    curSp<a id="_idTextAnchor129"/>eed);</pre>
			<p>The preceding code <a id="_idIndexMarker094"/>represents the classic <em class="italic">WASD</em> control scheme. The tank rotates with the <em class="italic">A</em> and <em class="italic">D</em> keys, and moves forward and backward with <em class="italic">W</em> and <em class="italic">S</em>. </p>
			<p class="callout-heading">Information</p>
			<p class="callout">Depending on your level of Unity expertise, you may wonder what about the <code>Ler<a id="_idTextAnchor130"/><a id="_idTextAnchor131"/>p</code> and <code>Time.deltaTime</code> multiplications. It may be worth a slight digression. First, <code>Lerp</code> function to smoothly spread the velocity changes over multiple frames so that the tank's movement doesn't look like it's accelerating and decelerating instantaneously. The <code>7.0f</code> value is just a <em class="italic">smoothing factor</em>, and you can play with it to find your favorite value (the bigger the value, the greater the tank's acceleration).</p>
			<p class="callout">Then, we multiply everything by <code>Time.deltaTime</code>. This value represents the time in seconds between now and the last frame, and we use it to make our velocity independent from<a id="_idIndexMarker096"/> the frame rate. For more info, refer to <a href="https://learn.unity.com/tutorial/delta-time">https://learn.unity.com/tutorial/delta-time</a>.</p>
			<p>Next, it is time to implement the projectiles fired by the player and enemy<a id="_idTextAnchor132"/><a id="_idTextAnchor133"/><a id="_idTextAnchor134"/><a id="_idTextAnchor135"/> tanks.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor136"/>Implementing a Bullet class</h1>
			<p>Next, we set up <a id="_idIndexMarker097"/>our <strong class="bold">Bullet</strong> prefab with two orthogonal planes and a box collider, using a laser-like material and a <strong class="bold">Particles/Additive-Layer</strong> property in the <strong class="bold">Shader</strong> field:</p>
			<div><div><img src="img/B17984_02_4.jpg" alt="Figure 2.4 – Our Bullet prefab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – Our Bullet prefab</p>
			<p>The <a id="_idIndexMarker098"/>code in the <code>Bullet.cs</code> file is as follows:</p>
			<pre>using UnityEngine;
using System.Colle<a id="_idTextAnchor137"/>ctions;
public class Bullet : Mono<a id="_idTextAnchor138"/>Behaviour {
    //Explosion Effect 
    [SerializeField] // Used to expose in the inspector private 
                     // fields!
    private GameObject Explosion;
    [SerializeField]
    private float Speed = 600.0f;
    [SerializeField]
    private float LifeTime = 3.0f;
    public int damage = 50;
    void Start() {
        Destroy(gameObject, LifeTime);
    }
    void Update() {
        transform.position +=
        transform.forward * Speed * Time.deltaTime;
    }
    void OnCollisionEnter(Collision collision) {
        ContactPoint contact = collision.contacts[0];
        Instantiate(Explosion, contact.point,
                    Quaternion.identity);
        Destroy(gameObject);
    }
}</pre>
			<p>The <code>Bullet</code> class <a id="_idIndexMarker099"/>has three properties: <code>damage</code>, <code>Speed</code>, and <code>Lifetime</code> – the latter so that the bullet is automatically destroyed after a certain amount of time. Note that we use <code>[SerializeField]</code> to show the private fields in the Inspector; by default, in fact, Unity only shows public fields. It is a good practice to set fields that we need to access from other classes as public-only. </p>
			<p>As you can see, the <code>Explosion</code> property of the bullet is linked to the <code>ParticleExplosion</code> prefab, which we're not going to discuss in detail. This prefab is in the <code>ParticleEffects</code> folder, so we drop it into the <code>OnCollisionEnter</code> method. The <code>ParticleExplosion</code> prefab uses the <code>AutoDestruct</code> script to <a id="_idIndexMarker100"/>automatically destroy the <code>Explosion</code> object after a small amount of time:</p>
			<pre>using Uni<a id="_idTextAnchor139"/>tyEngine;
public class AutoDestruct : Mo<a id="_idTextAnchor140"/>noBehaviour {
    [SerializeField]
    private float DestructTime = 2.0f;
    void Start() {
        Destroy(gameObject, DestructTime);
    }
}</pre>
			<p>The <code>AutoDestruct</code> script is small but convenient. It just destroys the attached object after a certain number of seconds. Many Unity games use a similar script almost every tim<a id="_idTextAnchor141"/><a id="_idTextAnchor142"/>e for many situations.</p>
			<p>Now that we have a tank that can fire and move, we can set up a simple patrolling path for the en<a id="_idTextAnchor143"/><a id="_idTextAnchor144"/>emy tanks.</p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor145"/>Setting up waypoints</h1>
			<p>By default, the enemy tanks<a id="_idIndexMarker101"/> will patrol the game arena. To implement this behavior, we need to specify first the patrolling path. We will explore path following thoroughly in <a href="B17984_06_Epub.xhtml#_idTextAnchor375"><em class="italic">Chapter 6</em></a>, <em class="italic">Path Following and Steering Behaviors</em>. For now, we limit ourselves to a simple <em class="italic">waypoints path</em>.</p>
			<p>To implement it, we put four <code>WanderPoint</code>:</p>
			<div><div><img src="img/B17984_02_5.jpg" alt="Figure 2.5 – WanderPoint&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5 – WanderPoint</p>
			<p>Here is<a id="_idIndexMarker102"/> what our <strong class="bold">WanderPoint</strong> objects look like:</p>
			<div><div><img src="img/B17984_02_6.jpg" alt="Figure 2.6 – The WanderPoint properties&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.6 – The WanderPoint properties</p>
			<p>Note that <a id="_idIndexMarker103"/>we need to tag these points with a tag called <strong class="bold">WanderPoint</strong>. Later, we will use this tag when we try to find the waypoints from our tank AI. As you can see in its properties, a waypoint is just a <strong class="bold">Cube</strong> game object with the <strong class="bold">Mesh Renderer</strong> checkbox disabled:</p>
			<div><div><img src="img/B17984_02_7.jpg" alt="Figure 2.7 – The gizmo selection panel&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.7 – The gizmo selec<a id="_idTextAnchor146"/><a id="_idTextAnchor147"/>tion panel</p>
			<p>To show these<a id="_idIndexMarker104"/> points in the editor (but not in the game), we use an empty object with a gizmo icon, since all we need from a waypoint is its position and the transformation data. To do that, click the small triangle near the object icon in the Inspector, as shown in<a id="_idTextAnchor148"/><a id="_idTextAnchor149"/> <em class="italic">Figure 2.7</em>.</p>
			<p>We are now ready to give life to the enemy tanks with the power <a id="_idTextAnchor150"/><a id="_idTextAnchor151"/>of the FSM.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor152"/>Creating the abstract FSM class</h1>
			<p>Next, we implement a<a id="_idIndexMarker105"/> generic abstract class to define the enemy tank AI class's methods. This abstract class will be the skeleton of our AI and represent a high-level view of what an enemy tank should do.</p>
			<p>We can see the <a id="_idIndexMarker106"/>code of this class in the <code>FSM.cs</code> file:</p>
			<pre>using UnityEngine;
using System.Collections;
public class FSM : MonoBehaviour {
    protected virtual void Initialize() { } 
    
    protected virtual void FSMUpdate() { } 
    
    protected virtual void FSMFixedUpdate() { }
    // Use this for initialization 
    void Start () {
        Initialize();
    }
    // Update is called once per frame 
    void Update () {
        FSMUpdate();
    }
    void FixedUpdate() {
        FSMFixedUpdate();
    }
}</pre>
			<p>The enemy tanks need only to know the position of the player's tank, their next destination point, and the list of waypoints to choose from while they're patrolling. Once the player tank is in range, they rotate their turret object and start shooting from the bullet spawn point at their fire rate.</p>
			<p>As we explained<a id="_idIndexMarker107"/> before, we will extend this class in two ways: using a simple <em class="italic">if-then-else</em>-based FSM (the <code>SimpleFSM</code> class) and a more engineered but more flexible FSM (<code>AdvancedFSM</code>). These two FSM implementations will inherit the <code>FSM</code> abstract class, and they will implement the three abstract methods: <code>Initialize</code>, <code>FSMUpdate</code>, and <code>FSMFixedUpdate</code>.</p>
			<p>We will see the two different ways to implement these three methods in the next sections. For now, let's start with the basic i<a id="_idTextAnchor153"/><a id="_idTextAnchor154"/><a id="_idTextAnchor155"/><a id="_idTextAnchor156"/>mplementation.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor157"/>Using a simple FSM for the enemy tank AI</h1>
			<p>Let's look <a id="_idIndexMarker108"/>at the actual code for our AI tanks. First, let's <a id="_idIndexMarker109"/>create a new class, called <code>SimpleFSM</code>, which inherits from our FSM abstract class.</p>
			<p>You can find the source code in the <code>SimpleFSM.cs</code> file:</p>
			<pre>using UnityEngine;
using System.Collections;
public class SimpleFSM : FSM {
    public enum FSMState {
        None, Patrol, Chase, Attack, Dead,
    }
    //Current state that the NPC is reaching
    public FSMState curState = FSMState.Patrol;
    //Speed of the tank
    private float curSpeed = 150.0f;
    //Tank Rotation Speed
    private float curRotSpeed = 2.0f;
    //Bullet
    public GameObject Bullet;
    //Whether the NPC is destroyed or not
    private bool bDead = false;
    private int health = 100;
    // We overwrite the deprecated built-in rigidbody 
    // variable.
    new private Rigidbody rigidbody;
    //Player Transform
    protected Transform playerTransform;
    //Next destination position of the NPC Tank
    protected Vector3 destPos;
    //List of points for patrolling
    protected GameObject[] pointList;
    //Bullet shooting rate
    protected float shootRate = 3.0f;
    protected float elapsedTime = 0.0f;
    public float maxFireAimError = 0.001f;
    // Status Radius
    public float patrollingRadius = 100.0f;
    public float attackRadius = 200.0f;
    public float playerNearRadius = 300.0f;
    //Tank Turret
    public Transform turret;
    public Transform bulletSpawnPoint;</pre>
			<p>Here, we declare <a id="_idIndexMarker110"/>a few variables. Our tank AI has four different<a id="_idIndexMarker111"/> states: <strong class="bold">Patrol</strong>, <strong class="bold">Chase</strong>, <strong class="bold">Attack</strong>, and <strong class="bold">Dead</strong>. We are implementing the FSM that we described as an example in <a href="B17984_01_Epub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to AI</em>:</p>
			<div><div><img src="img/B17984_02_8.jpg" alt="Figure 2.8 – The enemy tank AI's FSM&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.8 – The enemy tank AI's FSM</p>
			<p>In our <code>Initialize</code> method, we set up our AI tank's properties with default values. Then, we<a id="_idIndexMarker112"/> store the positions of waypoints in our local variable. We<a id="_idIndexMarker113"/> get those waypoints from our scene using the <code>FindGameObjectsWithTag</code> method, trying to find those objects with t<a id="_idTextAnchor158"/>he <strong class="bold">WandarPoint</strong> tag:</p>
			<pre>//Initialize the Finite state machine for the NPC tank protected overrid<a id="_idTextAnchor159"/>e void Initialize () {
    // Get the list of points 
    pointList = 
      GameObject.FindGameObjectsWithTag("WandarPoint");
    // Set Random destination point first 
    FindNextPoint();
    // Get the target enemy(Player) 
    GameObject objPlayer =
    GameObject.FindGameObjectWithTag("Player");
    // Get the rigidbody
    rigidbody = GetComponent&lt;Rigidbody&gt;();
    playerTransform = objPlayer.transform;
    if (!playerTransform) {
        print("Player doesn't exist. Please add one with
               Tag named 'Player'");
    }
}</pre>
			<p>The <code>Update</code> method<a id="_idIndexMarker114"/> that gets called every frame looks like the<a id="_idIndexMarker115"/> following:</p>
			<pre>protected override void FSMUpdate() {
    switch (curState) {
        case FSMState.Patrol: 
            UpdatePatrolState(); 
            break; 
        case FSMState.Chase: 
            UpdateChaseState(); 
            break; 
        case FSMState.Attack: 
            UpdateAttackState(); 
            break; 
        case FSMState.Dead: 
            UpdateDeadState();
            break;
   }
    // Update the time
    elapsedTime += Time.deltaTime;
    // Go to dead state is no health left 
    if (health &lt;= 0) {
        curState = FSMState.Dead;
    }
}</pre>
			<p>We check the <a id="_idIndexMarker116"/>current state and then call the appropriate<a id="_idIndexMarker117"/> state method. Once the health object has a value of zero or less, we set the tank to the <code>Dead</code> state.</p>
			<p class="callout-heading">Debugging Private Variables</p>
			<p class="callout">A public variable<a id="_idIndexMarker118"/> in the Inspector is not only useful because we can quickly experiment with different values but also because we can quickly look at a glance at their value when debugging. For this reason, you may even be tempted to make public (or expose to the Inspector) variables that should not be changed by the component's user. Don't worry – there is a solution: you can show the Inspector in <strong class="bold">Debug</strong> mode. In <strong class="bold">Debug</strong> mode, the Inspector also shows private fields. To enable Debug mode, click on the three dots at the top right and then click on <strong class="bold">Debug</strong>:</p>
			<div><div><img src="img/B17984_02_9.jpg" alt="Figure 2.9 – Unity's Inspector in Debug mode&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.9 – Unity's Inspector in Debug mode</p>
			<p>Now, let's see how to implement<a id="_idTextAnchor160"/><a id="_idTextAnchor161"/><a id="_idTextAnchor162"/><a id="_idTextAnchor163"/> each state one by one.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor164"/>The Patrol state</h2>
			<p>The <strong class="bold">Patrol</strong> state is <a id="_idIndexMarker119"/>the state in which the tank moves from waypoint to waypoint, looking for <a id="_idIndexMarker120"/>the player. The <strong class="bold">Patrol</strong> state's code is shown here: </p>
			<pre>protected void UpdatePatrolState() {
    if (Vector3.Distance(transform.position, destPos) &lt;=
        patrollingRadius) {
        print("Reached to the destination point\n 
               calculating the next point");
        FindNextPoint();
    } else if (Vector3.Distance(transform.position,
        playerTransform.position) &lt;= playerNearRadius) {
        print("Switch to Chase Position");
        curState = FSMState.Chase;
    }
    // Rotate to the target point 
    Quaternion targetRotation = Quaternion.LookRotation(
      destPos - transform.position);
    transform.rotation = Quaternion.Slerp(
      transform.rotation, targetRotation,
      Time.deltaTime * curRotSpeed);
    // Go Forward
    transform.Translate(Vector3.forward * Time.deltaTime *
                        curSpeed);
}
protected void FindNextPoint() {
    print("Finding next point");
    int rndIndex = Random.Range(0, pointList.Length); 
    float rndRadius = 10.0f;
    Vector3 rndPosition = Vector3.zero;
    destPos = pointList[rndIndex].transform.position + 
      rndPosition;
    // Check Range to decide the random point as the same
    // as before
    if (IsInCurrentRange(destPos)) {
        rndPosition = new Vector3(Random.Range(-rndRadius,
          rndRadius), 0.0f, Random.Range(-rndRadius,
          rndRadius));
        destPos = pointList[rndIndex].transform.position +
          rndPosition;
    }
}
protected bool IsInCurrentRange(Vector3 pos) {
    float xPos = Mathf.Abs(pos.x - transform.position.x);
    float zPos = Mathf.Abs(pos.z - transform.position.z);
    if (xPos &lt;= 50 &amp;&amp; zPos &lt;= 50) return<a id="_idTextAnchor165"/> <a id="_idTextAnchor166"/><a id="_idTextAnchor167"/><a id="_idTextAnchor168"/><a id="_idTextAnchor169"/>true;
    return false;
}</pre>
			<p>While our tank <a id="_idIndexMarker121"/>is in the <code>FindNextPoint</code> method. This method simply chooses a random point from among the waypoints we defined before.</p>
			<p>On the other hand, if the tank has not reached its destination point, it checks the distance to the player's tank. If the player's tank is in range (which, in this example, we choose to be <code>300</code> units), the AI switches to the <code>UpdatePatrolState</code> function to rotate the tank and move it toward the next waypoint.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor170"/>The Chase state</h2>
			<p>In the <strong class="bold">Chase</strong> state, the<a id="_idIndexMarker123"/> tank actively tries to get near the player's tank. In simple terms, the<a id="_idIndexMarker124"/> destination point becomes the player's tank itself. The <strong class="bold">Chase</strong> state implementation code is shown here:</p>
			<pre>protected void UpdateChaseState() {
    // Set the target position as the player position 
    destPos = playerTransform.position;
    // Check the distance with player tank When
    // the distance is near, transition to attack state 
    float dist = Vector3.Distance(transform.position,
      playerTransform.position);
    if (dist &lt;= attackRadius) {
        curState = FSMState.Attack;
    } else if (dist &gt;= playerNearRadius {
        curState = FSMState.Patrol;
    }
    transform.Translate(Vector3.forward * Time.deltaTime *
                        curSpeed);
}</pre>
			<p>In this state, we first set the destination point as the player. Then, we continue checking the player's distance from the tank. If the player is close enough, the AI switches to the <strong class="bold">Attack</strong> state. On the other hand, if the player's tank manages to escape and goes too far, the AI goes back to the <strong class="bold">Patrol</strong> state.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor171"/>The Attack state</h2>
			<p>The <strong class="bold">Attack</strong> state is <a id="_idIndexMarker125"/>precisely what you expect: the enemy tank aims and shoots at the player. The <a id="_idIndexMarker126"/>following code block is the implementation code for the <strong class="bold">Attack</strong> state:</p>
			<pre>protected void UpdateAttackState() {
    destPos = playerTransform.position;
    Vector3 frontVector = Vector3.forward;
    float dist = Vector3.Distance(transform.position,
      playerTransform.position);
    if (dist &gt;= attackRadius &amp;&amp; dist &lt; playerNearRadius {
        Quaternion targetRotation = 
          Quaternion. FromToRotation(destPos – 
                                     transform.position); 
        transform.rotation = Quaternion.Slerp(
          transform.rotation, targetRotation,
          Time.deltaTime * curRotSpeed);
        transform.Translate(Vector3.forward * 
                            Time.deltaTime * curSpeed);
        curState = FSMState.Attack;
    } else if (dist &gt;= playerNearRadius) {
        curState = FSMState.Patrol;
    }
    // Rotate the turret to the target point
    // The rotation is only around the vertical axis of the
    // tank.
    Quaternion targetRotation = Quaternion.FromToRotation(
      frontVector, destPos - transform.position);
    turret.rotation = Quaternion.Slerp(turret.rotation,
      turretRotation, Time.deltaTime * curRotSpeed);
    //Shoot the bullets
    if (Mathf.Abs(Quaternion.Dot(turretRotation,
      turret.rotation)) &gt; 1.0f - maxFireAimError) {
        ShootBullet();
    }
}
private void ShootBullet() {
    if (elapsedTime &gt;= shootRate) {
        Instantiate(Bullet, bulletSpawnPoint.position,
                    bulletSpawnPoint.rotation);
    <a id="_idTextAnchor172"/><a id="_idTextAnchor173"/><a id="_idTextAnchor174"/><a id="_idTextAnchor175"/>    elapsedTime = 0.0f;
    }
}</pre>
			<p>In the first line, we still set the destination point to the player's position. After all, even when attacking, we need to keep a close distance from the player. Then, if the player tank is close enough, the <a id="_idIndexMarker127"/>AI tank rotates the <code>turret</code> object in the direction of the player tank<a id="_idIndexMarker128"/> and then starts shooting. Finally, if the player's tank goes out of range, the tank goes back to the <strong class="bold">Patrol</strong> state.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor176"/>The Dead state</h2>
			<p>The <strong class="bold">Dead</strong> state is <a id="_idIndexMarker129"/>the final state. Once a tank is in the <strong class="bold">Dead</strong> state, it explodes and gets <a id="_idIndexMarker130"/>uninstantiated. The following is the code for the <strong class="bold">Dead</strong> state:</p>
			<pre>protected void UpdateDeadState() {
    // Show the dead animation with some physics effects 
    if (!bDead) {
        bDead = true;
        Explode();
    }
}</pre>
			<p>As you can see, the code is straightforward – if the tank has reached the <strong class="bold">Dead</strong> state, we make it explode:</p>
			<pre>protected void Explode() {
    float rndX = Random.Range(10.0f, 30.0f); 
    float rndZ = Random.Range(10.0f, 30.0f); 
    for (int i = 0; i &lt; 3; i++) {
        rigidbody.AddExplosionForce(10000.0f,
          transform.position - new Vector3(rndX, 
          10.0f, rndZ), 40.0f, 10.0f);
        rigidbody.velocity = transform.TransformDirection(
          new Vector3(rndX, 20.0f, rndZ));
    <a id="_idTextAnchor177"/><a id="_idTextAnchor178"/><a id="_idTextAnchor179"/><a id="_idTextAnchor180"/>}
    Destroy(gameObject, 1.5f);
}</pre>
			<p>Here's a small function that<a id="_idIndexMarker131"/> gives a nice explosion effect. We apply a random <code>ExplosionForce</code> function <a id="_idIndexMarker132"/>to the tank's <code>Rigidbody</code> component. If everything is correct, you should see the tank flying in the air in a random direction for the player's amusement.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor181"/>Taking damage</h2>
			<p>To complete the<a id="_idIndexMarker133"/> demo, we need to add another small detail: we need the tanks to take damage when they get hit by a bullet. Every time a bullet enters the collision area of the tank, the <code>health</code> property's value decreases, according to the <code>Bullet</code> object's <code>damage</code> value:</p>
			<pre>void OnCollisionEnter(Collision collision) {
    // Reduce health 
    if(collision.gameObject.tag == "Bullet") {
        health -=collision.gameObject.GetComponent
          &lt;Bullet&gt;().damage;
    }
}</pre>
			<p>You can open the <code>SimpleFSM.scene</code> file in Unity; you should see the AI tanks patrolling, chasing, and attacking the player. Our player's tank doesn't take damage from AI tanks yet, so it never gets destroyed. But the AI tanks have the health property and take damage from the player's bullets, so you'll see them explode once their health property reaches zero.</p>
			<p>If your demo doesn't work, try playing with different values in the Inspector for the <strong class="bold">SimpleFSM</strong> components. After all, the values may change, depe<a id="_idTextAnchor182"/>nding on the scale of your project:</p>
			<p class="figure-caption"><a id="_idTextAnchor183"/><a id="_idTextAnchor184"/><a id="_idTextAnchor185"/></p>
			<div><div><img src="img/B17984_02_10.jpg" alt="Figure 2.10 – The AI tanks in action&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.10 – The AI tanks in action</p>
			<p>In this demo, we<a id="_idIndexMarker134"/> used a very simple FSM, but now it's time to step up the challenge and implement a complete FSM framework.</p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor186"/>Using an FSM framework</h1>
			<p>The FSM framework we're<a id="_idIndexMarker135"/> going to use here is adapted from <a id="_idIndexMarker136"/>the <code>Chapter02</code> folder of the book repository (<a href="https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition">https://github.com/PacktPublishing/Unity-Artificial-Intelligence-Programming-Fifth-Edition</a>). In particular, we will look at the <strong class="bold">AdvancedFSM</strong> scene. </p>
			<p>In this section, we will study how the framework works and how w<a id="_idTextAnchor187"/>e can use this to implement our tank AI. <code>AdvancedFSM</code> and <code>FSMState</code> are the two main classes of<a id="_idTextAnchor188"/><a id="_idTextAnchor189"/> our framew<a id="_idTextAnchor190"/>ork. So, let's take a look at them first.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor191"/>The AdvancedFSM class</h2>
			<p>The <code>AdvancedFSM</code> class manages<a id="_idIndexMarker137"/> all the <code>FSMState</code> classes we've implemented and keeps them updated with the transitions and the current state. So, the first thing to do before using our framework is to declare the transitions and states that we plan to implement for our AI tanks.</p>
			<p>Let's start by <a id="_idIndexMarker138"/>creating <code>AdvancedFSM.cs</code>:</p>
			<pre>using UnityEngine;
using System.Collections;
using System.Collections.Generic;
public enum Transition {
    None = 0, SawPlayer, ReachPlayer, LostPlayer, NoHealth,
}
public enum FSMStateID {
    None = 0, Patrolling, Chasing, Attacking, Dead,
}</pre>
			<p>Here, we define two enumerations, one for the set of states and one for the set of transitions. Then, we add a list object to store the <code>FSMState</code> objects and two local variables to store the current ID of the <code>FSMState</code> class and the current <code>FSMState</code> itself.</p>
			<p>The <code>AddFSMState</code> and <code>DeleteState</code> methods add and delete the instances of the <code>FSMState</code> class in our list respectively. When the <code>PerformTransition</code> method gets called, it updates the <code>CurrentState</code> variable with the new state, according to the transition:</p>
			<pre>public class AdvancedFSM : FSM {
    private List&lt;FSMState&gt; fsmStates;<a id="_idTextAnchor192"/><a id="_idTextAnchor193"/> 
    private FSMStateID currentStateID; 
    public FSMStateID CurrentStateID {
        get {
            return currentStateID;
        }
    }
    private FSMState currentState; 
    public FSMState CurrentState {
        get {
      <a id="_idTextAnchor194"/><a id="_idTextAnchor195"/><a id="_idTextAnchor196"/><a id="_idTextAnchor197"/>      return currentState;
        }
    }</pre>
			<p>Now that the<a id="_idIndexMarker139"/> data part of the class is ready, we can proceed with the internal logic of the FSM framework.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor198"/>The FSMState class</h2>
			<p><code>FSMState</code> manages the <a id="_idIndexMarker140"/>transitions to other states. It has a dictionary object called <code>map</code> in which we store the key-value pairs of transitions and states. So, for example, the <code>SawPlayer</code> transition maps to the <code>Chasing</code> state, <code>LostPlayer</code> maps to the <code>Patrolling</code> state, and so on.</p>
			<p>Let's create an <code>FSMState.cs</code> file:</p>
			<pre>using UnityEngine;
using System.Collections;
using System.Collections.Generic;
public abstract class FSMState {
    protected Dictionary&lt;Transition, FSMStateID&gt; map = 
      new Dictionary&lt;Transition, FSMStateID&gt;();
    // Continue...</pre>
			<p>The <code>AddTransition</code> and <code>DeleteTransition</code> methods add and delete transitions from their state-transition dictionary <code>map</code> object. The <code>GetOutputState</code> method looks up from the <code>map</code> object and returns the state based on the input transition.</p>
			<p>The <code>FSMState</code> class <a id="_idIndexMarker141"/>also declares two abstract methods that its child classes need to implement. They are as follows:</p>
			<pre>...
    public abstract void CheckTransitionRules(Transform 
      player, Transform npc);
    public abstract void RunState(Tr<a id="_idTextAnchor199"/><a id="_idTextAnchor200"/>ansform player,
      Transform npc);
...</pre>
			<p>The <code>CheckTransitionRules</code> method has to check whether the state should carry out <a id="_idTextAnchor201"/><a id="_idTextAnchor202"/>the transition to another state. Instead, the <code>RunState</code> method does the actual execution of the tasks for the <code>currentState</code> variable, such as moving toward a destination point and chasing or attacking the player. Both methods require transformed data from th<a id="_idTextAnchor203"/><a id="_idTextAnchor204"/>e player and <a id="_idIndexMarker142"/>the <strong class="bold">Non Playable Cha<a id="_idTextAnchor205"/><a id="_idTextAnchor206"/>racter</strong> (<strong class="bold">NPC</strong>) entity obtained using this class.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor207"/>The state classes</h2>
			<p>Unlike the <a id="_idIndexMarker143"/>previous <code>SimpleFSM</code> example, we write the states for our tank AI in separate classes that inherit from the <code>FSMState</code> class, such as <code>AttackState</code>, <code>ChaseState</code>, <code>DeadSt<a id="_idTextAnchor208"/><a id="_idTextAnchor209"/>ate</code>, and <code>PatrolState</code>. All of them implement the <code>CheckTransitionRules</code> and <code>RunState</code> methods. Let's take<a id="_idTextAnchor210"/><a id="_idTextAnchor211"/><a id="_idTextAnchor212"/><a id="_idTextAnchor213"/> a look at the <code>PatrolState</code> class as an example.</p>
			<h3>The PatrolState class</h3>
			<p>This class has three<a id="_idIndexMarker144"/> methods: a constructor, <code>CheckTransitionRules</code>, and <code>RunState</code>. Let's create the <code>PatrolState</code> class in the <code>PatrolState.cs</code> file:</p>
			<pre>using UnityEngine;
using System.Collections;
public class PatrolState : FSMState {
    private Vector3 destPos;
    private Transform[] waypoints;
    private float curRotSpeed = 1.0f;
    private float curSpeed = 100.0f;
    private float playerNearRadius;
    private float patrollRadius;
    public PatrolState(Transform[] wp, float
      playerNearRadius, float patrollRadius) {
        waypoints = wp;
        stateID = FSMStateID.Patrolling;
        this.playerNearRadius = playerNearRadius;
        this.patrollRadius = patrollRadius;
    }
    public override void CheckTransitionRules(
      Transform player, Transform npc) {
        // Check the distance with player tank
        // When the distance is near, transition to chase
       // state 
        if (Vector3.Distance(npc.position, player.position)
            &lt;= playerNearRadius) {
            Debug.Log("Switch to Chase State");
            NPCTankController npcTankController = 
              npc.GetComponent&lt;NPCTankController&gt;();
            if (npcTankController != null) {
                npcTankController.SetTransition(
                Transition.SawPlayer);
            } else {
                Debug.LogError("NPCTankController not found
                                in NPC");
            }
        }
    }
    public override void RunState(Transform player,
      Transform npc) {
        // Find another random patrol point if the current
        // point is reached
        if (Vector3.Distance(npc.position, destPos) &lt;= 
            patrollRadius) {
            Debug.Log("Reached to the destination point\n
                       calculating the next point"); 
            FindNextPoint();
        }
        // Rotate to the target point
        Quaternion targetRotation =
          Quaternion.FromToRotation(Vector3.forward,
          destPos - npc.position);
        npc.rotation = Quaternion.Slerp(npc.rotation,
          targetRotation, Time.deltaTime * curRotSpeed);
        // Go Forward 
        npc.Translate(Vector3.forward * Time.deltaTime * 
                      curSpeed);
    }
}</pre>
			<p>The <code>constructor</code> method takes the <code>waypoints</code> array, stores them in a local array, and then initializes properties such as movement and rotation speed. The <code>Reason</code> method checks the <a id="_idIndexMarker145"/>distance between itself (the AI tank) and the player tank. If the player tank is in range, it sets the transition ID to the <code>SawPlayer</code> transition using the <code>SetTransition</code> method of the <code>NPCTankController</code> class, which looks as follows:</p>
			<pre>public void SetTransition(Transition t) {
    PerformTransition(t);
}</pre>
			<p>The preceding function is just a wrapper method that calls the <code>PerformTransition</code> method of the <code>AdvanceFSM</code> class. In turn, that method updates the <code>CurrentState</code> variable with the one responsible for this transition, using the <code>Transition</code> object and the state-transition dictionary map object from the <code>FSMState</code> class. The <code>Act</code> method updates the AI tank's destination point, rotates the tank in that direction, and moves it forward.</p>
			<p>Other state <a id="_idIndexMarker146"/>classes also follow this template with different reasoning and acting procedures. We've already seen them in our previous simple FSM examples, and therefore, we won't describe them again here. See whether you can figure out how to s<a id="_idTextAnchor214"/><a id="_idTextAnchor215"/>et up these classes on your own. If you get stuck, the assets that come w<a id="_idTextAnchor216"/><a id="_idTextAnchor217"/>ith this book contain the code for you to look at.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor218"/>The NPCTankController class</h2>
			<p>For the tank AI, we <a id="_idIndexMarker147"/>set up the states for our NPC by using the <code>NPCTankController</code> class. This class inherits from <code>AdvanceFSM</code>:</p>
			<pre>private void ConstructFSM() {
    PatrolState patrol = new PatrolState(waypoints,
      playerNearRadius, patrollingRadius);
    patrol.AddTransition(Transition.SawPlayer,
                         FSMStateID.Chasing);
    patrol.AddTransition(Transition.NoHealth,
                         FSMStateID.Dead);
    ChaseState chase = new ChaseState(waypoints); 
     chase.AddTransition(Transition.LostPlayer,
                         FSMStateID.Patrolling); 
    chase.AddTransition(Transition.ReachPlayer,
                        FSMStateID.Attacking); 
    chase.AddTransition(Transition.NoHealth,
                        FSMStateID.Dead);
    AttackState attack = new AttackState(waypoints); 
   attack.AddTransition(Transition.LostPlayer,
                        FSMStateID.Patrolling); 
    attack.AddTransition(Transition.SawPlayer,
                         FSMStateID.Chasing); 
    attack.AddTransition(Transition.NoHealth,
                         FSMStateID.Dead);
    DeadState dead = new DeadState(); 
    dead.AddTransition(Transition.NoHealth,
                       FSMStateID.Dead);
    AddFSMState(patrol); 
    AddFSMState(chase); 
    AddFSMState(attack);
    AddFSMState(dead);
}</pre>
			<p>Here's the <a id="_idIndexMarker148"/>beauty of using our FSM framework: since the states are self-managed within their respective classes, our <code>NPCTankController</code> class only needs to call the <code>Reason</code> and <code>Act</code> methods of the currently active state.</p>
			<p>This fact eliminates the need to write a long list of the <code>if</code>/<code>else</code> and <code>switch</code> statements. Instead, our states are now nicely packaged in classes of their own, which makes the code more manageable, as the number of states and transitions between them grows more and more in larger projects:</p>
			<pre>protected override void FSMFixedUpdate() {
    CurrentState.Reason(playerTransform, transform);
    CurrentState.Act(playerTransform, transform);
}</pre>
			<p>The main steps to<a id="_idIndexMarker149"/> use this framework can be summarized as follows:</p>
			<ol>
				<li value="1">Declare the transitions and states in the <code>AdvanceFSM</code> class.</li>
				<li>Write the state classes inherited from the <code>FSMState</code> class, and then implement the <code>Reason</code> and <code>Act</code> methods.</li>
				<li>Write the custom NPC AI class inherited from <code>AdvanceFSM</code>.</li>
				<li>Create states from the state classes, and then add transition and state pairs using the <code>AddTransition</code> method of the <code>FSMState</code> class.</li>
				<li>Add those states into the state list of the <code>AdvanceFSM</code> class, using the <code>AddFSMState</code> method.</li>
				<li>Call the <code>CurrentState</code> variab<a id="_idTextAnchor219"/>le's <code>Reason</code> and <code>Act</code> methods in the game update cycle.</li>
			</ol>
			<p>You can play around with the <code>AdvancedFSM</code> scene in Unity. It'll run the same way as our previous <code>SimpleFSM</code> examp<a id="_idTextAnchor220"/>le, but the code is now more organized and manageable.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor221"/>Summary</h1>
			<p>In this chapter, we learned how to implement state machines in Unity3D based on a simple tank game. We first looked at how to implement FSM by using <code>switch</code> statements. Then, we studied how to use a framework to make AI implementation easier to manage and extend.</p>
			<p>In the next chapter, we will look at randomness and probability and see how we can use them to make the outcome of our games more unpredictable.</p>
		</div>
	</body></html>