- en: Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The problem behind pathfinding is as old as the Labyrinth at Knossos: how
    do I get from point A to point B using the shortest route and avoiding all obstacles
    in-between?*'
  prefs: []
  type: TYPE_NORMAL
- en: Many algorithms have been developed to solve pathfinding problems, including
    those related to the A* algorithm, which was first introduced in computer science
    during the 1960s (section 2).
  prefs: []
  type: TYPE_NORMAL
- en: Pathfinding routines are typical components of many video games, with Non-Player
    Characters (NPCs) having the task of finding optimal paths on the game maps, which
    can constantly change. For example, passageways, gates, or doors can change their
    statuses during gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a lot of problems when it comes to pathfinding, and unluckily
    for us, there isn't a one-solution-fits-all approach. This is because each problem
    will have its own solution, depending on the type of problem it is. Not only this,
    it will also depend on the type of game that you are developing. For example,
    is the final destination for the AI a static building (stationary), or do they
    need to jump on top of a floating raft (dynamic)? You also need to take the terrain
    into consideration – is it flat or rocky, and so on? To add an additional layer
    of complexity, we also need to consider whether there are obstacles present, as
    well as whether these objects are static (fire hydrant) or if they can be moved
    (e.g. boxes). Then, we need to think about the actual path itself. For example,
    it might be easier to travel along the road, but running across rooftops will
    get you where you need to be quicker. Following the same train of thought, the
    AI might not even have a final destination, in the sense that they don't have
    to be somewhere specific. For example, they might just wander around as someone
    who is part of a village. However, I have only highlighted a few issues and considerations
    that are related to pathfinding. As you experience different situations that use
    pathfinding, you are likely to encounter other issues. Remember to be patient
    and to consider all the variables that I have mentioned here and others that are
    specific to your situation.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately for us, Unreal has incorporated a navigation system that can be
    used for the most common of situations. As a result, we don't need to re-implement
    everything from scratch. The main goal of this chapter is to ensure that you understand
    how to use it, and ensure that you have some idea of how you can expand on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What to expect from a ***Navigation System***
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ***Unreal Navigation System***, and how it works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to ***Generate the Navigation Mesh*** for a level, and its available settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to ***Modify the Navigation Mesh***, by using the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Navigation Areas***, to change the weight associated with a part of the
    Navigation Mesh'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Navigation Links***, to connect two parts of the Navigation Mesh that would
    otherwise be separated'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Navigation Filters***, to perform a slight change to the Navigation Mesh
    while executing a specific query on the *Navigation System*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's dive in!
  prefs: []
  type: TYPE_NORMAL
- en: What to expect from a Navigation System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, before we explore the ***Unreal Navigation System***, it is useful
    to define what we would expect from a generic *Navigation System*. The following
    is required from the *Navigation System*:'
  prefs: []
  type: TYPE_NORMAL
- en: It needs to determine if a path (that can be traversed by the agent performing
    the query) exists between two generic points on the map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If such a path exists, return the one that is the most convenient for the agent
    (usually the shortest)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, while searching for the best path, there are many aspects to take
    into consideration. A good navigation system should not only consider these, but
    also perform the query in a relatively short period of time. Some of these aspects
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the AI agent who's performing the query able to pass through a specific portion
    of the map? For instance, there might be a lake, and the AI character may or may not
    know how to swim. Similarly, can the agent crouch and move into a ventilation
    tunnel?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The AI agent might want to avoid (or prefer) certain paths, which aren''t necessarily
    the shortest ones. For instance, if a building is on fire, the agent should try
    to avoid this, or risk of getting burned. As another example, let''s say there
    are two paths: one is covered from enemy fire, but it''s long, while the other
    one is short but exposed to enemy fire; which one should the AI choose? Although
    this might be part of the decision-making process, some heuristics can be implemented
    at the level of pathfinding, and a navigation system should support them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A map might be dynamic, which means that obstacles, objects, roads, cliffs,
    and so on, change during gameplay. Is the navigation system able to handle these
    changes in real time while they happen, and correct the generated paths?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, it's time to see how Unreal implements all of these features.
  prefs: []
  type: TYPE_NORMAL
- en: Unreal Navigation System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Unreal navigation system is based on a ***Navigation Mesh*** (***Nav Mesh***
    for short). It entails dividing the navigable space into areas – in this case,
    polygons – which are subdivided into triangles for efficiency. Then, to reach
    a certain place, each triangle is considered a node of a graph, and if two triangles
    are adjacent, then their respective nodes are connected. On this graph, you can
    execute a pathfinding algorithm, such as A* with a Euclidean distance heuristic,
    or even something more complicated (e.g. variants of A* or systems that take into
    consideration different costs). This will produce a path among these triangles
    where the AI character can walk.
  prefs: []
  type: TYPE_NORMAL
- en: In reality, this process is a little bit more complicated, because considering
    all the triangles as nodes of a giant graph will produce a good result, but it
    is inefficient, especially since we have access to the information that's stored
    in the polygons and how these are connected. Moreover, you might need extra information
    about specific triangles, which might have different costs, different abilities required
    to traverse them, etc… However, unless you need to change the underlying structure
    of the *Navigation System*, you don't need to work/operate at this level of detail.
    Being able to understand that all of the triangles form a graph in some way, in
    which pathfinding algorithms can run, is more than sufficient to master the tool
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to use the *Navigation System*, let''s understand the main process
    of setting up the navigation system. At this stage, we will no longer worry about
    how the system is structured underneath, but rather how we can use all of its
    features. The system will do the rest. In the same way, we need to provide information
    about the map to the navigation system (e.g. specify special areas). Usually,
    it''s the AI programmer in your team who takes care of this, but if your team
    is small, a level designer might take care of this task. Although there is not
    a specific process, but, rather an iterative procedure, let''s explore the different
    steps – or tools, if you prefer – that you can use to define the *Nav Mesh* in
    Unreal. We will examine them in detail throughout this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generation of the Navigation Mesh**: This is the first step. Before you''ll
    be able to use the following tools, it is important to start generating a *Nav
    Mesh*. This step includes defining how to generate the polygons, the triangles,
    the precision of the *Nav Mesh*, and even which kind of agents will traverse this
    specific *Nav Mesh*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Navigation Mesh Modifiers**: Not all the parts of the *Nav Mesh* are created
    equal, and this is a tool to specify which parts of the *Nav Mesh* should behave
    differently. In fact, as we have seen before, there might be a zone with poisoned
    gas, and the agent would like to avoid this part, unless they really have to traverse
    it. The Nav Mesh Modifier allows you to specify that the area containing the gas
    is special. However, the type of behavior within the area (e.g. this path should
    not be traversed, or should only be traversed by agents with swimming abilities)
    is specified within a Nav Area.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Navigation Areas**: This allows you to specify how a specific type of area
    should behave, whether it should be avoided, etc. These are key when performing
    *Nav Filtering* to determine which areas the agent can traverse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Navigation Links**: These can connect two different parts of the *Nav Mesh*.
    Suppose you have a platform ledge. By default, the AI agent will find another
    way. If you have in mind the Third Person map template, the agent that needs to
    get down from platform will go around the area to use the stairs, rather than
    just falling/jumping off the platform. A ***Nav Link*** allows you to connect
    the part of the *Nav Mesh* that''s on top of the platform with the part below
    it. As a result, the agent will be able to fall off the platform. However, note
    that ***Nav Links*** can connect two generic portions of the *Nav Mesh*, thus
    allowing pathfinding to find its way through jumps, teleports, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nav Filtering**: We don''t necessarily want to find a path in the same way
    on every occasion. ***Nav Filtering*** allows us to define specific rules on how
    to perform the pathfind for that specific instance (for that specific time that
    the pathfind is invoked to seek a path).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's break these points down and talk about them in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the Navigation Mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generating a simple *Navigation Mesh* is pretty straightforward in Unreal.
    Let''s look at how we can do it. From the ***Mode*** panel, in the ***Volume***
    tab, you will be able to find the **Nav Mesh Bounds Volume**, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c95dcf12-7fb9-4646-910e-f8caffee10e6.png)'
  prefs: []
  type: TYPE_IMG
- en: Drag it into the world. You will notice that the volume is quite small in respect
    to the map. Everything inside that volume will be taken into consideration to
    generate a *Nav Mesh*. Of course, a *Nav Mesh* has many parameters, but for now
    let's keep thing simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you press the *P* button on your keyboard, you will be able to see the *Nav
    Mesh* in the *Viewport*, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7bda5f63-d4ba-4669-880e-571872b8f2f7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, it is limited to the area that''s contained in the volume of
    ***Nav Mesh Bounds Volume***. Let''s scale the ***Nav Mesh Bounds Volume*** to
    fit all the level we have. This is what your level should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a05c6e9-be72-4247-8f7f-3a7faba6bc5b.png)'
  prefs: []
  type: TYPE_IMG
- en: Did you notice how, while you were scaling your volume, the *Nav Mesh* was updating
    automatically? This is because, in Unreal, the *Nav Mesh* is generated every time
    something that impacts the *Nav Mesh* moves.
  prefs: []
  type: TYPE_NORMAL
- en: 'While updating, the part of the *Nav Mesh* that''s affected (that is, updated)
    should turn red, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4fb77e20-0694-4e05-be87-ef51c87721e3.png)'
  prefs: []
  type: TYPE_IMG
- en: This is how easy is to generate a *Nav Mesh*. However, to be able to master
    the tool, we need to learn more about how to refine the *Nav Mesh* and how it
    is used by the AI.
  prefs: []
  type: TYPE_NORMAL
- en: Setting parameters for the Nav Mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you click on the ***Nav Mesh Bounds Volume***, you will notice that there
    are no options for the generation of the *Nav Mesh*. In fact, some parameters
    are at the project level, while others are at the map level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s navigate to the ***World Outliner***, where you will find that a ***RecastNavMesh-Default***
    actor has been placed in the scene, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a7aa75c-89fb-4011-ab5d-b79e3d098f91.png)'
  prefs: []
  type: TYPE_IMG
- en: In fact, when you drag a ***Nav Mesh Bounds Volume***, if the map doesn't have
    a ***RecastNavMesh-Default***, one will be created. If we click on it, we will
    be able to change all of its properties in the ***Details Panel***.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are a lot of default values. These can be changed in the
    *Project Settings* (under the *Navigation Mesh* tab). Let's break down every section,
    and try to grasp the main concepts around them.
  prefs: []
  type: TYPE_NORMAL
- en: Display settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name suggests, these are settings that are related on how we can visualize
    the *Nav Mesh* that we have generated in detail. In particular, we will be able
    to see the generated Polygons, the triangles, and how the polygons are connected. We
    will go through these in more detail in [Chapter 12](a60155c1-2bb0-403f-bdcf-dbd6a9c67824.xhtml)*,
    Debugging Methods for AI - Navigation, EQS, and Profiling*, when we will talk
    about debugging tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d306b851-9c15-49ac-91b8-d7d845857233.png)'
  prefs: []
  type: TYPE_IMG
- en: Generation settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These settings concern the generation of the *Nav Mesh*. Usually, the default
    values are more than perfect to start with, and so you should only touch these
    values if you know what you are doing. The following screenshot shows these settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b4fde45-cb3b-465a-a1f0-6f15cbc1b1d1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The best way to learn about these settings is by playing with their parameters,
    first in an example map, then in your own maps. After that, you need to check
    the results of doing this (especially with the visual debugging tools that are
    presented in [Chapter 12](a60155c1-2bb0-403f-bdcf-dbd6a9c67824.xhtml), *Debugging
    Methods for AI - Navigation, EQS, and Profiling*). To get you started, let''s
    look at the main ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tile Size UU**: This parameter defines how fine the polygons that are generated
    are. Lower values mean a more precise navigation mesh, with more polygons, but
    also a slower generation time (and potentially more memory usage). You can see
    the effect of this parameter by turning on the **Draw Triangle Edges** in the
    display settings that are shown in the preceding screenshot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cell Height**: This determines how high the generated cells are from the
    floor (which might result in connecting areas at a different height, so be careful).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Agent settings* (**Radius**, **Height**, **Max Height**, **Max Slope**, **Max
    Step Height**): These settings are specific to your agents and should be specified
    appropriately. In particular, these are the minimum values an agent should have
    to traverse this *Nav Mesh*. As a result, the *Nav Mesh* will not be able to navigate
    with agents with smaller values than this, because the *Nav Mesh* is generated
    only for agents with these requirements. These settings are useful to generate
    an appropriate *Nav Mesh* for your agents, without wasting resources on a *Nav
    Mesh* with areas that your agents will never be able to navigate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Min Region Area**: This gets rid of certain artifacts of the *Nav Mesh Generation* that
    are too insignificant to navigate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many of the remaining settings are about optimization, and they can be overwhelming,
    especially for newcomers in AI Programming. Therefore, I decided to not include
    these details in this book. However, once you are confident about using the Navigation
    System, you can check the tool-tips of these settings and experiment with them
    so that you can learn about what they do.
  prefs: []
  type: TYPE_NORMAL
- en: Project Settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is worthwhile mentioning, even if we don''t go through them in details,
    that same *Navigation* settings can be changed from the ***Project Settings***;
    there is a specific tab for that, as shown in the following picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ad635c0-048f-4e67-bec9-00bb4eabfd58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Interesting to notice is the last tab about *Agents*. Here it is possible to
    create an *Array* of ***Supported Agents***, so that different agents can have
    different ways to navigate the *Nav Mesh*. For instance, a mouse might have a
    very different *Navigation Mesh* than a Giant Troll. In fact the mouse can also
    go in small holes, whereas the Troll can''t. Here you will be able to specify
    all the different kinds of agents you have:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a66abba0-becf-4f70-9023-e4b8a90d4c55.png)'
  prefs: []
  type: TYPE_IMG
- en: You cannot assign directly which kind of *agents* your character will follow,
    but, based on the *Character Movement Component* (or *Movement Components* in
    general), a kind of agent is assigned to the *Character/AI Agent*.
  prefs: []
  type: TYPE_NORMAL
- en: Settings on the Character Movement Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen from the previous section, the agents, which are its abilities,
    its shape, etc... influence a lot how it navigates the *Nav Mesh*. You will be
    able to find all of these settings on the *Character Movement Component*.
  prefs: []
  type: TYPE_NORMAL
- en: However, this component is outside the scope of this book, and we will not see
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the Navigation Mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how is it possible to generate a Navigation Mesh. However,
    we would like to modify this so that it suits our needs better. As we mentioned
    previously, there might be different areas that can be costly to traverse, or
    there might be a connection between two points of the *Nav Mesh* that seem to
    be separated (e.g. by a ledge).
  prefs: []
  type: TYPE_NORMAL
- en: As a result, this section explores the different tools that Unreal has to modify
    the *Nav Mesh* so that it can be adapted to the level.
  prefs: []
  type: TYPE_NORMAL
- en: Nav Modifier Volume
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alright – it's time to look at how we can start modifying the *Nav Mesh*. For
    instance, there might be a part of the *Nav Mesh* that we don't want to be crossable,
    or another section that we want to have different properties. We can do this by
    using a ***Nav Modifier Volume***.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find this setting by going to the *Mode* panel, under the *Volumes*
    tab, and then by going to the *Nav Mesh Bounds Volume*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1db935b4-77c7-4a20-a9d5-3f5df34c14d9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once this volume has been placed in the map, the default value is to remove
    the part of the ***Nav Mesh*** within the volume, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5dbdb0f1-7a72-4f6b-ad6c-ab68a8627daa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is useful when you have areas that you don''t want your AI to go in, or
    fix up artifacts of your navigation mesh. Although the ***Nav Modifier Volume***
    specifies a part of the map, the behavior is specified in the ***Nav Mesh Areas***.
    This means that, if we look at the settings of the ***Nav Mesh Modifier Volume***,
    we can find only one related to the *Navigation*, named ***Area Class***:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf02f114-879b-4d7f-92ee-9cc5185b4e2a.png)'
  prefs: []
  type: TYPE_IMG
- en: As a result, this volume can only specify a portion of the map in which a specific
    ***Area Class*** is applied. By default, the ***Area Class*** is ***NavArea_Null***,
    which "*removes*" the *Nav Mesh* in that portion of the map that's overlapping
    this volume. We'll explore how ***Nav Mesh Areas*** work in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Nav Mesh Areas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we talked about how not all parts of the navigable
    area of the map are created equal. If there is a zone that it is considered dangerous,
    the AI should avoid it. Unreal's built-in navigation system is able to handle
    these different areas by using costs. This means that the AI will evaluate the
    path to take by summing all the costs along the path, and it will select the one
    with the minimal cost.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it is worth specifying that there are two types of costs. For each area,
    there is an initial cost for entering (or leaving) the area and a cost for traversing
    the area. Let's look at a couple of examples to clarify the difference between
    the two.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that there is a forest, but at each entrance of the forest, the AI needs
    to pay a toll to the indigenous living in the forest. However, once inside, the
    AI can move freely, as if they were outside the forest. In this case, entering
    the forest has a cost, but once inside, there is no cost to pay. As a result,
    when the AI needs to evaluate whether to traverse the forest or not, it depends
    on whether there is another way to go and how long it would take them to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine that there is an area with poison gas instead. In this second scenario,
    the cost for entering the area might be zero, but the cost for traversing it is
    high. In fact, the longer the AI stays in the area, the more health it loses.
    Whether it is worth entering or not only depends on whether there is an alternative
    way and how long that alternative way will take to traverse (like in the previous
    case), but also how long, once entered, the AI needs to traverse the area.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Unreal, costs are specified inside the class. If you click on a ***Nav Modifier
    Volume***, you will notice that you need to specify an ***Area Class***, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2ce11a2-a705-48ff-a8da-fce7169816dd.png)'
  prefs: []
  type: TYPE_IMG
- en: As you may have guessed, the default value is ***NavArea_Null***, which has
    an infinite cost for entering, resulting in the AI never going into that area.
    The Navigation system is smart enough to not even bother generating that area,
    and treats it as a non-navigable area.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you can change the ***Area Class***. By default, you will be able
    to access the following *Area Classes*:'
  prefs: []
  type: TYPE_NORMAL
- en: '***NavArea_Default***: This is the default area that is generated. It is useful
    to have it as a modifier in case you want to have more than one of these modifiers
    in the same spot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NavArea_LowHeight**: This indicates that the area is not suitable for every
    agent, since the height is reduced (for example, in the case of a ventilation
    tunnel, not all the agents can fit/crouch).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NavArea_Null**: This makes the area non-navigable for all the agents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NavArea_Obstacle**: This assigns a higher cost to the area, so the agent
    will want to avoid it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/7e2b287f-260f-4a69-972f-f53b0a1be631.png)'
  prefs: []
  type: TYPE_IMG
- en: You will notice that if you create a new Blueprint, or even when you open the
    source code in Visual Studio, there will be **NavArea_Meta** and a child of it,
    **NavArea_MetaSwitchingActor**. However, if you look at their code, they mainly
    have some deprecated code. Therefore, we won't be using them in this book.
  prefs: []
  type: TYPE_NORMAL
- en: However, you can extend the list of the different areas (and potentially add
    more functionalities) by extending the ***NavArea Class***. Let's see how we can
    do this, both in Blueprint and C++. Of course, as we did in the previous chapter,
    we are going to create a new folder named *Chapter3/Navigation*, in which we will
    place all our code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a NavArea class in Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a new ***NavArea*** class in blueprint is quite straightforward; you
    just need to create a new Blueprint that inherits from the ***NavArea*** class,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3907d95-e2b5-4284-8d11-238ff812a44c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By convention, the name of the class should start with "*NavArea_*". We will
    rename it to ***NavArea_BPJungle*** here (I added BP to signify that we have created
    this with Blueprint, since we are repeating the same task both in Blueprint and
    in C++). This is what it should look like in the *Content Browser*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b2e7914-a6c9-464b-8dc8-3e0f4921f9cc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, if you open the blueprint, you will be able to assign the custom costs
    to the area. You can also specify a specific color for your area so that it is
    easy to recognize when you build your *Nav Mesh*. This is what the *Details* panel
    looks like by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20aef577-b969-498d-b42d-6a5c75c5b16a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can customize as per our needs. For example, we might want to have
    a cost to enter the *Jungle*, and a slightly higher cost to traverse it. We are
    going to use a bright green for the color, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e241764-a571-49aa-90d8-873e5d59d480.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once compiled and saved, we can assign this newly created area to the ***Nav
    Modifier Volume***, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe05e7eb-2bbd-4282-a6c3-ee63a9ffca6a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is what our finished class looks like in our level (if the *Navigation
    Mesh* is visible):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9eeedb0-3cd3-4091-aa80-8b852d08869a.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a NavArea class in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s easy to create a ***NavArea*** class in C++ as well. First of all, you
    need to create a new C++ class that inherits from the ***NavArea*** class, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08e5efd9-ba54-4a2d-b17f-ed75f2d2b4ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By convention, the name should start with "*NavArea_*". Therefore, you can
    rename it ***NavArea_Desert*** (just to vary which kind of terrain the AI can
    face, since we created a *Jungle* previously) and place it in "***Chapter3/Navigation***":'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60f44b62-465c-4eb7-a887-6aff0a644ad7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have created the class, you just need to assign the parameters in
    the constructor. For your convenience, here is the class definition in which we
    declare a simple constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the implementation of the constructor, we can assign the different
    parameters. For instance, we can have a high cost for entering and a higher cost
    for traversing (with respect to the *Default* or the *Jungle*). Furthermore, we
    can set the color to *Yellow* so that we remember that it is a desert area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can always play with these values to see which one works best for you. For
    instance, you can create an area with a very high entering cost, but a low traversal
    cost. As a result, you will have an area that, should be avoided if it's only
    going to be traversed for a little while, but if the agent traverses it for a
    long period of time, it might be more convenient than the shorter route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created the class, you can set it as part of the ***Nav Modifier
    Volume***, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73745221-a2e8-420a-8710-ef9639376624.png)'
  prefs: []
  type: TYPE_IMG
- en: As a result, you will be able to see your custom area in the *Nav Mesh* (in
    this case, with a *Yellow Color*)*:*
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ff546d2-ffcc-419a-8a9a-47b27a3bab00.png)'
  prefs: []
  type: TYPE_IMG
- en: Nav Link Proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, if there is a ledge, the AI will not fall through it, even if it
    would be the shortest path they could take to get to their destination. In fact,
    the *Nav Mesh* on top of the ledge is not (directly) connected with the *Nav Mesh*
    at the bottom. However, the *Unreal Navigation System* provides a way to connect
    two arbitrary triangles in the *Nav Mesh* through what is called a ***Nav Link
    Proxy***.
  prefs: []
  type: TYPE_NORMAL
- en: Although the regions are connected, and the pathfinder will find the correct
    road, the AI cannot go against the rules of the game, both in terms of physics
    or game mechanics. This means that if the AI is unable to jump or traverse a magic
    wall, the character will get stuck since the pathfinder returned a path, but the
    character cannot execute it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore this tool in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Nav Link Proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To connect two regions with a link, we need to go to the ***Mode*** panel in
    the ***All Classes*** tab and select ***Nav Link Proxy***, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7efd30e8-18cf-4e84-aa25-cfb16f3c32fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, you can search for it in the *Modes* panel to find it more quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b88cd2f-5954-461f-989d-b6236f2a911f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the link has been placed in the level, you will see an "*arrow/link*",
    and you will be able to modify the start and end points of the link. They are
    called ***Left*** and ***Right***, and the easiest way to set their location is
    by dragging (and placing) them in the *Viewport*. As a result, you will be able
    to connect two different parts of the *Nav Mesh*. As we can see in the following
    screenshot, if the *Nav Mesh* is visible (enabled with the *P* key), you will
    see an arrow connecting the ***Right*** and ***Left*** nodes. This arrow is pointing
    in both directions. This will result in the link being bidirectional:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c72f4dfa-8b3d-481e-b4e0-f2d54ea58e6c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You might notice that there are two arrows, one with a darker shade of green.
    Also, this second *arro**w/arc/link* might not be exactly where you placed your
    *Right* end, but rather attached to the *Nav Mesh*. You can see this second arrow
    more clearly in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/546c4c46-99a4-413c-a745-fa7b6f80b15e.png)'
  prefs: []
  type: TYPE_IMG
- en: This is actually how the *Nav Mesh* is connected, due to the *Projection Settings*
    of the *Link*. We will explore this setting in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to make the link go only in one direction, we can change this setting
    in the *Details Panel*. However, to explore these settings, we first need to understand
    that there are two different types of *Links*: ***Simple*** and ***Smart***.'
  prefs: []
  type: TYPE_NORMAL
- en: Simple Links and Smart Links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we create a ***Nav Link Proxy***, it comes with an array of ***Simple Links***.
    This means that with a single ***Nav Link Proxy***, we can connect different parts
    of the *Nav Mesh* together. However, the ***Nav Link Proxy*** comes with a single
    ***Smart Link*** as well, which is disabled by default.
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn about the similarities and difference between a ***Simple Link***
    and a ***Smart Link***.
  prefs: []
  type: TYPE_NORMAL
- en: Both Simple and Smart Links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '***Both Simple and Smart Links*** behave in a similar fashion, in the sense
    that they connect two parts of the *Nav Mesh* together. Moreover, Both type of
    links can have ***Direction*** (*Left to Right*, *Right to Left*, or *Both Ways*)
    and a ***Nav Area*** (which kind of navigation area the link is in; for instance,
    you might want to have a custom cost when using this link).'
  prefs: []
  type: TYPE_NORMAL
- en: Simple Links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '***Simple Links*** exists in the ***Point Links Array*** within the *Nav Proxy
    Link*, which means that multiple simple links in a single *Nav Proxy Link* are
    possible. To create another *Simple Link*, you can add an additional element to
    the array of *Simple Nodes* from the *Details* panel, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39a6c509-1e98-4a47-9dc3-7716d8590c37.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have more *Simple Links*, we can set the ***Start*** and ***End***
    positions, like we did for the first one (by selecting them and moving them within
    the *Viewport* as any other actor). The following screenshot shows where I placed
    two *Simple Links* on the same *Nav Proxy Link* next to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c6c5746-93b0-4c2f-b473-42e3ce0696ee.png)'
  prefs: []
  type: TYPE_IMG
- en: Every time we create a *Nav Link Proxy*, it comes with one *Simple Link* within
    the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'For every ***Simple Link*** we have in the *Point Links Array*, we can access
    its settings by expanding the item. The following screenshot shows the Settings
    for the first *Simple Link*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6294e13f-1c31-4d72-90e9-e0303d1c8030.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s understand these various settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '***Left*** and ***Right***: The position of the ***Left*** and ***Right***
    ends of the Link, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Left Project Height*** and ***Right Project Height***: If this number is
    greater than zero, then the link will be projected down to the navigation geometry
    (using a trace with the maximum length specified by this number) for the *Left*
    and *Right* end of the *Link*, respectively. You can see this projected link in
    the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/31afd7a3-fd7e-480c-b726-e0e967eb9d8f.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Direction***: This specifies in which direction the link works. Also, the
    arrow in the *Viewport* will update accordingly. The possible options for this
    are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Both Ways***: The link is bidirectional (remember that the AI needs to be
    equipped to traverse the Link in both directions; e.g. if we''re going over a
    ledge, the agent needs to be able to fall from it (one direction of the link)
    and jump (the other direction of the link).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Left to Right***: The link is only crossable from the Left end to the Right
    one (the agent still needs to have the ability to go in that link direction).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Right to Left***: The link is only crossable from the Right end to the Left
    one (the agent still needs have the ability to go in that link direction).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Snap Radius*** and ***Height Radius***: You may have noticed a cylinder
    that attaches the end of each link. These two settings control the Radius and
    the Height of that cylinder. Check *Snap to Cheapest Area* for more information
    about the use of this cylinder. The following screenshot shows that the first
    link has a bigger cylinder (both a bigger radius and higher):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/695389b2-d0c7-4738-b69b-acf7be8d5361.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Description***: This is just a string in which you can insert a description
    for your convenience; it has no impact on the *Navigation* or on the *Link*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Snap to Cheapest Area***: If enabled, it will try to connect the link ends
    to the cheapest area among the available triangles within the cylinder that''s
    specified by the *Snap Radius* and the *Height Radius*. For instance, if the cylinder
    intersects both the *Default Nav Area* and the *BPJungle* Nav Area (that we created
    earlier), the link will be connected directly to the *Default Nav Area*, rather
    than the jungle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Area Class***: The *Link* might have a cost to traverse, or be of a specific
    *Nav Area*. This parameter allows you to define which kind of *Nav Area* the *Link* is
    when traversed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This concludes all the possibilities for the ***Simple Links***. However, this
    is a very powerful tool that lets you shape the *Nav Mesh* and achieve amazing
    AI behavior. Now, let's dive into *Smart Links*.
  prefs: []
  type: TYPE_NORMAL
- en: Smart Links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Smart Links can be enabled and disabled at *runtime* using the "***Smart Link
    Is Relevant***" boolean variable. You can also notify surrounding actors of this
    change. By default, it is not relevant (it isn't used in the sense that the link
    is not available), and there is only a single ***Smart Link*** per *Nav Proxy
    Link*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Please note, and don''t get confused**: The *Smart link* can be in two states:
    Enabled and Disabled. However, if the link is actually "present/exists" (for the
    Navigation Mesh), that is another property (*Smart Link Is Relevant*), which in
    other words means that the link is "*active*" for the Navigation System (but it
    can still be in the Enabled or Disabled state).'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately (at least for the current version of the Engine), these are not
    visible in the Editor, which means that the ***Start*** and ***End*** positions
    need to be set manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, let''s go through the settings of a *Smart Link*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/958f72d7-f063-49ac-ac10-8c36b41901cc.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Enabled Area Class***: This is the *Nav Area* that the Link assumes when
    it is enabled. The default is *NavArea_Default*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Disabled Area Class***: This is the *Nav Area* that the Link assumes when
    it is disabled. This means that, when the Link is disabled, it can still be traversed
    if a crossable area is assigned (e.g. when the link is disabled, we might want
    to have a very high cost to cross, but we still want it to be possible to traverse
    it. Of course, the default is *NavArea_Default*, which means that it is not crossable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Link Relative Start***: This represents the Start point of the link, relative
    to the position of its *Nav Link Proxy*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Link Relative End***: This represents the End point of the link, relative
    to the position of its *Nav Link Proxy*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Link Direction***: This specifies in which direction the link works. The
    possible options are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Both Ways***: The link is bidirectional (remember that the AI needs to be
    equipped to traverse the Link in both directions; e.g. over a ledge, the agent
    needs to be able to fall from it (one direction of the link) and jump (the other
    direction of the link).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Left to Right***: The link is only crossable from the Left end to the Right
    one (the agent still needs to have the ability to go in that link direction).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Right to Left***: The link is only crossable from the Right end to the Left
    one (the agent still needs to have the ability to go in that link direction).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the options of this parameter label the end points of the link as *Left*
    and *Right*, they refer to the *Start* and *End* point of the link. Alternatively
    (this may be better since the link can be bidirectional), *Link Relative Start*
    and *Link Relative End* refer to *Left* and *Right*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Link Enabled***: This is a boolean variable that determines whether the
    *Smart Link* is enabled. This value can be changed at runtime, and the link can
    "*notify*" surrounding agents/actors that are interested in such information (see
    later for more info). The default value is true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Smart Link Is Relevant***: This is a boolean variable that determines whether
    the *Smart Link* is actually "*active*", that is, if it is relevant or whether
    we should ignore it. The default value is false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the main settings regarding a Smart Link.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth mentioning that *Smart Links* can actually do more than just connect
    Nav Meshes. They have a series of functions to handle agents that are traversing
    the Link. For instance, by opening the `NavLinkProxy.h` file, we can find the
    following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, these functions are outside the scope of this book, but I invite
    you to read the code to learn more about them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, we mentioned that the *Smart Link* can broadcast information regarding
    its status change at runtime to nearby agent/actors. You can change how the *Smart
    Link* broadcasts this information with the ***Broadcast*** settings, which are
    just below the *Smart Link* ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36555d1b-3e0c-4ec7-a7f8-c4e01c536479.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These settings are quite intuitive, but let''s go through them quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: '***Notify when Enabled***: If true, the Link will notify agents/actors when
    it gets *Enabled*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Notify when Disabled***: If true, the Link will notify agents/actors when
    it gets *Disabled*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Broadcast Radius***: This specifies how far the broadcast should go. Every
    agent that is outside this radius will not get notified about the change of the
    Link.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Broadcast Interval***: This specifies after how long the Link should repeat
    the broadcast. If the value is zero, the broadcast is repeated only once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Broadcast Channel***: This is the trace channel for broadcasting the change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This concludes our discussion on ***Smart Links***.
  prefs: []
  type: TYPE_NORMAL
- en: Other settings of the Nav Link Proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, it''s just worth mentioning that the ***Nav Link Proxy*** can create
    an *Obstacle Box* when the *Nav Mesh* is generated. You can find these settings
    in the *Details Panel* of the ***Nav Link Proxy***, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec16dca6-906f-46f9-9647-3ef6462bfb5d.png)'
  prefs: []
  type: TYPE_IMG
- en: These settings allow you to decide whether the *Obstacle Box* is active/used,
    its *dimension/extent* and its offset, as well as the type of *Nav Area*.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the Nav Link Proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are wondering whether it is possible to extend *Links* or include them
    within more complex actors, the answer is "*Of course, Yes! But you can only extend
    them in C++*".
  prefs: []
  type: TYPE_NORMAL
- en: Since this book cannot cover everything, we don't have the time to deal with
    this in detail. However, some of the reasons why you may want to extend the ***Nav
    Link Proxy*** are to have a better control over the characters that enter your
    Link. For instance, you might want to have a *Jump Pad* that pushes the character
    through the Link. This isn't very complicated to do, and if you search for this
    online, you will find plenty of tutorials on how to do this using *Navigation
    Links*.
  prefs: []
  type: TYPE_NORMAL
- en: Just keep in mind that to be a good AI programmer in Unreal, you will eventually
    need to master this part of *Nav Links* as well, but for now, we are covering
    enough.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation Avoidance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Navigation Avoidance is a very broad topic, and Unreal has some subsystems that
    do this for us. Therefore, we will deal with this topic in [Chapter 6](c1359fa6-3bdf-4f0d-8a0c-98c35f885167.xhtml)*,
    Crowds*.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation Filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We don't want to find a certain path in the same way every time. Imagine that
    our AI agent uses a power up and it is able to move through the jungle twice as
    fast. In this case, the Navigation System is not aware of this change, nor is
    it a permanent change to the shape or weights of the *Nav Mesh*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Nav Filtering*** allows us to define specific rules on how to perform the
    pathfind for that specific period of time. You may have noticed that every time
    we perform a navigation task, either in Blueprint or C++, there is an optional
    parameter for inserting a ***Nav Filter***. Here are some examples of Blueprint
    nodes (the same goes for C++ functions) that have this optional filter parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76884c87-a640-4eef-8342-95d9c87ce979.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Even the ***Move To*** nodes of ***Behavior Trees*** have the ***Navigation
    Filter*** option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3c66db1-5dfc-4681-9faf-d233bf226f27.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, once you have inserted a filter, the pathfinding will behave accordingly.
    This means that using ***Nav Filters*** is pretty straightforward. However, how
    can we create ***Nav Filters***? Let's find out, both in Blueprint and C++.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Navigation Filter in Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously in this chapter, we created a Jungle area in Blueprint. Thus, this
    seems like a good example that we can use to create a ***Nav Filter*** that allows
    the AI Agent to travel through the Jungle faster – even faster than it takes to
    traverse the *Default Area* of the *Nav Mesh*. Let's imagine that the AI Agent
    has some power or ability that allows it to move faster in Jungle type areas in
    the level.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a ***Nav Filter*** in Blueprint, we need to start creating a new
    Blueprint that inherits from ***NavigationQueryFilter***, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ab2ad92-2ebe-4288-ac0a-c44987dcabc0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By convention, the name of the class should start with "*NavFilter_*". We will
    rename it to ***NavFilter_BPFastJungle*** (I added BP so that I can remember that
    I created this with Blueprint, since we are repeating the same task in Blueprint
    and in C++). This is what it should look like in the *Content Browser*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e66b0b6-c13f-426c-ae20-89eec9929602.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we open the Blueprint, we will find its options in the *Details* panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72deec62-e9a3-4d06-8959-56d80ddcd367.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, there is an ***Array of Areas*** and two sets for *Including
    and Excluding (Nav) Flags*. Unfortunately, we didn''t cover *Nav Flags* since
    they are out of the scope of this book, and they can only be assigned in C++ at
    the time of writing. However, the ***Array of Areas*** is quite interesting. Let''s
    add a new Area and use our ***NavArea_BPJungle*** for the ***Area Class***, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2de8dfeb-c213-4a39-80bb-41cd53eaad36.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can override the ***Travel Cost*** and the ***Entering Cost*** for
    the Jungle Area, which will be used instead of the costs we specified in the Area
    Class if this filter is used. Remember to tick the checkbox next to the option''s
    name to enable editing. For example, we could have a ***Travel Cost*** of ***0.6***
    (since we can move through the Jungle quickly without any issues) and an ***Entering
    Cost*** of ***zero***:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a5f47e4-1cb1-4140-a704-550b50bf9a2e.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we are all good to good. The filter is ready for if you prefer traveling
    in the Jungle!
  prefs: []
  type: TYPE_NORMAL
- en: '**Changing the Travel Cost for a** **Nav Area DOESN''T make the AI agent go
    faster or slower in that area**, it just makes pathfinding prefer that path over
    another. The implementation that the agent becomes faster in that area is left
    out from the *Navigation System*, and so you will need to implement that when
    the AI character is in the jungle.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you also followed the C++ part for the *Nav Areas*, then you should also
    have the Desert area in your project. As an optional step, we can add a second
    area to the filter. Imagine that by using the power-up or ability to move faster
    in the Jungle, our character has become very sensitive to the sun and very prone
    to sunburns, which decreases their health significantly. As a result, we can set
    a higher cost for the *Desert Area* if this filter is used. Just add another Area,
    and set the ***Area Class*** to ***NavArea_Desert***. Then, override the costs;
    for instance, a ***Travel Cost*** of ***2.5*** and an ***Entering Cost*** of ***10***:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/403f1ba4-5fc5-4d2c-bcef-50d932d1905f.png)'
  prefs: []
  type: TYPE_IMG
- en: Once you have finished editing the settings, save the Blueprint. From now on,
    you will be able to use this filter within the *Navigation System*. This concludes
    how to create a ***Nav Filter*** in Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Navigation Filter in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a similar way to Blueprint, we can create a C++ ***Nav Filter***. This time,
    we can create a filter that slightly lowers the cost for the Desert Area. You
    can use this filter on certain animals that live in the desert and will be less
    prone to its effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we need to create a new C++ class that inherits from ***NavigationQueryFilter***,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5fabbbab-98ea-4c47-9577-88f07d3c7fb3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By convention, the name of the class should start with "*NavFilter_*". Hence,
    we will rename it to ***NavFilter_Desert Animal*** and place it in "***Chapter3/Navigation***":'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17195ad5-bddc-4e6c-917d-39058ad8f501.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To set its properties, we need to create a default constructor. Write the following
    in the header (`.h`) file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For the implementation (`.cpp` file), we need to do a bit more work. First
    of all, we need to have access to the *Nav Area* that we need, which, in this
    case, is the Desert. Let''s add the following `#include` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the constructor, we need to create a ***FNavigationFilterArea***,
    which is a class that contains all the options for filtering a specific class.
    In our example, we can store this new *Filter Area* inside a variable named `Desert`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to fill the `Desert` variable with the options that we want to
    override for that class, including which ***Nav Area*** we are modifying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to add this *Filter Area* in the ***Areas*** array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For your convenience, here is the full `.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Compile this code and you will be able to use this filter next time you need
    to use the *Navigation System*. This concludes our discussion on *Navigation Filters*.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding the Navigation System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the *Mode Panel*, you are able to drag into the level a special actor called
    ***Nav System Config Override***.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e076b9b0-72f7-4027-803a-1d200c5c974d.png)'
  prefs: []
  type: TYPE_IMG
- en: This actor allows you to override the built-in *Navigation System* by using
    another one. Of course, you will have to develop it first, and this would need
    a lot of effort.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14df0108-48ef-4609-8f2c-0008f216d03d.png)'
  prefs: []
  type: TYPE_IMG
- en: Reasons why you should substitute the default Navigation System (or maybe used
    along with another one) is mainly due to overcome limitations. What about air-units;
    how can they do a 3D Pathfinding? How about spiders who have a surface pathfinding?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how we can set up the *Navigation System *so that
    our AI character can move around the map. In particular, we have learned how we
    can shape the *Nav Mesh* with *Modifier Volumes*, *Nav Link Proxies*, and *NavMesh
    Areas*.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, our AI agents can smoothly navigate through the map, efficiently
    finding a path between two points that is optimized based on their capabilities
    (e.g. using *Navigation Filters*) by respecting the varies types of "*terrains*"
    of the map (e.g. using *Navigation Areas*). Moreover, they can fall over ledges
    or jump between platforms (e.g. by using *Nav Link Proxies* and a bit of coding
    for jumping).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn about a more advanced AI feature
    in the Unreal Framework, that is, the *Environment Querying System*, which allows
    the agent to "*query*" the environment so that they can find locations (or actors)
    with specific requisites.
  prefs: []
  type: TYPE_NORMAL
