- en: Chapter 7. Clustering Customer Profiles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 聚类客户画像
- en: 'One of the amazing capabilities of neural networks applying unsupervised learning
    is their ability to find hidden patterns which even experts may not have any clue
    about. In this chapter, we''re going to explore this fascinating feature through
    a practical application to find customer and product clusters provided in transactions
    database. We''ll go through a review on unsupervised learning and the clustering
    task. To demonstrate this application, the reader will be provided with a practical
    example on customer profiling and it''s implementation in Java. The topics of
    this chapter are:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 神经网络在应用无监督学习时的一项令人惊叹的能力是它们发现隐藏模式的能力，即使专家也可能毫无头绪。在本章中，我们将通过一个实际应用来探索这一迷人的特性，该应用旨在通过交易数据库中提供的客户和产品聚类来寻找。我们将回顾无监督学习和聚类任务。为了演示这个应用，读者将获得一个关于客户画像及其在Java中实现的实际示例。本章的主题包括：
- en: Clustering tasks
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚类任务
- en: Cluster analysis
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚类分析
- en: Cluster evaluation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚类评估
- en: Applied unsupervised learning
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用无监督学习
- en: Radial basis functions neural network
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 径向基函数神经网络
- en: Kohonen network for clustering
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于聚类的Kohonen网络
- en: Handling with types of data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理数据类型
- en: Customer profiling
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户画像
- en: Preprocessing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预处理
- en: Implementation in Java
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java实现
- en: Credit analysis and profiles of customers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信用分析和客户画像
- en: Clustering tasks
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚类任务
- en: Clustering is part of a broader set of tasks in data analysis, whose objective
    is to group elements that look alike, more similar to each other, into clusters
    or groups. Clustering tasks are fully based on unsupervised learning since there
    is no need to include any target output data in order to find clusters; instead,
    the solution designer may choose a number of clusters that they want to group
    the records into and check the response of the algorithm to it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类是数据分析中更广泛任务集的一部分，其目标是把看起来相似、彼此更相似的数据元素分组或归类。聚类任务完全基于无监督学习，因为不需要包含任何目标输出数据来找到聚类；相反，解决方案设计者可以选择他们想要将记录分组的聚类数量，并检查算法对此的反应。
- en: Tip
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Clustering tasks may seem to overlap with classification tasks with the crucial
    difference that in clustering there is no need to have a predefined set of classes
    before the clustering algorithm is run.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类任务似乎与分类任务重叠，但关键区别在于聚类中不需要在运行聚类算法之前有一个预定义的类别集合。
- en: 'One may wish to apply clustering when there is little or no information at
    all about how the data can be gathered into groups. Provided with dataset, we
    wish our neural network to identify both the groups and their members. While this
    may seem easy and straightforward to perform visually in a two-dimensional dataset,
    as shown in the following figure, with a higher number of dimensions, this task
    becomes not so trivial to perform and needs an algorithmic solution:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当几乎没有关于如何将数据分组的信息时，人们可能会希望应用聚类。在提供数据集的情况下，我们希望我们的神经网络能够识别出组和它们的成员。虽然这在二维数据集中看起来很容易且直观，如图所示，但随着维数的增加，这项任务就不再那么简单，需要算法解决方案：
- en: '![Clustering tasks](img/B05964_07_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![聚类任务](img/B05964_07_01.jpg)'
- en: In clustering, the number of clusters is not determined by the data, but by
    the data analyst who is looking to cluster the data. Here the *boundaries* are
    a little bit different than those of classification tasks because they depend
    primarily on the number of clusters.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在聚类中，聚类的数量不是由数据决定的，而是由希望聚类数据的分析师决定的。在这里，*边界*与分类任务的边界略有不同，因为它们主要取决于聚类的数量。
- en: Cluster analysis
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚类分析
- en: One difficulty in the clustering tasks, and also in unsupervised learning tasks,
    is the accurate interpretation of the results. While in supervised learning there
    is a defined target, from which we can derive an error measure or confusion matrix,
    in unsupervised learning the evaluation of quality is totally different, and also
    totally dependent on the data itself. The validation criteria involves indexes
    that assert how well the data distributed across the clusters is, as well as external
    opinions from experts on the data that are also a measure of quality.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类任务中的一个困难，也是无监督学习任务中的一个困难，是对结果的准确解释。虽然在监督学习中有一个定义明确的目标，我们可以从中推导出误差度量或混淆矩阵，但在无监督学习中，质量的评估完全不同，并且完全依赖于数据本身。验证标准涉及指数，这些指数断言数据在聚类中的分布有多好，以及来自专家的外部意见，这些意见也是质量的一个衡量标准。
- en: Tip
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To illustrate an example, let's suppose a task of clustering of plants given
    their characteristics (sizes, leave colors, period of fruiting, and so on), and
    a neural network mistakenly groups cactus with pine trees in the same cluster.
    A botanist would certainly not endorse the classification based on their specific
    knowledge on the field that this grouping does not make any sense.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明一个例子，让我们假设一个基于植物特征（大小、叶色、结果实期等）进行聚类任务，而一个神经网络错误地将仙人掌和松树分到了同一个簇中。一个植物学家当然不会支持基于他们在该领域的专业知识，这种分组没有任何意义。
- en: Two major issues happen in clustering. One is the fact that one neural network's
    output is never activated, meaning that one cluster does not have any data point
    associated with it. Another one is the case of nonlinear or sparse clusters, which
    could be erroneously grouped into several clusters while actually there might
    be only one.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类过程中有两个主要问题。一个是某个神经网络的输出永远不会被激活，这意味着一个簇没有任何数据点与之关联。另一个是非线性或稀疏簇的情况，这些簇可能会错误地分成几个簇，而实际上可能只有一个。
- en: '![Cluster analysis](img/B05964_07_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![聚类分析](img/B05964_07_02.jpg)'
- en: Cluster evaluation and validation
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚类评估和验证
- en: Unfortunately, if the neural network clusters badly, one needs either to redefine
    the number of clusters or perform additional data preprocessing. To evaluate how
    well the clustered data is, the Davies-Bouldin and Dunn indexes may be applied.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果神经网络聚类效果不佳，就需要重新定义簇的数量或进行额外的数据预处理。为了评估聚类数据的好坏，可以应用 Davies-Bouldin 和 Dunn
    指数。
- en: 'The Davies-Boudin index takes into account the cluster''s centroids in order
    to find inter and intra-distances between clusters and cluster members:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Davies-Boudin 指数考虑簇的质心来寻找簇和簇成员之间的簇间和簇内距离：
- en: '![Cluster evaluation and validation](img/B05964_07_02_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![聚类评估和验证](img/B05964_07_02_01.jpg)'
- en: Where *n* is the number of clusters, ci is the centroid of cluster i, σi is
    the average distance of all elements in cluster *i*, and d(ci,cj) is the distance
    between clusters *i* and *j*. The smaller the value of DB index, the better the
    neural network will be considered to the cluster.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *n* 是簇的数量，ci 是簇 i 的质心，σi 是簇 *i* 中所有元素的平均距离，而 d(ci,cj) 是簇 *i* 和 *j* 之间的距离。DB
    指数的值越小，神经网络在聚类方面的表现越好。
- en: 'However, for dense and sparse clusters, the DB index will not give much useful
    information. This limitation can be overcome with the Dunn index:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于密集和稀疏簇，DB 指数不会提供太多有用的信息。这种限制可以通过 Dunn 指数来克服：
- en: '![Cluster evaluation and validation](img/B05964_07_02_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![聚类评估和验证](img/B05964_07_02_02.jpg)'
- en: Where *d(i,j)* is the inter cluster distance between *i* and *j*, and *d'(k)*
    is the intra cluster distance of cluster *k*. Here the higher the Dunn index is,
    the better the clustering will be because although the clusters may be sparse,
    they still need to be grouped together, and high intra-cluster distances will
    denote a bad grouping of data.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *d(i,j)* 是簇 *i* 和 *j* 之间的簇间距离，而 *d'(k)* 是簇 *k* 的簇内距离。在这里，Dunn 指数越高，聚类效果越好，因为尽管簇可能很稀疏，但它们仍然需要被分组在一起，高簇内距离将表示数据分组不良。
- en: Implementation
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'In the `CompetitiveLearning` class, we are going to implement these indexes:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CompetitiveLearning` 类中，我们将实现以下指标：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: External validation
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部验证
- en: In some cases, there is already an expected result for clustering, as in the
    example of plants clustering. This is called external validation. One may apply
    a neural network with unsupervised learning to cluster data that is already assigned
    a value. The major difference against the classification lies in the fact that
    the target outputs are not considered, so the algorithm itself is expected to
    draw a borderline based only on the data.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，聚类已经有了预期的结果，例如植物聚类的例子。这被称为外部验证。可以将无监督学习的神经网络应用于已经分配了值的聚类数据。与分类的主要区别在于，目标输出不被考虑，因此算法本身预期仅基于数据绘制边界线。
- en: Applied unsupervised learning
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用无监督学习
- en: In neural networks, there are a number of architectures implementing unsupervised
    learning; however, the scope of this book will cover only the Kohonen neural network,
    developed in [Chapter 4](ch04.xhtml "Chapter 4. Self-Organizing Maps"), *Self-Organizing
    Maps*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在神经网络中，有许多架构实现了无监督学习；然而，本书的范围将仅涵盖在第 4 章（[第 4 章](ch04.xhtml "第 4 章. 自组织映射"）中开发的
    Kohonen 神经网络，*自组织映射*。
- en: Kohonen neural network
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kohonen 神经网络
- en: Kohonen Networks, which have been covered in [Chapter 4](ch04.xhtml "Chapter 4. Self-Organizing
    Maps"), *Self-Organizing Maps* are now used in a modified fashion. Kohonen can
    produce a shape in one or two dimensions at the output, but here we are interested
    in clustering, which can be reduced in only one dimension.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Kohonen网络，在[第4章](ch04.xhtml "第4章. 自组织映射")中有所介绍，*自组织映射*现在以修改后的方式被使用。Kohonen可以在一维或二维输出中产生一个形状，但在这里我们感兴趣的是聚类，这可以简化为一维。
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Actually the Kohonen neural network implemented in this framework considers
    the dimensions zero, one, and two, where zero means no connections between the
    output neurons and one means they form a line, and two means a grid. For this
    chapter's example, we will need a Kohonen network with no connected output neurons,
    therefore, the dimension will be zero.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在这个框架中实现的Kohonen神经网络考虑了零维、一维和二维，其中零表示输出神经元之间没有连接，一表示它们形成一条线，二表示一个网格。对于本章的示例，我们需要一个没有连接输出神经元的Kohonen网络，因此维度将为零。
- en: 'In addition, clusters may be related or not to each other, so the vicinity
    of neurons can be ignored for now in this chapter, which means only one neuron
    will be activated and their neighbors will remain unchanged. And so, the neural
    network will adjust its weights to match data to an array of clusters:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，聚类之间可能有关联也可能无关，因此在本章中可以暂时忽略神经元的邻近性，这意味着只有一个神经元会被激活，而其邻居将保持不变。因此，神经网络将调整其权重以匹配数据到一系列聚类：
- en: '![Kohonen neural network](img/B05964_07_03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Kohonen神经网络](img/B05964_07_03.jpg)'
- en: The training algorithm will be the competitive learning, whereby the neuron
    with the greatest output has its weights adjusted. By the end of training, all
    the clusters of a neural network are expected to be defined. Note that there are
    no links between output neurons, meaning that only one input is active at the
    output.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 训练算法将是竞争学习，其中输出最大的神经元将调整其权重。到训练结束时，神经网络的所有聚类都应被定义。请注意，输出神经元之间没有链接，这意味着输出只有一个活动输入。
- en: Profiling
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置文件
- en: One of the interesting tasks in unsupervised learning is the profiling or clustering
    of information, in this chapter, customers and products. Given one dataset, one
    wants to find groups of records that share similar characteristics. Examples are
    customers that buy the same products or products that are usually bought together.
    This task results in a number of benefits for business owners because they are
    provided the information on which groups of customers and products they have,
    whereby they are enabled to address them more accurately.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 无监督学习中的一个有趣任务是信息的配置文件或聚类，在本章中是客户和产品。给定一个数据集，人们希望找到具有相似特征的记录组。例如，购买相同产品的客户或通常一起购买的产品。这项任务为商业主带来了许多好处，因为他们可以了解他们拥有的客户和产品组，从而能够更准确地针对他们。
- en: Pre-processing
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预处理
- en: 'As seen in [Chapter 6](ch06.xhtml "Chapter 6. Classifying Disease Diagnosis"),
    *Classifying Disease Diagnosis* transactional databases can contain both numerical
    and categorical data. Whenever we face a categorical unscaled variable, we need
    to split it into the number of values the variable may take, using the `CategoricalDataSet`
    class. For example, let''s suppose we have the following transaction list of customer
    purchases:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第6章](ch06.xhtml "第6章. 疾病诊断分类")中所示，*疾病诊断分类*事务数据库可以包含数值数据和分类数据。每当面对一个分类未缩放变量时，我们需要使用`CategoricalDataSet`类将其拆分为变量可能取的值的数量。例如，假设我们有以下客户购买事务列表：
- en: '| Transaction ID | Customer ID | Products | Discount | Total |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 交易ID | 客户ID | 产品 | 折扣 | 总计 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 1399 | 56 | Milk, Bread, Butter | 0.00 | 4.30 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 1399 | 56 | 牛奶，面包，黄油 | 0.00 | 4.30 |'
- en: '| 1400 | 991 | Cheese, Milk | 2.30 | 5.60 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 1400 | 991 | 干酪，牛奶 | 2.30 | 5.60 |'
- en: '| 1401 | 406 | Bread, Sausage | 0.00 | 8.80 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 1401 | 406 | 面包，香肠 | 0.00 | 8.80 |'
- en: '| 1402 | 239 | Chipotle Sauce, Spice | 0.00 | 6.70 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 1402 | 239 | 奶椒酱，香料 | 0.00 | 6.70 |'
- en: '| 1403 | 33 | Turkey | 0.00 | 4.50 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 1403 | 33 | 火鸡 | 0.00 | 4.50 |'
- en: '| 1404 | 406 | Turkey, Butter, Spice | 1.00 | 9.00 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 1404 | 406 | 火鸡，黄油，香料 | 1.00 | 9.00 |'
- en: 'It can easily be seen that the products are unscaled categorical data and for
    each transaction there is an undefined number of products purchased, the customer
    may purchase one or several. In order to transform that dataset into a numerical
    dataset, preprocessing is needed. For each product there will be a variable added
    to the dataset, resulting in the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 可以很容易地看出，产品是不加缩放的分类数据，并且对于每一笔交易，购买的产品数量是未定义的，客户可能购买一个或多个。为了将此数据集转换为数值数据集，需要进行预处理。对于每个产品，将在数据集中添加一个变量，结果如下：
- en: '| Cust. Id | Milk | Bread | Butter | Cheese | Sausage | Chipotle Sauce | Spice
    | Turkey |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 客户 ID | 牛奶 | 面包 | 黄油 | 干酪 | 香肠 | 奇普otle酱 | 调味品 | 火鸡 |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| 56 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 56 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 |'
- en: '| 991 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 991 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 |'
- en: '| 406 | 0 | 1 | 1 | 0 | 1 | 0 | 1 | 1 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 406 | 0 | 1 | 1 | 0 | 1 | 0 | 1 | 1 |'
- en: '| 239 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 0 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 239 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 0 |'
- en: '| 33 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 33 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |'
- en: In order to save space, we ignored the numerical variables and considered the
    presence of the product purchased by a client as *1* and the absence as *0*. Alternative
    preprocessing may consider the number of occurrences of a value, therefore becoming
    no longer binary, but discrete.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，我们忽略了数值变量，并考虑客户购买的产品存在与否作为 *1* 和 *0*。另一种预处理可能考虑值的出现次数，因此不再二进制，而是离散的。
- en: Implementation in Java
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java实现
- en: In this chapter, we are going to explore the usage of Kohonen neural network
    applied to customer clustering based on customer information collected from Proben1
    (Card dataset).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨将Kohonen神经网络应用于基于从Proben1（卡片数据集）收集的客户信息的客户聚类。
- en: Card – credit analysis for customer profiling
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 卡片 – 信用分析用于客户画像
- en: 'The card dataset is composed of 16 variables in total. 15 are inputs and one
    is output. For security reasons, all variable names have been changed to meaningless
    symbols. This dataset brings a good mix of variable types (continuous, categorical
    with small numbers of values, and categorical with a larger number of values).
    The following table shows a summary of data:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 卡片数据集总共由16个变量组成。其中15个是输入，1个是输出。出于安全考虑，所有变量名都已更改为无意义的符号。此数据集带来了各种变量类型的良好混合（连续型、具有少量值的分类型，以及具有更多值的分类型）。以下表格显示了数据的摘要：
- en: '| Variable | Type | Values |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 类型 | 值 |'
- en: '| --- | --- | --- |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| V1 | OUTPUT | 0; 1 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| V1 | 输出 | 0; 1 |'
- en: '| V2 | INPUT #1 | b, a |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| V2 | 输入 #1 | b, a |'
- en: '| V3 | INPUT #2 | continuous |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| V3 | 输入 #2 | 连续 |'
- en: '| V4 | INPUT #3 | continuous |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| V4 | 输入 #3 | 连续 |'
- en: '| V5 | INPUT #4 | u, y, l, t. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| V5 | 输入 #4 | u, y, l, t. |'
- en: '| V6 | INPUT #5 | g, p, gg |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| V6 | 输入 #5 | g, p, gg |'
- en: '| V7 | INPUT #6 | c, d, cc, i, j, k, m, r, q, w, x, e, aa, ff |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| V7 | 输入 #6 | c, d, cc, i, j, k, m, r, q, w, x, e, aa, ff |'
- en: '| V8 | INPUT #7 | v, h, bb, j, n, z, dd, ff, o |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| V8 | 输入 #7 | v, h, bb, j, n, z, dd, ff, o |'
- en: '| V9 | INPUT #8 | continuous |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| V9 | 输入 #8 | 连续 |'
- en: '| V10 | INPUT #9 | t, f |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| V10 | 输入 #9 | t, f |'
- en: '| V11 | INPUT #10 | t, f |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| V11 | 输入 #10 | t, f |'
- en: '| V12 | INPUT #11 | continuous |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| V12 | 输入 #11 | 连续 |'
- en: '| V13 | INPUT #12 | t, f |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| V13 | 输入 #12 | t, f |'
- en: '| V14 | INPUT #13 | g, p, s |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| V14 | 输入 #13 | g, p, s |'
- en: '| V15 | INPUT #14 | continuous |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| V15 | 输入 #14 | 连续 |'
- en: '| V16 | INPUT #15 | continuous |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| V16 | 输入 #15 | 连续 |'
- en: 'For simplicity we didn''t use the inputs *v5-v8* and *v14*, in order to not
    inflate the number of inputs very much. We applied the following transformation:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们没有使用输入 *v5-v8* 和 *v14*，以避免过多地增加输入数量。我们应用了以下转换：
- en: '| Variable | Type | Values | Conversion |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 类型 | 值 | 转换 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| V1 | OUTPUT | 0; 1 | - |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| V1 | 输出 | 0; 1 | - |'
- en: '| V2 | INPUT #1 | b, a | b = 1, a = 0 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| V2 | 输入 #1 | b, a | b = 1, a = 0 |'
- en: '| V3 | INPUT #2 | continuous | - |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| V3 | 输入 #2 | 连续 | - |'
- en: '| V4 | INPUT #3 | continuous | - |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| V4 | 输入 #3 | 连续 | - |'
- en: '| V9 | INPUT #8 | continuous | - |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| V9 | 输入 #8 | 连续 | - |'
- en: '| V10 | INPUT #9 | t, f | t = 1, f = 0 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| V10 | 输入 #9 | t, f | t = 1, f = 0 |'
- en: '| V11 | INPUT #10 | t, f | t = 1, f = 0 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| V11 | 输入 #10 | t, f | t = 1, f = 0 |'
- en: '| V12 | INPUT #11 | continuous | - |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| V12 | 输入 #11 | 连续 | - |'
- en: '| V13 | INPUT #12 | t, f | t = 1, f = 0 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| V13 | 输入 #12 | t, f | t = 1, f = 0 |'
- en: '| V15 | INPUT #14 | continuous | - |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| V15 | 输入 #14 | 连续 | - |'
- en: '| V16 | INPUT #15 | continuous | - |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| V16 | 输入 #15 | 连续 | - |'
- en: 'The neural net topology proposed is shown in the following figure:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 提出的神经网络拓扑结构如下所示：
- en: '![Card – credit analysis for customer profiling](img/B05964_07_04.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![卡片 – 信用分析用于客户画像](img/B05964_07_04.jpg)'
- en: 'The number of examples stored is 690, but 37 of them have missing values. These
    37 records were discarded. Therefore, 653 examples were used to train and test
    the neural network. The dataset division was made as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '**Training**: 583 records'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test**: 70 records'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Kohonen training algorithm used to cluster similar behavior depends on
    some parameters, such as:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Normalization type
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning rate
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to consider that the Kohonen training algorithm is unsupervised.
    So, this algorithm is used when the output is not known. In the card example there
    are output values in the dataset and they will be used here only to attest clustering.
    But in traditional clustering cases, the output values are not available.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'In this specific case, because output is known, as classification, the clustering
    quality may be attested by:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Sensibility (true positive rate)
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specificity (true negative rate)
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Total accuracy
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Java projects, the calculations of these values are done through a class
    named `NeuralOutputData`, previously developed in [Chapter 6](ch06.xhtml "Chapter 6. Classifying
    Disease Diagnosis"), *Classifying Disease Diagnosis*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'It is good practice to do many experiments to try to find the best neural net
    to cluster customers'' profiles. Ten different experiments will be generated and
    each will be analyzed with the quality rates mentioned previously. The following
    table summarizes the strategy that will be followed:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '| Experiment | Learning rate | Normalization type |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '| #1 | 0.1 | MIN_MAX |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| #2 | Z_SCORE |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| #3 | 0.3 | MIN_MAX |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| #4 | Z_SCORE |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| #5 | 0.5 | MIN_MAX |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| #6 | Z_SCORE |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: '| #7 | 0.7 | MIN_MAX |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| #8 | Z_SCORE |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '| #9 | 0.9 | MIN_MAX |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: '| #10 | Z_SCORE |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: The `ClusterExamples` class was created to run each experiment. In addition
    to processing data in [Chapter 4](ch04.xhtml "Chapter 4. Self-Organizing Maps"),
    *Self-Organizing Maps* it was also explained how to create a Kohonen net and how
    to train it via the Euclidian distance algorithm.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'The following piece of code shows a bit of its implementation:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After running each experiment using the `ClusteringExamples` class and saving
    the confusion matrix and total accuracy rates, it is possible to observe that
    experiments #4, #6, #8, and #10 have the same confusion matrix and accuracy. These
    experiments used z-score to normalize data:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '| Experiment | Confusion matrix | Total accuracy |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| #1 | [[14.0, 21.0][18.0, 17.0]] | 44.28% |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| #2 | [[11.0, 24.0][34.0, 1.0]] | 17.14% |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '| #3 | [[21.0, 14.0][17.0, 18.0]] | 55.71% |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '| #4 | [[24.0, 11.0][1.0, 34.0]] | 82.85% |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: '| #5 | [[21.0, 14.0][17.0, 18.0]] | 55.71% |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: '| #6 | [[24.0, 11.0][1.0, 34.0]] | 82.85% |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
- en: '| #7 | [[8.0, 27.0][7.0, 28.0]] | 51.42% |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| #8 | [[24.0, 11.0][1.0, 34.0]] | 82.85% |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| #9 | [[27.0, 8.0][28.0, 7.0]] | 48.57% |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| #10 | [[24.0, 11.0][1.0, 34.0]] | 82.85% |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: 'So, neural nets built by experiments #4, #6, #8, or #10 may be used to reach
    accuracy more than 80% to cluster customers financially.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Product profiling
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 产品分析
- en: 'Using a transactional database provided with the code, we''ve compiled about
    650 purchase transactions into a big matrix transactions *x* products, where in
    each cell there is the quantity of the corresponding product that has been bought
    on the corresponding transaction:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代码提供的交易数据库，我们已将大约650笔购买交易编译成一个大的矩阵交易 *x* 产品，其中每个单元格中都有对应交易中购买的相应产品的数量：
- en: '| #Trns. | Prd.1 | Prd.2 | Prd.3 | Prd.4 | Prd.5 | Prd.6 | Prd.7 | … | Prd.N
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| #Trns. | Prd.1 | Prd.2 | Prd.3 | Prd.4 | Prd.5 | Prd.6 | Prd.7 | … | Prd.N
    |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| 1 | 56 | 0 | 0 | 3 | 2 | 0 | 0 | … | 0 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 56 | 0 | 0 | 3 | 2 | 0 | 0 | … | 0 |'
- en: '| 2 | 0 | 0 | 40 | 0 | 7 | 0 | 19 | … | 0 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 0 | 0 | 40 | 0 | 7 | 0 | 19 | … | 0 |'
- en: '| … | … | … | … | … | … | … | … | … | … |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| … | … | … | … | … | … | … | … | … | … |'
- en: '| n | 0 | 0 | 0 | 0 | 0 | 0 | 0 | … | 1 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| n | 0 | 0 | 0 | 0 | 0 | 0 | 0 | … | 1 |'
- en: Let's consider that this matrix is a representation in an N-dimensional hyperspace
    taking each product as a dimension and the transactions as points. For simplicity,
    let's consider an example on three dimensions. A given transaction with the quantities
    bought for each product will be placed in a point corresponding to the quantities
    at each dimension.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑这个矩阵是在一个 N 维超空间中的表示，每个产品作为一个维度，交易作为点。为了简单起见，让我们考虑一个三维的例子。一个给定的交易将每个产品的购买数量放置在每个维度的对应点上。
- en: '![Product profiling](img/B05964_07_05.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![产品分析](img/B05964_07_05.jpg)'
- en: The idea is to cluster these transactions in order to find which products are
    usually bought together. So, we are going to use a Kohonen neural network in order
    to find the positions of the products that the clusters centers will be located
    at.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是聚类这些交易，以找到哪些产品通常一起购买。因此，我们将使用 Kohonen 神经网络来找到产品簇中心的定位。
- en: 'Our database consists of a clothing store and a sample of 27 registered products:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据库由一家服装店和27个注册产品的样本组成：
- en: '| 1 Long Dress A | 19 Overall with zipper | 43 Bermuda M |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 1 长裙 A | 19 带拉链的整体 | 43 百慕大 M |'
- en: '| 3 Long Dress B | 22 Shoulder overall | 48 Stripped skirt |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 3 长裙 B | 22 肩部整体 | 48 条纹裙 |'
- en: '| 7 Short Dress A | 23 Long stamped skirt | 67 Camisole shoulder strap |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 7 短裙 A | 23 长印花裙 | 67 无袖衫肩带 |'
- en: '| 8 Stamped Dress | 24 Stamped short dress | 68 Jeans M |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 8 印花裙 | 24 印花短裙 | 68 牛仔裤 M |'
- en: '| 9 Women Camisole | 28 Pants M | 69 XL Short dress |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 9 女士无袖衫 | 28 短裤 M | 69 XL 短裙 |'
- en: '| 13 Pants S | 31 Sleeveless short dress | 74 Stripped camisole S |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 13 短裤 S | 31 无袖短裙 | 74 条纹无袖衫 S |'
- en: '| 16 Overall for children | 32 Short dress shoulder | 75 Stripped camisole
    M |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 16 儿童整体 | 32 短裙肩部 | 75 条纹无袖衫 M |'
- en: '| 17 Shorts | 34 Short dress B | 76 Stripped camisole L |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 17 短裤 | 34 短裙 B | 76 条纹无袖衫 L |'
- en: '| 18 Stamped overall | 42 Two blouse overall | 106 Straight skirt |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 18 印花整体 | 42 两件套上衣 | 106 直筒裙 |'
- en: How many clusters?
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有多少个簇？
- en: Sometimes it may be difficult to choose how many clusters to find in a clustering
    algorithm. Some approaches to determine an optimal choice include information
    criteria such as **Akaike Information Criteria** (**AIC**), **Bayesian Information
    Criteria** (**BIC**), and the Mahalanobis distance from the center to the data.
    We suggest to the reader to check the references if interested in further details
    on these criteria.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在聚类算法中确定要找到多少个簇可能很困难。确定最佳选择的某些方法包括信息准则，如 **赤池信息准则** (**AIC**), **贝叶斯信息准则**
    (**BIC**), 以及从中心到数据的马氏距离。我们建议读者如果对这些准则的更多细节感兴趣，请查阅参考文献。
- en: 'To make tests to product example, we also should use the `ClusteringExamples`
    class. For simplicity, we run tests with three and five clusters. For each experiment,
    the number of epochs was *1000*, the learning rate was *0.5*, and the normalization
    type was `MIN_MAX (-1; 1)`. Some results are shown in the following table:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对产品进行测试，我们也应该使用 `ClusteringExamples` 类。为了简单起见，我们使用三个和五个簇进行测试。对于每个实验，epoch
    数为 *1000*，学习率为 *0.5*，归一化类型为 `MIN_MAX (-1; 1)`。一些结果如下表所示：
- en: '| Number of clusters | Clusters of the first 15 elements | Sum of products
    bought |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 簇数量 | 前十五个元素组成的簇 | 购买产品总和 |'
- en: '| --- | --- | --- |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 3 | 0, 1, 2, 2, 2,2, 2, 2, 2, 2,2, 2, 0, 0, 2, | 973, 585, 11, 5, 2,4, 11,
    6, 3, 2,2, 2, 669, 672, 7, |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 0, 1, 2, 2, 2,2, 2, 2, 2, 2,2, 2, 0, 0, 2, | 973, 585, 11, 5, 2,4, 11,
    6, 3, 2,2, 2, 669, 672, 7, |'
- en: '| 5 | 0, 1, 4, 4, 4,4, 4, 4, 4, 4,4, 4, 0, 0, 4, | 973, 585, 11, 5, 2,4, 11,
    6, 3, 2,2, 2, 669, 672, 7, |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 0, 1, 4, 4, 4,4, 4, 4, 4, 4,4, 4, 0, 0, 4, | 973, 585, 11, 5, 2,4, 11,
    6, 3, 2,2, 2, 669, 672, 7, |'
- en: Observing the preceding table, we note when the sum of products acquired is
    more than 600, then it's clustered together. Otherwise, when the sum is in the
    range of 500 to 599, another cluster is formed. Lastly, if the sum is low, a large
    cluster is created, because the dataset is compound by many cases that customers
    doesn't by more than 20 items.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 观察前表，我们注意到当产品组合的总和超过600时，它们会聚集在一起。否则，当总和在500到599之间时，会形成另一个簇。最后，如果总和较低，会创建一个大簇，因为数据集由许多客户购买不超过20件商品的案例组成。
- en: Tip
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As recommend in the previous chapter, we suggest you explore the `ClusteringExamples`
    class and create a GUI to easily select the neural net parameters. You should
    try to reuse code through the inheritance concept.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所建议，我们建议您探索`ClusteringExamples`类，并创建一个GUI以轻松选择神经网络参数。您应该尝试通过继承概念重用代码。
- en: 'Another tip is to further explore the product profiling example: varying the
    neural network training parameters, the number of clusters, and/or develop others
    ways of analyzing the clustering result.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个技巧是进一步探索产品特征示例：调整神经网络训练参数、簇的数量，或者开发其他分析聚类结果的方法。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've an application of customer profiling using the Kohonen
    neural network. Unlike the classification task, the clustering task does not consider
    the previous knowledge on the desired output; instead it is desirable for the
    clusters to be found by the neural network. However, we've seen that validation
    techniques may include external validation, which is a comparison with what could
    be understood as *target output*. Customer profiling is important because it gives
    a business owner more accurate and clean information about their customers, without
    the *human interference* in pointing which customers are in some groups or in
    others, as occurs in supervised learning. That's the advantage of unsupervised
    learning, enabling the data to draw results solely by themselves.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了使用Kohonen神经网络的客户特征应用。与分类任务不同，聚类任务不考虑对所需输出的先前知识；相反，希望神经网络找到簇。然而，我们已经看到验证技术可能包括外部验证，这可以与所谓的*目标输出*进行比较。客户特征分析很重要，因为它为业务所有者提供了关于客户更准确和干净的信息，没有*人为干预*指出哪些客户属于某个群体或另一个群体，正如在监督学习中发生的那样。这就是无监督学习的优势，使数据能够完全自行得出结果。
