<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-56">
    <a id="_idTextAnchor058">
    </a>
    
     3
    
   </h1>
   <h1 id="_idParaDest-57">
    <a id="_idTextAnchor059">
    </a>
    
     Presenting the Unreal Engine Navigation System
    
   </h1>
   <p>
    
     The Unreal Engine
    
    <strong class="bold">
     
      Navigation System
     
    </strong>
    
     is a
    
    <a id="_idIndexMarker112">
    </a>
    
     sophisticated framework that enables AI-controlled entities to navigate and interact seamlessly within game levels.
    
    
     It provides a set of tools and algorithms that allow game developers to define and create paths, obstacles, and movement behaviors.
    
    
     By using the Navigation System, you will be able to simulate realistic movement and behavior patterns of AI-controlled entities, enhancing the immersion and believability of your virtual environments.
    
    
     As this system incorporates
    
    <a id="_idIndexMarker113">
    </a>
    
     advanced features
    
    <a id="_idIndexMarker114">
    </a>
    
     such as
    
    <strong class="bold">
     
      pathfinding algorithms
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      collision avoidance
     
    </strong>
    
     , and
    
    <strong class="bold">
     
      dynamic obstacle handling
     
    </strong>
    
     , understanding
    
    <a id="_idIndexMarker115">
    </a>
    
     its full potential is a crucial skill for aspiring
    
    
     
      AI programmers.
     
    
   </p>
   <p>
    
     By the time you reach the end of this chapter, you will possess a strong comprehension of how this specific part of the Gameplay Framework operates.
    
    
     Equipped with this knowledge, you will be fully prepared to embark on your journey of actively working with the
    
    
     
      system itself.
     
    
   </p>
   <p>
    
     In this chapter, we will be covering the
    
    
     
      following topics:
     
    
   </p>
   <ul>
    <li>
     
      Introducing
     
     
      
       AI movement
      
     
    </li>
    <li>
     
      
       Understanding pathfinding
      
     
    </li>
    <li>
     
      Testing the Navigation System with a
     
     
      
       project template
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-58">
    <a id="_idTextAnchor060">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     There are no technical requirements to follow for
    
    
     
      this chapter.
     
    
   </p>
   <h1 id="_idParaDest-59">
    <a id="_idTextAnchor061">
    </a>
    
     Introducing AI movement
    
   </h1>
   <p>
    
     When it comes to moving
    
    <a id="_idIndexMarker116">
    </a>
    
     AI entities in a virtual environment, we face numerous challenges, and there is no universal solution.
    
    
     The approach to solving each problem depends on each unique characteristic that will be faced in the type of game being developed.
    
    
     For example, is the AI’s destination something stationary – for instance, a pickup – or is it something that is moving unpredictably, such as the player character?
    
    
     Furthermore, will the AI just need to wander around without a specific destination, or will it have a pre-defined pattern – for instance, as a
    
    
     
      patrolling sentinel?
     
    
   </p>
   <p>
    
     Also, as a developer, you will need to consider factors such as different terrains, obstacles, and dangerous zones.
    
    
     Deciding between an easier or a more dangerous – but quicker – path can have a significant impact at runtime.
    
    
     These are just a few of the considerations involved in moving AIs within a level and, as you encounter different scenarios, you will be likely to face different issues.
    
    
     Understanding and properly addressing all pertinent variables is essential for an optimal
    
    
     
      player experience.
     
    
   </p>
   <p>
    
     So, what are the main entities involved in AI movement and, specifically, in pathfinding?
    
    
     How do they cooperate to make a player’s experience flawless?
    
    
     I will tell you all about it in a
    
    
     
      few seconds!
     
    
   </p>
   <h2 id="_idParaDest-60">
    <a id="_idTextAnchor062">
    </a>
    
     Understanding the Navigation Mesh
    
   </h2>
   <p>
    
     In Unreal Engine, the Navigation System
    
    <a id="_idIndexMarker117">
    </a>
    
     is based on a
    
    <strong class="bold">
     
      navigation mesh
     
    </strong>
    
     – or
    
    <strong class="bold">
     
      nav mesh
     
    </strong>
    
     – that
    
    <a id="_idIndexMarker118">
    </a>
    
     works by dividing the navigable space into polygons, which are subsequently divided into triangles for efficiency.
    
    
     Each triangle is then considered a node of a graph to reach a specific location and when two triangles are adjacent, their respective nodes are connected.
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    <em class="italic">
     
      .1
     
    </em>
    
     depicts a game level with the aforementioned mesh, divided
    
    
     
      by triangles:
     
    
   </p>
   <div><div><img alt="Figure 3.1 – A nav mesh example" src="img/B31016_03_1.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.1 – A nav mesh example
    
   </p>
   <p>
    
     Using this
    
    <a id="_idIndexMarker119">
    </a>
    
     graph, you can apply any type of pathfinding algorithm – such as
    
    <strong class="bold">
     
      A-star
     
    </strong>
    
     (
    
    <strong class="bold">
     
      A*
     
    </strong>
    
     ), which I will explain later in this chapter – and the resulting process will generate a path among these triangles that the AI character
    
    
     
      can traverse.
     
    
   </p>
   <p>
    
     Fortunately, unless
    
    <a id="_idIndexMarker120">
    </a>
    
     you truly need to delve into the intricacies of altering the core structure of the Navigation System, there is no immediate need to venture into such detail.
    
    
     Understanding that the collection of generated triangles forms a cohesive graph, which serves as the foundation for pathfinding algorithms, is sufficient for getting the best out of the
    
    
     
      Navigation System.
     
    
   </p>
   <p>
    
     To generate a nav mesh in Unreal Engine, all you have to do is add one or more
    
    <strong class="bold">
     
      Nav Mesh Bounds Volume
     
    </strong>
    
     actors
    
    <a id="_idIndexMarker121">
    </a>
    
     in the level and change their size to suit your
    
    
     
      own needs.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     In Unreal Engine, a
    
    <strong class="source-inline">
     
      Volume
     
    </strong>
    
     class
    
    <a id="_idIndexMarker122">
    </a>
    
     refers to a special type of actor that can influence the behavior of other actors within its area of effect.
    
    
     Volumes are used to define various effects, such as lighting, and can modify how players or other objects interact with the game world.
    
    
     Some common types of volumes in Unreal Engine include Trigger Volumes, Lightmass Importance Volumes, Post-Processing Volumes, and, obviously, Nav Mesh
    
    
     
      Bounds Volumes.
     
    
   </p>
   <p>
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    <em class="italic">
     
      .2
     
    </em>
    
     shows a
    
    <strong class="bold">
     
      Nav Mesh Bounds Volume
     
    </strong>
    <a id="_idIndexMarker123">
    </a>
    
     actor added to a level; the yellow lines mark the
    
    
     
      volume itself.
     
    
   </p>
   <div><div><img alt="Figure 3.2 – A Nav Mesh Bounds Volume" src="img/B31016_03_2.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.2 – A Nav Mesh Bounds Volume
    
   </p>
   <p>
    
     This actor is pretty straightforward, and the only possible action you can take with it is to adjust its extension.
    
    
     From the previous image, you may have noticed a green mesh, made of two triangles; this fairly simple shape has been generated by another actor: the
    
    <strong class="bold">
     
      Recast Nav Mesh
     
    </strong>
    
     one, which
    
    <a id="_idIndexMarker124">
    </a>
    
     is usually auto-generated the very first time Nav Mesh Bounds Volume is added to
    
    
     
      the level.
     
    
   </p>
   <p>
    
     This actor oversees the walkable area generation for AI entities that will use it to make their own efficient and accurate calculations on pathfinding; an instance of it is usually auto-generated once you add a Nav Mesh Bounds Volume in
    
    
     
      your level.
     
    
   </p>
   <p>
    
     It should be noted that most of the settings available for the
    
    <strong class="source-inline">
     
      RecastNavMesh
     
    </strong>
    
     actor can be set with predefined values in your editor’s
    
    <strong class="bold">
     
      Project Settings
     
    </strong>
    
     – this can be opened from the
    
    <strong class="bold">
     
      File
     
    </strong>
    
     menu – by selecting the
    
    <strong class="bold">
     
      Engine - Navigation Mesh
     
    </strong>
    
     section, as depicted in
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    
     <em class="italic">
      
       .3
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 3.3 – The Navigation Mesh settings section" src="img/B31016_03_3.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.3 – The Navigation Mesh settings section
    
   </p>
   <p>
    
     Now that you understand how a nav mesh is created in Unreal Engine, it is important to know that you can adjust it to enhance its interest and realism using navigation modifiers by using the available
    
    
     
      modifier system.
     
    
   </p>
   <h2 id="_idParaDest-61">
    <a id="_idTextAnchor063">
    </a>
    
     Modifying the nav mesh
    
   </h2>
   <p>
    
     The Navigation System comprises various actors
    
    <a id="_idIndexMarker125">
    </a>
    
     and components that alter the generation of the nav mesh, such as the cost of traversing a polygon.
    
    
     These adjustments influence how AI agents move through
    
    
     
      your level.
     
    
   </p>
   <h3>
    
     The Nav Modifier Volume
    
   </h3>
   <p>
    
     The simplest one is the
    
    <a id="_idIndexMarker126">
    </a>
    <strong class="bold">
     
      Nav Modifier Volume
     
    </strong>
    
     actor, whose task is… well, to modify a nav mesh!
    
    
     Once you have positioned this volume in your level, you will have the choice to modify how an AI agent will perceive it for pathfinding – you can designate it as an impassable terrain, a difficult terrain, or even an obstacle.
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    <em class="italic">
     
      .4
     
    </em>
    
     shows three modifier volumes set with the three different
    
    
     
      cost settings:
     
    
   </p>
   <div><div><img alt="Figure 3.4 – Three navigation modifiers in action" src="img/B31016_03_4.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.4 – Three navigation modifiers in action
    
   </p>
   <p>
    
     If you are
    
    <a id="_idIndexMarker127">
    </a>
    
     thinking about creating your own nav mesh modifiers, well, that’s possible; you will just need to extend the
    
    <strong class="source-inline">
     
      UNavArea
     
    </strong>
    
     class, set its parameters, and you are ready
    
    
     
      to go!
     
    
   </p>
   <h3>
    
     Navigation Query Filters
    
   </h3>
   <p>
    
     As an additional method for tailoring the behavior of the Navigation System when generating paths for AI agents, you can take advantage
    
    <a id="_idIndexMarker128">
    </a>
    
     of
    
    <strong class="bold">
     
      Navigation Query Filters
     
    </strong>
    
     .
    
    
     This method encompasses information pertaining to one or more specific areas and provides the flexibility to override the cost values assigned to the areas themselves, if necessary.
    
    
     By implementing query filters, you will gain the ability to customize the navigation patterns of AI agents as they traverse various regions within your game world, and this will let you fine-tune and optimize the movement of
    
    
     
      AI entities.
     
    
   </p>
   <h3>
    
     Navigation Link Proxies
    
   </h3>
   <p>
    
     When you begin designing your
    
    <a id="_idIndexMarker129">
    </a>
    
     walkable terrain, you will most probably be introducing gaps or areas with varying altitudes; and I guess you’ll need your AI character to jump from one side to the other.
    
    
     That’s exactly why the Nav Link Proxy has been created; this actor will connect two areas of the nav mesh that lack a direct navigation path.
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    <em class="italic">
     
      .5
     
    </em>
    
     shows such a link, connecting two zones at
    
    
     
      different heights:
     
    
   </p>
   <div><div><img alt="Figure 3.5 – Nav link proxy" src="img/B31016_03_5.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.5 – Nav link proxy
    
   </p>
   <p>
    
     With such a
    
    <a id="_idIndexMarker130">
    </a>
    
     useful tool at your disposal, you will be able to make your character jump, fall down, and execute breathtaking acrobatics, seamlessly transitioning from one gravity-defying move
    
    
     
      to another.
     
    
   </p>
   <h3>
    
     Runtime nav mesh generation
    
   </h3>
   <p>
    
     By default, Unreal Engine
    
    <a id="_idIndexMarker131">
    </a>
    
     is set to generate nav meshes statically – this means that the mesh is generated offline and cannot be changed at runtime.
    
    
     However, if you need a more flexible way of generating a nav mesh, you can opt for the
    
    <strong class="bold">
     
      dynamic mesh generation
     
    </strong>
    
     system
    
    <a id="_idIndexMarker132">
    </a>
    
     that will let you update the mesh under different circumstances – for example, by adding moving entities.
    
    
     The runtime generation can be enabled for the whole project by opening
    
    <strong class="bold">
     
      Project Settings
     
    </strong>
    
     , and then going to the
    
    <strong class="bold">
     
      Engine - Navigation Mesh
     
    </strong>
    
     section, and selecting the
    
    <strong class="bold">
     
      Runtime Generation
     
    </strong>
    
     option in the
    
    
     <strong class="bold">
      
       Runtime
      
     </strong>
    
    
     
      category:
     
    
   </p>
   <div><div><img alt="Figure 3.6 – Enabling Runtime Generation" src="img/B31016_03_6.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.6 – Enabling Runtime Generation
    
   </p>
   <p>
    
     Alternatively, you can
    
    <a id="_idIndexMarker133">
    </a>
    
     enable it for just a single level, by changing the
    
    <strong class="bold">
     
      Runtime Generation
     
    </strong>
    
     attribute in the
    
    <strong class="bold">
     
      Recast Nav
     
    </strong>
    
     <strong class="bold">
      
       Mesh
      
     </strong>
    
    
     
      actor.
     
    
   </p>
   <h3>
    
     Invokers
    
   </h3>
   <p>
    
     A
    
    <strong class="bold">
     
      Navigation Invoker
     
    </strong>
    
     is an
    
    <a id="_idIndexMarker134">
    </a>
    
     actor component that will generate the nav mesh around an AI agent at runtime.
    
    
     It is used to remove the need for pre-computing the mesh, and it allows for dynamic navigation in the game world.
    
    
     This feature is particularly useful when you have extensive terrains – for instance, an open world – that will take a huge amount of time to generate the nav mesh; through an Invoker, the system will generate the mesh itself at runtime, but just in a limited space, around
    
    
     
      the actor.
     
    
   </p>
   <p>
    
     You now have a grasp of how a nav mesh is created and tweaked, so let’s explore who – or what – will be moving
    
    
     
      through it.
     
    
   </p>
   <h2 id="_idParaDest-62">
    <a id="_idTextAnchor064">
    </a>
    
     AI agents
    
   </h2>
   <p>
    
     In Unreal Engine’s Navigation System, an
    
    <strong class="bold">
     
      agent
     
    </strong>
    
     is an
    
    <a id="_idIndexMarker135">
    </a>
    
     AI character or entity that is capable of navigating the game world by means of the nav mesh.
    
    
     An agent will use the nav mesh data to compute paths, avoid obstacles, and move around the environment intelligently.
    
    
     Each agent in a level typically represents a specific type of character, such as a player character – for instance, in a point-and-click game – an enemy AI, or any other entity that needs to move within the
    
    
     
      game world.
     
    
   </p>
   <p>
    
     To move an agent within a
    
    <a id="_idIndexMarker136">
    </a>
    
     level, you will typically be using a
    
    <strong class="bold">
     
      Pawn
     
    </strong>
    
     or a
    
    
     <strong class="bold">
      
       Character
      
     </strong>
    
    
     
      actor.
     
    
   </p>
   <p>
    
     One of the easiest ways to move an agent toward a location or an actor is by using the
    
    <strong class="bold">
     
      Simple Move to Location
     
    </strong>
    
     or
    
    <strong class="bold">
     
      Simple Move to Actor
     
    </strong>
    
     
      Blueprint nodes.
     
    
   </p>
   <div><div><img alt="Figure 3.7 – The Simple Move nodes" src="img/B31016_03_7.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.7 – The Simple Move nodes
    
   </p>
   <p>
    
     Alternatively, you can use the corresponding C++ methods called, respectively,
    
    <strong class="source-inline">
     
      SimpleMoveToLocation()
     
    </strong>
    
     
      and
     
    
    
     <strong class="source-inline">
      
       SimpleMovetoActor()
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Obviously, in Unreal Engine, you can create more complex behaviors than just moving an agent to a single point; this is something we will explore starting from
    
    <a href="B31016_08.xhtml#_idTextAnchor148">
     
      <em class="italic">
       
        Chapter 8
       
      </em>
     
    </a>
    
     ,
    
    <em class="italic">
     
      Setting Up a
     
    </em>
    
     <em class="italic">
      
       Behavior Tree
      
     </em>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-63">
    <a id="_idTextAnchor065">
    </a>
    
     Avoidance
    
   </h2>
   <p>
    
     Basic pathfinding algorithms are effective for finding routes around stationary objects; however, when it comes to moving obstacles – such as player characters or other AI agents – a more suitable system is needed.
    
    
     That’s why Unreal Engine provides two
    
    <strong class="bold">
     
      avoidance
     
    </strong>
    
     systems, to prevent
    
    <a id="_idIndexMarker137">
    </a>
    
     collision between
    
    
     
      moving entities:
     
    
   </p>
   <ul>
    <li>
     
      The
     
     <strong class="bold">
      
       Reciprocal Velocity Obstacles
      
     </strong>
     
      (
     
     <strong class="bold">
      
       RVO
      
     </strong>
     
      ) system
     
     <a id="_idIndexMarker138">
     </a>
     
      computes the
     
     <a id="_idIndexMarker139">
     </a>
     
      velocity vectors for each agent, considering nearby agents and assuming they are moving at a constant velocity in each time step of the calculation.
     
     
      The chosen optimal velocity vector is the closest match to the agent’s desired velocity in the direction of its destination.
     
     
      This system is included in the character movement component.
     
     
      RVO does not use the nav mesh for
     
     <a id="_idIndexMarker140">
     </a>
     
      avoidance, so it
     
     <a id="_idIndexMarker141">
     </a>
     
      can be used separately from the Navigation System for
     
     
      
       any character.
      
     
    </li>
    <li>
     
      The
     
     <strong class="bold">
      
       Detour Crowd Manager
      
     </strong>
     
      computes a
     
     <a id="_idIndexMarker142">
     </a>
     
      rough sample of velocities that lean
     
     <a id="_idIndexMarker143">
     </a>
     
      toward the agent’s direction, resulting in a substantial enhancement in avoidance quality compared to the standard RVO approach.
     
     
      This system can be used by any actor extending the
     
     <strong class="source-inline">
      
       Pawn
      
     </strong>
     
      class by using the
     
     
      <strong class="source-inline">
       
        ADetourCrowdAIController
       
      </strong>
     
     
      
       class.
      
     
    </li>
   </ul>
   <p>
    
     You will be introduced to avoidance in
    
    <a href="B31016_05.xhtml#_idTextAnchor099">
     
      <em class="italic">
       
        Chapter 5
       
      </em>
     
    </a>
    
     ,
    
    <em class="italic">
     
      Improving
     
    </em>
    
     <em class="italic">
      
       Agent Navigation
      
     </em>
    
    
     
      .
     
    
   </p>
   <p>
    
     In this section, you have been introduced to the main elements involved in pathfinding and how they interact with
    
    
     
      the environment.
     
    
   </p>
   <p>
    
     In the following section, I will provide you with further details on how
    
    
     
      pathfinding works.
     
    
   </p>
   <h1 id="_idParaDest-64">
    <a id="_idTextAnchor066">
    </a>
    
     Understanding pathfinding
    
   </h1>
   <p>
    
     As you are aware, Unreal Engine uses
    
    <strong class="bold">
     
      pathfinding
     
    </strong>
    
     for
    
    <a id="_idIndexMarker144">
    </a>
    
     moving an agent around a level; in this section, I will go a bit deeper into detail on how things work under the hood.
    
    
     Unreal Engine takes advantage of a generalized version of the A* algorithm, a widely employed graph traversal and pathfinding algorithm in computer science.
    
    
     Known for its completeness, optimality, and efficiency, its main goal is to determine the shortest path between a designated source node and a specified goal node in a
    
    
     
      weighted graph.
     
    
   </p>
   <p>
    
     This graph is a node-based representation of the level, where nodes represent walkable areas that are interconnected and have information on neighbor nodes and traversal costs to
    
    
     
      reach them.
     
    
   </p>
   <p>
    
     A* uses a heuristic function to estimate the cost from each node to the target location; this trial-by-error system helps guide the search toward the most promising paths,
    
    
     
      improving efficiency.
     
    
   </p>
   <p>
    
     During the pathfinding process, the algorithm maintains two lists: one of them contains nodes that are yet to be evaluated, while the other contains nodes that have already been evaluated.
    
    
     The algorithm evaluates each node by considering its cost, and the cost of reaching it from the previous node.
    
    
     It selects the node with the lowest total cost from the open list for further evaluation.
    
    
     Once the target node is reached, the algorithm reconstructs the path by backtracking from the target node to the start node, following the connections
    
    
     
      between nodes.
     
    
   </p>
   <p>
    
     Unreal Engine’s version often includes post-smoothing operations to improve the quality of the generated path.
    
    
     Post-smoothing adjusts the path to make it more natural and avoid obstacles
    
    
     
      more effectively.
     
    
   </p>
   <p>
    
     If you want to take a deep dive into how the nav mesh generation works and how pathfinding is computed, my suggestion is to check the Unreal Engine source code available on GitHub (
    
    <a href="https://github.com/EpicGames/UnrealEngine">
     
      https://github.com/EpicGames/UnrealEngine
     
    </a>
    
     ); in particular, you should look for the
    
    <strong class="source-inline">
     
      NavigationSystem
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      NavMesh
     
    </strong>
    
     modules, which are located in the
    
    
     <strong class="source-inline">
      
       Engine/Source/Runtime
      
     </strong>
    
    
     
      folder.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     To access the Unreal Engine source code, you will need to be part of the Epic Games GitHub organization.
    
    
     Subscription is free and there’s no reason why you shouldn’t take part
    
    
     
      in it.
     
    
   </p>
   <p>
    
     As an example, by
    
    <a id="_idIndexMarker145">
    </a>
    
     checking the
    
    <strong class="source-inline">
     
      DetourNavMeshQuery
     
    </strong>
    
     class in the Unreal Engine source code, you will get an insight into how the A* pathfinding algorithm is used and how cost is computed or how to find a tile on
    
    
     
      a path.
     
    
   </p>
   <p>
    
     It seems you have gained some insight into how pathfinding is handled within Unreal Engine, so I guess it’s time to delve into a practical example by exploring a real case scenario; we will begin by creating a project from
    
    
     
      a template.
     
    
   </p>
   <h1 id="_idParaDest-65">
    <a id="_idTextAnchor067">
    </a>
    
     Testing the Navigation System with a project template
    
   </h1>
   <p>
    
     In this section, we will look at a project that uses the Unreal Engine Navigation System and do it with a
    
    <a id="_idIndexMarker146">
    </a>
    
     project template – using a pre-made project such as a template presents a valuable chance for you to acquire practical experience on a particular topic, saving you the time and effort required to build a project from the
    
    
     
      ground up.
     
    
   </p>
   <p>
    
     Once the project has been created, we will quickly analyze the nav mesh generation system and how the template handles the character movement
    
    
     
      at runtime.
     
    
   </p>
   <p>
    
     Here, you will
    
    <a id="_idIndexMarker147">
    </a>
    
     start by creating a game prototype by using the
    
    <strong class="bold">
     
      Top Down
     
    </strong>
    
     project, one of the templates available in the
    
    <strong class="bold">
     
      GAMES
     
    </strong>
    
     category of
    
    <strong class="bold">
     
      Unreal
     
    </strong>
    
     <strong class="bold">
      
       Project Browser
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-66">
    <a id="_idTextAnchor068">
    </a>
    
     Setting up the project
    
   </h2>
   <p>
    
     Once you are ready, you can fire up the Epic Games Launcher
    
    <a id="_idIndexMarker148">
    </a>
    
     and follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Select
     
     <strong class="bold">
      
       GAMES
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Top Down
      
     </strong>
     
      from the
     
     
      
       available templates.
      
     
    </li>
    <li>
     
      Set the project to
     
     <strong class="bold">
      
       Blueprint
      
     </strong>
     
      or
     
     <strong class="bold">
      
       C++
      
     </strong>
     
      depending on your
     
     
      
       personal preferences.
      
     
    </li>
    <li>
     
      Name your project – any name
     
     
      
       will do.
      
     
    </li>
    <li>
     
      Leave the other settings with their
     
     
      
       default values.
      
     
    </li>
    <li>
     
      Click the
     
     
      <strong class="bold">
       
        Create
       
      </strong>
     
     
      
       button.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 3.8 – Project setup" src="img/B31016_03_8.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.8 – Project setup
    
   </p>
   <p>
    
     Once the project has been created and opened, you are ready to
    
    
     
      analyze it.
     
    
   </p>
   <h2 id="_idParaDest-67">
    <a id="_idTextAnchor069">
    </a>
    
     Analyzing the nav mesh
    
   </h2>
   <p>
    
     We are now going to get a
    
    <a id="_idIndexMarker149">
    </a>
    
     brief tour of the generated level and of the actors that contribute to the nav
    
    
     
      mesh generation.
     
    
   </p>
   <p>
    
     In the
    
    <strong class="bold">
     
      Outliner
     
    </strong>
    
     view, you will notice that there is a folder named
    
    <strong class="source-inline">
     
      Navigation
     
    </strong>
    
     , including
    
    
     
      three actors:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       NavMesh
      
     </strong>
     
      <strong class="bold">
       
        Bounds Volume
       
      </strong>
     
    </li>
    <li>
     <strong class="bold">
      
       Recast
      
     </strong>
     
      <strong class="bold">
       
        Nav Mesh
       
      </strong>
     
    </li>
    <li>
     <strong class="bold">
      
       Nav
      
     </strong>
     
      <strong class="bold">
       
        Link Proxy
       
      </strong>
     
    </li>
   </ul>
   <p>
    
     Let’s analyze each element
    
    
     
      in detail.
     
    
   </p>
   <h3>
    
     Nav Mesh Bounds Volume
    
   </h3>
   <p>
    
     As you already know from the previous
    
    <a id="_idIndexMarker150">
    </a>
    
     sections in this chapter, the
    
    <strong class="bold">
     
      NavMeshBoundsVolume
     
    </strong>
    
     actor is responsible for defining the area where the nav mesh will be computed.
    
    
     By selecting it, you will notice that a yellow-edged area is shown, wrapping all the game levels, as shown in
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    
     <em class="italic">
      
       .9
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 3.9 – Nav Mesh Bounds Volume" src="img/B31016_03_9.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.9 – Nav Mesh Bounds Volume
    
   </p>
   <p>
    
     You cannot do much with this actor; just resize it and the nav mesh will
    
    
     
      be recomputed.
     
    
   </p>
   <h3>
    
     Recast Nav Mesh
    
   </h3>
   <p>
    
     The
    
    <strong class="bold">
     
      RecastNavMesh
     
    </strong>
    
     actor will take
    
    <a id="_idIndexMarker151">
    </a>
    
     care of the nav mesh generation; by default, it does not have a visible representation within the Unreal Engine Editor.
    
    
     However, if you press the
    
    <em class="italic">
     
      P
     
    </em>
    
     key on your keyboard, the nav mesh will become visible and accessible within the editor interface.
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    <em class="italic">
     
      .10
     
    </em>
    
     shows the level once this actor has been
    
    
     
      made visible:
     
    
   </p>
   <div><div><img alt="Figure 3.10 – Recast Nav Mesh" src="img/B31016_03_10.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.10 – Recast Nav Mesh
    
   </p>
   <p>
    
     In
    
    <a href="B31016_06.xhtml#_idTextAnchor116">
     
      <em class="italic">
       
        Chapter 6
       
      </em>
     
    </a>
    
     ,
    
    <em class="italic">
     
      Optimizing the Navigation System
     
    </em>
    
     , I will be presenting you some techniques on how to optimize mesh generation with this actor.
    
    
     For now, you can just check the
    
    <strong class="bold">
     
      Display
     
    </strong>
    
     category in the
    
    <strong class="bold">
     
      Details
     
    </strong>
    
     window; here, you will have access to a plethora of visualization utilities that will come in handy later in this book.
    
    
     As an example, in
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    <em class="italic">
     
      .11
     
    </em>
    
     , I am showing the
    
    <a id="_idIndexMarker152">
    </a>
    
     sections of the level – named
    
    <strong class="bold">
     
      tiles
     
    </strong>
    
     – along with their labels and the
    
    
     
      generated polygons:
     
    
   </p>
   <div><div><img alt="Figure 3.11 – Some display settings for the Recast Nav Mesh actor" src="img/B31016_03_11.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.11 – Some display settings for the Recast Nav Mesh actor
    
   </p>
   <p>
    
     You may have observed
    
    <a id="_idIndexMarker153">
    </a>
    
     that the blue cube actors on the level are not affecting the nav mesh in any way.
    
    
     This is because they have been configured not to impact the navigation; since they are movable objects, we do not intend for them to create non-navigable areas
    
    
     
      around them.
     
    
   </p>
   <p>
    
     As a simple test, in the
    
    <strong class="bold">
     
      Details
     
    </strong>
    
     panel, you can look for the
    
    <strong class="bold">
     
      Can Ever Affect Navigation
     
    </strong>
    
     property and enable it; the nav mesh will be immediately recomputed and the cube will carve a hole in it, as depicted in
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    
     <em class="italic">
      
       .12
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 3.12 – The blue cube actor carving the nav mesh" src="img/B31016_03_12.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.12 – The blue cube actor carving the nav mesh
    
   </p>
   <p>
    
     The aforementioned property states that the object will be an obstruction in the navigation area and that the generated hole will be a non-navigable area in
    
    
     
      the mesh.
     
    
   </p>
   <p>
    
     Please note that letting such a movable object carve the nav mesh may produce undesired results; by default, the nav mesh is static and cannot be altered at runtime.
    
    
     This implies that even if the object is moved, the non-navigable area will remain fixed and – though unseen – will hinder the player character from moving into or
    
    
     
      through it.
     
    
   </p>
   <h3>
    
     Nav Link Proxy
    
   </h3>
   <p>
    
     The last nav mesh entity in this
    
    <a id="_idIndexMarker154">
    </a>
    
     example is a
    
    <strong class="bold">
     
      NavLinkProxy
     
    </strong>
    
     actor that, in our level, will let the player character jump down from
    
    
     
      a platform.
     
    
   </p>
   <div><div><img alt="Figure 3.13 – The Nav Link Proxy in the level" src="img/B31016_03_13.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.13 – The Nav Link Proxy in the level
    
   </p>
   <p>
    
     Now that you comprehend how the nav mesh is structured, let’s examine the character controller to understand how the player character
    
    
     
      is maneuvered.
     
    
   </p>
   <h2 id="_idParaDest-68">
    <a id="_idTextAnchor070">
    </a>
    
     Analyzing the character controller
    
   </h2>
   <p>
    
     Depending on your choice in creating the
    
    <a id="_idIndexMarker155">
    </a>
    
     project – Blueprints or C++ – you will have two slightly different versions of the
    
    
     
      character controller.
     
    
   </p>
   <h3>
    
     The Blueprint character controller
    
   </h3>
   <p>
    
     The code for moving the controller
    
    <a id="_idIndexMarker156">
    </a>
    
     character is pretty straightforward and can be found in
    
    <strong class="source-inline">
     
      BP_TopDownController
     
    </strong>
    
     – located in the
    
    
     <strong class="source-inline">
      
       Content/TopDown/Blueprints
      
     </strong>
    
    
     
      folder.
     
    
   </p>
   <p>
    
     Once the Blueprint class is opened, locate the
    
    <strong class="source-inline">
     
      MoveTo
     
    </strong>
    
     function in the
    
    <strong class="bold">
     
      Functions
     
    </strong>
    
     tab and open it; you will find the
    
    <strong class="bold">
     
      Simple Move to Location
     
    </strong>
    
     node that is used to make the player character move through the
    
    
     
      nav mesh.
     
    
   </p>
   <div><div><img alt="Figure 3.14 – The MoveTo function" src="img/B31016_03_14.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.14 – The MoveTo function
    
   </p>
   <p>
    
     This is all you need to use to move your player character to a predefined location in
    
    
     
      the level.
     
    
   </p>
   <h3>
    
     The C++ character controller
    
   </h3>
   <p>
    
     The same logic can be found inside
    
    <a id="_idIndexMarker157">
    </a>
    
     a C++-generated project; just open the generated
    
    <strong class="source-inline">
     
      .cpp
     
    </strong>
    
     class for the player controller and look for the
    
    <strong class="source-inline">
     
      OnSetDestinationReleased()
     
    </strong>
    
     method; you will find this line
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
UAIBlueprintHelperLibrary::SimpleMoveToLocation(this, CachedDestination);</pre>
   <p>
    
     This helper function will start the navigation process for
    
    
     
      your agent.
     
    
   </p>
   <h2 id="_idParaDest-69">
    <a id="_idTextAnchor071">
    </a>
    
     Testing the project
    
   </h2>
   <p>
    
     Now that you know all the actors involved in this project, you can simply hit the
    
    <strong class="bold">
     
      Play
     
    </strong>
    
     button and start testing how the Navigation System works.
    
    
     In particular, you will notice that the character will move to the destination point by selecting the
    
    
     
      shortest path.
     
    
   </p>
   <p>
    
     Additionally, once on the raised platform on the left, it will be able to jump down thanks to the Nav Link Proxy that has been added at
    
    
     
      that location.
     
    
   </p>
   <h1 id="_idParaDest-70">
    <a id="_idTextAnchor072">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, I introduced you to the key components of the Unreal Engine Navigation System.
    
    
     We started by discussing the process of generating the nav mesh, which is essential for AI agents to navigate the environment.
    
    
     Then, I provided a brief explanation of how the pathfinding algorithm works, enabling AI characters to find their way efficiently.
    
    
     Lastly, I highlighted the benefits of using the
    
    <strong class="bold">
     
      Top Down
     
    </strong>
    
     project template, which effectively utilizes the
    
    
     
      Navigation System.
     
    
   </p>
   <p>
    
     By now, you should have a good understanding of the capabilities offered by the Unreal Engine AI Navigation System.
    
    
     I imagine you are eager to dive in and start coding on your keyboard, and that is exactly what we will be doing in the
    
    
     
      next chapter!
     
    
   </p>
  </div>
 </body></html>