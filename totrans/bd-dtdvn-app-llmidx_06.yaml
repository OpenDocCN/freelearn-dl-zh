- en: '<html:html><html:head><html:title>Indexing our PITS study materials – hands-on</html:title></html:head>
    <html:body><html:div class="epub-source"><html:h1 id="_idParaDest-129">Indexing
    our PITS study materials – hands-on</html:h1> <html:div id="_idContainer052">from
    llama_index.core import (     VectorStoreIndex, TreeIndex, load_index_from_storage)
    from llama_index.core import StorageContext from global_settings import INDEX_STORAGE
    from document_uploader import ingest_documents def build_indexes(nodes):     try:
            storage_context = StorageContext.from_defaults(             persist_dir=INDEX_STORAGE
            )         vector_index = load_index_from_storage(             storage_context,
    index_id="vector"         )         tree_index = load_index_from_storage(             storage_context,
    index_id="tree"         )         print("All indices loaded from storage.")     except
    Exception as e:         print(f"Error occurred while loading indices: {e}")         storage_context
    = StorageContext.from_defaults()         vector_index = VectorStoreIndex(             nodes,
    storage_context=storage_context         )         vector_index.set_index_id("vector")
            tree_index = TreeIndex(             nodes, storage_context=storage_context
            )         tree_index.set_index_id("tree")         storage_context.persist(
                persist_dir=INDEX_STORAGE         )         print("New indexes created
    and persisted.")     return vector_index, tree_index <html:p>With a solid understanding
    <html:a id="_idIndexMarker511"></html:a>of how indexing works in LlamaIndex, we’re
    now ready to implement the indexing logic in our <html:span class="No-Break">tutoring
    application.</html:span></html:p> <html:p>Let’s create the <html:code class="literal">index_builder.py</html:code>
    module. This module takes care of Index creation. In the current implementation,
    it creates two Indexes: a <html:code class="literal">VectorStoreIndex</html:code>
    and a <html:code class="literal">TreeIndex</html:code> . As you can see, this
    is a very basic implementation and there is definitely <html:a id="_idIndexMarker512"></html:a>room
    for improvement. Let’s handle the <html:span class="No-Break">imports first:</html:span></html:p>
    <html:p>Next, we’ll implement our Index <html:span class="No-Break">building function:</html:span></html:p>
    <html:p>We first check to see whether the Indexes have already been persisted
    to disk. If affirmative, then we leverage persistence to avoid the additional
    cost of <html:span class="No-Break">rebuilding them.</html:span></html:p> <html:p
    class="callout-heading">Note on: Notice the usage of index_id</html:p> <html:p
    class="callout">Because we have persisted <html:a id="_idIndexMarker513"></html:a>more
    than one Index in the same storage folder – <html:code class="literal">INDEX_STORAGE</html:code>
    – when using <html:code class="literal">load_index_from_storage</html:code> ,
    we need to specify their individual IDs so that LlamaIndex can identify the <html:span
    class="No-Break">correct Index.</html:span></html:p> <html:p>If we cannot find
    them in the <html:code class="literal">INDEX_STORAGE</html:code> folder, we proceed
    to build them from the nodes. We also set an ID for each Index using <html:code
    class="literal">set_index_id</html:code> so that we can load them correctly <html:a
    id="_idIndexMarker514"></html:a>in <html:span class="No-Break">future sessions:</html:span></html:p>
    <html:p>The <html:code class="literal">build_indexes</html:code> function returns
    the two Index objects that we’ll use later in <html:span class="No-Break">our
    application.</html:span></html:p> <html:p>That’s it for now. We’ll take <html:a
    id="_idIndexMarker515"></html:a>the next steps during <html:a><html:span class="No-Break"><html:em
    class="italic">Chapter 6</html:em></html:span></html:a> , <html:em class="italic">Querying
    Our Data, Part 1 –</html:em> <html:span class="No-Break"><html:em class="italic">Context
    Retrieval</html:em></html:span> <html:span class="No-Break">.</html:span></html:p>
    <html:a id="_idTextAnchor129"></html:a></html:div></html:div></html:body></html:html><html:html><html:head><html:title>Summary</html:title></html:head>
    <html:body><html:div class="epub-source"><html:h1 id="_idParaDest-130">Summary</html:h1>
    <html:div id="_idContainer052"><html:p>In this chapter, we explored various indexing
    strategies and architectures within LlamaIndex. Indexes provide essential capabilities
    for building performant <html:span class="No-Break">RAG systems.</html:span></html:p>
    <html:p>Throughout the chapter, we looked at the <html:code class="literal">VectorStoreIndex</html:code>
    , which is the most commonly used Index type. We also gained an understanding
    of embeddings, vector stores, similarity search, and storage contexts. These are
    key concepts related to <html:span class="No-Break">the</html:span> <html:span
    class="No-Break"><html:code class="literal">VectorStoreIndex</html:code></html:span>
    <html:span class="No-Break">.</html:span></html:p> <html:p>We also covered other
    Index types such as <html:code class="literal">SummaryIndex</html:code> for simple
    linear scans, <html:code class="literal">KeywordTableIndex</html:code> for keyword
    search, <html:code class="literal">TreeIndex</html:code> for hierarchical data,
    and <html:code class="literal">KnowledgeGraphIndex</html:code> for relationship-based
    queries. <html:code class="literal">ComposableGraph</html:code> was introduced
    as a tool for building multi-level Indexes, and cost estimation techniques were
    discussed together with <html:span class="No-Break">best practices.</html:span></html:p>
    <html:p>Overall, this chapter provided an overview of indexing capabilities in
    LlamaIndex, laying the foundation for building sophisticated and efficient <html:span
    class="No-Break">RAG applications.</html:span></html:p> <html:p>See you in <html:a><html:span
    class="No-Break"><html:em class="italic">Chapter 6</html:em></html:span></html:a>
    , where we’ll discuss methods for querying our data <html:span class="No-Break">in
    LlamaIndex.</html:span></html:p></html:div></html:div></html:body></html:html>
    <html:html><html:head><html:title>Part 3: Retrieving and Working with Indexed
    Data</html:title></html:head> <html:body><html:div class="epub-source"><html:h1
    id="_idParaDest-131" lang="en-US">Part 3: Retrieving and Working with Indexed
    Data</html:h1> <html:div id="_idContainer054"><html:p>This part progresses from
    exploring LlamaIndex’s querying capabilities within a RAG workflow, focusing on
    retrieval mechanisms, query mechanics, and advanced retrieval strategies, to refining
    these queries through post-processing techniques and integrating them into comprehensive
    query engines. It culminates in a practical examination of building chatbots and
    intelligent agents, covering various engine modes, agent architectures, and the
    implementation of conversational features, thereby equipping you with the knowledge
    to create dynamic, conversational <html:span class="No-Break">RAG interfaces.</html:span></html:p>
    <html:p>This part has the <html:span class="No-Break">following chapters:</html:span></html:p>
    <html:ul><html:li><html:a><html:em class="italic">Chapter 6</html:em></html:a>
    , <html:em class="italic">Querying Our Data, Part 1 – Context Retrieval</html:em></html:li>
    <html:li><html:a><html:em class="italic">Chapter 7</html:em></html:a> , <html:em
    class="italic">Querying Our Data, Part 2 – Postprocessing and Response Synthesis</html:em></html:li>
    <html:li><html:a><html:em class="italic">Chapter 8</html:em></html:a> , <html:em
    class="italic">Building Chatbots and Agents with LlamaIndex</html:em></html:li></html:ul></html:div></html:div></html:body></html:html>'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '<html:html><html:head><html:title>索引我们的PITS学习资料 – 实战</html:title></html:head>
    <html:body><html:div class="epub-source"><html:h1 id="_idParaDest-129">索引我们的PITS学习资料
    – 实战</html:h1> <html:div id="_idContainer052">from llama_index.core import ( VectorStoreIndex,
    TreeIndex, load_index_from_storage) from llama_index.core import StorageContext
    from global_settings import INDEX_STORAGE from document_uploader import ingest_documents
    def build_indexes(nodes): try storage_context = StorageContext.from_defaults(
    persist_dir=INDEX_STORAGE ) vector_index = load_index_from_storage( storage_context,
    index_id="vector" ) tree_index = load_index_from_storage( storage_context, index_id="tree"
    ) print("所有索引已从存储中加载.") except Exception as e: print(f"加载索引时发生错误：{e}") storage_context
    = StorageContext.from_defaults() vector_index = VectorStoreIndex( nodes, storage_context=storage_context
    ) vector_index.set_index_id("vector") tree_index = TreeIndex( nodes, storage_context=storage_context
    ) tree_index.set_index_id("tree") storage_context.persist( persist_dir=INDEX_STORAGE
    ) print("新索引已创建并持久化.") return vector_index, tree_index <html:p>在深入理解LlamaIndex中索引工作原理的基础上，我们现在准备在我们的<html:span
    class="No-Break">辅导应用程序</html:span>中实现索引逻辑。</html:p> <html:p>让我们创建<html:code class="literal">index_builder.py</html:code>模块。此模块负责索引创建。在当前实现中，它创建了两个索引：一个<html:code
    class="literal">VectorStoreIndex</html:code>和一个<html:code class="literal">TreeIndex</html:code>。如您所见，这是一个非常基本的实现，肯定有<html:a
    id="_idIndexMarker512"></html:a>改进的空间。让我们先处理<html:span class="No-Break">导入</html:span>：</html:p>
    <html:p>接下来，我们将实现我们的<html:span class="No-Break">索引构建函数</html:span>：</html:p> <html:p>我们首先检查索引是否已经持久化到磁盘。如果是肯定的，那么我们利用持久化来避免重建它们的额外成本<html:span
    class="No-Break">。</html:span></html:p> <html:p class="callout-heading">关于：注意index_id的使用</html:p>
    <html:p class="callout">因为我们已经在同一个存储文件夹<html:code class="literal">INDEX_STORAGE</html:code>中持久化了<html:a
    id="_idIndexMarker513"></html:a>多个索引，当使用<html:code class="literal">load_index_from_storage</html:code>时，我们需要指定它们的个别ID，以便LlamaIndex可以识别<html:span
    class="No-Break">正确的索引</html:span>。</html:p> <html:p>如果我们无法在<html:code class="literal">INDEX_STORAGE</html:code>文件夹中找到它们，我们就从节点中构建它们。我们还使用<html:code
    class="literal">set_index_id</html:code>为每个索引设置一个ID，以便我们可以在<html:a id="_idIndexMarker514"></html:a>未来的会话中<html:span
    class="No-Break">正确地加载</html:span>它们：</html:p> <html:p><html:code class="literal">build_indexes</html:code>函数返回我们将稍后在<html:span
    class="No-Break">我们的应用程序</html:span>中使用的两个索引对象。</html:p> <html:p>到此为止。我们将在<html:a
    id="_idIndexMarker515"></html:a>第6章中讨论下一步，第6章将讨论<html:em class="italic">查询我们的数据，第1部分
    –</html:em> <html:span class="No-Break"><html:em class="italic">上下文检索</html:em></html:span>
    <html:span class="No-Break">。</html:span></html:p> <html:a id="_idTextAnchor129"></html:a></html:div></html:div></html:body></html:html><html:html><html:head><html:title>总结</html:title></html:head>
    <html:body><html:div class="epub-source"><html:h1 id="_idParaDest-130">总结</html:h1>
    <html:div id="_idContainer052"><html:p>在本章中，我们探讨了LlamaIndex中的各种索引策略和架构。索引为构建高性能<html:span
    class="No-Break">RAG系统</html:span>提供了基本功能。</html:p> <html:p>在本章中，我们研究了<html:code
    class="literal">VectorStoreIndex</html:code>，这是最常用的索引类型。我们还了解了嵌入、向量存储、相似性搜索和存储上下文。这些都是与<html:span
    class="No-Break"><html:code class="literal">VectorStoreIndex</html:code></html:span>相关的关键概念<html:span
    class="No-Break">。</html:span></html:p> <html:p>我们还介绍了其他索引类型，如<html:code class="literal">SummaryIndex</html:code>用于简单线性扫描、<html:code
    class="literal">KeywordTableIndex</html:code>用于关键字搜索、<html:code class="literal">TreeIndex</html:code>用于层次数据、<html:code
    class="literal">KnowledgeGraphIndex</html:code>用于基于关系的查询。<html:code class="literal">ComposableGraph</html:code>被引入作为构建多层索引的工具，并讨论了成本估算技术和最佳实践。</html:p>
    <html:p>总的来说，本章概述了LlamaIndex的索引功能，为构建复杂和高效的<html:span class="No-Break">RAG应用程序</html:span>奠定了基础。</html:p>
    <html:p>我们将在<html:a><html:span class="No-Break"><html:em class="italic">第6章</html:em></html:span></html:a>中见到您，我们将讨论在LlamaIndex中查询我们的数据<html:span
    class="No-Break">的方法</html:span>。</html:p></html:div></html:div></html:body></html:html>
    <html:html><html:head><html:title>第3部分：检索和使用索引数据</html:title></html:head> <html:body><html:div
    class="epub-source"><html:h1 id="_idParaDest-131" lang="en-US">第3部分：检索和使用索引数据</html:h1>
    <html:div id="_idContainer054"><html:p>本部分从探索LlamaIndex在RAG工作流程中的查询功能开始，重点关注检索机制、查询机制和高级检索策略，然后通过后处理技术对这些查询进行优化，并将它们集成到综合查询引擎中。它最终通过构建聊天机器人和智能代理的实践考察，涵盖了各种引擎模式、代理架构和对话功能的实现，从而为您提供了创建动态、对话<html:span
    class="No-Break">RAG接口</html:span>的知识。</html:p> <html:p>本部分包含以下章节：</html:p> <html:ul><html:li><html:a><html:em
    class="italic">第6章</html:em></html:a>，<html:em class="italic">查询我们的数据，第1部分 – 上下文检索</html:em></html:li>
    <html:li><html:a><html:em class="italic">第7章</html:em></html:a>，<html:em class="italic">查询我们的数据，第2部分
    – 后处理和响应合成</html:em></html:li> <html:li><html:a><html:em class="italic">第8章</html:em></html:a>，<html:em
    class="italic">使用LlamaIndex构建聊天机器人和代理</html:em></html:li></html:ul></html:div></html:div></html:body></html:html>'
