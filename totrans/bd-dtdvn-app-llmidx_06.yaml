- en: '<html:html><html:head><html:title>Indexing our PITS study materials – hands-on</html:title></html:head>
    <html:body><html:div class="epub-source"><html:h1 id="_idParaDest-129">Indexing
    our PITS study materials – hands-on</html:h1> <html:div id="_idContainer052">from
    llama_index.core import (     VectorStoreIndex, TreeIndex, load_index_from_storage)
    from llama_index.core import StorageContext from global_settings import INDEX_STORAGE
    from document_uploader import ingest_documents def build_indexes(nodes):     try:
            storage_context = StorageContext.from_defaults(             persist_dir=INDEX_STORAGE
            )         vector_index = load_index_from_storage(             storage_context,
    index_id="vector"         )         tree_index = load_index_from_storage(             storage_context,
    index_id="tree"         )         print("All indices loaded from storage.")     except
    Exception as e:         print(f"Error occurred while loading indices: {e}")         storage_context
    = StorageContext.from_defaults()         vector_index = VectorStoreIndex(             nodes,
    storage_context=storage_context         )         vector_index.set_index_id("vector")
            tree_index = TreeIndex(             nodes, storage_context=storage_context
            )         tree_index.set_index_id("tree")         storage_context.persist(
                persist_dir=INDEX_STORAGE         )         print("New indexes created
    and persisted.")     return vector_index, tree_index <html:p>With a solid understanding
    <html:a id="_idIndexMarker511"></html:a>of how indexing works in LlamaIndex, we’re
    now ready to implement the indexing logic in our <html:span class="No-Break">tutoring
    application.</html:span></html:p> <html:p>Let’s create the <html:code class="literal">index_builder.py</html:code>
    module. This module takes care of Index creation. In the current implementation,
    it creates two Indexes: a <html:code class="literal">VectorStoreIndex</html:code>
    and a <html:code class="literal">TreeIndex</html:code> . As you can see, this
    is a very basic implementation and there is definitely <html:a id="_idIndexMarker512"></html:a>room
    for improvement. Let’s handle the <html:span class="No-Break">imports first:</html:span></html:p>
    <html:p>Next, we’ll implement our Index <html:span class="No-Break">building function:</html:span></html:p>
    <html:p>We first check to see whether the Indexes have already been persisted
    to disk. If affirmative, then we leverage persistence to avoid the additional
    cost of <html:span class="No-Break">rebuilding them.</html:span></html:p> <html:p
    class="callout-heading">Note on: Notice the usage of index_id</html:p> <html:p
    class="callout">Because we have persisted <html:a id="_idIndexMarker513"></html:a>more
    than one Index in the same storage folder – <html:code class="literal">INDEX_STORAGE</html:code>
    – when using <html:code class="literal">load_index_from_storage</html:code> ,
    we need to specify their individual IDs so that LlamaIndex can identify the <html:span
    class="No-Break">correct Index.</html:span></html:p> <html:p>If we cannot find
    them in the <html:code class="literal">INDEX_STORAGE</html:code> folder, we proceed
    to build them from the nodes. We also set an ID for each Index using <html:code
    class="literal">set_index_id</html:code> so that we can load them correctly <html:a
    id="_idIndexMarker514"></html:a>in <html:span class="No-Break">future sessions:</html:span></html:p>
    <html:p>The <html:code class="literal">build_indexes</html:code> function returns
    the two Index objects that we’ll use later in <html:span class="No-Break">our
    application.</html:span></html:p> <html:p>That’s it for now. We’ll take <html:a
    id="_idIndexMarker515"></html:a>the next steps during <html:a><html:span class="No-Break"><html:em
    class="italic">Chapter 6</html:em></html:span></html:a> , <html:em class="italic">Querying
    Our Data, Part 1 –</html:em> <html:span class="No-Break"><html:em class="italic">Context
    Retrieval</html:em></html:span> <html:span class="No-Break">.</html:span></html:p>
    <html:a id="_idTextAnchor129"></html:a></html:div></html:div></html:body></html:html><html:html><html:head><html:title>Summary</html:title></html:head>
    <html:body><html:div class="epub-source"><html:h1 id="_idParaDest-130">Summary</html:h1>
    <html:div id="_idContainer052"><html:p>In this chapter, we explored various indexing
    strategies and architectures within LlamaIndex. Indexes provide essential capabilities
    for building performant <html:span class="No-Break">RAG systems.</html:span></html:p>
    <html:p>Throughout the chapter, we looked at the <html:code class="literal">VectorStoreIndex</html:code>
    , which is the most commonly used Index type. We also gained an understanding
    of embeddings, vector stores, similarity search, and storage contexts. These are
    key concepts related to <html:span class="No-Break">the</html:span> <html:span
    class="No-Break"><html:code class="literal">VectorStoreIndex</html:code></html:span>
    <html:span class="No-Break">.</html:span></html:p> <html:p>We also covered other
    Index types such as <html:code class="literal">SummaryIndex</html:code> for simple
    linear scans, <html:code class="literal">KeywordTableIndex</html:code> for keyword
    search, <html:code class="literal">TreeIndex</html:code> for hierarchical data,
    and <html:code class="literal">KnowledgeGraphIndex</html:code> for relationship-based
    queries. <html:code class="literal">ComposableGraph</html:code> was introduced
    as a tool for building multi-level Indexes, and cost estimation techniques were
    discussed together with <html:span class="No-Break">best practices.</html:span></html:p>
    <html:p>Overall, this chapter provided an overview of indexing capabilities in
    LlamaIndex, laying the foundation for building sophisticated and efficient <html:span
    class="No-Break">RAG applications.</html:span></html:p> <html:p>See you in <html:a><html:span
    class="No-Break"><html:em class="italic">Chapter 6</html:em></html:span></html:a>
    , where we’ll discuss methods for querying our data <html:span class="No-Break">in
    LlamaIndex.</html:span></html:p></html:div></html:div></html:body></html:html>
    <html:html><html:head><html:title>Part 3: Retrieving and Working with Indexed
    Data</html:title></html:head> <html:body><html:div class="epub-source"><html:h1
    id="_idParaDest-131" lang="en-US">Part 3: Retrieving and Working with Indexed
    Data</html:h1> <html:div id="_idContainer054"><html:p>This part progresses from
    exploring LlamaIndex’s querying capabilities within a RAG workflow, focusing on
    retrieval mechanisms, query mechanics, and advanced retrieval strategies, to refining
    these queries through post-processing techniques and integrating them into comprehensive
    query engines. It culminates in a practical examination of building chatbots and
    intelligent agents, covering various engine modes, agent architectures, and the
    implementation of conversational features, thereby equipping you with the knowledge
    to create dynamic, conversational <html:span class="No-Break">RAG interfaces.</html:span></html:p>
    <html:p>This part has the <html:span class="No-Break">following chapters:</html:span></html:p>
    <html:ul><html:li><html:a><html:em class="italic">Chapter 6</html:em></html:a>
    , <html:em class="italic">Querying Our Data, Part 1 – Context Retrieval</html:em></html:li>
    <html:li><html:a><html:em class="italic">Chapter 7</html:em></html:a> , <html:em
    class="italic">Querying Our Data, Part 2 – Postprocessing and Response Synthesis</html:em></html:li>
    <html:li><html:a><html:em class="italic">Chapter 8</html:em></html:a> , <html:em
    class="italic">Building Chatbots and Agents with LlamaIndex</html:em></html:li></html:ul></html:div></html:div></html:body></html:html>'
  prefs: []
  type: TYPE_NORMAL
