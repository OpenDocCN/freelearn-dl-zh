["```py\nOPEN // the set of nodes to be evaluated \nCLOSED // the set of nodes already evaluated \n\nAdd the start node to OPEN \n\nloop \n   current = node in OPEN with the lowest f_cost \n   remove current from OPEN \n   add current to CLOSED \n\n   if current is the target node // path has been found \n         return \n\n   foreach neighbor of the current node \n         if neighbor is not traversable or neighbor is in CLOSED \n               skip to the next neighbor \n\nif new path to neighbor is shorter OR neighbor is not in OPEN \n   set f_cost of neighbor \n   set parent of neighbor to current \n   if neighbor is not in OPEN \n         add neighbor to OPEN \n```", "```py\nAdd the start node to OPEN \n```", "```py\nloop \n   current = node in OPEN with the lowest f_cost \n   remove current from OPEN \n   add current to CLOSED \n```", "```py\nif current is the target node // path has been found \n         return \n```", "```py\nforeach neighbor of the current node \n         if neighbor is not traversable or neighbor is in CLOSED \n               skip to the next neighbor \n```", "```py\nif new path to neighbor is shorter OR neighbor is not in OPEN \n   set f_cost of neighbor \n   set parent of neighbor to current \n   if neighbor is not in OPEN \n         add neighbor to OPEN \n```", "```py\npublic bool walkable;\n public Vector3 worldPosition; public Node(bool _walkable, Vector3\n         _worldPos, int _gridX, int _gridY) {\n         walkable = _walkable;\n         worldPosition = _worldPos; \n```", "```py\n Node[,] grid;  \n public LayerMask unwalkableMask;\n public Vector2 gridWorldSize;\n publicfloatnodeRadius;\n void OnDrawGizmos() \n {\n         Gizmos.DrawWireCube(transform.position,new\n    Vector3(gridWorldSize.x,1,gridWorldSize.y));  \n } \n```", "```py\n     public LayerMask unwalkableMask;\n     public Vector2 gridWorldSize;\n     public float nodeRadius;\n     Node[,] grid;\n\n     float nodeDiameter;\n     int gridSizeX, gridSizeY;\n\n     void Start() {\n         nodeDiameter = nodeRadius*2;\n         gridSizeX = Mathf.RoundToInt(gridWorldSize.x/nodeDiameter);\n         gridSizeY = Mathf.RoundToInt(gridWorldSize.y/nodeDiameter);\n         CreateGrid();\n     }\n\n     void CreateGrid(){\n         grid = new Node[gridSizeX,gridSizeY];\n         Vector3 worldBottomLeft = transform.position - Vector3.right *\n     gridWorldSize.x/2 - Vector3.forward * gridWorldSize.y/2;\n     } \n```", "```py\n public LayerMask unwalkableMask;\n public Vector2 gridWorldSize;\n public float nodeRadius;\n Node[,] grid;\n\n float nodeDiameter;\n int gridSizeX, gridSizeY;\n\n void Start(){\n         nodeDiameter = nodeRadius*2;\n         gridSizeX = Mathf.RoundToInt(gridWorldSize.x/nodeDiameter);\n         gridSizeY = Mathf.RoundToInt(gridWorldSize.y/nodeDiameter);\n         CreateGrid();\n } \n\n void CreateGrid() \n {\n         grid = new Node[gridSizeX,gridSizeY];\n         Vector3 worldBottomLeft = transform.position - Vector3.right *\n         gridWorldSize.x/2 - Vector3.forward * gridWorldSize.y/2;\n\n         for (int x = 0; x < gridSizeX; x ++) {\n             for (int y = 0; y < gridSizeY; y ++) {\n                 Vector3 worldPoint = worldBottomLeft + Vector3.right *\n                 (x * nodeDiameter + nodeRadius) + Vector3.forward * (y\n                 * nodeDiameter + nodeRadius);\n                 bool walkable = !(Physics.CheckSphere(worldPoint,\n                                   nodeRadius,unwalkableMask));\n                 grid[x,y] = new Node(walkable,worldPoint);\n             }\n         } \n }  \n```", "```py\n void OnDrawGizmos() {\n         Gizmos.DrawWireCube(transform.position,new\n         Vector3(gridWorldSize.x,1,gridWorldSize.y));\n\n         if (grid != null) {\n             foreach (Node n in grid) {\n                 Gizmos.color = (n.walkable)?Color.white:Color.red;\n                 Gizmos.DrawCube(n.worldPosition, Vector3.one *\n                 (nodeDiameter-.1f));\n             }\n         }\n } \n```", "```py\n public LayerMask unwalkableMask;\n public Vector2 gridWorldSize;\n public float nodeRadius;\n Node[,] grid;\n\n float nodeDiameter;\n int gridSizeX, gridSizeY;\n\n void Start(){\n         nodeDiameter = nodeRadius*2;\n         gridSizeX = Mathf.RoundToInt(gridWorldSize.x/nodeDiameter);\n         gridSizeY = Mathf.RoundToInt(gridWorldSize.y/nodeDiameter);\n         CreateGrid();\n } \n\n void CreateGrid() \n {\n         grid = new Node[gridSizeX,gridSizeY];\n         Vector3 worldBottomLeft = transform.position - Vector3.right *\n               gridWorldSize.x/2 - Vector3.forward * gridWorldSize.y/2;\n\n         for (int x = 0; x < gridSizeX; x ++) {\n             for (int y = 0; y < gridSizeY; y ++) {\n                 Vector3 worldPoint = worldBottomLeft + Vector3.right *\n                 (x * nodeDiameter + nodeRadius) + Vector3.forward * (y\n                 * nodeDiameter + nodeRadius);\n                 bool walkable = !(Physics.CheckSphere(worldPoint,\n                                   nodeRadius,unwalkableMask));\n                 grid[x,y] = new Node(walkable,worldPoint);\n             }\n         } \n }  \n public Node NodeFromWorldPoint(Vector3 worldPosition) {\n         float percentX = (worldPosition.x + gridWorldSize.x/2) /\n         gridWorldSize.x;\n         float percentY = (worldPosition.z + gridWorldSize.y/2) /\n         gridWorldSize.y;\n         percentX = Mathf.Clamp01(percentX);\n         percentY = Mathf.Clamp01(percentY);\n\n         int x = Mathf.RoundToInt((gridSizeX-1) * percentX);\n         int y = Mathf.RoundToInt((gridSizeY-1) * percentY);\n         return grid[x,y];\n     } void OnDrawGizmos() {\n         Gizmos.DrawWireCube(transform.position,new\n         Vector3(gridWorldSize.x,1,gridWorldSize.y));\n\n         if (grid != null) {\n             foreach (Node n in grid) {\n                 Gizmos.color = (n.walkable)?Color.white:Color.red;\n                 Gizmos.DrawCube(n.worldPosition, Vector3.one *\n                (nodeDiameter-.1f));\n             }\n         }\n     } \n```", "```py\nGrid grid;\n\nvoid Awake(){\n      requestManager = GetComponent<PathRequestManager>();\n      grid = GetComponent<Grid>();\n } \n\nvoid FindPath(Vector3 startPos, Vector3 targetPos) \n{ \nNode startNode = grid.NodeFromWorldPoint(startPos);\n Node targetNode = grid.NodeFromWorldPoint(targetPos);  \n} \n\n```", "```py\nvoid FindPath(Vector3 startPos, Vector3 targetPos) \n{ \nNode startNode = grid.NodeFromWorldPoint(startPos); \nNode targetNode = grid.NodeFromWorldPoint(targetPos); \n\nList<Node> openSet = new List<Node>(); \nHashSet<Node> closedSet = new HashSet<Node>(); \nopenSet.Add(startNode); \n} \n```", "```py\npublic bool walkable; \npublic Vector3 worldPosition; \n\npublic int gCost; \npublic int hCost; \npublic Node parent; \n\npublic Node(bool _walkable, Vector3 _worldPos, int _gridX, int _gridY) \n{ \n         walkable = _walkable; \n         worldPosition = _worldPos; \n} \n\npublic int fCost \n{ \n         get { \n               return gCost + hCost; \n         } \n} \n```", "```py\nGrid grid; \n\nvoid Awake() \n{ \n         grid = GetComponent<Grid> (); \n} \n\nvoid FindPath(Vector3 startPos, Vector3 targetPos) \n{ \n   Node startNode = grid.NodeFromWorldPoint(startPos); \n   Node targetNode = grid.NodeFromWorldPoint(targetPos); \n\n   List<Node> openSet = new List<Node>(); \n   HashSet<Node> closedSet = new HashSet<Node>(); \n   openSet.Add(startNode); \n\n   while (openSet.Count > 0) \n{ \n         Node node = openSet[0]; \n         for (int i = 1; i < openSet.Count; i ++) { \n         if (openSet[i].fCost < node.fCost || openSet[i].fCost ==\n         node.fCost) { \n         if (openSet[i].hCost < node.hCost) \n         node = openSet[i]; \n   } \n} \n```", "```py\nGrid grid; \nvoid Awake() \n{ \n         grid = GetComponent<Grid> (); \n} \n\nvoid FindPath(Vector3 startPos, Vector3 targetPos) \n{ \n   Node startNode = grid.NodeFromWorldPoint(startPos); \n   Node targetNode = grid.NodeFromWorldPoint(targetPos); \n\n   List<Node> openSet = new List<Node>(); \n   HashSet<Node> closedSet = new HashSet<Node>(); \n   openSet.Add(startNode); \n\n   while (openSet.Count > 0) \n{ \n         Node node = openSet[0]; \n         for (int i = 1; i < openSet.Count; i ++) \n{ \n         if (openSet[i].fCost < node.fCost || openSet[i].fCost ==\n         node.fCost){ \n               if (openSet[i].hCost < node.hCost) \n         node = openSet[i]; \n           } \n         } \n\n         openSet.Remove(node); \n         closedSet.Add(node); \n\n         if (node == targetNode) { \n               RetracePath(startNode,targetNode); \n               return; \n         } \n```", "```py\npublic List<Node> GetNeighbors(Node node) \n{ \n   List<Node> neighbors = new List<Node>(); \n\n   for (int x = -1; x <= 1; x++) { \n         for (int y = -1; y <= 1; y++) { \n               if (x == 0 && y == 0) \n                     continue; \n\n               int checkX = node.gridX + x; \n               int checkY = node.gridY + y; \n\n               if (checkX >= 0 && checkX < gridSizeX && checkY >= 0 &&\n               checkY < gridSizeY) { \n                     neighbors.Add(grid[checkX,checkY]); \n                     } \n               } \n         } \n   } \n```", "```py\npublic bool walkable; \npublic Vector3 worldPosition; \npublic int gridX; \npublic int gridY; \n\npublic int gCost; \npublic int hCost; \npublic Node parent; \n\npublic Node(bool _walkable, Vector3 _worldPos, int _gridX, int _gridY) \n{ \n   walkable = _walkable; \n   worldPosition = _worldPos; \n   gridX = _gridX; \n   gridY = _gridY; \n} \n\npublic int fCost \n{ \n   get \n{ \n         return gCost + hCost; \n   } \n} \n\n```", "```py\nforeach (Node neighbor in grid.GetNeighbors(node)) { \nif (!neighbor.walkable || closedSet.Contains(neighbor)) \n{ \n               continue; \n} \n} \n```", "```py\nint GetDistance(Node nodeA, Node nodeB) \n{ \n   int dstX = Mathf.Abs(nodeA.gridX - nodeB.gridX); \n   int dstY = Mathf.Abs(nodeA.gridY - nodeB.gridY); \n\n   if (dstX > dstY) \n         return 14*dstY + 10* (dstX-dstY); \n   return 14*dstX + 10 * (dstY-dstX); \n} \n```", "```py\nOPEN // the set of nodes to be evaluated \nCLOSED // the set of nodes already evaluated \n\nAdd the start node to OPEN \n\nloop \n   current = node in OPEN with the lowest f_cost \n   remove current from OPEN \n   add current to CLOSED \n\n   if current is the target node // path has been found \n         return \n\n   foreach neighbor of the current node \n         if neighbor is not traversable or neighbor is in CLOSED \n               skip to the next neighbor \n\nif new path to neighbor is shorter OR neighbor is not in OPEN \n   set f_cost of neighbor \n   set parent of neighbor to current \n   if neighbor is not in OPEN \n         add neighbor to OPEN \n```", "```py\nforeach (Node neighbor in grid.GetNeighbors(node)) \n{ \n   if (!neighbor.walkable || closedSet.Contains(neighbor)) { \n         continue; \n   } \n\n   int newCostToNeighbor = node.gCost + GetDistance(node, neighbor); \n   if (newCostToNeighbor < neighbor.gCost ||\n   !openSet.Contains(neighbor)) { \n         neighbor.gCost = newCostToNeighbor; \n         neighbor.hCost = GetDistance(neighbor, targetNode); \n         neighbor.parent = node; \n   } \n```", "```py\nvoid RetracePath(Node startNode, Node endNode) { \n         List<Node> path = new List<Node>(); \n         Node currentNode = endNode; \n\n         while (currentNode != startNode) { \n               path.Add(currentNode); \n               currentNode = currentNode.parent; \n         } \n         path.Reverse(); \n\n         grid.path = path; \n} \n```", "```py\npublic List<Node> path; \nvoid OnDrawGizmos() \n{ \nGizmos.DrawWireCube(transform.position,new Vector3(gridWorldSize.x,1,gridWorldSize.y)); \n\n         if (grid != null) { \n               foreach (Node n in grid) { \n                     Gizmos.color = (n.walkable)?Color.white:Color.red; \n                     if (path != null) \n                           if (path.Contains(n)) \n                                 Gizmos.color = Color.black; \n                     Gizmos.DrawCube(n.worldPosition, Vector3.one * (nodeDiameter-.1f)); \n               } \n   } \n} \n```", "```py\npublic Transform seeker, target; \n\nGrid grid; \n\nvoid Awake() \n{ \n   grid = GetComponent<Grid> (); \n} \n\nvoid Update() \n{ \n   FindPath (seeker.position, target.position); \n} \n```"]