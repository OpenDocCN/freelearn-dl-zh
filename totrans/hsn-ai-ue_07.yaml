- en: Extending Behavior Trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Empowering a tree with more leaves and branches will make it unstoppable.*'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will understand how to extend *Behavior Trees* by implementing
    our custom **Tasks**, **Decorators**, and **Services**.
  prefs: []
  type: TYPE_NORMAL
- en: Since in chapters 8, 9, and 10 we are going to create a concrete example of
    a *Behavior Tree* from scratch and create custom *Tasks*, *Decorators*, and *Services*,
    you can look at this chapter as a quick theoretical introduction to those chapters
    in order to give you a ground base for extending *Behavior Trees*. Thus, this
    chapter might be super fluid and repetitive, but it will teach you about a great
    tool, which we will refine later in this book in a more playful way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create a ***Task***, both in *Blueprint and C++*, to make our AI agent
    capable of executing custom actions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a ***Decorator***, both in *Blueprint and C++*, to create specific
    conditions that we can enter in certain sub-branches of the *Behavior Tree*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a ***Service***, both in *Blueprint and C++*, to continuously update
    the data in our *Blackboard* for the *Behavior Tree*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create *Composite nodes*, *new types of nodes*, or even *new trees*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's dive in!
  prefs: []
  type: TYPE_NORMAL
- en: A quick recap on Behavior Trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here is a quick recap on **Behaviors Trees** to refresh you.
  prefs: []
  type: TYPE_NORMAL
- en: A **Behavior Tree** is a structure for decision-making which uses a *Blackboard*
    as its memory. In particular, the flow starts from a special node called the **Root**,
    all the way down to the leaves, which are called Tasks. A **Task** is a single
    action that the AI can take/perform.
  prefs: []
  type: TYPE_NORMAL
- en: Then, all the nodes that are non-leaves (or the root) are **Composite**. A composite
    node chooses which one of the children to execute. The two main **Composite**
    nodes are ***Sequence*** (which tries to execute all the sequences of its children
    in order, and if they succeed, it reports a success back, otherwise it reports
    a fail) and ***Selector*** (which tries each child until it finds one that succeeds
    and reports a success or all of them fail and it reports a fail).
  prefs: []
  type: TYPE_NORMAL
- en: Both **Composite** and **Tasks** nodes can use **Decorators** (which impose
    conditions that must be true so that you can choose that node) or **Services** on
    top (a continuously running piece of code, e.g. what's used to set Blackboard
    values).
  prefs: []
  type: TYPE_NORMAL
- en: If you still have some doubts, please revise [Chapter 2](00781951-41e3-4e33-8512-052e7aecfd15.xhtml),
    *Behavior Trees and Blackboards*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deep diving into the concepts we looked at earlier, back in [Chapter 2](00781951-41e3-4e33-8512-052e7aecfd15.xhtml),
    *Behavior Trees and Blackboards*, a ***Task*** is a single action that our AI
    Agent can perform. Some examples include walking to a specific location, performing/running
    an EQS, locating something, chasing the players, etc. All of these actions can
    either fail or succeed. The final result of a task is then carried back on the
    *Behavior Tree*, with rules we have seen for Selectors and Sequences.
  prefs: []
  type: TYPE_NORMAL
- en: A task doesn't necessarily have to be executed in a frame, but it can be extended
    indefinitely. In fact, a Task is not finished until it reports with either a *Failure*
    or a *Success*. However, they can be interrupted/aborted by external nodes, such
    as a *Decorator*.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a Task, regardless of whether this is done in Blueprint or C++,
    you will need to override some functions. Since Blueprint is easier, and share
    the same concepts that we use in C++, we will first look at how the system works
    in Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Blueprint Task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a ***Blueprint Task***, we have a few options available to us. The
    easiest one is in the *Behavior Tree Editor*, in which we press the "***New Task***"
    button in the top bar, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da0c1058-4cb4-4104-bba6-7b559850a1ff.png)'
  prefs: []
  type: TYPE_IMG
- en: However, you will need to manually rename the file and place it in the folder
    that you wish it to be in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to create a Task is to create a new Blueprint that inherits from
    ***BTTask_BlueprintBase***, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4aceb3ad-af67-4eb2-8b2b-209c41de92d1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The convention is to prefix the Tasks with "*BBTask_*" (which stands for *Behavior
    Tree Task*). For instance, we could call our Task something like *BTTask_BPMyFirstTask*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bb229e7-b40e-49e8-ad4a-fab724aaf32f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once a *Blueprint Task* has been created, there are three type functions that
    we can override:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f1ba58f-6c0f-40c9-86d1-087b3541d714.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Receive Execute**: This is called when the *Task* starts, and here you should
    implement all the initialization for your task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receive Tick**: This is called every time the Task ticks, and so you can
    use it to continuously do something. However, since there might be many agents
    executing many *Behaviors Trees*, it would be advisable to keep this Tick function
    as short as possible or not implement it at all (for performance reasons), and
    use either timers or delegates to handle the task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receive Abort**: This is called every time that the Task is executing, but
    the *Behavior Tree* requested to abort it. You need to use this function to clean
    up your tasks (e.g. restore some Blackboard values).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Blueprint, these three functions exist in two forms, ***AI*** and ***non-AI***,
    and are also known as being *generic* (e.g. *Receive Execute* and *Receive Execute
    AI*). There is not much difference between them. If only one is implemented (as
    a suggestion, implement the AI version to keep your project consistent), that
    is the function that is called. Otherwise, the most convenient will be called,
    which means that the AI version is called when the Pawn is possessed by an *AI
    Controller*, and the *non-AI* version is called in all the other cases. Of course,
    most of your cases would be that the *Behavior Tree* is running on top of an *AI
    Controller*, so the *non-AI* version is for very specific and rarer cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, the system has no way of understanding when a *Task* has finished its
    execution or has finished to clean up after an abort. For this reason, there are
    two functions you will need to call:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3343947a-a17c-4fb1-b240-9f88833757df.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Finish Execute**: This will indicate that the *Task* has finished its execution.
    It has a Boolean parameter to indicate whether the *Task* has ***succeeded***
    (***true*** value) or ***failed*** (***false*** value).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Finish Abort**: This will indicate that the *Task* has finished to abort.
    It has no parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note that if you don't call these two functions, the task will hang there
    forever, which is not a desired behavior. Although it would be advisable to call
    the Finish Abort function at the end of the *Receive Abort* event, there are cases
    in which you will need more than one frame to clean up. In this case, you can
    call the *Finish Abort* somewhere else (e.g. in a delegate).
  prefs: []
  type: TYPE_NORMAL
- en: There are also other ways to finish executing a Task, for example, by using
    AI Messages, but we will not cover them in this book.
  prefs: []
  type: TYPE_NORMAL
- en: This is all you need to know to create a *Task*. You just create the graph that
    you want, and remember to call the *Finish Execute* node when you are done (either
    with a *Success* or a *Fail*). We will look at a concrete example of creating
    a new Task in the following three chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Task in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of creating a ***Task in C++*** share the same concepts as its Blueprint
    counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: 'First all of, to create a new C++ Task, we need to create a C++ class that
    inherits from ***BTTaskNode***, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e6ad68c-8037-42f2-b501-8840f3db93e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Just like for a Blueprint Task, the convention is to prefix the *Task* with
    "***BTTask_***" (*Behavior Tree Task*). Therefore, we could name our Task something
    like "*BTTask_MyFirstTask*":'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98a53e83-5688-461c-8c6c-c6654cf30a38.png)'
  prefs: []
  type: TYPE_IMG
- en: Once you have created the *Task*, you need to override some functions, which
    have very similar functionalities to the ones in Blueprint. However, there are
    some differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the main differences is how to report that the Task has finished its
    execution (or has finished to abort). For these cases, there is a special enum
    structure called `EBTNodeResult`. It needs to be returned by a function so that
    the *Behavior Tree* "*knows*" if it needs to keep calling the Task or not. This
    structure can have four values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Succeeded**: The Tasks finishes with a success'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Failed**: The Tasks finishes with a failure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aborted**: The Task has aborted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**InProgress**: The Task hasn''t finished yet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another difference lies in the fact that the twin of the Blueprint *Receive
    Execute* has to finish and thus it needs to return a `EBTNodeResult` structure
    to communicate and state whether the task has finished or whether it needs more
    than one frame. If so, other functions are then called, as we will see.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, in C++, there are other special concepts and structures that you can
    use that in Blueprint you cannot. For example, you have access to `NodeMemory`,
    which holds a specific memory for the Task that has been executed. For the correct
    use of this structure, watch the engine source code, and in particular, the file
    that's suggested at the end of this section.
  prefs: []
  type: TYPE_NORMAL
- en: The last difference is that there are not the *AI* and the *non-AI* (G*eneric*)
    versions of the functions. You will have to determine by yourself if you have
    an AI controller and what to do (if you do anything).
  prefs: []
  type: TYPE_NORMAL
- en: 'The functions to are as follows (this has been taken directly from the source
    code of the engine, with the two most important functions in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there's quite a lot of code, and it might be a bit confusing
    at first. However, if you have understood Blueprint well, making the jump to understand
    the C++ functions should be much easier. For instance, the `ExecuteTask()` function
    starts the execution of the task, but it doesn't complete it if it returns that
    the Task is still in progress.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a comment from the Engine Source code, which might help clarify this
    a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The two best ways that I know of to get a better feeling of how to create a
    C++ Task is to either create one yourself, or read the source code of other Tasks.
    For instance, you can read the code in the `BTTask_MoveTo.cpp` file within the
    engine source for a complete example on how to create a C++ Task. Don't be discouraged,
    because using C++ is awesome!
  prefs: []
  type: TYPE_NORMAL
- en: In any case, we will go through the process of creating a C++ Task from scratch
    in the following three chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recalling from [Chapter 2](00781951-41e3-4e33-8512-052e7aecfd15.xhtml)*, Behavior
    Trees and Blackboards*, a ***Decorator*** is a conditional node (which can also
    be seen as a gate) that controls the execution flow of the sub-branch that it
    is attached to (if the execution would enter in the sub-branch in the first place).
  prefs: []
  type: TYPE_NORMAL
- en: In a similar fashion on how we *extended/created* a *Task*, we can *extend/create*
    a ***Decorator***. Once again, we will first dive into how to do it in Blueprint,
    and then move on to how to extend it in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Decorator in Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a ***Blueprint ******Decorator***, like we did for *Tasks*, you can
    press the "***New Decorator***" button in the top bar of the *Behavior Tree Editor*,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95acded1-f9f6-4e78-bf7e-a1091c192aab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, you can generate the *Blueprint* class that inherits from ***BTDecorator_BlueprintBase***,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3224587e-daa9-4311-ae3b-4200c68086e5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In any case, the naming convention is to prefix the *Decorator* with "***BTDecorator_***"
    (which stands for *Behavior Tree Decorator*). For instance, we can call our class
    something like *BTDecorator_BPMyFirstDecorator*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fbc9a933-225f-40c2-96f5-6631c0540466.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As for Tasks, all the *overridable* functions come in two flavors: *AI* and
    *non-AI*. The concept is exactly the same. If only one of them is implemented
    (to keep your project consistent, it is advisable to override the AI version),
    then that function is called. If both are implemented, the *AI* is called when
    the Pawn is possessed by the AI Controller, and the *non-AI* function instead
    in all the other cases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the six functions that a *Decorator* can extend:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f8880f6-c133-447a-9c0e-bd6b2a55df49.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Perform Condition Check**: This is the most important function and the only
    one you might need to override (if you don''t have dynamic things to handle).
    It has a return value of a bool, which indicates whether the conditional check
    has succeeded or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receive Execution Start**: This is called when the execution of the underlying
    node (either a Composite or a Task) starts. Use this to initialize the decorator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receive Execution Finish**: This is called when the execution of the underlying
    node (either a Composite or a Task) is finished. Use this to clean up the decorator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receive Tick**: This is the Tick function, in case you need to continuously
    update something. Performance-wise, is not advisable to use it for heavy operation,
    but it''s even better if it''s not used at all (e.g. use timers or delegates).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receive Observer Activated**: As the name suggests, it is called when the
    Observer is activated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receive Observer Deactivated**: As the name suggests, it is called when the
    Observer is deactivated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, *Decorators* are pretty easy (at least in Blueprint); mainly,
    you only need to *override/implement* the *Perform Condition Check* function,
    which returns a boolean value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/568ad0bc-c704-447c-a3d8-2e978eac9f11.png)'
  prefs: []
  type: TYPE_IMG
- en: In any case, we will look at a concrete example of creating a *Blueprint Decorator*
    from scratch in the following three chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Decorator in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a very similar fashion to how we extended a *Task* in C++, you can extend
    a ***Decorator in C++*** as well. The base class to inherit from is ***BTDecorator***,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3effa149-b0b5-4253-8507-dcacdcae57a0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The convention, as usual, is to prefix the *Decorator* with "***BTDecorator_***"
    (*Behavior Tree Decorator*). A possible name for our *Decorator* could be "*BTDecorator_MyFirstDecorator*":'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d68be21-df09-4423-83c8-889b37ec5a3b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Diving directly into C++, these are the overridable functions, as taken from
    the Engine Source code (there are quite a lot):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, in the Engine Source code, we can find the following comment, which
    explains a couple of implementation choices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, we don't have the time to go through all of them in detail, but
    most of them are very intuitive, and so it shouldn't be hard for you to understand
    their meaning. In any case, we will look at a concrete example of how to create
    a ***C++ Decorator*** from scratch (and we will be using many of these functions)
    in the next three chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recalling from [Chapter 2](00781951-41e3-4e33-8512-052e7aecfd15.xhtml)*, Behavior
    Trees and Blackboards*, a ***Service*** is a node that runs constantly if attached
    to one of the parents of the sub-branch. The main use of this node is to update
    the data in the *Blackboard* for the *Behavior Tree*, and it is among the nodes
    that you will need to create since they are very specific to your Gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar fashion to how we extended both Tasks and *Decorators*, we can
    also *extend/create* ***Services*** as well. We will go through how to implement
    the extension in Blueprint first, and then understand how to do it in C++ as well.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Service in Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like you did for *Tasks* and *Decorators*, you can create a new ***Blueprint
    Service*** by pressing the ***New Service*** button on the top bar of the *Behavior
    Tree Editor*, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/177b1552-524f-4249-98d7-bf5679bb6163.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, you can generate the *Blueprint* class that inherits from ***BTService_BlueprintBase***,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88357201-1e22-4ac7-9f2c-a8093f501756.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In any case, the naming convention is to prefix the *Service* with "***BTService_***"
    (which stands for *Behavior Tree Service*). For instance, we can call our class
    something like *BTService_BPMyFirstService*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7169615a-8396-4d62-b6ac-5cc016dd706e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Just like the *Tasks* and *Decorators*, all the *overridable* functions come
    in two different versions: AI and *non-AI* (*Generic*). The concept is exactly
    the same: if only one of them is implemented (to keep your project consistent,
    it is advisable to override the AI version), then that function is called. If
    both are implemented, the AI is called when the Pawn is possessed by the AI Controller,
    otherwise the generic function is called instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here there are the four *overridable* functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18ec6bbb-d361-4378-b833-e77d6f20ab76.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Receive Activation**: This is called when the *Service* becomes active. Use
    it to initialize the *Service*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receive Tick**: This is called when the Service ticks. Mainly, a *Service*
    does something continuously (e.g. update a *Blackboard* variables), and so this
    is the most important function for the service. Performance-wise, it would be
    advisable to keep it as short as possible. Moreover, back to the *Behavior Tree*,
    it is possible to adjust how often a Service ticks (with a random value between
    min and max). However, the implementation, in theory, should not be aware of how
    often the Service ticks; it just needs to offer a "*service"*. Then, the user
    of the service, the *Behavior Tree*, will decide how often it wants this service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receive Search Start**: This is a special case in which the service is active
    (so you should have initialized the service, but in theory, the service should
    not have performed anything yet). This function is called before a *Task/Node*
    is searched. In fact, a *Behavior Tree* needs to evaluate which *Task* or *Node*
    to pick next to execute. In doing so, the *Behavior Tree* checks the conditions
    of the decorators on top of the possible *Tasks* or *Nodes*. As a result, in this
    function, you can adjust values before the next *Task* or *Node* is searched,
    and therefore choose something that influences the choice into being the correct
    one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receive Deactivation**: This is called when the service becomes inactive.
    Use it to clean up the Service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mainly, you will need to implement your logic in the ***Receive Tick*** function,
    so that you can constantly update the information in the Blackboard. A *Service*
    is a layer between the Behavior Tree and the game world.
  prefs: []
  type: TYPE_NORMAL
- en: We will implement a *Blueprint Service* during the course of the next three
    chapters, in which we will face a much more practical and concrete example.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Service in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a very similar fashion to how we extended *Tasks* and *Decorators* in C++,
    you can extend ***Services in C++*** as well. The base class to inherit from is ***BTService***,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b210ca98-7182-45b1-894c-d22f8aa78633.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The convention is to prefix the Service class name with "***BTService_***"
    (*Behavior Tree Service*).  A possible name for our class could be *BTService_MyFirstService*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/063bee02-8793-4140-95eb-0c5d152e5cef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have created the ***Service in C++***, the rest is done in a really
    similar fashion to e*xtending/creating* a *Decorator* in C++. Here there are the
    functions to override (taken from the Engine Source Code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here there is a comment at the beginning (always taken from the Engine Source
    Code) that explains some implementation choices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, we cannot go into detail about each function, but they are all
    quite easy to understand. In any case, we will explore further ***Services* **in
    the following three chapters, when we build a *Behavior Tree* from scratch, as
    well as when we implement a ***C++ Service***.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Composite Node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most of these cases, you ***will not need to extend a Composite Node***.
    By "*most of these cases"*, I mean that you can create very complex *AI Behavior
    Trees* that can perform very complicated tasks, and that you really shouldn't
    extend or create a Composite Node unless you really need to.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, a Composite Node influences the flow of the *Behavior Tree*, including
    which node to execute, which *Decorators* to check, and which *Service* to activate.
    By default, there are only three: *Selector*, *Sequence*, and *Simple Parallel*.
    These will be more than enough for covering most of our cases.'
  prefs: []
  type: TYPE_NORMAL
- en: However, if you really have specific needs, then Unreal Engine is so flexible
    that it allows you to extend a *Composite Node* as well.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, this is impossible to do in Blueprint, so the only way you can
    extend a (or create a new) *Composite Node* is through C++.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example of why you would like to create a new *Composite Node*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why**: Because you can implement a flow in the Behavior Tree that might be
    hard to achieve (or impossible) with the current composite nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**An Example**: You could potentially simulate a Behavior Tree with Simple
    Parallel nodes, with another one that does not use them. But this would be really
    complicated and not very clean. Thus, using Simple Parallel nodes simplifies a
    lot the workflow (originally, in the first versions of the engine, there were
    no Simple Parallel nodes).'
  prefs: []
  type: TYPE_NORMAL
- en: '**A Concrete Example**: You want to pick which tasks should execute at random,
    below this custom Composite node, based on some weights. For instance, the weights
    can be evaluated by a special type of *Decorators*. Thus, extending a *Composite* might
    require additional work on other type of nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Another Concrete example**: You can create a composite node that keeps picking
    a random child so that it succeeds until either a threshold is reached, or one
    of the children reports a fail.'
  prefs: []
  type: TYPE_NORMAL
- en: Despite this being a very interesting topic, unfortunately, it is outside the
    scope of this book. Therefore, we will limit our selves to creating new *Tasks*,
    *Decorators*, and *Services*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new type of nodes or new types of Trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In theory, you can create new types of nodes (for *Behavior Trees*, it's not
    really needed, because you would create a different kind of structure). Actually,
    you can create different tree structures that are not *Behavior Trees* anymore
    (e.g. a *Dialogue Tree*), which are far more useful than creating another node
    for a Behavior Tree. *Dialogue Trees* are really interesting, because they use
    a very similar structure to a *Behavior Tree*, and you can use the same *Editor*
    (or better, a slightly modified version of it) to edit the tree.
  prefs: []
  type: TYPE_NORMAL
- en: As much as I would like to dive into these topics, the main focus of this book
    is on AI, and so talking about *Dialogue Trees* is outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored how it is possible to *extend/create* ***Tasks***,
    ***Decorators***, and ***Services*** both in *Blueprint and in C++*. As a result,
    this gives us the ability to create complex behaviors for our AI agents, especially
    if combined with what we learned in the previous chapters, such as *navigation*,
    *EQS*, and *perception*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will deal with *Crowds*, before jumping into creating
    a concrete example in [Chapter 8](6995bf12-0f10-47a9-a48c-cec31696df87.xhtml),
    *Designing Behavior Trees – Part I*, [Chapter 9](063dda79-cb3c-49e7-bfa5-11f8680ee358.xhtml),
    *Designing Behavior Trees – Part II*, and [Chapter 10](039565e6-4f8d-4c73-936f-f5974e9c8226.xhtml),
    *Designing Behavior Trees – Part III*.
  prefs: []
  type: TYPE_NORMAL
