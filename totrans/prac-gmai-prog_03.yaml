- en: Production System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be talking about different ways to perfect our AI character
    and how to adapt the same techniques to work on different types of game that we
    want to create. We''ll also be discussing the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Automated finite-state machines (AFSMs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating chance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utility-based functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic gaming AI balance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After exploring possibility and probability maps, we need to understand how
    to use them in conjunction with other techniques and strategies to create a well-balanced
    and human-like AI character. Possibility maps or even probability maps can be
    used alone to create enjoyable and challenging games; in fact, many video games
    only relied on maps, and kept with the same approach in order to create their
    AI enemies, and they became very successful doing it that way. A perfect example
    would be a generic platform game, such as *Super Mario Bros* from Nintendo. They
    don't need to create a complex AI system in order to make enemies challenging
    and that is why for decades they kept using the same formula for enemies, because
    it works perfectly for the genre. So it's also important to remember that, depending
    on the game that we are creating, some techniques could work better than others
    and it's up to us to decide to use, and when to use it. Now, the same should be
    applied to the character that we are creating it should know what to do and when
    to do it at every single second of the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue with the *Super Mario Bros* example and analyze what some common
    enemies do:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6da34b24-83ac-4b1a-b1a3-66823cede4e3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The enemy in the screenshot is called Goomba. As soon as he appears in the
    game, you will notice that he moves from right to left, and only if he hits something
    (excluding the player) does he change his direction and move from left to right.
    If he''s on a higher platform, he keeps moving from right to left until he falls
    and on the lower platform he keeps moving from right to left. This enemy never
    tries to defeat the player and it''s very predictable. So we can determine that
    he only has one goal, that is, moving, and can be placed anywhere on the stage
    as he will behave in exactly the same way in terms of position that he is in.
    Now let''s MOVE TO our next enemy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/addacce9-51e4-42ac-89b4-d368d1a417eb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this second example, the enemy is called Hammer Bro and he has a different
    function from the previous one. This AI can move left or right, always facing
    the player, and he throws a hammer in the direction of the player. So his main
    objective in the game is to defeat the player. Exactly the same as the previous
    enemy, this one can also be placed anywhere in the game and will behave according
    to his goal. Now, imagine that we picked up the enemy AI that we developed in
    the previous chapter and we placed him in a different position or stage of the
    game. He wouldn't react because we haven't supplied directions on what he should
    do if placed on a different position. Depending on the game that we are creating,
    we need to develop an AI character that will react as we intended. Sometimes he
    will be fixed in a single position but most of the time it will be required for
    the same AI to react the same way in different positions in the game. Imagine
    if the creators of *Super Mario Bros* had to redefine their AI character every
    time they inserted it in the game; it would take a lot of time and work. So let's
    learn how to use FSMs to make our character adaptable to every situation of the
    game.
  prefs: []
  type: TYPE_NORMAL
- en: Automated finite-state machines (AFSMs)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we observed in the *Super Mario Bros* example, enemies know how to react
    no matter what position they are placed in. Obviously, it is not required for
    them to perform complex tasks or plan ahead what they will do, but it served perfectly
    as an example, especially when compared with other video games with different
    genres. For example, we can see the same principles being used on Halo with the
    Grunts (the small enemies). They simply move from one side to another and if they
    find the player they start shooting at him. It's the same principle, where they
    simply added a personality to their character that would run away every time they
    lost the combat against the player. For that, they used a statement where, every
    time the character is below a certain number of HP, they start running away. FSMs
    are what we used to create our possibility and probability maps; this is also
    what the character should do in different situations he is facing at the moment.
    Now let's create **automated finite-state machines** (**AFSMs**), where the character
    will choose the best option according to the factors that he will be able to calculate
    (position, player HP, current weapon, and so on). This method is extremely useful
    if we plan to use the same character on different stages or in games that involve
    an open world.
  prefs: []
  type: TYPE_NORMAL
- en: When planning AFSMs, it's a good start if we can break actions into two or three
    main columns; in one side of the column we put the main information, such as orientation,
    speed, or goals, and in the other columns we put actions that can be performed
    over the first column actions, such as moving, shooting, charging, finding cover,
    hiding, using the object, and so on. Doing that, we can ensure that our character
    can react according to our first column independently of the position in which
    he is currently placed. Imagine that the goal assigned to the AI is to guard the
    position that we defined. That goal is the primary objective so it will be placed
    on the first column. Now imagine that the character starts the game far away from
    the position that he should be guarding. At that point, he will be using the second
    column actions to fulfill the first column objectives. What we should put in the
    second column to make that possible depends heavily on the type of game that we
    want to create. So let's create an example and chose the best options for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll continue using the FPS genre as the main stage for our example, but
    the same principles can be used on almost any video game. That is why we''ve chosen
    *Super Mario Bros* as a reference, to show that no matter the type of game that
    we want to create, AI development tends to follow the same process of creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a71c920-aa26-48ec-89b6-dfb8ff443da9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, in our example, the map will have six buildings and neither the player nor
    the enemy can get inside them but they are allowed to move anywhere else. The
    main goal of this game is to defeat the opponent as many times as possible in
    a limited time; bullets and health points will appear occasionally in the game.
    Now let's develop an AI that can react the same way on any map. For that, we need
    to assign the main goal to the character and let him know about the possibilities
    available in order to fulfill that goal and also ensure that he is doing something
    every second of the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a basic form, we have two main goals for this AI character: **DEFEAT PLAYER**
    and **SURVIVE**. We need to make sure that we are able to kill the player when
    we have the chance and to survive when we don''t. For now, let''s simplify this
    formula and define goals by taking into consideration the current HP of our character.
    If he''s above 20% of his total HP, the main goal will be defeating the player
    and, on the other hand, if he''s below 20% of his HP, the main goal switches to
    surviving:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b84e237e-ae1e-4ce9-b681-0bf2ba0b4847.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have defined this, we can MOVE TO the second column and write the secondary
    goals that our AI will choose in order to complete the first column goals. So
    for this example, we will give our character three secondary goals: **FIND PLAYER**,
    **FIND COVER**, and **FIND POINTS**. By using these three objectives, our AI will
    be able to fulfill the main goals, will always have something to do, and will
    not wait for the player to do something, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c4f203a-0c53-4ec3-844c-6bb6861b39d8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that, we have already defined the secondary objectives, we''ll write down
    all the possible actions in the game, such as **MOVE TO**, **FIRE**, **USING OBJECT**,
    and **CROUCH** as follows. Once again, all of the things that a player or enemy
    AI is able to do in the game are defined while we think about the game design
    and all of that should be in this column. This is also an important strategy to
    analyze whether all the actions available to the characters of the game are relevant
    or not to the main or secondary goals. This will save us time in the future because
    there''s no point in programming a complex action if that doesn''t contribute
    to the success of the main goal, as with, *Super Mario Bros*, where they have
    chosen not to assign complex actions to their enemies because it wasn''t necessary
    for the type of game that they were creating. For this example, the character
    has the possibility to move freely, fire the weapon, use objects (reload weapon
    or use health points) and crouch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce15685d-d958-4665-abba-c7b4d47fca3f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we have the three columns filled with all of the information needed for
    our AI to choose the best options according to his current situation. As we'll
    see in a moment, this is a different method from what we used in the previous
    chapter, because back then we used the map to give him instructions about what
    he should do and we assigned him orders according to that position only. In this
    example, we want our character to decide the best option for himself no matter
    the map or position that he is placed on. This will move us to the next level
    of developing an AI character because if we take a look at human behavior, we
    rarely make a decision according to a single criterion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same process will be applied to our current enemy: they will choose the
    best option according to different criteria and we''ll make sure that they choose
    the best option based on their decision. For example, it is more urgent being
    at 1% health than being down to only 1% of ammunition or even completing the main
    goal of the game.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have our three columns ready, we can move on to the next step and link
    every action in the third column to the second, and all of the behaviors in the
    second to the first column goals. While doing this, we need to think about what
    the AI should be doing if he wants to find the player, find cover position, or
    find points. Also, we need to define when he should be looking for points, cover
    position, or the player. To find the player, we need to use the MOVE TO action,
    so our character will be walking around until he finds the player and ultimately
    fires at him. Then is, finding cover; once again, we'll be using the MOVE TO action,
    so our character will walk until he is near to a wall that can serve as a cover
    position, then we can choose whether he is crouching or not depending on what
    he wants to achieve. Finally, to find points, we'll be using MOVE TO and after
    that, we'll make the AI decide whether he will be using points or not (USE OBJECT).
    Now, let's think about what behavior or behaviors he should choose when he is
    trying to defeat the player and when he is trying to survive. In order to defeat
    the player, our AI character needs to find him, so we'll use the FIND PLAYER behavior
    for this goal; also, we'll let him choose the FIND COVER behavior if he has already
    found the player and they are close to a wall. For the SURVIVE goal, we'll be
    choosing FIND COVER, in case he's being attacked by the player, and FIND POINTS,
    to regain more HP points.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating chances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have everything set, we are ready to input all of this information
    into our code. We'll be using Booleans to define the main goals and then we'll
    create statements that will make the character AI choose between all of the other
    options. We already defined the primary statement that will switch our goal from
    defeating the player to simply surviving, but now we'll be adding more details
    to our AI behavior because of this question; What happens if the enemy has enough
    HP to confront the player but doesn't have enough bullets? What if he has enough
    bullets but his previous attempts to shoot the target have failed? The character
    will need to prioritize his choices and for each choice that they will be making,
    they need to compare it to the other alternatives and choose the one that has
    more chance of success in that goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the chances of hitting the player: imagine that our AI already
    fired ten bullets and only four have hit the player. We can say that he has a
    40% chance of hitting the player the next time he shoots. Now imagine that he
    only has two bullets in his gun; what should he do? Fire against the player with
    a not so favorable chance of being successful and then remain defenceless? Or
    run right away toward the point position where he can reload his weapon? To help
    in deciding this, the character will also be calculating the chance of being hit
    by the player; if the player has less chance of hitting the character, our AI
    will take the risk and fire against the player, otherwise it will try to reload
    its weapon. We''ll start adding this information into our code. You can see an
    example of how it should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the variables that we''ll be using for now. `firedBullets` represents
    how many bullets the character has already fired in the entire game; `hitBullets`
    represents how many of those bullets hit the target; `pFireBullets` and `pHitBullets`
    are the same but take player bullets into consideration. We can move on to the
    calculation of the chances of hitting the target or being hit. `chanceFire` will
    represent the percentage of bullets that hit the target and `chanceHit` the percentage
    of getting hit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have used the chances of hitting or being hit to determine what the AI should
    do in certain given situations. If he has more than 20 health points and has more
    than five bullets in his gun, he is free to shoot against the player until one
    of those two conditions doesn't match. Once when he only has five bullets, is
    it time to think about the next move, so in this example, if he has less than
    an 80% chance of being successful and hitting the player, he will decide not to
    shoot and will move towards the point position where he can reload his weapon.
    If he has more than an 80% chance, that means that he is being successful and
    he is free to try his luck. If, in the middle of the combat, the AI has less than
    a 30% chance of hitting the player and the player has more than a 30% chance,
    the character should immediately look for cover. Finally, if the AI character
    has less than 20% of his total health but he has a 90% chance of hitting the player
    and less than a 50% chance of being hit, he will choose to fire.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to be even more precise about the percentages, we could add a
    time variable into this equation, where the AI will take into consideration the
    last two minutes or so instead of the whole time, or compare both percentages
    and analyze whether he has been more or less successful in the last two minutes
    in comparison with the rest of the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: By calculating chances, we give our AI enough methods to calculate his next
    step, where he can freely decide which goal has more importance at that specific
    moment and choose his action according to that. Doing this will also give the
    AI the ability to choose between two or more options that are available to him.
    We start developing a more intelligent character, that can think for itself, and
    we can define personalities by simply changing the percentage values to make him
    take more risks or carefully choose his possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Utility-based functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to calculate chance and use AFSMs, it's time to explore
    them a little more and make our characters look smart. This time, we'll use an
    AI character that is set to behave autonomously in a simulation game such as *The
    Sims*. This is a perfect environment to test artificial intelligence because it
    mimics real-life needs and choices.
  prefs: []
  type: TYPE_NORMAL
- en: In the video game *The Sims*, the player has the opportunity to control a human-like
    character and the main goal of the game is to make sure that the character is
    always in good situations and that their personal and professional life is always
    on a positive note. Meanwhile, time goes by, just like in real life, and the character
    gets older until he finally dies at the end. The player is responsible for the
    life of that being but if the player doesn't give any orders to the character,
    he will react autonomously to fulfill his needs. It was revolutionary the way
    that an AI character could behave in a video game; people could relate to that
    virtual character and look at him just as an independent living being. The secret
    is that we already know what is necessary to create a character that can behave
    exactly like characters in *The Sims*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without further ado, let''s jump to our next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d902cab4-afb7-4180-b2c1-119164e5fb5e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s give a name to the character in this example and call her Sophie. She
    is a virtual human being. She has a home with everything necessary to live: sofa,
    shower, television, bed, oven, and so on. Just like a human being, she has human-like
    necessities such as hunger, energy, comfort, hygiene, and fun. As time passes,
    she needs to fulfill her necessities in order to stay healthy. Now that we have
    the problem, let''s work on the solution and make Sophie completely autonomous
    and able to decide for herself what she needs to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a866d7e6-e727-4137-948b-ea61468f8983.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can simplify and divide the objectives into two columns: on the left side,
    we put the main objectives of the game and on the right side, the actions the
    character perform. For example, if she is hungry, she needs to move towards the
    kitchen and interact with the fridge. This is exactly the same principle that
    we used to create the automated finite-state machines in the FPS example. But
    this time we''ll explore this concept even further.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s think for a minute about the hunger feeling. Let''s say that when we
    eat breakfast, we fulfill our hunger need and we don''t feel hungry anymore. At
    this point, we can say that our hunger necessity is at 100%, right? Imagine that
    a few minutes have passed by and now we are at 98%; why we don''t go right on
    to fulfill the 2% that is missing? We can say that feeling hungry is a state where
    we are no longer full and not necessarily that we are empty and because of that
    we switch our priorities towards other necessities. So it''s important to remember
    that when developing an autonomous AI character: he needs to have that thought
    in mind and not go to eat soon as he loses 1% of food. That would not look like
    human behavior; we tend to balance everything, otherwise we would sleep five minutes
    and work five, not so healthy or productive perhaps because it''s not enough to
    fall asleep and isn''t enough to start working. So, we sleep a fair number of
    hours to compensate for the other time that we are awake, and we eat a fair number
    of food to remain fulfilled for a few hours. We can make judgment decisions and
    decide that we are a little bit hungry but we need to finish the work first. Also,
    we make comparative judgments, for example, I''m hungry but I''m tired even more.
    It is important to understand our behavior when creating a virtual human being
    like Sophie because otherwise it will act like a robot.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To help Sophie determine what is more important at any specific moment, we''ll
    be using percentages and then she will be able to compare and decide what she
    wants to do. Before complicating it too much, let''s start writing the basic information
    in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We wrote down the basic variables relating to the necessities of the character
    that we are creating. As time goes by, those values will decrease, with different
    attributed values depending on necessity. Also we have an `Overall` variable that
    serves to calculate the overall situation of the character and could perfectly
    represent the mood of our virtual human being. That will be an important factor
    and will help Sophie to decide what is the best option for her.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s individualize each necessity and create a decision tree for all
    of them. To do so, we need to plan the process of decision-making that Sophie
    will think through before choosing any action. Let''s start with the hunger necessity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b695bc1d-e584-408b-9d9c-f7c5eb25f87b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If Sophie feels hungry and she decides that is a priority, these would be the
    steps that she will follow. First she feels hungry and then asks herself if she
    has enough food; to answer that, she moves towards the fridge and checks whether
    she has. If the answer is yes, she moves on, cooks, and finally eats. In the event
    any of the segments can''t be accomplished, the process will be interrupted and
    she will move on to a different priority. Let''s say that she only has food in
    her fridge if she goes to work and for every day of work she receives, for example,
    two days of food. So going to work will become a priority very soon if she wants
    to keep healthy and alive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code we have an example of how the decision tree can be represented
    in our code. We''ll continue writing what she will be doing for every necessity,
    and once we have that done, we can determine how she will prioritize and decide
    which necessity needs to be taken care of first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c324985-1690-403e-ba53-58541902eba8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next one on the list is energy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4cb0c20-d3e8-4651-8678-2f9d478a3f55.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If Sophie feels sleepy and she decides that is a priority, these will be the
    steps that she follows. First, she feels sleepy and then asks herself if she has
    to work. If she has free time then she will make a final judgment and decide whether
    she needs to go to the bathroom before sleeping. Once every state is approved,
    she can finally complete her goal and go to sleep. We can see an example of how
    it could be represented in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s assume that, for every hour that Sophie sleeps, she gains +10 points
    of Energy but loses 10 points of Hygiene. She''ll need to confirm first that she
    won''t need to use the bathroom in the middle of her sleep and for that we compare
    the number of Energy points that she needs with the number of Hygiene points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7be3456-8e13-4249-ac9c-46ce09cf374d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s move on to the Comfort necessity. This one is a little bit special because
    we can assign two objectives at the same time while gaining Comfort points. For
    example, she will be capable of deciding whether she wants to eat sitting on a
    chair or not. The same can be applied when she is watching TV. This is an important
    example that can be applied in many games, where a character decides to do two
    things at the same time when he has the opportunity and understands that it is
    important to do so. In the example that follows, we''ll be taking that into consideration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b44cb82-c245-4e28-bdbe-30366f45dc26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If Sophie feels uncomfortable, she will check first whether at that moment
    she is doing something. This question can only have two answers: yes or no. If
    the answer is yes, she''ll need to think whether it is possible for her to keep
    on doing it seated. Otherwise, she''ll finish what she is doing at that moment
    and then will start asking the same question. If possible or available, she''ll
    finally sit and get comfortable. We can check an example of how it should look
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We added three more variables: `isEating`, `isWatchingTV`, and `Busy`. This
    will help her decide the best option, taking into consideration those three values.
    In the event that she feels uncomfortable but is eating or watching TV, she can
    perform both of the actions together. Otherwise, she needs to compare the rest
    of the necessities and judge whether it''s more important to sit instead of doing
    other things. In the event that she is doing something at that moment and it''s
    not possible for her to sit - let''s say, for example, that she is taking a shower
    or working - she''ll ignore the fact that she feels uncomfortable and, as soon
    as Sophie has the opportunity, she''ll sit and gain Comfort points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1477cb1-ea98-4ac2-8be5-acf32e8313fb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There remain two more necessities to finish this example and soon we will have
    an AI character that could live by itself without the need for someone to control
    and decide what is best for her. We are developing an AI system that works on
    a simulation game but this same method can also be used on different genres of
    game. Imagine a real-time strategy game where the workers make autonomous decisions
    and, instead of being idle waiting for orders, immediately go to work on what
    they think is more important at that moment and, as soon as other priorities arrive,
    switch to another occupation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to the next objective, Hygiene. Just for the sake of simplicity,
    we will use this necessity as everything related to the bathroom:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b1cd9c2-d399-4d73-9e60-d073cda1cccf.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The hygiene necessity is simpler than the previous ones; it's just a question
    of whether she is available or not to take a shower. The extra factor that we'll
    be using on this one is that, no matter the circumstances, going to the bathroom
    is the most important one and she will immediately pause what she is doing and
    go straight towards the bathroom.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only things that she could possibly do while taking a shower are brushing
    her teeth or any other sub-segment of the hygiene criterion. But for now, let''s
    stick with as few options as possible to test the AI; once we have the basic functions
    working properly, we then can start adding more actions. For prototype purposes,
    that is also a good methodology to follow: by first having the basic functions
    working, we can move on and gradually add more details. Now let''s take a look
    at an example of how the `Hygiene` function would look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/b750f69f-6355-489f-a76c-76c563120ff5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s jump right away into the next and last necessity, Fun. This one will
    have the opportunity to be the most flexible of them all, because we can eat and
    watch TV at the same time, we can sit and watch TV at the same time, and we can
    eat sitting down while watching TV. We give the option to our AI to be able to
    do three distinct things at the same time. At first glance, allowing our character
    to boost her points in three different necessities looks ideal, but we''ll be
    discussing that later on. For now, let''s just focus on the Fun factor and plan
    the steps that she''ll be using to determine whether she needs to, and can, watch
    TV:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a13f5dc9-42e2-410b-8117-d8bbdadbbaf0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If Sophie feels bored, she''ll start asking herself whether she can watch TV.
    First, if she is available, she''s free to watch TV and, in the default state,
    she watches TV seated. But if she is busy at that time, she needs to ask herself
    whether she can watch TV at the same time that she is doing whatever she''s doing
    (in this example, that represents eating, sitting, or both at the same time).
    Once again, for the sake of simplicity, let''s assume that she doesn''t need to
    reach the television in order to turn it on. We can see an example of how that
    could be represented in our code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we conclude the necessity behaviors using different approaches for
    each one. Doing this, we can ensure that she will know what to do in different
    situations of the game and will always be looking to do something. There are some
    flaws in the AI design that we''ll need to perfect; for example, she can''t decide
    to continue watching TV even if she is hungry or tired. To make that possible,
    we would need to simply add a probability map and use the `Overall` variable to
    define whether she is happy or not; let''s say that, in the event that she''s
    above 50% for happiness, she can decide to watch TV even if she feels tired. All
    of those restrictions can now be assigned to the code and we can continuously
    add more details to the behavior of our character. But, for now, we will just
    focus on two more details: AI balance and dynamic problem-solving.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4de89310-035c-4ea4-88d8-8545a62796f3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Dynamic game AI balancing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another interesting and very useful topic to learn about AI development is
    game difficulty. If we play against a human player, the difficulty of the game
    will solely depend on the experience of the player that is playing against us.
    If they are very skillful with that specific video game, obviously they will have
    a greater advantage against a player who is just starting the game. Usually, video-games
    tend to increase the difficulty step by step, so the player can adapt to it and
    doesn''t get frustrated too soon or simply bored because the game doesn''t offer
    a challenge. Dynamic game difficulty balancing is used to solve this problem,
    by creating an interesting experience for each gamer. To balance the AI character
    using this method, we take into consideration some dynamic game elements that
    can be adjusted according to player experience; those attributes can be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Speed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Health
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Magic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Power
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually, we use these attributes to define the difficulty of the AI character,
    adjusting them to the difficulty desired. Another way to balance the difficulty
    is by adjusting the quantity of weapons and enemies that the player faces during
    the game. When adjusting the difficulty, we also need to be careful to not create
    an enemy that behaves like a rubber band; for example, if the AI car is behind
    the player, it gets significantly faster in order to keep challenging the player.
    When the player is behind the opponent car, that car will decrease its speed and
    this method, if not moderated, can become uninteresting.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a generic fighting game, developers usually define AI combat like this:
    if the player is reachable, the AI uses kicks or punches; if not, he goes towards
    the player. Then the difficulty is adjusted by using percentages and time gaps
    between attacks.'
  prefs: []
  type: TYPE_NORMAL
- en: In an FPS shooter, for example, the game AI is adjusted by taking into consideration
    the player performance while in the development stage, where the programmers input
    all the AI stat values and tactics that match the overall performance of the human
    players. For example, if the shoot rate of the player is about 70%, the AI characters
    will use that value to stay relatively close to a human performance.
  prefs: []
  type: TYPE_NORMAL
- en: '*Crash Bandicoot* used *Dynamic Game Difficulty Balancing* not directly in
    the behavior of the AI characters themselves, but rather in the animation speed,
    making it slower if the player was having difficulty passing the level. This difficulty
    adjustment takes place according to the players number of deaths. This is a smart
    and simple way to adjust the difficulty of the AI character, by considering the
    number of times that the player died trying to beat the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Resident Evil 4*, released in 2005 by Capcom, based the difficulty adjustment
    on the same principle but employed a more complex system. The adjustment took
    into consideration player performance and, without notice, the player was rated
    by the game from one to ten, where one meant that they were not very successful
    in the game and ten that they were very skillful. Taking those rates into consideration,
    enemies would behave differently, being more or less aggressive and taking more
    or less damage. The rating was constantly updated and many things were taken into
    consideration to determine how good the player was, such as how many bullets he
    needed to kill a zombie, how many hits he took, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Left 4 Dead* also took into consideration how well the player was doing, but
    instead of only increasing the difficulty of the enemies'' AI, they decided to
    change where the enemies would appear, creating a different challenge every time
    the player decided to play the same level. If the player just started the game,
    the enemies would appear in easier places; if the player had already passed that
    level, the enemies would appear in more difficult positions.'
  prefs: []
  type: TYPE_NORMAL
- en: To summarize the choices that game developers are making while adjusting the
    difficulty of character AI, we need to mention that the difficulty not always
    is meant to be adjusted or to increase or decrease taking into consideration player
    performance. One great example is simulation games, where it's crucial to meet
    real-life difficulties and not make them more difficult or easier, otherwise it
    won't feel like a simulation. Other examples could be games such as Ghosts'n Goblins
    or, more recently, Dark Souls, where developers explicitly chose to make the game
    hard from start to finish without changing the AI behavior regarding the difficulty.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discovered how to create AI characters that make their own
    decisions no matter where we place them by using AFSMs. Then we learned how to
    calculate chance and how to use it in conjunction with the previous techniques
    to create a character that could calculate a better option for his next step.
    Using all of the the set techniques, we moved on to how to use utility-based functions
    to create a human-like character that can behave autonomously. Finally, we talked
    about different ways of adjusting the values that we input in our characters to
    make them balanced compared to player performance. In the next chapter, we'll
    be talking in depth about environment and AI, taking into consideration different
    genres of video game and different types of AI, how the AI should use the available
    space on the map to create a challenge for the player, how to interact with the
    environment, how to use the environment in its favor, and a lot more.
  prefs: []
  type: TYPE_NORMAL
