- en: Production System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be talking about different ways to perfect our AI character
    and how to adapt the same techniques to work on different types of game that we
    want to create. We''ll also be discussing the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Automated finite-state machines (AFSMs)
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating chance
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utility-based functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic gaming AI balance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After exploring possibility and probability maps, we need to understand how
    to use them in conjunction with other techniques and strategies to create a well-balanced
    and human-like AI character. Possibility maps or even probability maps can be
    used alone to create enjoyable and challenging games; in fact, many video games
    only relied on maps, and kept with the same approach in order to create their
    AI enemies, and they became very successful doing it that way. A perfect example
    would be a generic platform game, such as *Super Mario Bros* from Nintendo. They
    don't need to create a complex AI system in order to make enemies challenging
    and that is why for decades they kept using the same formula for enemies, because
    it works perfectly for the genre. So it's also important to remember that, depending
    on the game that we are creating, some techniques could work better than others
    and it's up to us to decide to use, and when to use it. Now, the same should be
    applied to the character that we are creating it should know what to do and when
    to do it at every single second of the game.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue with the *Super Mario Bros* example and analyze what some common
    enemies do:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6da34b24-83ac-4b1a-b1a3-66823cede4e3.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
- en: 'The enemy in the screenshot is called Goomba. As soon as he appears in the
    game, you will notice that he moves from right to left, and only if he hits something
    (excluding the player) does he change his direction and move from left to right.
    If he''s on a higher platform, he keeps moving from right to left until he falls
    and on the lower platform he keeps moving from right to left. This enemy never
    tries to defeat the player and it''s very predictable. So we can determine that
    he only has one goal, that is, moving, and can be placed anywhere on the stage
    as he will behave in exactly the same way in terms of position that he is in.
    Now let''s MOVE TO our next enemy:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/addacce9-51e4-42ac-89b4-d368d1a417eb.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
- en: In this second example, the enemy is called Hammer Bro and he has a different
    function from the previous one. This AI can move left or right, always facing
    the player, and he throws a hammer in the direction of the player. So his main
    objective in the game is to defeat the player. Exactly the same as the previous
    enemy, this one can also be placed anywhere in the game and will behave according
    to his goal. Now, imagine that we picked up the enemy AI that we developed in
    the previous chapter and we placed him in a different position or stage of the
    game. He wouldn't react because we haven't supplied directions on what he should
    do if placed on a different position. Depending on the game that we are creating,
    we need to develop an AI character that will react as we intended. Sometimes he
    will be fixed in a single position but most of the time it will be required for
    the same AI to react the same way in different positions in the game. Imagine
    if the creators of *Super Mario Bros* had to redefine their AI character every
    time they inserted it in the game; it would take a lot of time and work. So let's
    learn how to use FSMs to make our character adaptable to every situation of the
    game.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第二个例子中，敌人被称作锤子兄弟（Hammer Bro），它和之前的敌人功能不同。这个AI可以左右移动，始终面向玩家，并且朝玩家的方向投掷锤子。因此，他在游戏中的主要目标是击败玩家。和之前的敌人一样，这个敌人也可以被放置在游戏的任何位置，并且会根据他的目标行动。现在，假设我们拾起了上一章中开发的敌人AI，并将其放置在游戏的不同位置或阶段。他不会做出反应，因为我们没有提供关于如果放置在另一个位置时他应该做什么的指示。根据我们正在创建的游戏，我们需要开发一个AI角色，使其能够按照我们的意图做出反应。有时他会被固定在单个位置，但大多数时候，需要同一个AI在游戏的不同位置以相同的方式做出反应。想象一下，如果《超级马里奥兄弟》（*Super
    Mario Bros*）的制作者每次将AI角色插入游戏时都必须重新定义他们的AI角色，这将花费大量的时间和精力。所以，让我们学习如何使用有限状态机（FSMs）来使我们的角色能够适应游戏的每一种情况。
- en: Automated finite-state machines (AFSMs)
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动有限状态机（AFSMs）
- en: As we observed in the *Super Mario Bros* example, enemies know how to react
    no matter what position they are placed in. Obviously, it is not required for
    them to perform complex tasks or plan ahead what they will do, but it served perfectly
    as an example, especially when compared with other video games with different
    genres. For example, we can see the same principles being used on Halo with the
    Grunts (the small enemies). They simply move from one side to another and if they
    find the player they start shooting at him. It's the same principle, where they
    simply added a personality to their character that would run away every time they
    lost the combat against the player. For that, they used a statement where, every
    time the character is below a certain number of HP, they start running away. FSMs
    are what we used to create our possibility and probability maps; this is also
    what the character should do in different situations he is facing at the moment.
    Now let's create **automated finite-state machines** (**AFSMs**), where the character
    will choose the best option according to the factors that he will be able to calculate
    (position, player HP, current weapon, and so on). This method is extremely useful
    if we plan to use the same character on different stages or in games that involve
    an open world.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在《超级马里奥兄弟》（*Super Mario Bros*）的例子中所观察到的，敌人无论被放置在什么位置都知道如何做出反应。显然，他们不需要执行复杂的任务或提前计划他们将要做什么，但这作为一个例子非常完美，尤其是在与其他不同类型的视频游戏进行比较时。例如，我们可以在《光环》（Halo）中看到相同的原理被应用于小敌人（Grunts）。他们只是从一个侧面移动到另一个侧面，如果他们发现玩家，就会开始射击。这是同样的原理，他们只是给他们的角色添加了一个个性，每次在与玩家战斗失败后都会逃跑。为此，他们使用了一个语句，每次角色的生命值（HP）低于一定数值时，他们就开始逃跑。有限状态机（FSMs）是我们用来创建可能性和概率图的东西；这也是角色在面临不同情况时应做的事情。现在，让我们创建**自动有限状态机**（**AFSMs**），其中角色将根据他能计算出的因素（位置、玩家HP、当前武器等）选择最佳选项。如果我们计划在不同的阶段或涉及开放世界的游戏中使用同一个角色，这种方法非常有用。
- en: When planning AFSMs, it's a good start if we can break actions into two or three
    main columns; in one side of the column we put the main information, such as orientation,
    speed, or goals, and in the other columns we put actions that can be performed
    over the first column actions, such as moving, shooting, charging, finding cover,
    hiding, using the object, and so on. Doing that, we can ensure that our character
    can react according to our first column independently of the position in which
    he is currently placed. Imagine that the goal assigned to the AI is to guard the
    position that we defined. That goal is the primary objective so it will be placed
    on the first column. Now imagine that the character starts the game far away from
    the position that he should be guarding. At that point, he will be using the second
    column actions to fulfill the first column objectives. What we should put in the
    second column to make that possible depends heavily on the type of game that we
    want to create. So let's create an example and chose the best options for it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在规划AFSM（有限状态机）时，如果我们能够将动作分解为两到三个主要列，那是一个很好的开始；在一侧的列中，我们放置主要信息，例如方向、速度或目标，而在另一列中，我们放置可以在第一列动作上执行的动作，例如移动、射击、充电、寻找掩护、隐藏、使用物品等等。通过这样做，我们可以确保我们的角色可以独立于他当前所在的位置根据第一列的反应。想象一下，分配给AI的目标是守卫我们定义的位置。这个目标是主要目标，因此它将被放置在第一列。现在想象一下，角色开始游戏时离他应该守卫的位置很远。在那个时刻，他将使用第二列的动作来实现第一列的目标。我们应该在第二列中放置什么，以便使这一点成为可能，这很大程度上取决于我们想要创建的游戏类型。所以让我们创建一个示例，并选择最佳选项。
- en: 'We''ll continue using the FPS genre as the main stage for our example, but
    the same principles can be used on almost any video game. That is why we''ve chosen
    *Super Mario Bros* as a reference, to show that no matter the type of game that
    we want to create, AI development tends to follow the same process of creation:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用FPS（第一人称射击）游戏类型作为示例的主要舞台，但同样的原则几乎可以应用于任何视频游戏。这就是我们选择《超级马里奥兄弟》作为参考的原因，以展示无论我们想要创建的游戏类型如何，人工智能的开发往往遵循相同的创作过程：
- en: '![](img/2a71c920-aa26-48ec-89b6-dfb8ff443da9.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2a71c920-aa26-48ec-89b6-dfb8ff443da9.jpg)'
- en: So, in our example, the map will have six buildings and neither the player nor
    the enemy can get inside them but they are allowed to move anywhere else. The
    main goal of this game is to defeat the opponent as many times as possible in
    a limited time; bullets and health points will appear occasionally in the game.
    Now let's develop an AI that can react the same way on any map. For that, we need
    to assign the main goal to the character and let him know about the possibilities
    available in order to fulfill that goal and also ensure that he is doing something
    every second of the game.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的示例中，地图将有六个建筑，玩家和敌人都不可以进入其中，但他们可以在其他任何地方移动。这个游戏的主要目标是尽可能多地在有限的时间内击败对手；子弹和生命值会在游戏中偶尔出现。现在让我们开发一个能够在任何地图上以相同方式反应的人工智能。为此，我们需要将主要目标分配给角色，并让他了解实现该目标所需的可能性，同时确保他在游戏的每一秒都在做些什么。
- en: 'On a basic form, we have two main goals for this AI character: **DEFEAT PLAYER**
    and **SURVIVE**. We need to make sure that we are able to kill the player when
    we have the chance and to survive when we don''t. For now, let''s simplify this
    formula and define goals by taking into consideration the current HP of our character.
    If he''s above 20% of his total HP, the main goal will be defeating the player
    and, on the other hand, if he''s below 20% of his HP, the main goal switches to
    surviving:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本形式上，我们为这个AI角色设定了两个主要目标：**击败玩家**和**生存**。我们需要确保当我们有机会时能够杀死玩家，而在没有机会时能够生存。目前，让我们简化这个公式，通过考虑我们角色的当前生命值来定义目标。如果他总生命值的20%以上，主要目标将是击败玩家；另一方面，如果他总生命值的20%以下，主要目标将切换为生存：
- en: '![](img/b84e237e-ae1e-4ce9-b681-0bf2ba0b4847.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b84e237e-ae1e-4ce9-b681-0bf2ba0b4847.jpg)'
- en: 'Once we have defined this, we can MOVE TO the second column and write the secondary
    goals that our AI will choose in order to complete the first column goals. So
    for this example, we will give our character three secondary goals: **FIND PLAYER**,
    **FIND COVER**, and **FIND POINTS**. By using these three objectives, our AI will
    be able to fulfill the main goals, will always have something to do, and will
    not wait for the player to do something, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了这一点，我们就可以移动到第二列，并写下我们的AI将选择的次要目标，以便完成第一列的目标。所以在这个例子中，我们将给我们的角色三个次要目标：**找到玩家**、**找到掩护**和**找到得分点**。通过使用这三个目标，我们的AI将能够实现主要目标，将始终有事情可做，并且不会等待玩家采取行动，如下所示：
- en: '![](img/4c4f203a-0c53-4ec3-844c-6bb6861b39d8.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4c4f203a-0c53-4ec3-844c-6bb6861b39d8.jpg)'
- en: 'Now that, we have already defined the secondary objectives, we''ll write down
    all the possible actions in the game, such as **MOVE TO**, **FIRE**, **USING OBJECT**,
    and **CROUCH** as follows. Once again, all of the things that a player or enemy
    AI is able to do in the game are defined while we think about the game design
    and all of that should be in this column. This is also an important strategy to
    analyze whether all the actions available to the characters of the game are relevant
    or not to the main or secondary goals. This will save us time in the future because
    there''s no point in programming a complex action if that doesn''t contribute
    to the success of the main goal, as with, *Super Mario Bros*, where they have
    chosen not to assign complex actions to their enemies because it wasn''t necessary
    for the type of game that they were creating. For this example, the character
    has the possibility to move freely, fire the weapon, use objects (reload weapon
    or use health points) and crouch:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经定义了次要目标，我们将写下游戏中所有可能采取的行动，例如**移动到**、**开火**、**使用物品**和**蹲下**，如下所示。再次强调，当我们在思考游戏设计时，所有玩家或敌人AI能够执行的动作都应该被定义，并且所有这些都应该在这一栏中。这也是分析游戏中角色的所有可用动作是否与主要或次要目标相关的重要策略。这将节省我们未来的时间，因为没有必要编写复杂的动作，如果这些动作不会对主要目标的成功做出贡献，就像在*超级马里奥兄弟*中，他们选择不将复杂的动作分配给敌人，因为这对他们所创建的游戏类型来说并不必要。在这个例子中，角色有自由移动、开火、使用物品（重新装填武器或使用生命值）和蹲下的可能性：
- en: '![](img/ce15685d-d958-4665-abba-c7b4d47fca3f.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ce15685d-d958-4665-abba-c7b4d47fca3f.jpg)'
- en: Now, we have the three columns filled with all of the information needed for
    our AI to choose the best options according to his current situation. As we'll
    see in a moment, this is a different method from what we used in the previous
    chapter, because back then we used the map to give him instructions about what
    he should do and we assigned him orders according to that position only. In this
    example, we want our character to decide the best option for himself no matter
    the map or position that he is placed on. This will move us to the next level
    of developing an AI character because if we take a look at human behavior, we
    rarely make a decision according to a single criterion.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经填满了三列，包含了我们AI选择最佳选项所需的所有信息。正如我们很快就会看到的，这与我们在上一章中使用的方法不同，因为那时我们使用地图来给他指示他应该做什么，并且我们根据那个位置只分配给他命令。在这个例子中，我们希望我们的角色无论处于地图上的哪个位置，都能为自己决定最佳选项。这将推动我们进入开发AI角色的下一阶段，因为如果我们观察人类行为，我们很少根据单一标准做出决定。
- en: 'The same process will be applied to our current enemy: they will choose the
    best option according to different criteria and we''ll make sure that they choose
    the best option based on their decision. For example, it is more urgent being
    at 1% health than being down to only 1% of ammunition or even completing the main
    goal of the game.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的过程将应用于我们当前的敌人：他们将会根据不同的标准选择最佳选项，我们将确保他们基于自己的决定选择最佳选项。例如，健康值降至1%比弹药量降至仅剩1%或完成游戏的主要目标更为紧急。
- en: Once we have our three columns ready, we can move on to the next step and link
    every action in the third column to the second, and all of the behaviors in the
    second to the first column goals. While doing this, we need to think about what
    the AI should be doing if he wants to find the player, find cover position, or
    find points. Also, we need to define when he should be looking for points, cover
    position, or the player. To find the player, we need to use the MOVE TO action,
    so our character will be walking around until he finds the player and ultimately
    fires at him. Then is, finding cover; once again, we'll be using the MOVE TO action,
    so our character will walk until he is near to a wall that can serve as a cover
    position, then we can choose whether he is crouching or not depending on what
    he wants to achieve. Finally, to find points, we'll be using MOVE TO and after
    that, we'll make the AI decide whether he will be using points or not (USE OBJECT).
    Now, let's think about what behavior or behaviors he should choose when he is
    trying to defeat the player and when he is trying to survive. In order to defeat
    the player, our AI character needs to find him, so we'll use the FIND PLAYER behavior
    for this goal; also, we'll let him choose the FIND COVER behavior if he has already
    found the player and they are close to a wall. For the SURVIVE goal, we'll be
    choosing FIND COVER, in case he's being attacked by the player, and FIND POINTS,
    to regain more HP points.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们准备好了三列，我们就可以进行下一步，将第三列中的每个动作链接到第二列，并将第二列中的所有行为链接到第一列的目标。在这样做的时候，我们需要考虑如果AI想要找到玩家、找到掩护位置或找到点数，他应该做什么。同时，我们需要定义他应该在什么时候寻找点数、掩护位置或玩家。为了找到玩家，我们需要使用“移动到”动作，因此我们的角色将四处走动，直到找到玩家，然后最终向他开火。然后是寻找掩护；再次使用“移动到”动作，因此我们的角色将走到靠近可以作为掩护位置的一堵墙，然后我们可以根据他想要达到的目标选择他是蹲下还是不蹲下。最后，为了找到点数，我们将使用“移动到”，然后，我们将让AI决定他是否使用点数（使用对象）。现在，让我们考虑当他在试图击败玩家和试图生存时，他应该选择什么样的行为或行为。为了击败玩家，我们的AI角色需要找到他，所以我们将使用“找到玩家”行为来实现这个目标；此外，如果他已经找到玩家并且他们靠近一堵墙，我们将让他选择“找到掩护”行为。对于“生存”目标，我们将选择“找到掩护”，以防他被玩家攻击，并选择“找到点数”，以恢复更多的HP点数。
- en: Calculating chances
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算概率
- en: Now that we have everything set, we are ready to input all of this information
    into our code. We'll be using Booleans to define the main goals and then we'll
    create statements that will make the character AI choose between all of the other
    options. We already defined the primary statement that will switch our goal from
    defeating the player to simply surviving, but now we'll be adding more details
    to our AI behavior because of this question; What happens if the enemy has enough
    HP to confront the player but doesn't have enough bullets? What if he has enough
    bullets but his previous attempts to shoot the target have failed? The character
    will need to prioritize his choices and for each choice that they will be making,
    they need to compare it to the other alternatives and choose the one that has
    more chance of success in that goal.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经一切准备就绪，我们可以将所有这些信息输入到我们的代码中。我们将使用布尔值来定义主要目标，然后创建语句，让角色AI在所有其他选项之间进行选择。我们已经定义了将目标从击败玩家切换到仅仅生存的主要语句，但现在我们将因为这个问题添加更多细节到我们的AI行为中；如果敌人有足够的HP面对玩家，但没有足够的子弹会发生什么？如果他有很多子弹，但之前的射击目标尝试都失败了怎么办？角色需要优先考虑他的选择，并且对于他们将要做出的每一个选择，他们需要将其与其他替代方案进行比较，并选择在那个目标中成功机会更大的一个。
- en: 'Let''s start with the chances of hitting the player: imagine that our AI already
    fired ten bullets and only four have hit the player. We can say that he has a
    40% chance of hitting the player the next time he shoots. Now imagine that he
    only has two bullets in his gun; what should he do? Fire against the player with
    a not so favorable chance of being successful and then remain defenceless? Or
    run right away toward the point position where he can reload his weapon? To help
    in deciding this, the character will also be calculating the chance of being hit
    by the player; if the player has less chance of hitting the character, our AI
    will take the risk and fire against the player, otherwise it will try to reload
    its weapon. We''ll start adding this information into our code. You can see an
    example of how it should look as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从击中玩家的概率开始：想象一下我们的AI已经发射了十发子弹，但只有四发击中了玩家。我们可以说他下一次射击击中玩家的概率是40%。现在想象一下，他枪中只剩下两发子弹；他应该怎么做？以不太有利的成功概率向玩家射击，然后变得毫无防备？或者直接跑向可以重新装填武器的位置？为了帮助做出决定，角色还将计算被玩家击中的概率；如果玩家击中角色的概率更低，我们的AI将冒险向玩家射击，否则它将尝试重新装填武器。我们将开始将此信息添加到我们的代码中。以下是如何呈现的示例：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'These are the variables that we''ll be using for now. `firedBullets` represents
    how many bullets the character has already fired in the entire game; `hitBullets`
    represents how many of those bullets hit the target; `pFireBullets` and `pHitBullets`
    are the same but take player bullets into consideration. We can move on to the
    calculation of the chances of hitting the target or being hit. `chanceFire` will
    represent the percentage of bullets that hit the target and `chanceHit` the percentage
    of getting hit:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们目前将使用的变量。`firedBullets` 表示角色在整个游戏中已经发射了多少发子弹；`hitBullets` 表示其中有多少发子弹击中了目标；`pFireBullets`
    和 `pHitBullets` 与此相同，但考虑了玩家的子弹。我们可以继续计算击中目标或被击中的概率。`chanceFire` 将表示击中目标的子弹百分比，而
    `chanceHit` 则表示被击中的百分比：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have used the chances of hitting or being hit to determine what the AI should
    do in certain given situations. If he has more than 20 health points and has more
    than five bullets in his gun, he is free to shoot against the player until one
    of those two conditions doesn't match. Once when he only has five bullets, is
    it time to think about the next move, so in this example, if he has less than
    an 80% chance of being successful and hitting the player, he will decide not to
    shoot and will move towards the point position where he can reload his weapon.
    If he has more than an 80% chance, that means that he is being successful and
    he is free to try his luck. If, in the middle of the combat, the AI has less than
    a 30% chance of hitting the player and the player has more than a 30% chance,
    the character should immediately look for cover. Finally, if the AI character
    has less than 20% of his total health but he has a 90% chance of hitting the player
    and less than a 50% chance of being hit, he will choose to fire.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用击中或被击中的概率来确定AI在特定情况下应该做什么。如果他拥有超过20点生命值并且枪中有超过五发子弹，他可以自由地向玩家射击，直到这两个条件中的任何一个不再符合。一旦他只剩下五发子弹，就是考虑下一步行动的时候了，所以在这个例子中，如果他成功击中玩家的概率低于80%，他将决定不射击，并移动到可以重新装填武器的位置。如果他成功击中的概率超过80%，这意味着他正在取得成功，他可以自由地尝试运气。如果在战斗过程中，AI击中玩家的概率低于30%，而玩家击中AI的概率超过30%，角色应该立即寻找掩护。最后，如果AI角色剩余的总生命值低于20%，但他有90%的概率击中玩家，且被击中的概率低于50%，他将选择开火。
- en: 'If we wanted to be even more precise about the percentages, we could add a
    time variable into this equation, where the AI will take into consideration the
    last two minutes or so instead of the whole time, or compare both percentages
    and analyze whether he has been more or less successful in the last two minutes
    in comparison with the rest of the game:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要对百分比更加精确，我们可以将时间变量添加到这个方程中，其中AI将考虑最后两分钟或更短的时间，而不是整个时间，或者比较这两个百分比，分析他在最后两分钟内与整个游戏相比成功或失败的程度：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By calculating chances, we give our AI enough methods to calculate his next
    step, where he can freely decide which goal has more importance at that specific
    moment and choose his action according to that. Doing this will also give the
    AI the ability to choose between two or more options that are available to him.
    We start developing a more intelligent character, that can think for itself, and
    we can define personalities by simply changing the percentage values to make him
    take more risks or carefully choose his possibilities.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过计算概率，我们给我们的AI足够的计算下一步的方法，他可以自由地决定在那个特定时刻哪个目标更重要，并根据那个目标选择他的行动。这样做也将使AI能够在两个或更多可用的选项之间进行选择。我们开始开发一个更智能的角色，他可以自己思考，我们可以通过简单地改变百分比值来定义个性，使他更愿意冒险或谨慎地选择他的可能性。
- en: Utility-based functions
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于效用函数
- en: Now that we know how to calculate chance and use AFSMs, it's time to explore
    them a little more and make our characters look smart. This time, we'll use an
    AI character that is set to behave autonomously in a simulation game such as *The
    Sims*. This is a perfect environment to test artificial intelligence because it
    mimics real-life needs and choices.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何计算概率并使用自动有限状态机（AFSM），是时候更深入地探索它们，并让我们的角色看起来更聪明了。这次，我们将使用一个设置为在模拟游戏如《模拟人生》中自主行为的AI角色。这是一个测试人工智能的完美环境，因为它模仿了现实生活中的需求和选择。
- en: In the video game *The Sims*, the player has the opportunity to control a human-like
    character and the main goal of the game is to make sure that the character is
    always in good situations and that their personal and professional life is always
    on a positive note. Meanwhile, time goes by, just like in real life, and the character
    gets older until he finally dies at the end. The player is responsible for the
    life of that being but if the player doesn't give any orders to the character,
    he will react autonomously to fulfill his needs. It was revolutionary the way
    that an AI character could behave in a video game; people could relate to that
    virtual character and look at him just as an independent living being. The secret
    is that we already know what is necessary to create a character that can behave
    exactly like characters in *The Sims*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在视频游戏《模拟人生》中，玩家有机会控制一个类似人类的角色，游戏的主要目标是确保这个角色始终处于良好的状况，并且他们的个人和职业生活始终处于积极的状态。与此同时，时间就像在现实生活中一样流逝，角色会逐渐变老，直到最终死亡。玩家负责这个角色的生活，但如果玩家不对角色下达任何指令，他将会自主地反应以满足自己的需求。一个AI角色在视频游戏中的行为方式是革命性的；人们可以与这个虚拟角色产生共鸣，就像看待一个独立的生物一样。秘密在于我们早已知道如何创建一个可以像《模拟人生》中的角色一样行为的角色。
- en: 'Without further ado, let''s jump to our next example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，让我们直接跳到下一个例子：
- en: '![](img/d902cab4-afb7-4180-b2c1-119164e5fb5e.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d902cab4-afb7-4180-b2c1-119164e5fb5e.jpg)'
- en: 'Let''s give a name to the character in this example and call her Sophie. She
    is a virtual human being. She has a home with everything necessary to live: sofa,
    shower, television, bed, oven, and so on. Just like a human being, she has human-like
    necessities such as hunger, energy, comfort, hygiene, and fun. As time passes,
    she needs to fulfill her necessities in order to stay healthy. Now that we have
    the problem, let''s work on the solution and make Sophie completely autonomous
    and able to decide for herself what she needs to do:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给这个例子中的角色起个名字，叫她Sophie。她是一个虚拟的人类。她有一个家，拥有所有必要的生活用品：沙发、淋浴、电视、床、烤箱等等。就像人类一样，她有类似人类的需求，如饥饿、能量、舒适、卫生和乐趣。随着时间的推移，她需要满足她的需求以保持健康。现在我们有了问题，让我们着手解决它，让Sophie完全自主，能够自己决定需要做什么：
- en: '![](img/a866d7e6-e727-4137-948b-ea61468f8983.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a866d7e6-e727-4137-948b-ea61468f8983.jpg)'
- en: 'We can simplify and divide the objectives into two columns: on the left side,
    we put the main objectives of the game and on the right side, the actions the
    character perform. For example, if she is hungry, she needs to move towards the
    kitchen and interact with the fridge. This is exactly the same principle that
    we used to create the automated finite-state machines in the FPS example. But
    this time we''ll explore this concept even further.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将目标简化并分为两列：在左侧，我们放置游戏的主要目标，在右侧，放置角色执行的动作。例如，如果她饿了，她需要走向厨房并与冰箱互动。这正是我们在FPS示例中创建自动化有限状态机所使用的原理。但这次我们将更深入地探索这个概念。
- en: 'Let''s think for a minute about the hunger feeling. Let''s say that when we
    eat breakfast, we fulfill our hunger need and we don''t feel hungry anymore. At
    this point, we can say that our hunger necessity is at 100%, right? Imagine that
    a few minutes have passed by and now we are at 98%; why we don''t go right on
    to fulfill the 2% that is missing? We can say that feeling hungry is a state where
    we are no longer full and not necessarily that we are empty and because of that
    we switch our priorities towards other necessities. So it''s important to remember
    that when developing an autonomous AI character: he needs to have that thought
    in mind and not go to eat soon as he loses 1% of food. That would not look like
    human behavior; we tend to balance everything, otherwise we would sleep five minutes
    and work five, not so healthy or productive perhaps because it''s not enough to
    fall asleep and isn''t enough to start working. So, we sleep a fair number of
    hours to compensate for the other time that we are awake, and we eat a fair number
    of food to remain fulfilled for a few hours. We can make judgment decisions and
    decide that we are a little bit hungry but we need to finish the work first. Also,
    we make comparative judgments, for example, I''m hungry but I''m tired even more.
    It is important to understand our behavior when creating a virtual human being
    like Sophie because otherwise it will act like a robot.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微思考一下饥饿感。假设当我们吃早餐时，我们满足了饥饿需求，不再感到饥饿。在这个时候，我们可以说我们的饥饿需求是100%，对吧？想象一下，几分钟过去了，现在我们处于98%；为什么我们不立即去满足那缺失的2%呢？我们可以这样说，感到饥饿是一种我们不再感到饱胀的状态，并不一定意味着我们感到空虚，因此我们调整我们的优先级，转向其他需求。所以，在开发一个自主AI角色时，重要的是要记住这一点：当他失去1%的食物时，他不应该立即去吃东西。这样看起来不像人类行为；我们倾向于平衡一切，否则我们可能会睡五分钟，工作五分钟，这可能不够健康或高效，因为不足以入睡，也不足以开始工作。所以，我们睡足够多的时间来补偿我们醒着的时间，我们吃足够多的食物来保持满足感几个小时。我们可以做出判断决策，决定我们有点饿，但我们需要先完成工作。此外，我们还会做出比较判断，例如，我饿了，但我更累。在创造像索菲这样的虚拟人类时，理解我们的行为是很重要的，否则它将表现得像机器人。
- en: 'To help Sophie determine what is more important at any specific moment, we''ll
    be using percentages and then she will be able to compare and decide what she
    wants to do. Before complicating it too much, let''s start writing the basic information
    in our code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助索菲在任何特定时刻确定什么更重要，我们将使用百分比，然后她将能够比较并决定她想要做什么。在我们过于复杂化之前，让我们先在我们的代码中写下基本信息：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We wrote down the basic variables relating to the necessities of the character
    that we are creating. As time goes by, those values will decrease, with different
    attributed values depending on necessity. Also we have an `Overall` variable that
    serves to calculate the overall situation of the character and could perfectly
    represent the mood of our virtual human being. That will be an important factor
    and will help Sophie to decide what is the best option for her.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们记录了我们正在创造的角色所需的基本变量。随着时间的推移，这些值将会减少，不同的属性值取决于需求。此外，我们还有一个`总体`变量，用于计算角色的整体情况，并且可以完美地代表我们虚拟人类的情绪。这将成为一个重要因素，并帮助索菲决定什么是对她最好的选择。
- en: 'Now let''s individualize each necessity and create a decision tree for all
    of them. To do so, we need to plan the process of decision-making that Sophie
    will think through before choosing any action. Let''s start with the hunger necessity:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为每个需求进行个性化处理，并为它们创建一个决策树。为了做到这一点，我们需要规划索菲在选择任何行动之前会思考的决策过程。让我们从饥饿需求开始：
- en: '![](img/b695bc1d-e584-408b-9d9c-f7c5eb25f87b.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b695bc1d-e584-408b-9d9c-f7c5eb25f87b.jpg)'
- en: 'If Sophie feels hungry and she decides that is a priority, these would be the
    steps that she will follow. First she feels hungry and then asks herself if she
    has enough food; to answer that, she moves towards the fridge and checks whether
    she has. If the answer is yes, she moves on, cooks, and finally eats. In the event
    any of the segments can''t be accomplished, the process will be interrupted and
    she will move on to a different priority. Let''s say that she only has food in
    her fridge if she goes to work and for every day of work she receives, for example,
    two days of food. So going to work will become a priority very soon if she wants
    to keep healthy and alive:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果索菲感到饥饿并且认为这是一个优先事项，她将遵循以下步骤。首先，她感到饥饿，然后问自己是否有足够的食物；为了回答这个问题，她走向冰箱并检查是否有。如果答案是肯定的，她将继续前进，做饭，最后吃饭。如果任何一段无法完成，过程将被中断，她将转向不同的优先事项。比如说，如果她去上班，冰箱里才有食物，而且她每工作一天，比如，可以得到两天的食物。所以，如果她想要保持健康和活着，她很快就会把去上班变成一个优先事项：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code we have an example of how the decision tree can be represented
    in our code. We''ll continue writing what she will be doing for every necessity,
    and once we have that done, we can determine how she will prioritize and decide
    which necessity needs to be taken care of first:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个例子说明如何在我们的代码中表示决策树。我们将继续编写她将进行的每个需求，一旦完成，我们就可以确定她将如何优先排序，并决定哪个需求需要首先处理：
- en: '![](img/4c324985-1690-403e-ba53-58541902eba8.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c324985-1690-403e-ba53-58541902eba8.jpg)'
- en: 'The next one on the list is energy:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的下一个是能量：
- en: '![](img/d4cb0c20-d3e8-4651-8678-2f9d478a3f55.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4cb0c20-d3e8-4651-8678-2f9d478a3f55.jpg)'
- en: 'If Sophie feels sleepy and she decides that is a priority, these will be the
    steps that she follows. First, she feels sleepy and then asks herself if she has
    to work. If she has free time then she will make a final judgment and decide whether
    she needs to go to the bathroom before sleeping. Once every state is approved,
    she can finally complete her goal and go to sleep. We can see an example of how
    it could be represented in the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果索菲感到困倦并且认为这是一个优先事项，她将遵循以下步骤。首先，她感到困倦，然后问自己是否需要工作。如果她有空闲时间，她将做出最终判断，决定是否需要在睡觉前去洗手间。一旦所有状态都得到批准，她最终可以完成目标并去睡觉。我们可以看到以下代码中如何表示这个过程：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s assume that, for every hour that Sophie sleeps, she gains +10 points
    of Energy but loses 10 points of Hygiene. She''ll need to confirm first that she
    won''t need to use the bathroom in the middle of her sleep and for that we compare
    the number of Energy points that she needs with the number of Hygiene points:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，对于索菲每睡一小时，她获得+10点的能量，但失去10点的卫生。她首先需要确认她不会在睡眠中需要使用洗手间，为此我们比较她需要的能量点和卫生点：
- en: '![](img/b7be3456-8e13-4249-ac9c-46ce09cf374d.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b7be3456-8e13-4249-ac9c-46ce09cf374d.jpg)'
- en: 'Let''s move on to the Comfort necessity. This one is a little bit special because
    we can assign two objectives at the same time while gaining Comfort points. For
    example, she will be capable of deciding whether she wants to eat sitting on a
    chair or not. The same can be applied when she is watching TV. This is an important
    example that can be applied in many games, where a character decides to do two
    things at the same time when he has the opportunity and understands that it is
    important to do so. In the example that follows, we''ll be taking that into consideration:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到舒适需求。这个需求有一点特别，因为我们可以在获得舒适点的同时同时设定两个目标。例如，她将能够决定是否想坐在椅子上吃饭。同样的情况也适用于她看电视时。这是一个重要的例子，可以在许多游戏中应用，当角色有机会同时做两件事并且理解这样做的重要性时。在接下来的例子中，我们将考虑这一点：
- en: '![](img/8b44cb82-c245-4e28-bdbe-30366f45dc26.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b44cb82-c245-4e28-bdbe-30366f45dc26.jpg)'
- en: 'If Sophie feels uncomfortable, she will check first whether at that moment
    she is doing something. This question can only have two answers: yes or no. If
    the answer is yes, she''ll need to think whether it is possible for her to keep
    on doing it seated. Otherwise, she''ll finish what she is doing at that moment
    and then will start asking the same question. If possible or available, she''ll
    finally sit and get comfortable. We can check an example of how it should look
    in the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果索菲感到不舒服，她首先会检查在那个时刻她是否正在做某事。这个问题只能有两个答案：是或否。如果答案是是，她需要思考是否有可能坐着继续做这件事。否则，她会完成当时正在做的事情，然后开始提出同样的问题。如果可能或可行，她最终会坐下并感到舒适。以下代码示例展示了它应该如何看起来：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We added three more variables: `isEating`, `isWatchingTV`, and `Busy`. This
    will help her decide the best option, taking into consideration those three values.
    In the event that she feels uncomfortable but is eating or watching TV, she can
    perform both of the actions together. Otherwise, she needs to compare the rest
    of the necessities and judge whether it''s more important to sit instead of doing
    other things. In the event that she is doing something at that moment and it''s
    not possible for her to sit - let''s say, for example, that she is taking a shower
    or working - she''ll ignore the fact that she feels uncomfortable and, as soon
    as Sophie has the opportunity, she''ll sit and gain Comfort points:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们增加了三个变量：`isEating`、`isWatchingTV`和`Busy`。这将帮助她根据这三个值决定最佳选项。如果她感到不舒服但正在吃饭或看电视，她可以同时执行这两个动作。否则，她需要比较其他需求，并判断是否比坐着做其他事情更重要。如果她当时正在做某事且无法坐下——比如说，她正在洗澡或工作——她会忽略自己感到不舒服的事实，一旦索菲有机会，她会坐下并获得舒适度分数：
- en: '![](img/d1477cb1-ea98-4ac2-8be5-acf32e8313fb.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1477cb1-ea98-4ac2-8be5-acf32e8313fb.jpg)'
- en: There remain two more necessities to finish this example and soon we will have
    an AI character that could live by itself without the need for someone to control
    and decide what is best for her. We are developing an AI system that works on
    a simulation game but this same method can also be used on different genres of
    game. Imagine a real-time strategy game where the workers make autonomous decisions
    and, instead of being idle waiting for orders, immediately go to work on what
    they think is more important at that moment and, as soon as other priorities arrive,
    switch to another occupation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 还剩下两个必要条件来完成这个示例，不久我们就会有一个可以独立生活的AI角色，无需有人控制并决定对她最好的事情。我们正在开发一个基于模拟游戏的AI系统，但这种方法也可以用于不同类型的游戏。想象一下实时策略游戏，其中工人会做出自主决定，而不是无所事事地等待命令，而是立即开始处理他们认为当时更重要的事情，一旦其他优先事项出现，就切换到另一项工作。
- en: 'Let''s move on to the next objective, Hygiene. Just for the sake of simplicity,
    we will use this necessity as everything related to the bathroom:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一个目标，卫生。为了简化起见，我们将使用这个需求来代表所有与洗手间相关的事情：
- en: '![](img/9b1cd9c2-d399-4d73-9e60-d073cda1cccf.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b1cd9c2-d399-4d73-9e60-d073cda1cccf.jpg)'
- en: The hygiene necessity is simpler than the previous ones; it's just a question
    of whether she is available or not to take a shower. The extra factor that we'll
    be using on this one is that, no matter the circumstances, going to the bathroom
    is the most important one and she will immediately pause what she is doing and
    go straight towards the bathroom.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 卫生需求比之前的简单；只是问她是否有时间洗澡的问题。我们将在这个问题上使用的一个额外因素是，无论情况如何，去洗手间是最重要的，她会立即暂停正在做的事情，直接走向洗手间。
- en: 'The only things that she could possibly do while taking a shower are brushing
    her teeth or any other sub-segment of the hygiene criterion. But for now, let''s
    stick with as few options as possible to test the AI; once we have the basic functions
    working properly, we then can start adding more actions. For prototype purposes,
    that is also a good methodology to follow: by first having the basic functions
    working, we can move on and gradually add more details. Now let''s take a look
    at an example of how the `Hygiene` function would look:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在洗澡时，她可能做的唯一事情是刷牙或任何其他与卫生标准相关的子段。但就目前而言，让我们尽量减少选项以测试AI；一旦基本功能正常工作，我们就可以开始添加更多动作。为了原型设计的目的，这也是一种好的方法：首先让基本功能正常工作，然后我们可以继续并逐步添加更多细节。现在让我们看看`Hygiene`函数的一个示例：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](img/b750f69f-6355-489f-a76c-76c563120ff5.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b750f69f-6355-489f-a76c-76c563120ff5.jpg)'
- en: 'Let''s jump right away into the next and last necessity, Fun. This one will
    have the opportunity to be the most flexible of them all, because we can eat and
    watch TV at the same time, we can sit and watch TV at the same time, and we can
    eat sitting down while watching TV. We give the option to our AI to be able to
    do three distinct things at the same time. At first glance, allowing our character
    to boost her points in three different necessities looks ideal, but we''ll be
    discussing that later on. For now, let''s just focus on the Fun factor and plan
    the steps that she''ll be using to determine whether she needs to, and can, watch
    TV:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接跳到下一个也是最后一个必要条件：乐趣。这个条件将有机会成为最灵活的一个，因为我们可以在吃饭和看电视的同时进行，我们可以坐着看电视，我们可以在看电视的同时坐着吃饭。我们给我们的AI提供同时做三件事的选择。乍一看，允许我们的角色在三个不同的必要条件中提高她的分数似乎是理想的，但我们稍后会讨论这个问题。现在，让我们只关注乐趣因素，并规划她将使用的步骤来判断她是否需要并且可以看电视：
- en: '![](img/a13f5dc9-42e2-410b-8117-d8bbdadbbaf0.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a13f5dc9-42e2-410b-8117-d8bbdadbbaf0.jpg)'
- en: 'If Sophie feels bored, she''ll start asking herself whether she can watch TV.
    First, if she is available, she''s free to watch TV and, in the default state,
    she watches TV seated. But if she is busy at that time, she needs to ask herself
    whether she can watch TV at the same time that she is doing whatever she''s doing
    (in this example, that represents eating, sitting, or both at the same time).
    Once again, for the sake of simplicity, let''s assume that she doesn''t need to
    reach the television in order to turn it on. We can see an example of how that
    could be represented in our code as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果索菲感到无聊，她会开始问自己是否可以看电视。首先，如果她有空闲时间，她可以自由地看电视，在默认状态下，她坐着看电视。但如果她那时正忙，她需要问自己是否可以在她做任何事的同时看电视（在这个例子中，这代表吃饭、坐着或同时进行）。再次为了简单起见，让我们假设她不需要走到电视前才能打开它。我们可以看到以下是如何在我们的代码中表示这个例子：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we conclude the necessity behaviors using different approaches for
    each one. Doing this, we can ensure that she will know what to do in different
    situations of the game and will always be looking to do something. There are some
    flaws in the AI design that we''ll need to perfect; for example, she can''t decide
    to continue watching TV even if she is hungry or tired. To make that possible,
    we would need to simply add a probability map and use the `Overall` variable to
    define whether she is happy or not; let''s say that, in the event that she''s
    above 50% for happiness, she can decide to watch TV even if she feels tired. All
    of those restrictions can now be assigned to the code and we can continuously
    add more details to the behavior of our character. But, for now, we will just
    focus on two more details: AI balance and dynamic problem-solving.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用不同的方法对每个必要行为进行总结。这样做，我们可以确保她知道在游戏的不同情况下应该做什么，并且总是寻求采取行动。AI设计中存在一些缺陷，我们需要完善；例如，即使她感到饥饿或疲倦，她也不能决定继续看电视。为了实现这一点，我们只需简单地添加一个概率图，并使用`Overall`变量来定义她是否快乐；比如说，如果她的快乐度超过50%，即使她感到疲倦，她也可以决定看电视。所有这些限制现在都可以分配给代码，我们可以不断地为我们的角色行为添加更多细节。但，目前，我们只关注两个额外的细节：AI平衡和动态问题解决。
- en: '![](img/4de89310-035c-4ea4-88d8-8545a62796f3.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4de89310-035c-4ea4-88d8-8545a62796f3.jpg)'
- en: Dynamic game AI balancing
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态游戏AI平衡
- en: 'Another interesting and very useful topic to learn about AI development is
    game difficulty. If we play against a human player, the difficulty of the game
    will solely depend on the experience of the player that is playing against us.
    If they are very skillful with that specific video game, obviously they will have
    a greater advantage against a player who is just starting the game. Usually, video-games
    tend to increase the difficulty step by step, so the player can adapt to it and
    doesn''t get frustrated too soon or simply bored because the game doesn''t offer
    a challenge. Dynamic game difficulty balancing is used to solve this problem,
    by creating an interesting experience for each gamer. To balance the AI character
    using this method, we take into consideration some dynamic game elements that
    can be adjusted according to player experience; those attributes can be the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Speed
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Health
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Magic
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Power
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually, we use these attributes to define the difficulty of the AI character,
    adjusting them to the difficulty desired. Another way to balance the difficulty
    is by adjusting the quantity of weapons and enemies that the player faces during
    the game. When adjusting the difficulty, we also need to be careful to not create
    an enemy that behaves like a rubber band; for example, if the AI car is behind
    the player, it gets significantly faster in order to keep challenging the player.
    When the player is behind the opponent car, that car will decrease its speed and
    this method, if not moderated, can become uninteresting.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'In a generic fighting game, developers usually define AI combat like this:
    if the player is reachable, the AI uses kicks or punches; if not, he goes towards
    the player. Then the difficulty is adjusted by using percentages and time gaps
    between attacks.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: In an FPS shooter, for example, the game AI is adjusted by taking into consideration
    the player performance while in the development stage, where the programmers input
    all the AI stat values and tactics that match the overall performance of the human
    players. For example, if the shoot rate of the player is about 70%, the AI characters
    will use that value to stay relatively close to a human performance.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '*Crash Bandicoot* used *Dynamic Game Difficulty Balancing* not directly in
    the behavior of the AI characters themselves, but rather in the animation speed,
    making it slower if the player was having difficulty passing the level. This difficulty
    adjustment takes place according to the players number of deaths. This is a smart
    and simple way to adjust the difficulty of the AI character, by considering the
    number of times that the player died trying to beat the game.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '*Resident Evil 4*, released in 2005 by Capcom, based the difficulty adjustment
    on the same principle but employed a more complex system. The adjustment took
    into consideration player performance and, without notice, the player was rated
    by the game from one to ten, where one meant that they were not very successful
    in the game and ten that they were very skillful. Taking those rates into consideration,
    enemies would behave differently, being more or less aggressive and taking more
    or less damage. The rating was constantly updated and many things were taken into
    consideration to determine how good the player was, such as how many bullets he
    needed to kill a zombie, how many hits he took, and so on.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 2005年由卡普空发布的 *《生化危机4》* 基于同样的难度调整原则，但采用了更复杂的系统。调整考虑了玩家的表现，并且玩家在不知情的情况下被游戏从一到十进行评级，其中一表示他们在游戏中不太成功，而十表示他们非常熟练。考虑到这些评级，敌人的行为会有所不同，攻击性更强或更弱，受到的伤害更多或更少。评级会不断更新，许多因素都会被考虑来确定玩家的表现如何，例如他们需要多少子弹来杀死一个僵尸，他们受到了多少次打击，等等。
- en: '*Left 4 Dead* also took into consideration how well the player was doing, but
    instead of only increasing the difficulty of the enemies'' AI, they decided to
    change where the enemies would appear, creating a different challenge every time
    the player decided to play the same level. If the player just started the game,
    the enemies would appear in easier places; if the player had already passed that
    level, the enemies would appear in more difficult positions.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*《左4死》* 也考虑了玩家的表现情况，但不是仅仅通过增加敌人AI的难度，而是决定改变敌人出现的位置，每次玩家选择玩同一关卡时都创造不同的挑战。如果玩家刚开始游戏，敌人会出现在较容易的地方；如果玩家已经通过了那个关卡，敌人会出现在更困难的位置。'
- en: To summarize the choices that game developers are making while adjusting the
    difficulty of character AI, we need to mention that the difficulty not always
    is meant to be adjusted or to increase or decrease taking into consideration player
    performance. One great example is simulation games, where it's crucial to meet
    real-life difficulties and not make them more difficult or easier, otherwise it
    won't feel like a simulation. Other examples could be games such as Ghosts'n Goblins
    or, more recently, Dark Souls, where developers explicitly chose to make the game
    hard from start to finish without changing the AI behavior regarding the difficulty.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结游戏开发者调整角色AI难度时所做的选择，我们需要提到，难度并不总是意味着要调整或根据玩家的表现来增加或减少。一个很好的例子是模拟游戏，在这些游戏中，至关重要的是要达到现实生活中的难度，而不是使它们更难或更容易，否则就不会有模拟的感觉。其他例子可以是像《鬼怪猎人》或更近期的《黑暗之魂》这样的游戏，开发者明确选择从始至终使游戏难度很高，而不改变AI行为以适应难度。
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discovered how to create AI characters that make their own
    decisions no matter where we place them by using AFSMs. Then we learned how to
    calculate chance and how to use it in conjunction with the previous techniques
    to create a character that could calculate a better option for his next step.
    Using all of the the set techniques, we moved on to how to use utility-based functions
    to create a human-like character that can behave autonomously. Finally, we talked
    about different ways of adjusting the values that we input in our characters to
    make them balanced compared to player performance. In the next chapter, we'll
    be talking in depth about environment and AI, taking into consideration different
    genres of video game and different types of AI, how the AI should use the available
    space on the map to create a challenge for the player, how to interact with the
    environment, how to use the environment in its favor, and a lot more.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们发现了如何使用有限状态机（AFSM）创建能够自主做出决定的AI角色。然后我们学习了如何计算概率以及如何结合之前的技术使用它来创建一个能够为其下一步计算更好选择的角色。使用所有这些技术，我们继续讨论如何使用基于效用的函数来创建一个类似人类的角色，使其能够自主行动。最后，我们讨论了调整我们输入角色中的值的多种方法，以使它们与玩家的表现相比保持平衡。在下一章中，我们将深入探讨环境和AI，考虑到不同类型的视频游戏和不同类型的AI，AI应该如何使用地图上的可用空间来为玩家创造挑战，如何与环境互动，如何利用环境来为自己谋利，以及更多。
