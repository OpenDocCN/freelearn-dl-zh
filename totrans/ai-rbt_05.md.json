["```py\ndef forward_kinematics(theta1, theta2, theta3, segment_length):\n # Convert degrees to radians\n    theta1_rad = math.radians(theta1)\n    theta2_rad = math.radians(theta2)\n    theta3_rad = math.radians(theta3)\n    # Calculate positions of each joint\n    x1 = segment_length * math.cos(theta1_rad)\n    y1 = segment_length * math.sin(theta1_rad)\n    x2 = x1 + segment_length * math.cos(theta1_rad + theta2_rad)\n    y2 = y1 + segment_length * math.sin(theta1_rad + theta2_rad)\n    x3 = x2 + segment_length * math.cos(theta1_rad + theta2_rad + theta3_rad)\n    y3 = y2 + segment_length * math.sin(theta1_rad + theta2_rad + theta3_rad)\nreturn x3, y3\n```", "```py\n    cd ~/ros2_ws/src\n    ros2 pkg create –build-type ament-cmake ros_xarm\n    src directory where we will store all of the parts we need.\n    ```", "```py\n    pip install xarm\n    ```", "```py\n    xarm_mgr.py, which is short for xarm manager.\n    ```", "```py\n    import rclpy\n    import xarm\n    import time\n    from rlcpy.node import Node\n    from std_msgs.msg import String, Int32MultiArray, Int32\n    ```", "```py\nHighCarry=[9999,500,195,858,618,9999]\nMidCarry=[9999, 500, 500, 807, 443, 9999]\nGrasp = [100,500,151,553,117,9999]\nGraspClose=[700,9999,9999,9999,9999,9999]\nAlign=[500,500,500,500,500,500]\n```", "```py\n    class xarmControl(Node):\n        def __init__(self):\n            super().__init__('xarm_manager') # node name\n            self.publisher = self.create_publisher(Int32MultiArray, 'xarm_pos', 10)\n            self.armAngPub = self.create_publisher(Int32MultiArray, 'xarm_angle', 10)\n    ```", "```py\n    self.cmdSubscribe = self.create_subscription(String, 'RobotCmd', self.cmdCallback,10)\n    ```", "```py\n            self.wristSubscribe = self.create_subscription(Int32, 'xarmWrist', self.wristCallback,10)\n            self.effSubscribe = self.create_subscription(Int32, 'xarmEffector', self.effCallback,10)\n            self.baseSubscribe = self.create_subscription(Int32, 'xarmBase', self.baseCallback,10)\n    ```", "```py\n            self.baseSubscribe = self.create_subscription(\n    Int32MultiArray, 'newArmPos', self.moveArmCallback,10)\n    ```", "```py\n            timer_period = 1.0 # seconds\n            self.timer = self.create_timer(timer_period, self.timer_callback)\n            self.i = 0 # counter\n            try:\n                self.arm = xarm.Controller('USB')\n                print(\"ARM OPEN\")\n            except:\n                self.get_logger().error(\"xarm_manager init NO ARM DETECTED\")\n                self.arm = None\n                print(\"ERROR init: NO ARM DETECTED\")\n            return\n    ```", "```py\n            timer_period = 1.0 # seconds\n            self.timer = self.create_timer(timer_period, self.timer_callback)\n            self.i = 0 # counter\n    ```", "```py\n            try:\n                self.arm = xarm.Controller('USB')\n                print(\"ARM OPEN\")\n            except:\n                self.get_logger().error(\"xarm_manager init NO ARM DETECTED\")\n                self.arm = None\n                print(\"ERROR init: NO ARM DETECTED\")\n            return\n    ```", "```py\n        def timer_callback(self):\n            msg = Int32MultiArray()\n            # call arm and get positions\n            armPos=[]\n            for i in range(1,7):\n                armPos.append(self.arm.getPosition(i))\n            msg.data = armPos\n            self.publisher.publish(msg)\n            # get arm positions in degrees\n            armPos=[]\n            for i in range(1,7):\n                armPos.append(int(self.arm.getPosition(i, True)))\n            msg.data = armPos\n            #print(armPos)\n            self.armAngPub.publish(msg)\n    ```", "```py\n        def cmdCallback(self, msg):\n            self.get_logger().info(\"xarm rec cmd %s\" % msg.data)\n            robotCmd = msg.data\n            if robotCmd==\"ARM HIGH_CARRY\":\n                self.setArm(HighCarry)\n            if robotCmd==\"ARM MID_CARRY\":\n                self.setArm(MidCarry)\n            if robotCmd==\"ARM GRASP_POS\":\n                self.setArm(Grasp)\n            if robotCmd==\"ARM GRASP_CLOSE\":\n                self.setArm(GraspClose)\n            if robotCmd==\"ARM ALIGN\":\n                self.setArm(Align)\n    ```", "```py\n        def wristCallback(self, msg):\n            try:\n                newArmPos = int(msg.data)\n            except ValueError:\n                self.get_logger().info(\"Invalid xarm wrist cmd %s\" % msg.data)\n                print(\"invalid wrist cmd \", msg.data)\n                return\n            # set limits\n            newArmPos = float(min(90.0,newArmPos))\n            newArmPos = float(max(-90.0,newArmPos))\n            self.arm.setPosition(2,newArmPos, True)\n    ```", "```py\n        def effCallback(self, msg):\n        # set just the end effector position\n            try:\n                newArmPos = int(msg.data)\n            except ValueError:\n                self.get_logger().info(\"Invalid xarm effector cmd %s\" % msg.data)\n                return\n            # set limits\n            newArmPos = min(1000,newArmPos)\n            newArmPos = max(0,newArmPos)\n            self.arm.setPosition(1,newArmPos)\n        def baseCallback(self, msg):\n        # set just the base azimuth position\n            try:\n                newArmPos = int(msg.data)\n            except ValueError:\n                self.get_logger().info(\"Invalid xarm base cmd %s\" % msg.data)\n                return\n            # set limits\n            newArmPos = min(1000,newArmPos)\n            newArmPos = max(0,newArmPos)\n            self.arm.setPosition(6,newArmPos)\n    ```", "```py\n    #######################MAIN####################################\n    rclpy.init()\n    print(\"Arm Control Active\")\n    xarmCtr = xarmControl()\n    # spin ROS 2\n    rclpy.spin(xarmCtr)\n    # destroy node explicitly\n    xarmCtr.destroy_node()\n    rclpy.shutdown()\n    ```", "```py\n    import rclpy\n    import time\n    import random\n    from rclpy.node import Node\n    from std_msgs.msg import String, Int32MultiArray, Int32\n    from sensor_msgs.msg import Image\n    from vision_msgs.msg import Detection2D\n    from vision_msgs.msg import ObjectHypothesisWithPose\n    from vision_msgs.msg import Detection2DArray\n    import math\n    import pickle\n    ```", "```py\n    global learningRate = 0.1 # learning rate\n    def round4(x):\n     return (math.round(x*4)/4)\n    # function to restrict a variable to a range. if x < minx, x=min x,etc.\n    def rangeMinMax(x,minx,maxx):\n     xx = max(minx,x)\n     xx = min(maxx,xx)\n     return xx\n    def sortByQ(listByAspect):\n     return(listByAspect[2])\n    ```", "```py\n    class LearningHand(Node):\n        def __init__(self):\n            super().__init__('armQLearn') # node name\n            # we need to both publish and subscribe to the RobotCmd topic\n    self.armPosSub = self.create_subscription(Int32MultiArray, \"xarm_pos\", self.armPosCallback, 10)\n            self.cmdSubscribe = self.create_subscription(String, 'RobotCmd', self.cmdCallback,10)\n            self.cmdPub = self.create_publisher(String, 'RobotCmd', 10)\n     self.wristPub = self.create_publisher(Int32,'xarmWrist', 10)\n     # declare parameter for number of repetitions\n     self.declare_parameter('ArmLearningRepeats', rclpy.Parameter.Type.INTEGER)\n     # get the current value from configuration\n     self.repeats = self.get_parameter('ArmLearningRepeats').get_parameter_value().int_value\n    ```", "```py\n     self.mode = \"idle\"\n     self.armInterface = ArmInterface()\n     # define the state space\n     self.stateActionPairs = []\n     # state space is the target aspect and the hand angle\n     # aspect is length / width length along x axis(front back) width on y axis)\n     aspects = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75]\n     handAngles = [90, -45, 0, 45] # note +90 and -90 are the same angle\n     for jj in range(0,len(aspects)):\n       for ii in range(0,4):\n         self.stateActionPairs.append([aspects[jj], handAngles[ii],0.0])\n    ```", "```py\n     def sndCmd(self,msgStr):\n         msg = String()\n         msg.data = msgStr\n         self.cmpPub.publish(msg)\n     def setHandAngle(self,ang):\n         msg = Int32()\n         msg.data = ang\n         self.wristPub.publish(msg)\n     def armPosCallback(self,msg):\n         self.currentArmPos = msg.data\n     def setActionPairs(self,pairs):\n         self.stateActionPairs = pairs\n    ```", "```py\n     def training(self, aspect):\n       # get the aspect from the vision system\n       #aspect = 1.0 # start here\n       stateActionPairs.sort(key=sortByQ) # sort by Q value\n       if len(stateActionPairs)<1:\n         #error - no aspects found!\n         #\n         self.get_logger().error(\"qLearningHand No Aspect for\n         Training\")\n         return\n       else:\n         mySetup = stateActionPairs[0] # using the highest q value\n         handAngle = mySetup[1]\n         myOldQ = mySetup[2]\n    ```", "```py\n         sndCmd(\"ARM MID_CARRY\")\n         timer.pause(1.0)\n         sndCmd(\"ARM GRASP\")\n         time.sleep(1.0)\n         setHandAngle(handAngle)\n         time.sleep(0.3)\n         # close the gripper\n         sndCmd(\"ARM GRASP_CLOSE\")\n         time.sleep(0.5)\n         # now raise the arm\n         sndCmd(\"ARM MID_CARRY\")\n         time.sleep(1.0)\n    ```", "```py\n         #check to see if grip is OK\n         handPos = self.currentArmPos[0]\n         gripSuccess = False\n         if handPos > 650: ## fail\n               gripSuccess = -1 # reward value of not gripping\n         else: # success!\n               gripSuccess = +1 # reward value of gripping\n    ```", "```py\n     # the Bellman Equation\n     ### Q(s, a) = Q(s, a) + α * [R + γ * max(Q(s', a')) - Q(s, a)]\n     newQ = myOldQ + (learningRate*(gripSuccess))\n     mySetup[2]=newQ\n    ```", "```py\n     foundStateActionPair = False\n     # re insert back into q learning array\n     for i in range (0,len(stateActionPairs):\n         thisStateAction = stateActionPairs[i]\n         if thisStateAction[0] == mySetup[0] and \n    thisStateAction[1] == mySetup[0]:\n             foundStateActionPair=True\n             stateActionPairs[2]=mySetup[2] # store the new q value in the table\n         if not foundStateActionPair:\n             # we don't have this in the table - let's add it\n             stateActionPairs.append(mySetup)\n     input(\"Reset and Press Enter\") # wait for enter key to continue\n    ```", "```py\n     def cmdCallBack(self,msg):\n       robotCmd = msg.data\n       if robotCmd == \"GoLearnHand\":\n         self.mode = \"start\"\n       if robotCmd == \"StopLearnHand\":\n         self.mode = \"idle\"\n    ```", "```py\n    class ArmInterface():\n     init(self):\n       self.armPosSub = self.create_subscription(Int32MultiArray, 'xarm_pos',self.armPosCallback, 10)\n       self.armAngSub = self.create_subscription(Int32MultiArray, 'xarm_angle',self.armAngCallback, 10)\n       self.armPosPub = self.create_publisher(Int32MultiArray, 'xarm')\n     def armPosCallback(self,msg):\n       self.armPos = msg.data\n     def armAngCallback(self, msg):\n       self.armAngle = msg.data\n       # decoder ring: [grip, wrist angle, wrist pitch, elbow pitch, \n      sholder pitch, sholder yaw]\n     def setArmPos(self,armPosArray):\n       msg = Int32MultiArray\n       msg.data = armPosArray\n       self.armPosPub.publish(msg)\n    ```", "```py\n    ### MAIN ####\n    # persistent training file to opeate the arm\n    ArmTrainingFileName = \"armTrainingFile.txt\"\n    armIf = ArmInterface()\n    armTrainer = LearningHand()\n    #open and read the file after the appending:\n    try:\n     f = open(ArmTrainingFileName, \"r\")\n     savedActionPairs = pickle.load(f)\n     armTrainer.setActionPairs(savedActionPairs)\n     f.close()\n    except:\n     print(\"No Training file found\")\n     self.get_logger().error(\"qLearningHand No Training File Found armTrainingFile.txt\")\n    ```", "```py\n    aspectTest = [1.0, 0.5, 1.5,2]\n    trainingKnt = 20\n    for jj in aspectTest:\n     for ii in range(0,trainingKnt):\n       print(\"Starting Training on Aspect \", jj)\n       armTrainer.training(jj)\n    ```", "```py\n    f = open(\"ArmTrainingFileName\", \"w\")\n    # open file in write mode\n    pickle.dump(armTrainer.stateActionPairs,f)\n    print(\"Arm Training File Written\")\n    f.close()\n    ```", "```py\n    def computeFitness(population, goal, learningRate, initialPos): \n      fitness = []\n      gamma = 0.6 \n      state=initialPos \n      index = 0\n      for chrom in population:\n        value=0\n        for allele in chrom:\n          action = ACTIONMAT[allele]\n          indivFit, state =\n          predictReward(state,goal,action,learningRate) value += \n          indivFit\n          if indivFit > 95:\n            # we are at the goal – snip the DNA here \n            break\n        fitness.append([value,index]) \n        index += 1\n      return fitness\n    ```", "```py\n    def make_new_individual():\n      # individual length of steps \n      lenInd = random.randint(10,60)\n      chrom = [] # chromosome description \n      for ii in range(lenInd):\n        chrom.append(randint(26)) \n      return chrom\n    ```", "```py\n    # select an individual in proportion to its value\n    def roulette(items):\n     total_weight = sum(item[0] \n     for item in items) \n     weight_to_target = random.uniform(0, total_weight) \n     for item in items:\n      weight_to_target -= item[0] \n      if weight_to_target <= 0: \n       return item\n    # main Program\n    INITIAL_POS = [127,127,127]\n    GOAL=[-107.39209423, -35.18324771]\n    robotArm=RobotArm() \n    robotArm.setGoal(GOAL) \n    population = 300\n    learningRate = 3\n    crossover_chance = .50\n    mutate_chance = .001 \n    pop = []\n    ```", "```py\n    for i in range(population): pop.append(make_new_individual())\n      trainingData=[] epochs = 100\n    ```", "```py\n    for jj in range(epochs):\n      # evaluate the population\n      fitnessList = computeFitness(pop,GOAL,learningRate, INITIAL_POS)\n    ```", "```py\n    fitnessList.sort(reverse=True)\n    ```", "```py\n    fitLen = 150\n    fitnessList = fitnessList[0:fitLen] # survival of the fittest...\n    ```", "```py\n     hoff = pop[fitnessList[0][1]]\n     print(\"HOF = \",fitnessList[0])\n    ```", "```py\n    trainingData.append(fitnessList[0][0])\n    newPop = []\n    for ddex in fitnessList: newPop.append(pop[ddex[1]])\n      print (\"Survivors: \",len(newPop))\n    ```", "```py\n    # crossover\n    # pick to individuals at random # on the basis of fitness\n    numCross = population-len(newPop)-10 print (\"New Pop Crossovers\",numCross) # #\n    # add 5 new random individuals for kk in range(10):\n    newPop.append(make_new_individual()) \n    for kk in range(int(numCross)):\n     p1 = roulette(fitnessList)[1] \n     p2 = roulette(fitnessList)[1]\n     chrom1 = pop[p1]\n     chrom2 = pop[p2]\n     lenChrom = min(len(chrom1),len(chrom2)) xover = \n     randint(lenChrom)\n     # xover is the point where the chromosomes cross over newChrom \n     = chrom1[0:xover]+chrom2[xover:]\n    ```", "```py\n    # now we do mutation bitDex = 0\n    for kk in range(len(newChrom)-1): \n      mutDraw = random.random()\n      if mutDraw < mutate_chance: # a mutation has occured! \n       bit = randint(26) \n       newChrom[kk]=bit\n       print (\"mutation\") \n    newPop.append(newChrom)\n    ```", "```py\n    # welcome the new baby from parent 1 (p1) and parent 2 (p2) print(\"Generation: \",jj,\"New population = \",len(newPop)) pop=newPop\n    mp.plot(trainingData) mp.show()\n    ```"]