- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Setting Up Your Robot
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置您的机器人
- en: This chapter begins with some background on my thoughts on what a robot is,
    and what robots are made of – a fairly standard list of parts and components.
    This chapter aims to allow you to duplicate the exercises and use the source code
    that is found throughout the book. I will describe how I set up my environments
    for development, what tools I used to create my code, and how to install the **Robotic
    Operating System version 2** (**ROS 2**). The assembly of Albert, the robot I
    use for all the examples, is covered in the GitHub repository for this book. There
    are many other types and configurations of robots that can work with the code
    in this book with some changes. I’ll try to provide all the shortcuts I can, including
    a full image of my robot’s SD card, in the Git repo.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从我对机器人是什么以及机器人由什么组成的思考开始，这是一个相当标准的部件和组件列表。本章旨在让您能够复制练习并使用书中找到的源代码。我将描述我是如何设置我的开发环境的，我使用了哪些工具来创建我的代码，以及如何安装**机器人操作系统版本2**（**ROS
    2**）。我使用的示例机器人Albert的组装可以在本书的GitHub仓库中找到。还有许多其他类型和配置的机器人可以通过对本书中的代码进行一些修改来与之配合工作。我将尝试提供所有可能的快捷方式，包括我机器人SD卡的全图，在Git仓库中。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the anatomy of a robot
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解机器人的解剖结构
- en: Introducing subsumption architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍吸收架构
- en: A brief introduction to ROS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS简介
- en: 'Software setup: Linux, ROS 2, Jetson Nano, and Arduino'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件设置：Linux，ROS 2，Jetson Nano，和Arduino
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete the practical exercises in this chapter, you will need the requirements
    specified in the *Preface* at the beginning of this book. The code for this chapter
    can be found at [https://github.com/PacktPublishing/Artificial-Intelligence-for-Robotics-2e/](https://github.com/PacktPublishing/Artificial-Intelligence-for-Robotics-2e/).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章中的实践练习，您将需要本书开头**前言**中指定的要求。本章的代码可以在[https://github.com/PacktPublishing/Artificial-Intelligence-for-Robotics-2e/](https://github.com/PacktPublishing/Artificial-Intelligence-for-Robotics-2e/)找到。
- en: Understanding the anatomy of a robot
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解机器人的解剖结构
- en: 'A robot is a machine that is capable of carrying out complex actions and behaviors
    by itself. Most robots are controlled by a computer or digital programmable device.
    Some key characteristics of robots are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人是一种能够自行执行复杂动作和行为的技术设备。大多数机器人由计算机或数字可编程设备控制。机器人的一些关键特性如下：
- en: '**Automation**: Robots can operate automatically without direct human input,
    based on their programming. This allows them to do repetitive or dangerous tasks
    consistently.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化**：机器人可以在没有直接人类输入的情况下自动运行，基于它们的编程。这使得它们可以持续地执行重复性或危险的任务。'
- en: '**Sensors**: Robots use sensors such as cameras, optics, lidar, and pressure
    sensors to gather information about their environment so they can navigate and
    interact. This sensory information is processed to determine what actions the
    robot should take.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传感器**：机器人使用摄像头、光学、激光雷达和压力传感器等传感器来收集有关其环境的信息，以便它们可以导航和交互。这些感官信息被处理以确定机器人应采取哪些行动。'
- en: '**Programming**: A robot’s *brain* consists of an onboard computer or device
    that runs code and algorithms that define how it will behave. Robots are programmed
    by humans to perform desired behaviors.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编程**：机器人的“大脑”由一个运行代码和算法的机载计算机或设备组成，这些代码和算法定义了它的行为方式。机器人由人类编程以执行所需的行为。'
- en: '**Movement**: Most robots are able to move around to some degree through wheels,
    legs, propellers, or other locomotion systems. This allows them to travel through
    environments to perform tasks.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动**：大多数机器人能够通过轮子、腿、螺旋桨或其他运动系统在一定程度上移动。这使得它们能够在环境中移动以执行任务。'
- en: '**Interaction**: Advanced robots can communicate with humans through voice,
    visual displays, lights, sounds, physical gestures, and more. This allows useful
    human-robot interaction and work.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互**：高级机器人可以通过语音、视觉显示、灯光、声音、物理手势等方式与人类进行交流。这允许有用的人类-机器人交互和工作。'
- en: '**Autonomy**: While robots are programmed by humans, they have a degree of
    self-governance and independence in how they meet their objectives. The ability
    to take action and make decisions without human oversight is their autonomy.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自主性**：虽然机器人由人类编程，但它们在实现目标的方式上具有一定的自我治理和独立性。在没有人类监督的情况下采取行动和做出决策的能力是它们的自主性。'
- en: In summary, a robot integrates automation, sensing, movement, programming, and
    autonomy to reliably carry out jobs that may be complex, repetitive, unsafe, or
    otherwise unsuitable for humans. They come in many shapes and sizes, from industrial
    robotic arms to social companion robots to autonomous self-driving cars.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，机器人集成了自动化、感知、移动、编程和自主性，以可靠地执行可能复杂、重复、不安全或不适于人类的工作。它们形状和大小各异，从工业机器人臂到社交伴侣机器人，再到自动驾驶汽车。
- en: 'There is a fairly standard collection of components and parts that make up
    the vast majority of robots. Even robots as outwardly different as a self-driving
    car, the welding robot that built the car, and a Roomba vacuum cleaner have a
    lot of the same components or parts. Some will have more, and some will have less,
    but most mobile robots will have the following categories of parts:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个相当标准的组件和部件集合，构成了绝大多数机器人的主体。即使是外表差异很大的自动驾驶汽车、制造汽车的焊接机器人，以及Roomba吸尘器，它们也有很多相同的组件或部件。有些可能会有更多，有些可能会有更少，但大多数移动机器人将具有以下几类部件：
- en: '![Figure 2.1 – Block diagram of a typical mobile robot](img/B19846_02_1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 典型移动机器人的框图](img/B19846_02_1.jpg)'
- en: Figure 2.1 – Block diagram of a typical mobile robot
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 典型移动机器人的框图
- en: 'Let’s look at these components in greater detail:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些组件：
- en: '**Computer**: A unit that runs the programming that controls the robot. This
    can be a traditional computer, a microcontroller, a **single board computer**
    (**SBC**) like we have, or some other sort of processor that sends and receives
    commands. Robot arms and some types of industrial robots will use a **Programmable
    Logic Controller** (**PLC**), which is a special type of controller that applies
    logic (*AND*, *OR*, *NOT*) to various inputs to produce an output. For a computer
    to send commands to the robot and receive telemetry, we’ll need some sort of sensor
    interface, such as a USB port, serial port, **General Purpose Input/Output** (**GPIO**)
    port, or a network interface such as Ethernet or Wi-Fi.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算机**：运行控制机器人的程序的单元。这可以是一台传统计算机、一个微控制器、一个**单板计算机**（**SBC**）如我们所拥有的，或者某种其他类型的处理器，它发送和接收命令。机器人臂和一些类型的工业机器人将使用**可编程逻辑控制器**（**PLC**），这是一种特殊的控制器，它将逻辑（*AND*、*OR*、*NOT*）应用于各种输入以产生输出。为了使计算机能够向机器人发送命令并接收遥测数据，我们需要某种类型的传感器接口，例如USB端口、串行端口、**通用输入/输出**（**GPIO**）端口，或者如以太网或Wi-Fi之类的网络接口。'
- en: '**Control Station** or **Human/Robot Interface** (**HRI**): Robots are designed
    to perform tasks, which requires that the operator must have some means to send
    and receive data from the robot and to supervise that the robot is behaving correctly.
    We will be using a laptop or desktop computer for this function, and we will talk
    to the robot via a wireless network. Our control station sends commands to the
    robot and receives **telemetry** from the robot in the form of **data**, **video**,
    or **audio**.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制站**或**人机界面**（**HRI**）：机器人被设计来执行任务，这要求操作员必须有一些方式来发送和接收来自机器人的数据，并监督机器人是否表现正确。我们将使用笔记本电脑或台式计算机来完成这个功能，并且我们将通过无线网络与机器人进行通信。我们的控制站向机器人发送命令，并从机器人那里接收**遥测数据**，这些数据以**数据**、**视频**或**音频**的形式存在。'
- en: '**Radio** or **Data Link**: Mobile robots such as the one we are designing
    in this book are capable of moving and exploring their environment. While it is
    possible to send commands to a robot over a tether or wire, the preferred way
    is to use a radio link. The ubiquitous availability of wireless networks such
    as Wi-Fi and cellular data services has made creating data links a lot easier.
    I have had a lot of robot projects where a network link was unavailable or impractical,
    and a custom radio solution needed to be devised. Other types of radio used in
    robots include Bluetooth, Zigbee, and various mesh network systems, such as Flutter.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无线电**或**数据链路**：移动机器人，如我们在本书中设计的机器人，能够移动和探索它们的环境。虽然通过绳索或电线向机器人发送命令是可能的，但首选的方式是使用无线电链路。无线网络如Wi-Fi和蜂窝数据服务的普遍可用性使得创建数据链路变得容易得多。我有很多机器人项目，其中网络链路不可用或不切实际，需要设计定制无线电解决方案。在机器人中使用的其他类型的无线电包括蓝牙、Zigbee以及各种网状网络系统，如Flutter。'
- en: '**Motors** or **Effectors**: Our definition of a robot includes the ability
    for **self-propulsion**; that is, the robot is able to move. In order to move,
    the robot needs a motor or set of motors. Our robot, Albert, has ten motors, four
    for driving and six to control the robot arm and hand. Motors convert electricity
    into motion. There are many different types, and picking the right motor is a
    challenge. You must match the torque (how hard the motor can pull), the speed
    of the motor shaft in revolutions per minute, and voltage. Here are some key factors
    to consider when selecting a motor for a robot drive system:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电机**或**执行器**：我们定义的机器人包括**自主推进**的能力；也就是说，机器人能够移动。为了移动，机器人需要电机或一组电机。我们的机器人，阿尔伯特，有十个电机，四个用于驱动，六个用于控制机器人手臂和手。电机将电能转化为运动。有各种不同的类型，选择正确的电机是一项挑战。你必须匹配扭矩（电机能拉多硬），电机轴的转速（每分钟的转数），以及电压。以下是选择机器人驱动系统电机时需要考虑的一些关键因素：'
- en: '**Torque**: Consider the torque required for your robot’s movements and payload
    handling. More torque allows faster acceleration and the ability to handle heavier
    loads. If there is insufficient torque, the robot will “bog down” or stall the
    motor. An electric motor pulls the most current when it is stalled (it is energized
    but not moving). All that power going nowhere gets turned into heat, which will
    eventually melt the wires or cause a fire.'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扭矩**：考虑机器人运动和负载处理所需的扭矩。更大的扭矩允许更快的加速和承载更重负载的能力。如果扭矩不足，机器人会“陷入困境”或使电机停转。电机在停转时（它被供电但不动）会拉取最多的电流。所有这些无法使用的能量都会转化为热量，最终会熔化电线或引起火灾。'
- en: '**Speed**: Determine the speeds your robot needs to operate at. Higher speeds
    require motors with higher RPM ratings. We only want our robot to go at a modest
    rate. The toys can’t get away.'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：确定机器人需要运行的速度。更高的速度需要具有更高RPM（每分钟转数）的电机。我们只希望我们的机器人以适度的速度行驶。玩具无法逃脱。'
- en: '**Duty cycle**: Choose a motor that can run continuously for the robot’s required
    duty cycle without overheating. Intermittent duty cycles allow smaller, lighter
    motors. We will be driving or moving quite a bit – about 50% of the time, but
    not too fast.'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载周期**：选择一个可以在不过热的情况下连续运行机器人所需负载周期的电机。间歇性负载周期允许使用更小、更轻的电机。我们将驾驶或移动很多——大约50%的时间，但不会太快。'
- en: '**Size and weight**: Large, heavy-duty motors provide a lot of power but may
    constrain robot design. Consider the full drive system size and weight. Remember
    the motor also has to move itself.'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尺寸和重量**：大型、重型电机提供大量功率，但可能会限制机器人设计。考虑整个驱动系统的尺寸和重量。记住电机本身也需要移动。'
- en: '**Control**: Brushless DC motors require electronic speed controllers. Stepper
    motors allow open-loop position control. Servomotors, such as the ones in the
    robot’s arm, have integrated encoders and are controlled by a serial interface.
    The drive motors I used are brushed motors, which are controlled by varying the
    voltage, which we control with **Pulse Width** **Modulation** (**PWM**).'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制**：无刷直流电机需要电子速度控制器。步进电机允许开环位置控制。伺服电机，如机器人手臂中的电机，具有集成编码器，并通过串行接口控制。我使用的驱动电机是刷式电机，通过改变电压来控制，我们通过**脉冲宽度调制**（**PWM**）来控制电压。'
- en: '**Voltage**: High voltages allow more power in small motors. Select a voltage
    that is compatible with other electronics. My battery is 7.2 volts, which matches
    the motors selected.'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电压**：高电压允许小型电机输出更多功率。选择与其它电子设备兼容的电压。我的电池是7.2伏，与选定的电机相匹配。'
- en: '**Noise**: Quiet motors may be required for home/office robots. Brushless,
    gear-reduced motors are quiet but expensive. Geared drivetrains are also noisy.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**噪音**：家庭/办公室机器人可能需要安静的电机。无刷、减速电机很安静但价格昂贵。齿轮传动系统也很嘈杂。'
- en: '**Cost**: More powerful motors cost more. Balance performance needs with budget
    constraints. Albert’s brushed motors are very inexpensive.'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本**：更强大的电机成本更高。在性能需求和预算限制之间取得平衡。阿尔伯特的刷式电机非常便宜。'
- en: Some robot motors also feature gearboxes to reduce the motor speed, basically
    exchanging speed for torque. Albert’s electric motors have reduction gearboxes
    that let the motor run at a faster speed than the wheels.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些机器人电机还配备了变速箱以降低电机速度，基本上是以速度换取扭矩。阿尔伯特的电动电机具有减速变速箱，允许电机以比车轮更快的速度运行。
- en: There are many ways to provide motion to a robot. We call these *things that
    make the robot move* **effectors**. Effectors are only limited by your imagination,
    and include **pneumatics** (things actuated by compressed air), **hydraulics**
    (things actuated by incompressible fluid), **linear actuators** (things that convert
    rotary motion into linear motion), **revolving joints** or **revolute joints**
    (angular joints like an elbow) and even exotic effectors such as **shape-memory
    alloy** or **piezoelectric crystals**, which change shape when electricity is
    applied.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为机器人提供运动的方式有很多。我们把这些使机器人移动的“东西”称为**执行器**。执行器的限制仅在于你的想象力，包括**气动**（由压缩空气驱动的装置）、**液压**（由不可压缩流体驱动的装置）、**线性执行器**（将旋转运动转换为线性运动的装置）、**旋转关节**或**回转关节**（如肘关节一样的角关节）以及甚至一些异类执行器，如**形状记忆合金**或**压电晶体**，当施加电力时它们会改变形状。
- en: '**Servos**: Some of the motors in our robot are a special category of motors
    called **servos**. Servo motors feature a feedback mechanism and a control loop,
    either to maintain a position or a speed. The feedback is provided by some sort
    of **sensor**. The servos we are using consist of a small electric motor that
    drives a gearbox made up of a series of gears that reduce the speed and consequently
    increase the torque of the motor. The sensor used in our case is a potentiometer
    (variable resistor) that can measure the angle of the output gear shaft. When
    we send a command to the servo, it tells the motor to be set to a particular angle.
    The angle is measured by the sensor, and any difference between the motor’s position
    and the sensor creates an error signal that moves the motor in the correct direction.
    You can hear the motor making a lot of noise because the motor turns many times
    through seven reduction gears to make the arm move. The gearbox lets us get a
    lot of torque without drawing a lot of current.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**伺服电机**：我们机器人中的一些电机属于一种特殊的电机类别，称为**伺服电机**。伺服电机具有反馈机制和控制回路，用于维持位置或速度。反馈由某种**传感器**提供。我们使用的伺服电机由一个小型电动机驱动一个由一系列齿轮组成的变速箱，这些齿轮降低了速度并相应地增加了电机的扭矩。我们使用的传感器是一个电位计（可变电阻），可以测量输出齿轮轴的角度。当我们向伺服电机发送命令时，它会告诉电机设置到特定的角度。角度由传感器测量，电机位置与传感器之间的任何差异都会产生一个错误信号，该信号将电机移动到正确的方向。你可以听到电机发出很多噪音，因为电机需要通过七个减速齿轮转动多次才能使机械臂移动。变速箱使我们能够在不消耗太多电流的情况下获得大量的扭矩。'
- en: '*Figure 2**.2* shows how a servo motor is controlled using **Pulse Position
    Modulation** (**PPM**). To control a servo, you must generate a pulse of a specific
    width:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图2.2*展示了如何使用**脉冲位置调制**（**PPM**）来控制伺服电机。要控制伺服电机，你必须生成一个特定宽度的脉冲：'
- en: '![Figure 2.2 – Servo motor control is via PPM signals](img/B19846_02_2.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 伺服电机控制通过PPM信号](img/B19846_02_2.jpg)'
- en: Figure 2.2 – Servo motor control is via PPM signals
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 伺服电机控制通过PPM信号
- en: A short pulse moves the servo to the beginning of its range. A medium pulse
    (1,500 microseconds) is the center of the servo’s position. A late pulse causes
    the servo motor to go to the end of its range. The robot arm I use in this version
    of my robot has a servo controller that comes with the arm hardware. We will be
    controlling the robot arm via serial commands to this controller in [*Chapter
    5*](B19846_05.xhtml#_idTextAnchor159).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 短脉冲将伺服电机移动到其范围的起始位置。中等脉冲（1,500微秒）是伺服电机位置的中间。晚脉冲会导致伺服电机移动到其范围的末端。我在这个版本的机器人中使用的机械臂有一个与机械臂硬件一起提供的伺服控制器。我们将通过串行命令控制这个控制器，具体在[*第五章*](B19846_05.xhtml#_idTextAnchor159)中介绍。
- en: '**Motor Controller or Electronic Speed Control**: Motors are not very useful
    by themselves – you need the ability to convert commands from the control computer
    into motion from the motors. Since motors need more voltage and more current than
    the control computer (our Jetson Nano) can provide, we need a device to turn small
    digital signals into large analog voltage and current. This device is called a
    motor controller. This controller I had to purchase separately, and is composed
    of two parts – an Arduino Uno and a motor controller shield that is attached:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电机控制器或电子速度控制器**：电机本身并不很有用——你需要将控制计算机的命令转换为电机运动的能力。由于电机需要的电压和电流比控制计算机（我们的Jetson
    Nano）能提供的要多，我们需要一个设备将小的数字信号转换为大的模拟电压和电流。这个设备被称为电机控制器。这个控制器我必须单独购买，并且由两部分组成——一个Arduino
    Uno和一个连接到其上的电机控制器屏蔽板：'
- en: "![Figure 2.3 – Motor \uFEFFcontroller shield I used for Albert](img/B19846_02_3.jpg)"
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – 我为Albert使用的电机控制器屏蔽板](img/B19846_02_3.jpg)'
- en: Figure 2.3 – Motor controller shield I used for Albert
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 我为Albert使用的电机控制器屏蔽板
- en: As shown in the image, the four motor wires are attached to the lettered connections.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，四个电机线连接到字母连接处。
- en: Since we have a tank-drive robot (we steer by running the motors at different
    speeds, also called **differential drive**), we also need the motors to be able
    to run forward or backward. The motor controller takes a special input signal
    called a **Pulse Width Modulation** (**PWM**). PWM is a repeating signal where
    the voltage turns on and off. The motor throttle (how fast the motor turns) is
    proportional to the amount the PWM signal stays in the *ON* position.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们有一个坦克式驱动机器人（我们通过以不同速度运行电机来转向，也称为**差速驱动**），我们还需要电机能够向前或向后运行。电机控制器接收一个特殊的输入信号，称为**脉冲宽度调制**（**PWM**）。PWM是一个重复信号，其中电压开启和关闭。电机的油门（电机转速）与PWM信号保持**开启**状态的时间成正比。
- en: 'The motor controller has several kinds of connections, and has to be wired
    carefully due to the high voltages and currents provided. This can be done by
    performing the following steps:'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 电机控制器有几种类型的连接，由于提供的高电压和大电流，必须仔细接线。这可以通过以下步骤完成：
- en: There are two **control wire inputs** – one for speed (the PWM signal) and the
    other is a direction signal. We put the motor in reverse by changing the **direction
    signal** – 1 is forward, and 0 is backward.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有两个**控制线输入**——一个用于速度（PWM信号）和另一个是方向信号。我们通过改变**方向信号**将电机置于倒车状态——1表示前进，0表示后退。
- en: The next thing we need is a **ground** – it is very important that the controller
    sending the PWM signal (in our case, it is the Ardunio Mega) and the motor control
    have their ground lines connected.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来我们需要的是**地面**——确保发送PWM信号（在我们的例子中，是Arduino Mega）和控制电机有它们的接地线连接是非常重要的。
- en: Next, the motor controller needs the **motor voltage** and **current**, which
    we get directly from our battery.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，电机控制器需要**电机电压**和**电流**，这些我们可以直接从我们的电池中获得。
- en: Finally, we connect two wires from each motor to the controller. It is interesting
    that we don’t care which wire goes to which side of the motor, since we can run
    both forward and backward. If the motor is turning the wrong way, just switch
    the two wires. This is the only time you get to say *just reverse the polarity*
    outside of a science fiction movie.
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将每个电机的两根线连接到控制器上。有趣的是，我们并不关心哪根线连接到电机的哪一侧，因为我们可以同时向前和向后运行。如果电机转向错误，只需交换两根线。这是唯一一次在科幻电影之外说“*只需反转极性*”的时候。
- en: We will be covering the specific wiring for the example robot – Albert – in
    the online appendix.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在在线附录中介绍示例机器人——Albert——的具体接线。
- en: '**Sensors**: In order for the robot, which is a machine that can move and react
    to its environment, to be able to see its surroundings, it needs sensors. Sensors
    take information from the outside or inside of the robot and convert it into a
    digital form. If we use a digital **camera sensor**, it takes light and turns
    it into digital pixels (picture elements), recorded as an array of numbers. A
    **sonar sensor** measures the distance to an object, such as a wall, by sending
    a pulse of energy (sound waves) and listening for the time delay before hearing
    an echo. Measuring the time delay gives us the distance to an object, since the
    speed of sound is fairly constant. For our Albert project, the robot has several
    types of sensors:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传感器**：为了让机器人，一个可以移动并对环境做出反应的机器，能够看到其周围的环境，它需要传感器。传感器从机器人的外部或内部获取信息并将其转换为数字形式。如果我们使用数字**摄像头传感器**，它将光转换为数字像素（图像元素），记录为数组。一个**声纳传感器**通过发送能量脉冲（声波）并监听回声前的延迟时间来测量到物体的距离，例如墙壁。测量延迟时间给我们提供了到物体的距离，因为声速相对恒定。在我们的Albert项目中，机器人有几种类型的传感器：'
- en: Our **primary sensor** is a wide-angle video camera, which we will use for avoiding
    obstacles and detecting objects.
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的**主要传感器**是一个广角视频摄像头，我们将用它来避开障碍物和检测物体。
- en: We will also use a **microphone** to listen for sounds and perform speech recognition.
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将使用一个**麦克风**来监听声音并执行语音识别。
- en: We mentioned servo motors earlier in this list – each servo motor contains an
    **angle sensor** that detects the amount of rotation and allows us to direct the
    robot arm and hand.
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在本列表中之前提到过伺服电机——每个伺服电机都包含一个**角度传感器**，它可以检测旋转量并允许我们控制机械臂和手。
- en: We have our **Emergency Stop button**, which is wired to the Arduino, and is
    a type of tactile (touch) sensor. When the button is pressed, a signal is sent
    that the robot can interpret as a stop command.
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有我们的**紧急停止按钮**，它连接到Arduino，是一种触觉（触摸）传感器。当按钮被按下时，机器人可以将其解释为停止命令。
- en: The robot arm I chose has a handy **voltage monitor** that we will use to keep
    track of the battery life (charge) remaining.
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我选择的机器人手臂有一个方便的**电压监控器**，我们将用它来跟踪剩余的电池寿命（充电）。
- en: In the next section, we will discuss robot software architectures, which act
    as a framework for the autonomy behaviors we will be creating.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论机器人软件架构，它将作为我们创建的自主行为的框架。
- en: Introducing subsumption architecture
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍吞没式架构
- en: At this point, I want to spend a bit of time on the idea behind the **subsumption
    architecture**, and point out some specifics of how we will be using this concept
    in the design of our robot project. Many of you will be familiar with the concept
    from school or from study, so you can look at my diagram and then move on. For
    the rest of us, let’s talk a bit about this biologically inspired robot concept.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我想花点时间讨论一下**吞没式架构**背后的理念，并指出我们将如何在我们的机器人项目设计中使用这个概念的一些具体细节。你们中的许多人可能在学校或学习中已经熟悉了这个概念，所以你们可以看看我的图，然后继续前进。对于其他人，让我们谈谈这个受生物学启发的机器人概念。
- en: Subsumption architecture was originally described by Dr. Rodney Brooks, a professor
    at MIT, who would later help found iRobot Corporation and invent the Baxter robot.
    Rodney was trying to develop analogs of insect brains in order to understand how
    to program intelligent robots. Robots before this time (1986) were very much single-threaded
    machines that pretty much only did one thing at a time. They read sensors, made
    decisions, and then acted – and only had one goal at any one time. Creatures such
    as flies or ants have very simple brains but still manage to function in the real
    world. Brooks reasoned that there were several layers of closed-loop feedback
    processes going simultaneously.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 吞没式架构最初由麻省理工学院教授罗德尼·布鲁克斯博士描述，他后来帮助创立了iRobot公司并发明了Baxter机器人。罗德尼试图开发昆虫大脑的类似物，以便了解如何编程智能机器人。在此之前的机器人（1986年）基本上是单线程机器，一次只能做一件事。它们读取传感器，做出决定，然后行动——在任何时候只有一个目标。像苍蝇或蚂蚁这样的生物拥有非常简单的头脑，但仍然能够在现实世界中发挥作用。布鲁克斯推理认为，存在多个同时进行的闭环反馈过程层。
- en: The basic concept of subsumption has been around for some time, and it has been
    adapted, reused, refined, and simplified in the years since it was first introduced.
    What I am presenting here is my interpretation of how to apply the concept of
    subsumption to a robot in the context of what we are trying to accomplish.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 吞没式的基本概念已经存在了一段时间，自从首次引入以来，它已经被适应、重用、改进和简化。我在这里展示的是我对如何将吞没式概念应用于我们试图达成的机器人环境中的解释。
- en: The first aspect to understand is that we want our robot to act on a series
    of goals. The robot is not simply reacting to each stimulus in total isolation,
    but is rather carrying out some sort of goal-oriented behavior. The goal may be
    to pick up a toy or navigate the room, avoiding obstacles. The paradigm we are
    creating has the user set goals for the robot and the robot determines how to
    carry those goals out, even if the goal is simply to move one meter forward.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要理解的是，我们希望我们的机器人能够根据一系列目标行动。机器人并不是简单地对每个刺激做出完全独立的反应，而是执行某种以目标为导向的行为。目标可能是捡起玩具或导航房间，避开障碍物。我们正在创建的范例是让用户为机器人设定目标，机器人决定如何实现这些目标，即使目标仅仅是向前移动一米。
- en: 'The problem begins when the robot has to keep more than one goal in mind at
    a time. The robot is not just driving around, but driving around avoiding obstacles
    and looking for toys to pick up. How do we arbitrate between different goals,
    to determine which one has precedence? The answer is found in the following diagram:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 问题始于机器人需要在同一时间记住多个目标。机器人不仅仅是四处驾驶，还要在避开障碍物的同时寻找可以捡起的玩具。我们如何在这不同的目标之间进行仲裁，以确定哪个目标具有优先级？答案可以在下面的图中找到：
- en: '![Figure 2.4 – An example subsumption architecture](img/B19846_02_4.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – 吞没式架构示例](img/B19846_02_4.jpg)'
- en: Figure 2.4 – An example subsumption architecture
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 吞没式架构示例
- en: We will divide the robot’s decision-making systems into three layers, each of
    which has a different level of responsibility and operates on a different time
    scale.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把机器人的决策系统分为三个层次，每个层次都有不同的责任级别和不同的时间尺度。
- en: At the lowest levels are what we might call the robot’s autonomic nervous system
    – it contains the robot’s internal health-keeping and monitoring functions. These
    processes run very fast – 20 times a second or so, or 20 hertz (Hz), and only
    deal with what is inside the robot. This includes reading internal sensors, checking
    battery levels, and reading and responding to heartbeat messages. I’ve labeled
    this level *Take Care* *of Myself*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在最低层，我们可以称之为机器人的自主神经系统——它包含机器人内部的健康保持和监控功能。这些过程运行得非常快——大约每秒20次，或者说20赫兹（Hz），并且只处理机器人内部的事情。这包括读取内部传感器、检查电池电量以及读取和响应心跳消息。我把这个层次标记为*照顾好自己*。
- en: Important note
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: What is a **heartbeat message**? Once a second, I have the control station send
    a special heartbeat message to the robot, which has a time tag down to the millisecond,
    which is the clock time of the host computer. This goes to the control computer
    and repeats the heartbeat message back to the host. We can see the delay in our
    message – our command latency – by comparing the time tags. We want to see a less
    than 25 milliseconds round trip for the heartbeat. If the onboard computer is
    not working or is locked up, then the time tag won’t come back and we know the
    robot is having problems.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是**心跳消息**？每秒一次，我会让控制站向机器人发送一个特殊的心跳消息，这个消息的时间标签精确到毫秒，即主机的时钟时间。这个消息传到控制计算机，并重复将心跳消息发送回主机。我们可以通过比较时间标签来看到我们消息的延迟——我们的命令延迟。我们希望看到心跳的往返时间小于25毫秒。如果机载计算机不工作或被锁定，那么时间标签就不会返回，我们就知道机器人出现了问题。
- en: The next level handles individual tasks, such as driving around or looking for
    toys. These tasks are short-term and deal with what the sensors can see. The time
    period for decisions is in the second range, so these tasks might have 1 or 2
    Hz update rates, but slower than the internal checks. I call this level *Complete
    the Task* – you might call it *Drive the Vehicle* or *Operate* *the Payload*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下一层处理单个任务，例如驾驶或寻找玩具。这些任务是短期性的，处理传感器可以看到的事情。决策的时间周期在秒的范围内，因此这些任务的更新率可能是1或2赫兹，但比内部检查慢。我把这个层次称为*完成任务*——你可能称之为*驾驶车辆*或*操作有效载荷*。
- en: The final and top level is the section devoted to *completing the mission*,
    and it deals with the overall purpose of the robot. This level has the overall
    state machine for finding toys, picking them up, and then putting them away, which
    is the mission of this robot. This level also deals with interacting with humans
    and responding to commands. The top level works on tasks that take minutes, or
    even hours, to complete.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一层和最高层是专门用于*完成任务*的部分，它处理机器人的整体目的。这一层有寻找玩具、捡起它们然后放回原处的整体状态机，这是这个机器人的任务。这一层还处理与人类交互和响应命令。顶层处理需要几分钟甚至几小时才能完成的任务。
- en: 'The rules of the subsumption architecture – and even where it gets its name
    – have to do with the priority and interaction of the processes in these layers.
    The rules are as follows (and this is my version):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 吞没架构的规则——甚至它的名字从何而来——与这些层级中进程的优先级和交互有关。规则如下（这是我的版本）：
- en: Each layer can only talk to the layers next to it. The top layer talks only
    to the middle layer, and the bottom layer also talks only to the middle layer.
    The middle layer can communicate with both the top and the bottom layer.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一层只能与相邻的层通信。顶层只与中间层通信，底层也只与中间层通信。中间层可以与顶层和底层通信。
- en: The layer with the lower level has the highest priority. The lower level has
    the ability to interrupt or override the commands from higher layers.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低层次的层级具有最高优先级。低层有中断或覆盖高层命令的能力。
- en: Think about this for a minute. I’ve given you an example of driving our robot
    in a room. The lowest level detects obstacles. The middle level is driving the
    robot in a particular direction, and the top layer is directing the mission. From
    the top down, the uppermost layer is commanded to *clean up the room*, the middle
    layer is commanded to *drive around*, and the bottom layer gets the command *left
    motor and right motor forward 60% throttle*. Now, the bottom level detects an
    obstacle. It interrupts the *drive around* function and overrides the command
    from the top layer to turn the robot away from the obstacle. Once the obstacle
    is cleared, the lowest layer returns control to the middle layer for the driving
    direction.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 想想这个问题。我给你举了一个在房间里驾驶我们机器人的例子。最低层检测障碍物。中间层将机器人驱动到特定方向，顶层则指导任务。从上到下，最高层被命令去*清理房间*，中间层被命令去*四处驾驶*，底层则接收到*左电机和右电机前进60%油门*的命令。现在，底层检测到一个障碍物。它中断了*四处驾驶*功能，并覆盖了来自顶层的命令，使机器人避开障碍物。一旦障碍物被清除，最低层将控制权交还给中间层以确定驾驶方向。
- en: Another example could be if the lowest layer loses the heartbeat signal, which
    indicates that something has gone wrong with the software or hardware. The lowest
    layer causes the motors to halt, overriding any commands from the upper layers.
    It does not matter what they want; the robot has a fault and needs to stop. This
    **priority inversion** of the lowest layers having the highest priority is the
    reason we call this a subsumption architecture, since the higher layers subsume
    – incorporate – the functions of the lower layers to perform their tasks.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，如果最低层失去了心跳信号，这表明软件或硬件出现了问题。最低层会停止电机，覆盖来自上层的一切命令。无论他们想要什么；机器人出现了故障，需要停止。这种最低层具有最高优先级的**优先级反转**是我们称之为吸收架构的原因，因为高层吸收——整合——低层的功能以执行其任务。
- en: The major benefit of this type of organization is that it keeps procedures clear
    as to which events, faults, or commands take precedence over others, and prevents
    the robot from getting stuck in an indecision loop.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种组织方式的主要好处是它使程序清晰，明确哪些事件、故障或命令比其他事件、故障或命令具有优先级，并防止机器人陷入犹豫不决的循环。
- en: Each type of robot may have different numbers of layers in their architecture.
    You could even have a **supervisory layer** that controls a number of other robots
    and has goals for the robots as a team. The most I have had so far has been five,
    used in one of my self-driving car projects.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每种机器人的架构中可能具有不同数量的层级。你甚至可以有一个**监督层**来控制多个其他机器人，并为机器人团队设定目标。我迄今为止最多使用过五个层级，这被应用在我的一个自动驾驶汽车项目中。
- en: Now let’s take a look at one of the most important concepts you’ll need in this
    book – ROS.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这本书中你需要了解的最重要概念之一——ROS。
- en: A brief introduction to ROS
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ROS 简介简述
- en: OK, before we do all of the work described in the following section to be able
    to use ROS 2 – the second version of the Robotic Operating System – let’s answer
    your questions. What is ROS, and what are its advantages?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，在我们完成以下部分描述的所有工作以使用 ROS 2——机器人操作系统的第二个版本——之前，让我们回答你的问题。ROS是什么，它的优点是什么？
- en: The first thing to know is that ROS is not an actual operating system, such
    as Linux or Windows. Rather it is a middleware layer that serves as a means of
    connecting different programs to work together to control a robot. It was originally
    designed to run Willow Garage’s PR2 robot, which was complex indeed. ROS is supported
    by a very large open source community and is constantly updated.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要知道的是，ROS不是一个真正的操作系统，如Linux或Windows。相反，它是一个中间件层，作为连接不同程序以协同工作控制机器人的手段。它最初是为运行
    Willow Garage 的 PR2 机器人而设计的，这个机器人确实很复杂。ROS 由一个非常大的开源社区支持，并且不断更新。
- en: 'I used to be a ROS skeptic, and frankly, reading the documentation did not
    help my first impression that it was cumbersome at best and difficult to use.
    However, at the insistence of one of my business partners, we started using ROS
    for a very complex self-guided security guard robot called RAMSEE, designed for
    Gamma 2 Robotics:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经是 ROS 的怀疑者，坦白说，阅读文档并没有帮助我第一次对它最起码觉得它很繁琐，难以使用。然而，在一位商业伙伴的坚持下，我们开始使用 ROS 为一个名为
    RAMSEE 的非常复杂的自主保安机器人，由 Gamma 2 Robotics 设计：
- en: '![Figure 2.5 – RAMSEE, the security guard robot, designed by the author](img/B19846_02_5.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – RAMSEE，作者设计的保安机器人](img/B19846_02_5.jpg)'
- en: Figure 2.5 – RAMSEE, the security guard robot, designed by the author
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – RAMSEE，由作者设计的安保机器人
- en: I quickly realized that while the initial learning curve with ROS was steep,
    the payoff was the ability to create and implement modular, easily portable services
    that could be developed independently. I did not need to combine everything into
    one program, or even in one CPU. I could take advantage of my multi-core computers
    to run independent processes, or even have more than one computer and move things
    freely from one to the other. RAMSEE has one computer with eight cores and another
    with four.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我很快意识到，虽然使用 ROS 的初始学习曲线很陡峭，但回报是能够创建和实施模块化、易于移植的服务，这些服务可以独立开发。我无需将所有内容组合成一个程序，甚至在一个
    CPU 中。我可以利用我的多核计算机来运行独立的过程，甚至拥有多个计算机，并将事物自由地从一台移动到另一台。RAMSEE 有一个拥有八个核心的计算机和另一个拥有四个核心的计算机。
- en: Important note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: ROS can be described as a **Modular Open System Software** (**MOSA**). It provides
    a standard interface to allow programs to talk to one another through a *Publish-Subscribe*
    paradigm. This means that one program publishes data, making it available to other
    programs. The programs that need this subscribe to that data and are sent a message
    whenever new data is available. This lets us develop programs independently and
    create standardized interfaces between programs. It really makes creating robots
    much easier and far more flexible.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ROS 可以描述为 **模块化开放式系统软件**（**MOSA**）。它提供了一个标准接口，允许程序通过 *发布-订阅* 模式相互通信。这意味着一个程序发布数据，使其可供其他程序使用。需要这些数据的程序会订阅这些数据，并在有新数据可用时收到消息。这使得我们可以独立开发程序，并在程序之间创建标准化的接口。这确实使创建机器人变得更加容易，并且更加灵活。
- en: The other major advantage, and worth all the bother, is that ROS has a very
    large library of ready-to-go interfaces for sensors, motors, drivers, and effectors,
    as well as every imaginable type of robot navigation and control tool. For example,
    we will be using the OAK-D 3D depth camera, which has a ROS 2 driver available
    at [https://github.com/luxonis/depthai-ros](https://github.com/luxonis/depthai-ros).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个主要优势，并且值得所有麻烦，是 ROS 拥有一个非常大的库，其中包括传感器、电机、驱动器和执行器的现成接口，以及所有可想象到的机器人导航和控制工具。例如，我们将使用
    OAK-D 3D 深度相机，该相机在 [https://github.com/luxonis/depthai-ros](https://github.com/luxonis/depthai-ros)
    提供了 ROS 2 驱动器。
- en: The RViz2 tool provides visualization of all of your sensor data, as well as
    showing the localization and navigation process. I greatly appreciated the logging
    and debugging tools included in ROS. You can log data – anything that crosses
    the publish/subscribe interface – to a **ROSBag** and play it back later to test
    your code without the robot being attached, which is very useful.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: RViz2 工具提供了您所有传感器数据的可视化，以及展示定位和导航过程。我非常欣赏 ROS 中包含的日志和调试工具。您可以将数据记录到 **ROSBag**
    中——任何跨发布/订阅接口的数据——稍后回放以测试您的代码，而无需连接机器人，这非常实用。
- en: 'The following illustration below shows the output given by RViz2, showing a
    map being drawn by one of my robots:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的插图显示了 RViz2 的输出，展示了我的机器人绘制的地图：
- en: '![Figure 2.6 – ROS RViz allows you to see what the robot sees, in this case,
    a map of a warehouse](img/B19846_02_6.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – ROS RViz 允许您看到机器人所看到的内容，在这种情况下，是一个仓库的地图](img/B19846_02_6.jpg)'
- en: Figure 2.6 – ROS RViz allows you to see what the robot sees, in this case, a
    map of a warehouse
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – ROS RViz 允许您看到机器人所看到的内容，在这种情况下，是一个仓库的地图
- en: Since this is the second edition of the book, we will be using ROS 2, the new
    and improved version of ROS. One of the most frustrating things about the old
    ROS was the use of **ROSCORE**, a traffic cop that connected all of the parts
    of the robot via the network. That is now gone, and the various components can
    find each other via a different sort of service, called **Distributed Data Services**
    (**DDS**). We will also need to use Python 3 instead of Python 2 for our code
    since Python 2 has been discontinued and is no longer supported.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是本书的第二版，我们将使用 ROS 2，这是 ROS 的新版本和改进版本。关于旧 ROS 最令人沮丧的事情之一是使用 **ROSCORE**，这是一个交通警察，通过网络连接机器人的所有部分。现在这已经不存在了，各种组件可以通过一种不同类型的服务找到彼此，称为
    **分布式数据服务**（**DDS**）。我们还需要使用 Python 3 而不是 Python 2 来编写我们的代码，因为 Python 2 已经停止使用，不再受支持。
- en: Hardware and software setup
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件和软件设置
- en: 'To match the examples in this book, and to have access to the same tools that
    are used in the code samples, you will have to set up three environments:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了匹配本书中的示例，并访问代码示例中使用的相同工具，您需要设置三个环境：
- en: '**A laptop or desktop computer**: This will run our control panel, and also
    be used to train neural networks. I used a Windows 10 computer with Oracle VirtualBox
    supporting a virtual machine running Ubuntu 20.04\. You may run a computer running
    Ubuntu or another Linux operating system by itself (without Windows) if you want.
    Several of the AI packages we will use in the tutorial sections of the book will
    require Ubuntu to run. We will load ROS 2 on this computer. I will also be using
    a PlayStation game controller on this computer for teleoperation (remote control)
    of the robot when we teach the robot how to navigate. I also have ROS 2 for Windows
    installed, which may obviate running the virtual machine. Either approach will
    work, since the Python programs we will use for control run in either mode.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**笔记本电脑或台式计算机**：这将运行我们的控制面板，并用于训练神经网络。我使用了一台Windows 10计算机，它通过Oracle VirtualBox支持运行Ubuntu
    20.04的虚拟机。如果您想单独运行运行Ubuntu或其他Linux操作系统的计算机（没有Windows），也可以这样做。我们将在这台计算机上加载ROS 2。我还会在这台计算机上使用PlayStation游戏控制器进行遥操作（遥控）机器人，当我们教机器人如何导航时。我还安装了ROS
    2 for Windows，这可能避免了运行虚拟机。两种方法都可行，因为我们将使用的控制Python程序可以在两种模式下运行。'
- en: '**Nvidia Jetson Nano 8GB**: This also runs Ubuntu Linux 20.04 (you can also
    run other Linux versions, but you will have to make any adjustments between those
    versions yourself). The Nano also runs ROS 2\. We will cover the additional libraries
    we need in the following sub-sections.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nvidia Jetson Nano 8GB**：这也运行Ubuntu Linux 20.04（您也可以运行其他Linux版本，但您将不得不自己在这之间进行调整）。Nano还运行ROS
    2。我们将在接下来的小节中介绍我们需要的附加库。'
- en: '**Arduino Mega 256**: We need to be able to create code for the Arduino. I’m
    using the regular Arduino IDE from the Arduino website. It can be run on Windows
    or Linux. We will be using the Arduino to control the motors on the robot base
    and drive it around. It also gives us a lot of expansion to add additional controls,
    such as an emergency stop button.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Arduino Mega 256**：我们需要能够为Arduino编写代码。我正在使用来自Arduino网站的常规Arduino IDE。它可以在Windows或Linux上运行。我们将使用Arduino来控制机器人底座的电机并使其移动。它还为我们提供了很多扩展，例如添加紧急停止按钮。'
- en: Preparing the laptop
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备笔记本电脑
- en: You will need to install ROS 2 for Windows for the robot control software to
    work. To do this, you can follow the instructions provided at [https://docs.ros.org/en/foxy/Installation/Windows-Install-Binary.html](https://docs.ros.org/en/foxy/Installation/Windows-Install-Binary.html).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要为Windows安装ROS 2，以便机器人控制软件能够工作。为此，您可以遵循[https://docs.ros.org/en/foxy/Installation/Windows-Install-Binary.html](https://docs.ros.org/en/foxy/Installation/Windows-Install-Binary.html)提供的说明。
- en: I also used **Virtual Network Computing** (**VNC**) to talk to my Nano from
    the laptop, which saves a lot of time and fiddling with cables and keyboards.
    Otherwise, you would need to connect the Nano to a monitor, keyboard, and mouse
    to be able to work on your code that is on the robot. I used **RealVNC**, which
    can be found at [https://www.realvnc.com/en/](https://www.realvnc.com/en/). You
    can also use **UltraVNC**, which is free software.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我还使用了**虚拟网络计算**（**VNC**）从笔记本电脑与我的Nano进行通信，这节省了很多时间和与电缆和键盘的麻烦。否则，您需要将Nano连接到显示器、键盘和鼠标，才能在机器人上工作您的代码。我使用了**RealVNC**，可以在[https://www.realvnc.com/en/](https://www.realvnc.com/en/)找到。您也可以使用**UltraVNC**，这是一款免费软件。
- en: Installing Python
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Python
- en: The Linux Ubuntu system will come with a default version of Python. I am going
    to assume that you are familiar with Python, as we will be using it throughout
    the book. If you need help with Python, Packt has several fine books on the subject.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Linux Ubuntu系统将自带一个Python默认版本。我将假设您熟悉Python，因为我们将全书都会用到它。如果您需要Python的帮助，Packt有关于这个主题的几本很好的书。
- en: 'Once you log on to your virtual machine, check which version of Python you
    have by opening a terminal window and typing `python` in the command prompt. You
    should see the Python version, like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您登录到虚拟机，请通过打开一个终端窗口并在命令提示符中输入`python`来检查您拥有的Python版本。您应该看到Python版本，如下所示：
- en: '[PRE0]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can see that I have version 3.8.16 in this case.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在这种情况下我使用的是版本 3.8.16。
- en: 'We are going to need several add-on libraries that add on to Python and extend
    its capabilities. The first thing to check is to see if you have `pip` installed.
    This is the `pip` by typing in the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要几个附加库，这些库可以添加到Python中并扩展其功能。首先需要检查的是您是否已安装`pip`。这是通过在以下命令提示符中输入以下内容来完成的：
- en: '[PRE1]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you get the output `No command ''pip'' found`, then you need to install
    Pip. Enter the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您得到输出`未找到命令'pip'`，那么您需要安装Pip。输入以下内容：
- en: '[PRE2]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we can install the rest of the packages we need. As a start, we need the
    Python math packages `numpy`, the scientific Python library `scipy`, and the math
    plotting library `matplotlib`. Let’s install them:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以安装我们需要的其他包。作为开始，我们需要Python数学包`numpy`、科学Python库`scipy`和数学绘图库`matplotlib`。让我们来安装它们：
- en: '[PRE3]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I’ll cover the other Python libraries we will use later (OpenCV, scikit-learn,
    Keras, etc.) as we need them in the appropriate chapters.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在适当章节中介绍我们将要使用的其他Python库（OpenCV、scikit-learn、Keras等），因为我们需要在适当章节中使用它们。
- en: Setting up Nvidia Jetson Nano
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置Nvidia Jetson Nano
- en: For this setup, we will use an image to run Ubuntu 20.04 on our Jetson Nano,
    which is required for ROS 2\. One source for this version is [https://github.com/Qengineering/Jetson-Nano-Ubuntu-20-image](https://github.com/Qengineering/Jetson-Nano-Ubuntu-20-image).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个设置，我们将使用一个映像在Jetson Nano上运行Ubuntu 20.04，这对于ROS 2是必需的。这个版本的来源之一是[https://github.com/Qengineering/Jetson-Nano-Ubuntu-20-image](https://github.com/Qengineering/Jetson-Nano-Ubuntu-20-image)。
- en: 'The basic steps, which you can follow in the Git repo, are as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Git仓库中遵循的基本步骤如下：
- en: The first step is to prepare an SD card with the operating system image on it.
    I used **Imager**, but there are several programs available that will do the job.
    You need an SD card with at least 32 GB of space – and keep in mind you are erasing
    the SD card in this process. This means that you need a card greater than 32 GB
    to start with – I used a 64 GB SD card as a 32 GB SD card did not work, contrary
    to the instructions provided on the website.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是准备一张带有操作系统映像的SD卡。我使用了**Imager**，但还有其他几个程序可以完成这项工作。您需要一个至少32GB空间的SD卡 – 请记住，在这个过程中您将擦除SD卡。这意味着您需要一张大于32GB的卡来开始
    – 我使用了一张64GB的SD卡，因为32GB的SD卡没有按网站上的说明工作。
- en: 'Follow the directions with your SD card – the Jetson Nano Ubuntu website ([https://github.com/jetsonhacks/installROS2](https://github.com/jetsonhacks/installROS2))
    advises us to use a Class 10 memory card with 64 GB of space. Put the SD card
    in your reader and start up your disk imager program. Double (and triple) check
    that you pick the right drive letter – you are erasing the disk in that drive.
    Select the disk image you downloaded. Hit the **Write** button and let the formatter
    create your disk image on the SD card:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照SD卡的指示操作 – Jetson Nano Ubuntu网站([https://github.com/jetsonhacks/installROS2](https://github.com/jetsonhacks/installROS2))建议我们使用容量为64GB的Class
    10存储卡。将SD卡插入读卡器，并启动您的磁盘映像程序。务必（并且再三）确认您选择了正确的驱动器字母 – 您将在该驱动器中擦除磁盘。选择您下载的磁盘映像。点击**写入**按钮，让格式化程序在SD卡上创建磁盘映像：
- en: '![Figure 2.7 – Imager program to write out disk images on SD cards](img/B19846_02_07.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – Imager程序用于在SD卡上写入磁盘映像](img/B19846_02_07.jpg)'
- en: Figure 2.7 – Imager program to write out disk images on SD cards
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – Imager程序用于在SD卡上写入磁盘映像
- en: You can follow the usual setup for setting up your language and keyboard, as
    well as setting up the network. I like to use a static IP address for the robot
    since we will be using it a lot.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以按照常规设置来设置您的语言和键盘，以及设置网络。我喜欢为机器人使用静态IP地址，因为我们将会大量使用它。
- en: It is always a good idea to set a new user ID and change the default passwords.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总是设置一个新的用户ID并更改默认密码是一个好主意。
- en: Now let’s look at how we can install ROS 2.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何安装ROS 2。
- en: Installing ROS 2
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装ROS 2
- en: 'We need to install ROS 2 on the Jetson Nano. I used the *Foxy* version on my
    machine. You can follow the instructions at this link: [https://github.com/Razany98/ROS-2-installation-on-Jetson-Nano](https://github.com/Razany98/ROS-2-installation-on-Jetson-Nano).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在Jetson Nano上安装ROS 2。我在我的机器上使用了*Foxy*版本。您可以按照此链接中的说明操作：[https://github.com/Razany98/ROS-2-installation-on-Jetson-Nano](https://github.com/Razany98/ROS-2-installation-on-Jetson-Nano)。
- en: 'You will have to set up the sources and point your computer at the ROS 2 repository.
    To do this, follow these steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要设置源并让您的计算机指向ROS 2仓库。为此，请按照以下步骤操作：
- en: 'Set `locale` using the following code:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码设置`locale`：
- en: '[PRE4]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Set up the source repository to use:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置要使用的源仓库：
- en: '[PRE5]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Install the ROS packages:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装ROS包：
- en: '[PRE6]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Set up the environment:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置环境：
- en: '[PRE7]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once you are done, you can check that your installation comepleted correctly
    by typing in the following:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，您可以通过输入以下内容来检查您的安装是否正确完成：
- en: '[PRE8]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Before we proceed, let’s take a look at how exactly ROS works.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们看看ROS是如何工作的。
- en: Understanding how ROS works
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解ROS的工作原理
- en: You can think of ROS as a type of *middleware* that works to connect different
    programs together. It provides **Interprocess Communications** (**IPC**) between
    programs so we don’t have to put all of our functions in one big block of code
    – we can distribute our robot’s capabilities and develop them independently.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将ROS视为一种连接不同程序的*中间件*。它提供了程序之间的**进程间通信**（**IPC**），这样我们就不必将所有函数放在一个大块代码中——我们可以将机器人的能力分散开来，独立开发和测试。
- en: Each individual part of a ROS robot control system is called a **node**. A node
    is a single-purpose programming module. We will have nodes that collect camera
    images, perform object recognition, or control the robot arm. With ROS, we can
    isolate these functions and develop and test them independently.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ROS机器人控制系统中的每个独立部分都称为**节点**。节点是一个单一用途的编程模块。我们将有收集摄像头图像、执行物体识别或控制机器人手臂的节点。使用ROS，我们可以隔离这些功能，并独立开发和测试它们。
- en: 'The various nodes (programs) talk to one another via `/image_raw`. This standard
    message type includes data about the image format, as well as the image itself.
    We also publish camera data on the `/camera_info` topic, using the `sensor_msgs/CameraInfo`
    format, which is described in the following image:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的节点（程序）通过`/image_raw`相互通信。这种标准消息类型包括有关图像格式的数据，以及图像本身。我们还使用`sensor_msgs/CameraInfo`格式在`/camera_info`主题上发布摄像头数据，该格式在以下图像中描述：
- en: '![Figure 2.8 – ROS 2 nodes, topics, and message types](img/B19846_02_8.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – ROS 2节点、主题和消息类型](img/B19846_02_8.jpg)'
- en: Figure 2.8 – ROS 2 nodes, topics, and message types
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – ROS 2节点、主题和消息类型
- en: The `/camera_info` topic has a lot of valuable information about the image,
    or frame, including the timestamp the data was collected and the frame number.
    It also provides calibration information to help us understand the geometry of
    the captured image, which we can use to map pixels to the 3D space around the
    robot.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`/camera_info`主题包含有关图像或帧的大量有价值信息，包括收集数据的时间戳和帧号。它还提供了校准信息，帮助我们理解捕获图像的几何形状，我们可以使用这些信息将像素映射到机器人周围的3D空间。'
- en: There is generally an existing or ROS standard message format for whatever you
    need to convey between components. I like to use the generic `std_msgs/String`)
    on a topic called `RobotCmd` to send general commands, such as mode changes, to
    the robot from a control application.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于组件之间需要传达的内容，都存在一个现有的或ROS标准消息格式。我喜欢使用通用的`std_msgs/String`消息格式，在名为`RobotCmd`的主题上发送一般命令，例如模式更改，从控制应用程序发送到机器人。
- en: 'ROS 2 allows us to set `arm_base_lock`, define it as a Boolean, and use the
    following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ROS 2允许我们设置`arm_base_lock`，将其定义为布尔值，并使用以下命令：
- en: '[PRE9]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will turn the rotation lock on. Then we can check this setting with this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这将开启旋转锁定。然后我们可以使用以下方式来检查这个设置：
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We get the following reply:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下回复：
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since our robot will be composed of a number of nodes (programs) that all have
    to be started together, ROS 2 provides the concept of a **launch file** that lets
    us start all of our programs with one command. In ROS 1, launch files were built
    in **YAML** format. YAML stands for **Yet Another Markup Language**. In ROS 2
    we can use YAML, Python, or **eXtensible Markup Language** (**XML**) to define
    a launch file. I’m used to creating files in YAML format, so we will stick to
    that. In our launch file, we can start nodes, change parameters, and create namespaces
    if we need to launch multiple copies of a node (for instance, if we had three
    cameras).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的机器人将由多个节点（程序）组成，这些节点都需要一起启动，ROS 2提供了**启动文件**的概念，使我们能够通过一个命令启动所有程序。在ROS
    1中，启动文件是内置的**YAML**格式。YAML代表**另一种标记语言**。在ROS 2中，我们可以使用YAML、Python或**可扩展标记语言**（**XML**）来定义启动文件。我习惯于创建YAML格式的文件，所以我们将继续使用它。在我们的启动文件中，我们可以启动节点、更改参数，如果需要启动多个节点的副本（例如，如果我们有三个摄像头），我们还可以创建命名空间。
- en: Virtual Network Computing
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 虚拟网络计算
- en: 'One tool that I have added to my Jetson Nano is **Virtual Network Computing**
    (**VNC**). This utility, if you are not familiar with it, allows you to see and
    work with the Nano desktop as if you were connected to it using a keyboard, a
    mouse, and a monitor. Since the Nano is physically installed inside the robot
    that travels by itself, attaching a keyboard, mouse, and monitor is not often
    convenient (or possible). There are many different versions of VNC, which is a
    standard protocol used amongst many Unix – and non-Unix – operating systems. The
    one I used is called **Vino**. You need two parts: the **server** and the **client**.
    The server runs on the Nano and basically copies all of the pixels appearing on
    the screen and sends them out to the Ethernet port. The client catches all of
    this data and displays it to you on another computer. Let’s install the VNC server
    using the steps on this webpage: [https://developer.nvidia.com/embedded/learn/tutorials/vnc-setup](https://developer.nvidia.com/embedded/learn/tutorials/vnc-setup).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我在我的Jetson Nano上添加了一个工具，那就是**虚拟网络计算**（**VNC**）。如果你不熟悉它，这个实用程序允许你像使用键盘、鼠标和显示器连接到它一样查看并使用Nano桌面。由于Nano物理安装在自行移动的机器人内部，因此连接键盘、鼠标和显示器通常不方便（或不可能）。VNC有许多不同的版本，这是一个在许多Unix和非Unix操作系统之间使用的标准协议。我使用的是名为**Vino**的版本。你需要两个部分：**服务器**和**客户端**。服务器在Nano上运行，基本上会复制屏幕上出现的所有像素并将它们发送到以太网端口。客户端捕获所有这些数据，并在另一台计算机上显示给你。让我们按照这个网页上的步骤安装VNC服务器：[https://developer.nvidia.com/embedded/learn/tutorials/vnc-setup](https://developer.nvidia.com/embedded/learn/tutorials/vnc-setup)。
- en: Load the viewer on your Windows PC, or Linux virtual machine, or do like I did,
    and load VNC on your Apple iPad. You will find the ability to log directly into
    the robot and use the desktop tools to be very helpful.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Windows PC或Linux虚拟机上加载查看器，或者像我一样，在你的Apple iPad上加载VNC。你会发现能够直接登录到机器人并使用桌面工具非常有帮助。
- en: Important note
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'In order to get VNC to run on the Nano without a monitor attached, you must
    set the Nano to automatically log itself on. You can edit the `/etc/gdm3/custom.conf`
    file to enable automatic login:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在没有连接显示器的情况下在Nano上运行VNC，你必须将Nano设置为自动登录。你可以编辑`/etc/gdm3/custom.conf`文件来启用自动登录：
- en: '`# Enabling` `automatic login`'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`# 启用` `自动登录`'
- en: '`AutomaticLoginEnable=true`'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`AutomaticLoginEnable=true`'
- en: '`AutomaticLogin=[your username]`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`AutomaticLogin=[你的用户名]`'
- en: Setting up the colcon workspace
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置colcon工作空间
- en: We will need a `colcon` workspace on your development machine—laptop or desktop—as
    well as on the Jetson Nano. Follow the instructions at [https://docs.ros.org/en/foxy/Tutorials/Beginner-Client-Libraries/Colcon-Tutorial.html](https://docs.ros.org/en/foxy/Tutorials/Beginner-Client-Libraries/Colcon-Tutorial.html).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在你的开发机器——笔记本电脑或台式机上，以及Jetson Nano上设置一个`colcon`工作空间。遵循[https://docs.ros.org/en/foxy/Tutorials/Beginner-Client-Libraries/Colcon-Tutorial.html](https://docs.ros.org/en/foxy/Tutorials/Beginner-Client-Libraries/Colcon-Tutorial.html)上的说明。
- en: If you are already a user of ROS, then you know what a workspace is, and how
    it is used to create packages that can be used and deployed as a unit. We are
    going to keep all of our programs in a package we will call `albert`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经是ROS的用户，那么你就知道什么是工作空间，以及它是如何用来创建可以作为一个单元使用和部署的包的。我们将把所有的程序都放在一个我们将称之为`albert`的包中。
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered several important topics. It started with some of the basics
    of robotics, for readers who needed a bit more background. We talked about common
    robot parts, such as sensors, computers, and motors/actuators. We discussed the
    subsumption architecture in more depth and showed how it helps the robot arbitrate
    between responding to different events and commands. The next section covered
    the software setup for running the robot, including the offboard development environment
    and the onboard Jetson Nano computer environments. We set up the ROS and installed
    the Python tools.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了几个重要主题。它从一些机器人学的基础知识开始，为需要更多背景知识的读者提供介绍。我们讨论了常见的机器人部件，例如传感器、计算机和电机/执行器。我们更深入地讨论了子吸收架构，并展示了它是如何帮助机器人在响应不同事件和命令之间进行仲裁的。下一节涵盖了运行机器人的软件设置，包括离线开发环境和Jetson
    Nano计算机环境。我们设置了ROS并安装了Python工具。
- en: The final section covered ROS 2 and explained what it is and what it does for
    us. ROS 2 is a middleware layer that lets us build modular components and multiple
    single-use programs, rather than having to lump everything into one executable.
    ROS also has logging, visualization, and debugging tools that help our task of
    designing a complex robot. ROS 2 is also a wonderful repository of additional
    capabilities that we can add, including sensor drivers, navigation functions,
    and controls.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分涵盖了ROS 2，并解释了它是什么以及它为我们做了什么。ROS 2是一个中间件层，它允许我们构建模块化组件和多个单次使用的程序，而不是将所有内容都打包到一个可执行文件中。ROS还提供了日志记录、可视化和调试工具，这些工具有助于我们设计复杂机器人的任务。ROS
    2也是一个非常好的额外功能库，我们可以添加包括传感器驱动程序、导航功能和控制功能。
- en: In the next chapter, we will discuss how to go from a concept to a working plan
    for developing complex robot AI-based software using systems engineering practices
    such as use cases and storyboards.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何从概念到实际的工作计划，使用系统工程实践，如用例和故事板，来开发基于复杂机器人AI的软件。
- en: Questions
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Name three types of robot sensors.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出三种类型的机器人传感器。
- en: What does the acronym PWM stand for?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PWM这个缩写代表什么？
- en: What is analog-to-digital conversion? What goes in and what comes out?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟到数字转换是什么？输入和输出是什么？
- en: Who invented the subsumption architecture?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 谁发明了子吸收架构？
- en: Compare my diagram of the three-layer subsumption architecture to the Three
    Laws of Robotics postulated by Isaac Asimov. Is there a correlation? Why is there
    one, or why not?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我的三层子吸收架构图与艾萨克·阿西莫夫提出的机器人三大定律进行比较。是否存在相关性？为什么有，或者为什么没有？
- en: '**Hint**: Think about how the laws change the behavior of the robot. Which
    is the lowest level law (from a subsumption perspective)? Which is the highest?'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**提示**：思考这些法律如何改变机器人的行为。从子吸收的角度来看，哪一条是最底层的法律？哪一条是最顶层的？'
- en: Do you think I should have given our robot project – *Albert* – a name? Do you
    name your robots? What about your washing machine? Why not?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你认为我应该给我的机器人项目——*阿尔伯特*——起一个名字吗？你给你的机器人起名字吗？你的洗衣机呢？为什么不给它起名字？
- en: What is the importance of the environment variable `ROS_ROOT`?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 环境变量`ROS_ROOT`的重要性是什么？
- en: Further reading
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Scripts to install ROS 2 on Jetson Nano: [https://github.com/jetsonhacks/installROS2](https://github.com/jetsonhacks/installROS2)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Jetson Nano上安装ROS 2的脚本：[https://github.com/jetsonhacks/installROS2](https://github.com/jetsonhacks/installROS2)
- en: Helpful troubleshooting in case you have problems with your ROS 2 installation
    can be found at [https://docs.ros.org/en/rolling/How-To-Guides/Installation-Troubleshooting.html](https://docs.ros.org/en/rolling/How-To-Guides/Installation-Troubleshooting.html)
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在ROS 2安装过程中遇到问题，可以找到有用的故障排除信息：[https://docs.ros.org/en/rolling/How-To-Guides/Installation-Troubleshooting.html](https://docs.ros.org/en/rolling/How-To-Guides/Installation-Troubleshooting.html)
- en: 'ROS 2 documentation: [https://docs.ros.org/en/foxy/index.html](https://docs.ros.org/en/foxy/index.html)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS 2文档：[https://docs.ros.org/en/foxy/index.html](https://docs.ros.org/en/foxy/index.html)
- en: 'Dr. Rodney Brooks’s paper on the subsumption architecture: [https://people.csail.mit.edu/brooks/papers/AIM-864.pdf](https://people.csail.mit.edu/brooks/papers/AIM-864.pdf)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 霍华德·罗德尼·布鲁克斯博士关于子吸收架构的论文：[https://people.csail.mit.edu/brooks/papers/AIM-864.pdf](https://people.csail.mit.edu/brooks/papers/AIM-864.pdf)
