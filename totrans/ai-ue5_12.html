<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-231">
    <a id="_idTextAnchor233">
    </a>
    
     12
    
   </h1>
   <h1 id="_idParaDest-232">
    <a id="_idTextAnchor234">
    </a>
    
     Using Hierarchical State Machines with State Trees
    
   </h1>
   <p>
    
     Unreal
    
    <a id="_idIndexMarker588">
    </a>
    
     Engine provides a powerful framework for creating complex AI behaviors through
    
    <strong class="bold">
     
      hierarchical state machines
     
    </strong>
    
     called
    
    <strong class="bold">
     
      state trees
     
    </strong>
    
     .
    
    
     By defining various
    
    <a id="_idIndexMarker589">
    </a>
    
     states and transitions, developers can design sophisticated AI logic that adapts to dynamic environments.
    
    
     State trees offer a structured approach to managing AI behavior, allowing for efficient decision-making and seamless integration with other systems in Unreal Engine.
    
    
     What’s more, with state trees, you can build clever AI agents that respond to environmental stimuli and interact with the game world in a natural and realistic manner.
    
    
     The purpose of the chapter is to introduce you to the state tree framework in Unreal Engine and to its
    
    
     
      basic concepts.
     
    
   </p>
   <p>
    
     In this chapter, we will have a quick introduction to the state tree system available in Unreal Engine and see how to implement state trees inside
    
    
     
      a project.
     
    
   </p>
   <p>
    
     In this chapter, we will be covering the
    
    
     
      following topics:
     
    
   </p>
   <ul>
    <li>
     
      Introducing
     
     
      
       state trees
      
     
    </li>
    <li>
     
      Creating and managing
     
     
      
       state trees
      
     
    </li>
    <li>
     
      Using advanced state
     
     
      
       tree features
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-233">
    <a id="_idTextAnchor235">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     To follow the topics presented in this chapter, you should have completed the previous ones and understood
    
    
     
      their content.
     
    
   </p>
   <p>
    
     You’ll be using the starter content available in this book’s companion repository located at
    
    <a href="https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5">
     
      https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5
     
    </a>
    
     .
    
    
     Through this link, locate the section for this chapter and download the following
    
    <strong class="source-inline">
     
      .zip
     
    </strong>
    
     file:
    
    <strong class="source-inline">
     
      Unreal Agility Arena –
     
    </strong>
    
     <strong class="source-inline">
      
       Starter Content
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Although not mandatory, you can use the code created so far or download the files that correspond to the end of the last chapter by clicking the
    
    <strong class="source-inline">
     
      Unreal Agility Arena –
     
    </strong>
    
     <strong class="source-inline">
      
       Chapter 11
      
     </strong>
    
    <strong class="source-inline">
     
      -
     
    </strong>
    
     <strong class="source-inline">
      
       End
      
     </strong>
    
    
     
      link.
     
    
   </p>
   <h1 id="_idParaDest-234">
    <a id="_idTextAnchor236">
    </a>
    
     Introducing state trees
    
   </h1>
   <p>
    
     It appeared inevitable that, sooner or later, someone would uncover Dr.
    
    
     Markus’
    
    
     
      secret experiments:
     
    
   </p>
   <p>
    <em class="italic">
     
      Hidden in their secret laboratory, Dr.
     
     
      Markus and Professor Viktoria kept on with their groundbreaking experiments.
     
     
      However, news of their remarkable inventions began to spread like wildfire; paparazzi and curious individuals started flocking to the area, eager to uncover the secrets hidden within the
     
    </em>
    
     <em class="italic">
      
       laboratory’s walls.
      
     </em>
    
   </p>
   <p>
    <em class="italic">
     
      Dr.
     
     
      Markus and Professor Viktoria realized they needed to take drastic measures to protect their precious research.
     
     
      With their expertise, the ingenious duo started enhancing their beloved AI dummy puppets with advanced algorithms and behavioral patterns.
     
     
      They programmed the puppets to detect and respond to unauthorized intrusions, trying to ensure the safety of their laboratory
     
    </em>
    
     <em class="italic">
      
       and research.
      
     </em>
    
   </p>
   <p>
    
     State trees
    
    <a id="_idIndexMarker590">
    </a>
    
     are the Unreal Engine version of hierarchical state machines that merge selectors from behavior trees with state machines, enabling users to build efficient and
    
    
     
      well-organized logic.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     A hierarchical state machine
    
    <a id="_idIndexMarker591">
    </a>
    
     is a design pattern used in software development to model complex systems with multiple states and transitions.
    
    
     It extends the concept of traditional finite-state machines by introducing the idea of hierarchically nested states.
    
    
     In a hierarchical state machine, states can be organized into a hierarchical structure, where higher-level states encapsulate and control lower-level states; this nesting allows for a more modular and organized representation of the system behavior.
    
    
     Each state can have its own set of substates, which can further have their own substates, forming a hierarchical tree-like structure.
    
    
     The main advantage of this pattern is that it provides a way to reuse behavior across multiple states.
    
    
     Instead of duplicating similar logic in different states, common behavior can be defined at higher-level states and inherited by their substates.
    
    
     This promotes code reusability, reduces redundancy, and simplifies the
    
    
     
      overall design.
     
    
   </p>
   <p>
    
     A state tree
    
    <a id="_idIndexMarker592">
    </a>
    
     is structured hierarchically, with the state selection process generally starting at the root.
    
    
     However, state selection can be initiated from any node within
    
    
     
      the tree.
     
    
   </p>
   <p>
    
     When selecting
    
    <a id="_idIndexMarker593">
    </a>
    
     a
    
    <strong class="bold">
     
      state
     
    </strong>
    
     , the system evaluates a set of
    
    <strong class="bold">
     
      enter conditions
     
    </strong>
    
     for the state itself; if
    
    <a id="_idIndexMarker594">
    </a>
    
     conditions are met, the selection progresses to the child states.
    
    
     If no child states exist, it means a leaf has been reached and the current state
    
    
     
      is activated.
     
    
   </p>
   <p>
    
     Activating a state
    
    <a id="_idIndexMarker595">
    </a>
    
     triggers all states from
    
    <a id="_idIndexMarker596">
    </a>
    
     the root to the leaf state, with each of these states comprising
    
    <strong class="bold">
     
      tasks
     
    </strong>
    
     
      and
     
    
    
     <strong class="bold">
      
       transitions
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Upon selecting a state, the chosen state and all its parent states become active, executing tasks for all active states starting from the root down to the leaf state.
    
    
     All tasks in a state are executed concurrently, and the first task reaching completion will trigger a transition that may result in the selection of a
    
    
     
      new state.
     
    
   </p>
   <p>
    
     Transitions can
    
    <a id="_idIndexMarker597">
    </a>
    
     point to any state in the tree, and they are triggered by a set of
    
    <strong class="bold">
     
      trigger conditions
     
    </strong>
    
     that must be satisfied for the transition to proceed.
    
    
     <em class="italic">
      
       Figure 12
      
     </em>
    
    <em class="italic">
     
      .1
     
    </em>
    
     shows a typical example of a state tree (example taken from the
    
    <strong class="bold">
     
      City Sample
     
    </strong>
    
     project freely available in the Epic
    
    
     
      Games Marketplace):
     
    
   </p>
   <div><div><img alt="Figure 12.1 – State tree example" src="img/Figure_12.1_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.1 – State tree example
    
   </p>
   <p>
    
     To sum it up, the main elements of a state tree are
    
    
     
      as follows:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Root
      
     </strong>
     
      state: the
     
     <a id="_idIndexMarker598">
     </a>
     
      first state selected when the state tree starts executing
     
     
      
       its logic
      
     
    </li>
    <li>
     <strong class="bold">
      
       Selector
      
     </strong>
     
      state: state
     
     <a id="_idIndexMarker599">
     </a>
     
      with
     
     
      
       child states
      
     
    </li>
    <li>
     <strong class="bold">
      
       State enter condition
      
     </strong>
     
      : lists
     
     <a id="_idIndexMarker600">
     </a>
     
      the conditions that decide if a state can
     
     
      
       be selected
      
     
    </li>
    <li>
     <strong class="bold">
      
       Task
      
     </strong>
     
      : lists a set of actions
     
     <a id="_idIndexMarker601">
     </a>
     
      that will be executed when a state
     
     
      
       is activated
      
     
    </li>
    <li>
     <strong class="bold">
      
       Transition
      
     </strong>
     
      : the
     
     <a id="_idIndexMarker602">
     </a>
     
      conditions that will trigger the state
     
     
      
       selection process
      
     
    </li>
   </ul>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     In case you are wondering, state trees and behavior trees are both decision-making architectures used in AI, but they serve different purposes.
    
    
     State trees are structured around discrete states and transitions, focusing on the current state of an entity and how it changes in response to events.
    
    
     This makes them suitable for scenarios where clear, distinct states are necessary.
    
    
     In contrast, behavior trees are designed for more complex and fluid decision-making, allowing for modular and hierarchical task execution.
    
    
     They enable smoother transitions between tasks and can handle more intricate behaviors by combining simple actions into
    
    
     
      complex sequences.
     
    
   </p>
   <p>
    
     Now that you have a basic understanding of the main state tree terminology, we will show how to extend your own
    
    
     
      state trees.
     
    
   </p>
   <h2 id="_idParaDest-235">
    <a id="_idTextAnchor237">
    </a>
    
     Extending state trees
    
   </h2>
   <p>
    
     A state tree can be created to be
    
    <a id="_idIndexMarker603">
    </a>
    
     executed on an AI controller or directly from an actor.
    
    
     There are two different components available to handle a
    
    
     
      state tree:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       StateTreeComponent
      
     </strong>
     
      : This can be attached to any actor and be executed by the
     
     
      
       actor itself
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       StateTreeAIComponent
      
     </strong>
     
      : This can be attached to any AI controller and be executed by the AI
     
     
      
       controller itself
      
     
    </li>
   </ul>
   <p>
    
     Additionally, as you may have already guessed, the state tree system has been created with extensibility in mind, which means you can create your own tasks, evaluators, and conditions.
    
    
     Although you can create your own C++ structures, state trees have been implemented with Blueprint creation in mind.
    
    
     In particular, the main classes available are
    
    
     
      as follows:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       StateTreeTaskBlueprintBase
      
     </strong>
     
      : Used for implementing your
     
     
      
       own tasks
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       StateTreeEvaluatorBlueprintBase
      
     </strong>
     
      : Used for implementing your
     
     
      
       own evaluators
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       StateTreeConditionBlueprintBase
      
     </strong>
     
      : Used for implementing your
     
     
      
       own conditions
      
     
    </li>
   </ul>
   <p>
    
     When extending state trees, it’s advisable to implement your own node logic using Blueprints rather than C++.
    
    
     This approach can enhance flexibility and ease
    
    
     
      of use.
     
    
   </p>
   <h2 id="_idParaDest-236">
    <a id="_idTextAnchor238">
    </a>
    
     Understanding the state tree flow
    
   </h2>
   <p>
    
     State selection
    
    <a id="_idIndexMarker604">
    </a>
    
     in a state tree starts from the tree root and continues down the tree by evaluating each enter conditions.
    
    
     The evaluation process
    
    <a id="_idIndexMarker605">
    </a>
    
     follows
    
    
     
      these steps:
     
    
   </p>
   <ul>
    <li>
     
      If enter conditions are not satisfied, selection goes to the next
     
     
      
       sibling state
      
     
    </li>
    <li>
     
      If enter conditions are satisfied and the state is a leaf, it is selected as the
     
     
      
       new state
      
     
    </li>
    <li>
     
      If enter conditions are satisfied but the state is not a leaf, the process is executed for the first
     
     
      
       child state
      
     
    </li>
   </ul>
   <p>
    
     It should be noted that state selection is run dynamically, triggered by transitions.
    
    
     During the first tick, there is an implicit transition to the root state, which then determines the initial state to be executed.
    
    
     Subsequently, once this state is chosen, the transitions specify the conditions that trigger the selection logic, determining when and where it will
    
    
     
      be executed.
     
    
   </p>
   <p>
    
     Once a state is selected, all its tasks are executed and will keep on executing until a transition triggers a new state
    
    
     
      selection process.
     
    
   </p>
   <h2 id="_idParaDest-237">
    <a id="_idTextAnchor239">
    </a>
    
     Data binding
    
   </h2>
   <p>
    
     In game
    
    <a id="_idIndexMarker606">
    </a>
    
     programming,
    
    <strong class="bold">
     
      data binding
     
    </strong>
    
     refers
    
    <a id="_idIndexMarker607">
    </a>
    
     to the process of connecting data between different parts of the game – such as the user interface and the game logic – and it involves creating a link that allows data to be synchronized and updated across various elements of the game.
    
    
     This helps in keeping the game elements consistent and up to date with the
    
    
     
      latest information.
     
    
   </p>
   <p>
    
     State trees use data binding for transferring data within the tree and to establish conditions or configure tasks for execution.
    
    
     Data binding allows access to data passed into the state tree or between nodes in a
    
    
     
      specified manner.
     
    
   </p>
   <p>
    
     State tree nodes have the following elements available to implement
    
    
     
      data binding:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Parameters
      
     </strong>
     
      : These
     
     <a id="_idIndexMarker608">
     </a>
     
      can be referenced during the
     
     
      
       tree’s execution
      
     
    </li>
    <li>
     <strong class="bold">
      
       Context data
      
     </strong>
     
      : This
     
     <a id="_idIndexMarker609">
     </a>
     
      represents predefined data available to the
     
     
      
       state tree
      
     
    </li>
    <li>
     <strong class="bold">
      
       Evaluators
      
     </strong>
     
      : These
     
     <a id="_idIndexMarker610">
     </a>
     
      are separate classes that can be executed at runtime and that expose data that could not be made available with parameters and
     
     
      
       context data
      
     
    </li>
    <li>
     <strong class="bold">
      
       Global tasks
      
     </strong>
     
      : These
     
     <a id="_idIndexMarker611">
     </a>
     
      are executed before the root state and can be used when you need permanent data during
     
     
      
       state selection
      
     
    </li>
   </ul>
   <p>
    
     It is also worth mentioning that nodes in a state tree share data among themselves and can bind data in three ways that have been
    
    
     
      previously mentioned:
     
    
   </p>
   <ul>
    <li>
     
      State
     
     
      
       enter conditions
      
     
    </li>
    <li>
     
      
       Transition conditions
      
     
    </li>
    <li>
     
      
       Tasks
      
     
    </li>
   </ul>
   <p>
    
     In this section, we introduced state trees and their key features.
    
    
     In the following section, we will delve into practical exercises by crafting our own state trees in order to use them effectively within a
    
    
     
      gym setting.
     
    
   </p>
   <h1 id="_idParaDest-238">
    <a id="_idTextAnchor240">
    </a>
    
     Creating and managing state trees
    
   </h1>
   <p>
    
     From this section onward, we will be creating a new gym based on a couple of AI agents using state trees instead of behavior trees.
    
    
     This will help us to understand the basic principles behind this new
    
    
     
      development pattern.
     
    
   </p>
   <p>
    
     To help us
    
    <a id="_idIndexMarker612">
    </a>
    
     understand
    
    <a id="_idIndexMarker613">
    </a>
    
     these principles, we’ll be doing
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create/place an actor in the level who will periodically emit a noise by using a dedicated
     
     
      
       state tree
      
     
    </li>
    <li>
     
      Create/place a dummy character who will be managed by another state tree and will do
     
     
      
       the following:
      
     
     <ul>
      <li>
       
        Stay idle in its
       
       
        
         starting location
        
       
      </li>
      <li>
       
        Reach the noise location whenever a noise
       
       
        
         is perceived
        
       
      </li>
      <li>
       
        Get
       
       <a id="_idIndexMarker614">
       </a>
       
        back to its starting
       
       <a id="_idIndexMarker615">
       </a>
       
        location after a brief time investigating
       
       
        
         the location
        
       
      </li>
     </ul>
    </li>
   </ul>
   <p>
    
     Although pretty simple, this logic can be used as a starting point for a guard AI agent that will investigate a level looking for intruders and responding to any suspicious
    
    
     
      noise around.
     
    
   </p>
   <p>
    
     As the state trees feature is not enabled by default, the first thing to do will be to get to the
    
    <strong class="bold">
     
      Plugins
     
    </strong>
    
     window and
    
    
     
      enable it.
     
    
   </p>
   <h2 id="_idParaDest-239">
    <a id="_idTextAnchor241">
    </a>
    
     Enabling state trees plugins
    
   </h2>
   <p>
    
     To start working with
    
    <a id="_idIndexMarker616">
    </a>
    
     state trees, you will need to enable a couple of dedicated plugins.
    
    
     In order to do so, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Open the
     
     <strong class="bold">
      
       Plugin
      
     </strong>
     
      window by selecting
     
     <strong class="bold">
      
       Edit
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Plugins
      
     </strong>
     
      from the
     
     
      
       main menu.
      
     
    </li>
    <li>
     
      Search for the
     
     <strong class="bold">
      
       GameplayStateTree
      
     </strong>
     
      and
     
     <strong class="bold">
      
       StateTree
      
     </strong>
     
      plugins and
     
     
      
       enable them.
      
     
    </li>
    <li>
     
      Restart the Unreal Engine Editor to
     
     
      
       activate them.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.2 – Plugin window" src="img/Figure_12.2_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.2 – Plugin window
    
   </p>
   <p>
    
     If you plan to use state
    
    <a id="_idIndexMarker617">
    </a>
    
     trees with C++ (and we do), you will need to add a module to the Unreal Engine
    
    
     
      build file.
     
    
   </p>
   <p>
    
     In our case, we will need to include the
    
    <strong class="source-inline">
     
      GameplayStateTreeModule
     
    </strong>
    
     dependency in the build, so that the module will be available to your C++ implementation.
    
    
     In order to do so, open your IDE and locate the
    
    <strong class="source-inline">
     
      UnrealAgilityArena.build.cs
     
    </strong>
    
     file in your project; it should be located in the
    
    
     <strong class="source-inline">
      
       UnrealAgilityArena/Source
      
     </strong>
    
    
     
      folder.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     The Unreal Engine
    
    <strong class="source-inline">
     
      .build.cs
     
    </strong>
    
     file is responsible for defining how the project is built, including options for defining
    
    
     
      module dependencies.
     
    
   </p>
   <p>
    
     Look for this line
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore" });</pre>
   <p>
    
     Update it to
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "GameplayStateTreeModule" });</pre>
   <p>
    
     So, once you declare this module, you will have all that’s needed to work with state trees
    
    
     
      in C++.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     At the time of writing this book, there seem to be some issues in declaring a
    
    <strong class="source-inline">
     
      StateTreeAIComponent
     
    </strong>
    
     class in C++, while the
    
    <strong class="source-inline">
     
      StateTreeComponent
     
    </strong>
    
     class is working just fine.
    
    
     Basically, the
    
    <strong class="source-inline">
     
      StateTreeAIComponent
     
    </strong>
    
     class seems to be unavailable in the module, and using this class won’t compile your project.
    
    
     To overcome this issue, we will be adding the
    
    <strong class="source-inline">
     
      StateTreeAIComponent
     
    </strong>
    
     class from Blueprint
    
    
     
      when needed.
     
    
   </p>
   <p>
    
     Once the plugins have been activated, we can start implementing our first AI agent using a state tree: the
    
    
     
      noise emitter.
     
    
   </p>
   <h2 id="_idParaDest-240">
    <a id="_idTextAnchor242">
    </a>
    
     Implementing a noise emitter actor
    
   </h2>
   <p>
    
     We will be now creating an
    
    <a id="_idIndexMarker618">
    </a>
    
     actor whose sole aim will be to periodically emit a noise by means of
    
    <a id="_idIndexMarker619">
    </a>
    
     the
    
    <strong class="bold">
     
      Perception System
     
    </strong>
    
     .
    
    
     This task is straightforward and can be implemented in any manner you find suitable.
    
    
     However, for this demonstration, we will use state trees to grasp the fundamental principles of
    
    
     
      this system.
     
    
   </p>
   <h3>
    
     Creating the noise emitter class
    
   </h3>
   <p>
    
     We will be starting by
    
    <a id="_idIndexMarker620">
    </a>
    
     creating the base class for the noise emitter; we will need to declare all the visual elements and, most importantly, the needed Perception System component and the state tree component.
    
    
     Moreover, we will include a function to generate the noise, without concerning ourselves with the logic that will manage it; this responsibility will be delegated to the
    
    
     
      state tree.
     
    
   </p>
   <p>
    
     Let’s start by creating a new C++ class extending
    
    <strong class="source-inline">
     
      Actor
     
    </strong>
    
     and call it
    
    <strong class="source-inline">
     
      BaseNoiseEmitter
     
    </strong>
    
     .
    
    
     Once the class has been created, open the
    
    <strong class="source-inline">
     
      BaseNoiseEmitter.h
     
    </strong>
    
     file and add the following forward declarations after the
    
    <strong class="source-inline">
     
      #
     
    </strong>
    
     <strong class="source-inline">
      
       include
      
     </strong>
    
    
     
      declarations:
     
    
   </p>
   <pre class="source-code">
class UAIPerceptionStimuliSourceComponent;
class UStateTreeComponent;</pre>
   <p>
    
     After that, make the class an acceptable base class for Blueprints by changing the
    
    <strong class="source-inline">
     
      UCLASS()
     
    </strong>
    
     macro into
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
UCLASS(Blueprintable)</pre>
   <p>
    
     Look for the
    
    <strong class="source-inline">
     
      Tick()
     
    </strong>
    
     declaration and remove it as we won’t be
    
    
     
      using it.
     
    
   </p>
   <p>
    
     Next, add the needed
    
    <a id="_idIndexMarker621">
    </a>
    
     components just after the
    
    
     <strong class="source-inline">
      
       GENERATED_BODY()
      
     </strong>
    
    
     
      macro:
     
    
   </p>
   <pre class="source-code">
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category="Dummy Target", meta=(AllowPrivateAccess="true"))
UStaticMeshComponent* BaseMeshComponent;
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category="Dummy Target", meta=(AllowPrivateAccess="true"))
UStaticMeshComponent* DummyMeshComponent;
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category="Dummy Target", meta=(AllowPrivateAccess="true"))
UAIPerceptionStimuliSourceComponent* PerceptionStimuliSourceComponent;
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category="Dummy Target", meta=(AllowPrivateAccess="true"))
UStateTreeComponent* StateTreeComponent;</pre>
   <p>
    
     As you can see from the preceding code, we will be using a few static meshes, as well as the needed state tree and Perception
    
    
     
      System components.
     
    
   </p>
   <p>
    
     Now, just after the constructor declaration, add the
    
    
     
      following declarations:
     
    
   </p>
   <pre class="source-code">
UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Noise Generation")
float MaxNoiseRange = 3000.f;
UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Noise Generation")
float NoiseRangeRandomDeviation = 100.f;
UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Noise Generation")
FName NoiseTag = "EmitterNoise";
UFUNCTION(BlueprintCallable)
void EmitNoise();</pre>
   <p>
    
     As you can see, we are exposing some properties to customize our emitter instances in the level, and we are declaring an
    
    <strong class="source-inline">
     
      EmitNoise()
     
    </strong>
    
     function that we will be using to activate the noise emission when needed.
    
    
     Finally, the
    
    <strong class="source-inline">
     
      NoiseTag
     
    </strong>
    
     property will be used to tag the noise and be
    
    <a id="_idIndexMarker622">
    </a>
    
     recognized by listening
    
    
     
      AI agents.
     
    
   </p>
   <p>
    
     It’s now time to open the
    
    <strong class="source-inline">
     
      BaseNoiseEmitter.cpp
     
    </strong>
    
     file and implement the methods.
    
    
     As a first step, remove the
    
    <strong class="source-inline">
     
      Tick()
     
    </strong>
    
     function and, in the constructor, modify this line
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
PrimaryActorTick.bCanEverTick = true;</pre>
   <p>
    
     Modify it
    
    
     
      into this:
     
    
   </p>
   <pre class="source-code">
PrimaryActorTick.bCanEverTick = false;</pre>
   <p>
    
     After that, add the needed
    
    <strong class="source-inline">
     
      #include
     
    </strong>
    
     declarations, so add this block of code at the top of
    
    
     
      the file:
     
    
   </p>
   <pre class="source-code">
#include "Components/StateTreeComponent.h"
#include "Perception/AIPerceptionStimuliSourceComponent.h"
#include "Perception/AISense_Hearing.h"</pre>
   <p>
    
     Now, let’s initialize the
    
    <a id="_idIndexMarker623">
    </a>
    
     static mesh components inside the constructor by adding the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
BaseMeshComponent = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT("BaseMesh"));
RootComponent = BaseMeshComponent;
static ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;   BaseStaticMeshAsset(
    TEXT("/Game/KayKit/SpaceBase/landingpad_large.landingpad_large"));
if (BaseStaticMeshAsset.Succeeded())
{
    BaseMeshComponent-&gt;SetStaticMesh(BaseStaticMeshAsset.Object);
}
DummyMeshComponent = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT
  ("DummyMesh"));
DummyMeshComponent-&gt;SetupAttachment(RootComponent);
DummyMeshComponent-&gt;SetRelativeRotation(FRotator
  (0.f, -90.f, 0.f));
DummyMeshComponent-&gt;SetRelativeLocation(FVector
  (0.f, 0.f,  80.f));
static ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;   DummyStaticMeshAsset(TEXT("/Game/KayKit/PrototypeBits/Models/Dummy_    Base.Dummy_Base"));
if (DummyStaticMeshAsset.Succeeded())
{
    DummyMeshComponent-&gt;SetStaticMesh(DummyStaticMeshAsset.Object);
}</pre>
   <p>
    
     You should be
    
    <a id="_idIndexMarker624">
    </a>
    
     already familiar with all of this, so we can go on and declare the stimuli source for the Perception System and the state tree by adding this piece
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
PerceptionStimuliSourceComponent = CreateDefaultSubobject   &lt;UAIPerceptionStimuliSourceComponent&gt;(TEXT("PerceptionStimuli     Source"));
PerceptionStimuliSourceComponent-&gt;RegisterForSense   (UAISense_Hearing::StaticClass());
StateTreeComponent = CreateDefaultSubobject&lt;UStateTreeComponent&gt;(TEXT
  ("StateTree"));</pre>
   <p>
    
     As you can see, we are just creating the needed components; additionally, we are registering the hearing sense as a stimuli source for the
    
    
     
      Perception System.
     
    
   </p>
   <p>
    
     Now, in the
    
    <strong class="source-inline">
     
      BeginPlay()
     
    </strong>
    
     function, add the following lines
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
PerceptionStimuliSourceComponent-&gt;RegisterWithPerceptionSystem();
StateTreeComponent-&gt;StartLogic();</pre>
   <p>
    
     Here, we are registering the Perception System, and we are starting the logic for the state tree.
    
    
     This means that as soon as the game starts, the state tree will
    
    
     
      begin executing.
     
    
   </p>
   <p>
    
     The last thing to do is implement the
    
    <strong class="source-inline">
     
      EmitNoise()
     
    </strong>
    
     function, so add this piece
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
void ABaseNoiseEmitter::EmitNoise()
{
    const auto NoiseRange = MaxNoiseRange +
      FMath::RandRange(-1.f * NoiseRangeRandomDeviation,
      NoiseRangeRandomDeviation);
    UAISense_Hearing::ReportNoiseEvent(GetWorld(),
      GetActorLocation(), 1.f, this, NoiseRange, NoiseTag);
}</pre>
   <p>
    
     In
    
    <a href="B31016_10.xhtml#_idTextAnchor198">
     
      <em class="italic">
       
        Chapter 10
       
      </em>
     
    </a>
    
     ,
    
    <em class="italic">
     
      Improving Agents with the Perception System
     
    </em>
    
     , you already learned how to handle the sight sense.
    
    
     With the sense of hearing, things are slightly different; while being visible is a continuous occurrence, being heard only occurs when you make noise.
    
    
     This is why we randomize a noise range – based on the previously declared properties – and
    
    <a id="_idIndexMarker625">
    </a>
    
     we use the
    
    <strong class="source-inline">
     
      ReportNoiseEvent()
     
    </strong>
    
     function to emit the
    
    
     
      actual noise.
     
    
   </p>
   <p>
    
     This class is ready, and we can now focus on the actual state tree creation, starting from a custom task: something that will tell the actor to emit
    
    
     
      the noise.
     
    
   </p>
   <h3>
    
     Creating the emit noise task
    
   </h3>
   <p>
    
     The state
    
    <a id="_idIndexMarker626">
    </a>
    
     tree task we will be creating needs to just tell the
    
    <strong class="source-inline">
     
      BaseNoiseEmitter
     
    </strong>
    
     instance to execute the
    
    <strong class="source-inline">
     
      EmitNoise()
     
    </strong>
    
     function.
    
    
     This task will be created as a Blueprint class so, inside
    
    <strong class="bold">
     
      Content Browser
     
    </strong>
    
     of the Unreal Engine Editor, navigate to the
    
    <strong class="source-inline">
     
      AI
     
    </strong>
    
     folder and do
    
    
     
      the following:
     
    
   </p>
   <ol>
    <li>
     
      Create a new Blueprint class extending from
     
     <strong class="bold">
      
       StateTreeTaskBlueprintBase
      
     </strong>
     
      and name it
     
     <strong class="source-inline">
      
       STT_EmitNoise
      
     </strong>
     
      .
     
     
      Double-click on it to
     
     
      
       open it.
      
     
    </li>
    <li>
     
      In the
     
     <strong class="bold">
      
       My Blueprints
      
     </strong>
     
      panel, hover over the
     
     <strong class="bold">
      
       FUNCTIONS
      
     </strong>
     
      section and click the
     
     <strong class="bold">
      
       Override
      
     </strong>
     
      dropdown menu that
     
     
      
       shows up.
      
     
    </li>
    <li>
     
      Select the
     
     <strong class="bold">
      
       Enter State
      
     </strong>
     
      option, as depicted in
     
     
      <em class="italic">
       
        Figure 12
       
      </em>
     
     
      <em class="italic">
       
        .3
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.3 – Enter State function creation" src="img/Figure_12.3_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.3 – Enter State function creation
    
   </p>
   <p class="list-inset">
    
     An
    
    <strong class="bold">
     
      Event Enter State
     
    </strong>
    
     node will be added to the Event Graph; this event will be executed when a new state in the state tree is entered and if the task is part of the
    
    
     
      active states.
     
    
   </p>
   <p class="list-inset">
    
     For this state, we need a reference to the owning actor; as previously mentioned, state trees use data binding for communicating.
    
    
     Therefore, we will take advantage of this feature to create the reference.
    
    
     To do this, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li value="4">
     
      Create a new variable that is an
     
     <strong class="bold">
      
       Object Reference
      
     </strong>
     
      of the
     
     <strong class="bold">
      
       BaseNoiseEmitter
      
     </strong>
     
      type and name
     
     
      
       it
      
     
     
      <strong class="source-inline">
       
        Actor
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Select the variable
     
     <a id="_idIndexMarker627">
     </a>
     
      and, in the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, locate the
     
     <strong class="bold">
      
       Category
      
     </strong>
     
      attribute and, in the
     
     <strong class="bold">
      
       Input
      
     </strong>
     
      field, type
     
     <strong class="source-inline">
      
       Context
      
     </strong>
     
      , as shown in
     
     
      <em class="italic">
       
        Figure 12
       
      </em>
     
     
      <em class="italic">
       
        .4
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.4 – Context category" src="img/Figure_12.4_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.4 – Context category
    
   </p>
   <p class="list-inset">
    
     While variable creation is self-explanatory, setting the category name to a value of
    
    <strong class="bold">
     
      Context
     
    </strong>
    
     needs some explanation; whenever you add a property to the
    
    <strong class="bold">
     
      Context
     
    </strong>
    
     category, the property itself will be exposed through data binding to the state tree the task will be executed in.
    
    
     This comes quite handy when you need to get information from the executing state tree and
    
    
     
      vice versa.
     
    
   </p>
   <p class="list-inset">
    
     With this new reference available, do the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li value="6">
     
      From the
     
     <strong class="bold">
      
       Variables
      
     </strong>
     
      section, drag the
     
     <strong class="bold">
      
       Actor
      
     </strong>
     
      variable into the Event Graph and add a
     
     <strong class="bold">
      
       Get
      
     </strong>
     
      <strong class="bold">
       
        Actor
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      From the outgoing pin of the
     
     <strong class="bold">
      
       Actor
      
     </strong>
     
      node, connect an
     
     <strong class="bold">
      
       Emit
      
     </strong>
     
      <strong class="bold">
       
        Noise
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Connect the outgoing execution pin of the
     
     <strong class="bold">
      
       Event Enter State
      
     </strong>
     
      node with the incoming execution pin of the
     
     <strong class="bold">
      
       Emit
      
     </strong>
     
      <strong class="bold">
       
        Noise
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      From the outgoing execution pin of the
     
     <strong class="bold">
      
       Emit Noise
      
     </strong>
     
      node, connect a
     
     <strong class="bold">
      
       Finish
      
     </strong>
     
      <strong class="bold">
       
        Task
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Check the
     
     <strong class="bold">
      
       Succeeded
      
     </strong>
     
      checkbox of the
     
     <strong class="bold">
      
       Finish Task
      
     </strong>
     
      node.
     
     
      The final graph should look
     
     <a id="_idIndexMarker628">
     </a>
     
      like the one depicted in
     
     
      <em class="italic">
       
        Figure 12
       
      </em>
     
     
      <em class="italic">
       
        .5
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.5 – Emit Noise graph" src="img/Figure_12.5_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.5 – Emit Noise graph
    
   </p>
   <p>
    
     The only thing worth mentioning here is the
    
    <strong class="bold">
     
      Finish Task
     
    </strong>
    
     node that will return a success value after emitting the noise.
    
    
     Now that this task is complete, we can finally start working on the
    
    
     
      state tree.
     
    
   </p>
   <h3>
    
     Creating the noise emitter state tree
    
   </h3>
   <p>
    
     As previously stated, we will
    
    <a id="_idIndexMarker629">
    </a>
    
     be executing the state tree from an actor; this means we will need something that can be used with the
    
    <strong class="source-inline">
     
      StateTreeComponent
     
    </strong>
    
     class.
    
    
     In order to do so, we will need to create an asset that follows the rules dictated by a
    
    <strong class="source-inline">
     
      StateTreeComponentSchema
     
    </strong>
    
     class that guarantees access to the actor executing the state tree.
    
    
     To create such an asset, do the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      In
     
     <strong class="bold">
      
       Content Browser
      
     </strong>
     
      , open the
     
     <strong class="source-inline">
      
       AI
      
     </strong>
     
      folder, right-click on it, and select
     
     <strong class="bold">
      
       Artificial Intelligence
      
     </strong>
     
      |
     
     
      <strong class="bold">
       
        State Tree
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      From the
     
     <strong class="bold">
      
       Pick Schema for State Tree
      
     </strong>
     
      pop-up window,
     
     
      
       select
      
     
     
      <strong class="bold">
       
        StateTreeComponentSchema
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.6 – State tree creation" src="img/Figure_12.6_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.6 – State tree creation
    
   </p>
   <ol>
    <li value="3">
     
      Name the
     
     <a id="_idIndexMarker630">
     </a>
     
      newly created asset
     
     <strong class="source-inline">
      
       ST_NoiseEmitter
      
     </strong>
     
      and double-click on it to
     
     
      
       open it.
      
     
     <p class="list-inset">
      
       Once the asset is opened, locate the
      
      <strong class="bold">
       
        StateTree
       
      </strong>
      
       tab to the left of the Editor and notice that there is a
      
      <strong class="bold">
       
        Context Actor Class
       
      </strong>
      
       property, as shown in
      
      
       <em class="italic">
        
         Figure 12
        
       </em>
      
      
       <em class="italic">
        
         .7
        
       </em>
      
      
       
        :
       
      
     </p>
    </li>
   </ol>
   <div><div><img alt="Figure 12.7 – State Tree context actor" src="img/Figure_12.7_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.7 – State Tree context actor
    
   </p>
   <p class="list-inset">
    
     This is the reference to the owning actor; at the moment, it is set to a generic actor but we need to be more specific, so click on the dropdown menu and select an
    
    <strong class="bold">
     
      Object Reference
     
    </strong>
    
     of
    
    <strong class="bold">
     
      BaseNoiseEmitter
     
    </strong>
    
     .
    
    
     From now on, each node of the tree will be granted access to
    
    
     
      this reference.
     
    
   </p>
   <p>
    
     Now, let’s start implementing the state
    
    
     
      tree logic:
     
    
   </p>
   <ol>
    <li>
     
      Click the
     
     <strong class="bold">
      
       Add State
      
     </strong>
     
      button three times to create
     
     
      
       three states.
      
     
    </li>
    <li>
     
      Select each of them and, in the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, name them
     
     <strong class="source-inline">
      
       Random Delay
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       Debug Message
      
     </strong>
     
      , and
     
     <strong class="source-inline">
      
       Emit Noise
      
     </strong>
     
      , respectively.
     
     
      Your state tree should be similar to the one depicted in
     
     
      <em class="italic">
       
        Figure 12
       
      </em>
     
     
      <em class="italic">
       
        .8
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.8 – Initial states" src="img/Figure_12.8_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.8 – Initial states
    
   </p>
   <p class="list-inset">
    
     As you can see, we
    
    <a id="_idIndexMarker631">
    </a>
    
     have created the basis structure for the state tree with three main states that will wait for a random time, display a debug message, and finally emit
    
    
     
      the noise.
     
    
   </p>
   <p class="list-inset">
    
     We now need to implement each of the states with their own tasks and transitions; let’s start from the first one.
    
    
     Select the
    
    <strong class="bold">
     
      Random Delay
     
    </strong>
    
     task and do
    
    
     
      the following:
     
    
   </p>
   <ol>
    <li value="3">
     
      In the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, locate the
     
     <strong class="bold">
      
       Tasks
      
     </strong>
     
      section and click the
     
     <strong class="bold">
      
       +
      
     </strong>
     
      button to add a
     
     
      
       new task.
      
     
    </li>
    <li>
     
      From the newly created task, click the dropdown menu and select
     
     
      <strong class="bold">
       
        Delay Task
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Expand the task by clicking the tiny arrow icon next to the task name.
     
     
      Set the
     
     <strong class="bold">
      
       Duration
      
     </strong>
     
      attribute to
     
     <strong class="source-inline">
      
       10.0
      
     </strong>
     
      and the
     
     <strong class="bold">
      
       Random Deviation
      
     </strong>
     
      attribute
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        3.0
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Locate the
     
     <strong class="bold">
      
       Transitions
      
     </strong>
     
      section and click the
     
     <strong class="bold">
      
       +
      
     </strong>
     
      button to create a
     
     
      
       new transition.
      
     
    </li>
    <li>
     
      You should see an item labeled
     
     <strong class="bold">
      
       On State Transition Completed Go to State Root
      
     </strong>
     
      .
     
     
      Click on the tiny arrow icon to expand it, and from the dropdown menu of the
     
     <strong class="bold">
      
       Transition To
      
     </strong>
     
      attribute, select
     
     <strong class="bold">
      
       Next State
      
     </strong>
     
      .
     
     
      This state should look like the one depicted in
     
     
      <em class="italic">
       
        Figure 12
       
      </em>
     
     
      <em class="italic">
       
        .9
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.9 – Random delay state" src="img/Figure_12.9_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.9 – Random delay state
    
   </p>
   <p class="list-inset">
    
     We can now
    
    <a id="_idIndexMarker632">
    </a>
    
     start working on the second state – that is,
    
    <strong class="bold">
     
      Debug Message
     
    </strong>
    
     – that is going to display an in-game message.
    
    
     This is obviously not mandatory for making our state tree work, but it serves the purpose of learning how things work.
    
    
     Select this state and do
    
    
     
      the following:
     
    
   </p>
   <ol>
    <li value="8">
     
      In the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, locate the
     
     <strong class="bold">
      
       Tasks
      
     </strong>
     
      section and click the
     
     <strong class="bold">
      
       +
      
     </strong>
     
      button to add a
     
     
      
       new task.
      
     
    </li>
    <li>
     
      From the newly created task, click the dropdown menu and select
     
     <strong class="bold">
      
       Debug
      
     </strong>
     
      <strong class="bold">
       
        Text Task
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Expand the task by clicking the tiny arrow icon next to the task name.
     
     
      Set the
     
     <strong class="bold">
      
       Text
      
     </strong>
     
      property value to
     
     <strong class="bold">
      
       Emitting Noise!
      
     </strong>
     
      and the
     
     <strong class="bold">
      
       Text Color
      
     </strong>
     
      property to a color of your choice – in my case, I opted for a
     
     
      
       bright yellow.
      
     
    </li>
    <li>
     
      Create another task; click the dropdown menu and select
     
     
      <strong class="bold">
       
        Delay Task
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Expand the task by clicking the tiny arrow icon next to the task name and set the
     
     <strong class="bold">
      
       Duration
      
     </strong>
     
      attribute
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        0.5
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Locate the
     
     <strong class="bold">
      
       Transitions
      
     </strong>
     
      section and click the
     
     <strong class="bold">
      
       +
      
     </strong>
     
      button to create a
     
     
      
       new transition.
      
     
    </li>
    <li>
     
      You should see an item labeled
     
     <strong class="bold">
      
       On State Transition Completed Go to State Root
      
     </strong>
     
      ; click on the tiny arrow icon to expand it and, from the dropdown menu of the
     
     <strong class="bold">
      
       Transition To
      
     </strong>
     
      attribute, select
     
     <strong class="bold">
      
       Next State
      
     </strong>
     
      .
     
     
      This state should look like the one
     
     <a id="_idIndexMarker633">
     </a>
     
      depicted in
     
     
      <em class="italic">
       
        Figure 12
       
      </em>
     
     
      <em class="italic">
       
        .10
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.10 – Debug Message state" src="img/Figure_12.10_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.10 – Debug Message state
    
   </p>
   <p class="list-inset">
    
     Now select the last state – that is,
    
    <strong class="bold">
     
      Emit Noise
     
    </strong>
    
     – and do
    
    
     
      the following:
     
    
   </p>
   <ol>
    <li value="15">
     
      Add a new task, of the
     
     <strong class="bold">
      
       STT Emit
      
     </strong>
     
      <strong class="bold">
       
        Noise
       
      </strong>
     
     
      
       type.
      
     
    </li>
    <li>
     
      Expand the task by clicking the tiny arrow icon; you should notice a property named
     
     <strong class="bold">
      
       Actor
      
     </strong>
     
      and labeled
     
     <strong class="bold">
      
       CONTEXT
      
     </strong>
     
      .
     
     
      On its far right, you should see a dropdown menu arrow.
     
     
      Click on it to open it and
     
     
      
       select
      
     
     
      <strong class="bold">
       
        Actor
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <p class="IMG---Figure">
   </p>
   <div><div><img alt="Figure 12.11 – Binding" src="img/Figure_12.11_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.11 – Binding
    
   </p>
   <p class="list-inset">
    
     This last action created the binding between the
    
    <strong class="bold">
     
      Actor
     
    </strong>
    
     property of the state tree and the
    
    <strong class="bold">
     
      Actor
     
    </strong>
    
     property we added when we created the
    
    <strong class="bold">
     
      STT_EmitNoise
     
    </strong>
    
     task.
    
    
     This last property has been exposed because in the task Blueprint; we set its category
    
    
     
      to
     
    
    
     <strong class="bold">
      
       Context
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p class="list-inset">
    
     This last
    
    <a id="_idIndexMarker634">
    </a>
    
     state will look like the one shown in
    
    
     <em class="italic">
      
       Figure 12
      
     </em>
    
    
     <em class="italic">
      
       .12
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 12.12 – Emit noise state" src="img/Figure_12.12_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.12 – Emit noise state
    
   </p>
   <p>
    
     Please note that we didn’t add a transition for this task.
    
    
     The default behavior is to point to the
    
    <strong class="bold">
     
      Root
     
    </strong>
    
     node, and we want to create an infinite loop, so we simply leave the
    
    
     
      default behavior.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     If you are unfamiliar with data binding, things might appear a bit weird initially, but do not worry.
    
    
     As you become accustomed to it, things will become quite simple and easy
    
    
     
      to understand.
     
    
   </p>
   <p>
    
     The state tree is finished and should look like
    
    
     <em class="italic">
      
       Figure 12
      
     </em>
    
    
     <em class="italic">
      
       .13
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 12.13 – Finished state tree" src="img/Figure_12.13_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.13 – Finished state tree
    
   </p>
   <p>
    
     As you can see, it is quite easy to get what’s happening in each state and how the state tree flow will progress.
    
    
     It’s time to bring everything together and get the noise emitter up
    
    
     
      and running!
     
    
   </p>
   <h3>
    
     Creating the noise emitter Blueprint
    
   </h3>
   <p>
    
     Creating the
    
    <a id="_idIndexMarker635">
    </a>
    
     Blueprint out of the
    
    <strong class="source-inline">
     
      BaseNoiseEmitter
     
    </strong>
    
     class is quite straightforward, so let’s do the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a new Blueprint class extending from
     
     <strong class="bold">
      
       BaseNoiseEmitter
      
     </strong>
     
      and name
     
     
      
       it
      
     
     
      <strong class="source-inline">
       
        BP_NoiseEmitter
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Open it and locate the
     
     <strong class="bold">
      
       State Tree
      
     </strong>
     
      attribute in the
     
     <strong class="bold">
      
       AI
      
     </strong>
     
      section.
     
     
      From the dropdown menu, set its value
     
     
      
       to
      
     
     
      <strong class="bold">
       
        ST_NoiseEmitter
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.14 – Finished BP_NoiseEmitter" src="img/Figure_12.14_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.14 – Finished BP_NoiseEmitter
    
   </p>
   <p>
    
     This is all you need to do to implement your noise emitter.
    
    
     It is important to note that what we have created is not technically an AI agent.
    
    
     This is the beauty of state trees; once you grasp the concept, you will be able to apply your logic to many different types of
    
    
     
      use cases.
     
    
   </p>
   <p>
    
     Now that the noise emitter is ready, it is time to test it out in
    
    
     
      a level.
     
    
   </p>
   <h3>
    
     Testing the noise emitter
    
   </h3>
   <p>
    
     To test the noise emitter, you will
    
    <a id="_idIndexMarker636">
    </a>
    
     just need to create a new gym and add some instances of
    
    <strong class="bold">
     
      BP_NoiseEmitter
     
    </strong>
    
     .
    
    
     To do that, start by doing
    
    
     
      the following:
     
    
   </p>
   <ol>
    <li>
     
      Create a new level, starting from the Level Instances and Packed Level Actors I provided in the
     
     
      
       project template.
      
     
    </li>
    <li>
     
      Add one or more instances of
     
     <strong class="bold">
      
       BP_NoiseEmitter
      
     </strong>
     
      to
     
     
      
       the level.
      
     
    </li>
    <li>
     
      Play
     
     
      
       the level.
      
     
    </li>
   </ol>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     Please note that the
    
    <strong class="bold">
     
      Debug Text Task
     
    </strong>
    
     message won’t be displayed if we hit the
    
    <strong class="bold">
     
      Simulate
     
    </strong>
    
     button.
    
    
     To show in-game messages, you will need to use the regular
    
    
     <strong class="bold">
      
       Play
      
     </strong>
    
    
     
      button.
     
    
   </p>
   <p>
    
     As the level is played, you will see each
    
    <strong class="bold">
     
      BP_NoiseEmitter
     
    </strong>
    
     instance showing debug messages at random times, as shown in
    
    
     <em class="italic">
      
       Figure 12
      
     </em>
    
    
     <em class="italic">
      
       .15
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 12.15 – Testing the gym" src="img/Figure_12.15_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.15 – Testing the gym
    
   </p>
   <p>
    
     In this section, we saw how to implement a state tree inside an actor.
    
    
     Starting from creating a custom task that calls a method in the owning actor, we then created our first state tree that looped indefinitely, emitting noise signals for the
    
    
     
      Perception System.
     
    
   </p>
   <p>
    
     In the following section, we will create a guard puppet that listens for noise events and responds accordingly.
    
    
     We will do this using
    
    
     
      state trees.
     
    
   </p>
   <h1 id="_idParaDest-241">
    <a id="_idTextAnchor243">
    </a>
    
     Using advanced state tree features
    
   </h1>
   <p>
    
     In this section, we will once again extend the
    
    <strong class="source-inline">
     
      BaseDummyCharacter
     
    </strong>
    
     class to create an AI agent that listens for noise signals and moves to the location where the noise was generated.
    
    
     Once the location has been checked, the AI agent will return to its original position.
    
    
     We will start by creating an AI controller that will have hearing capabilities through the Perception System and will handle its AI logic through state trees.
    
    
     We are essentially developing a guard to protect a level from intruders.
    
    
     As usual, let’s start by creating our own base
    
    
     
      C++ class.
     
    
   </p>
   <h2 id="_idParaDest-242">
    <a id="_idTextAnchor244">
    </a>
    
     Creating the C++ AI controller
    
   </h2>
   <p>
    
     The AI controller class will
    
    <a id="_idIndexMarker637">
    </a>
    
     need to implement a hearing sense and execute state tree logic.
    
    
     As mentioned earlier, at the time of writing this book, there seems to be a bug in Unreal Engine that prevents us from declaring a
    
    <strong class="source-inline">
     
      StateTreeAIComponent
     
    </strong>
    
     class in C++ so, for the time being, we will be implementing just the hearing sense and adding the state tree component from Blueprints.
    
    
     Let’s create a new C++ class called
    
    <strong class="source-inline">
     
      BaseGuardAIController
     
    </strong>
    
     .
    
    
     Then, open the
    
    <strong class="source-inline">
     
      BaseGuardAIController.h
     
    </strong>
    
     file and add the following forward declaration after the
    
    <strong class="source-inline">
     
      #
     
    </strong>
    
     <strong class="source-inline">
      
       include
      
     </strong>
    
    
     
      declarations:
     
    
   </p>
   <pre class="source-code">
struct FAIStimulus;</pre>
   <p>
    
     Then, add a
    
    <strong class="source-inline">
     
      public
     
    </strong>
    
     section with the following
    
    
     
      function declarations:
     
    
   </p>
   <pre class="source-code">
public:
    ABaseGuardAIController();
    UFUNCTION(BlueprintCallable,
      BlueprintImplementableEvent)
    void OnTargetPerceptionUpdate(AActor* Actor,
      FAIStimulus Stimulus);</pre>
   <p>
    
     We are already familiar with these function declarations but note that the
    
    <strong class="source-inline">
     
      OnTargetPerceptionUpdate()
     
    </strong>
    
     function has a
    
    <strong class="source-inline">
     
      BlueprintImplementableEvent
     
    </strong>
    
     specifier added; this will let us implement this function from an extending Blueprint instead of directly doing it from this class.
    
    
     This means we are leaving the responsibility of implementing this function to the Blueprint.
    
    
     Now, let’s open the
    
    <strong class="source-inline">
     
      BaseGuardAIController.cpp
     
    </strong>
    
     file to implement the functions.
    
    
     The
    
    <a id="_idIndexMarker638">
    </a>
    
     needed
    
    <strong class="source-inline">
     
      #include
     
    </strong>
    
     declarations you should be adding are
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
#include "Perception/AIPerceptionComponent.h"
#include "Perception/AISenseConfig_Hearing.h"</pre>
   <p>
    
     Then, add the
    
    
     
      constructor implementation:
     
    
   </p>
   <pre class="source-code">
ABaseGuardAIController::ABaseGuardAIController()
{
const auto SenseConfig_Hearing =
  CreateDefaultSubobject&lt;UAISenseConfig_Hearing&gt;
    ("SenseConfig_Hearing");
    SenseConfig_Hearing-&gt;
      DetectionByAffiliation.bDetectEnemies = true;
    SenseConfig_Hearing-&gt;
      DetectionByAffiliation.bDetectNeutrals = true;
    SenseConfig_Hearing-&gt;
      DetectionByAffiliation.bDetectFriendlies = true;
    SenseConfig_Hearing-&gt;HearingRange = 2500.f;
    SenseConfig_Hearing-&gt;SetStartsEnabled(true);
    PerceptionComponent =       CreateDefaultSubobject&lt;UAIPerceptionComponent&gt;(TEXT
      ("Perception"));
    PerceptionComponent-&gt;
      ConfigureSense(*SenseConfig_Hearing);
    PerceptionComponent-&gt;
      SetDominantSense(SenseConfig_Hearing-&gt;
        GetSenseImplementation());
    PerceptionComponent-&gt;
      OnTargetPerceptionUpdated.AddDynamic(this,
        &amp;ABaseGuardAIController::OnTargetPerceptionUpdate);
}</pre>
   <p>
    
     We already know
    
    <a id="_idIndexMarker639">
    </a>
    
     how to configure an
    
    <strong class="source-inline">
     
      AIPerceptionComponent
     
    </strong>
    
     from
    
    <a href="B31016_10.xhtml#_idTextAnchor198">
     
      <em class="italic">
       
        Chapter 10
       
      </em>
     
    </a>
    
     ,
    
    <em class="italic">
     
      Improving Agents with the Perception System
     
    </em>
    
     , so I will not bother you with extra details.
    
    
     Just pay attention to the final line of code, where we are registering the delegate that will manage the
    
    
     
      hearing stimuli.
     
    
   </p>
   <p>
    
     You can now compile your project to make this class available to the Blueprint system as, in the next few steps, we will create the AI
    
    
     
      controller Blueprint.
     
    
   </p>
   <h2 id="_idParaDest-243">
    <a id="_idTextAnchor245">
    </a>
    
     Implementing the AI controller Blueprint
    
   </h2>
   <p>
    
     Now that the base
    
    <a id="_idIndexMarker640">
    </a>
    
     AI controller is ready, we can start implementing a Blueprint version that will also manage the state tree.
    
    
     To get started, in the
    
    <strong class="source-inline">
     
      Blueprints
     
    </strong>
    
     folder, create a new Blueprint class extending from
    
    <strong class="bold">
     
      BaseGuardAIController
     
    </strong>
    
     , call it
    
    <strong class="source-inline">
     
      AIGuardController
     
    </strong>
    
     , and open it.
    
    
     Then, do the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a new variable of the
     
     <strong class="bold">
      
       Name
      
     </strong>
     
      type and call it
     
     <strong class="source-inline">
      
       NoiseTag
      
     </strong>
     
      .
     
     
      Make it
     
     <strong class="bold">
      
       Instance Editable
      
     </strong>
     
      .
     
     
      After compiling this Blueprint, set the default value for this variable
     
     
      
       to
      
     
     
      <strong class="bold">
       
        EmitterNoise
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Create another variable of the
     
     <strong class="bold">
      
       Vector
      
     </strong>
     
      type and name it
     
     <strong class="source-inline">
      
       NoiseLocation
      
     </strong>
     
      ; make it
     
     
      <strong class="bold">
       
        Instance Editable
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Create a third variable of the
     
     <strong class="bold">
      
       Vector
      
     </strong>
     
      type and name it
     
     <strong class="source-inline">
      
       StartLocation
      
     </strong>
     
      ; make it
     
     
      <strong class="bold">
       
        Instance Editable
       
      </strong>
     
     
      
       .
      
     
     <p class="list-inset">
      
       Now, let’s handle the state tree by following the steps
      
      
       
        that ensue.
       
      
     </p>
    </li>
    <li>
     
      Add a new component of the
     
     
      <strong class="bold">
       
        StateTreeAI
       
      </strong>
     
     
      
       type.
      
     
    </li>
    <li>
     
      Drag the component into the Event Graph to add a reference to the
     
     
      
       component itself.
      
     
    </li>
    <li>
     
      From the outgoing pin of the
     
     <strong class="bold">
      
       State Tree AI
      
     </strong>
     
      node, connect a
     
     <strong class="bold">
      
       Start
      
     </strong>
     
      <strong class="bold">
       
        Logic
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Connect the outgoing execution pin of the
     
     <strong class="bold">
      
       Event Begin Play
      
     </strong>
     
      node to the incoming execution pin of the
     
     <strong class="bold">
      
       Start Logic
      
     </strong>
     
      node.
     
     
      The Event Graph should look like
     
     
      <em class="italic">
       
        Figure 12
       
      </em>
     
     
      <em class="italic">
       
        .16
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.16 – Event Begin Play" src="img/Figure_12.16_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.16 – Event Begin Play
    
   </p>
   <p class="list-inset">
    
     This portion
    
    <a id="_idIndexMarker641">
    </a>
    
     of the graph will start the execution of the state tree.
    
    
     Now, let’s store the AI character’s starting location.
    
    
     To do this, follow the steps
    
    
     
      that ensue.
     
    
   </p>
   <ol>
    <li value="8">
     
      From the
     
     <strong class="bold">
      
       Variables
      
     </strong>
     
      section, drag the
     
     <strong class="bold">
      
       StartLocation
      
     </strong>
     
      variable into the Event Graph and make it a
     
     
      
       setter node.
      
     
    </li>
    <li>
     
      Connect the outgoing execution pin of the
     
     <strong class="bold">
      
       Start Logic
      
     </strong>
     
      node to the incoming execution pin of the
     
     <strong class="bold">
      
       Set Start
      
     </strong>
     
      <strong class="bold">
       
        Location
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Add a
     
     <strong class="bold">
      
       Get Actor Location
      
     </strong>
     
      node and add its
     
     <strong class="bold">
      
       Return Value
      
     </strong>
     
      pin to the
     
     <strong class="bold">
      
       Start Location
      
     </strong>
     
      pin of the
     
     <strong class="bold">
      
       Set Start
      
     </strong>
     
      <strong class="bold">
       
        Location
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Add a
     
     <strong class="bold">
      
       Get Controller Pawn
      
     </strong>
     
      node and connect its
     
     <strong class="bold">
      
       Return Value
      
     </strong>
     
      pin to the
     
     <strong class="bold">
      
       Target
      
     </strong>
     
      pin of
     
     <a id="_idIndexMarker642">
     </a>
     
      the
     
     <strong class="bold">
      
       Get Actor Location
      
     </strong>
     
      node.
     
     
      This portion of the graph is depicted in
     
     
      <em class="italic">
       
        Figure 12
       
      </em>
     
     
      <em class="italic">
       
        .17
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.17 – Store starting location" src="img/Figure_12.17_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.17 – Store starting location
    
   </p>
   <p class="list-inset">
    
     The
    
    <strong class="bold">
     
      Event BeginPlay
     
    </strong>
    
     code logic has been completed, so we can start implementing the previously declared
    
    <strong class="source-inline">
     
      OnTargetPerceptionUpdated()
     
    </strong>
    
     function.
    
    
     To do this, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li value="12">
     
      Right-click in the Event Graph and add an
     
     <strong class="bold">
      
       Event On Target Perception
      
     </strong>
     
      <strong class="bold">
       
        Update
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Click and drag from the
     
     <strong class="bold">
      
       Stimulus
      
     </strong>
     
      outgoing pin and add a
     
     <strong class="bold">
      
       Break
      
     </strong>
     
      <strong class="bold">
       
        AIStimulus
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      From the
     
     <strong class="bold">
      
       Variables
      
     </strong>
     
      panel, drag a getter node for the
     
     
      <strong class="bold">
       
        NoiseTag
       
      </strong>
     
     
      
       variable.
      
     
    </li>
    <li>
     
      From the outgoing pin of the
     
     <strong class="bold">
      
       Noise Tag
      
     </strong>
     
      node, add an
     
     <strong class="bold">
      
       Equal (==)
      
     </strong>
     
      
       node.
      
     
    </li>
    <li>
     
      Connect the
     
     <strong class="bold">
      
       Tag
      
     </strong>
     
      outgoing pin of the
     
     <strong class="bold">
      
       Break AIStimulus
      
     </strong>
     
      node to the second incoming pin of the
     
     <strong class="bold">
      
       Equal (==)
      
     </strong>
     
      
       node.
      
     
    </li>
    <li>
     
      Connect the outgoing execution pin of the
     
     <strong class="bold">
      
       Event On Target Perception Update
      
     </strong>
     
      node to a
     
     
      <strong class="bold">
       
        Branch
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Connect the
     
     <a id="_idIndexMarker643">
     </a>
     
      outgoing pin of the
     
     <strong class="bold">
      
       Equal (==)
      
     </strong>
     
      node to the
     
     <strong class="bold">
      
       Condition
      
     </strong>
     
      pin of the
     
     <strong class="bold">
      
       Break
      
     </strong>
     
      node.
     
     
      This portion of the graph is depicted in
     
     
      <em class="italic">
       
        Figure 12
       
      </em>
     
     
      <em class="italic">
       
        .18
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.18 – Check stimulus tag" src="img/Figure_12.18_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.18 – Check stimulus tag
    
   </p>
   <p class="list-inset">
    
     We now need to store the location of the noise, so let’s do the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li value="19">
     
      From the
     
     <strong class="bold">
      
       Variables
      
     </strong>
     
      section, drag the
     
     <strong class="bold">
      
       NoiseLocation
      
     </strong>
     
      reference to create a
     
     
      <strong class="bold">
       
        Set
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Connect the node’s incoming execution pin to the
     
     <strong class="bold">
      
       True
      
     </strong>
     
      execution pin of the
     
     
      <strong class="bold">
       
        Branch
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Connect the
     
     <strong class="bold">
      
       Noise Location
      
     </strong>
     
      pin of the
     
     <strong class="bold">
      
       Set Noise Location
      
     </strong>
     
      node to the
     
     <strong class="bold">
      
       Stimulus Location
      
     </strong>
     
      pin of the
     
     <strong class="bold">
      
       Break AI Stimulus
      
     </strong>
     
      node.
     
     
      This portion of the graph is shown in
     
     
      <em class="italic">
       
        Figure 12
       
      </em>
     
     
      <em class="italic">
       
        .19
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.19 – Store noise location" src="img/Figure_12.19_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.19 – Store noise location
    
   </p>
   <p class="list-inset">
    
     The last thing
    
    <a id="_idIndexMarker644">
    </a>
    
     we need to do is to notify the state tree that a noise has been heard and that the AI agent needs to respond
    
    <a id="_idIndexMarker645">
    </a>
    
     consequently.
    
    
     To do so, we will be using
    
    
     <strong class="bold">
      
       Gameplay Tags
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     In Unreal Engine, the Gameplay Tag system is used to mark and categorize gameplay elements.
    
    
     Gameplay Tags are lightweight identifiers that can be easily attached to game entities (such as actors or components) to help organize and classify them in a flexible and efficient way.
    
    
     Learning how to work with Gameplay Tags is out of the scope of this book; we will be just learning the bare minimum to properly communicate with a
    
    
     
      state tree.
     
    
   </p>
   <p class="list-inset">
    
     Let’s get on with our Event Graph implementation by doing the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li value="22">
     
      Add a
     
     <strong class="bold">
      
       Make StateTreeEvent
      
     </strong>
     
      node to
     
     
      
       the graph.
      
     
    </li>
    <li>
     
      Add a
     
     <strong class="bold">
      
       Send State Tree Event
      
     </strong>
     
      node to
     
     
      
       the graph.
      
     
    </li>
    <li>
     
      Drag a reference of the
     
     <strong class="bold">
      
       StateTreeAI
      
     </strong>
     
      component into
     
     
      
       the graph.
      
     
    </li>
    <li>
     
      Connect the outgoing execution pin of the
     
     <strong class="bold">
      
       Set Noise Location
      
     </strong>
     
      node to the incoming execution pin of the
     
     <strong class="bold">
      
       Send State Tree
      
     </strong>
     
      <strong class="bold">
       
        Event
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Connect the
     
     <strong class="bold">
      
       State Tree AI
      
     </strong>
     
      node to the
     
     <strong class="bold">
      
       Target
      
     </strong>
     
      pin of the
     
     <strong class="bold">
      
       Send State Tree
      
     </strong>
     
      <strong class="bold">
       
        Event
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Connect the outgoing pin of the
     
     <strong class="bold">
      
       Make State Tree Event
      
     </strong>
     
      node to the incoming
     
     <strong class="bold">
      
       Event
      
     </strong>
     
      pin of the
     
     <strong class="bold">
      
       Send State Tree
      
     </strong>
     
      <strong class="bold">
       
        Event
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      In the
     
     <strong class="bold">
      
       Origin
      
     </strong>
     
      input
     
     <a id="_idIndexMarker646">
     </a>
     
      field of the
     
     <strong class="bold">
      
       Make StateTreeEvent
      
     </strong>
     
      node, type
     
     <strong class="source-inline">
      
       AI Controller
      
     </strong>
     
      .
     
     
      This portion of the graph should look like
     
     
      <em class="italic">
       
        Figure 12
       
      </em>
     
     
      <em class="italic">
       
        .20
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.20 – Send State Tree Event" src="img/Figure_12.20_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.20 – Send State Tree Event
    
   </p>
   <p class="list-inset">
    
     This portion of the code is responsible for communicating with the state tree by sending an event; the event will need to be tagged in order to be recognized by the state tree itself.
    
    
     To do so, we need to create a Gameplay Tag.
    
    
     You can do this by following
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li value="29">
     
      In the
     
     <strong class="bold">
      
       Make StateTreeEvent
      
     </strong>
     
      node, click on the dropdown menu next to the
     
     <strong class="bold">
      
       Tag
      
     </strong>
     
      incoming pin.
     
     
      At the moment, it should be labeled
     
     
      
       as
      
     
     
      <strong class="bold">
       
        None
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      You will get a list of available tags; click on the
     
     <strong class="bold">
      
       Manage Gameplay Tags…
      
     </strong>
     
      option to open the
     
     <strong class="bold">
      
       Gameplay Tag
      
     </strong>
     
      <strong class="bold">
       
        Manager
       
      </strong>
     
     
      
       window.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.21 – Manage Gameplay Tags… option" src="img/Figure_12.21_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.21 – Manage Gameplay Tags… option
    
   </p>
   <ol>
    <li value="31">
     
      Once the
     
     <strong class="bold">
      
       Gameplay Tag Manager
      
     </strong>
     
      window is open, click on the
     
     <strong class="bold">
      
       +
      
     </strong>
     
      button.
     
     
      In the
     
     <strong class="bold">
      
       Name
      
     </strong>
     
      input field, enter
     
     <strong class="source-inline">
      
       UnrealAgilityArena.StateTree.HeardNoise
      
     </strong>
     
      and, in the
     
     <strong class="bold">
      
       Source
      
     </strong>
     
      field,
     
     
      
       select
      
     
     
      <strong class="bold">
       
        DefaultGameplayTags.ini
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Click the
     
     <strong class="bold">
      
       Add New Tag
      
     </strong>
     
      button
     
     <a id="_idIndexMarker647">
     </a>
     
      to confirm the creation of the new
     
     
      
       Gameplay Tag.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.22 – Create Gameplay Tag" src="img/Figure_12.22_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.22 – Create Gameplay Tag
    
   </p>
   <ol>
    <li value="33">
     
      In the
     
     <strong class="bold">
      
       Make StateTreeEvent
      
     </strong>
     
      node, click on the
     
     <strong class="bold">
      
       Tag
      
     </strong>
     
      dropdown menu and select the
     
     <strong class="bold">
      
       HeardNoise
      
     </strong>
     
      checkbox to select that
     
     
      
       gameplay tag.
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 12.23 – Select Gameplay Tag" src="img/Figure_12.23_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.23 – Select Gameplay Tag
    
   </p>
   <p>
    
     We’re almost done with the
    
    <strong class="bold">
     
      AIGuardController
     
    </strong>
    
     Blueprint; the only thing left is to include the state tree reference, but we have to create
    
    
     
      it first!
     
    
   </p>
   <h2 id="_idParaDest-244">
    <a id="_idTextAnchor246">
    </a>
    
     Implementing the state tree
    
   </h2>
   <p>
    
     Now, we are going to implement the
    
    <a id="_idIndexMarker648">
    </a>
    
     state tree.
    
    
     This time, we will be executing it from the
    
    <strong class="bold">
     
      AIGuardController
     
    </strong>
    
     Blueprint.
    
    
     That’s why we will need a subclass of the regular state tree – that is the state tree AI – that will have a reference to the owning
    
    
     
      AI controller.
     
    
   </p>
   <p>
    
     The main states will be
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Idle
      
     </strong>
     
      : The AI agent will stay at its
     
     
      
       starting location
      
     
    </li>
    <li>
     <strong class="bold">
      
       Alerted
      
     </strong>
     
      : The AI agent has been notified of a noise and it will go inspecting
     
     
      
       the location
      
     
    </li>
    <li>
     <strong class="bold">
      
       Return to Starting Location
      
     </strong>
     
      : The AI agent will get back to its
     
     
      
       starting location
      
     
    </li>
   </ul>
   <p>
    
     So, let’s start by opening the
    
    <strong class="source-inline">
     
      AI
     
    </strong>
    
     folder and doing the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Right-click and select
     
     <strong class="bold">
      
       Artificial Intelligence
      
     </strong>
     
      |
     
     
      <strong class="bold">
       
        State Tree
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      From the
     
     <strong class="bold">
      
       Pick Schema for State Tree
      
     </strong>
     
      pop-up window, select
     
     <strong class="bold">
      
       StateTreeAIComponentSchema
      
     </strong>
     
      and name the newly created asset
     
     <strong class="source-inline">
      
       STAI_Guard
      
     </strong>
     
      .
     
     
      Double-click on it to
     
     
      
       open it.
      
     
    </li>
    <li>
     
      In the
     
     <strong class="bold">
      
       StateTree
      
     </strong>
     
      left panel, set the
     
     <strong class="bold">
      
       AIController Class
      
     </strong>
     
      attribute to
     
     <strong class="bold">
      
       AIGuardController
      
     </strong>
     
      and the
     
     <strong class="bold">
      
       Context Actor Class
      
     </strong>
     
      attribute
     
     
      
       to
      
     
     
      <strong class="bold">
       
        BP_Guard
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <p>
    
     As we have already mentioned, the aforementioned steps will bind the state tree to the owning AI controller and actor; this way you will be granted access to
    
    
     
      their properties.
     
    
   </p>
   <p>
    
     We are now going to implement the base states.
    
    
     To do so, carry out the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Create three states and call them,
     
     <strong class="source-inline">
      
       Idle
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       Warned
      
     </strong>
     
      ,
     
     
      <strong class="source-inline">
       
        Resume
       
      </strong>
     
     
      
       , respectively.
      
     
    </li>
    <li>
     
      Select both the
     
     <strong class="bold">
      
       Warned
      
     </strong>
     
      and
     
     <strong class="bold">
      
       Resume
      
     </strong>
     
      states and, in the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, set the
     
     <strong class="bold">
      
       Type
      
     </strong>
     
      attribute
     
     
      
       to
      
     
     
      <strong class="bold">
       
        Group
       
      </strong>
     
     
      
       .
      
     
     <p class="list-inset">
      
       We marked the
      
      <strong class="bold">
       
        Warned
       
      </strong>
      
       and
      
      <strong class="bold">
       
        Resume
       
      </strong>
      
       states as groups because they won’t contain tasks but will delegate them to child states.
      
      
       They basically function as
      
      
       
        state
       
      
      
       <a id="_idIndexMarker649">
       </a>
      
      
       
        containers.
       
      
     </p>
    </li>
   </ol>
   <p>
    
     As an extra option, the
    
    <strong class="bold">
     
      State Tree
     
    </strong>
    
     panel has a
    
    <strong class="bold">
     
      Theme
     
    </strong>
    
     section that will let you define state colors that can then be applied to each state – and its own children – in the
    
    <strong class="bold">
     
      Details
     
    </strong>
    
     panel.
    
    
     In my case, I have opted for the colors depicted in
    
    
     <em class="italic">
      
       Figure 12
      
     </em>
    
    
     <em class="italic">
      
       .24
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 12.24 – Base states" src="img/Figure_12.24_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.24 – Base states
    
   </p>
   <p>
    
     Let’s now implement each
    
    
     
      state separately.
     
    
   </p>
   <h3>
    
     Implementing the Idle state
    
   </h3>
   <p>
    
     The
    
    <strong class="bold">
     
      Idle
     
    </strong>
    
     state is
    
    <a id="_idIndexMarker650">
    </a>
    
     going to be quite simple; we will make the AI agent wait in some sort of infinite loop until we get a noise notification.
    
    
     To implement this state, select it and do the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Add a
     
     <strong class="bold">
      
       Delay Task
      
     </strong>
     
      with the
     
     <strong class="bold">
      
       Duration
      
     </strong>
     
      attribute set
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        10.0
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add a
     
     <strong class="bold">
      
       Transition
      
     </strong>
     
      with the
     
     
      
       following settings:
      
     
     <ul>
      <li>
       
        The
       
       <strong class="bold">
        
         Trigger
        
       </strong>
       
        attribute set to
       
       <strong class="bold">
        
         On
        
       </strong>
       
        <strong class="bold">
         
          State Completed
         
        </strong>
       
      </li>
      <li>
       
        The
       
       <strong class="bold">
        
         Transition To
        
       </strong>
       
        attribute set
       
       
        
         to
        
       
       
        <strong class="bold">
         
          Idle
         
        </strong>
       
      </li>
     </ul>
    </li>
    <li>
     
      Add another
     
     <strong class="bold">
      
       Transition
      
     </strong>
     
      with the
     
     
      
       following settings:
      
     
     <ul>
      <li>
       
        The
       
       <strong class="bold">
        
         Trigger
        
       </strong>
       
        attribute set to
       
       
        <strong class="bold">
         
          On Event
         
        </strong>
       
      </li>
      <li>
       
        The
       
       <strong class="bold">
        
         Event Tag
        
       </strong>
       
        attribute set
       
       
        
         to
        
       
       
        <strong class="bold">
         
          UnrealAgilityArena.StateTree.HeardNoise
         
        </strong>
       
      </li>
      <li>
       
        The
       
       <strong class="bold">
        
         Transition To
        
       </strong>
       
        attribute set
       
       
        
         to
        
       
       
        <strong class="bold">
         
          Alert
         
        </strong>
       
      </li>
      <li>
       
        The
       
       <strong class="bold">
        
         Priority
        
       </strong>
       
        attribute set
       
       
        
         to
        
       
       
        <strong class="bold">
         
          High
         
        </strong>
       
      </li>
     </ul>
    </li>
   </ol>
   <div><div><img alt="Figure 12.25 – Idle state" src="img/Figure_12.25_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.25 – Idle state
    
   </p>
   <p>
    
     As you can see, we
    
    <a id="_idIndexMarker651">
    </a>
    
     will keep on looping inside this state until we get an event from the AI controller notifying us that a noise has been heard.
    
    
     In this case, we will transition to the
    
    
     <strong class="bold">
      
       Alert
      
     </strong>
    
    
     
      state.
     
    
   </p>
   <h3>
    
     Implementing the Alert state
    
   </h3>
   <p>
    
     Once in the
    
    <strong class="bold">
     
      Alert
     
    </strong>
    
     state, the AI
    
    <a id="_idIndexMarker652">
    </a>
    
     agent will try to move to the noise location.
    
    
     Once it reaches that point, will wait for some time before changing state; we will need two child states
    
    
     
      for this.
     
    
   </p>
   <p>
    
     So, to create the first child state, do the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a new state and call it
     
     <strong class="source-inline">
      
       Move to
      
     </strong>
     
      <strong class="source-inline">
       
        Noise Location
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add a task of the
     
     <strong class="bold">
      
       Action
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Move To
      
     </strong>
     
      type and do the following steps
     
     
      
       with it:
      
     
     <ol>
      <li class="upper-roman">
       
        Bind the
       
       <strong class="bold">
        
         AIController
        
       </strong>
       
        attribute – labeled
       
       <strong class="bold">
        
         CONTEXT
        
       </strong>
       
        – to the owner AI controller by clicking the dropdown arrow and
       
       
        
         selecting
        
       
       
        <strong class="bold">
         
          AIController
         
        </strong>
       
       
        
         .
        
       
      </li>
      <li class="upper-roman">
       
        Locate the
       
       <strong class="bold">
        
         Destination
        
       </strong>
       
        attribute, click the dropdown arrow, and select
       
       <strong class="bold">
        
         AIController
        
       </strong>
       
        |
       
       <strong class="bold">
        
         Noise Location
        
       </strong>
       
        to bind this attribute to the
       
       <strong class="bold">
        
         NoiseLocation
        
       </strong>
       
        property of the AI
       
       
        
         controller owner.
        
       
      </li>
     </ol>
    </li>
    <li>
     
      Add a
     
     <strong class="bold">
      
       Transition
      
     </strong>
     
      with the
     
     
      
       following settings:
      
     
     <ul>
      <li>
       
        The
       
       <strong class="bold">
        
         Trigger
        
       </strong>
       
        attribute set to
       
       <strong class="bold">
        
         On
        
       </strong>
       
        <strong class="bold">
         
          State Succeeded
         
        </strong>
       
      </li>
      <li>
       
        The
       
       <strong class="bold">
        
         Transition To
        
       </strong>
       
        attribute set to
       
       
        <strong class="bold">
         
          Next State
         
        </strong>
       
      </li>
     </ul>
    </li>
    <li>
     
      Add another
     
     <strong class="bold">
      
       Transition
      
     </strong>
     
      with the
     
     
      
       following settings:
      
     
     <ul>
      <li>
       
        The
       
       <strong class="bold">
        
         Trigger
        
       </strong>
       
        attribute set to
       
       <strong class="bold">
        
         On
        
       </strong>
       
        <strong class="bold">
         
          State Failed
         
        </strong>
       
      </li>
      <li>
       
        The
       
       <strong class="bold">
        
         Transition To
        
       </strong>
       
        attribute
       
       <a id="_idIndexMarker653">
       </a>
       
        set
       
       
        
         to
        
       
       
        <strong class="bold">
         
          Resume
         
        </strong>
       
      </li>
     </ul>
    </li>
   </ol>
   <div><div><img alt="Figure 12.26 – Move to Noise Location state" src="img/Figure_12.26_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.26 – Move to Noise Location state
    
   </p>
   <ol>
    <li value="5">
     
      This portion of the state tree will move the AI agent to the location set inside the
     
     <strong class="bold">
      
       NoiseLocation
      
     </strong>
     
      attribute of the owning AI controller.
     
     
      Once successful, the next state will be executed.
     
     
      If the location cannot be reached, it will get back to its
     
     
      
       original position.
      
     
    </li>
   </ol>
   <p>
    
     Let’s now create the second child state for the
    
    <strong class="bold">
     
      Alert
     
    </strong>
    
     state by doing the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a new state and call it
     
     <strong class="source-inline">
      
       Inspect
      
     </strong>
     
      <strong class="source-inline">
       
        Noise Location
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add a task of the
     
     <strong class="bold">
      
       Delay Task
      
     </strong>
     
      type and do the following
     
     
      
       with it:
      
     
     <ul>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Duration
        
       </strong>
       
        attribute
       
       
        
         to
        
       
       
        <strong class="source-inline">
         
          3.0
         
        </strong>
       
      </li>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Random Deviation
        
       </strong>
       
        attribute
       
       
        
         to
        
       
       
        <strong class="source-inline">
         
          1.0
         
        </strong>
       
      </li>
     </ul>
    </li>
    <li>
     
      Add a
     
     <strong class="bold">
      
       Transition
      
     </strong>
     
      with the
     
     
      
       following settings:
      
     
     <ul>
      <li>
       
        The
       
       <strong class="bold">
        
         Trigger
        
       </strong>
       
        attribute set to
       
       <strong class="bold">
        
         On
        
       </strong>
       
        <strong class="bold">
         
          State Completed
         
        </strong>
       
      </li>
      <li>
       
        The
       
       <strong class="bold">
        
         Transition To
        
       </strong>
       
        attribute
       
       <a id="_idIndexMarker654">
       </a>
       
        set
       
       
        
         to
        
       
       
        <strong class="bold">
         
          Resume
         
        </strong>
       
      </li>
     </ul>
    </li>
   </ol>
   <div><div><img alt="Figure 12.27 – Inspect Noise Location state" src="img/Figure_12.27_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.27 – Inspect Noise Location state
    
   </p>
   <p>
    
     This portion of the state tree will just make the AI agent wait for a bit, before it goes back to its original location.
    
    
     If the AI agent doesn’t find anything suspicious, it gets back to its
    
    
     
      guard location.
     
    
   </p>
   <h3>
    
     Implementing the Resume state
    
   </h3>
   <p>
    
     The
    
    <strong class="bold">
     
      Resume
     
    </strong>
    
     state will
    
    <a id="_idIndexMarker655">
    </a>
    
     need to bring the AI agent back to its original position; additionally, at any time, this state should be interrupted if a new noise has been notified.
    
    
     So, to create the first child state, do the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a new state and call it
     
     <strong class="source-inline">
      
       Move to
      
     </strong>
     
      <strong class="source-inline">
       
        Starting Location
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add a task of the
     
     <strong class="bold">
      
       Action
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Move To
      
     </strong>
     
      type and do the following steps
     
     
      
       with it:
      
     
     <ol>
      <li class="upper-roman">
       
        Bind the
       
       <strong class="bold">
        
         AI Controller
        
       </strong>
       
        attribute – labeled
       
       <strong class="bold">
        
         CONTEXT
        
       </strong>
       
        – to the owner AI controller by clicking the dropdown arrow and selecting
       
       
        <strong class="bold">
         
          AI Controller
         
        </strong>
       
       
        
         .
        
       
      </li>
      <li class="upper-roman">
       
        Locate the
       
       <strong class="bold">
        
         Destination
        
       </strong>
       
        attribute, click the dropdown arrow, and select
       
       <strong class="bold">
        
         AIController
        
       </strong>
       
        |
       
       <strong class="bold">
        
         Start Location
        
       </strong>
       
        to bind this attribute to the
       
       <strong class="bold">
        
         StartLocation
        
       </strong>
       
        property of the AI
       
       
        
         controller owner.
        
       
      </li>
     </ol>
    </li>
    <li>
     
      Add a
     
     <strong class="bold">
      
       Transition
      
     </strong>
     
      with the
     
     
      
       following settings:
      
     
     <ul>
      <li>
       
        The
       
       <strong class="bold">
        
         Trigger
        
       </strong>
       
        attribute set to
       
       <strong class="bold">
        
         On
        
       </strong>
       
        <strong class="bold">
         
          State Completed
         
        </strong>
       
      </li>
      <li>
       
        The
       
       <strong class="bold">
        
         Transition To
        
       </strong>
       
        attribute set to
       
       
        <strong class="bold">
         
          Next State
         
        </strong>
       
      </li>
     </ul>
    </li>
   </ol>
   <div><div><img alt="Figure 12.28 – Move to Start Location state" src="img/Figure_12.28_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.28 – Move to Start Location state
    
   </p>
   <p>
    
     This state is pretty similar to the
    
    <strong class="bold">
     
      Move to Noise Location
     
    </strong>
    
     one; the only difference is the
    
    <strong class="bold">
     
      Destination
     
    </strong>
    
     attribute that, in this case, is the original location of the
    
    
     
      AI agent.
     
    
   </p>
   <p>
    
     Let’s now create the
    
    <a id="_idIndexMarker656">
    </a>
    
     second child state for the
    
    <strong class="bold">
     
      Resume
     
    </strong>
    
     state by doing the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a new state and call
     
     
      
       it
      
     
     
      <strong class="source-inline">
       
        Wait
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add a task of the
     
     <strong class="bold">
      
       Delay Task
      
     </strong>
     
      type and do the following
     
     
      
       with it:
      
     
     <ul>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Duration
        
       </strong>
       
        attribute
       
       
        
         to
        
       
       
        <strong class="source-inline">
         
          2.0
         
        </strong>
       
      </li>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Random Deviation
        
       </strong>
       
        attribute
       
       
        
         to
        
       
       
        <strong class="source-inline">
         
          1.0
         
        </strong>
       
      </li>
     </ul>
    </li>
    <li>
     
      Add a
     
     <strong class="bold">
      
       Transition
      
     </strong>
     
      with the
     
     
      
       following settings:
      
     
     <ul>
      <li>
       
        The
       
       <strong class="bold">
        
         Trigger
        
       </strong>
       
        attribute set to
       
       <strong class="bold">
        
         On
        
       </strong>
       
        <strong class="bold">
         
          State Completed
         
        </strong>
       
      </li>
      <li>
       
        The
       
       <strong class="bold">
        
         Transition To
        
       </strong>
       
        attribute set
       
       
        
         to
        
       
       
        <strong class="bold">
         
          Idle
         
        </strong>
       
      </li>
     </ul>
    </li>
   </ol>
   <div><div><img alt="Figure 12.29 – Wait state" src="img/Figure_12.29_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.29 – Wait state
    
   </p>
   <p class="list-inset">
    
     As a last step, we will need to interrupt the
    
    <strong class="bold">
     
      Resume
     
    </strong>
    
     state if a new noise has been heard, so select the
    
    <strong class="bold">
     
      Resume
     
    </strong>
    
     state and do the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li value="4">
     
      Add a
     
     <strong class="bold">
      
       Transition
      
     </strong>
     
      with the
     
     
      
       following settings:
      
     
     <ul>
      <li>
       
        The
       
       <strong class="bold">
        
         Trigger
        
       </strong>
       
        attribute set to
       
       
        <strong class="bold">
         
          On Event
         
        </strong>
       
      </li>
      <li>
       
        The
       
       <strong class="bold">
        
         Event Tag
        
       </strong>
       
        attribute set
       
       
        
         to
        
       
       
        <strong class="bold">
         
          UnrealAgilityArena.StateTree.HeardNoise
         
        </strong>
       
      </li>
      <li>
       
        The
       
       <strong class="bold">
        
         Transition
        
       </strong>
       
        To attribute set
       
       
        
         to
        
       
       
        <strong class="bold">
         
          Alert
         
        </strong>
       
      </li>
      <li>
       
        The
       
       <strong class="bold">
        
         Priority
        
       </strong>
       
        attribute
       
       <a id="_idIndexMarker657">
       </a>
       
        set
       
       
        
         to
        
       
       
        <strong class="bold">
         
          High
         
        </strong>
       
      </li>
     </ul>
    </li>
   </ol>
   <div><div><img alt="Figure 12.30 – Resume state" src="img/Figure_12.30_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.30 – Resume state
    
   </p>
   <p>
    
     The state tree is pretty complete, and it should look like the one shown in
    
    
     <em class="italic">
      
       Figure 12
      
     </em>
    
    
     <em class="italic">
      
       .31
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 12.31 – Finished state tree" src="img/Figure_12.31_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.31 – Finished state tree
    
   </p>
   <p>
    
     Now that the state tree is ready, we will need to add it to the
    
    
     
      AI controller.
     
    
   </p>
   <h2 id="_idParaDest-245">
    <a id="_idTextAnchor247">
    </a>
    
     Assigning the state tree to the AI controller
    
   </h2>
   <p>
    
     Assigning the
    
    <a id="_idIndexMarker658">
    </a>
    
     newly created state tree to the AI controller is pretty straightforward.
    
    
     Just open the
    
    <strong class="bold">
     
      AIGuardController
     
    </strong>
    
     Blueprint and, in the
    
    <strong class="bold">
     
      Details
     
    </strong>
    
     panel, locate the
    
    <strong class="bold">
     
      AI
     
    </strong>
    
     section.
    
    
     Set the
    
    <strong class="bold">
     
      State Tree
     
    </strong>
    
     property
    
    
     
      to
     
    
    
     <strong class="bold">
      
       STAI_Guard
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Once this is done, we can create the AI
    
    
     
      agent Blueprint.
     
    
   </p>
   <h2 id="_idParaDest-246">
    <a id="_idTextAnchor248">
    </a>
    
     Creating the guard Blueprint
    
   </h2>
   <p>
    
     We will now create our
    
    <a id="_idIndexMarker659">
    </a>
    
     guard Blueprint and assign the AI logic to it.
    
    
     To do this, open
    
    <strong class="bold">
     
      Content Drawer
     
    </strong>
    
     .
    
    
     In the
    
    <strong class="source-inline">
     
      Blueprints
     
    </strong>
    
     folder, create a new Blueprint extending from
    
    <strong class="bold">
     
      Base Dummy Character
     
    </strong>
    
     and call
    
    
     
      it
     
    
    
     <strong class="source-inline">
      
       BP_Guard
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Open the newly created Blueprint and, in the
    
    <strong class="bold">
     
      Details
     
    </strong>
    
     panel, set the
    
    <strong class="bold">
     
      AI Controller Class
     
    </strong>
    
     attribute
    
    
     
      to
     
    
    
     <strong class="bold">
      
       AIGuardController
      
     </strong>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 12.32 – Guard Blueprint" src="img/Figure_12.32_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.32 – Guard Blueprint
    
   </p>
   <p>
    
     The guard AI agent is now ready; we just need to test it out in
    
    
     
      a gym.
     
    
   </p>
   <h2 id="_idParaDest-247">
    <a id="_idTextAnchor249">
    </a>
    
     Testing in a gym
    
   </h2>
   <p>
    
     With the Blueprint class
    
    <a id="_idIndexMarker660">
    </a>
    
     ready, it’s time to test it out.
    
    
     All you need to do is to add it to the previously created gym and play the level.
    
    
     Whenever a noise is emitted by a noise emitter actor, you should see the
    
    <strong class="bold">
     
      BP_Guard
     
    </strong>
    
     instance try to reach the noise location and, after a while, get back to its original position.
    
    
     Obviously, all of this will work if the AI agent is in range of the provoked noise location.
    
    
     You can obviously leverage your understanding of AI debugging tools to gain valuable insights into the hearing capabilities and range of the
    
    
     
      AI agent.
     
    
   </p>
   <div><div><img alt="Figure 12.33 – Testing the gym" src="img/Figure_12.33_B31016.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 12.33 – Testing the gym
    
   </p>
   <p>
    
     In this quite lengthy section, you got more advanced information on how to implement your own state trees.
    
    
     Starting from an AI controller with some hearing capabilities, we learned how to control a state tree and bind important data between the state tree and the AI controller.
    
    
     Finally, we added the AI controller and, consequently, the state tree to an AI agent and tested its behaviors in
    
    
     
      a gym.
     
    
   </p>
   <p>
    
     The AI agent we have created sets the foundation for a complete AI guard agent.
    
    
     Currently, it simply checks for any suspicious noises and investigates their source.
    
    
     I highly recommend adding your own logic to introduce more actions, such as sounding an alarm when an enemy is detected or trying to attack the source of
    
    
     
      the noise.
     
    
   </p>
   <h1 id="_idParaDest-248">
    <a id="_idTextAnchor250">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     State trees in Unreal Engine are crucial in the AI framework as they help manage and organize the decision-making processes of AI agents efficiently.
    
    
     They offer a neat alternative to behavior trees depending on your design and
    
    
     
      development patterns.
     
    
   </p>
   <p>
    
     In this chapter, we learned the basics of state trees, a hierarchical state machine framework implemented in Unreal Engine.
    
    
     Starting from its main concepts, such as how states are handled, we were introduced to the main elements involved – including tasks, transitions, and conditions.
    
    
     After that, we created our own actors, taking advantage of
    
    
     
      state trees.
     
    
   </p>
   <p>
    
     In the next chapter, we will be working on a totally different topic: how to manage huge numbers of objects within your level, treating them as a collective group for processing or
    
    
     
      simulation purposes.
     
    
   </p>
  </div>
 </body></html>