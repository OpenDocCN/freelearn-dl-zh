- en: Designing Behavior Trees - Part III
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a continuation of the previous one, and is the final part of
    *Designing Behavior Trees*. We will finish what we started. In particular, we
    will build the final *Behavior Tree* and make it run.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating the ***Blackboard*** and the ***Behavior Tree*** assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the ***Blackboard*** so that it can be used with the *Behavior Tree*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the ***Behavior Tree ***(using either the Blueprint or C++ nodes)
    to make a Chasing Behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Making the Behavior Tree running*** (both in a Blueprint or C++)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Improving the C++ nodes*** of the Behavior Tree to better align with *best
    practices*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once again, we will be implementing everything in both Blueprint and C++ to
    give you a broader idea of what you can use. Alternatively, if you already know
    what you want to use, you can just follow one of the two implementations.
  prefs: []
  type: TYPE_NORMAL
- en: This will conclude our journey of *Designing a Behavior Tree* from scratch,
    and at the end, we will have our Chasing Behavior complete.
  prefs: []
  type: TYPE_NORMAL
- en: So, without further ado, let's dive into building the *Behavior Tree*!
  prefs: []
  type: TYPE_NORMAL
- en: Building the Behavior Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last step in creating the Chasing Behavior is to build the Behavior Tree.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, if you feel like you have missed something, just revise the ***Expected
    Behavior*** (the one we have described in Chapter 8) and *do a checklist* of what
    you will need to build this *Behavior Tree*. However, even if you did miss something,
    don't worry – you can create it at a later stage.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers start developing the *Behavior Tree* and then build the nodes
    when they need them. Unless you are really good or the tree is particularly simple,
    it is always advisable to plan a little bit ahead, like we have did in the last
    two chapters. By doing this, you will avoid many headaches later on, and by having
    a little work overhead at the beginning, you avoid a large, bug-fixing time cost.
    Of course, you will still need to do bug fixing, but planning should reduce the
    chance of introducing bugs, or achieving a different behavior from the one that
    was originally planned.
  prefs: []
  type: TYPE_NORMAL
- en: From this point onward, you can use the Blueprint and C++ implementations (in
    case you have been using both), or just stick to the one you have been using so
    far. I will use the names from the Blueprint implementation, but the concepts
    for using our C++ nodes are exactly the same. In the end, I'll show a screenshot
    of the *Behavior Tree* build with CPP nodes instead.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth noting that we can also create a Mix tree. In fact, we can use both
    the C++ and the Blueprint nodes in the same tree. Since, in our case, we have
    a replica of each node in both Blueprint and C++, we should be free to use any
    as we like. However, this is not true, because we have made some nodes depending
    on the C++ AI controller, which was specific for that implementation. Thankfully
    in a project, you will not have replicas of everything, so if you have a specific
    AI Controller, both Blueprint and C++ node should refer to the same one.
  prefs: []
  type: TYPE_NORMAL
- en: During the development of your project, keep in mind that you can create some
    *Behavior Tree* nodes in C++ and some in Blueprint. Some developers prototype
    their nodes in Blueprint and then move the development to C++. Try to find the
    formula and the right balance between C++ and Blueprint that works best for you
    or your team.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, if you haven''t already, create the *Behavior Tree Asset*, along
    with the *Blackboard*. In my case, I''m going to call the *Behavior Tree* ***BT_ChasingBehavior ***and
    the Blackboard ***BB_ChasingBlackboard***. Both are placed in the AI folder (where
    we created our Blueprint nodes), as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cade3b5-f974-4890-9650-0754da2a9345.png)'
  prefs: []
  type: TYPE_IMG
- en: You can reorder the `AI` folder a bit by creating sub-folders. For instance,
    you can create a sub-folder for your Decorators, another for your Tasks, and a
    third for your Services. Either way, this is a relatively small example, so we
    will leave the folder as it is.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Blackboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by opening the *Blackboard Editor* (double-click on the asset).
    As you may recall, we need to have a Player reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, create a ***New Key*** of type ***Object***:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e532a773-dcc8-4ecd-955f-baac6abd1e33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Rename it ***Player***, and in the *Details Panel*, under the ***Key Type*** (you
    might need to expand this), set the ***Base Class*** to be the Player Pawn of
    our choice (e.g. ***Player***, the class we created at the beginning of this chapter),
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac15c42a-77e9-46ef-bceb-d3e483b3b3db.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next *Key* to add is the ***Destination***, which is of type Vector. This
    will be useful for determining a goal when the player is not in sight. Speaking
    of which, we need a third Key of type *boolean* named ***CanSeePlayer***, which
    is used to check if the Player is currently in sight or not. This is what the
    values of the *Blackboard* should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64a60bea-219c-40e9-a02a-cb3db0977b0b.png)'
  prefs: []
  type: TYPE_IMG
- en: Building the Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Double-click on the ***BT_ChasingBehavior*** asset to open the *Behavior Tree
    Editor*. Make sure that you have ***BB_ChasingBlackboard*** selected for the tree,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12001228-7b7e-468b-9baa-572755f192f7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the ***Root*** node, we need to start with a ***Selector***. This *Selector*
    will be where the tree will split into two branches: the one that will chase the
    Player when in sight, and the other when he/she isn''t. On this very *Selector*,
    we need to attach our ***BTService_UpdateChasingBehavior*** Service (or if you
    wish, its C++ version, named ***UpdatedChasing***). Don''t forget to assign all
    the variables in the *Details Panel* (the *three Blackboard variables*), as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50795f33-f026-4ae8-ac85-e6d1556a6fd8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the C++ version, we also need to assign the Player Class, along with the
    Blackboard Variables (since this is the way we designed our Service in C++). Hence,
    you will have something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cca03a5-239b-473c-8753-50c0034ddca3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have assigned all the variables, then this is what our Service will
    look like in the *Behavior Tree* when attached to the *Selector* node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7311d9a9-0370-47f5-bf5a-fa12a802818b.png)'
  prefs: []
  type: TYPE_IMG
- en: From the *Selector*, add two ***Sequence*** nodes (each representing the two
    branches of the tree). Which one the *Selector* chooses will depend on the decorators
    we are going to place on these two nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add both the ***Sequence*** nodes to ***BTDecorator_CheckBoolVariableBP*** (or
    the ***CheckBoolVariable*** C++ version of it). In the details panel, the *Bool
    Variable To Check* variable needs to be fed with the ***CanSeePlayer*** *Blackboard
    Key*, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b5bf8ca-06f0-40ab-9044-a23555bf96f3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, for the sequence on the right, you should set the ***Inverse Condition*** checkbox
    to *true*. By doing this, we can check whether ***CanSeePlayer*** is set to *false*.
    This is a bit wordy, but here are the final results in the Details panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9c8747a-39e7-46a5-b415-a84913cbbbe0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So far, our tree looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c06bf2f1-4711-4ef4-8d16-bea6121e2b7f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the sequence node on the left, we just need to chase the player by using
    the ***Move To*** task. You need to select the ***Player* **blackboard variable
    as the ***Blackboard Key***, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ca131c0-5140-4585-bc01-ba82b4b15840.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the current stage of the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/acf0f974-5619-466d-be05-030bfd37e6df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the ***Sequence*** node on the right, we need to have two tasks. The first
    one is ***Move To*** again, but this time select the ***Destination*** variable
    as the ***Blackboard Key***, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38b4bb64-3a50-4c54-86b6-a5f6c391ae4d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is what the tree looks like so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f626e1a8-ac78-4682-8945-bdf9eee05168.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The second *Task* is the one we have already created, ***BTTask_FindRandomLocationBP*** (or
    the ***Find Random Location*** C++ version). We need to set the ***DestinationKey*** with
    the ***Destination*** *Blackboard variable*, and as for the ***Radius***, we can
    choose a value (e.g. 30000, ten times more the default value). This is what the *Details*
    panel looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd525471-861b-472c-9a02-ecf30f330e69.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is what the complete tree should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42e5cf86-f25d-485b-a208-c868f0a2fb0f.png)'
  prefs: []
  type: TYPE_IMG
- en: It seems like we have finished, but we have one more thing to do. In fact, at
    the moment, the Decorators don't control the flow of the Sub-Tree once the AI
    is executing it. In fact, we would like to abort the Task of moving to the Player
    if he/she is not in sight anymore; on the other hand, if the agent is going to
    a random location, we want the agent to chase the Player if he/she is in sight
    again.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we need to select our ***Decorators*** (one at the time) and
    set ***Observer Abort*** to ***Self***, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e935bd39-f8bc-4771-97de-81ae5097d43d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the Decorator is still selected, the nodes that will be aborted are highlighted
    in the Tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1209ad61-9437-41ad-b166-34928c965f63.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The tree slightly changes to reflect this behavior (under the ***Decorators***, the
    abort conditions are shown):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f665e500-daf6-499b-bb61-d69566dd8f96.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you have built the tree using C++ nodes, you will have something similar
    to this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/493789be-3579-4c18-92ba-c1228813e109.png)'
  prefs: []
  type: TYPE_IMG
- en: Moreover, you should notice that, just down below the Node name, not all information
    are displayed (e.g. in the *Decorators*, it doesn't say if its condition is inverted
    and what the abort conditions are). Later in the chapter, we will tackle this
    issue as well.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the structure is very simple (and I have seen the same behavior
    being implemented in different trees), but it contains all the main concepts for ***Designing
    a Behavior Tree*** (including creating a node of each type: ***Decorator***, ***Service***,
    and ***Task***). The fact that the structure is simple doesn't mean that the behavior
    that represents it is simple too. In fact, what we have built is a very nice ***Chasing
    Behavior***!
  prefs: []
  type: TYPE_NORMAL
- en: We haven't touched upon Simple Parallel nodes, but those are used in more complicated
    trees for particular kind of behaviors with sub-trees. You don't have to worry –
    once you start mastering the art of creating *Behaviors Trees*, the use of Simple
    Parallel nodes will become natural.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing that's left to do is make this *Behavior Tree* run and then to
    test it in the game!
  prefs: []
  type: TYPE_NORMAL
- en: Running the Behavior Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already created the whole setup, including actors, controllers, perception,
    and navigation. However, we don't have any code that makes this Behavior Tree
    run on our agent. Of course, we will cover both the Blueprint case and the C++
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Behavior Tree using the Blueprint controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we have a Blueprint controller set up, we can easily modify it to get the
    Behavior Tree running immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, once we open the Editor, we can add the *Run Behavior Tree* node after 
    overriding the *Event OnPossess *and choose the right *Behavior Tree*, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0bd4942e-a919-4dc0-ada3-7b7585860e55.png)'
  prefs: []
  type: TYPE_IMG
- en: Save it, and you are good to go! Run the game and see if it works (of course,
    the AI controller needs to be set to ***BP_ChasingAIController***).
  prefs: []
  type: TYPE_NORMAL
- en: Running the Behavior Tree using the C++ controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unluckily for C+,+ this is not as straightforward (as we already saw in [Chapter
    2](00781951-41e3-4e33-8512-052e7aecfd15.xhtml)*, Behavior Trees and Blackboards*).
    In particular, we have two choices: we hardcode the value or we get a reference
    to the tree using blueprints.'
  prefs: []
  type: TYPE_NORMAL
- en: The first option is not very practical for this kind of stuff and it is not
    a best practice.
  prefs: []
  type: TYPE_NORMAL
- en: For the second option, we have a variety of choices. In particular, I suggest
    that you create a *Behavior Tree* variable in the controller and use it so that
    it can be run on the `OnPossess()` function. Then, we can create a child of this
    class in the blueprint, where we can easily assign this variable. Finally, we
    can change the reference to the controller for our ***AIChasingAgent***.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can place the *Behavior Tree* on the *Character/Pawn* that
    the AI will control, like we did in *Chapter 2*. That would be the best approach;
    however, in this moment it is good to see different alternatives in case you are
    in a situation in which you will need the *Behavior Tree* directly on the controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by opening the header file of our C++ controller and adding the
    following public variable (with the `UPROPERTY()` macro, since it needs to be
    editable in Blueprint):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to override the `OnPossess()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the `.cpp` file, we need to include the *Behavior Tree class*, so
    we need to add the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the `OnPossess()` implementation, we just run the Behavior Tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After compiling the code, we can right-click on the C++ controller and select ***Create
    Blueprint class based on ChasingAIController***, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb0bb51d-17a8-4fe8-baa8-713577b61681.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we can place this Blueprint inside the AI folder and name it ***CPP_ChasingAIController*** (to
    distinguish it from *BP_ChasingAIController*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c55c897-67e1-40ee-81b5-6975c2792598.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Its *Blueprint Editor* should open automatically (if not, just double-click
    on the asset to open it). Set the ***Behavior Tree*** variable in the *Details
    Panel*, as shown in the following screenshot (of course, we will need to set the
    *C++ version* of the *Behavior Tree*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/614c7993-25a9-40c7-85ad-2330b1f59755.png)'
  prefs: []
  type: TYPE_IMG
- en: Compile and save the *Blueprint*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in the ***AI_ChasingAgent*** blueprint, let''s change its settings
    (from the *Details* panel in the ***Pawn*** tab) so that it will use the new controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7581820f-462c-4dde-8c0d-fdf15a506759.png)'
  prefs: []
  type: TYPE_IMG
- en: This concludes how to run the *Behavior Tree* on a *C++ controller*.
  prefs: []
  type: TYPE_NORMAL
- en: Bug Correction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have though to have finished, well, that's not it. In fact, when designing
    a Behavior Tree, there must always be a phase of debugging and check if everything
    works as it should. Actually, on purpose I built the tree with something that
    doesn't work. Can you figure it out? Give it a try before keep reading.
  prefs: []
  type: TYPE_NORMAL
- en: The first problem is that, the Destination Key in the Blackboard, until the
    Player is not on sight, it will never get initialized. Moreover, there is another
    problem, when the AI enemy is seeking the Last Known Position of the player, but
    it is not reachable, it will fail the task. As a result, the sequence will not
    allow to go in the next Task to select a *Random Destination*. How can we fix
    this? Let's give it a try before we keep reading.
  prefs: []
  type: TYPE_NORMAL
- en: There are many approaches to this. For instance, you might have though to use
    the "*Force Success*" Decorator. It is not a bad idea at all, actually, this are
    the kind of cases in which you would use this Decorator (to add an optional Branch
    to the Sequence, so regardless if the Move To fails, we can still pick a Random
    Destination). Unfortunately, it doesn't work well with the setup we have with
    the other two decorators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, another solution is to modify the tree in the following way. We need
    to substitute the second Sequence with a Selector, with two Sequences as children.
    In the first Sequence, we place our Move To Task followed by the Find Random Destination
    one. In the other Sequence they are inverted. As result, in case the Task to follow
    the Last Known Player Position fails, the tree can revert back to Find a Random
    Location. If you wish, you could also remove the last Move To in the second Sequence,
    but I''m leaving it there for clarity; especially for those who struggle to grasp
    how *Behavior Tree* works. At the end, this is how it should look like the Behavior
    Tree (Blueprint version):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd0fbae0-60ef-4684-9c35-161a98aba46c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And this is how the C++ version should change (the changes of the next section
    have already been implemented in this picture):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2869bfc3-5bdd-49fe-a375-4f55f421631b.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course the solution is not unique, and you may find better ways to do it.
  prefs: []
  type: TYPE_NORMAL
- en: What about our first problem of the *Destination* never be initialized? Well,
    we don't have this problem anymore with the proposed solution, since if the first
    *Sequence* (in the right-branch) fails, then the second one will set the *Destination*
    to a *Random Location*. In fact, when debugging Behavior Trees, you always need
    to be careful to each modification and how this affects the whole tree. Imagine
    this for a complex Behavior, and you can get an idea of the time required for
    such Task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have fixed this, we can always check for other bugs and/or try to improve
    the set up. Here a couple of other issues, which I leave you to fix, in order
    to practice with *Behavior Trees*:'
  prefs: []
  type: TYPE_NORMAL
- en: When the *Behavior Tree* starts its execution, the *Destination* is set to the
    zero vector. This means, that the AI, if doesn't see the Player, will go straight
    to the *World Origin*. Can you try to avoid it? Try to think, which are the different
    alternatives we have? The best would be to have a Random Destination In range.
    How can we achieve that?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the moment, when we do the Cast in the Perception System, we just select
    a broader class of *BehaviorTreeDesignCharacter*. However, this causes problems
    if you have more than one AI in the level. How can you fix that? For sure, you
    can change the Cast into something more specific, so to reduce it only to the
    Player. But what if you cannot do that, because both Players and friendly AI must
    share the same class? You could try to use the different Teams to distinguish
    enemies, allies and neutral; recall from Chapter 5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, this was just a very small example of *Behavior Tree*, yet it took
    three solid chapters to go through it in details. I will leave you exploring Behavior
    Trees for your games, but before that, the next section will talk about some suggestions
    on how to improve the C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: Improving further (C++ only)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have made a very nice Behavior Tree by programming the different nodes we
    have used. However, when you work on a big project or with other team members,
    you should ensure that your nodes are as solid as possible. In fact, in the C++
    implementation, we added a static description to our nodes to show which variables
    were set, and that was fantastic. But we can do more!
  prefs: []
  type: TYPE_NORMAL
- en: This section will guide you through improving the C++ nodes even further.
  prefs: []
  type: TYPE_NORMAL
- en: Node Name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unreal does a good job in C++ Behavior Tree nodes by cutting out the prefix
    (e.g. "***BTTask_***") and directly showing the name of the Task (or Decorator
    or Service). In the blueprint, it keeps the whole prefix instead, as you see in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3121d28-a5f2-48e1-82f6-f0d73f76f70e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we saw in the previous chapters, you can modify the name that will be displayed
    by changing the ***Node Name*** property in the *Details* panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3bae5b3-5897-4208-abcc-34a08b43038f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is reflected in the Behavior Tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7928766e-7ce9-4487-aaea-e20bcf9a7281.png)'
  prefs: []
  type: TYPE_IMG
- en: Thus, when you write a C++ node, it's good practice to give a default ***Node
    Name***. You can do this by simply assigning it in the constructor. So, let's
    do this for all three C++ nodes we have created.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *Decorator* header file, we need to add the declaration of the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Its implementation in the `.cpp` file is straightforward, since we just need
    to add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the final result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b09da5ce-8ccf-42b8-8e5d-320c004e630a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to do this with our Task, too. So, let''s declare the constructor in
    the header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Its implementation in the `.cpp` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how it looks in the Behavior Tree Editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c16018a-7b00-4895-8950-d2100ba9e137.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we already have a constructor for our Service, so we just need to
    add a line to its constructor in the `.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The service will appear with a nice name in the Behavior Tree Editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff5d104e-4add-4206-8724-4ad2d05cf3ec.png)'
  prefs: []
  type: TYPE_IMG
- en: A better description for the Decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned previously, when we use the C++ version of the Decorator, we
    are unable to see whether the condition is reversed, or the aborts settings.
  prefs: []
  type: TYPE_NORMAL
- en: To add them into our static description, we need to change the code slightly.
    Fortunately, the header describing all of these properties is given in the parent
    class of our Decorator, and so we don't need to write the code from scratch. We
    need to store the return value of the parent function (by using the `Super::GetStaticDescription()` function)
    in a local FString Variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can add a couple of new lines and append the original Static Description
    we made. Finally, we return the new variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the final effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0170df2-400d-4730-91ee-4746531103e6.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, you can use the `Super::GetStaticDescription()` function for Tasks
    and Services as well.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering Blackboard Keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we insert *Blackboard Keys* in the *Details Panel*, we can insert any key
    that's present in the *Bl**ackboard*. However, when we use our ***CheckBoolVariable*** Decorator,
    we only want boolean keys in the ***BoolVariableToCheck***.
  prefs: []
  type: TYPE_NORMAL
- en: We can achieve this by adding some filters in the constructor, as we learned
    back in [Chapter 6](e8c4d8a9-579e-4e38-b02a-a9002f1c48ce.xhtml), *Extending the
    Behavior Tree*. Let's do this for all three nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the implementation of the *Constructor* of our ***Check Bool Variable Decorator*** (`.cpp`
    file), we need to add the following filter so that it can only select boolean
    keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our *Decorator* will only be able to accept Boolean keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28b60dbe-21ae-44b1-8a8f-b133b0cb7edc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Likewise, we can do the same for our *Task* for the Destination Vector, which
    is of type Vector. In its *Constructor* (`.cpp` file), add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our ***Find Random Location Task*** can only accept Vector Keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ce3ce9b-bd51-4056-81d9-3be4169ae8cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, in our ***Update Chasing Behavior Service***, we need to do the same,
    but for each of the three variables. In particular, in the *Object* filter, we
    need to specify a class. In this example, we can just filter based on `AActor`.
    So, in the `.cpp` file, add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how it appears when we try to select a key for our *Service*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5283aee-c6af-41ff-a88f-a0b7bd6a606b.png)'
  prefs: []
  type: TYPE_IMG
- en: This concludes this section and our journey of creating a *Behavior Tree* from
    scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have completed what we started in the previous two chapters.
    In fact, we have built a Behavior Tree from scratch, starting from the design
    phase, and implementing all the components we needed along the way (both in Blueprint
    and C++!).
  prefs: []
  type: TYPE_NORMAL
- en: In particular, in this chapter we have seen how to build the Behavior Tree,
    along with the Blackboard; make the Behavior Tree run (both in a Blueprint and
    C++ setup); and improved the C++ implementation of the nodes by assigning node
    names, placing a header in the Decorator, and filtering the *Blackboard Key* selectors
    based on their type.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter concludes the main features of the Unreal Engine AI Framework.
    However, this doesn't mean that we are finished with this Framework just yet.
    In fact, we can now perform an extensive debugging of the AI, which is the topic
    we are going to face in the next chapters.
  prefs: []
  type: TYPE_NORMAL
