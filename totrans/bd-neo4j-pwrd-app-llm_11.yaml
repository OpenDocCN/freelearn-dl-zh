- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integrating LangChain4j and Spring AI with Neo4j
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have loaded the data into a graph, in this chapter, we will look
    at how we can use LangChain4j or Spring AI to augment the graph to enhance its
    capabilities and build a knowledge graph. We will look into integrating the graph
    with LLMs to generate a summary of customer purchases and create an embedding
    of that summary to represent the customer purchase history. These embeddings are
    crucial for enabling machine learning and graph algorithms to understand and process
    graph data. These embeddings can help us build a knowledge graph to provide more
    personal recommendations for customers by understanding purchase behaviors. We
    will also look at how to create embeddings of the detailed description of each
    article present in the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up LangChain4j and Spring AI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your recommendation engine with LangChain4j
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your recommendation engine with Spring AI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fine-tuning your recommendation system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be using a Java IDE environment to work with the LangChain4j and Spring
    AI projects. You need to have these installed and know how to work with them.
    You will need the following to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Maven will be used to build a project and manage dependencies. If you are going
    to use the IntelliJ IDE (or IntelliJ IDEA), then Maven will be installed along
    with it, and you need not install it separately. If you are new to Maven, you
    can read more about it at [https://maven.apache.org/](https://maven.apache.org/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java 17.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IntelliJ – These examples are built and tested with the IntelliJ IDE. You can
    use your preferred IDE, however. We will be using the IntelliJ IDEA tool to build
    and run our projects. You can download the tool from [https://www.jetbrains.com/idea/](https://www.jetbrains.com/idea/).
    You can download the Community Edition to run the examples in this chapter. You
    can read more about using this IDE to build Spring applications at [https://www.jetbrains.com/idea/spring/](https://www.jetbrains.com/idea/spring/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot – If you are new to Spring Boot, you can go to [https://spring.io/projects/spring-boot](https://spring.io/projects/spring-boot)
    to learn more about it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Neo4j Desktop with the following plugins installed. We will be starting from
    the graph database we built in the last chapter. You can download Neo4j Desktop
    from [https://neo4j.com/download/](https://neo4j.com/download/). If you are new
    to Neo4j Desktop, you can learn more about it at [https://neo4j.com/docs/desktop-manual/current/](https://neo4j.com/docs/desktop-manual/current/).
    The code is tested with the 5.21.2 version of the database. The following are
    the plugins required:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APOC plugin – 5.21.2
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph Data Science library – 2.9.0
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The following figure shows how to install these plugins for a DBMS.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 — Install plugins on Neo4j Desktop](img/B31107_09_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 — Install plugins on Neo4j Desktop
  prefs: []
  type: TYPE_NORMAL
- en: When you select the DBMS on Neo4j Desktop, on the right side, it shows its details.
    Click on the **Plugins** tab and select the plugins you require. On the details
    pane, click on the **Install and Restart** button.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: You can find all the code you need at [https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch9](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch9).
    These are complete projects and ready to run in an IDE. We will only show snippets
    of the code in this chapter to showcase the usage. So, it might be a good idea
    to download the code to follow the steps in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with setting up the LangChain4j and Spring AI projects.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up LangChain4j and Spring AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will take a look at setting up the Spring AI and LangChain4j projects using
    the **spring initializr** website ([https://start.spring.io/](https://start.spring.io/)).
  prefs: []
  type: TYPE_NORMAL
- en: We will look at each of these technologies independently. LangChain4j and Spring
    AI are both options to perform the same tasks. We need only one of these frameworks
    to build GenAI projects. LangChain4j has been available for a bit longer than
    Spring AI. Both of them work pretty similarly in terms of the API and integrations.
    We will build the same application with both frameworks and see how similar they
    are. We will also identify the differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps we need to follow to create the starter projects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up the LangChain4j project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the website, [https://start.spring.io/](https://start.spring.io/).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Maven** under the **Project** section.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Java** under the **Language** section.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Project Metadata** section, fill in the following values:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Group**: `com.packt.genai.hnm.springai`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Artifact**: `springai _graphaugment`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Name**: `springai _graphaugment`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description**: `Graph Augmenting with Spring AI`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Package Name**: `com.packt.genai.hnm.springai.graphaugment`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Packaging**: `Jar`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java**: `17`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the **Dependencies** section, click on the **Add Dependencies** button and
    select the **Spring Web** dependency.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: There are no other dependencies that are currently listed by the initializer
    to add to the project. We will add LangChain4j dependencies manually to the project.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Download and save the ZIP file that is generated.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Setting up the Spring AI project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the website, [https://start.spring.io/](https://start.spring.io/).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Maven** under the **Project** section.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Java** under the **Language** section.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Project Metadata** section, fill in the following values:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Group**: `com.packt.genai.hnm.langchain`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Artifact**: `langchain_graphaugment`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Name**: `langchain_graphaugment`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description**: `Graph Augmenting with Langchain4J`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Package Name**: `com.packt.genai.hnm.langchain.graphaugment`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Packaging**: `Jar`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java**: `17`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the **Dependencies** section, click on the **Add Dependencies** button to
    select the following dependencies:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Spring Web**'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenAI**'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Neo4j Vector Database**'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Download and save the ZIP file that is generated.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: This will only give us a skeleton project with which we will build the application.
    The skeleton project gives us a basic structure upon which we can add more logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at what we want out of our application before we go ahead and build
    it. We loaded the H&M transaction data into the graph database in the previous
    chapter. Currently, it holds the customers, articles, and transactions along with
    some helper relationships that mark the first transaction in a given season and
    year. As we want to build a personal recommendation system, we want to enhance
    the graph to understand customer behavior and provide recommendations. For this
    purpose, we will be taking the following approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Select a season for which to understand the purchase behavior. For example,
    say we want to find the customers who made purchases in summer 2019 and fall 2019
    and use the transactions between those seasons to understand customer behavior.
    Note that there might be some customers who did not make any transactions in the
    fall of 2019, even though they might have made transactions in the summer of 2019\.
    We are ignoring those customers for this exercise, to make things a bit simpler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve the articles purchased during these transactions. The articles should
    match the condition (purchases made in the summer and fall of 2019) in the order
    they are purchased. We will then use an LLM to summarize these purchases. This
    summarization preserves the order of the articles purchased.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the LLM to generate embedding for this summary text. We will be leveraging
    an OpenAI LLM for this part.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store these embeddings. We will be storing them on the season relationship for
    which these embeddings are generated. For example, if we are generating a summary
    for the summer of 2019, we will store the resulting embeddings on the `SUMMER_2019`
    relationship. An OpenAI LLM is used to generate the embeddings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next section, we will take a look at building an application that performs
    the functions we described previously using LangChain4j.
  prefs: []
  type: TYPE_NORMAL
- en: Building your recommendation engine with LangChain4j
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at building a graph augmentation application
    that leverages LangChain4j. In this project, we will be using the GraphRAG approach
    to generate embeddings for a transaction chain that meets our requirements. We
    will be using the Neo4j graph retriever to retrieve the transaction chain that
    meets our requirements, as well as an LLM to generate a summary of those transactions
    to describe the customer purchase behavior and generate an embedding. The embedding
    generated will be a vector representation that describes the text summary in a
    manner that can be leveraged by machine learning or Graph Data Science algorithms.
    It can also be leveraged for vector search purposes. This article explains embeddings
    in the context of LLMs well: [https://ml-digest.com/architecture-training-of-the-embedding-layer-of-llms/](https://ml-digest.com/architecture-training-of-the-embedding-layer-of-llms/).
    We will start with the ZIP file downloaded in the last section. We need to unzip
    the file we have downloaded. Once it is unzipped, we will load the project into
    the IntelliJ platform using these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch the IntelliJ IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **File** | **New** | **Project from Existing Sources…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.2 — Create a new project](img/B31107_09_02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 — Create a new project
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Select the `pom.xml` file from the directory we unzipped.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 — Select pom.xml](img/B31107_09_03.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 — Select pom.xml
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Click on **Trust Project** to load the project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 — Trust Project](img/B31107_09_04.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 — Trust Project
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Select **New Window** when prompted.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 — Select New Window](img/B31107_09_05.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 — Select New Window
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Once the project is loaded, you can continue to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will update the project dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'LangChain4j: updating the project dependencies'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we used the Spring starter to prepare the starter project, we could only
    add the dependencies identified by that tool. We need to edit the `pom.xml` file
    to add the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the dependencies we need to add to the project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'LangChain4j Spring Boot starter – This dependency provides the Spring Boot
    integration of LangChain4j:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'LangChain4j OpenAI integration – This dependency provides the OpenAI integration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'LangChain4j Neo4j integration – This dependency provides the Neo4j integration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'LangChain4j LLM embeddings integration – This dependency provides the LLM embeddings
    API:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The latest integration options and details can be found at [https://docs.langchain4j.dev/category/integrations](https://docs.langchain4j.dev/category/integrations).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have added the project dependencies, we need to update the configuration
    properties that are required for the application. In the next section, we will
    be looking at updating the application properties.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: When you have made changes to the `pom.xml` file, you might have to reload the
  prefs: []
  type: TYPE_NORMAL
- en: project for the IDE to update all the dependencies correctly. You can learn
    more about how to work with Maven projects with IntelliJ IDEA at [https://www.jetbrains.com/help/idea/delegate-build-and-run-actions-to-maven.html#maven_reimport](https://www.jetbrains.com/help/idea/delegate-build-and-run-actions-to-maven.html#maven_reimport).
  prefs: []
  type: TYPE_NORMAL
- en: 'LangChain4j: updating the application properties'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we need to update the application properties for the dependencies
    we added in the last section to be able to leverage the APIs. We need to add this
    configuration to the `application.properties` file in the project. Since we will
    be using the OpenAI LLM for the chat model and embeddings, we need to acquire
    an API key for this purpose. We need to visit the following website to acquire
    an API key for this purpose: [https://platform.openai.com/docs/overview](https://platform.openai.com/docs/overview).'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the configuration properties we need to add:'
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenAI chat model integration – We need to add this configuration to `application.properties`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'OpenAI embeddings integration – We need to add this configuration to `application.properties`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Neo4j integration – We will add basic Neo4j integration this time, not the
    Neo4j vector database-related integration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have looked at the configuration properties, let us start building
    the application. We will start with Neo4j database integration, and then add chat
    model integration to summarize the transactions and generate embeddings for the
    summary. Finally, we will take a look at building a REST endpoint to invoke those
    requests as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'LangChain4j: Neo4j integration'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will take a look at Neo4j integration first. We will look at this first
    as we need a means to integrate with the database to perform these tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up connectivity to be able to perform read and write transactions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the articles for the transactions that occurred for the specified season.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Persist (save) the embeddings once they are generated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we can build this logic, we need to create a **configuration bean**
    for Neo4j connectivity. We can define that bean like this to read from `application.properties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `ConfigurationProperties` annotation on top of the class definition will
    read `application.properties` and initialize the properties in the bean. The `prefix`
    option tells us to read only the properties that start with that prefix. For example,
    if we want the `uri` field to be populated, then we need to add the `neo4j.uri`
    property to the configuration. We have not included all the getter and setter
    code that is required to read the properties from this bean here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will define a service to provide integration with the Neo4j database
    to read the articles and customer transactions data and update the embeddings
    as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the service class using `@Service` annotation. We also need to inject
    `Neo4JConfiguration` here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `setup` method to initialize the connection to the Neo4j database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the method to get the customer transactions data for given start- and end-of-season
    values. Based on the start- and end-of-season values provided, it retrieves the
    `elementId` value of the start-of-season value and the article description in
    the sequence they are purchased. We need this `elementId` value to save the embeddings
    later. We can see that we are trying to get more related data from the article
    attributes instead of just the description. This way, we can include more attributes,
    such as color, as part of the summary, so that we can represent them as embeddings
    more accurately:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the method to get the articles from the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a method to save the embeddings for the selected season of a customer.
    We are keeping the summary in the graph to understand what the embedding represents.
    Once we understand this aspect, we don’t need to store the summary in the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a method to save the embeddings for the `Article` text on an `Article`
    node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From the code, we can see that this service depends on `Neo4jConfiguration`
    and provides these methods.
  prefs: []
  type: TYPE_NORMAL
- en: The code flow here is simple and provides utility methods to interact with a
    Neo4j database. The methods to get and save data have Cypher queries embedded
    into the code here.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will take a look at an OpenAI chat model integration that can generate
    a summary for the list of articles.
  prefs: []
  type: TYPE_NORMAL
- en: 'LangChain4j: OpenAI chat integration'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To integrate the chat, we need to define `AiService`. This is the API exposed
    by Langchain4J to build Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we define `AiService`, the LangChain4j Spring Framework provides the implementation
    under the covers to make it very easy to invoke the chat service. Let’s look at
    how this can be defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We set a role for the LLM chat engine. This sets the context for the engine
    on what guidelines to use to handle the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We set a goal for the LLM engine here on how it should process the data. This
    describes what the input data is and how it is structured:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The response directive for the LLM gives directions on how the response should
    be structured:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Data` section has the `{text}` variable defined, which is substituted
    with the input the method receives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are defining an interface with an `@AiService` annotation. In this
    service, we need to define a chat method. We will be using a simple AI chat service
    with a `System Message` option here. To read about the common operations and advanced
    operations that `AIServices` offers, please read the documentation at [https://docs.langchain4j.dev/tutorials/ai-services/](https://docs.langchain4j.dev/tutorials/ai-services/).
    Here, we are asking the LLM to act like a fashion expert and give us a summary
    of customer fashion preferences and highlight the top purchases, keeping the order
    of purchases in mind. The `input` parameter from the text is used as input data
    to the chat assistant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will take a look at how we can invoke this chat request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We will take a look at embedding model integration next.
  prefs: []
  type: TYPE_NORMAL
- en: 'LangChain4j: OpenAI embedding model integration'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Embedding model integration is pretty simple since we have already enabled
    `AiService` for the chat service. The embedding model usage looks as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We can see from the code that it is as simple as adding `EmbeddingModel` to
    the class and initializing it using a constructor. When the Spring Boot application
    starts, the appropriate embedding model implementation based on properties is
    instantiated and assigned to this variable. This service provides a method to
    generate the embedding for a given text.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at all the services defined, let us look at how we can
    use all of these to build the application to augment a customer transactions graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'LangChain4j: final application'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the final application, we will build a REST endpoint to issue the request
    to perform the augmentation. Since the process itself can take time, it is split
    into two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Issue a request to start the augmentation process. This returns a request ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use the request ID returned in step 1 to check the progress of the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let us look at the REST controller first to issue requests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a REST controller to handle the HTTP requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inject the individual services defined using the `Autowired` directive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the global variable to hold the current processing requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the method to start the customer transactions augmenting process. This
    method takes the start- and end-of-season values and creates a `ProcessRequest`
    object. It starts a process thread that requests and returns a `UUID` for this
    request. We keep the `UUID` and `ProcessRequest` mapping so that we can provide
    the status when requested:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the method to start the article text augmentation process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a method to get the status of the specified request ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Note**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The graph augmenting process can take a lot of time. In particular, the summary
    generation part using the LLM chat API can be time-consuming and it can take quite
    a lot of time to augment all the customers that match the requirements, say, the
    summer of 2019 purchases. For that reason, the database dump that has the complete
    augmentation only covers around 10,000 customers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let us look at the process request implementation. This is where we tie
    in all the various APIs to perform the required process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to define a class `ProcessRequest` that implements the `Runnable` interface.
    We will start a thread as these requests are long-running ones. The chat service,
    embedding model service, Neo4j service, and other parameters are passed as input
    when we create this request. This class keeps track of the current processing
    status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `run` method implements the actual process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieve the customer transactions data from the Neo4j database. The output
    is a list, where each record contains the relationship ID for the start season
    as the context and the description of the articles in the order in which they
    were purchased:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you reach the required batch size of results collected, save the data
    to the Neo4j database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieve the customer purchase summary from the LLM chat service by passing
    the list of transactions retrieved from the graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the summary we get from the LLM chat service, create an embedding by leveraging
    the embedding service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the summary and embedding along with the relationship context ID into
    a record and then save it into a batch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If any data is left in the batch, save that data to the Neo4j database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this approach, we can augment the graph to perform the next steps to understand
    customer purchase behavior to be able to provide them with better recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code can process the article augmentation. The code is pretty
    much similar to the `ProcessRequest` class. We will look at only the differences
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `run` method reads the data from Neo4j and splits it into batches before
    invoking the batch embedding request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the batch of article texts is collected, we will pass that batch to the
    embedding service to get the embeddings. We will save the embeddings generated
    to the Neo4j database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Generate the embeddings for any of the remaining article texts and save them
    to the Neo4j database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The flow of the operation is similar to the one in the `ProcessRequest` class.
    While we used a single request mode for season purchase embeddings, for article
    embeddings, we are using the *batch mode*. With the single request mode (using
    the API), we could generate only one summary at a time. However, with the batch
    mode, it is much faster to generate embeddings.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the latest project from [https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch9/langchain_graphaugment](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch9/langchain_graphaugment)
    instead of building it from scratch if you would like to play with it.
  prefs: []
  type: TYPE_NORMAL
- en: To run the project, you can right-click on the `LangchainGraphaugmentApplication.java`
    file and select the **Run** menu option.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in customizing the run options and other aspects, then
    you can use the **Run**/**Debug** configurations provided by the IDE. To learn
    more about these aspects, please visit [https://www.jetbrains.com/help/idea/run-debug-configuration-java-application.html](https://www.jetbrains.com/help/idea/run-debug-configuration-java-application.html).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will take a look at how we can build the same recommendation
    engine using Spring AI.
  prefs: []
  type: TYPE_NORMAL
- en: Building your recommendation engine with Spring AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at building the graph augmentation application
    leveraging Spring AI. This project approach is similar to what we built using
    LangChain4j. We will be leveraging the GraphRAG approach to generate embeddings
    for a transaction chain that meets our requirements. We will start with the ZIP
    file downloaded in the last section. We need to unzip the file we have downloaded.
    Once it is unzipped, we will load the project into the IntelliJ platform using
    these steps. This is similar to what we did in the previous section. Please follow
    the steps listed at the start of the *Building your recommendation engine with
    LangChain4j* section to import the project.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to LangChain4j, there are no significant steps to update Spring
    AI project dependencies. Let’s see why.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring AI: updating the project dependencies'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike the LangChain4j project, we don’t need to update any dependencies. We
    were able to add all the required dependencies from the Spring starter project.
    We will take a look next at updating the application properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring AI: updating the application properties'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we need to update the application properties to be able to
    leverage the APIs. We need to add this configuration to the `application.properties`
    file in the project. Since we will be using an OpenAI LLM for the chat model and
    embeddings, we need to acquire an API key for this purpose, which we can do by
    visiting [https://platform.openai.com/docs/overview](https://platform.openai.com/docs/overview).
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the configuration properties we need to add:'
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenAI chat model integration – We need to add this configuration to `application.properties`.
    We only need to add the OpenAI API key:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'OpenAI embeddings integration – We need to add this configuration to `application.properties`.
    We don’t need to add the OpenAI API key again, as it uses the same configuration
    as the LLM chat configuration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Neo4j integration – We will add basic Neo4j integration, not the Neo4j vector
    database-related integration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have looked at the configuration properties, let us start building
    the application. We will start with Neo4j database integration first, then add
    chat model integration for summarizing the transactions and generating embeddings
    for the summary. Finally, we will take a look at building a REST endpoint to invoke
    those requests as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring AI: Neo4j integration'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are looking at Neo4j integration first as we need a means to integrate with
    the database to perform the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up connectivity to be able to perform read and write transactions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See the articles for the transactions that occurred for the specified period.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Persist the embeddings once they are generated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The implementation here is exactly the same as the LangChain4j project discussed
    in the *Langchain4J – Neo4j integration* part of the previous section. We will
    take a look at an OpenAI chat model integration that can generate a summary for
    the list of articles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring AI: OpenAI chat integration'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To integrate the chat, it is a bit different from LangChain4j. We need to define
    `Service` and initialize `ChatClient`. We need to leverage this client and use
    chat APIs to make the request. It is not abstracted as it is with LangChain4j.
    Let us take a look at this service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now look at the steps to integrate OpenAI chat:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to provide the prompts for the LLM slightly differently in the Spring
    AI framework. In the LangChain4j framework, we had a single system message that
    defined the role the LLM is playing, the goal for the response, and data as a
    parameter in a single message. Here, we have to split the role and goal into a
    system prompt template, while the `data` parameter is passed into the user message.
    The outcome is the same in both cases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are setting a role for the LLM chat engine. This sets the context for the
    engine on what guidelines to use to handle the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are setting a goal for the LLM engine here on how it should process the
    data. This describes what the input data is and how it is structured:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The response directive for the LLM gives directions on how the response should
    be structured:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The data is passed as a user message here. It has the `{text}` variable defined,
    which is the property that is substituted with the input the method receives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to initialize the chat client using `ChatClient.Builder`, which is
    injected by the Spring Framework into the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can see that the usage is different from the LangChain4j framework. Here,
    we need to create a prompt with a system template, pass the user message with
    data replacement, and invoke the `chatResponse` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will take a look at embedding model integration next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring AI: OpenAI embedding model integration'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Embedding model integration is pretty simple. We can use `Autowired` to initialize
    the embedding model instance. The embedding model usage looks as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: From the code, we can see it is as simple as adding `EmbeddingModel` to the
    class and initializing it using a constructor. When the Spring Boot application
    starts, the appropriate embedding model implementation based on properties is
    instantiated and assigned to this variable. This service provides a method to
    generate the embedding for a given text.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at all the services defined, let us look at how we can
    use all of these to build a graph augment application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring AI: final application'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The application flow is pretty much the same as the LangChain4j application
    we discussed in the *LangChain4j – final application* section. The code is similar,
    so we will not be adding that code here. The only difference would be the Java
    package names. For posterity, let us take a look at the application flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The REST endpoint is built to issue the request to perform the augmentation.
    Since the process itself can take time, this process is split into two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Issue a request to start the augmentation process. This returns a request ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the request ID returned in step 1 to check the progress of the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first step starts a thread and initiates processing the whole data. The
    request process follows these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve the relationship ID for the start season as the context, and the description
    of the articles in the order in which they were purchased. We return a list of
    records as a response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each record we retrieved from Neo4j, we perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the chat request to generate the summary.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For the summary returned from the chat request, generate an embedding using
    an LLM embedding API.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the relationship ID, summary, and embedding to a map to build a batch.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the batch size reaches the size specified in the configuration, write the
    summary and embedding to the relationship identified by the relationship ID.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: With this approach, we can augment the graph to perform the next steps to understand
    customer purchase behavior to be able to provide customers with better recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the latest project from [https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch9/springai_graphaugment](https://github.com/PacktPublishing/Building-Neo4j-Powered-Applications-with-LLMs/tree/main/ch9/springai_graphaugment)
    instead of building it from scratch if you would like to play with it.
  prefs: []
  type: TYPE_NORMAL
- en: To run the project, you can right-click on the `SpringaiGraphAugmentApplication.java`
    file and select the **Run** menu option.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in customizing the run options and other aspects, then
    you can use the **Run**/**Debug** configurations provided by the IDE. To learn
    more about these aspects, please visit [https://www.jetbrains.com/help/idea/run-debug-configuration-java-application.html](https://www.jetbrains.com/help/idea/run-debug-configuration-java-application.html).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now see how we can use this application we built to augment the graph
    and take a look at how we can provide recommendations from this.
  prefs: []
  type: TYPE_NORMAL
- en: Fine-tuning your recommendation system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the project is ready, we can either run the application in the IDE
    or build a runnable JAR file. Here, we will run it from the IDE directly. We will
    be using a LangChain4j application for testing here. A Spring AI application would
    follow the same principles. We will be starting from the database we created in
    the previous chapter. If you do not want to start from scratch, you can download
    the database dump from [https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/Building+Neo4j-Powered+Applications+with+LLMs+Database+Dump+files.zip](https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/Building+Neo4j-Powered+Applications+with+LLMs+Database+Dump+files.zip)
    and create a database from it.
  prefs: []
  type: TYPE_NORMAL
- en: You can double-click on the `LangchainGraphaugmentApplication`.`j``ava` file
    to load it into the IDE. Once it is loaded, you can right-click on the class name
    to run the application. *Figure 9.6* shows how we can do this.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 — Run the application from the IDE](img/B31107_09_06.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 — Run the application from the IDE
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve right-clicked on the class name, click on the **Run** menu item
    to start the application. Once the application is ready, you should see this in
    the IDE console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Once the application is up and running, we can open a browser and enter the
    URL `http://localhost:8080/augment/SUMMER_2019/FALL_2019` to start the augmentation
    process for the `SUMMER_2019` purchases of customers. When we issue this request,
    we get a UUID such as `aff867bd-08fb-42fb-8a27-3917e0ce83d1` as a response. While
    the process is running, we can inquire about the current completion percentage
    by entering the URL `http://localhost:8080/augment/status/aff867bd-08fb-42fb-8a27-3917e0ce83d1`
    in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `UUID` value of  `aff867bd-08fb-42fb-8a27-3917e0ce83d1` mentioned
    previously is a dynamic one. It is not guaranteed that you will get the same UUID
    as shown in the preceding text. This `UUID` is specific to the run in this example.
    You would need to take a look at the `UUID` returned by the request for your run
    and use it to check the status.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a summary and embedding will take time. Once this process is complete,
    we should create embeddings on articles next. The process is similar to the previous
    step. We need to enter the URL `http://localhost:8080/augmentArticles` in the
    browser. It will also provide us with a `UUID` as a response. We need to keep
    checking the completion percentage until it is complete.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not want to wait for this whole process to complete, you can download
    the database from [https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/Building+Neo4j-Powered+Applications+with+LLMs+Database+Dump+files.zip](https://packt-neo4j-powered-applications.s3.us-east-1.amazonaws.com/Building+Neo4j-Powered+Applications+with+LLMs+Database+Dump+files.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Now, that we have performed the augmentation, let us take a look at how good
    these embeddings are and how they can help us provide recommendations. For this
    purpose, we can further enhance the graph by creating vector indexes for the embeddings
    we created.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can execute this Cypher query to create a vector index for embeddings on
    articles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This creates a vector index on `Article` nodes named `article-embeddings`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Cypher code can be used to create a vector index on the summer
    2019 purchases embedding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This creates a vector index on the `SUMMER_2019` relationship named `summer-2019-embeddings`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a look at using the `Article` vector index first. This Cypher tries
    to find the top five matches for an article with an ID of `0748579001`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'From the results (*Figure 9.7*), we can see that the first match is the best
    match and it is the `Article` node we looked for:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Score** | **Id** | **Desc** |'
  prefs: []
  type: TYPE_TB
- en: '| 1.0 | “0748579001” | “Ankle-length, A-line beach dress in an airy, patterned
    weave with a deep V-neck with gold-coloured studs, and long dolman sleeves with
    elastication and a decorative drawstring at the cuffs. Unlined.” |'
  prefs: []
  type: TYPE_TB
- en: '| 0.882 | “0748033001” | “Long beach dress in airy, crinkled chiffon with narrow,
    tie-top shoulder straps and an opening at the back of the neck. Unlined.” |'
  prefs: []
  type: TYPE_TB
- en: '| 0.873 | “0748582008” | “Short beach dress in an airy cotton weave with broderie
    anglaise. V-neck front and back with a crocheted lace trim, horizontal, tasselled
    straps at the back of the neck, dropped shoulders and short sleeves. Seam at the
    waist and a gently flared skirt. Unlined.” |'
  prefs: []
  type: TYPE_TB
- en: '| 0.866 | “0748025004” | “Kaftan in an airy weave with buttons down the front
    and high slits in the sides.” |'
  prefs: []
  type: TYPE_TB
- en: '| 0.866 | “0747737004” | “Sarong in an airy weave. Size 130x150 cm.” |'
  prefs: []
  type: TYPE_TB
- en: Figure 9.7 — Similar articles for a given article
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we can see that the articles that are less similar to each other have
    lower score values. From this result, let us take `Article` with an ID of `0748582008`
    and see what we can find:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the Cypher, we can see these results:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Score** | **Id** | **Desc** |'
  prefs: []
  type: TYPE_TB
- en: '| 1.0 | “0748582008” | “Short beach dress in an airy cotton weave with broderie
    anglaise. V-neck front and back with a crocheted lace trim, horizontal, tasselled
    straps at the back of the neck, dropped shoulders and short sleeves. Seam at the
    waist and a gently flared skirt. Unlined.” |'
  prefs: []
  type: TYPE_TB
- en: '| 0.969 | “0748582001” | “Short beach dress in an airy cotton weave with broderie
    anglaise. V-neck front and back with a crocheted lace trim, horizontal, tasselled
    straps at the back of the neck, dropped shoulders and short sleeves. Seam at the
    waist and a gently flared skirt. Unlined.” |'
  prefs: []
  type: TYPE_TB
- en: '| 0.893 | “0848082001” | “Short beach kaftan in an airy weave with lace trims.
    Short, wide sleeves, and a drawstring at the waist.” |'
  prefs: []
  type: TYPE_TB
- en: '| 0.884 | “0854784001” | “Short beach dress in an airy cotton weave containing
    glittery threads. Round neckline with a V-neck opening and narrow ties at the
    front, dropped shoulders and long balloon sleeves with narrow, buttoned cuffs.
    Gathered tiers at the hem for added width.” |'
  prefs: []
  type: TYPE_TB
- en: '| 0.884 | “0850893001” | “Calf-length lace kaftan with a crocheted trim around
    the opening, a drawstring and twisted ties at the waist, and long sleeves. Scalloped
    trim around the cuffs and hem.” |'
  prefs: []
  type: TYPE_TB
- en: Figure 9.8 — Similar articles for a given article
  prefs: []
  type: TYPE_NORMAL
- en: From the results, we can see that when the score is closer to `0.9`, the articles
    are pretty similar. We can use this information to provide similar articles as
    recommendations, based on the articles customers have already purchased.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us look at the customer summer purchase behaviors for a customer whose
    ID ends in `92f0`. Let’s call this customer, A:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this Cypher, we can see these results:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Score** | **Id** | **Desc** |'
  prefs: []
  type: TYPE_TB
- en: '| 1.0 | “0002..92f0” | “The customer exhibits a strong preference for vibrant
    colors and comfortable, casual styles, particularly in swimwear and denim. Their
    purchases suggest a love for playful yet practical clothing, suitable for both
    beach outings and everyday wear. The mix of swimwear, shorts, and casual tops
    indicates a versatile wardrobe focused on both style and comfort.” |'
  prefs: []
  type: TYPE_TB
- en: '| 0.968 | “044d..d47e” | “The customer exhibits a strong preference for swimwear,
    particularly in vibrant colors like light orange and dark red, indicating a fun
    and playful style. Their choices also reflect an inclination towards high-waisted
    designs and supportive tops, suggesting a desire for both comfort and fashion.
    Additionally, the purchase of a versatile playsuit and tailored jacket indicates
    an appreciation for stylish yet practical everyday wear.” |'
  prefs: []
  type: TYPE_TB
- en: '| 0.967 | “07fe..a87f” | “The customer exhibits a strong preference for swimwear,
    particularly in vibrant colors like orange and black, indicating a love for beach
    and poolside activities. There is also a notable inclination towards basic wardrobe
    staples, such as tank tops and shorts, suggesting a desire for comfortable yet
    stylish casual wear. The blend of swimwear and basic clothing reflects a versatile
    fashion sense suitable for both leisure and everyday wear.” |'
  prefs: []
  type: TYPE_TB
- en: '| 0.966 | “0247..74b3” | “The customer demonstrates a preference for vibrant
    colors and versatile clothing items suitable for various occasions, including
    casual wear and swimwear. The repeated purchases of swimwear suggest a keen interest
    in beach or poolside activities. Additionally, the inclusion of dresses and accessories
    indicates a desire for stylish yet comfortable outfits.” |'
  prefs: []
  type: TYPE_TB
- en: '| 0.965 | “0686..5220” | “The customer displays a strong preference for vibrant
    colors, particularly orange and white, as seen in their selection of swimwear
    and casual attire. Their purchases indicate a blend of comfort and style, with
    a focus on versatile pieces that can be worn for various occasions. The inclusion
    of both swimwear and everyday clothing suggests a lifestyle that appreciates both
    leisure and fashion.” |'
  prefs: []
  type: TYPE_TB
- en: Figure 9.9 — Purchase summaries for other customers similar to the given customer
  prefs: []
  type: TYPE_NORMAL
- en: 'From the basic summary, we can see that the customer purchase behaviors are
    pretty similar. Let us pick another customer (say, customer B) from this list
    to see whether the same customers are returned when we run the same query. We
    will pick the customer ID ending in `74b3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us look at the results when we run this query:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Score** | **Id** | **Desc** |'
  prefs: []
  type: TYPE_TB
- en: '| 1.0 | “0247..74b3” | “The customer demonstrates a preference for vibrant
    colors and versatile clothing items suitable for various occasions, including
    casual wear and swimwear. The repeated purchases of swimwear suggest a keen interest
    in beach or poolside activities. Additionally, the inclusion of dresses and accessories
    indicates a desire for stylish yet comfortable outfits.” |'
  prefs: []
  type: TYPE_TB
- en: '| 0.968 | “05de..29df” | “The customer’s fashion preferences indicate a strong
    inclination towards swimwear and dresses, particularly in vibrant and playful
    colors such as pink, orange, and blue. The selection of both swimwear and dresses
    suggests a versatile style that embraces both casual beachwear and stylish everyday
    attire. Additionally, the repeated purchases of high-waisted bikini bottoms showcase
    a preference for flattering and functional swimwear options.” |'
  prefs: []
  type: TYPE_TB
- en: '| 0.967 | “0322..3e92” | “The customer exhibits a strong preference for swimwear,
    as evidenced by multiple purchases of bikini tops and bottoms, showcasing a desire
    for stylish beach attire. Additionally, the selection of dresses and blouses reflects
    an inclination towards fashionable yet comfortable everyday wear. The use of vibrant
    colors and unique design elements indicates a taste for contemporary and eye-catching
    pieces.” |'
  prefs: []
  type: TYPE_TB
- en: '| 0.966 | “0002..92f0” | “The customer exhibits a strong preference for vibrant
    colors and comfortable, casual styles, particularly in swimwear and denim. Their
    purchases suggest a love for playful yet practical clothing, suitable for both
    beach outings and everyday wear. The mix of swimwear, shorts, and casual tops
    indicates a versatile wardrobe focused on both style and comfort.” |'
  prefs: []
  type: TYPE_TB
- en: '| 0.965 | “0863..c454” | “The customer displays a strong preference for swimwear,
    particularly in vibrant colors like dark red and orange, indicating a fondness
    for beachwear and summer styles. Additionally, their choices in everyday clothing,
    such as airy dresses and denim skirts, suggest an inclination towards comfortable
    yet stylish casual wear. The repetition of specific items also reflects a desire
    for consistency and reliability in their fashion selections.” |'
  prefs: []
  type: TYPE_TB
- en: Figure 9.10 — Purchase summaries for other customers similar to the given customer
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the top five matches for customer B are very different from
    those of customer A, even though customer B’s purchase summary was in the top
    five similar customer purchases of customer A.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this approach to recommend articles to purchase based on customer
    purchase behavior. We are capturing the order of the purchases, but how the summary
    of these purchases is captured by an embedding defines who will be considered
    a similar customer. Let us see what this query would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to find other customers similar to this customer based on purchases.
    We will use the vector index to get the top five similar customers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Collect the articles purchased by the customer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Collect the articles purchased by the other customers who are similar to the
    first customer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the articles purchased by the original customer from the articles purchased
    by similar customers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This Cypher first collects the purchases made by the customer, finds other
    customers who have similar purchase behavior, retrieves the purchases made by
    those customers, and recommends 10 articles to the original customer that they
    haven’t previously purchased. The output of this query looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Id** | **Desc** |'
  prefs: []
  type: TYPE_TB
- en: '| “0471714036” | “Knee-length shorts in a cotton weave with a button fly, side
    pockets and a welt back pocket with a button.” |'
  prefs: []
  type: TYPE_TB
- en: '| “0699923078” | “T-shirt in soft, printed cotton jersey.” |'
  prefs: []
  type: TYPE_TB
- en: '| “0786663001” | “Short, off-the-shoulder dress in an airy, plumeti weave with
    elastication and a small frill trim at the top. Long sleeves with elastication
    at the cuffs, an elasticated seam at the waist and a flounce at the hem. Jersey
    lining.” |'
  prefs: []
  type: TYPE_TB
- en: '| “0728473001” | “Triangle bikini top with laser-cut scalloped edges and lightly
    padded cups with removable inserts. Narrow, adjustable shoulder straps that can
    be fastened in different ways and an adjustable metal hook fastening at the back.”
    |'
  prefs: []
  type: TYPE_TB
- en: '| “0689040001” | “Fully lined bikini bottoms with a mid waist, wide sides,
    a wide tie at one side and medium coverage at the back.” |'
  prefs: []
  type: TYPE_TB
- en: '| “0736046001” | “Metal hoop earrings in different sizes, three with charms
    in various designs. Diameter 1-2 cm.” |'
  prefs: []
  type: TYPE_TB
- en: '| “0713200006” | “Fully lined, waist-high bikini bottoms with wide sides and
    medium coverage at the back.” |'
  prefs: []
  type: TYPE_TB
- en: '| “0674606026” | “Short, A-line skirt with a high waist and buttons down the
    front.” |'
  prefs: []
  type: TYPE_TB
- en: '| “0562245064” | “5-pocket jeans in washed, superstretch denim with a regular
    waist, zip fly and button, and skinny legs.” |'
  prefs: []
  type: TYPE_TB
- en: '| “0557247005” | “Oversized top in sturdy sweatshirt fabric with dropped shoulders
    and ribbing around the neckline, cuffs and hem. Soft brushed inside.” |'
  prefs: []
  type: TYPE_TB
- en: Figure 9.11 — Recommendations for a customer based on purchases made by similar
    customers
  prefs: []
  type: TYPE_NORMAL
- en: By following the steps explained to fine-tune your graph, we can now provide
    recommendations based on customer purchase behavior by finding similar customers
    and their purchases or similar articles based on what customers bought. This approach
    is simple and works well. But we are determining who similar customers are, and
    so on. We might want to use **Graph Data Science** algorithms or machine learning
    to group customers better so that we can provide better recommendations. We will
    take a look at that aspect in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to build intelligent applications by leveraging
    LangChain4j and Spring AI. We used these applications to augment the H&M transactions
    graph we loaded in the previous chapter, by leveraging LLM chat and embedding
    capabilities. Once the graph was augmented, we further enhanced the graph by leveraging
    vector indexes and saw how these indexes help us find similar articles or customers
    based on their purchases.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will step into **Graph Data Science** algorithms to
    see how we can further enhance these recommendations.
  prefs: []
  type: TYPE_NORMAL
