- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performing Complex Actions by Chaining Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to create native plugins, which we used
    to check the format of Excel and Word documents, and semantic plugins, which we
    used to verify whether the content of the documents fulfilled our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start by creating a simple pipeline that generates
    images. The pipeline will receive a text with clues about an animal and will then
    generate a text that guesses the animal from the clues, as well as generating
    a picture of the animal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later in the chapter, we will continue the application of the previous chapter:
    verifying whether grant requests fulfill some requirements. For that application,
    a grant request will come with two files inside a folder: a Word document and
    an Excel spreadsheet.'
  prefs: []
  type: TYPE_NORMAL
- en: Our application checks that the Word document contains a proposal for a vaccination
    campaign, including the team who will perform it and their experience, and an
    Excel file that contains its budget.
  prefs: []
  type: TYPE_NORMAL
- en: 'This type of scenario is common in enterprises: governments and corporations
    must prioritize requests for projects, editors must approve or reject book proposals,
    and lawyers must verify that the documents they are filing in court fulfill legal
    requirements. It’s not uncommon to have to verify thousands or tens of thousands
    of documents. This is a kind of job that, until recently, was done manually. We’re
    going to write a pipeline that automates it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a native plugin that generates images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaining a semantic plugin that outputs text with the native plugin that generates
    images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a complex, multistep pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have the tools required to build a kernel
    that can perform many coordinated functions, and that can be used as a copilot
    or be integrated into other tools, such as a planner.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you will need to have a recent, supported version
    of your preferred Python or C# development environment:'
  prefs: []
  type: TYPE_NORMAL
- en: For Python, the minimum supported version is Python 3.10, and the recommended
    version is Python 3.11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For C#, the minimum supported version is .NET 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will call OpenAI services. Given the amount that companies
    spend on training these LLMs, it’s no surprise that using these services is not
    free. You will need an **OpenAI API** key, either directly through **OpenAI**
    or **Microsoft**, via the **Azure** **OpenAI** service.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using .NET, the code for this chapter is at [https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/dotnet/ch4](https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/dotnet/ch4).
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Python, the code for this chapter is at [https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/python/ch4](https://github.com/PacktPublishing/Building-AI-Applications-with-Microsoft-Semantic-Kernel/tree/main/python/ch4).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install the required packages by going to the GitHub repository and
    using the following: `pip install -``r requirements.txt`.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a native plugin that generates images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To learn about the power of chaining functions, we are going to create functions
    that perform very different actions. We will start by creating functions that
    generate images and putting them in a plugin. Then, we’re going to learn how to
    incorporate these functions into a more complex chain.
  prefs: []
  type: TYPE_NORMAL
- en: In some applications, you may want to generate an image with AI. For example,
    social media posts with images tend to get more engagement, but creating images
    without AI or finding images can be time-consuming and expensive.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to market prices of non-AI images, generating images with AI is very
    cheap. On the other hand, generating images is still one of the most compute-intensive
    activities that can be done with AI. Recent research from Hugging Face [1] has
    shown that generating an image is 2,000 times more expensive in terms of carbon
    emissions than generating a text answer. These costs will be passed down to you.
  prefs: []
  type: TYPE_NORMAL
- en: Costs of OpenAI image generation
  prefs: []
  type: TYPE_NORMAL
- en: If you want to reproduce the content in this section, be aware that image generation
    is far more costly than text generation. You will need an API key, and each image
    generation costs $0.04 per image for the following examples, and up to $0.12 per
    image if you want to create higher-quality images with higher resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: Prices change frequently, and you can check the latest prices at [https://openai.com/pricing](https://openai.com/pricing).
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 4**.1*, we show two examples of images generated with AI that I have
    created to enhance a couple of my social media posts. The first, me as a cowboy,
    was for a post about billionaires using cowboy hats. The second, with me as a
    character on the cover of a romantic novel, was for a post about writing fiction.
    Each image took less than a minute to generate with AI. I ran a test in Threads,
    Instagram’s new microblogging app where I have over 10,000 followers, and the
    image posts had multiple times more engagement than posts with the same text but
    no image.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Images generated with AI for social media posts](img/B21826_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Images generated with AI for social media posts
  prefs: []
  type: TYPE_NORMAL
- en: Image generation support in Microsoft Semantic Kernel is not consistent. The
    C# API has an object called `TextToImage` that can generate images using DALL-E
    2, a model released in November 2022, but that API is not available for Python.
    That image-generating model is now obsolete, having been superseded by DALL-E
    3 in October of 2023; however, at the time of writing, Semantic Kernel does not
    offer an out-of-the-box way to access DALL-E 3.
  prefs: []
  type: TYPE_NORMAL
- en: We will create two native plugins, one for C# and one for Python, that allow
    us to access DALL-E 3 from Semantic Kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new models to the kernel
  prefs: []
  type: TYPE_NORMAL
- en: Although we are using DALL-E 3, as an interesting and novel model, as the example
    that we are adding to the kernel, this approach of creating a native plugin wrapper
    works for any model that has an API, including Claude from Anthropic, Gemini from
    Google, and hundreds of models from Hugging Face. Any AI service that is made
    available through a REST API can be added in this way.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a DALL-E 3 wrapper in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is easier to write a DALL-E 3 wrapper in Python than in C# because OpenAI
    offers and supports a Python package called openai that allows developers to access
    any new OpenAI function as soon as it’s made available. All we must do is create
    a native function that uses the OpenAI package and send a request to DALL-E 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As we saw in [*Chapter 3*](B21826_03.xhtml#_idTextAnchor071), we declare a native
    function using the `kernel_function` decorator. We then simply instantiate an
    OpenAI client object with our API key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s submit the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The Python OpenAI client contains the `images.generate` method, which will call
    DALL-E 3 and return the generated URL. We simply call it and return the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to create a simple script that instantiates the plugin and
    calls it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code instantiates the `Dalle3` native plugin and calls its `ImageFromPrompt`
    function with the `"A painting of a cat sitting on a sofa in the impressionist
    style"` input parameter. An example output is in *Figure 4**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4-2 – A cat in the impressionist style generated by DALL-E 3 by Python](img/B21826_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – A cat in the impressionist style generated by DALL-E 3 by Python
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to do this in Python, let’s see how to do it in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a DALL-E 3 wrapper in C#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenAI does not provide a supported package for C# that allows users of that
    language to interact with its service. The best way of interacting with the OpenAI
    service for C# users is to use Microsoft Semantic Kernel, which has a `TextToImage`
    functionality, but at the time of writing, it only provides connectivity to DALL-E
    2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most AI services will expose a REST API. Therefore, to connect Microsoft Semantic
    Kernel to them, one solution is to write a native plugin that wraps the REST API.
    We show how to do this for DALL-E 3 here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Making a REST `POST` request requires several packages, such as `System.Text.Json`
    and `System.Net`. Like what we did in [*Chapter 3*](B21826_03.xhtml#_idTextAnchor071),
    we use a decorator, `KernelFunction`, to signal that the function is accessible
    to Semantic Kernel, and a `Description` attribute to describe what our function
    does.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then create an `HttpClient` object. This object will make a REST API call.
    We need to set it up with our API key as a `Bearer` token and set its header as
    accepting “`application/json`” because that’s how the OpenAI API will respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to submit the `POST` request to the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We created a JSON object, `obj`, using the fields that are required by the
    OpenAI API. The `model` field states what model we’re using, and here we make
    sure to specify `"dall-e-3"` to use DALL-E 3\. The documentation of all the possible
    parameters can be found here: [https://platform.openai.com/docs/api-reference/images/create](https://platform.openai.com/docs/api-reference/images/create).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step is to recover the `url` field from the JSON returned by OpenAI.
    That `url` field points to the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s see how to call the plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To call the plugin, we added a reference to the source file, `Plugins`, instantiated
    the `Dalle3` plugin with `AddFromType`, and called its `ImageFromPrompt` method,
    passing `prompt` as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting picture is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – A cat in the impressionist style generated by the C# native
    plugin](img/B21826_04_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – A cat in the impressionist style generated by the C# native plugin
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created a function that accesses a new service, let’s incorporate
    it into a solution that uses it.
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple steps to solve a problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although programming solutions step by step can be very helpful, one of the
    best abilities that Semantic Kernel gives users is allowing them to make requests
    using natural language. This will require using **planners**, which we will use
    in [*Chapter 5*](B21826_05.xhtml#_idTextAnchor106), to break down a user request
    into multiple steps and then automatically call each step in the appropriate order.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will solve problems by telling Semantic Kernel which functions
    to call. This is helpful for making sure that the solutions we make available
    to the planner work, and it is also helpful when we want to explicitly control
    how things are executed.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the manual approach, we will see how to give Semantic Kernel clues
    about an animal, guess it with a semantic function, and then generate an image
    of the animal using the native function we created in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Generating an image from a clue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following code, we have two steps. In the first step, we will use GPT-3.5
    to guess an animal from clues. To do that, we will create a semantic plugin called
    `AnimalGuesser`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important: Using OpenAI services is not free'
  prefs: []
  type: TYPE_NORMAL
- en: 'The semantic functions will call the OpenAI API. These calls require a paid
    subscription, and each call will incur a cost. The costs are usually small per
    request. GPT 3.5 costs $0.0002 per thousand tokens, but they may add up if you
    make a large number of calls. Prices change frequently, so make sure to check
    the latest prices on the following websites:'
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenAI pricing: [https://openai.com/pricing](https://openai.com/pricing)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure OpenAI pricing: [https://azure.microsoft.com/en-us/pricing/details/cognitive-services/openai-service/](https://azure.microsoft.com/en-us/pricing/details/cognitive-services/openai-service/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The semantic plugin, as always, consists of two files, `config.json` and `skprompt.txt`,
    listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: config.json
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: skprompt.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we always do, we must make sure that the `description` fields in the `config.json`
    files are set correctly. This will not have any effect now, but when we start
    using the planner or letting Semantic Kernel automatically call functions, the
    kernel will use the `description` fields to figure out what each function does
    and decide which ones to call.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let’s see how to tell the kernel to call functions in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining semantic and native functions with C#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C#, you need to use the `KernelFunctionCombinators` class to create a function
    pipeline. The code for the class is provided in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for implementing a function pipeline follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we create our kernel, add an OpenAI service to it,
    and add the `AnimalGuesser` and `Dalle3` plugins to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we assign the functions we want to call, `AnimalGuesser.GuessAnimal`
    and `Dalle3.ImageFromPrompt`, to `KernelFunction` variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we create a `KernelArguments` object called `context` and pass it as
    a parameter to `InvokeAsync`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The attributes of the `context` object must match what the first function is
    expecting. In our case, the `AnimalGuesser.GuessAnimal` function expects a parameter
    named `input`. From then on, the pipeline will call each function, get the output
    as a text string, and pass that text string as the first parameter to the next
    function. In our case, even though the first parameter of the `Dalle3.ImageFromPrompt`
    function is called `prompt` instead of `input`, the call is still going to work.
    You only need to provide the correct name for the parameter used in the first
    step of the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the preceding program, you will get a picture of a cat:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Picture of a cat generated from AI guessing the animal from
    clues](img/B21826_04_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Picture of a cat generated from AI guessing the animal from clues
  prefs: []
  type: TYPE_NORMAL
- en: Chaining semantic and native functions with Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we did in C#, let’s use Python to create a script that starts from a list
    of clues, guesses the animal that the clues refer to, and then generates a picture
    of the animal.
  prefs: []
  type: TYPE_NORMAL
- en: We will build on the plugins we already have. We will reuse the native plugin
    that we created to generate images using DALL-E 3.
  prefs: []
  type: TYPE_NORMAL
- en: One new thing is that we are going to create a function called `pipeline` that
    receives a list of functions and an input parameter and then calls each function
    in the list, passing the output of the call as the input parameter of the next
    function in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of the function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We start as we always do, creating a kernel and adding an AI service to it.
    Here, we are assigning the plugins to variables, which will enable us to reference
    functions in the next step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, we can now give our model the clues and ask it to guess:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As seen in the preceding snippet, to run the pipeline, we create the list of
    functions we want to call in order, adding it to the `function_list` variable,
    and then call the `pipeline` function. The `pipeline` function will run the first
    function with the input parameter you passed, then it will use the output of the
    first function as the parameter of the second function, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Like what happened in the C# example, the output will be a URL pointing to a
    freshly generated picture of a cat (not displayed).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’re done with a simple example of a pipeline, let’s go back to the
    problem we were solving in [*Chapter 3*](B21826_03.xhtml#_idTextAnchor071) and
    described in the introduction of this chapter: verifying whether a proposal for
    a vaccination campaign fulfills the basic requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with larger, more complex chains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we created three plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CheckSpreadsheet`: A native plugin that checks that the Excel spreadsheet
    contains the required fields and that they fulfill some rules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ParseWordDocument`: A native plugin that extracts text from a Word document'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProposalChecker`: A semantic plugin that checks whether text blocks fulfill
    some requirements, such as “*does this text block describe a team that has a Ph.D.
    and a* *medical doctor*?”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these three plugins, you can already solve the business problem of checking
    proposals by calling each plugin separately and writing the logic to handle whether
    there was an error. This is likely sufficient for problems that have a small number
    of steps.
  prefs: []
  type: TYPE_NORMAL
- en: While we are still going to use a small number of steps and a small number of
    documents for didactic purposes, the approach to analyzing and making decisions
    on a large number of documents presented in this chapter excels when there are
    many steps and many documents to process.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing our directory structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start, we need to make sure that we have the data for the proposals
    loaded in the `data/proposals` folder. We will also reuse the native plugins by
    putting them in the same directory as our main program. The semantic plugins will
    be in the `plugins` directory.
  prefs: []
  type: TYPE_NORMAL
- en: We will modify our native and semantic functions slightly from what we did in
    the previous chapter. The main change is that we will introduce error handling
    directly into the semantic functions, which will enable us to process many documents
    with a single call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below is the directory structure of our solution. Each proposal is represented
    by a directory in the `proposals` directory, and each directory should contain
    exactly two files, one Excel file with the extension `.xlsx` and one Word file
    with the extension `.docx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This follows the same structure we used earlier: a main file containing the
    code (`ch4.py` or `Program.cs`), additional files in the same directory, each
    containing a native plugin (`ParseWordDocument` and `CheckSpreadsheet`), and all
    the semantic plugins in a dedicated directory, `plugins`. We separate folders
    by language because that makes it simpler to manage the virtual environments that
    hold installed packages by folder. Semantic plugins are language-independent and
    can have their own directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have described the expected directory structure, let’s look at the
    high-level flow of our process.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the flow of our process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start by writing a native plugin called `Helpers` that contains a native
    function called `ProcessProposalFolder`, which when given a path that represents
    a folder, checks whether it contains exactly one Excel file and a Word document.
    If it does, it returns the path of the folder, if not, it returns a string with
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: Once we create the `Helpers` plugin, we will be almost ready to call the functions
    we developed in [*Chapter 3*](B21826_03.xhtml#_idTextAnchor071). We will make
    two modifications to the existing files `ParseWordDocument` and `CheckSpreadsheet`.
  prefs: []
  type: TYPE_NORMAL
- en: One modification we will make to both files will be to check if the input is
    an error state. If it is, we simply pass the error state forward. If we are not
    in an error state, we keep passing the folder path forward. We will need to make
    these simple modifications to all the native functions and semantic functions.
  prefs: []
  type: TYPE_NORMAL
- en: The second and last modification will be to the `ParseWordDocument` native plugin.
    We will add three separate helper functions, each one parsing one of the three
    different required sections of the document (`Team`, `Experience`, and `Implementation`
    details). The new functions will simply call the existing function with a parameter
    representing one section per function.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for doing all of this is to only have functions with a single parameter
    in the pipeline. This enables the return of each function to be passed as a parameter
    to the next function, which will make things much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: The full pipeline, with 10 steps, is represented in the next diagram.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Visual representation of the pipeline](img/B21826_04_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Visual representation of the pipeline
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 4**.5*, orange boxes represent native functions that deal with the
    filesystem, green boxes represent native functions that deal with Excel, blue
    boxes represent native functions that deal with Word, and purple boxes represent
    semantic functions.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand all the steps for the pipeline, let’s create the new
    plugin and function and make the required modifications.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the native function to process a folder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get the pipeline started, we need a plugin that ensures that the folder that
    we want to process contains the correct files. Since this is an activity that
    requires interacting with the operating system, we need to create a native function,
    which we will host inside a plugin we will call `Helpers`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the plugin is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: C#
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As usual, since we want this function to be available to Semantic Kernel, we
    use the `KernelFunction` decorator and the descriuption of what the function does
    under the `Description` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are simply going to count the number of files available in the folder.
    Remember that we want exactly one file with the `.docx` extension and one file
    with the `.``xlsx` extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The logical part of the function is very simple. It counts the number of files
    with the `.docx` and `.xlsx` extensions in the directory. If the directory has
    one of each, the call succeeded. We signal success by passing the folder as the
    return result. In any other situation, we generate a string with an error message.
    We will use the convention that error messages in this pipeline start with `Error`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now check out the code for the plugin in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In Python, we use the `kernel_function` decorator to indicate that this function
    can be used by Semantic Kernel. We also add an `Annotated` description to the
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the function code is very simple. Similar to the C# function above, we
    count how many files with the `.docx` and `.xlsx` extensions are in the directory.
    If there’s exactly one of each, we indicate success by returning the folder name.
    Anything else will result in a failure, which will be indicated by a string starting
    with `Error`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the function to kick off the pipeline, let’s see what needs
    to be done with the plugins we wrote in [*Chapter 3*](B21826_03.xhtml#_idTextAnchor071)
    to make them usable for this pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the Excel native plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to make a few changes to the Excel plugin we created for [*Chapter
    3*](B21826_03.xhtml#_idTextAnchor071):'
  prefs: []
  type: TYPE_NORMAL
- en: Standardize the error message to always start with `Error`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standardize the success message to always return the folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the beginning of every function, if the input starts with `Error`, do nothing
    and simply pass the received input forward
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To save space, the following code shows the changes to only one of the functions,
    `CheckTabs`. The full modified code is available in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: C#
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code checks if the input received contains an error. Since this
    is going to be used in a pipeline, any errors in previous steps will be received
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we get an error, we’re simply going to pass the error forward in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are ensuring that any error message starts with `Error`, to make
    sure they’re easy to detect when they are received by other pipeline functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now check how many sheets are in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the case of success, we simply pass the folder forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, the following code passes the error forward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Let’s see the changes in Python. To save space, we’re only showing the changes
    to the `CheckTabs` function. The full code for all functions is in the GitHub
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If the previous function sent us an error, we simply pass it forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, we continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To indicate success, we simply return the folder we received as input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have standardized the input and output of the functions, it makes
    it easier to extend the pipeline, since all the functions expect the same input,
    a folder, and when the function succeeds, it simply passes the folder to the next
    function.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of an error, the string passed as an input will start with `Error`,
    and all functions will simply pass it forward. These changes make it easier to
    change the order of steps and to add or remove steps.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’re done with the changes in the Excel plugin, let’s make changes
    to the `ParseWordDocument` plugin that extracts text from Word documents.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the Word native plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The modifications to the Word native plugin are very simple. In [*Chapter 3*](B21826_03.xhtml#_idTextAnchor071),
    when we were calling the native plugin directly, we created a function called
    `ExtractTextUnderHeading` that received two parameters: a path to a file and the
    heading that we wanted to extract, and we called that function three times so
    that we could extract the text under the three headings we wanted.'
  prefs: []
  type: TYPE_NORMAL
- en: In pipelines, since we can only have one parameter, we will create three functions
    named `ExtractTeam`, `ExtractExperience`, and `ExtractImplementation` that receive
    the folder as a parameter and call the `ExtractTextUnderHeading` function that
    we created in [*Chapter 3*](B21826_03.xhtml#_idTextAnchor071) with the appropriate
    heading parameter, respectively `"Team"`, `"Experience"`, and `"Implementation"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like we did with the Excel plugin, we will also make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Standardize the error message to always start with `Error`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standardize the success message to always return the folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the beginning of every function, if the input starts with `Error`, do nothing
    and simply pass the received input forward
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To save space, we only show one of the functions here. The full code, including
    the modifications in the `ExtractTextUnderHeading` function, is in the GitHub
    repository:'
  prefs: []
  type: TYPE_NORMAL
- en: C#
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, in addition to creating three function wrappers for `ExtractTextUnderHeading`
    to extract the text, we also perform two more tasks. The first is to check whether
    the previous step of the pipeline sent an error message. If it did, we simply
    pass it on. The second is to prepend the folder path to the text in a line called
    `FolderPath`. This will be used in the semantic functions. When the semantic function
    decides that the text it read fulfills the requirements, it will return the folder
    path, as is expected by functions in the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s work on the semantic functions.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the semantic functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main modification that we need to make to the semantic functions is to ensure
    they understand the inputs and provide the appropriate outputs – either the folder
    in the case of success or an error message in the case of failure.
  prefs: []
  type: TYPE_NORMAL
- en: One way to do this is to encode the input into tags and then tell the AI service
    to perform operations on the contents of the tag. There was no need to modify
    the `config.json` files, only the `skprompt.txt` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'CheckTeamV2: skprompt.txt'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this semantic function, we tell the AI to check the contents of the text
    between `=====` for an error and simply pass it on if it finds one. If the contents
    between the ===== tags are not an error, they will contain the folder we’re processing
    in a line starting with `FolderPath` and the text from the `Team` heading in the
    Word document. We tell the AI to return the folder if the team fulfills the requirements
    we list or to return an error message if they don’t:'
  prefs: []
  type: TYPE_NORMAL
- en: 'CheckDatesV2: skprompt.txt'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We now ask the AI to check the contents between the `=====` tags for an error.
    The same as before, we simply pass it on if we find it. We then check whether
    the dates proposed for the vaccination campaign are within our expectations. If
    they are, we return the folder contained in the `FolderPath` line inside the tag.
    Otherwise, we return an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: 'CheckPreviousProjectV2: skprompt.txt'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The final semantic function is very similar to the previous two. We ask the
    AI to check the contents between the `=====` tags and return an error message
    if the team requesting for funding does not have enough experience as demonstrated
    by a previous project.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’re done with all the steps of our process, let’s assemble them into
    a pipeline and run it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and calling the pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Calling the pipeline requires creating a kernel, loading it with the functions
    we want, and then calling them in sequence. Since we’re going to use semantic
    functions, we also need to add an AI service to the kernel. Evaluating text against
    requirements can be a complex task, and therefore we will use GPT-4 to execute
    it. GPT 3.5 can work if the documents are simple, but some of our documents have
    more than one page, and that can be too much for GPT 3.5 to handle well.
  prefs: []
  type: TYPE_NORMAL
- en: C#
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, we load all the native and semantic plugins into
    our kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create variables for each of the functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Creating variables for each of the functions is not strictly necessary – you
    could simply put the code on the right-hand side of each of the preceding assignments
    directly into the pipeline call.
  prefs: []
  type: TYPE_NORMAL
- en: For example, instead of
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Assigning it to variables makes the contents of the pipeline call much shorter,
    and that can make it easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a pipeline with the `Pipe` method of `KernelFunctionCombinators`,
    simply listing the steps in the order we want them to be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step will be to call the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We get the path of the `data/proposals` folder that contains our proposals.
    Each proposal is a subfolder of that folder. We iterate over each of the subfolders
    of the `data/proposal` folder and call our pipeline. If we don’t find any errors,
    we print `Success`. Otherwise, we list the errors we found.
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating our kernel, adding the GPT-4 service to it, and adding
    all the native and semantic plugins to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note that we added the pipeline function that we created in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step is to create a function list and call the pipeline for each
    document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The full pipeline obtains the expected results, with the proposals that fulfill
    all the requirements returning success and the proposals with problems returning
    an error message describing the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are displayed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before having the help of AI, reading and interpreting a document required using
    the time of a person, or writing a specialized machine learning model. Semantic
    Kernel allows you to write code to analyze large and complex documents.
  prefs: []
  type: TYPE_NORMAL
- en: In our pipeline, the `CheckSpreadsheet` native plugin does not strictly require
    Semantic Kernel and could be done in a separate step, since it only runs code
    that is never read by AI. We added it to the pipeline to make our end-to-end solution
    more streamlined.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ParseWordDocument` native plugin, on the other hand, helps Semantic Kernel
    receive the information in parts. Breaking the document into parts makes the semantic
    functions simpler: each function can evaluate just a portion of the document.
    For example, the function that evaluates the *Teams* section of the document just
    needs to check the team qualifications. That makes the function a lot simpler
    to write than a function that reads the whole document and decides about all sections
    of the document in a single step.'
  prefs: []
  type: TYPE_NORMAL
- en: The real value that AI adds to this process, therefore, is in the semantic plugin.
    The tasks of evaluating sections of the document that are implemented by the semantic
    functions in the `ProposalCheckerV2` plugin are the ones that would formerly require
    either a lot of human effort or a specialized machine learning model. This chapter
    showed how to execute these tasks just by describing what the requirements were
    in three short `skprompt.txt` files.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we created our pipeline manually, explicitly naming the functions
    that we wanted to call and in which order. In the next chapter, we will learn
    how to use a planner. The planner will receive the user request and decide which
    functions to call and in which order.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[1] A. S. Luccioni, Y. Jernite, and E. Strubell, “Power Hungry Processing:
    Watts Driving the Cost of AI Deployment?” arXiv, Nov. 28, 2023\. doi: 10.48550/arXiv.2311.16863.'
  prefs: []
  type: TYPE_NORMAL
