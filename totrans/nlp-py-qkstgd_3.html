<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Leveraging Linguistics</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we are going to pick up a simple use case and see how we can solve it. Then, we repeat this task again, but on a slightly different text corpus.</p>
<p class="mce-root">This helps us learn about build intuition when using linguistics in NLP. I will be using spaCy here, but you are free to use NLTK or an equivalent. There are programmatic differences in their APIs and styles, but the underlying theme remains the same.</p>
<p>In the previous chapter, we had our first taste of handling free text. Specifically, we learned how to tokenize text into words and sentences, pattern match with regex, and make fast substitutions.</p>
<p>By doing all of this, we operated with text on a <em>string</em> as the main representation. In this chapter, we will use <em>language</em> and <em>grammar</em> as the main representations.</p>
<p>In this chapter, we will learn about the following topics:</p>
<ul>
<li>spaCy, the natural language library for industrial use</li>
<li>The NLP pipeline, and a bit of English grammar</li>
<li>Real-life examples regarding what we can do with linguistics</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Linguistics and NLP</h1>
                </header>
            
            <article>
                
<p class="mce-root"><strong><span><span>T</span></span></strong>his section is dedicated to introducing you to the ideas and tools that have been around during several decades of linguistics. The most traditional way to introduce this is to take an idea, talk about it at length, and then put all of this together.</p>
<p class="mce-root">Here, I am going to do this the other way around. We will solve two problems and, in the process, look at the tools we will be using. Instead of talking to you about a number 8 spanner, I am giving you a car engine and the tools, and I will introduce the tools as I use them.</p>
<p class="mce-root"/>
<p class="mce-root">Most NLP tasks are solved in a sequential pipeline, with the results from one component feeding into the next.</p>
<p class="mce-root">There is a wide variety of data structures that are used to store pipeline results and intermediate steps. Here, for simplicity, I am going to use only the data structures that are already in spaCy and the native Python ones like lists and dictionaries.</p>
<p class="mce-root">Here, we will tackle the following real-life inspired challenges:</p>
<ul>
<li class="mce-root">Redacting names from any document, for example, for GDPR compliance</li>
<li class="mce-root">Making quizzes from any text, for example, from a Wikipedia article</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started</h1>
                </header>
            
            <article>
                
<p class="mce-root">You can install spaCy via <kbd>conda</kbd> or <kbd>pip</kbd>. Since I am in a <kbd>conda</kbd> environment, I will use the <kbd>conda</kbd> installation, as follows:</p>
<pre class="mce-root"><strong># !conda install -y spacy </strong><br/><strong># !pip install spacy</strong></pre>
<p class="mce-root">Let's download the English language model provided by spaCy. We are going to use <kbd>en_core_web_lg</kbd> (the <kbd>lg</kbd> at the end stands for <em>large</em>). This means that this is the most comprehensive and best performing model that spaCy has released for general-purpose use.</p>
<p class="mce-root">You only need to do this once:</p>
<pre><strong>!python -m spacy download en_core_web_lg</strong></pre>
<p class="mce-root">If you run into any errors when you download this, you can use the smaller model instead.</p>
<p class="mce-root">For Windows Shell, you can use <kbd>python -m spacy download en</kbd> as the administrator. From a Linux Terminal, you can use <kbd>sudo python -m spacy download en</kbd>.</p>
<p>Let's get the imports out of the way:</p>
<pre>import spacy<br/>from spacy import displacy # for visualization<br/>nlp = spacy.load('en_core_web_lg')<br/><span class="n">spacy</span><span class="o">.</span><span class="n">__version__</span></pre>
<p>The version I am using here is <kbd>version 2.0.11</kbd> from conda, but you can use any version above 2.0.x.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing textacy</h1>
                </header>
            
            <article>
                
<p class="mce-root">Textacy is a very underappreciated set of tools that revolves around spaCy. Its tagline tells you exactly what it does: <em>NLP, before and after spaCy</em>. It implements tools that use spaCy under the hood, ranging from data-streaming utilities for production use to higher level text-clustering functions.</p>
<p class="mce-root">You can install textacy via <kbd>pip</kbd> or <kbd>conda</kbd>. On <kbd>conda</kbd>, it's available on the <kbd>conda-forge</kbd> channel instead of the main <kbd>conda</kbd> channel. We've done this by adding a <kbd>-c</kbd> flag and the channel name after that:</p>
<pre><strong># !conda install -c conda-forge textacy </strong><br/><strong># !pip install textacy</strong></pre>
<pre>import textacy</pre>
<p>Now that we have the set up and have installation out of our way, let's get ready to tackle our challenge in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Redacting names with named entity recognition</h1>
                </header>
            
            <article>
                
<p class="mce-root">The challenge for this section is to replace all human names with [REDACTED] in free text.</p>
<p class="mce-root">Let's imagine that you are a new engineer at the European Bank Co. In preparation for the <strong>General Data Processing Regulation</strong> (<strong>GDPR</strong>), the bank is scrubbing off names of their customers from all of their old records and special internal communications like email and memos. They ask you to do this.</p>
<p class="mce-root">The first way you can do this is to look up the names of your customers and match each of them against all of your emails. This can be painfully slow and error-prone. For example, let's say the bank has a customer named John D'Souza <span>–</span> you might simply refer to him as DSouza in an email, so an exact match for D'Souza will never be scrubbed from the system.</p>
<p class="mce-root">Here, we will use an automatic NLP technique to assist us. We will parse all of our emails from spaCy and simply replace everyone's names with the token [REDACTED]. This will be at least 5-10 times faster than matching millions of substrings against millions of substrings.</p>
<p class="mce-root">We will use a small excerpt from the <em>Harry Potter and Chamber of Secrets</em>, talking about flu as an example:</p>
<pre class="mce-root">text = "Madam Pomfrey, the nurse, was kept busy by a sudden spate of colds among the staff and students. Her Pepperup potion worked instantly, though it left the drinker smoking at the ears for several hours afterward. Ginny Weasley, who had been looking pale, was bullied into taking some by Percy."</pre>
<p>Let's parse the text with spaCy. This runs the entire NLP pipeline:</p>
<pre><span class="n">doc</span> <span class="o">=</span> <span class="n">nlp</span><span class="p">(</span><span class="n">text</span><span class="p">)</span></pre>
<p class="mce-root"><kbd>doc</kbd> now contains a parsed version of the text. We can use it to do anything we want! For example, the following command will print out all the named entities that were detected:</p>
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3">
<pre><span class="k">for</span> <span class="n">entity</span> <span class="ow">in</span> <span class="n">doc</span><span class="o">.</span><span class="n">ents</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">"</span><span class="si">{entity.text}</span><span class="s2"> (</span><span class="si">{entity.label_}</span><span class="s2">)"</span><span class="p">)</span></pre></div>
</div>
</div>
<pre>Pomfrey (PERSON)
Pepperup (ORG)
several hours (TIME)
Ginny Weasley (PERSON)
Percy (PERSON)</pre>
<p class="mce-root">The spaCy object <kbd>doc</kbd> has an attribute called <kbd>ents</kbd> which stores all detected entities. To find this, spaCy has done a few things behind the scenes for us, for example:</p>
<ul>
<li class="mce-root"><strong>Sentence segmentation</strong>, to break the long text into smaller sentences</li>
<li class="mce-root"><strong>Tokenization</strong>, to break each sentence into individual words or tokens</li>
<li class="mce-root"><strong>Removed stop words</strong>, to remove words like <em>a, an, the,</em> and <em>of</em></li>
<li class="mce-root"><strong>NER</strong> for statistical techniques in order to find out which <em>entities</em> are there in the text and label them with the entity's type</li>
</ul>
<p>Let's take a quick look at the <kbd>doc</kbd> object, too:</p>
<pre>doc.ents<br/>&gt; (Pomfrey, Pepperup, several hours, Ginny Weasley, Percy)</pre>
<p class="mce-root">The <kbd>doc</kbd> object has a specific object called <kbd>ents</kbd>, which is short for entities. We can use these to look up all of the entities in our text. Additionally, each entity has a label:</p>
<div class="mce-root packt_tip">In spaCy, all information is stored by numeric hashing. Therefore, <kbd>entity.label</kbd> will be a numeric entry like 378, while <kbd>entity.label_</kbd> will be human-readable, for example, <kbd>PERSON</kbd>.</div>
<pre>entity.label, entity.label_<br/>&gt; (378, 'PERSON')<br/><br/></pre>
<p class="mce-root">In spaCy, all human-readable labels can also be explained using the simple <kbd>spacy.explain(label)</kbd> syntax:</p>
<pre>spacy.explain('GPE')<br/>&gt; 'Countries, cities, states'</pre>
<p>Using spaCy's NER, let's write a simple function to replace each PERSON name with [REDACTED]:</p>
<pre><span class="k">def</span> <span class="nf">redact_names</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="n">doc</span> <span class="o">=</span> <span class="n">nlp</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="n">redacted_sentence</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">token</span><span class="o">.</span><span class="n">ent_type_</span> <span class="o">==</span> <span class="s2">"PERSON"</span><span class="p">:</span>
            <span class="n">redacted_sentence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"[REDACTED]"</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">redacted_sentence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
    <span class="k">return</span> <span class="s2">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">redacted_sentence</span><span class="p">)<br/></span></pre>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The function takes in text as a string and parses it in the <kbd>doc</kbd> object using the <kbd>nlp</kbd> object, which we loaded earlier. Then, it traverses each token in the document (remember tokenization?). Each token is added to a list. If the token has the entity type of a person, it is replaced with [REDACTED] instead.</p>
<p>At the end, we reconstruct the original sentence by converting this list back into a string:</p>
</div>
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html packt_tip">
<p>As an exercise, try completing this challenge in-place by editing the original string itself instead of creating a new string.</p>
</div>
</div>
<pre><span class="n">redact_names</span><span class="p">(</span><span class="n">text</span><span class="p">)<br/><br/></span><span class="p">&gt; 'Madam [REDACTED], the nurse, was kept busy by a sudden spate of colds among the staff and students. Her Pepperup potion worked instantly, though it left the drinker smoking at the ears for several hours afterward. [REDACTED][REDACTED], who had been looking pale, was bullied into taking some by [REDACTED]<br/></span></pre>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The preceding output is still a leaky faucet if you are trying to make GDPR-compliant edits. By using two [REDACTED] blocks instead of one, we are disclosing the number of words in a name. This can be seriously harmful if we were to use this in some other context, for example, redacting locations or organization names.</p>
<p>Let's fix this:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3">
<pre><span class="k">def</span> <span class="nf">redact_names</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="n">doc</span> <span class="o">=</span> <span class="n">nlp</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="n">redacted_sentence</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">doc</span><span class="o">.</span><span class="n">ents</span><span class="p">:</span>
        <span class="n">ent</span><span class="o">.</span><span class="n">merge</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">token</span><span class="o">.</span><span class="n">ent_type_</span> <span class="o">==</span> <span class="s2">"PERSON"</span><span class="p">:</span>
            <span class="n">redacted_sentence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"[REDACTED]"</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">redacted_sentence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
    <span class="k">return</span> <span class="s2">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">redacted_sentence</span><span class="p">)</span></pre></div>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We do this by merging entities separately from the pipeline. Notice the two extra lines of code which call <kbd>ent.merge()</kbd> on all entities found. The <kbd>ent.merge()</kbd> function combines all of the tokens in each <em>entity</em> into one single token. This is why it needs to be called on each entity:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3">
<pre><span class="n">redact_names</span><span class="p">(</span><span class="n">text</span><span class="p">)<br/>&gt; </span>'Madam [REDACTED], the nurse, was kept busy by a sudden spate of colds among the staff and students. Her Pepperup potion worked instantly, though it left the drinker smoking at the ears for several hours afterward. [REDACTED], who had been looking pale, was bullied into taking some by [REDACTED].</pre></div>
</div>
</div>
</div>
</div>
<p><span class="p">This output, in practice, can still be incomplete.</span> <span class="p">You might want to remove the gender here, for example, <em>Madam</em>. Since we are already disclosing the designation, which is <em>nurse</em>, giving away the gender makes it easier to infer for people (or even machines) who are reading this document.<br/>
<br/></span></p>
<div class="packt_tip">Exercise: Remove any gender pronouns in reference to names.<br/>
Hint: Look up the co-reference resolution to help you with this.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Entity types</h1>
                </header>
            
            <article>
                
<div class="cell border-box-sizing text_cell rendered">
<p class="prompt input_prompt"><span>spaCy supports the following entity types in the large language model that we loaded in the <kbd>nlp</kbd> object:</span></p>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<table style="border-collapse: collapse;width: 883px;height: 669px" border="1">
<thead>
<tr style="height: 35.7397px">
<th style="width: 185.799px;height: 35.7397px">Type</th>
<th style="width: 689.132px;height: 35.7397px">Description</th>
</tr>
</thead>
<tbody>
<tr style="height: 32px">
<td style="width: 185.799px;height: 32px">PERSON</td>
<td style="width: 689.132px;height: 32px">People, including fictional people</td>
</tr>
<tr style="height: 32px">
<td style="width: 185.799px;height: 32px">NORP</td>
<td style="width: 689.132px;height: 32px">Nationalities or religious or political groups</td>
</tr>
<tr style="height: 32px">
<td style="width: 185.799px;height: 32px">FAC</td>
<td style="width: 689.132px;height: 32px">Buildings, airports, highways, bridges, and so on</td>
</tr>
<tr style="height: 32px">
<td style="width: 185.799px;height: 32px">ORG</td>
<td style="width: 689.132px;height: 32px">Companies, agencies, institutions, and so on</td>
</tr>
<tr style="height: 32px">
<td style="width: 185.799px;height: 32px">GPE</td>
<td style="width: 689.132px;height: 32px">Countries, cities, states</td>
</tr>
<tr style="height: 32px">
<td style="width: 185.799px;height: 32px">LOC</td>
<td style="width: 689.132px;height: 32px">Non-GPE locations, mountain ranges, bodies of water</td>
</tr>
<tr style="height: 32px">
<td style="width: 185.799px;height: 32px">PRODUCT</td>
<td style="width: 689.132px;height: 32px">Objects, vehicles, foods, and so on (not services)</td>
</tr>
<tr style="height: 32px">
<td style="width: 185.799px;height: 32px">EVENT</td>
<td style="width: 689.132px;height: 32px">Named hurricanes, battles, wars, sports events, and so on</td>
</tr>
<tr style="height: 32px">
<td style="width: 185.799px;height: 32px">WORK_OF_ART</td>
<td style="width: 689.132px;height: 32px">Titles of books, songs, and so on</td>
</tr>
<tr style="height: 32px">
<td style="width: 185.799px;height: 32px">LAW</td>
<td style="width: 689.132px;height: 32px">Named documents made into laws</td>
</tr>
<tr style="height: 32px">
<td style="width: 185.799px;height: 32px">LANGUAGE</td>
<td style="width: 689.132px;height: 32px">Any named language</td>
</tr>
<tr style="height: 33px">
<td style="width: 185.799px;height: 33px">DATE</td>
<td style="width: 689.132px;height: 33px">Absolute or relative dates or periods</td>
</tr>
<tr style="height: 33px">
<td style="width: 185.799px;height: 33px">TIME</td>
<td style="width: 689.132px;height: 33px">Times smaller than a day</td>
</tr>
<tr style="height: 33px">
<td style="width: 185.799px;height: 33px">PERCENT</td>
<td style="width: 689.132px;height: 33px">Percentage, including <em>%</em></td>
</tr>
<tr style="height: 33px">
<td style="width: 185.799px;height: 33px">MONEY</td>
<td style="width: 689.132px;height: 33px">Monetary values, including unit</td>
</tr>
<tr style="height: 33px">
<td style="width: 185.799px;height: 33px">QUANTITY</td>
<td style="width: 689.132px;height: 33px">Measurements, such as weight or distance</td>
</tr>
<tr style="height: 33px">
<td style="width: 185.799px;height: 33px">ORDINAL</td>
<td style="width: 689.132px;height: 33px"><em>First</em>, <em>second</em>, and so on</td>
</tr>
<tr style="height: 33px">
<td style="width: 185.799px;height: 33px">CARDINAL</td>
<td style="width: 689.132px;height: 33px">Numerals that do not fall under another type</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt"/>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p> </p>
<p>Let's look at some examples of the preceding entity types in real-world sentences. We will also use <kbd>spacy.explain()</kbd> on all of the entities to build a quick mental model of how these things work.</p>
</div>
</div>
</div>
<p>Given how lazy I am, I will write a function that I can reuse again and again so that I can simply focus on learning and not debugging code for different examples:</p>
<pre><span class="k">def</span> <span class="nf">explain_text_entities</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="n">doc</span> <span class="o">=</span> <span class="n">nlp</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ent</span> <span class="ow">in</span> <span class="n">doc</span><span class="o">.</span><span class="n">ents</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">'</span><span class="si">{ent}</span><span class="s1">, Label: </span><span class="si">{ent.label_}</span><span class="s1">, {spacy.explain(ent.label_)}'</span><span class="p">)</span></pre>
<p class="mce-root"/>
<p>Let's give it a spin with a few simple examples to begin with:</p>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3">
<pre><span class="n">explain_text_entities</span><span class="p">(</span><span class="s1">'Tesla has gained 20% market share in the months since'</span><span class="p">)<br/><br/></span>Tesla, Label: ORG, Companies, agencies, institutions, etc.
20%, Label: PERCENT, Percentage, including "%"
the months, Label: DATE, Absolute or relative dates or periods</pre></div>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<p class="prompt input_prompt">Let's look at a slightly longer sentence and Eastern example:</p>
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3">
<pre><span class="n">explain_text_entities</span><span class="p">(</span><span class="s1">'Taj Mahal built by Mughal Emperor Shah Jahan stands tall on the banks of Yamuna in modern day Agra, India'</span><span class="p">)<br/><br/></span>Taj Mahal, Label: PERSON, People, including fictional
Mughal, Label: NORP, Nationalities or religious or political groups
Shah Jahan, Label: PERSON, People, including fictional
Yamuna, Label: LOC, Non-GPE locations, mountain ranges, bodies of water
Agra, Label: GPE, Countries, cities, states
India, Label: GPE, Countries, cities, states</pre></div>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<p>Interesting <span>–</span> the model got <kbd>Taj Mahal</kbd> wrong. Taj Mahal is obviously a world-famous monument. However, the model has made a believable mistake, because <kbd>Taj Mahal</kbd> was also the stage name of a blues musician.</p>
<p>In most production use cases, we <em>fine-tune</em> the built-in spaCy models for specific languages using our own annotations. This will teach the model that Taj Mahal, for us, is almost always a monument and not a blues musician.</p>
<p class="text_cell_render border-box-sizing rendered_html">Let's see if the model repeats these mistakes in other examples:</p>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3">
<pre><span class="n">explain_text_entities</span><span class="p">(</span><span class="s1">'Ashoka was a great Indian king'</span><span class="p">)<br/></span>Ashoka, Label: PERSON, People, including fictional
Indian, Label: NORP, Nationalities or religious or political groups</pre></div>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<p class="prompt input_prompt">Let's try a different sentence with a different meaning of Ashoka:</p>
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3">
<pre><span class="n">explain_text_entities</span><span class="p">(</span><span class="s1">'The Ashoka University sponsors the Young India Fellowship'</span><span class="p">)<br/></span>Ashoka University, Label: ORG, Companies, agencies, institutions, etc.
the Young India Fellowship, Label: ORG, Companies, agencies, institutions, etc.</pre></div>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Here, spaCy is able to leverage the word <kbd>University</kbd> to infer that Ashoka is a name of an organization and not King Ashoka from Indian history.</p>
<p>It has also figured out that <kbd>Young India Fellowship</kbd> is one logical entity and has not tagged <kbd>India</kbd> as a location.</p>
<p>It helps to see a few examples such as these ones to form a mental model regarding what the limits of what we can and cannot do are.</p>
</div>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Automatic question generation</h1>
                </header>
            
            <article>
                
<p class="mce-root">Can you automatically convert a sentence into a question?</p>
<p class="mce-root">For instance, <em>Martin Luther King Jr. was a civil rights activist and skilled orator.</em> to <em>Who was Martin Luther King Jr.?</em></p>
<p class="mce-root">Notice that when we convert a sentence into a question, the answer might not be in the original sentence anymore. To me, the answer to that question might be something different, and that's fine. We are not aiming for answers here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Part-of-speech tagging</h1>
                </header>
            
            <article>
                
<p class="mce-root">Sometimes, we want to pull out keywords or keyphrases from a larger body of text quickly. This helps us mentally paint a picture of what this text is about. This is particularly helpful in the analysis of texts, like long emails or essays.</p>
<p class="mce-root">As a quick hack, we can pull out all relevant <em>nouns</em>. This is because most keywords are in fact nouns of some form:</p>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3">
<pre><span class="n">example_text</span> <span class="o">=</span> <span class="s1">'Bansoori is an Indian classical instrument. Tom plays Bansoori and Guitar.'</span></pre></div>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3">
<pre><span class="n">doc</span> <span class="o">=</span> <span class="n">nlp</span><span class="p">(</span><span class="n">example_text</span><span class="p">)</span></pre></div>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt"/>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p class="mce-root">We need noun chunks. Noun chunks are noun phrases <span>–</span> not single words, but a short phrase which describes the noun. For example, <em>the blue skies</em> or <em>the world's largest conglomerate</em>.</p>
<p class="mce-root">To get the noun chunks from a document, simply iterate over <kbd>doc.noun_chunks</kbd>:</p>
</div>
</div>
</div>
<div class="input">
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3">
<pre><span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">sentence</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">doc</span><span class="o">.</span><span class="n">sents</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">noun</span> <span class="ow">in</span> <span class="n">sentence</span><span class="o">.</span><span class="n">noun_chunks</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">'sentence{idx+1}'</span><span class="p">,</span> <span class="n">noun</span><span class="p">)<br/></span><br/>sentence1 Bansoori
sentence1 an Indian classical instrument
sentence2 Tom
sentence2 Bansoori
sentence2 Guitar</pre></div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Our example text has two sentences, and we can pull out noun phrase chunks from each sentence. We will pull out noun phrases instead of single words. This means that we are able to pull out <em>an Indian classical instrument</em> as one noun. This is quite useful, and we will see why in a moment.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Next, let's take a quick look at all of the parts-of-speech tags in our example text. We will use verbs and adjectives to write some simple question-generating logic:</p>
</div>
</div>
</div>
<div class="input">
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3">
<pre><span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">pos_</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">tag_</span><span class="p">)<br/><br/></span>Bansoori PROPN NNP
is VERB VBZ
an DET DT
Indian ADJ JJ
classical ADJ JJ
instrument NOUN NN
. PUNCT .
Tom PROPN NNP
plays VERB VBZ
Bansoori PROPN NNP
and CCONJ CC
Guitar PROPN NNP
. PUNCT .</pre></div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Notice that here, <em>instrument</em> is tagged as a NOUN, while <em>Indian</em> and <em>classical</em> are tagged as adjectives. This makes sense. Additionally, <em>Bansoori</em> and <em>Guitar</em> are tagged as PROPN, or proper nouns.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html packt_tip">
<p><strong>Common nouns versus </strong><strong>proper nouns:</strong> Nouns name people, places, and things. Common nouns name general items such as waiter, jeans, and country. Proper nouns name specific things such as Roger, Levi's, and India.</p>
</div>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a ruleset</h1>
                </header>
            
            <article>
                
<p>Quite often when using linguistics, you will be writing custom rules. Here is one data structure suggestion to help you store these rules: a list of dictionaries. Each dictionary in turn can have elements ranging from simple string lists to lists of strings. Avoid nesting a list of dictionaries inside a dictionary:</p>
<pre>ruleset = [<br/>    {<br/>        'id': 1, <br/>        'req_tags': ['NNP', 'VBZ', 'NN'],<br/>    }, <br/>    {<br/>        'id': 2, <br/>        'req_tags': ['NNP', 'VBZ'],<br/>    }<br/>    ]</pre>
<p>Here, I have written two rules. Each rule is simply a collection of part-of-speech tags that has been stored under the <kbd>req_tags</kbd> key. Each rule is comprised of all of the tags that I will look for in a particular sentence.</p>
<p class="mce-root">Depending on <kbd>id</kbd>, I will use a hardcoded question template to generate my questions. In practice, you can and should move the question template to your ruleset.</p>
<p>Next, I need a function to pull out all of the tokens that match a particular tag. We do this by simply iterating over the entire list of and matching each token against the target tag:</p>
<pre>def get_pos_tag(doc, tag):<br/>    return [tok for tok in doc if tok.tag_ == tag]</pre>
<p>On runtime complexity:</p>
<div class="packt_tip">This is slow O(n). As an exercise, can you think of a way to reduce this to O(1)?<br/>
Hint: You can precompute some results and store them, but at the cost of more memory consumption. </div>
<p>Next, I am going to write a function to use the preceding ruleset, and also use a question template.<br/>
<br/>
Here is the broad outline that I will follow for each sentence:</p>
<ul>
<li>For each rule ID, check if all the required tags (<kbd>req_tags</kbd>) meet the conditions</li>
<li>Find the first rule ID that matches</li>
<li>Find the words that match the required part of the speech tags</li>
<li>Fill in the corresponding question template and return the question string</li>
</ul>
<pre>def sent_to_ques(sent:str)-&gt;str:<br/>    """<br/>    Return a question string corresponding to a sentence string using a set of pre-written rules<br/>    """<br/>    doc = nlp(sent)<br/>    pos_tags = [token.tag_ for token in doc]<br/>    for idx, rule in enumerate(ruleset):<br/>        if rule['id'] == 1:<br/>            if all(key in pos_tags for key in rule['req_tags']): <br/>                print(f"Rule id {rule['id']} matched for sentence: {sent}")<br/>                NNP = get_pos_tag(doc, "NNP")<br/>                NNP = str(NNP[0])<br/>                VBZ = get_pos_tag(doc, "VBZ")<br/>                VBZ = str(VBZ[0])<br/>                ques = f'What {VBZ} {NNP}?'<br/>                return(ques)<br/>        if rule['id'] == 2:<br/>            if all(key in pos_tags for key in rule['req_tags']): #'NNP', 'VBZ' in sentence.<br/>                print(f"Rule id {rule['id']} matched for sentence: {sent}")<br/>                NNP = get_pos_tag(doc, "NNP")<br/>                NNP = str(NNP[0])<br/>                VBZ = get_pos_tag(doc, "VBZ")<br/>                VBZ = str(VBZ[0].lemma_)<br/>                ques = f'What does {NNP} {VBZ}?'<br/>                return(ques)</pre>
<p>Within each rule ID match, I do something more: I drop all but the first match for each part-of-speech tag that I receive. For instance, when I query for <kbd>NNP</kbd>, I later pick the first element with <kbd>NNP[0]</kbd>, convert it into a string, and drop all other matches.<br/>
<br/>
While this is a perfectly good approach for simple sentences, this breaks down when you have conditional statements or complex reasoning. Let's run the preceding function for each sentence in the example text and see what questions we get:</p>
<pre><span><span class="cm-keyword">for</span> <span class="cm-variable">sent</span> <span class="cm-keyword">in</span> <span class="cm-variable">doc</span>.<span class="cm-property">sents</span>:<br/></span><span>    <span class="cm-builtin">print</span><span class=" CodeMirror-matchingbracket">(</span><span class="cm-string">f"The generated question is: {sent_to_ques(str(sent))}"</span><span class=" CodeMirror-matchingbracket">)<br/><br/></span></span>Rule id 1 matched for sentence: Bansoori is an Indian classical instrument.
The generated question is: What is Bansoori?
Rule id 2 matched for sentence: Tom plays Bansoori and Guitar.
The generated question is: What does Tom play?</pre>
<div class="cell text_cell rendered selected">
<div class="inner_cell">
<div class="text_cell_render rendered_html">
<p>This is quite good. In practice, you will need a much larger set, maybe 10-15 rulesets and corresponding templates just to have a decent coverage of <em>What?</em> questions.</p>
<p>Another few rulesets might be needed to cover <em>When</em>, <em>Who</em>, and <em>Where</em> type questions. For instance, <em>Who plays Bansoori?</em> is also a valid question from the second sentence that we have in the preceding code.</p>
</div>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Question and answer generation using dependency parsing</h1>
                </header>
            
            <article>
                
<div class="inner_cell">
<div class="text_cell_render rendered_html">
<p>This means PoS tagging and a rule-driven engine can have large coverage and reasonable precision with respect to the questions <span>–</span> but it will still be a little tedious to maintain, debug, and generalize this system.</p>
<p>We need a set of better tools that is less reliant on the <em>state</em> of tokens and more on the relationship between them. This will allow you to change the relationship to form a question instead. This is where dependency parsing comes in.</p>
</div>
</div>
<p>What is a dependency parser?</p>
<div class="packt_quote"><br/>
"A dependency parser analyzes the grammatical structure of a sentence, establishing relationships between "head" words and words which modify those heads."</div>
<div class="packt_quote CDPAlignRight CDPAlign"><span>- from </span><a href="https://nlp.stanford.edu/software/nndep.html">Stanford NNDEP Project</a></div>
<p>A dependency parser helps us understand the various ways in which parts of the sentence interact or depend on each other. For instance, how is a noun modified by adjectives?</p>
<pre>for token in doc:<br/>    print(token, token.dep_)<br/><br/>Bansoori nsubj
is ROOT
an det
Indian amod
classical amod
instrument attr
. punct
Tom nsubj
plays ROOT
Bansoori dobj
and cc
Guitar conj
. punct</pre>
<p>Some of these terms are simple enough to guess, for example, <kbd>ROOT</kbd> is where the dependency tree might begin, <kbd>nsubj</kbd> is the noun or nominal subject, and <kbd>cc</kbd> is a conjunction. However, this is still incomplete. Luckily for us, spaCy includes the nifty <kbd>explain()</kbd> function to help us interpret these:</p>
<div class="input">
<div class="inner_cell">
<div class="input_area">
<div class="CodeMirror cm-s-ipython cm-fat-cursor">
<div class="CodeMirror-scroll">
<div class="CodeMirror-sizer">
<div>
<div class="CodeMirror-lines">
<div>
<div class="CodeMirror-code">
<pre class=" CodeMirror-line"><span><span class="cm-keyword">for</span> <span class="cm-variable">token</span> <span class="cm-keyword">in</span> <span class="cm-variable">doc</span>:<br/></span><span>    <span class="cm-builtin">print</span>(<span class="cm-variable">token</span>, <span class="cm-variable">token</span>.<span class="cm-property">dep_</span>, <span class="cm-variable">spacy</span>.<span class="cm-property">explain</span>(<span class="cm-variable">token</span>.<span class="cm-property">dep_</span>))</span></pre></div>
</div>
</div>
</div>
</div>
<p>This gives us the following explainer text:</p>
</div>
</div>
</div>
</div>
</div>
<div class="output_subarea output_text output_stream output_stdout">
<pre>Bansoori nsubj nominal subject
is ROOT None
an det determiner
Indian amod adjectival modifier
classical amod adjectival modifier
instrument attr attribute
. punct punctuation
Tom nsubj nominal subject
plays ROOT None
Bansoori dobj direct object
and cc coordinating conjunction
Guitar conj conjunct
. punct punctuation</pre></div>
<p>This gives us a good starting point to Google away and pick up some linguistics-specific terms. For example, a <em>conjunct</em> is often used to connect two clauses, while an <em>attribute</em> is simply a way to highlight something which is a property of the nominal subject.</p>
<div class="packt_tip"><br/>
<br/>
Nominal subjects are usually nouns or pronouns, which, in turn, are actors (via verbs) or have properties (via attributes).</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visualizing the relationship</h1>
                </header>
            
            <article>
                
<p>spaCy has a built-in tool called <strong>displacy</strong> for displaying simple, but clean and powerful visualizations. It offers two primary modes: named entity recognition and dependency parsing. Here, we will use the <kbd>dep</kbd>, or dependency mode:</p>
<pre>displacy.render(doc, style='dep', jupyter=True)</pre>
<p>Let's take the first sentence for a quick study: we can see that <strong>instrument</strong> is <strong>amod</strong>, or adjectively modified by <strong>Indian classicial</strong>. We pulled this phrase earlier as a noun chunk:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/550acbbf-98b4-49f1-bce5-933a2c814a19.png"/></div>
<p class="CDPAlignLeft CDPAlign">This means that when we pulled noun phrase chunks out of this sentence, spaCy must have finished dependency parsing already under the hood.</p>
<p class="CDPAlignLeft CDPAlign">Also, notice the direction of arrows while the NOUN (instrument) is being modified by ADJ. It is the <kbd>attr</kbd> of the ROOT VERB (is).</p>
<p>I leave the dependency visualization of the second sentence up to you to complete:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c77e59c7-1051-490d-ac47-b5899ee247c3.png"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This logical tree structure of simple sentences is what we will exploit to simplify our question generation. To do this, we need two important pieces of information</p>
<ul>
<li>The main verb, also known as the ROOT</li>
<li>The subjects on which this ROOT verb is acting</li>
</ul>
<p>Let's write some functions to extract these dependency entities in the spaCy token format, without converting them into strings.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing textacy</h1>
                </header>
            
            <article>
                
<p>Alternatively, we can import them from textacy itself:</p>
<pre>from textacy.spacier import utils as spacy_utils</pre>
<p>Inside a Jupyter Notebook, you can see the docstring AND function implementation by using the <kbd>??</kbd> syntax inside the Jupyter Notebook itself:</p>
<pre>??spacy_utils.get_main_verbs_of_sent<br/><br/># Signature: spacy_utils.get_main_verbs_of_sent(sent)<br/># Source:   <br/># def get_main_verbs_of_sent(sent):<br/>#     """Return the main (non-auxiliary) verbs in a sentence."""<br/>#     return [tok for tok in sent<br/>#             if tok.pos == VERB and tok.dep_ not in constants.AUX_DEPS]<br/># File:      d:\miniconda3\envs\nlp\lib\site-packages\textacy\spacier\utils.py<br/># Type:      function</pre>
<p>Usually, when you ask somebody a question, they are often about a piece of information, for example, <em>What is the capital of India?</em> Sometimes, they are also about a certain action, for example, W<em>hat did you do on Sunday?</em><br/>
<br/>
Answering <em>what</em> means that we need to find out what the verbs are acting on. This means that we need to find the subjects of the verb. Let's take a more concrete but simple example to explore this:</p>
<pre>toy_sentence = 'Shivangi is an engineer'<br/>doc = nlp(toy_sentence)</pre>
<p class="mce-root"/>
<p>What are the entities in this sentence?</p>
<pre>displacy.render(doc, style='ent', jupyter=True)</pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-367 image-border" src="assets/b7a4ae6b-1235-4487-b4ba-57abeacd1086.png" style=""/></div>
<div class="packt_infobox">The preceding example might return ORG for the smaller en model. This is why using <kbd>en_core_web_lg</kbd> is important. It gives much better performance.</div>
<p>Let's try the first few lines of Berlin's Wikipedia entry:</p>
<pre>displacy.render(nlp("Berlin, German pronunciation: [bɛɐ̯ˈliːn]) is the capital and the largest city of Germany, as well as one of its 16 constituent states. With a steadily growing population of approximately 3.7 million, Berlin is the second most populous city proper in the European Union behind London and the seventh most populous urban area in the European Union"), style='ent', jupyter=True)</pre>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-312 image-border" src="assets/2004af84-7959-461e-ac29-4adffdaf01ac.png" style=""/></div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's find out the main verb in this sentence:</p>
</div>
</div>
</div>
<div class="input">
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3">
<pre><span class="n">verbs</span> <span class="o">=</span> <span class="n">spacy_utils</span><span class="o">.</span><span class="n">get_main_verbs_of_sent</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">verbs</span><span class="p">)<br/>&gt;&gt; </span>[is]</pre></div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>And what are the nominal subjects of this verb?</p>
</div>
</div>
</div>
<div class="input">
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3">
<pre><span class="k">for</span> <span class="n">verb</span> <span class="ow">in</span> <span class="n">verbs</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">verb</span><span class="p">,</span> <span class="n">spacy_utils</span><span class="o">.</span><span class="n">get_subjects_of_verb</span><span class="p">(</span><span class="n">verb</span><span class="p">))<br/>&gt;&gt; </span>is [Shivangi]</pre></div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>You will notice that this has a reasonable overlap with the noun phrases that we pulled from our part-of-speech tagging. However, some of them are different, too:</p>
</div>
</div>
</div>
<div class="input">
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3">
<pre><span>print(</span><span class="p">[(</span><span class="n">token</span><span class="p">,</span> <span class="n">token</span><span class="o">.</span><span class="n">tag_</span><span class="p">)</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">])<br/>&gt;&gt;</span>[(Shivangi, 'NNP'), (is, 'VBZ'), (an, 'DT'), (engineer, 'NN')]</pre></div>
</div>
</div>
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html packt_tip">
<p>As an exercise, extend this approach to at least add <em>Who</em>, <em>Where</em>, and <em>When</em> questions as a best practice.</p>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Leveling up – question and answer</h1>
                </header>
            
            <article>
                
<p class="mce-root">So far, we have been trying to generate questions. But if you were trying to make an automated quiz for students, you would also need to mine the right answer.</p>
<p class="mce-root">The answer, in this case, will be simply the objects of a verb. What is an object of a verb?</p>
<div class="mce-root packt_quote">In the sentence, "Give the book to me", "book" is the direct object of the verb "give", and "me" is the indirect object.</div>
<div class="packt_quote CDPAlignRight CDPAlign"><span>– from the Cambridge English Dictionary</span></div>
<p class="mce-root">Loosely, the object is the piece on which our verb acts. This is almost always the answer to our <em>what</em> question. Let's write a question to find the objects of any verb <span>–</span> or, we can pull it from <kbd>textacy.spacier.utils.</kbd>:</p>
<div class="input">
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3">
<pre><span class="n">spacy_utils</span><span class="o">.</span><span class="n">get_objects_of_verb</span><span class="p">(</span><span class="n">verb</span><span class="p">)<br/>&gt;&gt; </span>[engineer]</pre></div>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<p class="input">Let's do this for all of the verbs:</p>
</div>
<div class="input">
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3">
<pre><span class="k">for</span> <span class="n">verb</span> <span class="ow">in</span> <span class="n">verbs</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">verb</span><span class="p">,</span> <span class="n">spacy_utils</span><span class="o">.</span><span class="n">get_objects_of_verb</span><span class="p">(</span><span class="n">verb</span><span class="p">))</span>
&gt;&gt; is [engineer]</pre></div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's look at the output of our functions from the example text. The first is the sentence itself, then the root verb, then the lemma form of that verb, followed by the subjects of the verb, and finally the objects:</p>
</div>
</div>
</div>
<div class="input">
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3">
<pre><span class="n">doc</span> <span class="o">=</span> <span class="n">nlp</span><span class="p">(</span><span class="n">example_text</span><span class="p">)</span>
<span class="k">for</span> <span class="n">sentence</span> <span class="ow">in</span> <span class="n">doc</span><span class="o">.</span><span class="n">sents</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">sentence</span><span class="p">,</span> <span class="n">sentence</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">sentence</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">lemma_</span><span class="p">,</span> <span class="n">spacy_utils</span><span class="o">.</span><span class="n">get_subjects_of_verb</span><span class="p">(</span><span class="n">sentence</span><span class="o">.</span><span class="n">root</span><span class="p">),</span> <span class="n">spacy_utils</span><span class="o">.</span><span class="n">get_objects_of_verb</span><span class="p">(</span><span class="n">sentence</span><span class="o">.</span><span class="n">root</span><span class="p">))</span>
<br/>&gt;&gt; Bansoori is an Indian classical instrument. is be [Bansoori] [instrument]
&gt;&gt; Tom plays Bansoori and Guitar. plays play [Tom] [Bansoori, Guitar]</pre></div>
</div>
</div>
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's arrange the preceding pieces of information into a neat function that we can then reuse:</p>
<pre><span class="n">def para_to_ques(eg_text):<br/>    doc = nlp(eg_text)<br/>    results = []<br/>    for sentence in doc.sents:<br/>        root = sentence.root<br/>        ask_about = spacy_utils.get_subjects_of_verb(root)<br/>        answers = spacy_utils.get_objects_of_verb(root)<br/>        <br/>        if len(ask_about) &gt; 0 and len(answers) &gt; 0:<br/>            if root.lemma_ == "be":<br/>                question = f'What {root} {ask_about[0]}?'<br/>            else:<br/>                question = f'What does {ask_about[0]} {root.lemma_}?'<br/>            results.append({'question':question, 'answers':answers})<br/>    return results</span></pre></div>
</div>
<p>Let's run it on our example text and see where it goes:</p>
<div class="input">
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3">
<pre><span class="n">para_to_ques</span><span class="p">(</span><span class="n">example_text</span><span class="p">)<br/>&gt;&gt; </span>[{'question': 'What is Bansoori?', 'answers': [instrument]},
&gt;&gt; {'question': 'What does Tom play?', 'answers': [Bansoori, Guitar]}]</pre></div>
</div>
</div>
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This seems right to me. Let's run this on a larger sample of sentences. This sample has varying degrees of complexities and sentence structures:</p>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3">
<pre><span class="n">large_example_text</span> <span class="o">=</span> <span class="s2">"""</span>
<span class="s2">Puliyogare is a South Indian dish made of rice and tamarind. </span>
<span class="s2">Priya writes poems. Shivangi bakes cakes. Sachin sings in the orchestra.</span>

<span class="s2">Osmosis is the movement of a solvent across a semipermeable membrane toward a higher concentration of solute. In biological systems, the solvent is typically water, but osmosis can occur in other liquids, supercritical liquids, and even gases.</span>
<span class="s2">When a cell is submerged in water, the water molecules pass through the cell membrane from an area of low solute concentration to high solute concentration. For example, if the cell is submerged in saltwater, water molecules move out of the cell. If a cell is submerged in freshwater, water molecules move into the cell.</span>

<span class="s2">Raja-Yoga is divided into eight steps. The first is Yama. Yama is nonviolence, truthfulness, continence, and non-receiving of any gifts.</span>
<span class="s2">After Yama, Raja-Yoga has Niyama. cleanliness, contentment, austerity, study, and self - surrender to God.</span>
<span class="s2">The steps are Yama and Niyama. </span>
<span class="s2">"""</span></pre></div>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<p class="input">Let's run it on the whole large example text:</p>
</div>
<div class="input">
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3">
<pre><span class="n">para_to_ques</span><span class="p">(</span><span class="n">large_example_text</span><span class="p">)<br/><br/>&gt;&gt; </span>[{'question': 'What is Puliyogare?', 'answers': [dish]},
 {'question': 'What does Priya write?', 'answers': [poems]},
 {'question': 'What does Shivangi bake?', 'answers': [cakes]},
 {'question': 'What is Osmosis?', 'answers': [movement]},
 {'question': 'What is solvent?', 'answers': [water]},
 {'question': 'What is first?', 'answers': [Yama]},
 {'question': 'What is Yama?',
  'answers': [nonviolence, truthfulness, continence, of]},
 {'question': 'What does Yoga have?', 'answers': [Niyama]},
 {'question': 'What are steps?', 'answers': [Yama, Niyama]}]</pre></div>
</div>
</div>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Putting it together and the end</h1>
                </header>
            
            <article>
                
<p>Linguistics is incredibly powerful. I have given you only a taste of its immense utility here. We looked at two motivating use cases and a lot of powerful ideas. For each use case, I have listed the related idea here: </p>
<ol>
<li style="list-style-type: none">
<ul>
<li>Redacting names:
<ul>
<li>Named entity recognition</li>
</ul>
</li>
<li>Question and answer generation:
<ul>
<li>Part-of-speech tagging</li>
<li>Lemmatization</li>
<li>Dependency parsing</li>
</ul>
</li>
</ul>
</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We now have a way to generate questions and answers. What were you going to ask the user? Can you match our answers against the user's answers?</p>
<p>Sure, an exact match is perfect. But we should also be looking for <em>meaning </em>matches, for example, <em>cake</em> with <em>pastry</em>, or <em>honesty</em> with <em>truthfulness</em>.</p>
<p>We could use a synonym dictionary <span>–</span> but how do we extend this into sentences and documents?</p>
<p>In the next chapter, we will answer all of these questions using text representations.</p>


            </article>

            
        </section>
    </body></html>