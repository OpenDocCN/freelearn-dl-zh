<html><head></head><body>
        

                            
                    <h1 class="header-title">Designing Behavior Trees - Part II</h1>
                
            
            
                
<p>This chapter is a continuation of the previous one. In particular, we will build the last missing piece of the puzzle before we build the final Behavior Tree in the next chapter.</p>
<p>In particular, we will be covering the following topics:</p>
<ul>
<li>Creating the <strong><em>Player Character</em></strong>, along with the <strong><em>Chasing Agent</em></strong></li>
<li>Setting up the <strong><em>Navigation System</em></strong> within the Level</li>
<li>Implementing a <strong><em>Custom Service </em></strong>(both in Blueprint and C++) to update the variables that are needed in the Chasing Behavior</li>
</ul>
<p>Once again, we will be implementing everything in both Blueprint and C++ to give you a broader idea of what you can use. Alternatively, if you already know what you want to use, you can just follow one of the two implementations.</p>
<p class="mce-root">Making the Custom Service is the part that will take the most time since we will be going through it step by step.</p>
<p>Let's get to it!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up the environment for testing the Behavior Tree</h1>
                
            
            
                
<p>Before we move on, let's take a break from coding and create the environment that we need to test our Behavior Tree. Preparing a good test environment allows you to easily spot bugs and fix them.</p>
<p>In this section, we are not going to do anything fancy, but we will look at what is required for testing our AI, step by step.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the Player</h1>
                
            
            
                
<p>First of all, we need to have a Player on the level, since our AI agent will chase the Player. Moreover, in the code we are going to write in this chapter, we will need to reference a Player class.</p>
<p>In this case, we already have the ThirdPersonCharacter in our project (if you created the project from the <em>Third Person Template</em>). Right-click on it and select Create Child Blueprint Class, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/07e3114c-dc08-49e3-81d8-a8b48a8d4b02.png" style="width:20.17em;height:37.00em;"/></p>
<p>Then, we can rename it <strong><em>Player</em></strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/cb500982-89dc-4a07-99ac-2242e999976e.png" style="width:38.33em;height:23.33em;"/></p>
<p>Double-click on the Player open it in the <em>Blueprint Editor</em>. In the Details Panel, under the Pawn tab, we need to change the Auto Possess Player to Player 0 and the Auto Possess AI to Disabled, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/8d10c570-7f16-43ea-99e6-423779ec9cfa.png"/></p>
<p>As a result, we will have a class just for the <em>Player Actor</em> (and it is a Blueprint class, which is important). Once that has been placed in the map, it will be possessed by the <em>Player</em> (to be precise, by the <em>Player Controller 0</em>).</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the Chasing Agent</h1>
                
            
            
                
<p>The next step is to set up the Chasing Agent.</p>
<p>We created a controller for this in the previous chapter, both in Blueprint and C++. However, we need to create the actual Pawn that will be possessed. We can achieve this in a very similar manner to how we created the player.</p>
<p>Create another child blueprint of the ThirdPersonCharacter, but this time rename it AI_ChasingAgent:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e42779b8-8779-4d63-a56a-1e182af5b4fd.png" style="width:34.33em;height:21.58em;"/></p>
<p>Double-click on this to open the Blueprint Editor. As we anticipated in the previous chapter, in the <em>Using the AI Controller</em> section, in the Details <em>Panel</em>, under the Pawn tab, we need to set Auto Possess Player to Disabled, Auto Possess AI to Placed in World or Spawned and AI Controller Class to ChasingAIController (or <kbd>BP_ChasingAIController</kbd>, if you prefer the Blueprint version of it), as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/acf395a2-6a9b-40b1-83a2-02bd8b1ff9d1.png" style="width:34.17em;height:15.17em;"/></p>
<p>Since we are going to have many agents trying to chase the Player they would probably get stuck if they were to use the current settings that we have. However, in <a href="c1359fa6-3bdf-4f0d-8a0c-98c35f885167.xhtml">Chapter 7</a>, <em>Crowds</em>, we looked at many techniques that we can use to handle these kinds of situations. In particular, if we have just a few agents, it might be sufficient to activate <strong><em>RVO Avoidance</em></strong>. Hence, select the <strong><em>CharacterMovementComponent</em></strong> from the Components panel:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a40927ca-8c9e-4274-932c-82347c4aeeeb.png" style="width:16.83em;height:16.67em;"/></p>
<p>Then, in the Character Movement: Avoidance tab, we just need to check Use RVOAvoidance. The default settings should be fine, but feel free to adapt them as per your needs (check out <a href="c1359fa6-3bdf-4f0d-8a0c-98c35f885167.xhtml">Chapter 7</a>, <em>Crowds</em>, again if you need more assistance):</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c2888ac2-5685-429d-a1ed-1ed8b6e46062.png" style="width:25.50em;height:8.50em;"/></p>
<p>Save the <kbd>AI_ChasingAgent</kbd>. As a result, our Chasing Agent is ready to be placed in the map, and once we have implemented the Behavior Tree and started it, it will start chasing the Player.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Preparing the Level</h1>
                
            
            
                
<p>We have our <em>Player</em> and the <em>Chasing Agent</em>. However, we need to set up a Level where we can test our Behavior. Therefore, we can duplicate (or directly use it, if you prefer) the <kbd>ThirdPersonExampleMap</kbd> and rename it to something more familiar (for example, <kbd>TestingChasingBehavior</kbd>).</p>
<p>Here, I leave you to your imagination so that you can build a nice test map for our character. Once you are done, come back here and continue reading. For simplicity's sake, I will not modify the map, but just describe the next steps that should be taken.</p>
<p>The first step is to erase all the characters that might be in the map (for example, the <kbd>ThirdPersonCharacter</kbd>) since we will replace them with ours. Then, we will place (by dragging from the <em>Content Browser</em> into the <em>Viewport</em>) one, and only one, Player:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/1e318c72-aa7b-4ab0-a6ca-6050cd59bf29.png"/></p>
<p>Then, we can place a couple of Chasing agents, in the same way as we did for the Player:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3d092580-6a62-42c6-9d0c-0b17c456df35.png"/></p>
<p>We are almost done. The last step is setting up the navigation for the level. In fact, our <strong><em>Find Random Location Task</em></strong> relies on the fact that the Navigation Mesh is set for the level. We went into detail about the Navigation System in Chapter XX, so revise that chapter if you need further assistance on the navigation. This section will just describe how to very quickly set up the navigation for our level.</p>
<p>To build the Navigation System, we just need to select the <em><strong>Nav Mesh Bounds Volume</strong></em> from the Modes panel (by selecting the <em>All Class Tab</em>) and drag it into the map:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f2516446-872b-48b7-8d62-8c1818f035ad.png" style="width:24.83em;height:45.08em;"/></p>
<p>Then, you need to extend it to cover the whole map. If you press the <em>P</em> key, you will be able to preview your <em>NavMesh</em>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/db878f26-db8f-409a-8838-d50e3e38efe1.png"/></p>
<p>Now, we are set to go. Let's continue with the coding part.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Service – Update Chasing Behavior</h1>
                
            
            
                
<p>We didn't describe anything like a service in our <strong><em>Expected Behaviour</em></strong>, and that's fine – it means that we don't need anything like a service for our Behavior, per-se. However, each Behavior Tree has to update the relevant values somehow. One way to do this is by using a service.</p>
<p>The kinds of services that update specific values are often specific (in the implementation) and less likely reusable, but sometimes they are needed to run the Behavior Tree. Moreover, since we already looked at a practical example on how to create a <em>Task</em> and a <em>Decorator</em>, this is the occasion to learn a bit more about <strong><em>Services</em></strong>.</p>
<p>We need to think about the variables contained in the <em>Blackboard</em>, and which one needs to be updated.</p>
<p>The first variable that we need to assign is the <strong>Player</strong>. In fact, we need to have a reference to the Player Pawn so that they can chase when the agent is in sight. However, we don't need to update this value every time the Service is updated, just when the service starts up.</p>
<p>It is worth noting that this service will be placed at the beginning of the tree. Every time the Behavior Tree restarts, the Service is "<em>rebooted</em>" again, updating the Player reference. This is intended because if the Player dies, and another Pawn spawns, this service will update the reference to the new Pawn as well.</p>
<p>Then, we have to update the boolean variable if the <em>Player</em> is currently i<em>n Sight</em> or not. Since this variable will determine which part of the Behavior Tree to execute (decorators will cut the tree if the condition is not met in our case, as we will see later in this chapter), we must update it at every tick of the Service.</p>
<p>The last variable to update is the <strong><em>Destination</em></strong> (in the case, the Player is not in sight). In fact, this variable will contain the <strong><em>Last Known Player</em></strong> <strong><em>Position</em></strong> in the case that the Player has just left the view. Otherwise, the variable will contain the random location we assign in our <em>Task</em>. Therefore, we need to check whether to update this variable or not at every tick of the service (since we want the last seen position of the player to be updated only when the player leaves the field of view of our agent). At the moment, the Player is no longer in sight, and so we update this value once, since the <strong><em>Last Known Player</em></strong> position will not change until the <em>Player</em> is in sight again, and the Behavior Tree will keep it until it isn't required and overrides it with a <em>Random Location</em>. We can achieve this behavior by using a local variable within the service that keeps track of the last value of the boolean variable (if the player is in sight), and if it differs from the current cycle (tick) of the service, then we update the <strong><em>Destination</em></strong> variable with the <strong><em>Last Known Player Position</em></strong>.</p>
<p>Moreover, it is worth noting that we are going to take the values of this variable from the agent controller, making this Service dependent on this specific controller (which is why I stated previously that these kinds of services aren't as reusable).</p>
<p>Now that we have a clear overview of what our service should do, let's jump into how to implement it (both in Blueprint and C++, so that you can choose the method that you prefer).</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Update Chasing Behavior Blueprint implementation</h1>
                
            
            
                
<p>First, we need to create the service and name it <kbd>BTService_UpdateChasingBehavior</kbd>. Then, we need to add some variables. We will call the first <strong><em>CanSeePlayerKey</em></strong>, of type <em>Blackboard Key Selector</em>, which will hold the reference to the boolean variable in the Blackboard that determines if the AI can currently see the player or not. Of course, this variable needs to be public so that it can be set from the Behavior Tree. The second variable, which always of type <em>Blackboard Key Selector</em>, named <strong><em>PlayerKey</em></strong>, is a reference to the Player Pawn in the Blackboard; this has to be public as well. The third is another public <em>Blackboard Key Selector</em> named <strong><em>LastKnownPositionKey</em></strong>, but it will be fed with the <em>Destination</em> vector in the Blackboard, as we discussed in the previous section. The last variable is a local private variable of type boolean named <strong><em>LastCanSeePlayer</em></strong>, which stores the previous state (during the last tick) of the <strong><em>CanSeePlayer</em></strong> boolean. In this way, it is possible to know whether the state has changed and if an update of the Destination is required or not. In the end, this is how our variables should appear in the editor:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/41f1b799-ba75-4df5-b325-8127e5067828.png" style="width:14.50em;height:6.83em;"/></p>
<p>The next step is to <em>override/create</em> the <strong><em>Receive Activation AI</em></strong> event, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/08b20073-5b5f-4027-a2ec-d3d1bc5d5e4d.png" style="width:19.25em;height:19.50em;"/></p>
<p>This event is fired only when the service is activated, which in our case will be every time the Behavior Tree restarts. Here, we need to get the reference to the <em>Player</em>. We can easily achieve this by using a <strong><em>Get All Actor of Class</em></strong> node. We need to provide the class player so that we can just insert the <em>Player</em> class we choose. In this case, we will be using the Player class we created at the beginning of this chapter:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/08870a32-96c4-4b17-b105-62142d024ba4.png" style="width:44.83em;height:14.92em;"/></p>
<p>If you want to make your service a bit more modular, you can pass the Player class as a variable so that you can change it depending on the Behavior Tree. In the C++ implementation, we will do this, mainly because it is easier to reference Blueprint classes as well.</p>
<p>Then, we assume that there is just one Player in the game (otherwise, you should have the logic to find the right Player to chase; maybe the closest one?) and we get it from the array. Finally, we save it in the <strong>Player Key</strong> <em>Object Reference </em>in the Blackboard by using the <strong>Set Blackboard Value as Object</strong> node. This is the final graph of the event:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/687ea3e5-8f05-4b17-a422-7c0d430645b6.png" style="width:47.08em;height:9.67em;"/></p>
<p>Now, we need to <em>override/create</em> the <strong>Receive Tick AI</strong> event, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9aa43632-9faf-4e50-88ca-0ca4fab3071c.png" style="width:24.42em;height:23.08em;"/></p>
<p>The first thing we can do is cast the Owner Controller into the Controller class we created earlier:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c7178712-c0d6-4282-98c4-ab661faaace5.png" style="width:31.83em;height:12.92em;"/></p>
<p>You can use also the <kbd>ChasingAIController</kbd> (the non-blueprint version written in C++). However, if you do, you will not be able to have access to its variables. Even if they are declared public, they are invisible to Blueprint if they don't have the <kbd><strong><em>UPROPERTY()</em></strong></kbd> macro before them. So, if you want to use the C++ version of the controller, be sure to add the <kbd>UPROPERTY()</kbd> macro (with the proper parameters) before each variable to make them visible to the blueprint as well.</p>
<p>Now, if the cast succeeds, we can gather the reference to the <strong>CanSeePlayer</strong> variable from the <kbd>BP_ChasingAIController</kbd>. Then, by using the <strong>CanSeePlayerKey</strong> variable, we can set its value within the Blackboard by using the <strong>Set Blackboard Value as Bool</strong>. This is the graph we have so far:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/83a6c05b-9b5d-4d72-a9ae-c0370ad127f3.png"/></p>
<p>Next, we need to compare this value (the current <strong>CanSeePlayer</strong> boolean) with the one stored in the <strong>LastCanSeePlayer</strong> variable (which stores the value of the last Tick). We can achieve this by using an <strong>Equal</strong> node along with a <strong>Branch</strong>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/db96e8e4-d681-4abe-89be-1fd6653ab4a9.png"/></p>
<p>If these two values are different, then we need to retrieve the <strong>LastKnownPlayerPosition</strong> from <kbd>BP_ChasingAIController</kbd> and set it in the Blackboard through the <strong>LastKnownPlayerPositionKey</strong> variable:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/11bded8e-dbbf-450b-857e-f3bf0ab3bc92.png"/></p>
<p>Finally, regardless of whether we have updated this vector or not (in both the <em>True</em> and <em>False</em> branches), we need to update the <strong>LastCanSeePlayer</strong> variable with the current value. This is the final part of the graph:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/5a4956d1-422a-4e39-bdf9-c7ac70698af1.png"/></p>
<p>Save the <em>Service</em>, and we are finally ready to build our <em>Behavior Tree</em>!</p>
<p>If you drop this service within a <em>Behavior Tree</em>, this is what it will look like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f277db40-ea55-4b50-91db-a9ea3bb90f3a.png" style="width:30.08em;height:28.92em;"/></p>
<p>The <em>Details Panel</em> of the <em>Service</em> (within the Behavior Tree Editor) should look as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d1ddd5eb-1063-42d8-889e-4fb7e3f11636.png"/></p>
<p>In the next section, we are going to implement this <em>Service in C++</em>, and there will be many things to take into consideration. Of course, you are welcome to repeat this process in C++ as well to improve your skills; otherwise, you can skip to the next section, in which we will build our Behavior Tree.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Update Chasing Behavior C++ implementation</h1>
                
            
            
                
<p>In this section, we are going to recreate the <em>Update Chasing Behavior Service in C++</em>.</p>
<p>Let's start by creating a new class that inherits from <strong>BTService</strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d2845e1d-0250-46ee-b012-bd000d9c9165.png" style="width:48.67em;height:31.67em;"/></p>
<p>We will rename our class <kbd>BTService_UpdateChasing</kbd> and place it in the <kbd>AI</kbd> folder, like we did for the other AI classes in the previous chapter:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6dd9512f-2f84-42f2-90b2-d2b0c4a45c83.png" style="width:48.83em;height:21.67em;"/></p>
<p>If, after the creation the code, it doesn't compile, ensure that you followed the previous chapter. In fact, we added both <strong>GameplayTasks</strong> and <strong>AIModule</strong> to the Public Dependencies of our Project. For your convenience, here is what we did in the previous chapter:<br/>
You need to change your <kbd>.cs</kbd> file (in our case, <strong><em>BehaviorTreeDesign.cs</em></strong>) and add <strong>GameplayTasks</strong> and <strong>AIModule</strong> as public dependencies, as shown in the following code:<br/>
<kbd>PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "HeadMountedDisplay", <strong>"GameplayTasks", "AIModule"</strong> });</kbd><br/>
Now, you should be able compile without any problems.</p>
<p class="mce-root"/>
<p>The next step is to add some variables to our Service in the header file. We can call the first <strong>CanSeePlayerKey</strong> of type Blackboard Key Selector, which will hold the reference to the boolean variable in the Blackboard that determines whether the AI can currently see the player or not. Of course, this variable needs to have the <kbd>UPROPERTY()</kbd> set so that it can be set from the Behavior Tree. The second variable, which is always of type Blackboard Key Selector, named <strong>PlayerKey</strong>, is a reference to the Player Pawn in the Blackboard; this needs to have the <kbd>UPROPERTY()</kbd> macro as well. The third is another Blackboard Key Selector named <strong>LastKnownPositionKey</strong>, always with the <kbd>UPROPERTY()</kbd> macro, but it will be fed with the Destination vector in the Blackboard, as we discussed previously. The last variable is a local private variable of type boolean named "<strong><em>Last</em>CanSeePlayer</strong>, which stores the previous state (during the last Tick) of the <strong>CanSeePlayer</strong> boolean. In this way, it is possible to know whether the state has changed and if an update of the Destination is required or not.</p>
<p>The following code needs to be inserted in the header file:</p>
<pre> UPROPERTY(EditAnywhere, Category = Blackboard)<br/>  FBlackboardKeySelector CanSeePlayerKey;<br/><br/>  UPROPERTY(EditAnywhere, Category = Blackboard)<br/>  FBlackboardKeySelector PlayerKey;<br/><br/>  UPROPERTY(EditAnywhere, Category = Blackboard)<br/>  FBlackboardKeySelector LastKnownPositionKey;<br/><br/>private:<br/>  <br/>  bool bLastCanSeePlayer;</pre>
<p>Now, we need another variable – not for the logic of the service, like in the previous cases, but one to select the Player class from the Behavior Tree. We will name the variable <strong>PlayerClass</strong> of type <strong>TSubclassOf&lt;AActor&gt;</strong> so that we can select any class that derives from AActor. Of course, this variable needs to have the <kbd>UPROPERTY()</kbd> macro as well so that it can be sent directly from the Behavior Tree:</p>
<p>We are going to mirror the blueprint version of the service, in which we find all the actors of that class, and assume that there is only one. At the end of this chapter, a different approach is proposed.</p>
<pre>  UPROPERTY(EditAnywhere, Category = PlayerClass)<br/>  TSubclassOf&lt;AActor&gt; PlayerClass;</pre>
<p>The next step is to declare some functions so that we can override/create both the C++ versions of the Blueprint <strong>Receive Activation AI</strong> and <strong>Receive Tick AI</strong> events. These are called <kbd>OnBecomingRelevant()</kbd> and <kbd>TickNode()</kbd>, respectively, and the signature to override them is as follows:</p>
<pre>protected:<br/><br/>  virtual void OnBecomeRelevant(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory) override;<br/><br/>  virtual void TickNode(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory, float DeltaSeconds) override;</pre>
<p>Finally, we need to declare a constructor for our Service. You will understand why shortly:</p>
<pre> UBTService_UpdateChasing(const FObjectInitializer&amp; ObjectInitializer = FObjectInitializer::Get());</pre>
<p>Now, in the <kbd>.cpp</kbd> file, we need to implement these functions.</p>
<p>Let's start with the constructor. In this function, we need to initialize some values for our service; in particular, we want to notify (by setting the respective variable to true) that we want to use the <kbd>OnBecomeRelevant()</kbd> function. Even if this is not necessary, because the variable is set to <em>true</em> by default, it's very good practice to explicitly set the values of these kinds of variables in the constructor. Since we are here, it's worth turning off the call to the <kbd>OnCeaseRelevant()</kbd> function (the inverse of the <kbd>OnBecomeRelevant()</kbd>). The following code shows the constructor with the names of the boolean variables we need to set:</p>
<pre>UBTService_UpdateChasing::UBTService_UpdateChasing(const FObjectInitializer&amp; ObjectInitializer)<br/>  : Super(ObjectInitializer)<br/>{<br/><strong>  bNotifyBecomeRelevant = true;</strong><br/><strong>  bNotifyCeaseRelevant = false;</strong><br/>}</pre>
<p>The next event to implement is <kbd>OnBecomRelevant()</kbd>, and it is only fired when the service becomes relevant (it gets activated), which in our case will be every time the Behavior Tree restarts. Here, we need to get the reference to the Player so that we can store it in Blackboard. First of all, we need to retrieve the Blackboard Component:</p>
<pre>void UBTService_UpdateChasing::OnBecomeRelevant(UBehaviorTreeComponent &amp; OwnerComp, uint8 * NodeMemory)<br/>{<br/><br/><strong>  //Get Blackboard Component</strong><br/><strong>  UBlackboardComponent* BlackboardComp = OwnerComp.GetBlackboardComponent();</strong><br/><strong>  if (BlackboardComp == NULL)</strong><br/><strong>  {</strong><br/><strong>    return;</strong><br/><strong>  }</strong><br/><br/><em>  //[REST OF THE CODE]<br/></em><br/>}</pre>
<p>Then, we need to retrieve the Player by using something very similar to the Blueprint node called <kbd>GetAllActorsOfClass</kbd>. In particular, we will create an empty <kbd>TArray&lt;AActor*&gt;</kbd> and use the <kbd>UGameplayStatics::GetAllActorsOfClass()</kbd> function to bypass the world, the Player class, and the empty array. Now, this function will fill up our array:</p>
<pre>void UBTService_UpdateChasing::OnBecomeRelevant(UBehaviorTreeComponent &amp; OwnerComp, uint8 * NodeMemory)<br/>{<br/>  //Get Blackboard Component<br/>  UBlackboardComponent* BlackboardComp = OwnerComp.GetBlackboardComponent();<br/>  if (BlackboardComp == NULL)<br/>  {<br/>    return;<br/>  }<br/><br/><strong>  //Retrieve Player and Update the Blackboard</strong><br/><strong>  TArray&lt;AActor*&gt; FoundActors;</strong><br/><strong>  UGameplayStatics::GetAllActorsOfClass(GetWorld(), PlayerClass, FoundActors);</strong><br/><br/><em>  //[REST OF THE CODE]<br/></em><br/>}</pre>
<p>Next, we assume that there is just one Player in the game (otherwise, you need to find the right player to chase; maybe the closest one?) and check if the first element of the Array is valid, and if so, we use the <strong>PlayerKey </strong>variable to save it in the Blackboard component.</p>
<p class="mce-root"/>
<p>Here's the code for doing so:</p>
<pre>void UBTService_UpdateChasing::OnBecomeRelevant(UBehaviorTreeComponent &amp; OwnerComp, uint8 * NodeMemory)<br/>{<br/>  //Get Blackboard Component<br/>  UBlackboardComponent* BlackboardComp = OwnerComp.GetBlackboardComponent();<br/>  if (BlackboardComp == NULL)<br/>  {<br/>    return;<br/>  }<br/><br/>  //Retrieve Player and Update the Blackboard<br/>  TArray&lt;AActor*&gt; FoundActors;<br/>  UGameplayStatics::GetAllActorsOfClass(GetWorld(), PlayerClass, FoundActors);<br/><strong>  if (FoundActors[0]) {</strong><br/><strong>    BlackboardComp-&gt;SetValueAsObject(PlayerKey.SelectedKeyName, FoundActors[0]);</strong><br/><strong>  }</strong><br/>}</pre>
<p>Once again, we have mirrored the blueprint service.</p>
<p>Furthermore, in C++ we can do an extra step and avoid to Set the <em>Player</em> again if the <em>Key</em> is already s<em>et</em> (something we couldn't do in Blueprint). So we can add this <em>if-statement</em>:</p>
<pre>void UBTService_UpdateChasing::OnBecomeRelevant(UBehaviorTreeComponent &amp; OwnerComp, uint8 * NodeMemory)<br/>{<br/><br/>  //Get Blackboard Component<br/>  UBlackboardComponent* BlackboardComp = OwnerComp.GetBlackboardComponent();<br/>  if (BlackboardComp == NULL)<br/>  {<br/>    return;<br/>  }<br/><br/><strong>  if (!PlayerKey.IsSet()) {</strong><br/>    //Retrieve Player and Update the Blackboard<br/>    TArray&lt;AActor*&gt; FoundActors;<br/>    UGameplayStatics::GetAllActorsOfClass(GetWorld(), PlayerClass, FoundActors);<br/>    if (FoundActors[0]) {<br/>      UE_LOG(LogTemp, Warning, TEXT("Found Player"));<br/>      BlackboardComp-&gt;SetValueAsObject(PlayerKey.SelectedKeyName, FoundActors[0]);<br/>    }<br/><strong>  }</strong><br/><br/>}</pre>
<p>Now, in regards to the implementation of the <kbd>TickNode()</kbd> function, we first retrieve the <em>Blackboard Component</em>:</p>
<pre>void UBTService_UpdateChasing::TickNode(UBehaviorTreeComponent &amp; OwnerComp, uint8 * NodeMemory, float DeltaSeconds)<br/>{<br/><br/><strong>  //Get Blackboard Component</strong><br/><strong>  UBlackboardComponent* BlackboardComp = OwnerComp.GetBlackboardComponent();</strong><br/><strong>  if (BlackboardComp == NULL)</strong><br/><strong>  {</strong><br/><strong>    return;</strong><br/><strong>  }</strong><br/><br/><em>  //[REST OF THE CODE]</em><br/>  <br/>}</pre>
<p>Then, we need to retrieve the AI Controller from the <kbd>OwnerComp</kbd> and check whether it is valid:</p>
<pre>void UBTService_UpdateChasing::TickNode(UBehaviorTreeComponent &amp; OwnerComp, uint8 * NodeMemory, float DeltaSeconds)<br/>{<br/><br/><em>  //[PREVIOUS CODE]</em><br/><br/><strong>  //Get AI Controller</strong><br/><strong>  AAIController* AIController = OwnerComp.GetAIOwner();</strong><br/><strong>  if (!AIController) {</strong><br/><strong>    return;</strong><br/><strong>  }</strong><br/><br/><em>  //[REST OF THE CODE]</em><br/>  <br/>}</pre>
<p class="mceNonEditable"/>
<p>Once we have the AI Controller, we need to <strong>Cast</strong> it into our <kbd>AChasingAIController</kbd> (the one we created in the previous chapter) and check its validity. As a result, this service will work only if the AI agent is controlled by a <kbd>ChasingAIController</kbd>:</p>
<pre>void UBTService_UpdateChasing::TickNode(UBehaviorTreeComponent &amp; OwnerComp, uint8 * NodeMemory, float DeltaSeconds)<br/>{<br/><br/><em>  //[PREVIOUS CODE]</em><br/><br/><strong>  //Get ChasingAIController (the controller we have created in the previous chapter)</strong><br/><strong>  AChasingAIController* ChasingController = Cast&lt;AChasingAIController&gt;(AIController);</strong><br/><strong>  if (!ChasingController) {</strong><br/><strong>    return;</strong><br/><strong>  }</strong><br/> <br/><em>  //[REST OF THE CODE]</em><br/> <br/>}</pre>
<p>From <kbd>ChasingAIController</kbd>, we can retrieve the (current) <strong>CanSeePlayer</strong> and save it within the Blackboard by using the <kbd>CanSeePlayerKey</kbd> variable:</p>
<pre>void UBTService_UpdateChasing::TickNode(UBehaviorTreeComponent &amp; OwnerComp, uint8 * NodeMemory, float DeltaSeconds)<br/>{<br/><br/><em>  //[PREVIOUS CODE]</em><br/><br/><strong>  //Update the Blackboard with the current value of CanSeePlayer from the Chasing Controller</strong><br/><strong>  BlackboardComp-&gt;SetValueAsBool(CanSeePlayerKey.SelectedKeyName, ChasingController-&gt;bCanSeePlayer);</strong><br/><br/><em>  //[REST OF THE CODE]</em><br/><br/>}</pre>
<p>If the private <kbd>LastCanSeePlayer</kbd> variable (which contains the value of the <kbd>CanSeePlayer</kbd> of the last Tick) is different from the current <kbd>CanSeePlayer</kbd> (which means that the Player is either entered or exited from the Sight of our Agent), then retrieve the <kbd>LastKnownPlayerPosition</kbd> from the <kbd>ChasingAIController</kbd> and save it within the Blackboard by using the <kbd>LastKnonwPositionKey</kbd> variable:</p>
<pre>void UBTService_UpdateChasing::TickNode(UBehaviorTreeComponent &amp; OwnerComp, uint8 * NodeMemory, float DeltaSeconds)<br/>{<br/><br/><em>  //[PREVIOUS CODE]</em><br/><br/><strong>  //If the LastCanSeePlayer is different from the current one, then update the LastKnownPlayerPosition</strong><br/><strong>  if (ChasingController-&gt;bCanSeePlayer != bLastCanSeePlayer) {</strong><br/><strong>    BlackboardComp-&gt;SetValueAsVector(LastKnownPositionKey.SelectedKeyName, ChasingController-&gt;LastKnownPlayerPosition);</strong><br/><strong>  }</strong><br/>  <br/><em>  //[REST OF THE CODE]</em><br/><br/>}</pre>
<p>After the previous check, we need to update the <kbd>LastCanSeePlayer</kbd> with the current value of it so that in the next Tick we will have the right value:</p>
<pre>void UBTService_UpdateChasing::TickNode(UBehaviorTreeComponent &amp; OwnerComp, uint8 * NodeMemory, float DeltaSeconds)<br/>{<br/><br/><em>  //[PREVIOUS CODE]</em><br/><br/><strong>  //Update the LastCanSeePlayer with the current CanSeePlayer</strong><br/><strong>  bLastCanSeePlayer = ChasingController-&gt;bCanSeePlayer;</strong><br/><br/><em>  //[REST OF THE CODE]</em><br/>  <br/>}</pre>
<p>Finally, we can make a call to the parent <kbd>TickNode()</kbd> (as per good practice):</p>
<pre>void UBTService_UpdateChasing::TickNode(UBehaviorTreeComponent &amp; OwnerComp, uint8 * NodeMemory, float DeltaSeconds)<br/>{<br/><br/><em>  //[PREVIOUS CODE]</em><br/><br/><strong>  //Call to the parent TickNode</strong><br/><strong>  Super::TickNode(OwnerComp, NodeMemory, DeltaSeconds);</strong><br/>  <br/>}</pre>
<p>The code for our service is now complete. For your convenience, here is the code of the <kbd>TickNode()</kbd> function:</p>
<pre>void UBTService_UpdateChasing::TickNode(UBehaviorTreeComponent &amp; OwnerComp, uint8 * NodeMemory, float DeltaSeconds)<br/>{<br/><br/>  //Get Blackboard Component<br/>  UBlackboardComponent* BlackboardComp = OwnerComp.GetBlackboardComponent();<br/>  if (BlackboardComp == NULL)<br/>  {<br/>    return;<br/>  }<br/><br/>  //Get AI Controller<br/>  AAIController* AIController = OwnerComp.GetAIOwner();<br/>  if (!AIController) {<br/>    return;<br/>  }<br/><br/>  //Get ChasingAIController (the controller we have created in the previous chapter)<br/>  AChasingAIController* ChasingController = Cast&lt;AChasingAIController&gt;(AIController);<br/>  if (!ChasingController) {<br/>    return;<br/>  }<br/><br/>  //Update the Blackboard with the current value of CanSeePlayer from the Chasing Controller<br/>  BlackboardComp-&gt;SetValueAsBool(CanSeePlayerKey.SelectedKeyName, ChasingController-&gt;bCanSeePlayer);<br/><br/>  //If the LastCanSeePlayer is different from the current one, then update the LastKnownPlayerPosition<br/>  if (ChasingController-&gt;bCanSeePlayer != bLastCanSeePlayer) {<br/>    BlackboardComp-&gt;SetValueAsVector(LastKnownPositionKey.SelectedKeyName, ChasingController-&gt;LastKnownPlayerPosition);<br/>  }<br/><br/>  //Update the LastCanSeePlayer with the current CanSeePlayer<br/>  bLastCanSeePlayer = ChasingController-&gt;bCanSeePlayer;<br/><br/>  //Call to the parent TickNode<br/>  Super::TickNode(OwnerComp, NodeMemory, DeltaSeconds);<br/>  <br/>}</pre>
<p>Save and compile the Service. Now, you will be able to use it in the Behavior Tree.</p>
<p>This is what the Service looks like once placed in the Behavior Tree:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/1befbcf5-8fea-4bec-b6b0-02a5a1b81ee3.png"/></p>
<p>The <em>Details Panel</em> of the Service (within the <em>Behavior Tree Editor</em>) should look as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/159b74a9-d476-4327-902f-df1e0a2be114.png" style="width:31.17em;height:27.67em;"/></p>
<p>Before we move on, as we did for the <em>Decorator</em> and the <em>Task</em>, it is good practice to add a static description to the <em>Service</em> so that we can visualize which Keys (<em>Blackboard Key Selector</em> variables) we assigned, along with the <em>Player</em> class. Here, we need to add the signature of the function in the header file, as shown in the following:</p>
<pre>protected:<br/><br/><strong>  virtual FString GetStaticDescription() const override;</strong></pre>
<p>As for the implementation (in the <kbd>.cpp</kbd> file), we can just return a formatted <em>FString</em> with all the information we need to show. We can easily format the string with the <kbd>Printf()</kbd> function. I'm using the <kbd>Append()</kbd> function here to increase the clarity of each line. In particular, we need to show which line is for the <kbd>PlayerClass</kbd>, and which values we have assigned to each <em>Blackboard Key Selector</em> variable:</p>
<pre>FString UBTService_UpdateChasing::GetStaticDescription() const<br/>{<br/>  return FString::Printf(TEXT("%s: '%s'"), TEXT("Player Class"), PlayerClass ? *PlayerClass-&gt;GetName() : TEXT(""))<br/>    .Append(FString::Printf(TEXT("\n%s: '%s'"), TEXT("PlayerKey"), PlayerKey.IsSet() ? *PlayerKey.SelectedKeyName.ToString() : TEXT("")))<br/>    .Append(FString::Printf(TEXT("\n%s: '%s'"), TEXT("LastKnownPositionKey"), LastKnownPositionKey.IsSet() ? *LastKnownPositionKey.SelectedKeyName.ToString() : TEXT("")))<br/>    .Append(FString::Printf(TEXT("\n%s: '%s'"), TEXT("CanSeePlayerKey"), CanSeePlayerKey.IsSet() ? *CanSeePlayerKey.SelectedKeyName.ToString() : TEXT("")));<br/>}</pre>
<p>Now, the Service will look as follows in the Behavior Tree:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/53cb0759-0498-497e-9f86-f9c6f81ecb63.png" style="width:18.50em;height:27.33em;"/></p>
<p>Now that our <em>Service</em> has been implemented, we are ready to build our <em>Behavior Tree</em> in the next chapter!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we continued our in-depth example of how to create a <strong><em>Behavior Tree</em></strong> and used all of the systems we have encountered so far.</p>
<p>In particular, we have seen how we can set up the <strong><em>Testing Environment</em></strong> and create both the <strong><em>Player Character</em></strong> and the Chasing Agent. This latter needed to have the right controller, and also needed to have <em>RVO Avoidance</em> activated.</p>
<p>Then, we implemented our <strong><em>Update Chasing Behavior Service</em></strong>, and looked at how to do so in both C++ and Blueprint. </p>
<p>In the next chapter, we will continue with this example and build the final Behavior Tree. By the end of this next chapter, we will have completed this project and we will have our <strong><em>Chasing Behavior</em></strong>. So, let's keep going!</p>


            

            
        
    </body></html>