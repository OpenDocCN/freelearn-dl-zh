- en: Environment Querying System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*A good leader knows which place is good, and EQS knows better!*'
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to [Chapter 4](1773b819-a79b-4339-ab07-6833fd9bc3a0.xhtml),* Environment
    Querying System*. In this chapter, we are going to use a specific, yet very powerful,
    system within the Unreal AI Framework. I'm talking about the **Environment Querying
    System** (**EQS)**. We will explore the system and will understand not only how
    it works, but how to use it effectively in our games.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, **EQS** falls into the realm of *Decision-Making*, and, in particular,
    evaluating which is the best place (or actor, in the context of Unreal) to satisfy
    certain conditions. We will see how it works in detail through this chapter, but
    as an anticipation of what we will cover, know that the system filters offer different
    possibilities, and the remaining ones assign a score. The choice that has the
    highest score is selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to enable the ***Environment Querying System (EQS)***
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding ***how EQS works***
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about ***Generators***, ***Tests***, and ***Contexts***
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the ***built-in*** ***Generators***, ***Tests***, and ***Contexts*** of
    *EQS*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Extending EQS*** with custom ***Generators***, ***Tests***, and ***Contexts***'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's dive in!
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the Environment Querying System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EQS is a feature that was introduced way back to Unreal 4.7, and improved a
    lot in 4.9\. However, in version 4.22, EQS is listed as an experimental feature,
    despite it being successfully used in many games, thus revealing that EQS is robust.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, we need to enable it from the ***Experimental*** features settings.
    From the top menu, go to **Edit | Editor Preferences…**, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d334f93a-4611-4928-a184-4d699ff1980e.png)'
  prefs: []
  type: TYPE_IMG
- en: Be careful that you don't get confused with the ***Project Settings***. From
    the top menu, above the *Viewport*, you only have access to the ***Project Settings***.
    However, from the top menu of the whole editor, you will be able to find ***Editor
    Preferences***. The preceding screenshot should help you locate the right menu
    (that is, the ***Edit*** drop-down menu).
  prefs: []
  type: TYPE_NORMAL
- en: 'From the lateral menu, you will be able to see a section named **Experimental**
    (under the **General** category), as highlighted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b61d381-c4a3-4774-8cee-36df15cc7742.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you scroll down through the settings, you will find the AI category, in
    which you are able to enable the **Environment Querying System**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9fb7d9b6-2cbe-4fed-936b-16a679f72e08.png)'
  prefs: []
  type: TYPE_IMG
- en: Check the box next to this option and, as a result, the ***Environment Querying System***
    will be activated in the whole project. Now, you will be able to create assets
    for it (as well as extend it) and call it from a *Behavior Tree*.
  prefs: []
  type: TYPE_NORMAL
- en: In case you are unable to see the ***Environment Querying System*** checkbox
    within the ***AI category***, it's likely you are using a recent version of the
    engine in which (finally) ***EQS*** is not experimental anymore, and so it is
    always enabled within your project. If this is your situation, then skip this
    section and move on to the next one.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Environment Querying System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When people face EQS for the first time, it might seem overwhelming, especially
    because it is unclear how the different parts of the system work and why. The
    aim of this section is to improve your understanding of the system by getting
    you familiar with the underlying workflow of EQS, which will help you with the
    actual workflow when you create a query.
  prefs: []
  type: TYPE_NORMAL
- en: The general mechanism of EQS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that, at a certain point, our AI agent is under fire, and it needs to
    evaluate different places for cover. One place might be far but well protected,
    whereas another one might be very close but not well protected. What should we
    do?
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to solve this problem is by using ***Utility Functions*** and solving
    equations in time (we will discuss them in more detail in [Chapter 14](d9a581ce-adca-46fe-8f95-a78b762ebc46.xhtml), *Going
    Beyond*). Actually, this produces very good results, and it is successfully implemented
    in many games. However, Unreal offers another possibility: EQS. This being said,
    it''s not mandatory to use EQS instead of utility functions, but EQS as part of
    the AI framework makes it easy to evaluate such decisions since it is a built-in
    system.'
  prefs: []
  type: TYPE_NORMAL
- en: So, coming back to our agent in need of a cover, a *Behavior Tree* will run
    an EQS query, which will give the final result of the place where the agent should
    get cover. Now, how does an Environment Query work?
  prefs: []
  type: TYPE_NORMAL
- en: First of all, a component (called a Generator, which we will look at in a moment) will
    generate a series of locations (or agents, which we will look at later in this
    chapter) according to some criteria specified in the Tests (we will get to them
    in a moment). For instance, we can take different positions on a uniform grid,
    which is very handy when we don't know which kind of locations we are searching
    for in advance (before evaluation).
  prefs: []
  type: TYPE_NORMAL
- en: Then, there is a filtering process for possible locations (or actors), in which
    it eliminates all that do not satisfy a certain criteria. In our cover example,
    any place that is still exposed to direct fire should be discarded.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining places are evaluated (the system assigns them a score), based
    on other criteria. Again, in our cover example, this might be the distance from
    the agent, how much cover they offer, or how close to the enemy the place is.
    The system assigns a score by taking into consideration all of these factors (and,
    of course, some will be weighted more than others; e.g. protection from fire might
    be more important than the distance from the enemy's location).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the location (or actor) with the highest score is given from the query
    to the *Behavior Tree*, which will decide what to do with it (e.g. flee quickly
    to that place to take cover).
  prefs: []
  type: TYPE_NORMAL
- en: The components of an Environment Query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Based on the mechanism we described in the previous section, let's dig deeper
    into how the actual implementation of the EQS in Unreal works.
  prefs: []
  type: TYPE_NORMAL
- en: At a high level, we have *Environment Queries*, *Contexts*, *Generators*, and
    *Tests*.
  prefs: []
  type: TYPE_NORMAL
- en: Environment Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, an ***Environment Query*** is a data structure (similar
    to a *Behavior Tree*) that holds information regarding how the query should be
    performed. In fact, it is an asset that you can create and find within your *Content
    Browser*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a new **Environment Query** by right-clicking on your *Content
    Browser* and then **Artificial Intelligence** | **Environment Queries**, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7e443b8-9e49-4002-8511-5102cdc30e9f.png)'
  prefs: []
  type: TYPE_IMG
- en: Keep in mind that this option will not appear if EQS is not enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what it looks like in the *Content Browser*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6a37b70-daed-4aab-9fe2-3267aad501f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we double-click on it to open it, Unreal opens a specific and **dedicated
    editor** for ***Environmental Queries***. This is what the Editor looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cbf0931-5fd1-43c4-bc34-f1dc9329ae7a.png)'
  prefs: []
  type: TYPE_IMG
- en: Editor view
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, it is very similar to a *Behavior Tree*, but you can only attach
    a Generator node to the ***Root*** node (only one), which results to be a leaf
    as well. Therefore, the whole "*tree*" will be just the ***Root*** node with a
    ***Generator***. In fact, by using a *Behavior Tree*-like editor, you can easily
    set up an ***Environmental Query***. On the (unique) *Generator* node, you can
    attach one or more ***Tests****—*either the Generator itself, or Contexts. Here
    is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d258634-8313-4eec-862d-2092550e4dfb.png)'
  prefs: []
  type: TYPE_IMG
- en: Editor view
  prefs: []
  type: TYPE_NORMAL
- en: We will understand what this means in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Contexts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Contexts are children of a particular and handy class that retrieves information.
    You can create/extend a ***Context*** either through Blueprint or by using C++.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why they are called contexts is because they provide a context to
    either a Generator or to a Test. By having a context, the Generator (or the Test)
    is able to perform all the calculations, starting from that point. If you prefer,
    a context can be thought of as a special (and very articulated) variable that
    is able to procedurally pass a set of interesting Actors and/or locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example so that we''re clear about what ***Contexts*** are.
    While performing a *Test*, you usually know where the ***Querier*** (e.g. the
    agent who needs the cover) is located (under the hood, even if the *Querier* is
    a default context). However, our test might need the location of our enemies (e.g.
    to check whether a cover spot is under fire or not, since it depends on the position
    of the enemies of our agent). ***Contexts*** can provide all of this information,
    and can do so in a procedural way: for instance, the agent might not be aware
    of every enemy of the map, so the ***Context*** might return only the enemies
    that the agent is currently aware of, so it only finds cover from those. Therefore,
    if there is a hidden enemy where it''s chose to take cover, then it''s tough luck
    for our agent!'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ***Contexts*** is not easy, so stick through this chapter, and
    maybe re-read the previous paragraph at the end, when you have a better idea of
    what Generators and Tests are, as well as how to build an ***EQS*** in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '***Generators***, as the name suggests, generate an initial set (or array)
    of locations (or actors). This set will be filtered and evaluated by Tests.'
  prefs: []
  type: TYPE_NORMAL
- en: The way to generate the initial set is completely free. If you have some important
    information regarding the place you are looking for before the evaluation stage,
    then you can create a custom ***Generator*** (for example, don't check places
    with water if the agent is unable to swim, or don't consider flying enemies if
    the only available attack is melee).
  prefs: []
  type: TYPE_NORMAL
- en: Like *Contexts*, ***Generators*** are children of a specific class. You can
    create Generators in Blueprint as well as in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the most used generator is the grid one, which will generate a uniform
    grid around a context (e.g. around the agent). By doing this, the agent will check
    more or less all of its surroundings.
  prefs: []
  type: TYPE_NORMAL
- en: Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '***Tests*** are responsible to both ***Filtering*** and ***Assigning a Score**
    (Evaluating)* to the different locations (or actors) that are generated by the
    *Generator*. A single ***Test*** can filter and score on the same criteria, as
    well as just one of the two.'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of *Tests* that use ***Filtering***, they try to identify which
    locations (or Actors) are not suitable for our criteria. EQS is optimized, so
    it performs the *Tests* in a specific order to try and detect unsuitable places
    early on. It does this so that it doesn't assign a score that won't be used.
  prefs: []
  type: TYPE_NORMAL
- en: Once all of the locations (or Actors) have been filtered out, the remaining
    ones are evaluated. Thus, ***each Test*** that ***is able to assign a score***
    is called (*executed*) on the location (or Actor) to report the evaluation in
    the form of a score (which can be positive or negative).
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, *Tests* need (at least) a *Context* to properly *filter* and
    *evaluate*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an easy example of a Test to understand how they work. One of
    the most common Tests is ***Distance***, that is, how far is this place (the generated
    we are evaluating) from a ***Context***? The *Context* can be the *Querier*, or
    the enemy that it is attacking, or anything else. Thus, we can (for instance)
    filter places above or below a certain distance threshold (e.g. we might not want
    perfect cover places if they are too far from the Player). The **same** ***Distance Test***
    can assign a score, depending on the distance, which can be positive (or negative)
    if the context is far (or close).
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, a **Test** has a **Scoring Factor** that represents **the weight**
    of the ***Test***: how important the Test is, and much influence this ***Test***
    needs to have when calculating the final score of the currently evaluated location
    (or actor). In fact, you will run many different ***Tests*** on the locations
    that are generated by the *Generator*. The ***Scoring Factor*** allows you to
    easily weigh them to determine which Test has a higher impact on the final score
    of the location (or actor).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each *Test* has the following structure for its options in the *Details* panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e599ab6f-505a-4846-9744-bf41714e4613.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Test***: Here, you can select whether the ***Test Purpose*** is to ***Filter
    and Score***, or just one of the two, and add a description (has no impact on
    the Test, but you can see it as a comment to recall what this test was about).
    Additionally, there might be other options, such as *Projection Data* that you
    can use with the *Navigation System* (for those tests that rely on the *Navigation
    System*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Specific Test***: This is the place where the specific options for the Test
    are held. This varies from test to test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Filter***: Here, you can select how the *Filter* behaves. This varies from
    test to test, but usually you are able to select a ***Filter Type***, which can
    be a *range* (or *minimum* or *maximum*) in case the tests valuate a float as
    a return value; otherwise, it can be a *boolean* in the case of conditional *Tests*.
    This tab doesn''t appear if the ***Test Purpose*** is set to ***Score Only***.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Score***: Here, you can select how the *Scoring* behaves. This varies from
    test to test. For float return types from tests, you can select an equation for
    scoring, along with a normalization. Moreover, there is ***Scoring Factor***,
    which is the weight of this test compared to the others. For boolean return values,
    there is just the Scoring Factor. This tab doesn''t appear if the ***Test Purpose*** is
    set to ***Filter Only***.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Preview***: This gives you a preview of what the filter and scoring function
    look like.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, these options are very easy to grasp, and you will understand
    them even better if you practice with EQS.
  prefs: []
  type: TYPE_NORMAL
- en: Visual representation of the components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These components might not be super intuitive at the beginning, but once you
    get used to EQS, you will realize how they make sense, and why the system has
    been designed in this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize the components and their importance, as well as to give you a
    visual representation, here is a diagram that you can reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc428801-f5bd-46f6-9137-56b3409f4f24.png)'
  prefs: []
  type: TYPE_IMG
- en: Running an Environmental Query within a Behavior Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, the last step to fully understanding how an ***Environmental Query***
    works is to see how it can be run within a *Behavior Tree*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, we have a node named run EQS, which is a built-in Behavior Tree
    Task. In looks as follows in a hypothetical *Behavior Tree Editor*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce511ffd-e992-4020-b55c-c093cd4f23d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The possible settings, which can be found in the Details panel, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d46b7e4-59f3-44cb-9ffa-a194307f9806.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, many are deprecated (so just ignore them), but I have highlighted
    the ones that are the most important. Here''s an explanation of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '***Blackboard Key***: This is the Blackboard Key Selector that references a
    *Blackboard Variable*, in which the result of the EQS will be stored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Query Template***: A specific reference to the EQS we want to run. Otherwise,
    we can deactivate this option to activate an *EQSQuery Blackboard Key*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Query Config***: These are optional parameters for the query (unfortunately,
    we won''t be looking at them in detail in this book).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***EQSQuery Blackboard Key***: A *Blackboard Key Selector* that references
    a *Blackboard Variable* containing an *EQS*. If activated, the *EQSQuery* contained
    in the *Blackboard Variable* will be executed, and not the *Query Template* one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Run Mode***: This shows results of the query we are going to retrieve. The
    possible options are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Single Best Item***: This retrieves the point (or actor) that scored the
    best'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Single Random Item from Best 5%***: This retrieves a random point among
    the best 5% scoring locations (or actors)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Single Random Item from Best 25%***: This retrieves a random point among
    the best 25% scoring locations (or actors)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***All Matching***: This retrieves all the locations (or actors) that match
    the query (they haven''t been filtered out)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This concludes how we can run an EQS and retrieve its result so that it can
    be used within a *Behavior Tree*.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there are other ways to trigger an EQSQuery, which are not necessarily
    done within a *Behavior Tree*, even though this is the most common use of the
    EQS. Unfortunately, we will not cover other methods to run an EQSQuery in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Not only Locations, but also Actors!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I emphasised a lot when I said "…evaluating a location **(or Actor)…** ".
  prefs: []
  type: TYPE_NORMAL
- en: In fact, one of the coolest features of EQS is the possibility to evaluate not
    only locations, but actors as well!
  prefs: []
  type: TYPE_NORMAL
- en: Once again, you can use EQS as a decision-making process. Imagine that you need
    to choose an enemy to attack first. You might want to take into consideration
    various parameters, such as the remaining life of that enemy, how strong it is,
    and how much it is considered a threat in the immediate future.
  prefs: []
  type: TYPE_NORMAL
- en: By carefully setting an EQS, you are able to assign a score to each of the enemies,
    depending on which one is the most convenient to attack. Of course, in this situation,
    you might need to put in a little bit of work to create the proper Generator,
    along with Contexts and the proper Tests, but in the long run, it makes EQS a
    very good choice when the agent needs to make these kinds of decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the built-in nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we create our own Generators, Contexts, and Tests, let's talk about built-in
    nodes. Unreal comes with a handful of useful built-in, general-purpose nodes.
    We are going to explore them in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that this section is going to analytically explain how each of
    the built-in nodes of EQS works, like documentation would. So, please use this
    section as a reference manual if you wish, and skip sections if you are not interested
    in them.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in Contexts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we started explaining EQS by looking at ***Contexts***, let's start from
    ***built-in Contexts***. Of course, making general-purpose ***Contexts*** is almost
    a paradox, since a Context is very specific to the "*context*" (situation).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, Unreal comes with two built-in Contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '***EnvQueryContext_Querier***: This represents the Pawn that is asking the
    query (to be precise, it isn''t the Pawn asking the Query, but the Controller
    that is running the *Behavior Tree* that is asking the query, and this context
    returns the controlled Pawn). Therefore, by using this *Context*, everything will
    be relative to the ***Querier***.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As I mentioned previously, under the hood, the *Querier* is indeed a *Context*.
  prefs: []
  type: TYPE_NORMAL
- en: '***EnvQueryContext_Item***: This returns all the locations that are generated
    by the *Generator*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many built-in ***Generators***, and most of the time, these will be
    more than enough so that you can do most of the EQS you want. You would use *custom
    Generators* only when you have a specific need, or when you want to optimize the
    EQS.
  prefs: []
  type: TYPE_NORMAL
- en: Most of these Generators are intuitive, so I'm going to explain them in brief,
    and provide (when necessary) a screenshot showing the kinds of points they are
    generating.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshots use a special Pawn that is able to visualize an Environment
    Query. We will learn how to use it later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This is the list of available built-in *Generators*, as you find them in the
    *Environmental Query Editor:*
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/edb9da7a-0421-4960-8348-5aa622a5ad9a.png)'
  prefs: []
  type: TYPE_IMG
- en: To organize this information, I'm going to split each Generator into a subsection,
    and I'm going to order them as they are listed in the preceding screenshot (alphabetically).
  prefs: []
  type: TYPE_NORMAL
- en: When I refer to the Settings of a Generator, I mean, once a specific Generator
    has been selected, the available options for it in the *Details Panel*.
  prefs: []
  type: TYPE_NORMAL
- en: Actors Of Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This Generator takes all of the actors of a specific class and returns all their
    locations as generated points (if these actors are within a certain radius from
    the Context).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what it looks like in the *Environmental Query Editor*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5f859a7-56cb-4651-96ff-1a040c6f90c9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The possible options are the ***Searched Actor Class*** (obviously) and the
    ***Search Radius*** from the ***Search Center*** (which is expressed as a *Context*).
    Optionally, we can retrieve all the actors of a certain class and ignore whether
    they are within the *Searched Radius*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/faecc901-8ef1-44bb-91c9-5692d6029691.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, I used the ***Querier*** as the ***Search Center***,
    a ***Search Radius*** of ***50000***, and the ***ThirdPersonCharacter*** as the ***Searched
    Actor Class***, since it is already available in the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using these settings (and placing a couple of ***ThirdPersonCharacter***
    actors), we have the following situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/155643e4-46c9-446e-b401-da15ae3a69b0.png)'
  prefs: []
  type: TYPE_IMG
- en: Note the (blue) sphere around the three ***ThirdPersonCharacter*** actors.
  prefs: []
  type: TYPE_NORMAL
- en: Current Location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ***Current Location Generator*** simply retrieve the location(s) from the
    *Context* and uses it (or them) to generate the points.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what it looks like in the *Environmental Query Editor*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9cdc1ae-401f-4d74-8e9e-e90d526f9702.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The only setting that''s available for this *Generator* is ***Query Context***:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4794baa-73a6-4354-96b1-b98a86200d66.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Thus, if we use the ***Querier*** as the ***Query Context***, then we just
    have the location of the ***Querier*** itself, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4c4a73f-e0e4-43fa-abf4-d89b7c99e9cd.png)'
  prefs: []
  type: TYPE_IMG
- en: Composite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ***Composite Generator*** allows you to mix multiple Generators so that
    you have a vaster selection of points.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what it looks like in the *Environmental Query Editor*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73623a4d-508f-463a-929a-732047b0bd0a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the *Settings*, you can set an array of ***Generators***:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8bf8b82-c8d0-41b7-b04a-2400395aa65f.png)'
  prefs: []
  type: TYPE_IMG
- en: Since we don't have the time to go through everything in detail, I won't cover
    this Generator further.
  prefs: []
  type: TYPE_NORMAL
- en: 'Points: Circle'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, the ***Circle Generator*** generates the points around
    a circle of a specified radius. Moreover, options for interacting with the *Navmesh*
    are available (so that you don't generate points outside the *Navmesh*).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what it looks like in the *Environmental Query Editor*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/084d82ed-9cae-4b91-9422-395d41ed1065.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is a very complex generator, and so there are various settings for this
    generator. Let''s check them out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c4924b3-3dbc-4821-84c4-b3dccc5964bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Ideally, it would be great to have a screenshot for each setting so that we
    can get a better feeling of how each setting affects the generation of the points.
    Unfortunately, this book already has many screenshots, and dedicating a chapter
    just to the different settings of these complex generators would take a lot of
    time and a lot of "*book space*". However, there is a better way for you to get
    the same feeling: ***Experiment yourself!*** Yes – once you know how to set up
    the ***EQSTestingPawn***, you can try them out yourself and see how each setting
    affects the generation process. This is the best way you can learn and really
    understand all of these settings.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Circ******le Radius***: As the name suggests, it is the radius of the Circle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Space Between***: How much space there should be between each point; if the *Point
    On Circle Spacing Method* is set to *By Space Between*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Number of Points***: How many points should be generated; if the *Point
    On Circle Spacing Method* is set to *By Number of Points*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Point On Circle Spacing Method***: Determines if the number of points to
    be generated should be calculated based on a constant number of points (***By
    Number of Points***), or by how many points fits the current circle if the space
    between the points is fixed (***By Space Between***).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Arc Direction***: If we are generating only an arc of the circle, this setting
    determines the direction this should be in. The method to calculate the direction
    can be either ***Two Points*** (it takes two *Contexts* and calculate the direction
    between the two) or ***Rotation*** (which takes a *Context* and retrieve its rotation,
    and based on that rotation, decides the direction of the Arc).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Arc Angle***: If this is different from *360*, it defines the angle of cut
    where the points stop being generated, thus creating an *Arc* instead of a circle.
    The direction (or rotation) of such an *Arc* is controlled by the *Arc Direction*
    parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Circle Center***: As the name suggests, it is the center of the circle,
    expressed as a *Context*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Ignore Any Context Actor when Generating Circle***: If checked, it will
    not consider the actors that are used as Contexts for the circle, thus skipping
    to generate points in those locations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Circle Center Z Offset***: As the name suggests, it is an offset along the
    z-axis for the *Circle Center*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Trace Data***: When generating the circle, if there is an obstacle, often,
    we don''t want to generate the points behind the obstacle. This parameter determines
    the rules for doing "*horizontal*" tracing. These options are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***None***: There will be no trace, and all the generated points will be on
    the circle (or arc).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Navigation***: This is the default option. Where the *NavMesh* ends is where
    the point is generated, even if the distance from the center is less then the
    Radius (in some way, the circle assumes the shape of the *NavMesh* if its boarder
    is encountered).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Geometry***: The same as Navigation, but instead of using the *NavMesh*
    as a boarder, the tracing will use the Geometry of the level (this might be really
    useful if you don''t have a *NavMesh*).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Navigation Over Ledges***: The same as Navigation, but now the trace is
    "*over ledges*".'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Projection Data***: This works similarly to Trace Data, but does a "*vertical*"
    trace by projecting the points from above. For the rest, the concept is exactly
    the same as *Trace Data*. The options are ***None***, ***Navigation***, and ***Geometry***,
    with the same meaning these assume in *Trace Data*. "*Navigation Over Ledges*"
    isn''t present because it wouldn''t make any sense.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By using the same settings that are shown in the preceding screenshot (I''m
    using *Trace Data* with *Navigation*, and I have a *NavMesh* in the Level), this
    is what it looks like (I activated the NavMesh with the *P* key so you can see
    that as well):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe7378b5-f5e7-4d35-a7fa-4436dcbb8882.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By using *Geometry* for *Trace Data* instead, we obtain a very similar, but
    slightly different, shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55aa2a78-a5ad-4d86-96c2-b4d818e63cdd.png)'
  prefs: []
  type: TYPE_IMG
- en: If you have a NavMesh that ends, but not the Geometry of the level, the effect
    is even clearer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Points: Cone'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, the ***Cone Generator*** generates the points in a cone
    of a specific Context (like a spotlight). Moreover, options to interact with the *Navmesh* are
    available (so that you can project points onto the *Navmesh*).
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that its shape is generated from many circles,
    from which we always take the same arc. So, if we take the whole circle, we are
    basically generating the points in the area of a single slice.
  prefs: []
  type: TYPE_NORMAL
- en: This Generator can also be used to generate points to cover the area of an entire
    circle.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what it looks like in the *Environmental Query Editor*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf81d358-66fc-410e-9bbd-898cf0a4240f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Its settings are mostly related to the shape of the cone, so let''s explore
    them all:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f25a26ed-5022-43df-96f6-2b70981a2948.png)'
  prefs: []
  type: TYPE_IMG
- en: Once again, it would be ideal to have a screenshot for each combination of settings
    so that you have a feeling of how each setting affects the generation of points.
    Because we don't have the space to do so in this book, I encourage you to experiment
    with an ***EQSTestingPawn*** so that you get a clearer understanding.
  prefs: []
  type: TYPE_NORMAL
- en: '***Aligned Points Distance***: This is the distance between each arc of the
    generated points (the distance between points of the same angle from the center).
    A smaller value generates more points, and the area that''s taken into consideration
    will be more dense.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Cone Degrees***: This dictates how big the arc of each circle is (we are
    taking into consideration how wide the slice is). A value of 360 takes the whole
    area of the circle into account.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Angle Step***: This is the distance, expressed in degrees, between the points
    of the same arc. Smaller values mean more points, and the area taken into consideration
    will be more dense.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Range***: This determines how far away the cone can be (by using a spotlight
    as an example, how far it can illuminate).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Center Actor***: This is the center of the generated circles and is used
    to determine the cone. It is the center, and is expressed as a *Context*.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Include Context Location***: As the name suggests, if checked, a point will
    also be generated in the center of the cone/circles.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Projection Data***: This performs a "*vertical*" trace, by projecting the
    points from above by taking into consideration either the Geometry or the *Navigation
    Mesh*. In fact, the possible options are ***None***, ***Navigation***, and ***Geometry***.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By using the default settings, this is what the cone might look in the level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95f7be1a-6cd2-46dd-bb31-cded301870c7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Points: Donut'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, the ***Donut Generator*** generates the points in a donut
    shape (or "*Annulus*", for those of you who are Math lovers), starting from a
    specific center that's given as a Context. Moreover, various options so that you
    can interact with the *Navmesh* are available (so that you can project points
    onto the *Navmesh*).
  prefs: []
  type: TYPE_NORMAL
- en: This generator can be used to generate spiral shapes as well. Just like the
    cone shape, this generator can be used to generate points to cover the area of
    a whole circle. You can do this by setting its *Inner Radius* to zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what it looks like in the *Environmental Query Editor*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1f37474-a43d-4211-abf8-3b52efcd0244.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following settings are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71132786-3332-4f02-a2c5-a6dc68a0c654.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Inner Radius***: This is the radius of the "*hole*" of the donuts; no points
    will be generated within this radius (thus it''s no closer to this value from
    the *Center*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Outer Radius***: This is the radius of the whole donut; points will be generated
    in rings between the *Inner Radius* and the *Outer Radius*. This also means that
    no points will be generated beyond this radius (thus, it''s further to this value
    from the *Center*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Number of Rings***: How many rings of points should be generated in-between
    the *Inner Radius* and the *Outer Radius*. These rings are always evenly spaced,
    which means that their distance is controlled by this variable, along with the
    *Inner Radius* and the *Outer Radius*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Points per Ring***: This dictates how many points each generated ring should
    have. The points are evenly spaced along the ring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Arc Direction***: If we are generating only an arc of the donut (to be precise,
    only an arc of the circles that will generate the donut), this setting determines
    the direction this should be in. The method to calculate the direction can be
    either ***Two Points*** (it takes two *Contexts* and calculates the direction
    between the two) or ***Rotation*** (which takes a *Context* and retrieves its
    rotation, and based on that rotation, decides on the direction of the Arc).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Arc Angle***: If this isn''t *360*, it defines the angle of cut where the
    points stop being generated, thus creating an *Arc* instead of a circle. The direction
    (or rotation) of such an *Arc* is controlled by the *Arc Direction* parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Use Spiral Pattern***: If checked, the points in each ring are slightly
    offset to generate a spiral pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Center***: This is the center of the generated rings (as well as the minimum and
    maximum extensions of the donut specified with *Inner Radius* and *Outer Radius*,
    respectively). It is expressed as a *Context*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Projection Data***: This performs a "*vertical*" trace by projecting the
    points from above by taking into consideration either the Geometry or the *Navigation
    Mesh*. The possible options are ***None***, ***Navigation***, and ***Geometry***.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand these settings, take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe4cd6af-ed12-474d-9dd0-c3d53ec0f964.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By using these slightly modified settings (please note how I increased the
    *Inner Radius*, bumped up the *Number of Rings* and *Points per Ring*, and also
    used *Navigation* for the Projection Data), it is possible to easily visualize
    the donut. Here are the settings I used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3ceb081-525b-4431-a8e5-e8f9b3657b25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the result they produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/137cd92e-b644-428a-b134-d3dfa19e6202.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By using the same settings, and checking ***Use Spiral Pattern***, you can
    see how the points in the different rings are slightly offset, creating a spiral
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe410a5b-80a1-4188-8afb-358a1b8b2d48.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Points: Grid'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, the ***Grid Generator*** generates the points within a
    Grid. Moreover, options to interact with the *Navmesh* are available (so that
    you don't generate points outside the *Navmesh*).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what it looks like in the *Environmental Query Editor*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99e82896-89ce-411a-aece-bbc0a5ccb177.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The settings for this generator are quite straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27e2040f-c1e2-4e34-a45f-b54c2b50808f.png)'
  prefs: []
  type: TYPE_IMG
- en: '***GridHalfSize***: How much the grid should extend from its center (which
    means it is half the size of the full grid). The dimensions of the grid are fully
    determined by this parameter, along with*Space Between*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Space Between***: How much space there is between each row and column of
    the grid. The dimensions of the grid are fully determined by this parameter, along
    with*GridHalfSize*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Generate Around***: This is the center of the grid (where it starts being
    generated), and it is expressed as a *Context*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Projection Data***: This performs a "*vertical*" trace by projecting the
    points from above. It does this by taking into consideration either the Geometry
    or the *Navigation Mesh*. The possible options are ***None***, ***Navigation***,
    and ***Geometry***.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By looking at the settings, you can see that this generator is quite simple,
    yet powerful and very commonly used. With the default settings, this is what it
    looks like in the level (the projection is enabled at Navmesh, and is present
    in the map):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f4cdf46-d051-403a-9ecf-94b8e3486fc3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Points: Pathing Grid'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, the ***Pathing ******Grid Generator*** generates the points
    within a Grid, just like the *Grid Generator*. However, the difference in this
    generator lies in the fact that the ***Pathing Grid Generator*** check whether
    the points are reachable by the context specified in the ***Generate Around***
    setting (usually the Querier), within a specified distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what it looks like in the *Environmental Query Editor*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ebb49ae-79ed-4f02-887f-758274929a5b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The settings for this generator are almost identical to the *Points: Grid*
    Generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23039003-01ac-4b91-a8ad-10153d183b5c.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Path to Item***: If checked, this excludes all the points that are not reachable
    from the Context, in the settings of the Querier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Navigation Filter***: As the name suggests, it is the navigation filter
    that''s used to perform pathfinding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***GridHalfSize***: This indicates how much the grid should extend from its
    center (which means it is half of the size of the full grid). The dimensions of
    the grid are fully determined by this parameter, along with*Space Between*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Space Between***: This indicates how much space there is between each row
    and column of the grid. The dimensions of the grid are fully determined by this
    parameter, along with*GridHalfSize*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Generate Around***: This is the center of the grid (where it starts being
    generated), and is expressed as a *Context*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Projection Data***: This performs a "*vertical*" trace by projecting the
    points from above. It does this by taking into consideration either the Geometry
    or the *Navigation Mesh*. The possible options are ***None***, ***Navigation***,
    and ***Geometry***.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is what it looks like in the environment (I changed the level slightly
    to block the path upstairs. This makes it clear that those points after the stairs
    that aren''t reachable aren''t even generated by this Generator):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0242db3e-035d-498e-880a-7f9ba85910f3.png)'
  prefs: []
  type: TYPE_IMG
- en: Built-in Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have explored all the generators, it's time to explore the different
    *Tests* that are available within the engine. Usually, the return can be either
    a boolean or a float value.
  prefs: []
  type: TYPE_NORMAL
- en: The Tests that return a float value are most commonly used for *Scoring*, whereas
    the ones that return a boolean are more commonly used for *Filtering*. However,
    each Test might have different return values, depending on whether the Test is
    being used for filtering or scoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the list of the possible *Built-In Tests*; let''s explore them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc324308-87be-4f52-a13d-e0583977208f.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Distance***: Calculates the distance between the item (the point generated)
    and a specific *Context* (e.g. the *Querier*). It can be calculated in ***3D***,
    ***2D***, ***along z-axis***, or ***along*** ***z-axis (absolute)***. The return
    value is a float.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Dot***: Calculates the dot product between ***Line A*** and ***Line B***.
    Both lines can be expressed as either the ***line between two Contexts*** or as
    the ***rotation of a specific Context*** (by taking the forward direction of the
    rotation). The calculation can be done both in ***3D*** or ***2D***.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Gameplay Tags***: Performs a *Query* on the *Gameplay Tags*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Overlap***: Performs an overlapping test with a Box; it is possible to specify
    some options, such as the offset or the extend, or the overlapping channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Pathfinding***: Performs a *Pathfind* between the generated point that is
    being evaluated and a Context. In particular, we can specify whether the return
    value is a boolean (if the *Path exists*) or a float (*Path Cost* or even *Path
    Length*). Moreover, it is possible to specify whether the path goes from the *Context* to
    the *Point* or vice-versa, and it is possible to use a *Navigation Filter*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Pathfinding Batch***: Same as ***Pathfinding***, but in a batch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Project***: Performs a *projection*, which is customizable through the different
    parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Trace***: Performs a *Trace Test*, with all the possible options available
    to perform a Trace elsewhere in the engine. This means that it can trace a *Line*,
    a *Box*, a *Sphere*, or a *Capsule*; either on the *Visibility* or *Camera* *Trace
    Channel*; either complex or simple; either from the Context to the point, or vice-versa.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This concludes our exploration of the built-in nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing Environment Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned previously, there is a simple built-in way to visualize ***Environment
    Queries*** within the Game World, directly from the Viewport; the game doesn't
    even have to be running. In fact, there is a special Pawn that it is able to do
    this. However, this Pawn cannot be brought directly into the level, because to
    ensure that it is not misused, it has been declared virtual within the code base.
    This means that to use it, we need to create our own *Blueprint Pawn* that inherits
    directly from this special Pawn.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, after this step, the Pawn is fully featured, and it doesn't need
    any more code, just the parameters to work with (i.e. the *Environmental Query*
    you want to visualize).
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, create a new Blueprint. The class to inherit from is ***EQSTestingPawn***,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06e89c58-aefe-42f2-a80c-9fc4d9bb9fd3.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, you can rename it ***MyEQSTestingPawn***.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you drag it into the map, from the *Details Panel*, you can change the ***EQS***
    settings, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca33dccd-a3ba-4881-924e-34def53a0ac1.png)'
  prefs: []
  type: TYPE_IMG
- en: The most important parameter is the ***Query Template***, in which you specify
    the query you want to visualize. If you want an in-depth break down of the parameter,
    check out [Chapter 12](a60155c1-2bb0-403f-bdcf-dbd6a9c67824.xhtml)*, Debugging
    methods for AI – Navigation, EQS, and Profiling*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating components for the Environment Querying System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn which class we need to expand to create our custom
    components within the *Environment Querying System*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Contexts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating custom *Contexts* is key in order to have the right references when
    you need them during an Environmental Query. In particular, we will create a simple
    Context to retrieve a single reference to the Player.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore how to create this ***Context***, both in *C++ and Blueprint*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Player Context in Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a context, we need to inherit from the ***EnvQueryContext_BlueprintBase***
    class. In the case of Blueprint, at its creation, just select the highlighted
    class, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83d991a2-7719-4ad8-bf86-7d9242c6bd4b.png)'
  prefs: []
  type: TYPE_IMG
- en: As for the name, the convention is to keep the prefix "*EnvQueryContext_*".
    We can call our Context something like "***EnvQueryContext_BPPlayer***".
  prefs: []
  type: TYPE_NORMAL
- en: 'For a Blueprint Context, you can choose to implement one of the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fcad80b-d9ef-40dd-a524-39c9a366f895.png)'
  prefs: []
  type: TYPE_IMG
- en: Each will provide a *Context* for the *Environmental Query.*
  prefs: []
  type: TYPE_NORMAL
- en: 'We can override the ***Provide Single Actor*** function and then return the
    Player Pawn, simple as that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8f49673-9c1d-4277-bc9f-422675387e6e.png)'
  prefs: []
  type: TYPE_IMG
- en: As a result, we now have a Context that is able to get a Player reference.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Player Context in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the case of creating a C++ Context, inherit from the ***EnvQueryContext*** class,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37440b05-6538-4586-8aa1-cffb60df8743.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The convention is the same, that is, to prefix the Context with "*EnvQueryContext_*".
    We will call our class "***EnvQueryContext_Player***":'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4783c2af-4ece-4cc4-9989-1d043158c85f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In C++, there is only one function to override: `ProvideContext()`. Hence,
    we just need to override it in the `.h` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the implementation file, we can provide the Context. I''m not going to go
    into the details of how – you can read the code of the other Contexts to help
    you understand this. In any case, we can have something like the following for
    our `.cpp` file (I could have implemented this differently, but I chose this way
    because I thought it was easy to understand):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As a result, we are able to retrieve the Player Context in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to how we created Contexts, we can create custom Generators. However,
    we will not go through this in detail, since they are outside the scope of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of Blueprint, inherit from the ***EnvQueryGenerator_BlueprintBase*** class,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36f2d84f-1e92-4920-aa97-02ace5030020.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In C++, you need to inherit from ***EnvQueryGenerator***:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc06c5f4-cba3-4396-b020-dc61879d71ee.png)'
  prefs: []
  type: TYPE_IMG
- en: You may want to start directly from ***EnvQueryGenerator_ProjectedPoints*** since
    you already have all the projections in place. By doing this, you only need to
    focus on its generation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the current version of Unreal Engine, it isn''t possible to create a Test
    in Blueprint – we can only do so with C++. You can do this by extending the ***EnvQueryTest***
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a76bd630-21c2-4463-8588-aacabe3309e2.png)'
  prefs: []
  type: TYPE_IMG
- en: Unfortunately, this is also outside the scope of this book. Exploring the Unreal
    Engine Source code, however, will give you a great amount of information and an
    almost infinite source of learning.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored how the ***Environment Querying System*** can make
    spatial reasoning in the Decision-Making domain.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, we have understood how the whole system works in general, and
    then we went through the built-in nodes of the system. We also saw how it is possible
    to visualize a Query by using a special Pawn. Finally, we explored how it is possible
    to extend the system.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore Agent Awareness, and the built-in Sensing
    system.
  prefs: []
  type: TYPE_NORMAL
