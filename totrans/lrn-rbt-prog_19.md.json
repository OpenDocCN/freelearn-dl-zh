["```py\n    import vpython as vp\n    from robot_pose import robot_view\n    ```", "```py\n    def make_robot():\n    ```", "```py\n        chassis_width = 155\n        chassis_thickness = 3\n        chassis_length = 200\n        wheel_thickness = 26\n        wheel_diameter = 70\n        axle_x = 30\n        axle_z = -20\n        castor_position = vp.vector(-80, -6, -30)\n        castor_radius = 14\n        castor_thickness = 12\n    ```", "```py\n        base = vp.box(length=chassis_length,\n                      height=chassis_thickness,\n                      width=chassis_width)\n    ```", "```py\n    base.rotate(angle=vp.radians(90), \n                    axis=vp.vector(1, 0, 0))\n    ```", "```py\n       wheel_dist = chassis_width/2\n    ```", "```py\n    cylinder axis says which way it is pointing. We set *y* to *-1* to point it left.\n    ```", "```py\n        wheel_r = vp.cylinder(radius=wheel_diameter/2,\n              length=wheel_thickness,\n              pos=vp.vector(axle_x, wheel_dist, axle_z),\n              axis=vp.vector(0, 1, 0))\n    ```", "```py\n        castor = vp.cylinder(radius=castor_radius,\n              length=castor_thickness,\n              pos=castor_position,\n              axis=vp.vector(0, 1, 0))\n    ```", "```py\n        return vp.compound([base, wheel_l, wheel_r, castor])\n    ```", "```py\n    if __name__ == \"__main__\":\n    ```", "```py\n        robot_view()\n    ```", "```py\n        x_arrow = vp.arrow(axis=vp.vector(200, 0, 0), color=vp.color.red)\n        y_arrow = vp.arrow(axis=vp.vector(0, 200, 0), color=vp.color.green)\n        z_arrow = vp.arrow(axis=vp.vector(0, 0, 200), color=vp.color.blue)\n    ```", "```py\n        make_robot()\n    ```", "```py\n    from robot_imu import RobotImu\n    import time\n    import vpython as vp\n    imu = RobotImu()\n    ```", "```py\n    gyro_min = vp.vector(0, 0, 0)\n    gyro_max = vp.vector(0, 0, 0)\n    ```", "```py\n    for n in range(500):\n        gyro = imu.read_gyroscope()\n    ```", "```py\n        gyro_min.x = min(gyro_min.x, gyro.x)\n        gyro_min.y = min(gyro_min.y, gyro.y)\n        gyro_min.z = min(gyro_min.z, gyro.z)\n    ```", "```py\n        gyro_max.x = max(gyro_max.x, gyro.x)\n        gyro_max.y = max(gyro_max.y, gyro.y)\n        gyro_max.z = max(gyro_max.z, gyro.z)\n    ```", "```py\n        offset = (gyro_min + gyro_max) / 2\n    ```", "```py\n        time.sleep(.01)\n    ```", "```py\n    print(f\"Zero offset: {offset}.\")\n    ```", "```py\n    pi@myrobot:~ $ python3 calibrate_gyro.py\n    Zero offset: <-0.583969, 0.675573, -0.530534>.\n    ```", "```py\n    from vpython import vector\n    gyro_offsets = vector(-0.583969, 0.675573, -0.530534)\n    ```", "```py\n        def __init__(self, gyro_offsets=None):\n            self._imu = ICM20948()\n            self.gyro_offsets = gyro_offsets or vector(0, 0, 0)\n    ```", "```py\n        def read_gyroscope(self):\n            _, _, _, gyro_x, gyro_y, gyro_z = self._imu.read_accelerometer_gyro_data()\n            return vector(x, y, z) - self.gyro_offsets\n    ```", "```py\n    import vpython as vp\n    from robot_imu import RobotImu\n    import time\n    import imu_settings\n    import virtual_robot\n    ```", "```py\n    imu = RobotImu(gyro_offsets=imu_settings.gyro_offsets)\n    ```", "```py\n    pitch = 0\n    roll = 0\n    yaw = 0\n    ```", "```py\n    model = virtual_robot.make_robot()\n    virtual_robot.robot_view()\n    ```", "```py\n    latest = time.time()\n    ```", "```py\n    while True:\n        vp.rate(1000)\n    ```", "```py\n        current = time.time()\n        dt = current - latest\n        latest = current\n    ```", "```py\n        gyro = imu.read_gyroscope()\n    ```", "```py\n        roll += gyro.x * dt\n        pitch += gyro.y * dt\n        yaw += gyro.z * dt\n    ```", "```py\n        model.up = vp.vector(0, 1, 0)\n        model.axis = vp.vector(1, 0, 0)\n    ```", "```py\n    1, 0, 0).\n    ```", "```py\n    from vpython import vector, degrees, atan2\n    ```", "```py\n        def read_accelerometer_pitch_and_roll(self):\n            accel = self.read_accelerometer()\n            pitch = degrees(-atan2(accel.x, accel.z))\n            roll = degrees(atan2(accel.y, accel.z))\n            return pitch, roll\n    ```", "```py\n    import vpython as vp\n    import time\n    from robot_imu import RobotImu\n    imu = RobotImu()\n    ```", "```py\n    vp.graph(xmin=0, xmax=60, scroll=True)\n    graph_pitch = vp.gcurve(color=vp.color.red)\n    graph_roll = vp.gcurve(color=vp.color.green)\n    ```", "```py\n    start = time.time()\n    while True:\n        vp.rate(100)\n        elapsed = time.time() - start\n    ```", "```py\n        pitch, roll = imu.read_accelerometer_pitch_and_roll()\n    ```", "```py\n        graph_pitch.plot(elapsed, pitch)\n        graph_roll.plot(elapsed, roll)\n    ```", "```py\n    import time\n    ```", "```py\n    last and start variables with the current time.\n    ```", "```py\n        def update(self):\n            current = time.time()\n    ```", "```py\n            dt = current - self.last\n    ```", "```py\n            elapsed = current - self.start\n    ```", "```py\n            self.last = current\n            return dt, elapsed\n    ```", "```py\n    class ComplementaryFilter:\n    ```", "```py\n        def __init__(self, filter_left=0.9):\n            self.filter_left = filter_left\n            self.filter_right = 1.0 - filter_left\n    ```", "```py\n        def filter(self, left, right):\n            return self.filter_left * left + \\\n                   self.filter_right * right\n    ```", "```py\n    class ImuFusion:\n    ```", "```py\n        def __init__(self, imu, filter_value=0.95):\n            self.imu = imu\n            self.filter = ComplementaryFilter(filter_value).filter\n            self.pitch = 0\n            self.roll = 0\n    ```", "```py\n        def update(self, dt):\n    ```", "```py\n            accel_pitch, accel_roll = self.imu.read_accelerometer_pitch_and_roll()\n    ```", "```py\n            gyro = self.imu.read_gyroscope()\n    ```", "```py\n            self.pitch = self.filter(self.pitch + gyro.y * dt, accel_pitch)\n    ```", "```py\n            self.roll = self.filter(self.roll + gyro.x * dt, accel_roll)\n    ```", "```py\n    import vpython as vp\n    from robot_imu import RobotImu, ImuFusion\n    from delta_timer import DeltaTimer\n    import imu_settings\n    ```", "```py\n    imu = RobotImu(gyro_offsets=imu_settings.gyro_offsets)\n    fusion = ImuFusion(imu)\n    ```", "```py\n    timer = DeltaTimer()\n    ```", "```py\n    while True:\n        vp.rate(100)\n        dt, elapsed = timer.update()\n    ```", "```py\n    fusion.update(dt)\n    ```", "```py\n        graph_pitch.plot(elapsed, fusion.pitch)\n        graph_roll.plot(elapsed, fusion.roll)\n    ```", "```py\n    import vpython as vp\n    from robot_imu import RobotImu\n    imu = RobotImu()\n    ```", "```py\n    mag_min = vp.vector(0, 0, 0)\n    mag_max = vp.vector(0, 0, 0)\n    ```", "```py\n    scatter_xy = vp.gdots(color=vp.color.red)\n    scatter_yz = vp.gdots(color=vp.color.green)\n    scatter_zx = vp.gdots(color=vp.color.blue) \n    ```", "```py\n    while True:\n        vp.rate(100)\n        mag = imu.read_magnetometer()\n    ```", "```py\n        mag_min.x = min(mag_min.x, mag.x)\n        mag_min.y = min(mag_min.y, mag.y)\n        mag_min.z = min(mag_min.z, mag.z)\n    ```", "```py\n        mag_max.x = max(mag_max.x, mag.x)\n        mag_max.y = max(mag_max.y, mag.y)\n        mag_max.z = max(mag_max.z, mag.z)\n    ```", "```py\n        offset = (mag_max + mag_min) / 2\n    ```", "```py\n        print(f\"Magnetometer: {mag}. Offsets: {offset}.\")\n    ```", "```py\n        scatter_xy.plot(mag.x, mag.y)\n        scatter_yz.plot(mag.y, mag.z)\n        scatter_zx.plot(mag.z, mag.x)\n    ```", "```py\n    Magnetometer: <30.6, -36.9, 10.35>. Offsets: <21.15, 3.15, 0.225>.\n    Magnetometer: <31.5, -36.75, 11.25>. Offsets: <21.15, 3.15, 0.225>.\n    ```", "```py\n      def __init__(self, gyro_offsets=None,\n                   mag_offsets=None):\n          self._imu = ICM20948()\n          self.gyro_offsets = gyro_offsets or vector(0, 0, 0)\n          self. mag_offsets = mag_offsets or vector(0, 0, 0)\n    ```", "```py\n        def read_magnetometer(self):\n            mag_x, mag_y, mag_z = self._imu.read_magnetometer_data()\n            return vector(mag_x, -mag_z, -mag_y) - self. mag_offsets\n    ```", "```py\n    from vpython import vector\n    gyro_offsets = vector(0.557252, -0.354962, -0.522901)\n    mag_offsets = vector(21.15, 3.15, 0.225)\n    ```", "```py\n    import vpython as vp\n    from robot_imu import RobotImu\n    from imu_settings import mag_offsets\n    ```", "```py\n    imu = RobotImu(mag_offsets=mag_offsets)\n    ```", "```py\n    import vpython as vp\n    from robot_imu import RobotImu\n    from delta_timer import DeltaTimer\n    import imu_settings\n    ```", "```py\n    imu = RobotImu(mag_offsets=imu_settings.mag_offsets)\n    ```", "```py\n    vp.cylinder(radius=1, axis=vp.vector(0, 0, 1), \n                pos=vp.vector(0, 0, -1))\n    needle = vp.arrow(axis=vp.vector(1, 0, 0), \n                      color=vp.color.red)\n    ```", "```py\n    vp.graph(xmin=0, xmax=60, scroll=True)\n    graph_yaw = vp.gcurve(color=vp.color.blue)\n    timer = DeltaTimer()\n    ```", "```py\n    while True:\n        vp.rate(100)\n        dt, elapsed = timer.update()\n    ```", "```py\n        mag = imu.read_magnetometer()\n    ```", "```py\n        yaw = -vp.atan2(mag.y, mag.x)\n    ```", "```py\n        graph_yaw.plot(elapsed, vp.degrees(yaw))\n    ```", "```py\n        needle.axis = vp.vector(vp.sin(yaw), vp.cos(yaw), 0)\n    ```", "```py\n    from icm20948 import ICM20948\n    from vpython import vector, degrees, atan2, radians\n    ```", "```py\n        def __init__(self, imu, filter_value=0.95):\n            self.imu = imu\n            self.filter = ComplementaryFilter(filter_value).filter\n            self.pitch = 0\n            self.roll = 0\n            self.yaw = 0\n    ```", "```py\n            mag = self.imu.read_magnetometer()\n    ```", "```py\n            mag = mag.rotate(radians(self.pitch), vector(0, 1, 0))\n            mag = mag.rotate(radians(self.roll), vector(1, 0, 0))\n    ```", "```py\n            mag_yaw = -degrees(atan2(mag.y, mag.x))\n    ```", "```py\n            self.yaw = self.filter(self.yaw + gyro.z * dt, mag_yaw)\n    ```", "```py\n    import vpython as vp\n    from robot_imu import RobotImu, ImuFusion\n    from delta_timer import DeltaTimer\n    import imu_settings\n    import virtual_robot\n    ```", "```py\n    imu = RobotImu(gyro_offsets=imu_settings.gyro_offsets,\n                   mag_offsets=imu_settings.mag_offsets)\n    fusion = ImuFusion(imu)\n    ```", "```py\n    robot_view = vp.canvas(align=\"left\")\n    model = virtual_robot.make_robot()\n    virtual_robot.robot_view()\n    ```", "```py\n    compass = vp.canvas(width=400, height=400)\n    vp.cylinder(radius=1, axis=vp.vector(0, 0, 1), \n                pos=vp.vector(0, 0, -1))\n    needle = vp.arrow(axis=vp.vector(1, 0, 0), \n                      color=vp.color.red)\n    ```", "```py\n    vp.graph(xmin=0, xmax=60, scroll=True)\n    graph_roll = vp.gcurve(color=vp.color.red)\n    graph_pitch = vp.gcurve(color=vp.color.green)\n    graph_yaw = vp.gcurve(color=vp.color.blue)\n    ```", "```py\n    timer = DeltaTimer()\n    while True:\n        vp.rate(100)\n        dt, elapsed = timer.update()\n    ```", "```py\n        fusion.update(dt)\n    ```", "```py\n        model.up = vp.vector(0, 1, 0)\n        model.axis = vp.vector(1, 0, 0)\n    ```", "```py\n        model.rotate(angle=vp.radians(fusion.roll), axis=vp.vector(1, 0, 0))\n        model.rotate(angle=vp.radians(fusion.pitch), axis=vp.vector(0, 1, 0))\n        model.rotate(angle=vp.radians(fusion.yaw), axis=vp.vector(0, 0, 1))\n    ```", "```py\n        needle.axis = vp.vector(\n    vp.sin(vp.radians(fusion.yaw)), \n    vp.cos(vp.radians(fusion.yaw)), \n                0)\n    ```", "```py\n        graph_roll.plot(elapsed, fusion.roll)\n        graph_pitch.plot(elapsed, fusion.pitch)\n        graph_yaw.plot(elapsed, fusion.yaw)\n    ```", "```py\n        @staticmethod\n        def format_angle(angle):\n    ```", "```py\n            if angle < -180:\n                angle += 360\n    ```", "```py\n            if angle > 180:\n                angle -= 360\n            return angle\n    ```", "```py\n        def filter(self, left, right):\n            left = self.format_angle(left)\n            right = self.format_angle(right)\n    ```", "```py\n            if left - right > 350:\n                right += 360\n            elif right - left > 350:\n                left += 360\n    filtered = self.filter_left * left + \\\n                   self.filter_right * right\n    ```", "```py\n            return format_angle(filtered)\n    ```", "```py\n    from robot_imu import RobotImu, ImuFusion\n    from delta_timer import DeltaTimer\n    from pid_controller import PIController\n    from robot import Robot\n    import imu_settings\n    ```", "```py\n    imu = RobotImu(mag_offsets=imu_settings.mag_offsets,\n                   gyro_offsets=imu_settings.gyro_offsets)\n    fusion = ImuFusion(imu)\n    timer = DeltaTimer()\n    ```", "```py\n    pid = PIController(0.7, 0.01)\n    robot = Robot()\n    ```", "```py\n    base_speed = 70\n    heading_set_point = 0\n    ```", "```py\n    while True:\n        dt, elapsed = timer.update()\n        fusion.update(dt)\n    ```", "```py\n        heading_error = fusion.yaw - heading_set_point\n        steer_value = pid.get_value(heading_error, delta_time=dt)\n    ```", "```py\n        print(f\"Error: {heading_error}, Value:{steer_value:2f}, t: {elapsed}\")\n        robot.set_left(base_speed + steer_value)\n        robot.set_right(base_speed - steer_value)\n    ```"]