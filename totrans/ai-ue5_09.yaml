- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extending Behavior Trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the nuances of behavior trees is crucial for game developers,
    as they enable them to have a firm grasp on creating responsive and more engaging
    AI characters. This is why, in this chapter, we will embark on a deep dive into
    the inner workings and best practices of the behavior tree system for Unreal Engine;
    we will go through a thorough explanation of their functionality, most notably
    on how to create more complex custom tasks, services, and decorators for our AI
    agents. Additionally, we will go back to the debugging tools and see how to analyze
    behavior trees at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Presenting best practices for authoring behavior trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging behavior trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the topics presented in this chapter, you should have completed the
    previous ones and understood their content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, if you would prefer to begin with code from the companion repository
    for this book, you can download the **.zip** project files provided in this book’s
    companion project repository: [https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5](https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: To download the files from the end of the last chapter, click the **Unreal Agility
    Arena –** **Chapter 08** **-** **End** link.
  prefs: []
  type: TYPE_NORMAL
- en: Presenting best practices for authoring behavior trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It seems our little novel has a new chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*In their quest to test the capabilities of their AI puppets, Dr. Markus and
    Professor Viktoria decided to equip them with Nerf guns. The idea was to create
    a fun and engaging scenario where the puppets could showcase their newfound* *shooting
    skills.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the secret lab, the atmosphere buzzed with excitement as the puppets, now
    armed and ready with non-lethal weapons, were going to take on the challenge.
    With their advanced AI programming and sensor systems, the puppets were able to
    analyze the environment, calculate trajectories, and take aim at the targets with*
    *remarkable accuracy.*'
  prefs: []
  type: TYPE_NORMAL
- en: When designing a behavior tree for your AI agents, it is crucial to possess
    a thorough understanding of the best practices to consider. Additionally, staying
    up to date with the latest advancements and research in the field of AI in the
    video game industry will provide valuable insights and inform your decision-making
    process when designing better behavior trees.
  prefs: []
  type: TYPE_NORMAL
- en: Listing best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, I will provide you with some valuable advice to optimize
    and enhance the engagement of your AIs; some of them come from well-known patterns,
    while some originate from my own personal experience – most of the time, acquired
    by a trial-and-error process.
  prefs: []
  type: TYPE_NORMAL
- en: Use proper naming conventions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is good practice to properly name any newly created tasks, decorators, or
    services in the behavior tree. Use naming conventions that indicate the type of
    asset, be it a task, decorator, or service. As a rule of thumb, you should use
    the following prefixes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**BTTask_** for tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BTDecorator_** for decorators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BTService_** for services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will not only help you in making it clear the type of asset you have created
    but you will also get a beneficial side effect; in the behavior tree graph, the
    system will recognize the type of class and will remove the prefix by showing
    just the node name. The use of improper naming conventions would result in erratic
    behaviors when trying to select the nodes in the node graph.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, in [*Chapter 8*](B31016_08.xhtml#_idTextAnchor148) , *Setting
    Up a Behavior Tree* , you may have noticed that we named the battery check service
    **BTService_BatteryCheck** , but in the behavior tree graph, it is shown just
    as **Battery Check** .
  prefs: []
  type: TYPE_NORMAL
- en: Give your nodes a meaningful name
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Behavior tree tasks, decorators, and services all have a property named **NodeName**
    that will be used to display the node name in the graph; use it if you want to
    give your nodes a different name than the class name.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid directly changing node properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of directly changing the properties of nodes within the behavior tree,
    you should leverage the power of Blackboards and change its keys. Alternatively,
    you may call a function inside the character that makes the necessary modifications
    to keys. This will help maintain a cleaner and more organized structure.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, our previously created dummy puppet handles the battery logic
    through the character and some dedicated Blackboard keys.
  prefs: []
  type: TYPE_NORMAL
- en: Consider performance optimization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The behavior tree system in Unreal Engine is fundamentally optimized, as it
    avoids evaluating the entire tree at every frame and instead relies on success
    and fail notifications to determine the next node to execute. However, it is important
    to exercise caution and not rely too heavily on certain features with the assumption
    that they will automatically function as intended.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, in the *Battery Check* service we previously created, we disabled
    the tick interval, leveraging the power of delegates instead.
  prefs: []
  type: TYPE_NORMAL
- en: Use modular design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try breaking down complex behaviors into smaller, reusable modules such as tasks,
    services, and decorators. This modular approach will make it easier to maintain
    and update the behavior tree.
  prefs: []
  type: TYPE_NORMAL
- en: As an example of small tasks creating a more complex behavior, try checking
    the **Roam Sequence** from the behavior tree implemented in [*Chapter 8*](B31016_08.xhtml#_idTextAnchor148)
    , *Setting Up a* *Behavior Tree* .
  prefs: []
  type: TYPE_NORMAL
- en: Do not assume your character is going to be an AI agent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When developing an AI character, you may be tempted to add AI logic directly
    into the **Character** class. However, it is generally advisable to avoid this
    practice. The **AI Controller** class has been specifically designed to serve
    a purpose, offering a more structured and modular method for overseeing the AI
    behavior of characters. By leveraging the **AI Controller** class, you can effectively
    separate the AI logic from the character itself, resulting in enhanced maintainability
    and the ability to update the AI behavior independently.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, having the capability of switching between an AI controller and
    a player controller at runtime can provide several advantages such as allowing
    a player to take control of an AI character.
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, it is recommended to create your **Pawn** and **Character**
    classes in a way that allows them to be controlled by both players and AI interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we will be creating a brand-new AI agent with this in
    mind.
  prefs: []
  type: TYPE_NORMAL
- en: Debug and test often
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regularly test and debug your behavior tree to ensure it functions as intended.
    Use debugging tools provided by Unreal Engine to identify and resolve any issues.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, I will be showing you how to properly use the debugging
    tools with your behavior trees.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have some additional information on how to create an AI agent effectively,
    it’s time to dive back into our project and begin crafting a brand-new character!
    Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a gunner character logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a starting point, we will be creating a new AI character with some extra
    features; in particular, it will have some nice gunning capabilities to shoot
    at targets – by means of a non-lethal Nerf gun. As mentioned earlier, it’s important
    to prioritize simplicity and modularity when working on your characters. In this
    particular scenario, it doesn’t make sense to have the shooting logic integrated
    within the base character. Instead, it would be more effective to take advantage
    of the capabilities provided by Unreal Engine components. By doing so, you can
    keep the shooting functionality separate and modular, allowing for better organization
    and flexibility in your project. As a final result, the AI agent will be capable
    of shooting at targets, by using AI behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the BaseWeaponComponent class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create a weapon component for our dummy character, we will start by extending
    a **StaticMeshComponent** class; this will give a good starting point – the mesh
    – and we will just need to add the socket attaching logic and the shooting logic.
  prefs: []
  type: TYPE_NORMAL
- en: To start creating this component, from Unreal Engine, create a new C++ class
    extending from **StaticMeshComponent** and name it **BaseWeaponComponent** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the class has been created, open the **BaseWeaponComponent.h** file and
    change the **UCLASS()** macro with this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will make the component accessible to Blueprints, and you can attach it
    directly to a Blueprint class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, inside the class, just after the **GENERATED_BODY()** macro, add the following
    declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are declaring the constructor, a **Shoot()** function that will spawn
    a bullet; then, we declare the **BulletClass** property for the spawned bullet
    and **MuzzleOffset** to precisely place the bullet spawn point. Finally, in the
    **protected** section, we will need the **BeginPlay()** declaration to add some
    initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to implement the component, so open the **BaseWeaponComponent.cpp**
    file and, at the very top of it, add this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Immediately after that, add the class constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This function is quite easy and straightforward as we are just declaring a default
    mesh – a Nerf gun pistol – for the component; you will be free to change it later
    on when extending this class with a Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, add the **BeginPlay()** implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This function tries to cast the owner of the component to a **Character** object,
    and if the cast is successful, it attaches the component to the mesh of the character
    at the **hand_right** socket so that the gun will stay in the character’s right
    hand; I have already provided such a socket for you in the **Dummy** skeletal
    mesh, as shown in *Figure 9* *.1* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Hand socket](img/B31016_figure_09.01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Hand socket
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final step, it’s time to implement the **Shoot()** function logic, so
    add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This function checks whether **BulletClass** is valid, gets the reference to
    **World** – the top-level object that represents a map reference – then calculates
    the spawn location and rotation based on the owner’s position, and finally, spawns
    an actor using **BulletClass** at the calculated location and rotation.
  prefs: []
  type: TYPE_NORMAL
- en: The component is now ready; the next step will be to create a proper bullet
    to shoot at the right time.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the BaseBullet class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Having created a weapon component that spawns bullets, the next logical step
    is to create a spawnable bullet. This is going to be quite straightforward; we
    will be creating an object with a mesh that will move forward, doing damage to
    anything that it will hit. Let’s start by creating a new C++ class extending **Actor**
    and calling it **BaseGunBullet** ; after the class has been created, open the
    **BaseGunBullet.h** header file and, just after the **#include** section, add
    the following forward declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, change the **UCLASS()** macro so that this class is an acceptable
    base for creating Blueprints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, just after the **GENERATED_BODY()** macro, add the needed component declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to declare the **public** functions – that is, the constructor
    and the getters for the components – so add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the **protected** section, remove the **BeginPlay()** declaration as it
    won’t be needed. Instead, we will need the **OnHit()** handler for bullet collision
    events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the header is complete, it’s time to start implementing the class,
    so open up **BaseGunBullet.cpp** . As a first step, add the needed **#include**
    declarations at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, remove the **BeginPlay()** implementation, which, as I previously said,
    won’t be needed. After that, add the constructor implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Most of the aforementioned code has been addressed previously or is self-explanatory,
    although there are some important things to mention. The **CollisionComponent**
    collision profile name has been set to **BlockAll** , in order to get proper collisions;
    additionally, we have bound the **OnComponentHit** delegate to the **OnHit()**
    method, in order to react to any bullet collisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add the final method implementation, which will handle the bullet
    hitting any object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we just call the **TakeDamage()** method to the **Actor** object
    that has been hit and then we destroy the bullet. No need to worry about damage
    parameters in this game! They aren’t the focus of this book, so you have the freedom
    to add your own damage logic and stick to it if you’d like. Feel free to customize
    the game to your heart’s content!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve finalized the bullet class, it’s time to create a suitable target
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Target class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now need to create a base actor that we will be using to implement a target
    for our shooting AI agent. So, let’s start by creating a new C++ class extending
    from **Actor** and call it **BaseTarget** . Once the class has been created, open
    up the **BaseTarget.h** header file.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first step, add this forward declaration just after the **#** **include**
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, remove the **BeginPlay()** and **Tick()** functions as they won’t be
    needed, and add the following declarations just after the **ABaseTarget()** constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Apart from the **StaticMeshComponent** property that will be used to show the
    target mesh, we have added the **TakeDamage()** declaration that will be used
    to handle hits from bullets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the **BaseTarget.cpp** file and, after removing the **BeginPlay()**
    and **Tick()** function implementations, change the constructor with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: By now, you should already be familiar with the previous code; after disabling
    the tick functionality for this actor, we proceeded to add and initialize a **StaticMesh**
    component, which will serve the purpose of displaying a target in our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the **TakeDamage()** implementation to your file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the approach here is quite simple; we are merely using the **Untagged**
    keyword, which will invalidate the tag assigned to the parent object. This effectively
    renders it invisible to the behavior tree task we will be constructing later in
    this chapter. We don’t need to worry about damage logic; once a target has been
    it, it will just be invalidated.
  prefs: []
  type: TYPE_NORMAL
- en: Now that all the base classes have been created, we are ready to implement the
    needed Blueprints, including a brand-new gunner character.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Blueprints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will proceed with the creation of the Blueprints that will be instrumental
    in generating the new AI gunner agent. Specifically, we will be working on the
    following components:'
  prefs: []
  type: TYPE_NORMAL
- en: The spawnable bullet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The gunner character itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by creating the bullet Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the bullet Blueprint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The creation of the bullet Blueprint is quite straightforward. Just follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Blueprints** folder in the Unreal Engine **Content Drawer** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on it and select **Blueprint Class** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **All Classes** section, select **BaseGunBullet** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name the new asset **BP_GunBullet** . *Figure 9* *.2* shows the final Blueprint
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Gun bullet Blueprint](img/B31016_figure_09.02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Gun bullet Blueprint
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the target Blueprint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The creation of the target Blueprint is almost identical to the bullet one;
    we just need to add a tag to the object. Do the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Blueprints** folder in the Unreal Engine **Content Drawer** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on it and select **Blueprint Class** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **All Classes** section, select **BaseTarget** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new asset **BP_Target** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Details** panel, look for the **Tags** property in the **Actor** |
    **Advanced** category and hit the **+** button to create a new tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name the tag **ShootingTarget** , as shown in *Figure 9* *.3* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Target tag](img/B31016_figure_09.03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Target tag
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9* *.4* shows the final Blueprint class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Target Blueprint](img/B31016_figure_09.04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Target Blueprint
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the gunner character Blueprint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s now time to create the gunner character as a Blueprint. You are already
    familiar with the process, but here are the steps to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Blueprints** folder in the Unreal Engine **Content Drawer** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on it and select **Blueprint Class** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **All Classes** section, select **BaseDummyCharacter** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new asset **BP_GunnerDummy** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We’ll add the AI controller later in this chapter, but we need to change a
    value in the Blueprint class in order to make our character properly work. So,
    open this Blueprint and, in the **Details** panel, locate the **Use Controller
    Rotation Yaw** attribute in the **Pawn** category; this will allow rotation of
    the character correctly when using AI logic later on. Tick the value, as depicted
    in *Figure 9* *.5* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Use Controller Rotation Yaw ticked](img/B31016_figure_09.05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Use Controller Rotation Yaw ticked
  prefs: []
  type: TYPE_NORMAL
- en: This value will allow us to rotate the character through a task when shooting
    at a target.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it’s time to add a proper weapon to the character. To do this, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: With the Blueprint character class open, locate the **Components** panel and
    click the **+** **Add** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **UnrealAgilityArena** | **Base Weapon** to add this component to the
    Blueprint class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select this newly added component and, in the **Bullet** category of the **Details**
    panel, locate the **Bullet Class** attribute; from its dropdown, select **BP_GunBullet**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we’ve got our character all primed and ready, it’s time to unleash
    its shooting prowess at our command!
  prefs: []
  type: TYPE_NORMAL
- en: Making the weapon shoot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To make the shooting phase work properly, we will be using **Anim Notify** –
    an event that can be synchronized with animation sequences – so that we can call
    the **Shoot()** function at a specific point along the animation timeline.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be curious about why we’re implementing this particular system instead
    of directly calling the **Shoot()** function from any part of our code. Well,
    here’s the thing: the shoot animation has a duration, and the moment when the
    bullet should be spawned occurs somewhere within the animation. This is where
    an Anim Notify comes into play. By using **Anim Notify** , we can specify the
    exact moment within the animation when the bullet should be spawned.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An Anim Notify is created by extending the **AnimNotify** class, so start by
    creating a new C++ class that extends **AnimNotify** and call it **AnimNotify_Shoot**
    . Once the files have been created, open the **AnimNotify_Shoot.h** header file
    and, as a first step, change the **UCLASS()** macro declaration to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Without delving too deeply into the specifics, it is sufficient to say that
    these initialization settings are necessary for the class to function correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, add the following **public** declarations to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The **UAnimNotify_Shoot()** declaration is the constructor, which is quite self-explanatory,
    while the **Notify()** declaration will be called when an Anim Notify is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the **AnimNotify_Shoot.cpp** file and add the needed **#include**
    declarations at its top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, add the constructor implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: While not mandatory, this function allows you to customize the color of the
    notify label within the Unreal Engine Editor. It’s quite handy, isn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the **Notify()** function holds significant importance for
    gameplay-related reasons, so add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This function looks for a **BaseWeaponComponent** instance, if any, and calls
    the **Shoot()** function.
  prefs: []
  type: TYPE_NORMAL
- en: Before adding this Anim Notify to the shoot animation, you will need to compile
    your project. Once the new class is available, look for the **AM_1H_Shoot** montage,
    which can be found in the **Content/KayKit/PrototypeBits/Character/Animations**
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In Unreal Engine, a **montage** refers to a specialized asset that allows you
    to create complex animations for characters or objects. Montages are commonly
    used for defining sequences of related animation. As montages are not part of
    this book’s focus, I have provided the needed ones for you.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have opened the asset by double-clicking on it, you will notice that,
    in the asset timeline, there is a **ShootNotify_C** label; this is an empty placeholder
    I have provided for you to let you know where the notify should be placed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Animation montage](img/B31016_figure_09.06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Animation montage
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on that label and select **Replace** with **Notify** | **Shoot**
    to add an **AnimNotify_Shoot** instance.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Shoot notify](img/B31016_figure_09.07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Shoot notify
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, whenever your AI agent plays this montage, it will get a notification
    from the montage itself that will call the **Shoot()** function. Later in this
    chapter, we will be creating a dedicated task for our AI agent behavior tree,
    in order to play the montage but, if you want to test things out, you can simply
    use the **Play Montage** node in the Event Graph of **BP_GunnerDummyCharacter**
    , as shown in *Figure 9* *.8* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Montage test](img/B31016_figure_09.08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Montage test
  prefs: []
  type: TYPE_NORMAL
- en: Just ensure to remove this node after completing your testing to prevent your
    AI agent from exhibiting seemingly erratic behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I have provided insights on enhancing AI agents and behavior
    trees through best practices and tips from my own experience. Following that,
    we established the foundation for a more advanced AI agent capable of shooting.
    The upcoming section will focus on developing a custom decorator, adding a new
    layer of complexity to our project. Exciting developments lie ahead for our endeavor!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decorators provide a way to add additional functionality or conditions to the
    execution of a portion of a behavior tree. As you already know from previous chapters,
    decorators are attached to either a composite or a task node and determine whether
    a branch in the tree (or even a single node) can be executed. By combining decorators
    with composite nodes, you can create behavior trees with prioritized behavior
    allowing for powerful logic capable of handling intricate scenarios. In [*Chapter
    8*](B31016_08.xhtml#_idTextAnchor148) , *Setting Up a Behavior Tree* , we used
    some built-in decorators but, in this section, I will give you more detailed information
    about creating your own custom decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the BTAuxiliaryNode class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both decorators and services inherit from the **BTAuxiliaryNode** class, which
    will let you implement the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OnBecomeRelevant()** : This will be called when the auxiliary node – the
    one the decorator or service is attached to – becomes active'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OnCeaseRelevant()** : This will be executed when the auxiliary node becomes
    inactive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TickNode()** : This will be executed at each auxiliary node tick'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [*Chapter 8*](B31016_08.xhtml#_idTextAnchor148) , *Setting Up a Behavior
    Tree* , I presented you with some of these functions, so it’s good to know where
    they come from.
  prefs: []
  type: TYPE_NORMAL
- en: Creating C++ decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A decorator extends from the **BTDecorator** class, and in C++, its main implementable
    functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OnNodeActivation()** : This is called when the underlying node is activated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OnNodeDeactivation()** : This is called when the underlying node is deactivated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OnNodeProcessed()** : This is called when the underlying node is deactivated
    or fails to activate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CalculateRawConditionalValue()** : This computes the value of the decorator
    condition without considering the inverse condition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, you can use the **IsInversed()** function to check whether the
    decorator will handle the inversed conditional value.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Blueprint decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whenever creating a decorator with Blueprints Visual Scripting, you should
    extend from the **BTDecorator_BlueprintBase** class, which includes some additional
    code logic and events, in order to better manage it. You can create a decorator
    in the usual way – from **Content Drawer** – or you can select the **New Decorator**
    button from the behavior tree graph, as shown in *Figure 9* *.9* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Decorator creation](img/B31016_figure_09.09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Decorator creation
  prefs: []
  type: TYPE_NORMAL
- en: 'The main events you will have at your disposal when working with Blueprint-generated
    decorators are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Receive Execution Start AI** : This is called when the underlying node is
    activated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receive Execution Finish AI** : This is called when the underlying node has
    finished executing its logic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receive Tick AI** : This is called on each tick'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Decorator nodes](img/B31016_figure_09.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Decorator nodes
  prefs: []
  type: TYPE_NORMAL
- en: By keeping this in mind, you will have the ability to implement your own Blueprint
    decorators for your AI agents.
  prefs: []
  type: TYPE_NORMAL
- en: We are now going to implement our own decorator, one that will be checking a
    tag on an actor.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the CheckTagOnActor decorator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now is the perfect time to create our first decorator. As you may recall, while
    implementing the **BaseTarget** class, we ensured that whenever a target gets
    hit, its tag is set to an undefined value. By implementing a decorator that checks
    an actor instance tag, we can determine whether the actor itself is a viable target.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s start by creating a new C++ class extending **BTDecorator** , and
    let’s call it **BTDecorator_CheckTagOnActor** . Once the class has been created,
    open the **BTDecorator_CheckTagOnActor.h** file and add the following declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we will be using a Blackboard key value – the **ActorToCheck**
    one – to check whether its referred value has a tag equal to **TagName** . This
    check will be handled by the **CalculateRawConditionValue()** function. Additionally,
    we will need to initialize any asset-related data, and this is usually done in
    the **InitializeFromAsset()** function, which is inherited by the **BTNode** superclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the **BTDecorator_CheckTagOnActor.cpp** file to start implementing
    the functions. Let’s start by adding the needed **#** **include** files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s implement the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: What we are doing here, immediately after naming the node, holds significant
    importance. We are filtering key values to only allow **Actor** classes. This
    step ensures that only valid Blackboard keys related to actors will be accepted,
    maintaining the integrity and appropriateness of the inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **CalculateRawConditionValue()** function is going to be pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we retrieve the Blackboard component and get the **ActorToCheck**
    key in order to check whether there is a valid **Actor** instance and whether
    it is tagged as a target.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, implement the last required function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This function retrieves the **BlackboardData** asset and resolves the selected
    key for **ActorToCheck** from that asset.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have been provided with more advanced information about
    decorators, including specific considerations for implementing them in C++ or
    Blueprints. Additionally, you have successfully created a custom decorator that
    will be utilized by our upcoming gunner AI agent. This custom decorator will play
    a crucial role in creating the behavior and decision-making capabilities of the
    AI gunner agent, further improving its performance and effectiveness.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, I will be presenting you with some detailed information
    on how to implement services.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since you are already acquainted with services from previous chapters, I will
    now provide you with additional information to further enrich your understanding
    of this topic. Let’s explore these details to enhance your expertise in services
    within behavior trees.
  prefs: []
  type: TYPE_NORMAL
- en: Creating C++ services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A service extends from the **BTService** class, and its main implementable function
    is **OnSearchStart()** , which is executed when the behavior tree search enters
    the underlying branch. You can use this to create some kind of initialization
    if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, it is important to remember that services extend the **BTAuxiliaryNode**
    class, thereby inheriting all of its functions. One particularly crucial function
    inherited by services is the **TickNode()** function, which plays a vital role
    in the implementation of services, as it governs the execution and periodic updating
    of the service node within the behavior tree.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Blueprint services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating a service using Blueprints Visual Scripting, it is advisable
    to extend from the **BTService_BlueprintBase** class as it provides additional
    code logic and events that facilitate better management of the service itself.
    Similar to decorators, there are two ways to create a service: the conventional
    method, which involves using **Content Drawer** , or selecting the **New Service**
    button directly from the behavior tree graph, as shown in *Figure 9* *.11* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Service creation](img/B31016_figure_09.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Service creation
  prefs: []
  type: TYPE_NORMAL
- en: 'The main events you will have at your disposal when working with Blueprint-generated
    services are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Receive Activation AI** : This is called when the service becomes active'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receive Deactivation AI** : This is called when the service becomes inactive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receive Search Start AI** : This is called when the behavior tree search
    enters the underlying branch'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receive Tick AI** : This is called on each tick'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Service nodes](img/B31016_figure_09.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Service nodes
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, you will have the ability to implement your own Blueprint
    services for your behavior trees.
  prefs: []
  type: TYPE_NORMAL
- en: With this new knowledge at our disposal, let’s implement a new service that
    will let us handle the ammo state.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the SetAmmo service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now ready to start implementing our own service; you already have created
    a couple of them in [*Chapter 8*](B31016_08.xhtml#_idTextAnchor148) , *Setting
    Up a Behavior Tree* , so you should be already familiar with some of the presented
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we will need a service that will allow us to tell the Blackboard
    when a weapon has fired – and so needs reloading – or is ready to shoot. As usual,
    let’s start by creating a new C++ class extending from **BT_Service** and call
    it **BTService_SetAmmo** . Once it has been created, open the **BTService_SetAmmo.h**
    file and add the following declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You should already be familiar with most of the code here; let’s just say that
    we will be using a **NeedsReload** Blackboard key as a **bool** value to see whether
    the weapon ammo is depleted or not. Now, open the **BTService_SetAmmo.cpp** file
    and add the following **#include** declaration at the top of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor is going to be pretty straightforward as we want the service
    tick to be disabled and we want to execute it just when it becomes relevant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The **OnBecomeRelevant()** function will serve us just to set the Blackboard
    key value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this section, you have been provided with additional information about services,
    including specific considerations for implementing them in C++ or Blueprints.
    Additionally, you have successfully created another custom service that will be
    used to handle your AI agent’s gun ammo.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, I will be presenting you with detailed information on how
    to implement tasks as we will be creating a couple more for our soon-to-be gunner
    agent.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I will provide you with additional information to enhance your
    understanding of tasks. Let’s explore these details together to further strengthen
    your grasp of tasks within the context of behavior trees.
  prefs: []
  type: TYPE_NORMAL
- en: Creating C++ tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A task extends from the **BTTask** class, and its main implementable functions
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ExecuteTask()** : This will start the task execution and will return the
    task result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AbortTask()** : This will let you handle events where a task should be stopped'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is usually all you need to create even a simple yet fully working task.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Blueprint tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating a task using Blueprints Visual Scripting, you will be extending
    from the **BTTask_BlueprintBase** class as it provides additional code logic to
    facilitate its implementation. As you may have guessed, there are two ways to
    create a task: the usual creation from **Content Drawer** , and the **New Task**
    selection button directly from the behavior tree graph, as shown in *Figure 9*
    *.13* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Task creation](img/B31016_figure_09.13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – Task creation
  prefs: []
  type: TYPE_NORMAL
- en: 'The main events you will have available when working with Blueprint-generated
    tasks are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Receive Execute AI** : This is called when the task is executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receive Abort AI** : This is called when the task is aborted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receive Tick AI** : This is called on each tick'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.14 – Task nodes](img/B31016_figure_09.14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – Task nodes
  prefs: []
  type: TYPE_NORMAL
- en: Keeping this in mind, you will possess the capability to implement your own
    Blueprint tasks for your behavior trees, and that’s exactly what we are going
    to do in the next steps.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the PlayMontage task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you already know, the shooting command for our AI agent is going to be controlled
    by an Anim Notify from an animation montage. Unfortunately, there is no out-of-the-box
    task for executing montages from a behavior tree; a **PlayAnimation** task is
    present, but it will not serve our purposes as it won’t handle montages really
    well. Fortunately, with our existing strong understanding of tasks, implementing
    the code logic will be relatively straightforward. Furthermore, having a task
    that plays montages will prove highly beneficial when handling other animation
    sequences, such as reloading bullets or celebrating when all targets have been
    successfully hit. So, start by creating a new C++ class that extends **BTTask**
    and call it **BTTask_PlayMontage** . Inside the **BTTask_PlayMontage.h** file,
    add the following self-explanatory declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the **BTTask_PlayMontage.cpp** file, add the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This function simply executes the **PlayAnimMontage()** function on the character,
    returning a **Succeeded** result. If any of the needed references are not found,
    a **Failed** result is returned.
  prefs: []
  type: TYPE_NORMAL
- en: With this task ready to go, we can implement a second one, the last one we will
    be needing in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the FindAvailableTarget task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This task will have the sole aim of finding an available target by checking
    all actors with a predefined tag. There is nothing fancy here, but we will be
    needing it, so create a new C++ class inheriting from **BBTask** and call it **BTTask_FindAvailableTarget**
    . In the **BTTask_FindAvailableTarget.h** header file, add the following declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'No need to add explanations here, so let’s open the **BTTask_FindAvailableTarget.cpp**
    file and add the needed **#** **include** declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor is just going to filter the type entries for the **TargetValue**
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The **ExecuteTask()** function will search through the level in order to find
    all **Actor** instances correctly tagged and return a random element from the
    list. Just add this piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a **Succeeded** result is returned if at least one **Actor**
    instance has been found.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we took a brief look at some of the key features of tasks and
    even added a couple more to our arsenal. It seems like we are now well-prepared
    to embark on our journey with the gunner AI character. While we are discussing
    this topic, it’s a great opportunity to explain the proper techniques for debugging
    a behavior tree. So, let’s dive in and get started with it!
  prefs: []
  type: TYPE_NORMAL
- en: Debugging behavior trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging behavior trees with Unreal Engine is essential for ensuring the smooth
    and efficient functioning of your AI-driven games. By carefully examining and
    analyzing the behavior tree’s execution, you can identify and resolve any issues
    or glitches that may arise during gameplay. You already have some understanding
    of how to enable the debugging tools in Unreal Engine. In this section, we will
    take a deep dive into the debugging feature specifically designed for behavior
    trees; before starting with the debugging tools, we’ll need to create a proper
    – and moderately complex – behavior tree.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Blackboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Blackboard for the behavior tree is going to be straightforward; we need
    a couple of keys to keep a reference of the target and a flag to check whether
    the weapon needs reloading. So, let’s start by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Content Drawer** and create a Blackboard asset in the **Content/AI**
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the asset **BB_GunnerDummy** and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new key of the **bool** type and name it **NeedsReload** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new key of the **Object** type and call it **TargetActor** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may remember that while creating the **BTTask_FindAvailableTarget** class,
    we decided to filter this key so that it will accept only the **Actor** type and
    not a generic **Object** one; this means you will need to set the base class for
    this key to an **Actor** type. To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **TargetActor** key and, in the **Blackboard Details** panel, open
    the **Key Type** option to show the **Base** **Class** attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the **Base Class** dropdown, select **Actor** , as shown in *Figure 9*
    *.15* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.15 – Target Actor key](img/B31016_figure_09.15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – Target Actor key
  prefs: []
  type: TYPE_NORMAL
- en: Creating the behavior tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The behavior tree we are going to implement is going to have the following
    logic:'
  prefs: []
  type: TYPE_NORMAL
- en: If the AI character has a valid target, it will shoot at it and then reload
    the weapon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no target is set, it will try to find one in the level and set the proper
    key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no target is available in the level, it means all targets have been hit and
    the AI character will cheer with happiness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Start by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Content/AI** folder, create a new **Behavior Tree** asset and call
    it **BT_GunnerDummy** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Details** panel, set the **Blackboard Asset** attribute to **BB_GunnerDummy**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect a **Selector** node to the **Root** node and call it **Root Selector**
    , as shown in *Figure 9* *.16* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.16 – The Root Selector node](img/B31016_figure_09.16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – The Root Selector node
  prefs: []
  type: TYPE_NORMAL
- en: As you may remember, a selector node will execute the subtrees in sequence until
    one of them succeeds; this is exactly what we need to do in order to create our
    gunner AI logic.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the shooting logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The shooting logic is going to be subdivided into two phases – shooting and
    reloading – so we are going to use another selector node. Let’s do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: From **Root Selector** , add another selector node and name it **Shoot Selector**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on it, add a **CheckTagOnTarget** decorator, and name it **Is Actor**
    **a Target?** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select this decorator and, in the **Details** panel, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Actor to Check** attribute to **TargetActor**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the **Tag Name** attribute to **ShootingTarget**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Basically, this selector will be executed only if there is a valid target in
    the **TargetActor** key of the Blackboard; if not, **Root Selector** will try
    executing the next subtree available. We need now to create the actual shooting
    logic, so start doing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a sequence node to **Shoot Selector** and name it **Shoot Sequence** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on it, add a **Blackboard** decorator, and name it **Has Ammo?**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the decorator and, in the **Details** panel, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Notify Observers** attribute to **On** **Value Change**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the **Key Query** attribute to **Is** **Not Set**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the **Blackboard Key** attribute to **NeedsReload**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This part of the tree will execute only when the **NeedsReload** key is set
    to **true** ; otherwise, it will try to execute the next subtree. This portion
    of the tree graph should look like the one depicted in *Figure 9* *.17* :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.17 – Starting shoot sequence](img/B31016_figure_09.17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17 – Starting shoot sequence
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add some nodes to **Shoot Sequence** :'
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Rotate to Face BBEntry** task and name it **Rotate** **Towards Target**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select this node and, in the **Details** panel, set the **Blackboard Key** attribute
    to **TargetActor** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From **Shoot Sequence** , add a **Play Montage** task and name it **Shoot Montage**
    . Make sure that this task is at the right of the **Rotate Towards Target** task.
    In the **Details** panel, set the **Anim Montage** attribute to **AM_1H_Shoot**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on this task node, add a **Set Ammo** service, and name it **Deplete
    Ammo** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select this service and do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Needs Reload** attribute to **NeedsReload**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the **Key** **Value** attribute
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From **Shoot Sequence** , add a **Wait** node and make sure that this task
    is at the right of the **Shoot Montage** task. Select the **Wait** node and do
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Wait Time** attribute to **2.0**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the **Random Deviation** attribute to **0.5**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This portion of the behavior tree can be seen in *Figure 9* *.18* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18 – Finished shoot sequence](img/B31016_figure_09.18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.18 – Finished shoot sequence
  prefs: []
  type: TYPE_NORMAL
- en: One of the great things about behavior trees is that when you give descriptive
    names to your nodes, you can quickly understand what’s happening at a glance.
    By naming your nodes in a way that accurately reflects their purpose or function,
    you create a clear and intuitive visual representation of your AI.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now start creating the reload sequence for the gun. Let’s start by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From **Shoot Selector** , add a new sequence node to the right of **Shoot Sequence**
    and name it **Reload Sequence** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From **Reload Sequence** , add a **Play Montage** task and name it **Reload
    Montage** . In the **Details** panel, set the **Anim Montage** attribute to **AM_1H_Reload**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on this task node, add a **Set Ammo** service, and name it **Refill
    Ammo** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select this service and do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Needs Reload** attribute to **NeedsReload**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Leave the **Key Value** attribute unchecked
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From **Reload Sequence** , add a **Wait** node and make sure that this task
    is at the right of the **Reload Montage** task. Select the **Wait** node and do
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Wait Time** attribute to **3.0** .
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Set the **Random Deviation** attribute to **0.5** . This portion of the behavior
    tree can be seen in *Figure 9.19* :'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.19 – Reload sequence](img/B31016_figure_09.19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.19 – Reload sequence
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we enter this portion of the tree, start the reload animation while
    setting the **NeedsReload** key to **false** , and we wait a bit before going
    on with the execution. With this portion of the behavior tree complete, we can
    implement the target search portion.
  prefs: []
  type: TYPE_NORMAL
- en: Finding an available target
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whenever there is no available target to shoot at, **Root Selector** will execute
    the next subtree; in this case, we will be looking for a new viable target. To
    do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From **Root Selector** , add a **FindAvailableTarget** task at the right of
    the **Shoot** **Selector** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the task and do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Target Actor** attribute to **TargetActor**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the **Target Tag** attribute to **ShootingTarget**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 9* *.20* shows this portion of the behavior tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.20 – Find target task](img/B31016_figure_09.20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.20 – Find target task
  prefs: []
  type: TYPE_NORMAL
- en: It’s now time to add the third and last part of the behavior tree logic.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing the AI logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last portion of the code will be to make the AI character cheer when all
    targets have been hit. To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From **Root Selector** , add a sequence node at the right of the **Find Available
    Target** task and name it **Cheer Sequence** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From **Cheer Sequence** , add a **Play Montage** task and name it **Cheer Montage**
    . In the **Details** panel, set the **Anim Montage** attribute to **AM_Cheer**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From **Cheer Sequence** , add a **Wait** node and make sure that this task
    is at the right of the **Cheer Montage** task. Select the **Wait** node and do
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Wait Time** attribute to **3.0**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the **Random Deviation** attribute to **0.5**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This part of the graph should look like *Figure 9* *.21* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.21 – Cheer sequence](img/B31016_figure_09.21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.21 – Cheer sequence
  prefs: []
  type: TYPE_NORMAL
- en: Now that the behavior tree is finally complete, we can move forward by creating
    a dedicated AI controller.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the AI controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The AI controller is going to be pretty simple; you’ll just need to do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Content Drawer** and, in the **Content/Blueprints** folder, add a new
    Blueprint class extending **BaseDummyAIController** and name it **AIGunnerDummyController**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open it and, in the **Details** panel, locate the **Behavior Tree** property
    and set its value to **BT_GunnerDummy** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open **BP_GunnerDummyCharacter** and, in the **Details** panel, set the **AI
    Controller Class** attribute to **AIDummyGunnerController** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have the controller ready and the character all set up, it’s time
    to test and debug its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging the behavior tree on a gym
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start debugging the newly created behavior tree, let’s start by creating
    a new level. Let’s follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a level of your choice, starting from the Level Instances and Packed
    Level Actors I provided in the project template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **BP_GunnerDummyCharacter** instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add one or more **BP_Target** instances so that your AI character will have
    a line of sight to them. My gym level is shown in *Figure 9* *.22* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.22 – Gym level](img/B31016_figure_09.22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.22 – Gym level
  prefs: []
  type: TYPE_NORMAL
- en: Once you test the level, the expected behavior is for the character to shoot
    at each target, reload after each shot, and cheer once all targets have been successfully
    hit.
  prefs: []
  type: TYPE_NORMAL
- en: Adding breakpoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To test your behavior tree, you can open it up and start the level simulation;
    you will see the active part of the tree, with nodes highlighted in yellow, as
    shown in *Figure 9* *.23* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.23 – Testing the tree](img/B31016_figure_09.23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.23 – Testing the tree
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, portions of the graph will be executed really fast and you may not
    see whether a particular portion of the tree has been executed. To get a better
    understanding of what’s happening, you may add a breakpoint by right-clicking
    on a node and selecting **Add Breakpoint** , as shown in *Figure 9* *.24* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.24 – Adding a breakpoint](img/B31016_figure_09.24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.24 – Adding a breakpoint
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In Unreal Engine’s behavior tree, a **breakpoint** is a debugging feature that
    allows you to pause the execution of the behavior tree at a specific node. When
    the execution reaches the breakpoint, the behavior tree execution is temporarily
    halted, giving you the opportunity to inspect the state of the AI character and
    analyze the flow of the behavior tree. Execution can be resumed at any time to
    get on with the behavior tree execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the behavior tree is executed, it will pause at the breakpoint, providing
    a clear view of what is happening at that moment. By pausing the execution at
    specific breakpoints, you can gain valuable insights into the inner workings of
    the AI behavior and identify any issues or unexpected behaviors that need to be
    addressed. *Figure 9* *.25* shows a breakpoint positioned on the **Find Available
    Target** node, showing that the previous subtree failed while checking the **Is
    Actor a** **Target?** decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.25 – Active breakpoint](img/B31016_figure_09.25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.25 – Active breakpoint
  prefs: []
  type: TYPE_NORMAL
- en: Using the debugging tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you may recall from [*Chapter 6*](B31016_06.xhtml#_idTextAnchor116) , *Optimizing
    the Navigation System* , Unreal Engine offers a range of debugging tools for the
    AI system. Behavior trees are no exception, and once you enable these tools, you
    will have the ability to analyze the situation by pressing the number *2* on your
    keyboard’s numpad. This feature allows you to gain insights into the behavior
    of the AI character and evaluate the execution of the behavior tree in real time.
    In *Figure 9* *.26* , we can observe a specific situation where the behavior tree
    is displayed on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.26 – Debugging tools](img/B31016_figure_09.26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.26 – Debugging tools
  prefs: []
  type: TYPE_NORMAL
- en: This visual representation provides a clear view of the structure and flow of
    the behavior tree, allowing us to analyze and understand its organization.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this comprehensive chapter, I have provided you with additional information
    on creating more effective and efficient behavior trees. We began by discussing
    some best practices and then delved into the key features of decorators, services,
    and tasks. Furthermore, we explored the implementation of custom nodes tailored
    to specific requirements, culminating in the creation of a fully functional AI
    agent. To validate our work and take advantage of Unreal Engine’s robust debugging
    tools, we also developed a gym environment for thorough testing.
  prefs: []
  type: TYPE_NORMAL
- en: Get ready for the next chapter because things are about to get even more packed
    with excitement! In this upcoming chapter, I’ll be unveiling the Unreal Perception
    System, where your AI agents will sharpen their senses and become more attentive
    than ever before!
  prefs: []
  type: TYPE_NORMAL
