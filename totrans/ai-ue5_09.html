<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-168">
    <a id="_idTextAnchor170">
    </a>
    
     9
    
   </h1>
   <h1 id="_idParaDest-169">
    <a id="_idTextAnchor171">
    </a>
    
     Extending Behavior Trees
    
   </h1>
   <p>
    
     Understanding the nuances of behavior trees is crucial for game developers, as they enable them to have a firm grasp on creating responsive and more engaging AI characters.
    
    
     This is why, in this chapter, we will embark on a deep dive into the inner workings and best practices of the behavior tree system for Unreal Engine; we will go through a thorough explanation of their functionality, most notably on how to create more complex custom tasks, services, and decorators for our AI agents.
    
    
     Additionally, we will go back to the debugging tools and see how to analyze behavior trees
    
    
     
      at runtime.
     
    
   </p>
   <p>
    
     In this chapter, we will be covering the
    
    
     
      following topics:
     
    
   </p>
   <ul>
    <li>
     
      Presenting best practices for authoring
     
     
      
       behavior trees
      
     
    </li>
    <li>
     
      
       Understanding decorators
      
     
    </li>
    <li>
     
      
       Understanding services
      
     
    </li>
    <li>
     
      
       Understanding tasks
      
     
    </li>
    <li>
     
      Debugging
     
     
      
       behavior trees
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-170">
    <a id="_idTextAnchor172">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     To follow the topics presented in this chapter, you should have completed the previous ones and understood
    
    
     
      their content.
     
    
   </p>
   <p>
    
     Additionally, if you would prefer to begin with code from the companion repository for this book, you can download the
    
    <strong class="source-inline">
     
      .zip
     
    </strong>
    
     project files provided in this book’s companion project
    
    
     
      repository:
     
    
    <a href="https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5">
     
      
       https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     To download the files from the end of the last chapter, click the
    
    <strong class="source-inline">
     
      Unreal Agility Arena –
     
    </strong>
    
     <strong class="source-inline">
      
       Chapter 08
      
     </strong>
    
    <strong class="source-inline">
     
      -
     
    </strong>
    
     <strong class="source-inline">
      
       End
      
     </strong>
    
    
     
      link.
     
    
   </p>
   <h1 id="_idParaDest-171">
    <a id="_idTextAnchor173">
    </a>
    
     Presenting best practices for authoring behavior trees
    
   </h1>
   <p>
    
     It seems
    
    <a id="_idIndexMarker389">
    </a>
    
     our little novel has a
    
    
     
      new chapter:
     
    
   </p>
   <p>
    <em class="italic">
     
      In their quest to test the capabilities of their AI puppets, Dr.
     
     
      Markus and Professor Viktoria decided to equip them with Nerf guns.
     
     
      The idea was to create a fun and engaging scenario where the puppets could showcase their newfound
     
    </em>
    
     <em class="italic">
      
       shooting skills.
      
     </em>
    
   </p>
   <p>
    <em class="italic">
     
      In the secret lab, the atmosphere buzzed with excitement as the puppets, now armed and ready with non-lethal weapons, were going to take on the challenge.
     
     
      With their advanced AI programming and sensor systems, the puppets were able to analyze the environment, calculate trajectories, and take aim at the targets with
     
    </em>
    
     <em class="italic">
      
       remarkable accuracy.
      
     </em>
    
   </p>
   <p>
    
     When designing a behavior tree for your AI agents, it is crucial to possess a thorough understanding of the best practices to consider.
    
    
     Additionally, staying up to date with the latest advancements and research in the field of AI in the video game industry will provide valuable insights and inform your decision-making process when designing better
    
    
     
      behavior trees.
     
    
   </p>
   <h2 id="_idParaDest-172">
    <a id="_idTextAnchor174">
    </a>
    
     Listing best practices
    
   </h2>
   <p>
    
     In this
    
    <a id="_idIndexMarker390">
    </a>
    
     subsection, I will provide you with some valuable advice to optimize and enhance the engagement of your AIs; some of them come from well-known patterns, while some originate from my own personal experience – most of the time, acquired by a
    
    
     
      trial-and-error process.
     
    
   </p>
   <h3>
    
     Use proper naming conventions
    
   </h3>
   <p>
    
     It is good
    
    <a id="_idIndexMarker391">
    </a>
    
     practice to properly name any newly created tasks, decorators, or services in the behavior tree.
    
    
     Use naming conventions that indicate the type of asset, be it a task, decorator, or service.
    
    
     As a rule of thumb, you should use the
    
    
     
      following prefixes:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       BTTask_
      
     </strong>
     
      
       for tasks
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       BTDecorator_
      
     </strong>
     
      
       for decorators
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       BTService_
      
     </strong>
     
      
       for services
      
     
    </li>
   </ul>
   <p>
    
     This will not
    
    <a id="_idIndexMarker392">
    </a>
    
     only help you in making it clear the type of asset you have created but you will also get a beneficial side effect; in the behavior tree graph, the system will recognize the type of class and will remove the prefix by showing just the node name.
    
    
     The use of improper naming conventions would result in erratic behaviors when trying to select the nodes in the
    
    
     
      node graph.
     
    
   </p>
   <p>
    
     As an example, in
    
    <a href="B31016_08.xhtml#_idTextAnchor148">
     
      <em class="italic">
       
        Chapter 8
       
      </em>
     
    </a>
    
     ,
    
    <em class="italic">
     
      Setting Up a Behavior Tree
     
    </em>
    
     , you may have noticed that we named the battery check service
    
    <strong class="source-inline">
     
      BTService_BatteryCheck
     
    </strong>
    
     , but in the behavior tree graph, it is shown just as
    
    
     <strong class="bold">
      
       Battery Check
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h3>
    
     Give your nodes a meaningful name
    
   </h3>
   <p>
    
     Behavior tree
    
    <a id="_idIndexMarker393">
    </a>
    
     tasks, decorators, and services all have a property named
    
    <strong class="source-inline">
     
      NodeName
     
    </strong>
    
     that will be used to display the node name in the graph; use it if you want to give your nodes a different name than the
    
    
     
      class name.
     
    
   </p>
   <h3>
    
     Avoid directly changing node properties
    
   </h3>
   <p>
    
     Instead
    
    <a id="_idIndexMarker394">
    </a>
    
     of directly changing the properties of nodes within the behavior tree, you should leverage the power of Blackboards and change its keys.
    
    
     Alternatively, you may call a function inside the character that makes the necessary modifications to keys.
    
    
     This will help maintain a cleaner and more
    
    
     
      organized structure.
     
    
   </p>
   <p>
    
     As an example, our previously created dummy puppet handles the battery logic through the character and some dedicated
    
    
     
      Blackboard keys.
     
    
   </p>
   <h3>
    
     Consider performance optimization
    
   </h3>
   <p>
    
     The
    
    <a id="_idIndexMarker395">
    </a>
    
     behavior tree system in Unreal Engine is fundamentally optimized, as it avoids evaluating the entire tree at every frame and instead relies on success and fail notifications to determine the next node to execute.
    
    
     However, it is important to exercise caution and not rely too heavily on certain features with the assumption that they will automatically function
    
    
     
      as intended.
     
    
   </p>
   <p>
    
     As an example, in the
    
    <em class="italic">
     
      Battery Check
     
    </em>
    
     service we previously created, we disabled the tick interval, leveraging the power of
    
    
     
      delegates instead.
     
    
   </p>
   <h3>
    
     Use modular design
    
   </h3>
   <p>
    
     Try breaking
    
    <a id="_idIndexMarker396">
    </a>
    
     down complex behaviors into smaller, reusable modules such as tasks, services, and decorators.
    
    
     This modular approach will make it easier to maintain and update the
    
    
     
      behavior tree.
     
    
   </p>
   <p>
    
     As an example of small tasks creating a more complex behavior, try checking the
    
    <strong class="bold">
     
      Roam Sequence
     
    </strong>
    
     from the behavior tree implemented in
    
    <a href="B31016_08.xhtml#_idTextAnchor148">
     
      <em class="italic">
       
        Chapter 8
       
      </em>
     
    </a>
    
     ,
    
    <em class="italic">
     
      Setting Up a
     
    </em>
    
     <em class="italic">
      
       Behavior Tree
      
     </em>
    
    
     
      .
     
    
   </p>
   <h3>
    
     Do not assume your character is going to be an AI agent
    
   </h3>
   <p>
    
     When developing an AI character, you may be tempted to add AI logic directly into the
    
    <strong class="source-inline">
     
      Character
     
    </strong>
    
     class.
    
    
     However, it is generally advisable to avoid this practice.
    
    
     The
    
    <strong class="source-inline">
     
      AI Controller
     
    </strong>
    
     class has been specifically designed to serve a purpose, offering a more structured and modular method for overseeing the AI behavior of characters.
    
    
     By leveraging the
    
    <strong class="source-inline">
     
      AI Controller
     
    </strong>
    
     class, you can effectively separate the AI logic from the character itself, resulting in enhanced maintainability and the ability to update the AI
    
    
     
      behavior independently.
     
    
   </p>
   <p>
    
     As an example, having the capability of switching between an AI controller and a player controller at runtime can provide several advantages such as allowing a player to take control of an
    
    
     
      AI character.
     
    
   </p>
   <p>
    
     As a rule of thumb, it is recommended to create your
    
    <strong class="source-inline">
     
      Pawn
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Character
     
    </strong>
    
     classes in a way that allows them to be controlled by both players and
    
    
     
      AI interchangeably.
     
    
   </p>
   <p>
    
     Later in this chapter, we will be creating a brand-new AI agent with this
    
    
     
      in mind.
     
    
   </p>
   <h3>
    
     Debug and test often
    
   </h3>
   <p>
    
     Regularly test
    
    <a id="_idIndexMarker397">
    </a>
    
     and debug your behavior tree to ensure it functions as intended.
    
    
     Use debugging tools provided by Unreal Engine to identify and
    
    <a id="_idIndexMarker398">
    </a>
    
     resolve
    
    
     
      any issues.
     
    
   </p>
   <p>
    
     By the end of this chapter, I will be showing you how to properly use the debugging tools with your
    
    
     
      behavior trees.
     
    
   </p>
   <p>
    
     Now that you have some additional information on how to create an AI agent effectively, it’s time to dive back into our project and begin crafting a brand-new character!
    
    
     Let’s
    
    
     
      get started!
     
    
   </p>
   <h2 id="_idParaDest-173">
    <a id="_idTextAnchor175">
    </a>
    
     Implementing a gunner character logic
    
   </h2>
   <p>
    
     As a starting point, we
    
    <a id="_idIndexMarker399">
    </a>
    
     will be creating a new AI character with some extra features; in particular, it will have some nice gunning capabilities to shoot at targets – by means of a non-lethal Nerf gun.
    
    
     As mentioned earlier, it’s important to prioritize simplicity and modularity when working on your characters.
    
    
     In this particular scenario, it doesn’t make sense to have the shooting logic integrated within the base character.
    
    
     Instead, it would be more effective to take advantage of the capabilities provided by Unreal Engine components.
    
    
     By doing so, you can keep the shooting functionality separate and modular, allowing for better organization and flexibility in your project.
    
    
     As a final result, the AI agent will be capable of shooting at targets, by using
    
    
     
      AI behaviors.
     
    
   </p>
   <h3>
    
     Creating the BaseWeaponComponent class
    
   </h3>
   <p>
    
     To create a
    
    <a id="_idIndexMarker400">
    </a>
    
     weapon component for our dummy character, we will start by extending a
    
    <strong class="source-inline">
     
      StaticMeshComponent
     
    </strong>
    
     class; this will give a good starting point – the mesh – and we will just need to add the socket attaching logic and the
    
    
     
      shooting logic.
     
    
   </p>
   <p>
    
     To start
    
    <a id="_idIndexMarker401">
    </a>
    
     creating this component, from Unreal Engine, create a new C++ class extending from
    
    <strong class="source-inline">
     
      StaticMeshComponent
     
    </strong>
    
     and name
    
    
     
      it
     
    
    
     <strong class="source-inline">
      
       BaseWeaponComponent
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Once the class has been created, open the
    
    <strong class="source-inline">
     
      BaseWeaponComponent.h
     
    </strong>
    
     file and change the
    
    <strong class="source-inline">
     
      UCLASS()
     
    </strong>
    
     macro with this line
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
UCLASS(BlueprintType, Blueprintable, ClassGroup="UnrealAgilityArena",
  meta=(BlueprintSpawnableComponent))</pre>
   <p>
    
     This will make the component accessible to Blueprints, and you can attach it directly to a
    
    
     
      Blueprint class.
     
    
   </p>
   <p>
    
     Now, inside the class, just after the
    
    <strong class="source-inline">
     
      GENERATED_BODY()
     
    </strong>
    
     macro, add the
    
    
     
      following declarations:
     
    
   </p>
   <pre class="source-code">
public:
    UBaseWeaponComponent();
    UFUNCTION(BlueprintCallable)
    virtual void Shoot();
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Bullet")
    TSubclassOf&lt;AActor&gt; BulletClass;
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Bullet")
    FVector MuzzleOffset = FVector(150, 30.f, 0.f);
protected:
    virtual void BeginPlay() override;</pre>
   <p>
    
     Here, we
    
    <a id="_idIndexMarker402">
    </a>
    
     are declaring the constructor, a
    
    <strong class="source-inline">
     
      Shoot()
     
    </strong>
    
     function that will spawn a bullet; then, we declare
    
    <a id="_idIndexMarker403">
    </a>
    
     the
    
    <strong class="source-inline">
     
      BulletClass
     
    </strong>
    
     property for the spawned bullet and
    
    <strong class="source-inline">
     
      MuzzleOffset
     
    </strong>
    
     to precisely place the bullet spawn point.
    
    
     Finally, in the
    
    <strong class="source-inline">
     
      protected
     
    </strong>
    
     section, we will need the
    
    <strong class="source-inline">
     
      BeginPlay()
     
    </strong>
    
     declaration to add
    
    
     
      some initialization.
     
    
   </p>
   <p>
    
     We are now ready to implement the component, so open the
    
    <strong class="source-inline">
     
      BaseWeaponComponent.cpp
     
    </strong>
    
     file and, at the very top of it, add this line
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
#include "BaseDummyCharacter.h"</pre>
   <p>
    
     Immediately after that, add the
    
    
     
      class constructor:
     
    
   </p>
   <pre class="source-code">
UBaseWeaponComponent::UBaseWeaponComponent()
{
    static ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;       StaticMeshAsset(
       TEXT("/Game/KayKit/PrototypeBits/Models/Gun_Pistol.Gun_         Pistol"));
    if (StaticMeshAsset.Succeeded())
    {
       UStaticMeshComponent::SetStaticMesh(StaticMeshAsset.Object);
    }
}</pre>
   <p>
    
     This
    
    <a id="_idIndexMarker404">
    </a>
    
     function is quite easy
    
    <a id="_idIndexMarker405">
    </a>
    
     and straightforward as we are just declaring a default mesh – a Nerf gun pistol – for the component; you will be free to change it later on when extending this class with
    
    
     
      a Blueprint.
     
    
   </p>
   <p>
    
     After that, add the
    
    
     <strong class="source-inline">
      
       BeginPlay()
      
     </strong>
    
    
     
      implementation:
     
    
   </p>
   <pre class="source-code">
void UBaseWeaponComponent::BeginPlay()
{
    Super::BeginPlay();
    const auto Character = Cast&lt;ABaseDummyCharacter&gt;(GetOwner());
    if(Character == nullptr) return;
    AttachToComponent(Character-&gt;GetMesh(),       FAttachmentTransformRules::SnapToTargetIncludingScale,       "hand_right");
}</pre>
   <p>
    
     This function tries to cast the owner of the component to a
    
    <strong class="source-inline">
     
      Character
     
    </strong>
    
     object, and if the cast is successful, it
    
    <a id="_idIndexMarker406">
    </a>
    
     attaches the component to the mesh of the character at the
    
    <strong class="source-inline">
     
      hand_right
     
    </strong>
    
     socket so that
    
    <a id="_idIndexMarker407">
    </a>
    
     the gun will stay in the character’s right hand; I have already provided such a socket for you in the
    
    <strong class="bold">
     
      Dummy
     
    </strong>
    
     skeletal mesh, as shown in
    
    
     <em class="italic">
      
       Figure 9
      
     </em>
    
    
     <em class="italic">
      
       .1
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 9.1 – Hand socket" src="img/B31016_figure_09.01.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.1 – Hand socket
    
   </p>
   <p>
    
     As a final step, it’s time to implement the
    
    <strong class="source-inline">
     
      Shoot()
     
    </strong>
    
     function logic, so add the following lines
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
void UBaseWeaponComponent::Shoot()
{
    if (BulletClass == nullptr) return;
    auto const World = GetWorld();
    if (World == nullptr) return;
    const FRotator SpawnRotation = GetOwner()-&gt;GetActorRotation();
    const FVector SpawnLocation = GetOwner()-&gt;GetActorLocation() +       SpawnRotation.RotateVector(MuzzleOffset);
    FActorSpawnParameters ActorSpawnParams;
    ActorSpawnParams.SpawnCollisionHandlingOverride =       ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButDont       SpawnIfColliding;
    World-&gt;SpawnActor&lt;AActor&gt;(BulletClass, SpawnLocation, SpawnRotation, ActorSpawnParams);
}</pre>
   <p>
    
     This
    
    <a id="_idIndexMarker408">
    </a>
    
     function checks
    
    <a id="_idIndexMarker409">
    </a>
    
     whether
    
    <strong class="source-inline">
     
      BulletClass
     
    </strong>
    
     is valid, gets the reference to
    
    <strong class="source-inline">
     
      World
     
    </strong>
    
     – the top-level object that represents a map reference – then calculates the spawn location and rotation based on the owner’s position, and finally, spawns an actor using
    
    <strong class="source-inline">
     
      BulletClass
     
    </strong>
    
     at the calculated location
    
    
     
      and rotation.
     
    
   </p>
   <p>
    
     The component is now ready; the next step will be to create a proper bullet to shoot at the
    
    
     
      right time.
     
    
   </p>
   <h3>
    
     Creating the BaseBullet class
    
   </h3>
   <p>
    
     Having
    
    <a id="_idIndexMarker410">
    </a>
    
     created a weapon component
    
    <a id="_idIndexMarker411">
    </a>
    
     that spawns bullets, the next logical step is to create a spawnable bullet.
    
    
     This is going to be quite straightforward; we will be creating an object with a mesh that will move forward, doing damage to anything that it will hit.
    
    
     Let’s start by creating a new C++ class extending
    
    <strong class="source-inline">
     
      Actor
     
    </strong>
    
     and calling it
    
    <strong class="source-inline">
     
      BaseGunBullet
     
    </strong>
    
     ; after the class has been created, open the
    
    <strong class="source-inline">
     
      BaseGunBullet.h
     
    </strong>
    
     header file and, just after the
    
    <strong class="source-inline">
     
      #include
     
    </strong>
    
     section, add the following
    
    
     
      forward declarations:
     
    
   </p>
   <pre class="source-code">
class USphereComponent;
class UProjectileMovementComponent;
class UStaticMeshComponent;</pre>
   <p>
    
     After that, change
    
    <a id="_idIndexMarker412">
    </a>
    
     the
    
    <strong class="source-inline">
     
      UCLASS()
     
    </strong>
    
     macro so that this class is an acceptable base for
    
    
     
      creating Blueprints:
     
    
   </p>
   <pre class="source-code">
UCLASS(Blueprintable)</pre>
   <p>
    
     Now, just
    
    <a id="_idIndexMarker413">
    </a>
    
     after the
    
    <strong class="source-inline">
     
      GENERATED_BODY()
     
    </strong>
    
     macro, add the needed
    
    
     
      component declarations:
     
    
   </p>
   <pre class="source-code">
UPROPERTY(VisibleDefaultsOnly, Category="Projectile")
USphereComponent* CollisionComponent;
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category="Projectile",   meta=(AllowPrivateAccess="true"))
UStaticMeshComponent* MeshComponent;
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category="Movement",   meta=(AllowPrivateAccess="true"))
UProjectileMovementComponent* ProjectileMovementComponent;</pre>
   <p>
    
     The next step is to declare the
    
    <strong class="source-inline">
     
      public
     
    </strong>
    
     functions – that is, the constructor and the getters for the components – so add the following lines
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
public:
   ABaseGunBullet();
    USphereComponent* GetCollision() const { return       CollisionComponent; }
    UProjectileMovementComponent* GetProjectileMovement() const {       return ProjectileMovementComponent; }
    UStaticMeshComponent* GetMesh() const { return MeshComponent; }</pre>
   <p>
    
     In the
    
    <strong class="source-inline">
     
      protected
     
    </strong>
    
     section, remove the
    
    <strong class="source-inline">
     
      BeginPlay()
     
    </strong>
    
     declaration as it won’t be needed.
    
    
     Instead, we will need the
    
    <strong class="source-inline">
     
      OnHit()
     
    </strong>
    
     handler for bullet
    
    
     
      collision events:
     
    
   </p>
   <pre class="source-code">
protected:
    virtual void BeginPlay() override;
    UFUNCTION()
    void OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor,       UPrimitiveComponent* OtherComp, FVector NormalImpulse, const         FHitResult&amp; Hit);</pre>
   <p>
    
     Now
    
    <a id="_idIndexMarker414">
    </a>
    
     that the header is complete, it’s time
    
    <a id="_idIndexMarker415">
    </a>
    
     to start implementing the class, so open up
    
    <strong class="source-inline">
     
      BaseGunBullet.cpp
     
    </strong>
    
     .
    
    
     As a first step, add the needed
    
    <strong class="source-inline">
     
      #include
     
    </strong>
    
     declarations at the top of
    
    
     
      the file:
     
    
   </p>
   <pre class="source-code">
#include "GameFramework/ProjectileMovementComponent.h"
#include "Components/SphereComponent.h"
#include "Components/StaticMeshComponent.h"
#include "Engine/DamageEvents.h"</pre>
   <p>
    
     Next, remove the
    
    <strong class="source-inline">
     
      BeginPlay()
     
    </strong>
    
     implementation, which, as I previously said, won’t be needed.
    
    
     After that, add the
    
    
     
      constructor implementation:
     
    
   </p>
   <pre class="source-code">
ABaseGunBullet::ABaseGunBullet()
{
    PrimaryActorTick.bCanEverTick = false;
    InitialLifeSpan = 10.0f;
    CollisionComponent =       CreateDefaultSubobject&lt;USphereComponent&gt;(TEXT("Collision"));
    CollisionComponent-&gt;InitSphereRadius(20.0f);
    CollisionComponent-&gt;BodyInstance.      SetCollisionProfileName("BlockAll");
    CollisionComponent-&gt;OnComponentHit.AddDynamic(this,       &amp;ABaseGunBullet::OnHit);
    CollisionComponent-&gt;SetWalkableSlopeOverride       (FWalkableSlopeOverride(WalkableSlope_Unwalkable, 0.f));
    CollisionComponent-&gt;CanCharacterStepUpOn = ECB_No;
    RootComponent = CollisionComponent;
    ProjectileMovementComponent = 
      CreateDefaultSubobject&lt;UProjectileMovementComponent&gt;(TEXT         ("Projectile"));
    ProjectileMovementComponent-&gt;UpdatedComponent =       CollisionComponent;
    ProjectileMovementComponent-&gt;InitialSpeed = 1800.f;
    ProjectileMovementComponent-&gt;MaxSpeed = 1800.f;
    ProjectileMovementComponent-&gt;bRotationFollowsVelocity = true;
    ProjectileMovementComponent-&gt;ProjectileGravityScale = 0.f;
    MeshComponent =       CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT("Mesh"));
    MeshComponent-&gt;SetupAttachment(RootComponent);
    MeshComponent-&gt;SetRelativeRotation(FRotator(0.f, -90.f, 0.f));
    MeshComponent-&gt;SetRelativeScale3D(FVector(2.f, 2.f, 2.f));
   static ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;      StaticMeshAsset(
       TEXT("/Game/KayKit/PrototypeBits/Models/Bullet.Bullet"));
   if (StaticMeshAsset.Succeeded())
    {
       MeshComponent-&gt;SetStaticMesh(StaticMeshAsset.Object);
    }
}</pre>
   <p>
    
     Most of
    
    <a id="_idIndexMarker416">
    </a>
    
     the
    
    <a id="_idIndexMarker417">
    </a>
    
     aforementioned code has been addressed previously or is self-explanatory, although there are some important things to mention.
    
    
     The
    
    <strong class="source-inline">
     
      CollisionComponent
     
    </strong>
    
     collision profile name has been set to
    
    <strong class="source-inline">
     
      BlockAll
     
    </strong>
    
     , in order to get proper collisions; additionally, we have bound the
    
    <strong class="source-inline">
     
      OnComponentHit
     
    </strong>
    
     delegate to the
    
    <strong class="source-inline">
     
      OnHit()
     
    </strong>
    
     method, in order to react to any
    
    
     
      bullet collisions.
     
    
   </p>
   <p>
    
     We can now add the final method implementation, which will handle the bullet hitting
    
    
     
      any object:
     
    
   </p>
   <pre class="source-code">
void ABaseGunBullet::OnHit(UPrimitiveComponent* HitComp, AActor*   OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse,     const FHitResult&amp; Hit)
{
    if (OtherActor != nullptr &amp;&amp; OtherActor != this)
    {
       const auto DamageEvt = FDamageEvent();
       OtherActor-&gt;TakeDamage(1.f, DamageEvt, nullptr, nullptr);
    }
    Destroy();
}</pre>
   <p>
    
     As you can see, we just call the
    
    <strong class="source-inline">
     
      TakeDamage()
     
    </strong>
    
     method to the
    
    <strong class="source-inline">
     
      Actor
     
    </strong>
    
     object that has been hit and then we destroy the bullet.
    
    
     No need to worry about damage parameters in this game!
    
    
     They
    
    <a id="_idIndexMarker418">
    </a>
    
     aren’t the focus of this book, so you have the freedom to add your own damage logic and stick to it if you’d like.
    
    
     Feel free to customize the game to your
    
    
     
      heart’s content!
     
    
   </p>
   <p>
    
     Now that we’ve finalized the bullet class, it’s time to create a suitable target
    
    
     
      for it.
     
    
   </p>
   <h2 id="_idParaDest-174">
    <a id="_idTextAnchor176">
    </a>
    
     Implementing a Target class
    
   </h2>
   <p>
    
     We now
    
    <a id="_idIndexMarker419">
    </a>
    
     need to create a base actor that we will be using to implement a target for our shooting AI agent.
    
    
     So, let’s start by creating a new C++ class extending from
    
    <strong class="source-inline">
     
      Actor
     
    </strong>
    
     and call it
    
    <strong class="source-inline">
     
      BaseTarget
     
    </strong>
    
     .
    
    
     Once the class has been created, open up the
    
    <strong class="source-inline">
     
      BaseTarget.h
     
    </strong>
    
     
      header file.
     
    
   </p>
   <p>
    
     As a first step, add this forward declaration just after the
    
    <strong class="source-inline">
     
      #
     
    </strong>
    
     <strong class="source-inline">
      
       include
      
     </strong>
    
    
     
      section:
     
    
   </p>
   <pre class="source-code">
class UStaticMeshComponent;</pre>
   <p>
    
     Next, remove the
    
    <strong class="source-inline">
     
      BeginPlay()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Tick()
     
    </strong>
    
     functions as they won’t be needed, and add the following declarations just after the
    
    
     <strong class="source-inline">
      
       ABaseTarget()
      
     </strong>
    
    
     
      constructor:
     
    
   </p>
   <pre class="source-code">
protected:
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly,       Category="Projectile", meta=(AllowPrivateAccess="true"))
    UStaticMeshComponent* MeshComponent;
    virtual float TakeDamage(float DamageAmount, FDamageEvent const&amp;       DamageEvent, AController* EventInstigator, AActor* DamageCauser)         override;</pre>
   <p>
    
     Apart from the
    
    <strong class="source-inline">
     
      StaticMeshComponent
     
    </strong>
    
     property that will be used to show the target mesh, we have added the
    
    <strong class="source-inline">
     
      TakeDamage()
     
    </strong>
    
     declaration that will be used to handle hits
    
    
     
      from bullets.
     
    
   </p>
   <p>
    
     Now, open the
    
    <strong class="source-inline">
     
      BaseTarget.cpp
     
    </strong>
    
     file and, after removing the
    
    <strong class="source-inline">
     
      BeginPlay()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Tick()
     
    </strong>
    
     function implementations, change the constructor with the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
ABaseTarget::ABaseTarget()
{
    PrimaryActorTick.bCanEverTick = false;
    MeshComponent =       CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT("Mesh"));
    MeshComponent-&gt;SetupAttachment(RootComponent);
    MeshComponent-&gt;SetRelativeRotation(FRotator(0.f, -90.f, 0.f));
    RootComponent = MeshComponent;
    static ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;       StaticMeshAsset(
    TEXT("/Game/KayKit/PrototypeBits/Models/target_stand_B_target_      stand_B.target_stand_B_target_stand_B"));
    if (StaticMeshAsset.Succeeded())
    {
       MeshComponent-&gt;SetStaticMesh(StaticMeshAsset.Object);
    }
}</pre>
   <p>
    
     By now, you
    
    <a id="_idIndexMarker420">
    </a>
    
     should already be familiar with the previous code; after disabling the tick functionality for this actor, we proceeded to add and initialize a
    
    <strong class="source-inline">
     
      StaticMesh
     
    </strong>
    
     component, which will serve the purpose of displaying a target in
    
    
     
      our project.
     
    
   </p>
   <p>
    
     Now, add the
    
    <strong class="source-inline">
     
      TakeDamage()
     
    </strong>
    
     implementation to
    
    
     
      your file:
     
    
   </p>
   <pre class="source-code">
float ABaseTarget::TakeDamage(float DamageAmount, FDamageEvent const&amp;   DamageEvent, AController* EventInstigator,
    AActor* DamageCauser)
{
    Tags[0] = "Untagged";
    return DamageAmount;
}</pre>
   <p>
    
     As you can see, the
    
    <a id="_idIndexMarker421">
    </a>
    
     approach here is quite simple; we are merely using the
    
    <strong class="source-inline">
     
      Untagged
     
    </strong>
    
     keyword, which will invalidate the tag assigned to the parent object.
    
    
     This effectively renders it invisible to the behavior tree task we will be constructing later in this chapter.
    
    
     We don’t need to worry about damage logic; once a target has been it, it will just
    
    
     
      be invalidated.
     
    
   </p>
   <p>
    
     Now that all the base classes have been created, we are ready to implement the needed Blueprints, including a brand-new
    
    
     
      gunner character.
     
    
   </p>
   <h2 id="_idParaDest-175">
    <a id="_idTextAnchor177">
    </a>
    
     Creating the Blueprints
    
   </h2>
   <p>
    
     We
    
    <a id="_idIndexMarker422">
    </a>
    
     will proceed with the creation of the Blueprints that will be instrumental in generating the new AI gunner agent.
    
    
     Specifically, we will be working on the
    
    
     
      following components:
     
    
   </p>
   <ul>
    <li>
     
      The
     
     
      
       spawnable bullet
      
     
    </li>
    <li>
     
      
       The target
      
     
    </li>
    <li>
     
      The gunner
     
     
      
       character itself
      
     
    </li>
   </ul>
   <p>
    
     Let’s start by creating the
    
    
     
      bullet Blueprint.
     
    
   </p>
   <h3>
    
     Implementing the bullet Blueprint
    
   </h3>
   <p>
    
     The creation of
    
    <a id="_idIndexMarker423">
    </a>
    
     the bullet Blueprint is quite straightforward.
    
    
     Just follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Open the
     
     <strong class="source-inline">
      
       Blueprints
      
     </strong>
     
      folder in the Unreal Engine
     
     
      <strong class="bold">
       
        Content Drawer
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Right-click on it and select
     
     
      <strong class="bold">
       
        Blueprint Class
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      From the
     
     <strong class="bold">
      
       All Classes
      
     </strong>
     
      section,
     
     
      
       select
      
     
     
      <strong class="bold">
       
        BaseGunBullet
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Name the
     
     <a id="_idIndexMarker424">
     </a>
     
      new asset
     
     <strong class="source-inline">
      
       BP_GunBullet
      
     </strong>
     
      .
     
     
      <em class="italic">
       
        Figure 9
       
      </em>
     
     <em class="italic">
      
       .2
      
     </em>
     
      shows the final
     
     
      
       Blueprint class:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 9.2 – Gun bullet Blueprint" src="img/B31016_figure_09.02.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.2 – Gun bullet Blueprint
    
   </p>
   <h3>
    
     Implementing the target Blueprint
    
   </h3>
   <p>
    
     The
    
    <a id="_idIndexMarker425">
    </a>
    
     creation of the target Blueprint is almost identical to the bullet one; we just need to add a tag to the object.
    
    
     Do the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Open the
     
     <strong class="source-inline">
      
       Blueprints
      
     </strong>
     
      folder in the Unreal Engine
     
     
      <strong class="bold">
       
        Content Drawer
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Right-click on it and select
     
     
      <strong class="bold">
       
        Blueprint Class
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      From the
     
     <strong class="bold">
      
       All Classes
      
     </strong>
     
      section,
     
     
      
       select
      
     
     
      <strong class="bold">
       
        BaseTarget
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Name the new
     
     
      
       asset
      
     
     
      <strong class="source-inline">
       
        BP_Target
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      In the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, look for the
     
     <strong class="bold">
      
       Tags
      
     </strong>
     
      property in the
     
     <strong class="bold">
      
       Actor
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Advanced
      
     </strong>
     
      category and hit the
     
     <strong class="bold">
      
       +
      
     </strong>
     
      button to create a
     
     
      
       new tag.
      
     
    </li>
    <li>
     
      Name the tag
     
     <strong class="source-inline">
      
       ShootingTarget
      
     </strong>
     
      , as shown in
     
     
      <em class="italic">
       
        Figure 9
       
      </em>
     
     
      <em class="italic">
       
        .3
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 9.3 – Target tag" src="img/B31016_figure_09.03.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.3 – Target tag
    
   </p>
   <p>
    
     <em class="italic">
      
       Figure 9
      
     </em>
    
    <em class="italic">
     
      .4
     
    </em>
    
     shows
    
    <a id="_idIndexMarker426">
    </a>
    
     the final
    
    
     
      Blueprint class:
     
    
   </p>
   <div><div><img alt="Figure 9.4 – Target Blueprint" src="img/B31016_figure_09.04.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.4 – Target Blueprint
    
   </p>
   <h3>
    
     Implementing the gunner character Blueprint
    
   </h3>
   <p>
    
     It’s now time
    
    <a id="_idIndexMarker427">
    </a>
    
     to create the gunner character as a Blueprint.
    
    
     You are already familiar with the process, but here are the steps
    
    
     
      to follow:
     
    
   </p>
   <ol>
    <li>
     
      Open the
     
     <strong class="source-inline">
      
       Blueprints
      
     </strong>
     
      folder in the Unreal Engine
     
     
      <strong class="bold">
       
        Content Drawer
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Right-click on it and select
     
     
      <strong class="bold">
       
        Blueprint Class
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      From the
     
     <strong class="bold">
      
       All Classes
      
     </strong>
     
      section,
     
     
      
       select
      
     
     
      <strong class="bold">
       
        BaseDummyCharacter
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Name the new
     
     
      
       asset
      
     
     
      <strong class="source-inline">
       
        BP_GunnerDummy
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <p>
    
     We’ll add the AI controller later in this chapter, but we need to change a value in the Blueprint class in order to make our character properly work.
    
    
     So, open this Blueprint and, in the
    
    <strong class="bold">
     
      Details
     
    </strong>
    
     panel, locate the
    
    <strong class="bold">
     
      Use Controller Rotation Yaw
     
    </strong>
    
     attribute in the
    
    <strong class="bold">
     
      Pawn
     
    </strong>
    
     category; this will allow rotation of the character correctly when using AI logic later on.
    
    
     Tick the value, as depicted in
    
    
     <em class="italic">
      
       Figure 9
      
     </em>
    
    
     <em class="italic">
      
       .5
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 9.5 – Use Controller Rotation Yaw ticked" src="img/B31016_figure_09.05.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.5 – Use Controller Rotation Yaw ticked
    
   </p>
   <p>
    
     This value
    
    <a id="_idIndexMarker428">
    </a>
    
     will allow us to rotate the character through a task when shooting at
    
    
     
      a target.
     
    
   </p>
   <p>
    
     Now, it’s time to add a proper weapon to the character.
    
    
     To do this, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      With the Blueprint character class open, locate the
     
     <strong class="bold">
      
       Components
      
     </strong>
     
      panel and click the
     
     <strong class="bold">
      
       +
      
     </strong>
     
      <strong class="bold">
       
        Add
       
      </strong>
     
     
      
       button.
      
     
    </li>
    <li>
     
      Select
     
     <strong class="bold">
      
       UnrealAgilityArena
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Base Weapon
      
     </strong>
     
      to add this component to the
     
     
      
       Blueprint class.
      
     
    </li>
    <li>
     
      Select this newly added component and, in the
     
     <strong class="bold">
      
       Bullet
      
     </strong>
     
      category of the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, locate the
     
     <strong class="bold">
      
       Bullet Class
      
     </strong>
     
      attribute; from its dropdown,
     
     
      
       select
      
     
     
      <strong class="bold">
       
        BP_GunBullet
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <p>
    
     Now that we’ve got our character all primed and ready, it’s time to unleash its shooting prowess at
    
    
     
      our command!
     
    
   </p>
   <h3>
    
     Making the weapon shoot
    
   </h3>
   <p>
    
     To make the
    
    <a id="_idIndexMarker429">
    </a>
    
     shooting phase work properly, we will be
    
    <a id="_idIndexMarker430">
    </a>
    
     using
    
    <strong class="bold">
     
      Anim Notify
     
    </strong>
    
     – an event that can be synchronized with animation sequences – so that we can call the
    
    <strong class="source-inline">
     
      Shoot()
     
    </strong>
    
     function at a specific point along the
    
    
     
      animation timeline.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     You might be curious about why we’re implementing this particular system instead of directly calling the
    
    <strong class="source-inline">
     
      Shoot()
     
    </strong>
    
     function from any part of our code.
    
    
     Well, here’s the thing: the shoot animation has a duration, and the moment when the bullet should be spawned occurs somewhere within the animation.
    
    
     This is where an Anim Notify comes into play.
    
    
     By using
    
    <strong class="bold">
     
      Anim Notify
     
    </strong>
    
     , we can specify the exact moment within the animation when the bullet should
    
    
     
      be spawned.
     
    
   </p>
   <p>
    
     An
    
    <a id="_idIndexMarker431">
    </a>
    
     Anim Notify is
    
    <a id="_idIndexMarker432">
    </a>
    
     created by extending the
    
    <strong class="source-inline">
     
      AnimNotify
     
    </strong>
    
     class, so start by creating a new C++ class that extends
    
    <strong class="source-inline">
     
      AnimNotify
     
    </strong>
    
     and call it
    
    <strong class="source-inline">
     
      AnimNotify_Shoot
     
    </strong>
    
     .
    
    
     Once the files have been created, open the
    
    <strong class="source-inline">
     
      AnimNotify_Shoot.h
     
    </strong>
    
     header file and, as a first step, change the
    
    <strong class="source-inline">
     
      UCLASS()
     
    </strong>
    
     macro declaration to
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
UCLASS(const, hidecategories=Object, collapsecategories, Config = Game, meta=(DisplayName="Shoot"))</pre>
   <p>
    
     Without delving too deeply into the specifics, it is sufficient to say that these initialization settings are necessary for the class to
    
    
     
      function correctly.
     
    
   </p>
   <p>
    
     After that, add the following
    
    <strong class="source-inline">
     
      public
     
    </strong>
    
     declarations to
    
    
     
      the class:
     
    
   </p>
   <pre class="source-code">
public:
    UAnimNotify_Shoot();
   virtual void Notify(USkeletalMeshComponent* MeshComp,      UAnimSequenceBase* Animation, const FAnimNotifyEventReference&amp;        EventReference) override;</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      UAnimNotify_Shoot()
     
    </strong>
    
     declaration is the constructor, which is quite self-explanatory, while the
    
    <strong class="source-inline">
     
      Notify()
     
    </strong>
    
     declaration will be called when an Anim Notify
    
    
     
      is triggered.
     
    
   </p>
   <p>
    
     Now, open the
    
    <strong class="source-inline">
     
      AnimNotify_Shoot.cpp
     
    </strong>
    
     file and add the needed
    
    <strong class="source-inline">
     
      #include
     
    </strong>
    
     declarations at
    
    
     
      its top:
     
    
   </p>
   <pre class="source-code">
#include "BaseDummyCharacter.h"
#include "BaseWeaponComponent.h"</pre>
   <p>
    
     After that, add the
    
    
     
      constructor implementation:
     
    
   </p>
   <pre class="source-code">
UAnimNotify_Shoot::UAnimNotify_Shoot():Super()
{
#if WITH_EDITORONLY_DATA
    NotifyColor = FColor(222, 142, 142, 255);
#endif
}</pre>
   <p>
    
     While not
    
    <a id="_idIndexMarker433">
    </a>
    
     mandatory, this function allows you to customize the color of the notify label within the Unreal Engine Editor.
    
    
     It’s quite handy,
    
    
     
      isn’t it?
     
    
   </p>
   <p>
    
     On the other hand, the
    
    <strong class="source-inline">
     
      Notify()
     
    </strong>
    
     function holds significant importance for gameplay-related reasons, so add the following lines
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
void UAnimNotify_Shoot::Notify(USkeletalMeshComponent* MeshComp, UAnimSequenceBase* Animation,
                               const FAnimNotifyEventReference&amp; EventReference)
{
    if(MeshComp == nullptr) return;
    const auto Character = Cast&lt;ABaseDummyCharacter&gt;      (MeshComp-&gt;GetOwner());
    if(Character == nullptr) return;
    const auto WeaponComponent = Character-&gt;      GetComponentByClass&lt;UBaseWeaponComponent&gt;();
    if(WeaponComponent == nullptr) return;
    WeaponComponent-&gt;Shoot();
}</pre>
   <p>
    
     This function looks for a
    
    <strong class="source-inline">
     
      BaseWeaponComponent
     
    </strong>
    
     instance, if any, and calls the
    
    
     <strong class="source-inline">
      
       Shoot()
      
     </strong>
    
    
     
      function.
     
    
   </p>
   <p>
    
     Before adding this Anim Notify to the shoot animation, you will need to compile your project.
    
    
     Once the new class is available, look for the
    
    <strong class="bold">
     
      AM_1H_Shoot
     
    </strong>
    
     montage, which can be found in the
    
    
     <strong class="source-inline">
      
       Content/KayKit/PrototypeBits/Character/Animations
      
     </strong>
    
    
     
      folder.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     In Unreal Engine, a
    
    <strong class="bold">
     
      montage
     
    </strong>
    
     refers
    
    <a id="_idIndexMarker434">
    </a>
    
     to a specialized asset that allows you to create complex animations for characters or objects.
    
    
     Montages are commonly used for defining sequences of related animation.
    
    
     As montages are not part of this book’s focus, I have provided the needed ones
    
    
     
      for you.
     
    
   </p>
   <p>
    
     Once you have
    
    <a id="_idIndexMarker435">
    </a>
    
     opened the asset by double-clicking on it, you will notice that, in the asset timeline, there is a
    
    <strong class="bold">
     
      ShootNotify_C
     
    </strong>
    
     label; this is an empty placeholder I have provided for you to let you know where the notify should
    
    
     
      be placed.
     
    
   </p>
   <div><div><img alt="Figure 9.6 – Animation montage" src="img/B31016_figure_09.06.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.6 – Animation montage
    
   </p>
   <p>
    
     Right-click on that label and select
    
    <strong class="bold">
     
      Replace
     
    </strong>
    
     with
    
    <strong class="bold">
     
      Notify
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Shoot
     
    </strong>
    
     to add an
    
    
     <strong class="source-inline">
      
       AnimNotify_Shoot
      
     </strong>
    
    
     
      instance.
     
    
   </p>
   <div><div><img alt="Figure 9.7 – Shoot notify" src="img/B31016_figure_09.07.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.7 – Shoot notify
    
   </p>
   <p>
    
     Now, whenever your AI agent plays this montage, it will get a notification from the montage itself that will call the
    
    <strong class="source-inline">
     
      Shoot()
     
    </strong>
    
     function.
    
    
     Later in this chapter, we will be creating a
    
    <a id="_idIndexMarker436">
    </a>
    
     dedicated task for our AI agent behavior tree, in order to play the montage but, if you want to test things out, you can simply use the
    
    <strong class="bold">
     
      Play Montage
     
    </strong>
    
     node in the Event Graph of
    
    <strong class="bold">
     
      BP_GunnerDummyCharacter
     
    </strong>
    
     , as shown in
    
    
     <em class="italic">
      
       Figure 9
      
     </em>
    
    
     <em class="italic">
      
       .8
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 9.8 – Montage test" src="img/B31016_figure_09.08.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.8 – Montage test
    
   </p>
   <p>
    
     Just ensure to remove this node after completing your testing to prevent your AI agent from exhibiting seemingly
    
    
     
      erratic behaviors.
     
    
   </p>
   <p>
    
     In this section, I have provided insights on enhancing AI agents and behavior trees through best practices and tips from my own experience.
    
    
     Following that, we established the foundation for a more advanced AI agent capable of shooting.
    
    
     The upcoming section will focus on developing a custom decorator, adding a new layer of complexity to our project.
    
    
     Exciting developments lie ahead for
    
    
     
      our endeavor!
     
    
   </p>
   <h1 id="_idParaDest-176">
    <a id="_idTextAnchor178">
    </a>
    
     Understanding decorators
    
   </h1>
   <p>
    
     Decorators
    
    <a id="_idIndexMarker437">
    </a>
    
     provide a way to add additional functionality or conditions to the execution of a portion of a behavior tree.
    
    
     As you already know from previous chapters, decorators are attached to either a composite or a task node and determine whether a branch in the tree (or even a single node) can be executed.
    
    
     By combining decorators with composite nodes, you can create behavior trees with prioritized behavior allowing for powerful logic capable of handling intricate scenarios.
    
    
     In
    
    <a href="B31016_08.xhtml#_idTextAnchor148">
     
      <em class="italic">
       
        Chapter 8
       
      </em>
     
    </a>
    
     ,
    
    <em class="italic">
     
      Setting Up a Behavior Tree
     
    </em>
    
     , we used some built-in decorators but, in this section, I will give you more detailed information about creating your own
    
    
     
      custom decorators.
     
    
   </p>
   <h2 id="_idParaDest-177">
    <a id="_idTextAnchor179">
    </a>
    
     Explaining the BTAuxiliaryNode class
    
   </h2>
   <p>
    
     Both
    
    <a id="_idIndexMarker438">
    </a>
    
     decorators and services inherit from the
    
    <strong class="source-inline">
     
      BTAuxiliaryNode
     
    </strong>
    
     class, which
    
    <a id="_idIndexMarker439">
    </a>
    
     will let you implement the
    
    
     
      following functions:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       OnBecomeRelevant()
      
     </strong>
     
      : This will be called when the auxiliary node – the one the decorator or service is attached to –
     
     
      
       becomes active
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       OnCeaseRelevant()
      
     </strong>
     
      : This will be executed when the auxiliary node
     
     
      
       becomes inactive
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       TickNode()
      
     </strong>
     
      : This will be executed at each auxiliary
     
     
      
       node tick
      
     
    </li>
   </ul>
   <p>
    
     In
    
    <a href="B31016_08.xhtml#_idTextAnchor148">
     
      <em class="italic">
       
        Chapter 8
       
      </em>
     
    </a>
    
     ,
    
    <em class="italic">
     
      Setting Up a Behavior Tree
     
    </em>
    
     , I presented you with some of these functions, so it’s good to know where they
    
    
     
      come from.
     
    
   </p>
   <h2 id="_idParaDest-178">
    <a id="_idTextAnchor180">
    </a>
    
     Creating C++ decorators
    
   </h2>
   <p>
    
     A
    
    <a id="_idIndexMarker440">
    </a>
    
     decorator
    
    <a id="_idIndexMarker441">
    </a>
    
     extends from the
    
    <strong class="source-inline">
     
      BTDecorator
     
    </strong>
    
     class, and in C++, its main implementable functions are
    
    
     
      as follows:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       OnNodeActivation()
      
     </strong>
     
      : This is called when the underlying node
     
     
      
       is activated
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       OnNodeDeactivation()
      
     </strong>
     
      : This is called when the underlying node
     
     
      
       is deactivated
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       OnNodeProcessed()
      
     </strong>
     
      : This is called when the underlying node is deactivated or fails
     
     
      
       to activate
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       CalculateRawConditionalValue()
      
     </strong>
     
      : This computes the value of the decorator condition without considering the
     
     
      
       inverse condition
      
     
    </li>
   </ul>
   <p>
    
     Additionally, you can use the
    
    <strong class="source-inline">
     
      IsInversed()
     
    </strong>
    
     function to check whether the decorator will handle the inversed
    
    
     
      conditional value.
     
    
   </p>
   <h2 id="_idParaDest-179">
    <a id="_idTextAnchor181">
    </a>
    
     Creating Blueprint decorators
    
   </h2>
   <p>
    
     Whenever
    
    <a id="_idIndexMarker442">
    </a>
    
     creating a decorator with Blueprints
    
    <a id="_idIndexMarker443">
    </a>
    
     Visual Scripting, you should extend from the
    
    <strong class="source-inline">
     
      BTDecorator_BlueprintBase
     
    </strong>
    
     class, which includes some additional code logic and events, in order to better manage it.
    
    
     You can create a decorator in the usual way – from
    
    <strong class="bold">
     
      Content Drawer
     
    </strong>
    
     – or you can select the
    
    <strong class="bold">
     
      New Decorator
     
    </strong>
    
     button from the behavior tree graph, as shown in
    
    
     <em class="italic">
      
       Figure 9
      
     </em>
    
    
     <em class="italic">
      
       .9
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 9.9 – Decorator creation" src="img/B31016_figure_09.09.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.9 – Decorator creation
    
   </p>
   <p>
    
     The main
    
    <a id="_idIndexMarker444">
    </a>
    
     events you will have at your disposal when working with Blueprint-generated decorators are
    
    
     
      as follows:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Receive Execution Start AI
      
     </strong>
     
      : This is called when the underlying node
     
     
      
       is activated
      
     
    </li>
    <li>
     <strong class="bold">
      
       Receive Execution Finish AI
      
     </strong>
     
      : This is called when the underlying node has finished executing
     
     
      
       its logic
      
     
    </li>
    <li>
     <strong class="bold">
      
       Receive Tick AI
      
     </strong>
     
      : This is called on
     
     
      
       each tick
      
     
    </li>
   </ul>
   <div><div><img alt="Figure 9.10 – Decorator nodes" src="img/B31016_figure_09.10.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.10 – Decorator nodes
    
   </p>
   <p>
    
     By keeping this in mind, you will have the ability to implement your own Blueprint decorators for your
    
    
     
      AI agents.
     
    
   </p>
   <p>
    
     We are now going to implement our own decorator, one that will be checking a tag on
    
    
     
      an actor.
     
    
   </p>
   <h2 id="_idParaDest-180">
    <a id="_idTextAnchor182">
    </a>
    
     Implementing the CheckTagOnActor decorator
    
   </h2>
   <p>
    
     Now is
    
    <a id="_idIndexMarker445">
    </a>
    
     the perfect time to create
    
    <a id="_idIndexMarker446">
    </a>
    
     our first decorator.
    
    
     As you may recall, while implementing the
    
    <strong class="source-inline">
     
      BaseTarget
     
    </strong>
    
     class, we ensured that whenever a target gets hit, its tag is set to an undefined value.
    
    
     By implementing a decorator that checks an actor instance tag, we can determine whether the actor itself is a
    
    
     
      viable target.
     
    
   </p>
   <p>
    
     So, let’s start by creating a new C++ class extending
    
    <strong class="source-inline">
     
      BTDecorator
     
    </strong>
    
     , and let’s call it
    
    <strong class="source-inline">
     
      BTDecorator_CheckTagOnActor
     
    </strong>
    
     .
    
    
     Once the class has been created, open the
    
    <strong class="source-inline">
     
      BTDecorator_CheckTagOnActor.h
     
    </strong>
    
     file and add the
    
    
     
      following declarations:
     
    
   </p>
   <pre class="source-code">
protected:
   UBTDecorator_CheckTagOnActor();
   UPROPERTY(EditAnywhere, Category=TagCheck)
    FBlackboardKeySelector ActorToCheck;
   UPROPERTY(EditAnywhere, Category=TagCheck)
    FName TagName;
   virtual bool CalculateRawConditionValue(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory) const override;
   virtual void InitializeFromAsset(UBehaviorTree&amp; Asset) override;</pre>
   <p>
    
     As you can see, we will be using a Blackboard key value – the
    
    <strong class="source-inline">
     
      ActorToCheck
     
    </strong>
    
     one – to check whether its referred value has a tag equal to
    
    <strong class="source-inline">
     
      TagName
     
    </strong>
    
     .
    
    
     This check will be handled by the
    
    <strong class="source-inline">
     
      CalculateRawConditionValue()
     
    </strong>
    
     function.
    
    
     Additionally, we will need to initialize any asset-related data, and this is usually done in the
    
    <strong class="source-inline">
     
      InitializeFromAsset()
     
    </strong>
    
     function, which is inherited by the
    
    
     <strong class="source-inline">
      
       BTNode
      
     </strong>
    
    
     
      superclass.
     
    
   </p>
   <p>
    
     Now, open
    
    <a id="_idIndexMarker447">
    </a>
    
     the
    
    <strong class="source-inline">
     
      BTDecorator_CheckTagOnActor.cpp
     
    </strong>
    
     file to start implementing the functions.
    
    
     Let’s start by adding the needed
    
    <strong class="source-inline">
     
      #
     
    </strong>
    
     <strong class="source-inline">
      
       include
      
     </strong>
    
    
     
      files:
     
    
   </p>
   <pre class="source-code">
#include "BehaviorTree/BlackboardComponent.h"
#include "BehaviorTree/Blackboard/BlackboardKeyType_Object.h"</pre>
   <p>
    
     Next, let’s
    
    <a id="_idIndexMarker448">
    </a>
    
     implement
    
    
     
      the constructor:
     
    
   </p>
   <pre class="source-code">
UBTDecorator_CheckTagOnActor::UBTDecorator_CheckTagOnActor()
{
    NodeName = "Tag Condition";
    ActorToCheck.AddObjectFilter(this, GET_MEMBER_NAME_      CHECKED(UBTDecorator_CheckTagOnActor, ActorToCheck),         AActor::StaticClass());
    ActorToCheck.SelectedKeyName = FBlackboard::KeySelf;
}</pre>
   <p>
    
     What we are doing here, immediately after naming the node, holds significant importance.
    
    
     We are filtering key values to only allow
    
    <strong class="source-inline">
     
      Actor
     
    </strong>
    
     classes.
    
    
     This step ensures that only valid Blackboard keys related to actors will be accepted, maintaining the integrity and appropriateness of
    
    
     
      the inputs.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      CalculateRawConditionValue()
     
    </strong>
    
     function is going to be
    
    
     
      pretty straightforward:
     
    
   </p>
   <pre class="source-code">
bool UBTDecorator_CheckTagOnActor::CalculateRawConditionValue(UBehaviorTreeComponent&amp; OwnerComp,
                                                              uint8* NodeMemory) const
{
    const UBlackboardComponent* BlackboardComp = OwnerComp.      GetBlackboardComponent();
    if (BlackboardComp == nullptr) return false;
   const AActor* Actor = Cast&lt;AActor&gt;(BlackboardComp-     &gt;GetValue&lt;UBlackboardKeyType_Object&gt;(ActorToCheck.       SelectedKeyName));
    return Actor != nullptr &amp;&amp; Actor-&gt;ActorHasTag(TagName);
}</pre>
   <p>
    
     As you
    
    <a id="_idIndexMarker449">
    </a>
    
     can see, we retrieve the
    
    <a id="_idIndexMarker450">
    </a>
    
     Blackboard component and get the
    
    <strong class="source-inline">
     
      ActorToCheck
     
    </strong>
    
     key in order to check whether there is a valid
    
    <strong class="source-inline">
     
      Actor
     
    </strong>
    
     instance and whether it is tagged as
    
    
     
      a target.
     
    
   </p>
   <p>
    
     Now, implement the last
    
    
     
      required function:
     
    
   </p>
   <pre class="source-code">
void UBTDecorator_CheckTagOnActor::InitializeFromAsset(UBehaviorTree&amp; Asset)
{
    Super::InitializeFromAsset(Asset);
    if (const UBlackboardData* BBAsset = GetBlackboardAsset();       ensure(BBAsset))
    {
       ActorToCheck.ResolveSelectedKey(*BBAsset);
    }
}</pre>
   <p>
    
     This function retrieves the
    
    <strong class="source-inline">
     
      BlackboardData
     
    </strong>
    
     asset and resolves the selected key for
    
    <strong class="source-inline">
     
      ActorToCheck
     
    </strong>
    
     from
    
    
     
      that asset.
     
    
   </p>
   <p>
    
     In this section, you have been provided with more advanced information about decorators, including specific considerations for implementing them in C++ or Blueprints.
    
    
     Additionally, you have successfully created a custom decorator that will be utilized by our upcoming gunner AI agent.
    
    
     This custom decorator will play a crucial role in creating the behavior and decision-making capabilities of the AI gunner agent, further improving its performance
    
    
     
      and effectiveness.
     
    
   </p>
   <p>
    
     In the next section, I will be presenting you with some detailed information on how to
    
    
     
      implement services.
     
    
   </p>
   <h1 id="_idParaDest-181">
    <a id="_idTextAnchor183">
    </a>
    
     Understanding services
    
   </h1>
   <p>
    
     Since you
    
    <a id="_idIndexMarker451">
    </a>
    
     are already acquainted with services from previous chapters, I will now provide you with additional information to further enrich your understanding of this topic.
    
    
     Let’s explore these details to enhance your expertise in services within
    
    
     
      behavior trees.
     
    
   </p>
   <h2 id="_idParaDest-182">
    <a id="_idTextAnchor184">
    </a>
    
     Creating C++ services
    
   </h2>
   <p>
    
     A service
    
    <a id="_idIndexMarker452">
    </a>
    
     extends from the
    
    <strong class="source-inline">
     
      BTService
     
    </strong>
    
     class, and its main
    
    <a id="_idIndexMarker453">
    </a>
    
     implementable function is
    
    <strong class="source-inline">
     
      OnSearchStart()
     
    </strong>
    
     , which is executed when the behavior tree search enters the underlying branch.
    
    
     You can use this to create some kind of initialization
    
    
     
      if needed.
     
    
   </p>
   <p>
    
     Furthermore, it is important to remember that services extend the
    
    <strong class="source-inline">
     
      BTAuxiliaryNode
     
    </strong>
    
     class, thereby inheriting all of its functions.
    
    
     One particularly crucial function inherited by services is the
    
    <strong class="source-inline">
     
      TickNode()
     
    </strong>
    
     function, which plays a vital role in the implementation of services, as it governs the execution and periodic updating of the service node within the
    
    
     
      behavior tree.
     
    
   </p>
   <h2 id="_idParaDest-183">
    <a id="_idTextAnchor185">
    </a>
    
     Creating Blueprint services
    
   </h2>
   <p>
    
     When
    
    <a id="_idIndexMarker454">
    </a>
    
     creating
    
    <a id="_idIndexMarker455">
    </a>
    
     a service using Blueprints Visual Scripting, it is advisable to extend from the
    
    <strong class="source-inline">
     
      BTService_BlueprintBase
     
    </strong>
    
     class as it provides additional code logic and events that facilitate better management of the service itself.
    
    
     Similar to decorators, there are two ways to create a
    
    <a id="_idIndexMarker456">
    </a>
    
     service: the conventional method, which involves using
    
    <strong class="bold">
     
      Content Drawer
     
    </strong>
    
     , or selecting the
    
    <strong class="bold">
     
      New Service
     
    </strong>
    
     button directly from the behavior tree graph, as shown in
    
    
     <em class="italic">
      
       Figure 9
      
     </em>
    
    
     <em class="italic">
      
       .11
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 9.11 – Service creation" src="img/B31016_figure_09.11.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.11 – Service creation
    
   </p>
   <p>
    
     The main
    
    <a id="_idIndexMarker457">
    </a>
    
     events you will have at your disposal when working with Blueprint-generated services are
    
    
     
      as follows:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Receive Activation AI
      
     </strong>
     
      : This is called when the service
     
     
      
       becomes active
      
     
    </li>
    <li>
     <strong class="bold">
      
       Receive Deactivation AI
      
     </strong>
     
      : This is called when the service
     
     
      
       becomes inactive
      
     
    </li>
    <li>
     <strong class="bold">
      
       Receive Search Start AI
      
     </strong>
     
      : This is called when the behavior tree search enters the
     
     
      
       underlying branch
      
     
    </li>
    <li>
     <strong class="bold">
      
       Receive Tick AI
      
     </strong>
     
      : This is called on
     
     
      
       each tick
      
     
    </li>
   </ul>
   <div><div><img alt="Figure 9.12 – Service nodes" src="img/B31016_figure_09.12.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.12 – Service nodes
    
   </p>
   <p>
    
     With this in mind, you will have the ability to implement your own Blueprint services for your
    
    
     
      behavior trees.
     
    
   </p>
   <p>
    
     With this new knowledge at our disposal, let’s implement a new service that will let us handle the
    
    
     
      ammo state.
     
    
   </p>
   <h2 id="_idParaDest-184">
    <a id="_idTextAnchor186">
    </a>
    
     Implementing the SetAmmo service
    
   </h2>
   <p>
    
     We are
    
    <a id="_idIndexMarker458">
    </a>
    
     now ready to start implementing our own service; you already have created a couple of them in
    
    <a href="B31016_08.xhtml#_idTextAnchor148">
     
      <em class="italic">
       
        Chapter 8
       
      </em>
     
    </a>
    
     ,
    
    <em class="italic">
     
      Setting Up a Behavior Tree
     
    </em>
    
     , so you should be already familiar with some of the
    
    
     
      presented steps.
     
    
   </p>
   <p>
    
     In this case, we
    
    <a id="_idIndexMarker459">
    </a>
    
     will need a service that will allow us to tell the Blackboard when a weapon has fired – and so needs reloading – or is ready to shoot.
    
    
     As usual, let’s start by creating a new C++ class extending from
    
    <strong class="source-inline">
     
      BT_Service
     
    </strong>
    
     and call it
    
    <strong class="source-inline">
     
      BTService_SetAmmo
     
    </strong>
    
     .
    
    
     Once it has been created, open the
    
    <strong class="source-inline">
     
      BTService_SetAmmo.h
     
    </strong>
    
     file and add the
    
    
     
      following declarations:
     
    
   </p>
   <pre class="source-code">
public:
    UBTService_SetAmmo();
protected:
    UPROPERTY(BlueprintReadOnly, EditAnywhere, Category="Blackboard")
    FBlackboardKeySelector NeedsReload;
    UPROPERTY(BlueprintReadOnly, EditAnywhere, Category="Blackboard")
    bool bKeyValue = false;
    virtual void OnBecomeRelevant(UBehaviorTreeComponent&amp; OwnerComp,       uint8* NodeMemory) override;</pre>
   <p>
    
     You should already be familiar with most of the code here; let’s just say that we will be using a
    
    <strong class="source-inline">
     
      NeedsReload
     
    </strong>
    
     Blackboard key as a
    
    <strong class="source-inline">
     
      bool
     
    </strong>
    
     value to see whether the weapon ammo is depleted or not.
    
    
     Now, open the
    
    <strong class="source-inline">
     
      BTService_SetAmmo.cpp
     
    </strong>
    
     file and add the following
    
    <strong class="source-inline">
     
      #include
     
    </strong>
    
     declaration at the top
    
    
     
      of it:
     
    
   </p>
   <pre class="source-code">
#include "BehaviorTree/BlackboardComponent.h"</pre>
   <p>
    
     The constructor is going to be pretty straightforward as we want the service tick to be disabled and we want to execute it just when it
    
    
     
      becomes relevant:
     
    
   </p>
   <pre class="source-code">
UBTService_SetAmmo::UBTService_SetAmmo()
{
    NodeName = "SetAmmo";
    bCreateNodeInstance = true;
    bNotifyBecomeRelevant = true;
    bNotifyTick = false;
}</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      OnBecomeRelevant()
     
    </strong>
    
     function
    
    <a id="_idIndexMarker460">
    </a>
    
     will serve us just to set
    
    <a id="_idIndexMarker461">
    </a>
    
     the Blackboard
    
    
     
      key value:
     
    
   </p>
   <pre class="source-code">
void UBTService_SetAmmo::OnBecomeRelevant(UBehaviorTreeComponent&amp;   OwnerComp, uint8* NodeMemory)
{
    const auto BlackboardComp = OwnerComp.GetBlackboardComponent();
    if (BlackboardComp == nullptr) return;
    BlackboardComp-&gt;SetValueAsBool(NeedsReload.SelectedKeyName,       bKeyValue);
}</pre>
   <p>
    
     In this section, you have been provided with additional information about services, including specific considerations for implementing them in C++ or Blueprints.
    
    
     Additionally, you have successfully created another custom service that will be used to handle your AI agent’s
    
    
     
      gun ammo.
     
    
   </p>
   <p>
    
     In the next section, I will be presenting you with detailed information on how to implement tasks as we will be creating a couple more for our soon-to-be
    
    
     
      gunner agent.
     
    
   </p>
   <h1 id="_idParaDest-185">
    <a id="_idTextAnchor187">
    </a>
    
     Understanding tasks
    
   </h1>
   <p>
    
     In this section, I will
    
    <a id="_idIndexMarker462">
    </a>
    
     provide you with additional information to enhance your understanding of tasks.
    
    
     Let’s explore these details together to further strengthen your grasp of tasks within the context of
    
    
     
      behavior trees.
     
    
   </p>
   <h2 id="_idParaDest-186">
    <a id="_idTextAnchor188">
    </a>
    
     Creating C++ tasks
    
   </h2>
   <p>
    
     A task
    
    <a id="_idIndexMarker463">
    </a>
    
     extends from the
    
    <strong class="source-inline">
     
      BTTask
     
    </strong>
    
     class, and its main implementable
    
    <a id="_idIndexMarker464">
    </a>
    
     functions are
    
    
     
      as follows:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       ExecuteTask()
      
     </strong>
     
      : This will start the task execution and will return the
     
     
      
       task result
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       AbortTask()
      
     </strong>
     
      : This will let you handle events where a task should
     
     
      
       be stopped
      
     
    </li>
   </ul>
   <p>
    
     This is usually all you need to create even a simple yet fully
    
    
     
      working task.
     
    
   </p>
   <h2 id="_idParaDest-187">
    <a id="_idTextAnchor189">
    </a>
    
     Creating Blueprint tasks
    
   </h2>
   <p>
    
     When
    
    <a id="_idIndexMarker465">
    </a>
    
     creating a task using Blueprints Visual Scripting, you
    
    <a id="_idIndexMarker466">
    </a>
    
     will be extending from the
    
    <strong class="source-inline">
     
      BTTask_BlueprintBase
     
    </strong>
    
     class as it provides additional code logic to facilitate its implementation.
    
    
     As you may have guessed, there are two ways to create a task: the usual creation from
    
    <strong class="bold">
     
      Content Drawer
     
    </strong>
    
     , and the
    
    <strong class="bold">
     
      New Task
     
    </strong>
    
     selection button directly from the behavior tree graph, as shown in
    
    
     <em class="italic">
      
       Figure 9
      
     </em>
    
    
     <em class="italic">
      
       .13
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 9.13 – Task creation" src="img/B31016_figure_09.13.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.13 – Task creation
    
   </p>
   <p>
    
     The main events you will have available when working with Blueprint-generated tasks are
    
    
     
      as follows:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Receive Execute AI
      
     </strong>
     
      : This is called when the task
     
     
      
       is executed
      
     
    </li>
    <li>
     <strong class="bold">
      
       Receive Abort AI
      
     </strong>
     
      : This is called when the task
     
     
      
       is aborted
      
     
    </li>
    <li>
     <strong class="bold">
      
       Receive Tick AI
      
     </strong>
     
      : This is called on
     
     
      
       each tick
      
     
    </li>
   </ul>
   <div><div><img alt="Figure 9.14 – Task nodes" src="img/B31016_figure_09.14.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.14 – Task nodes
    
   </p>
   <p>
    
     Keeping this in
    
    <a id="_idIndexMarker467">
    </a>
    
     mind, you will possess the capability to implement your own Blueprint tasks for your
    
    <a id="_idIndexMarker468">
    </a>
    
     behavior trees, and that’s exactly what we are going to do in the
    
    
     
      next steps.
     
    
   </p>
   <h2 id="_idParaDest-188">
    <a id="_idTextAnchor190">
    </a>
    
     Implementing the PlayMontage task
    
   </h2>
   <p>
    
     As you
    
    <a id="_idIndexMarker469">
    </a>
    
     already know, the shooting command for our AI agent is going to be controlled by an Anim Notify from an animation
    
    <a id="_idIndexMarker470">
    </a>
    
     montage.
    
    
     Unfortunately, there is no out-of-the-box task for executing montages from a behavior tree; a
    
    <strong class="bold">
     
      PlayAnimation
     
    </strong>
    
     task is present, but it will not serve our purposes as it won’t handle montages really well.
    
    
     Fortunately, with our existing strong understanding of tasks, implementing the code logic will be relatively straightforward.
    
    
     Furthermore, having a task that plays montages will prove highly beneficial when handling other animation sequences, such as reloading bullets or celebrating when all targets have been successfully hit.
    
    
     So, start by creating a new C++ class that extends
    
    <strong class="source-inline">
     
      BTTask
     
    </strong>
    
     and call it
    
    <strong class="source-inline">
     
      BTTask_PlayMontage
     
    </strong>
    
     .
    
    
     Inside the
    
    <strong class="source-inline">
     
      BTTask_PlayMontage.h
     
    </strong>
    
     file, add the following
    
    
     
      self-explanatory declarations:
     
    
   </p>
   <pre class="source-code">
public:
   UPROPERTY(EditAnywhere, Category="Dummy Task")
   UAnimMontage* AnimMontage;
   virtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent&amp;      OwnerComp, uint8* NodeMemory) override;</pre>
   <p>
    
     Inside the
    
    <strong class="source-inline">
     
      BTTask_PlayMontage.cpp
     
    </strong>
    
     file, add the
    
    
     
      following implementation:
     
    
   </p>
   <pre class="source-code">
EBTNodeResult::Type UBTTask_PlayMontage::ExecuteTask(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory)
{
    if(AnimMontage == nullptr) return EBTNodeResult::Failed;
    const auto Controller = OwnerComp.GetAIOwner();
    if(Controller == nullptr) return EBTNodeResult::Failed;
   const auto Character = Cast&lt;ACharacter&gt;     (Controller-&gt;GetCharacter());
    if(Character == nullptr) return EBTNodeResult::Failed;
    Character-&gt;PlayAnimMontage(AnimMontage, 1.f, FName("Default"));
    return EBTNodeResult::Succeeded;
}</pre>
   <p>
    
     This function
    
    <a id="_idIndexMarker471">
    </a>
    
     simply executes the
    
    <strong class="source-inline">
     
      PlayAnimMontage()
     
    </strong>
    
     function on the character, returning a
    
    <strong class="source-inline">
     
      Succeeded
     
    </strong>
    
     result.
    
    
     If any of the needed
    
    <a id="_idIndexMarker472">
    </a>
    
     references are not found, a
    
    <strong class="source-inline">
     
      Failed
     
    </strong>
    
     result
    
    
     
      is returned.
     
    
   </p>
   <p>
    
     With this task ready to go, we can implement a second one, the last one we will be needing in
    
    
     
      this chapter.
     
    
   </p>
   <h2 id="_idParaDest-189">
    <a id="_idTextAnchor191">
    </a>
    
     Implementing the FindAvailableTarget task
    
   </h2>
   <p>
    
     This task
    
    <a id="_idIndexMarker473">
    </a>
    
     will have the sole aim of finding an
    
    <a id="_idIndexMarker474">
    </a>
    
     available target by checking all actors with a predefined tag.
    
    
     There is nothing fancy here, but we will be needing it, so create a new C++ class inheriting from
    
    <strong class="source-inline">
     
      BBTask
     
    </strong>
    
     and call it
    
    <strong class="source-inline">
     
      BTTask_FindAvailableTarget
     
    </strong>
    
     .
    
    
     In the
    
    <strong class="source-inline">
     
      BTTask_FindAvailableTarget.h
     
    </strong>
    
     header file, add the
    
    
     
      following declarations:
     
    
   </p>
   <pre class="source-code">
public:
    UBTTask_FindAvailableTarget();
   UPROPERTY(EditAnywhere, Category="Blackboard")
    FBlackboardKeySelector TargetActor;
    UPROPERTY(EditAnywhere, Category="Dummy Task")
    FName TargetTag;
protected:
    virtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent&amp;       OwnerComp, uint8* NodeMemory) override;</pre>
   <p>
    
     No need
    
    <a id="_idIndexMarker475">
    </a>
    
     to
    
    <a id="_idIndexMarker476">
    </a>
    
     add explanations here, so let’s open the
    
    <strong class="source-inline">
     
      BTTask_FindAvailableTarget.cpp
     
    </strong>
    
     file and add the needed
    
    <strong class="source-inline">
     
      #
     
    </strong>
    
     <strong class="source-inline">
      
       include
      
     </strong>
    
    
     
      declarations:
     
    
   </p>
   <pre class="source-code">
#include "BehaviorTree/BlackboardComponent.h"
#include "Kismet/GameplayStatics.h"</pre>
   <p>
    
     The constructor is just going to filter the type entries for the
    
    
     <strong class="source-inline">
      
       TargetValue
      
     </strong>
    
    
     
      key:
     
    
   </p>
   <pre class="source-code">
UBTTask_FindAvailableTarget::UBTTask_FindAvailableTarget()
{
    NodeName = "Find Available Target";
    TargetActor.AddObjectFilter(this, GET_MEMBER_NAME_CHECKED(UBTTask_      FindAvailableTarget, TargetActor), AActor::StaticClass());
    TargetActor.SelectedKeyName = FBlackboard::KeySelf;
}</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      ExecuteTask()
     
    </strong>
    
     function will search through the level in order to find all
    
    <strong class="source-inline">
     
      Actor
     
    </strong>
    
     instances
    
    <a id="_idIndexMarker477">
    </a>
    
     correctly tagged and
    
    <a id="_idIndexMarker478">
    </a>
    
     return a random element from the list.
    
    
     Just add this piece
    
    
     
      of code:
     
    
   </p>
   <pre class="source-code">
EBTNodeResult::Type UBTTask_FindAvailableTarget::ExecuteTask   (UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory)
{
    const auto BlackboardComp = OwnerComp.GetBlackboardComponent();
    if (BlackboardComp == nullptr) { return EBTNodeResult::Failed; }
    TArray&lt;AActor*&gt; TargetList;
    UGameplayStatics::GetAllActorsWithTag(GetWorld(), TargetTag,       TargetList);
    if(TargetList.Num() == 0) { return EBTNodeResult::Failed; }
    const auto RandomTarget = TargetList[FMath::RandRange(0,       TargetList.Num() - 1)];
    BlackboardComp-&gt;SetValueAsObject(TargetActor.SelectedKeyName,       RandomTarget);
    return EBTNodeResult::Succeeded;
}</pre>
   <p>
    
     As you can see, a
    
    <strong class="source-inline">
     
      Succeeded
     
    </strong>
    
     result is returned if at least one
    
    <strong class="source-inline">
     
      Actor
     
    </strong>
    
     instance has
    
    
     
      been found.
     
    
   </p>
   <p>
    
     In this
    
    <a id="_idIndexMarker479">
    </a>
    
     section, we took a brief look at some of the key features of tasks and even added a couple more to our arsenal.
    
    
     It seems like we are now well-prepared to embark on our journey with the gunner AI character.
    
    
     While we are discussing this topic, it’s a great opportunity to
    
    <a id="_idIndexMarker480">
    </a>
    
     explain the proper techniques for debugging a behavior tree.
    
    
     So, let’s dive in and get started
    
    
     
      with it!
     
    
   </p>
   <h1 id="_idParaDest-190">
    <a id="_idTextAnchor192">
    </a>
    
     Debugging behavior trees
    
   </h1>
   <p>
    
     Debugging
    
    <a id="_idIndexMarker481">
    </a>
    
     behavior trees with Unreal Engine is essential for ensuring the smooth and efficient functioning of your AI-driven games.
    
    
     By carefully examining and analyzing the behavior tree’s execution, you can identify and resolve any issues or glitches that may arise during gameplay.
    
    
     You already have some understanding of how to enable the debugging tools in Unreal Engine.
    
    
     In this section, we will take a deep dive into the debugging feature specifically designed for behavior trees; before starting with the debugging tools, we’ll need to create a proper – and moderately complex –
    
    
     
      behavior tree.
     
    
   </p>
   <h2 id="_idParaDest-191">
    <a id="_idTextAnchor193">
    </a>
    
     Creating the Blackboard
    
   </h2>
   <p>
    
     The
    
    <a id="_idIndexMarker482">
    </a>
    
     Blackboard for the behavior tree is going to be straightforward; we need a couple of keys to keep a reference of the target and a flag to check whether the weapon needs reloading.
    
    
     So, let’s start by doing
    
    
     
      the following:
     
    
   </p>
   <ol>
    <li>
     
      Open
     
     <strong class="bold">
      
       Content Drawer
      
     </strong>
     
      and create a Blackboard asset in the
     
     
      <strong class="source-inline">
       
        Content/AI
       
      </strong>
     
     
      
       folder.
      
     
    </li>
    <li>
     
      Name the asset
     
     <strong class="source-inline">
      
       BB_GunnerDummy
      
     </strong>
     
      and
     
     
      
       open it.
      
     
    </li>
    <li>
     
      Create a new key of the
     
     <strong class="source-inline">
      
       bool
      
     </strong>
     
      type and name
     
     
      
       it
      
     
     
      <strong class="source-inline">
       
        NeedsReload
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Create a new key of the
     
     <strong class="source-inline">
      
       Object
      
     </strong>
     
      type and call
     
     
      
       it
      
     
     
      <strong class="source-inline">
       
        TargetActor
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <p>
    
     You may
    
    <a id="_idIndexMarker483">
    </a>
    
     remember that while creating the
    
    <strong class="source-inline">
     
      BTTask_FindAvailableTarget
     
    </strong>
    
     class, we decided to filter this key so that it will accept only the
    
    <strong class="source-inline">
     
      Actor
     
    </strong>
    
     type and not a generic
    
    <strong class="source-inline">
     
      Object
     
    </strong>
    
     one; this means you will need to set the base class for this key to an
    
    <strong class="source-inline">
     
      Actor
     
    </strong>
    
     type.
    
    
     To do this, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Select the
     
     <strong class="bold">
      
       TargetActor
      
     </strong>
     
      key and, in the
     
     <strong class="bold">
      
       Blackboard Details
      
     </strong>
     
      panel, open the
     
     <strong class="bold">
      
       Key Type
      
     </strong>
     
      option to show the
     
     <strong class="bold">
      
       Base
      
     </strong>
     
      <strong class="bold">
       
        Class
       
      </strong>
     
     
      
       attribute.
      
     
    </li>
    <li>
     
      From the
     
     <strong class="bold">
      
       Base Class
      
     </strong>
     
      dropdown, select
     
     <strong class="bold">
      
       Actor
      
     </strong>
     
      , as shown in
     
     
      <em class="italic">
       
        Figure 9
       
      </em>
     
     
      <em class="italic">
       
        .15
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 9.15 – Target Actor key" src="img/B31016_figure_09.15.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.15 – Target Actor key
    
   </p>
   <h2 id="_idParaDest-192">
    <a id="_idTextAnchor194">
    </a>
    
     Creating the behavior tree
    
   </h2>
   <p>
    
     The
    
    <a id="_idIndexMarker484">
    </a>
    
     behavior tree we are going to implement is going to have the
    
    
     
      following logic:
     
    
   </p>
   <ul>
    <li>
     
      If the AI character has a valid target, it will shoot at it and then reload
     
     
      
       the weapon
      
     
    </li>
    <li>
     
      If no target is set, it will try to find one in the level and set the
     
     
      
       proper key
      
     
    </li>
    <li>
     
      If no target is available in the level, it means all targets have been hit and the AI character will cheer
     
     
      
       with happiness
      
     
    </li>
   </ul>
   <p>
    
     Start by doing
    
    
     
      the following:
     
    
   </p>
   <ol>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       Content/AI
      
     </strong>
     
      folder, create a new
     
     <strong class="bold">
      
       Behavior Tree
      
     </strong>
     
      asset and call
     
     
      
       it
      
     
     
      <strong class="source-inline">
       
        BT_GunnerDummy
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      In the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, set the
     
     <strong class="bold">
      
       Blackboard Asset
      
     </strong>
     
      attribute
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        BB_GunnerDummy
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Connect a
     
     <strong class="bold">
      
       Selector
      
     </strong>
     
      node to the
     
     <strong class="bold">
      
       Root
      
     </strong>
     
      node and call it
     
     <strong class="source-inline">
      
       Root Selector
      
     </strong>
     
      , as shown in
     
     
      <em class="italic">
       
        Figure 9
       
      </em>
     
     
      <em class="italic">
       
        .16
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 9.16 – The Root Selector node" src="img/B31016_figure_09.16.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.16 – The Root Selector node
    
   </p>
   <p>
    
     As you may
    
    <a id="_idIndexMarker485">
    </a>
    
     remember, a selector node will execute the subtrees in sequence until one of them succeeds; this is exactly what we need to do in order to create our gunner
    
    
     
      AI logic.
     
    
   </p>
   <h3>
    
     Adding the shooting logic
    
   </h3>
   <p>
    
     The
    
    <a id="_idIndexMarker486">
    </a>
    
     shooting logic is going to be subdivided into two phases – shooting and reloading – so we are going to use another selector node.
    
    
     Let’s do
    
    
     
      the following:
     
    
   </p>
   <ol>
    <li>
     
      From
     
     <strong class="bold">
      
       Root Selector
      
     </strong>
     
      , add another selector node and name it
     
     
      <strong class="source-inline">
       
        Shoot Selector
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Right-click on it, add a
     
     <strong class="bold">
      
       CheckTagOnTarget
      
     </strong>
     
      decorator, and name it
     
     <strong class="source-inline">
      
       Is Actor
      
     </strong>
     
      <strong class="source-inline">
       
        a Target?
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Select this decorator and, in the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, do
     
     
      
       the following:
      
     
     <ul>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Actor to Check
        
       </strong>
       
        attribute
       
       
        
         to
        
       
       
        <strong class="bold">
         
          TargetActor
         
        </strong>
       
      </li>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Tag Name
        
       </strong>
       
        attribute
       
       
        
         to
        
       
       
        <strong class="bold">
         
          ShootingTarget
         
        </strong>
       
      </li>
     </ul>
    </li>
   </ol>
   <p>
    
     Basically, this selector will be executed only if there is a valid target in the
    
    <strong class="bold">
     
      TargetActor
     
    </strong>
    
     key of the Blackboard; if not,
    
    <strong class="bold">
     
      Root Selector
     
    </strong>
    
     will try executing the next subtree available.
    
    
     We need now to create the actual shooting logic, so start doing the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Add a sequence node to
     
     <strong class="bold">
      
       Shoot Selector
      
     </strong>
     
      and name it
     
     
      <strong class="source-inline">
       
        Shoot Sequence
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Right-click on it, add a
     
     <strong class="bold">
      
       Blackboard
      
     </strong>
     
      decorator, and name it
     
     
      <strong class="source-inline">
       
        Has Ammo?
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Select the decorator and, in the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, do
     
     
      
       the following:
      
     
     <ul>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Notify Observers
        
       </strong>
       
        attribute to
       
       <strong class="bold">
        
         On
        
       </strong>
       
        <strong class="bold">
         
          Value Change
         
        </strong>
       
      </li>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Key Query
        
       </strong>
       
        attribute to
       
       <strong class="bold">
        
         Is
        
       </strong>
       
        <strong class="bold">
         
          Not Set
         
        </strong>
       
      </li>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Blackboard Key
        
       </strong>
       
        attribute
       
       
        
         to
        
       
       
        <strong class="bold">
         
          NeedsReload
         
        </strong>
       
      </li>
     </ul>
     <p class="list-inset">
      
       This part
      
      <a id="_idIndexMarker487">
      </a>
      
       of the tree will execute only when the
      
      <strong class="bold">
       
        NeedsReload
       
      </strong>
      
       key is set to
      
      <strong class="bold">
       
        true
       
      </strong>
      
       ; otherwise, it will try to execute the next subtree.
      
      
       This portion of the tree graph should look like the one depicted in
      
      
       <em class="italic">
        
         Figure 9
        
       </em>
      
      
       <em class="italic">
        
         .17
        
       </em>
      
      
       
        :
       
      
     </p>
    </li>
   </ol>
   <div><div><img alt="Figure 9.17 – Starting shoot sequence" src="img/B31016_figure_09.17.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.17 – Starting shoot sequence
    
   </p>
   <p class="list-inset">
    
     Let’s add some nodes to
    
    
     <strong class="bold">
      
       Shoot Sequence
      
     </strong>
    
    
     
      :
     
    
   </p>
   <ol>
    <li value="4">
     
      Add a
     
     <strong class="bold">
      
       Rotate to Face BBEntry
      
     </strong>
     
      task and name it
     
     <strong class="source-inline">
      
       Rotate
      
     </strong>
     
      <strong class="source-inline">
       
        Towards Target
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Select this node and, in the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, set the
     
     <strong class="bold">
      
       Blackboard Key
      
     </strong>
     
      attribute
     
     
      
       to
      
     
     
      <strong class="bold">
       
        TargetActor
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      From
     
     <strong class="bold">
      
       Shoot Sequence
      
     </strong>
     
      , add a
     
     <strong class="bold">
      
       Play Montage
      
     </strong>
     
      task and name it
     
     <strong class="source-inline">
      
       Shoot Montage
      
     </strong>
     
      .
     
     
      Make sure that this task is at the right of the
     
     <strong class="bold">
      
       Rotate Towards Target
      
     </strong>
     
      task.
     
     
      In the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, set the
     
     <strong class="bold">
      
       Anim Montage
      
     </strong>
     
      attribute
     
     
      
       to
      
     
     
      <strong class="bold">
       
        AM_1H_Shoot
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Right-click on this task node, add a
     
     <strong class="bold">
      
       Set Ammo
      
     </strong>
     
      service, and name it
     
     
      <strong class="source-inline">
       
        Deplete Ammo
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Select this
     
     <a id="_idIndexMarker488">
     </a>
     
      service and do
     
     
      
       the following:
      
     
     <ul>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Needs Reload
        
       </strong>
       
        attribute
       
       
        
         to
        
       
       
        <strong class="bold">
         
          NeedsReload
         
        </strong>
       
      </li>
      <li>
       
        Check the
       
       <strong class="bold">
        
         Key
        
       </strong>
       
        <strong class="bold">
         
          Value
         
        </strong>
       
       
        
         attribute
        
       
      </li>
     </ul>
    </li>
    <li>
     
      From
     
     <strong class="bold">
      
       Shoot Sequence
      
     </strong>
     
      , add a
     
     <strong class="bold">
      
       Wait
      
     </strong>
     
      node and make sure that this task is at the right of the
     
     <strong class="bold">
      
       Shoot Montage
      
     </strong>
     
      task.
     
     
      Select the
     
     <strong class="bold">
      
       Wait
      
     </strong>
     
      node and do
     
     
      
       the following:
      
     
     <ul>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Wait Time
        
       </strong>
       
        attribute
       
       
        
         to
        
       
       
        <strong class="source-inline">
         
          2.0
         
        </strong>
       
      </li>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Random Deviation
        
       </strong>
       
        attribute
       
       
        
         to
        
       
       
        <strong class="source-inline">
         
          0.5
         
        </strong>
       
      </li>
     </ul>
    </li>
   </ol>
   <p>
    
     This portion of the behavior tree can be seen in
    
    
     <em class="italic">
      
       Figure 9
      
     </em>
    
    
     <em class="italic">
      
       .18
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 9.18 – Finished shoot sequence" src="img/B31016_figure_09.18.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.18 – Finished shoot sequence
    
   </p>
   <p>
    
     One of the great things about behavior trees is that when you give descriptive names to your nodes, you can quickly understand what’s happening at a glance.
    
    
     By naming your nodes in a way that accurately reflects their purpose or function, you create a clear and intuitive visual representation of
    
    
     
      your AI.
     
    
   </p>
   <p>
    
     We can now start creating the reload sequence for the gun.
    
    
     Let’s start by following
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      From
     
     <strong class="bold">
      
       Shoot Selector
      
     </strong>
     
      , add a new sequence node to the right of
     
     <strong class="bold">
      
       Shoot Sequence
      
     </strong>
     
      and name it
     
     
      <strong class="source-inline">
       
        Reload Sequence
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      From
     
     <strong class="bold">
      
       Reload Sequence
      
     </strong>
     
      , add a
     
     <strong class="bold">
      
       Play Montage
      
     </strong>
     
      task and name it
     
     <strong class="source-inline">
      
       Reload Montage
      
     </strong>
     
      .
     
     
      In the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, set the
     
     <strong class="bold">
      
       Anim Montage
      
     </strong>
     
      attribute
     
     
      
       to
      
     
     
      <strong class="bold">
       
        AM_1H_Reload
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Right-click
     
     <a id="_idIndexMarker489">
     </a>
     
      on this task node, add a
     
     <strong class="bold">
      
       Set Ammo
      
     </strong>
     
      service, and name it
     
     
      <strong class="source-inline">
       
        Refill Ammo
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Select this service and do
     
     
      
       the following:
      
     
     <ul>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Needs Reload
        
       </strong>
       
        attribute
       
       
        
         to
        
       
       
        <strong class="bold">
         
          NeedsReload
         
        </strong>
       
      </li>
      <li>
       
        Leave the
       
       <strong class="bold">
        
         Key Value
        
       </strong>
       
        
         attribute unchecked
        
       
      </li>
     </ul>
    </li>
    <li>
     
      From
     
     <strong class="bold">
      
       Reload Sequence
      
     </strong>
     
      , add a
     
     <strong class="bold">
      
       Wait
      
     </strong>
     
      node and make sure that this task is at the right of the
     
     <strong class="bold">
      
       Reload Montage
      
     </strong>
     
      task.
     
     
      Select the
     
     <strong class="bold">
      
       Wait
      
     </strong>
     
      node and do
     
     
      
       the following:
      
     
     <ul>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Wait Time
        
       </strong>
       
        attribute
       
       
        
         to
        
       
       
        <strong class="source-inline">
         
          3.0
         
        </strong>
       
       
        
         .
        
       
      </li>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Random Deviation
        
       </strong>
       
        attribute to
       
       <strong class="source-inline">
        
         0.5
        
       </strong>
       
        .
       
       
        This portion of the behavior tree can be seen in
       
       
        <em class="italic">
         
          Figure 9.19
         
        </em>
       
       
        
         :
        
       
      </li>
     </ul>
    </li>
   </ol>
   <div><div><img alt="Figure 9.19 – Reload sequence" src="img/B31016_figure_09.19.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.19 – Reload sequence
    
   </p>
   <p>
    
     Whenever we enter this portion of the tree, start the reload animation while setting the
    
    <strong class="bold">
     
      NeedsReload
     
    </strong>
    
     key to
    
    <strong class="bold">
     
      false
     
    </strong>
    
     , and we wait a bit before going on with the execution.
    
    
     With this portion of the behavior tree complete, we can implement the target
    
    
     
      search portion.
     
    
   </p>
   <h3>
    
     Finding an available target
    
   </h3>
   <p>
    
     Whenever there is no available target to shoot at,
    
    <strong class="bold">
     
      Root Selector
     
    </strong>
    
     will execute the next subtree; in this
    
    <a id="_idIndexMarker490">
    </a>
    
     case, we will be looking for a new viable target.
    
    
     To do this, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      From
     
     <strong class="bold">
      
       Root Selector
      
     </strong>
     
      , add a
     
     <strong class="bold">
      
       FindAvailableTarget
      
     </strong>
     
      task at the right of the
     
     <strong class="bold">
      
       Shoot
      
     </strong>
     
      <strong class="bold">
       
        Selector
       
      </strong>
     
     
      
       node.
      
     
    </li>
    <li>
     
      Select the task and do
     
     
      
       the following:
      
     
     <ul>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Target Actor
        
       </strong>
       
        attribute
       
       
        
         to
        
       
       
        <strong class="bold">
         
          TargetActor
         
        </strong>
       
      </li>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Target Tag
        
       </strong>
       
        attribute
       
       
        
         to
        
       
       
        <strong class="bold">
         
          ShootingTarget
         
        </strong>
       
      </li>
     </ul>
    </li>
   </ol>
   <p>
    
     <em class="italic">
      
       Figure 9
      
     </em>
    
    <em class="italic">
     
      .20
     
    </em>
    
     shows this portion of the
    
    
     
      behavior tree:
     
    
   </p>
   <div><div><img alt="Figure 9.20 – Find target task" src="img/B31016_figure_09.20.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.20 – Find target task
    
   </p>
   <p>
    
     It’s now time to add the third and last part of the behavior
    
    
     
      tree logic.
     
    
   </p>
   <h3>
    
     Finishing the AI logic
    
   </h3>
   <p>
    
     The
    
    <a id="_idIndexMarker491">
    </a>
    
     last portion of the code will be to make the AI character cheer when all targets have been hit.
    
    
     To do so, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      From
     
     <strong class="bold">
      
       Root Selector
      
     </strong>
     
      , add a sequence node at the right of the
     
     <strong class="bold">
      
       Find Available Target
      
     </strong>
     
      task and name it
     
     
      <strong class="source-inline">
       
        Cheer Sequence
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      From
     
     <strong class="bold">
      
       Cheer Sequence
      
     </strong>
     
      , add a
     
     <strong class="bold">
      
       Play Montage
      
     </strong>
     
      task and name it
     
     <strong class="source-inline">
      
       Cheer Montage
      
     </strong>
     
      .
     
     
      In the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, set the
     
     <strong class="bold">
      
       Anim Montage
      
     </strong>
     
      attribute
     
     
      
       to
      
     
     
      <strong class="bold">
       
        AM_Cheer
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      From
     
     <strong class="bold">
      
       Cheer Sequence
      
     </strong>
     
      , add a
     
     <strong class="bold">
      
       Wait
      
     </strong>
     
      node and make sure that this task is at the right of the
     
     <strong class="bold">
      
       Cheer Montage
      
     </strong>
     
      task.
     
     
      Select the
     
     <strong class="bold">
      
       Wait
      
     </strong>
     
      node and do
     
     
      
       the following:
      
     
     <ul>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Wait Time
        
       </strong>
       
        attribute
       
       
        
         to
        
       
       
        <strong class="source-inline">
         
          3.0
         
        </strong>
       
      </li>
      <li>
       
        Set the
       
       <strong class="bold">
        
         Random Deviation
        
       </strong>
       
        attribute
       
       
        
         to
        
       
       
        <strong class="source-inline">
         
          0.5
         
        </strong>
       
      </li>
     </ul>
    </li>
   </ol>
   <p>
    
     This part of
    
    <a id="_idIndexMarker492">
    </a>
    
     the graph should look like
    
    
     <em class="italic">
      
       Figure 9
      
     </em>
    
    
     <em class="italic">
      
       .21
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 9.21 – Cheer sequence" src="img/B31016_figure_09.21.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.21 – Cheer sequence
    
   </p>
   <p>
    
     Now that the behavior tree is finally complete, we can move forward by creating a dedicated
    
    
     
      AI controller.
     
    
   </p>
   <h2 id="_idParaDest-193">
    <a id="_idTextAnchor195">
    </a>
    
     Creating the AI controller
    
   </h2>
   <p>
    
     The AI controller
    
    <a id="_idIndexMarker493">
    </a>
    
     is going to be pretty simple; you’ll just need to do
    
    
     
      the following:
     
    
   </p>
   <ol>
    <li>
     
      Open
     
     <strong class="bold">
      
       Content Drawer
      
     </strong>
     
      and, in the
     
     <strong class="source-inline">
      
       Content/Blueprints
      
     </strong>
     
      folder, add a new Blueprint class extending
     
     <strong class="bold">
      
       BaseDummyAIController
      
     </strong>
     
      and name
     
     
      
       it
      
     
     
      <strong class="source-inline">
       
        AIGunnerDummyController
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Open it and, in the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, locate the
     
     <strong class="bold">
      
       Behavior Tree
      
     </strong>
     
      property and set its value
     
     
      
       to
      
     
     
      <strong class="bold">
       
        BT_GunnerDummy
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Open
     
     <strong class="bold">
      
       BP_GunnerDummyCharacter
      
     </strong>
     
      and, in the
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      panel, set the
     
     <strong class="bold">
      
       AI Controller Class
      
     </strong>
     
      attribute
     
     
      
       to
      
     
     
      <strong class="bold">
       
        AIDummyGunnerController
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <p>
    
     Now that we have the controller ready and the character all set up, it’s time to test and debug
    
    
     
      its behavior.
     
    
   </p>
   <h2 id="_idParaDest-194">
    <a id="_idTextAnchor196">
    </a>
    
     Debugging the behavior tree on a gym
    
   </h2>
   <p>
    
     To start
    
    <a id="_idIndexMarker494">
    </a>
    
     debugging the newly created behavior tree, let’s start by creating a new level.
    
    
     Let’s follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a level of your choice, starting from the Level Instances and Packed Level Actors I provided in the
     
     
      
       project template.
      
     
    </li>
    <li>
     
      Add a
     
     
      <strong class="bold">
       
        BP_GunnerDummyCharacter
       
      </strong>
     
     
      
       instance.
      
     
    </li>
    <li>
     
      Add one or more
     
     <strong class="bold">
      
       BP_Target
      
     </strong>
     
      instances so that your AI character will have a line of sight to them.
     
     
      My gym level is shown in
     
     
      <em class="italic">
       
        Figure 9
       
      </em>
     
     
      <em class="italic">
       
        .22
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 9.22 – Gym level" src="img/B31016_figure_09.22.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.22 – Gym level
    
   </p>
   <p>
    
     Once you test the level, the expected behavior is for the character to shoot at each target, reload after each shot, and cheer once all targets have been
    
    
     
      successfully hit.
     
    
   </p>
   <h3>
    
     Adding breakpoints
    
   </h3>
   <p>
    
     To test
    
    <a id="_idIndexMarker495">
    </a>
    
     your behavior tree, you can open it up and start the level simulation; you will see the active part of the tree, with nodes highlighted in yellow, as shown in
    
    
     <em class="italic">
      
       Figure 9
      
     </em>
    
    
     <em class="italic">
      
       .23
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 9.23 – Testing the tree" src="img/B31016_figure_09.23.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.23 – Testing the tree
    
   </p>
   <p>
    
     Sometimes, portions
    
    <a id="_idIndexMarker496">
    </a>
    
     of the graph will be executed really fast and you may not see whether a particular portion of the tree has been executed.
    
    
     To get a better understanding of what’s happening, you may add a breakpoint by right-clicking on a node and selecting
    
    <strong class="bold">
     
      Add Breakpoint
     
    </strong>
    
     , as shown in
    
    
     <em class="italic">
      
       Figure 9
      
     </em>
    
    
     <em class="italic">
      
       .24
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 9.24 – Adding a breakpoint" src="img/B31016_figure_09.24.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.24 – Adding a breakpoint
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     In Unreal Engine’s behavior tree, a
    
    <strong class="bold">
     
      breakpoint
     
    </strong>
    
     is a
    
    <a id="_idIndexMarker497">
    </a>
    
     debugging feature that allows you to pause the execution of the behavior tree at a specific node.
    
    
     When the execution reaches the breakpoint, the behavior tree execution is temporarily halted, giving you the opportunity to inspect the state of the AI character and analyze the flow of the behavior tree.
    
    
     Execution can be resumed at any time to get on with the behavior
    
    
     
      tree execution.
     
    
   </p>
   <p>
    
     When the
    
    <a id="_idIndexMarker498">
    </a>
    
     behavior tree is executed, it will pause at the breakpoint, providing a clear view of what is happening at that moment.
    
    
     By pausing the execution at specific breakpoints, you can gain valuable insights into the inner workings of the AI behavior and identify any issues or unexpected behaviors that need to be addressed.
    
    
     <em class="italic">
      
       Figure 9
      
     </em>
    
    <em class="italic">
     
      .25
     
    </em>
    
     shows a breakpoint positioned on the
    
    <strong class="bold">
     
      Find Available Target
     
    </strong>
    
     node, showing that the previous subtree failed while checking the
    
    <strong class="bold">
     
      Is Actor a
     
    </strong>
    
     <strong class="bold">
      
       Target?
      
     </strong>
    
    
     
      decorator:
     
    
   </p>
   <div><div><img alt="Figure 9.25 – Active breakpoint" src="img/B31016_figure_09.25.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.25 – Active breakpoint
    
   </p>
   <h3>
    
     Using the debugging tools
    
   </h3>
   <p>
    
     As you
    
    <a id="_idIndexMarker499">
    </a>
    
     may recall from
    
    <a href="B31016_06.xhtml#_idTextAnchor116">
     
      <em class="italic">
       
        Chapter 6
       
      </em>
     
    </a>
    
     ,
    
    <em class="italic">
     
      Optimizing the Navigation System
     
    </em>
    
     , Unreal Engine offers a range of debugging tools for the AI system.
    
    
     Behavior trees are no exception, and once you enable these tools, you will have the ability to analyze the situation by pressing the number
    
    <em class="italic">
     
      2
     
    </em>
    
     on your keyboard’s numpad.
    
    
     This feature allows you to gain insights into the behavior of the AI character and evaluate the execution of the behavior tree in real time.
    
    
     In
    
    
     <em class="italic">
      
       Figure 9
      
     </em>
    
    <em class="italic">
     
      .26
     
    </em>
    
     , we can observe a specific situation where the behavior tree is displayed on
    
    
     
      the screen:
     
    
   </p>
   <div><div><img alt="Figure 9.26 – Debugging tools" src="img/B31016_figure_09.26.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.26 – Debugging tools
    
   </p>
   <p>
    
     This visual
    
    <a id="_idIndexMarker500">
    </a>
    
     representation provides a clear view of the structure and flow of the behavior tree, allowing us to analyze and understand
    
    
     
      its organization.
     
    
   </p>
   <h1 id="_idParaDest-195">
    <a id="_idTextAnchor197">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this comprehensive chapter, I have provided you with additional information on creating more effective and efficient behavior trees.
    
    
     We began by discussing some best practices and then delved into the key features of decorators, services, and tasks.
    
    
     Furthermore, we explored the implementation of custom nodes tailored to specific requirements, culminating in the creation of a fully functional AI agent.
    
    
     To validate our work and take advantage of Unreal Engine’s robust debugging tools, we also developed a gym environment for
    
    
     
      thorough testing.
     
    
   </p>
   <p>
    
     Get ready for the next chapter because things are about to get even more packed with excitement!
    
    
     In this upcoming chapter, I’ll be unveiling the Unreal Perception System, where your AI agents will sharpen their senses and become more attentive than
    
    
     
      ever before!
     
    
   </p>
  </div>
 </body></html>