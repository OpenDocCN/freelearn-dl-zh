- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Improving Agents with the Perception System
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用感知系统改进代理
- en: The AI **Perception System** is a powerful tool in the Unreal Engine Gameplay
    Framework, as it allows AI-controlled actors to perceive and react to various
    stimuli in an environment. It provides a way for AI agents to become aware of
    the presence of other actors – such as players or enemies – through different
    senses such as sight, hearing, or touch. By properly configuring and using the
    Perception System, developers can create AI agents that respond appropriately
    to events in their surroundings. What’s more, this system allows developers to
    implement and configure custom senses tailored to their game’s specific needs.
    This flexibility enables developers to create unique and engaging AI experiences.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: AI **感知系统**是虚幻引擎游戏框架中的一个强大工具，因为它允许AI控制的演员感知并对其环境中的各种刺激做出反应。它为AI代理提供了一种通过不同的感官（如视觉、听觉或触觉）感知其他演员（如玩家或敌人）存在的方法。通过正确配置和使用感知系统，开发者可以创建能够对其周围事件做出适当反应的AI代理。更重要的是，这个系统允许开发者根据他们游戏的具体需求实现和配置定制的感官。这种灵活性使开发者能够创建独特且引人入胜的AI体验。
- en: In this chapter, we will be covering the main components of the Unreal Engine
    Perception System, starting with a bit of theory and then applying this newly
    acquired knowledge to a real-world example.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍虚幻引擎感知系统的主要组件，从一些理论开始，然后应用这些新获得的知识到实际案例中。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Presenting the Perception System
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍感知系统
- en: Adding perception to an agent
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为代理添加感知功能
- en: Debugging perception
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试感知
- en: Creating perception stimuli
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建感知刺激
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow along with the topics presented in this chapter, you should have completed
    the previous ones and understood their content.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中介绍的主题，您应该已经完成了前面的章节，并理解了它们的内容。
- en: 'Additionally, if you would prefer to begin with code from the companion repository
    for this book, you can download the **.zip** project files provided in this book’s
    companion project repository: [https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5](https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5)
    .'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您希望从本书的配套仓库开始编写代码，您可以下载本书配套项目仓库中提供的**.zip**项目文件：[https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5](https://github.com/PacktPublishing/Artificial-Intelligence-in-Unreal-Engine-5)。
- en: To download the files from the end of the last chapter, click the **Unreal Agility
    Arena –** **Chapter 09** **-** **End** link.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载最后一章末尾的文件，请点击**Unreal Agility Arena –** **第09章** **-** **结束**链接。
- en: Presenting the Perception System
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍感知系统
- en: 'Dr. Markus and Professor Viktoria seem to have a new chapter in their story:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 马库斯博士和维克托利亚教授似乎在他们的故事中开启了一个新的篇章：
- en: '*Dr. Markus and Professor Viktoria knew that allowing sophisticated synthetic
    beings such as their AI dummy puppets to roam unchecked could prove disastrous.
    Therefore, they started working tirelessly to develop an intricate network of
    hidden security cameras that could monitor the movements and actions of their
    creations at all times. With this vigilant surveillance system in place, they
    hoped to keep them under strict observation and maintain full control, ensuring
    the safety of their* *controversial research.*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*马库斯博士和维克托利亚教授知道，如果允许像他们的AI木偶这样的复杂合成生物不受限制地漫游，可能会造成灾难。因此，他们开始不知疲倦地开发一个复杂的隐藏摄像头网络，可以随时监控他们的创造物的移动和行动。有了这个警惕的监控系统，他们希望对他们进行严格的监督，保持完全的控制，确保他们*
    *有争议的研究* *的安全*。'
- en: One of the key components when creating intelligent and reactive AI agents in
    Unreal Engine is the AI Perception System; this powerful system allows AI controllers
    – and, consequently, AI agents – to perceive and respond to different stimuli
    in their virtual environment.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中创建智能和反应灵敏的AI代理时，AI感知系统是一个关键组件；这个强大的系统允许AI控制器——以及随之而来的AI代理——感知并对其虚拟环境中的不同刺激做出反应。
- en: At the core of the AI Perception System are **senses** and **stimuli** . A sense
    – such as sight or hearing – represents a way for an AI agent to perceive its
    surroundings and is configured to detect specific types of stimuli, which are
    sources of perception data emanating from other actors in the game world.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: AI感知系统的核心是**感官**和**刺激**。一个感官——如视觉或听觉——代表AI代理感知其环境的方式，并配置为检测特定类型的刺激，这些刺激是来自游戏世界中其他演员的感知数据源。
- en: As an example, *sight sense* is preconfigured to detect any visible pawn actors,
    while *damage sense* triggers when the associated AI controller’s pawn takes damage
    from an external source.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*视觉感官*预先配置为检测任何可见的演员，而*伤害感官*在关联的AI控制器的演员受到外部伤害时触发。
- en: Note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As a developer, you can create custom senses tailored to your game’s specific
    needs by extending the **AISense** class, if you are working with C++, or the
    **AISense_Blueprint** class, if you are working with Blueprints.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，您可以通过扩展**AISense**类（如果您使用C++）或**AISense_Blueprint**类（如果您使用蓝图）来创建针对您游戏特定需求定制的感官。
- en: AI Perception System components
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AI感知系统组件
- en: 'The AI Perception System consists of the following main classes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: AI感知系统由以下主要类组成：
- en: '**AIPerceptionSystem** : This is the core manager that keeps track of all AI
    stimuli sources.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AIPerceptionSystem**：这是核心管理器，负责跟踪所有AI刺激源。'
- en: '**AIPerceptionComponent** : This represents the AI agent’s mind and handles
    processing perceived stimuli. It needs to be attached to an AI controller to properly
    work.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AIPerceptionComponent**：这代表AI代理的头脑，负责处理感知刺激。它需要附加到AI控制器才能正常工作。'
- en: '**AIPerceptionStimuliSourceComponent** : This component is added to actors
    that can generate stimuli and is in charge of broadcasting perception data to
    listening elements.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AIPerceptionStimuliSourceComponent**：此组件添加到可以生成刺激的演员上，并负责向监听元素广播感知数据。'
- en: '**AIPerceptionSenseConfig** : This defines the properties of a specific sense,
    what actors can be perceived, and how perception decays over time or distance.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AIPerceptionSenseConfig**：这定义了特定感官的属性、可以感知的演员以及感知随时间或距离衰减的方式。'
- en: When an actor with **AIPerceptionStimuliSourceComponent** generates a stimulus,
    nearby **AIPerceptionComponents** detect it through their configured senses. This
    perceived data is then processed by the AI controller to trigger desired behaviors.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当具有**AIPerceptionStimuliSourceComponent**的演员生成刺激时，附近的**AIPerceptionComponents**通过其配置的感官检测它。然后，AI控制器处理这些感知数据以触发所需的行为。
- en: 'Once you have added **AIPerceptionComponent** to an AI controller, you will
    need to add one or more **AIPerceptionSenseConfig** elements in order to give
    your AI agent dedicated senses. *Figure 10* *.1* shows an example where perception
    is based on touch:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您将**AIPerceptionComponent**添加到AI控制器中，您需要添加一个或多个**AIPerceptionSenseConfig**元素，以便为您的AI代理提供专用的感官。*图10.1*展示了基于触觉的感知示例：
- en: '![Figure 10.1 – The touch sense config](img/Figure_10.1_B31016.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 触觉配置](img/Figure_10.1_B31016.jpg)'
- en: Figure 10.1 – The touch sense config
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 触觉配置
- en: From the previous screenshot, you may have noticed a **Dominant Sense** property;
    this property allows you to designate a specific sense that takes priority over
    others when determining the location of a sensed actor.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的屏幕截图，您可能已经注意到一个**主导感官**属性；此属性允许您指定一个在确定感知演员位置时优先于其他感官的特定感官。
- en: 'Let’s explore the available sense configs that, as mentioned earlier, define
    the properties of each specific sense:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索可用的感官配置，正如之前提到的，这些配置定义了每个特定感官的属性：
- en: AIPerceptionSenseConfig types
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AIPerceptionSenseConfig类型
- en: 'Unreal Engine offers a range of predefined **AIPerceptionSenseConfig** classes
    that are highly likely to meet your specific requirements. Let’s take a look at
    the available options:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine提供了一系列预定义的**AIPerceptionSenseConfig**类，这些类很可能满足您的特定需求。让我们看看可用的选项：
- en: '**AIDamag** e: Use this configuration if your AI agent needs to respond to
    damage events such as *Any Damage* , *Point Damage* , or *Radial Damage*'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AIDamage**：如果您的AI代理需要响应诸如*任何伤害*、*点伤害*或*径向伤害*等伤害事件，请使用此配置'
- en: '**AIHearing** : Use this configuration if you need to detect sounds generated
    in the surrounding environment'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AIHearing**：如果您需要检测周围环境中产生的声音，请使用此配置'
- en: '**AIPrediction** : Use this configuration when you need to predict the target
    actor location in the next few moments'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AIPrediction**：当您需要预测未来几秒钟的目标演员位置时，请使用此配置'
- en: '**AISight** : Use this configuration when you want your AI agent to see things
    in the level'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AISight**：当您希望您的AI代理在关卡中看到事物时，请使用此配置'
- en: '**AITeam** : Use this configuration if you want to notify the AI agent that
    some ally is nearby'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AITeam**：如果您想通知AI代理附近有盟友，请使用此配置'
- en: '**AITouch** : Use this configuration when the AI agent touches some other actor
    or, vice versa, when something is touching the AI agent'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AITouch**：当AI代理触摸其他演员或反过来，当其他事物触摸AI代理时，请使用此配置'
- en: Stimuli source
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刺激源
- en: The **AIPerceptionStimuliSourceComponent** class allows an actor to register
    itself as a source of stimuli for one or more senses. For instance, you can register
    an actor as a stimuli source for sight. This registration allows an AI agent to
    visually perceive the actor in the game level.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**AIPerceptionStimuliSourceComponent**类允许一个角色将自己注册为一个或多个感官的刺激源。例如，您可以将一个角色注册为视觉刺激源。这种注册允许AI代理在游戏关卡中视觉上感知到该角色。'
- en: A stimuli source can be registered – or unregistered – for a sense, making it
    detectable – or undetectable – by the Perception System.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个刺激源可以为一个感官注册或注销，使其可检测或不可检测，由感知系统检测。
- en: Note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The **Pawn** and **Character** classes in Unreal Engine are inherently visible
    to **AISight** perception due to their default behavior as stimuli sources. This
    design choice streamlines AI behavior development by eliminating the need to manually
    configure visibility for each character or pawn. However, if you want the AI to
    ignore specific characters, you’ll need to take additional steps to configure
    them accordingly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**Pawn**和**Character**类在Unreal Engine中作为刺激源具有默认行为，因此它们对**AISight**感知是固有的可见的。这种设计选择通过消除为每个角色或单位手动配置可见性的需要，简化了AI行为开发。然而，如果您想让AI忽略特定的角色，您需要采取额外的步骤来相应地配置它们。
- en: In this section, we were introduced to the Perception System and its main elements.
    In the next section, we will work on a fully functional AI agent that will let
    you sense other actors in your game.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了感知系统及其主要元素。在下一节中，我们将致力于开发一个功能齐全的AI代理，它将让您在游戏中感知到其他角色。
- en: Adding perception to an agent
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为代理添加感知
- en: In this section, we will create a new AI agent that will use the Perception
    System. We will create a security camera that will probe nearby surrounding areas,
    looking for some possible targets for the dummy gunner that we created in [*Chapter
    9*](B31016_09.xhtml#_idTextAnchor170) , *Extending Behavior Trees* . Think of
    it as some kind of infrared camera for a dark environment. Once the camera spots
    a target, it will tag it so that the gunner will be able to locate it in the environment.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个新的AI代理，它将使用感知系统。我们将创建一个安全摄像头，它将探测附近的周边区域，寻找我们创建的模拟炮手可能的目标[*第9章*](B31016_09.xhtml#_idTextAnchor170)
    ，*扩展行为树*。将其视为一种在黑暗环境中的红外摄像头。一旦摄像头发现目标，它将标记它，以便炮手能够在环境中定位它。
- en: We will start by creating an **Actor** class that will be used as the camera
    model.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个**Actor**类，它将被用作摄像头模型。
- en: Creating the BaseSecurityCam class
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建BaseSecurityCam类
- en: 'Even though we will be implementing the Perception System inside the AI controller,
    a nice model to display in the level will help your environment’s look and feel,
    so let’s start by creating a new C++ class, extending from the **Pawn** class
    and named **BaseSecurityCam** . Once the class has been created, open the **BaseSecurityCam.h**
    file and add the following forward declaration after the **#** **include** declarations:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们将在AI控制器中实现感知系统，但一个在关卡中显示的漂亮模型将有助于您环境的视觉效果，所以让我们首先创建一个新的C++类，从**Pawn**类扩展，命名为**BaseSecurityCam**。一旦创建了类，打开**BaseSecurityCam.h**文件，在**#**
    **include**声明之后添加以下前置声明：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, make the class a **Blueprintable** one by changing the **UCLASS()** macro
    to the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过将**UCLASS()**宏更改为以下内容，使该类成为**Blueprintable**：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After that, remove the **BeginPlay()** and **Tick()** declarations, as we won’t
    be using them.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，移除**BeginPlay()**和**Tick()**声明，因为我们不会使用它们。
- en: 'As a final step, add the following component declarations for the static meshes
    that will display the model just after the **GENERATED_BODY()** macro:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，在**GENERATED_BODY()**宏之后添加以下组件声明，用于显示模型：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can now open the **BaseSecurityCam.cpp** file to implement this class;
    as a first step, remove the **BeginPlay()** and **Tick()** functions. Then, locate
    the constructor and change this line of code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以打开**BaseSecurityCam.cpp**文件来实现这个类；作为第一步，移除**BeginPlay()**和**Tick()**函数。然后，找到构造函数并更改以下代码行：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Change it to this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 更改为以下内容：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, inside the constructor and just after the aforementioned line of code,
    add the following block of code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在构造函数和上述代码行之后，添加以下代码块：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You already know all about this from the previous chapters of the book, so I
    suppose there’s no need to explain it again. With the security camera model created,
    we can now implement the corresponding AI controller, along with its perception
    sense.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经从本书的前几章中了解了所有这些，所以我想没有必要再次解释。随着安全摄像头模型的创建，我们现在可以实现相应的 AI 控制器，以及其感知能力。
- en: Creating the BaseSecurityCamAIController class
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 BaseSecurityCamAIController 类
- en: 'To add a proper controller for the security camera, let’s create a C++ class
    extending **AIController** and name it **BaseSecurityCamAIController** . Once
    the class has been created, open the **BaseSecurityCamAIController.h** file and
    add the following forward declarations, just after the **#** **include** declarations:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个合适的摄像头控制器，让我们创建一个扩展 **AIController** 的 C++ 类，并将其命名为 **BaseSecurityCamAIController**。一旦创建了类，打开
    **BaseSecurityCamAIController.h** 文件，并在 **#** **include** 声明之后添加以下前置声明：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, make the class **Blueprintable** by changing the **UCLASS()** macro to
    the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过将 **UCLASS()** 宏更改为以下内容来使类 **Blueprintable**：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After that, add this block of code just after the already existing constructor
    declaration:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在现有的构造函数声明之后添加以下代码块：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You are already familiar with the behavior tree property and the **OnPosses()**
    function from [*Chapter 8*](B31016_08.xhtml#_idTextAnchor148) , *Setting Up a
    Behavior Tree* ; in addition, the **OnTargetPerceptionUpdate()** function will
    be used as an event handler when getting information from the Perception System.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经熟悉了行为树属性和来自 [*第8章*](B31016_08.xhtml#_idTextAnchor148) 的 **OnPosses()** 函数，*设置行为树*；此外，**OnTargetPerceptionUpdate()**
    函数将用作从感知系统获取信息时的事件处理程序。
- en: 'You can now open **BaseSecurityCamAIController.cpp** and add the following
    **#include** declarations to the top of the file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以打开 **BaseSecurityCamAIController.cpp** 并将以下 **#include** 声明添加到文件顶部：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, locate the constructor, and inside of it, add the following block of code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，定位构造函数，并在其中添加以下代码块：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, we are creating the sense config for the sight perception, along
    with some of its properties, such as **SightRadius** and **LoseSightRadius** ,
    which will determine the distance at which the Perception System can detect something
    and the distance at which detection will be lost, respectively. As redundant as
    these two attributes may seem, keep in mind that, once a target has been detected,
    it will be more difficult to lose perception of it, unless both attributes have
    the same value. **PeripheralVisionAngleDegrees** will handle the cone that will
    be used to check whether an actor is in the line of sight or not. Lastly, the
    **DetectionByAffiliation** property is used to handle whether the detected actor
    is an enemy, friend, or neutral; in this case, we want to check all of them in
    order to detect anything that is in the line of sight.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们正在为视觉感知创建感知配置，以及一些其属性，例如 **SightRadius** 和 **LoseSightRadius**，这将确定感知系统可以检测到某物的距离和检测将丢失的距离。尽管这两个属性可能看起来很冗余，但请记住，一旦检测到目标，就很难失去对其的感知，除非这两个属性具有相同的值。**PeripheralVisionAngleDegrees**
    将处理用于检查演员是否在视线中的锥形。最后，**DetectionByAffiliation** 属性用于处理检测到的演员是敌人、朋友还是中立；在这种情况下，我们想要检查所有这些，以便检测视线中的任何物体。
- en: 'Now, it’s time to add the actual perception component, so add the following
    piece of code just after the previous one:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候添加实际感知组件了，所以请在之前的代码之后添加以下代码段：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, we create the **AIPerceptionComponent** instance, and then we
    assign the previously created sight configuration. Lastly, we register to the
    **OnTargetPerceptionUpdated** delegate that will notify the component of any changes
    detected by the Perception System.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们创建了 **AIPerceptionComponent** 实例，然后我们分配了之前创建的视野配置。最后，我们注册到 **OnTargetPerceptionUpdated**
    代理，该代理将通知组件感知系统检测到的任何变化。
- en: 'Now, it’s time to implement the **OnPosses()** function, something that we
    already know how to handle:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候实现 **OnPosses()** 函数了，这是我们已知如何处理的：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The last step is to implement the event handler. To do so, add the following
    block of code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是实现事件处理程序。为此，请添加以下代码块：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This function first checks whether the target has already been tagged; in this
    case, it means that it has already been spotted. It then retrieves the ID of the
    sight sense, calling **GetSenseID()** , and checks whether the stimulus type is
    equal to the sight sense ID and whether the stimulus was successfully sensed.
    If both conditions are **true** , it initializes the **Tags** array, with the
    first element set to a value of **ShootingTarget** , in order to make it a viable
    target for the dummy gunner we have at our disposal.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先检查目标是否已被标记；在这种情况下，这意味着它已经被发现。然后它检索视觉感官的ID，调用**GetSenseID()**，并检查刺激类型是否等于视觉感官ID以及刺激是否被成功感知。如果两个条件都为**真**，它初始化**Tags**数组，第一个元素设置为**ShootingTarget**的值，以便使其成为我们可用的模拟枪手的有效目标。
- en: The security camera is now ready to go; we just need a nice environment to test
    it on.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 安全摄像头现在已准备就绪；我们只需要一个合适的环境来测试它。
- en: In this section, we’ve shown you how to properly create an AI agent, taking
    advantage of the Perception System. In the next section, we will test this agent
    and learn how to properly debug perception information.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们向您展示了如何正确创建AI代理，利用感知系统。在下一节中，我们将测试这个代理并学习如何在运行时正确调试感知信息。
- en: Debugging perception
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试感知
- en: It’s now time to test our perception logic and learn how to properly debug the
    Perception system at runtime. In order to do this, we will need to add some small
    improvements to the base dummy character. As previously mentioned, the **Pawn**
    and **Character** classes are already registered with sight stimuli, so we won’t
    need to implement this logic. However, we will need to handle damage, as we will
    be playing around with both **BP_RoamerDummyCharacter** and **BP_GunnerDummyCharacter**
    . It appears that exciting and enjoyable times are just around the corner!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候测试我们的感知逻辑并学习如何在运行时正确调试感知系统了。为了做到这一点，我们需要对基础模拟角色进行一些小的改进。如前所述，**Pawn**和**Character**类已经注册了视觉刺激，因此我们不需要实现此逻辑。然而，我们需要处理伤害，因为我们将在**BP_RoamerDummyCharacter**和**BP_GunnerDummyCharacter**上做一些实验。看起来激动人心且愉快的时光就在眼前！
- en: Enhancing the roamer behavior tree
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升漫游行为树
- en: The first step in improving our AI agents will be adding some logic to handle
    damage to the dummy roamer behavior tree. In particular, we want the AI agent
    to sit down when it is hit by a Nerf gun projectile. We will start by adding a
    new key to the dedicated Blackboard.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 改进我们的AI代理的第一步将是添加一些逻辑来处理模拟漫游行为树的伤害。特别是，我们希望当AI代理被 Nerf 枪弹击中时，它会坐下。我们将首先向专用黑板添加一个新键。
- en: Improving the Blackboard
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改进黑板
- en: 'A new flag is required for the Blackboard to effectively monitor and keep a
    record of the character that has been hit. So, open up the **BB_Dummy** asset
    and do the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 黑板需要一个新标志来有效地监控并记录被击中的角色。因此，打开**BB_Dummy**资产并执行以下操作：
- en: Click the **New Key** button, and from the dropdown menu, select **Bool** .
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**新建键**按钮，然后从下拉菜单中选择**布尔值**。
- en: Name the newly created key **IsHit** .
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的键命名为**IsHit**。
- en: As you already know, this will expose a new key available to the behavior tree;
    additionally the key will be exposed to the AI controller, as we will see later
    on.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，这将向行为树公开一个新键；此外，该键还将向AI控制器公开，正如我们稍后将看到的。
- en: Improving the behavior tree
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改进行为树
- en: 'The behavior tree needs to manage the AI agent being hit; in our case, we want
    to play a montage with the character sitting down, as it has been eliminated from
    the game. So, let’s start by opening the **BT_RoamerDummy** asset and doing the
    following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树需要管理被击中的AI代理；在我们的案例中，我们希望播放一个角色坐下的蒙太奇，因为它已经被从游戏中淘汰。所以，让我们先打开**BT_RoamerDummy**资产并执行以下操作：
- en: Right-click on the **Root Sequence** node and add a **Blackboard** decorator,
    naming it **Is** **Not Hit?** .
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**根序列**节点并添加一个**黑板**装饰器，命名为**是否被击中？**。
- en: 'With the decorator selected, do the following:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择装饰器后，执行以下操作：
- en: Set the **Notify Observer** attribute to **On** **Value Change**
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**通知观察者**属性设置为**值更改时**
- en: Set the **Observer aborts** attribute to **Self**
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**观察者中止**属性设置为**自身**
- en: Set the **Key Query** attribute to **Is** **Not Set**
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**键查询**属性设置为**未设置**
- en: Set the **Blackboard Key** attribute to **IsHit**
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**黑板键**属性设置为**IsHit**
- en: Rename the root sequence **In Game Sequence** and disconnect it from the **ROOT**
    node.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将根序列重命名为**游戏序列**并将其从**ROOT**节点断开连接。
- en: Add a **Selector** node to the **ROOT** node and name it **Root Selector** .
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个**选择器**节点添加到**根节点**，并将其命名为**根选择器**。
- en: Connect the **Root Selector** node to the **In Game** **Sequence** node.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**根选择器**节点连接到**游戏****序列**节点。
- en: Connect the **Root Selector** node to a **PlayMontage** task, and name the newly
    created node **Sit Montage** . This node should be at the right of the **In Game**
    **Sequence** node.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**根选择器**节点连接到一个**播放动作组**任务，并将新创建的节点命名为**坐动作组**。此节点应位于**游戏****序列**节点的右侧。
- en: 'With the **Sit Montage** node selected, set the **Anim Montage** attribute
    to **AM_Sit** . The modified portion of the behavior tree is depicted in *Figure
    10* *.2* :'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择**坐动作组**节点时，将**动画动作组**属性设置为**AM_Sit**。修改后的行为树部分如图*10*.*2*所示：
- en: '![Figure 10.2 – A modified behavior tree](img/Figure_10.2_B31016.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 修改后的行为树](img/Figure_10.2_B31016.jpg)'
- en: Figure 10.2 – A modified behavior tree
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 修改后的行为树
- en: As you can see, the behavior tree will keep on working as before, unless the
    AI agent has been hit; in that case, the character will sit down and stop wandering.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，行为树将继续按之前的方式工作，除非AI代理受到攻击；在这种情况下，角色将坐下并停止徘徊。
- en: It’s now time to improve the AI controller, in order to manage incoming damage.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候改进AI控制器，以便管理即将到来的伤害。
- en: Enhancing BaseDummyAIController
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强**BaseDummyAIController**
- en: The AI controller for any dummy character will need to handle any damage. We
    are handling all of this inside the AI controller instead of the character for
    the sake of simplicity; we will need to communicate with the Blackboard, and this
    is much simpler and more direct when done from the controller itself.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 任何木偶角色的AI控制器都需要处理任何伤害。为了简化，我们将在AI控制器内部而不是在角色内部处理所有这些；我们需要与黑板通信，而从控制器本身进行操作要简单得多和直接。
- en: 'Let’s start by opening the **BaseDummyAIController.h** file and adding the
    following declaration for the damage handler:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开**BaseDummyAIController.h**文件并添加以下声明开始，用于处理伤害：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, open the **BaseDummyAIController.cpp** file, and in the **OnPossess()**
    function, add the following line of code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开**BaseDummyAIController.cpp**文件，在**OnPossess()**函数中，添加以下代码行：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, add the following implementation:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加以下实现：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This function is called when a pawn associated with the AI controller is damaged;
    the function retrieves the Blackboard component of the AI controller and sets
    the **IsHit** key to a value of **true** . Then, it sets the first tag of the
    actor to a value of **Untagged** so that it won’t be a viable target anymore for
    the gunner dummy.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当与AI控制器关联的pawn受到伤害时，将调用此函数；该函数检索AI控制器的黑板组件，并将**IsHit**键设置为**true**。然后，它将演员的第一个标签设置为**未标记**，这样它就不再是枪手木偶的有效目标。
- en: With this AI controller all set up, it’s time to create a Blueprint for the
    security camera.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个AI控制器设置完成后，现在是时候为安全摄像头创建一个蓝图了。
- en: Creating security camera Blueprints
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建安全摄像头蓝图
- en: Now, get back to the Unreal Engine Editor, and after compilation has finished,
    create a Blueprint out of the **BaseSecurityCamAIController** class, naming it
    **AISecurityCamController** . You don’t need to add a behavior tree, as all the
    logic is handled inside the controller itself.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到Unreal Engine编辑器，编译完成后，从**BaseSecurityCamAIController**类创建一个蓝图，命名为**AISecurityCamController**。您不需要添加行为树，因为所有逻辑都在控制器内部处理。
- en: Now, create a Blueprint class from the **BaseSecurityCam** class, and name it
    **BP_SecurityCam** . Once it has been created, open it, and in the **Details**
    panel, locate the **AI Controller Class** attribute and set its value to **AISecurityCamController**
    .
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从**BaseSecurityCam**类创建一个蓝图类，并将其命名为**BP_SecurityCam**。一旦创建完成，打开它，在**详细信息**面板中找到**AI控制器类**属性，并将其值设置为**AISecurityCamController**。
- en: '![Figure 10.3 – The security cam Blueprint](img/Figure_10.3_B31016.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 安全摄像头蓝图](img/Figure_10.3_B31016.jpg)'
- en: Figure 10.3 – The security cam Blueprint
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 安全摄像头蓝图
- en: We have gathered all the necessary elements to bring our new gym to life, and
    we are ready to take the next steps and start the process of debugging the Perception
    System.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经收集了所有必要的元素来让我们的新健身房焕发生机，我们现在准备采取下一步并开始调试感知系统的过程。
- en: Creating the gym
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建健身房
- en: 'We are now going to create a level to test and debug everything. We want to
    achieve this kind of behavior:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个关卡来测试和调试一切。我们希望实现以下行为：
- en: One or more AI agents will move around the level
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个AI代理将在关卡中移动
- en: A security cam will try to spot AI agents and tag them as viable targets
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全摄像头会尝试识别 AI 代理并将它们标记为可攻击的目标
- en: A gunner will wait for the AI agents to be tagged, in order to shoot at them
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枪手将等待 AI 代理被标记，以便射击它们
- en: 'So, let’s start by creating the gym:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先创建健身房：
- en: Create a level of your choice, starting from the Level Instances and Packed
    Level Actors I provided in the project template.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个您选择的级别，从项目模板中提供的 Level Instances 和 Packed Level Actors 开始。
- en: Add a **NavMeshBoundsVolume** actor so that it will cover all the walkable areas.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 **NavMeshBoundsVolume** 角色以使其覆盖所有可通行区域。
- en: Add some obstacles to make things more interesting.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些障碍物以使事情更有趣。
- en: Add a **BP_GunnerDummyCharacter** instance to the level.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向级别中添加一个 **BP_GunnerDummyCharacter** 实例。
- en: Add one or more **BP_RoamerDummyCharacter** instances.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个或多个 **BP_RoamerDummyCharacter** 实例。
- en: Add some **NS_Target** Niagara actors that will work as target points for the
    pathfinding system; just remember to tag them **TargetPoint** . Make sure that
    the path will bring the AI agents in the line of sight of the gunner.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些 **NS_Target** Niagara 角色作为路径查找系统的目标点；只需记住将它们标记为 **TargetPoint**。确保路径将 AI
    代理带到枪手的视线中。
- en: 'Add one or more **BP_SecurityCam** instances to the walls. The final result
    should be similar to *Figure 10* *.4* :'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向墙壁添加一个或多个 **BP_SecurityCam** 实例。最终结果应类似于 *图 10* *.4*：
- en: '![Figure 10.4 – The gym](img/Figure_10.4_B31016.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – 健身房](img/Figure_10.4_B31016.jpg)'
- en: Figure 10.4 – The gym
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 健身房
- en: 'Considering the type of scenario, where the gunner character will shoot at
    targets located by the security camera, I have decided to make the gym a bit juicier
    by adding a post-process volume that simulates an infra-red scenario, as depicted
    in *Figure 10* *.5* :'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到场景类型，枪手角色将向安全摄像头定位的目标射击，我决定通过添加模拟红外场景的后处理体积来使健身房更具吸引力，如图 *图 10* *.5* 所示：
- en: '![Figure 10.5 – The gym with a post-process volume](img/Figure_10.5_B31016.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – 后处理体积的健身房](img/Figure_10.5_B31016.jpg)'
- en: Figure 10.5 – The gym with a post-process volume
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 后处理体积的健身房
- en: This is obviously not mandatory, and you are free to set your post-process environment
    as you wish.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然不是强制性的，您可以自由设置您想要的后期处理环境。
- en: Now that the gym is finished, it’s time to start testing it and learn how to
    debug the Perception System.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在健身房已经完成，是时候开始测试它并学习如何调试感知系统了。
- en: Enabling perception debugging
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用感知调试
- en: 'If you start the simulation, you should see the following things happening:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您开始模拟，您应该看到以下事情发生：
- en: As the roamers wander around, the gunner, unaware of their presence, will cheer
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当漫游者四处游荡时，枪手由于没有意识到他们的存在，会欢呼
- en: As soon as one of the roamers enters the camera’s line of sight, the gunner
    will start aiming at it
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦某个漫游者进入摄像头的视线，枪手就会开始瞄准它
- en: Every time a roamer is hit, it will sit down and stop wandering
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当漫游者被击中时，它就会坐下并停止游荡
- en: You can tweak the security camera parameters to make it more or less attentive
    to what’s happening in the level.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以调整安全摄像头的参数，使其对级别中发生的事情更加或更少关注。
- en: At this point, you might be curious about how we determine whether an agent
    is in the camera’s line of sight. Well, it’s actually quite simple to observe
    once you enable the debugging tools!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您可能会好奇我们是如何确定代理是否在摄像头的视线中的。好吧，一旦启用调试工具，观察这一点实际上非常简单！
- en: So, let’s start by enabling the debugging tools, as explained in [*Chapter 6*](B31016_06.xhtml#_idTextAnchor116)
    , *Optimizing the* *Navigation Mesh* .
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先启用调试工具，如 [*第 6 章*](B31016_06.xhtml#_idTextAnchor116) 中所述，*优化导航网格*。
- en: Note
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Once the simulation starts, you may be wondering why the security camera has
    a tiny red icon on top of it, while all the dummy puppets have a green one, as
    displayed in *Figure 10* *.6* . When the AI debugging tools are enabled, a green
    icon is displayed if a pawn has some AI logic set up and running; otherwise, the
    icon will be red. In our case, the security cam is possessed by a dedicated AI
    controller, but it has no behavior tree, so the icon will be red.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开始模拟，您可能会想知道为什么安全摄像头顶部有一个小红图标，而所有虚拟木偶都有一个绿色图标，如图 *图 10* *.6* 所示。当启用 AI 调试工具时，如果
    pawn 设置并运行了某些 AI 逻辑，则显示绿色图标；否则，图标将是红色。在我们的情况下，安全摄像头被一个专门的 AI 控制器控制，但没有行为树，所以图标将是红色。
- en: '![img](img/Figure_10.6_B31016.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/Figure_10.6_B31016.jpg)'
- en: Figure 10 .6 – AI icons
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – AI 图标
- en: 'Now, while the simulation is going on, select a security camera and enable
    the **Perception** and **Perception System** tools by pressing the *4* and *5*
    keys on your numpad, respectively. You should immediately see a visualization
    of the security camera sight sense, as depicted in *Figure 10* *.7* :'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当模拟进行时，选择一个安全摄像头，并通过按下数字键盘上的 *4* 和 *5* 键分别启用 **感知** 和 **感知系统** 工具。你应该立即看到安全摄像头视感的可视化，如图
    *图 10.7* 所示：
- en: '![Figure 10.7 – Perception debugging tools](img/Figure_10.7_B31016.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – 感知调试工具](img/Figure_10.7_B31016.jpg)'
- en: Figure 10.7 – Perception debugging tools
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 感知调试工具
- en: 'The display will show some important information on the AI agent perception,
    such as the active sense and its data. Additionally, you will also see a visual
    representation of the agent sense. In particular, the sight sense will show the
    following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 显示将显示有关 AI 代理感知的一些重要信息，例如活动感官及其数据。此外，你还将看到代理感官的视觉表示。特别是，视感将显示以下内容：
- en: A green circular area that represents the range of the agent sight.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个代表代理视距范围的绿色圆形区域。
- en: A pink circular area that represents the maximum range of the agent sight. Once
    the spotted agent goes beyond this range, sight contact will be lost.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个代表代理视距最大范围的粉红色圆形区域。一旦被发现的代理超出这个范围，视线接触将丢失。
- en: A green angle that represents the peripheral vision of the agent.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个代表代理周围视野的绿色角度。
- en: 'Once an AI agent enters the green circle, it will be detected by the Perception
    System, and you should see a green line, starting from the security camera and
    ending at the detected pawn, as depicted in *Figure 10* *.8* :'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 AI 代理进入绿色圆圈，它将被感知系统检测到，你应该看到一条从安全摄像头开始到检测到的棋子结束的绿色线，如图 *图 10.8* 所示：
- en: '![Figure 10.8 – A pawn detected](img/Figure_10.8_B31016.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.8 – 检测到的棋子](img/Figure_10.8_B31016.jpg)'
- en: Figure 10.8 – A pawn detected
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – 检测到的棋子
- en: A green wireframe sphere will show the detection point, which will be updated
    as the detected AI agent moves around.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一个绿色的线框球体将显示检测点，当检测到的 AI 代理移动时，该点将更新。
- en: 'Once an AI agent moves out of sight, the detection point will stop following
    it, and you should see the **age** label next to the sphere, updating its value;
    this is the time that has passed since detection was lost. *Figure 10* *.9* shows
    this scenario:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 AI 代理离开视线，检测点将停止跟随它，你应该看到球体旁边的 **年龄** 标签，更新其值；这是自检测丢失以来经过的时间。*图 10.9* 显示了这种情况：
- en: '![Figure 10.9 – Detection lost](img/Figure_10.9_B31016.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 – 检测丢失](img/Figure_10.9_B31016.jpg)'
- en: Figure 10.9 – Detection lost
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – 检测丢失
- en: Each sense has its own way of displaying info, so my advice is to start experimenting
    with each of them to get an understanding of how to debug and get information
    from the debugging tools.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 每个感官都有其显示信息的方式，因此我的建议是开始尝试每个感官，以了解如何调试和从调试工具中获取信息。
- en: In this section, we have created a new gym and tested how the Perception System
    works; what’s more, I have shown you how to enable the debugging tools and get
    a better understanding of what’s happening in the level at runtime. In the next
    section, we are going to take a look at perception stimuli, in order to make our
    levels more articulated and engaging.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了一个新的 gym 并测试了感知系统的工作方式；更重要的是，我向您展示了如何启用调试工具并更好地理解在运行时级别中发生的事情。在下一节中，我们将探讨感知刺激，以便使我们的级别更加精致和引人入胜。
- en: Creating perception stimuli
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建感知刺激
- en: In the previous section, we utilized the out-of-the-box pawn feature that enables
    it to be visible to sight sense. We will now analyze actors that are not perceivable
    by default; this means we will need to add **AIPerceptionStimuliSourceComponent**
    to an actor. What’s more, we will learn how to register or unregister these stimuli,
    in order to make the actor visible or invisible to the Perception System.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用了开箱即用的棋子功能，使其对视感可见。现在，我们将分析默认不可感知的演员；这意味着我们需要将 **AIPerceptionStimuliSourceComponent**
    添加到演员中。更重要的是，我们将学习如何注册或注销这些刺激，以便使演员对感知系统可见或不可见。
- en: Creating the target actor
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建目标演员
- en: In this subsection, we will create a new actor that will serve as a target for
    the dummy gunner puppet, but with a twist – this actor will create some interference
    in the level and won’t be visible to the security camera. Achieving this kind
    of feature is quite easy, once you know how to register and unregister an actor
    from the Perception System. We are basically creating a scrambler device that
    will disturb – that is, it will be invisible to – the gunner sight sense.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将创建一个新的角色，该角色将作为虚拟枪手木偶的目标，但有一个转折——这个角色将在关卡中产生一些干扰，并且不会被安全摄像头看到。一旦你知道如何从感知系统中注册和注销角色，实现这种功能相当简单。我们基本上创建了一个干扰设备，它将干扰——也就是说，它将对枪手视觉感知不可见。
- en: To keep things simple, I will create a Blueprint class; when working with stimuli,
    it is often more convenient to configure settings directly from a Blueprint rather
    than using a C++ class. By utilizing a Blueprint, we can easily adjust and fine-tune
    various aspects of the stimuli, making the whole process more flexible and accessible.
    This approach allows for quicker iterations and modifications, ultimately resulting
    in a smoother and more efficient workflow.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我将创建一个蓝图类；当处理刺激时，通常更方便直接从蓝图配置设置，而不是使用C++类。通过利用蓝图，我们可以轻松调整和微调刺激的各个方面，使整个过程更加灵活和易于访问。这种方法允许更快地进行迭代和修改，最终导致更顺畅和更高效的流程。
- en: 'To create our scrambler, open the **Blueprints** folder, create a new Blueprint
    class extending from **Actor** , and name it **BP_Scrambler** . Once the blueprint
    is opened, follow these steps:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的干扰器，打开**蓝图**文件夹，创建一个从**Actor**扩展的新蓝图类，并将其命名为**BP_Scrambler**。一旦蓝图打开，按照以下步骤操作：
- en: In the **Components** panel, add a static mesh component.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**组件**面板中，添加一个静态网格组件。
- en: In the **Details** panel, set the **Static Mesh** property to **SM_RoboGun_BaseRemote**
    and the **Scale** property to **(3.0,** **3.0, 3.0)** .
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**详细信息**面板中，将**静态网格**属性设置为**SM_RoboGun_BaseRemote**，将**缩放**属性设置为**(3.0, 3.0,
    3.0)**。
- en: Add an **AIPerceptionStimuliSource** component.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**AIPerceptionStimuliSource**组件。
- en: In the **Details** panel, locate the **Register as Source for Senses** attribute,
    add a new element by clicking the **+** button, and set the value to **AISense_Sight**
    .
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**详细信息**面板中，找到**注册为感官源**属性，通过点击**+**按钮添加新元素，并将值设置为**AISense_Sight**。
- en: Leave the **Auto Register as Source** attribute unchecked
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持**自动注册为源**属性未选中
- en: '![Figure 10.10 – The stimuli source](img/Figure_10.10_B31016.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.10 – 刺激源](img/Figure_10.10_B31016.jpg)'
- en: Figure 10.10 – The stimuli source
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – 刺激源
- en: 'Now, open the Event Graph for this Blueprint and do the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开此蓝图的事件图，并执行以下操作：
- en: From the outgoing execution pin of the **Event Begin Play** node, add a **Delay**
    node.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Event Begin Play**节点的输出执行引脚，添加一个**Delay**节点。
- en: From the **Completed** pin of the **Delay** node, add a **Register for Sense**
    node; this should automatically add an **AIPerception Stimuli Source** reference
    to the **Target** incoming pin.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Delay**节点的**完成**引脚，添加一个**注册感官**节点；这将自动将**AIPerception Stimuli Source**引用添加到**目标**输入引脚。
- en: From the **Duration** pin of the **Delay** node, add a **Random Float in Range**
    node, setting its **Min** and **Max** values to **4.0** and **6.0** , respectively.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Delay**节点的**持续时间**引脚，添加一个**随机浮点数在范围内**节点，将其**最小值**和**最大值**分别设置为**4.0**和**6.0**。
- en: 'From the dropdown menu of the incoming **Sense Class** pin, select **AISense_Sight**
    . The final graph should look like the one depicted in *Figure 10* *.11* :'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**感官类**输入引脚的下拉菜单中选择**AISense_Sight**。最终的图表应该看起来像*图 10.11*中描述的那样：
- en: '![Figure 10.11 – The Event Graph](img/Figure_10.11_B31016.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.11 – 事件图](img/Figure_10.11_B31016.jpg)'
- en: Figure 10.11 – The Event Graph
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – 事件图
- en: This graph will simply register the sight sense for this actor after a random
    interval, making the actor itself visible to the Perception System in the level.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表将在随机间隔后简单地记录该角色的视觉感知，使该角色本身在关卡中的感知系统中可见。
- en: Note
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you need to unregister a stimuli source, the corresponding Blueprint node
    is **Unregister** **from Sense** .
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要注销刺激源，相应的蓝图节点是**从感官注销**。
- en: Let’s test this functionality in a brand-new gym.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个全新的健身房中测试这个功能。
- en: Testing the gym
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试健身房
- en: 'To create the testing level, follow these steps:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建测试关卡，按照以下步骤操作：
- en: Create a level of your choice, starting from the Level Instances and Packed
    Level Actors that I provided in the project template.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个你选择的关卡，从我在项目模板中提供的Level Instances和Packed Level Actors开始。
- en: Add some obstacles to make things more interesting.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些障碍物以使事情更有趣。
- en: Add **BP_GunnerDummyCharacter** to the level.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关卡中添加 **BP_GunnerDummyCharacter**。
- en: Add one **BP_Scrambler** instance so that the gunner puppet can shoot at it.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 **BP_Scrambler** 实例，以便枪手木偶可以对其射击。
- en: 'Add one **BP_SecurityCam** instance to the walls so that it is in the line
    of sight of the scrambler. The final result should be similar to *Figure 10* *.12*
    :'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在墙上添加一个 **BP_SecurityCam** 实例，使其位于混乱角力场的视线范围内。最终结果应类似于 *图 10.12*：
- en: '![Figure 10.12 – The scrambler gym](img/Figure_10.12_B31016.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.12 – 混乱角力场](img/Figure_10.12_B31016.jpg)'
- en: Figure 10.12 – The scrambler gym
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – 混乱角力场
- en: By starting the simulation, you can see that the scrambler will go unnoticed
    by the security camera until it reveals itself after a random interval. After
    that, the scrambler will be tagged as a viable target and the gunner will shoot
    at it. Try enabling the debugging tools to check what’s happening to the Perception
    System.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启动模拟，您可以看到混乱角力场在随机间隔后才会被安全摄像头发现，在此之前它将不被注意。之后，混乱角力场将被标记为可行的目标，枪手将对其射击。尝试启用调试工具以检查感知系统发生了什么。
- en: In this final section, I have presented how to make any actor detectable by
    the Perception System. By following the steps and guidelines provided, you can
    seamlessly integrate the Perception System into your project, allowing your actors
    to be accurately recognized and interacted with within the virtual environment.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后部分，我介绍了如何使任何演员可被感知系统检测到。通过遵循提供的步骤和指南，您可以无缝地将感知系统集成到您的项目中，使您的演员能够在虚拟环境中被准确识别和交互。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the basics of the Unreal Engine Perception System.
    Firstly, we showed the main elements that will let you add senses to your AI agents;
    after that, you built a pawn with a sight sense that detects moving characters
    around the level. Then, you learned how to debug the active senses at runtime.
    Finally, you added a stimuli source to an actor, in order to make it detectable
    by the Perception System itself. All of this opens up a world of possibilities
    for creating immersive and dynamic experiences, using the power of the Unreal
    Engine AI Framework.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了 Unreal Engine 感知系统的基本知识。首先，我们展示了您可以为您的 AI 代理添加感官的主要元素；之后，您构建了一个具有视觉感官的
    pawn，它可以检测到关卡周围的移动角色。然后，您学习了如何在运行时调试活跃的感官。最后，您向一个演员添加了一个刺激源，以便使其可被感知系统本身检测到。所有这些都为使用
    Unreal Engine AI 框架创建沉浸式和动态体验打开了无限可能。
- en: In the upcoming chapter, I’ll unveil a new method to gather data from the environment;
    brace yourself, as this cutting-edge feature is still in the experimental stage.
    But fear not, my friend, for it is knowledge well worth acquiring!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将揭示一种从环境中收集数据的新方法；准备好吧，因为这个前沿特性仍处于实验阶段。但不用担心，我的朋友，因为这是一种值得获取的知识！
